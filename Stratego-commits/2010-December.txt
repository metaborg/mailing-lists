From m.dejonge at tudelft.nl  Wed Dec  1 16:20:21 2010
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Wed, 01 Dec 2010 15:20:21 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21436 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr
Message-ID: <201012011520.oB1FKLMt024291@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: Wed Dec  1 15:20:20 2010
New Revision: 21436
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21436&sc=1

Log:
clean up code

Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/RecoveryConnector.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/RecoveryConnector.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/RecoveryConnector.java	Mon Nov 29 20:25:09 2010	(r21435)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/RecoveryConnector.java	Wed Dec  1 15:20:20 2010	(r21436)
@@ -1,8 +1,6 @@
 package org.spoofax.jsglr;
 
 import java.io.IOException;
-import java.util.HashMap;
-import java.util.Map;
 
 import org.spoofax.ArrayDeque;
 
@@ -11,9 +9,7 @@
     private SGLR mySGLR;
     private IRecoveryParser recoveryParser;
     private RegionRecovery skipRecovery;
-    private boolean active;
     private boolean useBridgeParser;
-    private IRecoveryResult bpResult;
     private boolean useFineGrained;
     
     
@@ -22,10 +18,9 @@
     }
 
     public RecoveryConnector(SGLR parser, IRecoveryParser recoveryParser){
-        useFineGrained=true;
-        active=false;
         mySGLR=parser;        
         skipRecovery = new RegionRecovery(mySGLR); 
+        useFineGrained=true;
         if(recoveryParser!=null){
             this.recoveryParser = recoveryParser;
             useBridgeParser=true;
@@ -35,198 +30,76 @@
         
     }    
     
-    
-    private Map<Integer, char[]> getBPSuggestions(){
-        Map<Integer, char[]> bpSuggestions = getBridges();
-        int startPos = skipRecovery.getStartPositionErrorFragment_InclLeftMargin();
-        
-        Map<Integer, char[]> bpSuggestAbsolute = new HashMap<Integer, char[]>();
-        for (Integer aKey : bpSuggestions.keySet()) {
-            Integer newKey=new Integer(startPos+aKey.intValue());
-            char[] newValue=bpSuggestions.get(aKey);
-            bpSuggestAbsolute.put(newKey, newValue);
-        }
-        return bpSuggestAbsolute;
-    }
-
-    private Map<Integer, char[]> getBridges() {
-        if (bpResult != null) {
-            return bpResult.getSuggestions();
-        }
-        return new HashMap<Integer, char[]>();
-    }
-    
-    
-    
     private ParserHistory getHistory() {
         return mySGLR.getHistory();
     }
-    
-    public void recover() throws IOException{
-        long startSkip=System.currentTimeMillis();
-        //System.err.print("***************** Recover");
-        doRecoverSteps();
-        long durationSkip=System.currentTimeMillis()-startSkip;
-        //System.err.print(" Recovertime: "+durationSkip);
-    }
 
-    private void doRecoverSteps() throws IOException {
-        active=true;
+    public void recover() throws IOException {
         boolean skipSucceeded = skipRecovery.selectErroneousFragment(); //decides whether whitespace parse makes sense
         mySGLR.acceptingStack=null;
-        long startSkip=System.currentTimeMillis();
-        String errorFragment = skipRecovery.getErrorFragmentWithLeftMargin();
-        long durationSkip=System.currentTimeMillis()-startSkip;
-        Tools.debug("Skip time: "+ durationSkip);
-        //System.err.print("Skip time: "+ durationSkip+ "  ");
-        Tools.debug(errorFragment);
-        //System.err.print(errorFragment);
         mySGLR.activeStacks.clear();
         //BRIDGE REPAIR
-        if(useBridgeParser){            
+        if(useBridgeParser){       
+            String errorFragment = skipRecovery.getErrorFragmentWithLeftMargin();
             boolean succeeded = tryBridgeRepair(errorFragment);
             if(succeeded){
-                Tools.debug("Bridge Repair Succeeded");
-                //System.err.print("************** BP-Succeeded");
                 return;
             }
-            Tools.debug("Bridge Repair Failed");
         }
-        //System.out.println("USE FG? "+useFineGrained);
         //FINEGRAINED REPAIR 
         if(useFineGrained){            
-            long startFineGrained=System.currentTimeMillis();        
-            tryFineGrainedRepair();       
-            long durationFG=System.currentTimeMillis()-startFineGrained;
-            Tools.debug("Fine-Grained time: "+ durationFG);
-        }
-        //System.out.println("HISTORY AFTER FINE-GRAINED");
-        //getHistory().logHistory();
-        //System.err.print("Fine-Grained time: "+ durationFG);
-        //Tools.debug("Disambiguations: " +  RecoverDisambiguator.testCount);
-        if(recoverySucceeded()){
-            Tools.debug("Fine-Grained Repair Succeeded");
-            //System.err.print("**************** FG-succeeded");
-            ArrayDeque<Frame> fgStacks=new ArrayDeque<Frame>();
-            fgStacks.addAll(mySGLR.activeStacks);
-            if (skipSucceeded) { 
-                
-                boolean whiteSpaceRecovery=parseErrorFragmentAsWhiteSpace(false);
-                if(whiteSpaceRecovery)
-                    whiteSpaceRecovery=parseRemainingTokens(false);
-                if(whiteSpaceRecovery){
-                    for (Frame frame : mySGLR.activeStacks) {
-                        for (Link l : frame.getAllLinks()) {
-                            l.recoverCount = 5;
-                        }
-                    }                    
-                }
-               // ArrayDeque<Frame> wsStacks=mySGLR.activeStacks;
-                
-                //mySGLR.activeStacks.clear();
-                //whiteSpaceParse();
-                //whiteSpaceParse(errorFragment); 
-                for (Frame frame : fgStacks) {
-                    mySGLR.addStack(frame);
-                } 
-                /*
-                for (Frame frame : wsStacks) {
-                    mySGLR.addStack(frame);
-                } */  
+            if(tryFineGrainedRepair()){ //FG succeeded  
+                addSkipOption(skipSucceeded);
+                return;
             }
-            //System.out.println("HISTORY AFTER FG + COLLECTING WS-STACKS");
-            //getHistory().logHistory();
-            return;
         }
-        Tools.debug("FineGrained Repair Failed");
         //WHITESPACE REPAIR
         if (skipSucceeded) { 
             getHistory().deleteLinesFrom(skipRecovery.getStartIndexErrorFragment());//TODO: integrate with FG and BP
             getHistory().resetRecoveryIndentHandler(skipRecovery.getStartLineErrorFragment().getIndentValue());
-            boolean whiteSpaceRecovery=parseErrorFragmentAsWhiteSpace(false);//true
-            //System.err.println("MMM");
-            //getHistory().logHistory();
-            if(whiteSpaceRecovery){
-                parseRemainingTokens(true);
-                //System.err.println("MMM");
-                //getHistory().logHistory();
-            }
-            //whiteSpaceParse();
-            //whiteSpaceParse(errorFragment); 
-            if(recoverySucceeded()){
-                Tools.debug("WhiteSpace Repair Succeeded");
-                //System.err.print("************* WS-succeeded");
-            }
-            else{
-                Tools.debug("WhiteSpace Repair unexpectly fails");
-                recover();
-                //System.err.print("*************** WS-Fails unexpected");
-            }/*
-            if(!parseRemainingTokens())
-                recover();*/
+            parseErrorFragmentAsWhiteSpace(false);
+            parseRemainingTokens(true);
         }
-        //FORCE PREFIX ACCEPT
-        /*else {            
-            EofRecovery eofR = new EofRecovery(mySGLR);
-            eofR.enforceAccept(getHistory().getBigReducePoint().getStackNodes());
-            if(recoverySucceeded()){
-                Tools.debug("Enforcing Accepting Stack - Succeeded");
-                //System.err.print("******************* AS-succeeded");
-            }
-            else{
-                Tools.debug("Enforcing Accepting Stack - Failed"); 
-              //System.err.print("******************* AS-Failed");
-            }
-        }*/
-        active = false;
     }
-    
-    private boolean recoverySucceeded() {
-        boolean hasSucceeded = (mySGLR.activeStacks.size()>0 || mySGLR.acceptingStack!=null);
-        /*
-        if(hasSucceeded){           
-            ArrayList<IndentInfo> recoverNewLinePoints = new ArrayList<IndentInfo>();            
-            IndentInfo currentStatus = new IndentInfo(mySGLR.lineNumber, getHistory().getTokenIndex(), mySGLR.getIndentHandler().getIndentValue());
-            recoverNewLinePoints.add(currentStatus);
-            getHistory().addRecoverLines(recoverNewLinePoints);
+
+    private void addSkipOption(boolean skipSucceeded)
+            throws IOException {
+        ArrayDeque<Frame> fgStacks=new ArrayDeque<Frame>();
+        fgStacks.addAll(mySGLR.activeStacks);
+        if(skipSucceeded && parseErrorFragmentAsWhiteSpace(false) && parseRemainingTokens(false)){
+            for (Frame frame : mySGLR.activeStacks) {
+                for (Link l : frame.getAllLinks()) {
+                    l.recoverCount = 5;
+                }
+            }                        
+            for (Frame frame : fgStacks) {
+                mySGLR.addStack(frame);
+            } 
         }
-        */
-        return hasSucceeded;
     }
-
-    private void whiteSpaceParse() throws IOException {
-        String errorFragment=skipRecovery.getErrorFragment();
-        mySGLR.activeStacks.addAll(skipRecovery.getStartLineErrorFragment().getStackNodes());            
-        tryParsing(errorFragment, true);
-        parseRemainingTokens(true);
+    
+    private boolean recoverySucceeded() {
+        return (mySGLR.activeStacks.size()>0 || mySGLR.acceptingStack!=null);
     }
 
-    private void tryFineGrainedRepair() throws IOException {
+    private boolean tryFineGrainedRepair() throws IOException {
         FineGrainedOnRegion fgRepair=new FineGrainedOnRegion(mySGLR);        
         fgRepair.setRegionInfo(skipRecovery.getErroneousRegion(), skipRecovery.getAcceptPosition());
         fgRepair.recover();
         fgRepair.parseRemainingTokens();
-        /*if(!fgRepair.parseRemainingTokens())
-            recover();*/
+        return recoverySucceeded();
     }
-    /*
-    private void tryFineGrainedRepair() throws IOException {
-        FineGrainedRepair fineGrained=new FineGrainedRepair(mySGLR);   
-        fineGrained.setBpSuggestions(getBPSuggestions());
-        fineGrained.findRecoverBranch(skipRecovery.getSkippedLines(), skipRecovery.getEndPositionErrorFragment());        
-    }*/
 
     private boolean tryBridgeRepair(String errorFragment) throws IOException {
         String repairedFragment = repairBridges(errorFragment);
         mySGLR.activeStacks.addAll(skipRecovery.getStartLineErrorFragment().getStackNodes());   
         tryParsing(repairedFragment, false);      
-        parseRemainingTokens(true);
-        return recoverySucceeded();
+        return parseRemainingTokens(true);
     }
 
-    private String repairBridges(String errorFragment) {
+    private String repairBridges(String errorFragment) {        
         try {            
-            bpResult = null;
+            IRecoveryResult bpResult = null;
             bpResult = recoveryParser.recover(errorFragment);
             return bpResult.getResult();
         } catch (TokenExpectedException e) {
@@ -245,14 +118,10 @@
     
     private void tryParsing(String fragment, boolean asLayout) throws IOException{
         // Skip any leading whitespace, since we already parsed up to that point
-        int indexFragment = findFirstNonLayoutToken(fragment);      
-        //System.out.println("&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&");
+        int indexFragment = findFirstNonLayoutToken(fragment);
         while(indexFragment<fragment.length() && mySGLR.activeStacks.size()>0) {                        
             mySGLR.currentToken=fragment.charAt(indexFragment);
-            //System.out.print((char)mySGLR.currentToken);
-            //Tools.debug((char)mySGLR.currentToken);
             indexFragment++;
-            
             if(!asLayout)
                 mySGLR.doParseStep();
             else
@@ -282,7 +151,7 @@
             //System.out.print((char)mySGLR.currentToken);
             mySGLR.doParseStep();            
         }  
-        return mySGLR.activeStacks.size()>0 || mySGLR.acceptingStack!=null;
+        return recoverySucceeded();
     }
 
     
@@ -308,12 +177,31 @@
         return indexFragment;
     }
 
-    public boolean isActive() {        
-        return active;
-    }
-
     public void setUseFineGrained(boolean useFG) {
         useFineGrained=useFG;        
     }
+    
+    /*
+    private Map<Integer, char[]> getBPSuggestions(){
+        Map<Integer, char[]> bpSuggestions = getBridges();
+        int startPos = skipRecovery.getStartPositionErrorFragment_InclLeftMargin();
+        
+        Map<Integer, char[]> bpSuggestAbsolute = new HashMap<Integer, char[]>();
+        for (Integer aKey : bpSuggestions.keySet()) {
+            Integer newKey=new Integer(startPos+aKey.intValue());
+            char[] newValue=bpSuggestions.get(aKey);
+            bpSuggestAbsolute.put(newKey, newValue);
+        }
+        return bpSuggestAbsolute;
+    }
+
+    private Map<Integer, char[]> getBridges() {
+        IRecoveryResult bpResult;
+        if (bpResult != null) {
+            return bpResult.getSuggestions();
+        }
+        return new HashMap<Integer, char[]>();
+    }
+    */
 
 }

From m.dejonge at tudelft.nl  Wed Dec  1 18:31:10 2010
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Wed, 01 Dec 2010 17:31:10 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21437 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr
Message-ID: <201012011731.oB1HVAcF026132@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: Wed Dec  1 17:31:09 2010
New Revision: 21437
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21437&sc=1

Log:
History is initialized for each parse

Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/SGLR.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/SGLR.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/SGLR.java	Wed Dec  1 15:20:20 2010	(r21436)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/SGLR.java	Wed Dec  1 17:31:09 2010	(r21437)
@@ -159,6 +159,12 @@
         recoverIntegrator = new RecoveryConnector(this, parser);
     }
     
+    public void setCombinedRecovery(boolean useBP, boolean useFG, boolean useOnlyFG){
+        recoverIntegrator.setOnlyFineGrained(useOnlyFG);
+        recoverIntegrator.setUseBridgeParser(useBP);
+        recoverIntegrator.setUseFineGrained(useFG);
+    }
+    
     /**
      * Structure-based recovery without bridge parsing.
      * 
@@ -359,6 +365,7 @@
         acceptingStack = null; 
         //history.keepInitialState(this);
         collectedErrors.clear();
+        history=new ParserHistory();
     }    
 
      private BadTokenException createBadTokenException() {
@@ -400,7 +407,7 @@
         logBeforeShifter();
         clearActiveStacks(false);
 
-        IParseNode prod = parseTable.lookupProduction(currentToken);
+        IParseNode prod = parseTable.lookupProduction(currentToken); 
 
         while (forShifter.size() > 0) {
             ActionState as = forShifter.remove();

From r.t.lindeman at student.tudelft.nl  Wed Dec  1 23:27:24 2010
From: r.t.lindeman at student.tudelft.nl (Ricky Lindeman)
Date: Wed, 01 Dec 2010 22:27:24 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21438 -
	spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans
Message-ID: <201012012227.oB1MROns029938@proliant.st.ewi.tudelft.nl>

Author: RickyLindeman
Date: Wed Dec  1 22:27:24 2010
New Revision: 21438
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21438&sc=1

Log:
* Add support for debug compiling a stratego program with imports
 * Refactored tests to transformer-test-suite, TODO: make a nice test-suite

Added:
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/transformer-test-suite.str
Modified:
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/gen-lookup.str
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/str-reader.str
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/stratego-transformer.str
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/trans-str.str
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/traverse-imports.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/gen-lookup.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/gen-lookup.str	Wed Dec  1 17:31:09 2010	(r21437)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/gen-lookup.str	Wed Dec  1 22:27:24 2010	(r21438)
@@ -4,14 +4,21 @@
 	include/Test
 	str-reader
 	assert
+	trans-str
 	  
-// parse the given stratego file and create a lookup file containing all debug-call and their linenumbers
+// parse the given stratego file and create a lookup file containing all debug-calls and their linenumbers
 rules
-	create-table: inputfilename -> contents
+	// table-filename is the location of the output table
+	// current term should be a list of inputfilenames each pointing to a stratego file
+	// output is the location of the table
+	create-table(|table-filename): inputfilenames* -> table-filename
 	where(debug(!"create-table"))
 	where(
-//	  	absPath := 	<concat-strings> [sourceBasedir, "/", inputfilePath]
-//  	; get-anno-ast(|absPath)
+		table-file-handle := <get-file-handle(|table-filename)>
+		; <map(create-table-for-input(|table-file-handle))> inputfilenames* // writes the table contents of each inputfilename to table-file-handle
+		; close-file-handle(|table-file-handle)
+	)
+	/*
 	get-anno-ast(|inputfilename)
   	; assert-module
   	; collect-debug-calls
@@ -19,8 +26,22 @@
   	; contents := $[[lines*]]
   	; filename := <guarantee-extension(|"table")> inputfilename
   	; write-to-file(|filename, contents)
-  	  )
+  	  )*/
   	  
+  	// parse the inputfile, create table entries and add them to the table-file-handle
+  	create-table-for-input(|table-file-handle) :
+  		inputfilename -> contents
+  		where
+			get-anno-ast(|inputfilename)
+		  	; assert-module // check if it properly parsed!
+		  	; collect-debug-calls
+		  	; lines* :=  <create-table-entries>
+		  	; contents := $[[lines*]]
+		  	; write-contents-to-handle(|table-file-handle, contents) // also flushes
+		  	    
+		  	//; filename := <guarantee-extension(|"table")> inputfilename
+		  	//; write-to-file(|filename, contents)
+  	    			
 // strategy to collect all strago debug calls
 	collect-debug-calls =
     	collect-all(is-debug-call)
@@ -55,5 +76,30 @@
     convert-to-line :
   (debug-event, filename, name, a, b, c, d) -> 
     $[[debug-event]	[filename]	[name]	[a]	[b]	[c]	[d]
-     ]
-	test-create-table = <create-table> "/home/rlindeman/workspace/strj-dbg-test/working/localvar/stratego/localvar.str"
\ No newline at end of file
+     ]// should be real tabs between the variables
+
+strategies
+	
+	test-create-table-1 =
+		echo(|"test-create-table-1")
+  		; get-project-dir => project-dir
+  		; !"test/generated/localvar/stratego" => stratego-files-base-dir
+  		; !"localvar.str" => main-stratego-file
+  		; <concat-strings> [project-dir, "/", stratego-files-base-dir, "/", main-stratego-file]	=> file1
+  		; stratego-files := [file1] // all files should be stratego files with debug information
+  		; table-filename := <concat-strings> [project-dir, "/", stratego-files-base-dir, "/", main-stratego-file, ".table"]
+  		; <create-table(|table-filename)> stratego-files
+  		       
+	test-create-table-2 = 
+		echo(|"test-create-table-2")
+  		; get-project-dir => project-dir
+  		; !"test/generated/testimports" => stratego-files-base-dir
+  		; !"localvar.str" => rel-f1
+  		; !"localmod/syntax/varsyntax.str" => rel-f2
+  		; !"localmod/util/utils.str" => rel-f3
+		; <concat-strings> [project-dir, "/", stratego-files-base-dir, "/", rel-f1]	=> file1
+		; <concat-strings> [project-dir, "/", stratego-files-base-dir, "/", rel-f2]	=> file2
+		; <concat-strings> [project-dir, "/", stratego-files-base-dir, "/", rel-f3]	=> file3
+		; stratego-files := [file1, file2, file3] // all files should be stratego files with debug information
+		; table-filename := <concat-strings> [project-dir, "/", stratego-files-base-dir, "/", rel-f1, ".table"]
+		; <create-table(|table-filename)> stratego-files
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/str-reader.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/str-reader.str	Wed Dec  1 17:31:09 2010	(r21437)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/str-reader.str	Wed Dec  1 22:27:24 2010	(r21438)
@@ -29,10 +29,14 @@
 	
 	// current term is string
 	// writes the string to the absolute-location
-  write-stratego(|absolute-location)	:
+  write-stratego(|absolute-location) :
    source-code -> absolute-location
+   //where <debug(!"write-stratego to ")> absolute-location
    where
-   	write-to-file(|absolute-location, source-code)
+   	<dirname> absolute-location => dir
+   	//; debug(!"dirname: ")
+   	; check-dir // check if dir exists, if not create the complete path otherwise write-to-file will fail 
+   	; write-to-file(|absolute-location, source-code)
   
   strategies
 
@@ -56,13 +60,49 @@
   	; check-dir
   	; write-to-file(|absolutepath, content)
 	
+	// assume the directory exists
+	// current term is ignored
+	write-to-file(|filename, contents) = 
+		handle := <fopen> (filename, "w")
+		; <fputs> (contents, handle)
+		; fclose
+
+
+	// assume directory exists
+	// current term is ignored
+	// returns the result of <fopen> (Stream)
+	// howto write to the file:
+	// <fputs> (contents, handle)
+	get-file-handle(|filename) =
+		handle := <fopen> (filename, "w")
+		
+	// writes contents to the file-handle and flush
+	// returns the Stream
+	write-contents-to-handle(|file-handle, contents) = 	<fputs> (contents, file-handle); fflush
 	
-	write-to-file(|filename, contents) = handle := <fopen> (filename, "w"); <fputs> (contents, handle); fclose
-	
-	check-dir =
-		//debug(!"check-dir")
-		(file-exists ; filemode ; isdir) <+ (debug(!"create dir: "); mkdir)
+	// closes the file-handle Stream
+	close-file-handle(|file-handle) = <fclose> file-handle
 		
+	// check if the current term is a directory and it exists
+	// if not, create the full path
+	check-dir =
+		?directory
+		//; debug(!"check-dir: ")
+		; parent-dir := <dirname> directory
+		; !directory
+		; (file-exists ; filemode ; isdir) // if isdir fails, mkdir
+		  <+ (create-dir)
+	
+	// current term should be a directory path
+	// creates the full directory path	  
+	create-dir =
+		?directory
+		//; debug(!"create dir: ")
+		; parent-dir := <dirname> directory
+		; <check-dir> parent-dir
+		// check if the parent dir exists
+		; try(!directory; mkdir//; debug(!"mkdir succes")
+		  )
 	
   // current term should be a Stratego ast
   // converts ast to a stratego program

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/stratego-transformer.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/stratego-transformer.str	Wed Dec  1 17:31:09 2010	(r21437)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/stratego-transformer.str	Wed Dec  1 22:27:24 2010	(r21438)
@@ -21,4 +21,27 @@
 
       
 strategies
-	main = io-wrap(id)
\ No newline at end of file
+	main = io-wrap(create-options, create-usage, default-system-about, execute)
+	
+	execute = id
+	
+	create-options =
+ 		Option("--option1"
+ 			, <set-config> ("--option1", ())
+ 			, !"--option1        This is a an example option"
+		)
+		+ ArgOption("--arg1"
+			, <set-config> ("--arg1", <id>)
+ 			, !"--arg1           This is an example arg option"
+		)
+  
+ create-usage =
+ default-system-usage(
+ 	!"Usage: option-demo [options]"
+  , !
+"   This is a test program to demonstrate use of
+    parse-options and  generation of usage info
+    from option and switch specificatios. These
+    now contain usage info as additional third 
+    argument."
+     )
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/trans-str.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/trans-str.str	Wed Dec  1 17:31:09 2010	(r21437)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/trans-str.str	Wed Dec  1 22:27:24 2010	(r21438)
@@ -7,6 +7,7 @@
   assert
   gen-lookup
   traverse-imports // show all files used as import
+  transformer-test-suite // test-suite
   	
 rules
 // transform stratego to stratego but add debug statements
@@ -44,141 +45,7 @@
 	//get-project-dir = !"/home/rlindeman/workspace/strj-dbg-transformer"	
 	get-project-dir = !"/home/rlindeman/Documents/TU/webdsl/spoofax-imp/source/org.strategoxt.imp.debug.stratego.transformer"
 
-  // show ast with complete location annotation
-  foo1 = 
-  	echo(|"Start foo1")
-  	; get-project-dir => project-dir
-  	; !"test/src" => input-base-dir
-  	; !"test/generated" => output-base-dir
-  	; !"example.tes" => sma-file
-  	; <concat-strings> [project-dir, "/", input-base-dir, "/", sma-file] => absolute-location
-  	; echo(|"reading ast from: ")
-  	; echo(|absolute-location)
-  	; get-anno-ast(|absolute-location)
-  	; assert-module
-  	// ; debug
-  	; echo(|"End foo1")
-	
-	  // show ast with complete location annotation
-  bar1 = 
-  	echo(|"Start bar1")
-  	; get-project-dir => project-dir
-  	; !"test/src" => input-base-dir
-  	; !"test/generated" => output-base-dir
-  	; !"localvar.tes" => sma-file
-  	; <concat-strings> [project-dir, "/", input-base-dir, "/", sma-file] => absolute-location
-  	; echo(|"reading ast from: ")
-  	; echo(|absolute-location)
-  	; get-anno-ast(|absolute-location)
-  	; assert-module
-  	// ; debug
-  	; echo(|"End bar1")
-  	  
-  // filter unnecessary Location-annotations	
-  foo2 = 
-  	echo(|"Start foo2")
-  	; get-project-dir => project-dir
-  	; !"test/src" => input-base-dir
-  	; !"test/generated" => output-base-dir
-  	; !"example.tes" => sma-file
-  	; <concat-strings> [project-dir, "/", input-base-dir, "/", sma-file] => absolute-location
-  	; echo(|"reading ast from: ")
-  	; echo(|absolute-location)
-  	; get-anno-ast(|absolute-location)
-  	; assert-module
-  	; filter-location
-  	// ; debug
-  	; echo(|"End foo2")
-  
-  // add strategy entry and strategy exit calls 
-  foo3 = 
-  	echo(|"Start foo3")
-  	; get-project-dir => project-dir
-  	; !"test/src" => input-base-dir
-  	; !"test/generated" => output-base-dir
-  	; !"example.tes" => sma-file
-  	; <concat-strings> [project-dir, "/", input-base-dir, "/", sma-file] => absolute-location
-  	; echo(|"reading ast from: ")
-  	; echo(|absolute-location)
-  	; get-anno-ast(|absolute-location)
-  	; assert-module
-  	; filter-location
-  	; add-debug-info(|absolute-location)
-  	// ; debug
-  	; echo(|"End foo3")
-  	  
-  // add strategy entry and strategy exit calls 
-  bar3 = 
-  	echo(|"Start bar3")
-  	; get-project-dir => project-dir
-  	; !"test/src" => input-base-dir
-  	; !"test/generated" => output-base-dir
-  	; !"localvar.tes" => sma-file
-  	; <concat-strings> [project-dir, "/", input-base-dir, "/", sma-file] => absolute-location
-  	; echo(|"reading ast from: ")
-  	; echo(|absolute-location)
-  	; get-anno-ast(|absolute-location)
-  	; assert-module
-  	; filter-location
-  	; add-debug-info(|absolute-location)
-  	// ; debug
-  	; echo(|"End bar3")
-  	  
-  // pretty print stratego program with debug info
-  foo4 = 
-  	echo(|"Start foo4")
-  	; get-project-dir => project-dir
-  	; !"test/src" => input-base-dir
-  	; !"test/generated" => output-base-dir
-  	; !"example.tes" => sma-file
-  	; <concat-strings> [project-dir, "/", input-base-dir, "/", sma-file] => absolute-location
-  	; echo(|"reading ast from: ")
-  	; echo(|absolute-location)
-  	; get-anno-ast(|absolute-location)
-  	; assert-module
-  	; filter-location
-  	; add-debug-info(|absolute-location)
-  	; pp-stratego-ast
-  	// ; debug
-  	; echo(|"End foo4")
-  	  
-  	    // pretty print stratego program with debug info
-  bar4 = 
-  	echo(|"Start bar4")
-  	; get-project-dir => project-dir
-  	; !"test/src" => input-base-dir
-  	; !"test/generated" => output-base-dir
-  	; !"localvar.tes" => sma-file
-  	; <concat-strings> [project-dir, "/", input-base-dir, "/", sma-file] => absolute-location
-  	; echo(|"reading ast from: ")
-  	; echo(|absolute-location)
-  	; get-anno-ast(|absolute-location)
-  	; assert-module
-  	; filter-location
-  	; add-debug-info(|absolute-location)
-  	; pp-stratego-ast
-  	// ; debug
-  	; echo(|"End bar4")
-  	  
-  // read str file with annotations, add debug statements, write the file	  
-  foo5 = 
-  	echo(|"Start foo5")
-  	; get-project-dir => project-dir
-  	; !"test/src" => input-base-dir
-  	; !"test/generated" => output-base-dir
-  	; !"example.tes" => sma-file
-  	; <concat-strings> [project-dir, "/", input-base-dir, "/", sma-file] => absolute-location
-  	; <concat-strings> [project-dir, "/", output-base-dir, "/", <guarantee-extension(|"str")> sma-file] => absolute-output-location
-  	; echo(|"reading ast from: ")
-  	; echo(|absolute-location)
-  	; get-anno-ast(|absolute-location)
-  	; assert-module
-  	; filter-location
-  	; add-debug-info(|absolute-location)
-  	; pp-stratego-ast
-  	; write-stratego(|absolute-output-location)
-  	// ; debug
-  	; echo(|"End foo5")
+
   	  
   	
 rules  	  
@@ -203,10 +70,12 @@
   	; add-debug-info(|inputfilePath)
   	//; debug(!"add-debug-info(|inputfilePath)")
   	; pp-stratego-ast
-  	//; debug(!"pp-stratego-ast")
+  	; debug(!"pp-stratego-ast")
   	; write-stratego(|outputfilename)
+  	; debug(!"write-stratego")
   	; status := "SUCCES"  		
   	)
+  	; <debug(!"exit-apply")> ""
   
   apply-debug-trans-debug :
   	input -> output
@@ -222,83 +91,3 @@
   		; status := "FAIL"
   	)
   	
-  a-d-t : arguments -> output
-  where(
-  	apply-debug-trans < debug(!"first") + debug(!"second")
-  	; output := "out"
-  )
-  		
-  	
-  test-apply-debug-1 = !("asdf", "ddfg"); apply-debug-trans
-  test-apply-debug-2 = !("asdf", "ddfg", "asfd"); apply-debug-trans
-  test-apply-debug-3 = !"asdf"; apply-debug-trans
-  
-  test-list-imports-1 = 
-  	echo(|"test-list-imports-1")
-  	; get-project-dir => project-dir
-  	; !"test/src" => input-base-dir
-  	; !"testimports/localvar.str" => main-str-file
-  	; <concat-strings> [project-dir, "/", input-base-dir, "/", main-str-file] => absolute-location
-  	; echo(|"reading ast from: ")
-  	; echo(|absolute-location)
-  	//; !["-i",  absolute-location, "-I", "."]
-  	; args := ["-i", absolute-location]
-  	; <list-imports(|args)> absolute-location
-  	; ?(files, _)
-  	; <debug(!"files: ")> files
-  	  
-  test-list-imports-2 = 
-  	echo(|"test-list-imports-2")
-  	; get-project-dir => project-dir
-  	; !"test/src" => input-base-dir
-  	; !"testogetarts/ogetarts.str" => main-str-file
-  	; <concat-strings> [project-dir, "/", input-base-dir, "/", main-str-file] => absolute-location
-  	; echo(|"reading ast from: ")
-  	; echo(|absolute-location)
-  	//; !["-i",  absolute-location, "-I", "."]
-  	; args := ["-i", absolute-location]
-  	; <list-imports(|args)> absolute-location
-  	; ?(files, _)
-  	; <debug(!"files: ")> files
-  	  
-  test-list-imports-3 = 
-  	echo(|"test-list-imports-3")
-  	; get-project-dir => project-dir
-  	; !"trans" => input-base-dir
-  	; !"stratego-transformer.str" => main-str-file
-  	; <concat-strings> [project-dir, "/", input-base-dir, "/", main-str-file] => absolute-location
-  	; echo(|"reading ast from: ")
-  	; echo(|absolute-location)
-  	//; !["-i",  absolute-location, "-I", "."]
-  	; include-dir := <concat-strings> [project-dir, "/", "include"]
-  	; lib-dir := <concat-strings> [project-dir, "/", "lib"] 
-  	; syntax-dir := <concat-strings> [project-dir, "/", "syntax"]
-  	; args := [/*"pack-stratego-io", */"--slack", "--imports", "-i", absolute-location, "-I", include-dir, "-I", lib-dir, "-I", syntax-dir, "-I", project-dir]
-  	; debug(!"arguments: ")
-  	; incl := [include-dir, lib-dir, syntax-dir, project-dir]
-  	; <set-config> ("-I", incl)  
-  	; <set-config> ("-i", absolute-location)
-  	; <list-imports(|args)> absolute-location
-  	; ?(files, _)
-  	; <debug(!"files: ")> files
-
-/*
-  test-list-imports-4 = 
-  	echo(|"test-list-imports-3")
-  	; get-project-dir => project-dir
-  	; !"trans" => input-base-dir
-  	; !"stratego-transformer.str" => main-str-file
-  	; <concat-strings> [project-dir, "/", input-base-dir, "/", main-str-file] => absolute-location
-  	; echo(|"reading ast from: ")
-  	; echo(|absolute-location)
-  	//; !["-i",  absolute-location, "-I", "."]
-  	; include-dir := <concat-strings> [project-dir, "/", "include"]
-  	; lib-dir := <concat-strings> [project-dir, "/", "lib"] 
-  	; syntax-dir := <concat-strings> [project-dir, "/", "syntax"]
-  	; args := ["pack-stratego-io", "--slack", "--imports", "-i", absolute-location, "-I", include-dir, "-I", lib-dir, "-I", syntax-dir, "-I", project-dir]
-  	; debug(!"arguments: ")
-  	; pack-stratego-io // when -o is missing it prints to stdout
-  	; ?(files, _)
-  	; <debug(!"files: ")> files
-*/
-  	
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/transformer-test-suite.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/transformer-test-suite.str	Wed Dec  1 22:27:24 2010	(r21438)
@@ -0,0 +1,340 @@
+module transformer-test-suite
+
+imports
+  str-reader
+  libstratego-lib
+  gen-debug-info
+  assert
+  gen-lookup
+  traverse-imports // show all files used as import
+  trans-str
+
+strategies // test the apply-debug-trans internal steps
+	
+
+  // show ast with complete location annotation
+  foo1 = 
+  	echo(|"Start foo1")
+  	; get-project-dir => project-dir
+  	; !"test/src" => input-base-dir
+  	; !"test/generated" => output-base-dir
+  	; !"example.tes" => sma-file
+  	; <concat-strings> [project-dir, "/", input-base-dir, "/", sma-file] => absolute-location
+  	; echo(|"reading ast from: ")
+  	; echo(|absolute-location)
+  	; get-anno-ast(|absolute-location)
+  	; assert-module
+  	// ; debug
+  	; echo(|"End foo1")
+	
+	  // show ast with complete location annotation
+  bar1 = 
+  	echo(|"Start bar1")
+  	; get-project-dir => project-dir
+  	; !"test/src" => input-base-dir
+  	; !"test/generated" => output-base-dir
+  	; !"localvar.tes" => sma-file
+  	; <concat-strings> [project-dir, "/", input-base-dir, "/", sma-file] => absolute-location
+  	; echo(|"reading ast from: ")
+  	; echo(|absolute-location)
+  	; get-anno-ast(|absolute-location)
+  	; assert-module
+  	// ; debug
+  	; echo(|"End bar1")
+  	  
+  // filter unnecessary Location-annotations	
+  foo2 = 
+  	echo(|"Start foo2")
+  	; get-project-dir => project-dir
+  	; !"test/src" => input-base-dir
+  	; !"test/generated" => output-base-dir
+  	; !"example.tes" => sma-file
+  	; <concat-strings> [project-dir, "/", input-base-dir, "/", sma-file] => absolute-location
+  	; echo(|"reading ast from: ")
+  	; echo(|absolute-location)
+  	; get-anno-ast(|absolute-location)
+  	; assert-module
+  	; filter-location
+  	// ; debug
+  	; echo(|"End foo2")
+  
+  // add strategy entry and strategy exit calls 
+  foo3 = 
+  	echo(|"Start foo3")
+  	; get-project-dir => project-dir
+  	; !"test/src" => input-base-dir
+  	; !"test/generated" => output-base-dir
+  	; !"example.tes" => sma-file
+  	; <concat-strings> [project-dir, "/", input-base-dir, "/", sma-file] => absolute-location
+  	; echo(|"reading ast from: ")
+  	; echo(|absolute-location)
+  	; get-anno-ast(|absolute-location)
+  	; assert-module
+  	; filter-location
+  	; add-debug-info(|absolute-location)
+  	// ; debug
+  	; echo(|"End foo3")
+  	  
+  // add strategy entry and strategy exit calls 
+  bar3 = 
+  	echo(|"Start bar3")
+  	; get-project-dir => project-dir
+  	; !"test/src" => input-base-dir
+  	; !"test/generated" => output-base-dir
+  	; !"localvar.tes" => sma-file
+  	; <concat-strings> [project-dir, "/", input-base-dir, "/", sma-file] => absolute-location
+  	; echo(|"reading ast from: ")
+  	; echo(|absolute-location)
+  	; get-anno-ast(|absolute-location)
+  	; assert-module
+  	; filter-location
+  	; add-debug-info(|absolute-location)
+  	// ; debug
+  	; echo(|"End bar3")
+  	  
+  // pretty print stratego program with debug info
+  foo4 = 
+  	echo(|"Start foo4")
+  	; get-project-dir => project-dir
+  	; !"test/src" => input-base-dir
+  	; !"test/generated" => output-base-dir
+  	; !"example.tes" => sma-file
+  	; <concat-strings> [project-dir, "/", input-base-dir, "/", sma-file] => absolute-location
+  	; echo(|"reading ast from: ")
+  	; echo(|absolute-location)
+  	; get-anno-ast(|absolute-location)
+  	; assert-module
+  	; filter-location
+  	; add-debug-info(|absolute-location)
+  	; pp-stratego-ast
+  	// ; debug
+  	; echo(|"End foo4")
+  	  
+  	    // pretty print stratego program with debug info
+  bar4 = 
+  	echo(|"Start bar4")
+  	; get-project-dir => project-dir
+  	; !"test/src" => input-base-dir
+  	; !"test/generated" => output-base-dir
+  	; !"localvar.tes" => sma-file
+  	; <concat-strings> [project-dir, "/", input-base-dir, "/", sma-file] => absolute-location
+  	; echo(|"reading ast from: ")
+  	; echo(|absolute-location)
+  	; get-anno-ast(|absolute-location)
+  	; assert-module
+  	; filter-location
+  	; add-debug-info(|absolute-location)
+  	; pp-stratego-ast
+  	// ; debug
+  	; echo(|"End bar4")
+  	  
+  // read str file with annotations, add debug statements, write the file	  
+  foo5 = 
+  	echo(|"Start foo5")
+  	; get-project-dir => project-dir
+  	; !"test/src" => input-base-dir
+  	; !"test/generated" => output-base-dir
+  	; !"example.tes" => sma-file
+  	; <concat-strings> [project-dir, "/", input-base-dir, "/", sma-file] => absolute-location
+  	; <concat-strings> [project-dir, "/", output-base-dir, "/", <guarantee-extension(|"str")> sma-file] => absolute-output-location
+  	; echo(|"reading ast from: ")
+  	; echo(|absolute-location)
+  	; get-anno-ast(|absolute-location)
+  	; assert-module
+  	; filter-location
+  	; add-debug-info(|absolute-location)
+  	; pp-stratego-ast
+  	; write-stratego(|absolute-output-location)
+  	// ; debug
+  	; echo(|"End foo5")
+  	  
+strategies // test apply-debug-trans errors
+	
+	  test-apply-debug-1 = !("asdf", "ddfg"); apply-debug-trans
+  test-apply-debug-2 = !("asdf", "ddfg", "asfd"); apply-debug-trans
+  test-apply-debug-3 = !"asdf"; apply-debug-trans
+  
+strategies // test get-internal-files
+	
+	
+  
+  test-list-imports-1 = 
+  	echo(|"test-list-imports-1")
+  	; get-project-dir => project-dir
+  	; !"test/src" => input-base-dir
+  	; !"testimports/localvar.str" => main-str-file
+  	; <concat-strings> [project-dir, "/", input-base-dir, "/", main-str-file] => absolute-location
+  	; echo(|"reading ast from: ")
+  	; echo(|absolute-location)
+  	//; !["-i",  absolute-location, "-I", "."]
+  	; args := ["-i", absolute-location]
+  	; <list-imports(|args)> absolute-location
+  	; ?(files, _)
+  	; <debug(!"files: ")> files
+  	  
+  test-list-imports-2 = 
+  	echo(|"test-list-imports-2")
+  	; get-project-dir => project-dir
+  	; !"test/src" => input-base-dir
+  	; !"testogetarts/ogetarts.str" => main-str-file
+  	; <concat-strings> [project-dir, "/", input-base-dir, "/", main-str-file] => absolute-location
+  	; echo(|"reading ast from: ")
+  	; echo(|absolute-location)
+  	//; !["-i",  absolute-location, "-I", "."]
+  	; args := ["-i", absolute-location]
+  	; <list-imports(|args)> absolute-location
+  	; ?(files, _)
+  	; <debug(!"files: ")> files
+  	  
+  // project dir
+  test-list-imports-3 = 
+  	echo(|"test-list-imports-3")
+  	; get-project-dir => project-dir
+  	; !"trans" => input-base-dir
+  	; !"stratego-transformer.str" => main-str-file
+  	; <concat-strings> [project-dir, "/", input-base-dir, "/", main-str-file] => absolute-location
+  	; echo(|"reading ast from: ")
+  	; echo(|absolute-location)
+  	//; !["-i",  absolute-location, "-I", "."]
+  	; include-dir := <concat-strings> [project-dir, "/", "include"]
+  	; lib-dir := <concat-strings> [project-dir, "/", "lib"] 
+  	; syntax-dir := <concat-strings> [project-dir, "/", "syntax"]
+  	; args := [/*"pack-stratego-io", */"--slack"/*, "--imports"*/
+  	  , "-i", absolute-location
+  	    //, "-I", include-dir // not needed!, will contain output
+  	      //, "-I", lib-dir
+  	        //, "-I", syntax-dir
+  	          , "-I", project-dir
+  	            //, "-I", "."
+  	            ]
+  	; debug(!"arguments: ")
+  	; incl := [ //include-dir, // not needed, include dir only contains generated output
+  	  lib-dir, syntax-dir, project-dir]
+  	; <set-config> ("-I", incl)  
+  	//; <set-config> ("-i", absolute-location)
+  	; <list-imports(|args)> absolute-location
+  	; ?(files, _)
+  	; <debug(!"files: ")> ""
+  	; <map(debug)> files
+
+  // only ".", missing syntax and lib
+  test-list-imports-4 = 
+  	echo(|"test-list-imports-4")
+  	; get-project-dir => project-dir
+  	; !"trans" => input-base-dir
+  	; !"stratego-transformer.str" => main-str-file
+  	; <concat-strings> [project-dir, "/", input-base-dir, "/", main-str-file] => absolute-location
+  	; echo(|"reading ast from: ")
+  	; echo(|absolute-location)
+  	//; !["-i",  absolute-location, "-I", "."]
+  	; include-dir := <concat-strings> [project-dir, "/", "include"]
+  	; lib-dir := <concat-strings> [project-dir, "/", "lib"] 
+  	; syntax-dir := <concat-strings> [project-dir, "/", "syntax"]
+  	; args := [/*"pack-stratego-io", */"--slack"/*, "--imports"*/
+  	  , "-i", absolute-location
+  	    //, "-I", include-dir // not needed!, will contain output
+  	      //, "-I", lib-dir
+  	        //, "-I", syntax-dir
+  	          , "-I", "."
+  	            ]
+  	; debug(!"arguments: ")
+  	; incl := [
+  	  	//include-dir, lib-dir, syntax-dir, project-dir
+  	  	"." ]
+  	; <set-config> ("-I", incl)  
+  	//; <set-config> ("-i", absolute-location)
+  	; <list-imports(|args)> absolute-location
+  	; ?(files, _)
+  	; <debug(!"files: ")> ""
+  	; <map(debug)> files
+  	  
+  // only ".", missing syntax and lib
+  // current term: (basepath, stratego-file)
+  test-list-imports-5 = 
+  	echo(|"test-list-imports-5")
+  	; get-project-dir => project-dir
+  	; !"trans" => input-base-dir
+  	; !"stratego-transformer.str" => main-str-file
+  	; <concat-strings> [project-dir, "/", input-base-dir] => base-path
+  	; !(base-path, main-str-file)
+  	; files := <get-internal-files(|["."])>//; map(try-dbg); debug
+  	//; debug(!"not-empty: ")
+  	//; existing-files := <map(try-dbg)>
+  	//; abs-files := <filter(is-abspath)>
+  	; <debug(!"files: ")> ""
+  	; <map(debug)> files
+  	; missing := <filter(is-relpath)> files
+  	; <debug(!"missing: ")> ""
+  	; <map(debug)> missing
+  	; echo(|"end test-list-imports-5")
+  	  
+  // current term: (basepath, stratego-file)
+  // "-I" project-dir
+  // all imports
+  test-list-imports-6 = 
+  	echo(|"test-list-imports-6")
+  	; get-project-dir => project-dir
+  	; !"trans" => input-base-dir
+  	; !"stratego-transformer.str" => main-str-file
+  	; <concat-strings> [project-dir, "/", input-base-dir] => base-path
+  	//; lib-dir := <concat-strings> [project-dir, "/", "lib"] 
+  	//; syntax-dir := <concat-strings> [project-dir, "/", "syntax"]
+  	; !(base-path, main-str-file)
+  	// also include "./include/Test.str" and "./lib/editor-common.generated.str"
+  	; files := <get-internal-files(|[project-dir])> //; map(try-dbg); debug
+  	; <debug(!"files: ")> ""
+  	; <map(debug)> files
+  	; missing := <filter(is-relpath)> files
+  	; <debug(!"missing: ")> ""
+  	; <map(debug)> missing
+  	; echo(|"end test-list-imports-6")
+
+  // "." contains all imports
+  // current term: (basepath, stratego-file)
+  test-list-imports-7 = 
+  	echo(|"test-list-imports-7")
+  	; get-project-dir => project-dir
+  	; !"test/src/testimports" => input-base-dir
+  	; !"test/generated/testimports" => output-base-dir
+  	; !"localvar.str" => main-str-file
+  	; <concat-strings> [project-dir, "/", input-base-dir] => base-path
+  	; <concat-strings> [project-dir, "/", output-base-dir] => output-base-path
+  	; !(base-path, main-str-file)
+  	; files := <get-internal-files(|["."])> //; map(try-dbg); debug
+  	; <debug(!"files: ")> ""
+  	; <map(debug)> files
+  	; missing := <filter(is-relpath)> files
+  	; <debug(!"missing: ")> ""
+  	; <map(debug)> missing
+  	; real-files := <filter(is-abspath)> files
+  	; map(handle-file(|base-path, output-base-path))
+  	//; echo(|"end test-list-imports-7")
+
+strategies // test split-path
+	  	
+  create-s = !"/home/rlindeman/Documents/TU/webdsl/spoofax-imp/source/org.strategoxt.imp.debug.stratego.transformer/test/src/testimports/localvar.str"
+  create-sub = !"/home/rlindeman/Documents/TU/webdsl/spoofax-imp/source/org.strategoxt.imp.debug.stratego.transformer/test/src/testimports"
+  //create-s = !"/home/rlindeman"
+  //create-sub = !"/home/r"
+  
+  
+  test-extract-base-from-path-1 =
+  	echo(|"test-extract-base-from-path-1")
+  	//; !"long-string"; is-substring(!"long"); debug(!"is-substring: ")
+  	//; <string-starts-with(|"foo")> "foobar"; debug(!"starts-with: ")
+    ; create-s; string-starts-with(|<create-sub>) ; debug(!"starts-with: ")
+  	; create-sub
+  	; sub-string-length := <string-length>
+  	; create-s
+  	; full-string-length := <string-length>
+  	; create-s; string-list := <explode-string>
+  	; <split-at(|sub-string-length)> string-list => (base, path)// slice from sub-string-length to list end
+  	; <debug(!"base, path: ")> (<implode-string> base, <implode-string> path)
+  	//; create-s; try(is-substring(create-sub); debug(!"is-substring: "))
+  	; echo(|"end test-extract-base-from-path-1")
+  	  
+  test-extract-base-from-path-2 = 	  
+  	echo(|"test-extract-base-from-path-2")
+  	; create-s; split-path(|<create-sub>)
+  	; debug(!"parent, child: ")
+  	; echo(|"end test-extract-base-from-path-2")
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/traverse-imports.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/traverse-imports.str	Wed Dec  1 17:31:09 2010	(r21437)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/traverse-imports.str	Wed Dec  1 22:27:24 2010	(r21438)
@@ -7,6 +7,8 @@
   libstratego-xtc 
   libstratego-rtg
   
+  trans-str
+  
 strategies
 	// current term should be a string pointing to a stratego file
 	list-imports(|args) =
@@ -15,65 +17,67 @@
 		//; pack-stratego-trm(|args)
 	; where(id
       ; incl := <get-config <+ ![]> "-I"
-      ; debug(!"incl: ")
+      //; debug(!"incl: ")
       //; <set-config> ("-I", [])
       //; debug(!"set: ")
       //; incl2 := <get-config <+ ![]> "-I"
       //; debug(!"incl2: ")
-      ; <parse-options(pack-stratego-options <+ input-options, system-usage, id)> 
-          [<whoami <+ !"strc"> | args]
+      ; <parse-options(pack-stratego-options <+ input-options, system-usage, id)> [<whoami <+ !"strc"> | args]
     )
-    ; debug(!"where: ")
+    //; debug(!"where: ")
     ; pack-process-options
     ; pack-report-options
-    ; debug(!"config:")
-    ; where(!"-I"; get-config; debug(!"IIII: "))
+    ; where(pack-include-path; debug(!"pack-include-path: ") )
+    //; debug(!"config:")
+    //; where(!"-I"; get-config; debug(!"IIII: "))
       // current is FILE
     ; pack-stratego(|<pack-include-path>) => (files, spec)
-    /*
-    ; <pack-maybe-create-depfile> files
-    ; !spec
-    ; where(<set-config>("-I", incl))
-	*/
-	
-	/*
-	  pack-strategoXX(|mkpt) =
-	  	?g; debug(!"g"); 
-      \ FILE(s) -> IncludePathName(s) \
-      ;debug(!"File: ")
-    ; !(<id>, mkpt, [])
-    ; graph-nodes-undef(
-        { file:
-          pack-stratego-parse-stratego => (file,_)
-        ; rules( FileDependencies :+= file )
-        ; if <get-config> "--dump-aterms" then
-            where({fn, trm: 
-                ?(fn, trm)
-                ; if <string-ends-with(|".str")> fn then
-                    rules ( StrAsts :+= (fn, trm) )
-                  end
-                })
-          end
-        }
-      , pack-get-stratego-imports 
-        ; map(IncludePathName(id) <+ !IncludeFromPath(<id>))
-      , \ (n,x,xs) -> [x|xs] \
-      )
-    ; (uniq,id)
-    ; debug(!"uniq: ")
-    ; if ?(_, []) then
-       Fst
-       ; unzip
-       ; (id, pack-flatten-stratego)
-      else
-        if not(<get-config>"--slack") then
-          Snd 
-          ; map(pack-report-module-not-found)
-          ; <xtc-exit> 1
-        else 
-          Fst
-        ; unzip
-        ; (id, pack-flatten-stratego)
-        end
-      end
-*/
\ No newline at end of file
+
+  // directories is a list of strings, each element is a directory used by "-I"
+  get-internal-files(|directories) :
+  	(basepath, stratego-file) -> real-files
+  	where
+  		absolute-location := 	<concat-strings> [basepath, "/", stratego-file]
+  		; basic-args := [ "--slack" // skip errors
+  			, "-i", absolute-location]
+  		//; basic-ext-args := ["-I", "."]  // "." = basepath. Look for imports only in the current dir
+  		; ext-args := <map(create-I); concat> directories
+  		//	, "-I", "."
+  		; <set-config> ("-I", directories)
+  		; args := <concat> [basic-args, ext-args]
+  		; debug(!"ARGS: ")
+  	  	; <list-imports(|args)> absolute-location
+  		; ?(files, _)
+  		; real-files := <filter(not(?""))> files
+  		  
+  create-I:
+  	directory -> ["-I", directory]
+  	
+  	// if real-file start with base-path
+  	// strip the basepath from real-file => inputfilePath
+  	// call apply-debug-trans
+  	// sourceBasedir = base-path
+  	// outputfilename = output-base-path + inputfilePath
+  	// (sourceBasedir, inputfilePath, outputfilename)
+  handle-file(|base-path, output-base-path) = 
+  	?absolute-stratego-file
+  	; split-path(|base-path) => (parent, rel-path)
+  	; sourceBasedir := base-path
+  	; inputfilePath := rel-path
+  	; outputfilename := <concat-strings> [output-base-path, "/", rel-path]
+  	; args := (sourceBasedir, inputfilePath, outputfilename)
+  	; debug(!"apply-debug-trans: ")
+  	; <apply-debug-trans> args
+  	//; debug(!"DONE apply: ")  	
+  	
+  // splits the path in two paths, first is base-path, second is the path-part after the base-path (trim leading "/")
+  split-path(|base-path) :
+  	path -> (parent-path, child-path)
+  	where <string-starts-with(|base-path)> path // path should start with the base-path
+  	where
+  		sub-string-length := <string-length> base-path
+  		; full-string-length := <string-length> path
+  		; string-list := <explode-string> path
+  		; <split-at(|sub-string-length)> string-list => (p0, p1)
+  		; parent-path := <implode-string> p0
+  		; child-path := <implode-string; ltrim-chars(?'/')> p1
\ No newline at end of file

From r.t.lindeman at student.tudelft.nl  Wed Dec  1 23:30:10 2010
From: r.t.lindeman at student.tudelft.nl (Ricky Lindeman)
Date: Wed, 01 Dec 2010 22:30:10 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21439 - in
	spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/test/src/testimports:
	. localmod localmod/syntax localmod/util
Message-ID: <201012012230.oB1MUAaD029955@proliant.st.ewi.tudelft.nl>

Author: RickyLindeman
Date: Wed Dec  1 22:30:10 2010
New Revision: 21439
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21439&sc=1

Log:
Added a sample stratego program with imports. The imports are in the same package

Added:
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/test/src/testimports/
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/test/src/testimports/localmod/
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/test/src/testimports/localmod/syntax/
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/test/src/testimports/localmod/syntax/varsyntax.str
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/test/src/testimports/localmod/util/
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/test/src/testimports/localmod/util/utils.str
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/test/src/testimports/localvar.str
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/test/src/testimports/run.input
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/test/src/testimports/run.output

Added: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/test/src/testimports/localmod/syntax/varsyntax.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/test/src/testimports/localmod/syntax/varsyntax.str	Wed Dec  1 22:30:10 2010	(r21439)
@@ -0,0 +1,21 @@
+module localmod/syntax/varsyntax
+
+signature
+  sorts
+    Var Number Add Sub Print Assign Function Comment Program
+
+  constructors
+  	
+  	Var		: String -> Expression
+  	Number	: Int -> Expression
+  	Add		: Expression * Expression -> Expression
+  	Sub		: Expression * Expression -> Expression
+  	
+  	Print	: Expression -> Statement
+  	Assign	: String * Expression -> Statement
+  	
+  	Function : String * List(Statement) -> Definition
+  	
+  	Comment : String * String -> Definition
+  	
+  	Program : String * List(Definition) -> Program
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/test/src/testimports/localmod/util/utils.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/test/src/testimports/localmod/util/utils.str	Wed Dec  1 22:30:10 2010	(r21439)
@@ -0,0 +1,16 @@
+module localmod/util/utils
+
+imports 
+	localmod/syntax/varsyntax
+	
+strategies
+	
+	is-empty = ?[] 
+	
+	
+	first = 
+		debug(!"first: ") ;
+		(is-empty < build-c + last)
+		
+		
+	build-c = !Comment("new", "created!!")
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/test/src/testimports/localvar.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/test/src/testimports/localvar.str	Wed Dec  1 22:30:10 2010	(r21439)
@@ -0,0 +1,75 @@
+module localvar
+// use local vars in rules and strategies to store temp result
+
+imports
+  libstrategolib
+
+imports
+	localmod/syntax/varsyntax
+	localmod/util/utils
+
+   
+strategies
+  main =
+    io-wrap(execute)
+    
+rules
+  // show Comment and Function that have the same name
+	
+  execute:
+  	input -> output
+  	with
+  	  output := <match-comments> input
+
+rules
+	match-comments :
+		// match program
+		Program(_, definitions*) -> out
+		with
+			f* := <find-functions> definitions* // find functions
+			; c* := <find-comments> definitions* // find comments
+			; out := <match-f-and-c> (f*, c*)
+
+		
+	find-functions:
+		definition* -> functions*
+		with
+			functions* := <filter(?Function(_,_))> definition*
+			
+	find-comments:
+		definition* -> comments*
+		with
+			comments* := <filter(?Comment(_,_))> definition*
+			
+	match-f-and-c:
+		(f*, c*) -> matches*
+		with
+			//matches* := <map(find-comment-match(|c*))> f*
+			matches* := <map(try-find-comment-by-name(|c*))> f*
+		
+	try-find-comment-by-name(|c*) = find-comment-match(|c*) // <+ (debug(!"fail"); !"fail")	
+		
+	find-comment-match(|c*):
+		f -> (f, c)
+		// f should be a Function
+		where
+			name := <get-function-name> f
+			; c := <find-comment-by-name(|name)> c*
+			  
+	get-function-name:
+		Function(name, _) -> name
+			
+	find-comment-by-name(|name):
+		c* -> comment
+		with 
+		c-filtered* := <filter(?Comment(name, _))> c*
+		; comment := (<debug(!"stuff:"); first> c-filtered*) //  <+ !Comment(name, "created!!")
+		//; comment := <first> c-filtered*
+
+
+/*
+	old-first : c-list* -> out
+	where out := <last> c-list* <+ build-c
+*/
+
+		

Added: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/test/src/testimports/run.input
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/test/src/testimports/run.input	Wed Dec  1 22:30:10 2010	(r21439)
@@ -0,0 +1,23 @@
+Program("progname",
+[
+	Comment("fname", "laalalalalalalalalal")
+	, Comment("this", "this text")
+	, Comment("that", "that text")
+	, Function("fname",
+		[
+			Assign("var_foo"
+				, 
+				Add(Number(2),Number(7))
+				)
+			, Print("var_foo")
+		])
+	, Function("nocomment",
+		[
+			Assign("var_foo"
+				, 
+				Add(Number(2),Number(7))
+				)
+			, Print("var_foo")
+		])
+]
+)

Added: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/test/src/testimports/run.output
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/test/src/testimports/run.output	Wed Dec  1 22:30:10 2010	(r21439)
@@ -0,0 +1 @@
+[(Function("fname",[Assign("var_foo",Add(Number(2),Number(7))),Print("var_foo")]),Comment("fname","laalalalalalalalalal")),(Function("nocomment",[Assign("var_foo",Add(Number(2),Number(7))),Print("var_foo")]),Comment("new","created!!"))]

From r.t.lindeman at student.tudelft.nl  Wed Dec  1 23:34:16 2010
From: r.t.lindeman at student.tudelft.nl (Ricky Lindeman)
Date: Wed, 01 Dec 2010 22:34:16 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21440 - in
	spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test:
	src/stratego/testimports src/stratego/testimports/localmod
	src/stratego/testimports/localmod/syntax sr...
Message-ID: <201012012234.oB1MYGGh030007@proliant.st.ewi.tudelft.nl>

Author: RickyLindeman
Date: Wed Dec  1 22:34:16 2010
New Revision: 21440
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21440&sc=1

Log:
Added Java DebugCompile test for testimports

Added:
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/src/stratego/testimports/
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/src/stratego/testimports/localmod/
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/src/stratego/testimports/localmod/syntax/
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/src/stratego/testimports/localmod/syntax/varsyntax.str
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/src/stratego/testimports/localmod/util/
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/src/stratego/testimports/localmod/util/utils.str
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/src/stratego/testimports/localvar.str
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/src/stratego/testimports/run.input
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/src/stratego/testimports/run.output
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/util/dctests/
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/util/dctests/DebugCompileDynamic.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/util/dctests/DebugCompileLocalVar.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/util/dctests/DebugCompileTestImports.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/util/dctests/DebugCompileTestProp.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/util/dctests/DebugCompilerTest.java
Deleted:
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/DebugCompileDynamic.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/DebugCompileLocalVar.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/DebugCompileTestProp.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/DebugCompilerTest.java

Added: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/src/stratego/testimports/localmod/syntax/varsyntax.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/src/stratego/testimports/localmod/syntax/varsyntax.str	Wed Dec  1 22:34:16 2010	(r21440)
@@ -0,0 +1,21 @@
+module localmod/syntax/varsyntax
+
+signature
+  sorts
+    Var Number Add Sub Print Assign Function Comment Program
+
+  constructors
+  	
+  	Var		: String -> Expression
+  	Number	: Int -> Expression
+  	Add		: Expression * Expression -> Expression
+  	Sub		: Expression * Expression -> Expression
+  	
+  	Print	: Expression -> Statement
+  	Assign	: String * Expression -> Statement
+  	
+  	Function : String * List(Statement) -> Definition
+  	
+  	Comment : String * String -> Definition
+  	
+  	Program : String * List(Definition) -> Program
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/src/stratego/testimports/localmod/util/utils.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/src/stratego/testimports/localmod/util/utils.str	Wed Dec  1 22:34:16 2010	(r21440)
@@ -0,0 +1,16 @@
+module localmod/util/utils
+
+imports 
+	localmod/syntax/varsyntax
+	
+strategies
+	
+	is-empty = ?[] 
+	
+	
+	first = 
+		debug(!"first: ") ;
+		(is-empty < build-c + last)
+		
+		
+	build-c = !Comment("new", "created!!")
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/src/stratego/testimports/localvar.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/src/stratego/testimports/localvar.str	Wed Dec  1 22:34:16 2010	(r21440)
@@ -0,0 +1,75 @@
+module localvar
+// use local vars in rules and strategies to store temp result
+
+imports
+  libstrategolib
+
+imports
+	localmod/syntax/varsyntax
+	localmod/util/utils
+
+   
+strategies
+  main =
+    io-wrap(execute)
+    
+rules
+  // show Comment and Function that have the same name
+	
+  execute:
+  	input -> output
+  	with
+  	  output := <match-comments> input
+
+rules
+	match-comments :
+		// match program
+		Program(_, definitions*) -> out
+		with
+			f* := <find-functions> definitions* // find functions
+			; c* := <find-comments> definitions* // find comments
+			; out := <match-f-and-c> (f*, c*)
+
+		
+	find-functions:
+		definition* -> functions*
+		with
+			functions* := <filter(?Function(_,_))> definition*
+			
+	find-comments:
+		definition* -> comments*
+		with
+			comments* := <filter(?Comment(_,_))> definition*
+			
+	match-f-and-c:
+		(f*, c*) -> matches*
+		with
+			//matches* := <map(find-comment-match(|c*))> f*
+			matches* := <map(try-find-comment-by-name(|c*))> f*
+		
+	try-find-comment-by-name(|c*) = find-comment-match(|c*) // <+ (debug(!"fail"); !"fail")	
+		
+	find-comment-match(|c*):
+		f -> (f, c)
+		// f should be a Function
+		where
+			name := <get-function-name> f
+			; c := <find-comment-by-name(|name)> c*
+			  
+	get-function-name:
+		Function(name, _) -> name
+			
+	find-comment-by-name(|name):
+		c* -> comment
+		with 
+		c-filtered* := <filter(?Comment(name, _))> c*
+		; comment := (<debug(!"stuff:"); first> c-filtered*) //  <+ !Comment(name, "created!!")
+		//; comment := <first> c-filtered*
+
+
+/*
+	old-first : c-list* -> out
+	where out := <last> c-list* <+ build-c
+*/
+
+		

Added: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/src/stratego/testimports/run.input
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/src/stratego/testimports/run.input	Wed Dec  1 22:34:16 2010	(r21440)
@@ -0,0 +1,23 @@
+Program("progname",
+[
+	Comment("fname", "laalalalalalalalalal")
+	, Comment("this", "this text")
+	, Comment("that", "that text")
+	, Function("fname",
+		[
+			Assign("var_foo"
+				, 
+				Add(Number(2),Number(7))
+				)
+			, Print("var_foo")
+		])
+	, Function("nocomment",
+		[
+			Assign("var_foo"
+				, 
+				Add(Number(2),Number(7))
+				)
+			, Print("var_foo")
+		])
+]
+)

Added: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/src/stratego/testimports/run.output
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/src/stratego/testimports/run.output	Wed Dec  1 22:34:16 2010	(r21440)
@@ -0,0 +1 @@
+[(Function("fname",[Assign("var_foo",Add(Number(2),Number(7))),Print("var_foo")]),Comment("fname","laalalalalalalalalal")),(Function("nocomment",[Assign("var_foo",Add(Number(2),Number(7))),Print("var_foo")]),Comment("new","created!!"))]

Added: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/util/dctests/DebugCompileDynamic.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/util/dctests/DebugCompileDynamic.java	Wed Dec  1 22:34:16 2010	(r21440)
@@ -0,0 +1,55 @@
+package org.strategoxt.debug.core.util.dctests;
+
+import java.io.IOException;
+
+import org.StrategoFileManager;
+import org.strategoxt.debug.core.util.DebugCompiler;
+import org.strategoxt.debug.core.util.DebugSessionSettings;
+
+public class DebugCompileDynamic {
+
+	public static void main(String[] args) {
+		//testDebugCompileLocalVar();
+		testDebugCompileDynamic();
+	}
+	
+	public static void testDebugCompileDynamic() {
+		//String inputBase = StrategoFileManager.BASE;
+		String inputFilePath = "src/stratego/dynamic/localvar.str";
+		//String strategoFilePath = inputBase + "/" + inputFilename;
+		String projectName = "dynamic";
+		DebugCompiler debugCompiler = new DebugCompiler(StrategoFileManager.WORKING_DIR);
+		// mkdir localvar/stratego in workingdir
+		// mkdir localvar/java
+		// mkdir localvar/class
+		String binBase = null;
+		boolean compileSucces = false;
+		try {
+			binBase = debugCompiler.debugCompile(StrategoFileManager.BASE, inputFilePath, projectName);
+			compileSucces = true;
+		} catch (IOException e) {
+			e.printStackTrace();
+		} catch (Exception e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+		boolean runjava = true;
+		// run .class
+		if (runjava && compileSucces)
+		{
+			String input = StrategoFileManager.BASE + "/src/stratego/dynamic/run.input";
+			String argsForMainClass = "-i " + input;
+			String mainClass = "dynamic.dynamic";
+			String mainArgs = mainClass + " " + argsForMainClass;
+			
+			String strategoxtjar = DebugSessionSettings.strategoxtjar;
+			String libstrategodebuglib = DebugSessionSettings.libstrategodebuglib;
+			String strjdebugruntime = DebugSessionSettings.strjdebugruntime;
+			
+			String cp = strategoxtjar + ":" + libstrategodebuglib + ":" + strjdebugruntime + ":" + binBase;
+			String classpath = cp;
+			org.strategoxt.debug.core.util.Runner.run(projectName, mainArgs, classpath);
+		}
+	}
+	
+}

Added: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/util/dctests/DebugCompileLocalVar.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/util/dctests/DebugCompileLocalVar.java	Wed Dec  1 22:34:16 2010	(r21440)
@@ -0,0 +1,58 @@
+package org.strategoxt.debug.core.util.dctests;
+
+import java.io.IOException;
+
+import org.StrategoFileManager;
+import org.strategoxt.debug.core.util.DebugCompiler;
+import org.strategoxt.debug.core.util.DebugSessionSettings;
+
+public class DebugCompileLocalVar {
+
+	/**
+	 * @param args
+	 */
+	public static void main(String[] args) {
+		testDebugCompileLocalVar();
+
+	}
+	
+	public static void testDebugCompileLocalVar() {
+		//String inputBase = StrategoFileManager.BASE;
+		String inputFilePath = "src/stratego/localvar/localvar.str";
+		//String strategoFilePath = inputBase + "/" + inputFilename;
+		String projectName = "localvar";
+		DebugCompiler debugCompiler = new DebugCompiler(StrategoFileManager.WORKING_DIR);
+		// mkdir localvar/stratego in workingdir
+		// mkdir localvar/java
+		// mkdir localvar/class
+		String binBase = null;
+		boolean compileSucces = false;
+		try {
+			binBase = debugCompiler.debugCompile(StrategoFileManager.BASE, inputFilePath, projectName);
+			compileSucces = true;
+		} catch (IOException e) {
+			e.printStackTrace();
+		} catch (Exception e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+		boolean runjava = true;
+		// run .class
+		if (runjava && compileSucces)
+		{
+			String input = StrategoFileManager.BASE + "/src/stratego/localvar/run.input";
+			String argsForMainClass = "-i " + input;
+			String mainClass = "localvar.localvar";
+			String mainArgs = mainClass + " " + argsForMainClass;
+			
+			String strategoxtjar = DebugSessionSettings.strategoxtjar;
+			String libstrategodebuglib = DebugSessionSettings.libstrategodebuglib;
+			String strjdebugruntime = DebugSessionSettings.strjdebugruntime;
+			
+			String cp = strategoxtjar + ":" + libstrategodebuglib + ":" + strjdebugruntime + ":" + binBase;
+			String classpath = cp;
+			org.strategoxt.debug.core.util.Runner.run(projectName, mainArgs, classpath);
+		}
+	}
+
+}

Added: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/util/dctests/DebugCompileTestImports.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/util/dctests/DebugCompileTestImports.java	Wed Dec  1 22:34:16 2010	(r21440)
@@ -0,0 +1,54 @@
+package org.strategoxt.debug.core.util.dctests;
+
+import java.io.IOException;
+
+import org.StrategoFileManager;
+import org.strategoxt.debug.core.util.DebugCompiler;
+import org.strategoxt.debug.core.util.DebugSessionSettings;
+
+public class DebugCompileTestImports {
+
+	public static void main(String[] args) {
+		testDebugCompileTestImports();
+	}
+
+	public static void testDebugCompileTestImports()
+	{
+		//String inputBase = StrategoFileManager.BASE;
+		String inputFilePath = "src/stratego/testimports/localvar.str";
+		//String strategoFilePath = inputBase + "/" + inputFilename;
+		String projectName = "testimports";
+		DebugCompiler debugCompiler = new DebugCompiler(StrategoFileManager.WORKING_DIR);
+		// mkdir localvar/stratego in workingdir
+		// mkdir localvar/java
+		// mkdir localvar/class
+		String binBase = null;
+		boolean compileSucces = false;
+		try {
+			binBase = debugCompiler.debugCompile(StrategoFileManager.BASE, inputFilePath, projectName);
+			compileSucces = true;
+		} catch (IOException e) {
+			e.printStackTrace();
+		} catch (Exception e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+		boolean runjava = true;
+		// run .class
+		if (runjava && compileSucces)
+		{
+			String input = StrategoFileManager.BASE + "/src/stratego/dynamic/run.input";
+			String argsForMainClass = "-i " + input;
+			String mainClass = "dynamic.dynamic";
+			String mainArgs = mainClass + " " + argsForMainClass;
+			
+			String strategoxtjar = DebugSessionSettings.strategoxtjar;
+			String libstrategodebuglib = DebugSessionSettings.libstrategodebuglib;
+			String strjdebugruntime = DebugSessionSettings.strjdebugruntime;
+			
+			String cp = strategoxtjar + ":" + libstrategodebuglib + ":" + strjdebugruntime + ":" + binBase;
+			String classpath = cp;
+			org.strategoxt.debug.core.util.Runner.run(projectName, mainArgs, classpath);
+		}
+	}
+}

Added: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/util/dctests/DebugCompileTestProp.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/util/dctests/DebugCompileTestProp.java	Wed Dec  1 22:34:16 2010	(r21440)
@@ -0,0 +1,5 @@
+package org.strategoxt.debug.core.util.dctests;
+
+public class DebugCompileTestProp {
+
+}

Added: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/util/dctests/DebugCompilerTest.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/util/dctests/DebugCompilerTest.java	Wed Dec  1 22:34:16 2010	(r21440)
@@ -0,0 +1,57 @@
+package org.strategoxt.debug.core.util.dctests;
+
+import java.io.IOException;
+
+import org.StrategoFileManager;
+import org.strategoxt.debug.core.util.DebugCompiler;
+import org.strategoxt.debug.core.util.DebugSessionSettings;
+
+public class DebugCompilerTest {
+	
+	public static void main(String[] args) {
+		testDebugCompileLocalVarDebug();
+	}
+	
+
+	
+	public static void testDebugCompileLocalVarDebug() {
+		//String inputBase = StrategoFileManager.BASE;
+		String inputFilePath = "src/stratego/localvardebug/localvar.str";
+		//String strategoFilePath = inputBase + "/" + inputFilename;
+		String projectName = "localvardebug";
+		DebugCompiler debugCompiler = new DebugCompiler(StrategoFileManager.WORKING_DIR);
+		// mkdir localvar/stratego in workingdir
+		// mkdir localvar/java
+		// mkdir localvar/class
+		String binBase = null;
+		boolean compileSucces = false;
+		try {
+			binBase = debugCompiler.debugCompile(StrategoFileManager.BASE, inputFilePath, projectName);
+			compileSucces = true;
+		} catch (IOException e) {
+			e.printStackTrace();
+		} catch (Exception e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+		boolean runjava = true;
+		// run .class
+		if (runjava && compileSucces)
+		{
+			String input = StrategoFileManager.BASE + "/src/stratego/localvardebug/run.input";
+			String argsForMainClass = "-i " + input;
+			String mainClass = "localvardebug.localvardebug";
+			String mainArgs = mainClass + " " + argsForMainClass;
+			
+			String strategoxtjar = DebugSessionSettings.strategoxtjar;
+			String libstrategodebuglib = DebugSessionSettings.libstrategodebuglib;
+			String strjdebugruntime = DebugSessionSettings.strjdebugruntime;
+			
+			String cp = strategoxtjar + ":" + libstrategodebuglib + ":" + strjdebugruntime + ":" + binBase;
+			String classpath = cp;
+			org.strategoxt.debug.core.util.Runner.run(projectName, mainArgs, classpath);
+		}
+	}
+
+
+}

From r.t.lindeman at student.tudelft.nl  Thu Dec  2 14:04:39 2010
From: r.t.lindeman at student.tudelft.nl (Ricky Lindeman)
Date: Thu, 02 Dec 2010 13:04:39 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21441 - in
	spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer:
	test/generated trans
Message-ID: <201012021304.oB2D4dhk009129@proliant.st.ewi.tudelft.nl>

Author: RickyLindeman
Date: Thu Dec  2 13:04:38 2010
New Revision: 21441
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21441&sc=1

Log:
* implemented apply-debug-project, call this stratego to add debug information to the stratego-file and the imports that are on the library-paths
 * removed debug prints

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/test/generated/   (props changed)
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/gen-lookup.str
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/str-reader.str
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/trans-str.str
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/transformer-test-suite.str
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/traverse-imports.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/gen-lookup.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/gen-lookup.str	Wed Dec  1 22:34:16 2010	(r21440)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/gen-lookup.str	Thu Dec  2 13:04:38 2010	(r21441)
@@ -37,10 +37,7 @@
 		  	; collect-debug-calls
 		  	; lines* :=  <create-table-entries>
 		  	; contents := $[[lines*]]
-		  	; write-contents-to-handle(|table-file-handle, contents) // also flushes
-		  	    
-		  	//; filename := <guarantee-extension(|"table")> inputfilename
-		  	//; write-to-file(|filename, contents)
+		  	; write-contents-to-handle(|table-file-handle, contents)
   	    			
 // strategy to collect all strago debug calls
 	collect-debug-calls =

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/str-reader.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/str-reader.str	Wed Dec  1 22:34:16 2010	(r21440)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/str-reader.str	Thu Dec  2 13:04:38 2010	(r21441)
@@ -76,9 +76,10 @@
 	get-file-handle(|filename) =
 		handle := <fopen> (filename, "w")
 		
-	// writes contents to the file-handle and flush
+	// writes contents to the file-handle
 	// returns the Stream
-	write-contents-to-handle(|file-handle, contents) = 	<fputs> (contents, file-handle); fflush
+	// cannot call fflush Primitive not defined: SSL_fflush when using java
+	write-contents-to-handle(|file-handle, contents) = 	<fputs> (contents, file-handle) //; fflush
 	
 	// closes the file-handle Stream
 	close-file-handle(|file-handle) = <fclose> file-handle

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/trans-str.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/trans-str.str	Wed Dec  1 22:34:16 2010	(r21440)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/trans-str.str	Thu Dec  2 13:04:38 2010	(r21441)
@@ -70,12 +70,12 @@
   	; add-debug-info(|inputfilePath)
   	//; debug(!"add-debug-info(|inputfilePath)")
   	; pp-stratego-ast
-  	; debug(!"pp-stratego-ast")
+  	//; debug(!"pp-stratego-ast")
   	; write-stratego(|outputfilename)
-  	; debug(!"write-stratego")
+  	//; debug(!"write-stratego")
   	; status := "SUCCES"  		
   	)
-  	; <debug(!"exit-apply")> ""
+  	//; <debug(!"exit-apply")> ""
   
   apply-debug-trans-debug :
   	input -> output
@@ -91,3 +91,18 @@
   		; status := "FAIL"
   	)
   	
+  	apply-debug-project = apply-debug-project(|["."])
+  	
+  	// base-path = "/home/rlindeman/Documents/TU/webdsl/spoofax-imp/source/org.strategoxt.imp.debug.stratego.transformer/test/src/testimports"
+  	// output-base-path = "/tmp/testimports"
+  	// stratego-file = "localvar.str"
+  	// library-paths = [".", "<dir>"]
+	apply-debug-project(|library-paths) :
+		(base-path, output-base-path, stratego-file) -> results
+		where
+			!(base-path, stratego-file)
+  			; files := <get-internal-files(|library-paths)>
+  			; missing := <filter(is-relpath)> files // files that still have a relative path are not found on the "-I" paths
+  			; real-files := <filter(is-abspath)> files // only add debug information to the files that can be found on the "-I" paths
+  			; results := <map(handle-file(|base-path, output-base-path))> // do apply-debug-trans for each file, store the result in the output-base-path
+  			// results = [(status, filename), (status, filename)]

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/transformer-test-suite.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/transformer-test-suite.str	Wed Dec  1 22:34:16 2010	(r21440)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/transformer-test-suite.str	Thu Dec  2 13:04:38 2010	(r21441)
@@ -307,9 +307,20 @@
   	; <debug(!"missing: ")> ""
   	; <map(debug)> missing
   	; real-files := <filter(is-abspath)> files
-  	; map(handle-file(|base-path, output-base-path))
+  	; map(handle-file(|base-path, output-base-path)) // do apply-debug-trans for each file
   	//; echo(|"end test-list-imports-7")
 
+	test-list-imports-8 =
+		echo(|"test-list-imports-8")
+	  	; get-project-dir => project-dir
+	  	; !"test/src/testimports" => input-base-dir
+	  	; !"test/generated/testimports" => output-base-dir
+	  	; !"localvar.str" => main-str-file
+  		; <concat-strings> [project-dir, "/", input-base-dir] => base-path
+  		; <concat-strings> [project-dir, "/", output-base-dir] => output-base-path	  	  
+  	  	; !(base-path, output-base-path, main-str-file)
+  	  	; apply-debug-project(|["."])
+  	  	  	
 strategies // test split-path
 	  	
   create-s = !"/home/rlindeman/Documents/TU/webdsl/spoofax-imp/source/org.strategoxt.imp.debug.stratego.transformer/test/src/testimports/localvar.str"

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/traverse-imports.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/traverse-imports.str	Wed Dec  1 22:34:16 2010	(r21440)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/traverse-imports.str	Thu Dec  2 13:04:38 2010	(r21441)
@@ -27,7 +27,7 @@
     //; debug(!"where: ")
     ; pack-process-options
     ; pack-report-options
-    ; where(pack-include-path; debug(!"pack-include-path: ") )
+    ; where(pack-include-path /*; debug(!"pack-include-path: ")*/ )
     //; debug(!"config:")
     //; where(!"-I"; get-config; debug(!"IIII: "))
       // current is FILE
@@ -45,7 +45,7 @@
   		//	, "-I", "."
   		; <set-config> ("-I", directories)
   		; args := <concat> [basic-args, ext-args]
-  		; debug(!"ARGS: ")
+  		//; debug(!"ARGS: ")
   	  	; <list-imports(|args)> absolute-location
   		; ?(files, _)
   		; real-files := <filter(not(?""))> files
@@ -66,7 +66,7 @@
   	; inputfilePath := rel-path
   	; outputfilename := <concat-strings> [output-base-path, "/", rel-path]
   	; args := (sourceBasedir, inputfilePath, outputfilename)
-  	; debug(!"apply-debug-trans: ")
+  	//; debug(!"apply-debug-trans: ")
   	; <apply-debug-trans> args
   	//; debug(!"DONE apply: ")  	
   	

From r.t.lindeman at student.tudelft.nl  Thu Dec  2 15:20:44 2010
From: r.t.lindeman at student.tudelft.nl (Ricky Lindeman)
Date: Thu, 02 Dec 2010 14:20:44 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21442 - in
	spoofax-imp/trunk:
	org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control
	org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/...
Message-ID: <201012021420.oB2EKinZ010144@proliant.st.ewi.tudelft.nl>

Author: RickyLindeman
Date: Thu Dec  2 14:20:44 2010
New Revision: 21442
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21442&sc=1

Log:
Added filename property to breakpoint.

Added:
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestImports.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/VMMonitorTestImpl2.java
Deleted:
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/thread-main.txt
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/writer.txt
Modified:
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/EventThread.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/ThreadEventHandler.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/RuleEnterHandler.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/RuleExitHandler.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyEnterHandler.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyExitHandler.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyStepHandler.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/BreakPoint.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/RuleEnterBreakPoint.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/RuleExitBreakPoint.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/StrategyEnterBreakPoint.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/StrategyExitBreakPoint.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/StrategyStepBreakPoint.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/util/DebugCompiler.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/util/StrategoTermBuilder.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/util/table/EventEntry.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/util/table/EventTable.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/AbstractDSMTest.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestDynamic.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DebugSessionManagerTest.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/util/dctests/DebugCompileDynamic.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/util/dctests/DebugCompileLocalVar.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/util/dctests/DebugCompileTestImports.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/util/dctests/DebugCompilerTest.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/util/table/EventTableTest.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/EventThread.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/EventThread.java	Thu Dec  2 13:04:38 2010	(r21441)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/EventThread.java	Thu Dec  2 14:20:44 2010	(r21442)
@@ -78,8 +78,6 @@
 	private final VirtualMachine vm; // Running VM
 	private final String[] excludes; // Packages to exclude
 
-	static String nextBaseIndent = ""; // Starting indent for next thread
-
 	private boolean connected = false; // Connected to VM
 	private boolean vmDied = false; // VMDeath occurred
 

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/ThreadEventHandler.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/ThreadEventHandler.java	Thu Dec  2 13:04:38 2010	(r21441)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/ThreadEventHandler.java	Thu Dec  2 14:20:44 2010	(r21442)
@@ -1,8 +1,5 @@
 package org.strategoxt.debug.core.control;
 
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -20,8 +17,6 @@
 import org.strategoxt.debug.core.model.StrategoState;
 import org.strategoxt.debug.core.util.StrategoTermBuilder;
 
-import com.sun.jdi.Field;
-import com.sun.jdi.IncompatibleThreadStateException;
 import com.sun.jdi.Method;
 import com.sun.jdi.ThreadReference;
 import com.sun.jdi.Value;
@@ -41,10 +36,6 @@
 	 */
 
 	final ThreadReference thread;
-	final String baseIndent = "";
-	StringBuffer indent;
-	
-	private PrintWriter writer;
 
 	// share stratego state across threads
 	private StrategoState strategoState = null;
@@ -52,31 +43,6 @@
 	public ThreadEventHandler(ThreadReference thread, StrategoState strategoState) {
 		this.thread = thread;
 		this.strategoState = strategoState;
-		indent = new StringBuffer(baseIndent);
-		initWriter();
-		
-		println("====== " + thread.name() + " ======");
-		
-	}
-	
-	private void initWriter()
-	{
-		String filename = "thread-"+thread.name()+".txt";
-		try {
-			writer = new PrintWriter(new File(filename));
-			writer.println("Start thread");
-			writer.flush();
-			System.out.println("Created: " + filename);
-		} catch (FileNotFoundException e) {
-			// TODO Auto-generated catch block
-			e.printStackTrace();
-		}		
-	}
-
-	private void println(String str) {
-		writer.print(indent);
-		writer.println(str);
-		writer.flush();
 	}
 
 	/*
@@ -111,8 +77,6 @@
 		//System.out.println(eventType);
 		
 		String methodName = event.method().name();
-		String declaringType = event.method().declaringType().name();
-
 		
 		if ("<clinit>".equals(methodName) || "<init>".equals(methodName))
 		{
@@ -120,10 +84,6 @@
 			return suspendThread;
 		}
 		
-		//System.out.println(methodName + "  --------------------  " + declaringType);
-		println(methodName + "  --  " + declaringType);
-
-		
 		EventHandler h = null;
 		if (EventHandler.R_ENTER.equals(eventType))
 		{
@@ -246,14 +206,13 @@
 	}
 
 	void fieldWatchEvent(ModificationWatchpointEvent event) {
-		Field field = event.field();
-		Value value = event.valueToBe();
-		println("    " + field.name() + " = " + value);
+		//Field field = event.field();
+		//Value value = event.valueToBe();
+		// field changed value
 	}
 
 	void exceptionEvent(ExceptionEvent event) {
-		println("Exception: " + event.exception() + " catch: "
-				+ event.catchLocation());
+		// event.exception() at event.catchLocation()
 
 		// Step to the catch
 		EventRequestManager mgr = event.virtualMachine().eventRequestManager();
@@ -266,24 +225,12 @@
 
 	// Step to exception catch
 	void stepEvent(StepEvent event) {
-		// Adjust call depth
-		int cnt = 0;
-		indent = new StringBuffer(baseIndent);
-		try {
-			cnt = thread.frameCount();
-		} catch (IncompatibleThreadStateException exc) {
-		}
-		while (cnt-- > 0) {
-			indent.append("| ");
-		}
-
 		EventRequestManager mgr = event.virtualMachine().eventRequestManager();
 		mgr.deleteEventRequest(event.request());
 	}
 
 	void threadDeathEvent(ThreadDeathEvent event) {
-		indent = new StringBuffer(baseIndent);
-		println("====== " + thread.name() + " end ======");
+		// thread death event
 	}
 
 }

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/RuleEnterHandler.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/RuleEnterHandler.java	Thu Dec  2 13:04:38 2010	(r21441)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/RuleEnterHandler.java	Thu Dec  2 14:20:44 2010	(r21442)
@@ -18,8 +18,9 @@
 	@Override
 	protected BreakPoint createBreakPoint() {
 		String name = this.getName(); // the name of the rule
+		String filename = this.getFilename(); // the filename of the stratego file in which we want to set a breakpoint
 		LocationInfo locationInfo = getLocationInfo();
-		RuleEnterBreakPoint b = new RuleEnterBreakPoint(name, locationInfo.getStart_line_num(), locationInfo.getStart_token_pos());
+		RuleEnterBreakPoint b = new RuleEnterBreakPoint(filename, name, locationInfo.getStart_line_num(), locationInfo.getStart_token_pos());
 		return b;
 	}
 

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/RuleExitHandler.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/RuleExitHandler.java	Thu Dec  2 13:04:38 2010	(r21441)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/RuleExitHandler.java	Thu Dec  2 14:20:44 2010	(r21442)
@@ -16,8 +16,9 @@
 	@Override
 	protected BreakPoint createBreakPoint() {
 		String name = this.getName(); // the name of the rule
+		String filename = this.getFilename(); // the filename of the stratego file in which we want to set a breakpoint
 		LocationInfo locationInfo = getLocationInfo();
-		RuleExitBreakPoint b = new RuleExitBreakPoint(name, locationInfo.getStart_line_num(), locationInfo.getStart_token_pos());
+		RuleExitBreakPoint b = new RuleExitBreakPoint(filename, name, locationInfo.getStart_line_num(), locationInfo.getStart_token_pos());
 		return b;
 	}
 

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyEnterHandler.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyEnterHandler.java	Thu Dec  2 13:04:38 2010	(r21441)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyEnterHandler.java	Thu Dec  2 14:20:44 2010	(r21442)
@@ -18,8 +18,9 @@
 	@Override
 	protected BreakPoint createBreakPoint() {
 		String name = this.getName(); // the name of the strategy
+		String filename = this.getFilename(); // the filename of the stratego file in which we want to set a breakpoint
 		LocationInfo locationInfo = getLocationInfo();
-		StrategyEnterBreakPoint b = new StrategyEnterBreakPoint(name, locationInfo.getStart_line_num(), locationInfo.getStart_token_pos());
+		StrategyEnterBreakPoint b = new StrategyEnterBreakPoint(filename, name, locationInfo.getStart_line_num(), locationInfo.getStart_token_pos());
 		return b;
 	}
 

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyExitHandler.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyExitHandler.java	Thu Dec  2 13:04:38 2010	(r21441)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyExitHandler.java	Thu Dec  2 14:20:44 2010	(r21442)
@@ -21,8 +21,9 @@
 	@Override
 	protected BreakPoint createBreakPoint() {
 		String name = this.getName(); // the name of the strategy
+		String filename = this.getFilename(); // the filename of the stratego file in which we want to set a breakpoint
 		LocationInfo locationInfo = getLocationInfo();
-		StrategyExitBreakPoint b = new StrategyExitBreakPoint(name, locationInfo.getStart_line_num(), locationInfo.getStart_token_pos());
+		StrategyExitBreakPoint b = new StrategyExitBreakPoint(filename, name, locationInfo.getStart_line_num(), locationInfo.getStart_token_pos());
 		return b;
 	}
 

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyStepHandler.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyStepHandler.java	Thu Dec  2 13:04:38 2010	(r21441)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyStepHandler.java	Thu Dec  2 14:20:44 2010	(r21442)
@@ -16,8 +16,9 @@
 	@Override
 	protected BreakPoint createBreakPoint() {
 		String name = this.getName(); // the name of the strategy
+		String filename = this.getFilename(); // the filename of the stratego file in which we want to set a breakpoint
 		LocationInfo locationInfo = getLocationInfo();
-		StrategyStepBreakPoint b = new StrategyStepBreakPoint(name, locationInfo.getStart_line_num(), locationInfo.getStart_token_pos());
+		StrategyStepBreakPoint b = new StrategyStepBreakPoint(filename, name, locationInfo.getStart_line_num(), locationInfo.getStart_token_pos());
 		return b;
 	}
 

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/BreakPoint.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/BreakPoint.java	Thu Dec  2 13:04:38 2010	(r21441)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/BreakPoint.java	Thu Dec  2 14:20:44 2010	(r21442)
@@ -2,6 +2,7 @@
 
 public abstract class BreakPoint {
 
+	private String filename;
 	private String name;
 	private int lineNumber;
 	private int startTokenPosition;
@@ -13,11 +14,22 @@
 	 * @param lineNumber
 	 * @param startTokenPosition
 	 */
-	public BreakPoint(String name, int lineNumber, int startTokenPosition) {
+	public BreakPoint(String filename, String name, int lineNumber, int startTokenPosition) {
+		this.filename = filename;
 		this.name = name;
 		this.lineNumber = lineNumber;
 		this.startTokenPosition = startTokenPosition;
 	}
+	
+	public String getFilename()
+	{
+		return filename;
+	}
+	
+	public void setFilename(String filename)
+	{
+		this.filename = filename;
+	}
 
 	public String getName() {
 		return name;

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/RuleEnterBreakPoint.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/RuleEnterBreakPoint.java	Thu Dec  2 13:04:38 2010	(r21441)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/RuleEnterBreakPoint.java	Thu Dec  2 14:20:44 2010	(r21442)
@@ -2,8 +2,8 @@
 
 public class RuleEnterBreakPoint extends BreakPoint {
 	
-	public RuleEnterBreakPoint(String name, int lineNumber, int startTokenPosition) {
-		super(name, lineNumber, startTokenPosition);
+	public RuleEnterBreakPoint(String filename, String name, int lineNumber, int startTokenPosition) {
+		super(filename, name, lineNumber, startTokenPosition);
 	}
 
 	@Override
@@ -13,6 +13,7 @@
 		result = prime * result + getLineNumber();
 		result = prime * result
 				+ ((getName() == null) ? 0 : getName().hashCode());
+		result = prime * result + ((getFilename() == null) ? 0 : getFilename().hashCode());
 		return result;
 	}
 
@@ -25,6 +26,11 @@
 		if (!(obj instanceof RuleEnterBreakPoint))
 			return false;
 		RuleEnterBreakPoint other = (RuleEnterBreakPoint) obj;
+		if (getFilename() == null || other.getFilename() == null) {
+			return false;
+		} else if (!getFilename().equals(other.getFilename())) {
+			return false;
+		}
 		if (getName() == null || other.getName() == null) {
 			return false;
 		} else if (!getName().equals(other.getName())) {

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/RuleExitBreakPoint.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/RuleExitBreakPoint.java	Thu Dec  2 13:04:38 2010	(r21441)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/RuleExitBreakPoint.java	Thu Dec  2 14:20:44 2010	(r21442)
@@ -2,8 +2,8 @@
 
 public class RuleExitBreakPoint extends BreakPoint {
 	
-	public RuleExitBreakPoint(String name, int lineNumber, int startTokenPosition) {
-		super(name, lineNumber, startTokenPosition);
+	public RuleExitBreakPoint(String filename, String name, int lineNumber, int startTokenPosition) {
+		super(filename, name, lineNumber, startTokenPosition);
 	}
 
 	@Override
@@ -13,6 +13,7 @@
 		result = prime * result + getLineNumber();
 		result = prime * result
 				+ ((getName() == null) ? 0 : getName().hashCode());
+		result = prime * result + ((getFilename() == null) ? 0 : getFilename().hashCode());
 		return result;
 	}
 
@@ -25,6 +26,11 @@
 		if (!(obj instanceof RuleExitBreakPoint))
 			return false;
 		RuleExitBreakPoint other = (RuleExitBreakPoint) obj;
+		if (getFilename() == null || other.getFilename() == null) {
+			return false;
+		} else if (!getFilename().equals(other.getFilename())) {
+			return false;
+		}
 		if (getName() == null || other.getName() == null) {
 			return false;
 		} else if (!getName().equals(other.getName()))

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/StrategyEnterBreakPoint.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/StrategyEnterBreakPoint.java	Thu Dec  2 13:04:38 2010	(r21441)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/StrategyEnterBreakPoint.java	Thu Dec  2 14:20:44 2010	(r21442)
@@ -2,8 +2,8 @@
 
 public class StrategyEnterBreakPoint extends BreakPoint {
 	
-	public StrategyEnterBreakPoint(String name, int lineNumber, int startTokenPosition) {
-		super(name, lineNumber, startTokenPosition);
+	public StrategyEnterBreakPoint(String filename, String name, int lineNumber, int startTokenPosition) {
+		super(filename, name, lineNumber, startTokenPosition);
 	}
 
 	@Override
@@ -13,6 +13,7 @@
 		result = prime * result + getLineNumber();
 		result = prime * result
 				+ ((getName() == null) ? 0 : getName().hashCode());
+		result = prime * result + ((getFilename() == null) ? 0 : getFilename().hashCode());
 		return result;
 	}
 
@@ -25,6 +26,11 @@
 		if (!(obj instanceof StrategyEnterBreakPoint))
 			return false;
 		StrategyEnterBreakPoint other = (StrategyEnterBreakPoint) obj;
+		if (getFilename() == null || other.getFilename() == null) {
+			return false;
+		} else if (!getFilename().equals(other.getFilename())) {
+			return false;
+		}
 		if (getName() == null || other.getName() == null) {
 			return false;
 		} else if (!getName().equals(other.getName())) {

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/StrategyExitBreakPoint.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/StrategyExitBreakPoint.java	Thu Dec  2 13:04:38 2010	(r21441)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/StrategyExitBreakPoint.java	Thu Dec  2 14:20:44 2010	(r21442)
@@ -2,8 +2,8 @@
 
 public class StrategyExitBreakPoint extends BreakPoint {
 	
-	public StrategyExitBreakPoint(String name, int lineNumber, int startTokenPosition) {
-		super(name, lineNumber, startTokenPosition);
+	public StrategyExitBreakPoint(String filename, String name, int lineNumber, int startTokenPosition) {
+		super(filename, name, lineNumber, startTokenPosition);
 	}
 
 	@Override
@@ -13,6 +13,7 @@
 		result = prime * result + getLineNumber();
 		result = prime * result
 				+ ((getName() == null) ? 0 : getName().hashCode());
+		result = prime * result + ((getFilename() == null) ? 0 : getFilename().hashCode());
 		return result;
 	}
 
@@ -25,6 +26,11 @@
 		if (!(obj instanceof StrategyEnterBreakPoint))
 			return false;
 		StrategyEnterBreakPoint other = (StrategyEnterBreakPoint) obj;
+		if (getFilename() == null || other.getFilename() == null) {
+			return false;
+		} else if (!getFilename().equals(other.getFilename())) {
+			return false;
+		}
 		if (getName() == null || other.getName() == null) {
 			return false;
 		} else if (!getName().equals(other.getName())) {

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/StrategyStepBreakPoint.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/StrategyStepBreakPoint.java	Thu Dec  2 13:04:38 2010	(r21441)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/StrategyStepBreakPoint.java	Thu Dec  2 14:20:44 2010	(r21442)
@@ -3,8 +3,8 @@
 
 public class StrategyStepBreakPoint extends BreakPoint {
 
-	public StrategyStepBreakPoint(String name, int lineNumber, int startTokenPosition) {
-		super(name, lineNumber, startTokenPosition);
+	public StrategyStepBreakPoint(String filename, String name, int lineNumber, int startTokenPosition) {
+		super(filename, name, lineNumber, startTokenPosition);
 	}
 
 	@Override
@@ -15,6 +15,7 @@
 		result = prime * result + getStartTokenPosition();
 		result = prime * result
 				+ ((getName() == null) ? 0 : getName().hashCode());
+		result = prime * result + ((getFilename() == null) ? 0 : getFilename().hashCode());
 		return result;
 	}
 
@@ -27,6 +28,11 @@
 		if (!(obj instanceof StrategyStepBreakPoint))
 			return false;
 		StrategyStepBreakPoint other = (StrategyStepBreakPoint) obj;
+		if (getFilename() == null || other.getFilename() == null) {
+			return false;
+		} else if (!getFilename().equals(other.getFilename())) {
+			return false;
+		}
 		if (getName() == null || other.getName() == null) {
 			return false; // one of the names is null
 		} else if (!getName().equals(other.getName())) {

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/util/DebugCompiler.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/util/DebugCompiler.java	Thu Dec  2 13:04:38 2010	(r21441)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/util/DebugCompiler.java	Thu Dec  2 14:20:44 2010	(r21442)
@@ -4,16 +4,19 @@
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.Collection;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Map;
 
 import org.eclipse.jdt.core.compiler.CompilationProgress;
 import org.eclipse.jdt.internal.compiler.batch.Main;
 import org.spoofax.interpreter.terms.BasicStrategoString;
 import org.spoofax.interpreter.terms.BasicStrategoTuple;
+import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoString;
 import org.spoofax.interpreter.terms.IStrategoTerm;
-import org.spoofax.interpreter.terms.IStrategoTuple;
 import org.strategoxt.lang.Context;
 
 
@@ -64,13 +67,14 @@
 	 * @return returns the basedir of the binary files
 	 * @throws IOException
 	 */
-	public String runCompile(String strategoFilePath, String projectName) throws IOException
+	public String runCompile(String strategoSourceBasedir, String strategoFilePath, String projectName) throws IOException
 	{
 		// throw exception if completeInputPath does not exist
-		File f = new File(strategoFilePath);
-		if (!f.exists())
+		File absFilePath = new File(strategoSourceBasedir, strategoFilePath);
+		//File f = new File(strategoFilePath);
+		if (!absFilePath.exists())
 		{
-			throw new FileNotFoundException("Input file '" + strategoFilePath + "' does not exists!");
+			throw new FileNotFoundException("Input file '" + absFilePath.getAbsolutePath() + "' does not exists!");
 		}
 		
 		cleanDirectories(projectName); // create directory structure in the working dir
@@ -115,35 +119,37 @@
 		}
 		
 		cleanDirectories(projectName); // create directory structure in the working dir
-		// projectName should be the stratego filename without the dir and the extension
-		
-		File strategoFilePathFile = new File(strategoFilePath);
-		String strFilename = strategoFilePathFile.getName(); // just the filename, no directory
+		// projectName should be unique, let the caller of this method decide what the name of the project is.
 
 
+		Collection<String> libraryPaths = new ArrayList<String>();
+		libraryPaths.add("."); // the "-I" arguments
 		
 		String projectDir = this.workingDir + "/" + projectName;
 		String projectStrategoDir = projectDir + "/stratego";
 		String projectJavaDir = projectDir + "/java";
 		String projectClassDir = projectDir + "/class";
 
-		String strOutputFilename = projectStrategoDir + "/" + strFilename;
-		// outputFilename should stay the same
-		strOutputFilename = generateStratego(strategoSourceBasedir, strategoFilePath, strOutputFilename); // str to str (with debug info) 
-		// TODO check if file is actually created!
-		if (strOutputFilename == null)
+		String strOutputBasedir = projectStrategoDir; // + "/" + strFilename;
+		// strategoSourceBasedir + strategoFilePath is the input stratego file (without debug information)
+		// strOutputBasedir + strategoFilePath should be the output stratego file (with debug information)
+		List<String> generatedFiles = generateStratego(strategoSourceBasedir, strategoFilePath, strOutputBasedir, libraryPaths); // str to str (with debug info) 
+		// TODO check if files are actually created!
+		if (generatedFiles == null || generatedFiles.isEmpty())
 		{
 			throw new Exception("Failed to compile stratego program with debug information");
 		}
 		
 		// create lookup table
-		generateLookupTable(strOutputFilename);
+		String tableFilename = projectStrategoDir + "/" + projectName + ".table"; // location of the table
+		// the table contains all debug lookup information for all files in the project
+		generateLookupTable(tableFilename, generatedFiles);
 		
 		String libraryName = projectName; // will be the packageName
 		String className = projectName;
 		String packageFolder = projectName;
 		String compiledStrategoFilename = projectJavaDir + "/" + packageFolder + "/" + className + ".java"; // packageName + className
-		String inputStrategoFilename = strOutputFilename; // the output of str to str is used as input
+		String inputStrategoFilename = strOutputBasedir + "/" + strategoFilePath; // the output of str to str is used as input
 		compileStratego(inputStrategoFilename, libraryName, compiledStrategoFilename); // stratego to java
 		
 		String sourceBasedir = projectJavaDir;
@@ -154,14 +160,16 @@
 	}
 	
 	/**
-	 * Add stratego debug information to the given strategofile at inputFilename, the output will be saved at outputFilename.
+	 * Add stratego debug information to the given strategofile at sourceBasedir/inputFilename
+	 * The output will be saved in the strOutputBasedir.
 	 * The inputFilePath should be relative to the sourceBasedir. 
+	 * libraryPaths contains all "-I" paths
 	 * 
 	 * The inputFilePath will be saved in the debug information instead
 	 * of the complete absolute path so it points to a relative file containing the original stratego source.
 	 * The debugger needs to figure out what the actual absolute path is.
 	 * 
-	 * Method returns null when the generation failed.
+	 * Method returns a list of all generated files.
 	 * 
 	 * @param sourceBasedir
 	 * @param inputFilePath
@@ -169,87 +177,113 @@
 	 * @return
 	 * @throws Exception 
 	 */
-	protected static String generateStratego(String sourceBasedir, String inputFilePath, String outputFilename) throws Exception
+	protected List<String> generateStratego(String sourceBasedir, String inputFilePath, String strOutputBasedir, Collection<String> libraryPaths) throws Exception
 	{
 		// assume f is a valid file
-		File f = new File(sourceBasedir, inputFilePath);
-		System.out.println("Adding debug information to " + f.getAbsolutePath());
+		File absInput = new File(sourceBasedir, inputFilePath);
+		System.out.println("Adding debug information to " + absInput.getAbsolutePath());
 		System.out.println("Please wait...");
 		
 		System.out.println(sourceBasedir);
 		System.out.println(inputFilePath);
-		System.out.println(outputFilename);
+		//System.out.println(outputFilename);
 		
 		//the package org.strjdbg.transformer transform a stratego program to a stratego program with debug information
 		Context context = org.strategoxt.imp.debug.stratego.transformer.trans.Main.init();
 		//Context context = org.strjdbg.transformer.Main.init();
-		// see trans-str.str#apply-debug-trans
-		// (sourceBasedir, inputfilePath, outputfilename)
-		// inputfilePath is relative to sourceBasedir.
-		// sourceBasedir should be treated as a project directory
-		// the generated file will be saved at outputfilename
+		// see trans-str.str#apply-debug-project
+		// (base-path, output-base-path, stratego-file)
 		BasicStrategoString[] kids = new BasicStrategoString[]
            {
-				new BasicStrategoString(sourceBasedir) , // sourceBasedir
-				new BasicStrategoString(inputFilePath) , // inputfilePath
-				new BasicStrategoString(outputFilename) // outputfilename
+				new BasicStrategoString(sourceBasedir) , // base-path
+				new BasicStrategoString(strOutputBasedir) , // output-base-path
+				new BasicStrategoString(inputFilePath) // stratego-file
            };
 		IStrategoTerm input = new BasicStrategoTuple(kids);
+		
+		// termArguments should be a list of Strings, each is a path for the "-I" parameter
+		StrategoTermBuilder b = new StrategoTermBuilder();
+		IStrategoList termArguments = b.convertToIStrategoList(libraryPaths);
+		
 		IStrategoTerm term; 
+		term = org.strategoxt.imp.debug.stratego.transformer.trans.apply_debug_project_0_1.instance.invoke(context, input, termArguments);
+
 		
-		term = org.strategoxt.imp.debug.stratego.transformer.trans.apply_debug_trans_0_0.instance.invoke(context, input);
-		//System.out.println(term);
-		String status = null; // will be SUCCES or FAIL
-		String result = null; // should be the same as outputFilename
+		boolean hasFailed = false;
+		List<String> generatedFiles = new ArrayList<String>();
 		if (term == null)
 		{
 			System.out.println("Adding debug information failed!");
 			return null;
 		}
-		else if (term.getTermType() == IStrategoTerm.STRING)
+		else if (term.getTermType() == IStrategoTerm.LIST)
 		{
-			IStrategoString sterm = (IStrategoString) term;
-			outputFilename = sterm.stringValue();
-		}
-		else if (term.getTermType() == IStrategoTerm.TUPLE)
-		{
-			IStrategoTuple tterm = (IStrategoTuple) term;
-			int subtermCount = tterm.getSubtermCount();
-			if (subtermCount != 2)
-			{
-				// wrong number of arguments
-			}
-			else
+			IStrategoList listTerm = (IStrategoList) term;
+			IStrategoTerm[] subterms = listTerm.getAllSubterms();
+			for(IStrategoTerm subterm : subterms)
 			{
-				// first argument is SUCCES or FAIL
-				status = ((IStrategoString) tterm.get(0)).stringValue();
-				// second argument is the outputfilename
-				result = ((IStrategoString) tterm.get(1)).stringValue();
+				if (subterm.getTermType() == IStrategoTerm.TUPLE)
+				{
+					// should be a tuple: (status, filename)
+					IStrategoTerm[] tupleTerms = subterm.getAllSubterms();
+					if (tupleTerms.length != 2)
+					{
+						// tuple should have two items
+					}
+					else
+					{
+						IStrategoString ss = (IStrategoString) tupleTerms[0];
+						String status = ss.stringValue();
+						IStrategoString sf = (IStrategoString) tupleTerms[1];
+						String filename = sf.stringValue();
+						System.out.println(status + " " + filename);
+						if (!"SUCCES".equals(status))
+						{
+							hasFailed = true;
+							System.out.println(status + " : Failed at " + filename);
+						}
+						else
+						{
+							generatedFiles.add(filename);
+						}
+					}
+				}
+				
 			}
 		}
-		//TODO: outputFilename should be the same as result
-		
-		
-		if ("SUCCES".equals(status))
+		else
 		{
-			System.out.println("Adding debug information finished");	
+			// incorrect return type
 		}
-		else
+
+
+		if (hasFailed)
 		{
 			System.out.println("Adding debug information failed!");
 			throw new Exception("Adding debug information failed!");
 		}
-		return result;
+		return generatedFiles;
 	}
 	
-	protected static void generateLookupTable(String strategoDebugFileName)
+	protected static void generateLookupTable(String tableFilenameString, List<String> strategoDebugFileNames)
 	{
 		//the package org.strjdbg.transformer transform a stratego program to a stratego program with debug information
 		Context context = org.strategoxt.imp.debug.stratego.transformer.trans.Main.init();
-		
-		IStrategoTerm input = new BasicStrategoString(strategoDebugFileName);
-		
-		org.strategoxt.imp.debug.stratego.transformer.trans.create_table_0_0.instance.invoke(context, input);
+		StrategoTermBuilder builder = new StrategoTermBuilder();
+		IStrategoList inputfilenames = builder.convertToIStrategoList(strategoDebugFileNames);
+		//IStrategoTerm input = new BasicStrategoString(strategoDebugFileName);
+		
+		// table-filename is the location of the output table
+		// current term should be a list of inputfilenames each pointing to a stratego file
+		// output is the location of the table
+		// STRATEGO: create-table(|table-filename): inputfilenames* -> table-filename
+		IStrategoTerm current = inputfilenames;
+		IStrategoTerm tableFilename = new BasicStrategoString(tableFilenameString); 
+		IStrategoTerm output = org.strategoxt.imp.debug.stratego.transformer.trans.create_table_0_1.instance.invoke(context, current, tableFilename);
+		if (output == null || !output.toString().equals(tableFilenameString))
+		{
+			// output should match tableFilenameString
+		}
 	}
 	
 	/**

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/util/StrategoTermBuilder.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/util/StrategoTermBuilder.java	Thu Dec  2 13:04:38 2010	(r21441)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/util/StrategoTermBuilder.java	Thu Dec  2 14:20:44 2010	(r21442)
@@ -5,6 +5,7 @@
 import java.util.Iterator;
 import java.util.List;
 
+import org.spoofax.interpreter.terms.BasicStrategoString;
 import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoConstructor;
 import org.spoofax.interpreter.terms.IStrategoInt;
@@ -292,6 +293,11 @@
 		return strategoConstructor;
 	}
 	
+	/**
+	 * The given IStrategoTerm should be a list, all items in the list are converted to a String[].
+	 * @param term
+	 * @return
+	 */
 	public String[] convertToStringArray(IStrategoTerm term)
 	{
 		if (term instanceof org.strategoxt.lang.terms.StrategoList)
@@ -310,5 +316,22 @@
 			return null;
 		}
 	}
+	
+	/**
+	 * Converts a Collection<String> to a IStrategoList containing BasicStrategoString's.
+	 * @param collection
+	 * @return
+	 */
+	public IStrategoList convertToIStrategoList(Collection<String> collection)
+	{
+		Collection<IStrategoTerm> terms = new ArrayList<IStrategoTerm>();
+		for(String item : collection)
+		{
+			IStrategoTerm t = new BasicStrategoString(item);
+			terms.add(t);
+		}
+		IStrategoList list = f.makeList(terms);
+		return list;
+	}
 
 }

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/util/table/EventEntry.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/util/table/EventEntry.java	Thu Dec  2 13:04:38 2010	(r21441)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/util/table/EventEntry.java	Thu Dec  2 14:20:44 2010	(r21442)
@@ -37,4 +37,10 @@
 		return locationInfo;
 	}
 	
+	@Override
+	public String toString() {
+		String s = String.format("EventEntry type=%s strategyName=%s file=%s locationInfo=%s", eventType, strategyName, strategoFilename, locationInfo.toString());
+		return s;
+	}
+	
 }

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/util/table/EventTable.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/util/table/EventTable.java	Thu Dec  2 13:04:38 2010	(r21441)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/util/table/EventTable.java	Thu Dec  2 14:20:44 2010	(r21442)
@@ -19,16 +19,29 @@
 		this.eventEntries = new ArrayList<EventEntry>();
 	}
 	
+	/**
+	 * Add an EventEntry to the EventTable.
+	 * @param eventEntry
+	 */
 	public void add(EventEntry eventEntry)
 	{
 		this.eventEntries.add(eventEntry);
 	}
 		
+	/**
+	 * Returns the number of items in the EventTable.
+	 * @return
+	 */
 	public int size()
 	{
 		return this.eventEntries.size();
 	}
 	
+	/**
+	 * Read the table from the given location and return a EventTable
+	 * @param location
+	 * @return
+	 */
 	public static EventTable readEventTable(String location)
 	{
 		EventTable eventTable = null; // return value
@@ -80,7 +93,14 @@
 		return eventTable;
 	}
 	
-	public List<EventEntry> getEventEntries(int linenumber)
+	/**
+	 * Gets the EventEntries that match the given filename and the given linenumber.
+	 * Multiple EventEntries can be at the same linenumber.
+	 * @param filename
+	 * @param linenumber
+	 * @return
+	 */
+	public List<EventEntry> getEventEntries(String filename, int linenumber)
 	{
 		List<EventEntry> matches = new ArrayList<EventEntry>();
 		
@@ -94,9 +114,16 @@
 		return matches;
 	}
 	
-	public List<EventEntry> getEventEntries(int linenumber, String eventType)
+	/**
+	 * Gets the EventEntries that match the given filename, the given linenumber and the given eventType.
+	 * @param filename
+	 * @param linenumber
+	 * @param eventType
+	 * @return
+	 */
+	public List<EventEntry> getEventEntries(String filename, int linenumber, String eventType)
 	{
-		List<EventEntry> matches = this.getEventEntries(linenumber);
+		List<EventEntry> matches = this.getEventEntries(filename, linenumber);
 		List<EventEntry> typeMatches = new ArrayList<EventEntry>();
 		for(EventEntry eventEntry : matches)
 		{
@@ -108,13 +135,21 @@
 		return typeMatches;
 	}
 	
-	public List<EventEntry> getEventEntries(int linenumber, int token_position)
+	/**
+	 * Gets the EventEntries that match the given filename and the EventEntry should surround the linenumber and token_position.
+	 * 
+	 * @param filename
+	 * @param linenumber
+	 * @param token_position
+	 * @return
+	 */
+	public List<EventEntry> getEventEntries(String filename, int linenumber, int token_position)
 	{
 		List<EventEntry> matches = new ArrayList<EventEntry>();
 		
 		for(EventEntry eventEntry : this.eventEntries)
 		{
-			if (eventEntry.getLocationInfo().surrounds(linenumber, token_position))
+			if (eventEntry.getLocationInfo().surrounds(linenumber, token_position) && eventEntry.getStrategoFilename().equals(filename))
 			{
 				matches.add(eventEntry);
 			}
@@ -122,9 +157,18 @@
 		return matches;
 	}
 	
-	public List<EventEntry> getEventEntries(int linenumber, int token_position, String eventType)
+	/**
+	 * Gets the EventEntries that match the given filename, the given eventType and the EventEntry should surround the linenumber and token_position.
+	 * 
+	 * @param filename
+	 * @param linenumber
+	 * @param token_position
+	 * @param eventType
+	 * @return
+	 */
+	public List<EventEntry> getEventEntries(String filename, int linenumber, int token_position, String eventType)
 	{
-		List<EventEntry> matches = this.getEventEntries(linenumber, token_position);
+		List<EventEntry> matches = this.getEventEntries(filename, linenumber, token_position);
 		List<EventEntry> typeMatches = new ArrayList<EventEntry>();
 		for(EventEntry eventEntry : matches)
 		{
@@ -136,6 +180,11 @@
 		return typeMatches;
 	}
 	
+	/**
+	 * Returns the first EventEntry that is a s-step event from the given list.
+	 * @param entries
+	 * @return
+	 */
 	public static EventEntry getFirstStepEventEntry(List<EventEntry> entries)
 	{
 		for(EventEntry eventEntry: entries)
@@ -148,6 +197,11 @@
 		return null;
 	}
 	
+	/**
+	 * Returns the first EventEntry that is a s-enter or a r-enter event from the given list.
+	 * @param entries
+	 * @return
+	 */
 	public static EventEntry getFirstEnterEventEntry(List<EventEntry> entries)
 	{
 		for(EventEntry eventEntry: entries)

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/AbstractDSMTest.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/AbstractDSMTest.java	Thu Dec  2 13:04:38 2010	(r21441)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/AbstractDSMTest.java	Thu Dec  2 14:20:44 2010	(r21442)
@@ -12,10 +12,10 @@
 public abstract class AbstractDSMTest {
 
 	
-	protected void addBP(DebugSessionManager dsm, int lineNumber, int startTokenPosition, String eventType)
+	protected void addBP(DebugSessionManager dsm, String filename, int lineNumber, int startTokenPosition, String eventType)
 	{
 		EventTable eventTable = dsm.getEventSpecManager().getEventTable();
-		List<EventEntry> entries = eventTable.getEventEntries(lineNumber, startTokenPosition, eventType);
+		List<EventEntry> entries = eventTable.getEventEntries(filename, lineNumber, startTokenPosition, eventType);
 		Assert.assertEquals(1, entries.size());
 		
 		// a breakpoint may be placed at any place in the LocationInfo that is defined by a statement
@@ -23,7 +23,22 @@
 		// use these to lookup the actual LocationInfo used by the breakpoint
 		EventEntry match = entries.get(0);
 		BreakPoint bp = null;
-		bp = new StrategyStepBreakPoint(match.getStrategyName(), match.getLocationInfo().getStart_line_num(), match.getLocationInfo().getStart_token_pos());
+		bp = new StrategyStepBreakPoint(filename, match.getStrategyName(), match.getLocationInfo().getStart_line_num(), match.getLocationInfo().getStart_token_pos());
 		dsm.getEventSpecManager().add(bp);
 	}
+	
+	/**
+	 * classPath contains the binary files of the compiled strj program
+	 * @param mainArgs
+	 * @param classpath
+	 */
+	public static DebugSessionManager start(DebugSessionManager manager, String mainArgs, String classpath)
+	{
+		manager.initVM(mainArgs, classpath);
+		//manager.initVM(mainArgs);
+		manager.setupEventListeners();
+		manager.redirectOutput();
+		manager.runVM();		
+		return manager;
+	}
 }

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestDynamic.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestDynamic.java	Thu Dec  2 13:04:38 2010	(r21441)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestDynamic.java	Thu Dec  2 14:20:44 2010	(r21442)
@@ -1,12 +1,8 @@
 package org.strategoxt.debug.core.control;
 
-import java.util.Map.Entry;
-
 import junit.framework.Assert;
 
 import org.StrategoFileManager;
-import org.spoofax.interpreter.terms.IStrategoTerm;
-import org.strategoxt.debug.core.model.StrategoState;
 import org.strategoxt.debug.core.util.DebugSessionSettings;
 import org.strategoxt.debug.core.util.table.EventTable;
 
@@ -21,6 +17,7 @@
 	public void testStepBreakPoint()
 	{
 		String projectName = "dynamic";
+		String strategoFilename = "localvar.str";
 		DebugSessionSettings debugSessionSettings = new DebugSessionSettings(StrategoFileManager.WORKING_DIR, projectName);
 		
 		//String binBase = DebugCompilerTest.WORKING_DIR + "/" + projectName + "/class";
@@ -33,7 +30,7 @@
 		String cp = /*strategoxtjar + ":" + libstrategodebuglib + ":" + strjdebugruntime + ":" + */ debugSessionSettings.getClassDirectory(); // was binBase
 		String classpath = cp;
 		
-		VMMonitorTestImpl1 vmMonitor = new VMMonitorTestImpl1();
+		VMMonitorTestImpl2 vmMonitor = new VMMonitorTestImpl2();
 		DebugSessionManager dsm = new DebugSessionManager(debugSessionSettings, vmMonitor);
 		vmMonitor.setDSM(dsm);
 		
@@ -51,7 +48,7 @@
 		int lineNumber = 78;
 		int startTokenPosition = 8;
 		String eventType = "s-step";
-		this.addBP(dsm, lineNumber, startTokenPosition, eventType);
+		this.addBP(dsm, strategoFilename, lineNumber, startTokenPosition, eventType);
 		
 		// 93, 6
 		// ; comment := (<debug(!"stuff:"); first> c-filtered*) //  <+ !Comment(name, "created!!")
@@ -61,7 +58,7 @@
 		lineNumber = 93;
 		startTokenPosition = 6;
 		eventType = "s-step";
-		this.addBP(dsm, lineNumber, startTokenPosition, eventType);
+		this.addBP(dsm, strategoFilename, lineNumber, startTokenPosition, eventType);
 		
 		// TODO: test set breakpoint on dynamic rule
 		/*
@@ -90,69 +87,7 @@
 		start(dsm, mainArgs, classpath);
 	}
 	
-	/**
-	 * classPath contains the binary files of the compiled strj program
-	 * @param mainArgs
-	 * @param classpath
-	 */
-	public static DebugSessionManager start(DebugSessionManager manager, String mainArgs, String classpath)
-	{
-		manager.initVM(mainArgs, classpath);
-		//manager.initVM(mainArgs);
-		manager.setupEventListeners();
-		manager.redirectOutput();
-		manager.runVM();		
-		return manager;
-	}
-	
-	
-	class VMMonitorTestImpl1 implements VMMonitor {
 
-		private DebugSessionManager debugSessionManager;
-		private VMStateTester vmStateTester;
-		
-		public VMMonitorTestImpl1() {
-
-		}
-		
-		public void setVMStateTester(VMStateTester vmStateTester) {
-			this.vmStateTester = vmStateTester;
-		}
-
-		public void setDSM(DebugSessionManager dsm)
-		{
-			this.debugSessionManager = dsm;
-		}
-		
-		public void stateChanged(StrategoState state) {
-			//System.out.println("state changed");
-			String name = state.currentFrame().getName();
-			boolean expected = vmStateTester.isNextHit(name);
-			System.out.println("expected: " + expected);
-			String message = "Hit " + name + ", but expected to hit " + vmStateTester.currentHit();
-			Assert.assertTrue(message, expected);
-			String termString = state.currentFrame().getCurrentTerm().toString();
-			System.out.println("current: " + termString);
-			for ( Entry<String, IStrategoTerm> entry : state.currentFrame().getVariables().entrySet() )
-			{
-				System.out.println("variable entry " + entry.getKey() + " # " + entry.getValue());
-			}
-			this.debugSessionManager.resumeVM();
-		}
-
-		public void vmEvent(String event) {
-			System.out.println("vmEvent: " + event);
-			if ("VMDEATH".equals(event))
-			{
-				// vm terminated
-				if (this.vmStateTester.hasNextHit())
-				{
-					Assert.fail("VM has terminated but there are still some expected hits left...");
-				}
-			}
-		}
-		
-	}
 
 
 }

Added: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestImports.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestImports.java	Thu Dec  2 14:20:44 2010	(r21442)
@@ -0,0 +1,66 @@
+package org.strategoxt.debug.core.control;
+
+import junit.framework.Assert;
+
+import org.StrategoFileManager;
+import org.strategoxt.debug.core.util.DebugSessionSettings;
+import org.strategoxt.debug.core.util.table.EventTable;
+
+public class DSMTestImports extends AbstractDSMTest {
+
+	public static void main(String[] args) {
+		DSMTestImports test = new DSMTestImports();
+		test.testStepBreakPoint();
+	}
+	
+	@org.junit.Test
+	public void testStepBreakPoint()
+	{
+		String projectName = "testimports";
+		String localvarFilename = "localvar.str";
+		String utilsFilename = "localmod/util/utils.str";
+		
+		DebugSessionSettings debugSessionSettings = new DebugSessionSettings(StrategoFileManager.WORKING_DIR, projectName);
+		
+		String input = StrategoFileManager.BASE + "/src/stratego/testimports/run.input";
+		String argsForMainClass = "-i " + input;
+		String mainClass = "testimports.testimports";
+		String mainArgs = mainClass + " " + argsForMainClass;
+		String cp = /*strategoxtjar + ":" + libstrategodebuglib + ":" + strjdebugruntime + ":" + */ debugSessionSettings.getClassDirectory(); // was binBase
+		String classpath = cp;
+		
+		VMMonitorTestImpl2 vmMonitor = new VMMonitorTestImpl2();
+		DebugSessionManager dsm = new DebugSessionManager(debugSessionSettings, vmMonitor);
+		vmMonitor.setDSM(dsm);
+		
+		//String location = debugSessionSettings.getStrategoDirectory() + "/" + projectName + ".table";
+		//EventTable eventTable = EventTable.readEventTable(location);
+		EventTable eventTable = dsm.getEventSpecManager().getEventTable();
+		Assert.assertEquals(48, eventTable.size());
+		
+		// localvar.str # match-comments # 31, 8
+		// ; out := <match-f-and-c> (f*, c*)
+		int lineNumber = 31;
+		int startTokenPosition = 8;
+		String eventType = "s-step";
+		this.addBP(dsm, localvarFilename, lineNumber, startTokenPosition, eventType);
+		
+		// localmod/util/utils.str # first # 12, 4
+		// debug(!"first: ") ;
+		lineNumber = 12;
+		startTokenPosition = 4;
+		eventType = "s-step";
+		this.addBP(dsm, utilsFilename, lineNumber, startTokenPosition, eventType);
+		
+		// which breakpoints will be hit?
+		VMStateTester vmStateTester = new VMStateTester();
+		vmStateTester.addName("match-comments");
+		vmStateTester.addName("first");
+		vmStateTester.addName("first");
+		vmMonitor.setVMStateTester(vmStateTester);
+		
+		System.out.println("RUN");
+		// start the debug session
+		start(dsm, mainArgs, classpath);
+	}
+}

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DebugSessionManagerTest.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DebugSessionManagerTest.java	Thu Dec  2 13:04:38 2010	(r21441)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DebugSessionManagerTest.java	Thu Dec  2 14:20:44 2010	(r21442)
@@ -58,7 +58,7 @@
 		
 		// create a breakpoint
 		BreakPoint bp = null;
-		bp = new RuleEnterBreakPoint("find-comment-match", -1, -1); // should hit "find-comment-by-name" two times
+		bp = new RuleEnterBreakPoint("localvar.str", "find-comment-match", -1, -1); // should hit "find-comment-by-name" two times
 		dsm.getEventSpecManager().add(bp);
 		
 		System.out.println("RUN");
@@ -96,9 +96,9 @@
 		
 		// create a breakpoint
 		BreakPoint bp = null;
-		bp = new RuleEnterBreakPoint("find-comment-match", -1, -1); // should hit "find-comment-by-name" two times
+		bp = new RuleEnterBreakPoint("localvar.str", "find-comment-match", -1, -1); // should hit "find-comment-by-name" two times
 		dsm.getEventSpecManager().add(bp);
-		bp = new StrategyEnterBreakPoint("first", -1, -1); // should hit two times
+		bp = new StrategyEnterBreakPoint("localvar.str", "first", -1, -1); // should hit two times
 		dsm.getEventSpecManager().add(bp);
 		System.out.println("RUN");
 		// start the debug session
@@ -109,6 +109,7 @@
 	public void testStepBreakPoint()
 	{
 		String projectName = "localvar";
+		String strategoFilename = "localvar.str";
 		DebugSessionSettings debugSessionSettings = new DebugSessionSettings(StrategoFileManager.WORKING_DIR, projectName);
 		
 		//String binBase = DebugCompilerTest.WORKING_DIR + "/" + projectName + "/class";
@@ -136,7 +137,7 @@
 		int lineNumber = 47;
 		int startTokenPosition = 8;
 		String eventType = "s-step";
-		this.addBP(dsm, lineNumber, startTokenPosition, eventType);
+		this.addBP(dsm, strategoFilename, lineNumber, startTokenPosition, eventType);
 
 		
 		// 48, 8
@@ -144,14 +145,14 @@
 		lineNumber = 48;
 		startTokenPosition = 8;
 		eventType = "s-step";
-		this.addBP(dsm, lineNumber, startTokenPosition, eventType);
+		this.addBP(dsm, strategoFilename, lineNumber, startTokenPosition, eventType);
 		
 		// 49, 8
 		// out := <match-f-and-c> (f*, c*)
 		lineNumber = 49;
 		startTokenPosition = 8;
 		eventType = "s-step";
-		this.addBP(dsm, lineNumber, startTokenPosition, eventType);
+		this.addBP(dsm, strategoFilename, lineNumber, startTokenPosition, eventType);
 	
 		
 		// which breakpoints will be hit?
@@ -171,6 +172,7 @@
 	public void testStepVarBreakPoint()
 	{
 		String projectName = "localvar";
+		String strategoFilename = "localvar.str";
 		DebugSessionSettings debugSessionSettings = new DebugSessionSettings(StrategoFileManager.WORKING_DIR, projectName);
 		
 		//String binBase = DebugCompilerTest.WORKING_DIR + "/" + projectName + "/class";
@@ -198,7 +200,7 @@
 		int lineNumber = 47;
 		int startTokenPosition = 8;
 		String eventType = "s-step";
-		this.addBP(dsm, lineNumber, startTokenPosition, eventType);
+		this.addBP(dsm, strategoFilename, lineNumber, startTokenPosition, eventType);
 
 		
 		// 48, 8
@@ -206,7 +208,7 @@
 		lineNumber = 48;
 		startTokenPosition = 8;
 		eventType = "s-step";
-		this.addBP(dsm, lineNumber, startTokenPosition, eventType);
+		this.addBP(dsm, strategoFilename, lineNumber, startTokenPosition, eventType);
 
 		
 		// 49, 8
@@ -214,7 +216,7 @@
 		lineNumber = 49;
 		startTokenPosition = 8;
 		eventType = "s-step";
-		this.addBP(dsm, lineNumber, startTokenPosition, eventType);
+		this.addBP(dsm, strategoFilename, lineNumber, startTokenPosition, eventType);
 
 		
 		
@@ -235,6 +237,7 @@
 	public void testBreakpointLookup()
 	{
 		String projectName = "localvar";
+		String strategoFilename = "localvar.str";
 		// TODO: project should be compiled with debug info!
 		
 		DebugSessionSettings debugSessionSettings = new DebugSessionSettings(StrategoFileManager.WORKING_DIR, projectName);
@@ -258,7 +261,7 @@
 		Assert.assertEquals(46, eventTable.size());
 		
 		// find-comment-match s-enter is at 71,7
-		List<EventEntry> entries = eventTable.getEventEntries(71, 7);
+		List<EventEntry> entries = eventTable.getEventEntries(strategoFilename, 71, 7);
 		Assert.assertEquals(2, entries.size()); // r-enter/r-exit
 		EventEntry rEnter = null; // only use the r-enter
 		for(EventEntry e : entries)
@@ -279,7 +282,7 @@
 		
 		// create a breakpoint
 		BreakPoint bp = null;
-		bp = new RuleEnterBreakPoint(rEnter.getStrategyName(), -1, -1); // should hit "find-comment-by-name" two times
+		bp = new RuleEnterBreakPoint("localvar.str", rEnter.getStrategyName(), -1, -1); // should hit "find-comment-by-name" two times
 		dsm.getEventSpecManager().add(bp);
 		System.out.println("RUN");
 		// start the debug session

Added: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/VMMonitorTestImpl2.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/VMMonitorTestImpl2.java	Thu Dec  2 14:20:44 2010	(r21442)
@@ -0,0 +1,55 @@
+package org.strategoxt.debug.core.control;
+
+import java.util.Map.Entry;
+
+import junit.framework.Assert;
+
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.strategoxt.debug.core.model.StrategoState;
+
+public class VMMonitorTestImpl2 implements VMMonitor {
+	
+	private DebugSessionManager debugSessionManager;
+	private VMStateTester vmStateTester;
+	
+	public VMMonitorTestImpl2() {
+
+	}
+	
+	public void setVMStateTester(VMStateTester vmStateTester) {
+		this.vmStateTester = vmStateTester;
+	}
+
+	public void setDSM(DebugSessionManager dsm)
+	{
+		this.debugSessionManager = dsm;
+	}
+	
+	public void stateChanged(StrategoState state) {
+		//System.out.println("state changed");
+		String name = state.currentFrame().getName();
+		boolean expected = vmStateTester.isNextHit(name);
+		System.out.println("expected: " + expected);
+		String message = "Hit " + name + ", but expected to hit " + vmStateTester.currentHit();
+		Assert.assertTrue(message, expected);
+		String termString = state.currentFrame().getCurrentTerm().toString();
+		System.out.println("current: " + termString);
+		for ( Entry<String, IStrategoTerm> entry : state.currentFrame().getVariables().entrySet() )
+		{
+			System.out.println("variable entry " + entry.getKey() + " # " + entry.getValue());
+		}
+		this.debugSessionManager.resumeVM();
+	}
+
+	public void vmEvent(String event) {
+		System.out.println("vmEvent: " + event);
+		if ("VMDEATH".equals(event))
+		{
+			// vm terminated
+			if (this.vmStateTester.hasNextHit())
+			{
+				Assert.fail("VM has terminated but there are still some expected hits left...");
+			}
+		}
+	}
+}

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/util/dctests/DebugCompileDynamic.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/util/dctests/DebugCompileDynamic.java	Thu Dec  2 13:04:38 2010	(r21441)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/util/dctests/DebugCompileDynamic.java	Thu Dec  2 14:20:44 2010	(r21442)
@@ -14,9 +14,9 @@
 	}
 	
 	public static void testDebugCompileDynamic() {
-		//String inputBase = StrategoFileManager.BASE;
-		String inputFilePath = "src/stratego/dynamic/localvar.str";
-		//String strategoFilePath = inputBase + "/" + inputFilename;
+		String baseInputPath = "src/stratego/dynamic";
+		String strategoFile = "localvar.str";
+
 		String projectName = "dynamic";
 		DebugCompiler debugCompiler = new DebugCompiler(StrategoFileManager.WORKING_DIR);
 		// mkdir localvar/stratego in workingdir
@@ -25,7 +25,8 @@
 		String binBase = null;
 		boolean compileSucces = false;
 		try {
-			binBase = debugCompiler.debugCompile(StrategoFileManager.BASE, inputFilePath, projectName);
+			String strategoSourceBasedir = StrategoFileManager.BASE + "/" + baseInputPath;
+			binBase = debugCompiler.debugCompile(strategoSourceBasedir, strategoFile, projectName);
 			compileSucces = true;
 		} catch (IOException e) {
 			e.printStackTrace();

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/util/dctests/DebugCompileLocalVar.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/util/dctests/DebugCompileLocalVar.java	Thu Dec  2 13:04:38 2010	(r21441)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/util/dctests/DebugCompileLocalVar.java	Thu Dec  2 14:20:44 2010	(r21442)
@@ -17,9 +17,9 @@
 	}
 	
 	public static void testDebugCompileLocalVar() {
-		//String inputBase = StrategoFileManager.BASE;
-		String inputFilePath = "src/stratego/localvar/localvar.str";
-		//String strategoFilePath = inputBase + "/" + inputFilename;
+		String baseInputPath = "src/stratego/localvar";
+		String strategoFile = "localvar.str";
+
 		String projectName = "localvar";
 		DebugCompiler debugCompiler = new DebugCompiler(StrategoFileManager.WORKING_DIR);
 		// mkdir localvar/stratego in workingdir
@@ -28,7 +28,8 @@
 		String binBase = null;
 		boolean compileSucces = false;
 		try {
-			binBase = debugCompiler.debugCompile(StrategoFileManager.BASE, inputFilePath, projectName);
+			String strategoSourceBasedir = StrategoFileManager.BASE + "/" + baseInputPath;
+			binBase = debugCompiler.debugCompile(strategoSourceBasedir, strategoFile, projectName);
 			compileSucces = true;
 		} catch (IOException e) {
 			e.printStackTrace();

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/util/dctests/DebugCompileTestImports.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/util/dctests/DebugCompileTestImports.java	Thu Dec  2 13:04:38 2010	(r21441)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/util/dctests/DebugCompileTestImports.java	Thu Dec  2 14:20:44 2010	(r21442)
@@ -14,9 +14,9 @@
 
 	public static void testDebugCompileTestImports()
 	{
-		//String inputBase = StrategoFileManager.BASE;
-		String inputFilePath = "src/stratego/testimports/localvar.str";
-		//String strategoFilePath = inputBase + "/" + inputFilename;
+		String baseInputPath = "src/stratego/testimports";
+		String strategoFile = "localvar.str";
+
 		String projectName = "testimports";
 		DebugCompiler debugCompiler = new DebugCompiler(StrategoFileManager.WORKING_DIR);
 		// mkdir localvar/stratego in workingdir
@@ -25,7 +25,8 @@
 		String binBase = null;
 		boolean compileSucces = false;
 		try {
-			binBase = debugCompiler.debugCompile(StrategoFileManager.BASE, inputFilePath, projectName);
+			String strategoSourceBasedir = StrategoFileManager.BASE + "/" + baseInputPath;
+			binBase = debugCompiler.debugCompile(strategoSourceBasedir, strategoFile, projectName);
 			compileSucces = true;
 		} catch (IOException e) {
 			e.printStackTrace();
@@ -37,9 +38,9 @@
 		// run .class
 		if (runjava && compileSucces)
 		{
-			String input = StrategoFileManager.BASE + "/src/stratego/dynamic/run.input";
+			String input = StrategoFileManager.BASE + "/src/stratego/testimports/run.input";
 			String argsForMainClass = "-i " + input;
-			String mainClass = "dynamic.dynamic";
+			String mainClass = "testimports.testimports";
 			String mainArgs = mainClass + " " + argsForMainClass;
 			
 			String strategoxtjar = DebugSessionSettings.strategoxtjar;

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/util/dctests/DebugCompilerTest.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/util/dctests/DebugCompilerTest.java	Thu Dec  2 13:04:38 2010	(r21441)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/util/dctests/DebugCompilerTest.java	Thu Dec  2 14:20:44 2010	(r21442)
@@ -15,9 +15,9 @@
 
 	
 	public static void testDebugCompileLocalVarDebug() {
-		//String inputBase = StrategoFileManager.BASE;
-		String inputFilePath = "src/stratego/localvardebug/localvar.str";
-		//String strategoFilePath = inputBase + "/" + inputFilename;
+		String baseInputPath = "src/stratego/localvardebug";
+		String strategoFile = "localvar.str";
+
 		String projectName = "localvardebug";
 		DebugCompiler debugCompiler = new DebugCompiler(StrategoFileManager.WORKING_DIR);
 		// mkdir localvar/stratego in workingdir
@@ -26,7 +26,8 @@
 		String binBase = null;
 		boolean compileSucces = false;
 		try {
-			binBase = debugCompiler.debugCompile(StrategoFileManager.BASE, inputFilePath, projectName);
+			String strategoSourceBasedir = StrategoFileManager.BASE + "/" + baseInputPath;
+			binBase = debugCompiler.debugCompile(strategoSourceBasedir, strategoFile, projectName);
 			compileSucces = true;
 		} catch (IOException e) {
 			e.printStackTrace();

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/util/table/EventTableTest.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/util/table/EventTableTest.java	Thu Dec  2 13:04:38 2010	(r21441)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/util/table/EventTableTest.java	Thu Dec  2 14:20:44 2010	(r21442)
@@ -20,7 +20,7 @@
 	{
 		String location = "working/localvar/stratego/localvar.table";
 		EventTable eventTable = EventTable.readEventTable(location);
-		Assert.assertEquals(46, eventTable.size());
+		Assert.assertEquals(51, eventTable.size());
 		
 		// 31,1 // 0
 		List<EventEntry> entries = countEntries(eventTable, 31, 1, 0);
@@ -29,26 +29,26 @@
 		// 31,2 // 0
 		entries = countEntries(eventTable, 31, 2, 0);
 		
-		// 31,3 // 2 enter/exit
-		entries = countEntries(eventTable, 31, 3, 2);
+		// 31,3 // 3 enter/exit/exit
+		entries = countEntries(eventTable, 31, 3, 3);
 		
-		// 31,4 //  2 enter/exit
-		entries = countEntries(eventTable, 31, 4, 2);
+		// 31,4 //  3 enter/exit/exit
+		entries = countEntries(eventTable, 31, 4, 3);
 		
-		// 32,1 // 2 enter/exit
-		entries = countEntries(eventTable, 32, 1, 2);
+		// 32,1 // 3 enter/exit/exit
+		entries = countEntries(eventTable, 32, 1, 3);
 
-		// 32,2 // 2 enter/exit
-		entries = countEntries(eventTable, 32, 2, 2);
+		// 32,2 // 3 enter/exit/exit
+		entries = countEntries(eventTable, 32, 2, 3);
 
-		// 32,3 // 2 enter/exit
-		entries = countEntries(eventTable, 32, 3, 2);
+		// 32,3 // 3 enter/exit/exit
+		entries = countEntries(eventTable, 32, 3, 3);
 
-		// 32,4 // 2 enter/exit
-		entries = countEntries(eventTable, 32, 4, 2);
+		// 32,4 // 3 enter/exit/exit
+		entries = countEntries(eventTable, 32, 4, 3);
 
-		// 32,5 // 3 enter/exit/step
-		entries = countEntries(eventTable, 32, 5, 3);
+		// 32,5 // 4 enter/exit/exit/step
+		entries = countEntries(eventTable, 32, 5, 4);
 
 		// 43,2 // enter/exit
 		entries = countEntries(eventTable, 43, 2, 2);
@@ -68,7 +68,7 @@
 	
 	private List<EventEntry> countEntries(EventTable eventTable, int linenumber, int token_position, int count)
 	{
-		List<EventEntry> entries = eventTable.getEventEntries(linenumber, token_position);
+		List<EventEntry> entries = eventTable.getEventEntries("localvar.str", linenumber, token_position);
 		Assert.assertEquals(count, entries.size());
 		return entries;
 	}

From r.t.lindeman at student.tudelft.nl  Thu Dec  2 16:19:46 2010
From: r.t.lindeman at student.tudelft.nl (Ricky Lindeman)
Date: Thu, 02 Dec 2010 15:19:46 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21443 - in
	spoofax-imp/trunk/org.strategoxt.imp.debug.core: lib
	src/org/strjdbg/eclipse/core/str/launching
	src/org/strjdbg/eclipse/core/str/model
Message-ID: <201012021519.oB2FJk3u011096@proliant.st.ewi.tudelft.nl>

Author: RickyLindeman
Date: Thu Dec  2 15:19:46 2010
New Revision: 21443
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21443&sc=1

Log:
Eclipse plugin: Implemented debugging a stratego program with imports. (Imports should be in the same package)

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.debug.core/lib/stratego-debug-core.jar
   spoofax-imp/trunk/org.strategoxt.imp.debug.core/lib/stratego-transformer.jar
   spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/launching/StrategoLaunchDelegate.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/StrategoDebugTarget.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.core/lib/stratego-debug-core.jar
==============================================================================
Binary file (source and/or target). No diff available.

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.core/lib/stratego-transformer.jar
==============================================================================
Binary file (source and/or target). No diff available.

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/launching/StrategoLaunchDelegate.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/launching/StrategoLaunchDelegate.java	Thu Dec  2 14:20:44 2010	(r21442)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/launching/StrategoLaunchDelegate.java	Thu Dec  2 15:19:46 2010	(r21443)
@@ -139,7 +139,7 @@
 			else if (mode.equals(ILaunchManager.RUN_MODE))
 			{
 				try {
-					binBase = debugCompiler.runCompile(strategoFilePath, projectName);
+					binBase = debugCompiler.runCompile(strategoSourceBasedir, strategoFilePath, projectName);
 				} catch (IOException e) {
 					// TODO Auto-generated catch block
 					e.printStackTrace();

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/StrategoDebugTarget.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/StrategoDebugTarget.java	Thu Dec  2 14:20:44 2010	(r21442)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/StrategoDebugTarget.java	Thu Dec  2 15:19:46 2010	(r21443)
@@ -1,11 +1,13 @@
 package org.strjdbg.eclipse.core.str.model;
 
+import java.io.File;
 import java.io.IOException;
 import java.util.List;
 import java.util.Map;
 
 import org.eclipse.core.resources.IMarker;
 import org.eclipse.core.resources.IMarkerDelta;
+import org.eclipse.core.resources.IResource;
 import org.eclipse.core.runtime.CoreException;
 import org.eclipse.core.runtime.IPath;
 import org.eclipse.core.runtime.IProgressMonitor;
@@ -319,11 +321,20 @@
 		if (breakpoint.getModelIdentifier().equals(IStrategoConstants.ID_STRATEGO_DEBUG_MODEL)) {
 			try {
 				String program = getLaunch().getLaunchConfiguration().getAttribute(IStrategoConstants.ATTR_STRATEGO_PROGRAM, (String)null);
+				// program-dir = get the dir of the program
+				// library-dirs = get the "-I" paths
+				// the given breakpoint should be a resource in a subdir of program-dir or one of the library-dirs
 				if (program != null) {
 					IMarker marker = breakpoint.getMarker();
 					if (marker != null) {
-						IPath p = new Path(program);
-						return marker.getResource().getFullPath().equals(p);
+						IPath programPath = new Path(program);
+						File parent = programPath.toFile().getParentFile();
+						IPath breakPointPath = marker.getResource().getFullPath();
+						IPath subProjectPath = new Path(parent.getAbsolutePath()); // the dir in which the program is
+						System.out.println("subProjectPath: " + subProjectPath.toOSString());
+						System.out.println("breakPointPath: " + breakPointPath.toOSString());
+						boolean isPrefix = subProjectPath.isPrefixOf(breakPointPath);
+						return isPrefix;
 					}
 				}
 			} catch (CoreException e) {
@@ -409,11 +420,18 @@
 				{
 					// only add the breakpoint to the Stratego debugger when the breakpoint is enabled
 					int linenumber = breakpoint.getMarker().getAttribute(IMarker.LINE_NUMBER, -1);
-					
+					IResource r = breakpoint.getMarker().getResource();
+					//String fullpath = r.getFullPath().toOSString();
+					//System.out.println("Fullpath: " + fullpath);
+					//String location = r.getLocation().toOSString();
+					//System.out.println("Location: " + location);
+					String pRel = r.getProjectRelativePath().toOSString();
+					//System.out.println("ProRel: " + pRel);
+					String filename = pRel;
 					if (linenumber > 0)
 					{
 						// only linenumbers greater than 0 are valid as linenumber is 1-based
-						BreakPoint bp = createBreakpoint(linenumber);
+						BreakPoint bp = createBreakpoint(filename, linenumber);
 						if (bp != null)
 						{
 							this.manager.getEventSpecManager().add(bp);
@@ -428,20 +446,20 @@
 		
 	}
 	
-	private BreakPoint createBreakpoint(int linenumber)
+	private BreakPoint createBreakpoint(String filename, int linenumber)
 	{
 		BreakPoint bp = null;
 		
 		// returns the type of events (s-step/r-enter/s-enter/s-exit/r-exit) can occur at the given linenumber
 		// the event type determines the breakpoint type
-		List<EventEntry> entries = this.manager.getEventSpecManager().getEventTable().getEventEntries(linenumber);
+		List<EventEntry> entries = this.manager.getEventSpecManager().getEventTable().getEventEntries(filename, linenumber);
 
 		// prefer s-step over enter/exit breakpoints
 		EventEntry stepEvent = EventTable.getFirstStepEventEntry(entries);
 		if (stepEvent != null)
 		{
 			//create a step breakpoint
-			bp = new StrategyStepBreakPoint(stepEvent.getStrategyName(), stepEvent.getLocationInfo().getStart_line_num(), stepEvent.getLocationInfo().getStart_token_pos());
+			bp = new StrategyStepBreakPoint(filename, stepEvent.getStrategyName(), stepEvent.getLocationInfo().getStart_line_num(), stepEvent.getLocationInfo().getStart_token_pos());
 		}
 		else
 		{
@@ -455,11 +473,11 @@
 			{
 				if ("s-enter".equals(enterEvent.getEventType()))
 				{
-					bp = new StrategyEnterBreakPoint(enterEvent.getStrategyName(), enterEvent.getLocationInfo().getStart_line_num(), enterEvent.getLocationInfo().getStart_token_pos());
+					bp = new StrategyEnterBreakPoint(filename, enterEvent.getStrategyName(), enterEvent.getLocationInfo().getStart_line_num(), enterEvent.getLocationInfo().getStart_token_pos());
 				}
 				else if ("r-enter".equals(enterEvent.getEventType()))
 				{
-					bp = new RuleEnterBreakPoint(enterEvent.getStrategyName(), enterEvent.getLocationInfo().getStart_line_num(), enterEvent.getLocationInfo().getStart_token_pos());
+					bp = new RuleEnterBreakPoint(filename, enterEvent.getStrategyName(), enterEvent.getLocationInfo().getStart_line_num(), enterEvent.getLocationInfo().getStart_token_pos());
 				}
 				else
 				{
@@ -496,11 +514,13 @@
 			// convert IBreakpoint to Stratego Breakpoint
 
 			int linenumber = breakpoint.getMarker().getAttribute(IMarker.LINE_NUMBER, -1);
-			
+			IResource r = breakpoint.getMarker().getResource();
+			String pRel = r.getProjectRelativePath().toOSString();
+			String filename = pRel;
 			if (linenumber > 0)
 			{
 				// only linenumbers greater than 0 are valid as linenumber is 1-based
-				BreakPoint bp = createBreakpoint(linenumber);
+				BreakPoint bp = createBreakpoint(filename, linenumber);
 				if (bp != null)
 				{
 					this.manager.getEventSpecManager().remove(bp);
@@ -619,6 +639,7 @@
 		// determine which breakpoint was hit, and set the thread's breakpoint
 		//int lineNumber = state.getLocationInfo().getStart_line_num(); // 1-based index // Use the currentFrame
 		int lineNumber = state.currentFrame().getCurrentLocationInfo().getStart_line_num(); // 1-based index
+		String strategoFilename = state.currentFrame().getFilename();
 		
 		IBreakpoint[] breakpoints = DebugPlugin.getDefault().getBreakpointManager().getBreakpoints(IStrategoConstants.ID_STRATEGO_DEBUG_MODEL);
 		for (int i = 0; i < breakpoints.length; i++) {
@@ -628,8 +649,9 @@
 					ILineBreakpoint lineBreakpoint = (ILineBreakpoint) breakpoint;
 					
 					try {
-						
-						if (lineBreakpoint.getLineNumber() == lineNumber) {
+						IResource r = breakpoint.getMarker().getResource();
+						String breakpointPath = r.getProjectRelativePath().toOSString();
+						if (lineBreakpoint.getLineNumber() == lineNumber && strategoFilename.equals(breakpointPath)) {
 							fThread.setBreakpoints(new IBreakpoint[]{breakpoint});
 							break;
 						}

From r.t.lindeman at student.tudelft.nl  Thu Dec  2 17:21:14 2010
From: r.t.lindeman at student.tudelft.nl (Ricky Lindeman)
Date: Thu, 02 Dec 2010 16:21:14 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21444 - in
	spoofax-imp/trunk:
	org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model
	org.strategoxt.imp.debug.ui/src/org/strjdbg/eclipse/ui/str/launching
Message-ID: <201012021621.oB2GLEaJ012206@proliant.st.ewi.tudelft.nl>

Author: RickyLindeman
Date: Thu Dec  2 16:21:14 2010
New Revision: 21444
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21444&sc=1

Log:
Eclipse plugin: implemented basic Run As, Debug As functionality when right clicking on an Editor with a stratego file. (The filename should match an existing LaunchConfiguration)

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/StrategoDebugTarget.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.ui/src/org/strjdbg/eclipse/ui/str/launching/StrategoLaunchShortcut.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/StrategoDebugTarget.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/StrategoDebugTarget.java	Thu Dec  2 15:19:46 2010	(r21443)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/StrategoDebugTarget.java	Thu Dec  2 16:21:14 2010	(r21444)
@@ -329,7 +329,7 @@
 					if (marker != null) {
 						IPath programPath = new Path(program);
 						File parent = programPath.toFile().getParentFile();
-						IPath breakPointPath = marker.getResource().getFullPath();
+						IPath breakPointPath = marker.getResource().getFullPath(); // path to the file in which the breakpoint was set
 						IPath subProjectPath = new Path(parent.getAbsolutePath()); // the dir in which the program is
 						System.out.println("subProjectPath: " + subProjectPath.toOSString());
 						System.out.println("breakPointPath: " + breakPointPath.toOSString());
@@ -337,6 +337,7 @@
 						return isPrefix;
 					}
 				}
+				// TODO: implement -I directories
 			} catch (CoreException e) {
 			}			
 		}
@@ -421,12 +422,7 @@
 					// only add the breakpoint to the Stratego debugger when the breakpoint is enabled
 					int linenumber = breakpoint.getMarker().getAttribute(IMarker.LINE_NUMBER, -1);
 					IResource r = breakpoint.getMarker().getResource();
-					//String fullpath = r.getFullPath().toOSString();
-					//System.out.println("Fullpath: " + fullpath);
-					//String location = r.getLocation().toOSString();
-					//System.out.println("Location: " + location);
 					String pRel = r.getProjectRelativePath().toOSString();
-					//System.out.println("ProRel: " + pRel);
 					String filename = pRel;
 					if (linenumber > 0)
 					{
@@ -512,7 +508,6 @@
 		if (supportsBreakpoint(breakpoint)) {
 
 			// convert IBreakpoint to Stratego Breakpoint
-
 			int linenumber = breakpoint.getMarker().getAttribute(IMarker.LINE_NUMBER, -1);
 			IResource r = breakpoint.getMarker().getResource();
 			String pRel = r.getProjectRelativePath().toOSString();

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.ui/src/org/strjdbg/eclipse/ui/str/launching/StrategoLaunchShortcut.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.ui/src/org/strjdbg/eclipse/ui/str/launching/StrategoLaunchShortcut.java	Thu Dec  2 15:19:46 2010	(r21443)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.ui/src/org/strjdbg/eclipse/ui/str/launching/StrategoLaunchShortcut.java	Thu Dec  2 16:21:14 2010	(r21444)
@@ -1,11 +1,20 @@
 package org.strjdbg.eclipse.ui.str.launching;
 
+import java.util.ArrayList;
+import java.util.List;
+
 import org.eclipse.core.resources.IFile;
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.debug.core.DebugPlugin;
+import org.eclipse.debug.core.ILaunchConfiguration;
+import org.eclipse.debug.core.ILaunchConfigurationType;
+import org.eclipse.debug.core.ILaunchManager;
 import org.eclipse.debug.ui.ILaunchShortcut;
 import org.eclipse.jface.viewers.ISelection;
 import org.eclipse.jface.viewers.IStructuredSelection;
 import org.eclipse.ui.IEditorInput;
 import org.eclipse.ui.IEditorPart;
+import org.strjdbg.eclipse.core.str.launching.IStrategoConstants;
 
 public class StrategoLaunchShortcut implements ILaunchShortcut {
 
@@ -26,7 +35,20 @@
         if (file != null) {
         	System.out.println("File: " + file.getFullPath());
         	// /stratego-resources/src-str/test/localvar/localvar.str
+        	List<ILaunchConfiguration> launchConfigs = searchStrategoLaunchConfigs(file.getFullPath().toOSString(), mode);
+        	if (launchConfigs != null && !launchConfigs.isEmpty())
+        	{
+        		ILaunchConfiguration config = launchConfigs.get(0); // get the first
+        		try {
+					config.launch(mode, null);
+				} catch (CoreException e) {
+					// TODO Auto-generated catch block
+					e.printStackTrace();
+				}
+        	}
         }
+        // lookup an existing launch configuration
+        
 		/*
         IEditorInput input = editor.getEditorInput();
         IJavaElement javaElement = 
@@ -76,5 +98,40 @@
         }*/
     }
     
+    /**
+     * Returns the LaunchConfigurations that are Stratego launch configs and match the strategoProgramPath.
+     * 
+     * @param strategoProgramPath strategoProgramPath points to a stratego program, the path should start with "/{project-name}"
+     */
+    private List<ILaunchConfiguration> searchStrategoLaunchConfigs(String strategoProgramPath, String mode)
+    {
+    	ILaunchManager manager = DebugPlugin.getDefault().getLaunchManager();
+
+		ILaunchConfigurationType type = manager.getLaunchConfigurationType(IStrategoConstants.ID_STRATEGO_DEBUG_MODEL+".launchConfigurationType.str"); // fetch the stratego
+		List<ILaunchConfiguration> launchConfigs = new ArrayList<ILaunchConfiguration>();
+		if (type != null)
+		{
+			// type found!
+			try {
+				ILaunchConfiguration[] configs = manager.getLaunchConfigurations(type);
+				for(ILaunchConfiguration config : configs)
+				{
+					String program = config.getAttribute(IStrategoConstants.ATTR_STRATEGO_PROGRAM, "");
+					// TODO: should we equal on IPath objects instead of Strings?
+					if (program.equals(strategoProgramPath)) 
+					{
+						System.out.println(config.getModes());
+						launchConfigs.add(config);
+					}
+					//System.out.println(program);
+				}
+			} catch (CoreException e) {
+				// TODO Auto-generated catch block
+				e.printStackTrace();
+			}
+		}
+		return launchConfigs;
+    }
+    
     
 }

From g.h.wachsmuth at tudelft.nl  Thu Dec  2 21:14:43 2010
From: g.h.wachsmuth at tudelft.nl (Guido Wachsmuth)
Date: Thu, 02 Dec 2010 20:14:43 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21445 - jasmin-spoofax
Message-ID: <201012022014.oB2KEhSw015619@proliant.st.ewi.tudelft.nl>

Author: GuidoWachsmuth
Date: Thu Dec  2 20:14:43 2010
New Revision: 21445
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21445&sc=1

Log:
Initial import.

Added:
   jasmin-spoofax/

From g.h.wachsmuth at tudelft.nl  Thu Dec  2 21:16:56 2010
From: g.h.wachsmuth at tudelft.nl (Guido Wachsmuth)
Date: Thu, 02 Dec 2010 20:16:56 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21446 - in
	jasmin-spoofax: . .externalToolBuilders META-INF editor
	editor/java editor/java/org editor/java/org/strategoxt
	editor/java/org/strategoxt/spoofax editor/java/or...
Message-ID: <201012022016.oB2KGu4C015639@proliant.st.ewi.tudelft.nl>

Author: GuidoWachsmuth
Date: Thu Dec  2 20:16:56 2010
New Revision: 21446
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21446&sc=1

Log:
Initial import.

Added:
   jasmin-spoofax/.classpath
   jasmin-spoofax/.externalToolBuilders/
   jasmin-spoofax/.externalToolBuilders/JasminXT build.main.xml.launch
   jasmin-spoofax/.project
   jasmin-spoofax/META-INF/
   jasmin-spoofax/META-INF/MANIFEST.MF
   jasmin-spoofax/build.generated.xml
   jasmin-spoofax/build.main.xml
   jasmin-spoofax/build.properties
   jasmin-spoofax/editor/
   jasmin-spoofax/editor/JasminXT-Builders.esv
   jasmin-spoofax/editor/JasminXT-Colorer.esv
   jasmin-spoofax/editor/JasminXT-Completions.esv
   jasmin-spoofax/editor/JasminXT-Folding.esv
   jasmin-spoofax/editor/JasminXT-Outliner.esv
   jasmin-spoofax/editor/JasminXT-References.esv
   jasmin-spoofax/editor/JasminXT-Syntax.esv
   jasmin-spoofax/editor/JasminXT.main.esv
   jasmin-spoofax/editor/java/
   jasmin-spoofax/editor/java/org/
   jasmin-spoofax/editor/java/org/strategoxt/
   jasmin-spoofax/editor/java/org/strategoxt/spoofax/
   jasmin-spoofax/editor/java/org/strategoxt/spoofax/jasminxt/
   jasmin-spoofax/editor/java/org/strategoxt/spoofax/jasminxt/Activator.java
   jasmin-spoofax/editor/java/org/strategoxt/spoofax/jasminxt/JasminXTParseController.java
   jasmin-spoofax/editor/java/org/strategoxt/spoofax/jasminxt/JasminXTValidator.java
   jasmin-spoofax/lib/
   jasmin-spoofax/lib/editor-common.generated.str
   jasmin-spoofax/lib/environment.str
   jasmin-spoofax/lib/namespace.str
   jasmin-spoofax/plugin.xml
   jasmin-spoofax/syntax/
   jasmin-spoofax/syntax/JasminXT-Directives.sdf
   jasmin-spoofax/syntax/JasminXT-Fields.sdf
   jasmin-spoofax/syntax/JasminXT-Header.sdf
   jasmin-spoofax/syntax/JasminXT-Methods.sdf
   jasmin-spoofax/syntax/JasminXT.generated.pp
   jasmin-spoofax/syntax/JasminXT.pp
   jasmin-spoofax/syntax/JasminXT.sdf
   jasmin-spoofax/syntax/instructions/
   jasmin-spoofax/syntax/instructions/JasminXT-Arithmetic.sdf
   jasmin-spoofax/syntax/instructions/JasminXT-Control.sdf
   jasmin-spoofax/syntax/instructions/JasminXT-Conversion.sdf
   jasmin-spoofax/syntax/instructions/JasminXT-Exceptions.sdf
   jasmin-spoofax/syntax/instructions/JasminXT-Instructions.sdf
   jasmin-spoofax/syntax/instructions/JasminXT-LoadStore.sdf
   jasmin-spoofax/syntax/instructions/JasminXT-Methods.sdf
   jasmin-spoofax/syntax/instructions/JasminXT-Objects.sdf
   jasmin-spoofax/syntax/instructions/JasminXT-Stack.sdf
   jasmin-spoofax/syntax/instructions/JasminXT-Synchronisation.sdf
   jasmin-spoofax/syntax/lexical/
   jasmin-spoofax/syntax/lexical/JasminXT-Descriptors.sdf
   jasmin-spoofax/syntax/lexical/JasminXT-Names.sdf
   jasmin-spoofax/syntax/lexical/JasminXT-Numbers.sdf
   jasmin-spoofax/syntax/lexical/JasminXT-Signatures.sdf
   jasmin-spoofax/syntax/lexical/JasminXT-Strings.sdf
   jasmin-spoofax/syntax/lexical/JasminXT-Whitespace.sdf
   jasmin-spoofax/test/
   jasmin-spoofax/test/ANewArray.j
   jasmin-spoofax/test/AnInterface.j
   jasmin-spoofax/test/Arrays.j
   jasmin-spoofax/test/Catch.j
   jasmin-spoofax/test/Checkcast.j
   jasmin-spoofax/test/Count.j
   jasmin-spoofax/test/HelloWeb.j
   jasmin-spoofax/test/HelloWorld.j
   jasmin-spoofax/test/Implementor.j
   jasmin-spoofax/test/InvokeInterface.j
   jasmin-spoofax/test/MultiANewArray.j
   jasmin-spoofax/test/MultiArrays.j
   jasmin-spoofax/test/NewArray.j
   jasmin-spoofax/test/Switch.j
   jasmin-spoofax/test/Uncaught.j
   jasmin-spoofax/test/VerifyTest.j
   jasmin-spoofax/test/VerifyTest1.j
   jasmin-spoofax/trans/
   jasmin-spoofax/trans/analysis/
   jasmin-spoofax/trans/analysis/main.str
   jasmin-spoofax/trans/analysis/names/
   jasmin-spoofax/trans/analysis/names/check.str
   jasmin-spoofax/trans/analysis/names/map.str
   jasmin-spoofax/trans/analysis/names/namespaces.str
   jasmin-spoofax/trans/analysis/names/rename.str
   jasmin-spoofax/trans/editor/
   jasmin-spoofax/trans/editor/resolve.str
   jasmin-spoofax/trans/jasminxt.str
Modified:
   jasmin-spoofax/   (props changed)

Added: jasmin-spoofax/.classpath
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/.classpath	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+
+<classpath>
+	<classpathentry kind="src" excluding="trans/**" path="editor/java"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/J2SE-1.5"/>
+	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
\ No newline at end of file

Added: jasmin-spoofax/.externalToolBuilders/JasminXT build.main.xml.launch
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/.externalToolBuilders/JasminXT build.main.xml.launch	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<launchConfiguration type="org.eclipse.ant.AntLaunchConfigurationType">
+<stringAttribute key="bad_container_name" value=".externalToolBuilders"/>
+<booleanAttribute key="org.eclipse.ant.ui.DEFAULT_VM_INSTALL" value="false"/>
+<listAttribute key="org.eclipse.debug.core.MAPPED_RESOURCE_PATHS"/>
+<listAttribute key="org.eclipse.debug.core.MAPPED_RESOURCE_TYPES"/>
+<booleanAttribute key="org.eclipse.debug.ui.ATTR_LAUNCH_IN_BACKGROUND" value="false"/>
+<listAttribute key="org.eclipse.jdt.launching.CLASSPATH">
+<listEntry value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&#10;&lt;runtimeClasspathEntry containerPath=&quot;org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/java-1.5.0-sun-1.5.0.18&quot; path=&quot;1&quot; type=&quot;4&quot;/&gt;&#10;"/>
+<listEntry value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&#10;&lt;runtimeClasspathEntry id=&quot;org.eclipse.ant.ui.classpathentry.antHome&quot;&gt;&#10;&lt;memento default=&quot;true&quot;/&gt;&#10;&lt;/runtimeClasspathEntry&gt;&#10;"/>
+<listEntry value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&#10;&lt;runtimeClasspathEntry id=&quot;org.eclipse.ant.ui.classpathentry.extraClasspathEntries&quot;&gt;&#10;&lt;memento/&gt;&#10;&lt;/runtimeClasspathEntry&gt;&#10;"/>
+</listAttribute>
+<stringAttribute key="org.eclipse.jdt.launching.CLASSPATH_PROVIDER" value="org.eclipse.ant.ui.AntClasspathProvider"/>
+<booleanAttribute key="org.eclipse.jdt.launching.DEFAULT_CLASSPATH" value="false"/>
+<stringAttribute key="org.eclipse.jdt.launching.PROJECT_ATTR" value=""/>
+<stringAttribute key="org.eclipse.jdt.launching.SOURCE_PATH_PROVIDER" value="org.eclipse.ant.ui.AntClasspathProvider"/>
+<stringAttribute key="org.eclipse.ui.externaltools.ATTR_ANT_TARGETS" value="all,"/>
+<stringAttribute key="org.eclipse.ui.externaltools.ATTR_LAUNCH_CONFIGURATION_BUILD_SCOPE" value="${none}"/>
+<stringAttribute key="org.eclipse.ui.externaltools.ATTR_LOCATION" value="${project_loc}/build.main.xml"/>
+<booleanAttribute key="org.eclipse.ui.externaltools.ATTR_TRIGGERS_CONFIGURED" value="true"/>
+<stringAttribute key="org.eclipse.ui.externaltools.ATTR_WORKING_DIRECTORY" value="${project_loc}"/>
+<stringAttribute key="process_factory_id" value="org.eclipse.ant.ui.remoteAntProcessFactory"/>
+</launchConfiguration>

Added: jasmin-spoofax/.project
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/.project	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,37 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+
+<projectDescription>
+      <name>org.strategoxt.spoofax.jasminxt</name>
+      <comment></comment>
+      <buildSpec>
+		<buildCommand>
+			<name>org.eclipse.ui.externaltools.ExternalToolBuilder</name>
+			<triggers>full,incremental,</triggers>
+			<arguments>
+				<dictionary>
+					<key>LaunchConfigHandle</key>
+					<value>&lt;project&gt;/.externalToolBuilders/JasminXT build.main.xml.launch</value>
+				</dictionary>
+			</arguments>
+		</buildCommand>
+        <buildCommand>
+          <name>org.eclipse.jdt.core.javabuilder</name>
+          <arguments>
+          </arguments>
+        </buildCommand>
+        <buildCommand>
+          <name>org.eclipse.pde.ManifestBuilder</name>
+          <arguments>
+          </arguments>
+        </buildCommand>
+        <buildCommand>
+          <name>org.eclipse.pde.SchemaBuilder</name>
+          <arguments>
+          </arguments>
+        </buildCommand>
+      </buildSpec>
+      <natures>
+        <nature>org.eclipse.pde.PluginNature</nature>
+        <nature>org.eclipse.jdt.core.javanature</nature>
+      </natures>
+    </projectDescription>
\ No newline at end of file

Added: jasmin-spoofax/META-INF/MANIFEST.MF
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/META-INF/MANIFEST.MF	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,21 @@
+Manifest-Version: 1.0
+Bundle-ManifestVersion: 2
+Bundle-Name: JasminXT Plug-in
+Bundle-SymbolicName: org.strategoxt.spoofax.jasminxt; singleton:=true
+Bundle-Version: 1.0.0
+Bundle-Activator: org.strategoxt.spoofax.jasminxt.Activator
+Import-Package: org.osgi.framework;version="1.3.0"
+Require-Bundle: org.eclipse.core.runtime,
+  org.eclipse.core.resources,
+  org.eclipse.imp.runtime,
+  org.eclipse.ui,
+  lpg.runtime,
+  org.eclipse.jface.text,
+  org.eclipse.ui.editors,
+  org.eclipse.ui.workbench.texteditor,
+  org.strategoxt.imp.runtime,
+  org.spoofax.aterm,
+  org.spoofax.jsglr
+Bundle-RequiredExecutionEnvironment: J2SE-1.5
+Bundle-ActivationPolicy: lazy
+Export-Package: org.strategoxt.spoofax.jasminxt

Added: jasmin-spoofax/build.generated.xml
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/build.generated.xml	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,425 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+
+<project name="build.generated">
+
+        <target name="spoofaximp.default" depends="spoofaximp.default.ctree"/>
+        <target name="spoofaximp.default.ctree" depends="check-classpath,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.ctree,sdf2imp,refresh"/>
+        <target name="spoofaximp.default.jar" depends="check-classpath,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.jar,  sdf2imp,refresh"/>
+    
+        <!-- Initialization -->
+        <available file="${trans}/${strmodule}.str" property="build.stratego.enabled"/>
+        <dirname property="externaldefdir" file="${externaldef}"/>
+        <condition property="externaldefimport" value="-I ${externaldefdir}" else="">
+            <isset property="externaldef"/>
+        </condition>
+        <condition property="externaljarimport" value=":${externaljar}" else="">
+            <isset property="externaljar"/>
+        </condition>
+        <condition property="build.compiler" value="org.eclipse.jdt.core.JDTCompilerAdapter">
+            <isset property="eclipse.running"/>
+        </condition>
+        <condition property="externaljarflags" value="${externaljarflags}" else="">
+            <isset property="externaljarflags"/>
+        </condition>
+        <condition property="metasdfmodule.available" value="1">
+            <available file="${syntax}/${metasdfmodule}.sdf"/>
+        </condition>
+        <mkdir dir="${build}"/>
+        <mkdir dir="${src-gen}"/>
+        <mkdir dir="${dist}"/>
+        <mkdir dir="${include}"/>
+        <mkdir dir="${lib}"/>
+        <mkdir dir="${syntax}"/>
+
+        <target name="sdf2imp" depends="sdf2table,sdf2imp.eclipse,sdf2imp.standalone"/>
+        
+        <target name="sdf2imp.eclipse" if="eclipse.running" depends="sdf2rtg">
+            <java classname="org.strategoxt.imp.metatooling.building.AntDescriptorBuilder" failonerror="true">
+                <arg value="${include}/${esvmodule}.packed.esv"/>
+            </java>
+        </target>
+        
+        <target name="refresh" if="eclipse.running">
+            <eclipse.convertPath fileSystemPath="${basedir}" property="projectdir"/>
+            <eclipse.refreshLocal resource="${projectdir}/lib" depth="infinite"/>
+            <eclipse.refreshLocal resource="${projectdir}/syntax/${sdfmodule}.pp.generated" depth="infinite"/>
+            <eclipse.refreshLocal resource="${projectdir}/lib/editor-common.generated.str" depth="infinite"/>
+            <eclipse.refreshLocal resource="${projectdir}/build.generated.xml" depth="infinite"/>
+            <eclipse.refreshLocal resource="${projectdir}/editor/${sdfmodule}-Builders.generated.esv" depth="infinite"/>
+            <eclipse.refreshLocal resource="${projectdir}/editor/${sdfmodule}-Colorer.generated.esv" depth="infinite"/>
+            <eclipse.refreshLocal resource="${projectdir}/editor/${sdfmodule}-Completions.generated.esv" depth="infinite"/>
+            <eclipse.refreshLocal resource="${projectdir}/editor/${sdfmodule}-Folding.generated.esv" depth="infinite"/>
+            <eclipse.refreshLocal resource="${projectdir}/editor/${sdfmodule}-References.generated.esv" depth="infinite"/>
+            <eclipse.refreshLocal resource="${projectdir}/editor/${sdfmodule}-Syntax.generated.esv" depth="infinite"/>
+            <eclipse.convertPath fileSystemPath="${src-gen}" property="eclipse.path.src-gen"/>
+            <eclipse.refreshLocal resource="${eclipse.path.src-gen}" depth="infinite"/>
+            <eclipse.convertPath fileSystemPath="${build}" property="eclipse.path.build"/>
+            <eclipse.refreshLocal resource="${eclipse.path.build}" depth="infinite"/>
+            <!-- Might cause the editor to be reloaded?
+            <eclipse.refreshLocal resource="${projectdir}/include" depth="infinite" />
+            -->
+        </target>
+        
+        <target name="sdf2imp.standalone" unless="eclipse.running" depends="sdf2rtg">
+            <java classname="org.strategoxt.imp.generator.sdf2imp" failonerror="true">
+                <arg value="-i"/>
+                <arg value="${basedir}/editor/${esvmodule}.main.esv"/>
+                <arg value="-p"/>
+                <arg value="${include}/${sdfmodule}.tbl"/>
+            </java>
+        </target>
+        
+        <target name="check-classpath">
+            <available classname="org.strategoxt.imp.generator.sdf2imp" property="check-classpath.available"/>
+            <antcall target="check-classpath.helper"/>  
+        </target>
+  
+        <target name="check-classpath.helper" unless="check-classpath.available">
+            <echo level="error" message="Could not load the Spoofax plugin loading classes."/>
+            <echo level="error" message="Make sure it is on the class path."/>
+            <echo level="error" message=""/>               
+            <echo level="error" message="In Eclipse, make sure the Ant builder is configured properly:"/>
+            <echo level="error" message="right-click on build.main.xml, go to Run as, Ant build..., JRE tab,"/>
+            <echo level="error" message="and ensure Run in the same JRE as the workspace is selected"/>
+            <echo level="error" message="alternatively, build the project using Build Project in the Project menu"/>
+            <fail/>
+        </target>
+    
+        <target name="sdf2table" depends="make-permissive">
+            <apply executable="${build.strategoxt.sdf}sdf2table" dest="${include}" failonerror="true">
+                <arg value="-i"/>
+                <srcfile/>
+                <arg value="-o"/>
+                <targetfile/>
+                <arg value="-m"/>
+                <arg value="${sdfmodule}"/>
+                
+                <fileset file="${include}/${sdfmodule}-Permissive.def"/>
+                <mapper type="glob" from="*-Permissive.def" to="*.tbl"/>
+            </apply>
+        </target>
+        
+        <target name="meta-sdf2table" if="metasdfmodule.available">
+            <fail unless="eclipse.spoofaximp.jars" message="Property eclipse.spoofaximp.jars must point to the directory containing StrategoMix.def"/>
+            <antcall target="sdf2table">
+                <param name="sdfmodule" value="${metasdfmodule}"/>
+                <param name="build.sdf.imports" value="-Idef &quot;${eclipse.spoofaximp.jars}/StrategoMix.def&quot; ${build.sdf.imports}"/>
+            </antcall>
+            <antcall target="meta-sdf2table.helper"/>
+        </target>
+        
+        <target name="meta-sdf2table.helper" if="eclipse.running">
+           <eclipse.convertPath fileSystemPath="${include}" property="includeresource"/>
+           <eclipse.refreshLocal resource="${includeresource}/${metasdfmodule}.tbl" depth="infinite"/>
+        </target>
+        
+        <target name="make-permissive" depends="pack-sdf,copy-sdf">
+            <dependset>
+                <srcfileset file="${include}/${sdfmodule}.def"/>
+                <targetfileset file="${include}/${sdfmodule}-Permissive.def"/>
+            </dependset>
+            <available file="${include}/${sdfmodule}-Permissive.def" property="permissive-grammar.available"/>
+            <antcall target="make-permissive.helper"/>
+        </target>
+    
+        <target name="make-permissive.helper" unless="permissive-grammar.available">
+            <java classname="org.strategoxt.permissivegrammars.make_permissive" failonerror="true">
+                <arg value="-i"/>
+                <arg value="${include}/${sdfmodule}.def"/>
+                <arg value="-o"/>
+                <arg value="${include}/${sdfmodule}-Permissive.def"/>
+                <arg line="--optimize on"/>
+            </java>
+        </target>
+
+        <target name="utils-files"> <!-- only useful for builds outside of Eclipse -->
+            <mkdir dir="utils"/>
+            <copy file="${eclipse.spoofaximp.jars}/make_permissive.jar" todir="utils" failonerror="false"/>
+            <copy file="${eclipse.spoofaximp.jars}/sdf2imp.jar" todir="utils" failonerror="false"/>
+            <copy file="${eclipse.spoofaximp.jars}/aster.jar" todir="utils" failonerror="false"/>
+            <copy file="${eclipse.spoofaximp.strategojar}" todir="utils" failonerror="false"/>
+        </target>
+    
+        <target name="pack-sdf" unless="externaldef">
+            <dependset>
+                <srcfileset dir="${syntax}">
+                    <include name="**/*.sdf"/>
+                </srcfileset>
+                <targetfileset file="${include}/${sdfmodule}.def"/>
+            </dependset>
+            <available file="${include}/${sdfmodule}.def" property="pack-sdf.available"/>
+            <antcall target="pack-sdf.helper"/>
+        </target>
+    
+        <target name="pack-sdf.helper" unless="pack-sdf.available">
+            <condition property="utils-include" value="-I ${utils}" else="">
+                <available file="${utils}"/>
+            </condition>
+            <java classname="run" failonerror="true">
+                <arg value="org.strategoxt.tools.main-pack-sdf"/>
+                <arg value="-i"/>
+                <arg value="${syntax}/${sdfmodule}.sdf"/>
+                <arg value="-o"/>
+                <arg value="${include}/${sdfmodule}.def"/>
+                <arg value="-I"/>
+                <arg value="${syntax}"/>
+                <arg value="-I"/>
+                <arg value="${lib}"/>
+                <arg line="${utils-include}"/>
+                <arg line="${build.sdf.imports}"/>
+            </java>
+        </target>
+    
+        <target name="copy-sdf" if="externaldef">
+            <copy file="${externaldef}" tofile="${include}/${sdfmodule}.def" preservelastmodified="true"/>
+        </target>
+    
+        <target name="copy-jar" if="externaljar">
+            <copy file="${externaljar}" todir="${include}" preservelastmodified="true"/>
+        </target>
+    
+        <target name="rtg2sig" if="build.stratego.enabled" depends="sdf2rtg">
+            <dependset>
+                <srcfileset file="${include}/${sdfmodule}.rtg"/>
+                <targetfileset file="${include}/${sdfmodule}.str"/>
+            </dependset>
+            <available file="${include}/${sdfmodule}.str" property="rtg2sig.available"/>
+            <antcall target="rtg2sig.helper"/>
+        </target>
+    
+        <target name="rtg2sig.helper" unless="rtg2sig.available">
+            <java classname="run" failonerror="true">
+                <arg value="org.strategoxt.tools.main-rtg2sig"/>
+                <arg value="-i"/>
+                <arg value="${include}/${sdfmodule}.rtg"/>
+                <arg value="-o"/>
+                <arg value="${include}/${sdfmodule}.str"/>
+                <arg value="--module"/>
+                <arg value="${sdfmodule}"/>
+            </java>
+        </target>
+        
+        <target name="sdf2rtg" depends="pack-sdf,copy-sdf">
+            <dependset>
+                <srcfileset file="${include}/${sdfmodule}.def"/>
+                <targetfileset file="${include}/${sdfmodule}.rtg"/>
+            </dependset>
+            <available file="${include}/${sdfmodule}.rtg" property="sdf2rtg.available"/>
+            <antcall target="sdf2rtg.helper"/>
+        </target>
+    
+        <target name="sdf2rtg.helper" unless="sdf2rtg.available">
+            <java classname="run" failonerror="true">
+                <arg value="org.strategoxt.tools.main-sdf2rtg"/>
+                <arg value="-i"/>
+                <arg value="${include}/${sdfmodule}.def"/>
+                <arg value="-m"/>
+                <arg value="${sdfmodule}"/>
+                <arg value="-o"/>
+                <arg value="${include}/${sdfmodule}.rtg"/>
+                <arg value="--ignore-missing-cons"/>
+                <arg value="-Xnativepath"/>
+                <arg value="${build.strategoxt.sdf}"/>
+            </java>
+        </target>
+        
+        <target name="ppgen" if="build.stratego.enabled" depends="pack-sdf">
+            <dependset>
+                <srcfileset file="${include}/${sdfmodule}.def"/>
+                <targetfileset file="${syntax}/${sdfmodule}.generated.pp"/>
+                <targetfileset file="${include}/${sdfmodule}.generated.pp.af"/>
+            </dependset>
+            <available file="${include}/${sdfmodule}.generated.pp.af" property="ppgen.available"/>
+            <antcall target="ppgen.helper"/>
+            <available file="${include}/${sdfmodule}.generated.pp.af" property="ppgen.available"/>
+            <antcall target="ppgen.helper.fallback"/>
+        </target>
+    
+        <target name="ppgen.helper" unless="ppgen.available">
+            <!-- Any failures here are ignored; they are only a problem when imported from Stratego -->
+            <java classname="run" failonerror="false">
+                <arg value="org.strategoxt.tools.main-ppgen"/>
+                <arg value="-i"/>
+                <arg value="${include}/${sdfmodule}.def"/>
+                <arg value="-o"/>
+                <arg value="${include}/${sdfmodule}.generated.pp.af"/>
+                <arg value="-t"/>
+            </java>
+            <java classname="run" failonerror="false">
+                <arg value="org.strategoxt.tools.main-pp-pp-table"/>
+                <arg value="-i"/>
+                <arg value="${include}/${sdfmodule}.generated.pp.af"/>
+                <arg value="-o"/>
+                <arg value="${syntax}/${sdfmodule}.generated.pp"/>
+            </java>
+        </target>
+    
+        <target name="ppgen.helper.fallback" unless="ppgen.available">
+            <echo file="${include}/${sdfmodule}.generated.pp.af" message="PP-Table([])"/>
+        </target>
+        
+        <target name="pppack" if="build.stratego.enabled" depends="pack-sdf">
+            <dependset>
+                <srcfileset file="${syntax}/${sdfmodule}.pp"/>
+                <targetfileset file="${include}/${sdfmodule}.pp.af"/>
+            </dependset>
+            <available file="${syntax}/${sdfmodule}.pp" property="pppack.source-available"/>
+            <available file="${include}/${sdfmodule}.pp.af" property="pppack.available"/>
+            <antcall target="pppack.helper"/>
+            <available file="${include}/${sdfmodule}.pp.af" property="pppack.available"/>
+            <antcall target="pppack.helper.fallback"/>
+        </target>
+    
+        <target name="pppack.helper" unless="pppack.available" if="pppack.source-available">
+            <java classname="run" failonerror="true">
+                <arg value="org.strategoxt.tools.main-parse-pp-table"/>
+                <arg value="-i"/>
+                <arg value="${syntax}/${sdfmodule}.pp"/>
+                <arg value="-o"/>
+                <arg value="${include}/${sdfmodule}.pp.af"/>
+            </java>
+        </target>
+    
+        <target name="pppack.helper.fallback" unless="pppack.available">
+            <echo file="${include}/${sdfmodule}.pp.af" message="PP-Table([])"/>
+        </target>
+    
+        <!-- Aster to Stratego -->
+        <target name="stratego.aster">
+            <available file="${trans}/${strmodule}.rtree" property="aster-output.available"/>
+            <pathconvert property="aster-input" setonempty="false" pathsep=" ">
+                <path><fileset dir="${basedir}" includes="*.astr"/></path>
+            </pathconvert>
+            <dependset>
+                <srcfileset dir="${basedir}">
+                    <include name="**/*.astr"/>
+                </srcfileset>
+                <targetfileset file="${trans}/${strmodule}.rtree"/>
+            </dependset>
+            <condition property="aster-output.uptodate">
+                <and>
+                    <isset property="aster-output.available"/>
+                    <available file="${trans}/${strmodule}.rtree"/>
+                </and>
+            </condition>
+            <available file="${trans}/${strmodule}.rtree" property="aster-output.uptodate"/>
+            <antcall target="stratego.aster.helper"/>
+        </target>
+    
+        <target name="stratego.aster.helper" if="aster-input" unless="aster-output.uptodate">
+            <java classname="org.strategoxt.aster.Main" failonerror="true">
+                <arg value="-i"/>
+                <fileset dir="${basedir}">
+                    <include name="**/*.astr"/>
+                </fileset>
+            </java>
+        </target>
+    
+        <!-- Stratego to Java interpreter -->
+        <target name="stratego.ctree" depends="rtg2sig">
+            <dependset>
+                <srcfileset dir="${basedir}">
+                    <include name="**/*.str"/>
+                    <include name="**/*.astr"/>
+                    <exclude name="lib/editor-common.generated.str"/>
+                </srcfileset>
+                <targetfileset file="${include}/${strmodule}.ctree"/>
+            </dependset>
+            <available file="${include}/${strmodule}.ctree" property="strc-java.available"/>
+            <antcall target="copy-jar"/>
+            <antcall target="stratego.jvm.helper">
+                <param name="build.stratego.outputpath" value="${include}"/>
+                <param name="build.stratego.extraargs" value="-F"/>
+                <param name="build.stratego.extension" value="ctree"/>
+                <param name="build.stratego.compiler" value="strc"/>
+            </antcall>
+        </target>
+    
+        <!-- Stratego to Java compiler -->
+        <target name="stratego.jar" depends="rtg2sig,utils-files">
+            <dependset>
+                <srcfileset dir="${basedir}">
+                    <include name="**/*.str"/>
+                    <include name="**/*.astr"/>
+                    <exclude name="lib/editor-common.generated.str"/>
+                </srcfileset>
+                <targetfileset file="${src-gen}/trans/Main.java"/>
+            </dependset>
+            <available file="${src-gen}/trans/Main.java" property="strc-java.available"/>
+            <antcall target="copy-jar"/>
+            <antcall target="stratego.jar.deletehelper"/>
+            <antcall target="stratego.jvm.helper">
+                <param name="build.stratego.outputpath" value="${src-gen}/trans"/>
+                <param name="build.stratego.extraargs" value="-la java-front"/>
+                <param name="build.stratego.extension" value="java"/>
+            </antcall>
+            <javac classpath="utils/strategoxt.jar:${src-gen}${externaljarimport}" srcdir="${src-gen}" includes="trans/**" destdir="${build}" source="1.5" target="1.5" debug="on"/>
+            <!-- copy imported terms -->
+            <copy todir="${build}/trans">
+                <fileset dir="${src-gen}/trans" excludes="**/*.java"/>
+            </copy>
+            <jar basedir="${build}" includes="trans/**" destfile="${include}/${strmodule}.tmp.jar"/>
+            <move file="${include}/${strmodule}.tmp.jar" tofile="${include}/${strmodule}.jar"/>
+            <delete><fileset dir="${build}" includes="trans/**"/></delete>
+        </target>
+        
+        <target name="stratego.jar.deletehelper" unless="strc-java.available">
+            <delete>
+                <fileset dir="${src-gen}" includes="trans/**"/>
+                <fileset dir="${build}" includes="trans/**"/>
+            </delete>
+        </target>
+            
+        <target name="stratego.jvm.helper" unless="strc-java.available" if="build.stratego.enabled">
+            <delete file="${include}/${strmodule}.rtree" failonerror="false"/>
+            <java classname="org.strategoxt.strj.Main" failonerror="true">
+                <arg value="-i"/>
+                <arg value="${trans}/${strmodule}.str"/>
+                <arg value="-o"/>
+                <arg value="${build.stratego.outputpath}/${strmodule}.${build.stratego.extension}"/>
+                <arg value="-p"/>
+                <arg value="trans"/>
+                <arg value="--library"/>
+                <arg value="--clean"/>
+                <arg line="${build.stratego.args}"/>
+                <arg line="${build.stratego.extraargs}"/>
+                <arg line="${externaljarflags}"/>
+                <arg line="${externaldefimport}"/>
+                <arg line="-I &quot;${lib}&quot; -I &quot;${include}&quot;  --cache-dir &quot;${basedir}/.cache&quot;"/>
+            </java>
+            <delete file="${include}/${strmodule}.rtree" failonerror="false"/>
+            <mkdir dir="${build}/trans"/>
+        </target>
+                
+        <!-- Stratego to C-based native executable -->
+        <target name="stratego.c">
+            <antcall target="stratego.c.helper">
+                <param name="build.stratego.outputpath" value="${basedir}/include"/>
+                <param name="build.stratego.extraargs" value=""/>
+                <param name="build.stratego.extension" value=""/>
+                <param name="build.stratego.compiler" value="strc"/>
+            </antcall>
+        </target>
+        
+        <!-- Helper target for calling the stratego compiler -->
+        <target name="stratego.c.helper" depends="rtg2sig" if="build.stratego.enabled">
+            <apply executable="${build.strategoxt.stratego}/${build.stratego.compiler}" dest="${build.stratego.outputpath}" failonerror="true">
+                <arg value="-i"/>
+                <srcfile/>
+                <arg value="-o"/>
+                <targetfile/>
+                <arg line="${build.stratego.args}"/>
+                <arg line="${build.stratego.extraargs}"/>
+                <arg line="${externaldefimport}"/>
+                <arg line="-I &quot;${lib}&quot; --cache-dir &quot;${basedir}/.cache&quot;"/>
+                
+                <fileset file="${trans}/${strmodule}.str"/>
+                <mapper type="glob" from="*.str" to="*.${build.stratego.extension}"/>
+            </apply>
+        </target>
+        
+        <target name="clean" description="clean up">
+            <delete dir="${build}"/>
+            <delete file="${src-gen}/trans/Main.java"/>
+        </target>
+    </project>
\ No newline at end of file

Added: jasmin-spoofax/build.main.xml
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/build.main.xml	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,44 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+
+<project name="JasminXT" default="all">
+        
+        <!-- Key input modules -->
+        <property name="sdfmodule" value="JasminXT"/>
+        <property name="metasdfmodule" value="Stratego-JasminXT"/>
+        <property name="esvmodule" value="JasminXT"/>
+        <property name="strmodule" value="jasminxt"/>
+    
+        <!-- Project directories -->
+        <property name="trans" location="trans"/>
+        <property name="src-gen" location="editor/java"/>
+        <property name="syntax" location="syntax"/>
+        <property name="include" location="include"/>
+        <property name="lib" location="lib"/>
+        <property name="build" location="bin"/>
+        <property name="dist" location="bin/dist"/>
+        
+        <!-- Imports -->
+        <property name="build.sdf.imports" value=""/>
+        <property name="build.stratego.args" value="
+                        --library
+                        -I &quot;${trans}&quot;
+                        -I &quot;${basedir}&quot;
+                        -la stratego-lib -la stratego-sglr -la stratego-gpp -la stratego-xtc -la stratego-aterm"/>
+        
+        <!-- External .def and .jar locations
+        <property name="externaldef" location="syntax/${sdfmodule}.def"/>
+        <property name="externaljar" value="../lib.jar"/>
+        <property name="externaljarflags" value="-la org.lib"/>
+        -->
+    
+        <!-- Environment configuration for command-line builds -->
+        <condition property="build.strategoxt.sdf" value="${eclipse.spoofaximp.nativeprefix}" else="">
+            <isset property="eclipse.spoofaximp.nativeprefix"/>
+        </condition>
+        <property name="build.strategoxt.stratego" location="${user.home}/.nix-profile/bin"/>
+    
+        <import file="build.generated.xml"/>
+    
+        <!-- Main target -->
+        <target name="all" depends="spoofaximp.default.ctree"/>
+    </project>
\ No newline at end of file

Added: jasmin-spoofax/build.properties
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/build.properties	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,8 @@
+source.. = editor/java/
+output.. = bin/
+bin.includes = META-INF/,\
+               plugin.xml,\
+               include/,\
+               bin/,\
+               lib/,\
+               .

Added: jasmin-spoofax/editor/JasminXT-Builders.esv
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/editor/JasminXT-Builders.esv	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,19 @@
+
+module JasminXT-Builders
+
+imports JasminXT-Builders.generated
+
+builders
+                                                                      
+  // This file can be used for custom analysis and builder rules.     
+  //                                                                  
+  // See the imported file for a brief introduction and examples.     
+
+builders
+                                                                                                                               
+  provider                  : include/jasminxt.ctree                                                                           
+                                                                                                                               
+  observer                  : editor-analyse                                                                                   
+                                                                                                                               
+  builder                   : "Show abstract syntax (for selection)" = generate-aterm (openeditor) (realtime) (meta) (source)  
+                                                                                                                               
\ No newline at end of file

Added: jasmin-spoofax/editor/JasminXT-Colorer.esv
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/editor/JasminXT-Colorer.esv	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,12 @@
+module JasminXT-Colorer
+
+imports JasminXT-Colorer.generated
+
+colorer
+                                                                      
+  // This file can be used for custom colorer rules.                  
+  //                                                                  
+  // See the imported file for a brief introduction and examples.     
+  
+  Instruction: 0 0 128 bold
+  
\ No newline at end of file

Added: jasmin-spoofax/editor/JasminXT-Completions.esv
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/editor/JasminXT-Completions.esv	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,11 @@
+module JasminXT-Completions
+
+imports JasminXT-Completions.generated
+
+completions
+                                                                   
+  // This file is used to define content completion.               
+  //                                                               
+  // See the imported file for a brief introduction and examples.  
+                                                                   
+

Added: jasmin-spoofax/editor/JasminXT-Folding.esv
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/editor/JasminXT-Folding.esv	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,9 @@
+module JasminXT-Folding
+
+imports JasminXT-Folding.generated
+
+folding
+  
+  // This file can be used for custom folding rules.
+  //
+  // See the imported file for a brief introduction and examples.
\ No newline at end of file

Added: jasmin-spoofax/editor/JasminXT-Outliner.esv
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/editor/JasminXT-Outliner.esv	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,9 @@
+module JasminXT-Outliner
+
+imports JasminXT-Outliner.generated
+
+outliner
+  
+  // This file can be used for custom outliner rules.
+  //
+  // See the imported file for a brief introduction and examples.
\ No newline at end of file

Added: jasmin-spoofax/editor/JasminXT-References.esv
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/editor/JasminXT-References.esv	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,8 @@
+module JasminXT-References
+
+imports JasminXT-References.generated
+
+references
+
+	reference _ : editor-resolve                                     
+ 
\ No newline at end of file

Added: jasmin-spoofax/editor/JasminXT-Syntax.esv
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/editor/JasminXT-Syntax.esv	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,9 @@
+module JasminXT-Syntax
+
+imports JasminXT-Syntax.generated
+
+language
+                                                                   
+  // This file can be used for custom syntax rules.                
+  //                                                               
+  // See the imported file for a brief introduction and examples.  
\ No newline at end of file

Added: jasmin-spoofax/editor/JasminXT.main.esv
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/editor/JasminXT.main.esv	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,16 @@
+module JasminXT.main
+
+imports JasminXT-Builders JasminXT-Colorer JasminXT-Completions JasminXT-Folding JasminXT-Outliner JasminXT-References JasminXT-Syntax
+
+language General properties
+                  
+  name          : JasminXT
+  id            : org.strategoxt.spoofax.jasminxt
+  extends       : Root
+                  
+  description   : "Spoofax/IMP-generated editor for the JasminXT language"
+  url           : http://strategoxt.org
+                  
+  extensions    : j
+  table         : include/JasminXT.tbl
+  start symbols : Start
\ No newline at end of file

Added: jasmin-spoofax/editor/java/org/strategoxt/spoofax/jasminxt/Activator.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/editor/java/org/strategoxt/spoofax/jasminxt/Activator.java	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,44 @@
+package org.strategoxt.spoofax.jasminxt;
+
+import org.eclipse.imp.preferences.PreferencesService;
+import org.eclipse.imp.runtime.PluginBase;
+import org.osgi.framework.BundleContext;
+
+public class Activator extends PluginBase 
+{ 
+  public static final String kPluginID = "JasminXT";
+
+  public static final String kLanguageName = "JasminXT";
+
+  protected static Activator sPlugin;
+
+  public static Activator getInstance()
+  { 
+    if(sPlugin == null)
+      return new Activator();
+    return sPlugin;
+  }
+
+  public Activator () 
+  { 
+    super();
+    sPlugin = this;
+  }
+
+  @Override public void start(BundleContext context) throws Exception
+  { 
+    super.start(context);
+  }
+
+  @Override public String getID()
+  { 
+    return kPluginID;
+  }
+
+  @Override public String getLanguageID()
+  { 
+    return kLanguageName;
+  }
+
+  protected static PreferencesService preferencesService = null;
+}
\ No newline at end of file

Added: jasmin-spoofax/editor/java/org/strategoxt/spoofax/jasminxt/JasminXTParseController.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/editor/java/org/strategoxt/spoofax/jasminxt/JasminXTParseController.java	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,89 @@
+package org.strategoxt.spoofax.jasminxt;
+
+import java.io.InputStream;
+import java.io.IOException;
+import org.eclipse.imp.parser.IParseController;
+import org.strategoxt.imp.runtime.Environment;
+import org.strategoxt.imp.runtime.dynamicloading.BadDescriptorException;
+import org.strategoxt.imp.runtime.dynamicloading.Descriptor;
+import org.strategoxt.imp.runtime.dynamicloading.DescriptorFactory;
+import org.strategoxt.imp.runtime.dynamicloading.DynamicParseController;
+
+public class JasminXTParseController extends DynamicParseController 
+{ 
+  public static final String LANGUAGE = new String("JasminXT");
+
+  private static final String TABLE = "/include/" + LANGUAGE + ".tbl";
+
+  private static final String DESCRIPTOR = "/include/" + LANGUAGE + ".packed.esv";
+
+  private static volatile Descriptor descriptor;
+
+  private static Throwable notLoadingCause;
+
+  public static synchronized Descriptor getDescriptor()
+  { 
+    if(notLoadingCause != null)
+      throw new RuntimeException(notLoadingCause);
+    if(descriptor == null)
+      createDescriptor();
+    return descriptor;
+  }
+
+  private static void createDescriptor()
+  { 
+    try
+    { 
+      InputStream descriptorStream = JasminXTParseController.class.getResourceAsStream(DESCRIPTOR);
+      InputStream table = JasminXTParseController.class.getResourceAsStream(TABLE);
+      if(descriptorStream == null)
+        throw new BadDescriptorException("Could not load descriptor file from " + DESCRIPTOR + " (not found in plugin: " + getPluginLocation() + ")");
+      if(table == null)
+        throw new BadDescriptorException("Could not load parse table from " + TABLE + " (not found in plugin: " + getPluginLocation() + ")");
+      descriptor = DescriptorFactory.load(descriptorStream, table, null);
+      descriptor.setAttachmentProvider(JasminXTParseController.class);
+    }
+    catch(BadDescriptorException exc)
+    { 
+      notLoadingCause = exc;
+      Environment.logException("Bad descriptor for " + LANGUAGE + " plugin", exc);
+      throw new RuntimeException("Bad descriptor for " + LANGUAGE + " plugin", exc);
+    }
+    catch(IOException exc)
+    { 
+      notLoadingCause = exc;
+      Environment.logException("I/O problem loading descriptor for " + LANGUAGE + " plugin", exc);
+      throw new RuntimeException("I/O problem loading descriptor for " + LANGUAGE + " plugin", exc);
+    }
+  }
+
+  private static String getPluginLocation()
+  { 
+    return JasminXTParseController.class.getProtectionDomain().getCodeSource().getLocation().getFile();
+  }
+
+  @Override public IParseController getWrapped()
+  { 
+    if(!isInitialized())
+    { 
+      if(notLoadingCause != null)
+        throw new RuntimeException(notLoadingCause);
+      try
+      { 
+        initialize(this, getDescriptor().getLanguage());
+      }
+      catch(BadDescriptorException exc)
+      { 
+        notLoadingCause = exc;
+        throw new RuntimeException(exc);
+      }
+    }
+    return super.getWrapped();
+  }
+
+  @Override protected void setNotLoadingCause(Throwable value)
+  { 
+    notLoadingCause = value;
+    super.setNotLoadingCause(value);
+  }
+}
\ No newline at end of file

Added: jasmin-spoofax/editor/java/org/strategoxt/spoofax/jasminxt/JasminXTValidator.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/editor/java/org/strategoxt/spoofax/jasminxt/JasminXTValidator.java	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,12 @@
+package org.strategoxt.spoofax.jasminxt;
+
+import org.strategoxt.imp.runtime.dynamicloading.Descriptor;
+import org.strategoxt.imp.runtime.services.MetaFileLanguageValidator;
+
+public class JasminXTValidator extends MetaFileLanguageValidator 
+{ 
+  @Override public Descriptor getDescriptor()
+  { 
+    return JasminXTParseController.getDescriptor();
+  }
+}
\ No newline at end of file

Added: jasmin-spoofax/lib/editor-common.generated.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/lib/editor-common.generated.str	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,252 @@
+module lib/editor-common.generated
+
+imports
+  libstratego-lib
+  libstratego-sglr
+  libstratego-gpp
+
+strategies
+
+  parse-file = parse-jasminxt-file
+  parse-jasminxt-file =
+    parse-file(
+      strsglr-perror, strsglr-report-parse-error
+    | <import-term(include/JasminXT.tbl)>
+    )
+
+  parse-string = parse-jasminxt-string
+  parse-jasminxt-string =
+    parse-string(
+      strsglr-report-parse-error
+    | <import-term(include/JasminXT.tbl)>
+    )
+  
+  parse-stream = parse-jasminxt-stream
+  parse-jasminxt-stream =
+    parse-stream(
+      strsglr-report-parse-error
+    | <import-term(include/JasminXT.tbl)>
+    )
+
+  pp-jasminxt-string =
+    ast2abox(|[<import-term(include/JasminXT.generated.pp.af)>,
+               <import-term(include/JasminXT.pp.af)>]);
+    box2text-string(|100)
+
+strategies
+  
+  /**
+   * Processes an import during semantic analysis.
+   * Ensures proper caching of files and prevents
+   * processing duplicate imports more than once.
+   *
+   * @param resolve-path  Resolves the filesystem path of this import
+   * @param parse-file    Parses a file (optionally removing definition bodies
+   *                      so only signatures are stored in the cache)
+   * @param record-declarations
+   *                      Performs semantic analysis on a tree
+   */
+  open-import(resolve-path, parse-file, record-declarations):
+    import -> import
+    where
+      if not(!import => COMPLETION(_)) then
+        path       := <resolve-path> import;
+        cache-path := <import-cache-path> path;
+        if not(<IsImported> path) then
+          rules(
+            IsImported: path
+          );
+          ( <is-newer> (cache-path, path);
+            file := <ReadFromFile> cache-path
+          <+
+            file := <parse-file> path;
+            if <file-exists> path then
+              // Only cache if on filesystem (e.g., ignore libstratego-lib)
+              <WriteToBinaryFile> (cache-path, file)
+            end        
+          );
+          {| CurrentFile:
+            rules(CurrentFile := path);
+            <record-declarations> file
+          |}
+        end
+      end
+
+  open-wildcard-import(resolve-path, parse-file, record-declarations, is-source-file):
+    import -> import
+    where
+      if not(!import => COMPLETION(_)) then
+        path := <resolve-path> import;
+        readdir;
+        list-loop(
+          if is-source-file then
+            <open-import(id, parse-file, record-declarations)>
+              $[[path]/[<id>]]
+          <+
+            try(?one-failed)
+          end
+        );
+        not(!one-failed)
+      end
+  
+  import-cache-path:
+    full-path -> cache-path
+    with
+      project-path := <project-path>;
+      cache-dir    := <file-exists <+ mkdir> $[[project-path]/.cache];
+      full-path'   := <string-replace(|"/", "+"); string-replace(|"\\", "+"); string-replace(|":", "+")> full-path;
+      cache-path   := $[[cache-dir]/[full-path'].sig]
+
+  project-path = prim("SSL_EXT_projectpath")
+  
+  plugin-path = prim("SSL_EXT_pluginpath")
+
+  is-newer:
+    (file1, file2) -> <id>
+    where
+      <gt> (<file-exists; modification-time> file1, <file-exists; modification-time> file2) 
+
+strategies
+  
+  editor-init =
+    // Ensure all dynamic rules are properly scoped
+    try(dr-scope-all-end);
+    dr-scope-all-start
+  
+  refresh-workspace-file:
+    path -> <prim("SSL_EXT_refreshresource", path)>
+  
+  string-starts-with-capital =
+    explode-string; Hd; is-upper
+
+strategies
+  
+  origin-term      = prim("SSL_EXT_origin_term", <id>)
+  origin-text      = prim("SSL_EXT_origin_text", <id>)
+  origin-location  = prim("SSL_EXT_origin_location", <id>)
+  origin-line      = origin-location => (<id>, _, _, _)
+  origin-column    = origin-location => (_, <id>, _, _)
+  origin-strip     = prim("SSL_EXT_origin_strip", <id>)
+  origin-equal(|t) = prim("SSL_EXT_origin_equal", <id>, t)
+  
+  origin-surrounding-comments =
+    prim("SSL_EXT_origin_surrounding_comments", "JasminXT", <id>)
+    
+  origin-documentation-comment =
+    origin-surrounding-comments;
+    filter(string-as-chars(documentation-comment-chars));
+    concat-strings
+  
+  documentation-comment-chars:
+    ['*' | c*] -> <ltrim(' ' + '\t' + '\n' + '\r')> c*
+  
+  origin-track-forced(s) =
+    !Some(<id>); all(s); ?Some(<id>)
+
+strategies
+
+  desugar-position(desugar|ast):
+    position -> position'
+    where
+      ast'  := <at-position(!<id>{MARKER()}|position)> ast;
+      ast'' := <topdown(repeat(preserve-annos({?x; desugar; not(?x)})))> ast';
+      position' := <position-of-term({?_{a*}; <one(?MARKER())> a*})> ast''
+   
+  at-position(s|position):
+    c#(t*) -> t'
+    where
+      !position => [i | position']
+    where
+      t' := c#(<at-index(at-position(s|position'))> (i, t*))
+
+  at-position(s|position):
+    t -> t'
+    where
+      !position => [];
+      t' := <s> t
+
+  position-of-term(is-term):
+    t -> []
+    where
+      is-term
+  
+  position-of-term(is-term):
+    _#(t*) -> <position-of-term(is-term|0)> t*
+  
+  position-of-term(is-term|start-index):
+    [t | t*] -> position
+    where
+      if i* := <position-of-term(is-term)> t then
+        position := [start-index | i*]
+      else
+        position := <position-of-term(is-term | <inc> start-index)> t*
+      end
+
+  term-at-position(|position):
+    t -> t'
+    where
+      at-position(?t'|position) 
+
+  parent-at-position(|position):
+    t -> t'
+    where
+      !position => [i, _];
+      t' := <subterm-at(|i)> t
+  
+  parent-at-position(|position):
+    t -> <parent-at-position(|position')> t'
+    where
+      !position => [i | position' @ [_, _ | _]];
+      t' := <subterm-at(|i)> t
+
+  subterm-at(|index):
+    _#(t*) -> <index(|<inc> index)> t*
+  
+signature constructors
+
+  COMPLETION : String -> Term
+  NOCONTEXT  : Term   -> Term
+  MARKER     : Term
+
+  // Below are copies of the signatures of the terms used in example
+  // trans/jasminxt.str file. These definitions should also be automatically 
+  // generated in the imported include/JasminXT.str module. However,
+  // to ensure that the example transformation doesn't break when the
+  // syntax is changed, we also hard-coded them here.
+          
+  Module   : ID * List(Entity)   -> Module
+  Entity   : ID * List(Property) -> Entity
+  Property : ID * Type           -> Property
+  Type     : ID                  -> Type
+
+strategies
+  
+  // Set markers for a given file. Use when checking files from a queued strategy.
+  // Current term: (ast-desugared, errors, warnings, notes) tuple
+  // ast: the root node of the file to set markers on 
+  set-markers(|ast) = prim("SSL_EXT_set_markers", ast)
+
+  // Indicate that one or more files need analysis. 
+  // Current term: ss a list of absolute file paths, or a single absolute file path to analyze
+  queue-analysis = 
+       (is-list; list-loop(queue-analysis))
+    <+ prim("SSL_EXT_queue_analysis")
+
+  // Set the total number of work units to complete. Can be called multiple times. 
+  // Current term: number of work units (int).
+  set-total-work-units = prim("SSL_EXT_set_total_work_units")
+  
+  // Complete one work unit and update progress monitors.
+  // Current term: ignored
+  complete-work-unit = prim("SSL_EXT_complete_work_unit")
+  
+  // Queue a strategy for background processing with a progress indicator.
+  // Current term: the term to pass to the background strategy
+  // s: the strategy, as string
+  // description: name of the task (will be shown in progress view)
+  queue-strategy(|s,description) = prim("SSL_EXT_queue_strategy", s, description)
+  
+  // Return the result of this strategy to indicate a non-completed (backgrounded) analysis.
+  // Editor services (hover, resolve) will be delayed until a complete analysis is performed. 
+  set-analysis-backgrounded = !"BACKGROUNDED"
+  

Added: jasmin-spoofax/lib/environment.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/lib/environment.str	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,270 @@
+module lib/environment
+
+signature constructors
+
+	References: Environment -> Environment
+		
+rules // store mappings and references
+	
+	/**
+	* stores a mapping from a name to a declaration
+	* can distinguish different tables
+	* remembers the mapping by storing a dynamic rule
+	*
+	* @param env
+	* @type (a, b) -> b
+	*/
+	env-store-mapping(|env) :
+		(x, d) -> d
+		where rules(
+			EnvMapping:+ (env, x) -> d
+		)
+		// where 
+			// <debug(!"Environment: ")> env ;
+			// <debug(!"Stored mapping: ")> (x,d)
+			
+	/**
+	* stores the usage of a reference
+	* can distinguish different namespaces
+	* remembers the reference by storing a dynamic rule
+	*
+	* @param env
+	* @type a -> a
+	*/
+	env-store-element(|env):
+		x -> x
+		where rules(
+			EnvElement:+ (env, x) -> x
+		)
+		// where 
+			// <debug(!"Environment: ")> env ;
+			// <debug(!"Stored element: ")> (x,x)
+	
+rules // include environments
+	
+	/**
+	*
+	* example: 
+	*     store: Class(c, Parent(p), _, _) -> <id> 
+	*         where 
+	*             <env-store-mapping(|Classes())> c ; 
+	*             <env-include(|Fields(c))> Fields(p) ;
+	*             <env-include(|Methods(c))> Methods(p) 
+	*/
+	env-include(|env) : 
+		nested -> nested
+		where rules (
+			EnvNested:+ env -> nested
+			EnvParent:+ nested -> env
+		)
+				
+strategies
+	
+	env-drop: 
+		env -> env
+		where rules (
+			EnvNested:- env
+			EnvParent:- env
+			EnvMapping:- (env, _)
+			EnvElement:- (env, _)
+		)
+		
+	env-drop-all =
+		rules (
+			EnvNested:- _
+			EnvParent:- _
+			EnvMapping:- _
+			EnvElement:- _
+		)
+		
+strategies // access inclusions
+	
+	env-nested = get-inclusions(bagof-EnvNested)
+	env-get-parents  = get-inclusions(bagof-EnvParent)
+	
+	get-inclusions(s) = ![<id>] ; get-inclusions(s|[]) ; reverse 
+	
+	get-inclusions(s|temps): [] -> temps
+	 
+	get-inclusions(s|temps): 
+		[env|envs] -> <get-inclusions(s|temps)> envs
+		where <elem> (env, temps)
+		
+	get-inclusions(s|temps):  
+		[env|envs] -> incls
+		where
+			not (<elem> (env, temps)) ;
+			incls1 	:= <s> env ;
+			incls2	:= <get-inclusions(s|[env|temps])> incls1 ;
+			incls	:= <get-inclusions(s|incls2)> envs
+		
+strategies // access declarations
+	
+	/**
+	* maps a name to its declarations
+	* can distinguish different environments
+	* remembers the mapping by calling a dynamic rule
+	*
+	* @param env
+	* 
+	* @type a -> List(b)
+	*/
+	env-lookup-all-local(|env): key -> <bagof-EnvMapping> (env, key)
+	
+	/**
+	* maps a name to its declarations
+	* can distinguish different environments
+	* remembers the mapping by calling a dynamic rule
+	*
+	* @param env
+	* 
+	* @type a -> List(b)
+	*/
+	env-lookup-all(|env): 
+		key -> entries
+		where
+			envs 	:= <env-nested> env ; 
+			entries := <mapconcat(env-lookup-help(|key))> envs 
+		// where
+			// <debug(!"Environment: ")> env ;
+			// <debug(!"Key: ")> (key, key) ;
+			// <debug(!"Entries: ")> entries
+	
+	env-lookup-help(|key): env -> <env-lookup-all-local(|env)> key
+	
+	/**
+	* succeeds if the current term can be mapped to a declaration
+	* can distinguish different environments
+	* 
+	* @param namespace
+	* 
+	* @type a -> a
+	*/
+	env-has-key-local(|env) = where(env-lookup-all-local(|env) ; Hd)
+
+	/**
+	* succeeds if the current term can be mapped to a declaration
+	* can distinguish different environments
+	* 
+	* @param namespace
+	* 
+	* @type a -> a
+	*/
+	env-has-key(|env) = where(env-lookup-all(|env) ; Hd)
+	
+	/**
+	* maps a name to its only declaration
+	* can distinguish different environments
+	* 
+	* @param env
+	*/
+	env-lookup-unique(|env) = env-lookup-all(|env) ; Last
+	
+	/**
+	* maps a name to its only declaration
+	* can distinguish different environments
+	* 
+	* @param env
+	*/
+	env-lookup-unique-local(|env) = env-lookup-all-local(|env) ; Last
+	
+	/**
+	* maps a name to its first declaration
+	* can distinguish different environments
+	* 
+	* @param env
+	*/
+	env-lookup(|env) = env-project(id|env) 
+	
+	env-lookup-local(|env) = env-project-local(id|env)
+	
+	/**
+	* maps a name to its first declaration for which strategy s holds
+	* can distinguish different environments
+	* 
+	* @param s: b -> c
+	* @param env
+	* 
+	* @type a -> b
+	*/
+	env-lookup(s|env) = env-project(where(s)|env)
+	
+	env-lookup-local(s|env) = env-project-local(where(s)|env)
+	
+	/**
+	* maps a name to its declarations for which strategy s holds
+	* can distinguish different environments
+	* 
+	* @param s: b -> c
+	* @param env
+	* 
+	* @type a -> List(b)
+	*/
+	env-lookup-all(s|env) = env-project-all(where(s)|env)
+
+	env-lookup-all-local(s|env) = env-project-all-local(where(s)|env)
+
+strategies // project declarations
+	
+	/**
+	* maps a name to the first projection of its declarations
+	* can distinguish different environments
+	* 
+	* @param s: b -> c
+	* @param env
+	* 
+	* @type a -> c
+	*/
+	env-project(s|env) = env-lookup-all(|env) ; fetch-elem(s) 
+
+	env-project-local(s|env) = env-lookup-all-local(|env) ; fetch-elem(s) 
+
+	/**
+	* maps a name to the projections of its declarations
+	* can distinguish different environments
+	* 
+	* @param s: b -> c
+	* @param env
+	* 
+	* @type a -> List(c)
+	*/
+	env-project-all(s|env) = env-lookup-all(|env) ; filter(s) 
+	
+	env-project-all-local(s|env) = env-lookup-all-local(|env) ; filter(s) 
+	
+strategies // access all declarations
+	
+	env-key(|envs): (env, key) -> key where <elem> (env, envs)
+	
+	env-all-keys: 
+		env -> keys
+		where 
+			envs 	:= <env-nested> env ; 
+			allkeys	:= <all-keys-EnvMapping> ; 
+			keys	:= <filter(where(env-key(|envs)))> allkeys 
+	
+	env-all-keys(s) = env-project-all-keys(where(s)) 
+	
+	env-project-all-keys(s) = env-all-keys ; filter(s) 
+	
+	env-all-values: 
+		env -> values
+		where 
+			keys	:= <env-all-keys> env ;
+			values	:= <mapconcat(bagof-EnvMapping)> keys
+	
+	env-all-values(s) = env-project-all-values(where(s)) 
+
+	env-project-all-values(s) = env-all-values ; filter(s) 
+	 
+strategies // access references
+
+	env-all-elements:
+		env -> elems
+		where 
+			envs 	:= <env-nested> env ; 
+			allkeys	:= <all-keys-EnvElement> ; 
+			elems	:= <filter(env-key(|envs))> allkeys 
+						
+	env-has-element(|env): x -> x where <elem> (x, <env-all-elements> env)
+			
\ No newline at end of file

Added: jasmin-spoofax/lib/namespace.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/lib/namespace.str	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,95 @@
+module lib/namespace
+
+imports lib/environment
+
+signature constructors
+	
+	Names: 		String -> Environment
+	Proposals:  Environment
+	
+	name:  String -> Annotation
+	
+rules // scoped renaming
+	
+	/**
+	* executes the renaming strategy s in a new scope
+	* 
+	* declarations inside the new scope will hide existing declarations outside the new scope
+	* multiple declarations with the same name inside the new scope will be renamed to the same name
+	*
+	* @param renaming strategy s: a -> b
+	* @type a -> b
+	*/
+	new-scope(s) :
+		x -> y
+		where
+			<newname> x => scope ;
+			<env-include(|(Names(scope)))> Names(<current-scope> ());
+			{| CurrentScope, Scope:
+				rules (
+					CurrentScope: namespace -> scope
+					Scope:+ x -> scope
+				) ;
+				<s> x => y 
+			|} ;
+			<env-drop> Names(scope)
+			
+	/**
+	* annotates the current term with a fresh name
+	* can distinguish different namespaces
+	* remembers the renaming by storing two dynamic rules
+	* 
+	* multiple calls on the same term inside the same scope will give identical results
+	* calls inside a new scope will hide the results of calls to the same term from outer scopes
+	*
+	* @param namespace 
+	* @type a -> a
+	*/
+	rename-declaration(|namespace) : 
+		x -> x'
+		where 
+			<current-scope> namespace => scope 
+		where
+			( <env-lookup-local(|Names(scope))> (namespace, x) => x' ) <+
+			(
+				<set-anno> (x, name(<newname> x)) => x' ;
+				<env-store-mapping(|Names(scope))> ((namespace, x), x')
+			) 
+	
+	/**
+	* annotates the current term with a new name
+	* succeeds only if rename-declaration was called before on the same term
+	* will use the same name as rename-declaration (by calling the dynamic rule stored by rename-declaration)
+	*
+	* @param namespace 
+	* @type a -> b
+	*/
+	rename-reference(|namespace) :
+		x -> x'
+		where
+			x' := <env-lookup(|Names(<current-scope> ()))> (namespace, x)
+
+strategies // access scopes
+	
+	current-scope = CurrentScope <+ !"global"
+	
+	get-scopes = all-keys-Scope
+	
+	get-scopes(s) = get-scopes ; filter(where(s))
+	
+	get-scope(s) = get-scopes ; fetch-elem(where(s))
+	
+	project-scopes(s) = get-scopes ; filter(s)
+	
+	project-scope(s) = get-scopes ; fetch-elem(s)
+	
+	in-scope(s) = where(get-scope(s))
+	
+strategies	
+	
+	namespace-key(|namespace): (namespace, x) -> x
+	
+	store-proposal-candidates(|namespace) =  	
+		<env-project-all-keys(namespace-key(|namespace))> Names(<current-scope> ()) ;
+		map(env-store-element(|Proposals()))
+	
\ No newline at end of file

Added: jasmin-spoofax/plugin.xml
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/plugin.xml	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+<?eclipse version="3.0"?>
+
+<plugin>
+       <extension point="org.eclipse.imp.runtime.languageDescription">
+          <language extensions="j" description="JasminXT" language="JasminXT" derivedFrom="DynamicRoot" validator="org.strategoxt.spoofax.jasminxt.JasminXTValidator" validatorClass="org.strategoxt.spoofax.jasminxt.JasminXTValidator"></language>
+       </extension>
+       <extension id="org.strategoxt.spoofax.jasminxt.parser" name="JasminXT Parser" point="org.eclipse.imp.runtime.parser">
+          <parser class="org.strategoxt.spoofax.jasminxt.JasminXTParseController" language="JasminXT">
+          </parser>
+       </extension>    
+    </plugin>
\ No newline at end of file

Added: jasmin-spoofax/syntax/JasminXT-Directives.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/syntax/JasminXT-Directives.sdf	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,35 @@
+module JasminXT-Directives
+
+imports
+	
+	lexical/JasminXT-Numbers
+	lexical/JasminXT-Descriptors
+	
+exports
+	
+	context-free syntax
+		
+		".limit" "stack" Int 	-> Directive {cons("JBCLimitStack")}		
+		".limit" "locals" Int 	-> Directive {cons("JBCLimitLocals")}	
+		".line" Int				-> Directive {cons("JBCLine")}
+		".throws" ClassName		-> Directive {cons("JBCThrows")}
+		
+		".catch" ClassName "from" LabelRef "to" LabelRef "using" LabelRef 			-> Directive {cons("JBCCatch")}
+		".var" VarRef "is" VarName FieldDescriptor "from" LabelRef "to" LabelRef 	-> Directive {cons("JBCVarDecl")}
+		
+	lexical restrictions
+		
+		".limit" 
+		"stack" 
+		"locals" 	
+		".line" 
+		".throws" 
+		".catch" 
+		"from" 
+		"to" 
+		"using" 
+		".var" 
+		"is" 
+		"from"
+		"to" 	-/- ~[\ \t]
+		
\ No newline at end of file

Added: jasmin-spoofax/syntax/JasminXT-Fields.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/syntax/JasminXT-Fields.sdf	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,63 @@
+module JasminXT-Fields
+
+imports
+	
+	lexical/JasminXT-Names
+	lexical/JasminXT-Numbers
+	lexical/JasminXT-Strings
+	lexical/JasminXT-Descriptors
+	lexical/JasminXT-Signatures
+	
+exports
+	
+	context-free syntax
+			
+		".field" 
+		FieldAccess* 
+		FieldName 
+		FieldDescriptor 
+		FieldSignatureSpec
+		InitialValue 		-> Field {cons("JBCField")}
+	
+		".field" 
+		FieldAccess* 
+		FieldName 
+		FieldDescriptor 
+		InitialValue 
+		FieldExt*
+		".end" "field"	-> Field {cons("JBCExtField")}
+		
+		".signature" FieldSignature 	-> FieldExt {cons("JBCSignature")}
+		".deprecated"  					-> FieldExt {cons("JBCDeprecated")}
+		%%TODO add .attribute and .annotation
+
+		"signature" FieldSignature	-> FieldSignatureSpec {cons("FieldSig")}
+									-> FieldSignatureSpec {cons("None")}
+									
+		"=" Constant	-> InitialValue {cons("InitVal")}
+						-> InitialValue {cons("None")}
+		
+			
+ 		"public" 		-> FieldAccess {cons("PUBLIC")}
+ 		"private" 		-> FieldAccess {cons("PRIVATE")}
+ 		"protected" 	-> FieldAccess {cons("PROTECTED")}
+ 		"static" 		-> FieldAccess {cons("STATIC")}
+ 		"final"			-> FieldAccess {cons("FINAL")}
+ 		"volatile"		-> FieldAccess {cons("VOLATILE")}
+ 		"transient"		-> FieldAccess {cons("TRANSIENT")}
+ 		
+ 	lexical restrictions
+			
+		".field" 
+		".end"
+		".signature" 
+		".deprecated"
+		"signature"
+		"public" 	
+ 		"private" 	
+ 		"protected" 
+ 		"static" 	
+ 		"final"		
+ 		"volatile"	
+ 		"transient"	-/- ~[\ \t]
+ 		
\ No newline at end of file

Added: jasmin-spoofax/syntax/JasminXT-Header.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/syntax/JasminXT-Header.sdf	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,88 @@
+module JasminXT-Header
+
+imports
+	
+	lexical/JasminXT-Names
+	lexical/JasminXT-Numbers
+	lexical/JasminXT-Strings
+	lexical/JasminXT-Descriptors
+	lexical/JasminXT-Signatures
+		
+exports
+
+	context-free syntax %% header
+			
+		BytecodeSpec 
+		SourceSpec 
+		ClassSpec
+		SuperSpec 
+		ImplementsSpec*
+		SignatureSpec
+		EnclosingSpec
+		DeprecatedSpec
+		%%Annotations
+		%%GenericAttributes
+		%%DebugExtension		
+							-> JasminHeader {cons("JBCHeader")}
+			
+	context-free syntax
+			
+		".bytecode" MajorVersion MinorVersion 	-> BytecodeSpec {cons("JBCVersion")}
+												-> BytecodeSpec {cons("None")}
+		
+		Int 	-> MajorVersion {cons("Major")}
+ 		"." Int	-> MinorVersion {cons("Minor")}
+				-> MinorVersion {cons("None")}
+		
+		".source" String	-> SourceSpec {cons("JBCSource")}
+	%%	".source" Word		-> SourceSpec {cons("Source")}
+							-> SourceSpec {cons("None")}
+								
+	context-free syntax
+		
+		".class"     ClassAccess* ClassName -> ClassSpec {cons("JBCClass")}
+		".interface" ClassAccess* ClassName -> ClassSpec {cons("JBCInterface")}
+		
+		"public" 		-> ClassAccess {cons("PUBLIC")}
+ 		"final" 		-> ClassAccess {cons("FINAL")}
+ 		"interface"		-> ClassAccess {cons("INTERFACE")}
+ 		"abstract" 		-> ClassAccess {cons("ABSTRACT")}
+ 		"super" 		-> ClassAccess {cons("SUPER")}			%% TODO: check this
+  	
+ 		".super" ClassName -> SuperSpec {cons("JBCSuper")}
+
+		".implements" ClassName -> ImplementsSpec {cons("JBCImplements")}
+		
+ 	context-free syntax
+ 								
+		".signature" ClassSignature 	-> SignatureSpec {cons("JBCSignature")}
+										-> SignatureSpec {cons("None")}
+	
+		".enclosing" "method" MethodDescriptor 	-> EnclosingSpec {cons("JBCEnclosing")}
+												-> EnclosingSpec {cons("None")}		
+	
+		".deprecated"	-> DeprecatedSpec {cons("JBCDeprecated")}
+						-> DeprecatedSpec {cons("None")}
+	
+%%		DebugSpec* -> DebugExtension {cons("Debug")}
+		
+%%		".debug" Str -> DebugSpec {cons("Debug")}
+
+	lexical restrictions
+		
+		".bytecode"
+		".source"
+		".class"     
+		".interface" 
+		"public" 
+ 		"final" 
+ 		"interface"
+ 		"abstract" 
+ 		"super" 	
+ 		".super" 		
+		".implements" 		
+		".signature" 
+		".enclosing" 
+		%%"method"
+		".deprecated" -/- ~[\ \t]
+		
\ No newline at end of file

Added: jasmin-spoofax/syntax/JasminXT-Methods.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/syntax/JasminXT-Methods.sdf	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,54 @@
+module JasminXT-Methods
+
+imports
+	
+	lexical/JasminXT-Names
+	lexical/JasminXT-Numbers
+	lexical/JasminXT-Strings
+	lexical/JasminXT-Descriptors
+	
+	instructions/JasminXT-Instructions
+	JasminXT-Directives
+	
+exports
+	
+	context-free syntax
+		
+ 		".method" 
+ 		MethodAccess* 
+ 		MethodName 
+ 		MethodDescriptor 
+ 		Statement*
+ 		".end" "method" -> Method {cons("JBCMethod")}
+				
+ 		"public" 		-> MethodAccess {cons("PUBLIC")}
+ 		"private" 		-> MethodAccess {cons("PRIVATE")}
+ 		"protected" 	-> MethodAccess {cons("PROTECTED")}
+ 		"static" 		-> MethodAccess {cons("STATIC")}
+ 		"final"			-> MethodAccess {cons("FINAL")}
+ 		"synchronized"	-> MethodAccess {cons("SYNCHRONIZED")}
+ 		"native"		-> MethodAccess {cons("NATIVE")}
+ 		"abstract"		-> MethodAccess {cons("ABSTRACT")}
+ 		
+ 	context-free syntax %% statements
+ 		
+ 		PCInstruction 	-> Statement
+ 		Directive		-> Statement
+ 	%%	Error			-> Statement
+ 		Label			-> Statement
+ 	
+ 		LabelName ":"	-> Label {cons("JBCLabel")}
+ 		
+ 	lexical restrictions
+ 		
+ 		".method" 
+ 		".end" 
+ 		"public" 
+ 		"private"
+ 		"protected"
+ 		"static" 	
+ 		"final"		
+ 		"synchronized"
+ 		"native"		
+ 		"abstract"		-/- ~[\ \t]
+ 		
\ No newline at end of file

Added: jasmin-spoofax/syntax/JasminXT.generated.pp
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/syntax/JasminXT.generated.pp	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,295 @@
+[
+   JBCLimitStack            -- KW[".limit"] KW["stack"] _1,
+   JBCLimitLocals           -- KW[".limit"] KW["locals"] _1,
+   JBCLine                  -- KW[".line"] _1,
+   JBCThrows                -- KW[".throws"] _1,
+   JBCCatch                 -- KW[".catch"] _1 KW["from"] _2 KW["to"] _3 KW["using"] _4,
+   JBCVarDecl               -- KW[".var"] _1 KW["is"] _2 _3 KW["from"] _4 KW["to"] _5,
+   MONITORENTER             -- KW["monitorenter"],
+   MONITOREXIT              -- KW["monitorexit"],
+   ATHROW                   -- KW["athrow"],
+   INVOKESPECIAL            -- KW["invokenonvirtual"] _1,
+   INVOKEVIRTUAL            -- KW["invokevirtual"] _1,
+   INVOKESTATIC             -- KW["invokestatic"] _1,
+   INVOKEINTERFACE          -- KW["invokeinterface"] _1 _2,
+   RETURN                   -- KW["return"],
+   IRETURN                  -- KW["ireturn"],
+   LRETURN                  -- KW["lreturn"],
+   FRETURN                  -- KW["freturn"],
+   DRETURN                  -- KW["dreturn"],
+   ARETURN                  -- KW["areturn"],
+   Absolute                 -- _1,
+   RelativeFwd              -- KW["$+"] _1,
+   RelativeBwd              -- KW["$-"] _1,
+   IFEQ                     -- KW["ifeq"] _1,
+   IFLT                     -- KW["iflt"] _1,
+   IFLE                     -- KW["ifle"] _1,
+   IFNE                     -- KW["ifne"] _1,
+   IFGT                     -- KW["ifgt"] _1,
+   IFGE                     -- KW["ifge"] _1,
+   IFNULL                   -- KW["ifnull"] _1,
+   IFNONNULL                -- KW["ifnonnull"] _1,
+   IF_ICMPEQ                -- KW["if_icmpeq"] _1,
+   IF_ICMPLT                -- KW["if_icmplt"] _1,
+   IF_ICMPLE                -- KW["if_icmple"] _1,
+   IF_ICMPNE                -- KW["if_icmpne"] _1,
+   IF_ICMPGT                -- KW["if_icmpgt"] _1,
+   IF_ICMPGE                -- KW["if_icmpge"] _1,
+   IF_ACMPEQ                -- KW["if_acmpeq"] _1,
+   IF_ACMPNE                -- KW["if_acmpne"] _1,
+   Table                    -- KW["tableswitch"] _1 _2 KW["default"] KW[":"] _3,
+   Table.2:iter-star        -- _1,
+   Lookup                   -- KW["lookupswitch"] _1 KW["default"] KW[":"] _2,
+   Lookup.1:iter-star       -- _1,
+   Jump                     -- _1,
+   NPAIR                    -- _1 KW[":"] _2,
+   GOTO                     -- KW["goto"] _1,
+   GOTO_W                   -- KW["goto_w"] _1,
+   POP                      -- KW["pop"],
+   POP2                     -- KW["pop2"],
+   DUP                      -- KW["dup"],
+   DUP2                     -- KW["dup2"],
+   DUP_X1                   -- KW["dup_x1"],
+   DUP2_X1                  -- KW["dup2_x1"],
+   DUP_X2                   -- KW["dup_x2"],
+   DUP2_X2                  -- KW["dup2_x2"],
+   SWAP                     -- KW["swap"],
+   NEW                      -- KW["new"] _1,
+   NEWARRAY                 -- KW["newarray"] _1,
+   ANEWARRAY                -- KW["anewarray"] _1,
+   ANEWARRAY                -- KW["anewarray"] _1,
+   MULTIANEWARRAY           -- KW["multianewarray"] _1 _2,
+   GETFIELD                 -- KW["getfield"] _1,
+   PUTFIELD                 -- KW["putfield"] _1,
+   GETSTATIC                -- KW["getstatic"] _1,
+   PUTSTATIC                -- KW["putstatic"] _1,
+   IALOAD                   -- KW["iaload"],
+   LALOAD                   -- KW["laload"],
+   BALOAD                   -- KW["baload"],
+   CALOAD                   -- KW["caload"],
+   SALOAD                   -- KW["saload"],
+   FALOAD                   -- KW["faload"],
+   DALOAD                   -- KW["daload"],
+   AALOAD                   -- KW["aaload"],
+   IASTORE                  -- KW["iastore"],
+   LASTORE                  -- KW["lastore"],
+   BASTORE                  -- KW["bastore"],
+   CASTORE                  -- KW["castore"],
+   SASTORE                  -- KW["sastore"],
+   FASTORE                  -- KW["fastore"],
+   DASTORE                  -- KW["dastore"],
+   AASTORE                  -- KW["aastore"],
+   ARRAYLENGTH              -- KW["arraylength"],
+   CHECKCAST                -- KW["checkcast"] _1,
+   INSTANCEOF               -- KW["instanceof"] _1,
+   I2L                      -- KW["i2l"],
+   I2F                      -- KW["i2f"],
+   I2D                      -- KW["i2d"],
+   L2F                      -- KW["l2f"],
+   L2D                      -- KW["l2d"],
+   F2D                      -- KW["f2d"],
+   I2B                      -- KW["int2byte"],
+   I2S                      -- KW["int2short"],
+   I2C                      -- KW["int2char"],
+   L2I                      -- KW["l2i"],
+   F2I                      -- KW["f2i"],
+   F2L                      -- KW["f2l"],
+   D2I                      -- KW["d2i"],
+   D2L                      -- KW["d2l"],
+   D2F                      -- KW["d2f"],
+   IADD                     -- KW["iadd"],
+   IAND                     -- KW["iand"],
+   IDIV                     -- KW["idiv"],
+   IMUL                     -- KW["imul"],
+   INEG                     -- KW["ineg"],
+   IOR                      -- KW["ior"],
+   IREM                     -- KW["irem"],
+   ISHL                     -- KW["ishl"],
+   ISHR                     -- KW["ishr"],
+   ISUB                     -- KW["isub"],
+   IUSHR                    -- KW["iushr"],
+   IXOR                     -- KW["ixor"],
+   LADD                     -- KW["ladd"],
+   LAND                     -- KW["land"],
+   LDIV                     -- KW["ldiv"],
+   LMUL                     -- KW["lmul"],
+   LNEG                     -- KW["lneg"],
+   LOR                      -- KW["lor"],
+   LREM                     -- KW["lrem"],
+   LSHL                     -- KW["lshl"],
+   LSHR                     -- KW["lshr"],
+   LSUB                     -- KW["lsub"],
+   LUSHR                    -- KW["lushr"],
+   LXOR                     -- KW["lxor"],
+   FADD                     -- KW["fadd"],
+   FDIV                     -- KW["fdiv"],
+   FMUL                     -- KW["fmul"],
+   FNEG                     -- KW["fneg"],
+   FREM                     -- KW["frem"],
+   FSUB                     -- KW["fsub"],
+   DADD                     -- KW["dadd"],
+   DDIV                     -- KW["ddiv"],
+   DMUL                     -- KW["dmul"],
+   DNEG                     -- KW["dneg"],
+   DREM                     -- KW["drem"],
+   DSUB                     -- KW["dsub"],
+   IINC                     -- KW["iinc"] _1 _2,
+   Neg                      -- KW["-"] _1,
+   FCMPG                    -- KW["fcmpg"],
+   FCMPL                    -- KW["fcmpl"],
+   DCMPG                    -- KW["dcmpg"],
+   DCMPL                    -- KW["dcmpl"],
+   LCMP                     -- KW["lcmp"],
+   BIPUSH                   -- KW["bipush"] _1,
+   SIPUSH                   -- KW["sipush"] _1,
+   ICONST_M1                -- KW["iconst_m1"],
+   ICONST_0                 -- KW["iconst_0"],
+   ICONST_1                 -- KW["iconst_1"],
+   ICONST_2                 -- KW["iconst_2"],
+   ICONST_3                 -- KW["iconst_3"],
+   ICONST_4                 -- KW["iconst_4"],
+   ICONST_5                 -- KW["iconst_5"],
+   LCONST_0                 -- KW["lconst_0"],
+   LCONST_1                 -- KW["lconst_1"],
+   FCONST_0                 -- KW["fconst_0"],
+   FCONST_1                 -- KW["fconst_1"],
+   FCONST_2                 -- KW["fconst_2"],
+   DCONST_0                 -- KW["dconst_0"],
+   DCONST_1                 -- KW["dconst_1"],
+   ACONST_NULL              -- KW["aconst_null"],
+   LDC                      -- KW["ldc"] _1,
+   LDC2_W                   -- KW["ldc2_w"] _1,
+   ILOAD                    -- KW["iload"] _1,
+   LLOAD                    -- KW["lload"] _1,
+   FLOAD                    -- KW["fload"] _1,
+   DLOAD                    -- KW["dload"] _1,
+   ALOAD                    -- KW["aload"] _1,
+   ILOAD_0                  -- KW["iload_0"],
+   ILOAD_1                  -- KW["iload_1"],
+   ILOAD_2                  -- KW["iload_2"],
+   ILOAD_3                  -- KW["iload_3"],
+   ALOAD_0                  -- KW["aload_0"],
+   ALOAD_1                  -- KW["aload_1"],
+   ALOAD_2                  -- KW["aload_2"],
+   ALOAD_3                  -- KW["aload_3"],
+   LLOAD_0                  -- KW["lload_0"],
+   LLOAD_1                  -- KW["lload_1"],
+   LLOAD_2                  -- KW["lload_2"],
+   LLOAD_3                  -- KW["lload_3"],
+   DLOAD_0                  -- KW["dload_0"],
+   DLOAD_1                  -- KW["dload_1"],
+   DLOAD_2                  -- KW["dload_2"],
+   DLOAD_3                  -- KW["dload_3"],
+   FLOAD_0                  -- KW["fload_0"],
+   FLOAD_1                  -- KW["fload_1"],
+   FLOAD_2                  -- KW["fload_2"],
+   FLOAD_3                  -- KW["fload_3"],
+   ISTORE                   -- KW["istore"] _1,
+   LSTORE                   -- KW["lstore"] _1,
+   FSTORE                   -- KW["fstore"] _1,
+   DSTORE                   -- KW["dstore"] _1,
+   ASTORE                   -- KW["astore"] _1,
+   ISTORE_0                 -- KW["istore_0"],
+   ISTORE_1                 -- KW["istore_1"],
+   ISTORE_2                 -- KW["istore_2"],
+   ISTORE_3                 -- KW["istore_3"],
+   ASTORE_0                 -- KW["astore_0"],
+   ASTORE_1                 -- KW["astore_1"],
+   ASTORE_2                 -- KW["astore_2"],
+   ASTORE_3                 -- KW["astore_3"],
+   LSTORE_0                 -- KW["lstore_0"],
+   LSTORE_1                 -- KW["lstore_1"],
+   LSTORE_2                 -- KW["lstore_2"],
+   LSTORE_3                 -- KW["lstore_3"],
+   FSTORE_0                 -- KW["fstore_0"],
+   FSTORE_1                 -- KW["fstore_1"],
+   FSTORE_2                 -- KW["fstore_2"],
+   FSTORE_3                 -- KW["fstore_3"],
+   DSTORE_0                 -- KW["dstore_0"],
+   DSTORE_1                 -- KW["dstore_1"],
+   DSTORE_2                 -- KW["dstore_2"],
+   DSTORE_3                 -- KW["dstore_3"],
+   NOP                      -- KW["nop"],
+   BREAKPOINT               -- KW["breakpoint"],
+   PC                       -- _1 KW[":"] _2,
+   JBCMethod                -- KW[".method"] _1 _2 _3 _4 KW[".end"] KW["method"],
+   JBCMethod.1:iter-star    -- _1,
+   JBCMethod.4:iter-star    -- _1,
+   PUBLIC                   -- KW["public"],
+   PRIVATE                  -- KW["private"],
+   PROTECTED                -- KW["protected"],
+   STATIC                   -- KW["static"],
+   FINAL                    -- KW["final"],
+   SYNCHRONIZED             -- KW["synchronized"],
+   NATIVE                   -- KW["native"],
+   ABSTRACT                 -- KW["abstract"],
+   JBCLabel                 -- _1 KW[":"],
+   JBCField                 -- KW[".field"] _1 _2 _3 _4 _5,
+   JBCField.1:iter-star     -- _1,
+   JBCExtField              -- KW[".field"] _1 _2 _3 _4 _5 KW[".end"] KW["field"],
+   JBCExtField.1:iter-star  -- _1,
+   JBCExtField.5:iter-star  -- _1,
+   JBCSignature             -- KW[".signature"] _1,
+   JBCDeprecated            -- KW[".deprecated"],
+   FieldSig                 -- KW["signature"] _1,
+   None                     -- ,
+   InitVal                  -- KW["="] _1,
+   None                     -- ,
+   PUBLIC                   -- KW["public"],
+   PRIVATE                  -- KW["private"],
+   PROTECTED                -- KW["protected"],
+   STATIC                   -- KW["static"],
+   FINAL                    -- KW["final"],
+   VOLATILE                 -- KW["volatile"],
+   TRANSIENT                -- KW["transient"],
+   JBCFieldDesc             -- _1,
+   Void                     -- KW["V"],
+   Byte                     -- KW["B"],
+   Char                     -- KW["C"],
+   Double                   -- KW["D"],
+   Float                    -- KW["F"],
+   Int                      -- KW["I"],
+   Long                     -- KW["J"],
+   Short                    -- KW["S"],
+   Boolean                  -- KW["Z"],
+   Init                     -- KW["<init>"],
+   VarNum                   -- _1,
+   LabelRef                 -- _1,
+   ByteName                 -- KW["byte"],
+   CharName                 -- KW["char"],
+   DoubleName               -- KW["double"],
+   FloatName                -- KW["float"],
+   IntName                  -- KW["int"],
+   LongName                 -- KW["long"],
+   ShortName                -- KW["short"],
+   BooleanName              -- KW["boolean"],
+   JBCHeader                -- _1 _2 _3 _4 _5 _6 _7 _8,
+   JBCHeader.5:iter-star    -- _1,
+   JBCVersion               -- KW[".bytecode"] _1 _2,
+   None                     -- ,
+   Major                    -- _1,
+   Minor                    -- KW["."] _1,
+   None                     -- ,
+   JBCSource                -- KW[".source"] _1,
+   None                     -- ,
+   JBCClass                 -- V  [V vs=2 [KW[".class"] _1] _2],
+   JBCClass.1:iter-star     -- _1,
+   JBCInterface             -- V  [V vs=2 [KW[".interface"] _1] _2],
+   JBCInterface.1:iter-star -- _1,
+   PUBLIC                   -- KW["public"],
+   FINAL                    -- KW["final"],
+   INTERFACE                -- KW["interface"],
+   ABSTRACT                 -- KW["abstract"],
+   SUPER                    -- KW["super"],
+   JBCSuper                 -- KW[".super"] _1,
+   JBCImplements            -- KW[".implements"] _1,
+   JBCSignature             -- KW[".signature"] _1,
+   None                     -- ,
+   JBCEnclosing             -- KW[".enclosing"] KW["method"] _1,
+   None                     -- ,
+   JBCDeprecated            -- KW[".deprecated"],
+   None                     -- ,
+   JBCFile                  -- _1 _2 _3,
+   JBCFile.2:iter-star      -- _1,
+   JBCFile.3:iter-star      -- _1
+]
\ No newline at end of file

Added: jasmin-spoofax/syntax/JasminXT.pp
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/syntax/JasminXT.pp	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,84 @@
+[
+   JBCLimitStack             -- H [KW[".limit"] KW["stack"] _1],
+   JBCLimitLocals            -- H [KW[".limit"] KW["locals"] _1],
+   JBCLine                   -- H [KW[".line"] _1],
+   JBCThrows                 -- H [KW[".throws"] _1],
+   JBCCatch                  -- H [KW[".catch"] _1 KW["from"] _2 KW["to"] _3 KW["using"] _4],
+   JBCVarDecl                -- H [KW[".var"] _1 KW["is"] _2 _3 KW["from"] _4 KW["to"] _5],
+   INVOKESPECIAL             -- H [KW["invokenonvirtual"] _1],
+   INVOKEVIRTUAL             -- H [KW["invokevirtual"] _1],
+   INVOKESTATIC              -- H [KW["invokestatic"] _1],
+   INVOKEINTERFACE           -- H [KW["invokeinterface"] _1 _2],
+   RelativeFwd               -- H [KW["$+"] _1],
+   RelativeBwd               -- H [KW["$-"] _1],
+   IFEQ                      -- H [KW["ifeq"] _1],
+   IFLT                      -- H [KW["iflt"] _1],
+   IFLE                      -- H [KW["ifle"] _1],
+   IFNE                      -- H [KW["ifne"] _1],
+   IFGT                      -- H [KW["ifgt"] _1],
+   IFGE                      -- H [KW["ifge"] _1],
+   IFNULL                    -- H [KW["ifnull"] _1],
+   IFNONNULL                 -- H [KW["ifnonnull"] _1],
+   IF_ICMPEQ                 -- H [KW["if_icmpeq"] _1],
+   IF_ICMPLT                 -- H [KW["if_icmplt"] _1],
+   IF_ICMPLE                 -- H [KW["if_icmple"] _1],
+   IF_ICMPNE                 -- H [KW["if_icmpne"] _1],
+   IF_ICMPGT                 -- H [KW["if_icmpgt"] _1],
+   IF_ICMPGE                 -- H [KW["if_icmpge"] _1],
+   IF_ACMPEQ                 -- H [KW["if_acmpeq"] _1],
+   IF_ACMPNE                 -- H [KW["if_acmpne"] _1],
+   Table                     -- H [KW["tableswitch"] _1 _2 KW["default"] KW[":"] _3],
+   Lookup                    -- H [KW["lookupswitch"] _1 KW["default"] KW[":"] _2],
+   NPAIR                     -- H [_1 KW[":"] _2],
+   GOTO                      -- H [KW["goto"] _1],
+   GOTO_W                    -- H [KW["goto_w"] _1],
+   NEW                       -- H [KW["new"] _1],
+   NEWARRAY                  -- H [KW["newarray"] _1],
+   ANEWARRAY                 -- H [KW["anewarray"] _1],
+   ANEWARRAY                 -- H [KW["anewarray"] _1],
+   MULTIANEWARRAY            -- H [KW["multianewarray"] _1 _2],
+   GETFIELD                  -- H [KW["getfield"] _1],
+   PUTFIELD                  -- H [KW["putfield"] _1],
+   GETSTATIC                 -- H [KW["getstatic"] _1],
+   PUTSTATIC                 -- H [KW["putstatic"] _1],
+   CHECKCAST                 -- H [KW["checkcast"] _1],
+   INSTANCEOF                -- H [KW["instanceof"] _1],
+   IINC                      -- H [KW["iinc"] _1 _2],
+   Neg                       -- H [KW["-"] _1],
+   BIPUSH                    -- H [KW["bipush"] _1],
+   SIPUSH                    -- H [KW["sipush"] _1],
+   LDC                       -- H [KW["ldc"] _1],
+   LDC2_W                    -- H [KW["ldc2_w"] _1],
+   ILOAD                     -- H [KW["iload"] _1],
+   LLOAD                     -- H [KW["lload"] _1],
+   FLOAD                     -- H [KW["fload"] _1],
+   DLOAD                     -- H [KW["dload"] _1],
+   ALOAD                     -- H [KW["aload"] _1],
+   ISTORE                    -- H [KW["istore"] _1],
+   LSTORE                    -- H [KW["lstore"] _1],
+   FSTORE                    -- H [KW["fstore"] _1],
+   DSTORE                    -- H [KW["dstore"] _1],
+   ASTORE                    -- H [KW["astore"] _1],
+   PC                        -- H [_1 KW[":"] _2],
+   JBCMethod                 -- V [V is=4[H [KW[".method"] _1 H hs=0 [_2 _3]] _4] H [KW[".end"] KW["method"]]],
+   JBCLabel                  -- H [_1 KW[":"]],
+   JBCField                  -- H [KW[".field"] _1 _2 _3 _4 _5],
+   JBCExtField               -- KW[".field"] _1 _2 _3 _4 _5 KW[".end"] KW["field"],
+   JBCSignature              -- H [KW[".signature"] _1],
+   FieldSig                  -- H [KW["signature"] _1],
+   JBCMethodDesc             -- H hs=0 [KW["("] _1 KW[")"] _2],
+   Reference                 -- H hs=0[KW["L"] _1 KW[";"]],
+   Array                     -- H hs=0[KW["["] _1],
+   JBCFieldRef               -- H [H hs=0 [_1 KW["/"] _2] _3],
+   JBCMethodRef              -- H hs=0[_1 KW["/"] _2 _3],
+   JBCHeader                 -- V vs=0[_1 _2 _3 _4 _5 _6 _7 _8],
+   JBCVersion                -- H [KW[".bytecode"] _1 _2],
+   JBCSource                 -- H [KW[".source"] _1],
+   JBCClass                  -- H  [H hs=1 [KW[".class"] _1] _2],
+   JBCInterface              -- V  [V vs=2 [KW[".interface"] _1] _2],
+   JBCSuper                  -- H [KW[".super"] _1],
+   JBCImplements             -- H [KW[".implements"] _1],
+   JBCSignature              -- H [KW[".signature"] _1],
+   JBCEnclosing              -- H [KW[".enclosing"] KW["method"] _1],
+   JBCFile                   -- V vs=1[_1 _2 _3]
+]
\ No newline at end of file

Added: jasmin-spoofax/syntax/JasminXT.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/syntax/JasminXT.sdf	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,22 @@
+module JasminXT
+
+imports
+	
+	lexical/JasminXT-Whitespace
+	JasminXT-Header
+	JasminXT-Fields
+	JasminXT-Methods
+	
+exports
+
+	context-free start-symbols
+		Start
+
+	context-free syntax
+  
+		JasminFile		-> Start 
+		
+		JasminHeader 
+		%%Inners
+		Field* 
+		Method* -> JasminFile {cons("JBCFile")}

Added: jasmin-spoofax/syntax/instructions/JasminXT-Arithmetic.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/syntax/instructions/JasminXT-Arithmetic.sdf	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,68 @@
+module instructions/JasminXT-Arithmetic
+
+imports
+	
+	lexical/JasminXT-Names
+	lexical/JasminXT-Numbers
+	
+exports
+	context-free syntax
+		
+		"iadd" 	-> Instruction {cons("IADD")}
+		"iand" 	-> Instruction {cons("IAND")}
+		"idiv" 	-> Instruction {cons("IDIV")}
+		"imul" 	-> Instruction {cons("IMUL")}
+		"ineg" 	-> Instruction {cons("INEG")}
+		"ior"  	-> Instruction {cons("IOR")}
+		"irem" 	-> Instruction {cons("IREM")}
+		"ishl" 	-> Instruction {cons("ISHL")}
+		"ishr" 	-> Instruction {cons("ISHR")}
+		"isub" 	-> Instruction {cons("ISUB")}
+		"iushr" -> Instruction {cons("IUSHR")}
+		"ixor" 	-> Instruction {cons("IXOR")}
+		
+		"ladd" 	-> Instruction {cons("LADD")}
+		"land" 	-> Instruction {cons("LAND")}
+		"ldiv" 	-> Instruction {cons("LDIV")}
+		"lmul" 	-> Instruction {cons("LMUL")}
+		"lneg" 	-> Instruction {cons("LNEG")}
+		"lor" 	-> Instruction {cons("LOR")}
+		"lrem" 	-> Instruction {cons("LREM")}
+		"lshl" 	-> Instruction {cons("LSHL")}
+		"lshr" 	-> Instruction {cons("LSHR")}
+		"lsub" 	-> Instruction {cons("LSUB")}
+		"lushr" -> Instruction {cons("LUSHR")}
+		"lxor" 	-> Instruction {cons("LXOR")}
+		
+		"fadd" 	-> Instruction {cons("FADD")}
+		"fdiv" 	-> Instruction {cons("FDIV")}
+		"fmul" 	-> Instruction {cons("FMUL")}
+		"fneg" 	-> Instruction {cons("FNEG")}
+		"frem" 	-> Instruction {cons("FREM")}
+		"fsub" 	-> Instruction {cons("FSUB")}
+
+		"dadd" 	-> Instruction {cons("DADD")}
+		"ddiv" 	-> Instruction {cons("DDIV")}
+		"dmul" 	-> Instruction {cons("DMUL")}
+		"dneg" 	-> Instruction {cons("DNEG")}		
+		"drem" 	-> Instruction {cons("DREM")}
+		"dsub" 	-> Instruction {cons("DSUB")}
+		
+		"iinc" VarRef Amount -> Instruction {cons("IINC")}
+    
+    	Int 	-> Amount
+    	"-" Int -> Amount {cons("Neg")}
+    	
+    	"fcmpg" -> Instruction {cons("FCMPG")}
+    	"fcmpl" -> Instruction {cons("FCMPL")}
+    	
+    	"dcmpg" -> Instruction {cons("DCMPG")}
+    	"dcmpl" -> Instruction {cons("DCMPL")}
+    	
+    	"lcmp" 	-> Instruction {cons("LCMP")}
+    	
+    lexical restrictions
+    	
+     	"iinc" -/- ~[\ \t]
+  
+	    
\ No newline at end of file

Added: jasmin-spoofax/syntax/instructions/JasminXT-Control.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/syntax/instructions/JasminXT-Control.sdf	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,71 @@
+module instructions/JasminXT-Control
+
+imports
+	lexical/JasminXT-Names
+	lexical/JasminXT-Numbers
+	
+exports
+	
+	context-free syntax
+		
+		Int			-> LabelRef {cons("Absolute")}
+		"$+" Int	-> RelOffset {cons("RelativeFwd")}
+		"$-" Int	-> RelOffset {cons("RelativeBwd")}
+		
+		LabelRef	-> Target
+		RelOffset	-> Target
+		
+	context-free syntax
+		
+		"ifeq" Target 		-> Instruction {cons("IFEQ")} 
+		"iflt" Target 		-> Instruction {cons("IFLT")} 
+		"ifle" Target 		-> Instruction {cons("IFLE")} 
+		"ifne" Target 		-> Instruction {cons("IFNE")} 
+		"ifgt" Target 		-> Instruction {cons("IFGT")} 
+		"ifge" Target 		-> Instruction {cons("IFGE")} 
+		"ifnull" Target 	-> Instruction {cons("IFNULL")} 
+		"ifnonnull" Target 	-> Instruction {cons("IFNONNULL")} 
+		"if_icmpeq" Target 	-> Instruction {cons("IF_ICMPEQ")} 
+		"if_icmplt" Target 	-> Instruction {cons("IF_ICMPLT")} 
+		"if_icmple" Target 	-> Instruction {cons("IF_ICMPLE")} 
+		"if_icmpne" Target 	-> Instruction {cons("IF_ICMPNE")} 
+		"if_icmpgt" Target 	-> Instruction {cons("IF_ICMPGT")} 
+		"if_icmpge" Target 	-> Instruction {cons("IF_ICMPGE")} 
+		"if_acmpeq" Target 	-> Instruction {cons("IF_ACMPEQ")} 
+		"if_acmpne" Target 	-> Instruction {cons("IF_ACMPNE")} 
+		
+		"tableswitch"  Int TableEntry*  "default" ":" LabelRef -> Instruction {cons("Table")}
+		"lookupswitch"     LookupEntry* "default" ":" LabelRef -> Instruction {cons("Lookup")}
+		
+		LabelRef         -> TableEntry {cons("Jump")}
+		Int ":" LabelRef -> LookupEntry {cons("NPAIR")}
+		
+  		"goto" LabelRef   -> Instruction {cons("GOTO")}
+		"goto_w" LabelRef -> Instruction {cons("GOTO_W")}
+			
+	lexical restrictions
+		
+		"ifeq" 
+		"iflt" 
+		"ifle" 
+		"ifne" 
+		"ifgt" 
+		"ifge" 
+		"ifnull" 
+		"ifnonnull" 
+		"if_icmpeq" 
+		"if_icmplt" 
+		"if_icmple" 
+		"if_icmpne" 
+		"if_icmpgt" 
+		"if_icmpge" 
+		"if_acmpeq" 
+		"if_acmpne"
+		"tableswitch"
+		"goto" 	
+		"goto_w"		-/- ~[\ \t]
+		
+
+    	%% jsr  <label>
+	    %% jsr_w  <label>
+	    
\ No newline at end of file

Added: jasmin-spoofax/syntax/instructions/JasminXT-Conversion.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/syntax/instructions/JasminXT-Conversion.sdf	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,24 @@
+module instructions/JasminXT-Conversion
+
+exports
+	
+	context-free syntax
+		
+		"i2l" -> Instruction {cons("I2L")}
+		"i2f" -> Instruction {cons("I2F")}
+		"i2d" -> Instruction {cons("I2D")}
+		"l2f" -> Instruction {cons("L2F")}
+		"l2d" -> Instruction {cons("L2D")}
+		"f2d" -> Instruction {cons("F2D")}
+		
+		"int2byte" 	-> Instruction {cons("I2B")} %% TODO: recover i2b, i2s, i2c
+		"int2short" -> Instruction {cons("I2S")}
+		"int2char" 	-> Instruction {cons("I2C")}
+		
+		"l2i" -> Instruction {cons("L2I")}
+		"f2i" -> Instruction {cons("F2I")}
+		"f2l" -> Instruction {cons("F2L")}
+		"d2i" -> Instruction {cons("D2I")}
+		"d2l" -> Instruction {cons("D2L")}
+		"d2f" -> Instruction {cons("D2F")}
+		    
\ No newline at end of file

Added: jasmin-spoofax/syntax/instructions/JasminXT-Exceptions.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/syntax/instructions/JasminXT-Exceptions.sdf	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,7 @@
+module instructions/JasminXT-Exceptions
+
+exports
+
+	context-free syntax
+		
+		"athrow" -> Instruction {cons("ATHROW")}

Added: jasmin-spoofax/syntax/instructions/JasminXT-Instructions.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/syntax/instructions/JasminXT-Instructions.sdf	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,22 @@
+module instructions/JasminXT-Instructions
+
+imports
+
+	instructions/JasminXT-LoadStore
+	instructions/JasminXT-Arithmetic
+	instructions/JasminXT-Conversion
+	instructions/JasminXT-Objects
+	instructions/JasminXT-Stack
+	instructions/JasminXT-Control
+	instructions/JasminXT-Methods
+	instructions/JasminXT-Exceptions
+	instructions/JasminXT-Synchronisation
+	
+exports
+	context-free syntax
+		
+		"nop" 		 -> Instruction {cons("NOP")}
+		"breakpoint" -> Instruction {cons("BREAKPOINT")}
+
+		Int ":" Instruction -> PCInstruction {cons("PC")}
+				Instruction -> PCInstruction
\ No newline at end of file

Added: jasmin-spoofax/syntax/instructions/JasminXT-LoadStore.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/syntax/instructions/JasminXT-LoadStore.sdf	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,112 @@
+module instructions/JasminXT-LoadStore
+
+imports
+	
+	lexical/JasminXT-Names
+	lexical/JasminXT-Numbers
+	lexical/JasminXT-Strings
+	
+exports
+	
+	context-free syntax
+		
+		"bipush" Int -> Instruction {cons("BIPUSH")} %% pushes a byte onto the stack as an integer value
+		"sipush" Int -> Instruction {cons("SIPUSH")} %% pushes a signed integer onto the stack
+		
+		"iconst_m1" -> Instruction {cons("ICONST_M1")} %% loads the int value -1 onto the stack
+		"iconst_0" -> Instruction {cons("ICONST_0")} %% loads the int value 0 onto the stack
+		"iconst_1" -> Instruction {cons("ICONST_1")} %% loads the int value 1 onto the stack
+		"iconst_2" -> Instruction {cons("ICONST_2")} %% loads the int value 2 onto the stack
+		"iconst_3" -> Instruction {cons("ICONST_3")} %% loads the int value 3 onto the stack
+		"iconst_4" -> Instruction {cons("ICONST_4")} %% loads the int value 4 onto the stack
+		"iconst_5" -> Instruction {cons("ICONST_5")} %% loads the int value 5 onto the stack
+		
+		"lconst_0" -> Instruction {cons("LCONST_0")} %% pushes the long 0 onto the stack
+		"lconst_1" -> Instruction {cons("LCONST_1")} %% pushes the long 1 onto the stack
+
+		"fconst_0" -> Instruction {cons("FCONST_0")} %% pushes 0.0f on the stack
+		"fconst_1" -> Instruction {cons("FCONST_1")} %% pushes 1.0f on the stack
+		"fconst_2" -> Instruction {cons("FCONST_2")} %% pushes 2.0f on the stack
+		
+		"dconst_0" -> Instruction {cons("DCONST_0")} %% pushes the constant 0.0 onto the stack
+		"dconst_1" -> Instruction {cons("DCONST_1")} %% pushes the constant 1.0 onto the stack
+		
+		"aconst_null" -> Instruction {cons("ACONST_NULL")} %% pushes a null reference onto the stack
+		
+		"ldc"    Constant -> Instruction {cons("LDC")} %% pushes a constant from a constant pool (String, int or float) onto the stack
+    	"ldc2_w" Constant -> Instruction {cons("LDC2_W")} %% pushes a constant from a constant pool (double or long) onto the stack
+				
+		"iload" VarRef -> Instruction {cons("ILOAD")} %% loads an int value from a local variable
+		"lload" VarRef -> Instruction {cons("LLOAD")} %% loads a long value from a local variable
+		"fload" VarRef -> Instruction {cons("FLOAD")} %% loads a float value from a local variable
+		"dload" VarRef -> Instruction {cons("DLOAD")} %% loads a double value from a local variable
+		"aload" VarRef -> Instruction {cons("ALOAD")} %% loads a reference from a local variable
+		
+		"iload_0" -> Instruction {cons("ILOAD_0")} 
+		"iload_1" -> Instruction {cons("ILOAD_1")} 
+		"iload_2" -> Instruction {cons("ILOAD_2")} 
+		"iload_3" -> Instruction {cons("ILOAD_3")} 
+
+		"aload_0" -> Instruction {cons("ALOAD_0")} 
+		"aload_1" -> Instruction {cons("ALOAD_1")} 
+		"aload_2" -> Instruction {cons("ALOAD_2")} 
+		"aload_3" -> Instruction {cons("ALOAD_3")} 
+		
+		"lload_0" -> Instruction {cons("LLOAD_0")} 
+		"lload_1" -> Instruction {cons("LLOAD_1")} 
+		"lload_2" -> Instruction {cons("LLOAD_2")} 
+		"lload_3" -> Instruction {cons("LLOAD_3")} 
+
+		"dload_0" -> Instruction {cons("DLOAD_0")} 
+		"dload_1" -> Instruction {cons("DLOAD_1")} 
+		"dload_2" -> Instruction {cons("DLOAD_2")} 
+		"dload_3" -> Instruction {cons("DLOAD_3")} 
+		
+		"fload_0" -> Instruction {cons("FLOAD_0")} 
+		"fload_1" -> Instruction {cons("FLOAD_1")} 
+		"fload_2" -> Instruction {cons("FLOAD_2")} 
+		"fload_3" -> Instruction {cons("FLOAD_3")} 
+
+		"istore" VarRef -> Instruction {cons("ISTORE")} %% stores an int value into a local variable
+		"lstore" VarRef -> Instruction {cons("LSTORE")} %% stores a long value into a local variable
+		"fstore" VarRef -> Instruction {cons("FSTORE")} %% stores a float value into a local variable
+		"dstore" VarRef -> Instruction {cons("DSTORE")} %% stores a double value into a local variable
+		"astore" VarRef -> Instruction {cons("ASTORE")} %% stores a reference into a local variable
+
+		"istore_0" -> Instruction {cons("ISTORE_0")} 
+		"istore_1" -> Instruction {cons("ISTORE_1")} 
+		"istore_2" -> Instruction {cons("ISTORE_2")} 
+		"istore_3" -> Instruction {cons("ISTORE_3")} 
+
+		"astore_0" -> Instruction {cons("ASTORE_0")} 
+		"astore_1" -> Instruction {cons("ASTORE_1")} 
+		"astore_2" -> Instruction {cons("ASTORE_2")} 
+		"astore_3" -> Instruction {cons("ASTORE_3")} 
+		
+		"lstore_0" -> Instruction {cons("LSTORE_0")} 
+		"lstore_1" -> Instruction {cons("LSTORE_1")} 
+		"lstore_2" -> Instruction {cons("LSTORE_2")} 
+		"lstore_3" -> Instruction {cons("LSTORE_3")} 
+
+		"fstore_0" -> Instruction {cons("FSTORE_0")} 
+		"fstore_1" -> Instruction {cons("FSTORE_1")} 
+		"fstore_2" -> Instruction {cons("FSTORE_2")} 
+		"fstore_3" -> Instruction {cons("FSTORE_3")} 
+		
+		"dstore_0" -> Instruction {cons("DSTORE_0")} 
+		"dstore_1" -> Instruction {cons("DSTORE_1")} 
+		"dstore_2" -> Instruction {cons("DSTORE_2")} 
+		"dstore_3" -> Instruction {cons("DSTORE_3")} 
+
+	lexical restrictions
+		
+		"iload"
+		"lload"
+		"fload"
+		"dload"
+		"aload"
+		"istore"
+		"lstore"
+		"fstore"
+		"dstore"
+		"astore" -/- ~[\ \t]

Added: jasmin-spoofax/syntax/instructions/JasminXT-Methods.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/syntax/instructions/JasminXT-Methods.sdf	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,30 @@
+module instructions/JasminXT-Methods
+
+imports
+	lexical/JasminXT-Names
+	lexical/JasminXT-Descriptors
+	
+exports
+	context-free syntax
+				
+		"invokenonvirtual" MethodRef		-> Instruction {cons("INVOKESPECIAL")}
+		"invokevirtual"    MethodRef 		-> Instruction {cons("INVOKEVIRTUAL")}
+		"invokestatic"     MethodRef		-> Instruction {cons("INVOKESTATIC")}
+		"invokeinterface"  MethodRef Int	-> Instruction {cons("INVOKEINTERFACE")}
+		
+		"return"  -> Instruction {cons("RETURN")}   
+		"ireturn" -> Instruction {cons("IRETURN")} 
+		"lreturn" -> Instruction {cons("LRETURN")} 
+		"freturn" -> Instruction {cons("FRETURN")} 
+		"dreturn" -> Instruction {cons("DRETURN")} 
+		"areturn" -> Instruction {cons("ARETURN")} 
+
+	lexical restrictions
+		
+		"invokenonvirtual"
+		"invokevirtual"
+		"invokestatic"
+		"invokeinterface" -/- ~[\ \t]
+
+	%% ret <var-num>
+	    

Added: jasmin-spoofax/syntax/instructions/JasminXT-Objects.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/syntax/instructions/JasminXT-Objects.sdf	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,60 @@
+module instructions/JasminXT-Objects
+
+imports
+	
+	lexical/JasminXT-Names
+	lexical/JasminXT-Numbers
+	lexical/JasminXT-Descriptors
+	
+exports
+	context-free syntax
+		
+		"new" ClassName -> Instruction {cons("NEW")}
+		
+		"newarray"       BaseTypeName 	-> Instruction {cons("NEWARRAY")}
+		"anewarray"      ClassName		-> Instruction {cons("ANEWARRAY")}
+		"anewarray"      ArrayType		-> Instruction {cons("ANEWARRAY")}
+		"multianewarray" ArrayType Int	-> Instruction {cons("MULTIANEWARRAY")}
+
+		"getfield"  FieldRef -> Instruction {cons("GETFIELD")}
+		"putfield"  FieldRef -> Instruction {cons("PUTFIELD")}
+		"getstatic" FieldRef -> Instruction {cons("GETSTATIC")}
+		"putstatic" FieldRef -> Instruction {cons("PUTSTATIC")}
+	
+		"iaload" -> Instruction {cons("IALOAD")}
+		"laload" -> Instruction {cons("LALOAD")}
+		"baload" -> Instruction {cons("BALOAD")}
+		"caload" -> Instruction {cons("CALOAD")}
+		"saload" -> Instruction {cons("SALOAD")}
+		"faload" -> Instruction {cons("FALOAD")}
+		"daload" -> Instruction {cons("DALOAD")}
+		"aaload" -> Instruction {cons("AALOAD")}
+
+		"iastore" -> Instruction {cons("IASTORE")}
+		"lastore" -> Instruction {cons("LASTORE")}
+		"bastore" -> Instruction {cons("BASTORE")}
+		"castore" -> Instruction {cons("CASTORE")}
+		"sastore" -> Instruction {cons("SASTORE")}
+		"fastore" -> Instruction {cons("FASTORE")}
+		"dastore" -> Instruction {cons("DASTORE")}
+		"aastore" -> Instruction {cons("AASTORE")}
+		
+		"arraylength" -> Instruction {cons("ARRAYLENGTH")}
+		
+		"checkcast" ClassName  -> Instruction {cons("CHECKCAST")}
+		"instanceof" ClassName -> Instruction {cons("INSTANCEOF")}
+    
+    
+	lexical restrictions
+		
+		"new"
+		"newarray"
+		"anewarray"
+		"multianewarray"
+		"getfield"
+		"putfield"
+		"getstatic"
+		"putstatic"
+		"checkcast"
+		"instanceof"-/- ~[\ \t]
+    
\ No newline at end of file

Added: jasmin-spoofax/syntax/instructions/JasminXT-Stack.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/syntax/instructions/JasminXT-Stack.sdf	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,15 @@
+module instructions/JasminXT-Stack
+
+exports
+	
+	context-free syntax
+		
+		"pop"     -> Instruction {cons("POP")}
+		"pop2"    -> Instruction {cons("POP2")}    
+		"dup"     -> Instruction {cons("DUP")}
+		"dup2"    -> Instruction {cons("DUP2")}
+		"dup_x1"  -> Instruction {cons("DUP_X1")}
+		"dup2_x1" -> Instruction {cons("DUP2_X1")}
+		"dup_x2"  -> Instruction {cons("DUP_X2")}
+		"dup2_x2" -> Instruction {cons("DUP2_X2")}
+		"swap"    -> Instruction {cons("SWAP")}

Added: jasmin-spoofax/syntax/instructions/JasminXT-Synchronisation.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/syntax/instructions/JasminXT-Synchronisation.sdf	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,8 @@
+module instructions/JasminXT-Synchronisation
+
+exports
+
+	context-free syntax
+		
+		"monitorenter" -> Instruction {cons("MONITORENTER")}
+		"monitorexit"  -> Instruction {cons("MONITOREXIT")}

Added: jasmin-spoofax/syntax/lexical/JasminXT-Descriptors.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/syntax/lexical/JasminXT-Descriptors.sdf	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,40 @@
+module lexical/JasminXT-Descriptors
+
+imports lexical/JasminXT-Names
+
+exports 
+
+	%% Chapter 4	: The class File Format
+	%% Section 4.3	: Descriptors
+	
+	context-free syntax
+		
+		FieldType 	-> FieldDescriptor {cons("JBCFieldDesc")}
+		
+		FieldType	-> ParameterDescriptor
+		
+		FieldType 	-> ReturnDescriptor
+		"V"			-> ReturnDescriptor {cons("Void")}
+
+		BaseType	-> FieldType
+		ObjectType	-> FieldType
+		ArrayType	-> FieldType
+		
+		"B" 	-> BaseType {cons("Byte")}
+		"C" 	-> BaseType {cons("Char")}
+		"D" 	-> BaseType {cons("Double")}
+		"F" 	-> BaseType {cons("Float")}
+		"I" 	-> BaseType {cons("Int")}
+		"J" 	-> BaseType {cons("Long")}
+		"S" 	-> BaseType {cons("Short")}
+		"Z" 	-> BaseType {cons("Boolean")}
+
+	syntax %% avoid whitespaces in method descriptors, reference types, array types
+		
+		"(" <ParameterDescriptor-CF>* ")" <ReturnDescriptor-CF> -> <MethodDescriptor-CF> {cons("JBCMethodDesc")}
+				
+		"L" <ClassName-CF> ";"	-> <ObjectType-CF> {cons("Reference")}
+		
+		"[" <ComponentType-CF> 	-> <ArrayType-CF> {cons("Array")}
+
+		<FieldType-CF> 	-> <ComponentType-CF>
\ No newline at end of file

Added: jasmin-spoofax/syntax/lexical/JasminXT-Names.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/syntax/lexical/JasminXT-Names.sdf	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,57 @@
+module lexical/JasminXT-Names
+
+imports 
+	
+	lexical/JasminXT-Numbers
+	lexical/JasminXT-Descriptors
+	
+exports
+	
+	lexical syntax
+		
+		[A-Za-z] [A-Za-z0-9]* 	-> Identifier
+		
+		{Identifier "/"}+ 		-> QualifiedName
+		
+		~[\=\:\.\"\-\ \t\n\r]+	-> LabelName
+		
+	lexical restrictions
+		
+		Identifier -/- [a-zA-Z0-9]
+		LabelName -/- ~[\=\:\.\"\-\ \t\n\r]
+		
+	context-free syntax
+		
+		QualifiedName 	-> ClassName
+		
+		Identifier		-> FieldName
+		
+		Identifier		-> MethodName
+		"<init>"		-> MethodName {cons("Init")}
+		
+		Identifier		-> VarName
+		
+	syntax
+		
+		<ClassName-CF> "/" <FieldName-CF> <LAYOUT?-CF> <FieldDescriptor-CF>  -> <FieldRef-CF> {cons("JBCFieldRef")}
+			
+		<ClassName-CF> "/" <MethodName-CF> 			   <MethodDescriptor-CF> -> <MethodRef-CF> {cons("JBCMethodRef")}
+
+	context-free syntax
+		
+		%%VarName     -> VarRef	{cons("VarRef")}
+		Int			-> VarRef	{cons("VarNum")}
+		
+		LabelName 	-> LabelRef {cons("LabelRef")}
+		
+		"byte" 				-> BaseTypeName {cons("ByteName")}
+		"char" 				-> BaseTypeName {cons("CharName")}
+		"double" 			-> BaseTypeName {cons("DoubleName")}
+		"float"				-> BaseTypeName {cons("FloatName")}
+		"int" 				-> BaseTypeName {cons("IntName")}
+		"long" 				-> BaseTypeName {cons("LongName")}
+		"short"				-> BaseTypeName {cons("ShortName")}
+		"boolean"			-> BaseTypeName {cons("BooleanName")}
+		
+		
+		
\ No newline at end of file

Added: jasmin-spoofax/syntax/lexical/JasminXT-Numbers.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/syntax/lexical/JasminXT-Numbers.sdf	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,15 @@
+module lexical/JasminXT-Numbers
+
+exports
+	
+	lexical syntax
+		
+		[0-9] [0-9]* 	-> Int
+		
+	lexical restrictions
+		
+		Int -/- [0-9]
+
+	context-free syntax
+		
+		Int -> Constant
\ No newline at end of file

Added: jasmin-spoofax/syntax/lexical/JasminXT-Signatures.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/syntax/lexical/JasminXT-Signatures.sdf	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,14 @@
+module lexical/JasminXT-Signatures
+
+imports 
+	
+	lexical/JasminXT-Strings
+	lexical/JasminXT-Descriptors
+	
+exports
+	
+	lexical syntax
+		
+		String -> ClassSignature
+		String -> FieldSignature
+		
\ No newline at end of file

Added: jasmin-spoofax/syntax/lexical/JasminXT-Strings.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/syntax/lexical/JasminXT-Strings.sdf	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,18 @@
+module lexical/JasminXT-Strings
+
+exports
+	
+	lexical syntax
+		
+		'"' StringChar* '"' 	-> String
+    	
+		~[\"\\\n\r]				-> StringChar
+    	[\\] [nrtfb\"\'\\]		-> StringChar
+    	
+		[\\] 'u' HexDigit HexDigit HexDigit HexDigit	-> StringChar
+	
+		[0-9a-fA-F] -> HexDigit
+		
+	context-free syntax
+		
+		String -> Constant
\ No newline at end of file

Added: jasmin-spoofax/syntax/lexical/JasminXT-Whitespace.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/syntax/lexical/JasminXT-Whitespace.sdf	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,28 @@
+module lexical/JasminXT-Whitespace
+
+exports
+
+	lexical syntax
+  
+		[\ \t] 	-> LAYOUT
+		SEP 	-> LAYOUT
+    
+		( [\n\r] | Comment )+ 	-> SEP
+    
+		";" [\n\r] 							-> Comment
+		";" [\ \t] ~[\n\r]* ([\n\r] | EOF) 	-> Comment
+    
+		-> EOF
+  
+	lexical restrictions
+    
+		EOF -/- ~[]
+		SEP -/- [\;].[\ \t]
+		SEP -/- [\;].[\n\r]
+ 
+	context-free restrictions
+  
+		LAYOUT? -/- [\ \t\n\r]
+		LAYOUT? -/- [\;].[\ \t]
+		LAYOUT? -/- [\;].[\n\r]
+    

Added: jasmin-spoofax/test/ANewArray.j
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/test/ANewArray.j	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,52 @@
+; --- Copyright Jonathan Meyer 1996. All rights reserved. -----------------
+; File:      jasmin/examples/ANewArray.j
+; Author:    Jonathan Meyer, 10 July 1996
+; Purpose:   Shows how to use anewarray instruction
+; -------------------------------------------------------------------------
+;
+; This class demonstrates how to allocate a multidimensional
+; array using anewarray.
+;
+
+.class public examples/ANewArray
+.super java/lang/Object
+
+.method public <init>()V
+   aload_0
+   invokenonvirtual java/lang/Object/<init>()V
+   return
+.end method
+
+.method public static main([Ljava/lang/String;)V
+   .limit stack 4
+   .limit locals 2
+
+    ;
+    ; Allocates an array like:
+    ;      String x[][] = new String[2][5]
+    ;
+
+    ; Allocate spine for array and store it in local var 1
+    ; (i.e. String[2][])
+
+    iconst_2
+    anewarray [Ljava/lang/String;
+    astore_1
+
+    ; allocate first array of String[5] and store it in index 0
+    aload_1
+    iconst_0
+    bipush 5
+    anewarray java/lang/String
+    aastore
+
+    ; allocate second array of String[5] and store it in index 1
+    aload_1
+    iconst_1
+    bipush 5
+    anewarray java/lang/String
+    aastore
+
+    ; done ...
+    return
+.end method

Added: jasmin-spoofax/test/AnInterface.j
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/test/AnInterface.j	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,31 @@
+; --- Copyright Jonathan Meyer 1996. All rights reserved. -----------------
+; File:      jasmin/examples/AnInterface.j
+; Author:    Jonathan Meyer, 1 Oct 1996
+; Purpose:   A Java interface written in Jasmin
+; -------------------------------------------------------------------------
+
+;
+; This file shows how to use Jasmin to define an interface. It
+; is like the Java code:
+; 
+; interface public examples.AnInterface {
+;     void foo();
+; }
+;
+; See examples.Implementor for an example of a class that implements
+; this interface.
+;
+
+.interface public examples/AnInterface
+.super java/lang/Object     
+
+; (Interfaces should either inherit from Object, or from 
+;  another interface.)
+
+;
+; declare abstract method foo() - note that the method body is empty.
+;
+.method abstract foo()V
+.end method
+
+

Added: jasmin-spoofax/test/Arrays.j
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/test/Arrays.j	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,53 @@
+; --- Copyright Jonathan Meyer 1996. All rights reserved. -----------------
+; File:      jasmin/examples/Arrays.j
+; Author:    Jonathan Meyer, 10 July 1996
+; Purpose:   Example using JVM's anewarray and aaload/aastore
+; -------------------------------------------------------------------------
+
+;
+; This illustrates how to use the various JVM array instructions - though
+; it doesn't actually do anything very interesting with the arrays.
+;
+
+.class public examples/Arrays
+.super java/lang/Object
+
+; standard initializer
+.method public <init>()V
+   aload_0
+   invokenonvirtual java/lang/Object/<init>()V
+   return
+.end method
+
+.method public static main([Ljava/lang/String;)V
+   .limit locals 2
+   .limit stack 4
+
+   ; creates a new array of strings,
+   ; like:
+   ;      String[] myarray = new String[2];
+   iconst_2
+   anewarray java/lang/String
+   astore_1  ; stores this in local variable 1
+
+   ; this is like the code:
+   ;      myarray[0] = args[0];
+
+   aload_1     ; push my array on the stack
+   iconst_0
+   aload_0     ; push the array argument to main() on the stack
+   iconst_0
+   aaload      ; get its zero'th entry
+   aastore     ; and store it in my zero'th entry
+
+   ; now print out myarray[0]
+
+   getstatic java/lang/System/out Ljava/io/PrintStream;
+   aload_1
+   iconst_0
+   aaload
+   invokevirtual java/io/PrintStream/println(Ljava/lang/String;)V
+
+   ; done
+   return
+.end method

Added: jasmin-spoofax/test/Catch.j
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/test/Catch.j	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,79 @@
+; --- Copyright Jonathan Meyer 1996. All rights reserved. -----------------
+; File:      jasmin/examples/Catch.j
+; Author:    Jonathan Meyer, 10 July 1996
+; Purpose:   Catching and throwing exceptions
+; -------------------------------------------------------------------------
+
+;
+; This hows how to throw and catch Exceptions in Jasmin
+;
+
+.class public examples/Catch
+.super java/lang/Object
+
+; standard initializer
+.method public <init>()V
+    aload_0
+    invokenonvirtual java/lang/Object/<init>()V
+    return
+.end method
+
+.method public static main([Ljava/lang/String;)V
+
+    .limit locals 3
+    .limit stack 5
+
+    ; set up a handler to catch subclasses of java.lang.Exception
+    .catch java/lang/Exception from Label1 to Label2 using Handler
+
+    ; store System.out in local variable 1
+    getstatic java/lang/System/out Ljava/io/PrintStream;
+    astore_1
+
+    ; print out a message
+    aload_1
+    ldc " -- Before exception"
+    invokevirtual java/io/PrintStream/println(Ljava/lang/String;)V
+
+    ; construct an instance of Exception, initialize it with a string,
+    ; throw it. This is like the Java statement :
+    ;
+    ;     throw new Exception("My exception");
+    ;
+
+Label1:
+    new java/lang/Exception
+    dup
+    ldc "<my exception>"
+    invokenonvirtual java/lang/Exception/<init>(Ljava/lang/String;)V
+    athrow
+
+Label2:
+    aload_1
+    ldc " -- After exception"
+    invokevirtual java/io/PrintStream/println(Ljava/lang/String;)V
+
+    return
+
+    ; This is the handler for the exception
+
+Handler:
+    ; store the exception in local variable 2
+    astore_2
+
+    ; print out a message
+    aload_1
+    ldc " -- Caught exception: "
+    invokevirtual java/io/PrintStream/print(Ljava/lang/String;)V
+
+    ; call getMessage() to retrieve the message from the Exception...
+    aload_1
+    aload_2
+    invokevirtual java/lang/Throwable/getMessage()Ljava/lang/String;
+    ; ... now print it
+    invokevirtual java/io/PrintStream/println(Ljava/lang/String;)V
+
+    ; return to the code
+    goto Label2
+
+.end method

Added: jasmin-spoofax/test/Checkcast.j
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/test/Checkcast.j	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,35 @@
+; --- Copyright Jonathan Meyer 1996. All rights reserved. -----------------
+; File:      jasmin/examples/Checkcast.j
+; Author:    Jonathan Meyer, 10 July 1996
+; Purpose:   Catching and throwing exceptions
+; -------------------------------------------------------------------------
+
+
+
+;
+; Simple test for checkcast instruction
+;
+
+.class examples/Checkcast
+.super java/lang/Object
+
+;
+; standard initializer
+.method public <init>()V
+   aload_0
+   invokenonvirtual java/lang/Object/<init>()V
+   return
+.end method
+
+.method public static main()V
+   .limit stack 2
+
+   ; push System.out onto the stack
+   getstatic java/lang/System/out Ljava/io/PrintStream;
+
+   ; check that it is a PrintStream
+   checkcast java/io/PrintStream
+
+   ; done
+   return
+.end method

Added: jasmin-spoofax/test/Count.j
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/test/Count.j	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,56 @@
+; --- Copyright Jonathan Meyer 1996. All rights reserved. -----------------
+; File:      jasmin/examples/Count.j
+; Author:    Jonathan Meyer, 10 July 1996
+; Purpose:   Counts from 0 to 9, printing out the value
+; -------------------------------------------------------------------------
+
+.class public examples/Count
+.super java/lang/Object
+
+;
+; standard initializer
+.method public <init>()V
+   aload_0
+   invokenonvirtual java/lang/Object/<init>()V
+   return
+.end method
+
+.method public static main([Ljava/lang/String;)V
+       ; set limits used by this method
+       .limit locals 4
+       .limit stack 3
+
+       ; setup local variables:
+
+       ;    1 - the PrintStream object held in java.lang.System.out
+       getstatic java/lang/System/out Ljava/io/PrintStream;
+       astore_1
+
+       ;    2 - the integer 10 - the counter used in the loop
+       bipush 10
+       istore_2
+
+       ; now loop 10 times printing out a number
+
+     Loop:
+
+       ; compute 10 - <local variable 2> ...
+       bipush 10
+       iload_2
+       isub
+       invokestatic java/lang/String/valueOf(I)Ljava/lang/String;
+       astore_3
+       ; ... and print it
+       aload_1    ; push the PrintStream object
+       aload_3    ; push the string we just created - then ...
+       invokevirtual java/io/PrintStream/println(Ljava/lang/String;)V
+
+       ; decrement the counter and loop
+       iinc 2 -1
+       iload_2
+       ifne Loop 
+
+       ; done
+       return
+
+.end method

Added: jasmin-spoofax/test/HelloWeb.j
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/test/HelloWeb.j	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,91 @@
+; --- Copyright Jonathan Meyer 1996. All rights reserved. -----------------
+; File:      jasmin/examples/HelloWeb.j
+; Author:    Jonathan Meyer, 10 July 1996
+; Purpose:   Demonstration of a Jasmin-created applet
+; -------------------------------------------------------------------------
+; HelloWeb.j
+
+; This demonstrates how you can use Jasmin to create an applet.
+
+; The code below is like the Java code:
+;
+;     import java.applet.*;
+;     import java.awt.*;
+;
+;     public class HelloWeb extends Applet {
+;        private Font font;
+;
+;        public void init() {
+;            font = new Font("Helvetica", Font.BOLD, 48);
+;        }
+;
+;        public void paint(Graphics g) {
+;            g.setFont(font);
+;            g.drawString("Hello World!", 25, 50);
+;        }
+;     }
+
+
+.class public HelloWeb
+.super java/applet/Applet
+
+.field private font Ljava/awt/Font; 
+
+
+; my init() method - allocate a font and assign it to this.font.
+ 
+.method public init()V
+    .limit stack 5
+
+    ; Create a new Font and call its constructor with
+    ; "Helvetica", 1 (i.e. Font.BOLD), and 48.
+
+    new java/awt/Font
+    dup
+    ldc "Helvetica"
+    iconst_1
+    bipush 48
+    invokenonvirtual java/awt/Font/<init>(Ljava/lang/String;II)V
+
+    ; now store the Font on the stack in this.font
+    aload_0
+    swap
+    putfield HelloWeb/font Ljava/awt/Font;
+
+    ; done
+    return
+.end method
+
+; my paint() method - draws the string "Hello World!" using this.font.
+
+.method public paint(Ljava/awt/Graphics;)V
+    .limit stack 4
+    .limit locals 2
+
+    ; local variable 0 holds <this>
+    ; local variable 1 holds the java.awt.Graphics instance ('g').
+
+    ; g.setFont(this.font);
+    aload_1
+    aload_0
+    getfield HelloWeb/font Ljava/awt/Font;
+    invokevirtual java/awt/Graphics/setFont(Ljava/awt/Font;)V
+
+    ; g.drawString("Hello Web!", 25, 50);
+    aload_1
+    ldc "Hello Web!"
+    bipush 25
+    bipush 50
+    invokevirtual java/awt/Graphics/drawString(Ljava/lang/String;II)V
+
+    ; done
+    return
+.end method
+
+
+; standard constructor
+.method public <init>()V
+    aload_0
+    invokenonvirtual java/applet/Applet/<init>()V
+    return
+.end method

Added: jasmin-spoofax/test/HelloWorld.j
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/test/HelloWorld.j	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,31 @@
+.class public HelloWorld
+    .super java/lang/Object
+
+    ;
+    ; standard initializer (calls java.lang.Object's initializer)
+    ;
+    .method public <init>()V
+       aload_0
+       invokenonvirtual java/lang/Object/<init>()V
+       return
+    .end method
+
+    ;
+    ; main() - prints out Hello World
+    ;
+    .method public static main([Ljava/lang/String;)V
+       .limit stack 2   ; up to two items can be pushed
+
+       ; push System.out onto the stack
+       getstatic java/lang/System/out Ljava/io/PrintStream;
+
+       ; push a string onto the stack
+       ldc 42
+
+       ; call the PrintStream.println() method.
+       invokevirtual java/io/PrintStream/println(I)V
+	   new HelloWorld
+	   
+       ; done
+       return
+    .end method
\ No newline at end of file

Added: jasmin-spoofax/test/Implementor.j
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/test/Implementor.j	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,52 @@
+; --- Copyright Jonathan Meyer 1996. All rights reserved. -----------------
+; File:      jasmin/examples/HelloWorld.j
+; Author:    Jonathan Meyer, 10 July 1996
+; Purpose:   Shows how to define a class that implements an interface
+; -------------------------------------------------------------------------
+
+;
+; This class implements the examples.AnInterface interface - see
+; AnInterface.j
+;
+.class public examples/Implementor
+.super java/lang/Object
+.implements examples/AnInterface
+
+;
+; standard initializer
+;
+.method public <init>()V
+   aload_0
+
+   invokenonvirtual java/lang/Object/<init>()V
+   return
+.end method
+
+;
+; implement the foo()V method - this is an interface method
+;
+.method public foo()V
+   .limit stack 2
+
+   getstatic java/lang/System/out Ljava/io/PrintStream;
+   ldc "Hello Interface"
+   invokevirtual java/io/PrintStream/println(Ljava/lang/String;)V
+
+   ; done
+   return
+.end method
+
+.method public static main([Ljava/lang/String;)V
+    .limit stack 2
+
+    ; create a new one of me
+    new examples/Implementor
+    dup
+    invokenonvirtual examples/Implementor/<init>()V
+   
+    ; now call my interface method foo()
+    invokeinterface examples/AnInterface/foo()V 1
+
+    return
+.end method
+

Added: jasmin-spoofax/test/InvokeInterface.j
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/test/InvokeInterface.j	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,45 @@
+; --- Copyright Jonathan Meyer 1996. All rights reserved. -----------------
+; File:      jasmin/examples/InvokeInterface.j
+; Author:    Jonathan Meyer, 10 July 1996
+; Purpose:   Example of using invokeinterface
+; -------------------------------------------------------------------------
+;
+; Demonstrates invoking an interface method
+;
+
+.class public examples/InvokeInterface
+.super java/lang/Object
+
+; standard initializer
+.method public <init>()V
+   aload_0
+   invokenonvirtual java/lang/Object/<init>()V
+   return
+.end method
+
+;
+; This is a rather silly example - since the result of calling the
+; interface method isn't actually used. But it does illustrate how to
+; use invokeinterface.
+;
+
+.method public example(Ljava/util/Enumeration;)V
+    .limit stack 1
+    .limit locals 3
+
+    ; push local variable 1 (the Enumeration object)
+    aload_1
+
+    ; now call the hasMoreElements() interface method.
+    invokeinterface java/util/Enumeration/hasMoreElements()Z 1
+
+    ; store the integer result in local variable 2
+    istore_2
+
+    ; done
+    return
+.end method
+
+.method public static main([Ljava/lang/String;)V
+    return
+.end method

Added: jasmin-spoofax/test/MultiANewArray.j
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/test/MultiANewArray.j	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,37 @@
+; --- Copyright Jonathan Meyer 1996. All rights reserved. -----------------
+; File:      jasmin/examples/MultiANewArray.j
+; Author:    Jonathan Meyer, 10 July 1996
+; Purpose:   Example of multanewarray instruction
+; -------------------------------------------------------------------------
+;
+; This illustrates how to use multianewarray to allocate
+; an array.
+;
+
+.class public examples/MultiANewArray
+.super java/lang/Object
+
+; standard initializer
+.method public <init>()V
+   aload_0
+   invokenonvirtual java/lang/Object/<init>()V
+   return
+.end method
+
+.method public static main([Ljava/lang/String;)V
+
+   .limit locals 4
+   .limit stack 2
+
+   ;
+   ; This allocates an array like:
+   ;
+   ;      String s[][] = new String[2][5];
+   ;
+   iconst_2
+   iconst_5
+   multianewarray [[Ljava/lang/String; 2
+   astore_1
+
+   return
+.end method

Added: jasmin-spoofax/test/MultiArrays.j
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/test/MultiArrays.j	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,55 @@
+; --- Copyright Jonathan Meyer 1996. All rights reserved. -----------------
+; File:      jasmin/examples/MultiArrays.j
+; Author:    Jonathan Meyer, 10 July 1996
+; Purpose:   Examples involving multi-dimensional arrays
+; -------------------------------------------------------------------------
+;
+; This illustrates how to use multi-dimensional arrays in the Java VM
+; (though it doesn't actually do anything very interesting with the arrays.)
+;
+
+.class public examples/MultiArrays
+.super java/lang/Object
+
+; standard initializer
+.method public <init>()V
+   aload_0
+   invokenonvirtual java/lang/Object/<init>()V
+   return
+.end method
+
+.method public static main([Ljava/lang/String;)V
+
+   .limit locals 4
+   .limit stack 5
+
+   ; this is like:
+   ;    new int[2][5][]
+   iconst_2
+   iconst_5
+   multianewarray [[[I 2
+
+   ; store the result in local variable 1
+   astore_1
+
+   aload_1
+   iconst_1
+   aaload     ; stack now contains x[0]
+   astore_2   ; store the array in local variable 2
+
+   ; create a new array of 50 ints and store it in x[1][1]
+   aload_2
+   iconst_1
+   bipush 50
+   newarray int
+   aastore
+
+   ; create a new array of 60 ints and store it in x[1][2]
+   aload_2
+   iconst_2
+   bipush 60
+   newarray int
+   aastore
+
+   return
+.end method

Added: jasmin-spoofax/test/NewArray.j
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/test/NewArray.j	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,41 @@
+; --- Copyright Jonathan Meyer 1996. All rights reserved. -----------------
+; File:      jasmin/examples/NewArray.j
+; Author:    Jonathan Meyer, 10 July 1996
+; Purpose:   Example of newarray
+; -------------------------------------------------------------------------
+;
+; Example showing how to allocate an array using
+; newarray.
+;
+
+.class public examples/NewArray
+.super java/lang/Object
+
+.method public <init>()V
+   aload_0
+   invokenonvirtual java/lang/Object/<init>()V
+   return
+.end method
+
+.method public static main([Ljava/lang/String;)V
+   .limit stack 4
+   .limit locals 2
+
+   ; create an array like:
+   ;
+   ;     boolean b[] = new boolean[2]
+   ;
+   ; (stores it in local var 1)
+
+   iconst_2
+   newarray boolean
+   astore_1
+
+   ; b[0] = true;
+   aload_1
+   iconst_0
+   iconst_1
+   bastore
+
+   return
+.end method

Added: jasmin-spoofax/test/Switch.j
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/test/Switch.j	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,41 @@
+; --- Copyright Jonathan Meyer 1996. All rights reserved. -----------------
+; File:      jasmin/examples/Switch.j
+; Author:    Jonathan Meyer, 10 July 1996
+; Purpose:   Shows usage of lookupswitch and tableswitch
+; -------------------------------------------------------------------------
+
+;
+; Illustrates lookupswitch and tableswitch syntax for Jasmin
+;
+
+.class public examples/Switch
+.super java/lang/Object
+
+.method public <init>()V
+   aload_0
+   invokenonvirtual java/lang/Object/<init>()V
+   return
+.end method
+
+.method public static main([Ljava/lang/String;)V
+   .limit stack 3
+
+   iconst_1
+   lookupswitch
+	1 : Hello
+	2 : Goodbye
+     default : Foo
+
+   iconst_1
+   tableswitch 0
+	Hello
+	Goodbye
+     default : Foo
+
+Hello:
+Goodbye:
+Foo:
+
+   return
+
+.end method

Added: jasmin-spoofax/test/Uncaught.j
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/test/Uncaught.j	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,36 @@
+; --- Copyright Jonathan Meyer 1996. All rights reserved. -----------------
+; File:      jasmin/examples/Uncaught.j
+; Author:    Jonathan Meyer, 10 July 1996
+; Purpose:   Throws an exception - doesn't catch it
+; -------------------------------------------------------------------------
+
+;
+; This example class contains a main() method that throws
+; an exception but doesn't catch it -
+;
+.source "Uncaught.j"
+.class public examples/Uncaught
+.super java/lang/Object
+
+; specify the initializer method (as for HelloWorld)
+
+.method public <init>()V
+    ; just call Object's initializer
+    aload_0
+    invokenonvirtual java/lang/Object/<init>()V
+    return
+.end method
+
+; specify the "main" method - this throws an uncaught exception
+
+.method public static main([Ljava/lang/String;)V
+    .limit stack 2
+
+    new java/lang/Exception
+    dup
+    invokenonvirtual java/lang/Exception/<init>()V
+    athrow
+
+    ; without this the verifier might complain ...
+    return
+.end method

Added: jasmin-spoofax/test/VerifyTest.j
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/test/VerifyTest.j	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,41 @@
+; --- Copyright Jonathan Meyer 1996. All rights reserved. -----------------
+; File:      jasmin/examples/VerifyTest.j
+; Author:    Jonathan Meyer, 10 July 1996
+; Purpose:   Treats an int as an object - should alert the Verifier
+; -------------------------------------------------------------------------
+
+;
+; This code demonstrates the verifier at work. See also VerifyTest1.j.
+;
+; The main() method below tries to clone the integer 100 - this
+; is clearly an error since clone() expects an Object, not an integer.
+;
+; If you run this with no verification on, it is likely to crash the
+; interpreter. Running this with the -verify option produces a
+; Verifier error.
+;
+
+; This is similar to the Java code:
+;
+;    class VerifyTest {
+;        public static void main(String args[]) {
+;            int x = 100;
+;            x.clone();
+;        }
+;     }
+
+
+.class public examples/VerifyTest
+.super java/lang/Object
+
+.method public <init>()V
+   aload_0
+   invokenonvirtual java/lang/Object/<init>()V
+   return
+.end method
+
+.method public static main([Ljava/lang/String;)V
+    bipush 100
+    invokevirtual java/lang/Object/clone()Ljava/lang/Object;  
+    return
+.end method

Added: jasmin-spoofax/test/VerifyTest1.j
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/test/VerifyTest1.j	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,62 @@
+; --- Copyright Jonathan Meyer 1996. All rights reserved. -----------------
+; File:      jasmin/examples/VerifyTest1.j
+; Author:    Jonathan Meyer, 10 July 1996
+; Purpose:   Trys to pull one on the verifier
+; -------------------------------------------------------------------------
+
+; This file illustrates the bytecode verifier at work - the
+; code in the example() method below seems reasonable, but
+; Java's bytecode verifier will fail the code because the two points leading
+; to the Loop label (from the top of the method and from the ifne
+; statement) have different stack states.  Instead, a different approach
+; must be adopted  - e.g. by allocating an array, or simply writing:
+;
+;    aconst_null
+;    aconst_null
+;    aconst_null
+;    aconst_null
+
+; Note that many interpreters will run this code OK if you don't use
+; a verifier. The code itself is well behaved (it doesn't trash the
+; interpreter), but the approach it uses is disallowed by the verifier.
+;
+
+; Compile the example, then run it using:
+;
+;     % java -verify VerifyTest1
+;     VERIFIER ERROR VerifyTest1.example()V:
+;     Inconsistent stack height 1 != 0
+;
+
+.class public examples/VerifyTest1
+.super java/lang/Object
+
+.method public <init>()V
+   aload_0
+   invokenonvirtual java/lang/Object/<init>()V
+   return
+.end method
+
+.method public example()V
+    .limit locals 2
+    .limit stack  10
+
+    ; this tries to push four nulls onto the stack
+    ; using a loop - Java's verifier will fail this program
+
+    iconst_4     ; store 4 in local variable 1 (used as a counter)
+    istore_1
+
+  Loop:
+    aconst_null  ; push null onto the stack
+    iinc 1 -1    ; decrement local variable 4 (the counter variable)
+    iload_1
+    ifne Loop    ; jump back to Loop unless the variable has reached 0
+
+    return
+.end method
+
+.method public static main([Ljava/lang/String;)V
+    ; - do nothing : this is only to illustrate the bytecode verifier at work.
+    return
+.end method

Added: jasmin-spoofax/trans/analysis/main.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/trans/analysis/main.str	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,29 @@
+module analysis/main
+
+imports
+	lib/editor-common.generated
+
+imports	
+	include/JasminXT
+	
+	analysis/names/rename
+	analysis/names/map
+	analysis/names/check
+	
+		
+strategies
+
+	analyse =  origin-track-forced(rename-all ; store-all) 
+
+rules
+	
+	editor-analyse:
+		(ast, path, project-path) -> (ast', errors, warnings, notes)
+		with
+			editor-init;
+			<analyse> ast => ast';
+			<collect-all(editor-error, conc)> ast' 		=> errors;
+			<collect-all(editor-warning, conc)> ast' 	=> warnings;
+			<collect-all(editor-note, conc)> ast'		=> notes
+		
+	editor-note = fail
\ No newline at end of file

Added: jasmin-spoofax/trans/analysis/names/check.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/trans/analysis/names/check.str	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,30 @@
+module analysis/names/check
+
+imports
+	lib/environment
+
+imports
+	include/JasminXT
+	
+imports
+	analysis/names/namespaces
+	
+rules // undeclared elements
+	
+	editor-error:
+		LabelRef(l) -> (l, $[Lable [l] is not declared.])
+		where not ( <env-has-key(|Labels())> l )
+
+	
+rules // multiple declarations
+	
+	editor-error:
+		JBCLabel(l) -> (l, $[Multiple declarations for label [l].])
+		where not ( <env-lookup-unique(|Labels())> l )
+	
+rules // unused declarations
+	
+	editor-warning: 
+		JBCLabel(l) -> (l, $[Label [l] is never used.])
+		where not ( <env-has-element(|Labels())> l )	
+	
\ No newline at end of file

Added: jasmin-spoofax/trans/analysis/names/map.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/trans/analysis/names/map.str	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,39 @@
+module analysis/names/map
+
+imports
+	lib/environment
+	
+imports	
+	include/JasminXT
+	analysis/names/namespaces
+	
+strategies
+	
+	store-all = topdown(try(store)) 
+
+rules // declarations
+	
+	store : d at JBCClass(access, name) -> d where <store-current-class> name
+	
+	store : d at JBCField(access, name, descr, sig, init) -> d where <env-store-mapping(|Fields(<get-current-class>))> ((name, descr), d)
+	
+	store : d at JBCMethod(access, name, descr, stmts) -> d where <env-store-mapping(|Methods(<get-current-class>))> ((name, descr), d)
+	
+	store : d at JBCLabel(label) -> d where <env-store-mapping(|Labels())> (label, d)
+	
+rules // references
+	
+	store : r at JBCFieldRef(cname, fname, fdescr) -> r where <env-store-element(|Fields(cname))> (fname, fdescr)
+	
+	store : r at JBCMethodRef(cname, mname, mdescr) -> r where <env-store-element(|Methods(cname))> (mname, mdescr)
+	
+	store : r at LabelRef(l) -> r where <env-store-element(|Labels())> l
+
+rules
+	
+	store-current-class : 
+		name -> name
+		where
+			<env-store-mapping(|Main())> ("current-class", name)
+			
+	get-current-class = <env-lookup-local(|Main())> "current-class"
\ No newline at end of file

Added: jasmin-spoofax/trans/analysis/names/namespaces.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/trans/analysis/names/namespaces.str	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,9 @@
+module analysis/names/namespaces
+
+signature constructors // namespaces
+	
+	Labels: Namespace
+	Fields: ClassName -> Namespace
+	Methods: ClassName -> Namespace
+	
+	Main: Environment
\ No newline at end of file

Added: jasmin-spoofax/trans/analysis/names/rename.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/trans/analysis/names/rename.str	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,27 @@
+module analysis/names/rename
+
+imports 
+	lib/editor-common.generated
+	lib/namespace
+
+imports
+	include/JasminXT
+
+	analysis/names/namespaces
+	
+strategies
+
+	rename-all = alltd(rename)
+
+rules 
+	
+	rename: 
+		JBCMethod(access, name, descr, stmts) -> JBCMethod(access, name, descr, stmts')
+		where
+			new-scope(
+				<alltd(rename) ; alltd(rename-ref)> stmts => stmts'
+			)
+		
+	rename: JBCLabel(l) -> JBCLabel(<rename-declaration(|Labels())> l)	 
+	
+	rename-ref: LabelRef(l) -> LabelRef(<rename-reference(|Labels())> l)

Added: jasmin-spoofax/trans/editor/resolve.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/trans/editor/resolve.str	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,24 @@
+module editor/resolve
+
+imports
+	lib/environment
+
+imports
+	include/JasminXT
+	
+imports
+	analysis/names/namespaces
+		
+rules
+
+	editor-resolve: 
+		(node, position, ast, path, project-path) -> elem
+		where 
+			<resolve> node => elem
+		
+rules
+	
+	resolve : JBCFieldRef(cname, fname, fdesc) -> <env-lookup(|Fields(cname))> (fname, fdesc)
+	resolve : JBCMethodRef(cname, mname, mdesc) -> <env-lookup(|Methods(cname))> (mname, mdesc)
+	
+	resolve : LabelRef(l) -> <env-lookup(|Labels())> l

Added: jasmin-spoofax/trans/jasminxt.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ jasmin-spoofax/trans/jasminxt.str	Thu Dec  2 20:16:56 2010	(r21446)
@@ -0,0 +1,30 @@
+module jasminxt
+
+imports
+	lib/editor-common.generated
+
+imports
+	include/JasminXT
+
+imports
+	analysis/main
+	editor/resolve
+	
+rules // Main editor interface (defined by editor/JasminXT-Builders and -References.esv)
+  
+  // Analyzes the current program, returning a tuple with errors, warnings, and notes;
+  // each a list of (term, message) tuples or simply (message) terms.
+  editor-analyse:
+    (ast, path, project-path) -> (ast, errors, warnings, notes)
+    with
+      editor-init;
+      errors   := <collect-all(fail, conc)> ast;
+      warnings := <collect-all(fail, conc)> ast;
+      notes    := <collect-all(fail, conc)> ast
+  
+  // Prints the abstract syntax ATerm of a selection.
+  generate-aterm:
+    (selected, position, ast, path, project-path) -> (filename, result)
+    with
+      filename := <guarantee-extension(|"aterm")> path;
+      result   := selected // we just return the input term
\ No newline at end of file

From karltk at strategoxt.org  Fri Dec  3 12:14:55 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Fri, 03 Dec 2010 11:14:55 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21447 - in
	strategoxt-javascript-backend/trunk: src/javascript tests/basic
Message-ID: <201012031114.oB3BEtVj027727@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Fri Dec  3 11:14:55 2010
New Revision: 21447
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21447&sc=1

Log:
* Added additional hashtable functions to improve dynrules support; not entirely complete yet.

Modified:
   strategoxt-javascript-backend/trunk/src/javascript/ssl.js
   strategoxt-javascript-backend/trunk/src/javascript/terms.js
   strategoxt-javascript-backend/trunk/tests/basic/dynrules_2.str
   strategoxt-javascript-backend/trunk/tests/basic/dynrules_3.str
   strategoxt-javascript-backend/trunk/tests/basic/dynrules_4.str
   strategoxt-javascript-backend/trunk/tests/basic/dynrules_5.str

Modified: strategoxt-javascript-backend/trunk/src/javascript/ssl.js
==============================================================================
--- strategoxt-javascript-backend/trunk/src/javascript/ssl.js	Thu Dec  2 20:16:56 2010	(r21446)
+++ strategoxt-javascript-backend/trunk/src/javascript/ssl.js	Fri Dec  3 11:14:55 2010	(r21447)
@@ -172,6 +172,19 @@
 			var idx = this._counter++;
 			this._hash[key] = idx; 
 			return idx;
+		},
+		sortedKeySet: function() {
+			var r = [];
+			var sorter = function (a, b) { return a.v - b.v; }
+			for(var x in this._hash) {
+				r.push({t:x,v:this._hash[x]});
+			}
+			r.sort(sorter);
+			var rr = [];
+			for(var x in r) {
+				rr.push(x.t)
+			}
+			return rr;
 		}
 	}
 }
@@ -200,6 +213,11 @@
 	return StrategoJS.SSL._indexedSets.length - 1;
 }
 
+StrategoJS.SSL.SSL_indexedSet_destroy = function(ctx, currentTerm, setIndex) {
+	delete StrategoJS.SSL._indexedSets[setIndex];
+	return currentTerm;
+}
+
 StrategoJS.SSL.SSL_indexedSet_put = function(ctx, currentTerm, strategy, setIndex, key) {
 	var set = StrategoJS.SSL._indexedSets[setIndex];
 	var keyAsString = ctx.factory.prettify(key);
@@ -219,16 +237,54 @@
 	return r === undefined ? null : r;
 }
 
+StrategoJS.SSL.SSL_indexedSet_elements = function(ctx, currentTerm, setIndex) {
+	var set = StrategoJS.SSL._indexedSets[setIndex];
+	print("SSL_indexedSet_elements " + setIndex);
+	var tmp = set.sortedKeySet();
+	print(tmp);
+	var r = ctx.factory.makeEmptyList();
+	for(int i = tmp.length - 1; i >= 0; i--) {
+		r = ctx.factory.makeListCons(tmp[i], r);
+	}
+	return r;
+}
+
 StrategoJS.SSL.SSL_hashtable_create = function(ctx, currentTerm, initialSize, maxLoad) {
 	print("SSL_hashtable_create");
 	StrategoJS.SSL._hashtables.push(_makeHashtable());
 	return StrategoJS.SSL._hashtables.length - 1;
 }
 
+StrategoJS.SSL.SSL_hashtable_destroy = function(ctx, currentTerm, hashIndex) {
+	delete StrategoJS.SSL._hashtables[hashIndex];
+	return currentTerm;
+}
+
 StrategoJS.SSL.SSL_hashtable_put = function(ctx, currentTerm, hashIndex, key, value) {
 	var hash = StrategoJS.SSL._hashtables[hashIndex];
 	var keyAsString = ctx.factory.prettify(key);
 	print("SSL_hashtable_put " + hashIndex + " " + keyAsString);
 	hash[keyAsString] = value;
 	return hashIndex;
-}
\ No newline at end of file
+}
+
+StrategoJS.SSL.SSL_hashtable_keys = function(ctx, currentTerm, hashIndex, key, value) {
+	print("SSL_hashtable_keys " + hashIndex);
+	var hash = StrategoJS.SSL._hashtables[hashIndex];
+	var r = ctx.factory.makeEmptyList();
+	for(var k in hash) {
+		print(k);
+		r = ctx.factory.makeListCons(ctx.factory.parse(k), r);
+	}
+	print("< " + ctx.factory.prettify(r));
+	return r;
+}
+
+StrategoJS.SSL.SSL_hashtable_remove = function(ctx, currentTerm, hashIndex, key) {
+	var hash = StrategoJS.SSL._hashtables[hashIndex];
+	var keyAsString = ctx.factory.prettify(key);
+	print("SSL_hashtable_remove " + hashIndex + " " + keyAsString);
+	delete hash[keyAsString];
+	return hashIndex;
+}
+

Modified: strategoxt-javascript-backend/trunk/src/javascript/terms.js
==============================================================================
--- strategoxt-javascript-backend/trunk/src/javascript/terms.js	Thu Dec  2 20:16:56 2010	(r21446)
+++ strategoxt-javascript-backend/trunk/src/javascript/terms.js	Fri Dec  3 11:14:55 2010	(r21447)
@@ -56,7 +56,7 @@
 			// FIXME(karltk) how to print annotated list conses?
 			doPrettify(term.term, builder);
 			builder.push("{");
-			listPrettify(term.annos, builder);
+			listPrettify(term.annos, builder, true);
 			builder.push("}");
 			return builder;
 		}
@@ -132,10 +132,12 @@
 		doListPrettify(tail, builder);
 	}
 	
-	var listPrettify = function(list, builder) {
-		builder.push("[");
+	var listPrettify = function(list, builder, skipParens) {
+		if(!skipParens)
+			builder.push("[");
 		doListPrettify(list, builder);
-		builder.push("]");
+		if(!skipParens)
+			builder.push("]");
 	}
 
 	var PushbackStringIterator = function(text) {

Modified: strategoxt-javascript-backend/trunk/tests/basic/dynrules_2.str
==============================================================================
--- strategoxt-javascript-backend/trunk/tests/basic/dynrules_2.str	Thu Dec  2 20:16:56 2010	(r21446)
+++ strategoxt-javascript-backend/trunk/tests/basic/dynrules_2.str	Fri Dec  3 11:14:55 2010	(r21447)
@@ -1,7 +1,7 @@
 module dynrules_2
 
 imports
-  libstratego-lib
+  emu-libstratego-lib
 
 rules
 

Modified: strategoxt-javascript-backend/trunk/tests/basic/dynrules_3.str
==============================================================================
--- strategoxt-javascript-backend/trunk/tests/basic/dynrules_3.str	Thu Dec  2 20:16:56 2010	(r21446)
+++ strategoxt-javascript-backend/trunk/tests/basic/dynrules_3.str	Fri Dec  3 11:14:55 2010	(r21447)
@@ -1,7 +1,7 @@
 module dynrules_3
 
 imports
-  libstratego-lib
+  emu-libstratego-lib
 
 rules
 

Modified: strategoxt-javascript-backend/trunk/tests/basic/dynrules_4.str
==============================================================================
--- strategoxt-javascript-backend/trunk/tests/basic/dynrules_4.str	Thu Dec  2 20:16:56 2010	(r21446)
+++ strategoxt-javascript-backend/trunk/tests/basic/dynrules_4.str	Fri Dec  3 11:14:55 2010	(r21447)
@@ -1,7 +1,7 @@
 module dynrules_4
 
 imports
-  libstratego-lib
+  emu-libstratego-lib
 
 rules
 

Modified: strategoxt-javascript-backend/trunk/tests/basic/dynrules_5.str
==============================================================================
--- strategoxt-javascript-backend/trunk/tests/basic/dynrules_5.str	Thu Dec  2 20:16:56 2010	(r21446)
+++ strategoxt-javascript-backend/trunk/tests/basic/dynrules_5.str	Fri Dec  3 11:14:55 2010	(r21447)
@@ -1,7 +1,7 @@
 module dynrules_5
 
 imports
-  libstratego-lib
+  emu-libstratego-lib
 
 rules
 

From r.t.lindeman at student.tudelft.nl  Fri Dec  3 12:44:39 2010
From: r.t.lindeman at student.tudelft.nl (Ricky Lindeman)
Date: Fri, 03 Dec 2010 11:44:39 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21448 - in
	spoofax-imp/trunk: org.strategoxt.imp.debug.core/lib
	org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/launching
	org.strategoxt.imp.debug.stratego....
Message-ID: <201012031144.oB3Bidv1028022@proliant.st.ewi.tudelft.nl>

Author: RickyLindeman
Date: Fri Dec  3 11:44:39 2010
New Revision: 21448
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21448&sc=1

Log:
Fixed: recompile stratego program when no class files are found (even when recompile=false)

Added:
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/util/DebugCompileException.java
Modified:
   spoofax-imp/trunk/org.strategoxt.imp.debug.core/lib/stratego-debug-core.jar
   spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/launching/StrategoLaunchDelegate.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/util/DebugCompiler.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/util/DebugSessionSettings.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.ui/src/org/strjdbg/eclipse/ui/str/launching/StrategoLaunchShortcut.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.core/lib/stratego-debug-core.jar
==============================================================================
Binary file (source and/or target). No diff available.

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/launching/StrategoLaunchDelegate.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/launching/StrategoLaunchDelegate.java	Fri Dec  3 11:14:55 2010	(r21447)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/launching/StrategoLaunchDelegate.java	Fri Dec  3 11:44:39 2010	(r21448)
@@ -28,6 +28,7 @@
 import org.eclipse.jdt.launching.IVMRunner;
 import org.eclipse.jdt.launching.JavaRuntime;
 import org.eclipse.jdt.launching.VMRunnerConfiguration;
+import org.strategoxt.debug.core.util.DebugCompileException;
 import org.strategoxt.debug.core.util.DebugCompiler;
 import org.strategoxt.debug.core.util.DebugSessionSettings;
 import org.strjdbg.eclipse.core.str.model.StrategoDebugTarget;
@@ -116,40 +117,39 @@
 		
 		DebugCompiler debugCompiler = new DebugCompiler("/tmp");
 		String projectName = DebugCompiler.createProjectName(new File(program));
-		
+		DebugSessionSettings debugSessionSettings = new DebugSessionSettings("/tmp", projectName);
+		debugSessionSettings.setStrategoSourceBasedir(strategoSourceBasedir);
+		debugSessionSettings.setStrategoFilePath(strategoFilePath);
 		// compile the stratego program
-		String binBase = "/tmp/"+projectName+"/class";
+		String binBase = debugSessionSettings.getClassDirectory(); // default
 		if (rebuildBinary)
 		{
-			monitor.subTask("Compiling stratego program");
-			if (mode.equals(ILaunchManager.DEBUG_MODE)) 
+			binBase = compile(monitor, mode, debugCompiler, debugSessionSettings);
+		}
+		else
+		{
+			// TODO: check if all the necessary files exist in the working dir...
+			// check if binBase contains javafiles
+			IPath binBasePath = new Path(binBase);
+			File binBaseFile = binBasePath.toFile();
+			if (!binBaseFile.exists())
 			{
-				
-				try {
-					binBase = debugCompiler.debugCompile(strategoSourceBasedir, strategoFilePath, projectName);
-				} catch (IOException e) {
-					// TODO Auto-generated catch block
-					e.printStackTrace();
-				}
-				catch (Exception e) {
-					// TODO Auto-generated catch block
-					e.printStackTrace();
-				}
+				// did not compile to class files
+				// try to compile it
+				System.out.println("Class files not found, compile...");
+				binBase = compile(monitor, mode, debugCompiler, debugSessionSettings);
 			}
-			else if (mode.equals(ILaunchManager.RUN_MODE))
+			else
 			{
-				try {
-					binBase = debugCompiler.runCompile(strategoSourceBasedir, strategoFilePath, projectName);
-				} catch (IOException e) {
-					// TODO Auto-generated catch block
-					e.printStackTrace();
+				// check if dir is empty
+				String[] files = binBaseFile.list();
+				if (files == null || files.length == 0)
+				{
+					System.out.println("Class files not found, compile...");
+					binBase = compile(monitor, mode, debugCompiler, debugSessionSettings);
 				}
 			}
-			monitor.worked(3);
-		}
-		else
-		{
-			// TODO: check if all the necessary files exist in the working dir...
+			
 		}
 		
 		monitor.subTask("Starting Stratego VM");
@@ -190,7 +190,7 @@
 		}
 		
 
-		DebugSessionSettings debugSessionSettings = new DebugSessionSettings("/tmp", projectName);
+		
 		if (mode.equals(ILaunchManager.DEBUG_MODE)) {
 			monitor.subTask("Attaching to the Stratego VM");
 			StrategoDebugTarget target = new StrategoDebugTarget(debugSessionSettings, launch, port);
@@ -209,6 +209,52 @@
 		monitor.done();
 	}
 	
+	private String compile(IProgressMonitor monitor, String mode, DebugCompiler debugCompiler, DebugSessionSettings debugSessionSettings)
+	{
+		monitor.subTask("Compiling stratego program");
+		String binBase = null;
+		if (mode.equals(ILaunchManager.DEBUG_MODE)) 
+		{
+			binBase = debugCompile(debugCompiler, debugSessionSettings);
+
+		}
+		else if (mode.equals(ILaunchManager.RUN_MODE))
+		{
+			binBase = runCompile(debugCompiler, debugSessionSettings);
+		}
+		monitor.worked(3);
+		return binBase;
+	}
+	
+	private String debugCompile(DebugCompiler debugCompiler, DebugSessionSettings debugSessionSettings)
+	{
+		// compile for a debug
+		String binBase = null;
+		try {
+			binBase = debugCompiler.debugCompile(debugSessionSettings);
+		} catch (IOException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		} catch (DebugCompileException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+		return binBase;
+	}
+	
+	private String runCompile(DebugCompiler debugCompiler, DebugSessionSettings debugSessionSettings)
+	{
+		// compile for a run
+		String binBase = null;
+		try {
+			binBase = debugCompiler.runCompile(debugSessionSettings);
+		} catch (IOException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+		return binBase;
+	}
+	
 	public static void showDebugInfo(IVMInstall defaultInstall, VMRunnerConfiguration vmRunnerConfiguration)
 	{
 		// show debug info

Added: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/util/DebugCompileException.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/util/DebugCompileException.java	Fri Dec  3 11:44:39 2010	(r21448)
@@ -0,0 +1,24 @@
+package org.strategoxt.debug.core.util;
+
+public class DebugCompileException extends Exception {
+
+	/**
+	 * 
+	 */
+	private static final long serialVersionUID = 8748784387087000852L;
+
+	public DebugCompileException(String message) {
+		// TODO Auto-generated constructor stub
+		super(message);
+	}
+	
+    public DebugCompileException(String message, Throwable cause) {
+        super(message, cause);
+    }
+    
+    public DebugCompileException(Throwable cause) {
+        super(cause);
+    }
+
+
+}

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/util/DebugCompiler.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/util/DebugCompiler.java	Fri Dec  3 11:14:55 2010	(r21447)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/util/DebugCompiler.java	Fri Dec  3 11:44:39 2010	(r21448)
@@ -31,6 +31,11 @@
 		this.workingDir = workingDir;
 	}
 	
+	public String getWorkingDir()
+	{
+		return this.workingDir;
+	}
+	
 	/**
 	 * Clear the contents of the given project directory.
 	 * 
@@ -59,6 +64,11 @@
 		
 	}
 	
+	public String runCompile(DebugSessionSettings debugSessionSettings) throws IOException
+	{
+		return this.runCompile(debugSessionSettings.getStrategoSourceBasedir(), debugSessionSettings.getStrategoFilePath(), debugSessionSettings.getProjectName());
+	}
+	
 	/**
 	 * Compile a stratego program to java classes.
 	 * 
@@ -88,7 +98,7 @@
 		String className = projectName;
 		String packageFolder = projectName;
 		String compiledStrategoFilename = projectJavaDir + "/" + packageFolder + "/" + className + ".java"; // packageName + className
-		String inputStrategoFilename = strategoFilePath;
+		String inputStrategoFilename = strategoSourceBasedir +"/" + strategoFilePath;
 		compileStratego(inputStrategoFilename, libraryName, compiledStrategoFilename); // stratego to java
 		
 		String sourceBasedir = projectJavaDir;
@@ -98,7 +108,10 @@
 		return binBase;	
 	}
 	
-
+	public String debugCompile(DebugSessionSettings debugSessionSettings) throws IOException, DebugCompileException
+	{
+		return this.debugCompile(debugSessionSettings.getStrategoSourceBasedir(), debugSessionSettings.getStrategoFilePath(), debugSessionSettings.getProjectName());
+	}
 
 	/**
 	 * Compile a stratego program with debug information to java classes.
@@ -106,9 +119,10 @@
 	 * @param strategoFilePath strategoFilePath should point to the stratego file
 	 * @param projectName projectName is the name of the project, used to create temp folders
 	 * @return returns the basedir of the binary files
-	 * @throws Exception 
+	 * @throws FileNotFoundException 
+	 * @throws DebugCompileException 
 	 */
-	public String debugCompile(String strategoSourceBasedir, String strategoFilePath, String projectName) throws Exception
+	public String debugCompile(String strategoSourceBasedir, String strategoFilePath, String projectName) throws FileNotFoundException, DebugCompileException
 	{
 		// throw exception if completeInputPath does not exist
 		File absFilePath = new File(strategoSourceBasedir, strategoFilePath);
@@ -137,7 +151,7 @@
 		// TODO check if files are actually created!
 		if (generatedFiles == null || generatedFiles.isEmpty())
 		{
-			throw new Exception("Failed to compile stratego program with debug information");
+			throw new DebugCompileException("Failed to compile stratego program with debug information");
 		}
 		
 		// create lookup table
@@ -175,9 +189,9 @@
 	 * @param inputFilePath
 	 * @param outputFilename
 	 * @return
-	 * @throws Exception 
+	 * @throws DebugCompileException 
 	 */
-	protected List<String> generateStratego(String sourceBasedir, String inputFilePath, String strOutputBasedir, Collection<String> libraryPaths) throws Exception
+	protected List<String> generateStratego(String sourceBasedir, String inputFilePath, String strOutputBasedir, Collection<String> libraryPaths) throws DebugCompileException
 	{
 		// assume f is a valid file
 		File absInput = new File(sourceBasedir, inputFilePath);
@@ -260,7 +274,7 @@
 		if (hasFailed)
 		{
 			System.out.println("Adding debug information failed!");
-			throw new Exception("Adding debug information failed!");
+			throw new DebugCompileException("Adding debug information failed!");
 		}
 		return generatedFiles;
 	}

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/util/DebugSessionSettings.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/util/DebugSessionSettings.java	Fri Dec  3 11:14:55 2010	(r21447)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/util/DebugSessionSettings.java	Fri Dec  3 11:44:39 2010	(r21448)
@@ -51,6 +51,33 @@
 		return javaDirectory;
 	}
 	
+	public String getProjectName()
+	{
+		return this.projectName;
+	}
+	
+	private String strategoSourceBasedir = null;
+	private String strategoFilePath = null;
+	
+	
+	
+	
+	public String getStrategoSourceBasedir() {
+		return strategoSourceBasedir;
+	}
+
+	public void setStrategoSourceBasedir(String strategoSourceBasedir) {
+		this.strategoSourceBasedir = strategoSourceBasedir;
+	}
+
+	public String getStrategoFilePath() {
+		return strategoFilePath;
+	}
+
+	public void setStrategoFilePath(String strategoFilePath) {
+		this.strategoFilePath = strategoFilePath;
+	}
+
 	private static String root = "/home/rlindeman/Documents/TU/webdsl/spoofax-imp/source";
 	public static String strategoxtjar = root+"/org.strategoxt.imp.debug.stratego.transformer/utils/strategoxt.jar";
 	public static String libstrategodebuglib = root + "/org.strategoxt.imp.debug.stratego.runtime/include/stratego-debug-runtime.jar";

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.ui/src/org/strjdbg/eclipse/ui/str/launching/StrategoLaunchShortcut.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.ui/src/org/strjdbg/eclipse/ui/str/launching/StrategoLaunchShortcut.java	Fri Dec  3 11:14:55 2010	(r21447)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.ui/src/org/strjdbg/eclipse/ui/str/launching/StrategoLaunchShortcut.java	Fri Dec  3 11:44:39 2010	(r21448)
@@ -35,7 +35,7 @@
         if (file != null) {
         	System.out.println("File: " + file.getFullPath());
         	// /stratego-resources/src-str/test/localvar/localvar.str
-        	List<ILaunchConfiguration> launchConfigs = searchStrategoLaunchConfigs(file.getFullPath().toOSString(), mode);
+        	List<ILaunchConfiguration> launchConfigs = searchStrategoLaunchConfigs(file, mode);
         	if (launchConfigs != null && !launchConfigs.isEmpty())
         	{
         		ILaunchConfiguration config = launchConfigs.get(0); // get the first
@@ -103,7 +103,7 @@
      * 
      * @param strategoProgramPath strategoProgramPath points to a stratego program, the path should start with "/{project-name}"
      */
-    private List<ILaunchConfiguration> searchStrategoLaunchConfigs(String strategoProgramPath, String mode)
+    private List<ILaunchConfiguration> searchStrategoLaunchConfigs(IFile strategoProgramPath, String mode)
     {
     	ILaunchManager manager = DebugPlugin.getDefault().getLaunchManager();
 
@@ -118,7 +118,7 @@
 				{
 					String program = config.getAttribute(IStrategoConstants.ATTR_STRATEGO_PROGRAM, "");
 					// TODO: should we equal on IPath objects instead of Strings?
-					if (program.equals(strategoProgramPath)) 
+					if (program.equals(strategoProgramPath.getFullPath().toOSString())) 
 					{
 						System.out.println(config.getModes());
 						launchConfigs.add(config);

From L.C.L.Kats at tudelft.nl  Fri Dec  3 14:55:08 2010
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Fri, 03 Dec 2010 13:55:08 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21449 -
	strategoxt/trunk/strc-core/lib/stratego/strc/parse
Message-ID: <201012031355.oB3Dt8Hw029615@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: Fri Dec  3 13:55:08 2010
New Revision: 21449
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21449&sc=1

Log:
Changed the --cache-dir path structure, hopefully helping with Spoofax/107.

Modified:
   strategoxt/trunk/strc-core/lib/stratego/strc/parse/parse-stratego.str

Modified: strategoxt/trunk/strc-core/lib/stratego/strc/parse/parse-stratego.str
==============================================================================
--- strategoxt/trunk/strc-core/lib/stratego/strc/parse/parse-stratego.str	Fri Dec  3 11:44:39 2010	(r21448)
+++ strategoxt/trunk/strc-core/lib/stratego/strc/parse/parse-stratego.str	Fri Dec  3 13:55:08 2010	(r21449)
@@ -231,8 +231,8 @@
     full-path -> cache-path
     with
       cache-dir  := <get-config> "--cache-dir";
-      full-path' := <string-replace(|"/", "+"); string-replace(|"\\", "+"); string-replace(|":", "+")> <guarantee-extension(|"rtree")> full-path;
-      cache-path := $[[cache-dir]/[full-path']]
+      full-path' := <string-replace(|"/", "+"); string-replace(|"\\", "+"); string-replace(|":", "+")> full-path;
+      cache-path := $[[cache-dir]/[full-path'].sig]
 
 /**
  * Main parsing strategies.

From karltk at strategoxt.org  Mon Dec  6 13:30:23 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Mon, 06 Dec 2010 12:30:23 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21450 - in
	strategoxt-javascript-backend/trunk: src/javascript
	src/stratego tests/basic tests/testlib
Message-ID: <201012061230.oB6CUNev013467@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Mon Dec  6 12:30:23 2010
New Revision: 21450
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21450&sc=1

Log:
* Fixed bug in equals().
 * Added undefined checking arond all calls, including prim-calls.
 * Added stack trace support.
 * Added some Rhino-specific I/O.

Deleted:
   strategoxt-javascript-backend/trunk/tests/basic/pp_java5_to_string.str
Modified:
   strategoxt-javascript-backend/trunk/src/javascript/emu-stratego-lib.js
   strategoxt-javascript-backend/trunk/src/javascript/srts.js
   strategoxt-javascript-backend/trunk/src/javascript/ssl.js
   strategoxt-javascript-backend/trunk/src/javascript/strategojs.js
   strategoxt-javascript-backend/trunk/src/javascript/terms.js
   strategoxt-javascript-backend/trunk/src/stratego/s2js.str
   strategoxt-javascript-backend/trunk/tests/basic/dynrules_4.str
   strategoxt-javascript-backend/trunk/tests/basic/readterm_1.str
   strategoxt-javascript-backend/trunk/tests/testlib/emu-libstratego-lib.str

Modified: strategoxt-javascript-backend/trunk/src/javascript/emu-stratego-lib.js
==============================================================================
--- strategoxt-javascript-backend/trunk/src/javascript/emu-stratego-lib.js	Fri Dec  3 13:55:08 2010	(r21449)
+++ strategoxt-javascript-backend/trunk/src/javascript/emu-stratego-lib.js	Mon Dec  6 12:30:23 2010	(r21450)
@@ -2,4 +2,4 @@
  * @author Karl Trygve Kalleberg
  */
 
-StrategoJS.StrategoLib = {}
\ No newline at end of file
+StrategoJS.StrategoLib = {}

Modified: strategoxt-javascript-backend/trunk/src/javascript/srts.js
==============================================================================
--- strategoxt-javascript-backend/trunk/src/javascript/srts.js	Fri Dec  3 13:55:08 2010	(r21449)
+++ strategoxt-javascript-backend/trunk/src/javascript/srts.js	Mon Dec  6 12:30:23 2010	(r21450)
@@ -26,13 +26,13 @@
 			nextStackPos--;
 		},
 		printStackTrace : function() {
-			log("Rewriting failed at:");
+			StrategoJS.log("rewriting failed, trace:");
 			for(var i = 0; i < maxStackPos; i++)
-				log(stack[i]);
+				StrategoJS.log("\t" + stack[i]);
 		},
 		popOnSuccess : function() {
-			maxStackPos--;
 			nextStackPos--;
+			maxStackPos = nextStackPos;
 		},
 		push : function(funName) {
 			if(nextStackPos < stack.length)

Modified: strategoxt-javascript-backend/trunk/src/javascript/ssl.js
==============================================================================
--- strategoxt-javascript-backend/trunk/src/javascript/ssl.js	Fri Dec  3 13:55:08 2010	(r21449)
+++ strategoxt-javascript-backend/trunk/src/javascript/ssl.js	Mon Dec  6 12:30:23 2010	(r21450)
@@ -1,5 +1,9 @@
 /**
  * @author Karl Trygve Kalleberg
+ * 
+ * Copyright (c) 2010, Karl Trygve Kalleberg
+ * Licensed under the GNU Lesser General Public License v2.1
+ * 
  */
 
 StrategoJS.SSL = {
@@ -35,31 +39,21 @@
 
 StrategoJS.SSL._makeAppl = function(factory, ctorName, args) {
 	var tmp = [];
-	print("makeAppl");
-	print(ctorName);
-	print(factory.prettify(args));
 	while(!factory.isEmptyList(args)) {
-		print(args);
 		tmp.push(factory.head(args));
 		args = factory.tail(args);
 	}
-
-	print("willmake");
 	if(ctorName.length == 0) {
 		return factory.makeTuple(tmp);
 	} else {
 		var ctor = factory.makeCtor(ctorName, tmp.length);
-		print("ctor");
-		print(ctor);
 		return factory.makeAppl(ctor, tmp);
 	}
 }
 
 StrategoJS.SSL.SSL_mkterm = function(ctx, currentTerm, ctorTerm, args) {
-	var factory = ctx.factory;
 	print("SSL_mkterm");
-	print(ctorTerm);
-	print(factory.prettify(args));
+	var factory = ctx.factory;
 	switch(factory.termType(ctorTerm)) {
 	case factory.STRING:
 		// FIXME how to make a string?
@@ -87,12 +81,35 @@
 }
 
 StrategoJS.SSL.SSL_write_term_to_stream_text = function(ctx, currentTerm, stream, outputTerm) {
+	print("SSL_write_term_to_stream_text");
 	var ctor = ctx.factory.getConstructor(stream);
 	if(ctx.factory.ctorEquals(ctor, StrategoJS.SSL._stdout) || ctx.factory.ctorEquals(ctor, StrategoJS.SSL._stderr))
 		print(ctx.factory.prettify(outputTerm));
-	else
-		throw "SSL_write_term_to_stream_text not fully implemented; cannot write to arbitrary streams";
-	return currentTerm;
+	else {
+		var f = StrategoJS.SSL._openFiles[stream]
+		f.write(ctx.factory.prettify(outputTerm));
+		f.flush();
+	}
+	return stream;
+}
+
+StrategoJS.SSL.SSL_read_term_from_stream = function(ctx, currentTerm, stream) {
+	print("SSL_read_term_from_stream");
+	var ctor = ctx.factory.getConstructor(stream);
+	if(ctx.factory.ctorEquals(ctor, StrategoJS.SSL._stdin))
+		throw "SSL_read_term_from_stream does not support stdin"; 
+	else {
+		var f = StrategoJS.SSL._openFiles[stream]
+		var r = "";
+		var s = f.readLine();
+		while(s !== null) {
+			r += s;
+			s = f.readLine();
+		}
+		r = ctx.factory.parse(r);
+		return r;
+	}
+	throw "unreachable";
 }
 
 StrategoJS.SSL.SSL_is_string = function(ctx, currentTerm, arg) {
@@ -102,23 +119,56 @@
 }
 
 StrategoJS.SSL.SSL_fputs = function(ctx, currentTerm, string, stream) {
+	print("SSL_fputs");
 	var ctor = ctx.factory.getConstructor(stream);
 	if(ctx.factory.ctorEquals(ctor, StrategoJS.SSL._stdout) || ctx.factory.ctorEquals(ctor, StrategoJS.SSL._stderr))
 		print(string);
 	else
 		throw "SSL_fputs not fully implemented; cannot write to arbitrary streams";
+	return currentTerm;
+}
+
+StrategoJS.SSL._openFiles = []
+
+StrategoJS.SSL.SSL_fopen = function(ctx, currentTerm, fileName, mode) {
+	print("SSL_fopen");
+	if(mode === "w") {
+		var f = new java.io.BufferedWriter(new java.io.FileWriter(fileName));
+		StrategoJS.SSL._openFiles.push(f)
+		return StrategoJS.SSL._openFiles.length - 1;
+	} else if(mode === "r") {
+		var f = new java.io.BufferedReader(new java.io.FileReader(fileName));
+		StrategoJS.SSL._openFiles.push(f)
+		return StrategoJS.SSL._openFiles.length - 1;
+	}
+	throw "SSL_fopen not implemented";
+}
+
+StrategoJS.SSL.SSL_fclose = function(ctx, currentTerm, stream) {
+	print("SSL_fclose");
+	var f = StrategoJS.SSL._openFiles[stream];
+	if(f) {
+		f.close();
+		StrategoJS.SSL._openFiles[stream] = null;
+	}
+	return stream;
 }
 
 StrategoJS.SSL.SSL_fputc = function(ctx, currentTerm, ch, stream) {
+	print("SSL_fputc");
 	var ctor = ctx.factory.getConstructor(stream);
 	if(ctx.factory.ctorEquals(ctor, StrategoJS.SSL._stdout) || ctx.factory.ctorEquals(ctor, StrategoJS.SSL._stderr))
 		print(String.fromCharCode(ch));
-	else
-		throw "SSL_fputc not fully implemented; cannot write to arbitrary streams";
+	else {
+		var f = StrategoJS.SSL._openFiles[stream];
+		f.write(String.fromCharCode(ch));
+		f.flush();
+	}
 	return currentTerm;
 }
 
 StrategoJS.SSL.SSL_get_constructor = function(ctx, currentTerm, term) {
+	print("SSL_get_constructor");
 	return ctx.factory.getConstructor(term);
 }
 
@@ -126,18 +176,21 @@
 	var tmp = [];
 	var factory = ctx.factory;
 	switch(factory.termType(term)) {
+	case factory.REAL:
+	case factory.INT:
+	case factory.STRING:
+		return factory.makeEmptyList();
 	case factory.LIST:
 		return term;
 	case factory.APPL:
+	case factory.TUPLE:
 		var r = factory.makeEmptyList();
 		for(var i = factory.getSubtermCount(term) - 1; i >= 0; i--) {
 			r = factory.makeListCons(factory.getSubterm(term, i), r);
 		}
 		return r;
-	default:
-		throw "not implemented SSL_get_arguments fully";
 	}
-	
+	throw "not implemented SSL_get_arguments fully";
 }
 
 StrategoJS.SSL.SSL_get_list_length = function(ctx, currentTerm, term) {
@@ -181,8 +234,8 @@
 			}
 			r.sort(sorter);
 			var rr = [];
-			for(var x in r) {
-				rr.push(x.t)
+			for(var i = 0; i < r.length; i++) {
+				rr.push(r[i].t);
 			}
 			return rr;
 		}
@@ -214,11 +267,13 @@
 }
 
 StrategoJS.SSL.SSL_indexedSet_destroy = function(ctx, currentTerm, setIndex) {
+	print("SSL_indexedSet_destroy");
 	delete StrategoJS.SSL._indexedSets[setIndex];
 	return currentTerm;
 }
 
 StrategoJS.SSL.SSL_indexedSet_put = function(ctx, currentTerm, strategy, setIndex, key) {
+	print("SSL_indexedSet_put : " + setIndex + " " + key);
 	var set = StrategoJS.SSL._indexedSets[setIndex];
 	var keyAsString = ctx.factory.prettify(key);
 	print("SSL_indexedSet_put " + setIndex + " " + keyAsString);
@@ -229,6 +284,7 @@
 }
 
 StrategoJS.SSL.SSL_indexedSet_getIndex = function(ctx, currentTerm, setIndex, key) {
+	print("SSL_indexedSet_getIndex");
 	var set = StrategoJS.SSL._indexedSets[setIndex];
 	var keyAsString = ctx.factory.prettify(key);
 	print("SSL_indexedSet_getIndex " + setIndex + " " + keyAsString);
@@ -238,12 +294,14 @@
 }
 
 StrategoJS.SSL.SSL_indexedSet_elements = function(ctx, currentTerm, setIndex) {
-	var set = StrategoJS.SSL._indexedSets[setIndex];
 	print("SSL_indexedSet_elements " + setIndex);
+	var set = StrategoJS.SSL._indexedSets[setIndex];
 	var tmp = set.sortedKeySet();
 	print(tmp);
 	var r = ctx.factory.makeEmptyList();
-	for(int i = tmp.length - 1; i >= 0; i--) {
+	for(var i = tmp.length - 1; i >= 0; i--) {
+		if(tmp[i] == undefined)
+			throw "undefined set element";
 		r = ctx.factory.makeListCons(tmp[i], r);
 	}
 	return r;
@@ -256,11 +314,13 @@
 }
 
 StrategoJS.SSL.SSL_hashtable_destroy = function(ctx, currentTerm, hashIndex) {
+	print("SSL_hashtable_destroy");
 	delete StrategoJS.SSL._hashtables[hashIndex];
 	return currentTerm;
 }
 
 StrategoJS.SSL.SSL_hashtable_put = function(ctx, currentTerm, hashIndex, key, value) {
+	print("SSL_hashtable_put");
 	var hash = StrategoJS.SSL._hashtables[hashIndex];
 	var keyAsString = ctx.factory.prettify(key);
 	print("SSL_hashtable_put " + hashIndex + " " + keyAsString);
@@ -281,6 +341,7 @@
 }
 
 StrategoJS.SSL.SSL_hashtable_remove = function(ctx, currentTerm, hashIndex, key) {
+	print("SSL_hashtable_remove");
 	var hash = StrategoJS.SSL._hashtables[hashIndex];
 	var keyAsString = ctx.factory.prettify(key);
 	print("SSL_hashtable_remove " + hashIndex + " " + keyAsString);

Modified: strategoxt-javascript-backend/trunk/src/javascript/strategojs.js
==============================================================================
--- strategoxt-javascript-backend/trunk/src/javascript/strategojs.js	Fri Dec  3 13:55:08 2010	(r21449)
+++ strategoxt-javascript-backend/trunk/src/javascript/strategojs.js	Mon Dec  6 12:30:23 2010	(r21450)
@@ -6,16 +6,6 @@
 
 StrategoJS = {}
 
-// Stolen from Crockford
-
-if (typeof Object.create !== 'function') {
-    Object.create = function (o) {
-        function F() {}
-        F.prototype = o;
-        return new F();
-    };
-}
-
 var dummy = function() {
 	var knownLibraries = [];
 	

Modified: strategoxt-javascript-backend/trunk/src/javascript/terms.js
==============================================================================
--- strategoxt-javascript-backend/trunk/src/javascript/terms.js	Fri Dec  3 13:55:08 2010	(r21449)
+++ strategoxt-javascript-backend/trunk/src/javascript/terms.js	Mon Dec  6 12:30:23 2010	(r21450)
@@ -31,6 +31,8 @@
 	}
 
 	function doEquals(lhs, rhs) {
+		if(!(lhs && rhs))
+			throw "equals on undefined";
 		var lt = typeof(lhs);
 		var rt = typeof(rhs);
 		if(lt !== rt) {
@@ -52,7 +54,9 @@
 	}
 	
 	function doPrettify(term, builder) {
-		if(typeof(term.annoType) !== 'undefined') {
+		if(term == undefined)
+			throw "doPrettify on undefined (" + term + ")";
+		if(term.annoType) {
 			// FIXME(karltk) how to print annotated list conses?
 			doPrettify(term.term, builder);
 			builder.push("{");
@@ -503,7 +507,7 @@
 					head : hd,
 					tail : tl,
 					equals : function(other) {
-						return other.termType == LIST && doEquals(hd, other.hd) && tl.equals(other.tail);
+						return other.termType == LIST && doEquals(hd, other.head) && tl.equals(other.tail);
 					}
 
 				};
@@ -582,8 +586,10 @@
 			},
 			
 			getSubterm : function(term, idx) {
-				StrategoJS.assert(term.termType == APPL || term.termType == TUPLE);
-				return term.getSubterm(idx);
+				var r = term.getSubterm(idx);
+				if(r === undefined)
+					throw "failed to get subterm " + idx + " for " + prettify(term); 
+				return r;
 			},
 
 			head : function(listTerm) {
@@ -600,9 +606,22 @@
 				return term.subtermCount;
 			},
 
-			getConstructor : function(appl) {
-				StrategoJS.assert(appl.termType == APPL);
-				return appl.getConstructor();
+			getConstructor : function(term) {
+				switch(termType(term)) {
+				case factory.INT:
+				case factory.REAL:
+					return term;
+				case factory.STRING:
+					return "\"" + term + "\""
+				case factory.APPL:
+					return term.getConstructor();
+				case factory.LIST:
+					return makeEmptyList();
+				case factory.TUPLE:
+					return "";
+				default:
+					throw "unknown term type";
+				}
 			},
 
 			ctorEquals : function(ctor1, ctor2) {
@@ -610,7 +629,7 @@
 			},
 
 			getAnnotations : function(annoterm) {
-				if(annoterm.annoType === ANNO)
+				if(annoterm.annoType)
 					return annoterm.annos;
 				else
 					return factory.makeEmptyList();

Modified: strategoxt-javascript-backend/trunk/src/stratego/s2js.str
==============================================================================
--- strategoxt-javascript-backend/trunk/src/stratego/s2js.str	Fri Dec  3 13:55:08 2010	(r21449)
+++ strategoxt-javascript-backend/trunk/src/stratego/s2js.str	Mon Dec  6 12:30:23 2010	(r21450)
@@ -111,13 +111,18 @@
   js-main-method =
   	!$[
   		c.main = function(term) {
-  			var t = main_0_0(rootCtx, SRTS._cliArgumentsToList(term, factory));
-  			if(t == null)
-  				rootCtx.debugLog("rewriting failed");
-  			else {
-  				rootCtx.debugLog(factory.prettify(t));
-  			}
-  			return t;
+  			try {
+  				var t = main_0_0(rootCtx, SRTS._cliArgumentsToList(term, factory));
+  				if(t != null) {
+  					rootCtx.debugLog(factory.prettify(t));
+  					return t;
+  				}
+			} catch(e) {
+				print("Stratego/JS internal exception :" + e);
+			}
+			//rootCtx.debugLog("rewriting failed");
+			rootCtx.printStackTrace();
+  			return null;
   		}
   	]	
 
@@ -155,7 +160,7 @@
   	SDefT(x, s*, t*, s) ->
   	$[
      function(ctx, term [param*]) {
-     	print("[x] : " + ctx.factory.prettify(term));
+       print("[x] : " + (term == undefined ? "undefined" : ctx.factory.prettify(term)));
        [bstm-init*]
        if(TRACES_ENABLED) ctx.push("[x]");
        [feil]: {
@@ -251,6 +256,8 @@
         if(term == null) {
         	print("[feil]"); 
             break [feil];
+        } else if(term == undefined) {
+        	throw "internal error: call to [x] produced 'undefined' result";
         }
   	]
   with
@@ -291,11 +298,16 @@
   translate-PrimT(|s,feil) :
     PrimT(f, s*, t*) ->
     $[ 
+      ctx.push("[f]");
       term = StrategoJS.SSL.[f](ctx, term [args]);
       if (term == null) {
+      	ctx.popOnFailure();
       	print("[feil]");
       	break [feil];
+      } else if(term == undefined) {
+      	throw "internal error: call to SSL.[f] gave undefined term"; 
       }
+      ctx.popOnSuccess();
     ]
     with
         s'*  := <map(lift-strategy-to-function)> s*

Modified: strategoxt-javascript-backend/trunk/tests/basic/dynrules_4.str
==============================================================================
--- strategoxt-javascript-backend/trunk/tests/basic/dynrules_4.str	Fri Dec  3 13:55:08 2010	(r21449)
+++ strategoxt-javascript-backend/trunk/tests/basic/dynrules_4.str	Mon Dec  6 12:30:23 2010	(r21450)
@@ -11,5 +11,11 @@
        Foo: None()    -> None()
        Foo: ("a", 2)  -> 3
      )
-   ; dr-all-keys(|"Foo"); debug => [Some("2"), None(), (a, 2)]
-   ; map(Foo) => [1{}, None(){}, 3{}]
+   ; dr-all-keys(|"Foo") ; debug 
+   ; where(one(?Some("2")))
+   ; where(one(?None()))
+   ; where(one(?("a", 2)))
+   ; map(Foo)
+   ; where(one(?1{}))
+   ; where(one(?None(){}))
+   ; where(one(?3{}))

Modified: strategoxt-javascript-backend/trunk/tests/basic/readterm_1.str
==============================================================================
--- strategoxt-javascript-backend/trunk/tests/basic/readterm_1.str	Fri Dec  3 13:55:08 2010	(r21449)
+++ strategoxt-javascript-backend/trunk/tests/basic/readterm_1.str	Mon Dec  6 12:30:23 2010	(r21450)
@@ -1,7 +1,7 @@
 module readterm_1
 
 imports
-  libstratego-lib
+  emu-libstratego-lib
 
 strategies
   

Modified: strategoxt-javascript-backend/trunk/tests/testlib/emu-libstratego-lib.str
==============================================================================
--- strategoxt-javascript-backend/trunk/tests/testlib/emu-libstratego-lib.str	Fri Dec  3 13:55:08 2010	(r21449)
+++ strategoxt-javascript-backend/trunk/tests/testlib/emu-libstratego-lib.str	Mon Dec  6 12:30:23 2010	(r21450)
@@ -1,106 +1,11 @@
 module emu-libstratego-lib
 imports
 	lang/dynamic-rules.str
-	
-signature
-  constructors
-    : ()
-    : a -> (a)
-    : a * b -> (a, b)
-    : a * b * c -> (a, b, c)
-    : a * b * c * d -> (a, b, c, d)
-    : a * b * c * d * e -> (a, b, c, d, e)
-    : a * b * c * d * e * f -> (a, b, c, d, e, f)
-    : a * b * c * d * e * f * g -> (a, b, c, d, e, f, g)
-    : a * b * c * d * e * f * g * h -> (a, b, c, d, e, f, g, h)
-    : a * b * c * d * e * f * g * h * i -> (a, b, c, d, e, f, g, h, i)
-    : a * b * c * d * e * f * g * h * i * j -> (a, b, c, d, e, f, g, h, i, j)
-    : a * b * c * d * e * f * g * h * i * j * k -> (a, b, c, d, e, f, g, h, i, j, k)
-    : a * b * c * d * e * f * g * h * i * j * k * l -> (a, b, c, d, e, f, g, h, i, j, k, l)
-    : a * b * c * d * e * f * g * h * i * j * k * l * m -> (a, b, c, d, e, f, g, h, i, j, k, l, m)
-    : a * b * c * d * e * f * g * h * i * j * k * l * m * n -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
-    : a * b * c * d * e * f * g * h * i * j * k * l * m * n * o -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
-    : a * b * c * d * e * f * g * h * i * j * k * l * m * n * o * p -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p)
-    : a * b * c * d * e * f * g * h * i * j * k * l * m * n * o * p * q -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)
-    : a * b * c * d * e * f * g * h * i * j * k * l * m * n * o * p * q * r -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r)
 
-signature
-  sorts List(a)
-  constructors
-    Nil  : List(a)
-    Cons : a * List(a) -> List(a)
-    Conc : List(a) * List(a) -> List(a)
+strategies
 
-signature
-  constructors
-  	Stream    : ImplDep -> Stream
-    stderr    : FileLoc
-    stdout    : FileLoc
-    stdin     : FileLoc
-
-signature
-  constructors
-    Some : a -> Option(a)
-    
-strategies 	 
-
-  oncetd(s) = rec x(s <+ one(x))
-
-  collect-one(s) = oncetd(s; ?t); !t
-  
-  length = ?t; prim("SSL_get_list_length", t)
-  
-  debug = where(<fprintnl> (stderr(), [<id>]))
-  
-  debug(msg) = where(<fprintnl> (stderr(), [<msg>,<id>]))
-  
-  fprint =
-    (?Stream(_) <+ stdio-stream, id)
-    ; ?(stream, <id>)
-    ; map(
-        where(
-          is-string
-        < <fputs> (<id>, stream)
-        + <write-in-text-to-stream> (stream, <id>)
-        )
-      )
-    ; !stream
-
-  fprintnl =
-    fprint; <fputc> ('\n', <?Stream(_) <+ stdio-stream>)
-
-  write-in-text-to-stream =
-    ?(Stream(stream), term); prim("SSL_write_term_to_stream_text", stream, term); !Stream(<id>)
-    
-  fputs =
-    ?(str, Stream(stream)); prim("SSL_fputs", str, stream); !Stream(<id>)
-    
-  map(s) =
-    rec x([] + [s | x])
-
-  fputc =
-    ?(c, Stream(stream)); prim("SSL_fputc", c, stream); !Stream(<id>)
-    
-  stdio-stream = ?stdin() ; stdin-stream
-  stdio-stream = ?stdout(); stdout-stream
-  stdio-stream = ?stderr(); stderr-stream
-  
-  stdin-stream  = prim("SSL_stdin_stream") ; !Stream(<id>)
-  stdout-stream = prim("SSL_stdout_stream"); !Stream(<id>)
-  stderr-stream = prim("SSL_stderr_stream"); !Stream(<id>)
+  perror = ?s; prim("SSL_perror", s)
 
-  is-string = ?x; prim("SSL_is_string", x)
+  report-run-time = <fprintnl> (stderr(), ["report-run-time not supported"])
 
-  filter(s) = [] + [s | filter(s)] <+ ?[_ | <filter(s)> ]
-  
-  try(s) = s <+ id
-  
-  inc = <add>  (<id>, 1)
-  
-  add  = ?(x,y); (prim("SSL_addi",x,y) <+ prim("SSL_addr",x,y))
-   
-  perror = ?s; prim("SSL_perror", s)
-  
   is-real = ?x; prim("SSL_is_real", x)
-  
-  report-run-time = <fprintnl> (stderr(), ["report-run-time not supported"])

From karltk at strategoxt.org  Mon Dec  6 16:38:48 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Mon, 06 Dec 2010 15:38:48 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21451 -
	strategoxt-javascript-backend/trunk/src/stratego
Message-ID: <201012061538.oB6Fcmir016497@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Mon Dec  6 15:38:48 2010
New Revision: 21451
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21451&sc=1

Log:
* Added support for term matching of str|int|real when they are annotated. Incurs a performance penalty.

Modified:
   strategoxt-javascript-backend/trunk/src/stratego/term-deconstruction.str

Modified: strategoxt-javascript-backend/trunk/src/stratego/term-deconstruction.str
==============================================================================
--- strategoxt-javascript-backend/trunk/src/stratego/term-deconstruction.str	Mon Dec  6 12:30:23 2010	(r21450)
+++ strategoxt-javascript-backend/trunk/src/stratego/term-deconstruction.str	Mon Dec  6 15:38:48 2010	(r21451)
@@ -103,7 +103,7 @@
   translate-Match(|s,feil) :
     Match(Str(str), e') -> 
     $[
-      if (factory.termType([e]) != factory.STRING || "[e_str]" !== [e]) {
+      if (factory.termType([e]) !== factory.STRING || !factory.match("[e_str]", [e])) {
       	print("[feil]");
         break [feil];
       }
@@ -115,7 +115,7 @@
   translate-Match(|s,feil) :
     Match(Int(i), e') -> 
     $[
-      if (factory.termType([e]) !== factory.INT || [e_int] !==  [e]) {
+      if (factory.termType([e]) !== factory.INT || !factory.match([e_int], [e])) {
         print("[feil]");
         break [feil];
       }
@@ -127,7 +127,7 @@
   translate-Match(|s,feil) :
     Match(Real(r), e') -> 
     $[
-      if (factory.termType([e]) !== factory.REAL || [e_real] !== [e]) {
+      if (factory.termType([e]) !== factory.REAL || !factory.match([e_real], [e])) {
       	print("[feil]");
         break [feil];
       }
@@ -142,7 +142,7 @@
   translate-Match(|s,feil) :
     Match(op at Op(c, ts), ReadFrom(e)) ->
     $[
-      if (factory.termType([e]) != factory.APPL || [e_nomatch]) {
+      if (factory.termType([e]) !== factory.APPL || [e_nomatch]) {
       	print("[feil]");
         break [feil];
       }

From karltk at strategoxt.org  Mon Dec  6 16:39:22 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Mon, 06 Dec 2010 15:39:22 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21452 -
	strategoxt-javascript-backend/trunk/src/stratego
Message-ID: <201012061539.oB6FdMkc016504@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Mon Dec  6 15:39:22 2010
New Revision: 21452
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21452&sc=1

Log:
* Initialize all closure vars to null.

Modified:
   strategoxt-javascript-backend/trunk/src/stratego/variable-access.str

Modified: strategoxt-javascript-backend/trunk/src/stratego/variable-access.str
==============================================================================
--- strategoxt-javascript-backend/trunk/src/stratego/variable-access.str	Mon Dec  6 15:38:48 2010	(r21451)
+++ strategoxt-javascript-backend/trunk/src/stratego/variable-access.str	Mon Dec  6 15:39:22 2010	(r21452)
@@ -14,7 +14,7 @@
     x{} -> $[ var [x] = null; ]
 
   to-js-vardecl:
-    x{Offset(i), Escapes()} -> $[ var [x] /* = new TermReference()*/; ]
+    x{Offset(i), Escapes()} -> $[ var [x] /* = new TermReference()*/ = null; ]
 
   js-VarToWrite :
     (x{}, e) -> $[ [x] = [e]; ]

From karltk at strategoxt.org  Mon Dec  6 16:39:59 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Mon, 06 Dec 2010 15:39:59 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21453 -
	strategoxt-javascript-backend/trunk/src/javascript
Message-ID: <201012061539.oB6Fdx07016522@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Mon Dec  6 15:39:59 2010
New Revision: 21453
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21453&sc=1

Log:
* Added sanity checking; cannot compare equality on undefined objects.

Modified:
   strategoxt-javascript-backend/trunk/src/javascript/terms.js

Modified: strategoxt-javascript-backend/trunk/src/javascript/terms.js
==============================================================================
--- strategoxt-javascript-backend/trunk/src/javascript/terms.js	Mon Dec  6 15:39:22 2010	(r21452)
+++ strategoxt-javascript-backend/trunk/src/javascript/terms.js	Mon Dec  6 15:39:59 2010	(r21453)
@@ -31,8 +31,7 @@
 	}
 
 	function doEquals(lhs, rhs) {
-		if(!(lhs && rhs))
-			throw "equals on undefined";
+		if(lhs === undefined || rhs === undefined) throw "equals on undefined";
 		var lt = typeof(lhs);
 		var rt = typeof(rhs);
 		if(lt !== rt) {

From karltk at strategoxt.org  Mon Dec  6 16:41:37 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Mon, 06 Dec 2010 15:41:37 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21454 - in
	strategoxt-javascript-backend/trunk: scripts src/javascript
	src/stratego tests/basic
Message-ID: <201012061541.oB6Ffc44016536@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Mon Dec  6 15:41:37 2010
New Revision: 21454
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21454&sc=1

Log:
* Added a bunch of new SSL prims, including gti, subti, strlen, exit, getenv (workaround), concat_strings, table_hashtable, implode_string, explode_string, stacktrace_get_all_frames_names (nominated for longest SSL function name).

Modified:
   strategoxt-javascript-backend/trunk/scripts/no-fail-check.sh
   strategoxt-javascript-backend/trunk/src/javascript/srts.js
   strategoxt-javascript-backend/trunk/src/javascript/ssl.js
   strategoxt-javascript-backend/trunk/src/stratego/s2js.str
   strategoxt-javascript-backend/trunk/tests/basic/dynrules_4.str
   strategoxt-javascript-backend/trunk/tests/basic/dynrules_5.str
   strategoxt-javascript-backend/trunk/tests/basic/extend_1.str
   strategoxt-javascript-backend/trunk/tests/basic/fetch_1.str
   strategoxt-javascript-backend/trunk/tests/basic/internal_1.str
   strategoxt-javascript-backend/trunk/tests/basic/internal_2.str
   strategoxt-javascript-backend/trunk/tests/basic/iset_1.str
   strategoxt-javascript-backend/trunk/tests/basic/iset_2.str

Modified: strategoxt-javascript-backend/trunk/scripts/no-fail-check.sh
==============================================================================
--- strategoxt-javascript-backend/trunk/scripts/no-fail-check.sh	Mon Dec  6 15:39:59 2010	(r21453)
+++ strategoxt-javascript-backend/trunk/scripts/no-fail-check.sh	Mon Dec  6 15:41:37 2010	(r21454)
@@ -2,5 +2,5 @@
 
 f="/tmp/strjs.exec.trace"
 tee $f
-x=$(tail -n 2 $f | egrep "failed|uncaught")
+x=$(tail -n 29 $f | egrep "rewriting failed|uncaught")
 [ "$x" == "" ]

Modified: strategoxt-javascript-backend/trunk/src/javascript/srts.js
==============================================================================
--- strategoxt-javascript-backend/trunk/src/javascript/srts.js	Mon Dec  6 15:39:59 2010	(r21453)
+++ strategoxt-javascript-backend/trunk/src/javascript/srts.js	Mon Dec  6 15:41:37 2010	(r21454)
@@ -42,6 +42,9 @@
 			nextStackPos++;
 			maxStackPos = nextStackPos;
 		},
+		getStackFrames : function() {
+			return stack.slice(0, maxStackPos);
+		},
 		factory : StrategoJS.Term
 	};
 };
@@ -49,6 +52,7 @@
 StrategoJS.SRTS.SRTS_one = function(ctx, term, fun) {
 	print("SRTS_one");
 	var factory = ctx.factory;
+	print(" : " + factory.prettify(term));
 	var termType = factory.termType(term)
 	switch(termType) {
 	case factory.REAL:
@@ -70,8 +74,9 @@
 				break;
 			}
 		}
-		if(!success)
+		if(!success) {
 			return null;
+		}
 		r = term;
 		for(var i = tmp.length-1; i >= 0; i--) {
 			r = factory.makeListCons(tmp[i], r);

Modified: strategoxt-javascript-backend/trunk/src/javascript/ssl.js
==============================================================================
--- strategoxt-javascript-backend/trunk/src/javascript/ssl.js	Mon Dec  6 15:39:59 2010	(r21453)
+++ strategoxt-javascript-backend/trunk/src/javascript/ssl.js	Mon Dec  6 15:41:37 2010	(r21454)
@@ -131,8 +131,8 @@
 StrategoJS.SSL._openFiles = []
 
 StrategoJS.SSL.SSL_fopen = function(ctx, currentTerm, fileName, mode) {
-	print("SSL_fopen");
-	if(mode === "w") {
+	print("SSL_fopen : " + fileName + " " + mode);
+	if(mode === "w" || mode === "a") {
 		var f = new java.io.BufferedWriter(new java.io.FileWriter(fileName));
 		StrategoJS.SSL._openFiles.push(f)
 		return StrategoJS.SSL._openFiles.length - 1;
@@ -141,7 +141,7 @@
 		StrategoJS.SSL._openFiles.push(f)
 		return StrategoJS.SSL._openFiles.length - 1;
 	}
-	throw "SSL_fopen not implemented";
+	throw "SSL_fopen not fully implemented, mode not supported : " + mode;
 }
 
 StrategoJS.SSL.SSL_fclose = function(ctx, currentTerm, stream) {
@@ -207,9 +207,14 @@
 	return ctx.factory.termType(term) == ctx.factory.REAL;
 }
 
-StrategoJS.SSL._hashtables = [{}];
+StrategoJS.SSL._hashtables = [
+                              {} /* table table */,  
+                              {} /* dynrule table */
+                              ];
 StrategoJS.SSL._indexedSets = [];
-StrategoJS.SSL._counter = 0;
+StrategoJS.SSL._counter     = 0;
+StrategoJS.SSL._TABLE_TABLE = 0;
+StrategoJS.SSL._DYN_TABLE   = 1;
 
 function _makeIndexedSet() {
 	return {
@@ -248,7 +253,7 @@
 
 StrategoJS.SSL.SSL_dynamic_rules_hashtable = function(ctx, currentTerm) {
 	print("SSL_dynamic_rules_hashtable");
-	return 1;
+	return StrategoJS.SSL._DYN_TABLE;
 }
 
 StrategoJS.SSL.SSL_hashtable_get = function(ctx, currentTerm, tableReference, key) {
@@ -302,7 +307,7 @@
 	for(var i = tmp.length - 1; i >= 0; i--) {
 		if(tmp[i] == undefined)
 			throw "undefined set element";
-		r = ctx.factory.makeListCons(tmp[i], r);
+		r = ctx.factory.makeListCons(ctx.factory.parse(tmp[i]), r);
 	}
 	return r;
 }
@@ -333,7 +338,6 @@
 	var hash = StrategoJS.SSL._hashtables[hashIndex];
 	var r = ctx.factory.makeEmptyList();
 	for(var k in hash) {
-		print(k);
 		r = ctx.factory.makeListCons(ctx.factory.parse(k), r);
 	}
 	print("< " + ctx.factory.prettify(r));
@@ -349,3 +353,84 @@
 	return hashIndex;
 }
 
+StrategoJS.SSL.SSL_explode_string = function(ctx, currentTerm, string) {
+	var f = ctx.factory;
+	var r = f.makeEmptyList();
+	for(var i = string.length - 1; i >= 0; i--) {
+		r = f.makeListCons(f.makeInt(string.charCodeAt(i)), r);
+	}
+	return r;
+}
+
+StrategoJS.SSL.SSL_implode_string = function(ctx, currentTerm, list) {
+	var f = ctx.factory;
+	var s = "";
+	while(!f.isEmptyList(list)) {
+		s += String.fromCharCode(f.head(list));
+		list = f.tail(list);
+	}
+	return s;
+}
+
+StrategoJS.SSL.SSL_stacktrace_get_all_frame_names = function(ctx, currentTerm) {
+	print("SSL_get_all_frame_names");
+	var frames = ctx.getStackFrames();
+	var f = ctx.factory;
+	var r = f.makeEmptyList();
+	for(var i = frames.length - 1; i >= 0; i--) {
+		r = f.makeListCons(frames[i], r);
+	}
+	return r;
+}
+
+
+StrategoJS.SSL.SSL_table_hashtable = function(ctx, currentTerm) {
+	print("SSL_table_hashtable");
+	return StrategoJS.SSL._TABLE_TABLE;
+}
+
+StrategoJS.SSL.SSL_gti = function(ctx, currentTerm, a, b) {
+	print("SSL_gti");
+	var f = ctx.factory;
+	if(f.termType(a) !== f.INT || f.termType(b) !== f.INT) { 
+		return null;
+	}
+	return a > b;
+}
+
+StrategoJS.SSL.SSL_subti = function(ctx, currentTerm, a, b) {
+	print("SSL_gti");
+	var f = ctx.factory;
+	if(f.termType(a) !== f.INT || f.termType(b) !== f.INT) { 
+		return null;
+	}
+	return a - b;
+}
+
+StrategoJS.SSL.SSL_concat_strings = function(ctx, currentTerm, s1, s2) {
+	print("SSL_concat_strings");
+	var f = ctx.factory;
+	var t1 = f.termType(s1);
+	var t2 = f.termType(s2);
+	if(s1 == undefined || s2 == undefined || s1 == null || s2 == null)
+		return null;
+	if(t1 !== f.STRING || t2 !== f.STRING)
+		return null;
+	return s1 + s2;
+}
+
+StrategoJS.SSL.SSL_getenv = function(ctx, currentTerm, name) {
+	print("SSL_getenv : " + name);
+	return null;
+}
+
+StrategoJS.SSL.SSL_strlen = function(ctx, currentTerm, string) {
+	print("SSL_strlen : " + string);
+	if(ctx.factory.termType(string) !== ctx.factory.STRING)
+		return null;
+	return string.length;
+}
+
+StrategoJS.SSL.SSL_exit = function(ctx, currentTerm) {
+	throw "Exit called";
+}	

Modified: strategoxt-javascript-backend/trunk/src/stratego/s2js.str
==============================================================================
--- strategoxt-javascript-backend/trunk/src/stratego/s2js.str	Mon Dec  6 15:39:59 2010	(r21453)
+++ strategoxt-javascript-backend/trunk/src/stratego/s2js.str	Mon Dec  6 15:41:37 2010	(r21454)
@@ -134,6 +134,20 @@
 
   translate-constant-definition = !"" // TODO(karltk)
 	
+  translate-outer-definition : 
+    AnnoDef([Extend()], def @ SDefT(x, s*, t*, s)) -> $[
+    	var /* extend */ [x] = [body];
+    ]
+  with
+  	body := <translate-definition-body> def   
+
+  translate-outer-definition : 
+    AnnoDef([Internal()], def @ SDefT(x, s*, t*, s)) -> $[
+    	var /* internal */ [x] = [body];
+    ]
+  with
+  	body := <translate-definition-body> def   
+
   translate-outer-definition :
   	SDefT(x, s*, t*, s){a*} -> $[
   		var [x] = [body];

Modified: strategoxt-javascript-backend/trunk/tests/basic/dynrules_4.str
==============================================================================
--- strategoxt-javascript-backend/trunk/tests/basic/dynrules_4.str	Mon Dec  6 15:39:59 2010	(r21453)
+++ strategoxt-javascript-backend/trunk/tests/basic/dynrules_4.str	Mon Dec  6 15:41:37 2010	(r21454)
@@ -12,10 +12,10 @@
        Foo: ("a", 2)  -> 3
      )
    ; dr-all-keys(|"Foo") ; debug 
-   ; where(one(?Some("2")))
-   ; where(one(?None()))
-   ; where(one(?("a", 2)))
+   ; with(one(?Some("2")))
+   ; with(one(?None()))
+   ; with(one(?("a", 2)))
    ; map(Foo)
-   ; where(one(?1{}))
-   ; where(one(?None(){}))
-   ; where(one(?3{}))
+   ; with(one(?1{}))
+   ; with(one(?None(){}))
+   ; with(one(?3{}))

Modified: strategoxt-javascript-backend/trunk/tests/basic/dynrules_5.str
==============================================================================
--- strategoxt-javascript-backend/trunk/tests/basic/dynrules_5.str	Mon Dec  6 15:39:59 2010	(r21453)
+++ strategoxt-javascript-backend/trunk/tests/basic/dynrules_5.str	Mon Dec  6 15:41:37 2010	(r21454)
@@ -15,5 +15,13 @@
    ; rules(
        Foo :- None()
      )
-   ; dr-all-keys(|"Foo"); debug => [Some("2"), None(), (a, 2)]
-   ; map(bagof-Foo); debug => [[1], [], [4,3]]
+   ; dr-all-keys(|"Foo")
+   ; debug 
+   ; with(one(?Some("2")))
+   ; with(one(?None()))
+   ; with(one(?(a, 2)))
+   ; map(bagof-Foo)
+   ; debug 
+   ; with(one(?[1]))
+   ; with(one(?[]))
+   ; with(one(?[4,3]))

Modified: strategoxt-javascript-backend/trunk/tests/basic/extend_1.str
==============================================================================
--- strategoxt-javascript-backend/trunk/tests/basic/extend_1.str	Mon Dec  6 15:39:59 2010	(r21453)
+++ strategoxt-javascript-backend/trunk/tests/basic/extend_1.str	Mon Dec  6 15:41:37 2010	(r21454)
@@ -1,7 +1,7 @@
 module extend_1
 
 imports
-  libstratego-lib
+  emu-libstratego-lib
 
 rules
 
@@ -9,6 +9,6 @@
     <cify> "foo-bar" => "foo_bar"
   ; <cify> "foosbar" => "foobar"
     
-  extend Cify(s) :
+  /* FIXME(karltk) extend*/ Cify(s) :
     ['s' | tail] -> <s> tail
 

Modified: strategoxt-javascript-backend/trunk/tests/basic/fetch_1.str
==============================================================================
--- strategoxt-javascript-backend/trunk/tests/basic/fetch_1.str	Mon Dec  6 15:39:59 2010	(r21453)
+++ strategoxt-javascript-backend/trunk/tests/basic/fetch_1.str	Mon Dec  6 15:41:37 2010	(r21454)
@@ -1,7 +1,7 @@
 module fetch_1
 
 imports
-  libstratego-lib
+  emu-libstratego-lib
 
 rules
 

Modified: strategoxt-javascript-backend/trunk/tests/basic/internal_1.str
==============================================================================
--- strategoxt-javascript-backend/trunk/tests/basic/internal_1.str	Mon Dec  6 15:39:59 2010	(r21453)
+++ strategoxt-javascript-backend/trunk/tests/basic/internal_1.str	Mon Dec  6 15:41:37 2010	(r21454)
@@ -1,7 +1,7 @@
 module internal_1
 
 imports
-  libstratego-lib
+  emu-libstratego-lib
 
 rules
 
@@ -9,7 +9,6 @@
     <cify> "foo-bar" => "foo_bar"
   ; not(<cify> "foosbar" => "foobar")
   ; <Cify(id)> ['s'] => []
-    
-  internal Cify(s) :
+        
+  /* FIXME(karltk) internal */ Cify(s) :
     ['s' | tail] -> <s> tail
-

Modified: strategoxt-javascript-backend/trunk/tests/basic/internal_2.str
==============================================================================
--- strategoxt-javascript-backend/trunk/tests/basic/internal_2.str	Mon Dec  6 15:39:59 2010	(r21453)
+++ strategoxt-javascript-backend/trunk/tests/basic/internal_2.str	Mon Dec  6 15:41:37 2010	(r21454)
@@ -1,7 +1,7 @@
 module internal_2
 
 imports
-  libstratego-lib
+  emu-libstratego-lib
 
 rules
 

Modified: strategoxt-javascript-backend/trunk/tests/basic/iset_1.str
==============================================================================
--- strategoxt-javascript-backend/trunk/tests/basic/iset_1.str	Mon Dec  6 15:39:59 2010	(r21453)
+++ strategoxt-javascript-backend/trunk/tests/basic/iset_1.str	Mon Dec  6 15:41:37 2010	(r21454)
@@ -1,6 +1,7 @@
 module iset_1
 
-imports libstratego-lib
+imports 
+  emu-libstratego-lib
 
 strategies
 

Modified: strategoxt-javascript-backend/trunk/tests/basic/iset_2.str
==============================================================================
--- strategoxt-javascript-backend/trunk/tests/basic/iset_2.str	Mon Dec  6 15:39:59 2010	(r21453)
+++ strategoxt-javascript-backend/trunk/tests/basic/iset_2.str	Mon Dec  6 15:41:37 2010	(r21454)
@@ -1,6 +1,7 @@
 module iset_2
 
-imports libstratego-lib
+imports 
+  emu-libstratego-lib
 
 strategies
 

From karltk at strategoxt.org  Mon Dec  6 17:42:38 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Mon, 06 Dec 2010 16:42:38 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21455 -
	strategoxt-java-backend/trunk/test/basic
Message-ID: <201012061642.oB6GgcQN017519@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Mon Dec  6 16:42:37 2010
New Revision: 21455
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21455&sc=1

Log:
Update module name to match file name.

Modified:
   strategoxt-java-backend/trunk/test/basic/shared_var_3.str

Modified: strategoxt-java-backend/trunk/test/basic/shared_var_3.str
==============================================================================
--- strategoxt-java-backend/trunk/test/basic/shared_var_3.str	Mon Dec  6 15:41:37 2010	(r21454)
+++ strategoxt-java-backend/trunk/test/basic/shared_var_3.str	Mon Dec  6 16:42:37 2010	(r21455)
@@ -1,4 +1,4 @@
-module shared_var_2
+module shared_var_3
 
 imports
   libstratego-lib

From karltk at strategoxt.org  Mon Dec  6 18:58:20 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Mon, 06 Dec 2010 17:58:20 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21456 - in
	strategoxt-javascript-backend/trunk: src/javascript
	src/stratego tests/basic
Message-ID: <201012061758.oB6HwKSn018597@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Mon Dec  6 17:58:19 2010
New Revision: 21456
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21456&sc=1

Log:
* Added workaround for internal, external and override; separate libraries not supported yet.
 * Added SSL_indexedSet_reset.
 * Fixed bug when calling HOF in SSL_indexedSet_put.
 * Fixed bug in compilation scheme for guarded left choice.
 * Fixed bug in assignment to variables -- matching code was bad.
 * Fixed numerous bugs in annotations.
 * Revised term equality functions to do equality with annotations.

Modified:
   strategoxt-javascript-backend/trunk/src/javascript/ssl.js
   strategoxt-javascript-backend/trunk/src/javascript/terms.js
   strategoxt-javascript-backend/trunk/src/stratego/s2js.str
   strategoxt-javascript-backend/trunk/src/stratego/term-deconstruction.str
   strategoxt-javascript-backend/trunk/tests/basic/mapconcat_1.str
   strategoxt-javascript-backend/trunk/tests/basic/match_5.str
   strategoxt-javascript-backend/trunk/tests/basic/override_1.str
   strategoxt-javascript-backend/trunk/tests/basic/scopes_1.str
   strategoxt-javascript-backend/trunk/tests/basic/scopes_2.str
   strategoxt-javascript-backend/trunk/tests/basic/shared_var_3.str
   strategoxt-javascript-backend/trunk/tests/basic/shared_var_4.str
   strategoxt-javascript-backend/trunk/tests/basic/traversal_1.str

Modified: strategoxt-javascript-backend/trunk/src/javascript/ssl.js
==============================================================================
--- strategoxt-javascript-backend/trunk/src/javascript/ssl.js	Mon Dec  6 16:42:37 2010	(r21455)
+++ strategoxt-javascript-backend/trunk/src/javascript/ssl.js	Mon Dec  6 17:58:19 2010	(r21456)
@@ -122,7 +122,7 @@
 	print("SSL_fputs");
 	var ctor = ctx.factory.getConstructor(stream);
 	if(ctx.factory.ctorEquals(ctor, StrategoJS.SSL._stdout) || ctx.factory.ctorEquals(ctor, StrategoJS.SSL._stderr))
-		print(string);
+		print(ctx.factory.stripAnnotations(string));
 	else
 		throw "SSL_fputs not fully implemented; cannot write to arbitrary streams";
 	return currentTerm;
@@ -216,37 +216,46 @@
 StrategoJS.SSL._TABLE_TABLE = 0;
 StrategoJS.SSL._DYN_TABLE   = 1;
 
-function _makeIndexedSet() {
-	return {
-		_counter : 0,
-		_hash : {},
-		getIndex: function(key) {
-			return this._hash[key]; 
-		},
-		containsKey: function(key) {
-			return this._hash[key] !== undefined;
-		},
-		put: function(key) {
-			var idx = this._counter++;
-			this._hash[key] = idx; 
-			return idx;
-		},
-		sortedKeySet: function() {
-			var r = [];
-			var sorter = function (a, b) { return a.v - b.v; }
-			for(var x in this._hash) {
-				r.push({t:x,v:this._hash[x]});
-			}
-			r.sort(sorter);
-			var rr = [];
-			for(var i = 0; i < r.length; i++) {
-				rr.push(r[i].t);
-			}
-			return rr;
+StrategoJS.SSL._IndexedSet = function() {
+	var _counter = 0;
+	var _hash = {};
+	
+	this.getIndex = function(key) {
+		return _hash[key]; 
+	}
+
+	this.containsKey = function(key) {
+		return _hash[key] !== undefined;
+	}
+
+	this.put = function(key) {
+		var idx = _counter++;
+		print("Z - " + key + " : " + idx);
+		_hash[key] = idx; 
+		return idx;
+	}
+
+	this.sortedKeySet = function() {
+		var r = [];
+		var sorter = function (a, b) { return a.v - b.v; }
+		for(var x in _hash) {
+			r.push({t:x, v:_hash[x]});
 		}
+		r.sort(sorter);
+		var rr = [];
+		for(var i = 0; i < r.length; i++) {
+			rr.push(r[i].t);
+		}
+		return rr;
+	}
+
+	this.reset = function() {
+		_hash = {};
+		_counter -= _counter;
 	}
 }
 
+
 function _makeHashtable() {
 	return {};
 }
@@ -267,7 +276,7 @@
 
 StrategoJS.SSL.SSL_indexedSet_create = function(ctx, currentTerm, initialSize, maxLoad) {
 	print("SSL_indexedSet_create");
-	StrategoJS.SSL._indexedSets.push(_makeIndexedSet());
+	StrategoJS.SSL._indexedSets.push(new StrategoJS.SSL._IndexedSet());
 	return StrategoJS.SSL._indexedSets.length - 1;
 }
 
@@ -277,15 +286,25 @@
 	return currentTerm;
 }
 
+StrategoJS.SSL.SSL_indexedSet_reset = function(ctx, currentTerm, setIndex) {
+	print("SSL_indexedSet_reset");
+	StrategoJS.SSL._indexedSets[setIndex].reset();
+	return setIndex;
+}
+
 StrategoJS.SSL.SSL_indexedSet_put = function(ctx, currentTerm, strategy, setIndex, key) {
 	print("SSL_indexedSet_put : " + setIndex + " " + key);
 	var set = StrategoJS.SSL._indexedSets[setIndex];
 	var keyAsString = ctx.factory.prettify(key);
-	print("SSL_indexedSet_put " + setIndex + " " + keyAsString);
-	if(set.containsKey(keyAsString))
-		return strategy(set.getIndex(keyAsString));
-	else
-		return set.put(keyAsString);
+	print("                   : " + setIndex + " " + keyAsString);
+	if(set.containsKey(keyAsString)) {
+		var r = set.getIndex(keyAsString);
+		return strategy(ctx, r === undefined ? null : r);
+	}
+	else {
+		var r = set.put(keyAsString);
+		return r === undefined ? null : r;
+	}
 }
 
 StrategoJS.SSL.SSL_indexedSet_getIndex = function(ctx, currentTerm, setIndex, key) {
@@ -434,3 +453,8 @@
 StrategoJS.SSL.SSL_exit = function(ctx, currentTerm) {
 	throw "Exit called";
 }	
+
+StrategoJS.SSL.SSL_is_int = function(ctx, currentTerm) {
+	print("SSL_is_int");
+	return ctx.factory.termType(currentTerm) === ctx.factory.INT;
+}

Modified: strategoxt-javascript-backend/trunk/src/javascript/terms.js
==============================================================================
--- strategoxt-javascript-backend/trunk/src/javascript/terms.js	Mon Dec  6 16:42:37 2010	(r21455)
+++ strategoxt-javascript-backend/trunk/src/javascript/terms.js	Mon Dec  6 17:58:19 2010	(r21456)
@@ -32,24 +32,23 @@
 
 	function doEquals(lhs, rhs) {
 		if(lhs === undefined || rhs === undefined) throw "equals on undefined";
-		var lt = typeof(lhs);
-		var rt = typeof(rhs);
-		if(lt !== rt) {
-			if(lhs.annoType || rhs.annoType)
-				return doAnnoEquals(lhs, rhs);
+		var lt = termType(lhs);
+		var rt = termType(rhs);
+		if(lt !== rt)
 			return false;
-		}
-		if(lt === 'number')
+		if(lhs.annoType || rhs.annoType)
+			return doAnnoEquals(lhs, rhs);
+		if(lt === REAL || lt === INT)
 			return lhs === rhs;
-		if(lt === 'string')
+		if(lt === STRING)
 			return lhs === rhs;
 		return lhs.equals(rhs);
 	}
 	
 	function doAnnoEquals(lhs, rhs) {
-		var l = lhs.annoType ? lhs : rhs;
-		var r = lhs.annoType ? rhs : lhs;
-		return l.equals(r);
+		var lhsAnno  = factory.getAnnotations(lhs);
+		var rhsAnno = factory.getAnnotations(rhs);
+		return lhs.equals(rhs) && lhsAnno.equals(rhsAnno);
 	}
 	
 	function doPrettify(term, builder) {
@@ -387,10 +386,10 @@
 		return list2;
 	}
 	
-	function fuseAnnotations(annotatedTerm, newAnnos) {
+	function resetAnnotations(annotatedTerm, newAnnos) {
 		var r = {
 				annoType : ANNO,
-				annos : listMerge(annotatedTerm.annos, newAnnos),
+				annos : newAnnos,
 				term : annotatedTerm.term,
 				termType : annotatedTerm.termType,
 				head : annotatedTerm.head,
@@ -634,7 +633,7 @@
 					return factory.makeEmptyList();
 			},
 
-			match : doEquals,
+			match : function(a, b) { print("MATCH " + factory.prettify(a) + " == " + factory.prettify(b)); var r = doEquals(a,b); print(r); return r; },
 
 			termType : termType,
 
@@ -650,10 +649,18 @@
 			},
 
 			annotateTerm : function(term, annos) {
+				if(factory.isEmptyList(annos))
+					return term.term ? term.term : term;
 				if(term.annoType)
-					return fuseAnnotations(term, annos);
+					return resetAnnotations(term, annos);
 				else
 					return wrapInAnnotation(term, annos);
+			},
+			
+			stripAnnotations : function(term) {
+				if(term.annoType)
+					return term.term;
+				return term;
 			}
 	};
 	return factory;

Modified: strategoxt-javascript-backend/trunk/src/stratego/s2js.str
==============================================================================
--- strategoxt-javascript-backend/trunk/src/stratego/s2js.str	Mon Dec  6 16:42:37 2010	(r21455)
+++ strategoxt-javascript-backend/trunk/src/stratego/s2js.str	Mon Dec  6 17:58:19 2010	(r21456)
@@ -141,6 +141,14 @@
   with
   	body := <translate-definition-body> def   
 
+
+  translate-outer-definition : 
+    AnnoDef([Override()], def @ SDefT(x, s*, t*, s)) -> $[
+    	var /* override */ [x] = [body];
+    ]
+  with
+  	body := <translate-definition-body> def   
+
   translate-outer-definition : 
     AnnoDef([Internal()], def @ SDefT(x, s*, t*, s)) -> $[
     	var /* internal */ [x] = [body];
@@ -268,7 +276,7 @@
   	$[
         term = [x](ctx, term [args]);	
         if(term == null) {
-        	print("[feil]"); 
+        	print("[feil] : return from [x]"); 
             break [feil];
         } else if(term == undefined) {
         	throw "internal error: call to [x] produced 'undefined' result";
@@ -357,16 +365,14 @@
   	; s1'  := <translate-strategy(|succ,feil)> s1
   	; s2'  := <translate-strategy(|succ,f)> s2
   	  	
-  translate-GuardedLChoice(|s,f):
+  translate-GuardedLChoice(|s,outerfeil):
   	GuardedLChoice(s1, s2, s3) -> $[
   		var [copy] = term;
   		[succ]: {
   			[feil]: {
   				[s1']
-  				[outerfeil]: {
-  					[s2']
-  					break [succ];
-  				}
+				[s2']
+  				break [succ];
   			}
   			term = [copy];
   			[s3']
@@ -376,10 +382,9 @@
   	  copy      := <newname> "term_"
   	; succ      := <newname> "Success_"
   	; feil      := <newname> "Fail_"
-  	; outerfeil := <newname> "OuterFail_"
   	; s1'       := <translate-strategy(|succ,feil)> s1
   	; s2'       := <translate-strategy(|succ,outerfeil)> s2
-    ; s3'       := <translate-strategy(|succ,f)> s3
+    ; s3'       := <translate-strategy(|succ,outerfeil)> s3
   	
     translate-Scope(|s,f) : 
     Scope(vars, body) -> 
@@ -393,10 +398,10 @@
 
   translate-Let(|s,f) : 
     Let(defs, body) -> $[
-    	{
+    	{/*let*/
     		[def*]
     		[body']
-    	}
+    	}/*let*/
     ]
   with 
     def* := <map(translate-inner-definition)> defs

Modified: strategoxt-javascript-backend/trunk/src/stratego/term-deconstruction.str
==============================================================================
--- strategoxt-javascript-backend/trunk/src/stratego/term-deconstruction.str	Mon Dec  6 16:42:37 2010	(r21455)
+++ strategoxt-javascript-backend/trunk/src/stratego/term-deconstruction.str	Mon Dec  6 17:58:19 2010	(r21456)
@@ -50,7 +50,7 @@
     $[
       if ([e_var] == null) {
         [stm_assign]
-      }?else if ([e_var] != [e] && ![e_var].match([e])) {
+      }?else if ([e_var] != [e] && !factory.match([e_var], [e])) {
       	print("[feil]");
         break [feil];
       }

Modified: strategoxt-javascript-backend/trunk/tests/basic/mapconcat_1.str
==============================================================================
--- strategoxt-javascript-backend/trunk/tests/basic/mapconcat_1.str	Mon Dec  6 16:42:37 2010	(r21455)
+++ strategoxt-javascript-backend/trunk/tests/basic/mapconcat_1.str	Mon Dec  6 17:58:19 2010	(r21456)
@@ -1,6 +1,7 @@
 module mapconcat_1
 
-imports libstratego-lib
+imports 
+  emu-libstratego-lib
 
 strategies
 

Modified: strategoxt-javascript-backend/trunk/tests/basic/match_5.str
==============================================================================
--- strategoxt-javascript-backend/trunk/tests/basic/match_5.str	Mon Dec  6 16:42:37 2010	(r21455)
+++ strategoxt-javascript-backend/trunk/tests/basic/match_5.str	Mon Dec  6 17:58:19 2010	(r21456)
@@ -1,7 +1,7 @@
 module match_5
 
 imports
-  libstratego-lib
+  emu-libstratego-lib
 
 strategies
 

Modified: strategoxt-javascript-backend/trunk/tests/basic/override_1.str
==============================================================================
--- strategoxt-javascript-backend/trunk/tests/basic/override_1.str	Mon Dec  6 16:42:37 2010	(r21455)
+++ strategoxt-javascript-backend/trunk/tests/basic/override_1.str	Mon Dec  6 17:58:19 2010	(r21456)
@@ -1,7 +1,7 @@
 module override_1
 
 imports
-  libstratego-lib
+  emu-libstratego-lib
 
 rules
 
@@ -9,6 +9,6 @@
     not(<cify> "foo-bar" => "foo_bar")
   ; <cify> "foosbar" => "foobar"
     
-  override Cify(s) :
+  /* FIXME(karltk) override */ Cify(s) :
     ['s' | tail] -> <s> tail
 

Modified: strategoxt-javascript-backend/trunk/tests/basic/scopes_1.str
==============================================================================
--- strategoxt-javascript-backend/trunk/tests/basic/scopes_1.str	Mon Dec  6 16:42:37 2010	(r21455)
+++ strategoxt-javascript-backend/trunk/tests/basic/scopes_1.str	Mon Dec  6 17:58:19 2010	(r21456)
@@ -1,6 +1,7 @@
 module scopes_1
 
-imports libstratego-lib
+imports 
+  emu-libstratego-lib
 
 rules
 

Modified: strategoxt-javascript-backend/trunk/tests/basic/scopes_2.str
==============================================================================
--- strategoxt-javascript-backend/trunk/tests/basic/scopes_2.str	Mon Dec  6 16:42:37 2010	(r21455)
+++ strategoxt-javascript-backend/trunk/tests/basic/scopes_2.str	Mon Dec  6 17:58:19 2010	(r21456)
@@ -1,6 +1,7 @@
 module scopes_2
 
-imports libstratego-lib
+imports 
+  emu-libstratego-lib
 
 rules
 

Modified: strategoxt-javascript-backend/trunk/tests/basic/shared_var_3.str
==============================================================================
--- strategoxt-javascript-backend/trunk/tests/basic/shared_var_3.str	Mon Dec  6 16:42:37 2010	(r21455)
+++ strategoxt-javascript-backend/trunk/tests/basic/shared_var_3.str	Mon Dec  6 17:58:19 2010	(r21456)
@@ -1,7 +1,7 @@
-module shared_var_2
+module shared_var_3
 
 imports
-  libstratego-lib
+  emu-libstratego-lib
 
 rules
 

Modified: strategoxt-javascript-backend/trunk/tests/basic/shared_var_4.str
==============================================================================
--- strategoxt-javascript-backend/trunk/tests/basic/shared_var_4.str	Mon Dec  6 16:42:37 2010	(r21455)
+++ strategoxt-javascript-backend/trunk/tests/basic/shared_var_4.str	Mon Dec  6 17:58:19 2010	(r21456)
@@ -1,7 +1,7 @@
 module shared_var_4
 
 imports
-  libstratego-lib
+  emu-libstratego-lib
 
 strategies
 

Modified: strategoxt-javascript-backend/trunk/tests/basic/traversal_1.str
==============================================================================
--- strategoxt-javascript-backend/trunk/tests/basic/traversal_1.str	Mon Dec  6 16:42:37 2010	(r21455)
+++ strategoxt-javascript-backend/trunk/tests/basic/traversal_1.str	Mon Dec  6 17:58:19 2010	(r21456)
@@ -1,6 +1,7 @@
 module traversal_1
 
-imports libstratego-lib
+imports 
+  emu-libstratego-lib
 
 signature constructors
   Fork : Term * Term -> Term

From L.C.L.Kats at tudelft.nl  Mon Dec  6 21:24:37 2010
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Mon, 06 Dec 2010 20:24:37 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21457 - in
	spoofax-imp/trunk: org.strategoxt.imp.editors.aterm/syntax
	org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser
	org.strategoxt.imp.runtime/src/org/s...
Message-ID: <201012062024.oB6KObFP020803@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: Mon Dec  6 20:24:37 2010
New Revision: 21457
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21457&sc=1

Log:
- Apparently the Stratego ATerm dialect allows underscores in constructor names
- Increased the parser timeout

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.aterm/syntax/ATerm.def
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/SGLRParseController.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AbstractVisitor.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.aterm/syntax/ATerm.def
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.aterm/syntax/ATerm.def	Mon Dec  6 17:58:19 2010	(r21456)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.aterm/syntax/ATerm.def	Mon Dec  6 20:24:37 2010	(r21457)
@@ -13,11 +13,11 @@
 
 lexical syntax
 
-head:[A-Za-z] tail:[A-Za-z\-0-9]* -> IdCon {cons("default")}
+head:[A-Za-z] tail:[A-Za-z\-0-9\_]* -> IdCon {cons("default")}
 
 lexical restrictions
 
-IdCon -/- [A-Za-z\-0-9]
+IdCon -/- [A-Za-z\-0-9\_]
 
 module basic/StrCon
 

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/SGLRParseController.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/SGLRParseController.java	Mon Dec  6 17:58:19 2010	(r21456)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/SGLRParseController.java	Mon Dec  6 20:24:37 2010	(r21457)
@@ -65,7 +65,7 @@
  */
 public class SGLRParseController implements IParseController {
 	
-	private static final int PARSE_TIMEOUT = 6 * 1000;
+	private static final int PARSE_TIMEOUT = 20 * 1000;
 	
 	private final TokenKindManager tokenManager = new TokenKindManager();
 	

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AbstractVisitor.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AbstractVisitor.java	Mon Dec  6 17:58:19 2010	(r21456)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AbstractVisitor.java	Mon Dec  6 20:24:37 2010	(r21457)
@@ -18,9 +18,12 @@
 	}
 }
 
-// Local interface avoids abstract methods and subsequent @Override annotations
+// Local interface avoids abstract methods and subsequent @Override annotation requirement
 
 interface IAstVisitor extends lpg.runtime.IAstVisitor {
+	/**
+	 * @return true if this node should be visited and post-visited.
+	 */
 	boolean preVisit(AstNode node);
 
 	void postVisit(AstNode node);

From r.t.lindeman at student.tudelft.nl  Tue Dec  7 14:13:56 2010
From: r.t.lindeman at student.tudelft.nl (Ricky Lindeman)
Date: Tue, 07 Dec 2010 13:13:56 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21458 - in
	spoofax-imp/trunk:
	org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control
	org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/...
Message-ID: <201012071313.oB7DDuJW000971@proliant.st.ewi.tudelft.nl>

Author: RickyLindeman
Date: Tue Dec  7 13:13:55 2010
New Revision: 21458
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21458&sc=1

Log:
* Added STEP_OVER support to debug.stratego.core.
 * Also added test cases in debug.stratego.test that test stepping
 * Improved VMStateTester. Use this class in test suites to control the behavior of the debug target after a breakpoint is hit

Added:
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestStepping.java
Modified:
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/DebugSessionManager.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/EventThread.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/ThreadEventHandler.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/EventHandler.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/RuleEnterHandler.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/RuleExitHandler.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyEnterHandler.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyExitHandler.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyStepHandler.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyVarHandler.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/EventSpecManager.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/model/StrategoStackFrame.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/util/DebugEventRequestInstaller.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.runtime/trans/strategodebuglib.str
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestDynamic.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestImports.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DebugSessionManagerTest.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/VMMonitorTestImpl2.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/VMStateTester.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/DebugSessionManager.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/DebugSessionManager.java	Mon Dec  6 20:24:37 2010	(r21457)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/DebugSessionManager.java	Tue Dec  7 13:13:55 2010	(r21458)
@@ -198,6 +198,28 @@
 		vm.suspend();
 	}
 	
+	public void stepInto()
+	{
+		// stop at the first possible s-enter/r-enter event
+		// if the current statement is not a call to another method, we can only step over
+	}
+	
+	public void stepOver()
+	{
+		// get the thread that is suspended, stratego programs are single threaded, so we always know which thread we need.
+		// just save the step info in the EventSpecManager, if stratego becomes multi-threaded, step info needs to be saved per Thread
+		ThreadEventHandler handler = this.eventThread.getMainThreadHandler();
+		this.eventSpecManager.setStepOver(handler.getStrategoState());
+		// stop at the next s-step that is in the same stackframe as the current one
+		// if the current StackFrame exists (s-exit or r-exit) continue at the returning stackframe
+		this.resumeVM();
+	}
+	
+	public void stepReturn()
+	{
+		
+	}
+	
 	/**
 	 * Terminate the Stratego VM.
 	 */

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/EventThread.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/EventThread.java	Mon Dec  6 20:24:37 2010	(r21457)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/EventThread.java	Tue Dec  7 13:13:55 2010	(r21458)
@@ -192,6 +192,24 @@
 		}
 		return handler;
 	}
+	
+	/**
+	 * Stratego programs runs single threaded so there should only be one ThreadEventHandler.
+	 * @return
+	 */
+	protected ThreadEventHandler getMainThreadHandler()
+	{
+		if (this.traceMap.keySet().size() > 1)
+		{
+			// TODO: more than one stratego thread
+			return null;
+		}
+		else
+		{
+			ThreadReference mainRef = this.traceMap.keySet().iterator().next(); // get the first ThreadReference
+			return this.getThreadEventHandler(mainRef);
+		}
+	}
 
 	/**
 	 * Dispatch incoming events
@@ -352,4 +370,16 @@
 		}
 	}
 
+	public void getSuspendedThread() {
+		// TODO Auto-generated method stub
+		System.out.println("threads:");
+		for(ThreadReference ref: this.traceMap.keySet())
+		{
+			System.out.println("ThreadRef Name " + ref.name());
+			//ThreadEventHandler handler = this.traceMap.get(ref);
+			boolean isSuspended = ref.isSuspended();
+			System.out.println("isSuspended: " + isSuspended);
+		}
+	}
+
 }

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/ThreadEventHandler.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/ThreadEventHandler.java	Mon Dec  6 20:24:37 2010	(r21457)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/ThreadEventHandler.java	Tue Dec  7 13:13:55 2010	(r21458)
@@ -119,12 +119,12 @@
 			}
 			try {
 				h.processDebugEvent(this.strategoState);
-				suspendThread = h.shouldSuspend(eventSpecManager);
 				
+				// update the current location
 				LocationInfo locationInfo = h.getLocationInfo();
-				//this.strategoState.setLocationInfo(locationInfo); // LocationInfo should be set on the current Frame
 				this.strategoState.currentFrame().setCurrentLocationInfo(locationInfo);
 				
+				suspendThread = h.shouldSuspend(this.strategoState, eventSpecManager);
 				// if the thread will be suspended, update the Dynamic Rules. But first get it from the vm while it is suspended
 
 				Method method = null;
@@ -232,5 +232,10 @@
 	void threadDeathEvent(ThreadDeathEvent event) {
 		// thread death event
 	}
+	
+	public StrategoState getStrategoState()
+	{
+		return this.strategoState;
+	}
 
 }

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/EventHandler.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/EventHandler.java	Mon Dec  6 20:24:37 2010	(r21457)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/EventHandler.java	Tue Dec  7 13:13:55 2010	(r21458)
@@ -406,7 +406,7 @@
 	 * Returns false if the thread should resume
 	 * @return
 	 */
-	public boolean shouldSuspend(EventSpecManager eventSpecManager){
+	public boolean shouldSuspend(StrategoState currentState, EventSpecManager eventSpecManager){
 		// sysout debug info
 		/*
 		String name = this.getName(); // the name of the rule
@@ -422,9 +422,46 @@
         //System.out.println();
         */
         // end debug info
-        
-        boolean isBreakPoint = eventSpecManager.match(createBreakPoint());
-        return isBreakPoint; // if break point exists suspend thread
+		boolean isBreakPointHit = eventSpecManager.match(createBreakPoint());
+		
+        // if we should step
+		// stop at the first s-step that is in the same StackFrame
+		boolean shouldSuspend = false;
+		if (isBreakPointHit){
+			// we hit a break point
+			// if stepping is active it should be cancelled
+			if (eventSpecManager.isStepOverActive())
+			{
+				eventSpecManager.resetStep();
+			}
+			shouldSuspend = true;
+		}
+		else if (eventSpecManager.isStepOverActive())
+		{
+			// if level is the same
+			if (eventSpecManager.getStepFrameLevel() == currentState.getStackFrames().length - 1)
+			{
+				// rule/strategy location are the same
+				boolean sameLocation = eventSpecManager.getStepFrame().getLocationInfo().equals(currentState.currentFrame().getLocationInfo());
+				boolean sameFilename = eventSpecManager.getStepFrame().getFilename().equals(currentState.currentFrame().getFilename());
+				boolean sameName = eventSpecManager.getStepFrame().getName().equals(currentState.currentFrame().getName());
+				if (sameLocation && sameFilename && sameName)
+				{
+					// we hit the next debug event
+					if (this.getEventType().equals(EventHandler.S_STEP))
+					{
+						// we hit the next s-step
+						shouldSuspend = true;
+						eventSpecManager.resetStep(); // reset step
+					}
+					// S_VAR we can ignore
+					// S_ENTER/R_ENTER should never happen is the same StackFrame
+					// S_EXIT/R_EXIT can happen
+				}
+			}
+		}
+		
+        return shouldSuspend; // if break point exists suspend thread
 	}
 	
 	/**

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/RuleEnterHandler.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/RuleEnterHandler.java	Mon Dec  6 20:24:37 2010	(r21457)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/RuleEnterHandler.java	Tue Dec  7 13:13:55 2010	(r21458)
@@ -26,7 +26,7 @@
 
 	@Override
 	protected String getEventType() {
-		return "Rule Enter";
+		return EventHandler.R_ENTER;
 	}
 
 	@Override

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/RuleExitHandler.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/RuleExitHandler.java	Mon Dec  6 20:24:37 2010	(r21457)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/RuleExitHandler.java	Tue Dec  7 13:13:55 2010	(r21458)
@@ -24,7 +24,7 @@
 
 	@Override
 	protected String getEventType() {
-		return "Rule Exit";
+		return EventHandler.R_EXIT;
 	}
 
 	@Override

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyEnterHandler.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyEnterHandler.java	Mon Dec  6 20:24:37 2010	(r21457)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyEnterHandler.java	Tue Dec  7 13:13:55 2010	(r21458)
@@ -27,7 +27,7 @@
 	@Override
 	protected String getEventType() {
 		// TODO Auto-generated method stub
-		return "Strategy Enter";
+		return EventHandler.S_ENTER;
 	}
 
 	@Override

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyExitHandler.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyExitHandler.java	Mon Dec  6 20:24:37 2010	(r21457)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyExitHandler.java	Tue Dec  7 13:13:55 2010	(r21458)
@@ -29,7 +29,7 @@
 
 	@Override
 	protected String getEventType() {
-		return "Strategy Exit";
+		return EventHandler.S_EXIT;
 	}
 
 	@Override

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyStepHandler.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyStepHandler.java	Mon Dec  6 20:24:37 2010	(r21457)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyStepHandler.java	Tue Dec  7 13:13:55 2010	(r21458)
@@ -24,7 +24,7 @@
 
 	@Override
 	protected String getEventType() {
-		return "Strategy Step";
+		return EventHandler.S_STEP;
 	}
 
 	@Override

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyVarHandler.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyVarHandler.java	Mon Dec  6 20:24:37 2010	(r21457)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyVarHandler.java	Tue Dec  7 13:13:55 2010	(r21458)
@@ -19,7 +19,7 @@
 	
 	@Override
 	protected String getEventType() {
-		return "Strategy Var";
+		return EventHandler.S_VAR;
 	}
 
 	@Override

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/EventSpecManager.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/EventSpecManager.java	Mon Dec  6 20:24:37 2010	(r21457)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/EventSpecManager.java	Tue Dec  7 13:13:55 2010	(r21458)
@@ -2,6 +2,8 @@
 
 import java.util.List;
 
+import org.strategoxt.debug.core.model.StrategoStackFrame;
+import org.strategoxt.debug.core.model.StrategoState;
 import org.strategoxt.debug.core.util.DebugSessionSettings;
 import org.strategoxt.debug.core.util.FileUtil;
 import org.strategoxt.debug.core.util.table.EventTable;
@@ -74,6 +76,74 @@
 		
 	}
 	
+	// StackFrame in which the step was started
+	private StrategoStackFrame stepFrame = null;
+	
+	// what was the level of the StrategoStackFrame when the step command was issued
+	// 0-based
+	private int stepFrameLevel = -1;
+	
+	// true if stepOver is active
+	private boolean isStepOverActive = false;
+	private boolean isStepReturnActive = false;
+	private boolean isStepIntoActive = false;
+
+	public StrategoStackFrame getStepFrame()
+	{
+		return this.stepFrame;
+	}
+	
+	public int getStepFrameLevel()
+	{
+		return this.stepFrameLevel;
+	}
+	
+	public boolean isStepReturnActive()
+	{
+		return this.isStepReturnActive;
+	}
+
+	public boolean isStepOverActive()
+	{
+		return this.isStepOverActive;
+	}
+	
+	public boolean isStepIntoActive()
+	{
+		return this.isStepIntoActive;
+	}
+	
+	public void setStepOver(StrategoState state)
+	{
+		stepFrame = state.currentFrame();
+		stepFrameLevel = state.getStackFrames().length - 1;
+		isStepOverActive = true;
+	}
+	
+	
+	public void setStepInto(StrategoState state)
+	{
+		stepFrame = state.currentFrame();
+		stepFrameLevel = state.getStackFrames().length - 1;
+		isStepIntoActive = true;
+	}
+	
+	public void setStepReturn(StrategoState state)
+	{
+		stepFrame = state.currentFrame();
+		stepFrameLevel = state.getStackFrames().length - 1;
+		isStepReturnActive = true;
+	}
+
+	public void resetStep()
+	{
+		this.stepFrame = null;
+		this.stepFrameLevel = -1;
+		this.isStepOverActive = false;
+		this.isStepIntoActive = false;
+		this.isStepReturnActive = false;
+	}
+	
 	public EventTable getEventTable()
 	{
 		return this.eventTable;

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/model/StrategoStackFrame.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/model/StrategoStackFrame.java	Mon Dec  6 20:24:37 2010	(r21457)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/model/StrategoStackFrame.java	Tue Dec  7 13:13:55 2010	(r21458)
@@ -22,7 +22,8 @@
 	private LocationInfo locationInfo;
 	
 	/**
-	 * The current LocationInfo, currentLocationInfo should be surrounded by this.locationInfo
+	 * The current LocationInfo, currentLocationInfo should be surrounded by this.locationInfo.
+	 * The currentLocationInfo points to the current active statement with a rule or strategy
 	 */
 	private LocationInfo currentLocationInfo = null;
 	
@@ -52,7 +53,15 @@
 	public String toString()
 	{
 		String val = "Frame @ " + this.name + "[" + this.filename + "]";
-		val += ":" + locationInfo.getStart_line_num();
+		if (currentLocationInfo != null) // specific location
+		{
+			val += "@("+currentLocationInfo.getStart_line_num()+","+currentLocationInfo.getStart_token_pos()+")";
+		}
+		/*
+		if (locationInfo != null) // location of the rule or strategy
+		{
+			val += ":" + locationInfo.getStart_line_num();
+		}*/
 		return val;
 	}
 	
@@ -77,6 +86,7 @@
 	
 	/**
 	 * Returns LocationInfo about the current rule or strategy.
+	 * The LocationInfo does not point to a specific statement in the rule or strategy.
 	 * @return
 	 */
 	public LocationInfo getLocationInfo()
@@ -94,6 +104,10 @@
 		return this.current;
 	}
 	
+	/**
+	 * Returns the LocationInfo of the current active statement with a rule or strategy.
+	 * @return
+	 */
 	public LocationInfo getCurrentLocationInfo()
 	{
 		return this.currentLocationInfo;

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/util/DebugEventRequestInstaller.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/util/DebugEventRequestInstaller.java	Mon Dec  6 20:24:37 2010	(r21457)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/util/DebugEventRequestInstaller.java	Tue Dec  7 13:13:55 2010	(r21458)
@@ -1,7 +1,12 @@
 package org.strategoxt.debug.core.util;
 
 import org.strategoxt.debug.core.control.events.EventHandler;
-import org.strategoxt.imp.debug.stratego.runtime.strategies.*;
+import org.strategoxt.imp.debug.stratego.runtime.strategies.java_r_enter_0_4;
+import org.strategoxt.imp.debug.stratego.runtime.strategies.java_r_exit_0_4;
+import org.strategoxt.imp.debug.stratego.runtime.strategies.java_s_enter_0_4;
+import org.strategoxt.imp.debug.stratego.runtime.strategies.java_s_exit_0_4;
+import org.strategoxt.imp.debug.stratego.runtime.strategies.java_s_step_0_4;
+import org.strategoxt.imp.debug.stratego.runtime.strategies.java_s_var_0_5;
 
 import com.sun.jdi.VirtualMachine;
 import com.sun.jdi.request.ClassPrepareRequest;
@@ -28,7 +33,6 @@
 	public static void installDebugEventRequests(VirtualMachine vm, boolean watchFields, String[] excludes)
 	{
 		EventRequestManager mgr = vm.eventRequestManager();
-		
 		// want all exceptions 
 		/*
 		ExceptionRequest excReq = mgr.createExceptionRequest(null, true, true); // suspend so we can step 

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.runtime/trans/strategodebuglib.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.runtime/trans/strategodebuglib.str	Mon Dec  6 20:24:37 2010	(r21457)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.runtime/trans/strategodebuglib.str	Tue Dec  7 13:13:55 2010	(r21458)
@@ -79,5 +79,5 @@
 strategies // strategies to collect the active dynamic rules
 	
 	// returns a list of strings
-	dr-get-key-set = prim("SSL_hashtable_keys",  <dr-rule-sets-hashtable>); debug(!"dr-get-key-set:")
+	dr-get-key-set = prim("SSL_hashtable_keys",  <dr-rule-sets-hashtable>) //; debug(!"dr-get-key-set:")
 	
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestDynamic.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestDynamic.java	Mon Dec  6 20:24:37 2010	(r21457)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestDynamic.java	Tue Dec  7 13:13:55 2010	(r21458)
@@ -74,11 +74,12 @@
 		
 		
 		// which breakpoints will be hit?
-		VMStateTester vmStateTester = new VMStateTester();
-		vmStateTester.addName("find-comment-match");
-		vmStateTester.addName("find-comment-by-name");
-		vmStateTester.addName("find-comment-match");
-		vmStateTester.addName("find-comment-by-name");
+		VMStateTester vmStateTester = new VMStateTester(VMStateTesterCompareType.Name);
+		vmStateTester.addStrategoState("find-comment-match");
+		vmStateTester.addStrategoState("find-comment-by-name");
+		vmStateTester.addStrategoState("find-comment-match");
+		vmStateTester.addStrategoState("find-comment-by-name");
+		vmStateTester.initialize();
 		vmMonitor.setVMStateTester(vmStateTester);
 		
 

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestImports.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestImports.java	Mon Dec  6 20:24:37 2010	(r21457)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestImports.java	Tue Dec  7 13:13:55 2010	(r21458)
@@ -53,10 +53,10 @@
 		this.addBP(dsm, utilsFilename, lineNumber, startTokenPosition, eventType);
 		
 		// which breakpoints will be hit?
-		VMStateTester vmStateTester = new VMStateTester();
-		vmStateTester.addName("match-comments");
-		vmStateTester.addName("first");
-		vmStateTester.addName("first");
+		VMStateTester vmStateTester = new VMStateTester(VMStateTesterCompareType.Name);
+		vmStateTester.addStrategoState("match-comments");
+		vmStateTester.addStrategoState("first");
+		vmStateTester.addStrategoState("first");
 		vmMonitor.setVMStateTester(vmStateTester);
 		
 		System.out.println("RUN");

Added: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestStepping.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestStepping.java	Tue Dec  7 13:13:55 2010	(r21458)
@@ -0,0 +1,114 @@
+package org.strategoxt.debug.core.control;
+
+import junit.framework.Assert;
+
+import org.StrategoFileManager;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.strategoxt.debug.core.model.LocationInfo;
+import org.strategoxt.debug.core.model.StrategoStackFrame;
+import org.strategoxt.debug.core.model.StrategoState;
+import org.strategoxt.debug.core.util.DebugSessionSettings;
+import org.strategoxt.debug.core.util.table.EventTable;
+
+public class DSMTestStepping extends AbstractDSMTest {
+
+	public static void main(String[] args) {
+		DSMTestStepping dsm = new DSMTestStepping();
+		dsm.testStepping();
+	}
+	
+	public void testStepping()
+	{
+		String projectName = "localvar";
+		String strategoFilename = "localvar.str";
+		DebugSessionSettings debugSessionSettings = new DebugSessionSettings(StrategoFileManager.WORKING_DIR, projectName);
+		
+		//String binBase = DebugCompilerTest.WORKING_DIR + "/" + projectName + "/class";
+		//String strategoBase = DebugCompilerTest.WORKING_DIR + "/" + projectName + "/stratego";
+		
+		String input = StrategoFileManager.BASE + "/src/stratego/localvar/run.input";
+		String argsForMainClass = "-i " + input;
+		String mainClass = "localvar.localvar";
+		String mainArgs = mainClass + " " + argsForMainClass;
+		String cp = /*strategoxtjar + ":" + libstrategodebuglib + ":" + strjdebugruntime + ":" + */ debugSessionSettings.getClassDirectory(); // was binBase
+		String classpath = cp;
+		
+		VMMonitorTestImpl2 vmMonitor = new VMMonitorTestImpl2();
+		DebugSessionManager dsm = new DebugSessionManager(debugSessionSettings, vmMonitor);
+		vmMonitor.setDSM(dsm);
+		
+		//String location = debugSessionSettings.getStrategoDirectory() + "/" + projectName + ".table";
+		//EventTable eventTable = EventTable.readEventTable(location);
+		EventTable eventTable = dsm.getEventSpecManager().getEventTable();
+		Assert.assertEquals(51, eventTable.size());
+
+		// which breakpoints will be hit?
+		VMStateTester vmStateTester = new VMStateTester(VMStateTesterCompareType.TopStackFrame);
+		
+		// 47, 8
+		// f* := <find-functions> definitions* // find functions
+		// in rule "match-comments"
+		int lineNumber = 47;
+		int startTokenPosition = 8;
+		String eventType = "s-step";
+		this.addBP(dsm, strategoFilename, lineNumber, startTokenPosition, eventType);
+		vmStateTester.addStrategoState(createState("localvar.str", "match-comments", 47, 4, 47, 39)); // match-comments[localvar.str]@(47,4)47 39
+
+		vmMonitor.addAction(VMMonitorTestImpl2.STEP_OVER);
+		// perform a STEP_OVER, will hit
+		// 48, 8
+		// c* := <find-comments> definitions* // find comments
+		// in rule "match-comments"
+		lineNumber = 48;
+		startTokenPosition = 8;
+		eventType = "s-step";
+		//this.addBP(dsm, strategoFilename, lineNumber, startTokenPosition, eventType);
+		vmStateTester.addStrategoState(createState("localvar.str", "match-comments", 48, 6, 48, 40)); // match-comments[localvar.str]@(48,6) 48,40
+		
+		vmMonitor.addAction(VMMonitorTestImpl2.STEP_OVER);
+		// perform a STEP_OVER, will hit
+		// 49, 8
+		// out := <match-f-and-c> (f*, c*)
+		// in rule "match-comments"
+		lineNumber = 49;
+		startTokenPosition = 8;
+		eventType = "s-step";
+		//this.addBP(dsm, strategoFilename, lineNumber, startTokenPosition, eventType);
+		vmStateTester.addStrategoState(createState("localvar.str", "match-comments", 49, 6, 49, 37)); // match-comments[localvar.str]@(49,6) 49 37
+	
+		
+
+		vmStateTester.initialize();
+		vmMonitor.setVMStateTester(vmStateTester);
+		
+
+		System.out.println("RUN");
+		// start the debug session
+		start(dsm, mainArgs, classpath);
+	}
+	
+	/**
+	 * Filename points to the stratego file name.
+	 * Name points to the strategy or rule name.
+	 * The four integers, startLineNum, startTokenPos, endLineNum, endTokenPos are used to create a LocationInfo object that points
+	 * to the current active statement.
+	 * @param filename
+	 * @param name
+	 * @param startLineNum
+	 * @param startTokenPos
+	 * @param endLineNum
+	 * @param endTokenPos
+	 * @return
+	 */
+	private StrategoState createState(String filename, String name, int startLineNum, int startTokenPos, int endLineNum,
+			int endTokenPos)
+	{
+		StrategoState state = new StrategoState();
+		LocationInfo currentLocationInfo = new LocationInfo(startLineNum, startTokenPos, endLineNum, endTokenPos);
+		IStrategoTerm current = null;
+		StrategoStackFrame frame = new StrategoStackFrame(filename, name, null, current);
+		frame.setCurrentLocationInfo(currentLocationInfo);
+		state.pushFrame(frame);
+		return state;
+	}
+}

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DebugSessionManagerTest.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DebugSessionManagerTest.java	Mon Dec  6 20:24:37 2010	(r21457)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DebugSessionManagerTest.java	Tue Dec  7 13:13:55 2010	(r21458)
@@ -1,16 +1,13 @@
 package org.strategoxt.debug.core.control;
 
 import java.util.List;
-import java.util.Map.Entry;
 
 import junit.framework.Assert;
 
 import org.StrategoFileManager;
-import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.strategoxt.debug.core.eventspec.BreakPoint;
 import org.strategoxt.debug.core.eventspec.RuleEnterBreakPoint;
 import org.strategoxt.debug.core.eventspec.StrategyEnterBreakPoint;
-import org.strategoxt.debug.core.model.StrategoState;
 import org.strategoxt.debug.core.util.DebugSessionSettings;
 import org.strategoxt.debug.core.util.table.EventEntry;
 import org.strategoxt.debug.core.util.table.EventTable;
@@ -46,14 +43,14 @@
 		String cp = /*strategoxtjar + ":" + libstrategodebuglib + ":" + strjdebugruntime + ":" + */ debugSessionSettings.getClassDirectory(); // was binBase
 		String classpath = cp;
 		
-		VMMonitorTestImpl1 vmMonitor = new VMMonitorTestImpl1();
+		VMMonitorTestImpl2 vmMonitor = new VMMonitorTestImpl2();
 		DebugSessionManager dsm = new DebugSessionManager(debugSessionSettings, vmMonitor);
 		vmMonitor.setDSM(dsm);
 		
 		// which breakpoints will be hit?
-		VMStateTester vmStateTester = new VMStateTester();
-		vmStateTester.addName("find-comment-match");
-		vmStateTester.addName("find-comment-match");
+		VMStateTester vmStateTester = new VMStateTester(VMStateTesterCompareType.Name);
+		vmStateTester.addStrategoState("find-comment-match");
+		vmStateTester.addStrategoState("find-comment-match");
 		vmMonitor.setVMStateTester(vmStateTester);
 		
 		// create a breakpoint
@@ -82,16 +79,16 @@
 		String cp = /*strategoxtjar + ":" + libstrategodebuglib + ":" + strjdebugruntime + ":" + */ debugSessionSettings.getClassDirectory(); // was binBase
 		String classpath = cp;
 		
-		VMMonitorTestImpl1 vmMonitor = new VMMonitorTestImpl1();
+		VMMonitorTestImpl2 vmMonitor = new VMMonitorTestImpl2();
 		DebugSessionManager dsm = new DebugSessionManager(debugSessionSettings, vmMonitor);
 		vmMonitor.setDSM(dsm);
 		
 		// which breakpoints will be hit?
-		VMStateTester vmStateTester = new VMStateTester();
-		vmStateTester.addName("find-comment-match");
-		vmStateTester.addName("first");
-		vmStateTester.addName("find-comment-match");
-		vmStateTester.addName("first");
+		VMStateTester vmStateTester = new VMStateTester(VMStateTesterCompareType.Name);
+		vmStateTester.addStrategoState("find-comment-match");
+		vmStateTester.addStrategoState("first");
+		vmStateTester.addStrategoState("find-comment-match");
+		vmStateTester.addStrategoState("first");
 		vmMonitor.setVMStateTester(vmStateTester);
 		
 		// create a breakpoint
@@ -122,7 +119,7 @@
 		String cp = /*strategoxtjar + ":" + libstrategodebuglib + ":" + strjdebugruntime + ":" + */ debugSessionSettings.getClassDirectory(); // was binBase
 		String classpath = cp;
 		
-		VMMonitorTestImpl1 vmMonitor = new VMMonitorTestImpl1();
+		VMMonitorTestImpl2 vmMonitor = new VMMonitorTestImpl2();
 		DebugSessionManager dsm = new DebugSessionManager(debugSessionSettings, vmMonitor);
 		vmMonitor.setDSM(dsm);
 		
@@ -156,10 +153,10 @@
 	
 		
 		// which breakpoints will be hit?
-		VMStateTester vmStateTester = new VMStateTester();
-		vmStateTester.addName("match-comments");
-		vmStateTester.addName("match-comments");
-		vmStateTester.addName("match-comments");
+		VMStateTester vmStateTester = new VMStateTester(VMStateTesterCompareType.Name);
+		vmStateTester.addStrategoState("match-comments");
+		vmStateTester.addStrategoState("match-comments");
+		vmStateTester.addStrategoState("match-comments");
 		vmMonitor.setVMStateTester(vmStateTester);
 		
 
@@ -185,7 +182,7 @@
 		String cp = /*strategoxtjar + ":" + libstrategodebuglib + ":" + strjdebugruntime + ":" + */ debugSessionSettings.getClassDirectory(); // was binBase
 		String classpath = cp;
 		
-		VMMonitorTestImpl1 vmMonitor = new VMMonitorTestImpl1();
+		VMMonitorTestImpl2 vmMonitor = new VMMonitorTestImpl2();
 		DebugSessionManager dsm = new DebugSessionManager(debugSessionSettings, vmMonitor);
 		vmMonitor.setDSM(dsm);
 		
@@ -221,10 +218,10 @@
 		
 		
 		// which breakpoints will be hit?
-		VMStateTester vmStateTester = new VMStateTester();
-		vmStateTester.addName("match-comments");
-		vmStateTester.addName("match-comments"); // value f* should be set
-		vmStateTester.addName("match-comments"); // value c* should be set
+		VMStateTester vmStateTester = new VMStateTester(VMStateTesterCompareType.Name);
+		vmStateTester.addStrategoState("match-comments");
+		vmStateTester.addStrategoState("match-comments"); // value f* should be set
+		vmStateTester.addStrategoState("match-comments"); // value c* should be set
 		vmMonitor.setVMStateTester(vmStateTester);
 		
 
@@ -251,7 +248,7 @@
 		String cp = /*strategoxtjar + ":" + libstrategodebuglib + ":" + strjdebugruntime + ":" + */ debugSessionSettings.getClassDirectory(); // was binBase
 		String classpath = cp;
 		
-		VMMonitorTestImpl1 vmMonitor = new VMMonitorTestImpl1();
+		VMMonitorTestImpl2 vmMonitor = new VMMonitorTestImpl2();
 		DebugSessionManager dsm = new DebugSessionManager(debugSessionSettings, vmMonitor);
 		vmMonitor.setDSM(dsm);
 		
@@ -275,9 +272,9 @@
 		// found the "find-comment-match" rule in the table
 
 		// which breakpoints will be hit?
-		VMStateTester vmStateTester = new VMStateTester();
-		vmStateTester.addName("find-comment-match");
-		vmStateTester.addName("find-comment-match");
+		VMStateTester vmStateTester = new VMStateTester(VMStateTesterCompareType.Name);
+		vmStateTester.addStrategoState("find-comment-match");
+		vmStateTester.addStrategoState("find-comment-match");
 		vmMonitor.setVMStateTester(vmStateTester);
 		
 		// create a breakpoint
@@ -303,55 +300,5 @@
 		manager.runVM();		
 		return manager;
 	}
-	
-
-	
-	class VMMonitorTestImpl1 implements VMMonitor {
-
-		private DebugSessionManager debugSessionManager;
-		private VMStateTester vmStateTester;
-		
-		public VMMonitorTestImpl1() {
-
-		}
-		
-		public void setVMStateTester(VMStateTester vmStateTester) {
-			this.vmStateTester = vmStateTester;
-		}
-
-		public void setDSM(DebugSessionManager dsm)
-		{
-			this.debugSessionManager = dsm;
-		}
-		
-		public void stateChanged(StrategoState state) {
-			//System.out.println("state changed");
-			String name = state.currentFrame().getName();
-			boolean expected = vmStateTester.isNextHit(name);
-			System.out.println("expected: " + expected);
-			String message = "Hit " + name + ", but expected to hit " + vmStateTester.currentHit();
-			Assert.assertTrue(message, expected);
-			String termString = state.currentFrame().getCurrentTerm().toString();
-			System.out.println("current: " + termString);
-			for ( Entry<String, IStrategoTerm> entry : state.currentFrame().getVariables().entrySet() )
-			{
-				System.out.println("variable entry " + entry.getKey() + " # " + entry.getValue());
-			}
-			this.debugSessionManager.resumeVM();
-		}
-
-		public void vmEvent(String event) {
-			System.out.println("vmEvent: " + event);
-			if ("VMDEATH".equals(event))
-			{
-				// vm terminated
-				if (this.vmStateTester.hasNextHit())
-				{
-					Assert.fail("VM has terminated but there are still some expected hits left...");
-				}
-			}
-		}
-		
-	}
 
 }

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/VMMonitorTestImpl2.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/VMMonitorTestImpl2.java	Mon Dec  6 20:24:37 2010	(r21457)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/VMMonitorTestImpl2.java	Tue Dec  7 13:13:55 2010	(r21458)
@@ -1,5 +1,7 @@
 package org.strategoxt.debug.core.control;
 
+import java.util.ArrayList;
+import java.util.List;
 import java.util.Map.Entry;
 
 import junit.framework.Assert;
@@ -9,9 +11,19 @@
 
 public class VMMonitorTestImpl2 implements VMMonitor {
 	
+	public final static String STEP_INTO = "STEP_INTO";
+	public final static String STEP_OVER = "STEP_OVER";
+	public final static String STEP_RETURN = "STEP_RETURN";
+	public final static String RESUME = "RESUME";
+	
 	private DebugSessionManager debugSessionManager;
 	private VMStateTester vmStateTester;
 	
+	// list contains String encoded actions: e.g. RESUME, STEP
+	// This action should be performed after a state change, if no actions are in the list left, do a RESUME
+	private List<String> afterStateChangeActions = null;
+	private int actionIndex = -1;
+	
 	public VMMonitorTestImpl2() {
 
 	}
@@ -26,19 +38,21 @@
 	}
 	
 	public void stateChanged(StrategoState state) {
-		//System.out.println("state changed");
-		String name = state.currentFrame().getName();
-		boolean expected = vmStateTester.isNextHit(name);
-		System.out.println("expected: " + expected);
-		String message = "Hit " + name + ", but expected to hit " + vmStateTester.currentHit();
-		Assert.assertTrue(message, expected);
-		String termString = state.currentFrame().getCurrentTerm().toString();
-		System.out.println("current: " + termString);
-		for ( Entry<String, IStrategoTerm> entry : state.currentFrame().getVariables().entrySet() )
+		System.out.println("state changed");
+		if (vmStateTester.hasNext())
 		{
-			System.out.println("variable entry " + entry.getKey() + " # " + entry.getValue());
+			vmStateTester.next();
+			boolean expected = vmStateTester.compareState(state);
+			String message = "Hit " + state.currentFrame() + ", but expected to hit " + vmStateTester.current().currentFrame();
+			Assert.assertTrue(message, expected);
+			System.out.println("current: " + state.currentFrame().getCurrentTerm());
+			for ( Entry<String, IStrategoTerm> entry : state.currentFrame().getVariables().entrySet() )
+			{
+				System.out.println("variable entry " + entry.getKey() + " # " + entry.getValue());
+			}
 		}
-		this.debugSessionManager.resumeVM();
+		
+		nextAction();
 	}
 
 	public void vmEvent(String event) {
@@ -46,10 +60,54 @@
 		if ("VMDEATH".equals(event))
 		{
 			// vm terminated
-			if (this.vmStateTester.hasNextHit())
+			if (this.vmStateTester.hasNext())
 			{
 				Assert.fail("VM has terminated but there are still some expected hits left...");
 			}
 		}
 	}
+	
+	public void addAction(String action)
+	{
+		if (this.afterStateChangeActions == null)
+		{
+			this.afterStateChangeActions = new ArrayList<String>();
+		}
+		this.afterStateChangeActions.add(action);
+	}
+	
+	private void nextAction()
+	{
+		actionIndex++;
+		if (afterStateChangeActions != null && actionIndex < afterStateChangeActions.size())
+		{
+			String action = afterStateChangeActions.get(actionIndex);
+			if (RESUME.equals(action))
+			{
+				this.debugSessionManager.resumeVM();
+			}
+			else if (STEP_INTO.equals(action))
+			{
+				this.debugSessionManager.stepInto();
+			}
+			else if (STEP_OVER.equals(action))
+			{
+				this.debugSessionManager.stepOver();
+			}
+			else if (STEP_RETURN.equals(action))
+			{
+				this.debugSessionManager.stepReturn();
+			}
+			else
+			{
+				// action unknown, just do a resume
+				this.debugSessionManager.resumeVM();
+			}
+		}
+		else
+		{
+			// no actions left, just do a resume
+			this.debugSessionManager.resumeVM();
+		}
+	}
 }

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/VMStateTester.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/VMStateTester.java	Mon Dec  6 20:24:37 2010	(r21457)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/VMStateTester.java	Tue Dec  7 13:13:55 2010	(r21458)
@@ -1,55 +1,121 @@
 package org.strategoxt.debug.core.control;
 
 import java.util.ArrayList;
+import java.util.Iterator;
 import java.util.List;
 
+import org.strategoxt.debug.core.model.StrategoStackFrame;
+import org.strategoxt.debug.core.model.StrategoState;
+
+enum VMStateTesterCompareType
+{
+	Name, TopStackFrame, FullState
+}
+/**
+ * Helper class for testing the state of the DebugSessionManager.
+ * This class contains a list of StrategoStates and whenever a breakpoint is hit we should compare the state
+ * of the DebugSessionManager with the current state of the VMStateTester.
+ * 
+ * For now it will only test the toplevel StrategoStackFrame.
+ * @author rlindeman
+ *
+ */
 public class VMStateTester {
 
-	private List<String> willHitNames = new ArrayList<String>();
+	private List<StrategoState> willHitStates = new ArrayList<StrategoState>();
 	
-	private int currentHit = -1;
+	private Iterator<StrategoState> iter = null;
 	
-	public boolean isNextHit(String name){
-		currentHit++;
-		if (currentHit >= willHitNames.size())
-		{
-			// we are hitting more breakpoints than anticipated...
-			return false;
-		}
-		String expected = willHitNames.get(currentHit);
-		if (name != null && name.equals(expected))
-		{
-			return true;
-		}
-		else
-		{
-			return false;
-		}
+	private StrategoState current;
+	
+	// if fullcompare is true compare the toplevel StackFrame
+	// if fullCompare is false only compare the strategy name
+	private VMStateTesterCompareType compareType = VMStateTesterCompareType.Name;
+	
+	public VMStateTester(VMStateTesterCompareType compareType)
+	{
+		this.compareType = compareType;
 	}
 	
-	public String currentHit()
+	public void initialize()
 	{
-		if (currentHit < 0 || currentHit >= willHitNames.size())
+		this.iter =  getIterator();
+	}
+	
+	private Iterator<StrategoState> getIterator()
+	{
+		if (iter == null)
 		{
-			return null;
+			this.iter = this.willHitStates.iterator();
 		}
-		return this.willHitNames.get(currentHit);
+		return this.iter;
 	}
 	
-	public boolean hasNextHit()
+	public boolean hasNext()
 	{
-		if (currentHit < 0 || (currentHit + 1) >= willHitNames.size())
-		{
-			return false;
+		return getIterator().hasNext();
+	}
+	
+	public StrategoState next()
+	{
+		this.current = getIterator().next();
+		return this.current;
+	}
+	
+	public StrategoState current()
+	{
+		return this.current;
+	}
+	
+	
+	
+	/**
+	 * Compare the given StrategoState with the current StrategoState.
+	 * 
+	 * For now only compare the toplevel StrategoStackFrame.
+	 * @param state
+	 */
+	public boolean compareState(StrategoState state)
+	{
+		StrategoStackFrame currentTop = this.current().currentFrame();
+		StrategoStackFrame compareTop = state.currentFrame();
+		
+		boolean statesEquals = false;
+		switch(this.compareType) {
+			case TopStackFrame:
+				boolean sameName = currentTop.getName().equals(compareTop.getName());
+				boolean sameFilename = currentTop.getFilename().equals(compareTop.getFilename());
+				boolean sameLocation = currentTop.getCurrentLocationInfo().equals(compareTop.getCurrentLocationInfo());
+				statesEquals = sameName && sameFilename && sameLocation;
+				break;
+			case Name:
+				statesEquals = currentTop.getName().equals(compareTop.getName());
+				break;
+			default:
+				break;
+			
 		}
-		else
+		// TODO: compare on full StackFrame or even on full StrategoState
+		return statesEquals;
+	}
+	
+
+	public void addStrategoState(String name)
+	{
+		if (this.compareType != VMStateTesterCompareType.Name)
 		{
-			return true;
+			// we want to compare on names, but compareType is not Name!
+			// TODO: throw error
 		}
+		StrategoState state = new StrategoState();
+		StrategoStackFrame frame = new StrategoStackFrame(null, name, null, null);
+		state.pushFrame(frame);
+		
+		this.willHitStates.add(state);
 	}
 	
-	public void addName(String name)
+	public void addStrategoState(StrategoState state)
 	{
-		this.willHitNames.add(name);
+		this.willHitStates.add(state);
 	}
 }

From m.dejonge at tudelft.nl  Tue Dec  7 14:46:28 2010
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Tue, 07 Dec 2010 13:46:28 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21459 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr
Message-ID: <201012071346.oB7DkSGS001489@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: Tue Dec  7 13:46:27 2010
New Revision: 21459
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21459&sc=1

Log:
Configurable error recovery

Added:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/RecoveryPerformance.java   (contents, props changed)
Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/FineGrainedOnRegion.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/RecoveryConnector.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/SGLR.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/FineGrainedOnRegion.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/FineGrainedOnRegion.java	Tue Dec  7 13:13:55 2010	(r21458)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/FineGrainedOnRegion.java	Tue Dec  7 13:46:27 2010	(r21459)
@@ -2,8 +2,6 @@
 
 import java.io.IOException;
 import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
 
 import org.spoofax.ArrayDeque;
 
@@ -11,7 +9,6 @@
     private static final int MAX_RECOVERIES_PER_LINE = 3;
     private static final int MAX_NR_OF_LINES = 25;
     private int acceptRecoveryPosition;
-    private int regionStartPosition;
     private int regionEndPosition;
     private ArrayList<BacktrackPosition> choicePoints;
     private SGLR mySGLR;
@@ -21,8 +18,22 @@
         return mySGLR.getHistory();
     }
    
+    public void setInfoFGOnly(){
+        regionEndPosition=mySGLR.tokensSeen;
+        acceptRecoveryPosition=regionEndPosition+10;
+        int lastIndex=getHistory().getIndexLastLine();       
+        for (int i = 0; i < lastIndex; i++) {
+            IndentInfo line= getHistory().getLine(i);
+            if(line.getStackNodes()!=null && line.getStackNodes().size()>0){
+                BacktrackPosition btPoint=new BacktrackPosition(line.getStackNodes(), line.getTokensSeen());
+                btPoint.setIndexHistory(i);
+                choicePoints.add(btPoint);
+            }            
+        } 
+        maxPerLine=MAX_RECOVERIES_PER_LINE;
+    }
+    
     public void setRegionInfo(StructureSkipSuggestion erroneousRegion, int acceptPosition){
-        regionStartPosition=erroneousRegion.getStartSkip().getTokensSeen();
         regionEndPosition=erroneousRegion.getEndSkip().getTokensSeen();
         acceptRecoveryPosition=acceptPosition;
         int lastIndex=Math.min(erroneousRegion.getIndexHistoryEnd(), getHistory().getIndexLastLine());
@@ -105,7 +116,7 @@
             //if(logToken==SGLR.EOF){logToken='$';}
             //System.out.print(logToken);
             if(curTokIndex<=endRecoverSearchPos && !firstRound){
-                int oldSize=newCandidates.size();
+                //int oldSize=newCandidates.size();
                 newCandidates.addAll(collectNewRecoverCandidates(curTokIndex));
                 //if(newCandidates.size()>oldSize)
                   //  System.out.println("CANDIDATES: " + (newCandidates.size()-oldSize));

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/RecoveryConnector.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/RecoveryConnector.java	Tue Dec  7 13:13:55 2010	(r21458)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/RecoveryConnector.java	Tue Dec  7 13:46:27 2010	(r21459)
@@ -11,8 +11,17 @@
     private RegionRecovery skipRecovery;
     private boolean useBridgeParser;
     private boolean useFineGrained;
+    private boolean onlyFineGrained;
     
     
+    public void setOnlyFineGrained(boolean onlyFG) {
+        onlyFineGrained=onlyFG;        
+    }
+    
+    public void setUseFineGrained(boolean useFG) {
+        useFineGrained=useFG;        
+    }
+    
     public void setUseBridgeParser(boolean useBridgeParser) {
         this.useBridgeParser = useBridgeParser;
     }
@@ -21,6 +30,7 @@
         mySGLR=parser;        
         skipRecovery = new RegionRecovery(mySGLR); 
         useFineGrained=true;
+        onlyFineGrained=false;
         if(recoveryParser!=null){
             this.recoveryParser = recoveryParser;
             useBridgeParser=true;
@@ -35,20 +45,39 @@
     }
 
     public void recover() throws IOException {
+        mySGLR.getPerformanceMeasuring().startRecovery();
+        combinedRecover();
+        mySGLR.getPerformanceMeasuring().endRecovery();
+    }
+
+    private void combinedRecover() throws IOException {
+        if(onlyFineGrained){
+            mySGLR.getPerformanceMeasuring().startFG();
+            tryFineGrainedRepair();
+            mySGLR.getPerformanceMeasuring().endFG();
+            return;
+        }
+        mySGLR.getPerformanceMeasuring().startCG();
         boolean skipSucceeded = skipRecovery.selectErroneousFragment(); //decides whether whitespace parse makes sense
+        mySGLR.getPerformanceMeasuring().endCG();
         mySGLR.acceptingStack=null;
         mySGLR.activeStacks.clear();
         //BRIDGE REPAIR
-        if(useBridgeParser){       
+        if(useBridgeParser){            
             String errorFragment = skipRecovery.getErrorFragmentWithLeftMargin();
+            mySGLR.getPerformanceMeasuring().startBP();
             boolean succeeded = tryBridgeRepair(errorFragment);
+            mySGLR.getPerformanceMeasuring().endBP();
             if(succeeded){
                 return;
             }
         }
         //FINEGRAINED REPAIR 
-        if(useFineGrained){            
-            if(tryFineGrainedRepair()){ //FG succeeded  
+        if(useFineGrained){
+            mySGLR.getPerformanceMeasuring().startFG();
+            boolean FGSucceeded=tryFineGrainedRepair();
+            mySGLR.getPerformanceMeasuring().endFG();
+            if(FGSucceeded){ //FG succeeded  
                 addSkipOption(skipSucceeded);
                 return;
             }
@@ -83,8 +112,13 @@
     }
 
     private boolean tryFineGrainedRepair() throws IOException {
-        FineGrainedOnRegion fgRepair=new FineGrainedOnRegion(mySGLR);        
-        fgRepair.setRegionInfo(skipRecovery.getErroneousRegion(), skipRecovery.getAcceptPosition());
+        FineGrainedOnRegion fgRepair=new FineGrainedOnRegion(mySGLR); 
+        if(!onlyFineGrained){
+            fgRepair.setRegionInfo(skipRecovery.getErroneousRegion(), skipRecovery.getAcceptPosition());
+        }
+        else{
+            fgRepair.setInfoFGOnly();
+        }
         fgRepair.recover();
         fgRepair.parseRemainingTokens();
         return recoverySucceeded();
@@ -176,10 +210,6 @@
             indexFragment++;
         return indexFragment;
     }
-
-    public void setUseFineGrained(boolean useFG) {
-        useFineGrained=useFG;        
-    }
     
     /*
     private Map<Integer, char[]> getBPSuggestions(){

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/RecoveryPerformance.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/RecoveryPerformance.java	Tue Dec  7 13:46:27 2010	(r21459)
@@ -0,0 +1,88 @@
+package org.spoofax.jsglr;
+
+import java.util.ArrayList;
+
+public class RecoveryPerformance {
+    
+    private long startParse;
+    private long parseTime;
+    private long startCG;
+    private ArrayList<Integer> CGTimes;
+    private long startFG;
+    private ArrayList<Integer> FGTimes;
+    private long startBP;
+    private ArrayList<Integer> BPTimes;
+    private long startRecovery;
+    private ArrayList<Integer> recoveryTimes;
+    
+    public RecoveryPerformance(){
+        CGTimes=new ArrayList<Integer>();
+        FGTimes=new ArrayList<Integer>();
+        BPTimes=new ArrayList<Integer>();
+        recoveryTimes=new ArrayList<Integer>();
+    }
+    
+    public long getParseTime() {
+        return parseTime;
+    }
+
+    public ArrayList<Integer> getCGTimes() {
+        return CGTimes;
+    }
+
+    public ArrayList<Integer> getFGTimes() {
+        return FGTimes;
+    }
+
+    public ArrayList<Integer> getBPTimes() {
+        return BPTimes;
+    }
+
+    public ArrayList<Integer> getRecoveryTimes() {
+        return recoveryTimes;
+    }
+
+    void startParse(){
+        startParse=System.currentTimeMillis();
+    }
+
+    void endParse(){
+        parseTime=System.currentTimeMillis()-startParse;
+    }
+    
+    void startCG(){
+        startCG=System.currentTimeMillis();
+    }
+
+    void endCG(){
+        long CGTime=System.currentTimeMillis()-startCG;
+        CGTimes.add((int) CGTime);
+    }
+    
+    void startFG(){
+        startFG=System.currentTimeMillis();
+    }
+
+    void endFG(){
+        long FGTime=System.currentTimeMillis()-startFG;
+        FGTimes.add((int)FGTime);
+    }
+    
+    void startBP(){
+        startBP=System.currentTimeMillis();
+    }
+
+    void endBP(){
+        long BPTime=System.currentTimeMillis()-startBP;
+        BPTimes.add((int)BPTime);
+    }
+    
+    void startRecovery(){
+        startRecovery=System.currentTimeMillis();
+    }
+
+    void endRecovery(){
+        long recoveryTime=System.currentTimeMillis()-startRecovery;
+        recoveryTimes.add((int)recoveryTime);
+    }
+}

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/SGLR.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/SGLR.java	Tue Dec  7 13:13:55 2010	(r21458)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/SGLR.java	Tue Dec  7 13:46:27 2010	(r21459)
@@ -28,6 +28,8 @@
 
 public class SGLR {             
    
+    private RecoveryPerformance performanceMeasuring;
+    
     private final Set<BadTokenException> collectedErrors = new LinkedHashSet<BadTokenException>();
     
     static final int EOF = ParseTable.NUM_CHARS;
@@ -93,15 +95,6 @@
     private int reductionCount;
 
     private PushbackInputStream currentInputStream;
-   
-    //Creates indent- and dedent- tokens
-    //Meant for parsing of indentation based languages
-    //TODO: still under construction
-    private IndentTokenizer indentTokenHandler;
-    
-    // ------------------------------------- Integrated recovery  ------------------------
-  //Keeps track of the indentation for each line
-   // private IndentationHandler indentHandler;
     
     private ParserHistory history;
     
@@ -138,9 +131,6 @@
     public Set<BadTokenException> getCollectedErrors() {
         return collectedErrors;
     }
-    
-    //-------------------------- fine-grained recovery ----------------------------------
-    private RecoverDisambiguator recoverDisambiguator;
        
     SGLR() {
         basicInit(null);
@@ -212,7 +202,6 @@
         useIntegratedRecovery = false;
         recoverIntegrator = null;
         history=new ParserHistory();
-        recoverDisambiguator=new RecoverDisambiguator(this.parseTable);
     }
 
     public static boolean isDebugging() {
@@ -248,7 +237,10 @@
         initParseVariables(fis);        
         startTime = System.currentTimeMillis();
         initParseTimer();
-        return sglrParse(startSymbol);
+        getPerformanceMeasuring().startParse();
+        ATerm pt= sglrParse(startSymbol);
+        getPerformanceMeasuring().endParse();
+        return pt;
     }
     
     public final ATerm parse(String input) throws IOException, BadTokenException,
@@ -366,6 +358,8 @@
         //history.keepInitialState(this);
         collectedErrors.clear();
         history=new ParserHistory();
+        performanceMeasuring=new RecoveryPerformance();
+        
     }    
 
      private BadTokenException createBadTokenException() {
@@ -1283,7 +1277,7 @@
     }    
     //-------------------------------------------------- mj: debug and recovery ------------------------
         
-    //Used for debugging
+    /*Used for debugging
     private String mjInfo() {
         String result = "";
         result += "CURR TOKEN: " + (char)currentToken;
@@ -1313,8 +1307,8 @@
             result += "} ; ";
         }
         return result;        
-    } 
-    
+    } */
+    /*
     private String[] viewStackObject(boolean avoidFiltered){
         List<String> stackPaths = new ArrayList<String>();
         for (Frame actNode : activeStacks) {
@@ -1322,8 +1316,9 @@
             stackPaths.addAll(testMJ);
         }
         return stackPaths.toArray(new String[stackPaths.size()]);
-    }  
+    } */ 
     
+    /*
     private String[] viewStackObject()
     {
         return viewStackObject(false);
@@ -1336,5 +1331,13 @@
     
     private void mjTesting() {        
         Tools.debug((char)currentToken); 
+    }*/
+
+    public void setPerformanceMeasuring(RecoveryPerformance performanceMeasuring) {
+        this.performanceMeasuring = performanceMeasuring;
+    }
+
+    public RecoveryPerformance getPerformanceMeasuring() {
+        return performanceMeasuring;
     }   
 }

From r.t.lindeman at student.tudelft.nl  Tue Dec  7 16:36:46 2010
From: r.t.lindeman at student.tudelft.nl (Ricky Lindeman)
Date: Tue, 07 Dec 2010 15:36:46 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21460 - in
	spoofax-imp/trunk:
	org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control
	org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/...
Message-ID: <201012071536.oB7FakNu003469@proliant.st.ewi.tudelft.nl>

Author: RickyLindeman
Date: Tue Dec  7 15:36:46 2010
New Revision: 21460
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21460&sc=1

Log:
* implemented STEP_INTO
 * fixed corner cases for STEP_OVER
 * Added more testcases for stepping

Added:
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestStepInto.java
Modified:
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/DebugSessionManager.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/EventThread.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/ThreadEventHandler.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/EventHandler.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/RuleEnterHandler.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/RuleExitHandler.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyEnterHandler.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyExitHandler.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyStepHandler.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyVarHandler.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/EventSpecManager.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/model/LocationInfo.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/model/StrategoStackFrame.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/model/StrategoState.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestStepping.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/VMMonitorTestImpl2.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/VMStateTester.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/DebugSessionManager.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/DebugSessionManager.java	Tue Dec  7 13:46:27 2010	(r21459)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/DebugSessionManager.java	Tue Dec  7 15:36:46 2010	(r21460)
@@ -202,6 +202,9 @@
 	{
 		// stop at the first possible s-enter/r-enter event
 		// if the current statement is not a call to another method, we can only step over
+		ThreadEventHandler handler = this.eventThread.getMainThreadHandler();
+		this.eventSpecManager.setStepInto(handler.getStrategoState());
+		this.resumeVM();
 	}
 	
 	public void stepOver()

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/EventThread.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/EventThread.java	Tue Dec  7 13:46:27 2010	(r21459)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/EventThread.java	Tue Dec  7 15:36:46 2010	(r21460)
@@ -370,16 +370,4 @@
 		}
 	}
 
-	public void getSuspendedThread() {
-		// TODO Auto-generated method stub
-		System.out.println("threads:");
-		for(ThreadReference ref: this.traceMap.keySet())
-		{
-			System.out.println("ThreadRef Name " + ref.name());
-			//ThreadEventHandler handler = this.traceMap.get(ref);
-			boolean isSuspended = ref.isSuspended();
-			System.out.println("isSuspended: " + isSuspended);
-		}
-	}
-
 }

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/ThreadEventHandler.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/ThreadEventHandler.java	Tue Dec  7 13:46:27 2010	(r21459)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/ThreadEventHandler.java	Tue Dec  7 15:36:46 2010	(r21460)
@@ -122,7 +122,7 @@
 				
 				// update the current location
 				LocationInfo locationInfo = h.getLocationInfo();
-				this.strategoState.currentFrame().setCurrentLocationInfo(locationInfo);
+				this.strategoState.currentFrame().setCurrentLocationInfo(locationInfo, h.getEventType());
 				
 				suspendThread = h.shouldSuspend(this.strategoState, eventSpecManager);
 				// if the thread will be suspended, update the Dynamic Rules. But first get it from the vm while it is suspended

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/EventHandler.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/EventHandler.java	Tue Dec  7 13:46:27 2010	(r21459)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/EventHandler.java	Tue Dec  7 15:36:46 2010	(r21460)
@@ -457,8 +457,35 @@
 					// S_VAR we can ignore
 					// S_ENTER/R_ENTER should never happen is the same StackFrame
 					// S_EXIT/R_EXIT can happen
+					else if (this.getEventType().equals(EventHandler.S_EXIT) || this.getEventType().equals(EventHandler.R_EXIT))
+					{
+						// we have hit the s-exit/r-exit of the frame in which the step occured.
+						shouldSuspend = true;
+						eventSpecManager.resetStep(); // reset step
+					}
 				}
 			}
+			// what if the current stackframe level is smaller that the stepFrameLevel? We must have missed an r-exit/s-exit
+		} else if (eventSpecManager.isStepIntoActive())
+		{
+			// an new debug event was fired, this should be an s-enter or r-enter as we can only step into strategies or rules that are debuggable
+			// if the event is s-step we just did a normal step over, cancel the stepinto event and just resume
+			
+			// level of the current stackframe should equal (stepFrameLevel+1)
+			// an we should have stopped at a s-enter/r-enter
+			int stepIntoFrameLevel = eventSpecManager.getStepFrameLevel() + 1;
+			if (stepIntoFrameLevel == currentState.getStackFrames().length - 1 && 
+					(this.getEventType().equals(EventHandler.S_ENTER)
+					|| this.getEventType().equals(EventHandler.R_ENTER))
+					)
+			{
+				shouldSuspend = true;
+			}
+			else
+			{
+				// could not do a s-enter
+			}
+			eventSpecManager.resetStep(); // reset step
 		}
 		
         return shouldSuspend; // if break point exists suspend thread
@@ -474,7 +501,7 @@
 	
 	protected abstract BreakPoint createBreakPoint();
 
-	protected abstract String getEventType();
+	public abstract String getEventType();
 
 	public abstract boolean isEnter();
 }

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/RuleEnterHandler.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/RuleEnterHandler.java	Tue Dec  7 13:46:27 2010	(r21459)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/RuleEnterHandler.java	Tue Dec  7 15:36:46 2010	(r21460)
@@ -25,7 +25,7 @@
 	}
 
 	@Override
-	protected String getEventType() {
+	public String getEventType() {
 		return EventHandler.R_ENTER;
 	}
 

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/RuleExitHandler.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/RuleExitHandler.java	Tue Dec  7 13:46:27 2010	(r21459)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/RuleExitHandler.java	Tue Dec  7 15:36:46 2010	(r21460)
@@ -23,7 +23,7 @@
 	}
 
 	@Override
-	protected String getEventType() {
+	public String getEventType() {
 		return EventHandler.R_EXIT;
 	}
 

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyEnterHandler.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyEnterHandler.java	Tue Dec  7 13:46:27 2010	(r21459)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyEnterHandler.java	Tue Dec  7 15:36:46 2010	(r21460)
@@ -25,7 +25,7 @@
 	}
 
 	@Override
-	protected String getEventType() {
+	public String getEventType() {
 		// TODO Auto-generated method stub
 		return EventHandler.S_ENTER;
 	}

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyExitHandler.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyExitHandler.java	Tue Dec  7 13:46:27 2010	(r21459)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyExitHandler.java	Tue Dec  7 15:36:46 2010	(r21460)
@@ -28,7 +28,7 @@
 	}
 
 	@Override
-	protected String getEventType() {
+	public String getEventType() {
 		return EventHandler.S_EXIT;
 	}
 

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyStepHandler.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyStepHandler.java	Tue Dec  7 13:46:27 2010	(r21459)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyStepHandler.java	Tue Dec  7 15:36:46 2010	(r21460)
@@ -23,7 +23,7 @@
 	}
 
 	@Override
-	protected String getEventType() {
+	public String getEventType() {
 		return EventHandler.S_STEP;
 	}
 

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyVarHandler.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyVarHandler.java	Tue Dec  7 13:46:27 2010	(r21459)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyVarHandler.java	Tue Dec  7 15:36:46 2010	(r21460)
@@ -18,7 +18,7 @@
 	}
 	
 	@Override
-	protected String getEventType() {
+	public String getEventType() {
 		return EventHandler.S_VAR;
 	}
 

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/EventSpecManager.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/EventSpecManager.java	Tue Dec  7 13:46:27 2010	(r21459)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/EventSpecManager.java	Tue Dec  7 15:36:46 2010	(r21460)
@@ -2,6 +2,7 @@
 
 import java.util.List;
 
+import org.strategoxt.debug.core.control.events.EventHandler;
 import org.strategoxt.debug.core.model.StrategoStackFrame;
 import org.strategoxt.debug.core.model.StrategoState;
 import org.strategoxt.debug.core.util.DebugSessionSettings;
@@ -115,17 +116,44 @@
 	
 	public void setStepOver(StrategoState state)
 	{
-		stepFrame = state.currentFrame();
-		stepFrameLevel = state.getStackFrames().length - 1;
-		isStepOverActive = true;
+		if (state.currentFrame().getEventType().equals(EventHandler.S_EXIT)
+				|| state.currentFrame().getEventType().equals(EventHandler.R_EXIT))
+		{
+			// can we step over an s-exit or r-exit?
+			// we should suspend at the next s-step in the parent Frame of the current Frame
+			int parentIndex = state.size() - 2;
+			if (parentIndex < 0)
+			{
+				// no parent index
+				// we are at the exit of the main strategy!
+				return;
+			}
+			stepFrame = state.get(parentIndex);
+			stepFrameLevel = parentIndex;
+			isStepOverActive = true;
+		}
+		else
+		{
+			stepFrame = state.currentFrame();
+			stepFrameLevel = state.size() - 1;
+			isStepOverActive = true;
+		}
 	}
 	
 	
 	public void setStepInto(StrategoState state)
 	{
-		stepFrame = state.currentFrame();
-		stepFrameLevel = state.getStackFrames().length - 1;
-		isStepIntoActive = true;
+		if (state.currentFrame().getEventType().equals(EventHandler.S_STEP))
+		{
+			// we can only step into a strategy or rule
+			stepFrame = state.currentFrame();
+			stepFrameLevel = state.getStackFrames().length - 1;
+			isStepIntoActive = true;
+		}
+		else
+		{
+			// current stackframe is suspend at a s-exit/r-exit/s-enter/r-enter
+		}
 	}
 	
 	public void setStepReturn(StrategoState state)

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/model/LocationInfo.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/model/LocationInfo.java	Tue Dec  7 13:46:27 2010	(r21459)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/model/LocationInfo.java	Tue Dec  7 15:36:46 2010	(r21460)
@@ -111,6 +111,16 @@
 				+ "]";
 	}
 	
+	/**
+	 * Returns a short version of the toString()
+	 * Example: "(48,8,48,30)"
+	 * @return
+	 */
+	public String toShortString()
+	{
+		return "("+start_line_num+","+start_token_pos+","+end_line_num+","+end_token_pos+")";
+	}
+	
 	public boolean surrounds(int linenumber, int token_position)
 	{
 		// check if the start_line_num <= linenumber <= end_line_num

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/model/StrategoStackFrame.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/model/StrategoStackFrame.java	Tue Dec  7 13:46:27 2010	(r21459)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/model/StrategoStackFrame.java	Tue Dec  7 15:36:46 2010	(r21460)
@@ -35,6 +35,11 @@
 	private HashMap<String, IStrategoTerm> variables = null;
 	
 	/**
+	 * The event that is associated with the currentLocationInfo.
+	 */
+	private String eventType = null;
+	
+	/**
 	 * 
 	 * @param filename The filename in which the current rule or strategy is defined.
 	 * @param name The name of the current rule or strategy.
@@ -55,7 +60,7 @@
 		String val = "Frame @ " + this.name + "[" + this.filename + "]";
 		if (currentLocationInfo != null) // specific location
 		{
-			val += "@("+currentLocationInfo.getStart_line_num()+","+currentLocationInfo.getStart_token_pos()+")";
+			val += "@"+currentLocationInfo.toShortString();
 		}
 		/*
 		if (locationInfo != null) // location of the rule or strategy
@@ -118,14 +123,24 @@
 		return this.variables;
 	}
 	
+	/**
+	 * Gets the eventType that was fired at the current LocationInfo.
+	 * @return
+	 */
+	public String getEventType()
+	{
+		return this.eventType;
+	}
+	
 	public void setCurrentTerm(IStrategoTerm term)
 	{
 		this.current = term;
 	}
 	
-	public void setCurrentLocationInfo(LocationInfo currentLocationInfo)
+	public void setCurrentLocationInfo(LocationInfo currentLocationInfo, String eventType)
 	{
 		this.currentLocationInfo = currentLocationInfo;
+		this.eventType = eventType;
 	}
 	
 	/**

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/model/StrategoState.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/model/StrategoState.java	Tue Dec  7 13:46:27 2010	(r21459)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/model/StrategoState.java	Tue Dec  7 15:36:46 2010	(r21460)
@@ -47,6 +47,16 @@
 		return stack.peek();
 	}
 	
+	public int size()
+	{
+		return this.stack.size();
+	}
+	
+	public StrategoStackFrame get(int index)
+	{
+		return this.stack.get(index);
+	}
+	
 	/**
 	 * Returns a list of strings, each item represents a stratego state
 	 * @return

Added: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestStepInto.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestStepInto.java	Tue Dec  7 15:36:46 2010	(r21460)
@@ -0,0 +1,128 @@
+package org.strategoxt.debug.core.control;
+
+import junit.framework.Assert;
+
+import org.StrategoFileManager;
+import org.strategoxt.debug.core.util.DebugSessionSettings;
+import org.strategoxt.debug.core.util.table.EventTable;
+
+public class DSMTestStepInto extends AbstractDSMTest {
+
+	public static void main(String[] args) {
+		DSMTestStepInto dsm = new DSMTestStepInto();
+		//dsm.testStepping1();
+		dsm.testStepping2();
+		//dsm.testStepping3();
+	}
+	
+	public void testStepping1()
+	{
+		String projectName = "localvar";
+		String strategoFilename = "localvar.str";
+		DebugSessionSettings debugSessionSettings = new DebugSessionSettings(StrategoFileManager.WORKING_DIR, projectName);
+		
+		//String binBase = DebugCompilerTest.WORKING_DIR + "/" + projectName + "/class";
+		//String strategoBase = DebugCompilerTest.WORKING_DIR + "/" + projectName + "/stratego";
+		
+		String input = StrategoFileManager.BASE + "/src/stratego/localvar/run.input";
+		String argsForMainClass = "-i " + input;
+		String mainClass = "localvar.localvar";
+		String mainArgs = mainClass + " " + argsForMainClass;
+		String cp = /*strategoxtjar + ":" + libstrategodebuglib + ":" + strjdebugruntime + ":" + */ debugSessionSettings.getClassDirectory(); // was binBase
+		String classpath = cp;
+		
+		VMMonitorTestImpl2 vmMonitor = new VMMonitorTestImpl2();
+		DebugSessionManager dsm = new DebugSessionManager(debugSessionSettings, vmMonitor);
+		vmMonitor.setDSM(dsm);
+		
+		//String location = debugSessionSettings.getStrategoDirectory() + "/" + projectName + ".table";
+		//EventTable eventTable = EventTable.readEventTable(location);
+		EventTable eventTable = dsm.getEventSpecManager().getEventTable();
+		Assert.assertEquals(51, eventTable.size());
+
+		// which breakpoints will be hit?
+		VMStateTester vmStateTester = new VMStateTester(VMStateTesterCompareType.TopStackFrame);
+		
+		// 47, 8
+		// f* := <find-functions> definitions* // find functions
+		// in rule "match-comments"
+		int lineNumber = 47;
+		int startTokenPosition = 8;
+		String eventType = "s-step";
+		this.addBP(dsm, strategoFilename, lineNumber, startTokenPosition, eventType);
+		vmStateTester.addStrategoState(VMStateTester.createState("localvar.str", "match-comments", "s-step", 47, 4, 47, 39)); // match-comments[localvar.str]@(47,4)47 39
+
+		vmMonitor.addAction(VMMonitorTestImpl2.STEP_INTO);
+		// perform a STEP_INTO, will hit
+		// 52, 3
+		//find-functions:
+		//	definition* -> functions*
+		//	with
+		//		functions* := <filter(?Function(_,_))> definition*
+		vmStateTester.addStrategoState(VMStateTester.createState("localvar.str", "find-functions", "s-enter", 52, 2, 55, 54));
+	
+		
+		
+		vmStateTester.initialize();
+		vmMonitor.setVMStateTester(vmStateTester);
+		
+
+		System.out.println("RUN");
+		// start the debug session
+		start(dsm, mainArgs, classpath);
+		System.out.println("EXIT");
+	}
+	
+	public void testStepping2()
+	{
+		// perform a step_into when the current statement cannot be stepped into
+		String projectName = "localvar";
+		String strategoFilename = "localvar.str";
+		DebugSessionSettings debugSessionSettings = new DebugSessionSettings(StrategoFileManager.WORKING_DIR, projectName);
+		
+		//String binBase = DebugCompilerTest.WORKING_DIR + "/" + projectName + "/class";
+		//String strategoBase = DebugCompilerTest.WORKING_DIR + "/" + projectName + "/stratego";
+		
+		String input = StrategoFileManager.BASE + "/src/stratego/localvar/run.input";
+		String argsForMainClass = "-i " + input;
+		String mainClass = "localvar.localvar";
+		String mainArgs = mainClass + " " + argsForMainClass;
+		String cp = /*strategoxtjar + ":" + libstrategodebuglib + ":" + strjdebugruntime + ":" + */ debugSessionSettings.getClassDirectory(); // was binBase
+		String classpath = cp;
+		
+		VMMonitorTestImpl2 vmMonitor = new VMMonitorTestImpl2();
+		DebugSessionManager dsm = new DebugSessionManager(debugSessionSettings, vmMonitor);
+		vmMonitor.setDSM(dsm);
+		
+		//String location = debugSessionSettings.getStrategoDirectory() + "/" + projectName + ".table";
+		//EventTable eventTable = EventTable.readEventTable(location);
+		EventTable eventTable = dsm.getEventSpecManager().getEventTable();
+		Assert.assertEquals(51, eventTable.size());
+
+		// which breakpoints will be hit?
+		VMStateTester vmStateTester = new VMStateTester(VMStateTesterCompareType.TopStackFrame);
+		
+		// 55, 6
+		// functions* := <filter(?Function(_,_))> definition*
+		// in rule "find-functions"
+		int lineNumber = 55;
+		int startTokenPosition = 6;
+		String eventType = "s-step";
+		this.addBP(dsm, strategoFilename, lineNumber, startTokenPosition, eventType);
+		
+		vmStateTester.addStrategoState(VMStateTester.createState("localvar.str", "find-functions", "s-step", 55, 4, 55, 54)); // find-functions[localvar.str]@(55,4,55,54)
+
+		vmMonitor.addAction(VMMonitorTestImpl2.STEP_INTO);
+		// perform a STEP_INTO, but current statement cannot be stepped into
+		
+		
+		vmStateTester.initialize();
+		vmMonitor.setVMStateTester(vmStateTester);
+		
+
+		System.out.println("RUN");
+		// start the debug session
+		start(dsm, mainArgs, classpath);
+		System.out.println("EXIT");
+	}
+}

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestStepping.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestStepping.java	Tue Dec  7 13:46:27 2010	(r21459)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestStepping.java	Tue Dec  7 15:36:46 2010	(r21460)
@@ -3,10 +3,6 @@
 import junit.framework.Assert;
 
 import org.StrategoFileManager;
-import org.spoofax.interpreter.terms.IStrategoTerm;
-import org.strategoxt.debug.core.model.LocationInfo;
-import org.strategoxt.debug.core.model.StrategoStackFrame;
-import org.strategoxt.debug.core.model.StrategoState;
 import org.strategoxt.debug.core.util.DebugSessionSettings;
 import org.strategoxt.debug.core.util.table.EventTable;
 
@@ -14,10 +10,12 @@
 
 	public static void main(String[] args) {
 		DSMTestStepping dsm = new DSMTestStepping();
-		dsm.testStepping();
+		dsm.testStepping1();
+		dsm.testStepping2();
+		dsm.testStepping3();
 	}
 	
-	public void testStepping()
+	public void testStepping1()
 	{
 		String projectName = "localvar";
 		String strategoFilename = "localvar.str";
@@ -52,7 +50,7 @@
 		int startTokenPosition = 8;
 		String eventType = "s-step";
 		this.addBP(dsm, strategoFilename, lineNumber, startTokenPosition, eventType);
-		vmStateTester.addStrategoState(createState("localvar.str", "match-comments", 47, 4, 47, 39)); // match-comments[localvar.str]@(47,4)47 39
+		vmStateTester.addStrategoState(VMStateTester.createState("localvar.str", "match-comments", eventType, 47, 4, 47, 39)); // match-comments[localvar.str]@(47,4)47 39
 
 		vmMonitor.addAction(VMMonitorTestImpl2.STEP_OVER);
 		// perform a STEP_OVER, will hit
@@ -63,7 +61,7 @@
 		startTokenPosition = 8;
 		eventType = "s-step";
 		//this.addBP(dsm, strategoFilename, lineNumber, startTokenPosition, eventType);
-		vmStateTester.addStrategoState(createState("localvar.str", "match-comments", 48, 6, 48, 40)); // match-comments[localvar.str]@(48,6) 48,40
+		vmStateTester.addStrategoState(VMStateTester.createState("localvar.str", "match-comments", eventType, 48, 6, 48, 40)); // match-comments[localvar.str]@(48,6) 48,40
 		
 		vmMonitor.addAction(VMMonitorTestImpl2.STEP_OVER);
 		// perform a STEP_OVER, will hit
@@ -74,7 +72,7 @@
 		startTokenPosition = 8;
 		eventType = "s-step";
 		//this.addBP(dsm, strategoFilename, lineNumber, startTokenPosition, eventType);
-		vmStateTester.addStrategoState(createState("localvar.str", "match-comments", 49, 6, 49, 37)); // match-comments[localvar.str]@(49,6) 49 37
+		vmStateTester.addStrategoState(VMStateTester.createState("localvar.str", "match-comments", eventType, 49, 6, 49, 37)); // match-comments[localvar.str]@(49,6) 49 37
 	
 		
 
@@ -85,30 +83,159 @@
 		System.out.println("RUN");
 		// start the debug session
 		start(dsm, mainArgs, classpath);
+		System.out.println("EXIT");
 	}
 	
-	/**
-	 * Filename points to the stratego file name.
-	 * Name points to the strategy or rule name.
-	 * The four integers, startLineNum, startTokenPos, endLineNum, endTokenPos are used to create a LocationInfo object that points
-	 * to the current active statement.
-	 * @param filename
-	 * @param name
-	 * @param startLineNum
-	 * @param startTokenPos
-	 * @param endLineNum
-	 * @param endTokenPos
-	 * @return
-	 */
-	private StrategoState createState(String filename, String name, int startLineNum, int startTokenPos, int endLineNum,
-			int endTokenPos)
+	public void testStepping2()
 	{
-		StrategoState state = new StrategoState();
-		LocationInfo currentLocationInfo = new LocationInfo(startLineNum, startTokenPos, endLineNum, endTokenPos);
-		IStrategoTerm current = null;
-		StrategoStackFrame frame = new StrategoStackFrame(filename, name, null, current);
-		frame.setCurrentLocationInfo(currentLocationInfo);
-		state.pushFrame(frame);
-		return state;
+		// step over at the last statement in a rule or strategy
+		String projectName = "localvar";
+		String strategoFilename = "localvar.str";
+		DebugSessionSettings debugSessionSettings = new DebugSessionSettings(StrategoFileManager.WORKING_DIR, projectName);
+		
+		//String binBase = DebugCompilerTest.WORKING_DIR + "/" + projectName + "/class";
+		//String strategoBase = DebugCompilerTest.WORKING_DIR + "/" + projectName + "/stratego";
+		
+		String input = StrategoFileManager.BASE + "/src/stratego/localvar/run.input";
+		String argsForMainClass = "-i " + input;
+		String mainClass = "localvar.localvar";
+		String mainArgs = mainClass + " " + argsForMainClass;
+		String cp = /*strategoxtjar + ":" + libstrategodebuglib + ":" + strjdebugruntime + ":" + */ debugSessionSettings.getClassDirectory(); // was binBase
+		String classpath = cp;
+		
+		VMMonitorTestImpl2 vmMonitor = new VMMonitorTestImpl2();
+		DebugSessionManager dsm = new DebugSessionManager(debugSessionSettings, vmMonitor);
+		vmMonitor.setDSM(dsm);
+		
+		//String location = debugSessionSettings.getStrategoDirectory() + "/" + projectName + ".table";
+		//EventTable eventTable = EventTable.readEventTable(location);
+		EventTable eventTable = dsm.getEventSpecManager().getEventTable();
+		Assert.assertEquals(51, eventTable.size());
+
+		// which breakpoints will be hit?
+		VMStateTester vmStateTester = new VMStateTester(VMStateTesterCompareType.TopStackFrame);
+		
+		// 47, 8
+		// f* := <find-functions> definitions* // find functions
+		// in rule "match-comments"
+		int lineNumber = 47;
+		int startTokenPosition = 8;
+		String eventType = "s-step";
+		this.addBP(dsm, strategoFilename, lineNumber, startTokenPosition, eventType);
+		vmStateTester.addStrategoState(VMStateTester.createState("localvar.str", "match-comments", eventType, 47, 4, 47, 39)); // match-comments[localvar.str]@(47,4)47 39
+
+		vmMonitor.addAction(VMMonitorTestImpl2.STEP_OVER);
+		// perform a STEP_OVER, will hit
+		// 48, 8
+		// c* := <find-comments> definitions* // find comments
+		// in rule "match-comments"
+		lineNumber = 48;
+		startTokenPosition = 8;
+		eventType = "s-step";
+		//this.addBP(dsm, strategoFilename, lineNumber, startTokenPosition, eventType);
+		vmStateTester.addStrategoState(VMStateTester.createState("localvar.str", "match-comments", eventType, 48, 6, 48, 40)); // match-comments[localvar.str]@(48,6) 48,40
+		
+		vmMonitor.addAction(VMMonitorTestImpl2.STEP_OVER);
+		// perform a STEP_OVER, will hit
+		// 49, 8
+		// out := <match-f-and-c> (f*, c*)
+		// in rule "match-comments"
+		lineNumber = 49;
+		startTokenPosition = 8;
+		eventType = "s-step";
+		//this.addBP(dsm, strategoFilename, lineNumber, startTokenPosition, eventType);
+		vmStateTester.addStrategoState(VMStateTester.createState("localvar.str", "match-comments", eventType, 49, 6, 49, 37)); // match-comments[localvar.str]@(49,6) 49 37
+	
+		vmMonitor.addAction(VMMonitorTestImpl2.STEP_OVER);
+		// perform a STEP_OVER, no s-steps left, stop at s-exit
+		//match-comments[localvar.str]@(43,2) 49 37
+		vmStateTester.addStrategoState(VMStateTester.createState("localvar.str", "match-comments", eventType, 43, 2, 49, 37)); // match-comments[localvar.str]@(49,6) 49 37
+		
+		vmMonitor.addAction(VMMonitorTestImpl2.STEP_OVER);
+		// hit s-exit of match-comments, perform a STEP_OVER
+		// should suspend at execute, execute is the caller of match-comments, will suspend at the s-exit of execute
+		vmStateTester.addStrategoState(VMStateTester.createState("localvar.str", "execute", eventType, 37, 3, 40, 38)); // match-comments[localvar.str]@(49,6) 49 37
+		
+		vmStateTester.initialize();
+		vmMonitor.setVMStateTester(vmStateTester);
+		
+
+		System.out.println("RUN");
+		// start the debug session
+		start(dsm, mainArgs, classpath);
+		System.out.println("EXIT");
+	}
+	
+	public void testStepping3()
+	{
+		// step over a statement in a rule, but hit a breakpoint while stepping
+		// step should be cancelled
+		
+		String projectName = "localvar";
+		String strategoFilename = "localvar.str";
+		DebugSessionSettings debugSessionSettings = new DebugSessionSettings(StrategoFileManager.WORKING_DIR, projectName);
+		
+		//String binBase = DebugCompilerTest.WORKING_DIR + "/" + projectName + "/class";
+		//String strategoBase = DebugCompilerTest.WORKING_DIR + "/" + projectName + "/stratego";
+		
+		String input = StrategoFileManager.BASE + "/src/stratego/localvar/run.input";
+		String argsForMainClass = "-i " + input;
+		String mainClass = "localvar.localvar";
+		String mainArgs = mainClass + " " + argsForMainClass;
+		String cp = /*strategoxtjar + ":" + libstrategodebuglib + ":" + strjdebugruntime + ":" + */ debugSessionSettings.getClassDirectory(); // was binBase
+		String classpath = cp;
+		
+		VMMonitorTestImpl2 vmMonitor = new VMMonitorTestImpl2();
+		DebugSessionManager dsm = new DebugSessionManager(debugSessionSettings, vmMonitor);
+		vmMonitor.setDSM(dsm);
+		
+		//String location = debugSessionSettings.getStrategoDirectory() + "/" + projectName + ".table";
+		//EventTable eventTable = EventTable.readEventTable(location);
+		EventTable eventTable = dsm.getEventSpecManager().getEventTable();
+		Assert.assertEquals(51, eventTable.size());
+
+		// which breakpoints will be hit?
+		VMStateTester vmStateTester = new VMStateTester(VMStateTesterCompareType.TopStackFrame);
+		
+		// 47, 8
+		// f* := <find-functions> definitions* // find functions
+		// in rule "match-comments"
+		int lineNumber = 47;
+		int startTokenPosition = 8;
+		String eventType = "s-step";
+		this.addBP(dsm, strategoFilename, lineNumber, startTokenPosition, eventType);
+		
+		
+		// add a breakpoint in strategy that we are going to step over, the step should be cancelled
+		lineNumber = 55;
+		startTokenPosition = 6;
+		// 			functions* := <filter(?Function(_,_))> definition*
+		// in "find-functions"
+		eventType = "s-step";
+		this.addBP(dsm, strategoFilename, lineNumber, startTokenPosition, eventType);
+		
+		
+		vmStateTester.addStrategoState(VMStateTester.createState("localvar.str", "match-comments", "s-step", 47, 4, 47, 39)); // match-comments[localvar.str]@(47,4)47 39
+		
+		vmMonitor.addAction(VMMonitorTestImpl2.STEP_OVER);
+		// perform a STEP_OVER, should hit
+		// 48, 8
+		// c* := <find-comments> definitions* // find comments
+		// in rule "match-comments"
+		// but we placed a breakpoint in find-functions. VM will suspend in 
+		vmStateTester.addStrategoState(VMStateTester.createState("localvar.str", "find-functions", "s-step", 55, 4, 55, 54)); // match-comments[localvar.str]@(48,6) 48,40
+		
+
+
+		vmStateTester.initialize();
+		vmMonitor.setVMStateTester(vmStateTester);
+		
+
+		System.out.println("RUN");
+		// start the debug session
+		start(dsm, mainArgs, classpath);
+		System.out.println("EXIT");
 	}
+	
+
 }

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/VMMonitorTestImpl2.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/VMMonitorTestImpl2.java	Tue Dec  7 13:46:27 2010	(r21459)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/VMMonitorTestImpl2.java	Tue Dec  7 15:36:46 2010	(r21460)
@@ -51,6 +51,11 @@
 				System.out.println("variable entry " + entry.getKey() + " # " + entry.getValue());
 			}
 		}
+		else
+		{
+			String message = "State changed but we did not except anymore state changes...";
+			Assert.fail(message);
+		}
 		
 		nextAction();
 	}
@@ -59,7 +64,7 @@
 		System.out.println("vmEvent: " + event);
 		if ("VMDEATH".equals(event))
 		{
-			// vm terminated
+			// vm terminated, TODO: last state should be a StrategoExitedState
 			if (this.vmStateTester.hasNext())
 			{
 				Assert.fail("VM has terminated but there are still some expected hits left...");

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/VMStateTester.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/VMStateTester.java	Tue Dec  7 13:46:27 2010	(r21459)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/VMStateTester.java	Tue Dec  7 15:36:46 2010	(r21460)
@@ -4,6 +4,8 @@
 import java.util.Iterator;
 import java.util.List;
 
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.strategoxt.debug.core.model.LocationInfo;
 import org.strategoxt.debug.core.model.StrategoStackFrame;
 import org.strategoxt.debug.core.model.StrategoState;
 
@@ -118,4 +120,29 @@
 	{
 		this.willHitStates.add(state);
 	}
+	
+	/**
+	 * Filename points to the stratego file name.
+	 * Name points to the strategy or rule name.
+	 * The four integers, startLineNum, startTokenPos, endLineNum, endTokenPos are used to create a LocationInfo object that points
+	 * to the current active statement.
+	 * @param filename
+	 * @param name
+	 * @param startLineNum
+	 * @param startTokenPos
+	 * @param endLineNum
+	 * @param endTokenPos
+	 * @return
+	 */
+	public static StrategoState createState(String filename, String name, String eventType, int startLineNum, int startTokenPos, int endLineNum,
+			int endTokenPos)
+	{
+		StrategoState state = new StrategoState();
+		LocationInfo currentLocationInfo = new LocationInfo(startLineNum, startTokenPos, endLineNum, endTokenPos);
+		IStrategoTerm current = null;
+		StrategoStackFrame frame = new StrategoStackFrame(filename, name, null, current);
+		frame.setCurrentLocationInfo(currentLocationInfo, eventType);
+		state.pushFrame(frame);
+		return state;
+	}
 }

From r.t.lindeman at student.tudelft.nl  Tue Dec  7 17:34:03 2010
From: r.t.lindeman at student.tudelft.nl (Ricky Lindeman)
Date: Tue, 07 Dec 2010 16:34:03 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21461 - in
	spoofax-imp/trunk:
	org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control
	org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/...
Message-ID: <201012071634.oB7GY3IO004278@proliant.st.ewi.tudelft.nl>

Author: RickyLindeman
Date: Tue Dec  7 16:34:02 2010
New Revision: 21461
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21461&sc=1

Log:
* implemented STEP_RETURN
 * Added more testcases for stepping
 * TODO: implement eclipse stepping interfaces

Added:
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestStepReturn.java
Modified:
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/DebugSessionManager.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/EventHandler.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/EventSpecManager.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/model/StrategoState.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestStepping.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/DebugSessionManager.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/DebugSessionManager.java	Tue Dec  7 15:36:46 2010	(r21460)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/DebugSessionManager.java	Tue Dec  7 16:34:02 2010	(r21461)
@@ -220,7 +220,11 @@
 	
 	public void stepReturn()
 	{
-		
+		// continue until the current stackframe fires an s-exit or r-exit event.
+		// we should stop at the next s-step in the parent stackframe.
+		ThreadEventHandler handler = this.eventThread.getMainThreadHandler();
+		this.eventSpecManager.setStepReturn(handler.getStrategoState());
+		this.resumeVM();
 	}
 	
 	/**

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/EventHandler.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/EventHandler.java	Tue Dec  7 15:36:46 2010	(r21460)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/EventHandler.java	Tue Dec  7 16:34:02 2010	(r21461)
@@ -430,7 +430,7 @@
 		if (isBreakPointHit){
 			// we hit a break point
 			// if stepping is active it should be cancelled
-			if (eventSpecManager.isStepOverActive())
+			if (eventSpecManager.isStepOverActive() || eventSpecManager.isStepIntoActive() || eventSpecManager.isStepReturnActive())
 			{
 				eventSpecManager.resetStep();
 			}
@@ -439,7 +439,7 @@
 		else if (eventSpecManager.isStepOverActive())
 		{
 			// if level is the same
-			if (eventSpecManager.getStepFrameLevel() == currentState.getStackFrames().length - 1)
+			if (eventSpecManager.getStepFrameLevel() == currentState.getCurrentFrameLevel())
 			{
 				// rule/strategy location are the same
 				boolean sameLocation = eventSpecManager.getStepFrame().getLocationInfo().equals(currentState.currentFrame().getLocationInfo());
@@ -474,7 +474,7 @@
 			// level of the current stackframe should equal (stepFrameLevel+1)
 			// an we should have stopped at a s-enter/r-enter
 			int stepIntoFrameLevel = eventSpecManager.getStepFrameLevel() + 1;
-			if (stepIntoFrameLevel == currentState.getStackFrames().length - 1 && 
+			if (stepIntoFrameLevel == currentState.getCurrentFrameLevel() && 
 					(this.getEventType().equals(EventHandler.S_ENTER)
 					|| this.getEventType().equals(EventHandler.R_ENTER))
 					)
@@ -487,6 +487,18 @@
 			}
 			eventSpecManager.resetStep(); // reset step
 		}
+		else if (eventSpecManager.isStepReturnActive())
+		{
+			// suspend if we get an event of the parent StackFrame of getStepFrame
+			// stepIntoFrameLevel - 1 = getCurrentFrameLevel()
+			int parentFrameLevel = eventSpecManager.getStepFrameLevel() - 1;
+			if (parentFrameLevel == currentState.getCurrentFrameLevel())
+			{
+				// it does not matter what the eventType is of the fired debug event
+				shouldSuspend = true;
+				eventSpecManager.resetStep(); // reset step
+			}
+		}
 		
         return shouldSuspend; // if break point exists suspend thread
 	}

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/EventSpecManager.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/EventSpecManager.java	Tue Dec  7 15:36:46 2010	(r21460)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/EventSpecManager.java	Tue Dec  7 16:34:02 2010	(r21461)
@@ -147,7 +147,7 @@
 		{
 			// we can only step into a strategy or rule
 			stepFrame = state.currentFrame();
-			stepFrameLevel = state.getStackFrames().length - 1;
+			stepFrameLevel = state.getCurrentFrameLevel();
 			isStepIntoActive = true;
 		}
 		else
@@ -158,8 +158,13 @@
 	
 	public void setStepReturn(StrategoState state)
 	{
+		if (state.getCurrentFrameLevel() == 0)
+		{
+			// we are at the main strategy, cannot step return
+			return;
+		}
 		stepFrame = state.currentFrame();
-		stepFrameLevel = state.getStackFrames().length - 1;
+		stepFrameLevel = state.getCurrentFrameLevel();
 		isStepReturnActive = true;
 	}
 

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/model/StrategoState.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/model/StrategoState.java	Tue Dec  7 15:36:46 2010	(r21460)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/model/StrategoState.java	Tue Dec  7 16:34:02 2010	(r21461)
@@ -71,6 +71,11 @@
 		return l;
 	}
 	
+	public int getCurrentFrameLevel()
+	{
+		return this.stack.size() - 1;
+	}
+	
 	public StrategoStackFrame[] getStackFrames()
 	{
 		StrategoStackFrame[] a = new StrategoStackFrame[this.stack.size()];

Added: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestStepReturn.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestStepReturn.java	Tue Dec  7 16:34:02 2010	(r21461)
@@ -0,0 +1,145 @@
+package org.strategoxt.debug.core.control;
+
+import junit.framework.Assert;
+
+import org.StrategoFileManager;
+import org.strategoxt.debug.core.util.DebugSessionSettings;
+import org.strategoxt.debug.core.util.table.EventTable;
+
+public class DSMTestStepReturn extends AbstractDSMTest {
+
+	public static void main(String[] args) {
+		DSMTestStepReturn dsm = new DSMTestStepReturn();
+		//dsm.testStepping1();
+		dsm.testStepping2();
+		//dsm.testStepping3();
+	}
+	
+	public void testStepping1()
+	{
+		String projectName = "localvar";
+		String strategoFilename = "localvar.str";
+		DebugSessionSettings debugSessionSettings = new DebugSessionSettings(StrategoFileManager.WORKING_DIR, projectName);
+		
+		//String binBase = DebugCompilerTest.WORKING_DIR + "/" + projectName + "/class";
+		//String strategoBase = DebugCompilerTest.WORKING_DIR + "/" + projectName + "/stratego";
+		
+		String input = StrategoFileManager.BASE + "/src/stratego/localvar/run.input";
+		String argsForMainClass = "-i " + input;
+		String mainClass = "localvar.localvar";
+		String mainArgs = mainClass + " " + argsForMainClass;
+		String cp = /*strategoxtjar + ":" + libstrategodebuglib + ":" + strjdebugruntime + ":" + */ debugSessionSettings.getClassDirectory(); // was binBase
+		String classpath = cp;
+		
+		VMMonitorTestImpl2 vmMonitor = new VMMonitorTestImpl2();
+		DebugSessionManager dsm = new DebugSessionManager(debugSessionSettings, vmMonitor);
+		vmMonitor.setDSM(dsm);
+		
+		//String location = debugSessionSettings.getStrategoDirectory() + "/" + projectName + ".table";
+		//EventTable eventTable = EventTable.readEventTable(location);
+		EventTable eventTable = dsm.getEventSpecManager().getEventTable();
+		Assert.assertEquals(51, eventTable.size());
+
+		// which breakpoints will be hit?
+		VMStateTester vmStateTester = new VMStateTester(VMStateTesterCompareType.TopStackFrame);
+		
+		
+		// 47, 8
+		// f* := <find-functions> definitions* // find functions
+		// in rule "match-comments"
+		int lineNumber = 47;
+		int startTokenPosition = 8;
+		String eventType = "s-step";
+		this.addBP(dsm, strategoFilename, lineNumber, startTokenPosition, eventType);
+		vmStateTester.addStrategoState(VMStateTester.createState("localvar.str", "match-comments", "s-step", 47, 4, 47, 39)); // match-comments[localvar.str]@(47,4)47 39
+
+		vmMonitor.addAction(VMMonitorTestImpl2.STEP_RETURN);
+		// perform a STEP_RETURN, will hit s-exit of execute
+		// 37, 3
+		//  execute:
+		//	  	input -> output
+		//	  	with
+		//	  	  output := <match-comments> input
+		vmStateTester.addStrategoState(VMStateTester.createState("localvar.str", "execute", "s-var", 40, 6, 40, 38));
+		
+		
+		
+		
+		vmStateTester.initialize();
+		vmMonitor.setVMStateTester(vmStateTester);
+		
+
+		System.out.println("RUN");
+		// start the debug session
+		start(dsm, mainArgs, classpath);
+		System.out.println("EXIT");
+	}
+	
+	
+	public void testStepping2()
+	{
+		// suspend at breakpoint, do a STEP_RETURN but hit another breakpoint before the active strategy could exit
+		// the step should be cancelled
+		String projectName = "localvar";
+		String strategoFilename = "localvar.str";
+		DebugSessionSettings debugSessionSettings = new DebugSessionSettings(StrategoFileManager.WORKING_DIR, projectName);
+		
+		//String binBase = DebugCompilerTest.WORKING_DIR + "/" + projectName + "/class";
+		//String strategoBase = DebugCompilerTest.WORKING_DIR + "/" + projectName + "/stratego";
+		
+		String input = StrategoFileManager.BASE + "/src/stratego/localvar/run.input";
+		String argsForMainClass = "-i " + input;
+		String mainClass = "localvar.localvar";
+		String mainArgs = mainClass + " " + argsForMainClass;
+		String cp = /*strategoxtjar + ":" + libstrategodebuglib + ":" + strjdebugruntime + ":" + */ debugSessionSettings.getClassDirectory(); // was binBase
+		String classpath = cp;
+		
+		VMMonitorTestImpl2 vmMonitor = new VMMonitorTestImpl2();
+		DebugSessionManager dsm = new DebugSessionManager(debugSessionSettings, vmMonitor);
+		vmMonitor.setDSM(dsm);
+		
+		//String location = debugSessionSettings.getStrategoDirectory() + "/" + projectName + ".table";
+		//EventTable eventTable = EventTable.readEventTable(location);
+		EventTable eventTable = dsm.getEventSpecManager().getEventTable();
+		Assert.assertEquals(51, eventTable.size());
+
+		// which breakpoints will be hit?
+		VMStateTester vmStateTester = new VMStateTester(VMStateTesterCompareType.TopStackFrame);
+		
+		// 47, 8
+		// f* := <find-functions> definitions* // find functions
+		// in rule "match-comments"
+		int lineNumber = 47;
+		int startTokenPosition = 8;
+		String eventType = "s-step";
+		this.addBP(dsm, strategoFilename, lineNumber, startTokenPosition, eventType);
+		vmStateTester.addStrategoState(VMStateTester.createState("localvar.str", "match-comments", "s-step", 47, 4, 47, 39)); // match-comments[localvar.str]@(47,4)47 39
+
+
+		// 48, 8
+		// c* := <find-comments> definitions* // find comments
+		// in rule "match-comments"
+		lineNumber = 48;
+		startTokenPosition = 8;
+		eventType = "s-step";
+		this.addBP(dsm, strategoFilename, lineNumber, startTokenPosition, eventType);
+
+		vmMonitor.addAction(VMMonitorTestImpl2.STEP_RETURN);
+		// perform a STEP_RETURN, will hit breakpoint on line 48
+		vmStateTester.addStrategoState(VMStateTester.createState("localvar.str", "match-comments", eventType, 48, 6, 48, 40)); // match-comments[localvar.str]@(48,6) 48,40
+
+
+		
+		
+		
+		
+		vmStateTester.initialize();
+		vmMonitor.setVMStateTester(vmStateTester);
+		
+
+		System.out.println("RUN");
+		// start the debug session
+		start(dsm, mainArgs, classpath);
+		System.out.println("EXIT");
+	}
+}

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestStepping.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestStepping.java	Tue Dec  7 15:36:46 2010	(r21460)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestStepping.java	Tue Dec  7 16:34:02 2010	(r21461)
@@ -222,7 +222,7 @@
 		// 48, 8
 		// c* := <find-comments> definitions* // find comments
 		// in rule "match-comments"
-		// but we placed a breakpoint in find-functions. VM will suspend in 
+		// but we placed a breakpoint in find-functions. VM will suspend at 55,4
 		vmStateTester.addStrategoState(VMStateTester.createState("localvar.str", "find-functions", "s-step", 55, 4, 55, 54)); // match-comments[localvar.str]@(48,6) 48,40
 		
 

From karltk at strategoxt.org  Tue Dec  7 17:47:33 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Tue, 07 Dec 2010 16:47:33 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21462 - in
	strategoxt-javascript-backend/trunk: src/javascript
	src/stratego tests/basic
Message-ID: <201012071647.oB7GlXR5004501@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Tue Dec  7 16:47:33 2010
New Revision: 21462
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21462&sc=1

Log:
* Fixed bugs in annotation pattern matching by simplifying implementation a lot.
 * Improved term construction compiler with check around building (potentially) unbound variables. 
 * Disabled test cases for override and internal, since we don't support these on JS (yet).

Modified:
   strategoxt-javascript-backend/trunk/src/javascript/terms.js
   strategoxt-javascript-backend/trunk/src/stratego/s2js.str
   strategoxt-javascript-backend/trunk/src/stratego/term-construction.str
   strategoxt-javascript-backend/trunk/src/stratego/term-deconstruction.str
   strategoxt-javascript-backend/trunk/tests/basic/internal_1.str
   strategoxt-javascript-backend/trunk/tests/basic/override_1.str

Modified: strategoxt-javascript-backend/trunk/src/javascript/terms.js
==============================================================================
--- strategoxt-javascript-backend/trunk/src/javascript/terms.js	Tue Dec  7 16:34:02 2010	(r21461)
+++ strategoxt-javascript-backend/trunk/src/javascript/terms.js	Tue Dec  7 16:47:33 2010	(r21462)
@@ -32,6 +32,10 @@
 
 	function doEquals(lhs, rhs) {
 		if(lhs === undefined || rhs === undefined) throw "equals on undefined";
+		if(lhs === null || rhs === null) {
+			print(lhs ? factory.prettify(lhs) : "null");
+			print(rhs ? factory.prettify(rhs) : "null");
+		}
 		var lt = termType(lhs);
 		var rt = termType(rhs);
 		if(lt !== rt)
@@ -48,11 +52,13 @@
 	function doAnnoEquals(lhs, rhs) {
 		var lhsAnno  = factory.getAnnotations(lhs);
 		var rhsAnno = factory.getAnnotations(rhs);
-		return lhs.equals(rhs) && lhsAnno.equals(rhsAnno);
+		var lhsNoAnno = factory.stripAnnotations(lhs);
+		var rhsNoAnno = factory.stripAnnotations(rhs);
+		return doEquals(lhsNoAnno, rhsNoAnno) && lhsAnno.equals(rhsAnno);
 	}
 	
 	function doPrettify(term, builder) {
-		if(term == undefined)
+		if(term === undefined)
 			throw "doPrettify on undefined (" + term + ")";
 		if(term.annoType) {
 			// FIXME(karltk) how to print annotated list conses?
@@ -505,7 +511,10 @@
 					head : hd,
 					tail : tl,
 					equals : function(other) {
-						return other.termType == LIST && doEquals(hd, other.head) && tl.equals(other.tail);
+						return other.termType == LIST 
+							&& r.subtermCount == other.subtermCount 
+							&& doEquals(hd, other.head)
+							&& doEquals(tl, other.tail);
 					}
 
 				};
@@ -534,13 +543,6 @@
 			},
 
 			makeAppl : function(ctor, args) {
-				if(ctor.arity != args.length) {
-					print("blowup");
-					print(ctor.name+"/"+ctor.arity)
-					for(var x = 0; x < args.length; x++) {
-						print(factory.prettify(args[x]));
-					}
-				}
 				StrategoJS.assert("ctor arity (" + ctor.arity + ") != argument count (" + args.length + ")", ctor.arity == args.length);
 				var r = {
 					name : ctor.name, 
@@ -590,6 +592,10 @@
 				return r;
 			},
 
+			getSubtermCount : function(term) {
+				return term.subtermCount;
+			},
+
 			head : function(listTerm) {
 				StrategoJS.assert(listTerm.termType == LIST);
 				return listTerm.head;
@@ -600,10 +606,6 @@
 				return list.tail;
 			},
 
-			getSubtermCount : function(term) {
-				return term.subtermCount;
-			},
-
 			getConstructor : function(term) {
 				switch(termType(term)) {
 				case factory.INT:
@@ -657,11 +659,11 @@
 					return wrapInAnnotation(term, annos);
 			},
 			
-			stripAnnotations : function(term) {
-				if(term.annoType)
-					return term.term;
-				return term;
-			}
+			stripAnnotations : function(term) { return term.annoType ? term.term : term; },
+			
+			intValue     : function(term) { return term.annoType ? term.term : term; },
+			realValue    : function(term) { return term.annoType ? term.term : term; },
+			stringValue  : function(term) { return term.annoType ? term.term : term; }
 	};
 	return factory;
 }();

Modified: strategoxt-javascript-backend/trunk/src/stratego/s2js.str
==============================================================================
--- strategoxt-javascript-backend/trunk/src/stratego/s2js.str	Tue Dec  7 16:34:02 2010	(r21461)
+++ strategoxt-javascript-backend/trunk/src/stratego/s2js.str	Tue Dec  7 16:47:33 2010	(r21462)
@@ -298,7 +298,7 @@
   	end
   	
   translate-Build(|s,f) :
-  	Build(t) -> 
+  	Build(t) -> <js-check-unbound-args(|t, f)>
   	$[
   		[dec*]
   		[stm*]
@@ -318,7 +318,7 @@
   	]
   	
   translate-PrimT(|s,feil) :
-    PrimT(f, s*, t*) ->
+    PrimT(f, s*, t*) -> <js-check-unbound-args(|t*, feil)>
     $[ 
       ctx.push("[f]");
       term = StrategoJS.SSL.[f](ctx, term [args]);
@@ -331,10 +331,10 @@
       }
       ctx.popOnSuccess();
     ]
-    with
-        s'*  := <map(lift-strategy-to-function)> s*
-      ; t'*  := <map(js-construct-term(|feil))> t*
-      ; args := <js-join-args> (s'*, t'*)
+  with
+      s'*  := <map(lift-strategy-to-function)> s*
+    ; t'*  := <map(js-construct-term(|feil))> t*
+    ; args := <js-join-args> (s'*, t'*)
         
 
   

Modified: strategoxt-javascript-backend/trunk/src/stratego/term-construction.str
==============================================================================
--- strategoxt-javascript-backend/trunk/src/stratego/term-construction.str	Tue Dec  7 16:34:02 2010	(r21461)
+++ strategoxt-javascript-backend/trunk/src/stratego/term-construction.str	Tue Dec  7 16:47:33 2010	(r21462)
@@ -122,3 +122,17 @@
     )
     
   js-ConstructorName-expr = js-ConstructorName
+
+  js-check-unbound-args(|t, f) = try(js-CheckUnboundArgs(|t,f))
+
+  js-CheckUnboundArgs(|t, feil) :
+  	stm -> $[
+      if ([e])
+        break [feil];
+      [stm]
+    ]
+  where
+      <collect({?Var(_){t*}; where(<not(["bound"])> t* )})> t
+    ; not([])
+    ; e := <foldr1(!$[[<Hd; js-ConstructVar>] == null]
+                  ,!$[[<Fst; js-ConstructVar>] == null || [<Snd>] ])>
\ No newline at end of file

Modified: strategoxt-javascript-backend/trunk/src/stratego/term-deconstruction.str
==============================================================================
--- strategoxt-javascript-backend/trunk/src/stratego/term-deconstruction.str	Tue Dec  7 16:34:02 2010	(r21461)
+++ strategoxt-javascript-backend/trunk/src/stratego/term-deconstruction.str	Tue Dec  7 16:47:33 2010	(r21462)
@@ -103,7 +103,7 @@
   translate-Match(|s,feil) :
     Match(Str(str), e') -> 
     $[
-      if (factory.termType([e]) !== factory.STRING || !factory.match("[e_str]", [e])) {
+      if (factory.termType([e]) !== factory.STRING || "[e_str]" !== factory.stringValue([e])) {
       	print("[feil]");
         break [feil];
       }
@@ -115,7 +115,7 @@
   translate-Match(|s,feil) :
     Match(Int(i), e') -> 
     $[
-      if (factory.termType([e]) !== factory.INT || !factory.match([e_int], [e])) {
+      if (factory.termType([e]) !== factory.INT || [e_int] !== factory.intValue([e])) {
         print("[feil]");
         break [feil];
       }
@@ -127,7 +127,7 @@
   translate-Match(|s,feil) :
     Match(Real(r), e') -> 
     $[
-      if (factory.termType([e]) !== factory.REAL || !factory.match([e_real], [e])) {
+      if (factory.termType([e]) !== factory.REAL || [e_real] !== factory.realValue([e])) {
       	print("[feil]");
         break [feil];
       }

Modified: strategoxt-javascript-backend/trunk/tests/basic/internal_1.str
==============================================================================
--- strategoxt-javascript-backend/trunk/tests/basic/internal_1.str	Tue Dec  7 16:34:02 2010	(r21461)
+++ strategoxt-javascript-backend/trunk/tests/basic/internal_1.str	Tue Dec  7 16:47:33 2010	(r21462)
@@ -8,7 +8,7 @@
   main =
     <cify> "foo-bar" => "foo_bar"
   ; not(<cify> "foosbar" => "foobar")
-  ; <Cify(id)> ['s'] => []
+  ; <Cify2(id)> ['s'] => []
         
-  /* FIXME(karltk) internal */ Cify(s) :
+  /* FIXME(karltk) internal */ Cify2(s) :
     ['s' | tail] -> <s> tail

Modified: strategoxt-javascript-backend/trunk/tests/basic/override_1.str
==============================================================================
--- strategoxt-javascript-backend/trunk/tests/basic/override_1.str	Tue Dec  7 16:34:02 2010	(r21461)
+++ strategoxt-javascript-backend/trunk/tests/basic/override_1.str	Tue Dec  7 16:47:33 2010	(r21462)
@@ -6,7 +6,7 @@
 rules
 
   main =
-    not(<cify> "foo-bar" => "foo_bar")
+    /*FIXME(karltk) override */not(not(<cify> "foo-bar" => "foo_bar"))
   ; <cify> "foosbar" => "foobar"
     
   /* FIXME(karltk) override */ Cify(s) :

From karltk at strategoxt.org  Tue Dec  7 17:49:04 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Tue, 07 Dec 2010 16:49:04 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21463 -
	strategoxt-javascript-backend/trunk/tests/basic
Message-ID: <201012071649.oB7Gn4BG004510@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Tue Dec  7 16:49:04 2010
New Revision: 21463
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21463&sc=1

Log:
* Added additional tests for term matching with annotations.

Added:
   strategoxt-javascript-backend/trunk/tests/basic/annos_3.str
   strategoxt-javascript-backend/trunk/tests/basic/annos_4.str

Added: strategoxt-javascript-backend/trunk/tests/basic/annos_3.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ strategoxt-javascript-backend/trunk/tests/basic/annos_3.str	Tue Dec  7 16:49:04 2010	(r21463)
@@ -0,0 +1,58 @@
+module annos_3
+
+imports
+  emu-libstratego-lib
+
+strategies
+
+  main = 
+  	  noanno-vs-anno 
+  	; wrong-anno-vs-anno
+  	; same-anno-vs-anno
+  	; anno-vs-noanno
+  	  
+  	; var-noanno-vs-anno
+  	; var-wrong-anno-vs-anno
+  	; var-same-anno-vs-anno
+  	; var-anno-vs-noanno
+  	
+  noanno-vs-anno =
+  	  !"foo"{1}
+  	; ?"foo"
+  	  
+  wrong-anno-vs-anno = 
+  	  !"foo"{1}
+  	; not(?"foo"{})
+
+  same-anno-vs-anno = 
+  	  !"foo"{1}
+  	; ?"foo"{1}
+
+  anno-vs-noanno = 
+  	  !"foo"
+  	; not(?"foo"{1})
+
+
+  var-noanno-vs-anno = 
+      !"foo" 
+  	; ?a
+  	; !"foo"{1}
+  	; not(?a)
+
+  var-wrong-anno-vs-anno = 
+      !"foo"{2} 
+  	; ?a
+  	; !"foo"{1}
+  	; not(?a)    	
+  	    
+  var-same-anno-vs-anno = 
+      !"foo"{1} 
+  	; ?a
+  	; !"foo"{1}
+  	; ?a
+  	  
+  var-anno-vs-noanno =
+  	  !"foo"{1}
+  	; ?a
+  	; !"foo"
+  	; not(?a)
\ No newline at end of file

Added: strategoxt-javascript-backend/trunk/tests/basic/annos_4.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ strategoxt-javascript-backend/trunk/tests/basic/annos_4.str	Tue Dec  7 16:49:04 2010	(r21463)
@@ -0,0 +1,22 @@
+module annos_4
+
+imports
+  emu-libstratego-lib
+
+strategies
+
+
+  main = 
+  	  anno-vs-anno 
+	; var-anno-vs-anno
+  
+  anno-vs-anno = 
+  	  !Some([1,2{3}]{4}){5}
+  	; ?Some([1,2{3}]{4}){5}
+  
+  var-anno-vs-anno = 
+  	  !Some([1,2{3}]{4}){5} 
+  	; ?a 
+  	; !Some([1,2{3}]{4}){5} 
+  	; ?a
+ 
\ No newline at end of file

From karltk at strategoxt.org  Wed Dec  8 12:32:46 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Wed, 08 Dec 2010 11:32:46 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21464 -
	strategoxt-javascript-backend/trunk/src/javascript
Message-ID: <201012081132.oB8BWkbU019707@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Wed Dec  8 11:32:46 2010
New Revision: 21464
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21464&sc=1

Log:
* Added dummy program name to argument list; otherwise the traversal_1 test won't work.

Modified:
   strategoxt-javascript-backend/trunk/src/javascript/cli-wrapper.js

Modified: strategoxt-javascript-backend/trunk/src/javascript/cli-wrapper.js
==============================================================================
--- strategoxt-javascript-backend/trunk/src/javascript/cli-wrapper.js	Tue Dec  7 16:49:04 2010	(r21463)
+++ strategoxt-javascript-backend/trunk/src/javascript/cli-wrapper.js	Wed Dec  8 11:32:46 2010	(r21464)
@@ -1,5 +1,5 @@
 StrategoJS.registerLibrary(StrategoJS.SSL);
 StrategoJS.registerLibrary(StrategoJS.SRTS);
 StrategoJS.registerLibrary(StrategoJS.StrategoLib);
-debug().main(arguments);
+debug().main(["./program"].concat(arguments));
 

From karltk at strategoxt.org  Wed Dec  8 12:34:40 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Wed, 08 Dec 2010 11:34:40 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21465 -
	strategoxt-javascript-backend/trunk/src/javascript
Message-ID: <201012081134.oB8BYehE019738@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Wed Dec  8 11:34:40 2010
New Revision: 21465
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21465&sc=1

Log:
* Removed getTermType and just left termType behind in factory API.
 * Added term type tests to most SSL functions; still a few holes. 
 * Now all core and basic tests pass, with the exception of file parsing and override/internal

Modified:
   strategoxt-javascript-backend/trunk/src/javascript/srts.js
   strategoxt-javascript-backend/trunk/src/javascript/ssl.js
   strategoxt-javascript-backend/trunk/src/javascript/terms.js

Modified: strategoxt-javascript-backend/trunk/src/javascript/srts.js
==============================================================================
--- strategoxt-javascript-backend/trunk/src/javascript/srts.js	Wed Dec  8 11:32:46 2010	(r21464)
+++ strategoxt-javascript-backend/trunk/src/javascript/srts.js	Wed Dec  8 11:34:40 2010	(r21465)
@@ -50,9 +50,8 @@
 };
 
 StrategoJS.SRTS.SRTS_one = function(ctx, term, fun) {
-	print("SRTS_one");
+	print("SRTS_one : " + term ? ctx.factory.prettify(term) : "undefined term");
 	var factory = ctx.factory;
-	print(" : " + factory.prettify(term));
 	var termType = factory.termType(term)
 	switch(termType) {
 	case factory.REAL:

Modified: strategoxt-javascript-backend/trunk/src/javascript/ssl.js
==============================================================================
--- strategoxt-javascript-backend/trunk/src/javascript/ssl.js	Wed Dec  8 11:32:46 2010	(r21464)
+++ strategoxt-javascript-backend/trunk/src/javascript/ssl.js	Wed Dec  8 11:34:40 2010	(r21465)
@@ -74,9 +74,19 @@
 	}
 }
 
-
-
 StrategoJS.SSL.SSL_addi = function(ctx, currentTerm, lhs, rhs) {
+	print("SSL_addi");
+	var f = ctx.factory;
+	if(f.termType(lhs) !== f.INT || f.termType(rhs) !== f.INT)
+		return null;
+	return lhs + rhs;
+}
+
+StrategoJS.SSL.SSL_addr = function(ctx, currentTerm, lhs, rhs) {
+	print("SSL_addr");
+	var f = ctx.factory;
+	if(f.termType(lhs) !== f.REAL || f.termType(rhs) !== f.REAL)
+		return null;
 	return lhs + rhs;
 }
 
@@ -113,7 +123,7 @@
 }
 
 StrategoJS.SSL.SSL_is_string = function(ctx, currentTerm, arg) {
-	if(ctx.factory.getTermType(arg) === ctx.factory.STRING)
+	if(ctx.factory.termType(arg) === ctx.factory.STRING)
 		return arg;
 	return null;
 }
@@ -194,6 +204,8 @@
 }
 
 StrategoJS.SSL.SSL_get_list_length = function(ctx, currentTerm, term) {
+	if(ctx.factory.termType(term) !== ctx.factory.LIST)
+		return null;
 	return ctx.factory.getSubtermCount(term);
 }
 
@@ -288,12 +300,16 @@
 
 StrategoJS.SSL.SSL_indexedSet_reset = function(ctx, currentTerm, setIndex) {
 	print("SSL_indexedSet_reset");
+	if(ctx.factory.termType(setIndex) !== ctx.factory.INT)
+		return null;
 	StrategoJS.SSL._indexedSets[setIndex].reset();
 	return setIndex;
 }
 
 StrategoJS.SSL.SSL_indexedSet_put = function(ctx, currentTerm, strategy, setIndex, key) {
 	print("SSL_indexedSet_put : " + setIndex + " " + key);
+	if(ctx.factory.termType(setIndex) !== ctx.factory.INT)
+		return null;
 	var set = StrategoJS.SSL._indexedSets[setIndex];
 	var keyAsString = ctx.factory.prettify(key);
 	print("                   : " + setIndex + " " + keyAsString);
@@ -309,6 +325,8 @@
 
 StrategoJS.SSL.SSL_indexedSet_getIndex = function(ctx, currentTerm, setIndex, key) {
 	print("SSL_indexedSet_getIndex");
+	if(ctx.factory.termType(setIndex) !== ctx.factory.INT)
+		return null;
 	var set = StrategoJS.SSL._indexedSets[setIndex];
 	var keyAsString = ctx.factory.prettify(key);
 	print("SSL_indexedSet_getIndex " + setIndex + " " + keyAsString);
@@ -319,6 +337,8 @@
 
 StrategoJS.SSL.SSL_indexedSet_elements = function(ctx, currentTerm, setIndex) {
 	print("SSL_indexedSet_elements " + setIndex);
+	if(ctx.factory.termType(setIndex) !== ctx.factory.INT)
+		return null;
 	var set = StrategoJS.SSL._indexedSets[setIndex];
 	var tmp = set.sortedKeySet();
 	print(tmp);
@@ -339,12 +359,16 @@
 
 StrategoJS.SSL.SSL_hashtable_destroy = function(ctx, currentTerm, hashIndex) {
 	print("SSL_hashtable_destroy");
+	if(ctx.factory.termType(hashIndex) !== ctx.factory.INT)
+		return null;
 	delete StrategoJS.SSL._hashtables[hashIndex];
 	return currentTerm;
 }
 
 StrategoJS.SSL.SSL_hashtable_put = function(ctx, currentTerm, hashIndex, key, value) {
 	print("SSL_hashtable_put");
+	if(ctx.factory.termType(hashIndex) !== ctx.factory.INT)
+		return null;
 	var hash = StrategoJS.SSL._hashtables[hashIndex];
 	var keyAsString = ctx.factory.prettify(key);
 	print("SSL_hashtable_put " + hashIndex + " " + keyAsString);
@@ -373,7 +397,10 @@
 }
 
 StrategoJS.SSL.SSL_explode_string = function(ctx, currentTerm, string) {
+	print("SSL_explode_string");
 	var f = ctx.factory;
+	if(f.termType(string) !== f.STRING)
+		return null;
 	var r = f.makeEmptyList();
 	for(var i = string.length - 1; i >= 0; i--) {
 		r = f.makeListCons(f.makeInt(string.charCodeAt(i)), r);
@@ -382,7 +409,10 @@
 }
 
 StrategoJS.SSL.SSL_implode_string = function(ctx, currentTerm, list) {
+	print("SSL_implode_string");
 	var f = ctx.factory;
+	if(f.termType(list) !== f.LIST)
+		return null;
 	var s = "";
 	while(!f.isEmptyList(list)) {
 		s += String.fromCharCode(f.head(list));
@@ -429,11 +459,7 @@
 StrategoJS.SSL.SSL_concat_strings = function(ctx, currentTerm, s1, s2) {
 	print("SSL_concat_strings");
 	var f = ctx.factory;
-	var t1 = f.termType(s1);
-	var t2 = f.termType(s2);
-	if(s1 == undefined || s2 == undefined || s1 == null || s2 == null)
-		return null;
-	if(t1 !== f.STRING || t2 !== f.STRING)
+	if(f.termType(s1) !== f.STRING || f.termType(s2) !== f.STRING)
 		return null;
 	return s1 + s2;
 }

Modified: strategoxt-javascript-backend/trunk/src/javascript/terms.js
==============================================================================
--- strategoxt-javascript-backend/trunk/src/javascript/terms.js	Wed Dec  8 11:32:46 2010	(r21464)
+++ strategoxt-javascript-backend/trunk/src/javascript/terms.js	Wed Dec  8 11:34:40 2010	(r21465)
@@ -581,10 +581,6 @@
 				return listTerm.subtermCount == 0; 
 			},
 
-			getTermType : function(term) {
-				return termType(term);
-			},
-			
 			getSubterm : function(term, idx) {
 				var r = term.getSubterm(idx);
 				if(r === undefined)

From karltk at strategoxt.org  Wed Dec  8 12:42:44 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Wed, 08 Dec 2010 11:42:44 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21466 -
	strategoxt-javascript-backend/trunk/tests/core
Message-ID: <201012081142.oB8BgiT6019844@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Wed Dec  8 11:42:44 2010
New Revision: 21466
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21466&sc=1

Log:
* Added mostly comprehensive tests for all and one.

Added:
   strategoxt-javascript-backend/trunk/tests/core/all_1.str
   strategoxt-javascript-backend/trunk/tests/core/all_2.str
   strategoxt-javascript-backend/trunk/tests/core/all_3.str
   strategoxt-javascript-backend/trunk/tests/core/all_4.str
   strategoxt-javascript-backend/trunk/tests/core/all_5.str
   strategoxt-javascript-backend/trunk/tests/core/all_6.str
   strategoxt-javascript-backend/trunk/tests/core/one_1.str
   strategoxt-javascript-backend/trunk/tests/core/one_2.str
   strategoxt-javascript-backend/trunk/tests/core/one_3.str
   strategoxt-javascript-backend/trunk/tests/core/one_4.str
   strategoxt-javascript-backend/trunk/tests/core/one_5.str
   strategoxt-javascript-backend/trunk/tests/core/one_6.str

Added: strategoxt-javascript-backend/trunk/tests/core/all_1.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ strategoxt-javascript-backend/trunk/tests/core/all_1.str	Wed Dec  8 11:42:44 2010	(r21466)
@@ -0,0 +1,7 @@
+module all_1
+imports
+  emu-libstratego-lib
+
+strategies
+	
+  main = ![1,2,3] ; all(id) ; ?[1,2,3]
\ No newline at end of file

Added: strategoxt-javascript-backend/trunk/tests/core/all_2.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ strategoxt-javascript-backend/trunk/tests/core/all_2.str	Wed Dec  8 11:42:44 2010	(r21466)
@@ -0,0 +1,7 @@
+module all_2
+imports
+  emu-libstratego-lib
+
+strategies
+	
+  main = ![1,2,3] ; all(!4) ; ?[4,4,4]
\ No newline at end of file

Added: strategoxt-javascript-backend/trunk/tests/core/all_3.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ strategoxt-javascript-backend/trunk/tests/core/all_3.str	Wed Dec  8 11:42:44 2010	(r21466)
@@ -0,0 +1,7 @@
+module all_3
+imports
+  emu-libstratego-lib
+
+strategies
+	
+  main = !(1,2,3) ; all(!4) ; ?(4,4,4)
\ No newline at end of file

Added: strategoxt-javascript-backend/trunk/tests/core/all_4.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ strategoxt-javascript-backend/trunk/tests/core/all_4.str	Wed Dec  8 11:42:44 2010	(r21466)
@@ -0,0 +1,7 @@
+module all_4
+imports
+  emu-libstratego-lib
+
+strategies
+	
+  main = !Foo(1,2,3) ; all(!4) ; ?Foo(4,4,4)
\ No newline at end of file

Added: strategoxt-javascript-backend/trunk/tests/core/all_5.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ strategoxt-javascript-backend/trunk/tests/core/all_5.str	Wed Dec  8 11:42:44 2010	(r21466)
@@ -0,0 +1,7 @@
+module all_5
+imports
+  emu-libstratego-lib
+
+strategies
+	
+  main = !1 ; all(!4) ; ?1
\ No newline at end of file

Added: strategoxt-javascript-backend/trunk/tests/core/all_6.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ strategoxt-javascript-backend/trunk/tests/core/all_6.str	Wed Dec  8 11:42:44 2010	(r21466)
@@ -0,0 +1,7 @@
+module all_6
+imports
+  emu-libstratego-lib
+
+strategies
+	
+  main = !"foo" ; all(!4) ; ?"foo"
\ No newline at end of file

Added: strategoxt-javascript-backend/trunk/tests/core/one_1.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ strategoxt-javascript-backend/trunk/tests/core/one_1.str	Wed Dec  8 11:42:44 2010	(r21466)
@@ -0,0 +1,7 @@
+module one_1
+imports
+  emu-libstratego-lib
+
+strategies
+	
+  main = ![1,2,3] ; one(id) ; ?[1,2,3]
\ No newline at end of file

Added: strategoxt-javascript-backend/trunk/tests/core/one_2.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ strategoxt-javascript-backend/trunk/tests/core/one_2.str	Wed Dec  8 11:42:44 2010	(r21466)
@@ -0,0 +1,7 @@
+module one_2
+imports
+  emu-libstratego-lib
+
+strategies
+	
+  main = ![1,2,3] ; one(!4) ; ?[4,2,3]
\ No newline at end of file

Added: strategoxt-javascript-backend/trunk/tests/core/one_3.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ strategoxt-javascript-backend/trunk/tests/core/one_3.str	Wed Dec  8 11:42:44 2010	(r21466)
@@ -0,0 +1,7 @@
+module one_3
+imports
+  emu-libstratego-lib
+
+strategies
+	
+  main = !(1,2,3) ; one(!4) ; ?(4,2,3)
\ No newline at end of file

Added: strategoxt-javascript-backend/trunk/tests/core/one_4.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ strategoxt-javascript-backend/trunk/tests/core/one_4.str	Wed Dec  8 11:42:44 2010	(r21466)
@@ -0,0 +1,7 @@
+module one_4
+imports
+  emu-libstratego-lib
+
+strategies
+	
+  main = !Foo(1,2,3) ; one(!4) ; ?Foo(4,2,3)
\ No newline at end of file

Added: strategoxt-javascript-backend/trunk/tests/core/one_5.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ strategoxt-javascript-backend/trunk/tests/core/one_5.str	Wed Dec  8 11:42:44 2010	(r21466)
@@ -0,0 +1,7 @@
+module one_5
+imports
+  emu-libstratego-lib
+
+strategies
+	
+  main = !1 ; one(!4) ; ?1
\ No newline at end of file

Added: strategoxt-javascript-backend/trunk/tests/core/one_6.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ strategoxt-javascript-backend/trunk/tests/core/one_6.str	Wed Dec  8 11:42:44 2010	(r21466)
@@ -0,0 +1,7 @@
+module one_6
+imports
+  emu-libstratego-lib
+
+strategies
+	
+  main = !"foo" ; one(!4) ; ?"foo"
\ No newline at end of file

From r.t.lindeman at student.tudelft.nl  Wed Dec  8 13:40:54 2010
From: r.t.lindeman at student.tudelft.nl (Ricky Lindeman)
Date: Wed, 08 Dec 2010 12:40:54 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21467 - in
	spoofax-imp/trunk:
	org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control
	org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/...
Message-ID: <201012081240.oB8CesGw020712@proliant.st.ewi.tudelft.nl>

Author: RickyLindeman
Date: Wed Dec  8 12:40:53 2010
New Revision: 21467
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21467&sc=1

Log:
* Fixed: an failing assert in a debug thread would not fail the entire test. Now: all exceptions will be collected and will be shown when the debug target has terminated.
 * all DSMTestCases succeed! :)

Added:
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMSuite.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestBasic.java
Deleted:
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DebugSessionManagerTest.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/VMMonitorTestHelper.java
Modified:
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/DebugSessionManager.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/StrategyExitBreakPoint.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/AbstractDSMTest.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestDynamic.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestImports.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestStepInto.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestStepReturn.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestStepping.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/VMMonitorTestImpl2.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/VMStateTester.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/DebugSessionManager.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/DebugSessionManager.java	Wed Dec  8 11:42:44 2010	(r21466)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/DebugSessionManager.java	Wed Dec  8 12:40:53 2010	(r21467)
@@ -228,11 +228,11 @@
 	}
 	
 	/**
-	 * Terminate the Stratego VM.
+	 * Terminate the Stratego VM. Exits with exitcode 1, abnormal termination.
 	 */
 	public void terminateVM()
 	{
-		// TODO: Implement
+		vm.exit(1);
 	}
 	
 	public EventSpecManager getEventSpecManager()

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/StrategyExitBreakPoint.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/StrategyExitBreakPoint.java	Wed Dec  8 11:42:44 2010	(r21466)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/StrategyExitBreakPoint.java	Wed Dec  8 12:40:53 2010	(r21467)
@@ -23,9 +23,9 @@
 			return true;
 		if (obj == null)
 			return false;
-		if (!(obj instanceof StrategyEnterBreakPoint))
+		if (!(obj instanceof StrategyExitBreakPoint))
 			return false;
-		StrategyEnterBreakPoint other = (StrategyEnterBreakPoint) obj;
+		StrategyExitBreakPoint other = (StrategyExitBreakPoint) obj;
 		if (getFilename() == null || other.getFilename() == null) {
 			return false;
 		} else if (!getFilename().equals(other.getFilename())) {

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/AbstractDSMTest.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/AbstractDSMTest.java	Wed Dec  8 11:42:44 2010	(r21466)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/AbstractDSMTest.java	Wed Dec  8 12:40:53 2010	(r21467)
@@ -1,5 +1,6 @@
 package org.strategoxt.debug.core.control;
 
+import java.util.ArrayList;
 import java.util.List;
 
 import junit.framework.Assert;
@@ -32,13 +33,33 @@
 	 * @param mainArgs
 	 * @param classpath
 	 */
-	public static DebugSessionManager start(DebugSessionManager manager, String mainArgs, String classpath)
+	public DebugSessionManager start(DebugSessionManager manager, String mainArgs, String classpath)
 	{
 		manager.initVM(mainArgs, classpath);
-		//manager.initVM(mainArgs);
 		manager.setupEventListeners();
 		manager.redirectOutput();
-		manager.runVM();		
+		manager.runVM();
+		// runVM waits for the threads to end
+		// check if any Exceptions were thrown
+		checkThreadFailures();
 		return manager;
 	}
+	
+	private List<Throwable> exceptions = new ArrayList<Throwable>();
+	
+	public void caughtThrowableInThread(Throwable e)
+	{
+		System.out.println("Caught Throwable in thread:");
+		e.printStackTrace();
+		//Assert.fail("Caught Throwable in thread");
+		exceptions.add(e);
+	}
+	
+	private void checkThreadFailures()
+	{
+		if (this.exceptions != null && this.exceptions.size() > 0)
+		{
+			Assert.fail("One of the treads threw an Exception...");
+		}
+	}
 }

Added: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMSuite.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMSuite.java	Wed Dec  8 12:40:53 2010	(r21467)
@@ -0,0 +1,30 @@
+package org.strategoxt.debug.core.control;
+
+import junit.framework.Test;
+import junit.framework.TestSuite;
+
+import org.junit.runner.RunWith;
+import org.junit.runners.Suite;
+
+ at RunWith(Suite.class)
+ at Suite.SuiteClasses({
+  DSMTestBasic.class,
+  DSMTestDynamic.class,
+  DSMTestImports.class,
+  DSMTestStepInto.class,
+  DSMTestStepping.class,
+  DSMTestStepReturn.class
+})
+
+public class DSMSuite {
+	
+	public static Test suite() {
+		TestSuite suite = new TestSuite(
+				"Test for org.strategoxt.debug.core.control");
+		//$JUnit-BEGIN$
+
+		//$JUnit-END$
+		return suite;
+	}
+
+}

Added: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestBasic.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestBasic.java	Wed Dec  8 12:40:53 2010	(r21467)
@@ -0,0 +1,275 @@
+package org.strategoxt.debug.core.control;
+
+import java.util.List;
+
+import junit.framework.Assert;
+
+import org.StrategoFileManager;
+import org.strategoxt.debug.core.eventspec.BreakPoint;
+import org.strategoxt.debug.core.eventspec.RuleEnterBreakPoint;
+import org.strategoxt.debug.core.eventspec.StrategyEnterBreakPoint;
+import org.strategoxt.debug.core.util.DebugSessionSettings;
+import org.strategoxt.debug.core.util.table.EventEntry;
+import org.strategoxt.debug.core.util.table.EventTable;
+
+public class DSMTestBasic extends AbstractDSMTest {
+
+	// stratego program should already be compiled
+	@org.junit.Test
+	public void testDSM1()
+	{
+		String projectName = "localvar";
+		DebugSessionSettings debugSessionSettings = new DebugSessionSettings(StrategoFileManager.WORKING_DIR, projectName);
+		
+		//String binBase = DebugCompilerTest.WORKING_DIR + "/" + projectName + "/class";
+		
+		String input = StrategoFileManager.BASE + "/src/stratego/localvar/run.input";
+		String argsForMainClass = "-i " + input;
+		String mainClass = "localvar.localvar";
+		String mainArgs = mainClass + " " + argsForMainClass;
+		String cp = /*strategoxtjar + ":" + libstrategodebuglib + ":" + strjdebugruntime + ":" + */ debugSessionSettings.getClassDirectory(); // was binBase
+		String classpath = cp;
+		
+		VMMonitorTestImpl2 vmMonitor = new VMMonitorTestImpl2(this);
+		DebugSessionManager dsm = new DebugSessionManager(debugSessionSettings, vmMonitor);
+		vmMonitor.setDSM(dsm);
+		
+		// which breakpoints will be hit?
+		VMStateTester vmStateTester = new VMStateTester(VMStateTesterCompareType.Name);
+		vmStateTester.addStrategoState("find-comment-match");
+		vmStateTester.addStrategoState("find-comment-match");
+		vmMonitor.setVMStateTester(vmStateTester);
+		
+		// create a breakpoint
+		BreakPoint bp = null;
+		bp = new RuleEnterBreakPoint("localvar.str", "find-comment-match", -1, -1); // should hit "find-comment-by-name" two times
+		dsm.getEventSpecManager().add(bp);
+		
+		System.out.println("RUN");
+		// start the debug session
+		start(dsm, mainArgs, classpath);
+	}
+	
+	// stratego program should already be compiled
+	@org.junit.Test
+	public void testDSM2()
+	{
+		String projectName = "localvar";
+		DebugSessionSettings debugSessionSettings = new DebugSessionSettings(StrategoFileManager.WORKING_DIR, projectName);
+		
+		//String binBase = DebugCompilerTest.WORKING_DIR + "/" + projectName + "/class";
+		
+		String input = StrategoFileManager.BASE + "/src/stratego/localvar/run.input";
+		String argsForMainClass = "-i " + input;
+		String mainClass = "localvar.localvar";
+		String mainArgs = mainClass + " " + argsForMainClass;
+		String cp = /*strategoxtjar + ":" + libstrategodebuglib + ":" + strjdebugruntime + ":" + */ debugSessionSettings.getClassDirectory(); // was binBase
+		String classpath = cp;
+		
+		VMMonitorTestImpl2 vmMonitor = new VMMonitorTestImpl2(this);
+		DebugSessionManager dsm = new DebugSessionManager(debugSessionSettings, vmMonitor);
+		vmMonitor.setDSM(dsm);
+		
+		// which breakpoints will be hit?
+		VMStateTester vmStateTester = new VMStateTester(VMStateTesterCompareType.Name);
+		vmStateTester.addStrategoState("find-comment-match");
+		vmStateTester.addStrategoState("first");
+		vmStateTester.addStrategoState("find-comment-match");
+		vmStateTester.addStrategoState("first");
+		vmMonitor.setVMStateTester(vmStateTester);
+		
+		// create a breakpoint
+		BreakPoint bp = null;
+		bp = new RuleEnterBreakPoint("localvar.str", "find-comment-match", -1, -1); // should hit "find-comment-by-name" two times
+		dsm.getEventSpecManager().add(bp);
+		bp = new StrategyEnterBreakPoint("localvar.str", "first", -1, -1); // should hit two times
+		dsm.getEventSpecManager().add(bp);
+		System.out.println("RUN");
+		// start the debug session
+		start(dsm, mainArgs, classpath);
+	}
+	
+	@org.junit.Test
+	public void testBreakPointAtS_Step()
+	{
+		String projectName = "localvar";
+		String strategoFilename = "localvar.str";
+		DebugSessionSettings debugSessionSettings = new DebugSessionSettings(StrategoFileManager.WORKING_DIR, projectName);
+		
+		//String binBase = DebugCompilerTest.WORKING_DIR + "/" + projectName + "/class";
+		//String strategoBase = DebugCompilerTest.WORKING_DIR + "/" + projectName + "/stratego";
+		
+		String input = StrategoFileManager.BASE + "/src/stratego/localvar/run.input";
+		String argsForMainClass = "-i " + input;
+		String mainClass = "localvar.localvar";
+		String mainArgs = mainClass + " " + argsForMainClass;
+		String cp = /*strategoxtjar + ":" + libstrategodebuglib + ":" + strjdebugruntime + ":" + */ debugSessionSettings.getClassDirectory(); // was binBase
+		String classpath = cp;
+		
+		VMMonitorTestImpl2 vmMonitor = new VMMonitorTestImpl2(this);
+		DebugSessionManager dsm = new DebugSessionManager(debugSessionSettings, vmMonitor);
+		vmMonitor.setDSM(dsm);
+		
+		//String location = debugSessionSettings.getStrategoDirectory() + "/" + projectName + ".table";
+		//EventTable eventTable = EventTable.readEventTable(location);
+		EventTable eventTable = dsm.getEventSpecManager().getEventTable();
+		Assert.assertEquals(51, eventTable.size());
+		
+		// 47, 8
+		// f* := <find-functions> definitions* // find functions
+		// in rule "match-comments"
+		int lineNumber = 47;
+		int startTokenPosition = 8;
+		String eventType = "s-step";
+		this.addBP(dsm, strategoFilename, lineNumber, startTokenPosition, eventType);
+
+		
+		// 48, 8
+		// c* := <find-comments> definitions* // find comments
+		lineNumber = 48;
+		startTokenPosition = 8;
+		eventType = "s-step";
+		this.addBP(dsm, strategoFilename, lineNumber, startTokenPosition, eventType);
+		
+		// 49, 8
+		// out := <match-f-and-c> (f*, c*)
+		lineNumber = 49;
+		startTokenPosition = 8;
+		eventType = "s-step";
+		this.addBP(dsm, strategoFilename, lineNumber, startTokenPosition, eventType);
+	
+		
+		// which breakpoints will be hit?
+		VMStateTester vmStateTester = new VMStateTester(VMStateTesterCompareType.Name);
+		vmStateTester.addStrategoState("match-comments");
+		vmStateTester.addStrategoState("match-comments");
+		vmStateTester.addStrategoState("match-comments");
+		vmMonitor.setVMStateTester(vmStateTester);
+		
+
+		System.out.println("RUN");
+		// start the debug session
+		start(dsm, mainArgs, classpath);
+	}
+	
+	@org.junit.Test
+	public void testStepVarBreakPoint()
+	{
+		String projectName = "localvar";
+		String strategoFilename = "localvar.str";
+		DebugSessionSettings debugSessionSettings = new DebugSessionSettings(StrategoFileManager.WORKING_DIR, projectName);
+		
+		//String binBase = DebugCompilerTest.WORKING_DIR + "/" + projectName + "/class";
+		//String strategoBase = DebugCompilerTest.WORKING_DIR + "/" + projectName + "/stratego";
+		
+		String input = StrategoFileManager.BASE + "/src/stratego/localvar/run.input";
+		String argsForMainClass = "-i " + input;
+		String mainClass = "localvar.localvar";
+		String mainArgs = mainClass + " " + argsForMainClass;
+		String cp = /*strategoxtjar + ":" + libstrategodebuglib + ":" + strjdebugruntime + ":" + */ debugSessionSettings.getClassDirectory(); // was binBase
+		String classpath = cp;
+		
+		VMMonitorTestImpl2 vmMonitor = new VMMonitorTestImpl2(this);
+		DebugSessionManager dsm = new DebugSessionManager(debugSessionSettings, vmMonitor);
+		vmMonitor.setDSM(dsm);
+		
+		//String location = debugSessionSettings.getStrategoDirectory() + "/" + projectName + ".table";
+		//EventTable eventTable = EventTable.readEventTable(location);
+		EventTable eventTable = dsm.getEventSpecManager().getEventTable();
+		Assert.assertEquals(51, eventTable.size());
+		
+		// 47, 8
+		// f* := <find-functions> definitions* // find functions
+		// in rule "match-comments"
+		int lineNumber = 47;
+		int startTokenPosition = 8;
+		String eventType = "s-step";
+		this.addBP(dsm, strategoFilename, lineNumber, startTokenPosition, eventType);
+
+		
+		// 48, 8
+		// c* := <find-comments> definitions* // find comments
+		lineNumber = 48;
+		startTokenPosition = 8;
+		eventType = "s-step";
+		this.addBP(dsm, strategoFilename, lineNumber, startTokenPosition, eventType);
+
+		
+		// 49, 8
+		// out := <match-f-and-c> (f*, c*)
+		lineNumber = 49;
+		startTokenPosition = 8;
+		eventType = "s-step";
+		this.addBP(dsm, strategoFilename, lineNumber, startTokenPosition, eventType);
+
+		
+		
+		// which breakpoints will be hit?
+		VMStateTester vmStateTester = new VMStateTester(VMStateTesterCompareType.Name);
+		vmStateTester.addStrategoState("match-comments");
+		vmStateTester.addStrategoState("match-comments"); // value f* should be set
+		vmStateTester.addStrategoState("match-comments"); // value c* should be set
+		vmMonitor.setVMStateTester(vmStateTester);
+		
+
+		System.out.println("RUN");
+		// start the debug session
+		start(dsm, mainArgs, classpath);
+	}
+	
+	@org.junit.Test
+	public void testBreakpointLookup()
+	{
+		String projectName = "localvar";
+		String strategoFilename = "localvar.str";
+		// TODO: project should be compiled with debug info!
+		
+		DebugSessionSettings debugSessionSettings = new DebugSessionSettings(StrategoFileManager.WORKING_DIR, projectName);
+		//String binBase = DebugCompilerTest.WORKING_DIR + "/" + projectName + "/class";
+		//String strategoBase = DebugCompilerTest.WORKING_DIR + "/" + projectName + "/stratego";
+		
+		String input = StrategoFileManager.BASE + "/src/stratego/localvar/run.input";
+		String argsForMainClass = "-i " + input;
+		String mainClass = "localvar.localvar";
+		String mainArgs = mainClass + " " + argsForMainClass;
+		String cp = /*strategoxtjar + ":" + libstrategodebuglib + ":" + strjdebugruntime + ":" + */ debugSessionSettings.getClassDirectory(); // was binBase
+		String classpath = cp;
+		
+		VMMonitorTestImpl2 vmMonitor = new VMMonitorTestImpl2(this);
+		DebugSessionManager dsm = new DebugSessionManager(debugSessionSettings, vmMonitor);
+		vmMonitor.setDSM(dsm);
+		
+		//String location = debugSessionSettings.getStrategoDirectory() + "/" + projectName + ".table";
+		//EventTable eventTable = EventTable.readEventTable(location);
+		EventTable eventTable = dsm.getEventSpecManager().getEventTable();
+		Assert.assertEquals(51, eventTable.size());
+		
+		// find-comment-match s-enter is at 71,7
+		List<EventEntry> entries = eventTable.getEventEntries(strategoFilename, 71, 7);
+		Assert.assertEquals(2, entries.size()); // r-enter/r-exit
+		EventEntry rEnter = null; // only use the r-enter
+		for(EventEntry e : entries)
+		{
+			if ("r-enter".equals(e.getEventType()))
+			{
+				rEnter = e;
+			}
+		}
+		Assert.assertEquals("find-comment-match", rEnter.getStrategyName());
+		// found the "find-comment-match" rule in the table
+
+		// which breakpoints will be hit?
+		VMStateTester vmStateTester = new VMStateTester(VMStateTesterCompareType.Name);
+		vmStateTester.addStrategoState("find-comment-match");
+		vmStateTester.addStrategoState("find-comment-match");
+		vmMonitor.setVMStateTester(vmStateTester);
+		
+		// create a breakpoint
+		BreakPoint bp = null;
+		bp = new RuleEnterBreakPoint("localvar.str", rEnter.getStrategyName(), -1, -1); // should hit "find-comment-by-name" two times
+		dsm.getEventSpecManager().add(bp);
+		System.out.println("RUN");
+		// start the debug session
+		start(dsm, mainArgs, classpath);
+	}
+}

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestDynamic.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestDynamic.java	Wed Dec  8 11:42:44 2010	(r21466)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestDynamic.java	Wed Dec  8 12:40:53 2010	(r21467)
@@ -30,7 +30,7 @@
 		String cp = /*strategoxtjar + ":" + libstrategodebuglib + ":" + strjdebugruntime + ":" + */ debugSessionSettings.getClassDirectory(); // was binBase
 		String classpath = cp;
 		
-		VMMonitorTestImpl2 vmMonitor = new VMMonitorTestImpl2();
+		VMMonitorTestImpl2 vmMonitor = new VMMonitorTestImpl2(this);
 		DebugSessionManager dsm = new DebugSessionManager(debugSessionSettings, vmMonitor);
 		vmMonitor.setDSM(dsm);
 		

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestImports.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestImports.java	Wed Dec  8 11:42:44 2010	(r21466)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestImports.java	Wed Dec  8 12:40:53 2010	(r21467)
@@ -29,7 +29,7 @@
 		String cp = /*strategoxtjar + ":" + libstrategodebuglib + ":" + strjdebugruntime + ":" + */ debugSessionSettings.getClassDirectory(); // was binBase
 		String classpath = cp;
 		
-		VMMonitorTestImpl2 vmMonitor = new VMMonitorTestImpl2();
+		VMMonitorTestImpl2 vmMonitor = new VMMonitorTestImpl2(this);
 		DebugSessionManager dsm = new DebugSessionManager(debugSessionSettings, vmMonitor);
 		vmMonitor.setDSM(dsm);
 		

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestStepInto.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestStepInto.java	Wed Dec  8 11:42:44 2010	(r21466)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestStepInto.java	Wed Dec  8 12:40:53 2010	(r21467)
@@ -15,6 +15,7 @@
 		//dsm.testStepping3();
 	}
 	
+	@org.junit.Test
 	public void testStepping1()
 	{
 		String projectName = "localvar";
@@ -31,7 +32,7 @@
 		String cp = /*strategoxtjar + ":" + libstrategodebuglib + ":" + strjdebugruntime + ":" + */ debugSessionSettings.getClassDirectory(); // was binBase
 		String classpath = cp;
 		
-		VMMonitorTestImpl2 vmMonitor = new VMMonitorTestImpl2();
+		VMMonitorTestImpl2 vmMonitor = new VMMonitorTestImpl2(this);
 		DebugSessionManager dsm = new DebugSessionManager(debugSessionSettings, vmMonitor);
 		vmMonitor.setDSM(dsm);
 		
@@ -73,6 +74,7 @@
 		System.out.println("EXIT");
 	}
 	
+	@org.junit.Test
 	public void testStepping2()
 	{
 		// perform a step_into when the current statement cannot be stepped into
@@ -90,7 +92,7 @@
 		String cp = /*strategoxtjar + ":" + libstrategodebuglib + ":" + strjdebugruntime + ":" + */ debugSessionSettings.getClassDirectory(); // was binBase
 		String classpath = cp;
 		
-		VMMonitorTestImpl2 vmMonitor = new VMMonitorTestImpl2();
+		VMMonitorTestImpl2 vmMonitor = new VMMonitorTestImpl2(this);
 		DebugSessionManager dsm = new DebugSessionManager(debugSessionSettings, vmMonitor);
 		vmMonitor.setDSM(dsm);
 		

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestStepReturn.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestStepReturn.java	Wed Dec  8 11:42:44 2010	(r21466)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestStepReturn.java	Wed Dec  8 12:40:53 2010	(r21467)
@@ -15,6 +15,7 @@
 		//dsm.testStepping3();
 	}
 	
+	@org.junit.Test
 	public void testStepping1()
 	{
 		String projectName = "localvar";
@@ -31,7 +32,7 @@
 		String cp = /*strategoxtjar + ":" + libstrategodebuglib + ":" + strjdebugruntime + ":" + */ debugSessionSettings.getClassDirectory(); // was binBase
 		String classpath = cp;
 		
-		VMMonitorTestImpl2 vmMonitor = new VMMonitorTestImpl2();
+		VMMonitorTestImpl2 vmMonitor = new VMMonitorTestImpl2(this);
 		DebugSessionManager dsm = new DebugSessionManager(debugSessionSettings, vmMonitor);
 		vmMonitor.setDSM(dsm);
 		
@@ -75,7 +76,7 @@
 		System.out.println("EXIT");
 	}
 	
-	
+	@org.junit.Test
 	public void testStepping2()
 	{
 		// suspend at breakpoint, do a STEP_RETURN but hit another breakpoint before the active strategy could exit
@@ -94,7 +95,7 @@
 		String cp = /*strategoxtjar + ":" + libstrategodebuglib + ":" + strjdebugruntime + ":" + */ debugSessionSettings.getClassDirectory(); // was binBase
 		String classpath = cp;
 		
-		VMMonitorTestImpl2 vmMonitor = new VMMonitorTestImpl2();
+		VMMonitorTestImpl2 vmMonitor = new VMMonitorTestImpl2(this);
 		DebugSessionManager dsm = new DebugSessionManager(debugSessionSettings, vmMonitor);
 		vmMonitor.setDSM(dsm);
 		

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestStepping.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestStepping.java	Wed Dec  8 11:42:44 2010	(r21466)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/DSMTestStepping.java	Wed Dec  8 12:40:53 2010	(r21467)
@@ -15,6 +15,7 @@
 		dsm.testStepping3();
 	}
 	
+	@org.junit.Test
 	public void testStepping1()
 	{
 		String projectName = "localvar";
@@ -31,7 +32,7 @@
 		String cp = /*strategoxtjar + ":" + libstrategodebuglib + ":" + strjdebugruntime + ":" + */ debugSessionSettings.getClassDirectory(); // was binBase
 		String classpath = cp;
 		
-		VMMonitorTestImpl2 vmMonitor = new VMMonitorTestImpl2();
+		VMMonitorTestImpl2 vmMonitor = new VMMonitorTestImpl2(this);
 		DebugSessionManager dsm = new DebugSessionManager(debugSessionSettings, vmMonitor);
 		vmMonitor.setDSM(dsm);
 		
@@ -86,6 +87,7 @@
 		System.out.println("EXIT");
 	}
 	
+	@org.junit.Test
 	public void testStepping2()
 	{
 		// step over at the last statement in a rule or strategy
@@ -103,7 +105,7 @@
 		String cp = /*strategoxtjar + ":" + libstrategodebuglib + ":" + strjdebugruntime + ":" + */ debugSessionSettings.getClassDirectory(); // was binBase
 		String classpath = cp;
 		
-		VMMonitorTestImpl2 vmMonitor = new VMMonitorTestImpl2();
+		VMMonitorTestImpl2 vmMonitor = new VMMonitorTestImpl2(this);
 		DebugSessionManager dsm = new DebugSessionManager(debugSessionSettings, vmMonitor);
 		vmMonitor.setDSM(dsm);
 		
@@ -166,6 +168,7 @@
 		System.out.println("EXIT");
 	}
 	
+	@org.junit.Test
 	public void testStepping3()
 	{
 		// step over a statement in a rule, but hit a breakpoint while stepping
@@ -185,7 +188,7 @@
 		String cp = /*strategoxtjar + ":" + libstrategodebuglib + ":" + strjdebugruntime + ":" + */ debugSessionSettings.getClassDirectory(); // was binBase
 		String classpath = cp;
 		
-		VMMonitorTestImpl2 vmMonitor = new VMMonitorTestImpl2();
+		VMMonitorTestImpl2 vmMonitor = new VMMonitorTestImpl2(this);
 		DebugSessionManager dsm = new DebugSessionManager(debugSessionSettings, vmMonitor);
 		vmMonitor.setDSM(dsm);
 		

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/VMMonitorTestImpl2.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/VMMonitorTestImpl2.java	Wed Dec  8 11:42:44 2010	(r21466)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/VMMonitorTestImpl2.java	Wed Dec  8 12:40:53 2010	(r21467)
@@ -15,17 +15,20 @@
 	public final static String STEP_OVER = "STEP_OVER";
 	public final static String STEP_RETURN = "STEP_RETURN";
 	public final static String RESUME = "RESUME";
+	public final static String TERMINATE = "TERMINATE";
 	
 	private DebugSessionManager debugSessionManager;
 	private VMStateTester vmStateTester;
 	
+	private AbstractDSMTest callback = null;
+	
 	// list contains String encoded actions: e.g. RESUME, STEP
 	// This action should be performed after a state change, if no actions are in the list left, do a RESUME
 	private List<String> afterStateChangeActions = null;
 	private int actionIndex = -1;
 	
-	public VMMonitorTestImpl2() {
-
+	public VMMonitorTestImpl2(AbstractDSMTest callback) {
+		this.callback = callback;
 	}
 	
 	public void setVMStateTester(VMStateTester vmStateTester) {
@@ -37,27 +40,56 @@
 		this.debugSessionManager = dsm;
 	}
 	
+	private void caughtThrowable(Throwable e)
+	{
+		if (this.callback != null)
+		{
+			callback.caughtThrowableInThread(e);
+		}
+	}
+	
 	public void stateChanged(StrategoState state) {
 		System.out.println("state changed");
-		if (vmStateTester.hasNext())
-		{
-			vmStateTester.next();
-			boolean expected = vmStateTester.compareState(state);
-			String message = "Hit " + state.currentFrame() + ", but expected to hit " + vmStateTester.current().currentFrame();
-			Assert.assertTrue(message, expected);
-			System.out.println("current: " + state.currentFrame().getCurrentTerm());
-			for ( Entry<String, IStrategoTerm> entry : state.currentFrame().getVariables().entrySet() )
+		// catch any exception
+		boolean stateMismatch = false; // true if the current state does not match the expected state
+		try
+		{
+			if (vmStateTester.hasNext())
+			{
+				vmStateTester.next();
+				boolean expected = vmStateTester.compareState(state);
+				String message = "State #" + vmStateTester.getIndex()+ ": Hit " + state.currentFrame() + ", but expected to hit " + vmStateTester.current().currentFrame();
+				Assert.assertTrue(message, expected);
+				System.out.println("current: " + state.currentFrame().getCurrentTerm());
+				for ( Entry<String, IStrategoTerm> entry : state.currentFrame().getVariables().entrySet() )
+				{
+					System.out.println("variable entry " + entry.getKey() + " # " + entry.getValue());
+				}
+			}
+			else
 			{
-				System.out.println("variable entry " + entry.getKey() + " # " + entry.getValue());
+				String message = "State changed but we did not except anymore state changes...";
+				Assert.fail(message);
 			}
+			
+		} catch(Exception e)
+		{
+			caughtThrowable(e);
+			stateMismatch = true;
+		} catch (AssertionError e)
+		{
+			caughtThrowable(e);
+			stateMismatch = true;
+		}
+		if (!stateMismatch)
+		{
+			nextAction();
 		}
 		else
 		{
-			String message = "State changed but we did not except anymore state changes...";
-			Assert.fail(message);
+			// test failed, stop VM
+			performAction(TERMINATE);
 		}
-		
-		nextAction();
 	}
 
 	public void vmEvent(String event) {
@@ -81,33 +113,49 @@
 		this.afterStateChangeActions.add(action);
 	}
 	
+	/**
+	 * Performs the given action on the Stratego VM.
+	 * @param action
+	 */
+	private void performAction(String action)
+	{
+		if (RESUME.equals(action))
+		{
+			this.debugSessionManager.resumeVM();
+		}
+		else if (STEP_INTO.equals(action))
+		{
+			this.debugSessionManager.stepInto();
+		}
+		else if (STEP_OVER.equals(action))
+		{
+			this.debugSessionManager.stepOver();
+		}
+		else if (STEP_RETURN.equals(action))
+		{
+			this.debugSessionManager.stepReturn();
+		}
+		else if (TERMINATE.equals(action))
+		{
+			this.debugSessionManager.terminateVM();
+		}
+		else
+		{
+			// action unknown, just do a resume
+			this.debugSessionManager.resumeVM();
+		}
+	}
+	
+	/**
+	 * Determines the next action in the list and performs the action.
+	 */
 	private void nextAction()
 	{
 		actionIndex++;
 		if (afterStateChangeActions != null && actionIndex < afterStateChangeActions.size())
 		{
 			String action = afterStateChangeActions.get(actionIndex);
-			if (RESUME.equals(action))
-			{
-				this.debugSessionManager.resumeVM();
-			}
-			else if (STEP_INTO.equals(action))
-			{
-				this.debugSessionManager.stepInto();
-			}
-			else if (STEP_OVER.equals(action))
-			{
-				this.debugSessionManager.stepOver();
-			}
-			else if (STEP_RETURN.equals(action))
-			{
-				this.debugSessionManager.stepReturn();
-			}
-			else
-			{
-				// action unknown, just do a resume
-				this.debugSessionManager.resumeVM();
-			}
+			performAction(action);
 		}
 		else
 		{

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/VMStateTester.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/VMStateTester.java	Wed Dec  8 11:42:44 2010	(r21466)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/VMStateTester.java	Wed Dec  8 12:40:53 2010	(r21467)
@@ -29,6 +29,7 @@
 	private Iterator<StrategoState> iter = null;
 	
 	private StrategoState current;
+	private int index = -1;
 	
 	// if fullcompare is true compare the toplevel StackFrame
 	// if fullCompare is false only compare the strategy name
@@ -41,7 +42,8 @@
 	
 	public void initialize()
 	{
-		this.iter =  getIterator();
+		this.iter = getIterator();
+		this.index = -1;
 	}
 	
 	private Iterator<StrategoState> getIterator()
@@ -61,6 +63,7 @@
 	public StrategoState next()
 	{
 		this.current = getIterator().next();
+		this.index++;
 		return this.current;
 	}
 	
@@ -69,7 +72,10 @@
 		return this.current;
 	}
 	
-	
+	public int getIndex()
+	{
+		return this.index;
+	}
 	
 	/**
 	 * Compare the given StrategoState with the current StrategoState.

From R.B.Vermaas at tudelft.nl  Wed Dec  8 15:01:54 2010
From: R.B.Vermaas at tudelft.nl (Rob Vermaas)
Date: Wed, 08 Dec 2010 14:01:54 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21468 - hydra/webdsl
Message-ID: <201012081401.oB8E1sY9022096@proliant.st.ewi.tudelft.nl>

Author: rob
Date: Wed Dec  8 14:01:53 2010
New Revision: 21468
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21468&sc=1

Log:
webdsl-tests: add feedback app

Modified:
   hydra/webdsl/tests.nix

Modified: hydra/webdsl/tests.nix
==============================================================================
--- hydra/webdsl/tests.nix	Wed Dec  8 12:40:53 2010	(r21467)
+++ hydra/webdsl/tests.nix	Wed Dec  8 14:01:53 2010	(r21468)
@@ -57,6 +57,7 @@
   researchr   = { researchrSrc ? { outPath = ../../researchr; rev = 1234; } }     : build "researchr" researchrSrc [];
   webdslorg   = { webdslorgSrc ? { outPath = ../../webdslorg; rev = 1234; } }     : build "webdslorg" webdslorgSrc [];
   yellowgrass = { yellowgrassSrc ? { outPath = ../../yellowgrass; rev = 1234; } } : build "yellowgrass" yellowgrassSrc ["s.d.vermolen at tudelft.nl"] ;
+  feedback    = { feedbackSrc ? { outPath = ../../feedback; rev = 1234; } }       : build "freedback" feedbackSrc [];
 
   webcheck =
     { webdslSrc ? {outPath = ../../webdsl; rev = 1234;}

From R.B.Vermaas at tudelft.nl  Wed Dec  8 15:05:02 2010
From: R.B.Vermaas at tudelft.nl (Rob Vermaas)
Date: Wed, 08 Dec 2010 14:05:02 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21469 - hydra/webdsl
Message-ID: <201012081405.oB8E527q022154@proliant.st.ewi.tudelft.nl>

Author: rob
Date: Wed Dec  8 14:05:01 2010
New Revision: 21469
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21469&sc=1

Log:
typo

Modified:
   hydra/webdsl/tests.nix

Modified: hydra/webdsl/tests.nix
==============================================================================
--- hydra/webdsl/tests.nix	Wed Dec  8 14:01:53 2010	(r21468)
+++ hydra/webdsl/tests.nix	Wed Dec  8 14:05:01 2010	(r21469)
@@ -57,7 +57,7 @@
   researchr   = { researchrSrc ? { outPath = ../../researchr; rev = 1234; } }     : build "researchr" researchrSrc [];
   webdslorg   = { webdslorgSrc ? { outPath = ../../webdslorg; rev = 1234; } }     : build "webdslorg" webdslorgSrc [];
   yellowgrass = { yellowgrassSrc ? { outPath = ../../yellowgrass; rev = 1234; } } : build "yellowgrass" yellowgrassSrc ["s.d.vermolen at tudelft.nl"] ;
-  feedback    = { feedbackSrc ? { outPath = ../../feedback; rev = 1234; } }       : build "freedback" feedbackSrc [];
+  feedback    = { feedbackSrc ? { outPath = ../../feedback; rev = 1234; } }       : build "feedback" feedbackSrc [];
 
   webcheck =
     { webdslSrc ? {outPath = ../../webdsl; rev = 1234;}

From L.C.L.Kats at tudelft.nl  Wed Dec  8 15:15:56 2010
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Wed, 08 Dec 2010 14:15:56 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21470 -
	strategoxt-java-backend/trunk/META-INF
Message-ID: <201012081415.oB8EFuBw022282@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: Wed Dec  8 14:15:56 2010
New Revision: 21470
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21470&sc=1

Log:


Modified:
   strategoxt-java-backend/trunk/META-INF/MANIFEST.MF

Modified: strategoxt-java-backend/trunk/META-INF/MANIFEST.MF
==============================================================================
--- strategoxt-java-backend/trunk/META-INF/MANIFEST.MF	Wed Dec  8 14:05:01 2010	(r21469)
+++ strategoxt-java-backend/trunk/META-INF/MANIFEST.MF	Wed Dec  8 14:15:56 2010	(r21470)
@@ -54,7 +54,6 @@
  org.strategoxt.lang.compat.stratego_rtg_compat,
  org.strategoxt.lang.compat.strc_compat,
  org.strategoxt.lang.parallel.collections,
- org.strategoxt.lang.parallel.tables.attic,
  org.strategoxt.lang.terms,
  org.strategoxt.stratego_aterm,
  org.strategoxt.stratego_gpp,

From L.C.L.Kats at tudelft.nl  Wed Dec  8 15:43:56 2010
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Wed, 08 Dec 2010 14:43:56 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21471 - in
	spoofax-imp/trunk: org.strategoxt.imp.generator/src/sdf2imp/project
	org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building
Message-ID: <201012081443.oB8Ehu56022640@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: Wed Dec  8 14:43:56 2010
New Revision: 21471
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21471&sc=1

Log:
Fixed: Project doesn't rebuild until changed after error (Spoofax/311)

Added:
   spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building/AntForceRefreshScheduler.java
Modified:
   spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-build-xml.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-build-xml.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-build-xml.str	Wed Dec  8 14:15:56 2010	(r21470)
+++ spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-build-xml.str	Wed Dec  8 14:43:56 2010	(r21471)
@@ -76,8 +76,8 @@
     <project name="build.generated">
 
         <target name="spoofaximp.default" depends="spoofaximp.default.ctree"/>
-        <target name="spoofaximp.default.ctree" depends="check-classpath,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.ctree,java.jar,sdf2imp,refresh"/>
-        <target name="spoofaximp.default.jar"   depends="check-classpath,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.jar,  java.jar,sdf2imp,refresh"/>
+        <target name="spoofaximp.default.ctree" depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.ctree,java.jar,sdf2imp,refresh"/>
+        <target name="spoofaximp.default.jar"   depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.jar,  java.jar,sdf2imp,refresh"/>
     
         <!-- Initialization -->
         <available file="${build}/<%= pkgdir %>/strategies/Main.class" property="java.jar.enabled"/>
@@ -157,6 +157,13 @@
             <available classname="org.strategoxt.imp.generator.sdf2imp" property="check-classpath.available"/>
             <antcall target="check-classpath.helper"/>  
         </target>
+        
+        <target name="init" if="eclipse.running">
+            <!-- refresh one file/dir in the project to trigger an Ant rebuild with the next build command -->
+            <java classname="org.strategoxt.imp.metatooling.building.AntForceRefreshScheduler" failonerror="false">
+                <arg value="${include}"/>
+            </java>
+        </target>
   
         <target name="check-classpath.helper" unless="check-classpath.available">
             <echo level="error" message="Could not load the Spoofax plugin loading classes."/>

Added: spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building/AntForceRefreshScheduler.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building/AntForceRefreshScheduler.java	Wed Dec  8 14:43:56 2010	(r21471)
@@ -0,0 +1,43 @@
+package org.strategoxt.imp.metatooling.building;
+
+import java.io.File;
+
+import org.eclipse.core.resources.IResource;
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.core.runtime.IStatus;
+import org.eclipse.core.runtime.Status;
+import org.eclipse.core.runtime.jobs.Job;
+import org.strategoxt.imp.runtime.Environment;
+import org.strategoxt.imp.runtime.stratego.EditorIOAgent;
+
+/**
+ * Helper class to force the Eclipse Ant builder to
+ * rebuild a project even if it didn't change (Spoofax/311).
+ * 
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class AntForceRefreshScheduler {
+	public static void main(String[] args) throws Exception {
+		if (args == null || args.length == 0)
+			throw new IllegalArgumentException("File expected");
+		
+		final String fileArg = args[0];
+		final int depthArg = args.length >= 2 ? Integer.parseInt(args[1]) : IResource.DEPTH_INFINITE;
+		final IResource file = EditorIOAgent.getResource(new File(fileArg));
+		
+		Job job = new Job("Refresh") {
+			@Override
+			protected IStatus run(IProgressMonitor monitor) {
+				try {
+					file.touch(monitor);
+					file.refreshLocal(depthArg, monitor);
+				} catch (Exception e) {
+					Environment.logWarning("Could not refresh file", e);
+				}
+				return Status.OK_STATUS;
+			}
+		};
+		job.setSystem(true);
+		job.schedule(500);
+	}
+}

From karltk at strategoxt.org  Wed Dec  8 15:57:28 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Wed, 08 Dec 2010 14:57:28 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21472 - in
	strategoxt-javascript-backend/trunk: src/javascript tests/core
Message-ID: <201012081457.oB8EvSSU022815@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Wed Dec  8 14:57:28 2010
New Revision: 21472
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21472&sc=1

Log:
* Fixed a few bugs in the one/all tests.
 * Fixed a few bugs in the one/all implementations.

Modified:
   strategoxt-javascript-backend/trunk/src/javascript/srts.js
   strategoxt-javascript-backend/trunk/tests/core/all_4.str
   strategoxt-javascript-backend/trunk/tests/core/one_4.str
   strategoxt-javascript-backend/trunk/tests/core/one_5.str
   strategoxt-javascript-backend/trunk/tests/core/one_6.str

Modified: strategoxt-javascript-backend/trunk/src/javascript/srts.js
==============================================================================
--- strategoxt-javascript-backend/trunk/src/javascript/srts.js	Wed Dec  8 14:43:56 2010	(r21471)
+++ strategoxt-javascript-backend/trunk/src/javascript/srts.js	Wed Dec  8 14:57:28 2010	(r21472)
@@ -122,7 +122,7 @@
 	case factory.REAL:
 	case factory.INT:
 	case factory.STRING: 
-		return fun(ctx, term);
+		return term;
 	case factory.LIST: 
 		var tmp = [];
 		while(!factory.isEmptyList(term)) {
@@ -139,20 +139,20 @@
 		return r;
 	case factory.TUPLE:
 	case factory.APPL:
-		throw "not implemented all";
 		var l = factory.getSubtermCount(term);
 		var tmp = [];
 		var success = false;
 		for(var i = 0; i < l; i++) {
 			var ot = factory.getSubterm(term, i); 
 			var nt = fun(ctx, ot);
-			tmp.push(nt === null ? ot : ot);
-			success = nt !== null || success;
+			if(nt === null)
+				return null;
+			tmp.push(nt);
 		}
-		if(success) {
-			
+		if(factory.termType(term) === factory.APPL) {
+			return factory.makeAppl(factory.getConstructor(term), tmp);
 		} else {
-			return null;
+			return factory.makeTuple(tmp);
 		}
 	default:
 		throw new "invalid term type ";

Modified: strategoxt-javascript-backend/trunk/tests/core/all_4.str
==============================================================================
--- strategoxt-javascript-backend/trunk/tests/core/all_4.str	Wed Dec  8 14:43:56 2010	(r21471)
+++ strategoxt-javascript-backend/trunk/tests/core/all_4.str	Wed Dec  8 14:57:28 2010	(r21472)
@@ -2,6 +2,10 @@
 imports
   emu-libstratego-lib
 
+signature
+  constructors
+  	Foo : Int * Int * Int -> Foo
+  	
 strategies
 	
   main = !Foo(1,2,3) ; all(!4) ; ?Foo(4,4,4)
\ No newline at end of file

Modified: strategoxt-javascript-backend/trunk/tests/core/one_4.str
==============================================================================
--- strategoxt-javascript-backend/trunk/tests/core/one_4.str	Wed Dec  8 14:43:56 2010	(r21471)
+++ strategoxt-javascript-backend/trunk/tests/core/one_4.str	Wed Dec  8 14:57:28 2010	(r21472)
@@ -2,6 +2,10 @@
 imports
   emu-libstratego-lib
 
+signature
+  constructors
+  	Foo : Int * Int * Int -> Foo
+  	
 strategies
 	
   main = !Foo(1,2,3) ; one(!4) ; ?Foo(4,2,3)
\ No newline at end of file

Modified: strategoxt-javascript-backend/trunk/tests/core/one_5.str
==============================================================================
--- strategoxt-javascript-backend/trunk/tests/core/one_5.str	Wed Dec  8 14:43:56 2010	(r21471)
+++ strategoxt-javascript-backend/trunk/tests/core/one_5.str	Wed Dec  8 14:57:28 2010	(r21472)
@@ -4,4 +4,4 @@
 
 strategies
 	
-  main = !1 ; one(!4) ; ?1
\ No newline at end of file
+  main = !1 ; not(one(!4)) ; ?1
\ No newline at end of file

Modified: strategoxt-javascript-backend/trunk/tests/core/one_6.str
==============================================================================
--- strategoxt-javascript-backend/trunk/tests/core/one_6.str	Wed Dec  8 14:43:56 2010	(r21471)
+++ strategoxt-javascript-backend/trunk/tests/core/one_6.str	Wed Dec  8 14:57:28 2010	(r21472)
@@ -4,4 +4,4 @@
 
 strategies
 	
-  main = !"foo" ; one(!4) ; ?"foo"
\ No newline at end of file
+  main = !"foo" ; not(one(!4)) ; ?"foo"
\ No newline at end of file

From L.C.L.Kats at tudelft.nl  Wed Dec  8 16:22:32 2010
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Wed, 08 Dec 2010 15:22:32 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21473 - in
	spoofax-imp/trunk: org.strategoxt.imp.feature
	org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services
	org.strategoxt.imp.updatesite
Message-ID: <201012081522.oB8FMWAL023421@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: Wed Dec  8 15:22:32 2010
New Revision: 21473
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21473&sc=1

Log:
Release 0.53.95 (new versioning scheme to accomodate for nightly builds)

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.feature/feature.xml
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/ContentProposer.java
   spoofax-imp/trunk/org.strategoxt.imp.updatesite/site.xml

Modified: spoofax-imp/trunk/org.strategoxt.imp.feature/feature.xml
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.feature/feature.xml	Wed Dec  8 14:57:28 2010	(r21472)
+++ spoofax-imp/trunk/org.strategoxt.imp.feature/feature.xml	Wed Dec  8 15:22:32 2010	(r21473)
@@ -2,7 +2,7 @@
 <feature
       id="org.strategoxt.imp"
       label="Spoofax/IMP"
-      version="0.5.3.qualifier"
+      version="0.53.95.qualifier"
       plugin="org.strategoxt.imp.runtime">
 
    <description url="http://strategoxt.org/Stratego/Spoofax-IMP">

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/ContentProposer.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/ContentProposer.java	Wed Dec  8 14:57:28 2010	(r21472)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/ContentProposer.java	Wed Dec  8 15:22:32 2010	(r21473)
@@ -168,7 +168,7 @@
 			try {
 				String parseErrorHelp = currentCompletionNode != null
 					&& currentCompletionNode.getConstructor() == COMPLETION_UNKNOWN
-					? "\n   (context could not be parsed with this grammar; consider experimenting\n   with additional productions for this partial construct, possibly\n   marked with a {recover} annotation.)"
+					? "\n   (context could not be parsed with this grammar; see the FAQ.)"
 					: "";
 				StrategoConsole.getOutputWriter().write(
 					":: Completion triggered for: " + currentCompletionNode

Modified: spoofax-imp/trunk/org.strategoxt.imp.updatesite/site.xml
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.updatesite/site.xml	Wed Dec  8 14:57:28 2010	(r21472)
+++ spoofax-imp/trunk/org.strategoxt.imp.updatesite/site.xml	Wed Dec  8 15:22:32 2010	(r21473)
@@ -3,7 +3,7 @@
    <description name="Spoofax/IMP" url="http://www.lclnet.nl/update/">
       Spoofax/IMP update site
    </description>
-   <feature url="features/org.strategoxt.imp_0.5.3.qualifier.jar" id="org.strategoxt.imp" version="0.5.3.qualifier">
+   <feature url="features/org.strategoxt.imp_0.53.95.201012081616.jar" id="org.strategoxt.imp" version="0.53.95.201012081616">
       <category name="Spoofax/IMP"/>
    </feature>
    <category-def name="Spoofax/IMP" label="Spoofax/IMP">

From L.C.L.Kats at tudelft.nl  Wed Dec  8 18:51:43 2010
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Wed, 08 Dec 2010 17:51:43 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21474 -
	spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services
Message-ID: <201012081751.oB8Hphai025898@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: Wed Dec  8 17:51:42 2010
New Revision: 21474
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21474&sc=1

Log:
Spoofax/306: Builder concatenates list in output

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoBuilder.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoBuilder.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoBuilder.java	Wed Dec  8 15:22:32 2010	(r21473)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoBuilder.java	Wed Dec  8 17:51:42 2010	(r21474)
@@ -260,8 +260,6 @@
 
 	private String getResultString(IStrategoTerm resultTerm) {
 		resultTerm = termAt(resultTerm, 1);
-		resultTerm = try_1_0.instance.invoke(observer.getRuntime().getCompiledContext(),
-				resultTerm, concat_strings_0_0.instance);
 		
 		return isTermString(resultTerm) ? asJavaString(resultTerm) : ppATerm(resultTerm).stringValue();
 	}

From L.C.L.Kats at tudelft.nl  Thu Dec  9 11:27:29 2010
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Thu, 09 Dec 2010 10:27:29 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21475 - in
	spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime:
	dynamicloading services
Message-ID: <201012091027.oB9ARTq5006090@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: Thu Dec  9 10:27:28 2010
New Revision: 21475
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21475&sc=1

Log:
Use the plugin's own classloader for loading JARs.

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/Descriptor.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoObserver.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/Descriptor.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/Descriptor.java	Wed Dec  8 17:51:42 2010	(r21474)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/Descriptor.java	Thu Dec  9 10:27:28 2010	(r21475)
@@ -267,7 +267,7 @@
 	/**
 	 * Gets the class that provides access to any attached files in its enclosing JAR file.
 	 */
-	protected Class<?> getAttachmentProvider() {
+	public Class<?> getAttachmentProvider() {
 		try {
 			if (attachmentProvider == null)
 				attachmentProvider = createService(IParseController.class, null).getClass();

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoObserver.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoObserver.java	Wed Dec  8 17:51:42 2010	(r21474)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoObserver.java	Thu Dec  9 10:27:28 2010	(r21475)
@@ -223,7 +223,8 @@
 					file = fileCopier.copyToTempFile(file);
 				classpath[i] = file.toURI().toURL();
 			}
-			runtime.loadJars(classpath);
+			ClassLoader loader = descriptor.getAttachmentProvider().getClassLoader();
+			runtime.loadJars(loader, classpath);
 			Debug.stopTimer("Successfully loaded " + jars);
 		} catch (SecurityException e) {
 			reportLoadException(e, jars);

From L.C.L.Kats at tudelft.nl  Thu Dec  9 11:38:28 2010
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Thu, 09 Dec 2010 10:38:28 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21476 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib
Message-ID: <201012091038.oB9AcS61006198@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: Thu Dec  9 10:38:27 2010
New Revision: 21476
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21476&sc=1

Log:
Replaced Stratego-Attributes.def with the correct grammar.

Replaced:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Stratego-Attributes.def
      - copied unchanged from r21473, spoofax-imp/trunk/org.strategoxt.imp.editors.aster/syntax/Stratego-Attributes.def

Copied: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Stratego-Attributes.def (from r21473, spoofax-imp/trunk/org.strategoxt.imp.editors.aster/syntax/Stratego-Attributes.def)
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Stratego-Attributes.def	Thu Dec  9 10:38:27 2010	(r21476, copy of r21473, spoofax-imp/trunk/org.strategoxt.imp.editors.aster/syntax/Stratego-Attributes.def)
@@ -0,0 +1,1087 @@
+definition
+module ResultTerms
+
+imports
+  Stratego-Sugar
+
+exports %% RECOVERY RULES START HERE
+  lexical syntax
+      -> ";" {recover, cons("INSERTION")}
+
+exports
+
+  sorts
+    LineEnd
+    TermNoApp
+    ResultTerm
+    SingleLineLayout
+
+  context-free syntax
+
+    TermNoApp -> ResultTerm
+
+    Term                  -> TermNoApp
+    StrategyAngle         -> TermNoApp {reject}
+    "<" Strategy ">" Term -> TermNoApp {reject}
+
+  lexical syntax
+  
+    ShortCom -> SingleLineLayout
+    LongCom  -> SingleLineLayout
+    [\ \t]+  -> SingleLineLayout
+    [\n\r]   -> LineEnd
+    Eof      -> LineEnd
+  
+  syntax
+  
+    %% <s>\n -> RootApp
+    
+    <StrategyAngle-CF> <SingleLineLayout*-LEX> <LineEnd-CF> -> <ResultTerm-CF> {ast("RootApp(<1>)")}
+    
+    %% <s>A -> App
+    
+    "<" <LAYOUT?-CF> <Strategy-CF> <LAYOUT?-CF> ">" <SingleLineLayout*-LEX>
+        <Term-CF>                                                           -> <ResultTerm-CF> {ast("App(<1>, <3>)")}
+
+module Stratego-Sugar-Overlays
+imports
+  Stratego-Core-Identifiers
+  Stratego-Sugar-Terms
+
+exports
+  sorts Overlay
+  context-free syntax
+    Id 			 "=" Term 	-> Overlay {cons("OverlayNoArgs")}
+    Id "(" {Id ","}* ")" "=" Term 	-> Overlay {cons("Overlay")}
+
+module Stratego-Sugar-DynamicRules
+imports
+  Stratego-Core-Identifiers
+  Stratego-Sugar-Strategies
+  Stratego-Sugar-Rules
+
+exports
+ 
+  sorts ScopeLabels
+  context-free syntax
+
+    "{|" ScopeLabels ":" Strategy "|}" -> Strategy {cons("DynRuleScope")}
+
+    {DynRuleScopeId ","}*   -> ScopeLabels
+    "~" Term		    -> ScopeLabels {cons("ScopeLabels")}
+
+  sorts DynRuleDef DynRuleId DynRuleScopeId RuleDec
+  context-free syntax
+
+    "rules" "(" DynRuleDef* ")" -> Strategy {cons("GenDynRules")}
+
+    Id "+" Term                 -> DynRuleDef {cons("AddScopeLabel")} 
+    DynRuleId ":-"  Term        -> DynRuleDef {cons("UndefineDynRule")}
+    DynRuleId ":"   Rule        -> DynRuleDef {cons("SetDynRule")}
+    DynRuleId ":+"  Rule        -> DynRuleDef {cons("AddDynRule")}
+    DynRuleId ":"   Term        -> DynRuleDef {cons("SetDynRuleMatch")}
+
+    DynRuleId ":="  Term        -> DynRuleDef {cons("DynRuleAssign")}
+    DynRuleId ":+="  Term       -> DynRuleDef {cons("DynRuleAssignAdd")}
+
+    DynRuleId ":"   Rule "depends" "on" Term -> DynRuleDef {cons("SetDynRuleDepends")}
+
+    RuleDec "." Term            -> DynRuleId {cons("LabeledDynRuleId")}
+    RuleDec "+" Term            -> DynRuleId {cons("AddLabelDynRuleId")}
+    RuleDec                     -> DynRuleId {cons("DynRuleId")}
+
+    Id "." Term                 -> DynRuleScopeId {cons("LabeledDynRuleScopeId")}
+    Id                          -> DynRuleScopeId {cons("DynRuleScopeId")}
+
+  context-free syntax
+
+    Id                          -> RuleDec {cons("RDecNoArgs")}
+    Id "(" {Typedid ","}* ")"   -> RuleDec {cons("RDec")}
+    Id "(" {Typedid ","}* 
+       "|" {Typedid ","}* ")"   -> RuleDec {cons("RDecT")}
+
+  sorts RuleNames
+  context-free syntax
+    {Id ","}*				  -> RuleNames
+    "~" Term				  -> RuleNames {cons("RuleNames")}
+
+    "/" RuleNames "\\*" Strategy          -> Strategy {cons("DynRuleIntersectFix")}
+
+  syntax
+    %% no space after RuleNames
+    "\\" <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleUnionFix")}
+
+    %% 1 space after RuleNames
+    "\\" <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleUnionFix")}
+
+    %% no space after RuleNames
+    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
+        <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}
+
+    %% 1 space after RuleNames
+    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
+        <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}
+
+
+  context-free syntax
+    Strategy "/" RuleNames"\\" Strategy  -> Strategy {cons("DynRuleIntersect"),right}
+    Strategy "\\" RuleNames "/" Strategy  -> Strategy {cons("DynRuleUnion"),right}
+
+    Strategy "/" RuleNames "\\" 
+                 RuleNames "/"  Strategy  -> Strategy {cons("DynRuleIntersectUnion"),right}
+
+  priorities
+    <StrategyAngle-CF> <LAYOUT?-CF> <Term-CF> -> <Strategy-CF> {cons("BA")}
+  > {
+
+    %% no space after RuleNames
+    "\\" <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleUnionFix")}
+
+    %% 1 space after RuleNames
+    "\\" <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleUnionFix")}
+
+    %% no space after RuleNames
+    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
+        <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}
+
+    %% 1 space after RuleNames
+    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
+        <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}
+
+    }
+  > <Strategy-CF> <LAYOUT?-CF> "=>" <LAYOUT?-CF> <Term-CF> -> <Strategy-CF> {cons("AM")}
+
+  context-free priorities
+    StrategyAngle Term 		          -> Strategy {cons("BA")}
+  > "/" RuleNames "\\*" Strategy          -> Strategy {cons("DynRuleIntersectFix")}
+  > Strategy "=>" Term 		  	  -> Strategy {cons("AM")}
+  > Strategy "/" RuleNames "\\" Strategy  -> Strategy {cons("DynRuleIntersect"),right}
+  > Strategy "\\" RuleNames "/" Strategy  -> Strategy {cons("DynRuleUnion"),right}
+  > Strategy "/" RuleNames "\\" 
+                 RuleNames "/"  Strategy  -> Strategy {cons("DynRuleIntersectUnion"),right}
+  > Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
+
+module Stratego-Sugar-Rules
+imports Stratego-Sugar-Strategies
+exports
+
+  sorts RuleDef
+  context-free syntax
+    Id ":" Rule 				-> RuleDef {cons("RDefNoArgs")}
+    
+    Anno+ RuleDef               -> Def {cons("AnnoDef")}
+
+    Id "(" {Typedid ","}* ")" ":" Rule 		-> RuleDef {cons("RDef")}
+
+    Id "(" {Typedid ","}* 
+       "|" {Typedid ","}* ")" ":" Rule 		-> RuleDef {cons("RDefT")}
+
+  sorts Rule RuleCond
+  context-free syntax
+    Term "->" Term           	    -> Rule {cons("RuleNoCond")} %% backward comp.
+    Term "->" Term "where" Strategy -> Rule {cons("Rule")}       %% backward comp.
+    Term "->" Term RuleCond+	    -> Rule {cons("Rule"), avoid}
+
+    "where" Strategy -> RuleCond {cons("WhereClause")}
+    "with"  Strategy -> RuleCond {cons("WithClause")}
+
+module Stratego-Sugar-Strategies
+imports
+  Stratego-Core-Strategies
+  Stratego-Sugar-Terms
+  Stratego-Sugar-Constants
+  Stratego-Sugar-Signatures
+
+exports
+  context-free syntax
+    Id  		      "=" Strategy -> StrategyDef {cons("SDefNoArgs")}
+    Id "(" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("SDef")}
+
+  context-free syntax
+    ID 				  	  -> Typedid {cons("DefaultVarDec")}
+
+  sorts Rule
+
+  sorts StrategyParen StrategyCurly StrategyAngle
+  context-free syntax
+
+    %% Abstraction
+
+    SVar "(" {Strategy ","}* ")" 	  -> Strategy {cons("Call")}
+
+    %% Match and build
+
+    "{" Strategy "}" 			  -> Strategy {cons("ScopeDefault")}
+
+     %%"<" Strategy ">" Term 		  -> Strategy {cons("BA")}
+     StrategyAngle Term 		  -> Strategy {cons("BA")}
+     "<" Strategy ">"			  -> StrategyAngle {bracket} %% {cons("AngleStrat")}
+
+    %% Combinators
+
+    Strategy "<+" Strategy 		  -> Strategy {cons("LChoice"),right}
+
+    "rec" Id "(" Strategy ")" 		  -> Strategy {cons("Rec")}
+
+    "not"   "(" Strategy ")" 		  -> Strategy {cons("Not")}
+    "where" "(" Strategy ")" 		  -> Strategy {cons("Where")}
+    "with"  "(" Strategy ")" 		  -> Strategy {cons("With"), prefer}
+    "test"  "(" Strategy ")" 		  -> Strategy {cons("Test")}
+
+    %% Primitives
+
+    "prim" "(" String ")" 		  -> Strategy {cons("PrimNoArgs")}
+    "prim" "(" String "," {Term ","}* ")" -> Strategy {cons("Prim")}
+
+    %% Congruence operators
+
+    String 				  -> Strategy {cons("StrCong")}
+    Int 				  -> Strategy {cons("IntCong")}
+    Real 				  -> Strategy {cons("RealCong")}
+    Char 			 	  -> Strategy {cons("CharCong")}
+
+    String "(" {Strategy ","}* ")" 	  -> Strategy {cons("CongQ")}
+
+    %%"(" {Strategy ","}* ")" 		  -> Strategy {cons("TupleCong"),avoid}
+
+    Strategy StrategyCurly		  -> Strategy {cons("AnnoCong")}
+    
+    "{" Strategy "}"		  	  -> StrategyCurly {cons("StrategyCurly")}
+
+    "("  ")" 		  		  -> Strategy {cons("EmptyTupleCong")}
+   "(" Strategy  ")" 		          -> Strategy {bracket}
+    "(" Strategy "," {Strategy ","}+ ")"  -> Strategy {cons("TupleCong")}
+
+%%    Mod 	  			  -> Strategy {cons("ModCongNoArgs")}
+%%    Mod "(" {Strategy ","}* ")"	  	  -> Strategy {cons("ModCong")}
+%%    Id "^" Id				  -> Mod {cons("Mod")}
+    "[" {Strategy ","}* "]" 		  -> Strategy {cons("ListCongNoTail")}
+    "[" {Strategy ","}* "|" Strategy "]"  -> Strategy {cons("ListCong")}
+
+%%    Strategy "#" "(" StrategyInj ")" 	  -> Strategy {cons("ExplodeCong")}
+%%    Strategy "#" "(" Strategy ")" 	  -> Strategy {cons("ExplodeCong")}
+    Strategy "#" StrategyParen	  	  -> Strategy {cons("ExplodeCong")}
+
+  %% Syntactic sugar sugar
+
+  sorts SwitchCase
+  context-free syntax
+
+    SVar  		  		  -> Strategy {cons("CallNoArgs")}
+    "\\" Rule "\\" 			  -> Strategy {cons("LRule")}
+    "(" Rule ")" 			  -> Strategy {cons("SRule")}
+    Strategy "+" Strategy 		  -> Strategy {cons("Choice"),right} 
+    Strategy "+>" Strategy 		  -> Strategy {cons("RChoice"),right}
+
+    "proceed" "(" {Strategy "," }+ ")" -> Strategy {cons("Proceed"), prefer}
+
+    "if" Strategy "then" Strategy 
+                  "else" Strategy "end"   -> Strategy {cons("CondChoice")}
+    "if" Strategy "then" Strategy "end"   -> Strategy {cons("IfThen")}
+
+    "switch" Strategy SwitchCase* "end"   -> Strategy {cons("SwitchChoiceNoOtherwise")}
+    "switch" Strategy SwitchCase*
+         "otherwise" ":" Strategy "end"   -> Strategy {cons("SwitchChoice")}
+
+    "case" Strategy ":" Strategy          -> SwitchCase {cons("SwitchCase")}
+
+    Strategy "=>" Term 		  	  -> Strategy {cons("AM")}
+
+    Term ":=" Term			  -> Strategy {cons("Assign")}
+
+  %% Priorities
+
+  context-free priorities
+    { Strategy StrategyCurly		  -> Strategy
+      Strategy "#" StrategyParen          -> Strategy
+    }
+  > { "!" Term 				  -> Strategy
+      "?" Term 				  -> Strategy
+    }
+  > StrategyAngle Term 		          -> Strategy
+  > Strategy "=>" Term 		  	  -> Strategy
+  > Strategy ";" Strategy 		  -> Strategy
+  > {right: 
+     Strategy "+" Strategy 		  -> Strategy
+     Strategy "<+" Strategy 		  -> Strategy
+     Strategy "+>" Strategy 		  -> Strategy
+     
+     Strategy "<" StrategyMid 
+              "+" Strategy 		  -> Strategy
+    }
+
+  context-free priorities
+    Strategy 				  -> StrategyMid
+  > Strategy "+" Strategy 		  -> Strategy
+
+  context-free priorities
+    { Strategy StrategyCurly      -> Strategy
+      Strategy "#" StrategyParen  -> Strategy
+    }
+    .> Term ":=" Term -> Strategy
+
+
+module Stratego-Sugar-Terms
+imports
+  Stratego-Core-Terms
+  Stratego-Sugar-Strategies
+
+exports
+  sorts LID
+  context-free syntax
+    LId 			-> LID  {cons("ListVar")}
+    LID				-> Var  {cons("Var")}
+    LID				-> ID
+
+  context-free syntax
+    "_" PreTerm 		 -> PreTerm {cons("BuildDefaultPT")}
+    "_" Term 			 -> Term {cons("BuildDefault"),prefer}
+
+    Char 			 -> PreTerm {cons("Char")}
+
+    PreTerm "{" {Term ","}* "}"	 -> Term {cons("AnnoList")}
+    PreTerm                      -> Term {cons("NoAnnoList")}
+
+    "<" Strategy ">" Term 	 -> PreTerm {cons("App")}
+    "<" Strategy ">" Term 	 -> Term {cons("App"),prefer}
+
+    StrategyAngle		 -> PreTerm {cons("RootApp")}
+    StrategyAngle		 -> Term {cons("RootApp"),prefer}
+
+    "(" {Term ","}* ")" 	 -> PreTerm {cons("Tuple")}
+    "[" {Term ","}* "]" 	 -> PreTerm {cons("List")}
+    "[" {Term ","}* "|" Term "]" -> PreTerm {cons("ListTail")}
+
+  context-free priorities
+    Term "#" "(" Term ")" 	 -> PreTerm {cons("Explode")}
+  > PreTerm "{" {Term ","}* "}"	 -> Term {cons("AnnoList")}
+  > Var "@" Term 		 -> Term {cons("As")}
+
+module Stratego-Sugar-Signatures
+imports
+  Stratego-Core-Signatures
+  Stratego-Sugar-Constants
+
+exports
+
+  sorts Sort
+  context-free syntax
+    "[" {Sort ","}* "]"		 -> Sort {cons("SortList")}
+    "[" {Sort ","}* "|" Sort "]" -> Sort {cons("SortListTl")}
+    "(" {Sort ","}* ")"		 -> Sort {cons("SortTuple")}
+
+  sorts Kind
+  context-free syntax
+    "*" 			-> Kind {cons("Star")}
+    "**" 			-> Kind {cons("StarStar")}
+
+module Stratego-Core-Signatures
+imports
+  Stratego-Core-Identifiers
+  Stratego-Core-Constants
+exports
+  sorts Sdecl
+  context-free syntax
+    "sorts" Sort* 		-> Sdecl {cons("Sorts")}
+    "constructors" Opdecl* 	-> Sdecl {cons("Constructors")}
+
+  sorts Sort
+  context-free syntax
+    LCID 			 -> Sort {cons("SortVar")}
+    UCID 			 -> Sort {cons("SortNoArgs")}
+    Id "(" {Sort ","}* ")" 	 -> Sort {cons("Sort")}
+
+  sorts Opdecl
+  context-free syntax
+    Id     ":" Type 		-> Opdecl {cons("OpDecl")}
+    String ":" Type 		-> Opdecl {cons("OpDeclQ")}
+           ":" Type 		-> Opdecl {cons("OpDeclInj")}
+
+  context-free syntax
+    "external" Id     ":" Type 	-> Opdecl {cons("ExtOpDecl")}
+    "external" String ":" Type 	-> Opdecl {cons("ExtOpDeclQ")}
+    "external"        ":" Type 	-> Opdecl {cons("ExtOpDeclInj")}
+
+  sorts Type ArgType ConstType FunType RetType
+  context-free syntax
+    Sort	                -> ConstType {cons("ConstType")}
+    {ArgType "*"}+ "->" RetType -> FunType {cons("FunType")}
+    "(" Type ")"                -> ArgType {bracket}
+    ConstType			-> ArgType
+    Type	                -> RetType
+    FunType			-> RetType {reject}
+
+    FunType			-> Type
+    ConstType			-> Type
+
+  %%%
+   %% Restriction is required for the Sort* in Sdecl: List(a) is
+   %% ambiguous.
+   %%%
+  context-free restrictions
+    Sort -/- [\(]
+
+module Stratego-Core-Terms
+imports
+  Stratego-Core-Identifiers
+  Stratego-Core-Constants
+
+exports
+  sorts ID Var Wld
+  context-free syntax
+    Id 				-> Var  {cons("Var")}
+    Id				-> ID
+    %% ":" Var                  -> Var  {cons("SeqVar")}
+
+  sorts Term PreTerm
+  context-free syntax
+    Var 			 -> PreTerm 
+    Var 			 -> Term {prefer}
+
+    "_" 			 -> Wld {cons("Wld")}
+    Wld 			 -> PreTerm
+    Wld 			 -> Term {prefer}
+
+    Int 			 -> PreTerm {cons("Int")}
+    Real 			 -> PreTerm {cons("Real")}
+    String 			 -> PreTerm {cons("Str")}
+
+    Id "(" {Term ","}* ")" 	 -> PreTerm {cons("Op")}
+    String "(" {Term ","}* ")" 	 -> PreTerm {cons("OpQ")}
+    Term "#" "(" Term ")" 	 -> PreTerm {cons("Explode")}
+
+    PreTerm "{^" PreTerm "}"	 -> Term {cons("Anno")}
+
+    Var "@" Term 		 -> Term {cons("As"),prefer}
+    Var "@" PreTerm 		 -> PreTerm {cons("As")}
+
+  context-free priorities
+    Term "#" "(" Term ")" 	 -> PreTerm {cons("Explode")}
+  > Var "@" Term 		 -> Term {cons("As")}
+
+module Stratego-Core-Strategies
+imports
+  Stratego-Core-Terms
+  Stratego-Core-Constants
+  Stratego-Core-Signatures
+
+exports
+  sorts Def
+  context-free syntax
+    StrategyDef					 -> Def 
+    Id						 -> SVar {cons("SVar")}
+    "let" Def* "in" Strategy "end"		 -> Strategy {cons("Let")}
+    SVar "(" {Strategy ","}* "|" {Term ","}* ")" -> Strategy {cons("CallT")}
+
+    "call" "(" Term "|" {Strategy ","}* "|" {Term ","}* ")" -> Strategy {cons("CallDynamic")}
+
+
+  sorts StrategyDef
+  context-free syntax
+    Id "(" {Typedid ","}* 
+       "|" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("SDefT")}
+
+    Anno+ StrategyDef -> Def {cons("AnnoDef")}
+
+    "external"
+    Id "(" {Typedid ","}* 
+       "|" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("ExtSDefInl")}
+
+    "external"
+    Id "(" {Typedid ","}* 
+       "|" {Typedid ","}* ")"		   -> StrategyDef {cons("ExtSDef")}
+
+    "external"
+    EmptyId "(" {Typedid ","}* 
+       "|" {Typedid ","}* ")"		   -> StrategyDef {cons("ExtSDef")}
+
+
+  sorts EmptyId
+  lexical syntax
+  
+    -> EmptyId
+
+  sorts Anno
+  context-free syntax
+    "extend"      -> Anno {cons("Extend")}
+    "override"    -> Anno {cons("Override")}
+    "internal"    -> Anno {cons("Internal")}
+%%  "sealed"      -> Anno {cons("Sealed")}
+%%  "extensible"  -> Anno {cons("Extensible")}
+%%  "overridable" -> Anno {cons("Overridable")}
+
+  lexical syntax
+    
+    "extend"      -> Keyword
+    "override"    -> Keyword
+    "internal"    -> Keyword
+    "sealed"      -> Keyword
+    "extensible"  -> Keyword
+    "overridable" -> Keyword
+
+  lexical restrictions
+  
+    "extend"
+    "override"
+    "internal"
+    "sealed"
+    "extensible"
+    "overridable" -/- [a-zA-Z0-9\'\-\_]
+
+  sorts Typedid
+  context-free syntax
+    ID ":" Type 			  -> Typedid {cons("VarDec")}
+
+
+  sorts Strategy SVar StrategyParen StrategyMid 
+  context-free syntax
+    "(" Strategy ")"			  -> StrategyParen {cons("ParenStrat")}
+
+    "fail" 				  -> Strategy {cons("Fail")}
+    "id" 				  -> Strategy {cons("Id")}
+
+    "proceed" "(" {Strategy ","}* "|" {Term ","}* ")" -> Strategy {cons("ProceedT"), prefer}
+    "proceed"                                         -> Strategy {cons("ProceedNoArgs"), prefer}
+
+    %% Match and build
+
+    "?" Term 				  -> Strategy {cons("Match")}
+    "!" Term 				  -> Strategy {cons("Build")}
+    "{" {ID ","}* ":" Strategy "}" 	  -> Strategy {cons("Scope")}
+
+    %% Combinators
+
+    Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
+    Strategy "<" StrategyMid 
+             "+" Strategy 		  -> Strategy {cons("GuardedLChoice"),right}
+    Strategy 				  -> StrategyMid
+
+    %% Primitives
+
+    "prim" "(" String "," {Strategy ","}* "|" {Term ","}*")"  -> Strategy {cons("PrimT")}
+
+    %% Traversal
+
+    "some" "(" Strategy ")" 		  -> Strategy {cons("Some")}
+    "one" "(" Strategy ")" 		  -> Strategy {cons("One")}
+    "all" "(" Strategy ")" 		  -> Strategy {cons("All")}
+
+  %% Priorities
+
+  context-free priorities
+    { "!" Term 				  -> Strategy {cons("Build")}
+      "?" Term 				  -> Strategy {cons("Match")}
+    }
+  > Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
+  > {right: 
+     Strategy "<" StrategyMid 
+              "+" Strategy 		  -> Strategy {cons("GuardedLChoice"),right}
+    }
+
+  context-free syntax
+    "import-term" "(" ModName ")" -> Strategy {cons("ImportTerm")}
+
+module Stratego-Core-Modules
+imports
+  Stratego-Core-Identifiers
+  Stratego-Core-Strategies
+  Stratego-Core-Signatures
+
+exports 
+  sorts Module
+  context-free syntax
+    "module" ModName Decl* 	 -> Module {cons("Module")}
+    "specification" Decl*	 -> Module {cons("Specification")}
+
+  sorts Decl 
+  context-free syntax
+    "imports" ImportModName* 	-> Decl {cons("Imports")}
+    "strategies" Def* 		-> Decl {cons("Strategies")}
+    "signature" Sdecl*  	-> Decl {cons("Signature")}
+
+  sorts ImportModName
+  context-free syntax
+    ModName              -> ImportModName {cons("Import")}
+  syntax
+    <ModName-CF> "/" "-" -> <ImportModName-CF> {cons("ImportWildcard")}
+
+module Stratego-Sugar-Modules
+imports
+  Stratego-Core-Modules
+  Stratego-Sugar-Strategies
+  Stratego-Sugar-Signatures
+  Stratego-Sugar-Overlays
+  Stratego-Sugar-Rules
+
+exports 
+
+  sorts Decl Def
+  context-free syntax
+    "rules" Def* 		-> Decl {cons("Rules")}
+    "overlays" Overlay* 	-> Decl {cons("Overlays")}
+
+    RuleDef 			-> Def 
+
+
+module Stratego-Sugar-StringQuotations
+exports
+
+  sorts
+    StringQuotation
+    StringQuotedPart1 StringQuotedChars1 DollarOpen1 DollarClose1 QuotedBracket1 Dollar1
+    StringQuotedPart2 StringQuotedChars2 DollarOpen2 DollarClose2 QuotedBracket2 Dollar2
+    StringQuotedPart3 StringQuotedChars3 DollarOpen3 DollarClose3 QuotedBracket3 Dollar3
+    StringQuotedPart4 StringQuotedChars4 DollarOpen4 DollarClose4 QuotedBracket4  Dollar4
+    Padding
+
+  context-free syntax
+
+    StringQuotation -> PreTerm
+
+  syntax
+
+    StringQuotation -> <PreTerm-CF>
+
+    "$" "[" Padding StringQuotedPart1*               "]"    -> StringQuotation {cons("StringQuotation1") }
+     Padding "[" <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> "]"    -> StringQuotedPart1 {cons("StringEscape1")}
+    <StringQuotedChars1-LEX>                                -> StringQuotedPart1 {cons("QStr")}
+    <Dollar1-LEX>                                           -> StringQuotedPart1 {cons("QDollar")}
+    "$" <QuotedBracket1-LEX> "$"                            -> StringQuotedPart1 {cons("QBr")}
+    ~[\[\]\$]+                                              -> <StringQuotedChars1-LEX>
+    [\[\]]                                                  -> <QuotedBracket1-LEX>
+    "$"                                                     -> <Dollar1-LEX>
+
+    "$" "{" Padding StringQuotedPart2*               "}"    -> StringQuotation {cons("StringQuotation2") }
+     Padding "{" <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> "}"    -> StringQuotedPart2 {cons("StringEscape2")}
+    <StringQuotedChars2-LEX>                                -> StringQuotedPart2 {cons("QStr")}
+    <Dollar2-LEX>                                           -> StringQuotedPart2 {cons("QDollar")}
+    "$" <QuotedBracket2-LEX> "$"                            -> StringQuotedPart2 {cons("QBr")}
+    ~[\{\}\$]+                                              -> <StringQuotedChars2-LEX>
+    [\{\}]                                                  -> <QuotedBracket2-LEX>
+    "$"                                                     -> <Dollar2-LEX>
+
+    "$" "(" Padding StringQuotedPart3*              ")"     -> StringQuotation {cons("StringQuotation3") }
+    Padding "(" <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> ")"     -> StringQuotedPart3 {cons("StringEscape3")}
+    <StringQuotedChars3-LEX>                                -> StringQuotedPart3 {cons("QStr")}
+    <Dollar3-LEX>                                           -> StringQuotedPart3 {cons("QDollar")}
+    "$" <QuotedBracket3-LEX> "$"                            -> StringQuotedPart3 {cons("QBr")}
+    ~[\(\)\$]+                                              -> <StringQuotedChars3-LEX>
+    [\(\)]                                                  -> <QuotedBracket3-LEX>
+    "$"                                                     -> <Dollar3-LEX>
+
+    "$" "<" Padding StringQuotedPart4*               ">"    -> StringQuotation {cons("StringQuotation4") }
+    Padding "<"  <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> ">"    -> StringQuotedPart4 {cons("StringEscape4")}
+    <StringQuotedChars4-LEX>                                -> StringQuotedPart4 {cons("QStr")}
+    <Dollar4-LEX>                                           -> StringQuotedPart4 {cons("QDollar")}
+    "$" <QuotedBracket4-LEX> "$"                            -> StringQuotedPart4 {cons("QBr")}
+    ~[\<\>\$]+                                              -> <StringQuotedChars4-LEX>
+    [\<\>]                                                  -> <QuotedBracket4-LEX>
+    "$"                                                     -> <Dollar4-LEX>
+   
+    %% Padding is a dummy lexical that will contain the indentation prefix of every quotation
+    <Padding-LEX>                                           -> Padding
+                                                            -> <Padding-LEX> {indentpadding}
+
+  lexical restrictions
+
+    StringQuotedChars1 -/- ~[\[\]\$]   
+    StringQuotedChars2 -/- ~[\{\}\$]    
+    StringQuotedChars3 -/- ~[\(\)\$]    
+    StringQuotedChars4 -/- ~[\<\>\$]
+    Dollar1            -/- [\[\]] . [\$]
+    Dollar2            -/- [\{\}] . [\$]
+    Dollar3            -/- [\(\)] . [\$]
+    Dollar4            -/- [\<\>] . [\$]
+
+module Stratego-Core-Constants
+exports
+  sorts Int Real String StrChar
+  lexical syntax
+    [\-]? [0-9]+ 		-> Int
+    [\-]? [0-9]+ [\.] [0-9]+ 	-> Real
+    "\"" StrChar* "\"" 		-> String
+    ~[\"\\] 			-> StrChar
+    [\\] [\"tnr\\] 		-> StrChar
+
+
+module Stratego-Sugar-Constants
+imports
+  Stratego-Core-Identifiers
+  Stratego-Core-Constants
+  Stratego-Sugar-StringQuotations
+exports
+  sorts Char CharChar
+  lexical syntax
+    "'" CharChar "'"		-> Char
+    ~[\']			-> CharChar
+    [\\] [\'ntr\ ]		-> CharChar
+    Char		 	-> Id {reject}
+
+module Stratego-Core-Identifiers
+exports
+  sorts ModName ModNamePart
+  lexical syntax
+    {ModNamePart "/"}+ -> ModName
+    [a-zA-Z\.\_] [a-zA-Z0-9\'\.\-\_]* -> ModNamePart
+  lexical restrictions
+    ModName -/- [a-zA-Z0-9\'\.\-\_]
+  lexical syntax
+    "imports" 		-> ModName {reject}
+    "overlays" 		-> ModName {reject}
+    "rules" 		-> ModName {reject}
+    "signature" 	-> ModName {reject}
+    "strategies" 	-> ModName {reject}
+
+  sorts Id LId LCID UCID Wld
+  lexical syntax
+    [a-zA-Z\_] [a-zA-Z0-9\'\-\_]*     -> Id
+    [a-zA-Z\_] [a-zA-Z0-9\'\-\_]* "*" -> LId
+    [\'] [a-z]+                       -> Id
+
+    [a-z] [a-zA-Z0-9\'\-\_]*  -> LCID
+    [A-Z] [a-zA-Z0-9\'\-\_]*  -> UCID
+
+  lexical restrictions
+    Id   -/- [a-zA-Z0-9\'\_\*]
+    Id   -/- [\-].~[\>]
+    LId  -/- [a-zA-Z0-9\'\-\_]
+    LCID -/- [a-zA-Z0-9\'\-\_]
+    UCID -/- [a-zA-Z0-9\'\-\_]
+
+  lexical syntax
+    "_"     -> Id {reject}
+    "'"     -> Id {reject}
+
+    Keyword -> Id   {reject}
+    Keyword -> LId  {reject}
+    Keyword -> LCID {reject}
+    Keyword -> UCID {reject}
+
+  lexical restrictions
+    "all"
+    "case" %% not reserved kw
+    "constructors"
+    "else" %% not reserved kw
+    "end" %% not reserved kw
+    "external" %% not reserved kw
+    "fail"
+    "id"
+    "if" %% not reserved kw
+    "in"
+    "imports" %% not reserved kw
+    "let"
+    "module"
+    "not"
+    "one"
+    "overlays"
+    "otherwise" %% not reserved kw
+    "prim"
+    "rec" %% not reserved kw
+    "rules"
+    "script"
+    "signature"
+    "some"
+    "sorts"
+    "strategies"
+    "stratego"
+    "switch" %% not reserved kw
+    "test"
+    "then" %% not reserved kw
+    "where"
+    "import-term"
+      -/- [a-zA-Z0-9\'\-\_]
+  
+  context-free restrictions
+    Wld -/- [a-zA-Z0-9\'\-\_]
+
+  sorts Keyword
+  lexical syntax
+    "all"               -> Keyword
+    "constructors" 	-> Keyword
+    "fail" 		-> Keyword
+    "id" 		-> Keyword
+    "in" 		-> Keyword
+    "let" 		-> Keyword
+    "module" 		-> Keyword
+    "not" 		-> Keyword
+    "one" 		-> Keyword
+    "overlays" 		-> Keyword
+    "prim" 		-> Keyword
+    "rules" 		-> Keyword
+    "script" 		-> Keyword
+    "signature" 	-> Keyword
+    "some" 		-> Keyword
+    "sorts" 		-> Keyword
+    "strategies" 	-> Keyword
+    "stratego" 		-> Keyword
+    "test" 		-> Keyword
+    "where" 		-> Keyword
+    "import-term"	-> Keyword
+
+
+module Stratego-Core-Layout
+exports
+  sorts Ws ShortCom LongCom CommChar Asterisk Eof 
+  lexical syntax
+    [\t\ \n\r]			-> Ws
+
+    "//" ~[\n]* ([\n] | Eof)	-> ShortCom
+    "/*" CommChar* "*/"	-> LongCom
+				-> Eof  
+
+    ~[\*]     -> CommChar
+
+    "*"       -> Asterisk
+    Asterisk  -> CommChar
+
+  lexical restrictions
+    Asterisk -/- [\/]
+    Eof      -/- ~[]
+
+  lexical syntax
+    ShortCom 	-> LAYOUT
+    LongCom 	-> LAYOUT
+    Ws 		-> LAYOUT
+
+  context-free restrictions
+    LAYOUT? -/- [\ \t\n\r]
+    LAYOUT? -/- [\/].[\*]
+    LAYOUT? -/- [\/].[\/]
+
+module Stratego-Sugar-Layout
+imports Stratego-Core-Layout
+%%exports
+%%  sorts VeryLongCom Eof VLCchar Backslash
+%%  lexical syntax
+%%    "\\end{code}" VLCchar* "\\begin{code}" -> VeryLongCom
+%%    "\\begin{code}" 			   -> VeryLongCom
+%%    "\\end{code}" VLCchar* Eof 		   -> VeryLongCom
+%%    "\\literate" VLCchar* "\\begin{code}"  -> VeryLongCom
+%%    ~[\\] 				   -> VLCchar
+%%    Backslash 				   -> VLCchar
+%%    [\\] 				   -> Backslash
+
+%%  lexical restrictions
+%%    Backslash -/- [b].[e].[g].[i].[n].[\{].[c].[o].[d].[e].[\}]
+%%    Eof -/- ~[]
+
+%%  lexical syntax
+%%    VeryLongCom -> LAYOUT
+
+
+
+module Stratego-Sugar
+imports
+  Stratego-Sugar-Layout
+  Stratego-Core-Identifiers
+  Stratego-Sugar-Constants 
+  Stratego-Sugar-Modules
+  Stratego-Sugar-Signatures
+  Stratego-Sugar-Terms
+  Stratego-Sugar-Strategies
+  Stratego-Sugar-Rules
+  Stratego-Sugar-DynamicRules
+  Stratego-Sugar-Overlays
+
+hiddens
+  context-free start-symbols Module
+
+module Stratego-Attributes
+
+imports
+  Stratego-Sugar
+  ResultTerms
+
+hiddens
+  context-free start-symbols
+    Module
+    Decl
+
+exports
+  sorts
+    DefType
+    Pattern
+    ADef
+    AttributeDef
+    AttributeRef
+    AttributeCall
+    AttributeCallLHS
+    AttributeDecl
+    AttributeType
+    AttributeTypeNoSort
+    DecoratorRef
+    DecoratorRefNoArgs
+    DecoratorId
+    AttributeKeyword
+    ChildDot
+    DotChild
+    AttributeId
+    AttributeDeclId
+    OptChildDot
+    OptDotChild
+    OptSortDot
+    NoSortDot
+    AttributeNameValue
+    NameDefBlockDef
+    PatternDefBlockDef
+    Where
+    NoWhere
+    UNDEFINED %% matches nothing
+  
+  lexical syntax
+  
+    %% Unreserve some Id's specifically for (built-in) attributes
+
+    "all"       -> AttributeId
+    "one"       -> AttributeId
+    "some"      -> AttributeId
+    "test"      -> AttributeId
+    "in"        -> AttributeId
+    "signature" -> AttributeId
+  
+  context-free restrictions
+  
+    AttributeId -/- [a-zA-Z0-9\'\-\_\*]
+
+    DecoratorRefNoArgs -/- [\(]  %% decorator(arg,y) vs. decorator (tuple, y)
+  
+  context-free syntax %% identifiers
+  
+    Id               -> AttributeId {prefer}
+  
+    AttributeId      -> AttributeDeclId
+    AttributeKeyword -> AttributeDeclId {reject}
+
+    AttributeId      -> DecoratorId
+    "*"              -> DecoratorId
+    "plain"          -> DecoratorId {prefer} %% treat as keyword
+    AttributeKeyword -> DecoratorId {reject}
+  
+  context-free syntax %% attributes
+    
+    AttributeDeclId "(" { Typedid "," }* "|" { Term "," }* ")" -> AttributeDecl {cons("Attribute")}
+    AttributeDeclId "(" { Typedid "," }*                   ")" -> AttributeDecl {cons("AttributeNoTerms")}
+    AttributeDeclId                                            -> AttributeDecl {cons("AttributeNoArgs")}
+    
+    AttributeId "(" { Typedid "," }* "|" { Term "," }* ")" -> AttributeDef {cons("Attribute")}
+    AttributeId "(" { Typedid "," }*                   ")" -> AttributeDef {cons("AttributeNoTerms")}
+    AttributeId                                            -> AttributeDef {cons("AttributeNoArgs")}
+    
+    AttributeId "(" { Strategy "," }* "|" { Term "," }* ")" -> AttributeRef {cons("Attribute")}
+    AttributeId "(" { Strategy "," }*                   ")" -> AttributeRef {cons("AttributeNoTerms")}
+    AttributeId                                             -> AttributeRef {cons("AttributeNoArgs")}
+    
+    DecoratorId "(" { Strategy "," }* "|" { Term "," }* ")" -> DecoratorRef {cons("Decorator")}
+    DecoratorId "(" { Strategy "," }*                   ")" -> DecoratorRef {cons("DecoratorNoTerms")}
+    DecoratorRefNoArgs                                      -> DecoratorRef
+    DecoratorId                                             -> DecoratorRefNoArgs {cons("DecoratorNoArgs")}
+
+    AttributeCallLHS "." AttributeRef -> AttributeCall {cons("AttributeRef")}
+    Term                              -> AttributeCallLHS
+    "<" Strategy ">" Term             -> AttributeCallLHS {reject}
+    
+    AttributeCall -> Strategy {prefer}
+    AttributeCall -> PreTerm {cons("AttributeTerm")}
+   
+  context-free syntax %% attribute equations: core syntax
+
+    "attributes" ADef* -> Decl {cons("Attributes")}
+
+    AttributeType { AttributeDecl "," }+               -> ADef {cons("ADecl")}
+    AttributeTypeNoSort Pattern "." AttributeNameValue -> ADef {cons("ADef")}
+    
+    DefType DecoratorRef* OptSortDot -> AttributeType {cons("Type")}
+    DefType DecoratorRef* NoSortDot  -> AttributeTypeNoSort {cons("Type")}
+    
+    OptChildDot AttributeDef "="  Strategy -> AttributeNameValue {cons("ADefStrategy")}
+    
+    "eq"        -> DefType {cons("Eq")}
+    "def"       -> DefType {cons("Def")}
+    "decorator" -> DefType {cons("Decorator")}
+    
+    Id "."     -> ChildDot {cons("Child")}
+    "." Id     -> DotChild {cons("DotChild")}
+    "id" "."   -> ChildDot {cons("IdChild"), prefer}    %% sugar
+    "." "id"   -> DotChild {cons("DotIdChild"), prefer} %% sugar
+    "root" "." -> ChildDot {reject}                     %% confusing
+    "." "root" -> DotChild {reject}                     %% confusing
+    
+    ChildDot   -> OptChildDot
+               -> OptChildDot {cons("NoChild")}
+    DotChild   -> OptDotChild
+               -> OptDotChild {cons("NoChild")}
+    
+    Sort "." -> OptSortDot {cons("Sort")}
+             -> OptSortDot {cons("NoSort")}
+             -> NoSortDot {cons("NoSort")}
+    
+    Term             -> Pattern
+    AttributeKeyword -> Pattern {reject}
+    AttributeCall    -> Pattern {reject}
+    "root"           -> Pattern {cons("Root"), prefer}
+
+  context-free syntax %% attribute equations: syntactic sugar
+ 
+    "decorators" ADef* -> Decl {cons("Decorators")}
+
+    %% Single-line attribute definitions
+    AttributeTypeNoSort AttributeNameValue    -> ADef {cons("ADefNoPattern"), avoid}
+    OptChildDot AttributeDef ":=" Term Where* -> AttributeNameValue {cons("ADefTerm")}
+    
+    %% Attribute definition blocks/groups
+    AttributeType Pattern      ":" NameDefBlockDef+    -> ADef {cons("NameDefBlock")}
+    AttributeType AttributeDef ":" PatternDefBlockDef+ -> ADef {cons("PatternDefBlock")}
+    
+    %% Definitions grouped in a NameDefBlock
+    ChildDot AttributeDef ":=" Term     Where* -> NameDefBlockDef {cons("ADefTerm")}
+    ChildDot AttributeDef "="  Strategy        -> NameDefBlockDef {cons("ADefStrategy")}
+
+    %% Definitions grouped in a PatternDefBlock
+    Pattern OptDotChild "->" ResultTerm NoWhere* -> PatternDefBlockDef {cons("APDefTerm")}
+    Pattern OptDotChild "->" Term       Where+   -> PatternDefBlockDef {cons("APDefTerm")}
+
+    "where" Strategy -> Where {cons("Where")}
+    "with" Strategy  -> Where {cons("With")}
+    UNDEFINED        -> NoWhere
+
+  context-free syntax %% Misc.
+    
+    "rewrite" Pattern "->" Term Where* -> ADef {cons("AnonymousRewriteRule")}
+      
+    "id"   -> PreTerm {cons("IdTerm")}
+    "fail" -> Term {cons("FailTerm")}
+
+  context-free syntax
+
+    %%  Either reject suffices, but the first may be too specific/confusing
+    %%  "<" Strategy ">" AttributeKeyword -> Term {reject}
+    AttributeKeyword -> Var {reject}
+    
+    AttributeKeyword -> ImportModName {reject}
+  
+  lexical syntax
+    
+    "eq"         -> AttributeKeyword
+    "def"        -> AttributeKeyword
+    "attributes" -> AttributeKeyword
+    "decorators" -> AttributeKeyword
+    "decorator"  -> AttributeKeyword
+    "rewrite"    -> AttributeKeyword
+  
+  context-free restrictions
+  
+    "eq"
+    "def"
+    "root"
+    "rewrite"
+    "decorator"
+    "decorators"
+    "attributes" -/- [a-zA-Z0-9\'\-\_]

From r.t.lindeman at student.tudelft.nl  Thu Dec  9 12:03:50 2010
From: r.t.lindeman at student.tudelft.nl (Ricky Lindeman)
Date: Thu, 09 Dec 2010 11:03:50 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21477 - in
	spoofax-imp/trunk: org.strategoxt.imp.debug.core/.settings
	org.strategoxt.imp.debug.core/lib
	org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/mode...
Message-ID: <201012091103.oB9B3okI006914@proliant.st.ewi.tudelft.nl>

Author: RickyLindeman
Date: Thu Dec  9 11:03:49 2010
New Revision: 21477
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21477&sc=1

Log:
* added stepping functionality to eclipse plugin, but the calls are not GUI thread safe
 * added project specific compiler settings

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.debug.core/.settings/org.eclipse.jdt.core.prefs
   spoofax-imp/trunk/org.strategoxt.imp.debug.core/lib/stratego-debug-core.jar
   spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/StrategoDebugTarget.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/StrategoThread.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/.settings/org.eclipse.jdt.core.prefs
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.runtime/.settings/org.eclipse.jdt.core.prefs
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/.settings/org.eclipse.jdt.core.prefs
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/.settings/org.eclipse.jdt.core.prefs
   spoofax-imp/trunk/org.strategoxt.imp.debug.ui/.settings/org.eclipse.jdt.core.prefs

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.core/.settings/org.eclipse.jdt.core.prefs
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.core/.settings/org.eclipse.jdt.core.prefs	Thu Dec  9 10:38:27 2010	(r21476)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.core/.settings/org.eclipse.jdt.core.prefs	Thu Dec  9 11:03:49 2010	(r21477)
@@ -1,8 +1,74 @@
-#Wed Oct 06 14:28:44 CEST 2010
+#Thu Dec 09 12:00:57 CET 2010
 eclipse.preferences.version=1
 org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
 org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.5
+org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
 org.eclipse.jdt.core.compiler.compliance=1.5
+org.eclipse.jdt.core.compiler.debug.lineNumber=generate
+org.eclipse.jdt.core.compiler.debug.localVariable=generate
+org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.annotationSuperInterface=warning
 org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.autoboxing=ignore
+org.eclipse.jdt.core.compiler.problem.comparingIdentical=warning
+org.eclipse.jdt.core.compiler.problem.deadCode=warning
+org.eclipse.jdt.core.compiler.problem.deprecation=warning
+org.eclipse.jdt.core.compiler.problem.deprecationInDeprecatedCode=disabled
+org.eclipse.jdt.core.compiler.problem.deprecationWhenOverridingDeprecatedMethod=disabled
+org.eclipse.jdt.core.compiler.problem.discouragedReference=warning
+org.eclipse.jdt.core.compiler.problem.emptyStatement=ignore
 org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.problem.fallthroughCase=ignore
+org.eclipse.jdt.core.compiler.problem.fatalOptionalError=enabled
+org.eclipse.jdt.core.compiler.problem.fieldHiding=ignore
+org.eclipse.jdt.core.compiler.problem.finalParameterBound=warning
+org.eclipse.jdt.core.compiler.problem.finallyBlockNotCompletingNormally=warning
+org.eclipse.jdt.core.compiler.problem.forbiddenReference=error
+org.eclipse.jdt.core.compiler.problem.hiddenCatchBlock=warning
+org.eclipse.jdt.core.compiler.problem.incompatibleNonInheritedInterfaceMethod=warning
+org.eclipse.jdt.core.compiler.problem.incompleteEnumSwitch=ignore
+org.eclipse.jdt.core.compiler.problem.indirectStaticAccess=ignore
+org.eclipse.jdt.core.compiler.problem.localVariableHiding=ignore
+org.eclipse.jdt.core.compiler.problem.methodWithConstructorName=warning
+org.eclipse.jdt.core.compiler.problem.missingDeprecatedAnnotation=ignore
+org.eclipse.jdt.core.compiler.problem.missingHashCodeMethod=ignore
+org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotation=ignore
+org.eclipse.jdt.core.compiler.problem.missingSerialVersion=warning
+org.eclipse.jdt.core.compiler.problem.missingSynchronizedOnInheritedMethod=ignore
+org.eclipse.jdt.core.compiler.problem.noEffectAssignment=warning
+org.eclipse.jdt.core.compiler.problem.noImplicitStringConversion=warning
+org.eclipse.jdt.core.compiler.problem.nonExternalizedStringLiteral=ignore
+org.eclipse.jdt.core.compiler.problem.nullReference=warning
+org.eclipse.jdt.core.compiler.problem.overridingPackageDefaultMethod=warning
+org.eclipse.jdt.core.compiler.problem.parameterAssignment=ignore
+org.eclipse.jdt.core.compiler.problem.possibleAccidentalBooleanAssignment=ignore
+org.eclipse.jdt.core.compiler.problem.potentialNullReference=ignore
+org.eclipse.jdt.core.compiler.problem.rawTypeReference=warning
+org.eclipse.jdt.core.compiler.problem.redundantNullCheck=ignore
+org.eclipse.jdt.core.compiler.problem.redundantSuperinterface=ignore
+org.eclipse.jdt.core.compiler.problem.specialParameterHidingField=disabled
+org.eclipse.jdt.core.compiler.problem.staticAccessReceiver=warning
+org.eclipse.jdt.core.compiler.problem.suppressWarnings=enabled
+org.eclipse.jdt.core.compiler.problem.syntheticAccessEmulation=ignore
+org.eclipse.jdt.core.compiler.problem.typeParameterHiding=warning
+org.eclipse.jdt.core.compiler.problem.uncheckedTypeOperation=warning
+org.eclipse.jdt.core.compiler.problem.undocumentedEmptyBlock=ignore
+org.eclipse.jdt.core.compiler.problem.unhandledWarningToken=warning
+org.eclipse.jdt.core.compiler.problem.unnecessaryElse=ignore
+org.eclipse.jdt.core.compiler.problem.unnecessaryTypeCheck=ignore
+org.eclipse.jdt.core.compiler.problem.unqualifiedFieldAccess=ignore
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownException=ignore
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionExemptExceptionAndThrowable=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionIncludeDocCommentReference=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionWhenOverriding=disabled
+org.eclipse.jdt.core.compiler.problem.unusedImport=warning
+org.eclipse.jdt.core.compiler.problem.unusedLabel=warning
+org.eclipse.jdt.core.compiler.problem.unusedLocal=warning
+org.eclipse.jdt.core.compiler.problem.unusedParameter=ignore
+org.eclipse.jdt.core.compiler.problem.unusedParameterIncludeDocCommentReference=enabled
+org.eclipse.jdt.core.compiler.problem.unusedParameterWhenImplementingAbstract=disabled
+org.eclipse.jdt.core.compiler.problem.unusedParameterWhenOverridingConcrete=disabled
+org.eclipse.jdt.core.compiler.problem.unusedPrivateMember=warning
+org.eclipse.jdt.core.compiler.problem.unusedWarningToken=warning
+org.eclipse.jdt.core.compiler.problem.varargsArgumentNeedCast=warning
 org.eclipse.jdt.core.compiler.source=1.5

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.core/lib/stratego-debug-core.jar
==============================================================================
Binary file (source and/or target). No diff available.

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/StrategoDebugTarget.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/StrategoDebugTarget.java	Thu Dec  9 10:38:27 2010	(r21476)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/StrategoDebugTarget.java	Thu Dec  9 11:03:49 2010	(r21477)
@@ -54,6 +54,9 @@
 	
 	// threads
 	private StrategoThread fThread;
+	/**
+	 * the array only contains the single StrategoThread (referenced by fThread) because a stratego program is single threaded.
+	 */
 	private IThread[] fThreads;
 	
 	// event dispatch job
@@ -665,6 +668,11 @@
 		return fEventDispatch;
 	}	
 	
+	public DebugSessionManager getDebugSessionManager()
+	{
+		return this.manager;
+	}
+	
 	private void updateState(StrategoState state)
 	{
 		this.state = state;

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/StrategoThread.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/StrategoThread.java	Thu Dec  9 10:38:27 2010	(r21476)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/StrategoThread.java	Thu Dec  9 11:03:49 2010	(r21477)
@@ -3,6 +3,7 @@
 import org.eclipse.debug.core.DebugException;
 import org.eclipse.debug.core.model.IBreakpoint;
 import org.eclipse.debug.core.model.IStackFrame;
+import org.eclipse.debug.core.model.IStep;
 import org.eclipse.debug.core.model.IThread;
 
 public class StrategoThread extends StrategoDebugElement implements IThread {
@@ -99,19 +100,46 @@
 		getDebugTarget().suspend();
 	}
 
+	/**
+	 * @see IStep#canStepInto()
+	 */
 	public boolean canStepInto() {
-		// TODO Auto-generated method stub
-		return false;
+		return canStep();
 	}
 
+	/**
+	 * @see IStep#canStepOver()
+	 */
 	public boolean canStepOver() {
-		// TODO Auto-generated method stub
-		return false;
+		return canStep();
 	}
 
+	/**
+	 * @see IStep#canStepReturn()
+	 */
 	public boolean canStepReturn() {
-		// TODO Auto-generated method stub
-		return false;
+		return canStep();
+	}
+	
+	/**
+	 * Returns whether this thread is in a valid state to
+	 * step.
+	 * 
+	 * @return whether this thread is in a valid state to
+	 * step
+	 */
+	protected boolean canStep() {
+		try {
+			return isSuspended()
+				// && (!isPerformingEvaluation() || isInvokingMethod()) // TODO: implement "perform evaluation"
+				// && !isSuspendVoteInProgress() // TODO:  (conditional breakpoints, etc.).
+				&& !isStepping()
+				&& getTopStackFrame() != null
+				// && !getJavaDebugTarget().isPerformingHotCodeReplace() // TODO: implement hot code replace
+				;
+		} catch (DebugException e) {
+			return false;
+		}
 	}
 
 	public boolean isStepping() {
@@ -119,19 +147,52 @@
 		return this.fStepping;
 	}
 
+	/**
+	 * This method is synchronized, such that the step request
+	 * begins before a background evaluation can be performed.
+	 * 
+	 * @see IStep#stepInto()
+	 */
 	public void stepInto() throws DebugException {
-		// TODO Auto-generated method stub
-		
+		synchronized (this) {
+			if (!canStepInto()) {
+				return;
+			}
+		}
+		// TODO: the jdi eclipse plugin uses scheduling and such
+		((StrategoDebugTarget)getDebugTarget()).getDebugSessionManager().stepInto();
 	}
 
+	/** 
+	 * This method is synchronized, such that the step request
+	 * begins before a background evaluation can be performed.
+	 * 
+	 * @see IStep#stepOver()
+	 */
 	public void stepOver() throws DebugException {
-		// TODO Auto-generated method stub
-		
+		synchronized (this) {
+			if (!canStepOver()) {
+				return;
+			}
+		}
+		// TODO: the jdi eclipse plugin uses scheduling and such
+		((StrategoDebugTarget)getDebugTarget()).getDebugSessionManager().stepOver();
 	}
 
+	/**
+	 * This method is synchronized, such that the step request
+	 * begins before a background evaluation can be performed.
+	 * 
+	 * @see IStep#stepReturn()
+	 */
 	public void stepReturn() throws DebugException {
-		// TODO Auto-generated method stub
-		
+		synchronized (this) {
+			if (!canStepReturn()) {
+				return;
+			}
+		}
+		// TODO: the jdi eclipse plugin uses scheduling and such
+		((StrategoDebugTarget)getDebugTarget()).getDebugSessionManager().stepReturn();
 	}
 
 	public boolean canTerminate() {
@@ -154,4 +215,6 @@
 	protected void setStepping(boolean stepping) {
 		fStepping = stepping;
 	}
+	
+
 }

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/.settings/org.eclipse.jdt.core.prefs
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/.settings/org.eclipse.jdt.core.prefs	Thu Dec  9 10:38:27 2010	(r21476)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/.settings/org.eclipse.jdt.core.prefs	Thu Dec  9 11:03:49 2010	(r21477)
@@ -1,4 +1,4 @@
-#Tue Sep 14 11:56:28 CEST 2010
+#Thu Dec 09 12:01:33 CET 2010
 eclipse.preferences.version=1
 org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
 org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.5
@@ -7,6 +7,68 @@
 org.eclipse.jdt.core.compiler.debug.lineNumber=generate
 org.eclipse.jdt.core.compiler.debug.localVariable=generate
 org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.annotationSuperInterface=warning
 org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.autoboxing=ignore
+org.eclipse.jdt.core.compiler.problem.comparingIdentical=warning
+org.eclipse.jdt.core.compiler.problem.deadCode=warning
+org.eclipse.jdt.core.compiler.problem.deprecation=warning
+org.eclipse.jdt.core.compiler.problem.deprecationInDeprecatedCode=disabled
+org.eclipse.jdt.core.compiler.problem.deprecationWhenOverridingDeprecatedMethod=disabled
+org.eclipse.jdt.core.compiler.problem.discouragedReference=warning
+org.eclipse.jdt.core.compiler.problem.emptyStatement=ignore
 org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.problem.fallthroughCase=ignore
+org.eclipse.jdt.core.compiler.problem.fatalOptionalError=enabled
+org.eclipse.jdt.core.compiler.problem.fieldHiding=ignore
+org.eclipse.jdt.core.compiler.problem.finalParameterBound=warning
+org.eclipse.jdt.core.compiler.problem.finallyBlockNotCompletingNormally=warning
+org.eclipse.jdt.core.compiler.problem.forbiddenReference=error
+org.eclipse.jdt.core.compiler.problem.hiddenCatchBlock=warning
+org.eclipse.jdt.core.compiler.problem.incompatibleNonInheritedInterfaceMethod=warning
+org.eclipse.jdt.core.compiler.problem.incompleteEnumSwitch=ignore
+org.eclipse.jdt.core.compiler.problem.indirectStaticAccess=ignore
+org.eclipse.jdt.core.compiler.problem.localVariableHiding=ignore
+org.eclipse.jdt.core.compiler.problem.methodWithConstructorName=warning
+org.eclipse.jdt.core.compiler.problem.missingDeprecatedAnnotation=ignore
+org.eclipse.jdt.core.compiler.problem.missingHashCodeMethod=ignore
+org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotation=ignore
+org.eclipse.jdt.core.compiler.problem.missingSerialVersion=warning
+org.eclipse.jdt.core.compiler.problem.missingSynchronizedOnInheritedMethod=ignore
+org.eclipse.jdt.core.compiler.problem.noEffectAssignment=warning
+org.eclipse.jdt.core.compiler.problem.noImplicitStringConversion=warning
+org.eclipse.jdt.core.compiler.problem.nonExternalizedStringLiteral=ignore
+org.eclipse.jdt.core.compiler.problem.nullReference=warning
+org.eclipse.jdt.core.compiler.problem.overridingPackageDefaultMethod=warning
+org.eclipse.jdt.core.compiler.problem.parameterAssignment=ignore
+org.eclipse.jdt.core.compiler.problem.possibleAccidentalBooleanAssignment=ignore
+org.eclipse.jdt.core.compiler.problem.potentialNullReference=ignore
+org.eclipse.jdt.core.compiler.problem.rawTypeReference=warning
+org.eclipse.jdt.core.compiler.problem.redundantNullCheck=ignore
+org.eclipse.jdt.core.compiler.problem.redundantSuperinterface=ignore
+org.eclipse.jdt.core.compiler.problem.specialParameterHidingField=disabled
+org.eclipse.jdt.core.compiler.problem.staticAccessReceiver=warning
+org.eclipse.jdt.core.compiler.problem.suppressWarnings=enabled
+org.eclipse.jdt.core.compiler.problem.syntheticAccessEmulation=ignore
+org.eclipse.jdt.core.compiler.problem.typeParameterHiding=warning
+org.eclipse.jdt.core.compiler.problem.uncheckedTypeOperation=warning
+org.eclipse.jdt.core.compiler.problem.undocumentedEmptyBlock=ignore
+org.eclipse.jdt.core.compiler.problem.unhandledWarningToken=warning
+org.eclipse.jdt.core.compiler.problem.unnecessaryElse=ignore
+org.eclipse.jdt.core.compiler.problem.unnecessaryTypeCheck=ignore
+org.eclipse.jdt.core.compiler.problem.unqualifiedFieldAccess=ignore
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownException=ignore
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionExemptExceptionAndThrowable=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionIncludeDocCommentReference=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionWhenOverriding=disabled
+org.eclipse.jdt.core.compiler.problem.unusedImport=warning
+org.eclipse.jdt.core.compiler.problem.unusedLabel=warning
+org.eclipse.jdt.core.compiler.problem.unusedLocal=warning
+org.eclipse.jdt.core.compiler.problem.unusedParameter=ignore
+org.eclipse.jdt.core.compiler.problem.unusedParameterIncludeDocCommentReference=enabled
+org.eclipse.jdt.core.compiler.problem.unusedParameterWhenImplementingAbstract=disabled
+org.eclipse.jdt.core.compiler.problem.unusedParameterWhenOverridingConcrete=disabled
+org.eclipse.jdt.core.compiler.problem.unusedPrivateMember=warning
+org.eclipse.jdt.core.compiler.problem.unusedWarningToken=warning
+org.eclipse.jdt.core.compiler.problem.varargsArgumentNeedCast=warning
 org.eclipse.jdt.core.compiler.source=1.5

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.runtime/.settings/org.eclipse.jdt.core.prefs
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.runtime/.settings/org.eclipse.jdt.core.prefs	Thu Dec  9 10:38:27 2010	(r21476)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.runtime/.settings/org.eclipse.jdt.core.prefs	Thu Dec  9 11:03:49 2010	(r21477)
@@ -1,3 +1,4 @@
+#Thu Dec 09 12:01:39 CET 2010
 eclipse.preferences.version=1
 org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
 org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.5
@@ -6,6 +7,68 @@
 org.eclipse.jdt.core.compiler.debug.lineNumber=generate
 org.eclipse.jdt.core.compiler.debug.localVariable=generate
 org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.annotationSuperInterface=warning
 org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.autoboxing=ignore
+org.eclipse.jdt.core.compiler.problem.comparingIdentical=warning
+org.eclipse.jdt.core.compiler.problem.deadCode=warning
+org.eclipse.jdt.core.compiler.problem.deprecation=warning
+org.eclipse.jdt.core.compiler.problem.deprecationInDeprecatedCode=disabled
+org.eclipse.jdt.core.compiler.problem.deprecationWhenOverridingDeprecatedMethod=disabled
+org.eclipse.jdt.core.compiler.problem.discouragedReference=warning
+org.eclipse.jdt.core.compiler.problem.emptyStatement=ignore
 org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.problem.fallthroughCase=ignore
+org.eclipse.jdt.core.compiler.problem.fatalOptionalError=enabled
+org.eclipse.jdt.core.compiler.problem.fieldHiding=ignore
+org.eclipse.jdt.core.compiler.problem.finalParameterBound=warning
+org.eclipse.jdt.core.compiler.problem.finallyBlockNotCompletingNormally=warning
+org.eclipse.jdt.core.compiler.problem.forbiddenReference=error
+org.eclipse.jdt.core.compiler.problem.hiddenCatchBlock=warning
+org.eclipse.jdt.core.compiler.problem.incompatibleNonInheritedInterfaceMethod=warning
+org.eclipse.jdt.core.compiler.problem.incompleteEnumSwitch=ignore
+org.eclipse.jdt.core.compiler.problem.indirectStaticAccess=ignore
+org.eclipse.jdt.core.compiler.problem.localVariableHiding=ignore
+org.eclipse.jdt.core.compiler.problem.methodWithConstructorName=warning
+org.eclipse.jdt.core.compiler.problem.missingDeprecatedAnnotation=ignore
+org.eclipse.jdt.core.compiler.problem.missingHashCodeMethod=ignore
+org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotation=ignore
+org.eclipse.jdt.core.compiler.problem.missingSerialVersion=warning
+org.eclipse.jdt.core.compiler.problem.missingSynchronizedOnInheritedMethod=ignore
+org.eclipse.jdt.core.compiler.problem.noEffectAssignment=warning
+org.eclipse.jdt.core.compiler.problem.noImplicitStringConversion=warning
+org.eclipse.jdt.core.compiler.problem.nonExternalizedStringLiteral=ignore
+org.eclipse.jdt.core.compiler.problem.nullReference=warning
+org.eclipse.jdt.core.compiler.problem.overridingPackageDefaultMethod=warning
+org.eclipse.jdt.core.compiler.problem.parameterAssignment=ignore
+org.eclipse.jdt.core.compiler.problem.possibleAccidentalBooleanAssignment=ignore
+org.eclipse.jdt.core.compiler.problem.potentialNullReference=ignore
+org.eclipse.jdt.core.compiler.problem.rawTypeReference=warning
+org.eclipse.jdt.core.compiler.problem.redundantNullCheck=ignore
+org.eclipse.jdt.core.compiler.problem.redundantSuperinterface=ignore
+org.eclipse.jdt.core.compiler.problem.specialParameterHidingField=disabled
+org.eclipse.jdt.core.compiler.problem.staticAccessReceiver=warning
+org.eclipse.jdt.core.compiler.problem.suppressWarnings=enabled
+org.eclipse.jdt.core.compiler.problem.syntheticAccessEmulation=ignore
+org.eclipse.jdt.core.compiler.problem.typeParameterHiding=warning
+org.eclipse.jdt.core.compiler.problem.uncheckedTypeOperation=warning
+org.eclipse.jdt.core.compiler.problem.undocumentedEmptyBlock=ignore
+org.eclipse.jdt.core.compiler.problem.unhandledWarningToken=warning
+org.eclipse.jdt.core.compiler.problem.unnecessaryElse=ignore
+org.eclipse.jdt.core.compiler.problem.unnecessaryTypeCheck=ignore
+org.eclipse.jdt.core.compiler.problem.unqualifiedFieldAccess=ignore
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownException=ignore
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionExemptExceptionAndThrowable=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionIncludeDocCommentReference=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionWhenOverriding=disabled
+org.eclipse.jdt.core.compiler.problem.unusedImport=warning
+org.eclipse.jdt.core.compiler.problem.unusedLabel=warning
+org.eclipse.jdt.core.compiler.problem.unusedLocal=warning
+org.eclipse.jdt.core.compiler.problem.unusedParameter=ignore
+org.eclipse.jdt.core.compiler.problem.unusedParameterIncludeDocCommentReference=enabled
+org.eclipse.jdt.core.compiler.problem.unusedParameterWhenImplementingAbstract=disabled
+org.eclipse.jdt.core.compiler.problem.unusedParameterWhenOverridingConcrete=disabled
+org.eclipse.jdt.core.compiler.problem.unusedPrivateMember=warning
+org.eclipse.jdt.core.compiler.problem.unusedWarningToken=warning
+org.eclipse.jdt.core.compiler.problem.varargsArgumentNeedCast=warning
 org.eclipse.jdt.core.compiler.source=1.5

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/.settings/org.eclipse.jdt.core.prefs
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/.settings/org.eclipse.jdt.core.prefs	Thu Dec  9 10:38:27 2010	(r21476)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/.settings/org.eclipse.jdt.core.prefs	Thu Dec  9 11:03:49 2010	(r21477)
@@ -1,4 +1,4 @@
-#Thu Sep 16 10:33:48 CEST 2010
+#Thu Dec 09 12:01:45 CET 2010
 eclipse.preferences.version=1
 org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
 org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.5
@@ -7,6 +7,68 @@
 org.eclipse.jdt.core.compiler.debug.lineNumber=generate
 org.eclipse.jdt.core.compiler.debug.localVariable=generate
 org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.annotationSuperInterface=warning
 org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.autoboxing=ignore
+org.eclipse.jdt.core.compiler.problem.comparingIdentical=warning
+org.eclipse.jdt.core.compiler.problem.deadCode=warning
+org.eclipse.jdt.core.compiler.problem.deprecation=warning
+org.eclipse.jdt.core.compiler.problem.deprecationInDeprecatedCode=disabled
+org.eclipse.jdt.core.compiler.problem.deprecationWhenOverridingDeprecatedMethod=disabled
+org.eclipse.jdt.core.compiler.problem.discouragedReference=warning
+org.eclipse.jdt.core.compiler.problem.emptyStatement=ignore
 org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.problem.fallthroughCase=ignore
+org.eclipse.jdt.core.compiler.problem.fatalOptionalError=enabled
+org.eclipse.jdt.core.compiler.problem.fieldHiding=ignore
+org.eclipse.jdt.core.compiler.problem.finalParameterBound=warning
+org.eclipse.jdt.core.compiler.problem.finallyBlockNotCompletingNormally=warning
+org.eclipse.jdt.core.compiler.problem.forbiddenReference=error
+org.eclipse.jdt.core.compiler.problem.hiddenCatchBlock=warning
+org.eclipse.jdt.core.compiler.problem.incompatibleNonInheritedInterfaceMethod=warning
+org.eclipse.jdt.core.compiler.problem.incompleteEnumSwitch=ignore
+org.eclipse.jdt.core.compiler.problem.indirectStaticAccess=ignore
+org.eclipse.jdt.core.compiler.problem.localVariableHiding=ignore
+org.eclipse.jdt.core.compiler.problem.methodWithConstructorName=warning
+org.eclipse.jdt.core.compiler.problem.missingDeprecatedAnnotation=ignore
+org.eclipse.jdt.core.compiler.problem.missingHashCodeMethod=ignore
+org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotation=ignore
+org.eclipse.jdt.core.compiler.problem.missingSerialVersion=warning
+org.eclipse.jdt.core.compiler.problem.missingSynchronizedOnInheritedMethod=ignore
+org.eclipse.jdt.core.compiler.problem.noEffectAssignment=warning
+org.eclipse.jdt.core.compiler.problem.noImplicitStringConversion=warning
+org.eclipse.jdt.core.compiler.problem.nonExternalizedStringLiteral=ignore
+org.eclipse.jdt.core.compiler.problem.nullReference=warning
+org.eclipse.jdt.core.compiler.problem.overridingPackageDefaultMethod=warning
+org.eclipse.jdt.core.compiler.problem.parameterAssignment=ignore
+org.eclipse.jdt.core.compiler.problem.possibleAccidentalBooleanAssignment=ignore
+org.eclipse.jdt.core.compiler.problem.potentialNullReference=ignore
+org.eclipse.jdt.core.compiler.problem.rawTypeReference=warning
+org.eclipse.jdt.core.compiler.problem.redundantNullCheck=ignore
+org.eclipse.jdt.core.compiler.problem.redundantSuperinterface=ignore
+org.eclipse.jdt.core.compiler.problem.specialParameterHidingField=disabled
+org.eclipse.jdt.core.compiler.problem.staticAccessReceiver=warning
+org.eclipse.jdt.core.compiler.problem.suppressWarnings=enabled
+org.eclipse.jdt.core.compiler.problem.syntheticAccessEmulation=ignore
+org.eclipse.jdt.core.compiler.problem.typeParameterHiding=warning
+org.eclipse.jdt.core.compiler.problem.uncheckedTypeOperation=warning
+org.eclipse.jdt.core.compiler.problem.undocumentedEmptyBlock=ignore
+org.eclipse.jdt.core.compiler.problem.unhandledWarningToken=warning
+org.eclipse.jdt.core.compiler.problem.unnecessaryElse=ignore
+org.eclipse.jdt.core.compiler.problem.unnecessaryTypeCheck=ignore
+org.eclipse.jdt.core.compiler.problem.unqualifiedFieldAccess=ignore
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownException=ignore
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionExemptExceptionAndThrowable=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionIncludeDocCommentReference=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionWhenOverriding=disabled
+org.eclipse.jdt.core.compiler.problem.unusedImport=warning
+org.eclipse.jdt.core.compiler.problem.unusedLabel=warning
+org.eclipse.jdt.core.compiler.problem.unusedLocal=warning
+org.eclipse.jdt.core.compiler.problem.unusedParameter=ignore
+org.eclipse.jdt.core.compiler.problem.unusedParameterIncludeDocCommentReference=enabled
+org.eclipse.jdt.core.compiler.problem.unusedParameterWhenImplementingAbstract=disabled
+org.eclipse.jdt.core.compiler.problem.unusedParameterWhenOverridingConcrete=disabled
+org.eclipse.jdt.core.compiler.problem.unusedPrivateMember=warning
+org.eclipse.jdt.core.compiler.problem.unusedWarningToken=warning
+org.eclipse.jdt.core.compiler.problem.varargsArgumentNeedCast=warning
 org.eclipse.jdt.core.compiler.source=1.5

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/.settings/org.eclipse.jdt.core.prefs
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/.settings/org.eclipse.jdt.core.prefs	Thu Dec  9 10:38:27 2010	(r21476)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/.settings/org.eclipse.jdt.core.prefs	Thu Dec  9 11:03:49 2010	(r21477)
@@ -1,3 +1,4 @@
+#Thu Dec 09 12:01:51 CET 2010
 eclipse.preferences.version=1
 org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
 org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.5
@@ -6,6 +7,68 @@
 org.eclipse.jdt.core.compiler.debug.lineNumber=generate
 org.eclipse.jdt.core.compiler.debug.localVariable=generate
 org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.annotationSuperInterface=warning
 org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.autoboxing=ignore
+org.eclipse.jdt.core.compiler.problem.comparingIdentical=warning
+org.eclipse.jdt.core.compiler.problem.deadCode=warning
+org.eclipse.jdt.core.compiler.problem.deprecation=warning
+org.eclipse.jdt.core.compiler.problem.deprecationInDeprecatedCode=disabled
+org.eclipse.jdt.core.compiler.problem.deprecationWhenOverridingDeprecatedMethod=disabled
+org.eclipse.jdt.core.compiler.problem.discouragedReference=warning
+org.eclipse.jdt.core.compiler.problem.emptyStatement=ignore
 org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.problem.fallthroughCase=ignore
+org.eclipse.jdt.core.compiler.problem.fatalOptionalError=enabled
+org.eclipse.jdt.core.compiler.problem.fieldHiding=ignore
+org.eclipse.jdt.core.compiler.problem.finalParameterBound=warning
+org.eclipse.jdt.core.compiler.problem.finallyBlockNotCompletingNormally=warning
+org.eclipse.jdt.core.compiler.problem.forbiddenReference=error
+org.eclipse.jdt.core.compiler.problem.hiddenCatchBlock=warning
+org.eclipse.jdt.core.compiler.problem.incompatibleNonInheritedInterfaceMethod=warning
+org.eclipse.jdt.core.compiler.problem.incompleteEnumSwitch=ignore
+org.eclipse.jdt.core.compiler.problem.indirectStaticAccess=ignore
+org.eclipse.jdt.core.compiler.problem.localVariableHiding=ignore
+org.eclipse.jdt.core.compiler.problem.methodWithConstructorName=warning
+org.eclipse.jdt.core.compiler.problem.missingDeprecatedAnnotation=ignore
+org.eclipse.jdt.core.compiler.problem.missingHashCodeMethod=ignore
+org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotation=ignore
+org.eclipse.jdt.core.compiler.problem.missingSerialVersion=warning
+org.eclipse.jdt.core.compiler.problem.missingSynchronizedOnInheritedMethod=ignore
+org.eclipse.jdt.core.compiler.problem.noEffectAssignment=warning
+org.eclipse.jdt.core.compiler.problem.noImplicitStringConversion=warning
+org.eclipse.jdt.core.compiler.problem.nonExternalizedStringLiteral=ignore
+org.eclipse.jdt.core.compiler.problem.nullReference=warning
+org.eclipse.jdt.core.compiler.problem.overridingPackageDefaultMethod=warning
+org.eclipse.jdt.core.compiler.problem.parameterAssignment=ignore
+org.eclipse.jdt.core.compiler.problem.possibleAccidentalBooleanAssignment=ignore
+org.eclipse.jdt.core.compiler.problem.potentialNullReference=ignore
+org.eclipse.jdt.core.compiler.problem.rawTypeReference=warning
+org.eclipse.jdt.core.compiler.problem.redundantNullCheck=ignore
+org.eclipse.jdt.core.compiler.problem.redundantSuperinterface=ignore
+org.eclipse.jdt.core.compiler.problem.specialParameterHidingField=disabled
+org.eclipse.jdt.core.compiler.problem.staticAccessReceiver=warning
+org.eclipse.jdt.core.compiler.problem.suppressWarnings=enabled
+org.eclipse.jdt.core.compiler.problem.syntheticAccessEmulation=ignore
+org.eclipse.jdt.core.compiler.problem.typeParameterHiding=warning
+org.eclipse.jdt.core.compiler.problem.uncheckedTypeOperation=warning
+org.eclipse.jdt.core.compiler.problem.undocumentedEmptyBlock=ignore
+org.eclipse.jdt.core.compiler.problem.unhandledWarningToken=warning
+org.eclipse.jdt.core.compiler.problem.unnecessaryElse=ignore
+org.eclipse.jdt.core.compiler.problem.unnecessaryTypeCheck=ignore
+org.eclipse.jdt.core.compiler.problem.unqualifiedFieldAccess=ignore
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownException=ignore
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionExemptExceptionAndThrowable=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionIncludeDocCommentReference=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionWhenOverriding=disabled
+org.eclipse.jdt.core.compiler.problem.unusedImport=warning
+org.eclipse.jdt.core.compiler.problem.unusedLabel=warning
+org.eclipse.jdt.core.compiler.problem.unusedLocal=warning
+org.eclipse.jdt.core.compiler.problem.unusedParameter=ignore
+org.eclipse.jdt.core.compiler.problem.unusedParameterIncludeDocCommentReference=enabled
+org.eclipse.jdt.core.compiler.problem.unusedParameterWhenImplementingAbstract=disabled
+org.eclipse.jdt.core.compiler.problem.unusedParameterWhenOverridingConcrete=disabled
+org.eclipse.jdt.core.compiler.problem.unusedPrivateMember=warning
+org.eclipse.jdt.core.compiler.problem.unusedWarningToken=warning
+org.eclipse.jdt.core.compiler.problem.varargsArgumentNeedCast=warning
 org.eclipse.jdt.core.compiler.source=1.5

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.ui/.settings/org.eclipse.jdt.core.prefs
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.ui/.settings/org.eclipse.jdt.core.prefs	Thu Dec  9 10:38:27 2010	(r21476)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.ui/.settings/org.eclipse.jdt.core.prefs	Thu Dec  9 11:03:49 2010	(r21477)
@@ -1,8 +1,70 @@
-#Wed Oct 06 14:52:32 CEST 2010
+#Thu Dec 09 12:01:57 CET 2010
 eclipse.preferences.version=1
 org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
 org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.5
 org.eclipse.jdt.core.compiler.compliance=1.5
+org.eclipse.jdt.core.compiler.problem.annotationSuperInterface=warning
 org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.autoboxing=ignore
+org.eclipse.jdt.core.compiler.problem.comparingIdentical=warning
+org.eclipse.jdt.core.compiler.problem.deadCode=warning
+org.eclipse.jdt.core.compiler.problem.deprecation=warning
+org.eclipse.jdt.core.compiler.problem.deprecationInDeprecatedCode=disabled
+org.eclipse.jdt.core.compiler.problem.deprecationWhenOverridingDeprecatedMethod=disabled
+org.eclipse.jdt.core.compiler.problem.discouragedReference=warning
+org.eclipse.jdt.core.compiler.problem.emptyStatement=ignore
 org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.problem.fallthroughCase=ignore
+org.eclipse.jdt.core.compiler.problem.fatalOptionalError=enabled
+org.eclipse.jdt.core.compiler.problem.fieldHiding=ignore
+org.eclipse.jdt.core.compiler.problem.finalParameterBound=warning
+org.eclipse.jdt.core.compiler.problem.finallyBlockNotCompletingNormally=warning
+org.eclipse.jdt.core.compiler.problem.forbiddenReference=error
+org.eclipse.jdt.core.compiler.problem.hiddenCatchBlock=warning
+org.eclipse.jdt.core.compiler.problem.incompatibleNonInheritedInterfaceMethod=warning
+org.eclipse.jdt.core.compiler.problem.incompleteEnumSwitch=ignore
+org.eclipse.jdt.core.compiler.problem.indirectStaticAccess=ignore
+org.eclipse.jdt.core.compiler.problem.localVariableHiding=ignore
+org.eclipse.jdt.core.compiler.problem.methodWithConstructorName=warning
+org.eclipse.jdt.core.compiler.problem.missingDeprecatedAnnotation=ignore
+org.eclipse.jdt.core.compiler.problem.missingHashCodeMethod=ignore
+org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotation=ignore
+org.eclipse.jdt.core.compiler.problem.missingSerialVersion=warning
+org.eclipse.jdt.core.compiler.problem.missingSynchronizedOnInheritedMethod=ignore
+org.eclipse.jdt.core.compiler.problem.noEffectAssignment=warning
+org.eclipse.jdt.core.compiler.problem.noImplicitStringConversion=warning
+org.eclipse.jdt.core.compiler.problem.nonExternalizedStringLiteral=ignore
+org.eclipse.jdt.core.compiler.problem.nullReference=warning
+org.eclipse.jdt.core.compiler.problem.overridingPackageDefaultMethod=warning
+org.eclipse.jdt.core.compiler.problem.parameterAssignment=ignore
+org.eclipse.jdt.core.compiler.problem.possibleAccidentalBooleanAssignment=ignore
+org.eclipse.jdt.core.compiler.problem.potentialNullReference=ignore
+org.eclipse.jdt.core.compiler.problem.rawTypeReference=warning
+org.eclipse.jdt.core.compiler.problem.redundantNullCheck=ignore
+org.eclipse.jdt.core.compiler.problem.redundantSuperinterface=ignore
+org.eclipse.jdt.core.compiler.problem.specialParameterHidingField=disabled
+org.eclipse.jdt.core.compiler.problem.staticAccessReceiver=warning
+org.eclipse.jdt.core.compiler.problem.suppressWarnings=enabled
+org.eclipse.jdt.core.compiler.problem.syntheticAccessEmulation=ignore
+org.eclipse.jdt.core.compiler.problem.typeParameterHiding=warning
+org.eclipse.jdt.core.compiler.problem.uncheckedTypeOperation=warning
+org.eclipse.jdt.core.compiler.problem.undocumentedEmptyBlock=ignore
+org.eclipse.jdt.core.compiler.problem.unhandledWarningToken=warning
+org.eclipse.jdt.core.compiler.problem.unnecessaryElse=ignore
+org.eclipse.jdt.core.compiler.problem.unnecessaryTypeCheck=ignore
+org.eclipse.jdt.core.compiler.problem.unqualifiedFieldAccess=ignore
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownException=ignore
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionExemptExceptionAndThrowable=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionIncludeDocCommentReference=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionWhenOverriding=disabled
+org.eclipse.jdt.core.compiler.problem.unusedImport=warning
+org.eclipse.jdt.core.compiler.problem.unusedLabel=warning
+org.eclipse.jdt.core.compiler.problem.unusedLocal=warning
+org.eclipse.jdt.core.compiler.problem.unusedParameter=ignore
+org.eclipse.jdt.core.compiler.problem.unusedParameterIncludeDocCommentReference=enabled
+org.eclipse.jdt.core.compiler.problem.unusedParameterWhenImplementingAbstract=disabled
+org.eclipse.jdt.core.compiler.problem.unusedParameterWhenOverridingConcrete=disabled
+org.eclipse.jdt.core.compiler.problem.unusedPrivateMember=warning
+org.eclipse.jdt.core.compiler.problem.unusedWarningToken=warning
+org.eclipse.jdt.core.compiler.problem.varargsArgumentNeedCast=warning
 org.eclipse.jdt.core.compiler.source=1.5

From tobivollebregt at gmail.com  Thu Dec  9 12:04:03 2010
From: tobivollebregt at gmail.com (Tobi Vollebregt)
Date: Thu, 09 Dec 2010 11:04:03 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21478 -
	spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms
Message-ID: <201012091104.oB9B43Mu006919@proliant.st.ewi.tudelft.nl>

Author: tvo
Date: Thu Dec  9 11:04:03 2010
New Revision: 21478
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21478&sc=1

Log:
Spoofax/312: ATerm parser: support parsing of negative integers

Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/BasicTermFactory.java

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/BasicTermFactory.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/BasicTermFactory.java	Thu Dec  9 11:03:49 2010	(r21477)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/BasicTermFactory.java	Thu Dec  9 11:04:03 2010	(r21478)
@@ -86,7 +86,7 @@
             if (Character.isLetter(ch)) {
                 return parseAnno(bis, parseAppl(bis));
             }
-            else if(Character.isDigit(ch))
+            else if (Character.isDigit(ch) || ch == '-')
                 return parseAnno(bis, parseNumber(bis));
         }
         throw new ParseError("Invalid term: '" + (char)ch + "'");

From tobivollebregt at gmail.com  Thu Dec  9 12:14:27 2010
From: tobivollebregt at gmail.com (Tobi Vollebregt)
Date: Thu, 09 Dec 2010 11:14:27 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21479 -
	strategoxt/trunk/xml-front/syn/xml
Message-ID: <201012091114.oB9BERx1006996@proliant.st.ewi.tudelft.nl>

Author: tvo
Date: Thu Dec  9 11:14:26 2010
New Revision: 21479
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21479&sc=1

Log:
fix XML comment syntax ("--" was not allowed in a comment)

Modified:
   strategoxt/trunk/xml-front/syn/xml/xml-comments.sdf

Modified: strategoxt/trunk/xml-front/syn/xml/xml-comments.sdf
==============================================================================
--- strategoxt/trunk/xml-front/syn/xml/xml-comments.sdf	Thu Dec  9 11:04:03 2010	(r21478)
+++ strategoxt/trunk/xml-front/syn/xml/xml-comments.sdf	Thu Dec  9 11:14:26 2010	(r21479)
@@ -7,6 +7,6 @@
 
   lexical restrictions
 
-    Dash -/- [\-]
+    Dash -/- [\-].[\>]
 
 

From L.C.L.Kats at tudelft.nl  Thu Dec  9 12:41:00 2010
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Thu, 09 Dec 2010 11:41:00 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21480 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/editor
Message-ID: <201012091141.oB9Bf0Cq007271@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: Thu Dec  9 11:40:59 2010
New Revision: 21480
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21480&sc=1

Log:
Some more coloring tweaks.

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/editor/Stratego-Sugar-Colorer.esv

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/editor/Stratego-Sugar-Colorer.esv
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/editor/Stratego-Sugar-Colorer.esv	Thu Dec  9 11:14:26 2010	(r21479)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/editor/Stratego-Sugar-Colorer.esv	Thu Dec  9 11:40:59 2010	(r21480)
@@ -17,8 +17,6 @@
   environment _.StringEscape2 : _ 255 255 255
   environment _.StringEscape3 : _ 255 255 255
   environment _.StringEscape4 : _ 255 255 255
-  _.ListVar : _ 255 255 255
-  _.Var     : _ 255 255 255
   _.Wld     : _ 255 255 255
 
   _.StringEscape1 : gray  
@@ -31,6 +29,30 @@
   _.QStr    : blue
   _.QDollar : blue
   _.QBr     : gray
+  
+  RuleDef     : 0 64 128 bold
+  RuleDec     : 0 64 128 bold
+  StrategyDef : 0 64 128 bold
+  Overlay     : 0 64 128 bold
+  
+  //strategies    = 0    0    0
+  strategycalls = 0   64  128
+  terms         = 0    0    0
+  vars          = 0    0    0   255 255 255
+  sdefault      = 0    0    0
+  
+  _.RootApp : strategycalls
+  _.App     : strategycalls
+  
+  //Strategy  : strategies
+  SVar      : strategycalls
+  Term      : terms
+  PreTerm   : terms
+  Var       : vars
+  _.Var     : vars
+  _.ListVar : vars
+  _.Assign  : sdefault
+  _.AM      : sdefault
 
   QuotedBracket1 : blue
   QuotedBracket2 : blue

From karltk at strategoxt.org  Thu Dec  9 12:50:17 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 09 Dec 2010 11:50:17 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21481 - in
	strategoxt-javascript-backend/trunk: scripts src/javascript
	src/stratego
Message-ID: <201012091150.oB9BoHJX007336@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec  9 11:50:17 2010
New Revision: 21481
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21481&sc=1

Log:
* Cleaning up JavaScript namespace. We only want one to leave one toplevel variable eventually: StrategoJS

Deleted:
   strategoxt-javascript-backend/trunk/src/javascript/emu-stratego-lib.js
Modified:
   strategoxt-javascript-backend/trunk/scripts/add-cli-wrapper.sh
   strategoxt-javascript-backend/trunk/src/javascript/srts.js
   strategoxt-javascript-backend/trunk/src/javascript/ssl.js
   strategoxt-javascript-backend/trunk/src/javascript/strategojs.js
   strategoxt-javascript-backend/trunk/src/javascript/terms.js
   strategoxt-javascript-backend/trunk/src/stratego/s2js.str
   strategoxt-javascript-backend/trunk/src/stratego/term-construction.str

Modified: strategoxt-javascript-backend/trunk/scripts/add-cli-wrapper.sh
==============================================================================
--- strategoxt-javascript-backend/trunk/scripts/add-cli-wrapper.sh	Thu Dec  9 11:40:59 2010	(r21480)
+++ strategoxt-javascript-backend/trunk/scripts/add-cli-wrapper.sh	Thu Dec  9 11:50:17 2010	(r21481)
@@ -6,6 +6,5 @@
 	${bp}/../src/javascript/terms.js \
 	${bp}/../src/javascript/srts.js \
 	${bp}/../src/javascript/ssl.js \
-	${bp}/../src/javascript/emu-stratego-lib.js \
 	- \
 	${bp}/../src/javascript/cli-wrapper.js

Modified: strategoxt-javascript-backend/trunk/src/javascript/srts.js
==============================================================================
--- strategoxt-javascript-backend/trunk/src/javascript/srts.js	Thu Dec  9 11:40:59 2010	(r21480)
+++ strategoxt-javascript-backend/trunk/src/javascript/srts.js	Thu Dec  9 11:50:17 2010	(r21481)
@@ -5,219 +5,225 @@
 
 StrategoJS.SRTS = {};
 
-StrategoJS.SRTS._cliArgumentsToList = function(jslist, factory) {
-	var r = factory.makeEmptyList();
-	for(var i = jslist.length-2; i >= 0; i--) {
-		r = factory.makeListCons(jslist[i], r);
-	}
-	if(jslist.length > 0)
-		r = factory.makeListCons(jslist[jslist.length-1], r);
-	return r;
-};
-
-StrategoJS.SRTS._initContext = function() {
-	var stack = [];
-	var nextStackPos = 0;
-	var maxStackPos = 0;
-
-	return {
-		debugLog : StrategoJS.log,
-		popOnFailure : function() {
-			nextStackPos--;
-		},
-		printStackTrace : function() {
-			StrategoJS.log("rewriting failed, trace:");
-			for(var i = 0; i < maxStackPos; i++)
-				StrategoJS.log("\t" + stack[i]);
-		},
-		popOnSuccess : function() {
-			nextStackPos--;
-			maxStackPos = nextStackPos;
-		},
-		push : function(funName) {
-			if(nextStackPos < stack.length)
-				stack[nextStackPos] = funName;
-			else
-				stack.push(funName);
-			nextStackPos++;
-			maxStackPos = nextStackPos;
-		},
-		getStackFrames : function() {
-			return stack.slice(0, maxStackPos);
-		},
-		factory : StrategoJS.Term
-	};
-};
+StrategoJS.SRTS._loaded = function() {
 
-StrategoJS.SRTS.SRTS_one = function(ctx, term, fun) {
-	print("SRTS_one : " + term ? ctx.factory.prettify(term) : "undefined term");
-	var factory = ctx.factory;
-	var termType = factory.termType(term)
-	switch(termType) {
-	case factory.REAL:
-	case factory.INT:
-	case factory.STRING:
-		return null;
-	case factory.LIST:
-		var tmp = [];
-		var success = false;
-		while(!factory.isEmptyList(term)) {
-			var ot = factory.head(term);
-			var nt = fun(ctx, ot);
-			term = factory.tail(term);
-			if(nt === null)
-				tmp.push(ot);
-			else {
-				tmp.push(nt);
-				success = true;
-				break;
-			}
-		}
-		if(!success) {
-			return null;
-		}
-		r = term;
-		for(var i = tmp.length-1; i >= 0; i--) {
-			r = factory.makeListCons(tmp[i], r);
+
+	StrategoJS.SRTS.cliArgumentsToList = function(jslist, factory) {
+		var r = factory.makeEmptyList();
+		for(var i = jslist.length-2; i >= 0; i--) {
+			r = factory.makeListCons(jslist[i], r);
 		}
+		if(jslist.length > 0)
+			r = factory.makeListCons(jslist[jslist.length-1], r);
 		return r;
-	case factory.TUPLE:
-	case factory.APPL:
-		var l = factory.getSubtermCount(term);
-		var tmp = [];
-		var success = false;
-		var i;
-		for(i = 0; i < l; i++) {
-			var ot = factory.getSubterm(term, i); 
-			var nt = fun(ctx, ot);
-			if(nt === null) {
-				tmp.push(ot);
+	};
+
+	StrategoJS.SRTS.initContext = function() {
+		var stack = [];
+		var nextStackPos = 0;
+		var maxStackPos = 0;
+
+		return {
+			debugLog : StrategoJS.log,
+			popOnFailure : function() {
+				nextStackPos--;
+			},
+			printStackTrace : function() {
+				StrategoJS.log("rewriting failed, trace:");
+				for(var i = 0; i < maxStackPos; i++)
+					StrategoJS.log("\t" + stack[i]);
+			},
+			popOnSuccess : function() {
+				nextStackPos--;
+				maxStackPos = nextStackPos;
+			},
+			push : function(funName) {
+				if(nextStackPos < stack.length)
+					stack[nextStackPos] = funName;
+				else
+					stack.push(funName);
+				nextStackPos++;
+				maxStackPos = nextStackPos;
+			},
+			getStackFrames : function() {
+				return stack.slice(0, maxStackPos);
+			},
+			factory : StrategoJS.Term
+		};
+	};
+
+	StrategoJS.SRTS.SRTS_one = function(ctx, term, fun) {
+		print("SRTS_one : " + term ? ctx.factory.prettify(term) : "undefined term");
+		var factory = ctx.factory;
+		var termType = factory.termType(term)
+		switch(termType) {
+		case factory.REAL:
+		case factory.INT:
+		case factory.STRING:
+			return null;
+		case factory.LIST:
+			var tmp = [];
+			var success = false;
+			while(!factory.isEmptyList(term)) {
+				var ot = factory.head(term);
+				var nt = fun(ctx, ot);
+				term = factory.tail(term);
+				if(nt === null)
+					tmp.push(ot);
+				else {
+					tmp.push(nt);
+					success = true;
+					break;
+				}
+			}
+			if(!success) {
+				return null;
+			}
+			r = term;
+			for(var i = tmp.length-1; i >= 0; i--) {
+				r = factory.makeListCons(tmp[i], r);
+			}
+			return r;
+		case factory.TUPLE:
+		case factory.APPL:
+			var l = factory.getSubtermCount(term);
+			var tmp = [];
+			var success = false;
+			var i;
+			for(i = 0; i < l; i++) {
+				var ot = factory.getSubterm(term, i); 
+				var nt = fun(ctx, ot);
+				if(nt === null) {
+					tmp.push(ot);
+				} else {
+					success = true;
+					tmp.push(nt);
+					i++; // for(;;i++) is exec'ed *after* the loop body, compensate 
+					break;
+				}
+			}
+			for(; i < l; i++) {
+				tmp.push(factory.getSubterm(term, i));
+			}
+			if(success && termType == factory.APPL) {
+				var ctor = factory.getConstructor(term);
+				return factory.makeAppl(ctor, tmp);
+			} if(success && termType == factory.TUPLE) {
+				return factory.makeTuple(tmp);
 			} else {
-				success = true;
-				tmp.push(nt);
-				i++; // for(;;i++) is exec'ed *after* the loop body, compensate 
-				break;
+				return null;
 			}
+		default:
+			throw new "invalid term type ";
 		}
-		for(; i < l; i++) {
-			tmp.push(factory.getSubterm(term, i));
-		}
-		if(success && termType == factory.APPL) {
-			var ctor = factory.getConstructor(term);
-			return factory.makeAppl(ctor, tmp);
-		} if(success && termType == factory.TUPLE) {
-			return factory.makeTuple(tmp);
-		} else {
-			return null;
+	}
+
+	StrategoJS.SRTS.SRTS_all = function(ctx, term, fun) {
+		print("SRTS_all");
+		var factory = ctx.factory;
+		switch(factory.termType(term)) {
+		case factory.REAL:
+		case factory.INT:
+		case factory.STRING: 
+			return term;
+		case factory.LIST: 
+			var tmp = [];
+			while(!factory.isEmptyList(term)) {
+				var nt = fun(ctx, factory.head(term));
+				if(nt === null)
+					return null;
+				tmp.push(nt);
+				term = factory.tail(term);
+			}
+			r = term;
+			for(var i = tmp.length-1; i >= 0; i--) {
+				r = factory.makeListCons(tmp[i], r);
+			}
+			return r;
+		case factory.TUPLE:
+		case factory.APPL:
+			var l = factory.getSubtermCount(term);
+			var tmp = [];
+			var success = false;
+			for(var i = 0; i < l; i++) {
+				var ot = factory.getSubterm(term, i); 
+				var nt = fun(ctx, ot);
+				if(nt === null)
+					return null;
+				tmp.push(nt);
+			}
+			if(factory.termType(term) === factory.APPL) {
+				return factory.makeAppl(factory.getConstructor(term), tmp);
+			} else {
+				return factory.makeTuple(tmp);
+			}
+		default:
+			throw new "invalid term type ";
 		}
-	default:
-		throw new "invalid term type ";
 	}
-}
 
-StrategoJS.SRTS.SRTS_all = function(ctx, term, fun) {
-	print("SRTS_all");
-	var factory = ctx.factory;
-	switch(factory.termType(term)) {
-	case factory.REAL:
-	case factory.INT:
-	case factory.STRING: 
-		return term;
-	case factory.LIST: 
-		var tmp = [];
-		while(!factory.isEmptyList(term)) {
-			var nt = fun(ctx, factory.head(term));
-			if(nt === null)
+	StrategoJS.SRTS.SRTS_some = function(ctx, term, fun) {
+		print("SRTS_some");
+		var factory = ctx.factory;
+		switch(factory.termType(term)) {
+		case factory.REAL:
+		case factory.INT:
+		case factory.STRING: 
+			return fun(ctx, term);
+		case factory.LIST: 
+			var tmp = [];
+			var success = false;
+			while(!factory.isEmptyList(term)) {
+				var ot = factory.head(term);
+				var nt = fun(ctx, ot);
+				term = factory.tail(term);
+				if(nt === null)
+					tmp.push(ot);
+				else {
+					tmp.push(nt);
+					success = true;
+				}
+			}
+			if(!success)
 				return null;
-			tmp.push(nt);
-			term = factory.tail(term);
-		}
-		r = term;
-		for(var i = tmp.length-1; i >= 0; i--) {
-			r = factory.makeListCons(tmp[i], r);
-		}
-		return r;
-	case factory.TUPLE:
-	case factory.APPL:
-		var l = factory.getSubtermCount(term);
-		var tmp = [];
-		var success = false;
-		for(var i = 0; i < l; i++) {
-			var ot = factory.getSubterm(term, i); 
-			var nt = fun(ctx, ot);
-			if(nt === null)
+			r = term;
+			for(var i = tmp.length-1; i >= 0; i--) {
+				r = factory.makeListCons(tmp[i], r);
+			}
+			return r;
+		case factory.TUPLE:
+		case factory.APPL:
+			throw "not implemented some";
+			var l = factory.getSubtermCount(term);
+			var tmp = [];
+			var success = false;
+			for(var i = 0; i < l; i++) {
+				var ot = factory.getSubterm(term, i); 
+				var nt = fun(ctx, ot);
+				tmp.push(nt === null ? ot : ot);
+				success = nt !== null || success;
+			}
+			if(success) {
+
+			} else {
 				return null;
-			tmp.push(nt);
-		}
-		if(factory.termType(term) === factory.APPL) {
-			return factory.makeAppl(factory.getConstructor(term), tmp);
-		} else {
-			return factory.makeTuple(tmp);
+			}
+		default:
+			throw new "invalid term type ";
 		}
-	default:
-		throw new "invalid term type ";
 	}
-}
 
-StrategoJS.SRTS.SRTS_some = function(ctx, term, fun) {
-	print("SRTS_some");
-	var factory = ctx.factory;
-	switch(factory.termType(term)) {
-	case factory.REAL:
-	case factory.INT:
-	case factory.STRING: 
-		return fun(ctx, term);
-	case factory.LIST: 
-		var tmp = [];
-		var success = false;
-		while(!factory.isEmptyList(term)) {
-			var ot = factory.head(term);
-			var nt = fun(ctx, ot);
-			term = factory.tail(term);
-			if(nt === null)
-				tmp.push(ot);
-			else {
-				tmp.push(nt);
-				success = true;
-			}
-		}
-		if(!success)
-			return null;
-		r = term;
-		for(var i = tmp.length-1; i >= 0; i--) {
-			r = factory.makeListCons(tmp[i], r);
-		}
-		return r;
-	case factory.TUPLE:
-	case factory.APPL:
-		throw "not implemented some";
-		var l = factory.getSubtermCount(term);
-		var tmp = [];
-		var success = false;
-		for(var i = 0; i < l; i++) {
-			var ot = factory.getSubterm(term, i); 
-			var nt = fun(ctx, ot);
-			tmp.push(nt === null ? ot : ot);
-			success = nt !== null || success;
-		}
-		if(success) {
-			
-		} else {
-			return null;
-		}
-	default:
-		throw new "invalid term type ";
+	StrategoJS.SRTS.checkListAnnos = function(factory, term) {
+		if(StrategoJS.Term.termType(term) !== StrategoJS.Term.LIST)
+			return makeList([term]);
+		return term;
+	}
+
+	StrategoJS.SRTS.checkListTail = function(term) {
+		if(StrategoJS.Term.termType(term) !== StrategoJS.Term.LIST)
+			throw "invalid list tail, " + termType(term);
+		return term;
 	}
-}
 
-StrategoJS.SRTS._checkListAnnos = function(factory, term) {
-	if(StrategoJS.Term.termType(term) !== StrategoJS.Term.LIST)
-		return makeList([term]);
-	return term;
-}
-
-StrategoJS.SRTS._checkListTail = function(term) {
-	if(StrategoJS.Term.termType(term) !== StrategoJS.Term.LIST)
-		throw "invalid list tail, " + termType(term);
-	return term;
-},
+	return true;
+}();

Modified: strategoxt-javascript-backend/trunk/src/javascript/ssl.js
==============================================================================
--- strategoxt-javascript-backend/trunk/src/javascript/ssl.js	Thu Dec  9 11:40:59 2010	(r21480)
+++ strategoxt-javascript-backend/trunk/src/javascript/ssl.js	Thu Dec  9 11:50:17 2010	(r21481)
@@ -6,481 +6,483 @@
  * 
  */
 
-StrategoJS.SSL = {
-		_stdin  : StrategoJS.Term.makeCtor("stdin", 0),
-		_stdout : StrategoJS.Term.makeCtor("stdout", 0),
-		_stderr : StrategoJS.Term.makeCtor("stderr", 0)
-};
-
-
-StrategoJS.SSL.SSL_fail = function(ctx, currentTerm) {
-	return null;
-}
-
-StrategoJS.SSL.SSL_id = function(ctx, currentTerm) {
-	return currentTerm;
-}
-
-StrategoJS.SSL.SSL_stdin_stream = function(ctx, currentTerm) {
-	return ctx.factory.makeAppl(StrategoJS.SSL._stdin, []);
-}
-
-StrategoJS.SSL.SSL_stdout_stream = function(ctx, currentTerm) {
-	return ctx.factory.makeAppl(StrategoJS.SSL._stdout, []);
-}
-
-StrategoJS.SSL.SSL_stderr_stream = function(ctx, currentTerm) {
-	return ctx.factory.makeAppl(StrategoJS.SSL._stderr, []);
-}
-
-StrategoJS.SSL._makeString = function(factory, string) {
-	return factory.makeString(string);
-}
-
-StrategoJS.SSL._makeAppl = function(factory, ctorName, args) {
-	var tmp = [];
-	while(!factory.isEmptyList(args)) {
-		tmp.push(factory.head(args));
-		args = factory.tail(args);
-	}
-	if(ctorName.length == 0) {
-		return factory.makeTuple(tmp);
-	} else {
-		var ctor = factory.makeCtor(ctorName, tmp.length);
-		return factory.makeAppl(ctor, tmp);
-	}
-}
-
-StrategoJS.SSL.SSL_mkterm = function(ctx, currentTerm, ctorTerm, args) {
-	print("SSL_mkterm");
-	var factory = ctx.factory;
-	switch(factory.termType(ctorTerm)) {
-	case factory.STRING:
-		// FIXME how to make a string?
-		var r = StrategoJS.SSL._makeAppl(factory, ctorTerm, args);
-		print("x");
-		print(r);
-		return r;
-	case factory.INT:
-	case factory.REAL:
-		return args[0];
-	case factory.LIST:
-		if(factory.termType(args[1]) == factory.LIST)
-			return args[1];
-		else
-			return null;
-	default:
+StrategoJS.SSL = {};
+
+StrategoJS.SSL._loaded = function() {
+
+	var _stdin  = StrategoJS.Term.makeCtor("stdin", 0);
+	var _stdout = StrategoJS.Term.makeCtor("stdout", 0);
+	var _stderr = StrategoJS.Term.makeCtor("stderr", 0);
+
+	StrategoJS.SSL.SSL_fail = function(ctx, currentTerm) {
 		return null;
 	}
-}
 
-StrategoJS.SSL.SSL_addi = function(ctx, currentTerm, lhs, rhs) {
-	print("SSL_addi");
-	var f = ctx.factory;
-	if(f.termType(lhs) !== f.INT || f.termType(rhs) !== f.INT)
-		return null;
-	return lhs + rhs;
-}
+	StrategoJS.SSL.SSL_id = function(ctx, currentTerm) {
+		return currentTerm;
+	}
 
-StrategoJS.SSL.SSL_addr = function(ctx, currentTerm, lhs, rhs) {
-	print("SSL_addr");
-	var f = ctx.factory;
-	if(f.termType(lhs) !== f.REAL || f.termType(rhs) !== f.REAL)
-		return null;
-	return lhs + rhs;
-}
+	StrategoJS.SSL.SSL_stdin_stream = function(ctx, currentTerm) {
+		return ctx.factory.makeAppl(_stdin, []);
+	}
+
+	StrategoJS.SSL.SSL_stdout_stream = function(ctx, currentTerm) {
+		return ctx.factory.makeAppl(_stdout, []);
+	}
+
+	StrategoJS.SSL.SSL_stderr_stream = function(ctx, currentTerm) {
+		return ctx.factory.makeAppl(_stderr, []);
+	}
+
+	var _makeString = function(factory, string) {
+		return factory.makeString(string);
+	}
 
-StrategoJS.SSL.SSL_write_term_to_stream_text = function(ctx, currentTerm, stream, outputTerm) {
-	print("SSL_write_term_to_stream_text");
-	var ctor = ctx.factory.getConstructor(stream);
-	if(ctx.factory.ctorEquals(ctor, StrategoJS.SSL._stdout) || ctx.factory.ctorEquals(ctor, StrategoJS.SSL._stderr))
-		print(ctx.factory.prettify(outputTerm));
-	else {
-		var f = StrategoJS.SSL._openFiles[stream]
-		f.write(ctx.factory.prettify(outputTerm));
-		f.flush();
-	}
-	return stream;
-}
-
-StrategoJS.SSL.SSL_read_term_from_stream = function(ctx, currentTerm, stream) {
-	print("SSL_read_term_from_stream");
-	var ctor = ctx.factory.getConstructor(stream);
-	if(ctx.factory.ctorEquals(ctor, StrategoJS.SSL._stdin))
-		throw "SSL_read_term_from_stream does not support stdin"; 
-	else {
-		var f = StrategoJS.SSL._openFiles[stream]
-		var r = "";
-		var s = f.readLine();
-		while(s !== null) {
-			r += s;
-			s = f.readLine();
+	var _makeAppl = function(factory, ctorName, args) {
+		var tmp = [];
+		while(!factory.isEmptyList(args)) {
+			tmp.push(factory.head(args));
+			args = factory.tail(args);
+		}
+		if(ctorName.length == 0) {
+			return factory.makeTuple(tmp);
+		} else {
+			var ctor = factory.makeCtor(ctorName, tmp.length);
+			return factory.makeAppl(ctor, tmp);
 		}
-		r = ctx.factory.parse(r);
-		return r;
 	}
-	throw "unreachable";
-}
 
-StrategoJS.SSL.SSL_is_string = function(ctx, currentTerm, arg) {
-	if(ctx.factory.termType(arg) === ctx.factory.STRING)
-		return arg;
-	return null;
-}
-
-StrategoJS.SSL.SSL_fputs = function(ctx, currentTerm, string, stream) {
-	print("SSL_fputs");
-	var ctor = ctx.factory.getConstructor(stream);
-	if(ctx.factory.ctorEquals(ctor, StrategoJS.SSL._stdout) || ctx.factory.ctorEquals(ctor, StrategoJS.SSL._stderr))
-		print(ctx.factory.stripAnnotations(string));
-	else
-		throw "SSL_fputs not fully implemented; cannot write to arbitrary streams";
-	return currentTerm;
-}
-
-StrategoJS.SSL._openFiles = []
-
-StrategoJS.SSL.SSL_fopen = function(ctx, currentTerm, fileName, mode) {
-	print("SSL_fopen : " + fileName + " " + mode);
-	if(mode === "w" || mode === "a") {
-		var f = new java.io.BufferedWriter(new java.io.FileWriter(fileName));
-		StrategoJS.SSL._openFiles.push(f)
-		return StrategoJS.SSL._openFiles.length - 1;
-	} else if(mode === "r") {
-		var f = new java.io.BufferedReader(new java.io.FileReader(fileName));
-		StrategoJS.SSL._openFiles.push(f)
-		return StrategoJS.SSL._openFiles.length - 1;
-	}
-	throw "SSL_fopen not fully implemented, mode not supported : " + mode;
-}
-
-StrategoJS.SSL.SSL_fclose = function(ctx, currentTerm, stream) {
-	print("SSL_fclose");
-	var f = StrategoJS.SSL._openFiles[stream];
-	if(f) {
-		f.close();
-		StrategoJS.SSL._openFiles[stream] = null;
-	}
-	return stream;
-}
-
-StrategoJS.SSL.SSL_fputc = function(ctx, currentTerm, ch, stream) {
-	print("SSL_fputc");
-	var ctor = ctx.factory.getConstructor(stream);
-	if(ctx.factory.ctorEquals(ctor, StrategoJS.SSL._stdout) || ctx.factory.ctorEquals(ctor, StrategoJS.SSL._stderr))
-		print(String.fromCharCode(ch));
-	else {
-		var f = StrategoJS.SSL._openFiles[stream];
-		f.write(String.fromCharCode(ch));
-		f.flush();
-	}
-	return currentTerm;
-}
-
-StrategoJS.SSL.SSL_get_constructor = function(ctx, currentTerm, term) {
-	print("SSL_get_constructor");
-	return ctx.factory.getConstructor(term);
-}
-
-StrategoJS.SSL.SSL_get_arguments = function(ctx, currentTerm, term) {
-	var tmp = [];
-	var factory = ctx.factory;
-	switch(factory.termType(term)) {
-	case factory.REAL:
-	case factory.INT:
-	case factory.STRING:
-		return factory.makeEmptyList();
-	case factory.LIST:
-		return term;
-	case factory.APPL:
-	case factory.TUPLE:
-		var r = factory.makeEmptyList();
-		for(var i = factory.getSubtermCount(term) - 1; i >= 0; i--) {
-			r = factory.makeListCons(factory.getSubterm(term, i), r);
+	StrategoJS.SSL.SSL_mkterm = function(ctx, currentTerm, ctorTerm, args) {
+		print("SSL_mkterm");
+		var factory = ctx.factory;
+		switch(factory.termType(ctorTerm)) {
+		case factory.STRING:
+			// FIXME how to make a string?
+			var r = _makeAppl(factory, ctorTerm, args);
+			print("x");
+			print(r);
+			return r;
+		case factory.INT:
+		case factory.REAL:
+			return args[0];
+		case factory.LIST:
+			if(factory.termType(args[1]) == factory.LIST)
+				return args[1];
+			else
+				return null;
+		default:
+			return null;
 		}
-		return r;
 	}
-	throw "not implemented SSL_get_arguments fully";
-}
 
-StrategoJS.SSL.SSL_get_list_length = function(ctx, currentTerm, term) {
-	if(ctx.factory.termType(term) !== ctx.factory.LIST)
+	StrategoJS.SSL.SSL_addi = function(ctx, currentTerm, lhs, rhs) {
+		print("SSL_addi");
+		var f = ctx.factory;
+		if(f.termType(lhs) !== f.INT || f.termType(rhs) !== f.INT)
+			return null;
+		return lhs + rhs;
+	}
+
+	StrategoJS.SSL.SSL_addr = function(ctx, currentTerm, lhs, rhs) {
+		print("SSL_addr");
+		var f = ctx.factory;
+		if(f.termType(lhs) !== f.REAL || f.termType(rhs) !== f.REAL)
+			return null;
+		return lhs + rhs;
+	}
+
+	StrategoJS.SSL.SSL_write_term_to_stream_text = function(ctx, currentTerm, stream, outputTerm) {
+		print("SSL_write_term_to_stream_text");
+		var ctor = ctx.factory.getConstructor(stream);
+		if(ctx.factory.ctorEquals(ctor, _stdout) || ctx.factory.ctorEquals(ctor, _stderr))
+			print(ctx.factory.prettify(outputTerm));
+		else {
+			var f = _openFiles[stream]
+			f.write(ctx.factory.prettify(outputTerm));
+			f.flush();
+		}
+		return stream;
+	}
+
+	StrategoJS.SSL.SSL_read_term_from_stream = function(ctx, currentTerm, stream) {
+		print("SSL_read_term_from_stream");
+		var ctor = ctx.factory.getConstructor(stream);
+		if(ctx.factory.ctorEquals(ctor, _stdin))
+			throw "SSL_read_term_from_stream does not support stdin"; 
+		else {
+			var f = _openFiles[stream]
+			var r = "";
+			var s = f.readLine();
+			while(s !== null) {
+				r += s;
+				s = f.readLine();
+			}
+			r = ctx.factory.parse(r);
+			return r;
+		}
+		throw "unreachable";
+	}
+
+	StrategoJS.SSL.SSL_is_string = function(ctx, currentTerm, arg) {
+		if(ctx.factory.termType(arg) === ctx.factory.STRING)
+			return arg;
 		return null;
-	return ctx.factory.getSubtermCount(term);
-}
+	}
 
-StrategoJS.SSL.SSL_perror = function(ctx, currentTerm, term) {
-	var msg = ctx.factory.termType(term) == ctx.factory.STRING ? term : "(no details on this error; perror not supported)";
-	print("ERROR: " + msg);
-	return currentTerm;
-}
+	StrategoJS.SSL.SSL_fputs = function(ctx, currentTerm, string, stream) {
+		print("SSL_fputs");
+		var ctor = ctx.factory.getConstructor(stream);
+		if(ctx.factory.ctorEquals(ctor, _stdout) || ctx.factory.ctorEquals(ctor, _stderr))
+			print(ctx.factory.stripAnnotations(string));
+		else
+			throw "SSL_fputs not fully implemented; cannot write to arbitrary streams";
+		return currentTerm;
+	}
 
-StrategoJS.SSL.SSL_is_real = function(ctx, currentTerm, term) {
-	return ctx.factory.termType(term) == ctx.factory.REAL;
-}
+	_openFiles = []
 
-StrategoJS.SSL._hashtables = [
-                              {} /* table table */,  
-                              {} /* dynrule table */
-                              ];
-StrategoJS.SSL._indexedSets = [];
-StrategoJS.SSL._counter     = 0;
-StrategoJS.SSL._TABLE_TABLE = 0;
-StrategoJS.SSL._DYN_TABLE   = 1;
+	StrategoJS.SSL.SSL_fopen = function(ctx, currentTerm, fileName, mode) {
+		print("SSL_fopen : " + fileName + " " + mode);
+		if(mode === "w" || mode === "a") {
+			var f = new java.io.BufferedWriter(new java.io.FileWriter(fileName));
+			_openFiles.push(f)
+			return _openFiles.length - 1;
+		} else if(mode === "r") {
+			var f = new java.io.BufferedReader(new java.io.FileReader(fileName));
+			_openFiles.push(f)
+			return _openFiles.length - 1;
+		}
+		throw "SSL_fopen not fully implemented, mode not supported : " + mode;
+	}
 
-StrategoJS.SSL._IndexedSet = function() {
-	var _counter = 0;
-	var _hash = {};
-	
-	this.getIndex = function(key) {
-		return _hash[key]; 
+	StrategoJS.SSL.SSL_fclose = function(ctx, currentTerm, stream) {
+		print("SSL_fclose");
+		var f = _openFiles[stream];
+		if(f) {
+			f.close();
+			_openFiles[stream] = null;
+		}
+		return stream;
 	}
 
-	this.containsKey = function(key) {
-		return _hash[key] !== undefined;
+	StrategoJS.SSL.SSL_fputc = function(ctx, currentTerm, ch, stream) {
+		print("SSL_fputc");
+		var ctor = ctx.factory.getConstructor(stream);
+		if(ctx.factory.ctorEquals(ctor, _stdout) || ctx.factory.ctorEquals(ctor, _stderr))
+			print(String.fromCharCode(ch));
+		else {
+			var f = _openFiles[stream];
+			f.write(String.fromCharCode(ch));
+			f.flush();
+		}
+		return currentTerm;
 	}
 
-	this.put = function(key) {
-		var idx = _counter++;
-		print("Z - " + key + " : " + idx);
-		_hash[key] = idx; 
-		return idx;
+	StrategoJS.SSL.SSL_get_constructor = function(ctx, currentTerm, term) {
+		print("SSL_get_constructor");
+		return ctx.factory.getConstructor(term);
+	}
+
+	StrategoJS.SSL.SSL_get_arguments = function(ctx, currentTerm, term) {
+		var tmp = [];
+		var factory = ctx.factory;
+		switch(factory.termType(term)) {
+		case factory.REAL:
+		case factory.INT:
+		case factory.STRING:
+			return factory.makeEmptyList();
+		case factory.LIST:
+			return term;
+		case factory.APPL:
+		case factory.TUPLE:
+			var r = factory.makeEmptyList();
+			for(var i = factory.getSubtermCount(term) - 1; i >= 0; i--) {
+				r = factory.makeListCons(factory.getSubterm(term, i), r);
+			}
+			return r;
+		}
+		throw "not implemented SSL_get_arguments fully";
 	}
 
-	this.sortedKeySet = function() {
-		var r = [];
-		var sorter = function (a, b) { return a.v - b.v; }
-		for(var x in _hash) {
-			r.push({t:x, v:_hash[x]});
+	StrategoJS.SSL.SSL_get_list_length = function(ctx, currentTerm, term) {
+		if(ctx.factory.termType(term) !== ctx.factory.LIST)
+			return null;
+		return ctx.factory.getSubtermCount(term);
+	}
+
+	StrategoJS.SSL.SSL_perror = function(ctx, currentTerm, term) {
+		var msg = ctx.factory.termType(term) == ctx.factory.STRING ? term : "(no details on this error; perror not supported)";
+		print("ERROR: " + msg);
+		return currentTerm;
+	}
+
+	StrategoJS.SSL.SSL_is_real = function(ctx, currentTerm, term) {
+		return ctx.factory.termType(term) == ctx.factory.REAL;
+	}
+
+	var _hashtables  = [
+	                    {} /* table table */,  
+	                    {} /* dynrule table */
+	                    ];
+	var _indexedSets = [];
+	var _counter     = 0;
+	var _TABLE_TABLE = 0;
+	var _DYN_TABLE   = 1;
+
+	var _IndexedSet = function() {
+		var _counter = 0;
+		var _hash = {};
+
+		this.getIndex = function(key) {
+			return _hash[key]; 
 		}
-		r.sort(sorter);
-		var rr = [];
-		for(var i = 0; i < r.length; i++) {
-			rr.push(r[i].t);
+
+		this.containsKey = function(key) {
+			return _hash[key] !== undefined;
+		}
+
+		this.put = function(key) {
+			var idx = _counter++;
+			_hash[key] = idx; 
+			return idx;
+		}
+
+		this.sortedKeySet = function() {
+			var r = [];
+			var sorter = function (a, b) { return a.v - b.v; }
+			for(var x in _hash) {
+				r.push({t:x, v:_hash[x]});
+			}
+			r.sort(sorter);
+			var rr = [];
+			for(var i = 0; i < r.length; i++) {
+				rr.push(r[i].t);
+			}
+			return rr;
+		}
+
+		this.reset = function() {
+			_hash = {};
+			_counter -= _counter;
 		}
-		return rr;
 	}
 
-	this.reset = function() {
-		_hash = {};
-		_counter -= _counter;
+
+	var _makeHashtable = function() {
+		return {};
 	}
-}
 
+	StrategoJS.SSL.SSL_dynamic_rules_hashtable = function(ctx, currentTerm) {
+		print("SSL_dynamic_rules_hashtable");
+		return _DYN_TABLE;
+	}
 
-function _makeHashtable() {
-	return {};
-}
+	StrategoJS.SSL.SSL_hashtable_get = function(ctx, currentTerm, tableReference, key) {
+		print("SSL_hashtable_get : " + tableReference);
+		var tbl = _hashtables[tableReference];
+		if(!tbl)
+			return null;
+		var keyAsString = ctx.factory.prettify(key);
+		return tbl[keyAsString] || null;
+	}
 
-StrategoJS.SSL.SSL_dynamic_rules_hashtable = function(ctx, currentTerm) {
-	print("SSL_dynamic_rules_hashtable");
-	return StrategoJS.SSL._DYN_TABLE;
-}
+	StrategoJS.SSL.SSL_indexedSet_create = function(ctx, currentTerm, initialSize, maxLoad) {
+		print("SSL_indexedSet_create");
+		_indexedSets.push(new _IndexedSet());
+		return _indexedSets.length - 1;
+	}
 
-StrategoJS.SSL.SSL_hashtable_get = function(ctx, currentTerm, tableReference, key) {
-	print("SSL_hashtable_get : " + tableReference);
-	var tbl = StrategoJS.SSL._hashtables[tableReference];
-	if(!tbl)
-		return null;
-	var keyAsString = ctx.factory.prettify(key);
-	return tbl[keyAsString] || null;
-}
-
-StrategoJS.SSL.SSL_indexedSet_create = function(ctx, currentTerm, initialSize, maxLoad) {
-	print("SSL_indexedSet_create");
-	StrategoJS.SSL._indexedSets.push(new StrategoJS.SSL._IndexedSet());
-	return StrategoJS.SSL._indexedSets.length - 1;
-}
-
-StrategoJS.SSL.SSL_indexedSet_destroy = function(ctx, currentTerm, setIndex) {
-	print("SSL_indexedSet_destroy");
-	delete StrategoJS.SSL._indexedSets[setIndex];
-	return currentTerm;
-}
-
-StrategoJS.SSL.SSL_indexedSet_reset = function(ctx, currentTerm, setIndex) {
-	print("SSL_indexedSet_reset");
-	if(ctx.factory.termType(setIndex) !== ctx.factory.INT)
-		return null;
-	StrategoJS.SSL._indexedSets[setIndex].reset();
-	return setIndex;
-}
-
-StrategoJS.SSL.SSL_indexedSet_put = function(ctx, currentTerm, strategy, setIndex, key) {
-	print("SSL_indexedSet_put : " + setIndex + " " + key);
-	if(ctx.factory.termType(setIndex) !== ctx.factory.INT)
-		return null;
-	var set = StrategoJS.SSL._indexedSets[setIndex];
-	var keyAsString = ctx.factory.prettify(key);
-	print("                   : " + setIndex + " " + keyAsString);
-	if(set.containsKey(keyAsString)) {
-		var r = set.getIndex(keyAsString);
-		return strategy(ctx, r === undefined ? null : r);
+	StrategoJS.SSL.SSL_indexedSet_destroy = function(ctx, currentTerm, setIndex) {
+		print("SSL_indexedSet_destroy");
+		delete _indexedSets[setIndex];
+		return currentTerm;
 	}
-	else {
-		var r = set.put(keyAsString);
+
+	StrategoJS.SSL.SSL_indexedSet_reset = function(ctx, currentTerm, setIndex) {
+		print("SSL_indexedSet_reset");
+		if(ctx.factory.termType(setIndex) !== ctx.factory.INT)
+			return null;
+		_indexedSets[setIndex].reset();
+		return setIndex;
+	}
+
+	StrategoJS.SSL.SSL_indexedSet_put = function(ctx, currentTerm, strategy, setIndex, key) {
+		print("SSL_indexedSet_put : " + setIndex + " " + key);
+		if(ctx.factory.termType(setIndex) !== ctx.factory.INT)
+			return null;
+		var set = _indexedSets[setIndex];
+		var keyAsString = ctx.factory.prettify(key);
+		print("                   : " + setIndex + " " + keyAsString);
+		if(set.containsKey(keyAsString)) {
+			var r = set.getIndex(keyAsString);
+			return strategy(ctx, r === undefined ? null : r);
+		}
+		else {
+			var r = set.put(keyAsString);
+			return r === undefined ? null : r;
+		}
+	}
+
+	StrategoJS.SSL.SSL_indexedSet_getIndex = function(ctx, currentTerm, setIndex, key) {
+		print("SSL_indexedSet_getIndex");
+		if(ctx.factory.termType(setIndex) !== ctx.factory.INT)
+			return null;
+		var set = _indexedSets[setIndex];
+		var keyAsString = ctx.factory.prettify(key);
+		print("SSL_indexedSet_getIndex " + setIndex + " " + keyAsString);
+		var r = set.getIndex(keyAsString);
+		print(r);
 		return r === undefined ? null : r;
 	}
-}
 
-StrategoJS.SSL.SSL_indexedSet_getIndex = function(ctx, currentTerm, setIndex, key) {
-	print("SSL_indexedSet_getIndex");
-	if(ctx.factory.termType(setIndex) !== ctx.factory.INT)
-		return null;
-	var set = StrategoJS.SSL._indexedSets[setIndex];
-	var keyAsString = ctx.factory.prettify(key);
-	print("SSL_indexedSet_getIndex " + setIndex + " " + keyAsString);
-	var r = set.getIndex(keyAsString);
-	print(r);
-	return r === undefined ? null : r;
-}
-
-StrategoJS.SSL.SSL_indexedSet_elements = function(ctx, currentTerm, setIndex) {
-	print("SSL_indexedSet_elements " + setIndex);
-	if(ctx.factory.termType(setIndex) !== ctx.factory.INT)
-		return null;
-	var set = StrategoJS.SSL._indexedSets[setIndex];
-	var tmp = set.sortedKeySet();
-	print(tmp);
-	var r = ctx.factory.makeEmptyList();
-	for(var i = tmp.length - 1; i >= 0; i--) {
-		if(tmp[i] == undefined)
-			throw "undefined set element";
-		r = ctx.factory.makeListCons(ctx.factory.parse(tmp[i]), r);
-	}
-	return r;
-}
-
-StrategoJS.SSL.SSL_hashtable_create = function(ctx, currentTerm, initialSize, maxLoad) {
-	print("SSL_hashtable_create");
-	StrategoJS.SSL._hashtables.push(_makeHashtable());
-	return StrategoJS.SSL._hashtables.length - 1;
-}
-
-StrategoJS.SSL.SSL_hashtable_destroy = function(ctx, currentTerm, hashIndex) {
-	print("SSL_hashtable_destroy");
-	if(ctx.factory.termType(hashIndex) !== ctx.factory.INT)
-		return null;
-	delete StrategoJS.SSL._hashtables[hashIndex];
-	return currentTerm;
-}
-
-StrategoJS.SSL.SSL_hashtable_put = function(ctx, currentTerm, hashIndex, key, value) {
-	print("SSL_hashtable_put");
-	if(ctx.factory.termType(hashIndex) !== ctx.factory.INT)
-		return null;
-	var hash = StrategoJS.SSL._hashtables[hashIndex];
-	var keyAsString = ctx.factory.prettify(key);
-	print("SSL_hashtable_put " + hashIndex + " " + keyAsString);
-	hash[keyAsString] = value;
-	return hashIndex;
-}
-
-StrategoJS.SSL.SSL_hashtable_keys = function(ctx, currentTerm, hashIndex, key, value) {
-	print("SSL_hashtable_keys " + hashIndex);
-	var hash = StrategoJS.SSL._hashtables[hashIndex];
-	var r = ctx.factory.makeEmptyList();
-	for(var k in hash) {
-		r = ctx.factory.makeListCons(ctx.factory.parse(k), r);
-	}
-	print("< " + ctx.factory.prettify(r));
-	return r;
-}
-
-StrategoJS.SSL.SSL_hashtable_remove = function(ctx, currentTerm, hashIndex, key) {
-	print("SSL_hashtable_remove");
-	var hash = StrategoJS.SSL._hashtables[hashIndex];
-	var keyAsString = ctx.factory.prettify(key);
-	print("SSL_hashtable_remove " + hashIndex + " " + keyAsString);
-	delete hash[keyAsString];
-	return hashIndex;
-}
-
-StrategoJS.SSL.SSL_explode_string = function(ctx, currentTerm, string) {
-	print("SSL_explode_string");
-	var f = ctx.factory;
-	if(f.termType(string) !== f.STRING)
-		return null;
-	var r = f.makeEmptyList();
-	for(var i = string.length - 1; i >= 0; i--) {
-		r = f.makeListCons(f.makeInt(string.charCodeAt(i)), r);
-	}
-	return r;
-}
-
-StrategoJS.SSL.SSL_implode_string = function(ctx, currentTerm, list) {
-	print("SSL_implode_string");
-	var f = ctx.factory;
-	if(f.termType(list) !== f.LIST)
-		return null;
-	var s = "";
-	while(!f.isEmptyList(list)) {
-		s += String.fromCharCode(f.head(list));
-		list = f.tail(list);
-	}
-	return s;
-}
-
-StrategoJS.SSL.SSL_stacktrace_get_all_frame_names = function(ctx, currentTerm) {
-	print("SSL_get_all_frame_names");
-	var frames = ctx.getStackFrames();
-	var f = ctx.factory;
-	var r = f.makeEmptyList();
-	for(var i = frames.length - 1; i >= 0; i--) {
-		r = f.makeListCons(frames[i], r);
-	}
-	return r;
-}
-
-
-StrategoJS.SSL.SSL_table_hashtable = function(ctx, currentTerm) {
-	print("SSL_table_hashtable");
-	return StrategoJS.SSL._TABLE_TABLE;
-}
-
-StrategoJS.SSL.SSL_gti = function(ctx, currentTerm, a, b) {
-	print("SSL_gti");
-	var f = ctx.factory;
-	if(f.termType(a) !== f.INT || f.termType(b) !== f.INT) { 
-		return null;
+	StrategoJS.SSL.SSL_indexedSet_elements = function(ctx, currentTerm, setIndex) {
+		print("SSL_indexedSet_elements " + setIndex);
+		if(ctx.factory.termType(setIndex) !== ctx.factory.INT)
+			return null;
+		var set = _indexedSets[setIndex];
+		var tmp = set.sortedKeySet();
+		print(tmp);
+		var r = ctx.factory.makeEmptyList();
+		for(var i = tmp.length - 1; i >= 0; i--) {
+			if(tmp[i] == undefined)
+				throw "undefined set element";
+			r = ctx.factory.makeListCons(ctx.factory.parse(tmp[i]), r);
+		}
+		return r;
 	}
-	return a > b;
-}
 
-StrategoJS.SSL.SSL_subti = function(ctx, currentTerm, a, b) {
-	print("SSL_gti");
-	var f = ctx.factory;
-	if(f.termType(a) !== f.INT || f.termType(b) !== f.INT) { 
-		return null;
+	StrategoJS.SSL.SSL_hashtable_create = function(ctx, currentTerm, initialSize, maxLoad) {
+		print("SSL_hashtable_create");
+		_hashtables.push(_makeHashtable());
+		return _hashtables.length - 1;
 	}
-	return a - b;
-}
 
-StrategoJS.SSL.SSL_concat_strings = function(ctx, currentTerm, s1, s2) {
-	print("SSL_concat_strings");
-	var f = ctx.factory;
-	if(f.termType(s1) !== f.STRING || f.termType(s2) !== f.STRING)
-		return null;
-	return s1 + s2;
-}
+	StrategoJS.SSL.SSL_hashtable_destroy = function(ctx, currentTerm, hashIndex) {
+		print("SSL_hashtable_destroy");
+		if(ctx.factory.termType(hashIndex) !== ctx.factory.INT)
+			return null;
+		delete _hashtables[hashIndex];
+		return currentTerm;
+	}
+
+	StrategoJS.SSL.SSL_hashtable_put = function(ctx, currentTerm, hashIndex, key, value) {
+		print("SSL_hashtable_put");
+		if(ctx.factory.termType(hashIndex) !== ctx.factory.INT)
+			return null;
+		var hash = _hashtables[hashIndex];
+		var keyAsString = ctx.factory.prettify(key);
+		print("SSL_hashtable_put " + hashIndex + " " + keyAsString);
+		hash[keyAsString] = value;
+		return hashIndex;
+	}
+
+	StrategoJS.SSL.SSL_hashtable_keys = function(ctx, currentTerm, hashIndex, key, value) {
+		print("SSL_hashtable_keys " + hashIndex);
+		var hash = _hashtables[hashIndex];
+		var r = ctx.factory.makeEmptyList();
+		for(var k in hash) {
+			r = ctx.factory.makeListCons(ctx.factory.parse(k), r);
+		}
+		return r;
+	}
 
-StrategoJS.SSL.SSL_getenv = function(ctx, currentTerm, name) {
-	print("SSL_getenv : " + name);
-	return null;
-}
-
-StrategoJS.SSL.SSL_strlen = function(ctx, currentTerm, string) {
-	print("SSL_strlen : " + string);
-	if(ctx.factory.termType(string) !== ctx.factory.STRING)
+	StrategoJS.SSL.SSL_hashtable_remove = function(ctx, currentTerm, hashIndex, key) {
+		print("SSL_hashtable_remove");
+		var hash = _hashtables[hashIndex];
+		var keyAsString = ctx.factory.prettify(key);
+		delete hash[keyAsString];
+		return hashIndex;
+	}
+
+	StrategoJS.SSL.SSL_table_hashtable = function(ctx, currentTerm) {
+		print("SSL_table_hashtable");
+		return _TABLE_TABLE;
+	}
+
+	StrategoJS.SSL.SSL_explode_string = function(ctx, currentTerm, string) {
+		print("SSL_explode_string");
+		var f = ctx.factory;
+		if(f.termType(string) !== f.STRING)
+			return null;
+		var r = f.makeEmptyList();
+		for(var i = string.length - 1; i >= 0; i--) {
+			r = f.makeListCons(f.makeInt(string.charCodeAt(i)), r);
+		}
+		return r;
+	}
+
+	StrategoJS.SSL.SSL_implode_string = function(ctx, currentTerm, list) {
+		print("SSL_implode_string");
+		var f = ctx.factory;
+		if(f.termType(list) !== f.LIST)
+			return null;
+		var s = "";
+		while(!f.isEmptyList(list)) {
+			s += String.fromCharCode(f.head(list));
+			list = f.tail(list);
+		}
+		return s;
+	}
+
+	StrategoJS.SSL.SSL_stacktrace_get_all_frame_names = function(ctx, currentTerm) {
+		print("SSL_get_all_frame_names");
+		var frames = ctx.getStackFrames();
+		var f = ctx.factory;
+		var r = f.makeEmptyList();
+		for(var i = frames.length - 1; i >= 0; i--) {
+			r = f.makeListCons(frames[i], r);
+		}
+		return r;
+	}
+
+
+
+	StrategoJS.SSL.SSL_gti = function(ctx, currentTerm, a, b) {
+		print("SSL_gti");
+		var f = ctx.factory;
+		if(f.termType(a) !== f.INT || f.termType(b) !== f.INT) { 
+			return null;
+		}
+		return a > b;
+	}
+
+	StrategoJS.SSL.SSL_subti = function(ctx, currentTerm, a, b) {
+		print("SSL_gti");
+		var f = ctx.factory;
+		if(f.termType(a) !== f.INT || f.termType(b) !== f.INT) { 
+			return null;
+		}
+		return a - b;
+	}
+
+	StrategoJS.SSL.SSL_concat_strings = function(ctx, currentTerm, s1, s2) {
+		print("SSL_concat_strings");
+		var f = ctx.factory;
+		if(f.termType(s1) !== f.STRING || f.termType(s2) !== f.STRING)
+			return null;
+		return s1 + s2;
+	}
+
+	StrategoJS.SSL.SSL_getenv = function(ctx, currentTerm, name) {
+		print("SSL_getenv : " + name);
 		return null;
-	return string.length;
-}
+	}
+
+	StrategoJS.SSL.SSL_strlen = function(ctx, currentTerm, string) {
+		print("SSL_strlen : " + string);
+		if(ctx.factory.termType(string) !== ctx.factory.STRING)
+			return null;
+		return string.length;
+	}
+
+	StrategoJS.SSL.SSL_exit = function(ctx, currentTerm) {
+		throw "Exit called";
+	}	
+
+	StrategoJS.SSL.SSL_is_int = function(ctx, currentTerm) {
+		print("SSL_is_int");
+		return ctx.factory.termType(currentTerm) === ctx.factory.INT;
+	}
 
-StrategoJS.SSL.SSL_exit = function(ctx, currentTerm) {
-	throw "Exit called";
-}	
-
-StrategoJS.SSL.SSL_is_int = function(ctx, currentTerm) {
-	print("SSL_is_int");
-	return ctx.factory.termType(currentTerm) === ctx.factory.INT;
-}
+	return true;
+}();

Modified: strategoxt-javascript-backend/trunk/src/javascript/strategojs.js
==============================================================================
--- strategoxt-javascript-backend/trunk/src/javascript/strategojs.js	Thu Dec  9 11:40:59 2010	(r21480)
+++ strategoxt-javascript-backend/trunk/src/javascript/strategojs.js	Thu Dec  9 11:50:17 2010	(r21481)
@@ -4,9 +4,9 @@
 
  // The global namespace for Stratego JavaScript backend
 
-StrategoJS = {}
+StrategoJS = {};
 
-var dummy = function() {
+StrategoJS._loaded = function() {
 	var knownLibraries = [];
 	
 	StrategoJS.registerLibrary = function(lib) {
@@ -37,7 +37,7 @@
 			throw msg;
 	}
 
-	
+	return true;
 }();
 
  // include order:

Modified: strategoxt-javascript-backend/trunk/src/javascript/terms.js
==============================================================================
--- strategoxt-javascript-backend/trunk/src/javascript/terms.js	Thu Dec  9 11:40:59 2010	(r21480)
+++ strategoxt-javascript-backend/trunk/src/javascript/terms.js	Thu Dec  9 11:50:17 2010	(r21481)
@@ -3,7 +3,9 @@
  * @author Lennart Kats
  */
 
-StrategoJS.Term = function() {
+StrategoJS.Term = {}
+
+StrategoJS.Term._loaded = function() {
 
 	//
 	//  private term implementation
@@ -92,7 +94,7 @@
 		return builder;
 	}
 
-	var reportInvalidSubterm = function(term, builder) {
+	function reportInvalidSubterm(term, builder) {
 		var s = "";
 		if(term === undefined) {
 			s += "undefined"
@@ -109,7 +111,7 @@
 		builder.push("<invalid subterm:" + s + ">");
 	} 
 	
-	var applPrettify = function(applTerm, builder) {
+	function applPrettify(applTerm, builder) {
 		builder.push(applTerm.getConstructor().name);
 		builder.push("(");
 		for(var i = 0; i < applTerm.args.length; i++) {
@@ -120,7 +122,7 @@
 		builder.push(")");
 	}
 
-	var tuplePrettify = function(tupleTerm, builder) {
+	function tuplePrettify(tupleTerm, builder) {
 		builder.push("(");
 		for(var i = 0; i < tupleTerm.length; i++) {
 			doPrettify(tupleTerm[i], builder, false);
@@ -130,7 +132,7 @@
 		builder.push(")");
 	}
 	
-	var doListPrettify = function(listTerm, builder) {
+	function doListPrettify(listTerm, builder) {
 		if(listTerm.head === null)
 			return;
 		doPrettify(listTerm.head, builder);
@@ -140,7 +142,7 @@
 		doListPrettify(tail, builder);
 	}
 	
-	var listPrettify = function(list, builder, skipParens) {
+	function listPrettify(list, builder, skipParens) {
 		if(!skipParens)
 			builder.push("[");
 		doListPrettify(list, builder);
@@ -148,7 +150,7 @@
 			builder.push("]");
 	}
 
-	var PushbackStringIterator = function(text) {
+	function PushbackStringIterator(text) {
 		this.offset = 0;
 		this.text = text;
 		this.read = function() {
@@ -268,7 +270,7 @@
 		return factory.makeString(sb.join(""));
 	};
 
-	var parseAppl = function(stringIterator) {
+	function parseAppl(stringIterator) {
 		var sb = [];
 		var ch = stringIterator.read();
 		do {
@@ -292,7 +294,7 @@
 		}
 	};
 
-	var parsePlaceholder = function(stringIterator) {
+	function parsePlaceholder(stringIterator) {
 		var template = parseFromStream(stringIterator);
 		parseSkip(stringIterator);
 		if (stringIterator.read() != '>') {
@@ -301,12 +303,12 @@
 		return makePlaceholder(template);
 	};
 
-	var parseTuple = function(stringIterator) {
+	function parseTuple(stringIterator) {
 		return factory.makeTuple(parseTermSequence(stringIterator, ')'));
 	};
 
 
-	var parseTermSequence = function(stringIterator, endChar) {
+	function parseTermSequence(stringIterator, endChar) {
 		var pos = stringIterator.offset;
 		var els = [];
 		parseSkip(stringIterator);
@@ -333,11 +335,11 @@
 		return els;
 	};
 
-	var parseList = function(stringIterator) {
+	function parseList(stringIterator) {
 		return factory.makeList(parseTermSequence(stringIterator, ']'));
 	};
 
-	var parseNumber = function(stringIterator) {
+	function parseNumber(stringIterator) {
 		var whole = parseDigitSequence(stringIterator);
 		var ch = stringIterator.read();
 		if(ch == '.') {
@@ -356,7 +358,7 @@
 		return factory.makeInt(parseInt(whole));
 	};
 
-	var parseDigitSequence = function(stringIterator) {
+	function parseDigitSequence(stringIterator) {
 		var sb = [];
 		var ch = stringIterator.read();
 		do {
@@ -367,7 +369,7 @@
 		return sb.join("");
 	};
 
-	var parseSkip = function(stringIterator){
+	function parseSkip(stringIterator){
 		for (;;) {
 			var b = stringIterator.read();
 			switch (b) {
@@ -661,5 +663,7 @@
 			realValue    : function(term) { return term.annoType ? term.term : term; },
 			stringValue  : function(term) { return term.annoType ? term.term : term; }
 	};
-	return factory;
+
+	StrategoJS.Term = factory;
+	return true;
 }();

Modified: strategoxt-javascript-backend/trunk/src/stratego/s2js.str
==============================================================================
--- strategoxt-javascript-backend/trunk/src/stratego/s2js.str	Thu Dec  9 11:40:59 2010	(r21480)
+++ strategoxt-javascript-backend/trunk/src/stratego/s2js.str	Thu Dec  9 11:50:17 2010	(r21481)
@@ -45,7 +45,7 @@
        [closure-name] = function() {
          var SRTS = StrategoJS.SRTS;
          var c = {};
-         var rootCtx = SRTS._initContext();
+         var rootCtx = SRTS.initContext();
          var factory = rootCtx.factory;
          var TRACES_ENABLED = true;
          var _Fail = StrategoJS.resolveImport("SSL_fail");
@@ -112,7 +112,7 @@
   	!$[
   		c.main = function(term) {
   			try {
-  				var t = main_0_0(rootCtx, SRTS._cliArgumentsToList(term, factory));
+  				var t = main_0_0(rootCtx, SRTS.cliArgumentsToList(term, factory));
   				if(t != null) {
   					rootCtx.debugLog(factory.prettify(t));
   					return t;

Modified: strategoxt-javascript-backend/trunk/src/stratego/term-construction.str
==============================================================================
--- strategoxt-javascript-backend/trunk/src/stratego/term-construction.str	Thu Dec  9 11:40:59 2010	(r21480)
+++ strategoxt-javascript-backend/trunk/src/stratego/term-construction.str	Thu Dec  9 11:50:17 2010	(r21481)
@@ -50,7 +50,7 @@
       e := <js-VarToReadRef> x
 
   js-ConstructAnnoVar(|f) :
-    Anno(Var(x), pt2) -> $[ factory.annotateTerm([e], StrategoJS.SRTS._checkListAnnos(factory, [<js-construct-term(|f)> pt2])) ]
+    Anno(Var(x), pt2) -> $[ factory.annotateTerm([e], StrategoJS.SRTS.checkListAnnos(factory, [<js-construct-term(|f)> pt2])) ]
   where
       <js-ConstructVar> Var(x) => e
 
@@ -60,7 +60,7 @@
       <not(?Var(_))> pt1
 
   js-ConstructTerm(|f) :
-    Anno(pt1, pt2) -> $[ factory.annotateTerm([<js-construct-term(|f)> pt1], StrategoJS.SRTS._checkListAnnos(factory,[<js-construct-term(|f)> pt2])) ]
+    Anno(pt1, pt2) -> $[ factory.annotateTerm([<js-construct-term(|f)> pt1], StrategoJS.SRTS.checkListAnnos(factory,[<js-construct-term(|f)> pt2])) ]
   where 
       <not(?Op("Nil", []))> pt2
     ; <not(?Var(_))> pt1
@@ -115,7 +115,7 @@
       js-CheckBuild :+=
         ( $[ var [x]; ]
         , $[
-            [x] = StrategoJS.SRTS._checkListTail([e]);
+            [x] = StrategoJS.SRTS.checkListTail([e]);
             if ([x] == null) break [feil];
           ]
         )

From R.B.Vermaas at tudelft.nl  Thu Dec  9 12:54:11 2010
From: R.B.Vermaas at tudelft.nl (Rob Vermaas)
Date: Thu, 09 Dec 2010 11:54:11 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21482 - hydra/jobs
Message-ID: <201012091154.oB9BsBgA007540@proliant.st.ewi.tudelft.nl>

Author: rob
Date: Thu Dec  9 11:54:11 2010
New Revision: 21482
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21482&sc=1

Log:
replace qualifier

Modified:
   hydra/jobs/spoofax-imp.nix

Modified: hydra/jobs/spoofax-imp.nix
==============================================================================
--- hydra/jobs/spoofax-imp.nix	Thu Dec  9 11:50:17 2010	(r21481)
+++ hydra/jobs/spoofax-imp.nix	Thu Dec  9 11:54:11 2010	(r21482)
@@ -70,7 +70,8 @@
 	                cp -R $d .
 	            stopNest
 	        done
-	        
+                sed -i 's|\.[0-9]\{12\}|.qualifier|g' org.strategoxt.imp.updatesite/site.xml
+
 	        cp -R ${shrike} com.ibm.wala.shrike
 	        cp -R ${lpgRuntime} lpg.runtime.java
 	        cp -R ${strategoxtJavaBackend} org.strategoxt.strj

From R.B.Vermaas at tudelft.nl  Thu Dec  9 13:00:34 2010
From: R.B.Vermaas at tudelft.nl (Rob Vermaas)
Date: Thu, 09 Dec 2010 12:00:34 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21483 - hydra/jobs
Message-ID: <201012091200.oB9C0YcH007816@proliant.st.ewi.tudelft.nl>

Author: rob
Date: Thu Dec  9 12:00:34 2010
New Revision: 21483
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21483&sc=1

Log:
replace qualifier

Modified:
   hydra/jobs/spoofax-imp.nix

Modified: hydra/jobs/spoofax-imp.nix
==============================================================================
--- hydra/jobs/spoofax-imp.nix	Thu Dec  9 11:54:11 2010	(r21482)
+++ hydra/jobs/spoofax-imp.nix	Thu Dec  9 12:00:34 2010	(r21483)
@@ -70,13 +70,13 @@
 	                cp -R $d .
 	            stopNest
 	        done
-                sed -i 's|\.[0-9]\{12\}|.qualifier|g' org.strategoxt.imp.updatesite/site.xml
 
 	        cp -R ${shrike} com.ibm.wala.shrike
 	        cp -R ${lpgRuntime} lpg.runtime.java
 	        cp -R ${strategoxtJavaBackend} org.strategoxt.strj
 	        
 	        chmod -R +w .
+                sed -i 's|\.[0-9]\{12\}|.qualifier|g' org.strategoxt.imp.updatesite/site.xml
 
 	        header "Patching org.eclipse.imp using ${spoofaxImp}/org.eclipse.imp/org.eclipse.imp.runtime.patch"
 	            patch -p0 < ${spoofaxImp}/org.eclipse.imp/org.eclipse.imp.runtime.patch

From karltk at strategoxt.org  Thu Dec  9 13:28:31 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 09 Dec 2010 12:28:31 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21484 - in
	strategoxt-javascript-backend/trunk/src: javascript stratego
Message-ID: <201012091228.oB9CSVMk008268@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec  9 12:28:31 2010
New Revision: 21484
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21484&sc=1

Log:
* Replaced all print calls to info/trace/error; to allow transition away from Rhino and the CLI.

Modified:
   strategoxt-javascript-backend/trunk/src/javascript/cli-wrapper.js
   strategoxt-javascript-backend/trunk/src/javascript/srts.js
   strategoxt-javascript-backend/trunk/src/javascript/ssl.js
   strategoxt-javascript-backend/trunk/src/javascript/strategojs.js
   strategoxt-javascript-backend/trunk/src/stratego/s2js.str
   strategoxt-javascript-backend/trunk/src/stratego/term-deconstruction.str

Modified: strategoxt-javascript-backend/trunk/src/javascript/cli-wrapper.js
==============================================================================
--- strategoxt-javascript-backend/trunk/src/javascript/cli-wrapper.js	Thu Dec  9 12:00:34 2010	(r21483)
+++ strategoxt-javascript-backend/trunk/src/javascript/cli-wrapper.js	Thu Dec  9 12:28:31 2010	(r21484)
@@ -1,5 +1,5 @@
 StrategoJS.registerLibrary(StrategoJS.SSL);
 StrategoJS.registerLibrary(StrategoJS.SRTS);
 StrategoJS.registerLibrary(StrategoJS.StrategoLib);
-debug().main(["./program"].concat(arguments));
+StrategoJS.init().main(["./program"].concat(arguments));
 

Modified: strategoxt-javascript-backend/trunk/src/javascript/srts.js
==============================================================================
--- strategoxt-javascript-backend/trunk/src/javascript/srts.js	Thu Dec  9 12:00:34 2010	(r21483)
+++ strategoxt-javascript-backend/trunk/src/javascript/srts.js	Thu Dec  9 12:28:31 2010	(r21484)
@@ -7,6 +7,7 @@
 
 StrategoJS.SRTS._loaded = function() {
 
+	var trace = StrategoJS.trace;
 
 	StrategoJS.SRTS.cliArgumentsToList = function(jslist, factory) {
 		var r = factory.makeEmptyList();
@@ -29,9 +30,9 @@
 				nextStackPos--;
 			},
 			printStackTrace : function() {
-				StrategoJS.log("rewriting failed, trace:");
+				StrategoJS.error("rewriting failed, trace:");
 				for(var i = 0; i < maxStackPos; i++)
-					StrategoJS.log("\t" + stack[i]);
+					StrategoJS.error("\t" + stack[i]);
 			},
 			popOnSuccess : function() {
 				nextStackPos--;
@@ -53,7 +54,7 @@
 	};
 
 	StrategoJS.SRTS.SRTS_one = function(ctx, term, fun) {
-		print("SRTS_one : " + term ? ctx.factory.prettify(term) : "undefined term");
+		trace("SRTS_one : " + term ? ctx.factory.prettify(term) : "undefined term");
 		var factory = ctx.factory;
 		var termType = factory.termType(term)
 		switch(termType) {
@@ -119,7 +120,7 @@
 	}
 
 	StrategoJS.SRTS.SRTS_all = function(ctx, term, fun) {
-		print("SRTS_all");
+		trace("SRTS_all");
 		var factory = ctx.factory;
 		switch(factory.termType(term)) {
 		case factory.REAL:
@@ -163,7 +164,7 @@
 	}
 
 	StrategoJS.SRTS.SRTS_some = function(ctx, term, fun) {
-		print("SRTS_some");
+		trace("SRTS_some");
 		var factory = ctx.factory;
 		switch(factory.termType(term)) {
 		case factory.REAL:

Modified: strategoxt-javascript-backend/trunk/src/javascript/ssl.js
==============================================================================
--- strategoxt-javascript-backend/trunk/src/javascript/ssl.js	Thu Dec  9 12:00:34 2010	(r21483)
+++ strategoxt-javascript-backend/trunk/src/javascript/ssl.js	Thu Dec  9 12:28:31 2010	(r21484)
@@ -10,6 +10,8 @@
 
 StrategoJS.SSL._loaded = function() {
 
+	var trace = StrategoJS.trace;
+	
 	var _stdin  = StrategoJS.Term.makeCtor("stdin", 0);
 	var _stdout = StrategoJS.Term.makeCtor("stdout", 0);
 	var _stderr = StrategoJS.Term.makeCtor("stderr", 0);
@@ -53,7 +55,7 @@
 	}
 
 	StrategoJS.SSL.SSL_mkterm = function(ctx, currentTerm, ctorTerm, args) {
-		print("SSL_mkterm");
+		trace("SSL_mkterm");
 		var factory = ctx.factory;
 		switch(factory.termType(ctorTerm)) {
 		case factory.STRING:
@@ -76,7 +78,7 @@
 	}
 
 	StrategoJS.SSL.SSL_addi = function(ctx, currentTerm, lhs, rhs) {
-		print("SSL_addi");
+		trace("SSL_addi");
 		var f = ctx.factory;
 		if(f.termType(lhs) !== f.INT || f.termType(rhs) !== f.INT)
 			return null;
@@ -84,7 +86,7 @@
 	}
 
 	StrategoJS.SSL.SSL_addr = function(ctx, currentTerm, lhs, rhs) {
-		print("SSL_addr");
+		trace("SSL_addr");
 		var f = ctx.factory;
 		if(f.termType(lhs) !== f.REAL || f.termType(rhs) !== f.REAL)
 			return null;
@@ -92,7 +94,7 @@
 	}
 
 	StrategoJS.SSL.SSL_write_term_to_stream_text = function(ctx, currentTerm, stream, outputTerm) {
-		print("SSL_write_term_to_stream_text");
+		trace("SSL_write_term_to_stream_text");
 		var ctor = ctx.factory.getConstructor(stream);
 		if(ctx.factory.ctorEquals(ctor, _stdout) || ctx.factory.ctorEquals(ctor, _stderr))
 			print(ctx.factory.prettify(outputTerm));
@@ -105,7 +107,7 @@
 	}
 
 	StrategoJS.SSL.SSL_read_term_from_stream = function(ctx, currentTerm, stream) {
-		print("SSL_read_term_from_stream");
+		trace("SSL_read_term_from_stream");
 		var ctor = ctx.factory.getConstructor(stream);
 		if(ctx.factory.ctorEquals(ctor, _stdin))
 			throw "SSL_read_term_from_stream does not support stdin"; 
@@ -130,7 +132,7 @@
 	}
 
 	StrategoJS.SSL.SSL_fputs = function(ctx, currentTerm, string, stream) {
-		print("SSL_fputs");
+		trace("SSL_fputs");
 		var ctor = ctx.factory.getConstructor(stream);
 		if(ctx.factory.ctorEquals(ctor, _stdout) || ctx.factory.ctorEquals(ctor, _stderr))
 			print(ctx.factory.stripAnnotations(string));
@@ -142,7 +144,7 @@
 	_openFiles = []
 
 	StrategoJS.SSL.SSL_fopen = function(ctx, currentTerm, fileName, mode) {
-		print("SSL_fopen : " + fileName + " " + mode);
+		trace("SSL_fopen : " + fileName + " " + mode);
 		if(mode === "w" || mode === "a") {
 			var f = new java.io.BufferedWriter(new java.io.FileWriter(fileName));
 			_openFiles.push(f)
@@ -156,7 +158,7 @@
 	}
 
 	StrategoJS.SSL.SSL_fclose = function(ctx, currentTerm, stream) {
-		print("SSL_fclose");
+		trace("SSL_fclose");
 		var f = _openFiles[stream];
 		if(f) {
 			f.close();
@@ -166,7 +168,7 @@
 	}
 
 	StrategoJS.SSL.SSL_fputc = function(ctx, currentTerm, ch, stream) {
-		print("SSL_fputc");
+		trace("SSL_fputc");
 		var ctor = ctx.factory.getConstructor(stream);
 		if(ctx.factory.ctorEquals(ctor, _stdout) || ctx.factory.ctorEquals(ctor, _stderr))
 			print(String.fromCharCode(ch));
@@ -179,7 +181,7 @@
 	}
 
 	StrategoJS.SSL.SSL_get_constructor = function(ctx, currentTerm, term) {
-		print("SSL_get_constructor");
+		trace("SSL_get_constructor");
 		return ctx.factory.getConstructor(term);
 	}
 
@@ -273,12 +275,12 @@
 	}
 
 	StrategoJS.SSL.SSL_dynamic_rules_hashtable = function(ctx, currentTerm) {
-		print("SSL_dynamic_rules_hashtable");
+		trace("SSL_dynamic_rules_hashtable");
 		return _DYN_TABLE;
 	}
 
 	StrategoJS.SSL.SSL_hashtable_get = function(ctx, currentTerm, tableReference, key) {
-		print("SSL_hashtable_get : " + tableReference);
+		trace("SSL_hashtable_get : " + tableReference);
 		var tbl = _hashtables[tableReference];
 		if(!tbl)
 			return null;
@@ -287,19 +289,19 @@
 	}
 
 	StrategoJS.SSL.SSL_indexedSet_create = function(ctx, currentTerm, initialSize, maxLoad) {
-		print("SSL_indexedSet_create");
+		trace("SSL_indexedSet_create");
 		_indexedSets.push(new _IndexedSet());
 		return _indexedSets.length - 1;
 	}
 
 	StrategoJS.SSL.SSL_indexedSet_destroy = function(ctx, currentTerm, setIndex) {
-		print("SSL_indexedSet_destroy");
+		trace("SSL_indexedSet_destroy");
 		delete _indexedSets[setIndex];
 		return currentTerm;
 	}
 
 	StrategoJS.SSL.SSL_indexedSet_reset = function(ctx, currentTerm, setIndex) {
-		print("SSL_indexedSet_reset");
+		trace("SSL_indexedSet_reset");
 		if(ctx.factory.termType(setIndex) !== ctx.factory.INT)
 			return null;
 		_indexedSets[setIndex].reset();
@@ -307,7 +309,7 @@
 	}
 
 	StrategoJS.SSL.SSL_indexedSet_put = function(ctx, currentTerm, strategy, setIndex, key) {
-		print("SSL_indexedSet_put : " + setIndex + " " + key);
+		trace("SSL_indexedSet_put : " + setIndex + " " + key);
 		if(ctx.factory.termType(setIndex) !== ctx.factory.INT)
 			return null;
 		var set = _indexedSets[setIndex];
@@ -324,7 +326,7 @@
 	}
 
 	StrategoJS.SSL.SSL_indexedSet_getIndex = function(ctx, currentTerm, setIndex, key) {
-		print("SSL_indexedSet_getIndex");
+		trace("SSL_indexedSet_getIndex");
 		if(ctx.factory.termType(setIndex) !== ctx.factory.INT)
 			return null;
 		var set = _indexedSets[setIndex];
@@ -336,12 +338,11 @@
 	}
 
 	StrategoJS.SSL.SSL_indexedSet_elements = function(ctx, currentTerm, setIndex) {
-		print("SSL_indexedSet_elements " + setIndex);
+		trace("SSL_indexedSet_elements " + setIndex);
 		if(ctx.factory.termType(setIndex) !== ctx.factory.INT)
 			return null;
 		var set = _indexedSets[setIndex];
 		var tmp = set.sortedKeySet();
-		print(tmp);
 		var r = ctx.factory.makeEmptyList();
 		for(var i = tmp.length - 1; i >= 0; i--) {
 			if(tmp[i] == undefined)
@@ -352,13 +353,13 @@
 	}
 
 	StrategoJS.SSL.SSL_hashtable_create = function(ctx, currentTerm, initialSize, maxLoad) {
-		print("SSL_hashtable_create");
+		trace("SSL_hashtable_create");
 		_hashtables.push(_makeHashtable());
 		return _hashtables.length - 1;
 	}
 
 	StrategoJS.SSL.SSL_hashtable_destroy = function(ctx, currentTerm, hashIndex) {
-		print("SSL_hashtable_destroy");
+		trace("SSL_hashtable_destroy");
 		if(ctx.factory.termType(hashIndex) !== ctx.factory.INT)
 			return null;
 		delete _hashtables[hashIndex];
@@ -366,18 +367,18 @@
 	}
 
 	StrategoJS.SSL.SSL_hashtable_put = function(ctx, currentTerm, hashIndex, key, value) {
-		print("SSL_hashtable_put");
+		trace("SSL_hashtable_put");
 		if(ctx.factory.termType(hashIndex) !== ctx.factory.INT)
 			return null;
 		var hash = _hashtables[hashIndex];
 		var keyAsString = ctx.factory.prettify(key);
-		print("SSL_hashtable_put " + hashIndex + " " + keyAsString);
+		trace("SSL_hashtable_put " + hashIndex + " " + keyAsString);
 		hash[keyAsString] = value;
 		return hashIndex;
 	}
 
 	StrategoJS.SSL.SSL_hashtable_keys = function(ctx, currentTerm, hashIndex, key, value) {
-		print("SSL_hashtable_keys " + hashIndex);
+		trace("SSL_hashtable_keys " + hashIndex);
 		var hash = _hashtables[hashIndex];
 		var r = ctx.factory.makeEmptyList();
 		for(var k in hash) {
@@ -387,7 +388,7 @@
 	}
 
 	StrategoJS.SSL.SSL_hashtable_remove = function(ctx, currentTerm, hashIndex, key) {
-		print("SSL_hashtable_remove");
+		trace("SSL_hashtable_remove");
 		var hash = _hashtables[hashIndex];
 		var keyAsString = ctx.factory.prettify(key);
 		delete hash[keyAsString];
@@ -395,12 +396,12 @@
 	}
 
 	StrategoJS.SSL.SSL_table_hashtable = function(ctx, currentTerm) {
-		print("SSL_table_hashtable");
+		trace("SSL_table_hashtable");
 		return _TABLE_TABLE;
 	}
 
 	StrategoJS.SSL.SSL_explode_string = function(ctx, currentTerm, string) {
-		print("SSL_explode_string");
+		trace("SSL_explode_string");
 		var f = ctx.factory;
 		if(f.termType(string) !== f.STRING)
 			return null;
@@ -412,7 +413,7 @@
 	}
 
 	StrategoJS.SSL.SSL_implode_string = function(ctx, currentTerm, list) {
-		print("SSL_implode_string");
+		trace("SSL_implode_string");
 		var f = ctx.factory;
 		if(f.termType(list) !== f.LIST)
 			return null;
@@ -425,7 +426,7 @@
 	}
 
 	StrategoJS.SSL.SSL_stacktrace_get_all_frame_names = function(ctx, currentTerm) {
-		print("SSL_get_all_frame_names");
+		trace("SSL_get_all_frame_names");
 		var frames = ctx.getStackFrames();
 		var f = ctx.factory;
 		var r = f.makeEmptyList();
@@ -438,7 +439,7 @@
 
 
 	StrategoJS.SSL.SSL_gti = function(ctx, currentTerm, a, b) {
-		print("SSL_gti");
+		trace("SSL_gti");
 		var f = ctx.factory;
 		if(f.termType(a) !== f.INT || f.termType(b) !== f.INT) { 
 			return null;
@@ -447,7 +448,7 @@
 	}
 
 	StrategoJS.SSL.SSL_subti = function(ctx, currentTerm, a, b) {
-		print("SSL_gti");
+		trace("SSL_gti");
 		var f = ctx.factory;
 		if(f.termType(a) !== f.INT || f.termType(b) !== f.INT) { 
 			return null;
@@ -456,7 +457,7 @@
 	}
 
 	StrategoJS.SSL.SSL_concat_strings = function(ctx, currentTerm, s1, s2) {
-		print("SSL_concat_strings");
+		trace("SSL_concat_strings");
 		var f = ctx.factory;
 		if(f.termType(s1) !== f.STRING || f.termType(s2) !== f.STRING)
 			return null;
@@ -464,12 +465,12 @@
 	}
 
 	StrategoJS.SSL.SSL_getenv = function(ctx, currentTerm, name) {
-		print("SSL_getenv : " + name);
+		trace("SSL_getenv : " + name);
 		return null;
 	}
 
 	StrategoJS.SSL.SSL_strlen = function(ctx, currentTerm, string) {
-		print("SSL_strlen : " + string);
+		trace("SSL_strlen : " + string);
 		if(ctx.factory.termType(string) !== ctx.factory.STRING)
 			return null;
 		return string.length;
@@ -480,7 +481,7 @@
 	}	
 
 	StrategoJS.SSL.SSL_is_int = function(ctx, currentTerm) {
-		print("SSL_is_int");
+		trace("SSL_is_int");
 		return ctx.factory.termType(currentTerm) === ctx.factory.INT;
 	}
 

Modified: strategoxt-javascript-backend/trunk/src/javascript/strategojs.js
==============================================================================
--- strategoxt-javascript-backend/trunk/src/javascript/strategojs.js	Thu Dec  9 12:00:34 2010	(r21483)
+++ strategoxt-javascript-backend/trunk/src/javascript/strategojs.js	Thu Dec  9 12:28:31 2010	(r21484)
@@ -32,6 +32,10 @@
 		return function() {}; 
 	}();
 	
+	StrategoJS.trace = StrategoJS.log;
+	StrategoJS.error = StrategoJS.log;
+	StrategoJS.info = StrategoJS.log;
+	
 	StrategoJS.assert = function(msg, e) {
 		if(e == false)
 			throw msg;

Modified: strategoxt-javascript-backend/trunk/src/stratego/s2js.str
==============================================================================
--- strategoxt-javascript-backend/trunk/src/stratego/s2js.str	Thu Dec  9 12:00:34 2010	(r21483)
+++ strategoxt-javascript-backend/trunk/src/stratego/s2js.str	Thu Dec  9 12:28:31 2010	(r21484)
@@ -42,9 +42,12 @@
   js-compile-spec:
     Specification([Signature([Constructors(ops)]), Strategies(defs)]) ->
     $[
-       [closure-name] = function() {
+       StrategoJS.[closure-name] = function() {
          var SRTS = StrategoJS.SRTS;
          var c = {};
+         var trace = StrategoJS.trace;
+         var error = StrategoJS.error;
+         var info = StrategoJS.info;
          var rootCtx = SRTS.initContext();
          var factory = rootCtx.factory;
          var TRACES_ENABLED = true;
@@ -99,7 +102,7 @@
 strategies
 	
   record-main-closurename =
-  	(<get-config> "-o" <+ strc-getoutfile(!"") <+ !"debug")
+  	(<get-config> "-o" <+ strc-getoutfile(!"") <+ !"init")
   ; base-filename
   ; jsify
   ; remove-extension
@@ -114,13 +117,12 @@
   			try {
   				var t = main_0_0(rootCtx, SRTS.cliArgumentsToList(term, factory));
   				if(t != null) {
-  					rootCtx.debugLog(factory.prettify(t));
+  					info(factory.prettify(t));
   					return t;
   				}
 			} catch(e) {
-				print("Stratego/JS internal exception :" + e);
+				error("Stratego/JS internal exception :" + e);
 			}
-			//rootCtx.debugLog("rewriting failed");
 			rootCtx.printStackTrace();
   			return null;
   		}
@@ -136,7 +138,7 @@
 	
   translate-outer-definition : 
     AnnoDef([Extend()], def @ SDefT(x, s*, t*, s)) -> $[
-    	var /* extend */ [x] = [body];
+    	var /* unsupported extend */ [x] = [body];
     ]
   with
   	body := <translate-definition-body> def   
@@ -144,14 +146,14 @@
 
   translate-outer-definition : 
     AnnoDef([Override()], def @ SDefT(x, s*, t*, s)) -> $[
-    	var /* override */ [x] = [body];
+    	var /* unsupported override */ [x] = [body];
     ]
   with
   	body := <translate-definition-body> def   
 
   translate-outer-definition : 
     AnnoDef([Internal()], def @ SDefT(x, s*, t*, s)) -> $[
-    	var /* internal */ [x] = [body];
+    	var /* unsupported internal */ [x] = [body];
     ]
   with
   	body := <translate-definition-body> def   
@@ -182,7 +184,7 @@
   	SDefT(x, s*, t*, s) ->
   	$[
      function(ctx, term [param*]) {
-       print("[x] : " + (term == undefined ? "undefined" : ctx.factory.prettify(term)));
+       trace("[x] : " + (term == undefined ? "undefined" : ctx.factory.prettify(term)));
        [bstm-init*]
        if(TRACES_ENABLED) ctx.push("[x]");
        [feil]: {
@@ -276,7 +278,7 @@
   	$[
         term = [x](ctx, term [args]);	
         if(term == null) {
-        	print("[feil] : return from [x]"); 
+        	trace("[feil] : return from [x]"); 
             break [feil];
         } else if(term == undefined) {
         	throw "internal error: call to [x] produced 'undefined' result";
@@ -324,7 +326,7 @@
       term = StrategoJS.SSL.[f](ctx, term [args]);
       if (term == null) {
       	ctx.popOnFailure();
-      	print("[feil]");
+      	trace("[feil]");
       	break [feil];
       } else if(term == undefined) {
       	throw "internal error: call to SSL.[f] gave undefined term"; 
@@ -342,7 +344,7 @@
   	Id() -> "/* id */"
   	
   translate-Fail(|s, feil):
-  	Fail() -> $[ {?print("[feil]"); break [feil]; } ]
+  	Fail() -> $[ {?trace("[feil]"); break [feil]; } ]
   	
   translate-Override(|s,f) = fail // TODO (karltk)
   

Modified: strategoxt-javascript-backend/trunk/src/stratego/term-deconstruction.str
==============================================================================
--- strategoxt-javascript-backend/trunk/src/stratego/term-deconstruction.str	Thu Dec  9 12:00:34 2010	(r21483)
+++ strategoxt-javascript-backend/trunk/src/stratego/term-deconstruction.str	Thu Dec  9 12:28:31 2010	(r21484)
@@ -38,7 +38,7 @@
     Match(Var(x){"bound"}, ReadFrom(e)) ->
     $[
       if ([e] != [e_var] && !factory.match([e_var],[e])) {
-      	print("[feil]"); 
+      	trace("[feil]"); 
         break [feil];
       }
      ]
@@ -51,7 +51,7 @@
       if ([e_var] == null) {
         [stm_assign]
       }?else if ([e_var] != [e] && !factory.match([e_var], [e])) {
-      	print("[feil]");
+      	trace("[feil]");
         break [feil];
       }
     ]
@@ -104,7 +104,7 @@
     Match(Str(str), e') -> 
     $[
       if (factory.termType([e]) !== factory.STRING || "[e_str]" !== factory.stringValue([e])) {
-      	print("[feil]");
+      	trace("[feil]");
         break [feil];
       }
     ]
@@ -116,7 +116,7 @@
     Match(Int(i), e') -> 
     $[
       if (factory.termType([e]) !== factory.INT || [e_int] !== factory.intValue([e])) {
-        print("[feil]");
+        trace("[feil]");
         break [feil];
       }
     ]
@@ -128,7 +128,7 @@
     Match(Real(r), e') -> 
     $[
       if (factory.termType([e]) !== factory.REAL || [e_real] !== factory.realValue([e])) {
-      	print("[feil]");
+      	trace("[feil]");
         break [feil];
       }
     ]
@@ -143,7 +143,7 @@
     Match(op at Op(c, ts), ReadFrom(e)) ->
     $[
       if (factory.termType([e]) !== factory.APPL || [e_nomatch]) {
-      	print("[feil]");
+      	trace("[feil]");
         break [feil];
       }
       [match-args]
@@ -166,7 +166,7 @@
     Match(op at Op(c, ts), ReadFrom(e)) ->
     $[
       if (factory.termType([e]) !== factory.TUPLE || factory.getSubtermCount([e]) !== [i]) {
-      	print("[feil]");
+      	trace("[feil]");
         break [feil];
       }
       [match-args]
@@ -213,7 +213,7 @@
     Match(Op("Nil", []), ReadFrom(e)) ->
     $[
       if(factory.termType([e]) !== factory.LIST || !factory.isEmptyList([e])) {
-      	print("[feil]");
+      	trace("[feil]");
         break [feil];
       }
     ]
@@ -222,7 +222,7 @@
     Match(Op("Cons", [hd, tl]), ReadFrom(e)) ->
     $[
       if(factory.termType([e]) !== factory.LIST || factory.isEmptyList([e])) {
-      	print("[feil]");
+      	trace("[feil]");
         break [feil];
       }
       [match-args]

From karltk at strategoxt.org  Thu Dec  9 13:53:33 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 09 Dec 2010 12:53:33 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21485 -
	strategoxt-javascript-backend/trunk/src/stratego
Message-ID: <201012091253.oB9CrXgX008627@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec  9 12:53:32 2010
New Revision: 21485
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21485&sc=1

Log:
* Added some credits.
 * Removed some unused code.

Modified:
   strategoxt-javascript-backend/trunk/src/stratego/backend-simplify.str
   strategoxt-javascript-backend/trunk/src/stratego/s2js.str
   strategoxt-javascript-backend/trunk/src/stratego/signatures.str
   strategoxt-javascript-backend/trunk/src/stratego/term-construction.str
   strategoxt-javascript-backend/trunk/src/stratego/term-deconstruction.str
   strategoxt-javascript-backend/trunk/src/stratego/utils.str

Modified: strategoxt-javascript-backend/trunk/src/stratego/backend-simplify.str
==============================================================================
--- strategoxt-javascript-backend/trunk/src/stratego/backend-simplify.str	Thu Dec  9 12:28:31 2010	(r21484)
+++ strategoxt-javascript-backend/trunk/src/stratego/backend-simplify.str	Thu Dec  9 12:53:32 2010	(r21485)
@@ -18,42 +18,13 @@
   
   backend-simplify =
     dr-scope-all-verbose(
-      dollars-for-capitals-top
 //    ; lift-definitions
-    ; canonicalize
+      canonicalize
     ; simplify1
     ; mark-bound-unbound-vars
     ; escaping-variables
     ; remove-closure-allocs
     )
-
-rules
-  
-  /**
-   * Adds dollars to names with capitals (e.g. Desugar becomes $Desugar).
-   * Doing so is required for supporting (Windows/Mac) case-insensitive file systems.
-   */
-  dollars-for-capitals-top =
-    topdown(try(
-      SVar(dollars-for-capitals)
-    + SDefT(dollars-for-capitals, id, id, id)
-    + ExtSDef(dollars-for-capitals, id, id)
-    ))
-   
-  dollars-for-capitals =
-    // We make an exception for the hand-crafted SRTS_EXT Java classes
-    if not(string-starts-with(|"SRTS_EXT")) then
-      escape(dollar-for-capital)
-    end
-  
-  dollar-for-capital(rec) :
-    [c | cs] -> ['$', c | <rec> cs] where <is-upper> c
-  
-  undo-dollars-for-capitals =
-    escape(undo-dollar-for-capital)
-  
-  undo-dollar-for-capital(rec) :
-    ['$' | cs] -> <rec> cs
   
 rules
 

Modified: strategoxt-javascript-backend/trunk/src/stratego/s2js.str
==============================================================================
--- strategoxt-javascript-backend/trunk/src/stratego/s2js.str	Thu Dec  9 12:28:31 2010	(r21484)
+++ strategoxt-javascript-backend/trunk/src/stratego/s2js.str	Thu Dec  9 12:53:32 2010	(r21485)
@@ -1,4 +1,6 @@
 /*
+ * JavaScript backend for Stratego.
+ *
  * @author Karl Trygve Kalleberg <karltk at strategoxt.org>
  * @author Lennart Kats
  */
@@ -233,15 +235,6 @@
   	 frame := <CurrentLiftedFrame>
    ; rules(IsStrategyArg: (frame, x))
   
-
-//  translate-inner-definition:
-//  	SDefT(x, s*, t*, s) ->
-//  	$[
-//  		var [x] = [body];
-//  	]
-//  with
-//  	body := <translate-definition-body>
-  	
  //
  //  Strategies
  //
@@ -271,7 +264,7 @@
   	 ) 
   	
 
-  translate-CallT-dynamic(|s,feil) = fail // TODO (karltk)
+  translate-CallT-dynamic(|s,feil) = fail // TODO(karltk)
   
   translate-CallT(|s,feil):
   	CallT(SVar(x), s*, t*) -> 
@@ -309,7 +302,7 @@
   with
   	{| js-CheckBuild : 
   	    e := <js-construct-term(|f)> t
-  	  ; (dec*, stm*) := <bagof-js-CheckBuild ; unzip /* FIXME reverse? */> e    
+  	  ; (dec*, stm*) := <bagof-js-CheckBuild ; unzip> e    
   	|}
   	
 

Modified: strategoxt-javascript-backend/trunk/src/stratego/signatures.str
==============================================================================
--- strategoxt-javascript-backend/trunk/src/stratego/signatures.str	Thu Dec  9 12:28:31 2010	(r21484)
+++ strategoxt-javascript-backend/trunk/src/stratego/signatures.str	Thu Dec  9 12:53:32 2010	(r21485)
@@ -1,3 +1,8 @@
+/**
+ *
+ * @author Karl Trygve Kalleberg
+ */
+
 module signatures
 imports
   libstrc

Modified: strategoxt-javascript-backend/trunk/src/stratego/term-construction.str
==============================================================================
--- strategoxt-javascript-backend/trunk/src/stratego/term-construction.str	Thu Dec  9 12:28:31 2010	(r21484)
+++ strategoxt-javascript-backend/trunk/src/stratego/term-construction.str	Thu Dec  9 12:53:32 2010	(r21485)
@@ -1,3 +1,9 @@
+/**
+ *
+ * @author Lennart Kats
+ * @author Karl Trygve Kalleberg
+ */
+ 
 module term-construction
 imports
   libstratego-lib

Modified: strategoxt-javascript-backend/trunk/src/stratego/term-deconstruction.str
==============================================================================
--- strategoxt-javascript-backend/trunk/src/stratego/term-deconstruction.str	Thu Dec  9 12:28:31 2010	(r21484)
+++ strategoxt-javascript-backend/trunk/src/stratego/term-deconstruction.str	Thu Dec  9 12:53:32 2010	(r21485)
@@ -1,3 +1,9 @@
+/**
+ *
+ * @author Lennart Kats
+ * @author Karl Trygve Kalleberg
+ */
+
 module term-deconstruction
 imports
  libstrc

Modified: strategoxt-javascript-backend/trunk/src/stratego/utils.str
==============================================================================
--- strategoxt-javascript-backend/trunk/src/stratego/utils.str	Thu Dec  9 12:28:31 2010	(r21484)
+++ strategoxt-javascript-backend/trunk/src/stratego/utils.str	Thu Dec  9 12:53:32 2010	(r21485)
@@ -1,3 +1,8 @@
+/**
+ *
+ * @author Karl Trygve Kalleberg
+ */
+ 
 module utils
 imports
   libstratego-lib

From L.C.L.Kats at tudelft.nl  Thu Dec  9 14:03:09 2010
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Thu, 09 Dec 2010 13:03:09 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21486 - in
	spoofax-imp/trunk: org.strategoxt.imp.editors.aster
	org.strategoxt.imp.editors.aterm
	org.strategoxt.imp.editors.editorservice
	org.strategoxt.imp.editors.pp org....
Message-ID: <201012091303.oB9D39sb008948@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: Thu Dec  9 13:03:09 2010
New Revision: 21486
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21486&sc=1

Log:
Proper comments for colors. Some generated build files.

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.aster/build.generated.xml
   spoofax-imp/trunk/org.strategoxt.imp.editors.aterm/build.generated.xml
   spoofax-imp/trunk/org.strategoxt.imp.editors.editorservice/build.generated.xml
   spoofax-imp/trunk/org.strategoxt.imp.editors.pp/build.generated.xml
   spoofax-imp/trunk/org.strategoxt.imp.editors.sdf/build.generated.xml
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/TokenColorer.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.aster/build.generated.xml
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.aster/build.generated.xml	Thu Dec  9 12:53:32 2010	(r21485)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.aster/build.generated.xml	Thu Dec  9 13:03:09 2010	(r21486)
@@ -3,8 +3,8 @@
 <project name="build.generated">
 
         <target name="spoofaximp.default" depends="spoofaximp.default.ctree"/>
-        <target name="spoofaximp.default.ctree" depends="check-classpath,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.ctree,java.jar,sdf2imp,refresh"/>
-        <target name="spoofaximp.default.jar" depends="check-classpath,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.jar,  java.jar,sdf2imp,refresh"/>
+        <target name="spoofaximp.default.ctree" depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.ctree,java.jar,sdf2imp,refresh"/>
+        <target name="spoofaximp.default.jar" depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.jar,  java.jar,sdf2imp,refresh"/>
     
         <!-- Initialization -->
         <available file="${build}/org/strategoxt/imp/editors/aster/strategies/Main.class" property="java.jar.enabled"/>
@@ -84,6 +84,13 @@
             <available classname="org.strategoxt.imp.generator.sdf2imp" property="check-classpath.available"/>
             <antcall target="check-classpath.helper"/>  
         </target>
+        
+        <target name="init" if="eclipse.running">
+            <!-- refresh one file/dir in the project to trigger an Ant rebuild with the next build command -->
+            <java classname="org.strategoxt.imp.metatooling.building.AntForceRefreshScheduler" failonerror="false">
+                <arg value="${include}"/>
+            </java>
+        </target>
   
         <target name="check-classpath.helper" unless="check-classpath.available">
             <echo level="error" message="Could not load the Spoofax plugin loading classes."/>

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.aterm/build.generated.xml
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.aterm/build.generated.xml	Thu Dec  9 12:53:32 2010	(r21485)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.aterm/build.generated.xml	Thu Dec  9 13:03:09 2010	(r21486)
@@ -3,8 +3,8 @@
 <project name="build.generated">
 
         <target name="spoofaximp.default" depends="spoofaximp.default.ctree"/>
-        <target name="spoofaximp.default.ctree" depends="check-classpath,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.ctree,java.jar,sdf2imp,refresh"/>
-        <target name="spoofaximp.default.jar" depends="check-classpath,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.jar,  java.jar,sdf2imp,refresh"/>
+        <target name="spoofaximp.default.ctree" depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.ctree,java.jar,sdf2imp,refresh"/>
+        <target name="spoofaximp.default.jar" depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.jar,  java.jar,sdf2imp,refresh"/>
     
         <!-- Initialization -->
         <available file="${build}/org/strategoxt/imp/editors/aterm/strategies/Main.class" property="java.jar.enabled"/>
@@ -84,6 +84,13 @@
             <available classname="org.strategoxt.imp.generator.sdf2imp" property="check-classpath.available"/>
             <antcall target="check-classpath.helper"/>  
         </target>
+        
+        <target name="init" if="eclipse.running">
+            <!-- refresh one file/dir in the project to trigger an Ant rebuild with the next build command -->
+            <java classname="org.strategoxt.imp.metatooling.building.AntForceRefreshScheduler" failonerror="false">
+                <arg value="${include}"/>
+            </java>
+        </target>
   
         <target name="check-classpath.helper" unless="check-classpath.available">
             <echo level="error" message="Could not load the Spoofax plugin loading classes."/>

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.editorservice/build.generated.xml
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.editorservice/build.generated.xml	Thu Dec  9 12:53:32 2010	(r21485)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.editorservice/build.generated.xml	Thu Dec  9 13:03:09 2010	(r21486)
@@ -3,8 +3,8 @@
 <project name="build.generated">
 
         <target name="spoofaximp.default" depends="spoofaximp.default.ctree"/>
-        <target name="spoofaximp.default.ctree" depends="check-classpath,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.ctree,java.jar,sdf2imp,refresh"/>
-        <target name="spoofaximp.default.jar" depends="check-classpath,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.jar,  java.jar,sdf2imp,refresh"/>
+        <target name="spoofaximp.default.ctree" depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.ctree,java.jar,sdf2imp,refresh"/>
+        <target name="spoofaximp.default.jar" depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.jar,  java.jar,sdf2imp,refresh"/>
     
         <!-- Initialization -->
         <available file="${build}/org/strategoxt/imp/editors/editorservice/strategies/Main.class" property="java.jar.enabled"/>
@@ -84,6 +84,13 @@
             <available classname="org.strategoxt.imp.generator.sdf2imp" property="check-classpath.available"/>
             <antcall target="check-classpath.helper"/>  
         </target>
+        
+        <target name="init" if="eclipse.running">
+            <!-- refresh one file/dir in the project to trigger an Ant rebuild with the next build command -->
+            <java classname="org.strategoxt.imp.metatooling.building.AntForceRefreshScheduler" failonerror="false">
+                <arg value="${include}"/>
+            </java>
+        </target>
   
         <target name="check-classpath.helper" unless="check-classpath.available">
             <echo level="error" message="Could not load the Spoofax plugin loading classes."/>

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.pp/build.generated.xml
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.pp/build.generated.xml	Thu Dec  9 12:53:32 2010	(r21485)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.pp/build.generated.xml	Thu Dec  9 13:03:09 2010	(r21486)
@@ -3,8 +3,8 @@
 <project name="build.generated">
 
         <target name="spoofaximp.default" depends="spoofaximp.default.ctree"/>
-        <target name="spoofaximp.default.ctree" depends="check-classpath,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.ctree,java.jar,sdf2imp,refresh"/>
-        <target name="spoofaximp.default.jar" depends="check-classpath,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.jar,  java.jar,sdf2imp,refresh"/>
+        <target name="spoofaximp.default.ctree" depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.ctree,java.jar,sdf2imp,refresh"/>
+        <target name="spoofaximp.default.jar" depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.jar,  java.jar,sdf2imp,refresh"/>
     
         <!-- Initialization -->
         <available file="${build}/org/strategoxt/imp/editors/pp/strategies/Main.class" property="java.jar.enabled"/>
@@ -84,6 +84,13 @@
             <available classname="org.strategoxt.imp.generator.sdf2imp" property="check-classpath.available"/>
             <antcall target="check-classpath.helper"/>  
         </target>
+        
+        <target name="init" if="eclipse.running">
+            <!-- refresh one file/dir in the project to trigger an Ant rebuild with the next build command -->
+            <java classname="org.strategoxt.imp.metatooling.building.AntForceRefreshScheduler" failonerror="false">
+                <arg value="${include}"/>
+            </java>
+        </target>
   
         <target name="check-classpath.helper" unless="check-classpath.available">
             <echo level="error" message="Could not load the Spoofax plugin loading classes."/>

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.sdf/build.generated.xml
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.sdf/build.generated.xml	Thu Dec  9 12:53:32 2010	(r21485)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.sdf/build.generated.xml	Thu Dec  9 13:03:09 2010	(r21486)
@@ -3,8 +3,8 @@
 <project name="build.generated">
 
         <target name="spoofaximp.default" depends="spoofaximp.default.ctree"/>
-        <target name="spoofaximp.default.ctree" depends="check-classpath,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.ctree,java.jar,sdf2imp,refresh"/>
-        <target name="spoofaximp.default.jar" depends="check-classpath,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.jar,  java.jar,sdf2imp,refresh"/>
+        <target name="spoofaximp.default.ctree" depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.ctree,java.jar,sdf2imp,refresh"/>
+        <target name="spoofaximp.default.jar" depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.jar,  java.jar,sdf2imp,refresh"/>
     
         <!-- Initialization -->
         <available file="${build}/org/strategoxt/imp/editors/sdf/strategies/Main.class" property="java.jar.enabled"/>
@@ -84,6 +84,13 @@
             <available classname="org.strategoxt.imp.generator.sdf2imp" property="check-classpath.available"/>
             <antcall target="check-classpath.helper"/>  
         </target>
+        
+        <target name="init" if="eclipse.running">
+            <!-- refresh one file/dir in the project to trigger an Ant rebuild with the next build command -->
+            <java classname="org.strategoxt.imp.metatooling.building.AntForceRefreshScheduler" failonerror="false">
+                <arg value="${include}"/>
+            </java>
+        </target>
   
         <target name="check-classpath.helper" unless="check-classpath.available">
             <echo level="error" message="Could not load the Spoofax plugin loading classes."/>

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/TokenColorer.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/TokenColorer.java	Thu Dec  9 12:53:32 2010	(r21485)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/TokenColorer.java	Thu Dec  9 13:03:09 2010	(r21486)
@@ -109,7 +109,8 @@
 		}
 		 
 		TextAttribute tokenColor = getColoring(tokenMappings, constructor, sort, tokenKind);
-		if (nodeColor == null) nodeColor = getColoring(nodeMappings, constructor, sort, tokenKind);
+		if (nodeColor == null && tokenKind != TokenKind.TK_LAYOUT.ordinal())
+			nodeColor = getColoring(nodeMappings, constructor, sort, tokenKind);
 		TextAttribute result = mergeStyles(nodeColor, tokenColor);
 		
 		if (node != null) {

From L.C.L.Kats at tudelft.nl  Thu Dec  9 15:12:16 2010
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Thu, 09 Dec 2010 14:12:16 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21487 - in
	spoofax-imp/trunk: org.strategoxt.imp.feature
	org.strategoxt.imp.updatesite
Message-ID: <201012091412.oB9ECGx7010000@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: Thu Dec  9 14:12:16 2010
New Revision: 21487
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21487&sc=1

Log:
New release 0.60.0 (skipping 0.5.3/0.53 as a stable release)

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.feature/feature.xml
   spoofax-imp/trunk/org.strategoxt.imp.updatesite/site.xml

Modified: spoofax-imp/trunk/org.strategoxt.imp.feature/feature.xml
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.feature/feature.xml	Thu Dec  9 13:03:09 2010	(r21486)
+++ spoofax-imp/trunk/org.strategoxt.imp.feature/feature.xml	Thu Dec  9 14:12:16 2010	(r21487)
@@ -2,7 +2,7 @@
 <feature
       id="org.strategoxt.imp"
       label="Spoofax/IMP"
-      version="0.53.95.qualifier"
+      version="0.60.0.qualifier"
       plugin="org.strategoxt.imp.runtime">
 
    <description url="http://strategoxt.org/Stratego/Spoofax-IMP">

Modified: spoofax-imp/trunk/org.strategoxt.imp.updatesite/site.xml
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.updatesite/site.xml	Thu Dec  9 13:03:09 2010	(r21486)
+++ spoofax-imp/trunk/org.strategoxt.imp.updatesite/site.xml	Thu Dec  9 14:12:16 2010	(r21487)
@@ -3,7 +3,7 @@
    <description name="Spoofax/IMP" url="http://www.lclnet.nl/update/">
       Spoofax/IMP update site
    </description>
-   <feature url="features/org.strategoxt.imp_0.53.95.201012081616.jar" id="org.strategoxt.imp" version="0.53.95.201012081616">
+   <feature url="features/org.strategoxt.imp_0.60.0.201012091355.jar" id="org.strategoxt.imp" version="0.60.0.201012091355">
       <category name="Spoofax/IMP"/>
    </feature>
    <category-def name="Spoofax/IMP" label="Spoofax/IMP">

From L.C.L.Kats at tudelft.nl  Thu Dec  9 16:04:14 2010
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Thu, 09 Dec 2010 15:04:14 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21488 - in
	spoofax-imp/trunk: . org.strategoxt.imp.editors.rtg
	org.strategoxt.imp.editors.rtg/editor
	org.strategoxt.imp.editors.rtg/lib
	org.strategoxt.imp.editors.rtg/synt...
Message-ID: <201012091504.oB9F4ERZ010717@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: Thu Dec  9 15:04:14 2010
New Revision: 21488
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21488&sc=1

Log:
Moved rtg.text.tbl to non-source directory.

Added:
   spoofax-imp/trunk/org.strategoxt.imp.editors.rtg/lib/rtg.text.tbl
      - copied unchanged from r21485, spoofax-imp/trunk/org.strategoxt.imp.editors.rtg/syntax/rtg.text.tbl
Deleted:
   spoofax-imp/trunk/org.strategoxt.imp.editors.rtg/syntax/rtg.text.tbl
Modified:
   spoofax-imp/trunk/Makefile
   spoofax-imp/trunk/org.strategoxt.imp.editors.rtg/build.generated.xml
   spoofax-imp/trunk/org.strategoxt.imp.editors.rtg/editor/rtg.main.esv
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/build.generated.xml

Modified: spoofax-imp/trunk/Makefile
==============================================================================
--- spoofax-imp/trunk/Makefile	Thu Dec  9 14:12:16 2010	(r21487)
+++ spoofax-imp/trunk/Makefile	Thu Dec  9 15:04:14 2010	(r21488)
@@ -5,7 +5,9 @@
       org.strategoxt.imp.editors.stratego.ant \
       org.strategoxt.imp.editors.aterm.ant \
       org.strategoxt.imp.editors.aster.ant \
-      org.strategoxt.imp.editors.pp.ant
+      org.strategoxt.imp.editors.pp.ant \
+      org.strategoxt.imp.editors.rtg.ant \
+      org.strategoxt.imp.editors.spoofax.ant
 
 org.strategoxt.imp.generator/lib/sdf2imp.jar : org.strategoxt.imp.generator/lib/strategoxt.jar .PHONY
 	$(MAKE) -C org.strategoxt.imp.generator all

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.rtg/build.generated.xml
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.rtg/build.generated.xml	Thu Dec  9 14:12:16 2010	(r21487)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.rtg/build.generated.xml	Thu Dec  9 15:04:14 2010	(r21488)
@@ -3,8 +3,8 @@
 <project name="build.generated">
 
         <target name="spoofaximp.default" depends="spoofaximp.default.ctree"/>
-        <target name="spoofaximp.default.ctree" depends="check-classpath,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.ctree,java.jar,sdf2imp,refresh"/>
-        <target name="spoofaximp.default.jar" depends="check-classpath,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.jar,  java.jar,sdf2imp,refresh"/>
+        <target name="spoofaximp.default.ctree" depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.ctree,java.jar,sdf2imp,refresh"/>
+        <target name="spoofaximp.default.jar" depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.jar,  java.jar,sdf2imp,refresh"/>
     
         <!-- Initialization -->
         <available file="${build}/org/strategoxt/imp/editors/rtg/strategies/Main.class" property="java.jar.enabled"/>
@@ -84,6 +84,13 @@
             <available classname="org.strategoxt.imp.generator.sdf2imp" property="check-classpath.available"/>
             <antcall target="check-classpath.helper"/>  
         </target>
+        
+        <target name="init" if="eclipse.running">
+            <!-- refresh one file/dir in the project to trigger an Ant rebuild with the next build command -->
+            <java classname="org.strategoxt.imp.metatooling.building.AntForceRefreshScheduler" failonerror="false">
+                <arg value="${include}"/>
+            </java>
+        </target>
   
         <target name="check-classpath.helper" unless="check-classpath.available">
             <echo level="error" message="Could not load the Spoofax plugin loading classes."/>

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.rtg/editor/rtg.main.esv
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.rtg/editor/rtg.main.esv	Thu Dec  9 14:12:16 2010	(r21487)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.rtg/editor/rtg.main.esv	Thu Dec  9 15:04:14 2010	(r21488)
@@ -12,5 +12,5 @@
   url           : http://strategoxt.org
                   
   extensions    : rtg
-  table         : syntax/rtg.text.tbl
+  table         : lib/rtg.text.tbl
   start symbols : RTG

Copied: spoofax-imp/trunk/org.strategoxt.imp.editors.rtg/lib/rtg.text.tbl (from r21485, spoofax-imp/trunk/org.strategoxt.imp.editors.rtg/syntax/rtg.text.tbl)
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.rtg/lib/rtg.text.tbl	Thu Dec  9 15:04:14 2010	(r21488, copy of r21485, spoofax-imp/trunk/org.strategoxt.imp.editors.rtg/syntax/rtg.text.tbl)
@@ -0,0 +1 @@
+parse-table(6,0,[label(prod([sort("<START>"),char-class([256])],sort("<Start>"),no-attrs),473),label(prod([cf(layout),cf(layout)],cf(layout),attrs([assoc(left)])),472),label(prod([sort("Id")],cf(sort("Id")),no-attrs),471),label(prod([lex(sort("PlainIdChars"))],sort("Id"),attrs([term(cons("Plain"))])),470),label(prod([lit("["),iter-star(sort("QuotedIdPart")),lit("]")],sort("Id"),attrs([term(cons("Quoted"))])),469),label(prod([lex(sort("QuotedIdChars"))],sort("QuotedIdPart"),attrs([term(cons("Chars"))])),468),label(prod([lit("\\"),char-class([range(92,93)])],sort("QuotedIdPart"),attrs([term(cons("EscapeSeq"))])),467),label(prod([lex(iter(char-class([range(0,91),range(94,255)])))],lex(sort("QuotedIdChars")),no-attrs),466),label(prod([lex(sort("QuotedIdChars"))],cf(sort("QuotedIdChars")),no-attrs),465),label(prod([lex(iter(char-class([39,45,range(48,57),range(65,90),95,range(97,122)])))],lex(sort("PlainIdChars")),no-attrs),464),label(prod([lex(sort("PlainIdChars"))],cf(sort("Pl!
 ainIdChars")),no-attrs),463),label(prod([lex(iter(char-class([range(48,57)])))],lex(sort("IntConst")),no-attrs),462),label(prod([lex(sort("IntConst"))],cf(sort("IntConst")),no-attrs),461),label(prod([cf(sort("Id"))],cf(sort("Term")),attrs([term(cons("Term"))])),460),label(prod([lit("<conc>")],cf(sort("Term")),attrs([term(cons("ConcTerm"))])),459),label(prod([lit("<cons>")],cf(sort("Term")),attrs([term(cons("ConsTerm"))])),458),label(prod([lit("<nil>")],cf(sort("Term")),attrs([term(cons("NilTerm"))])),457),label(prod([lit("<("),cf(opt(layout)),cf(sort("IntConst")),cf(opt(layout)),lit(")>")],cf(sort("Term")),attrs([term(cons("TupleTerm"))])),456),label(prod([lit("<some>")],cf(sort("Term")),attrs([term(cons("SomeTerm"))])),455),label(prod([lit("<none>")],cf(sort("Term")),attrs([term(cons("NoneTerm"))])),454),label(prod([lit("<string>")],cf(sort("Term")),attrs([term(cons("StringTerm"))])),453),label(prod([lit("<int>")],cf(sort("Term")),attrs([term(cons("IntTerm"))])),452),label!
 (prod([cf(sort("Id"))],cf(sort("NonTerm")),attrs([term(cons("Nonterm
])),451),label(prod([lit("<string>")],cf(sort("NonTerm")),attrs([term(cons("String"))])),450),label(prod([lit("<int>")],cf(sort("NonTerm")),attrs([term(cons("Int"))])),449),label(prod([char-class([range(0,47),range(58,64),range(91,94),96,range(123,255)])],lex(sort("WATERTOKENSTART")),attrs([term(recover),avoid])),448),label(prod([lex(sort("WATERTOKENSTART"))],cf(sort("WATERTOKENSTART")),no-attrs),447),label(prod([lex(sort("WATERTOKENSTART")),lex(iter-star(char-class([range(48,57),range(65,90),95,range(97,122)])))],lex(sort("WATERTOKEN")),no-attrs),446),label(prod([lex(sort("WATERTOKEN"))],cf(sort("WATERTOKEN")),no-attrs),445),label(prod([char-class([range(0,8),11,range(14,31),range(33,41),range(43,47),range(58,64),range(91,94),96,range(123,255)])],lex(sort("WATERTOKENSEPARATOR")),attrs([term(recover),avoid])),444),label(prod([lex(sort("WATERTOKENSEPARATOR"))],cf(sort("WATERTOKENSEPARATOR")),no-attrs),443),label(prod([lit("*")],lex(sort("WATERTOKENSTAR")),attrs([term(recover)!
 ,avoid])),442),label(prod([lex(sort("WATERTOKENSTAR"))],cf(sort("WATERTOKENSTAR")),no-attrs),441),label(prod([lex(sort("WATERTOKEN"))],lex(sort("WATER")),no-attrs),440),label(prod([lex(sort("WATER"))],cf(sort("WATER")),no-attrs),439),label(prod([lex(sort("WATERTOKENSEPARATOR"))],lex(sort("WATER")),no-attrs),438),label(prod([lex(sort("WATERTOKENSTAR"))],lex(sort("WATER")),no-attrs),437),label(prod([],lex(sort("WATEREOF")),no-attrs),436),label(prod([lex(sort("WATEREOF"))],cf(sort("WATEREOF")),no-attrs),435),label(prod([cf(sort("WATER"))],cf(layout),attrs([term(cons("WATER"))])),434),label(prod([lit("/*")],lex(sort("INSERTSTART3")),attrs([term(recover)])),433),label(prod([lex(sort("INSERTSTART3"))],cf(sort("INSERTSTART3")),no-attrs),432),label(prod([lex(sort("INSERTSTART3")),lex(iter(sort("CommChar"))),lex(sort("WATEREOF"))],lex(layout),attrs([term(cons("INSERTEND"))])),431),label(prod([lex(layout)],cf(layout),no-attrs),430),label(prod([],lit(")>"),attrs([term(recover),term(co!
 ns("INSERTION"))])),429),label(prod([lit(")>")],lit(")>"),no-attrs),
),label(prod([],lit("<("),attrs([term(recover),term(cons("INSERTION"))])),427),label(prod([lit("<(")],lit("<("),no-attrs),426),label(prod([],lit("regular"),attrs([term(recover),term(cons("INSERTION"))])),425),label(prod([lit("regular")],lit("regular"),no-attrs),424),label(prod([],lit("tree"),attrs([term(recover),term(cons("INSERTION"))])),423),label(prod([lit("tree")],lit("tree"),no-attrs),422),label(prod([],lit("grammar"),attrs([term(recover),term(cons("INSERTION"))])),421),label(prod([lit("grammar")],lit("grammar"),no-attrs),420),label(prod([],lit("start"),attrs([term(recover),term(cons("INSERTION"))])),419),label(prod([lit("start")],lit("start"),no-attrs),418),label(prod([],lit("productions"),attrs([term(recover),term(cons("INSERTION"))])),417),label(prod([lit("productions")],lit("productions"),no-attrs),416),label(prod([],lit("->"),attrs([term(recover),term(cons("INSERTION"))])),415),label(prod([lit("->")],lit("->"),no-attrs),414),label(prod([],lit("|"),attrs([term(recov!
 er),term(cons("INSERTION"))])),413),label(prod([lit("|")],lit("|"),no-attrs),412),label(prod([],lit("}"),attrs([term(recover),term(cons("INSERTION"))])),411),label(prod([lit("}")],lit("}"),no-attrs),410),label(prod([],lit(","),attrs([term(recover),term(cons("INSERTION"))])),409),label(prod([lit(",")],lit(","),no-attrs),408),label(prod([],lit(">>"),attrs([term(recover),term(cons("INSERTION"))])),407),label(prod([lit(">>")],lit(">>"),no-attrs),406),label(prod([char-class([range(9,10),32])],lex(layout),no-attrs),405),label(prod([lit("/*"),lex(iter(sort("CommChar"))),lit("*/")],lex(layout),no-attrs),404),label(prod([char-class([range(0,41),range(43,255)])],lex(sort("CommChar")),no-attrs),403),label(prod([lex(sort("CommChar"))],cf(sort("CommChar")),no-attrs),402),label(prod([lit("*")],lex(sort("Asterisk")),no-attrs),401),label(prod([lex(sort("Asterisk"))],cf(sort("Asterisk")),no-attrs),400),label(prod([lex(sort("Asterisk"))],lex(sort("CommChar")),no-attrs),399),label(prod([cf(op!
 t(layout)),cf(sort("RTG")),cf(opt(layout))],sort("<START>"),no-attrs
98),label(prod([cf(opt(layout)),cf(sort("ProdRule")),cf(opt(layout))],sort("<START>"),no-attrs),397),label(prod([cf(opt(layout)),cf(sort("TreeFN")),cf(opt(layout))],sort("<START>"),no-attrs),396),label(prod([cf(opt(layout)),cf(sort("AnnoTreeFN")),cf(opt(layout))],sort("<START>"),no-attrs),395),label(prod([cf(opt(layout)),cf(sort("NonTerm")),cf(opt(layout))],sort("<START>"),no-attrs),394),label(prod([lit("regular"),cf(opt(layout)),lit("tree"),cf(opt(layout)),lit("grammar"),cf(opt(layout)),cf(sort("Start")),cf(opt(layout)),cf(sort("ProdRules"))],cf(sort("RTG")),attrs([term(cons("RTG"))])),393),label(prod([lit("start"),cf(opt(layout)),cf(iter(sort("NonTerm")))],cf(sort("Start")),attrs([term(cons("Start"))])),392),label(prod([lit("productions"),cf(opt(layout)),cf(iter(sort("ProdRule")))],cf(sort("ProdRules")),attrs([term(cons("ProdRules"))])),391),label(prod([cf(sort("NonTerm")),cf(opt(layout)),lit("->"),cf(opt(layout)),cf(iter-sep(sort("AnnoTreeFN"),lit("|")))],cf(sort("ProdRul!
 e")),attrs([term(cons("ProdRule"))])),390),label(prod([cf(sort("TreeFN"))],cf(sort("AnnoTreeFN")),no-attrs),389),label(prod([cf(sort("TreeFN")),cf(opt(layout)),cf(iter(sort("Labelled")))],cf(sort("AnnoTreeFN")),attrs([term(cons("Annotated"))])),388),label(prod([cf(sort("Term")),cf(opt(layout)),lit("("),cf(opt(layout)),cf(iter-star-sep(sort("AnnoTreeFN"),lit(","))),cf(opt(layout)),lit(")")],cf(sort("TreeFN")),attrs([term(cons("Appl"))])),387),label(prod([cf(sort("NonTerm"))],cf(sort("TreeFN")),attrs([term(cons("Ref"))])),386),label(prod([lit("."),cf(opt(layout)),cf(sort("Term")),cf(opt(layout)),cf(sort("AnnoTreeFN"))],cf(sort("Labelled")),attrs([term(cons("Labelled"))])),385),label(prod([lit("{"),cf(opt(layout)),cf(iter-sep(sort("NonTerm"),lit(","))),cf(opt(layout)),lit("}")],cf(sort("NonTerm")),attrs([term(cons("Set"))])),384),label(prod([lit("<<"),cf(opt(layout)),cf(sort("TreeFN")),cf(opt(layout)),lit(">>")],cf(sort("NonTerm")),attrs([term(cons("Generated"))])),383),label(!
 prod([sort("QuotedIdPart")],iter(sort("QuotedIdPart")),no-attrs),382
abel(prod([iter(sort("QuotedIdPart")),iter(sort("QuotedIdPart"))],iter(sort("QuotedIdPart")),attrs([assoc(left)])),381),label(prod([iter(sort("QuotedIdPart")),iter-star(sort("QuotedIdPart"))],iter(sort("QuotedIdPart")),no-attrs),380),label(prod([iter-star(sort("QuotedIdPart")),iter(sort("QuotedIdPart"))],iter(sort("QuotedIdPart")),no-attrs),379),label(prod([iter-star(sort("QuotedIdPart")),iter-star(sort("QuotedIdPart"))],iter-star(sort("QuotedIdPart")),attrs([assoc(left)])),378),label(prod([],iter-star(sort("QuotedIdPart")),no-attrs),377),label(prod([iter(sort("QuotedIdPart"))],iter-star(sort("QuotedIdPart")),no-attrs),376),label(prod([char-class([range(0,91),range(94,255)])],lex(iter(char-class([range(0,91),range(94,255)]))),no-attrs),375),label(prod([lex(iter(char-class([range(0,91),range(94,255)])))],cf(iter(char-class([range(0,91),range(94,255)]))),no-attrs),374),label(prod([lex(iter(char-class([range(0,91),range(94,255)]))),lex(iter(char-class([range(0,91),range(94,255)!
 ])))],lex(iter(char-class([range(0,91),range(94,255)]))),attrs([assoc(left)])),373),label(prod([lex(iter(char-class([range(0,91),range(94,255)]))),lex(iter-star(char-class([range(0,91),range(94,255)])))],lex(iter(char-class([range(0,91),range(94,255)]))),no-attrs),372),label(prod([lex(iter-star(char-class([range(0,91),range(94,255)]))),lex(iter(char-class([range(0,91),range(94,255)])))],lex(iter(char-class([range(0,91),range(94,255)]))),no-attrs),371),label(prod([lex(iter-star(char-class([range(0,91),range(94,255)]))),lex(iter-star(char-class([range(0,91),range(94,255)])))],lex(iter-star(char-class([range(0,91),range(94,255)]))),attrs([assoc(left)])),370),label(prod([lex(iter-star(char-class([range(0,91),range(94,255)])))],cf(iter-star(char-class([range(0,91),range(94,255)]))),no-attrs),369),label(prod([],lex(iter-star(char-class([range(0,91),range(94,255)]))),no-attrs),368),label(prod([lex(iter(char-class([range(0,91),range(94,255)])))],lex(iter-star(char-class([range(0,91!
 ),range(94,255)]))),no-attrs),367),label(prod([char-class([39,45,ran
48,57),range(65,90),95,range(97,122)])],lex(iter(char-class([39,45,range(48,57),range(65,90),95,range(97,122)]))),no-attrs),366),label(prod([lex(iter(char-class([39,45,range(48,57),range(65,90),95,range(97,122)])))],cf(iter(char-class([39,45,range(48,57),range(65,90),95,range(97,122)]))),no-attrs),365),label(prod([lex(iter(char-class([39,45,range(48,57),range(65,90),95,range(97,122)]))),lex(iter(char-class([39,45,range(48,57),range(65,90),95,range(97,122)])))],lex(iter(char-class([39,45,range(48,57),range(65,90),95,range(97,122)]))),attrs([assoc(left)])),364),label(prod([lex(iter(char-class([39,45,range(48,57),range(65,90),95,range(97,122)]))),lex(iter-star(char-class([39,45,range(48,57),range(65,90),95,range(97,122)])))],lex(iter(char-class([39,45,range(48,57),range(65,90),95,range(97,122)]))),no-attrs),363),label(prod([lex(iter-star(char-class([39,45,range(48,57),range(65,90),95,range(97,122)]))),lex(iter(char-class([39,45,range(48,57),range(65,90),95,range(97,122)])))],le!
 x(iter(char-class([39,45,range(48,57),range(65,90),95,range(97,122)]))),no-attrs),362),label(prod([lex(iter-star(char-class([39,45,range(48,57),range(65,90),95,range(97,122)]))),lex(iter-star(char-class([39,45,range(48,57),range(65,90),95,range(97,122)])))],lex(iter-star(char-class([39,45,range(48,57),range(65,90),95,range(97,122)]))),attrs([assoc(left)])),361),label(prod([lex(iter-star(char-class([39,45,range(48,57),range(65,90),95,range(97,122)])))],cf(iter-star(char-class([39,45,range(48,57),range(65,90),95,range(97,122)]))),no-attrs),360),label(prod([],lex(iter-star(char-class([39,45,range(48,57),range(65,90),95,range(97,122)]))),no-attrs),359),label(prod([lex(iter(char-class([39,45,range(48,57),range(65,90),95,range(97,122)])))],lex(iter-star(char-class([39,45,range(48,57),range(65,90),95,range(97,122)]))),no-attrs),358),label(prod([char-class([range(48,57)])],lex(iter(char-class([range(48,57)]))),no-attrs),357),label(prod([lex(iter(char-class([range(48,57)])))],cf(ite!
 r(char-class([range(48,57)]))),no-attrs),356),label(prod([lex(iter(c
-class([range(48,57)]))),lex(iter(char-class([range(48,57)])))],lex(iter(char-class([range(48,57)]))),attrs([assoc(left)])),355),label(prod([lex(iter(char-class([range(48,57)]))),lex(iter-star(char-class([range(48,57)])))],lex(iter(char-class([range(48,57)]))),no-attrs),354),label(prod([lex(iter-star(char-class([range(48,57)]))),lex(iter(char-class([range(48,57)])))],lex(iter(char-class([range(48,57)]))),no-attrs),353),label(prod([lex(iter-star(char-class([range(48,57)]))),lex(iter-star(char-class([range(48,57)])))],lex(iter-star(char-class([range(48,57)]))),attrs([assoc(left)])),352),label(prod([lex(iter-star(char-class([range(48,57)])))],cf(iter-star(char-class([range(48,57)]))),no-attrs),351),label(prod([],lex(iter-star(char-class([range(48,57)]))),no-attrs),350),label(prod([lex(iter(char-class([range(48,57)])))],lex(iter-star(char-class([range(48,57)]))),no-attrs),349),label(prod([char-class([range(48,57),range(65,90),95,range(97,122)])],lex(iter(char-class([range(48,57)!
 ,range(65,90),95,range(97,122)]))),no-attrs),348),label(prod([lex(iter(char-class([range(48,57),range(65,90),95,range(97,122)])))],cf(iter(char-class([range(48,57),range(65,90),95,range(97,122)]))),no-attrs),347),label(prod([lex(iter(char-class([range(48,57),range(65,90),95,range(97,122)]))),lex(iter(char-class([range(48,57),range(65,90),95,range(97,122)])))],lex(iter(char-class([range(48,57),range(65,90),95,range(97,122)]))),attrs([assoc(left)])),346),label(prod([lex(iter(char-class([range(48,57),range(65,90),95,range(97,122)]))),lex(iter-star(char-class([range(48,57),range(65,90),95,range(97,122)])))],lex(iter(char-class([range(48,57),range(65,90),95,range(97,122)]))),no-attrs),345),label(prod([lex(iter-star(char-class([range(48,57),range(65,90),95,range(97,122)]))),lex(iter(char-class([range(48,57),range(65,90),95,range(97,122)])))],lex(iter(char-class([range(48,57),range(65,90),95,range(97,122)]))),no-attrs),344),label(prod([lex(iter-star(char-class([range(48,57),range(!
 65,90),95,range(97,122)]))),lex(iter-star(char-class([range(48,57),r
e(65,90),95,range(97,122)])))],lex(iter-star(char-class([range(48,57),range(65,90),95,range(97,122)]))),attrs([assoc(left)])),343),label(prod([lex(iter-star(char-class([range(48,57),range(65,90),95,range(97,122)])))],cf(iter-star(char-class([range(48,57),range(65,90),95,range(97,122)]))),no-attrs),342),label(prod([],lex(iter-star(char-class([range(48,57),range(65,90),95,range(97,122)]))),no-attrs),341),label(prod([lex(iter(char-class([range(48,57),range(65,90),95,range(97,122)])))],lex(iter-star(char-class([range(48,57),range(65,90),95,range(97,122)]))),no-attrs),340),label(prod([lex(sort("CommChar"))],lex(iter(sort("CommChar"))),no-attrs),339),label(prod([lex(iter(sort("CommChar")))],cf(iter(sort("CommChar"))),no-attrs),338),label(prod([lex(iter(sort("CommChar"))),lex(iter(sort("CommChar")))],lex(iter(sort("CommChar"))),attrs([assoc(left)])),337),label(prod([lex(iter(sort("CommChar"))),lex(iter-star(sort("CommChar")))],lex(iter(sort("CommChar"))),no-attrs),336),label(prod([!
 lex(iter-star(sort("CommChar"))),lex(iter(sort("CommChar")))],lex(iter(sort("CommChar"))),no-attrs),335),label(prod([lex(iter-star(sort("CommChar"))),lex(iter-star(sort("CommChar")))],lex(iter-star(sort("CommChar"))),attrs([assoc(left)])),334),label(prod([lex(iter-star(sort("CommChar")))],cf(iter-star(sort("CommChar"))),no-attrs),333),label(prod([],lex(iter-star(sort("CommChar"))),no-attrs),332),label(prod([lex(iter(sort("CommChar")))],lex(iter-star(sort("CommChar"))),no-attrs),331),label(prod([cf(sort("NonTerm"))],cf(iter(sort("NonTerm"))),no-attrs),330),label(prod([cf(iter(sort("NonTerm"))),cf(opt(layout)),cf(iter(sort("NonTerm")))],cf(iter(sort("NonTerm"))),attrs([assoc(left)])),329),label(prod([cf(iter(sort("NonTerm"))),cf(opt(layout)),cf(iter-star(sort("NonTerm")))],cf(iter(sort("NonTerm"))),no-attrs),328),label(prod([cf(iter-star(sort("NonTerm"))),cf(opt(layout)),cf(iter(sort("NonTerm")))],cf(iter(sort("NonTerm"))),no-attrs),327),label(prod([cf(iter-star(sort("NonTerm!
 "))),cf(opt(layout)),cf(iter-star(sort("NonTerm")))],cf(iter-star(so
"NonTerm"))),attrs([assoc(left)])),326),label(prod([],cf(iter-star(sort("NonTerm"))),no-attrs),325),label(prod([cf(iter(sort("NonTerm")))],cf(iter-star(sort("NonTerm"))),no-attrs),324),label(prod([cf(sort("ProdRule"))],cf(iter(sort("ProdRule"))),no-attrs),323),label(prod([cf(iter(sort("ProdRule"))),cf(opt(layout)),cf(iter(sort("ProdRule")))],cf(iter(sort("ProdRule"))),attrs([assoc(left)])),322),label(prod([cf(iter(sort("ProdRule"))),cf(opt(layout)),cf(iter-star(sort("ProdRule")))],cf(iter(sort("ProdRule"))),no-attrs),321),label(prod([cf(iter-star(sort("ProdRule"))),cf(opt(layout)),cf(iter(sort("ProdRule")))],cf(iter(sort("ProdRule"))),no-attrs),320),label(prod([cf(iter-star(sort("ProdRule"))),cf(opt(layout)),cf(iter-star(sort("ProdRule")))],cf(iter-star(sort("ProdRule"))),attrs([assoc(left)])),319),label(prod([],cf(iter-star(sort("ProdRule"))),no-attrs),318),label(prod([cf(iter(sort("ProdRule")))],cf(iter-star(sort("ProdRule"))),no-attrs),317),label(prod([cf(sort("AnnoTreeFN!
 "))],cf(iter-sep(sort("AnnoTreeFN"),lit("|"))),no-attrs),316),label(prod([cf(iter-sep(sort("AnnoTreeFN"),lit("|"))),cf(opt(layout)),lit("|"),cf(opt(layout)),cf(iter-sep(sort("AnnoTreeFN"),lit("|")))],cf(iter-sep(sort("AnnoTreeFN"),lit("|"))),attrs([assoc(left)])),315),label(prod([cf(iter-sep(sort("AnnoTreeFN"),lit("|"))),cf(opt(layout)),lit("|"),cf(opt(layout)),cf(iter-star-sep(sort("AnnoTreeFN"),lit("|")))],cf(iter-sep(sort("AnnoTreeFN"),lit("|"))),no-attrs),314),label(prod([cf(iter-star-sep(sort("AnnoTreeFN"),lit("|"))),cf(opt(layout)),lit("|"),cf(opt(layout)),cf(iter-sep(sort("AnnoTreeFN"),lit("|")))],cf(iter-sep(sort("AnnoTreeFN"),lit("|"))),no-attrs),313),label(prod([cf(iter-star-sep(sort("AnnoTreeFN"),lit("|"))),cf(opt(layout)),lit("|"),cf(opt(layout)),cf(iter-star-sep(sort("AnnoTreeFN"),lit("|")))],cf(iter-star-sep(sort("AnnoTreeFN"),lit("|"))),attrs([assoc(left)])),312),label(prod([],cf(iter-star-sep(sort("AnnoTreeFN"),lit("|"))),no-attrs),311),label(prod([cf(iter-s!
 ep(sort("AnnoTreeFN"),lit("|")))],cf(iter-star-sep(sort("AnnoTreeFN"
it("|"))),no-attrs),310),label(prod([cf(sort("Labelled"))],cf(iter(sort("Labelled"))),no-attrs),309),label(prod([cf(iter(sort("Labelled"))),cf(opt(layout)),cf(iter(sort("Labelled")))],cf(iter(sort("Labelled"))),attrs([assoc(left)])),308),label(prod([cf(iter(sort("Labelled"))),cf(opt(layout)),cf(iter-star(sort("Labelled")))],cf(iter(sort("Labelled"))),no-attrs),307),label(prod([cf(iter-star(sort("Labelled"))),cf(opt(layout)),cf(iter(sort("Labelled")))],cf(iter(sort("Labelled"))),no-attrs),306),label(prod([cf(iter-star(sort("Labelled"))),cf(opt(layout)),cf(iter-star(sort("Labelled")))],cf(iter-star(sort("Labelled"))),attrs([assoc(left)])),305),label(prod([],cf(iter-star(sort("Labelled"))),no-attrs),304),label(prod([cf(iter(sort("Labelled")))],cf(iter-star(sort("Labelled"))),no-attrs),303),label(prod([cf(sort("AnnoTreeFN"))],cf(iter-sep(sort("AnnoTreeFN"),lit(","))),no-attrs),302),label(prod([cf(iter-sep(sort("AnnoTreeFN"),lit(","))),cf(opt(layout)),lit(","),cf(opt(layout)),cf(!
 iter-sep(sort("AnnoTreeFN"),lit(",")))],cf(iter-sep(sort("AnnoTreeFN"),lit(","))),attrs([assoc(left)])),301),label(prod([cf(iter-sep(sort("AnnoTreeFN"),lit(","))),cf(opt(layout)),lit(","),cf(opt(layout)),cf(iter-star-sep(sort("AnnoTreeFN"),lit(",")))],cf(iter-sep(sort("AnnoTreeFN"),lit(","))),no-attrs),300),label(prod([cf(iter-star-sep(sort("AnnoTreeFN"),lit(","))),cf(opt(layout)),lit(","),cf(opt(layout)),cf(iter-sep(sort("AnnoTreeFN"),lit(",")))],cf(iter-sep(sort("AnnoTreeFN"),lit(","))),no-attrs),299),label(prod([cf(iter-star-sep(sort("AnnoTreeFN"),lit(","))),cf(opt(layout)),lit(","),cf(opt(layout)),cf(iter-star-sep(sort("AnnoTreeFN"),lit(",")))],cf(iter-star-sep(sort("AnnoTreeFN"),lit(","))),attrs([assoc(left)])),298),label(prod([],cf(iter-star-sep(sort("AnnoTreeFN"),lit(","))),no-attrs),297),label(prod([cf(iter-sep(sort("AnnoTreeFN"),lit(",")))],cf(iter-star-sep(sort("AnnoTreeFN"),lit(","))),no-attrs),296),label(prod([cf(sort("NonTerm"))],cf(iter-sep(sort("NonTerm"),lit!
 (","))),no-attrs),295),label(prod([cf(iter-sep(sort("NonTerm"),lit("
)),cf(opt(layout)),lit(","),cf(opt(layout)),cf(iter-sep(sort("NonTerm"),lit(",")))],cf(iter-sep(sort("NonTerm"),lit(","))),attrs([assoc(left)])),294),label(prod([cf(iter-sep(sort("NonTerm"),lit(","))),cf(opt(layout)),lit(","),cf(opt(layout)),cf(iter-star-sep(sort("NonTerm"),lit(",")))],cf(iter-sep(sort("NonTerm"),lit(","))),no-attrs),293),label(prod([cf(iter-star-sep(sort("NonTerm"),lit(","))),cf(opt(layout)),lit(","),cf(opt(layout)),cf(iter-sep(sort("NonTerm"),lit(",")))],cf(iter-sep(sort("NonTerm"),lit(","))),no-attrs),292),label(prod([cf(iter-star-sep(sort("NonTerm"),lit(","))),cf(opt(layout)),lit(","),cf(opt(layout)),cf(iter-star-sep(sort("NonTerm"),lit(",")))],cf(iter-star-sep(sort("NonTerm"),lit(","))),attrs([assoc(left)])),291),label(prod([],cf(iter-star-sep(sort("NonTerm"),lit(","))),no-attrs),290),label(prod([cf(iter-sep(sort("NonTerm"),lit(",")))],cf(iter-star-sep(sort("NonTerm"),lit(","))),no-attrs),289),label(prod([],cf(opt(layout)),no-attrs),288),label(prod([cf(!
 layout)],cf(opt(layout)),no-attrs),287),label(prod([char-class([91])],lit("["),no-attrs),286),label(prod([char-class([93])],lit("]"),no-attrs),285),label(prod([char-class([92])],lit("\\"),no-attrs),284),label(prod([char-class([60]),char-class([99]),char-class([111]),char-class([110]),char-class([99]),char-class([62])],lit("<conc>"),no-attrs),283),label(prod([char-class([60]),char-class([99]),char-class([111]),char-class([110]),char-class([115]),char-class([62])],lit("<cons>"),no-attrs),282),label(prod([char-class([60]),char-class([110]),char-class([105]),char-class([108]),char-class([62])],lit("<nil>"),no-attrs),281),label(prod([char-class([60]),char-class([115]),char-class([111]),char-class([109]),char-class([101]),char-class([62])],lit("<some>"),no-attrs),280),label(prod([char-class([60]),char-class([110]),char-class([111]),char-class([110]),char-class([101]),char-class([62])],lit("<none>"),no-attrs),279),label(prod([char-class([60]),char-class([115]),char-class([116]),ch!
 ar-class([114]),char-class([105]),char-class([110]),char-class([103]
har-class([62])],lit("<string>"),no-attrs),278),label(prod([char-class([60]),char-class([105]),char-class([110]),char-class([116]),char-class([62])],lit("<int>"),no-attrs),277),label(prod([char-class([41]),char-class([62])],lit(")>"),no-attrs),276),label(prod([char-class([60]),char-class([40])],lit("<("),no-attrs),275),label(prod([char-class([47]),char-class([42])],lit("/*"),no-attrs),274),label(prod([char-class([42]),char-class([47])],lit("*/"),no-attrs),273),label(prod([char-class([42])],lit("*"),no-attrs),272),label(prod([char-class([114]),char-class([101]),char-class([103]),char-class([117]),char-class([108]),char-class([97]),char-class([114])],lit("regular"),no-attrs),271),label(prod([char-class([116]),char-class([114]),char-class([101]),char-class([101])],lit("tree"),no-attrs),270),label(prod([char-class([103]),char-class([114]),char-class([97]),char-class([109]),char-class([109]),char-class([97]),char-class([114])],lit("grammar"),no-attrs),269),label(prod([char-class(!
 [115]),char-class([116]),char-class([97]),char-class([114]),char-class([116])],lit("start"),no-attrs),268),label(prod([char-class([112]),char-class([114]),char-class([111]),char-class([100]),char-class([117]),char-class([99]),char-class([116]),char-class([105]),char-class([111]),char-class([110]),char-class([115])],lit("productions"),no-attrs),267),label(prod([char-class([45]),char-class([62])],lit("->"),no-attrs),266),label(prod([char-class([40])],lit("("),no-attrs),265),label(prod([char-class([41])],lit(")"),no-attrs),264),label(prod([char-class([46])],lit("."),no-attrs),263),label(prod([char-class([123])],lit("{"),no-attrs),262),label(prod([char-class([125])],lit("}"),no-attrs),261),label(prod([char-class([60]),char-class([60])],lit("<<"),no-attrs),260),label(prod([char-class([62]),char-class([62])],lit(">>"),no-attrs),259),label(prod([char-class([124])],lit("|"),no-attrs),258),label(prod([char-class([44])],lit(","),no-attrs),257)],states([state-rec(0,[goto([47],19),goto!
 ([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31)
nge(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([473],14),goto([394],1),goto([287],2),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),goto([434],3),goto([439],10),goto([437],6),goto([442],9),goto([272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5),goto([448],4),goto([472],3),goto([288],2),goto([395],1),goto([396],1),goto([397],1),goto([398],1)],[action([range(48,57),range(65,90),95,range(97,122),256],[reduce(0,288,0)]),action([47],[shift(19),reduce(0,288,0)]),action([range(9,10),32],[shift(18)]),action([42],[shift(17),reduce(0,288,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[shift(16),reduce(0,288,0)]),action([range(12,13)],[shift(15),reduce(0,288,0)])]),state-rec(1,[goto([256],20)],[action([256],[accept])]),state-rec(2,[goto([114],48),goto([60],47),goto([123],46),goto([91],45),goto([39,45,range(48,57),!
 range(65,90),95,range(97,113),range(115,122)],44),goto([393],43),goto([271],42),goto([424],42),goto([425],42),goto([390],41),goto([383],36),goto([260],40),goto([384],36),goto([262],39),goto([449],36),goto([277],38),goto([450],36),goto([278],37),goto([451],36),goto([471],35),goto([469],33),goto([286],34),goto([470],33),goto([464],32),goto([362],30),goto([361],31),goto([363],30),goto([364],30),goto([366],30),goto([386],29),goto([387],29),goto([452],22),goto([453],22),goto([454],22),goto([279],28),goto([455],22),goto([280],27),goto([456],22),goto([275],26),goto([426],26),goto([427],26),goto([457],22),goto([281],25),goto([458],22),goto([282],24),goto([459],22),goto([283],23),goto([460],22),goto([388],21),goto([389],21)],[action([range(0,38),range(40,44),range(46,47),range(58,59),range(61,64),range(92,94),96,range(124,256)],[reduce(0,425,0),reduce(0,427,0)]),action([114],[reduce(0,427,0),shift(48),reduce(0,425,0)]),action([60],[reduce(0,427,0),shift(47),reduce(0,425,0)]),action(!
 [123],[reduce(0,427,0),shift(46),reduce(0,425,0)]),action([91],[redu
0,427,0),shift(45),reduce(0,425,0)]),action([39,45,range(48,57),range(65,90),95,range(97,113),range(115,122)],[reduce(0,427,0),shift(44),reduce(0,425,0)])]),state-rec(3,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([430],49),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),goto([434],49),goto([439],10),goto([437],6),goto([442],9),goto([272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5),goto([448],4)],[action([range(48,57),range(65,90),95,range(97,122),256],[reduce(1,287,0)]),action([47],[shift(19),reduce(1,287,0)]),action([range(9,10),32],[shift(18)]),action([42],[shift(17),reduce(1,287,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[shift(16),reduce(1,287,0)]),action([range(12,13)],[shift(15),reduce(1,287,0)])]),state-rec(4,[goto!
 ([range(48,57),range(65,90),95,range(97,122)],53),goto([340],50),goto([344],51),goto([343],52),goto([345],51),goto([346],51),goto([348],51),goto([341],50)],[action([range(0,47),range(58,64),range(91,94),96,range(123,256)],[reduce(0,341,0)]),action([range(48,57),range(65,90),95,range(97,122)],[shift(53),reduce(0,341,0)])]),state-rec(5,[],[action([range(0,256)],[reduce(1,440,0)])]),state-rec(6,[],[action([range(0,256)],[reduce(1,439,0)])]),state-rec(7,[],[action([range(0,256)],[reduce(1,438,0)])]),state-rec(8,[],[action([range(0,46),range(48,256)],[reduce(1,442,4)])]),state-rec(9,[],[action([range(0,256)],[reduce(1,437,0)])]),state-rec(10,[],[action([range(0,256)],[reduce(1,434,0)])]),state-rec(11,[goto([42],60),goto([range(0,41),range(43,255)],59),goto([335],57),goto([334],58),goto([336],57),goto([337],57),goto([339],57),goto([399],54),goto([401],56),goto([272],55),goto([403],54)],[action([42],[shift(60)]),action([range(0,41),range(43,255)],[shift(59)])]),state-rec(12,[],[ac!
 tion([range(0,256)],[reduce(1,430,0)])]),state-rec(13,[goto([42],60)
to([range(0,41),range(43,255)],59),goto([335],61),goto([334],58),goto([336],61),goto([337],61),goto([339],61),goto([399],54),goto([401],56),goto([272],55),goto([403],54)],[action([256],[reduce(1,433,0)]),action([42],[shift(60),reduce(1,433,0)]),action([range(0,41),range(43,255)],[shift(59),reduce(1,433,0)])]),state-rec(14,[],[]),state-rec(15,[],[action([range(0,256)],[reduce(1,448,4)])]),state-rec(16,[],[action([range(0,256)],[reduce(1,448,4),reduce(1,444,4)])]),state-rec(17,[],[action([range(0,256)],[reduce(1,448,4),reduce(1,272,0)])]),state-rec(18,[],[action([range(0,256)],[reduce(1,448,4),reduce(1,405,0)])]),state-rec(19,[goto([42],62)],[action([range(0,41),range(43,256)],[reduce(1,448,4),reduce(1,444,4)]),action([42],[reduce(1,444,4),shift(62),reduce(1,448,4)])]),state-rec(20,[],[]),state-rec(21,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,!
 13)],15),goto([287],63),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),goto([434],3),goto([439],10),goto([437],6),goto([442],9),goto([272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5),goto([448],4),goto([472],3),goto([288],63)],[action([range(48,57),range(65,90),95,range(97,122),256],[reduce(0,288,0)]),action([47],[shift(19),reduce(0,288,0)]),action([range(9,10),32],[shift(18)]),action([42],[shift(17),reduce(0,288,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[shift(16),reduce(0,288,0)]),action([range(12,13)],[shift(15),reduce(0,288,0)])]),state-rec(22,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],64),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),goto([434],3),got!
 o([439],10),goto([437],6),goto([442],9),goto([272],8),goto([438],6),
o([444],7),goto([440],6),goto([446],5),goto([448],4),goto([472],3),goto([288],64)],[action([range(48,57),range(65,90),95,range(97,122),256],[reduce(0,288,0)]),action([47],[shift(19),reduce(0,288,0)]),action([range(9,10),32],[shift(18)]),action([42],[shift(17),reduce(0,288,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[shift(16),reduce(0,288,0)]),action([range(12,13)],[shift(15),reduce(0,288,0)])]),state-rec(23,[],[action([range(0,256)],[reduce(1,459,0)])]),state-rec(24,[],[action([range(0,256)],[reduce(1,458,0)])]),state-rec(25,[],[action([range(0,256)],[reduce(1,457,0)])]),state-rec(26,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],65),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),goto([434],3),goto([439],10),goto([437]!
 ,6),goto([442],9),goto([272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5),goto([448],4),goto([472],3),goto([288],65)],[action([range(48,57),range(65,90),95,range(97,122),256],[reduce(1,426,0),reduce(0,288,0)]),action([47],[reduce(0,288,0),shift(19),reduce(1,426,0)]),action([range(9,10),32],[shift(18),reduce(1,426,0)]),action([42],[reduce(0,288,0),shift(17),reduce(1,426,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[reduce(0,288,0),shift(16),reduce(1,426,0)]),action([range(12,13)],[reduce(0,288,0),shift(15),reduce(1,426,0)])]),state-rec(27,[],[action([range(0,256)],[reduce(1,455,0)])]),state-rec(28,[],[action([range(0,256)],[reduce(1,454,0)])]),state-rec(29,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],66),goto([430],3),goto([404],12),goto([274],13!
 ),goto([405],12),goto([431],12),goto([433],11),goto([434],3),goto([4
,10),goto([437],6),goto([442],9),goto([272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5),goto([448],4),goto([472],3),goto([288],66)],[action([range(48,57),range(65,90),95,range(97,122),256],[reduce(1,389,0),reduce(0,288,0)]),action([47],[reduce(0,288,0),shift(19),reduce(1,389,0)]),action([range(9,10),32],[shift(18),reduce(1,389,0)]),action([42],[reduce(0,288,0),shift(17),reduce(1,389,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[reduce(0,288,0),shift(16),reduce(1,389,0)]),action([range(12,13)],[reduce(0,288,0),shift(15),reduce(1,389,0)])]),state-rec(30,[goto([39,45,range(48,57),range(65,90),95,range(97,122)],44),goto([366],67)],[action([range(0,38),range(40,44),range(46,47),range(58,64),range(91,94),96,range(123,256)],[reduce(1,464,0)]),action([39,45,range(48,57),range(65,90),95,range(97,122)],[shift(44)])]),state-rec(31,[goto([39,45,range(48,57),range(65,90),95,range(97,122)],44),goto([366],68)]!
 ,[action([39,45,range(48,57),range(65,90),95,range(97,122)],[shift(44)])]),state-rec(32,[],[action([range(0,256)],[reduce(1,470,0)])]),state-rec(33,[],[action([range(0,256)],[reduce(1,471,0)])]),state-rec(34,[goto([92],78),goto([range(0,91),range(94,255)],77),goto([376],69),goto([379],75),goto([378],76),goto([380],75),goto([381],75),goto([382],75),goto([467],73),goto([284],74),goto([468],73),goto([466],72),goto([371],70),goto([370],71),goto([372],70),goto([373],70),goto([375],70),goto([377],69)],[action([93],[reduce(0,377,0)]),action([92],[shift(78)]),action([range(0,91),range(94,255)],[shift(77)])]),state-rec(35,[],[action([range(0,256)],[reduce(1,460,0),reduce(1,451,0)])]),state-rec(36,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],79),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),!
 goto([434],3),goto([439],10),goto([437],6),goto([442],9),goto([272],
goto([438],6),goto([444],7),goto([440],6),goto([446],5),goto([448],4),goto([472],3),goto([288],79)],[action([range(48,57),range(65,90),95,range(97,122),256],[reduce(0,288,0),reduce(1,386,0)]),action([47],[reduce(1,386,0),shift(19),reduce(0,288,0)]),action([range(9,10),32],[shift(18),reduce(1,386,0)]),action([42],[reduce(1,386,0),shift(17),reduce(0,288,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[reduce(1,386,0),shift(16),reduce(0,288,0)]),action([range(12,13)],[reduce(1,386,0),shift(15),reduce(0,288,0)])]),state-rec(37,[],[action([range(0,256)],[reduce(1,453,0),reduce(1,450,0)])]),state-rec(38,[],[action([range(0,256)],[reduce(1,452,0),reduce(1,449,0)])]),state-rec(39,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],80),goto([430],3),goto([404],12),goto([274],13)!
 ,goto([405],12),goto([431],12),goto([433],11),goto([434],3),goto([439],10),goto([437],6),goto([442],9),goto([272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5),goto([448],4),goto([472],3),goto([288],80)],[action([range(48,57),range(65,90),95,range(97,122),256],[reduce(0,288,0)]),action([47],[shift(19),reduce(0,288,0)]),action([range(9,10),32],[shift(18)]),action([42],[shift(17),reduce(0,288,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[shift(16),reduce(0,288,0)]),action([range(12,13)],[shift(15),reduce(0,288,0)])]),state-rec(40,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],81),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),goto([434],3),goto([439],10),goto([437],6),goto([442],9),goto([272],8),goto([438],6)!
 ,goto([444],7),goto([440],6),goto([446],5),goto([448],4),goto([472],
goto([288],81)],[action([range(48,57),range(65,90),95,range(97,122),256],[reduce(0,288,0)]),action([47],[shift(19),reduce(0,288,0)]),action([range(9,10),32],[shift(18)]),action([42],[shift(17),reduce(0,288,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[shift(16),reduce(0,288,0)]),action([range(12,13)],[shift(15),reduce(0,288,0)])]),state-rec(41,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],82),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),goto([434],3),goto([439],10),goto([437],6),goto([442],9),goto([272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5),goto([448],4),goto([472],3),goto([288],82)],[action([range(48,57),range(65,90),95,range(97,122),256],[reduce(0,288,0)]),action([47],[shift(19),reduce(0,288,0)]!
 ),action([range(9,10),32],[shift(18)]),action([42],[shift(17),reduce(0,288,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[shift(16),reduce(0,288,0)]),action([range(12,13)],[shift(15),reduce(0,288,0)])]),state-rec(42,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],83),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),goto([434],3),goto([439],10),goto([437],6),goto([442],9),goto([272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5),goto([448],4),goto([472],3),goto([288],83)],[action([range(48,57),range(65,90),95,range(97,122),256],[reduce(1,424,0),reduce(0,288,0)]),action([47],[reduce(0,288,0),shift(19),reduce(1,424,0)]),action([range(9,10),32],[shift(18),reduce(1,424,0)]),action([42],[reduce(0,288,0),shift(17),redu!
 ce(1,424,0)]),action([range(0,8),11,range(14,31),range(33,41),range(
46),range(58,64),range(91,94),96,range(123,255)],[reduce(0,288,0),shift(16),reduce(1,424,0)]),action([range(12,13)],[reduce(0,288,0),shift(15),reduce(1,424,0)])]),state-rec(43,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],84),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),goto([434],3),goto([439],10),goto([437],6),goto([442],9),goto([272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5),goto([448],4),goto([472],3),goto([288],84)],[action([range(48,57),range(65,90),95,range(97,122),256],[reduce(0,288,0)]),action([47],[shift(19),reduce(0,288,0)]),action([range(9,10),32],[shift(18)]),action([42],[shift(17),reduce(0,288,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[shift(16),reduce(0,288,0)]),action([range(12,13)]!
 ,[shift(15),reduce(0,288,0)])]),state-rec(44,[],[action([range(0,256)],[reduce(1,366,0)])]),state-rec(45,[],[action([range(0,255)],[reduce(1,286,0)])]),state-rec(46,[],[action([range(0,256)],[reduce(1,262,0)])]),state-rec(47,[goto([99],90),goto([110],89),goto([40],88),goto([115],87),goto([105],86),goto([60],85)],[action([99],[shift(90)]),action([110],[shift(89)]),action([40],[shift(88)]),action([115],[shift(87)]),action([105],[shift(86)]),action([60],[shift(85)])]),state-rec(48,[goto([101],91)],[action([range(0,100),range(102,256)],[reduce(1,366,0)]),action([101],[shift(91),reduce(1,366,0)])]),state-rec(49,[],[action([range(0,256)],[reduce(2,472,0)])]),state-rec(50,[],[action([range(0,47),range(58,64),range(91,94),96,range(123,256)],[reduce(2,446,0)])]),state-rec(51,[goto([range(48,57),range(65,90),95,range(97,122)],53),goto([348],92)],[action([range(0,47),range(58,64),range(91,94),96,range(123,256)],[reduce(1,340,0)]),action([range(48,57),range(65,90),95,range(97,122)],[sh!
 ift(53),reduce(1,340,0)])]),state-rec(52,[goto([range(48,57),range(6
0),95,range(97,122)],53),goto([348],93)],[action([range(0,47),range(58,64),range(91,94),96,range(123,256)],[reduce(2,446,0)]),action([range(48,57),range(65,90),95,range(97,122)],[shift(53)])]),state-rec(53,[],[action([range(0,256)],[reduce(1,348,0)])]),state-rec(54,[],[action([range(0,256)],[reduce(1,339,0)])]),state-rec(55,[],[action([range(0,46),range(48,256)],[reduce(1,401,0)])]),state-rec(56,[],[action([range(0,256)],[reduce(1,399,0)])]),state-rec(57,[goto([42],60),goto([range(0,41),range(43,255)],59),goto([339],95),goto([399],54),goto([401],56),goto([272],55),goto([403],54),goto([436],94)],[action([256],[reduce(0,436,0)]),action([42],[shift(60)]),action([range(0,41),range(43,255)],[shift(59)])]),state-rec(58,[goto([42],60),goto([range(0,41),range(43,255)],59),goto([339],96),goto([399],54),goto([401],56),goto([272],55),goto([403],54)],[action([42],[shift(60)]),action([range(0,41),range(43,255)],[shift(59)])]),state-rec(59,[],[action([range(0,256)],[reduce(1,403,0)])]),st!
 ate-rec(60,[],[action([range(0,256)],[reduce(1,272,0)])]),state-rec(61,[goto([42],98),goto([range(0,41),range(43,255)],59),goto([339],95),goto([399],54),goto([401],56),goto([272],55),goto([403],54),goto([273],97)],[action([42],[shift(98)]),action([range(0,41),range(43,255)],[shift(59)])]),state-rec(62,[],[action([range(0,256)],[reduce(2,274,0)])]),state-rec(63,[],[action([256],[reduce(3,395,0)])]),state-rec(64,[goto([40],100),goto([265],99)],[action([40],[shift(100)])]),state-rec(65,[goto([range(48,57)],105),goto([461],104),goto([462],103),goto([353],101),goto([352],102),goto([354],101),goto([355],101),goto([357],101)],[action([range(48,57)],[shift(105)])]),state-rec(66,[goto([46],110),goto([306],108),goto([305],109),goto([307],108),goto([308],108),goto([309],108),goto([385],107),goto([263],106)],[action([256],[reduce(3,396,0)]),action([46],[shift(110)])]),state-rec(67,[],[action([range(0,256)],[reduce(2,364,0)])]),state-rec(68,[],[action([range(0,256)],[reduce(2,362,0)])])!
 ,state-rec(69,[goto([93],112),goto([285],111)],[action([93],[shift(1
])]),state-rec(70,[goto([range(0,91),range(94,255)],77),goto([375],113)],[action([range(92,93)],[reduce(1,466,0)]),action([range(0,91),range(94,255)],[shift(77)])]),state-rec(71,[goto([range(0,91),range(94,255)],77),goto([375],114)],[action([range(0,91),range(94,255)],[shift(77)])]),state-rec(72,[],[action([range(0,255)],[reduce(1,468,0)])]),state-rec(73,[],[action([range(0,255)],[reduce(1,382,0)])]),state-rec(74,[goto([range(92,93)],115)],[action([range(92,93)],[shift(115)])]),state-rec(75,[goto([92],78),goto([range(0,91),range(94,255)],77),goto([382],116),goto([467],73),goto([284],74),goto([468],73),goto([466],72),goto([371],70),goto([370],71),goto([372],70),goto([373],70),goto([375],70)],[action([93],[reduce(1,376,0)]),action([92],[shift(78)]),action([range(0,91),range(94,255)],[shift(77)])]),state-rec(76,[goto([92],78),goto([range(0,91),range(94,255)],77),goto([93],112),goto([382],117),goto([467],73),goto([284],74),goto([468],73),goto([466],72),goto([371],70),goto([370],!
 71),goto([372],70),goto([373],70),goto([375],70),goto([285],111)],[action([92],[shift(78)]),action([range(0,91),range(94,255)],[shift(77)]),action([93],[shift(112)])]),state-rec(77,[],[action([range(0,255)],[reduce(1,375,0)])]),state-rec(78,[],[action([range(92,93)],[reduce(1,284,0)])]),state-rec(79,[goto([45],119),goto([266],118),goto([414],118),goto([415],118)],[action([range(0,44),range(46,255)],[reduce(0,415,0)]),action([256],[reduce(0,415,0),reduce(3,394,0)]),action([45],[shift(119),reduce(0,415,0)])]),state-rec(80,[goto([60],126),goto([123],46),goto([91],45),goto([39,45,range(48,57),range(65,90),95,range(97,122)],44),goto([292],124),goto([291],125),goto([293],124),goto([294],124),goto([295],124),goto([383],121),goto([260],40),goto([384],121),goto([262],39),goto([449],121),goto([277],123),goto([450],121),goto([278],122),goto([451],121),goto([471],120),goto([469],33),goto([286],34),goto([470],33),goto([464],32),goto([362],30),goto([361],31),goto([363],30),goto([364],30)!
 ,goto([366],30)],[action([60],[shift(126)]),action([123],[shift(46)]
ction([91],[shift(45)]),action([39,45,range(48,57),range(65,90),95,range(97,122)],[shift(44)])]),state-rec(81,[goto([60],47),goto([123],46),goto([91],45),goto([39,45,range(48,57),range(65,90),95,range(97,122)],44),goto([386],127),goto([383],128),goto([260],40),goto([384],128),goto([262],39),goto([449],128),goto([277],38),goto([450],128),goto([278],37),goto([451],128),goto([471],35),goto([469],33),goto([286],34),goto([470],33),goto([464],32),goto([362],30),goto([361],31),goto([363],30),goto([364],30),goto([366],30),goto([387],127),goto([452],22),goto([453],22),goto([454],22),goto([279],28),goto([455],22),goto([280],27),goto([456],22),goto([275],26),goto([426],26),goto([427],26),goto([457],22),goto([281],25),goto([458],22),goto([282],24),goto([459],22),goto([283],23),goto([460],22)],[action([range(0,38),range(40,44),range(46,47),range(58,59),range(61,64),range(92,94),96,range(124,256)],[reduce(0,427,0)]),action([60],[shift(47),reduce(0,427,0)]),action([123],[shift(46),reduce(0!
 ,427,0)]),action([91],[shift(45),reduce(0,427,0)]),action([39,45,range(48,57),range(65,90),95,range(97,122)],[shift(44),reduce(0,427,0)])]),state-rec(82,[],[action([256],[reduce(3,397,0)])]),state-rec(83,[goto([116],130),goto([270],129),goto([422],129),goto([423],129)],[action([range(0,115),range(117,256)],[reduce(0,423,0)]),action([116],[shift(130),reduce(0,423,0)])]),state-rec(84,[],[action([256],[reduce(3,398,0)])]),state-rec(85,[],[action([range(0,256)],[reduce(2,260,0)])]),state-rec(86,[goto([110],131)],[action([110],[shift(131)])]),state-rec(87,[goto([116],133),goto([111],132)],[action([116],[shift(133)]),action([111],[shift(132)])]),state-rec(88,[],[action([range(0,256)],[reduce(2,275,0)])]),state-rec(89,[goto([111],135),goto([105],134)],[action([111],[shift(135)]),action([105],[shift(134)])]),state-rec(90,[goto([111],136)],[action([111],[shift(136)])]),state-rec(91,[goto([103],137)],[action([103],[shift(137)])]),state-rec(92,[],[action([range(0,256)],[reduce(2,346,0!
 )])]),state-rec(93,[],[action([range(0,256)],[reduce(2,344,0)])]),st
-rec(94,[],[action([range(0,256)],[reduce(3,431,0)])]),state-rec(95,[],[action([range(0,256)],[reduce(2,337,0)])]),state-rec(96,[],[action([range(0,256)],[reduce(2,335,0)])]),state-rec(97,[],[action([range(0,256)],[reduce(3,404,0)])]),state-rec(98,[goto([47],138)],[action([range(0,46),range(48,256)],[reduce(1,272,0)]),action([47],[shift(138),reduce(1,272,0)])]),state-rec(99,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],139),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),goto([434],3),goto([439],10),goto([437],6),goto([442],9),goto([272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5),goto([448],4),goto([472],3),goto([288],139)],[action([range(48,57),range(65,90),95,range(97,122),256],[reduce(0,288,0)]),action([47],[shift(19),reduce(0,288,0)]),action([range(9,10),32],[shift(!
 18)]),action([42],[shift(17),reduce(0,288,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[shift(16),reduce(0,288,0)]),action([range(12,13)],[shift(15),reduce(0,288,0)])]),state-rec(100,[],[action([range(0,255)],[reduce(1,265,0)])]),state-rec(101,[goto([range(48,57)],105),goto([357],140)],[action([range(0,47),range(58,256)],[reduce(1,462,0)]),action([range(48,57)],[shift(105),reduce(1,462,0)])]),state-rec(102,[goto([range(48,57)],105),goto([357],141)],[action([range(48,57)],[shift(105)])]),state-rec(103,[],[action([range(0,256)],[reduce(1,461,0)])]),state-rec(104,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],142),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),goto([434],3),goto([439],10),goto([437],6),goto([442],9),goto([!
 272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5),goto
48],4),goto([472],3),goto([288],142)],[action([range(48,57),range(65,90),95,range(97,122),256],[reduce(0,288,0)]),action([47],[shift(19),reduce(0,288,0)]),action([range(9,10),32],[shift(18)]),action([42],[shift(17),reduce(0,288,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[shift(16),reduce(0,288,0)]),action([range(12,13)],[shift(15),reduce(0,288,0)])]),state-rec(105,[],[action([range(0,256)],[reduce(1,357,0)])]),state-rec(106,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],143),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),goto([434],3),goto([439],10),goto([437],6),goto([442],9),goto([272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5),goto([448],4),goto([472],3),goto([288],143)],[action([range(48,57),range(6!
 5,90),95,range(97,122),256],[reduce(0,288,0)]),action([47],[shift(19),reduce(0,288,0)]),action([range(9,10),32],[shift(18)]),action([42],[shift(17),reduce(0,288,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[shift(16),reduce(0,288,0)]),action([range(12,13)],[shift(15),reduce(0,288,0)])]),state-rec(107,[],[action([range(0,256)],[reduce(1,309,0)])]),state-rec(108,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],144),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),goto([434],3),goto([439],10),goto([437],6),goto([442],9),goto([272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5),goto([448],4),goto([472],3),goto([288],144)],[action([range(48,57),range(65,90),95,range(97,122),256],[reduce(0,288,0),reduce(3,388,0)]),act!
 ion([47],[reduce(3,388,0),shift(19),reduce(0,288,0)]),action([range(
0),32],[shift(18),reduce(3,388,0)]),action([42],[reduce(3,388,0),shift(17),reduce(0,288,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[reduce(3,388,0),shift(16),reduce(0,288,0)]),action([range(12,13)],[reduce(3,388,0),shift(15),reduce(0,288,0)])]),state-rec(109,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],145),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),goto([434],3),goto([439],10),goto([437],6),goto([442],9),goto([272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5),goto([448],4),goto([472],3),goto([288],145)],[action([range(48,57),range(65,90),95,range(97,122),256],[reduce(0,288,0)]),action([47],[shift(19),reduce(0,288,0)]),action([range(9,10),32],[shift(18)]),action([42],[shift(17),reduce(0,288,0)]),act!
 ion([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[shift(16),reduce(0,288,0)]),action([range(12,13)],[shift(15),reduce(0,288,0)])]),state-rec(110,[],[action([range(0,256)],[reduce(1,263,0)])]),state-rec(111,[],[action([range(0,256)],[reduce(3,469,0)])]),state-rec(112,[],[action([range(0,256)],[reduce(1,285,0)])]),state-rec(113,[],[action([range(0,255)],[reduce(2,373,0)])]),state-rec(114,[],[action([range(0,255)],[reduce(2,371,0)])]),state-rec(115,[],[action([range(0,255)],[reduce(2,467,0)])]),state-rec(116,[],[action([range(0,255)],[reduce(2,381,0)])]),state-rec(117,[],[action([range(0,255)],[reduce(2,379,0)])]),state-rec(118,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],146),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),goto([434!
 ],3),goto([439],10),goto([437],6),goto([442],9),goto([272],8),goto([
],6),goto([444],7),goto([440],6),goto([446],5),goto([448],4),goto([472],3),goto([288],146)],[action([range(48,57),range(65,90),95,range(97,122),256],[reduce(1,414,0),reduce(0,288,0)]),action([47],[reduce(0,288,0),shift(19),reduce(1,414,0)]),action([range(9,10),32],[shift(18),reduce(1,414,0)]),action([42],[reduce(0,288,0),shift(17),reduce(1,414,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[reduce(0,288,0),shift(16),reduce(1,414,0)]),action([range(12,13)],[reduce(0,288,0),shift(15),reduce(1,414,0)])]),state-rec(119,[goto([62],147)],[action([62],[shift(147)])]),state-rec(120,[],[action([range(0,256)],[reduce(1,451,0)])]),state-rec(121,[],[action([range(0,256)],[reduce(1,295,0)])]),state-rec(122,[],[action([range(0,256)],[reduce(1,450,0)])]),state-rec(123,[],[action([range(0,256)],[reduce(1,449,0)])]),state-rec(124,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41)!
 ,range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],148),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),goto([434],3),goto([439],10),goto([437],6),goto([442],9),goto([272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5),goto([448],4),goto([472],3),goto([288],148)],[action([range(48,57),range(65,90),95,range(97,122),256],[reduce(0,288,0)]),action([47],[shift(19),reduce(0,288,0)]),action([range(9,10),32],[shift(18)]),action([42],[shift(17),reduce(0,288,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[shift(16),reduce(0,288,0)]),action([range(12,13)],[shift(15),reduce(0,288,0)])]),state-rec(125,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],149),goto([430],3),goto([404]!
 ,12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),got
434],3),goto([439],10),goto([437],6),goto([442],9),goto([272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5),goto([448],4),goto([472],3),goto([288],149)],[action([range(48,57),range(65,90),95,range(97,122),256],[reduce(0,288,0)]),action([47],[shift(19),reduce(0,288,0)]),action([range(9,10),32],[shift(18)]),action([42],[shift(17),reduce(0,288,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[shift(16),reduce(0,288,0)]),action([range(12,13)],[shift(15),reduce(0,288,0)])]),state-rec(126,[goto([115],150),goto([105],86),goto([60],85)],[action([115],[shift(150)]),action([105],[shift(86)]),action([60],[shift(85)])]),state-rec(127,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],151),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([4!
 33],11),goto([434],3),goto([439],10),goto([437],6),goto([442],9),goto([272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5),goto([448],4),goto([472],3),goto([288],151)],[action([range(48,57),range(65,90),95,range(97,122),256],[reduce(0,288,0)]),action([47],[shift(19),reduce(0,288,0)]),action([range(9,10),32],[shift(18)]),action([42],[shift(17),reduce(0,288,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[shift(16),reduce(0,288,0)]),action([range(12,13)],[shift(15),reduce(0,288,0)])]),state-rec(128,[],[action([range(0,256)],[reduce(1,386,0)])]),state-rec(129,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],152),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),goto([434],3),goto([439],10),goto([437],6),goto([442],9),g!
 oto([272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5)
to([448],4),goto([472],3),goto([288],152)],[action([range(48,57),range(65,90),95,range(97,122),256],[reduce(1,422,0),reduce(0,288,0)]),action([47],[reduce(0,288,0),shift(19),reduce(1,422,0)]),action([range(9,10),32],[shift(18),reduce(1,422,0)]),action([42],[reduce(0,288,0),shift(17),reduce(1,422,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[reduce(0,288,0),shift(16),reduce(1,422,0)]),action([range(12,13)],[reduce(0,288,0),shift(15),reduce(1,422,0)])]),state-rec(130,[goto([114],153)],[action([114],[shift(153)])]),state-rec(131,[goto([116],154)],[action([116],[shift(154)])]),state-rec(132,[goto([109],155)],[action([109],[shift(155)])]),state-rec(133,[goto([114],156)],[action([114],[shift(156)])]),state-rec(134,[goto([108],157)],[action([108],[shift(157)])]),state-rec(135,[goto([110],158)],[action([110],[shift(158)])]),state-rec(136,[goto([110],159)],[action([110],[shift(159)])]),state-rec(137,[goto([117],160)],[!
 action([117],[shift(160)])]),state-rec(138,[],[action([range(0,256)],[reduce(2,273,0)])]),state-rec(139,[goto([60],47),goto([123],46),goto([91],45),goto([39,45,range(48,57),range(65,90),95,range(97,122)],44),goto([296],161),goto([299],164),goto([298],165),goto([300],164),goto([301],164),goto([302],164),goto([388],162),goto([386],163),goto([383],128),goto([260],40),goto([384],128),goto([262],39),goto([449],128),goto([277],38),goto([450],128),goto([278],37),goto([451],128),goto([471],35),goto([469],33),goto([286],34),goto([470],33),goto([464],32),goto([362],30),goto([361],31),goto([363],30),goto([364],30),goto([366],30),goto([387],163),goto([452],22),goto([453],22),goto([454],22),goto([279],28),goto([455],22),goto([280],27),goto([456],22),goto([275],26),goto([426],26),goto([427],26),goto([457],22),goto([281],25),goto([458],22),goto([282],24),goto([459],22),goto([283],23),goto([460],22),goto([389],162),goto([297],161)],[action([range(48,57),range(65,90),95,range(97,122)],[shif!
 t(44),reduce(0,427,0)]),action([256],[reduce(0,427,0)]),action([rang
,38),range(40,44),range(46,47),range(58,59),range(61,64),range(92,94),96,range(124,255)],[reduce(0,427,0),reduce(0,297,0)]),action([60],[reduce(0,297,0),shift(47),reduce(0,427,0)]),action([123],[reduce(0,297,0),shift(46),reduce(0,427,0)]),action([91],[reduce(0,297,0),shift(45),reduce(0,427,0)]),action([39,45],[reduce(0,297,0),shift(44),reduce(0,427,0)])]),state-rec(140,[],[action([range(0,256)],[reduce(2,355,0)])]),state-rec(141,[],[action([range(0,256)],[reduce(2,353,0)])]),state-rec(142,[goto([41],167),goto([276],166),goto([428],166),goto([429],166)],[action([range(0,40),range(42,256)],[reduce(0,429,0)]),action([41],[shift(167),reduce(0,429,0)])]),state-rec(143,[goto([60],172),goto([91],45),goto([39,45,range(48,57),range(65,90),95,range(97,122)],44),goto([452],169),goto([277],171),goto([453],169),goto([278],170),goto([454],169),goto([279],28),goto([455],169),goto([280],27),goto([456],169),goto([275],26),goto([426],26),goto([427],26),goto([457],169),goto([281],25),goto([458!
 ],169),goto([282],24),goto([459],169),goto([283],23),goto([460],169),goto([471],168),goto([469],33),goto([286],34),goto([470],33),goto([464],32),goto([362],30),goto([361],31),goto([363],30),goto([364],30),goto([366],30)],[action([range(0,38),range(40,44),range(46,47),range(58,59),range(61,64),range(92,94),96,range(123,256)],[reduce(0,427,0)]),action([60],[shift(172),reduce(0,427,0)]),action([91],[shift(45),reduce(0,427,0)]),action([39,45,range(48,57),range(65,90),95,range(97,122)],[shift(44),reduce(0,427,0)])]),state-rec(144,[goto([46],110),goto([309],173),goto([385],107),goto([263],106)],[action([46],[shift(110)])]),state-rec(145,[goto([46],110),goto([309],174),goto([385],107),goto([263],106)],[action([46],[shift(110)])]),state-rec(146,[goto([60],47),goto([123],46),goto([91],45),goto([39,45,range(48,57),range(65,90),95,range(97,122)],44),goto([313],176),goto([312],177),goto([314],176),goto([315],176),goto([316],176),goto([388],175),goto([386],163),goto([383],128),goto([260!
 ],40),goto([384],128),goto([262],39),goto([449],128),goto([277],38),
o([450],128),goto([278],37),goto([451],128),goto([471],35),goto([469],33),goto([286],34),goto([470],33),goto([464],32),goto([362],30),goto([361],31),goto([363],30),goto([364],30),goto([366],30),goto([387],163),goto([452],22),goto([453],22),goto([454],22),goto([279],28),goto([455],22),goto([280],27),goto([456],22),goto([275],26),goto([426],26),goto([427],26),goto([457],22),goto([281],25),goto([458],22),goto([282],24),goto([459],22),goto([283],23),goto([460],22),goto([389],175)],[action([range(0,38),range(40,44),range(46,47),range(58,59),range(61,64),range(92,94),96,range(124,256)],[reduce(0,427,0)]),action([60],[shift(47),reduce(0,427,0)]),action([123],[shift(46),reduce(0,427,0)]),action([91],[shift(45),reduce(0,427,0)]),action([39,45,range(48,57),range(65,90),95,range(97,122)],[shift(44),reduce(0,427,0)])]),state-rec(147,[],[action([range(0,256)],[reduce(2,266,0)])]),state-rec(148,[goto([125],181),goto([44],180),goto([261],179),goto([410],179),goto([411],179),goto([257],178)!
 ,goto([408],178),goto([409],178)],[action([range(0,43),range(45,124),range(126,256)],[reduce(0,411,0),reduce(0,409,0)]),action([125],[reduce(0,409,0),shift(181),reduce(0,411,0)]),action([44],[reduce(0,409,0),shift(180),reduce(0,411,0)])]),state-rec(149,[goto([44],180),goto([257],182),goto([408],182),goto([409],182)],[action([range(0,43),range(45,256)],[reduce(0,409,0)]),action([44],[shift(180),reduce(0,409,0)])]),state-rec(150,[goto([116],133)],[action([116],[shift(133)])]),state-rec(151,[goto([62],184),goto([259],183),goto([406],183),goto([407],183)],[action([range(0,61),range(63,256)],[reduce(0,407,0)]),action([62],[shift(184),reduce(0,407,0)])]),state-rec(152,[goto([103],186),goto([269],185),goto([420],185),goto([421],185)],[action([range(0,102),range(104,256)],[reduce(0,421,0)]),action([103],[shift(186),reduce(0,421,0)])]),state-rec(153,[goto([101],187)],[action([101],[shift(187)])]),state-rec(154,[goto([62],188)],[action([62],[shift(188)])]),state-rec(155,[goto([101],1!
 89)],[action([101],[shift(189)])]),state-rec(156,[goto([105],190)],[
ion([105],[shift(190)])]),state-rec(157,[goto([62],191)],[action([62],[shift(191)])]),state-rec(158,[goto([101],192)],[action([101],[shift(192)])]),state-rec(159,[goto([115],194),goto([99],193)],[action([115],[shift(194)]),action([99],[shift(193)])]),state-rec(160,[goto([108],195)],[action([108],[shift(195)])]),state-rec(161,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],196),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),goto([434],3),goto([439],10),goto([437],6),goto([442],9),goto([272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5),goto([448],4),goto([472],3),goto([288],196)],[action([range(48,57),range(65,90),95,range(97,122),256],[reduce(0,288,0)]),action([47],[shift(19),reduce(0,288,0)]),action([range(9,10),32],[shift(18)]),action([42],[shift(17),reduce(0,288,0)]),act!
 ion([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[shift(16),reduce(0,288,0)]),action([range(12,13)],[shift(15),reduce(0,288,0)])]),state-rec(162,[],[action([range(0,255)],[reduce(1,302,0)])]),state-rec(163,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],197),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),goto([434],3),goto([439],10),goto([437],6),goto([442],9),goto([272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5),goto([448],4),goto([472],3),goto([288],197)],[action([range(48,57),range(65,90),95,range(97,122),256],[reduce(1,389,0),reduce(0,288,0)]),action([47],[reduce(0,288,0),shift(19),reduce(1,389,0)]),action([range(9,10),32],[shift(18),reduce(1,389,0)]),action([42],[reduce(0,288,0),shift(17),reduce(1,389,0)]),actio!
 n([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64)
nge(91,94),96,range(123,255)],[reduce(0,288,0),shift(16),reduce(1,389,0)]),action([range(12,13)],[reduce(0,288,0),shift(15),reduce(1,389,0)])]),state-rec(164,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],198),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),goto([434],3),goto([439],10),goto([437],6),goto([442],9),goto([272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5),goto([448],4),goto([472],3),goto([288],198)],[action([range(48,57),range(65,90),95,range(97,122),256],[reduce(0,288,0)]),action([47],[reduce(1,296,0),shift(19),reduce(0,288,0)]),action([range(9,10),32],[shift(18),reduce(1,296,0)]),action([42],[reduce(1,296,0),shift(17),reduce(0,288,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[reduce(1,296,0),s!
 hift(16),reduce(0,288,0)]),action([range(12,13)],[reduce(1,296,0),shift(15),reduce(0,288,0)])]),state-rec(165,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],199),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),goto([434],3),goto([439],10),goto([437],6),goto([442],9),goto([272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5),goto([448],4),goto([472],3),goto([288],199)],[action([range(48,57),range(65,90),95,range(97,122),256],[reduce(0,288,0)]),action([47],[shift(19),reduce(0,288,0)]),action([range(9,10),32],[shift(18)]),action([42],[shift(17),reduce(0,288,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[shift(16),reduce(0,288,0)]),action([range(12,13)],[shift(15),reduce(0,288,0)])]),state-rec(166,[],[action([range!
 (0,256)],[reduce(1,428,0),reduce(5,456,0)])]),state-rec(167,[goto([6
200)],[action([62],[shift(200)])]),state-rec(168,[],[action([range(0,256)],[reduce(1,460,0)])]),state-rec(169,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],201),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),goto([434],3),goto([439],10),goto([437],6),goto([442],9),goto([272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5),goto([448],4),goto([472],3),goto([288],201)],[action([range(48,57),range(65,90),95,range(97,122),256],[reduce(0,288,0)]),action([47],[shift(19),reduce(0,288,0)]),action([range(9,10),32],[shift(18)]),action([42],[shift(17),reduce(0,288,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[shift(16),reduce(0,288,0)]),action([range(12,13)],[shift(15),reduce(0,288,0)])]),state-rec(170,[],[action([range(!
 0,256)],[reduce(1,453,0)])]),state-rec(171,[],[action([range(0,256)],[reduce(1,452,0)])]),state-rec(172,[goto([99],90),goto([110],89),goto([40],88),goto([115],87),goto([105],86)],[action([99],[shift(90)]),action([110],[shift(89)]),action([40],[shift(88)]),action([115],[shift(87)]),action([105],[shift(86)])]),state-rec(173,[],[action([range(0,256)],[reduce(3,308,0)])]),state-rec(174,[],[action([range(0,256)],[reduce(3,306,0)])]),state-rec(175,[],[action([range(0,256)],[reduce(1,316,0)])]),state-rec(176,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],202),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),goto([434],3),goto([439],10),goto([437],6),goto([442],9),goto([272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5),goto([448],4),goto([472],3),goto([288],202)],[action([range(48!
 ,57),range(65,90),95,range(97,122),256],[reduce(0,288,0),reduce(5,39
)]),action([47],[reduce(5,390,0),shift(19),reduce(0,288,0)]),action([range(9,10),32],[shift(18),reduce(5,390,0)]),action([42],[reduce(5,390,0),shift(17),reduce(0,288,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[reduce(5,390,0),shift(16),reduce(0,288,0)]),action([range(12,13)],[reduce(5,390,0),shift(15),reduce(0,288,0)])]),state-rec(177,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],203),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),goto([434],3),goto([439],10),goto([437],6),goto([442],9),goto([272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5),goto([448],4),goto([472],3),goto([288],203)],[action([range(48,57),range(65,90),95,range(97,122),256],[reduce(0,288,0)]),action([47],[shift(19),reduce(0,288,0)]),act!
 ion([range(9,10),32],[shift(18)]),action([42],[shift(17),reduce(0,288,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[shift(16),reduce(0,288,0)]),action([range(12,13)],[shift(15),reduce(0,288,0)])]),state-rec(178,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],204),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),goto([434],3),goto([439],10),goto([437],6),goto([442],9),goto([272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5),goto([448],4),goto([472],3),goto([288],204)],[action([range(48,57),range(65,90),95,range(97,122),256],[reduce(0,288,0),reduce(1,408,0)]),action([47],[reduce(1,408,0),shift(19),reduce(0,288,0)]),action([range(9,10),32],[shift(18),reduce(1,408,0)]),action([42],[reduce(1,408,0),shift(17),reduce!
 (0,288,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43
),range(58,64),range(91,94),96,range(123,255)],[reduce(1,408,0),shift(16),reduce(0,288,0)]),action([range(12,13)],[reduce(1,408,0),shift(15),reduce(0,288,0)])]),state-rec(179,[],[action([range(0,256)],[reduce(1,410,0),reduce(5,384,0)])]),state-rec(180,[],[action([range(0,256)],[reduce(1,257,0)])]),state-rec(181,[],[action([range(0,256)],[reduce(1,261,0)])]),state-rec(182,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],205),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),goto([434],3),goto([439],10),goto([437],6),goto([442],9),goto([272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5),goto([448],4),goto([472],3),goto([288],205)],[action([range(48,57),range(65,90),95,range(97,122),256],[reduce(0,288,0),reduce(1,408,0)]),action([47],[reduce(1,408,0),shift(19),reduce(0,288,0)]),ac!
 tion([range(9,10),32],[shift(18),reduce(1,408,0)]),action([42],[reduce(1,408,0),shift(17),reduce(0,288,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[reduce(1,408,0),shift(16),reduce(0,288,0)]),action([range(12,13)],[reduce(1,408,0),shift(15),reduce(0,288,0)])]),state-rec(183,[],[action([range(0,256)],[reduce(1,406,0),reduce(5,383,0)])]),state-rec(184,[goto([62],206)],[action([62],[shift(206)])]),state-rec(185,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],207),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),goto([434],3),goto([439],10),goto([437],6),goto([442],9),goto([272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5),goto([448],4),goto([472],3),goto([288],207)],[action([range(48,57),range(65,90),95,range(9!
 7,122),256],[reduce(1,420,0),reduce(0,288,0)]),action([47],[reduce(0
8,0),shift(19),reduce(1,420,0)]),action([range(9,10),32],[shift(18),reduce(1,420,0)]),action([42],[reduce(0,288,0),shift(17),reduce(1,420,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[reduce(0,288,0),shift(16),reduce(1,420,0)]),action([range(12,13)],[reduce(0,288,0),shift(15),reduce(1,420,0)])]),state-rec(186,[goto([114],208)],[action([114],[shift(208)])]),state-rec(187,[goto([101],209)],[action([101],[shift(209)])]),state-rec(188,[],[action([range(0,256)],[reduce(5,277,0)])]),state-rec(189,[goto([62],210)],[action([62],[shift(210)])]),state-rec(190,[goto([110],211)],[action([110],[shift(211)])]),state-rec(191,[],[action([range(0,256)],[reduce(5,281,0)])]),state-rec(192,[goto([62],212)],[action([62],[shift(212)])]),state-rec(193,[goto([62],213)],[action([62],[shift(213)])]),state-rec(194,[goto([62],214)],[action([62],[shift(214)])]),state-rec(195,[goto([97],215)],[action([97],[shift(215)])]),state-rec(196,[got!
 o([41],217),goto([264],216)],[action([41],[shift(217)])]),state-rec(197,[goto([46],110),goto([306],108),goto([305],109),goto([307],108),goto([308],108),goto([309],108),goto([385],107),goto([263],106)],[action([46],[shift(110)])]),state-rec(198,[goto([44],180),goto([257],218),goto([408],218),goto([409],218)],[action([range(0,43),range(45,256)],[reduce(0,409,0)]),action([44],[shift(180),reduce(0,409,0)])]),state-rec(199,[goto([41],217),goto([44],180),goto([264],216),goto([257],219),goto([408],219),goto([409],219)],[action([range(0,40),range(42,43),range(45,256)],[reduce(0,409,0)]),action([41],[shift(217),reduce(0,409,0)]),action([44],[shift(180),reduce(0,409,0)])]),state-rec(200,[],[action([range(0,256)],[reduce(2,276,0)])]),state-rec(201,[goto([60],47),goto([123],46),goto([91],45),goto([39,45,range(48,57),range(65,90),95,range(97,122)],44),goto([388],220),goto([386],163),goto([383],128),goto([260],40),goto([384],128),goto([262],39),goto([449],128),goto([277],38),goto([450],1!
 28),goto([278],37),goto([451],128),goto([471],35),goto([469],33),got
286],34),goto([470],33),goto([464],32),goto([362],30),goto([361],31),goto([363],30),goto([364],30),goto([366],30),goto([387],163),goto([452],22),goto([453],22),goto([454],22),goto([279],28),goto([455],22),goto([280],27),goto([456],22),goto([275],26),goto([426],26),goto([427],26),goto([457],22),goto([281],25),goto([458],22),goto([282],24),goto([459],22),goto([283],23),goto([460],22),goto([389],220)],[action([range(0,38),range(40,44),range(46,47),range(58,59),range(61,64),range(92,94),96,range(124,256)],[reduce(0,427,0)]),action([60],[shift(47),reduce(0,427,0)]),action([123],[shift(46),reduce(0,427,0)]),action([91],[shift(45),reduce(0,427,0)]),action([39,45,range(48,57),range(65,90),95,range(97,122)],[shift(44),reduce(0,427,0)])]),state-rec(202,[goto([124],222),goto([258],221),goto([412],221),goto([413],221)],[action([range(0,123),range(125,256)],[reduce(0,413,0)]),action([124],[shift(222),reduce(0,413,0)])]),state-rec(203,[goto([124],222),goto([258],223),goto([412],223),goto(!
 [413],223)],[action([range(0,123),range(125,256)],[reduce(0,413,0)]),action([124],[shift(222),reduce(0,413,0)])]),state-rec(204,[goto([60],126),goto([123],46),goto([91],45),goto([39,45,range(48,57),range(65,90),95,range(97,122)],44),goto([295],224),goto([383],121),goto([260],40),goto([384],121),goto([262],39),goto([449],121),goto([277],123),goto([450],121),goto([278],122),goto([451],121),goto([471],120),goto([469],33),goto([286],34),goto([470],33),goto([464],32),goto([362],30),goto([361],31),goto([363],30),goto([364],30),goto([366],30)],[action([60],[shift(126)]),action([123],[shift(46)]),action([91],[shift(45)]),action([39,45,range(48,57),range(65,90),95,range(97,122)],[shift(44)])]),state-rec(205,[goto([60],126),goto([123],46),goto([91],45),goto([39,45,range(48,57),range(65,90),95,range(97,122)],44),goto([295],225),goto([383],121),goto([260],40),goto([384],121),goto([262],39),goto([449],121),goto([277],123),goto([450],121),goto([278],122),goto([451],121),goto([471],120),g!
 oto([469],33),goto([286],34),goto([470],33),goto([464],32),goto([362
0),goto([361],31),goto([363],30),goto([364],30),goto([366],30)],[action([60],[shift(126)]),action([123],[shift(46)]),action([91],[shift(45)]),action([39,45,range(48,57),range(65,90),95,range(97,122)],[shift(44)])]),state-rec(206,[],[action([range(0,256)],[reduce(2,259,0)])]),state-rec(207,[goto([115],228),goto([392],227),goto([268],226),goto([418],226),goto([419],226)],[action([range(0,114),range(116,256)],[reduce(0,419,0)]),action([115],[shift(228),reduce(0,419,0)])]),state-rec(208,[goto([97],229)],[action([97],[shift(229)])]),state-rec(209,[],[action([range(0,256)],[reduce(4,270,0)])]),state-rec(210,[],[action([range(0,256)],[reduce(6,280,0)])]),state-rec(211,[goto([103],230)],[action([103],[shift(230)])]),state-rec(212,[],[action([range(0,256)],[reduce(6,279,0)])]),state-rec(213,[],[action([range(0,256)],[reduce(6,283,0)])]),state-rec(214,[],[action([range(0,256)],[reduce(6,282,0)])]),state-rec(215,[goto([114],231)],[action([114],[shift(231)])]),state-rec(216,[],[action([!
 range(0,256)],[reduce(7,387,0)])]),state-rec(217,[],[action([range(0,256)],[reduce(1,264,0)])]),state-rec(218,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],232),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),goto([434],3),goto([439],10),goto([437],6),goto([442],9),goto([272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5),goto([448],4),goto([472],3),goto([288],232)],[action([range(48,57),range(65,90),95,range(97,122),256],[reduce(0,288,0),reduce(1,408,0)]),action([47],[reduce(1,408,0),shift(19),reduce(0,288,0)]),action([range(9,10),32],[shift(18),reduce(1,408,0)]),action([42],[reduce(1,408,0),shift(17),reduce(0,288,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[reduce(1,408,0),shift(16),reduce(0,288,0)]),acti!
 on([range(12,13)],[reduce(1,408,0),shift(15),reduce(0,288,0)])]),sta
rec(219,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],233),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),goto([434],3),goto([439],10),goto([437],6),goto([442],9),goto([272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5),goto([448],4),goto([472],3),goto([288],233)],[action([range(48,57),range(65,90),95,range(97,122),256],[reduce(0,288,0),reduce(1,408,0)]),action([47],[reduce(1,408,0),shift(19),reduce(0,288,0)]),action([range(9,10),32],[shift(18),reduce(1,408,0)]),action([42],[reduce(1,408,0),shift(17),reduce(0,288,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[reduce(1,408,0),shift(16),reduce(0,288,0)]),action([range(12,13)],[reduce(1,408,0),shift(15),reduce(0,288,0)])]),state-rec(220,[],[action([range(0,256)!
 ],[reduce(5,385,0)])]),state-rec(221,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],234),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),goto([434],3),goto([439],10),goto([437],6),goto([442],9),goto([272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5),goto([448],4),goto([472],3),goto([288],234)],[action([range(48,57),range(65,90),95,range(97,122),256],[reduce(0,288,0),reduce(1,412,0)]),action([47],[reduce(1,412,0),shift(19),reduce(0,288,0)]),action([range(9,10),32],[shift(18),reduce(1,412,0)]),action([42],[reduce(1,412,0),shift(17),reduce(0,288,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[reduce(1,412,0),shift(16),reduce(0,288,0)]),action([range(12,13)],[reduce(1,412,0),shift(15),reduce(0,288,0)])]),state-re!
 c(222,[],[action([range(0,256)],[reduce(1,258,0)])]),state-rec(223,[
o([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],235),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),goto([434],3),goto([439],10),goto([437],6),goto([442],9),goto([272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5),goto([448],4),goto([472],3),goto([288],235)],[action([range(48,57),range(65,90),95,range(97,122),256],[reduce(0,288,0),reduce(1,412,0)]),action([47],[reduce(1,412,0),shift(19),reduce(0,288,0)]),action([range(9,10),32],[shift(18),reduce(1,412,0)]),action([42],[reduce(1,412,0),shift(17),reduce(0,288,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[reduce(1,412,0),shift(16),reduce(0,288,0)]),action([range(12,13)],[reduce(1,412,0),shift(15),reduce(0,288,0)])]),state-rec(224,[],[action([range(0,256)],[reduce(5,!
 294,0)])]),state-rec(225,[],[action([range(0,256)],[reduce(5,292,0)])]),state-rec(226,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],236),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),goto([434],3),goto([439],10),goto([437],6),goto([442],9),goto([272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5),goto([448],4),goto([472],3),goto([288],236)],[action([range(48,57),range(65,90),95,range(97,122),256],[reduce(1,418,0),reduce(0,288,0)]),action([47],[reduce(0,288,0),shift(19),reduce(1,418,0)]),action([range(9,10),32],[shift(18),reduce(1,418,0)]),action([42],[reduce(0,288,0),shift(17),reduce(1,418,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[reduce(0,288,0),shift(16),reduce(1,418,0)]),action([range(12,13)],[reduc!
 e(0,288,0),shift(15),reduce(1,418,0)])]),state-rec(227,[goto([47],19
oto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],237),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),goto([434],3),goto([439],10),goto([437],6),goto([442],9),goto([272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5),goto([448],4),goto([472],3),goto([288],237)],[action([range(48,57),range(65,90),95,range(97,122),256],[reduce(0,288,0)]),action([47],[shift(19),reduce(0,288,0)]),action([range(9,10),32],[shift(18)]),action([42],[shift(17),reduce(0,288,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[shift(16),reduce(0,288,0)]),action([range(12,13)],[shift(15),reduce(0,288,0)])]),state-rec(228,[goto([116],238)],[action([116],[shift(238)])]),state-rec(229,[goto([109],239)],[action([109],[shift(239)])]),state-rec(230,[goto([62],240)],[ac!
 tion([62],[shift(240)])]),state-rec(231,[],[action([range(0,256)],[reduce(7,271,0)])]),state-rec(232,[goto([60],47),goto([123],46),goto([91],45),goto([39,45,range(48,57),range(65,90),95,range(97,122)],44),goto([302],241),goto([388],162),goto([386],163),goto([383],128),goto([260],40),goto([384],128),goto([262],39),goto([449],128),goto([277],38),goto([450],128),goto([278],37),goto([451],128),goto([471],35),goto([469],33),goto([286],34),goto([470],33),goto([464],32),goto([362],30),goto([361],31),goto([363],30),goto([364],30),goto([366],30),goto([387],163),goto([452],22),goto([453],22),goto([454],22),goto([279],28),goto([455],22),goto([280],27),goto([456],22),goto([275],26),goto([426],26),goto([427],26),goto([457],22),goto([281],25),goto([458],22),goto([282],24),goto([459],22),goto([283],23),goto([460],22),goto([389],162)],[action([range(0,38),range(40,44),range(46,47),range(58,59),range(61,64),range(92,94),96,range(124,256)],[reduce(0,427,0)]),action([60],[shift(47),reduce(0,4!
 27,0)]),action([123],[shift(46),reduce(0,427,0)]),action([91],[shift
),reduce(0,427,0)]),action([39,45,range(48,57),range(65,90),95,range(97,122)],[shift(44),reduce(0,427,0)])]),state-rec(233,[goto([60],47),goto([123],46),goto([91],45),goto([39,45,range(48,57),range(65,90),95,range(97,122)],44),goto([302],242),goto([388],162),goto([386],163),goto([383],128),goto([260],40),goto([384],128),goto([262],39),goto([449],128),goto([277],38),goto([450],128),goto([278],37),goto([451],128),goto([471],35),goto([469],33),goto([286],34),goto([470],33),goto([464],32),goto([362],30),goto([361],31),goto([363],30),goto([364],30),goto([366],30),goto([387],163),goto([452],22),goto([453],22),goto([454],22),goto([279],28),goto([455],22),goto([280],27),goto([456],22),goto([275],26),goto([426],26),goto([427],26),goto([457],22),goto([281],25),goto([458],22),goto([282],24),goto([459],22),goto([283],23),goto([460],22),goto([389],162)],[action([range(0,38),range(40,44),range(46,47),range(58,59),range(61,64),range(92,94),96,range(124,256)],[reduce(0,427,0)]),action([60],!
 [shift(47),reduce(0,427,0)]),action([123],[shift(46),reduce(0,427,0)]),action([91],[shift(45),reduce(0,427,0)]),action([39,45,range(48,57),range(65,90),95,range(97,122)],[shift(44),reduce(0,427,0)])]),state-rec(234,[goto([60],47),goto([123],46),goto([91],45),goto([39,45,range(48,57),range(65,90),95,range(97,122)],44),goto([316],243),goto([388],175),goto([386],163),goto([383],128),goto([260],40),goto([384],128),goto([262],39),goto([449],128),goto([277],38),goto([450],128),goto([278],37),goto([451],128),goto([471],35),goto([469],33),goto([286],34),goto([470],33),goto([464],32),goto([362],30),goto([361],31),goto([363],30),goto([364],30),goto([366],30),goto([387],163),goto([452],22),goto([453],22),goto([454],22),goto([279],28),goto([455],22),goto([280],27),goto([456],22),goto([275],26),goto([426],26),goto([427],26),goto([457],22),goto([281],25),goto([458],22),goto([282],24),goto([459],22),goto([283],23),goto([460],22),goto([389],175)],[action([range(0,38),range(40,44),range(46,!
 47),range(58,59),range(61,64),range(92,94),96,range(124,256)],[reduc
,427,0)]),action([60],[shift(47),reduce(0,427,0)]),action([123],[shift(46),reduce(0,427,0)]),action([91],[shift(45),reduce(0,427,0)]),action([39,45,range(48,57),range(65,90),95,range(97,122)],[shift(44),reduce(0,427,0)])]),state-rec(235,[goto([60],47),goto([123],46),goto([91],45),goto([39,45,range(48,57),range(65,90),95,range(97,122)],44),goto([316],244),goto([388],175),goto([386],163),goto([383],128),goto([260],40),goto([384],128),goto([262],39),goto([449],128),goto([277],38),goto([450],128),goto([278],37),goto([451],128),goto([471],35),goto([469],33),goto([286],34),goto([470],33),goto([464],32),goto([362],30),goto([361],31),goto([363],30),goto([364],30),goto([366],30),goto([387],163),goto([452],22),goto([453],22),goto([454],22),goto([279],28),goto([455],22),goto([280],27),goto([456],22),goto([275],26),goto([426],26),goto([427],26),goto([457],22),goto([281],25),goto([458],22),goto([282],24),goto([459],22),goto([283],23),goto([460],22),goto([389],175)],[action([range(0,38),r!
 ange(40,44),range(46,47),range(58,59),range(61,64),range(92,94),96,range(124,256)],[reduce(0,427,0)]),action([60],[shift(47),reduce(0,427,0)]),action([123],[shift(46),reduce(0,427,0)]),action([91],[shift(45),reduce(0,427,0)]),action([39,45,range(48,57),range(65,90),95,range(97,122)],[shift(44),reduce(0,427,0)])]),state-rec(236,[goto([60],126),goto([123],46),goto([91],45),goto([39,45,range(48,57),range(65,90),95,range(97,122)],44),goto([327],246),goto([326],247),goto([328],246),goto([329],246),goto([330],246),goto([383],245),goto([260],40),goto([384],245),goto([262],39),goto([449],245),goto([277],123),goto([450],245),goto([278],122),goto([451],245),goto([471],120),goto([469],33),goto([286],34),goto([470],33),goto([464],32),goto([362],30),goto([361],31),goto([363],30),goto([364],30),goto([366],30)],[action([60],[shift(126)]),action([123],[shift(46)]),action([91],[shift(45)]),action([39,45,range(48,57),range(65,90),95,range(97,122)],[shift(44)])]),state-rec(237,[goto([112],250!
 ),goto([391],249),goto([267],248),goto([416],248),goto([417],248)],[
ion([range(0,111),range(113,256)],[reduce(0,417,0)]),action([112],[shift(250),reduce(0,417,0)])]),state-rec(238,[goto([97],251)],[action([97],[shift(251)])]),state-rec(239,[goto([109],252)],[action([109],[shift(252)])]),state-rec(240,[],[action([range(0,256)],[reduce(8,278,0)])]),state-rec(241,[],[action([range(0,255)],[reduce(5,301,0)])]),state-rec(242,[],[action([range(0,255)],[reduce(5,299,0)])]),state-rec(243,[],[action([range(0,256)],[reduce(5,315,0)])]),state-rec(244,[],[action([range(0,256)],[reduce(5,313,0)])]),state-rec(245,[],[action([range(0,256)],[reduce(1,330,0)])]),state-rec(246,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],253),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),goto([434],3),goto([439],10),goto([437],6),goto([442],9),goto([272],8),goto([438],6),goto([444],7!
 ),goto([440],6),goto([446],5),goto([448],4),goto([472],3),goto([288],253)],[action([range(48,57),range(65,90),95,range(97,122),256],[reduce(0,288,0),reduce(3,392,0)]),action([47],[reduce(3,392,0),shift(19),reduce(0,288,0)]),action([range(9,10),32],[shift(18),reduce(3,392,0)]),action([42],[reduce(3,392,0),shift(17),reduce(0,288,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[reduce(3,392,0),shift(16),reduce(0,288,0)]),action([range(12,13)],[reduce(3,392,0),shift(15),reduce(0,288,0)])]),state-rec(247,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],254),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),goto([434],3),goto([439],10),goto([437],6),goto([442],9),goto([272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5),g!
 oto([448],4),goto([472],3),goto([288],254)],[action([range(48,57),ra
(65,90),95,range(97,122),256],[reduce(0,288,0)]),action([47],[shift(19),reduce(0,288,0)]),action([range(9,10),32],[shift(18)]),action([42],[shift(17),reduce(0,288,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[shift(16),reduce(0,288,0)]),action([range(12,13)],[shift(15),reduce(0,288,0)])]),state-rec(248,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],255),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),goto([434],3),goto([439],10),goto([437],6),goto([442],9),goto([272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5),goto([448],4),goto([472],3),goto([288],255)],[action([range(48,57),range(65,90),95,range(97,122),256],[reduce(1,416,0),reduce(0,288,0)]),action([47],[reduce(0,288,0),shift(19),reduce(1,416,0)]),action!
 ([range(9,10),32],[shift(18),reduce(1,416,0)]),action([42],[reduce(0,288,0),shift(17),reduce(1,416,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[reduce(0,288,0),shift(16),reduce(1,416,0)]),action([range(12,13)],[reduce(0,288,0),shift(15),reduce(1,416,0)])]),state-rec(249,[],[action([range(0,47),range(58,64),range(91,94),96,range(123,256)],[reduce(9,393,0)])]),state-rec(250,[goto([114],256)],[action([114],[shift(256)])]),state-rec(251,[goto([114],257)],[action([114],[shift(257)])]),state-rec(252,[goto([97],258)],[action([97],[shift(258)])]),state-rec(253,[goto([60],126),goto([123],46),goto([91],45),goto([39,45,range(48,57),range(65,90),95,range(97,122)],44),goto([330],259),goto([383],245),goto([260],40),goto([384],245),goto([262],39),goto([449],245),goto([277],123),goto([450],245),goto([278],122),goto([451],245),goto([471],120),goto([469],33),goto([286],34),goto([470],33),goto([464],32),goto([362],30),goto([36!
 1],31),goto([363],30),goto([364],30),goto([366],30)],[action([60],[s
t(126)]),action([123],[shift(46)]),action([91],[shift(45)]),action([39,45,range(48,57),range(65,90),95,range(97,122)],[shift(44)])]),state-rec(254,[goto([60],126),goto([123],46),goto([91],45),goto([39,45,range(48,57),range(65,90),95,range(97,122)],44),goto([330],260),goto([383],245),goto([260],40),goto([384],245),goto([262],39),goto([449],245),goto([277],123),goto([450],245),goto([278],122),goto([451],245),goto([471],120),goto([469],33),goto([286],34),goto([470],33),goto([464],32),goto([362],30),goto([361],31),goto([363],30),goto([364],30),goto([366],30)],[action([60],[shift(126)]),action([123],[shift(46)]),action([91],[shift(45)]),action([39,45,range(48,57),range(65,90),95,range(97,122)],[shift(44)])]),state-rec(255,[goto([60],126),goto([123],46),goto([91],45),goto([39,45,range(48,57),range(65,90),95,range(97,122)],44),goto([320],263),goto([319],264),goto([321],263),goto([322],263),goto([323],263),goto([390],262),goto([383],261),goto([260],40),goto([384],261),goto([262],39)!
 ,goto([449],261),goto([277],123),goto([450],261),goto([278],122),goto([451],261),goto([471],120),goto([469],33),goto([286],34),goto([470],33),goto([464],32),goto([362],30),goto([361],31),goto([363],30),goto([364],30),goto([366],30)],[action([60],[shift(126)]),action([123],[shift(46)]),action([91],[shift(45)]),action([39,45,range(48,57),range(65,90),95,range(97,122)],[shift(44)])]),state-rec(256,[goto([111],265)],[action([111],[shift(265)])]),state-rec(257,[goto([116],266)],[action([116],[shift(266)])]),state-rec(258,[goto([114],267)],[action([114],[shift(267)])]),state-rec(259,[],[action([range(0,256)],[reduce(3,329,0)])]),state-rec(260,[],[action([range(0,256)],[reduce(3,327,0)])]),state-rec(261,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],268),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto(!
 [433],11),goto([434],3),goto([439],10),goto([437],6),goto([442],9),g
([272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5),goto([448],4),goto([472],3),goto([288],268)],[action([range(48,57),range(65,90),95,range(97,122),256],[reduce(0,288,0)]),action([47],[shift(19),reduce(0,288,0)]),action([range(9,10),32],[shift(18)]),action([42],[shift(17),reduce(0,288,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[shift(16),reduce(0,288,0)]),action([range(12,13)],[shift(15),reduce(0,288,0)])]),state-rec(262,[],[action([range(0,256)],[reduce(1,323,0)])]),state-rec(263,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],269),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),goto([434],3),goto([439],10),goto([437],6),goto([442],9),goto([272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5),g!
 oto([448],4),goto([472],3),goto([288],269)],[action([range(48,57),range(65,90),95,range(97,122)],[reduce(0,288,0)]),action([256],[reduce(0,288,0),reduce(3,391,0)]),action([47],[reduce(3,391,0),shift(19),reduce(0,288,0)]),action([range(9,10),32],[shift(18),reduce(3,391,0)]),action([42],[reduce(3,391,0),shift(17),reduce(0,288,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[reduce(3,391,0),shift(16),reduce(0,288,0)]),action([range(12,13)],[reduce(3,391,0),shift(15),reduce(0,288,0)])]),state-rec(264,[goto([47],19),goto([range(9,10),32],18),goto([42],17),goto([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],16),goto([range(12,13)],15),goto([287],270),goto([430],3),goto([404],12),goto([274],13),goto([405],12),goto([431],12),goto([433],11),goto([434],3),goto([439],10),goto([437],6),goto([442],9),goto([272],8),goto([438],6),goto([444],7),goto([440],6),goto([446],5),goto!
 ([448],4),goto([472],3),goto([288],270)],[action([range(48,57),range
,90),95,range(97,122),256],[reduce(0,288,0)]),action([47],[shift(19),reduce(0,288,0)]),action([range(9,10),32],[shift(18)]),action([42],[shift(17),reduce(0,288,0)]),action([range(0,8),11,range(14,31),range(33,41),range(43,46),range(58,64),range(91,94),96,range(123,255)],[shift(16),reduce(0,288,0)]),action([range(12,13)],[shift(15),reduce(0,288,0)])]),state-rec(265,[goto([100],271)],[action([100],[shift(271)])]),state-rec(266,[],[action([range(0,256)],[reduce(5,268,0)])]),state-rec(267,[],[action([range(0,256)],[reduce(7,269,0)])]),state-rec(268,[goto([45],119),goto([266],118),goto([414],118),goto([415],118)],[action([range(0,44),range(46,256)],[reduce(0,415,0)]),action([45],[shift(119),reduce(0,415,0)])]),state-rec(269,[goto([60],126),goto([123],46),goto([91],45),goto([39,45,range(48,57),range(65,90),95,range(97,122)],44),goto([323],272),goto([390],262),goto([383],261),goto([260],40),goto([384],261),goto([262],39),goto([449],261),goto([277],123),goto([450],261),goto([278],12!
 2),goto([451],261),goto([471],120),goto([469],33),goto([286],34),goto([470],33),goto([464],32),goto([362],30),goto([361],31),goto([363],30),goto([364],30),goto([366],30)],[action([60],[shift(126)]),action([123],[shift(46)]),action([91],[shift(45)]),action([39,45,range(48,57),range(65,90),95,range(97,122)],[shift(44)])]),state-rec(270,[goto([60],126),goto([123],46),goto([91],45),goto([39,45,range(48,57),range(65,90),95,range(97,122)],44),goto([323],273),goto([390],262),goto([383],261),goto([260],40),goto([384],261),goto([262],39),goto([449],261),goto([277],123),goto([450],261),goto([278],122),goto([451],261),goto([471],120),goto([469],33),goto([286],34),goto([470],33),goto([464],32),goto([362],30),goto([361],31),goto([363],30),goto([364],30),goto([366],30)],[action([60],[shift(126)]),action([123],[shift(46)]),action([91],[shift(45)]),action([39,45,range(48,57),range(65,90),95,range(97,122)],[shift(44)])]),state-rec(271,[goto([117],274)],[action([117],[shift(274)])]),state-re!
 c(272,[],[action([range(0,256)],[reduce(3,322,0)])]),state-rec(273,[
action([range(0,256)],[reduce(3,320,0)])]),state-rec(274,[goto([99],275)],[action([99],[shift(275)])]),state-rec(275,[goto([116],276)],[action([116],[shift(276)])]),state-rec(276,[goto([105],277)],[action([105],[shift(277)])]),state-rec(277,[goto([111],278)],[action([111],[shift(278)])]),state-rec(278,[goto([110],279)],[action([110],[shift(279)])]),state-rec(279,[goto([115],280)],[action([115],[shift(280)])]),state-rec(280,[],[action([range(0,256)],[reduce(11,267,0)])])]),priorities([arg-gtr-prio(294,4,294),arg-gtr-prio(294,4,291),arg-gtr-prio(294,4,289),arg-gtr-prio(294,4,290),arg-gtr-prio(292,4,292),arg-gtr-prio(292,4,291),arg-gtr-prio(292,4,289),arg-gtr-prio(292,4,290),arg-gtr-prio(293,4,289),arg-gtr-prio(293,4,290),arg-gtr-prio(301,4,301),arg-gtr-prio(301,4,298),arg-gtr-prio(301,4,296),arg-gtr-prio(301,4,297),arg-gtr-prio(299,4,299),arg-gtr-prio(299,4,298),arg-gtr-prio(299,4,296),arg-gtr-prio(299,4,297),arg-gtr-prio(300,4,296),arg-gtr-prio(300,4,297),arg-gtr-prio(308,2,3!
 08),arg-gtr-prio(308,2,305),arg-gtr-prio(308,2,303),arg-gtr-prio(308,2,304),arg-gtr-prio(306,2,306),arg-gtr-prio(306,2,305),arg-gtr-prio(306,2,303),arg-gtr-prio(306,2,304),arg-gtr-prio(307,2,303),arg-gtr-prio(307,2,304),arg-gtr-prio(315,4,315),arg-gtr-prio(315,4,312),arg-gtr-prio(315,4,310),arg-gtr-prio(315,4,311),arg-gtr-prio(313,4,313),arg-gtr-prio(313,4,312),arg-gtr-prio(313,4,310),arg-gtr-prio(313,4,311),arg-gtr-prio(314,4,310),arg-gtr-prio(314,4,311),arg-gtr-prio(322,2,322),arg-gtr-prio(322,2,319),arg-gtr-prio(322,2,317),arg-gtr-prio(322,2,318),arg-gtr-prio(320,2,320),arg-gtr-prio(320,2,319),arg-gtr-prio(320,2,317),arg-gtr-prio(320,2,318),arg-gtr-prio(321,2,317),arg-gtr-prio(321,2,318),arg-gtr-prio(329,2,329),arg-gtr-prio(329,2,326),arg-gtr-prio(329,2,324),arg-gtr-prio(329,2,325),arg-gtr-prio(327,2,327),arg-gtr-prio(327,2,326),arg-gtr-prio(327,2,324),arg-gtr-prio(327,2,325),arg-gtr-prio(328,2,324),arg-gtr-prio(328,2,325),arg-gtr-prio(337,1,337),arg-gtr-prio(337,1,334),!
 arg-gtr-prio(337,1,331),arg-gtr-prio(337,1,332),arg-gtr-prio(335,1,3
,arg-gtr-prio(335,1,334),arg-gtr-prio(335,1,331),arg-gtr-prio(335,1,332),arg-gtr-prio(336,1,331),arg-gtr-prio(336,1,332),arg-gtr-prio(346,1,346),arg-gtr-prio(346,1,343),arg-gtr-prio(346,1,340),arg-gtr-prio(346,1,341),arg-gtr-prio(344,1,344),arg-gtr-prio(344,1,343),arg-gtr-prio(344,1,340),arg-gtr-prio(344,1,341),arg-gtr-prio(345,1,340),arg-gtr-prio(345,1,341),arg-gtr-prio(355,1,355),arg-gtr-prio(355,1,352),arg-gtr-prio(355,1,349),arg-gtr-prio(355,1,350),arg-gtr-prio(353,1,353),arg-gtr-prio(353,1,352),arg-gtr-prio(353,1,349),arg-gtr-prio(353,1,350),arg-gtr-prio(354,1,349),arg-gtr-prio(354,1,350),arg-gtr-prio(364,1,364),arg-gtr-prio(364,1,361),arg-gtr-prio(364,1,358),arg-gtr-prio(364,1,359),arg-gtr-prio(362,1,362),arg-gtr-prio(362,1,361),arg-gtr-prio(362,1,358),arg-gtr-prio(362,1,359),arg-gtr-prio(363,1,358),arg-gtr-prio(363,1,359),arg-gtr-prio(373,1,373),arg-gtr-prio(373,1,370),arg-gtr-prio(373,1,367),arg-gtr-prio(373,1,368),arg-gtr-prio(371,1,371),arg-gtr-prio(371,1,370),arg-!
 gtr-prio(371,1,367),arg-gtr-prio(371,1,368),arg-gtr-prio(372,1,367),arg-gtr-prio(372,1,368),arg-gtr-prio(381,1,381),arg-gtr-prio(381,1,378),arg-gtr-prio(381,1,376),arg-gtr-prio(381,1,377),arg-gtr-prio(379,1,379),arg-gtr-prio(379,1,378),arg-gtr-prio(379,1,376),arg-gtr-prio(379,1,377),arg-gtr-prio(380,1,376),arg-gtr-prio(380,1,377),arg-gtr-prio(294,4,292),arg-gtr-prio(294,4,293),arg-gtr-prio(292,4,294),arg-gtr-prio(292,4,293),arg-gtr-prio(293,4,291),gtr-prio(291,289),gtr-prio(291,290),gtr-prio(292,289),gtr-prio(292,290),gtr-prio(293,289),gtr-prio(293,290),gtr-prio(294,289),gtr-prio(294,290),arg-gtr-prio(301,4,299),arg-gtr-prio(301,4,300),arg-gtr-prio(299,4,301),arg-gtr-prio(299,4,300),arg-gtr-prio(300,4,298),gtr-prio(298,296),gtr-prio(298,297),gtr-prio(299,296),gtr-prio(299,297),gtr-prio(300,296),gtr-prio(300,297),gtr-prio(301,296),gtr-prio(301,297),arg-gtr-prio(308,2,306),arg-gtr-prio(308,2,307),arg-gtr-prio(306,2,308),arg-gtr-prio(306,2,307),arg-gtr-prio(307,2,305),gtr-prio!
 (305,303),gtr-prio(305,304),gtr-prio(306,303),gtr-prio(306,304),gtr-
o(307,303),gtr-prio(307,304),gtr-prio(308,303),gtr-prio(308,304),arg-gtr-prio(315,4,313),arg-gtr-prio(315,4,314),arg-gtr-prio(313,4,315),arg-gtr-prio(313,4,314),arg-gtr-prio(314,4,312),gtr-prio(312,310),gtr-prio(312,311),gtr-prio(313,310),gtr-prio(313,311),gtr-prio(314,310),gtr-prio(314,311),gtr-prio(315,310),gtr-prio(315,311),arg-gtr-prio(322,2,320),arg-gtr-prio(322,2,321),arg-gtr-prio(320,2,322),arg-gtr-prio(320,2,321),arg-gtr-prio(321,2,319),gtr-prio(319,317),gtr-prio(319,318),gtr-prio(320,317),gtr-prio(320,318),gtr-prio(321,317),gtr-prio(321,318),gtr-prio(322,317),gtr-prio(322,318),arg-gtr-prio(329,2,327),arg-gtr-prio(329,2,328),arg-gtr-prio(327,2,329),arg-gtr-prio(327,2,328),arg-gtr-prio(328,2,326),gtr-prio(326,324),gtr-prio(326,325),gtr-prio(327,324),gtr-prio(327,325),gtr-prio(328,324),gtr-prio(328,325),gtr-prio(329,324),gtr-prio(329,325),arg-gtr-prio(337,1,335),arg-gtr-prio(337,1,336),arg-gtr-prio(335,1,337),arg-gtr-prio(335,1,336),arg-gtr-prio(336,1,334),gtr-prio(334!
 ,331),gtr-prio(334,332),gtr-prio(335,331),gtr-prio(335,332),gtr-prio(336,331),gtr-prio(336,332),gtr-prio(337,331),gtr-prio(337,332),arg-gtr-prio(346,1,344),arg-gtr-prio(346,1,345),arg-gtr-prio(344,1,346),arg-gtr-prio(344,1,345),arg-gtr-prio(345,1,343),gtr-prio(343,340),gtr-prio(343,341),gtr-prio(344,340),gtr-prio(344,341),gtr-prio(345,340),gtr-prio(345,341),gtr-prio(346,340),gtr-prio(346,341),arg-gtr-prio(355,1,353),arg-gtr-prio(355,1,354),arg-gtr-prio(353,1,355),arg-gtr-prio(353,1,354),arg-gtr-prio(354,1,352),gtr-prio(352,349),gtr-prio(352,350),gtr-prio(353,349),gtr-prio(353,350),gtr-prio(354,349),gtr-prio(354,350),gtr-prio(355,349),gtr-prio(355,350),arg-gtr-prio(364,1,362),arg-gtr-prio(364,1,363),arg-gtr-prio(362,1,364),arg-gtr-prio(362,1,363),arg-gtr-prio(363,1,361),gtr-prio(361,358),gtr-prio(361,359),gtr-prio(362,358),gtr-prio(362,359),gtr-prio(363,358),gtr-prio(363,359),gtr-prio(364,358),gtr-prio(364,359),arg-gtr-prio(373,1,371),arg-gtr-prio(373,1,372),arg-gtr-prio(371!
 ,1,373),arg-gtr-prio(371,1,372),arg-gtr-prio(372,1,370),gtr-prio(370
7),gtr-prio(370,368),gtr-prio(371,367),gtr-prio(371,368),gtr-prio(372,367),gtr-prio(372,368),gtr-prio(373,367),gtr-prio(373,368),arg-gtr-prio(381,1,379),arg-gtr-prio(381,1,380),arg-gtr-prio(379,1,381),arg-gtr-prio(379,1,380),arg-gtr-prio(380,1,378),gtr-prio(378,376),gtr-prio(378,377),gtr-prio(379,376),gtr-prio(379,377),gtr-prio(380,376),gtr-prio(380,377),gtr-prio(381,376),gtr-prio(381,377),arg-gtr-prio(294,4,294),arg-gtr-prio(294,4,294),arg-gtr-prio(294,4,294),arg-gtr-prio(291,4,291),arg-gtr-prio(291,4,291),arg-gtr-prio(291,4,291),arg-gtr-prio(294,4,294),arg-gtr-prio(294,4,294),arg-gtr-prio(301,4,301),arg-gtr-prio(301,4,301),arg-gtr-prio(301,4,301),arg-gtr-prio(298,4,298),arg-gtr-prio(298,4,298),arg-gtr-prio(298,4,298),arg-gtr-prio(301,4,301),arg-gtr-prio(301,4,301),arg-gtr-prio(308,2,308),arg-gtr-prio(308,2,308),arg-gtr-prio(308,2,308),arg-gtr-prio(305,2,305),arg-gtr-prio(305,2,305),arg-gtr-prio(305,2,305),arg-gtr-prio(308,2,308),arg-gtr-prio(308,2,308),arg-gtr-prio(315,4,3!
 15),arg-gtr-prio(315,4,315),arg-gtr-prio(315,4,315),arg-gtr-prio(312,4,312),arg-gtr-prio(312,4,312),arg-gtr-prio(312,4,312),arg-gtr-prio(315,4,315),arg-gtr-prio(315,4,315),arg-gtr-prio(322,2,322),arg-gtr-prio(322,2,322),arg-gtr-prio(322,2,322),arg-gtr-prio(319,2,319),arg-gtr-prio(319,2,319),arg-gtr-prio(319,2,319),arg-gtr-prio(322,2,322),arg-gtr-prio(322,2,322),arg-gtr-prio(329,2,329),arg-gtr-prio(329,2,329),arg-gtr-prio(329,2,329),arg-gtr-prio(326,2,326),arg-gtr-prio(326,2,326),arg-gtr-prio(326,2,326),arg-gtr-prio(329,2,329),arg-gtr-prio(329,2,329),arg-gtr-prio(337,1,337),arg-gtr-prio(337,1,337),arg-gtr-prio(337,1,337),arg-gtr-prio(334,1,334),arg-gtr-prio(334,1,334),arg-gtr-prio(334,1,334),arg-gtr-prio(337,1,337),arg-gtr-prio(337,1,337),arg-gtr-prio(346,1,346),arg-gtr-prio(346,1,346),arg-gtr-prio(346,1,346),arg-gtr-prio(343,1,343),arg-gtr-prio(343,1,343),arg-gtr-prio(343,1,343),arg-gtr-prio(346,1,346),arg-gtr-prio(346,1,346),arg-gtr-prio(355,1,355),arg-gtr-prio(355,1,355),!
 arg-gtr-prio(355,1,355),arg-gtr-prio(352,1,352),arg-gtr-prio(352,1,3
,arg-gtr-prio(352,1,352),arg-gtr-prio(355,1,355),arg-gtr-prio(355,1,355),arg-gtr-prio(364,1,364),arg-gtr-prio(364,1,364),arg-gtr-prio(364,1,364),arg-gtr-prio(361,1,361),arg-gtr-prio(361,1,361),arg-gtr-prio(361,1,361),arg-gtr-prio(364,1,364),arg-gtr-prio(364,1,364),arg-gtr-prio(373,1,373),arg-gtr-prio(373,1,373),arg-gtr-prio(373,1,373),arg-gtr-prio(370,1,370),arg-gtr-prio(370,1,370),arg-gtr-prio(370,1,370),arg-gtr-prio(373,1,373),arg-gtr-prio(373,1,373),arg-gtr-prio(381,1,381),arg-gtr-prio(381,1,381),arg-gtr-prio(381,1,381),arg-gtr-prio(378,1,378),arg-gtr-prio(378,1,378),arg-gtr-prio(378,1,378),arg-gtr-prio(381,1,381),arg-gtr-prio(381,1,381),arg-gtr-prio(472,1,472)]))

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/build.generated.xml
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/build.generated.xml	Thu Dec  9 14:12:16 2010	(r21487)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/build.generated.xml	Thu Dec  9 15:04:14 2010	(r21488)
@@ -3,8 +3,8 @@
 <project name="build.generated">
 
         <target name="spoofaximp.default" depends="spoofaximp.default.ctree"/>
-        <target name="spoofaximp.default.ctree" depends="check-classpath,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.ctree,java.jar,sdf2imp,refresh"/>
-        <target name="spoofaximp.default.jar" depends="check-classpath,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.jar,  java.jar,sdf2imp,refresh"/>
+        <target name="spoofaximp.default.ctree" depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.ctree,java.jar,sdf2imp,refresh"/>
+        <target name="spoofaximp.default.jar" depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.jar,  java.jar,sdf2imp,refresh"/>
     
         <!-- Initialization -->
         <available file="${build}/org/strategoxt/imp/editors/spoofax/strategies/Main.class" property="java.jar.enabled"/>
@@ -50,9 +50,11 @@
         
         <target name="refresh" if="eclipse.running">
             <eclipse.convertPath fileSystemPath="${basedir}" property="projectdir"/>
-            <eclipse.refreshLocal resource="${projectdir}/lib" depth="infinite"/>
-            <eclipse.refreshLocal resource="${projectdir}/syntax/${sdfmodule}.pp.generated" depth="infinite"/>
-            <eclipse.refreshLocal resource="${projectdir}/lib/editor-common.generated.str" depth="infinite"/>
+            <eclipse.convertPath fileSystemPath="${syntax}" property="syntaxdir"/>
+            <eclipse.convertPath fileSystemPath="${lib}" property="libdir"/>
+            <eclipse.refreshLocal resource="${libdir}" depth="infinite"/>
+            <eclipse.refreshLocal resource="${syntaxdir}/${sdfmodule}.pp.generated" depth="infinite"/>
+            <eclipse.refreshLocal resource="${libdir}/editor-common.generated.str" depth="infinite"/>
             <eclipse.refreshLocal resource="${projectdir}/build.generated.xml" depth="infinite"/>
             <eclipse.refreshLocal resource="${projectdir}/editor/${sdfmodule}-Builders.generated.esv" depth="infinite"/>
             <eclipse.refreshLocal resource="${projectdir}/editor/${sdfmodule}-Colorer.generated.esv" depth="infinite"/>
@@ -82,6 +84,13 @@
             <available classname="org.strategoxt.imp.generator.sdf2imp" property="check-classpath.available"/>
             <antcall target="check-classpath.helper"/>  
         </target>
+        
+        <target name="init" if="eclipse.running">
+            <!-- refresh one file/dir in the project to trigger an Ant rebuild with the next build command -->
+            <java classname="org.strategoxt.imp.metatooling.building.AntForceRefreshScheduler" failonerror="false">
+                <arg value="${include}"/>
+            </java>
+        </target>
   
         <target name="check-classpath.helper" unless="check-classpath.available">
             <echo level="error" message="Could not load the Spoofax plugin loading classes."/>
@@ -151,9 +160,12 @@
     
         <target name="pack-sdf" unless="externaldef">
             <dependset>
-                <srcfileset dir="${syntax}">
+                <srcfileset dir="${basedir}">
                     <include name="**/*.sdf"/>
                 </srcfileset>
+                <srcfileset dir="${lib}">
+                    <include name="**/*.def"/>
+                </srcfileset>
                 <targetfileset file="${include}/${sdfmodule}.def"/>
             </dependset>
             <available file="${include}/${sdfmodule}.def" property="pack-sdf.available"/>

From L.C.L.Kats at tudelft.nl  Thu Dec  9 17:47:31 2010
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Thu, 09 Dec 2010 16:47:31 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21489 - in
	spoofax-imp/trunk: org.strategoxt.imp.feature
	org.strategoxt.imp.updatesite
Message-ID: <201012091647.oB9GlVMB012153@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: Thu Dec  9 16:47:31 2010
New Revision: 21489
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21489&sc=1

Log:
Release 0.6.0: changing the versioning scheme ... again!

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.feature/feature.xml
   spoofax-imp/trunk/org.strategoxt.imp.updatesite/site.xml

Modified: spoofax-imp/trunk/org.strategoxt.imp.feature/feature.xml
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.feature/feature.xml	Thu Dec  9 15:04:14 2010	(r21488)
+++ spoofax-imp/trunk/org.strategoxt.imp.feature/feature.xml	Thu Dec  9 16:47:31 2010	(r21489)
@@ -2,7 +2,7 @@
 <feature
       id="org.strategoxt.imp"
       label="Spoofax/IMP"
-      version="0.60.0.qualifier"
+      version="0.6.0.0"
       plugin="org.strategoxt.imp.runtime">
 
    <description url="http://strategoxt.org/Stratego/Spoofax-IMP">

Modified: spoofax-imp/trunk/org.strategoxt.imp.updatesite/site.xml
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.updatesite/site.xml	Thu Dec  9 15:04:14 2010	(r21488)
+++ spoofax-imp/trunk/org.strategoxt.imp.updatesite/site.xml	Thu Dec  9 16:47:31 2010	(r21489)
@@ -3,7 +3,7 @@
    <description name="Spoofax/IMP" url="http://www.lclnet.nl/update/">
       Spoofax/IMP update site
    </description>
-   <feature url="features/org.strategoxt.imp_0.60.0.201012091355.jar" id="org.strategoxt.imp" version="0.60.0.201012091355">
+   <feature url="features/org.strategoxt.imp_0.6.0.0.jar" id="org.strategoxt.imp" version="0.6.0.0">
       <category name="Spoofax/IMP"/>
    </feature>
    <category-def name="Spoofax/IMP" label="Spoofax/IMP">

From L.C.L.Kats at tudelft.nl  Fri Dec 10 10:23:10 2010
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Fri, 10 Dec 2010 09:23:10 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21490 -
	strategoxt/trunk/strc-core/lib/stratego/strc/parse
Message-ID: <201012100923.oBA9NA7m024844@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: Fri Dec 10 09:23:10 2010
New Revision: 21490
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21490&sc=1

Log:
Changed cache names to distinguish them from signature file generated by Spoofax.

Modified:
   strategoxt/trunk/strc-core/lib/stratego/strc/parse/parse-stratego.str

Modified: strategoxt/trunk/strc-core/lib/stratego/strc/parse/parse-stratego.str
==============================================================================
--- strategoxt/trunk/strc-core/lib/stratego/strc/parse/parse-stratego.str	Thu Dec  9 16:47:31 2010	(r21489)
+++ strategoxt/trunk/strc-core/lib/stratego/strc/parse/parse-stratego.str	Fri Dec 10 09:23:10 2010	(r21490)
@@ -232,7 +232,7 @@
     with
       cache-dir  := <get-config> "--cache-dir";
       full-path' := <string-replace(|"/", "+"); string-replace(|"\\", "+"); string-replace(|":", "+")> full-path;
-      cache-path := $[[cache-dir]/[full-path'].sig]
+      cache-path := $[[cache-dir]/[full-path'].cache]
 
 /**
  * Main parsing strategies.

From g.h.wachsmuth at tudelft.nl  Fri Dec 10 14:34:16 2010
From: g.h.wachsmuth at tudelft.nl (Guido Wachsmuth)
Date: Fri, 10 Dec 2010 13:34:16 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21491 -
	jasmin-spoofax/test
Message-ID: <201012101334.oBADYGTB029178@proliant.st.ewi.tudelft.nl>

Author: GuidoWachsmuth
Date: Fri Dec 10 13:34:15 2010
New Revision: 21491
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21491&sc=1

Log:
removed bug from hello world example

Modified:
   jasmin-spoofax/test/HelloWorld.j

Modified: jasmin-spoofax/test/HelloWorld.j
==============================================================================
--- jasmin-spoofax/test/HelloWorld.j	Fri Dec 10 09:23:10 2010	(r21490)
+++ jasmin-spoofax/test/HelloWorld.j	Fri Dec 10 13:34:15 2010	(r21491)
@@ -24,7 +24,6 @@
 
        ; call the PrintStream.println() method.
        invokevirtual java/io/PrintStream/println(I)V
-	   new HelloWorld
 	   
        ; done
        return

From L.C.L.Kats at tudelft.nl  Fri Dec 10 15:55:13 2010
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Fri, 10 Dec 2010 14:55:13 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21492 -
	spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services
Message-ID: <201012101455.oBAEtDiI030210@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: Fri Dec 10 14:55:12 2010
New Revision: 21492
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21492&sc=1

Log:
Spoofax/315: "Apply custom rule" builder should update its result in realtime

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/CustomStrategyBuilder.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/IBuilder.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoBuilder.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoBuilderListener.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/CustomStrategyBuilder.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/CustomStrategyBuilder.java	Fri Dec 10 13:34:15 2010	(r21491)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/CustomStrategyBuilder.java	Fri Dec 10 14:55:12 2010	(r21492)
@@ -34,6 +34,8 @@
 	private static final Map<String, String> initialValues =
 		synchronizedMap(new HashMap<String, String>());
 	
+	private String inputtedBuilderRule;
+	
 	public CustomStrategyBuilder(StrategoObserver observer, EditorState derivedFromEditor) {
 		// TODO: reconsider source = true here?
 		super(observer, "Apply custom rule...", null, true, true, false, true, false, derivedFromEditor);
@@ -52,7 +54,19 @@
 		}
 	}
 	
+	@Override
+	public Object getData() {
+		return inputtedBuilderRule;
+	}
+	
+	@Override
+	public void setData(Object data) {
+		inputtedBuilderRule = (String) data;
+	}
+	
 	private String inputBuilderRule(EditorState editor) {
+		if (inputtedBuilderRule != null)
+			return inputtedBuilderRule;
 		IInputValidator validator = 
 			new IInputValidator() {
 				public String isValid(String name) {
@@ -67,7 +81,7 @@
 			InputDialog dialog = new InputDialog(null, "Apply custom rule", "Enter the name of the rewrite rule or strategy to apply", getInitialValue(editor), validator);
 			if (dialog.open() == InputDialog.OK) {
 				setInitialValue(editor, dialog.getValue());
-				return dialog.getValue();
+				return inputtedBuilderRule = dialog.getValue();
 			} else {
 				return null;
 			}

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/IBuilder.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/IBuilder.java	Fri Dec 10 13:34:15 2010	(r21491)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/IBuilder.java	Fri Dec 10 14:55:12 2010	(r21492)
@@ -13,4 +13,8 @@
 	String getCaption();
 	
 	Job scheduleExecute(EditorState editor, IStrategoAstNode ast, IFile errorReportFile, boolean isRebuild);
+
+	Object getData();
+	
+	void setData(Object data);
 }

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoBuilder.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoBuilder.java	Fri Dec 10 13:34:15 2010	(r21491)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoBuilder.java	Fri Dec 10 14:55:12 2010	(r21492)
@@ -50,8 +50,6 @@
 import org.strategoxt.stratego_aterm.aterm_escape_strings_0_0;
 import org.strategoxt.stratego_aterm.pp_aterm_box_0_0;
 import org.strategoxt.stratego_gpp.box2text_string_0_1;
-import org.strategoxt.stratego_lib.concat_strings_0_0;
-import org.strategoxt.stratego_lib.try_1_0;
 
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
@@ -105,6 +103,15 @@
 		return caption;
 	}
 	
+	public Object getData() {
+		// Data not used for normal builders
+		return null;
+	}
+	
+	public void setData(Object data) {
+		// Data not used for normal builders
+	}
+	
 	public String getBuilderRule() {
 		return builderRule;
 	}
@@ -277,7 +284,7 @@
 					// if (!persistent) new File(file.getLocationURI()).delete();
 					// Create a listene *and* editor-derived editor relation
 					StrategoBuilderListener listener = 
-						StrategoBuilderListener.addListener(editor.getEditor(), target, file, getCaption(), node);
+						StrategoBuilderListener.addListener(editor.getEditor(), target, file, StrategoBuilder.this, node);
 					if (!realTime || editor == target || derivedFromEditor != null)
 						listener.setEnabled(false);
 					if (derivedFromEditor != null) // ensure we get builders from the source

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoBuilderListener.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoBuilderListener.java	Fri Dec 10 13:34:15 2010	(r21491)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoBuilderListener.java	Fri Dec 10 14:55:12 2010	(r21492)
@@ -27,7 +27,9 @@
 	private static final WeakWeakMap<IEditorPart, StrategoBuilderListener> asyncListeners =
 		new WeakWeakMap<IEditorPart, StrategoBuilderListener>();
 	
-	private final String builder;
+	private final String builderName;
+
+	private final Object builderData;
 	
 	private WeakReference<UniversalEditor> editor;
 	
@@ -42,17 +44,18 @@
 	private boolean enabled = true;
 	
 	private StrategoBuilderListener(UniversalEditor editor, IEditorPart targetEditor, IFile targetFile,
-			String builder, IStrategoAstNode selection) {
+			IBuilder builder, IStrategoAstNode selection) {
 		
 		this.editor = new WeakReference<UniversalEditor>(editor);
 		this.targetEditor = new WeakReference<IEditorPart>(targetEditor);
-		this.builder = builder;
+		this.builderName = builder.getCaption();
+		this.builderData = builder.getData();
 		this.targetFile = targetFile;
 		this.lastChanged = targetFile.getLocalTimeStamp();
 		this.selection = selection;
 	}
 
-	public static StrategoBuilderListener addListener(UniversalEditor editor, IEditorPart target, IFile file, String builder, IStrategoAstNode node) {
+	public static StrategoBuilderListener addListener(UniversalEditor editor, IEditorPart target, IFile file, IBuilder builder, IStrategoAstNode node) {
 		synchronized (asyncListeners) {
 			StrategoBuilderListener listener = asyncListeners.get(editor);
 			if (listener != null) listener.setEnabled(false);
@@ -122,9 +125,10 @@
 		
 		try {
 			IBuilderMap builders = editor.getDescriptor().createService(IBuilderMap.class, editor.getParseController());
-			IBuilder builder = builders.get(this.builder);
+			IBuilder builder = builders.get(this.builderName);
 			if (builder == null)
-			    throw new RuntimeException("No builder exists with this name: " + this.builder);
+			    throw new RuntimeException("No builder exists with this name: " + this.builderName);
+			builder.setData(builderData);
 			
 			IStrategoAstNode newSelection = findNewSelection(editor);
 			Job job;

From L.C.L.Kats at tudelft.nl  Fri Dec 10 16:47:16 2010
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Fri, 10 Dec 2010 15:47:16 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21493 -
	spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services
Message-ID: <201012101547.oBAFlGEc031005@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: Fri Dec 10 15:47:16 2010
New Revision: 21493
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21493&sc=1

Log:
Spoofax/316: NullPointerException in StrategoBuilderListener

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoBuilderListener.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoBuilderListener.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoBuilderListener.java	Fri Dec 10 14:55:12 2010	(r21492)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoBuilderListener.java	Fri Dec 10 15:47:16 2010	(r21493)
@@ -137,7 +137,8 @@
 			} else {
 				job = builder.scheduleExecute(editor, editor.getParseController().getCurrentAst(), targetFile, true);
 			}
-			job.join(); // wait to get new time stamp
+			if (job != null)
+				job.join(); // wait to get new time stamp
 
 		} catch (BadDescriptorException e) {
 			Environment.logException("Could not update derived editor for " + editor.getResource(), e);

From g.h.wachsmuth at tudelft.nl  Fri Dec 10 20:13:44 2010
From: g.h.wachsmuth at tudelft.nl (Guido Wachsmuth)
Date: Fri, 10 Dec 2010 19:13:44 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21494 - in
	jasmin-spoofax: editor lib trans
Message-ID: <201012101913.oBAJDiHo001760@proliant.st.ewi.tudelft.nl>

Author: GuidoWachsmuth
Date: Fri Dec 10 19:13:44 2010
New Revision: 21494
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21494&sc=1

Log:
support for class file generation and execution

Added:
   jasmin-spoofax/lib/jasmin.jar   (contents, props changed)
Modified:
   jasmin-spoofax/editor/JasminXT-Builders.esv
   jasmin-spoofax/trans/jasminxt.str

Modified: jasmin-spoofax/editor/JasminXT-Builders.esv
==============================================================================
--- jasmin-spoofax/editor/JasminXT-Builders.esv	Fri Dec 10 15:47:16 2010	(r21493)
+++ jasmin-spoofax/editor/JasminXT-Builders.esv	Fri Dec 10 19:13:44 2010	(r21494)
@@ -16,4 +16,8 @@
   observer                  : editor-analyse                                                                                   
                                                                                                                                
   builder                   : "Show abstract syntax (for selection)" = generate-aterm (openeditor) (realtime) (meta) (source)  
+  
+  builder                   : "Generate class file" = generate-class (source)  
+  
+  builder                   : "Execute" = execute-class (source)  
                                                                                                                                
\ No newline at end of file

Added: jasmin-spoofax/lib/jasmin.jar
==============================================================================
Binary file. No diff available.

Modified: jasmin-spoofax/trans/jasminxt.str
==============================================================================
--- jasmin-spoofax/trans/jasminxt.str	Fri Dec 10 15:47:16 2010	(r21493)
+++ jasmin-spoofax/trans/jasminxt.str	Fri Dec 10 19:13:44 2010	(r21494)
@@ -27,4 +27,21 @@
     (selected, position, ast, path, project-path) -> (filename, result)
     with
       filename := <guarantee-extension(|"aterm")> path;
-      result   := selected // we just return the input term
\ No newline at end of file
+      result   := selected // we just return the input term
+      
+  // Generates the Java class file
+  generate-class:
+    (selected, position, ast, path, project-path) -> None()
+    with
+      parentdir := <dirname> path ;
+      <try(call)> ("java", ["-jar", $[[<project-path>]/lib/jasmin.jar], path, "-d", parentdir])
+    where
+      cfname := <guarantee-extension(|"class")> path ;
+      <refresh-workspace-file> cfname
+      
+  execute-class:
+  	(selected, position, ast, path, project-path) -> None()
+    with
+      cname := <base-filename ; remove-extension> path;
+      parentdir := <dirname> path ;
+      <try(call)> ("java", ["-cp", parentdir, cname])
\ No newline at end of file

From L.C.L.Kats at tudelft.nl  Sat Dec 11 16:42:02 2010
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Sat, 11 Dec 2010 15:42:02 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21495 - in
	spoofax-imp/trunk: org.strategoxt.imp.editors.stratego
	org.strategoxt.imp.feature
	org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services
	org.strateg...
Message-ID: <201012111542.oBBFg2q2016525@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: Sat Dec 11 15:42:01 2010
New Revision: 21495
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21495&sc=1

Log:
Release 0.6.0.1 (Spoofax/315 fix is relevant for the lab)

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/build.generated.xml
   spoofax-imp/trunk/org.strategoxt.imp.feature/feature.xml
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoBuilderListener.java
   spoofax-imp/trunk/org.strategoxt.imp.updatesite/site.xml

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/build.generated.xml
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/build.generated.xml	Fri Dec 10 19:13:44 2010	(r21494)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/build.generated.xml	Sat Dec 11 15:42:01 2010	(r21495)
@@ -3,8 +3,8 @@
 <project name="build.generated">
 
         <target name="spoofaximp.default" depends="spoofaximp.default.ctree"/>
-        <target name="spoofaximp.default.ctree" depends="check-classpath,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.ctree,java.jar,sdf2imp,refresh"/>
-        <target name="spoofaximp.default.jar" depends="check-classpath,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.jar,  java.jar,sdf2imp,refresh"/>
+        <target name="spoofaximp.default.ctree" depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.ctree,java.jar,sdf2imp,refresh"/>
+        <target name="spoofaximp.default.jar" depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.jar,  java.jar,sdf2imp,refresh"/>
     
         <!-- Initialization -->
         <available file="${build}/org/strategoxt/imp/editors/stratego/strategies/Main.class" property="java.jar.enabled"/>
@@ -84,6 +84,13 @@
             <available classname="org.strategoxt.imp.generator.sdf2imp" property="check-classpath.available"/>
             <antcall target="check-classpath.helper"/>  
         </target>
+        
+        <target name="init" if="eclipse.running">
+            <!-- refresh one file/dir in the project to trigger an Ant rebuild with the next build command -->
+            <java classname="org.strategoxt.imp.metatooling.building.AntForceRefreshScheduler" failonerror="false">
+                <arg value="${include}"/>
+            </java>
+        </target>
   
         <target name="check-classpath.helper" unless="check-classpath.available">
             <echo level="error" message="Could not load the Spoofax plugin loading classes."/>

Modified: spoofax-imp/trunk/org.strategoxt.imp.feature/feature.xml
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.feature/feature.xml	Fri Dec 10 19:13:44 2010	(r21494)
+++ spoofax-imp/trunk/org.strategoxt.imp.feature/feature.xml	Sat Dec 11 15:42:01 2010	(r21495)
@@ -2,7 +2,7 @@
 <feature
       id="org.strategoxt.imp"
       label="Spoofax/IMP"
-      version="0.6.0.0"
+      version="0.6.0.1"
       plugin="org.strategoxt.imp.runtime">
 
    <description url="http://strategoxt.org/Stratego/Spoofax-IMP">

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoBuilderListener.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoBuilderListener.java	Fri Dec 10 19:13:44 2010	(r21494)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoBuilderListener.java	Sat Dec 11 15:42:01 2010	(r21495)
@@ -137,8 +137,11 @@
 			} else {
 				job = builder.scheduleExecute(editor, editor.getParseController().getCurrentAst(), targetFile, true);
 			}
-			if (job != null)
+			if (job == null) {
+				enabled = false;
+			} else {
 				job.join(); // wait to get new time stamp
+			}
 
 		} catch (BadDescriptorException e) {
 			Environment.logException("Could not update derived editor for " + editor.getResource(), e);

Modified: spoofax-imp/trunk/org.strategoxt.imp.updatesite/site.xml
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.updatesite/site.xml	Fri Dec 10 19:13:44 2010	(r21494)
+++ spoofax-imp/trunk/org.strategoxt.imp.updatesite/site.xml	Sat Dec 11 15:42:01 2010	(r21495)
@@ -3,7 +3,7 @@
    <description name="Spoofax/IMP" url="http://www.lclnet.nl/update/">
       Spoofax/IMP update site
    </description>
-   <feature url="features/org.strategoxt.imp_0.6.0.0.jar" id="org.strategoxt.imp" version="0.6.0.0">
+   <feature url="features/org.strategoxt.imp_0.6.0.1.jar" id="org.strategoxt.imp" version="0.6.0.1">
       <category name="Spoofax/IMP"/>
    </feature>
    <category-def name="Spoofax/IMP" label="Spoofax/IMP">

From R.B.Vermaas at tudelft.nl  Tue Dec 14 10:06:08 2010
From: R.B.Vermaas at tudelft.nl (Rob Vermaas)
Date: Tue, 14 Dec 2010 09:06:08 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21496 -
	spoofax-imp/trunk/org.strategoxt.imp.testing
Message-ID: <201012140906.oBE968Uk006822@proliant.st.ewi.tudelft.nl>

Author: rob
Date: Tue Dec 14 09:06:07 2010
New Revision: 21496
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21496&sc=1

Log:
spoofax testing plugin (for parse-unit integration, etc)

Added:
   spoofax-imp/trunk/org.strategoxt.imp.testing/

From R.B.Vermaas at tudelft.nl  Tue Dec 14 10:07:02 2010
From: R.B.Vermaas at tudelft.nl (Rob Vermaas)
Date: Tue, 14 Dec 2010 09:07:02 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21497 - in
	spoofax-imp/trunk/org.strategoxt.imp.testing: .
	.externalToolBuilders .settings META-INF editor editor/java
	editor/java/org editor/java/org/strategoxt editor/ja...
Message-ID: <201012140907.oBE972N6006835@proliant.st.ewi.tudelft.nl>

Author: rob
Date: Tue Dec 14 09:07:02 2010
New Revision: 21497
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21497&sc=1

Log:
initial import

Added:
   spoofax-imp/trunk/org.strategoxt.imp.testing/.classpath
   spoofax-imp/trunk/org.strategoxt.imp.testing/.externalToolBuilders/
   spoofax-imp/trunk/org.strategoxt.imp.testing/.externalToolBuilders/Spoofax-Testing build.main.xml.launch
   spoofax-imp/trunk/org.strategoxt.imp.testing/.project
   spoofax-imp/trunk/org.strategoxt.imp.testing/.settings/
   spoofax-imp/trunk/org.strategoxt.imp.testing/.settings/org.eclipse.jdt.core.prefs
   spoofax-imp/trunk/org.strategoxt.imp.testing/META-INF/
   spoofax-imp/trunk/org.strategoxt.imp.testing/META-INF/MANIFEST.MF
   spoofax-imp/trunk/org.strategoxt.imp.testing/build.generated.xml
   spoofax-imp/trunk/org.strategoxt.imp.testing/build.main.xml
   spoofax-imp/trunk/org.strategoxt.imp.testing/build.properties
   spoofax-imp/trunk/org.strategoxt.imp.testing/editor/
   spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Builders.esv
   spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Colorer.esv
   spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Completions.esv
   spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Folding.esv
   spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Outliner.esv
   spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-References.esv
   spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Syntax.esv
   spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing.main.esv
   spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/
   spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/
   spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/
   spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/
   spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/
   spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/Activator.java
   spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/SpoofaxTestingParseController.java
   spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/SpoofaxTestingParseControllerGenerated.java
   spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/SpoofaxTestingValidator.java
   spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/strategies/
   spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/strategies/InteropRegisterer.java
   spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/strategies/Main.java
   spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/strategies/java_strategy_0_0.java
   spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/strategies/open_editor_0_0.java
   spoofax-imp/trunk/org.strategoxt.imp.testing/include/
   spoofax-imp/trunk/org.strategoxt.imp.testing/lib/
   spoofax-imp/trunk/org.strategoxt.imp.testing/lib/editor-common.generated.str
   spoofax-imp/trunk/org.strategoxt.imp.testing/plugin.xml
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Common.sdf
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/RegExp.aterm
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/RegExp.sdf
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing-String-Quotation.sdf
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing.aterm
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing.generated.pp
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing.pp
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing.sdf
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/ASCII.sdf
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Areas.sdf
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/BoolCon.sdf
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/BytesCon.sdf
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Colors.sdf
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Comments.sdf
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Configuration.sdf
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Errors.sdf
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/File.sdf
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Graphs.sdf
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/IdentifierCon.sdf
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/IntCon.sdf
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Keys.sdf
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Locations.sdf
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Modules.sdf
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/NatCon.sdf
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/ParsetreeCon.sdf
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Path.sdf
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/RStores.sdf
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/ReadWriteCon.sdf
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Shortcut.sdf
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Slices.sdf
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/StrCon.sdf
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Whitespace.sdf
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/languages/
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/languages/aterm/
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/languages/aterm/syntax/
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/languages/aterm/syntax/ATerms.sdf
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/languages/aterm/syntax/IntCon.sdf
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/languages/aterm/syntax/RealCon.sdf
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/test.aterm
   spoofax-imp/trunk/org.strategoxt.imp.testing/test/
   spoofax-imp/trunk/org.strategoxt.imp.testing/test/asd.aterm
   spoofax-imp/trunk/org.strategoxt.imp.testing/test/asd2.aterm
   spoofax-imp/trunk/org.strategoxt.imp.testing/test/asd3.aterm
   spoofax-imp/trunk/org.strategoxt.imp.testing/test/example2.aterm
   spoofax-imp/trunk/org.strategoxt.imp.testing/test/example2.spt
   spoofax-imp/trunk/org.strategoxt.imp.testing/test/test.aterm
   spoofax-imp/trunk/org.strategoxt.imp.testing/test/test.java
   spoofax-imp/trunk/org.strategoxt.imp.testing/test/test.spt
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/ATerms.str
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/analysis.str
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/aterm-eq.str
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check.str
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/file-resolving.str
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/generate.str
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/spoofax_testing.str
   spoofax-imp/trunk/org.strategoxt.imp.testing/utils/

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/.classpath
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/.classpath	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+
+<classpath>
+	<classpathentry kind="src" excluding="trans/**" path="editor/java"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/J2SE-1.5"/>
+	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
+        <classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
+        <classpathentry kind="lib" path="include/spoofax_testing.jar"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/.externalToolBuilders/Spoofax-Testing build.main.xml.launch
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/.externalToolBuilders/Spoofax-Testing build.main.xml.launch	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<launchConfiguration type="org.eclipse.ant.AntLaunchConfigurationType">
+<stringAttribute key="bad_container_name" value=".externalToolBuilders"/>
+<booleanAttribute key="org.eclipse.ant.ui.DEFAULT_VM_INSTALL" value="false"/>
+<listAttribute key="org.eclipse.debug.core.MAPPED_RESOURCE_PATHS"/>
+<listAttribute key="org.eclipse.debug.core.MAPPED_RESOURCE_TYPES"/>
+<booleanAttribute key="org.eclipse.debug.ui.ATTR_LAUNCH_IN_BACKGROUND" value="false"/>
+<listAttribute key="org.eclipse.jdt.launching.CLASSPATH">
+<listEntry value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&#10;&lt;runtimeClasspathEntry containerPath=&quot;org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/java-1.5.0-sun-1.5.0.18&quot; path=&quot;1&quot; type=&quot;4&quot;/&gt;&#10;"/>
+<listEntry value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&#10;&lt;runtimeClasspathEntry id=&quot;org.eclipse.ant.ui.classpathentry.antHome&quot;&gt;&#10;&lt;memento default=&quot;true&quot;/&gt;&#10;&lt;/runtimeClasspathEntry&gt;&#10;"/>
+<listEntry value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&#10;&lt;runtimeClasspathEntry id=&quot;org.eclipse.ant.ui.classpathentry.extraClasspathEntries&quot;&gt;&#10;&lt;memento/&gt;&#10;&lt;/runtimeClasspathEntry&gt;&#10;"/>
+</listAttribute>
+<stringAttribute key="org.eclipse.jdt.launching.CLASSPATH_PROVIDER" value="org.eclipse.ant.ui.AntClasspathProvider"/>
+<booleanAttribute key="org.eclipse.jdt.launching.DEFAULT_CLASSPATH" value="false"/>
+<stringAttribute key="org.eclipse.jdt.launching.PROJECT_ATTR" value=""/>
+<stringAttribute key="org.eclipse.jdt.launching.SOURCE_PATH_PROVIDER" value="org.eclipse.ant.ui.AntClasspathProvider"/>
+<stringAttribute key="org.eclipse.ui.externaltools.ATTR_ANT_TARGETS" value="all,"/>
+<stringAttribute key="org.eclipse.ui.externaltools.ATTR_LAUNCH_CONFIGURATION_BUILD_SCOPE" value="${none}"/>
+<stringAttribute key="org.eclipse.ui.externaltools.ATTR_LOCATION" value="${project_loc}/build.main.xml"/>
+<booleanAttribute key="org.eclipse.ui.externaltools.ATTR_TRIGGERS_CONFIGURED" value="true"/>
+<stringAttribute key="org.eclipse.ui.externaltools.ATTR_WORKING_DIRECTORY" value="${project_loc}"/>
+<stringAttribute key="process_factory_id" value="org.eclipse.ant.ui.remoteAntProcessFactory"/>
+</launchConfiguration>

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/.project
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/.project	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,37 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+
+<projectDescription>
+      <name>org.strategoxt.imp.testing</name>
+      <comment></comment>
+      <buildSpec>
+        <buildCommand>
+          <name>org.eclipse.jdt.core.javabuilder</name>
+          <arguments>
+          </arguments>
+        </buildCommand>
+        <buildCommand>
+            <name>org.eclipse.ui.externaltools.ExternalToolBuilder</name>
+            <triggers>full,incremental,</triggers>
+            <arguments>
+                <dictionary>
+                    <key>LaunchConfigHandle</key>
+                    <value>&lt;project&gt;/.externalToolBuilders/Spoofax-Testing build.main.xml.launch</value>
+                </dictionary>
+            </arguments>
+        </buildCommand>
+        <buildCommand>
+          <name>org.eclipse.pde.ManifestBuilder</name>
+          <arguments>
+          </arguments>
+        </buildCommand>
+        <buildCommand>
+          <name>org.eclipse.pde.SchemaBuilder</name>
+          <arguments>
+          </arguments>
+        </buildCommand>
+      </buildSpec>
+      <natures>
+        <nature>org.eclipse.pde.PluginNature</nature>
+        <nature>org.eclipse.jdt.core.javanature</nature>
+      </natures>
+    </projectDescription>
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/.settings/org.eclipse.jdt.core.prefs
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/.settings/org.eclipse.jdt.core.prefs	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,11 @@
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.5
+org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
+org.eclipse.jdt.core.compiler.compliance=1.5
+org.eclipse.jdt.core.compiler.debug.lineNumber=generate
+org.eclipse.jdt.core.compiler.debug.localVariable=generate
+org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.source=1.5

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/META-INF/MANIFEST.MF
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/META-INF/MANIFEST.MF	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,26 @@
+Manifest-Version: 1.0
+Bundle-ManifestVersion: 2
+Bundle-Name: SpoofaxTesting Plug-in
+Bundle-SymbolicName: org.strategoxt.imp.testing; singleton:=true
+Bundle-Version: 1.0.0
+Bundle-Activator: org.strategoxt.imp.testing.Activator
+Import-Package: org.osgi.framework;version="1.3.0"
+Require-Bundle: org.strategoxt.imp.runtime,
+ org.eclipse.core.runtime,
+ org.eclipse.core.resources,
+ org.eclipse.imp.runtime,
+ org.eclipse.ui,
+ org.eclipse.ui.ide,
+ org.eclipse.swt,
+ lpg.runtime,
+ org.eclipse.jface.text,
+ org.eclipse.ui.editors,
+ org.eclipse.ui.workbench.texteditor,
+ org.spoofax.aterm,
+ org.spoofax.jsglr,
+ org.strategoxt.strj,
+ org.eclipse.jdt.junit
+Bundle-RequiredExecutionEnvironment: J2SE-1.5
+Bundle-ActivationPolicy: lazy
+Export-Package: org.strategoxt.imp.testing
+

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/build.generated.xml
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/build.generated.xml	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,447 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+
+<project name="build.generated">
+
+        <target name="spoofaximp.default" depends="spoofaximp.default.ctree"/>
+        <target name="spoofaximp.default.ctree" depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.ctree,java.jar,sdf2imp,refresh"/>
+        <target name="spoofaximp.default.jar" depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.jar,  java.jar,sdf2imp,refresh"/>
+    
+        <!-- Initialization -->
+        <available file="${build}/org/strategoxt/imp/testing/strategies/Main.class" property="java.jar.enabled"/>
+        <condition property="java.jar.import" value="-la org.strategoxt.imp.testing.strategies" else="">
+            <isset property="java.jar.enabled"/>
+        </condition>
+        <condition property="java.jar.classpath" value=":${include}/${strmodule}-java.jar" else="">
+            <isset property="java.jar.enabled"/>
+        </condition>
+        <available file="${trans}/${strmodule}.str" property="build.stratego.enabled"/>
+        <dirname property="externaldefdir" file="${externaldef}"/>
+        <condition property="externaldefimport" value="-I ${externaldefdir}" else="">
+            <isset property="externaldef"/>
+        </condition>
+        <condition property="externaljarimport" value=":${externaljar}" else="">
+            <isset property="externaljar"/>
+        </condition>
+        <condition property="build.compiler" value="org.eclipse.jdt.core.JDTCompilerAdapter">
+            <isset property="eclipse.running"/>
+        </condition>
+        <condition property="externaljarflags" value="${externaljarflags}" else="">
+            <isset property="externaljarflags"/>
+        </condition>
+        <condition property="metasdfmodule.available" value="1">
+            <available file="${syntax}/${metasdfmodule}.sdf"/>
+        </condition>
+        
+        <fail unless="build" message="Please use build.main.xml to build this project or configure the required properties manually"/>
+        <mkdir dir="${build}"/>
+        <mkdir dir="${src-gen}"/>
+        <mkdir dir="${dist}"/>
+        <mkdir dir="${include}"/>
+        <mkdir dir="${lib}"/>
+        <mkdir dir="${syntax}"/>
+
+        <target name="sdf2imp" depends="sdf2table,sdf2imp.eclipse,sdf2imp.standalone"/>
+        
+        <target name="sdf2imp.eclipse" if="eclipse.running" depends="sdf2rtg">
+            <java classname="org.strategoxt.imp.metatooling.building.AntDescriptorBuilder" failonerror="true">
+                <arg value="${include}/${esvmodule}.packed.esv"/>
+            </java>
+        </target>
+        
+        <target name="refresh" if="eclipse.running">
+            <eclipse.convertPath fileSystemPath="${basedir}" property="projectdir"/>
+            <eclipse.convertPath fileSystemPath="${syntax}" property="syntaxdir"/>
+            <eclipse.convertPath fileSystemPath="${lib}" property="libdir"/>
+            <eclipse.refreshLocal resource="${libdir}" depth="infinite"/>
+            <eclipse.refreshLocal resource="${syntaxdir}/${sdfmodule}.pp.generated" depth="infinite"/>
+            <eclipse.refreshLocal resource="${libdir}/editor-common.generated.str" depth="infinite"/>
+            <eclipse.refreshLocal resource="${projectdir}/build.generated.xml" depth="infinite"/>
+            <eclipse.refreshLocal resource="${projectdir}/editor/${sdfmodule}-Builders.generated.esv" depth="infinite"/>
+            <eclipse.refreshLocal resource="${projectdir}/editor/${sdfmodule}-Colorer.generated.esv" depth="infinite"/>
+            <eclipse.refreshLocal resource="${projectdir}/editor/${sdfmodule}-Completions.generated.esv" depth="infinite"/>
+            <eclipse.refreshLocal resource="${projectdir}/editor/${sdfmodule}-Folding.generated.esv" depth="infinite"/>
+            <eclipse.refreshLocal resource="${projectdir}/editor/${sdfmodule}-References.generated.esv" depth="infinite"/>
+            <eclipse.refreshLocal resource="${projectdir}/editor/${sdfmodule}-Syntax.generated.esv" depth="infinite"/>
+            <eclipse.convertPath fileSystemPath="${src-gen}" property="eclipse.path.src-gen"/>
+            <eclipse.refreshLocal resource="${eclipse.path.src-gen}" depth="infinite"/>
+            <eclipse.convertPath fileSystemPath="${build}" property="eclipse.path.build"/>
+            <eclipse.refreshLocal resource="${eclipse.path.build}" depth="infinite"/>
+            <!-- Might cause the editor to be reloaded?
+            <eclipse.refreshLocal resource="${projectdir}/include" depth="infinite" />
+            -->
+        </target>
+        
+        <target name="sdf2imp.standalone" unless="eclipse.running" depends="sdf2rtg">
+            <java classname="org.strategoxt.imp.generator.sdf2imp" failonerror="true">
+                <arg value="-i"/>
+                <arg value="${basedir}/editor/${esvmodule}.main.esv"/>
+                <arg value="-p"/>
+                <arg value="${include}/${sdfmodule}.tbl"/>
+            </java>
+        </target>
+        
+        <target name="check-classpath">
+            <available classname="org.strategoxt.imp.generator.sdf2imp" property="check-classpath.available"/>
+            <antcall target="check-classpath.helper"/>  
+        </target>
+        
+        <target name="init" if="eclipse.running">
+            <!-- refresh one file/dir in the project to trigger an Ant rebuild with the next build command -->
+            <java classname="org.strategoxt.imp.metatooling.building.AntForceRefreshScheduler" failonerror="false">
+                <arg value="${include}"/>
+            </java>
+        </target>
+  
+        <target name="check-classpath.helper" unless="check-classpath.available">
+            <echo level="error" message="Could not load the Spoofax plugin loading classes."/>
+            <echo level="error" message="Make sure it is on the class path."/>
+            <echo level="error" message=""/>               
+            <echo level="error" message="In Eclipse, make sure the Ant builder is configured properly:"/>
+            <echo level="error" message="right-click on build.main.xml, go to Run as, Ant build..., JRE tab,"/>
+            <echo level="error" message="and ensure Run in the same JRE as the workspace is selected"/>
+            <echo level="error" message="alternatively, build the project using Build Project in the Project menu"/>
+            <fail/>
+        </target>
+    
+        <target name="sdf2table" depends="make-permissive">
+            <apply executable="${build.strategoxt.sdf}sdf2table" dest="${include}" failonerror="true">
+                <arg value="-i"/>
+                <srcfile/>
+                <arg value="-o"/>
+                <targetfile/>
+                <arg value="-m"/>
+                <arg value="${sdfmodule}"/>
+                
+                <fileset file="${include}/${sdfmodule}-Permissive.def"/>
+                <mapper type="glob" from="*-Permissive.def" to="*.tbl"/>
+            </apply>
+        </target>
+        
+        <target name="meta-sdf2table" if="metasdfmodule.available">
+            <fail unless="eclipse.spoofaximp.jars" message="Property eclipse.spoofaximp.jars must point to the directory containing StrategoMix.def"/>
+            <antcall target="sdf2table">
+                <param name="sdfmodule" value="${metasdfmodule}"/>
+                <param name="build.sdf.imports" value="-Idef &quot;${eclipse.spoofaximp.jars}/StrategoMix.def&quot; ${build.sdf.imports}"/>
+            </antcall>
+            <antcall target="meta-sdf2table.helper"/>
+        </target>
+        
+        <target name="meta-sdf2table.helper" if="eclipse.running">
+           <eclipse.convertPath fileSystemPath="${include}" property="includeresource"/>
+           <eclipse.refreshLocal resource="${includeresource}/${metasdfmodule}.tbl" depth="infinite"/>
+        </target>
+        
+        <target name="make-permissive" depends="pack-sdf,copy-sdf">
+            <dependset>
+                <srcfileset file="${include}/${sdfmodule}.def"/>
+                <targetfileset file="${include}/${sdfmodule}-Permissive.def"/>
+            </dependset>
+            <available file="${include}/${sdfmodule}-Permissive.def" property="permissive-grammar.available"/>
+            <antcall target="make-permissive.helper"/>
+        </target>
+    
+        <target name="make-permissive.helper" unless="permissive-grammar.available">
+            <java classname="org.strategoxt.permissivegrammars.make_permissive" failonerror="true">
+                <arg value="-i"/>
+                <arg value="${include}/${sdfmodule}.def"/>
+                <arg value="-o"/>
+                <arg value="${include}/${sdfmodule}-Permissive.def"/>
+                <arg line="--optimize on"/>
+            </java>
+        </target>
+
+        <target name="utils-files"> <!-- only useful for builds outside of Eclipse -->
+            <mkdir dir="utils"/>
+            <copy file="${eclipse.spoofaximp.jars}/make_permissive.jar" todir="utils" failonerror="false"/>
+            <copy file="${eclipse.spoofaximp.jars}/sdf2imp.jar" todir="utils" failonerror="false"/>
+            <copy file="${eclipse.spoofaximp.jars}/aster.jar" todir="utils" failonerror="false"/>
+            <copy file="${eclipse.spoofaximp.strategojar}" todir="utils" failonerror="false"/>
+        </target>
+    
+        <target name="pack-sdf" unless="externaldef">
+            <dependset>
+                <srcfileset dir="${basedir}">
+                    <include name="**/*.sdf"/>
+                </srcfileset>
+                <srcfileset dir="${lib}">
+                    <include name="**/*.def"/>
+                </srcfileset>
+                <targetfileset file="${include}/${sdfmodule}.def"/>
+            </dependset>
+            <available file="${include}/${sdfmodule}.def" property="pack-sdf.available"/>
+            <antcall target="pack-sdf.helper"/>
+        </target>
+    
+        <target name="pack-sdf.helper" unless="pack-sdf.available">
+            <condition property="utils-include" value="-I ${utils}" else="">
+                <available file="${utils}"/>
+            </condition>
+            <java classname="run" failonerror="true">
+                <arg value="org.strategoxt.tools.main-pack-sdf"/>
+                <arg value="-i"/>
+                <arg value="${syntax}/${sdfmodule}.sdf"/>
+                <arg value="-o"/>
+                <arg value="${include}/${sdfmodule}.def"/>
+                <arg value="-I"/>
+                <arg value="${syntax}"/>
+                <arg value="-I"/>
+                <arg value="${lib}"/>
+                <arg line="${utils-include}"/>
+                <arg line="${build.sdf.imports}"/>
+            </java>
+        </target>
+    
+        <target name="copy-sdf" if="externaldef">
+            <copy file="${externaldef}" tofile="${include}/${sdfmodule}.def" preservelastmodified="true"/>
+        </target>
+    
+        <target name="copy-jar" if="externaljar">
+            <copy file="${externaljar}" todir="${include}" preservelastmodified="true"/>
+        </target>
+    
+        <target name="rtg2sig" if="build.stratego.enabled" depends="sdf2rtg">
+            <dependset>
+                <srcfileset file="${include}/${sdfmodule}.rtg"/>
+                <targetfileset file="${include}/${sdfmodule}.str"/>
+            </dependset>
+            <available file="${include}/${sdfmodule}.str" property="rtg2sig.available"/>
+            <antcall target="rtg2sig.helper"/>
+        </target>
+    
+        <target name="rtg2sig.helper" unless="rtg2sig.available">
+            <java classname="run" failonerror="true">
+                <arg value="org.strategoxt.tools.main-rtg2sig"/>
+                <arg value="-i"/>
+                <arg value="${include}/${sdfmodule}.rtg"/>
+                <arg value="-o"/>
+                <arg value="${include}/${sdfmodule}.str"/>
+                <arg value="--module"/>
+                <arg value="${sdfmodule}"/>
+            </java>
+        </target>
+        
+        <target name="sdf2rtg" depends="pack-sdf,copy-sdf">
+            <dependset>
+                <srcfileset file="${include}/${sdfmodule}.def"/>
+                <targetfileset file="${include}/${sdfmodule}.rtg"/>
+            </dependset>
+            <available file="${include}/${sdfmodule}.rtg" property="sdf2rtg.available"/>
+            <antcall target="sdf2rtg.helper"/>
+        </target>
+    
+        <target name="sdf2rtg.helper" unless="sdf2rtg.available">
+            <java classname="run" failonerror="true">
+                <arg value="org.strategoxt.tools.main-sdf2rtg"/>
+                <arg value="-i"/>
+                <arg value="${include}/${sdfmodule}.def"/>
+                <arg value="-m"/>
+                <arg value="${sdfmodule}"/>
+                <arg value="-o"/>
+                <arg value="${include}/${sdfmodule}.rtg"/>
+                <arg value="--ignore-missing-cons"/>
+                <arg value="-Xnativepath"/>
+                <arg value="${build.strategoxt.sdf}"/>
+            </java>
+        </target>
+        
+        <target name="ppgen" if="build.stratego.enabled" depends="pack-sdf">
+            <dependset>
+                <srcfileset file="${include}/${sdfmodule}.def"/>
+                <targetfileset file="${syntax}/${sdfmodule}.generated.pp"/>
+                <targetfileset file="${include}/${sdfmodule}.generated.pp.af"/>
+            </dependset>
+            <available file="${include}/${sdfmodule}.generated.pp.af" property="ppgen.available"/>
+            <antcall target="ppgen.helper"/>
+            <available file="${include}/${sdfmodule}.generated.pp.af" property="ppgen.available"/>
+            <antcall target="ppgen.helper.fallback"/>
+        </target>
+    
+        <target name="ppgen.helper" unless="ppgen.available">
+            <!-- Any failures here are ignored; they are only a problem when imported from Stratego -->
+            <java classname="run" failonerror="false">
+                <arg value="org.strategoxt.tools.main-ppgen"/>
+                <arg value="-i"/>
+                <arg value="${include}/${sdfmodule}.def"/>
+                <arg value="-o"/>
+                <arg value="${include}/${sdfmodule}.generated.pp.af"/>
+                <arg value="-t"/>
+            </java>
+            <java classname="run" failonerror="false">
+                <arg value="org.strategoxt.tools.main-pp-pp-table"/>
+                <arg value="-i"/>
+                <arg value="${include}/${sdfmodule}.generated.pp.af"/>
+                <arg value="-o"/>
+                <arg value="${syntax}/${sdfmodule}.generated.pp"/>
+            </java>
+        </target>
+    
+        <target name="ppgen.helper.fallback" unless="ppgen.available">
+            <echo file="${include}/${sdfmodule}.generated.pp.af" message="PP-Table([])"/>
+        </target>
+        
+        <target name="pppack" if="build.stratego.enabled" depends="pack-sdf">
+            <dependset>
+                <srcfileset file="${syntax}/${sdfmodule}.pp"/>
+                <targetfileset file="${include}/${sdfmodule}.pp.af"/>
+            </dependset>
+            <available file="${syntax}/${sdfmodule}.pp" property="pppack.source-available"/>
+            <available file="${include}/${sdfmodule}.pp.af" property="pppack.available"/>
+            <antcall target="pppack.helper"/>
+            <available file="${include}/${sdfmodule}.pp.af" property="pppack.available"/>
+            <antcall target="pppack.helper.fallback"/>
+        </target>
+    
+        <target name="pppack.helper" unless="pppack.available" if="pppack.source-available">
+            <java classname="run" failonerror="true">
+                <arg value="org.strategoxt.tools.main-parse-pp-table"/>
+                <arg value="-i"/>
+                <arg value="${syntax}/${sdfmodule}.pp"/>
+                <arg value="-o"/>
+                <arg value="${include}/${sdfmodule}.pp.af"/>
+            </java>
+        </target>
+    
+        <target name="pppack.helper.fallback" unless="pppack.available">
+            <echo file="${include}/${sdfmodule}.pp.af" message="PP-Table([])"/>
+        </target>
+    
+        <!-- Aster to Stratego -->
+        <target name="stratego.aster">
+            <available file="${trans}/${strmodule}.rtree" property="aster-output.available"/>
+            <pathconvert property="aster-input" setonempty="false" pathsep=" ">
+                <path><fileset dir="${basedir}" includes="*.astr"/></path>
+            </pathconvert>
+            <dependset>
+                <srcfileset dir="${basedir}">
+                    <include name="**/*.astr"/>
+                </srcfileset>
+                <targetfileset file="${trans}/${strmodule}.rtree"/>
+            </dependset>
+            <condition property="aster-output.uptodate">
+                <and>
+                    <isset property="aster-output.available"/>
+                    <available file="${trans}/${strmodule}.rtree"/>
+                </and>
+            </condition>
+            <available file="${trans}/${strmodule}.rtree" property="aster-output.uptodate"/>
+            <antcall target="stratego.aster.helper"/>
+        </target>
+    
+        <target name="stratego.aster.helper" if="aster-input" unless="aster-output.uptodate">
+            <java classname="org.strategoxt.aster.Main" failonerror="true">
+                <arg value="-i"/>
+                <fileset dir="${basedir}">
+                    <include name="**/*.astr"/>
+                </fileset>
+            </java>
+        </target>
+        
+        <target name="java.jar" if="java.jar.enabled">
+            <jar basedir="${build}" excludes="trans/**" update="true" destfile="${include}/${strmodule}-java.jar"/>
+        </target>
+    
+        <!-- Stratego to Java interpreter -->
+        <target name="stratego.ctree" depends="rtg2sig">
+            <dependset>
+                <srcfileset dir="${basedir}">
+                    <include name="**/*.str"/>
+                    <include name="**/*.astr"/>
+                    <exclude name="lib/editor-common.generated.str"/>
+                </srcfileset>
+                <targetfileset file="${include}/${strmodule}.ctree"/>
+            </dependset>
+            <available file="${include}/${strmodule}.ctree" property="strc-java.available"/>
+            <antcall target="copy-jar"/>
+            <antcall target="stratego.jvm.helper">
+                <param name="build.stratego.outputfile" value="${include}/${strmodule}.ctree"/>
+                <param name="build.stratego.extraargs" value="-F"/>
+            </antcall>
+        </target>
+    
+        <!-- Stratego to Java compiler -->
+        <target name="stratego.jar" depends="rtg2sig,utils-files">
+            <dependset>
+                <srcfileset dir="${basedir}">
+                    <include name="**/*.str"/>
+                    <include name="**/*.astr"/>
+                    <exclude name="lib/editor-common.generated.str"/>
+                </srcfileset>
+                <targetfileset file="${src-gen}/trans/Main.java"/>
+            </dependset>
+            <available file="${src-gen}/trans/Main.java" property="strc-java.available"/>
+            <antcall target="copy-jar"/>
+            <antcall target="stratego.jar.deletehelper"/>
+            <antcall target="stratego.jvm.helper">
+                <param name="build.stratego.outputfile" value="${src-gen}/trans/Main.java"/>
+                <param name="build.stratego.extraargs" value="-la java-front ${java.jar.import}"/>
+            </antcall>
+            <javac classpath="utils/strategoxt.jar:${src-gen}${externaljarimport}${java.jar.classpath}" srcdir="${src-gen}" includes="trans/**" destdir="${build}" source="1.5" target="1.5" debug="on"/>
+            <!-- copy imported terms -->
+            <copy todir="${build}/trans">
+                <fileset dir="${src-gen}/trans" excludes="**/*.java"/>
+            </copy>
+            <jar basedir="${build}" includes="trans/**" destfile="${include}/${strmodule}.tmp.jar"/>
+            <move file="${include}/${strmodule}.tmp.jar" tofile="${include}/${strmodule}.jar"/>
+            <delete><fileset dir="${build}" includes="trans/**"/></delete>
+        </target>
+        
+        <target name="stratego.jar.deletehelper" unless="strc-java.available">
+            <delete>
+                <fileset dir="${src-gen}" includes="trans/**"/>
+                <fileset dir="${build}" includes="trans/**"/>
+            </delete>
+        </target>
+            
+        <target name="stratego.jvm.helper" unless="strc-java.available" if="build.stratego.enabled">
+            <delete file="${include}/${strmodule}.rtree" failonerror="false"/>
+            <java classname="org.strategoxt.strj.Main" failonerror="true">
+                <arg value="-i"/>
+                <arg value="${trans}/${strmodule}.str"/>
+                <arg value="-o"/>
+                <arg value="${build.stratego.outputfile}"/>
+                <arg value="-p"/>
+                <arg value="trans"/>
+                <arg value="--library"/>
+                <arg value="--clean"/>
+                <arg line="${build.stratego.args}"/>
+                <arg line="${build.stratego.extraargs}"/>
+                <arg line="${externaljarflags}"/>
+                <arg line="${externaldefimport}"/>
+                <arg line="-I &quot;${lib}&quot; -I &quot;${include}&quot; --cache-dir &quot;${basedir}/.cache&quot;"/>
+            </java>
+            <delete file="${include}/${strmodule}.rtree" failonerror="false"/>
+            <mkdir dir="${build}/trans"/>
+        </target>
+                
+        <!-- Stratego to C-based native executable -->
+        <target name="stratego.c">
+            <antcall target="stratego.c.helper">
+                <param name="build.stratego.outputpath" value="${basedir}/include"/>
+                <param name="build.stratego.extraargs" value=""/>
+                <param name="build.stratego.extension" value=""/>
+                <param name="build.stratego.compiler" value="strc"/>
+            </antcall>
+        </target>
+        
+        <!-- Helper target for calling the stratego compiler -->
+        <target name="stratego.c.helper" depends="rtg2sig" if="build.stratego.enabled">
+            <apply executable="${build.strategoxt.stratego}/${build.stratego.compiler}" dest="${build.stratego.outputpath}" failonerror="true">
+                <arg value="-i"/>
+                <srcfile/>
+                <arg value="-o"/>
+                <targetfile/>
+                <arg line="${build.stratego.args}"/>
+                <arg line="${build.stratego.extraargs}"/>
+                <arg line="${externaldefimport}"/>
+                <arg line="-I &quot;${lib}&quot; --cache-dir &quot;${basedir}/.cache&quot;"/>
+                
+                <fileset file="${trans}/${strmodule}.str"/>
+                <mapper type="glob" from="*.str" to="*.${build.stratego.extension}"/>
+            </apply>
+        </target>
+        
+        <target name="clean" description="clean up">
+            <delete dir="${build}"/>
+            <delete file="${src-gen}/trans/Main.java"/>
+        </target>
+    </project>
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/build.main.xml
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/build.main.xml	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,44 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+
+<project name="Spoofax-Testing" default="all">
+        
+        <!-- Key input modules -->
+        <property name="sdfmodule" value="Spoofax-Testing"/>
+        <property name="metasdfmodule" value="Stratego-Spoofax-Testing"/>
+        <property name="esvmodule" value="Spoofax-Testing"/>
+        <property name="strmodule" value="spoofax_testing"/>
+    
+        <!-- Project directories -->
+        <property name="trans" location="trans"/>
+        <property name="src-gen" location="editor/java"/>
+        <property name="syntax" location="syntax"/>
+        <property name="include" location="include"/>
+        <property name="lib" location="lib"/>
+        <property name="build" location="bin"/>
+        <property name="dist" location="bin/dist"/>
+        
+        <!-- Imports -->
+        <property name="build.sdf.imports" value=""/>
+        <property name="build.stratego.args" value="
+                        --library
+                        -I &quot;${trans}&quot;
+                        -I &quot;${basedir}&quot;
+                        -la stratego-lib -la stratego-sglr -la stratego-gpp -la stratego-xtc -la stratego-aterm -la stratego-sdf"/>
+        
+        <!-- Optional: external .def and .jar locations
+        <property name="externaldef" location="syntax/${sdfmodule}.def"/>
+        <property name="externaljar" value="../lib.jar"/>
+        <property name="externaljarflags" value="-la org.lib"/>
+        -->
+    
+        <!-- Environment configuration for command-line builds -->
+        <condition property="build.strategoxt.sdf" value="${eclipse.spoofaximp.nativeprefix}" else="">
+            <isset property="eclipse.spoofaximp.nativeprefix"/>
+        </condition>
+        <property name="build.strategoxt.stratego" location="${user.home}/.nix-profile/bin"/>
+    
+        <import file="build.generated.xml"/>
+    
+        <!-- Main target -->
+        <target name="all" depends="spoofaximp.default.jar"/>
+    </project>

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/build.properties
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/build.properties	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,8 @@
+source.. = editor/java/
+output.. = bin/
+bin.includes = META-INF/,\
+               plugin.xml,\
+               include/,\
+               bin/,\
+               lib/,\
+               .

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Builders.esv
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Builders.esv	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,23 @@
+
+module Spoofax-Testing-Builders
+
+imports Spoofax-Testing-Builders.generated
+
+builders
+                                                                      
+  // This file can be used for custom analysis and builder rules.     
+  //                                                                  
+  // See the imported file for a brief introduction and examples.     
+
+builders
+  // on save  : generate-artifacts                                                                                                                             
+  provider : include/spoofax_testing.jar                                                                    
+  provider : include/spoofax_testing-java.jar                                                                 
+                                                                                                                               
+  observer : editor-analyze                                                                                   
+                                                                                                                               
+  builder  : "Generate Java code (for selection)"            = generate-java (openeditor)               
+  builder  : "Show abstract syntax (for selection)"          = generate-aterm (openeditor) (realtime) (meta) (source)  
+  builder  : "Generate missing output file with current AST" = generate-ast-file (cursor)              
+                                                                                                                               
+  //on save : generate-java                                                                                                    
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Colorer.esv
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Colorer.esv	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,12 @@
+module Spoofax-Testing-Colorer
+
+imports Spoofax-Testing-Colorer.generated
+
+colorer
+                                                                      
+  // This file can be used for custom colorer rules.                  
+  //                                                                  
+  // See the imported file for a brief introduction and examples.
+  
+  _.RegexPattern : darkgreen
+  _.AtomLiteral : darkgreen     
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Completions.esv
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Completions.esv	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,18 @@
+module Spoofax-Testing-Completions
+
+imports Spoofax-Testing-Completions.generated
+
+completions
+                                                                   
+  // This file is used to define content completion.               
+  //                                                               
+  // See the imported file for a brief introduction and examples.  
+                                                                   
+
+completions
+                                                                 
+  // Semantic (identifier) completion:   
+                                         
+  completion proposer                  : editor-complete
+                                         
+  completion trigger                   : ":"
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Folding.esv
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Folding.esv	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,9 @@
+module Spoofax-Testing-Folding
+
+imports Spoofax-Testing-Folding.generated
+
+folding
+  
+  // This file can be used for custom folding rules.
+  //
+  // See the imported file for a brief introduction and examples.
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Outliner.esv
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Outliner.esv	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,9 @@
+module Spoofax-Testing-Outliner
+
+imports Spoofax-Testing-Outliner.generated
+
+outliner
+  
+  // This file can be used for custom outliner rules.
+  //
+  // See the imported file for a brief introduction and examples.
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-References.esv
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-References.esv	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,15 @@
+module Spoofax-Testing-References
+
+imports Spoofax-Testing-References.generated
+
+references
+                                                                                                   
+  // This file can be used to specify reference resolving and hover help, and content completion.  
+  //                                                                                               
+  // See the imported file for a brief introduction and examples.                                  
+                                                                                                   
+
+references
+                
+  reference _ : editor-resolve
+  hover _     : editor-hover
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Syntax.esv
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Syntax.esv	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,9 @@
+module Spoofax-Testing-Syntax
+
+imports Spoofax-Testing-Syntax.generated
+
+language
+                                                                   
+  // This file can be used for custom syntax rules.                
+  //                                                               
+  // See the imported file for a brief introduction and examples.  
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing.main.esv
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing.main.esv	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,17 @@
+
+module Spoofax-Testing.main
+
+imports Spoofax-Testing-Builders Spoofax-Testing-Colorer Spoofax-Testing-Completions Spoofax-Testing-Folding Spoofax-Testing-Outliner Spoofax-Testing-References Spoofax-Testing-Syntax
+
+language General properties
+                  
+  name          : Spoofax-Testing
+  id            : org.strategoxt.imp.testing
+  extends       : Root
+                  
+  description   : "Spoofax/IMP-generated editor for the Spoofax-Testing language"
+  url           : http://strategoxt.org
+                  
+  extensions    : spt
+  table         : include/Spoofax-Testing.tbl
+  start symbols : TestSuite
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/Activator.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/Activator.java	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,44 @@
+package org.strategoxt.imp.testing;
+
+import org.eclipse.imp.preferences.PreferencesService;
+import org.eclipse.imp.runtime.PluginBase;
+import org.osgi.framework.BundleContext;
+
+public class Activator extends PluginBase 
+{ 
+  public static final String kPluginID = "SpoofaxTesting";
+
+  public static final String kLanguageName = "SpoofaxTesting";
+
+  protected static Activator sPlugin;
+
+  public static Activator getInstance()
+  { 
+    if(sPlugin == null)
+      return new Activator();
+    return sPlugin;
+  }
+
+  public Activator () 
+  { 
+    super();
+    sPlugin = this;
+  }
+
+  @Override public void start(BundleContext context) throws Exception
+  { 
+    super.start(context);
+  }
+
+  @Override public String getID()
+  { 
+    return kPluginID;
+  }
+
+  @Override public String getLanguageID()
+  { 
+    return kLanguageName;
+  }
+
+  protected static PreferencesService preferencesService = null;
+}
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/SpoofaxTestingParseController.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/SpoofaxTestingParseController.java	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,89 @@
+package org.strategoxt.imp.testing;
+
+import java.io.InputStream;
+import java.io.IOException;
+import org.eclipse.imp.parser.IParseController;
+import org.strategoxt.imp.runtime.Environment;
+import org.strategoxt.imp.runtime.dynamicloading.BadDescriptorException;
+import org.strategoxt.imp.runtime.dynamicloading.Descriptor;
+import org.strategoxt.imp.runtime.dynamicloading.DescriptorFactory;
+import org.strategoxt.imp.runtime.dynamicloading.DynamicParseController;
+
+public class SpoofaxTestingParseController extends DynamicParseController 
+{ 
+  public static final String LANGUAGE = new String("Spoofax-Testing");
+
+  private static final String TABLE = "/include/" + LANGUAGE + ".tbl";
+
+  private static final String DESCRIPTOR = "/include/" + LANGUAGE + ".packed.esv";
+
+  private static volatile Descriptor descriptor;
+
+  private static Throwable notLoadingCause;
+
+  public static synchronized Descriptor getDescriptor()
+  { 
+    if(notLoadingCause != null)
+      throw new RuntimeException(notLoadingCause);
+    if(descriptor == null)
+      createDescriptor();
+    return descriptor;
+  }
+
+  private static void createDescriptor()
+  { 
+    try
+    { 
+      InputStream descriptorStream = SpoofaxTestingParseController.class.getResourceAsStream(DESCRIPTOR);
+      InputStream table = SpoofaxTestingParseController.class.getResourceAsStream(TABLE);
+      if(descriptorStream == null)
+        throw new BadDescriptorException("Could not load descriptor file from " + DESCRIPTOR + " (not found in plugin: " + getPluginLocation() + ")");
+      if(table == null)
+        throw new BadDescriptorException("Could not load parse table from " + TABLE + " (not found in plugin: " + getPluginLocation() + ")");
+      descriptor = DescriptorFactory.load(descriptorStream, table, null);
+      descriptor.setAttachmentProvider(SpoofaxTestingParseController.class);
+    }
+    catch(BadDescriptorException exc)
+    { 
+      notLoadingCause = exc;
+      Environment.logException("Bad descriptor for " + LANGUAGE + " plugin", exc);
+      throw new RuntimeException("Bad descriptor for " + LANGUAGE + " plugin", exc);
+    }
+    catch(IOException exc)
+    { 
+      notLoadingCause = exc;
+      Environment.logException("I/O problem loading descriptor for " + LANGUAGE + " plugin", exc);
+      throw new RuntimeException("I/O problem loading descriptor for " + LANGUAGE + " plugin", exc);
+    }
+  }
+
+  private static String getPluginLocation()
+  { 
+    return SpoofaxTestingParseController.class.getProtectionDomain().getCodeSource().getLocation().getFile();
+  }
+
+  @Override public IParseController getWrapped()
+  { 
+    if(!isInitialized())
+    { 
+      if(notLoadingCause != null)
+        throw new RuntimeException(notLoadingCause);
+      try
+      { 
+        initialize(this, getDescriptor().getLanguage());
+      }
+      catch(BadDescriptorException exc)
+      { 
+        notLoadingCause = exc;
+        throw new RuntimeException(exc);
+      }
+    }
+    return super.getWrapped();
+  }
+
+  @Override protected void setNotLoadingCause(Throwable value)
+  { 
+    notLoadingCause = value;
+    super.setNotLoadingCause(value);
+  }
+}
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/SpoofaxTestingParseControllerGenerated.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/SpoofaxTestingParseControllerGenerated.java	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,89 @@
+package org.strategoxt.imp.testing;
+
+import java.io.InputStream;
+import java.io.IOException;
+import org.eclipse.imp.parser.IParseController;
+import org.strategoxt.imp.runtime.Environment;
+import org.strategoxt.imp.runtime.dynamicloading.BadDescriptorException;
+import org.strategoxt.imp.runtime.dynamicloading.Descriptor;
+import org.strategoxt.imp.runtime.dynamicloading.DescriptorFactory;
+import org.strategoxt.imp.runtime.dynamicloading.DynamicParseController;
+
+public class SpoofaxTestingParseControllerGenerated extends DynamicParseController 
+{ 
+  public static final String LANGUAGE = new String("Spoofax-Testing");
+
+  private static final String TABLE = "/include/" + LANGUAGE + ".tbl";
+
+  private static final String DESCRIPTOR = "/include/" + LANGUAGE + ".packed.esv";
+
+  private static volatile Descriptor descriptor;
+
+  private static Throwable notLoadingCause;
+
+  public static synchronized Descriptor getDescriptor()
+  { 
+    if(notLoadingCause != null)
+      throw new RuntimeException(notLoadingCause);
+    if(descriptor == null)
+      createDescriptor();
+    return descriptor;
+  }
+
+  private static void createDescriptor()
+  { 
+    try
+    { 
+      InputStream descriptorStream = SpoofaxTestingParseController.class.getResourceAsStream(DESCRIPTOR);
+      InputStream table = SpoofaxTestingParseController.class.getResourceAsStream(TABLE);
+      if(descriptorStream == null)
+        throw new BadDescriptorException("Could not load descriptor file from " + DESCRIPTOR + " (not found in plugin: " + getPluginLocation() + ")");
+      if(table == null)
+        throw new BadDescriptorException("Could not load parse table from " + TABLE + " (not found in plugin: " + getPluginLocation() + ")");
+      descriptor = DescriptorFactory.load(descriptorStream, table, null);
+      descriptor.setAttachmentProvider(SpoofaxTestingParseController.class);
+    }
+    catch(BadDescriptorException exc)
+    { 
+      notLoadingCause = exc;
+      Environment.logException("Bad descriptor for " + LANGUAGE + " plugin", exc);
+      throw new RuntimeException("Bad descriptor for " + LANGUAGE + " plugin", exc);
+    }
+    catch(IOException exc)
+    { 
+      notLoadingCause = exc;
+      Environment.logException("I/O problem loading descriptor for " + LANGUAGE + " plugin", exc);
+      throw new RuntimeException("I/O problem loading descriptor for " + LANGUAGE + " plugin", exc);
+    }
+  }
+
+  private static String getPluginLocation()
+  { 
+    return SpoofaxTestingParseController.class.getProtectionDomain().getCodeSource().getLocation().getFile();
+  }
+
+  @Override public IParseController getWrapped()
+  { 
+    if(!isInitialized())
+    { 
+      if(notLoadingCause != null)
+        throw new RuntimeException(notLoadingCause);
+      try
+      { 
+        initialize(this, getDescriptor().getLanguage());
+      }
+      catch(BadDescriptorException exc)
+      { 
+        notLoadingCause = exc;
+        throw new RuntimeException(exc);
+      }
+    }
+    return super.getWrapped();
+  }
+
+  @Override protected void setNotLoadingCause(Throwable value)
+  { 
+    notLoadingCause = value;
+    super.setNotLoadingCause(value);
+  }
+}
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/SpoofaxTestingValidator.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/SpoofaxTestingValidator.java	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,12 @@
+package org.strategoxt.imp.testing;
+
+import org.strategoxt.imp.runtime.dynamicloading.Descriptor;
+import org.strategoxt.imp.runtime.services.MetaFileLanguageValidator;
+
+public class SpoofaxTestingValidator extends MetaFileLanguageValidator 
+{ 
+  @Override public Descriptor getDescriptor()
+  { 
+    return SpoofaxTestingParseController.getDescriptor();
+  }
+}
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/strategies/InteropRegisterer.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/strategies/InteropRegisterer.java	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,14 @@
+package org.strategoxt.imp.testing.strategies;
+
+       import org.strategoxt.lang.JavaInteropRegisterer;
+       import org.strategoxt.lang.Strategy;
+
+       /**
+        * Helper class for {@link java_strategy_0_0}.
+        */
+       public class InteropRegisterer extends JavaInteropRegisterer {
+
+         public InteropRegisterer() {
+           super(new Strategy[] { java_strategy_0_0.instance });
+         }
+       }

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/strategies/Main.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/strategies/Main.java	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,11 @@
+package org.strategoxt.imp.testing.strategies;
+
+       import org.strategoxt.lang.Context;
+       
+       public class Main {
+         
+         public static void init(Context context) {
+           // Called when the editor is being initialized
+         }
+       
+       }

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/strategies/java_strategy_0_0.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/strategies/java_strategy_0_0.java	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,32 @@
+package org.strategoxt.imp.testing.strategies;
+
+       import org.spoofax.interpreter.terms.IStrategoTerm;
+       import org.spoofax.interpreter.terms.ITermFactory;
+       import org.strategoxt.lang.Context;
+       import org.strategoxt.lang.Strategy;
+       
+       /**
+        * Example Java strategy implementation.
+        *
+        * This strategy can be used by editor services and can be called
+        * in Stratego modules by declaring it as an external strategy
+        * as follows:
+        *
+        * <code>
+        *  external java-strategy(|)
+        * </code>
+        *
+        * @see InteropRegisterer  This class registers java_strategy_0_0 for use.
+        */
+       public class java_strategy_0_0 extends Strategy {
+         
+         public static java_strategy_0_0 instance = new java_strategy_0_0();
+       
+         @Override
+         public IStrategoTerm invoke(Context context, IStrategoTerm current) {
+           context.getIOAgent().printError("Input for java-strategy: " + current);
+           ITermFactory factory = context.getFactory();
+           return factory.makeString("Regards from java-strategy");
+         }
+       
+       }

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/strategies/open_editor_0_0.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/strategies/open_editor_0_0.java	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,43 @@
+package org.strategoxt.imp.testing.strategies;
+
+import static org.spoofax.interpreter.core.Tools.isTermString;
+
+import java.io.FileNotFoundException;
+
+import org.eclipse.core.resources.IFile;
+import org.eclipse.jdt.junit.launcher.JUnitLaunchShortcut;
+import org.eclipse.swt.widgets.Display;
+import org.eclipse.ui.PlatformUI;
+import org.spoofax.interpreter.terms.IStrategoString;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.strategoxt.HybridInterpreter;
+import org.strategoxt.imp.runtime.EditorState;
+import org.strategoxt.imp.runtime.Environment;
+import org.strategoxt.imp.runtime.stratego.EditorIOAgent;
+import org.strategoxt.lang.Context;
+import org.strategoxt.lang.Strategy;
+
+public class open_editor_0_0 extends Strategy {
+
+	public static open_editor_0_0 instance = new open_editor_0_0();
+	
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm current) {
+		if (!isTermString(current)) return null;
+
+		String f = ((IStrategoString)current).stringValue();
+		try {
+			IFile file = EditorIOAgent.getFile(HybridInterpreter.getContext(context), f);
+			if (file.exists()) {
+				EditorState.asyncOpenEditor(Display.getDefault(), file, true);
+			} else {
+				Environment.logException("File does not exist: "+f);
+			}
+		} 
+		catch(FileNotFoundException e) {
+			Environment.logException("File not in workspace: "+f);
+		}
+		return null;
+	}
+
+}

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/lib/editor-common.generated.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/lib/editor-common.generated.str	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,254 @@
+module lib/editor-common.generated
+
+imports
+  libstratego-lib
+  libstratego-sglr
+  libstratego-gpp
+
+strategies
+
+  parse-file = parse-spoofax_testing-file
+  parse-spoofax_testing-file =
+    parse-file(
+      strsglr-perror, strsglr-report-parse-error
+    | <import-term(include/Spoofax-Testing.tbl)>
+    )
+
+  parse-string = parse-spoofax_testing-string
+  parse-spoofax_testing-string =
+    parse-string(
+      strsglr-report-parse-error
+    | <import-term(include/Spoofax-Testing.tbl)>
+    )
+  
+  parse-stream = parse-spoofax_testing-stream
+  parse-spoofax_testing-stream =
+    parse-stream(
+      strsglr-report-parse-error
+    | <import-term(include/Spoofax-Testing.tbl)>
+    )
+
+  pp-spoofax_testing-string =
+    ast2abox(|[<import-term(include/Spoofax-Testing.generated.pp.af)>,
+               <import-term(include/Spoofax-Testing.pp.af)>]);
+    box2text-string(|100)
+
+strategies
+  
+  /**
+   * Processes an import during semantic analysis.
+   * Ensures proper caching of files and prevents
+   * processing duplicate imports more than once.
+   *
+   * @param resolve-path  Resolves the filesystem path of this import
+   * @param parse-file    Parses a file (optionally removing definition bodies
+   *                      so only signatures are stored in the cache)
+   * @param record-declarations
+   *                      Performs semantic analysis on a tree
+   */
+  open-import(resolve-path, parse-file, record-declarations):
+    import -> import
+    where
+      if not(!import => COMPLETION(_)) then
+        path       := <resolve-path> import;
+        cache-path := <import-cache-path> path;
+        if not(<IsImported> path) then
+          rules(
+            IsImported: path
+          );
+          ( <is-newer> (cache-path, path);
+            file := <ReadFromFile> cache-path
+          <+
+            file := <parse-file> path;
+            if <file-exists> path then
+              // Only cache if on filesystem (e.g., ignore libstratego-lib)
+              <WriteToBinaryFile> (cache-path, file)
+            end        
+          );
+          {| CurrentFile:
+            rules(CurrentFile := path);
+            <record-declarations> file
+          |}
+        end
+      end
+
+  open-wildcard-import(resolve-path, parse-file, record-declarations, is-source-file):
+    import -> import
+    where
+      if not(!import => COMPLETION(_)) then
+        path := <resolve-path> import;
+        readdir;
+        list-loop(
+          if is-source-file then
+            <open-import(id, parse-file, record-declarations)>
+              $[[path]/[<id>]]
+          <+
+            try(?one-failed)
+          end
+        );
+        not(!one-failed)
+      end
+  
+  import-cache-path:
+    full-path -> cache-path
+    with
+      project-path := <project-path>;
+      cache-dir    := <file-exists <+ mkdir> $[[project-path]/.cache];
+      full-path'   := <string-replace(|"/", "+"); string-replace(|"\\", "+"); string-replace(|":", "+")> full-path;
+      cache-path   := $[[cache-dir]/[full-path'].sig]
+
+  project-path = prim("SSL_EXT_projectpath")
+  
+  plugin-path = prim("SSL_EXT_pluginpath")
+  
+  candidate-sorts = prim("SSL_EXT_candidatesorts")
+
+  is-newer:
+    (file1, file2) -> <id>
+    where
+      <gt> (<file-exists; modification-time> file1, <file-exists; modification-time> file2) 
+
+strategies
+  
+  editor-init =
+    // Ensure all dynamic rules are properly scoped
+    try(dr-scope-all-end);
+    dr-scope-all-start
+  
+  refresh-workspace-file:
+    path -> <prim("SSL_EXT_refreshresource", path)>
+  
+  string-starts-with-capital =
+    explode-string; Hd; is-upper
+
+strategies
+  
+  origin-term      = prim("SSL_EXT_origin_term", <id>)
+  origin-text      = prim("SSL_EXT_origin_text", <id>)
+  origin-location  = prim("SSL_EXT_origin_location", <id>)
+  origin-line      = origin-location => (<id>, _, _, _)
+  origin-column    = origin-location => (_, <id>, _, _)
+  origin-strip     = prim("SSL_EXT_origin_strip", <id>)
+  origin-equal(|t) = prim("SSL_EXT_origin_equal", <id>, t)
+  
+  origin-surrounding-comments =
+    prim("SSL_EXT_origin_surrounding_comments", "Spoofax-Testing", <id>)
+    
+  origin-documentation-comment =
+    origin-surrounding-comments;
+    filter(string-as-chars(documentation-comment-chars));
+    concat-strings
+  
+  documentation-comment-chars:
+    ['*' | c*] -> <ltrim(' ' + '\t' + '\n' + '\r')> c*
+  
+  origin-track-forced(s) =
+    !Some(<id>); all(s); ?Some(<id>)
+
+strategies
+
+  desugar-position(desugar|ast):
+    position -> position'
+    where
+      ast'  := <at-position(!<id>{MARKER()}|position)> ast;
+      ast'' := <topdown(repeat(preserve-annos({?x; desugar; not(?x)})))> ast';
+      position' := <position-of-term({?_{a*}; <one(?MARKER())> a*})> ast''
+   
+  at-position(s|position):
+    c#(t*) -> t'
+    where
+      !position => [i | position']
+    where
+      t' := c#(<at-index(at-position(s|position'))> (i, t*))
+
+  at-position(s|position):
+    t -> t'
+    where
+      !position => [];
+      t' := <s> t
+
+  position-of-term(is-term):
+    t -> []
+    where
+      is-term
+  
+  position-of-term(is-term):
+    _#(t*) -> <position-of-term(is-term|0)> t*
+  
+  position-of-term(is-term|start-index):
+    [t | t*] -> position
+    where
+      if i* := <position-of-term(is-term)> t then
+        position := [start-index | i*]
+      else
+        position := <position-of-term(is-term | <inc> start-index)> t*
+      end
+
+  term-at-position(|position):
+    t -> t'
+    where
+      at-position(?t'|position) 
+
+  parent-at-position(|position):
+    t -> t'
+    where
+      !position => [i, _];
+      t' := <subterm-at(|i)> t
+  
+  parent-at-position(|position):
+    t -> <parent-at-position(|position')> t'
+    where
+      !position => [i | position' @ [_, _ | _]];
+      t' := <subterm-at(|i)> t
+
+  subterm-at(|index):
+    _#(t*) -> <index(|<inc> index)> t*
+  
+signature constructors
+
+  COMPLETION : String -> Term
+  NOCONTEXT  : Term   -> Term
+  MARKER     : Term
+
+  // Below are copies of the signatures of the terms used in example
+  // trans/spoofax_testing.str file. These definitions should also be automatically 
+  // generated in the imported include/Spoofax-Testing.str module. However,
+  // to ensure that the example transformation doesn't break when the
+  // syntax is changed, we also hard-coded them here.
+          
+  Module   : ID * List(Entity)   -> Module
+  Entity   : ID * List(Property) -> Entity
+  Property : ID * Type           -> Property
+  Type     : ID                  -> Type
+
+strategies
+  
+  // Set markers for a given file. Use when checking files from a queued strategy.
+  // Current term: (ast-desugared, errors, warnings, notes) tuple
+  // ast: the root node of the file to set markers on 
+  set-markers(|ast) = prim("SSL_EXT_set_markers", ast)
+
+  // Indicate that one or more files need analysis. 
+  // Current term: ss a list of absolute file paths, or a single absolute file path to analyze
+  queue-analysis = 
+       (is-list; list-loop(queue-analysis))
+    <+ prim("SSL_EXT_queue_analysis")
+
+  // Set the total number of work units to complete. Can be called multiple times. 
+  // Current term: number of work units (int).
+  set-total-work-units = prim("SSL_EXT_set_total_work_units")
+  
+  // Complete one work unit and update progress monitors.
+  // Current term: ignored
+  complete-work-unit = prim("SSL_EXT_complete_work_unit")
+  
+  // Queue a strategy for background processing with a progress indicator.
+  // Current term: the term to pass to the background strategy
+  // s: the strategy, as string
+  // description: name of the task (will be shown in progress view)
+  queue-strategy(|s,description) = prim("SSL_EXT_queue_strategy", s, description)
+  
+  // Return the result of this strategy to indicate a non-completed (backgrounded) analysis.
+  // Editor services (hover, resolve) will be delayed until a complete analysis is performed. 
+  set-analysis-backgrounded = !"BACKGROUNDED"
+  

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/plugin.xml
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/plugin.xml	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+<?eclipse version="3.0"?>
+
+<plugin>
+       <extension point="org.eclipse.imp.runtime.languageDescription">
+          <language extensions="spt" description="Spoofax-Testing" language="Spoofax-Testing" derivedFrom="DynamicRoot" validator="org.strategoxt.imp.testing.SpoofaxTestingValidator" validatorClass="org.strategoxt.imp.testing.SpoofaxTestingValidator"></language>
+       </extension>
+       <extension id="org.strategoxt.imp.testing.parser" name="Spoofax-Testing Parser" point="org.eclipse.imp.runtime.parser">
+          <parser class="org.strategoxt.imp.testing.SpoofaxTestingParseController" language="Spoofax-Testing">
+          </parser>
+       </extension>    
+    </plugin>
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Common.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Common.sdf	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,46 @@
+module Common
+
+exports
+
+  lexical syntax
+  
+    [a-zA-Z][a-zA-Z0-9\_]* -> ID
+    "-"? [0-9]+            -> INT
+    
+    "\"" StringChar* "\"" -> STRING
+    ~[\"\n]               -> StringChar
+    "\\\""                -> StringChar
+    BackSlashChar         -> StringChar
+    "\\"                  -> BackSlashChar
+    
+    [\ \t\n\r] -> LAYOUT
+    
+    [\*]                             -> CommentChar
+    "/*" (~[\*] | CommentChar)* "*/" -> LAYOUT
+    "//" ~[\n\r]* ([\n\r] | EOF)     -> LAYOUT
+    
+    -> EOF
+  
+  lexical restrictions
+  
+    %% Ensure greedy matching for lexicals
+  
+    CommentChar   -/- [\/]
+    INT           -/- [0-9]
+    ID            -/- [a-zA-Z0-9\_]
+    
+    %% EOF may not be followed by any char
+    
+    EOF           -/- ~[]
+
+    %% Backslash chars in strings may not be followed by " 
+    
+    BackSlashChar -/- [\"]
+
+  context-free restrictions
+  
+    %% Ensure greedy matching for comments
+
+    LAYOUT? -/- [\ \t\n\r]
+    LAYOUT? -/- [\/].[\/]
+    LAYOUT? -/- [\/].[\*]

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/RegExp.aterm
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/RegExp.aterm	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,9 @@
+prod(
+  [sort("Branche")]
+, sort("Pattern")
+, attrs(
+    [term(
+       default(appl(unquoted("cons"), [fun(quoted("\"SingleBranch\""))]))
+     )]
+  )
+)
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/RegExp.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/RegExp.sdf	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,257 @@
+module RegExp
+
+exports
+%%d  context-free start-symbols
+%%d    PatternDecl Pattern
+  sorts Pattern PatternDecl Exp
+  context-free syntax
+
+    "/" Pattern "/"            -> RegexExp { cons("RegexPattern") }
+    Branche                    -> Pattern {cons("SingleBranch")}
+    Pattern "|" Pattern        -> Pattern {cons("TupleBranch"), right, prefer}
+
+
+  sorts Branche
+  context-free syntax
+    Piece+                     -> Branche {cons("Pieces")}
+
+  sorts Piece
+  context-free syntax
+    Atom                       -> Piece {cons("SingleAtom")}
+    Atom Quantifier            -> Piece {cons("QuantifiedAtom")}
+
+  sorts Quantifier
+  context-free syntax
+   "{" Integer "}"              -> Quantifier {cons("GreedyExactBound")}
+   "{" Integer "," "}"          -> Quantifier {cons("GreedyLowerBound")}
+   "{" Integer "," Integer "}"  -> Quantifier {cons("GreedyLowerUpperBound")}
+   "?"                          -> Quantifier {cons("GreedyOnceOrNot")}
+   "*"                          -> Quantifier {cons("GreedyZeroOrMore")}
+   "+"                          -> Quantifier {cons("GreedyOneOrMore")}
+   "{" Integer "}?"             -> Quantifier {cons("ReluctantExactBound")}
+   "{" Integer "," "}?"         -> Quantifier {cons("ReluctantLowerBound")}
+   "{" Integer "," Integer "}?" -> Quantifier {cons("ReluctantLowerUpperBound")}
+   "??"                         -> Quantifier {cons("ReluctantOnceOrNot")}
+   "*?"                         -> Quantifier {cons("ReluctantZeroOrMore")}
+   "+?"                         -> Quantifier {cons("ReluctantOneOrMore")}  
+   "{" Integer "}+"             -> Quantifier {cons("PossessiveExactBound")}
+   "{" Integer "," "}+"         -> Quantifier {cons("PossessiveLowerBound")}
+   "{" Integer "," Integer "}+" -> Quantifier {cons("PossessiveLowerUpperBound")}
+   "?+"                         -> Quantifier {cons("PossessiveOnceOrNot")}
+   "*+"                         -> Quantifier {cons("PossessiveZeroOrMore")}
+   "++"                         -> Quantifier {cons("PossessiveOneOrMore")}   
+
+  sorts Atom
+  context-free syntax
+    "("   Pattern ")"          -> Atom {cons("Capture")}
+    "(?:" Pattern ")"          -> Atom {cons("NonCapture")}
+    "(?=" Pattern ")"          -> Atom {cons("PositiveLookahead")}
+    "(?!" Pattern ")"          -> Atom {cons("NegativeLookahead")}
+    "(?<=" Pattern ")"         -> Atom {cons("PositiveLookbehind")}
+    "(?<!" Pattern ")"         -> Atom {cons("NegativeLookbehind")}
+    "(?P<" RegexId ">" Pattern ")"  -> Atom {cons("PythonCapture")}
+    "(" Pattern ")@{" RegexId "}"   -> Atom {cons("RegexCapture")}
+    "()"                       -> Atom {cons("Empty")}
+    "."                        -> Atom {cons("SingleCharacter")}
+    "^"                        -> Atom {cons("LineStart")}
+    "$"                        -> Atom {cons("LineEnd")}
+    CharacterClass             -> Atom {cons("CharacterClass")}
+    AtomLiteral                -> Atom {cons("AtomLiteral")}
+    AtomCharacter              -> Atom {cons("AtomCharacter")}
+    "\\Q" AllChars "\\E"       -> Atom {cons("QuotedAtom")}    
+    
+  sorts CharacterClass BracketItem
+  context-free syntax
+    "[" BracketItem+ "]"       -> CharacterClass {cons("BracketList")}
+    "[^" BracketItem+ "]"      -> CharacterClass {cons("NegatedBracketList")}
+%%d "\\p\{" ClassKeyword "\}"   -> CharacterClass {cons("PredefineClass")}
+%%d "\\P\{" ClassKeyword "\}"   -> CharacterClass {cons("NegatedPredefineClass")}
+   
+
+    (BracketLiteral | BracketCharacter)
+     "-" 
+    (BracketLiteral | BracketCharacter)   -> BracketItem {cons("Range")}
+    CharacterClass                        -> BracketItem {cons("Union")}
+%%d "\&\&" CharacterClass                 -> BracketItem {cons("Intersection")}
+    BracketLiteral                        -> BracketItem {cons("BracketLiteral")}
+    BracketCharacter                      -> BracketItem {cons("BracketCharacter")}
+   
+
+%%
+ %%   Defining characterclasses
+  %% 
+sorts ClassKeyword
+  context-free syntax    
+    "Lower"                    -> ClassKeyword {cons("LowerClass")}
+    "Upper"                    -> ClassKeyword {cons("UpperClass")}
+    "ASCII"                    -> ClassKeyword {cons("ASCIIClass")}
+    "Alpha"                    -> ClassKeyword {cons("AlphaClass")}
+    "Digit"                    -> ClassKeyword {cons("DigitClass")}
+    "Alnum"                    -> ClassKeyword {cons("AlnumClass")}
+    "Punct"                    -> ClassKeyword {cons("PunctClass")}
+    "Graph"                    -> ClassKeyword {cons("GraphClass")}
+    "Print"                    -> ClassKeyword {cons("PrintClass")}
+    "Blank"                    -> ClassKeyword {cons("BlankClass")}
+    "Cntrl"                    -> ClassKeyword {cons("CntrlClass")}
+    "XDigit"                   -> ClassKeyword {cons("XDigitClass")}
+    "Space"                    -> ClassKeyword {cons("WhiteSpace")}
+    "javaLowerCase"            -> ClassKeyword {cons("JavaIsLowerCase")}
+    "javaUpperCase"            -> ClassKeyword {cons("JavaIsLowerCase")}
+    "javaWhitespace"           -> ClassKeyword {cons("JavaIsWhitespace")}
+    "javaMirrored"             -> ClassKeyword {cons("JavaIsMirrored")}
+    "InGreek"                  -> ClassKeyword {cons("GreekBlock")}
+    "Lu"                       -> ClassKeyword {cons("UppercaseLetter")}
+    "Sc"                       -> ClassKeyword {cons("CurrencySymbol")}
+
+%%
+ %%   Defining the Character -> Characters that appear as Atom and in Brackets  
+  %%   
+
+%%  ASCII characters:  
+%%  $*+?.{}()                             %% OnlyBranchSpecial
+%%  &]-                                   %% OnlyClassSpecial
+%%  [^\                                   %% AlwaysSpecial
+%%  !"#%',/:;<=>@_`~                      %% NeverSpecialCharacter
+%%  ABCDEFGHIJKLMNOPQRSTUVWXYZ            %% Character
+%%  abcdefghijklmnopqrstuvwxyz            %% Charater
+%%  0123456789                            %% Charater
+%%  <tab> <newline> <return> <form-feed>  %% SpecialEscapeCharacter
+
+
+  sorts BracketLiteral AtomLiteral AllChars
+  lexical syntax
+    [a-zA-Z0-9\!\#\%\'\,\:\;\<\=\>\@\_\`\~\$\*\+\?\.\}\|]
+                                                  -> BracketLiteral
+    "/"                                           -> BracketLiteral 
+    [\&\]\-]                                      -> BracketLiteral {reject}
+    [a-zA-Z0-9\!\#\%\'\,\:\;\<\=\>\@\_\`\~\&\]\-]
+                                                  -> AtomLiteral
+    "/"                                           -> AtomLiteral 
+    [\}\)\|\[]                                    -> AtomLiteral {reject}
+    
+    [\\\|\$\*\+\?\.\{\}\(\)\&\]\-\[\^\!\#\%\'\,\:\;\<\=\>\@\_\`\~a-zA-Z0-9\t\n\r]*              
+          -> AllChars
+    "/"   -> AllChars
+    "\""  -> AllChars {cons("DoubleQuote") } 
+      
+  sorts BracketCharacter AtomCharacter
+  context-free syntax
+%%d    "\{"                -> BracketCharacter {cons("CurlyBraceOpen") }
+%%d    "\{"                -> AtomCharacter    {cons("CurlyBraceOpen"), avoid}
+    "\""                -> BracketCharacter {cons("DoubleQuote") }
+    "\""                -> AtomCharacter    {cons("DoubleQuote") }
+%%d    "\)"                -> BracketCharacter {cons("BraceClose"), avoid }
+%%d    "\)"                -> AtomCharacter    {cons("BraceClose") }
+
+
+%%
+ %%   Escaping with a '\' to express a special character
+  %%
+  context-free syntax
+    "\\0" OctalValue       -> BracketCharacter {cons("OctalChar")}
+    "\\x" TwoHexValue      -> BracketCharacter {cons("HexHexChar")}
+    "\\u" FourHexValue     -> BracketCharacter {cons("DecHexChar")}
+    "\\t"                  -> BracketCharacter {cons("Tab")}
+    "\\n"                  -> BracketCharacter {cons("Newline")}
+    "\\r"                  -> BracketCharacter {cons("Return")}
+    "\\f"                  -> BracketCharacter {cons("Formfeed")}
+    "\\a"                  -> BracketCharacter {cons("Alarm")}
+    "\\e"                  -> BracketCharacter {cons("Escape")}
+    "\\w"                  -> BracketCharacter {cons("WordChar")}
+    "\\W"                  -> BracketCharacter {cons("NonWordChar")}
+    "\\s"                  -> BracketCharacter {cons("WhiteSpaceChar")}
+    "\\S"                  -> BracketCharacter {cons("NonWhiteSpaceChar")}
+    "\\d"                  -> BracketCharacter {cons("DigitChar")}
+    "\\D"                  -> BracketCharacter {cons("NonDigitChar")}
+    "\\c" ControlValue     -> BracketCharacter {cons("ControlCharacter")}
+    "\\b"                  -> BracketCharacter {cons("WordBoundry")}
+    "\\B"                  -> BracketCharacter {cons("NonWordBoundry")}
+    "\\A"                  -> BracketCharacter {cons("InputBeginBoundry")}
+    "\\G"                  -> BracketCharacter {cons("PrevMatchEndBoundry")}
+    "\\Z"                  -> BracketCharacter {cons("EndInputBoundry")}
+    "\\z"                  -> BracketCharacter {cons("EndInputFinalBoundry")}
+    "\\" BackReference     -> BracketCharacter {cons("BackReference")}
+    "\\ "                  -> BracketCharacter {cons("Space")}
+    "\\\t"                 -> BracketCharacter {cons("Tab")}
+%%d    "\\\r"                 -> BracketCharacter {cons("Return")}
+    "\\\n"                 -> BracketCharacter {cons("Newline")}
+    
+    "\\0" OctalValue       -> AtomCharacter {cons("OctalChar")}
+    "\\x" TwoHexValue      -> AtomCharacter {cons("HexHexChar")}
+    "\\u" FourHexValue     -> AtomCharacter {cons("DecHexChar")}
+    "\\t"                  -> AtomCharacter {cons("Tab")}
+    "\\n"                  -> AtomCharacter {cons("Newline")}
+    "\\r"                  -> AtomCharacter {cons("Return")}
+    "\\f"                  -> AtomCharacter {cons("Formfeed")}
+    "\\a"                  -> AtomCharacter {cons("Alarm")}
+    "\\e"                  -> AtomCharacter {cons("Escape")}
+    "\\w"                  -> AtomCharacter {cons("WordChar")}
+    "\\W"                  -> AtomCharacter {cons("NonWordChar")}
+    "\\s"                  -> AtomCharacter {cons("WhiteSpaceChar")}
+    "\\S"                  -> AtomCharacter {cons("NonWhiteSpaceChar")}
+    "\\d"                  -> AtomCharacter {cons("DigitChar")}
+    "\\D"                  -> AtomCharacter {cons("NonDigitChar")}
+    "\\c" ControlValue     -> AtomCharacter {cons("ControlCharacter")}
+    "\\b"                  -> AtomCharacter {cons("WordBoundry")}
+    "\\B"                  -> AtomCharacter {cons("NonWordBoundry")}
+    "\\A"                  -> AtomCharacter {cons("InputBeginBoundry")}
+    "\\G"                  -> AtomCharacter {cons("PrevMatchEndBoundry")}
+    "\\Z"                  -> AtomCharacter {cons("EndInputBoundry")}
+    "\\z"                  -> AtomCharacter {cons("EndInputFinalBoundry")}
+    "\\" BackReference     -> AtomCharacter {cons("BackReference")}
+    "\\ "                  -> AtomCharacter {cons("Space")}
+    "\\\t"                 -> AtomCharacter {cons("Tab")}
+%%d    "\\\r"                 -> AtomCharacter {cons("Return")}
+    "\\\n"                 -> AtomCharacter {cons("Newline")}
+    
+%%
+ %%   Quoting of symbols is always allowed to express that symbol
+  %%
+  sorts QuotablePatternSymbol
+  context-free syntax
+    "\\" QuotablePatternSymbol            -> AtomCharacter {cons("Quoted")}
+    "\\" QuotablePatternSymbol            -> BracketCharacter {cons("Quoted")}    
+  lexical syntax
+    [\|\$\*\+\?\.\{\}\(\)\&\]\[\-\^\\\!\#\%\'\,\:\;\<\=\>\@\_\`\~\/]
+                                   -> QuotablePatternSymbol
+  context-free syntax
+    "\""                -> QuotablePatternSymbol {cons("DoubleQuote") }
+    "\""                -> QuotablePatternSymbol {cons("DoubleQuote") }    
+%%
+ %%   Defining integers and number values
+  %% 
+  sorts Integer OctalValue TwoHexValue FourHexValue BackReference ControlValue
+  lexical syntax      
+    [0-9]+                                       -> Integer
+    [1-9] [0-9]*                                 -> BackReference
+    [0-7]                                        -> OctalValue
+    [0-7][0-7]                                   -> OctalValue
+    [0-3][0-7][0-7]                              -> OctalValue
+    [0-9A-Fa-f][0-9A-Fa-f]                       -> TwoHexValue
+    [0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f] -> FourHexValue
+    [0-9]                                        -> ControlValue
+    [0-9][0-9]                                   -> ControlValue
+
+%%d  lexical restrictions
+%%d    "/"  -/- [\]]
+%%d    "\\" -/- [\ \t\12\n\r]   
+    
+    
+exports
+  sorts
+    RegexId
+    RegexID
+
+  context-free syntax
+    RegexID -> RegexId {cons("RegexId")}
+
+  lexical syntax
+    [A-Za-z\_\$][A-Za-z0-9\_\$]* -> RegexID
+    
+    "true"  -> RegexID {reject}
+    "false" -> RegexID {reject}
+    "null"  -> RegexID {reject}
+
+  lexical restrictions
+    RegexID -/- [a-zA-Z0-9\_\$]
+

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing-String-Quotation.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing-String-Quotation.sdf	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,70 @@
+module Spoofax-Testing-String-Quotation
+exports
+
+  sorts
+    StringQuotation
+    StringQuotedPart1 StringQuotedChars1 DollarOpen1 DollarClose1 QuotedBracket1 Dollar1
+    StringQuotedPart2 StringQuotedChars2 DollarOpen2 DollarClose2 QuotedBracket2 Dollar2
+    StringQuotedPart3 StringQuotedChars3 DollarOpen3 DollarClose3 QuotedBracket3 Dollar3
+    StringQuotedPart4 StringQuotedChars4 DollarOpen4 DollarClose4 QuotedBracket4 Dollar4
+    Padding
+
+  context-free syntax
+
+    StringQuotation -> PreTerm
+
+  syntax
+
+    StringQuotation -> <PreTerm-CF>
+
+    "$" "[" Padding StringQuotedPart1*               "]"    -> StringQuotation {cons("StringQuotation1") }
+%%     Padding "[" <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> "]"    -> StringQuotedPart1 {cons("StringEscape1")}
+    <StringQuotedChars1-LEX>                                -> StringQuotedPart1 {cons("QStr")}
+    <Dollar1-LEX>                                           -> StringQuotedPart1 {cons("QDollar")}
+    "$" <QuotedBracket1-LEX> "$"                            -> StringQuotedPart1 {cons("QBr")}
+    ~[\[\]\$]+                                              -> <StringQuotedChars1-LEX>
+    [\[\]]                                                  -> <QuotedBracket1-LEX>
+    "$"                                                     -> <Dollar1-LEX>
+
+    "$" "{" Padding StringQuotedPart2*               "}"    -> StringQuotation {cons("StringQuotation2") }
+%%     Padding "{" <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> "}"    -> StringQuotedPart2 {cons("StringEscape2")}
+    <StringQuotedChars2-LEX>                                -> StringQuotedPart2 {cons("QStr")}
+    <Dollar2-LEX>                                           -> StringQuotedPart2 {cons("QDollar")}
+    "$" <QuotedBracket2-LEX> "$"                            -> StringQuotedPart2 {cons("QBr")}
+    ~[\{\}\$]+                                              -> <StringQuotedChars2-LEX>
+    [\{\}]                                                  -> <QuotedBracket2-LEX>
+    "$"                                                     -> <Dollar2-LEX>
+
+    "$" "(" Padding StringQuotedPart3*              ")"     -> StringQuotation {cons("StringQuotation3") }
+%%    Padding "(" <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> ")"     -> StringQuotedPart3 {cons("StringEscape3")}
+    <StringQuotedChars3-LEX>                                -> StringQuotedPart3 {cons("QStr")}
+    <Dollar3-LEX>                                           -> StringQuotedPart3 {cons("QDollar")}
+    "$" <QuotedBracket3-LEX> "$"                            -> StringQuotedPart3 {cons("QBr")}
+    ~[\(\)\$]+                                              -> <StringQuotedChars3-LEX>
+    [\(\)]                                                  -> <QuotedBracket3-LEX>
+    "$"                                                     -> <Dollar3-LEX>
+
+    "$" "<" Padding StringQuotedPart4*               ">"    -> StringQuotation {cons("StringQuotation4") }
+%%    Padding "<"  <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> ">"    -> StringQuotedPart4 {cons("StringEscape4")}
+    <StringQuotedChars4-LEX>                                -> StringQuotedPart4 {cons("QStr")}
+    <Dollar4-LEX>                                           -> StringQuotedPart4 {cons("QDollar")}
+    "$" <QuotedBracket4-LEX> "$"                            -> StringQuotedPart4 {cons("QBr")}
+    ~[\<\>\$]+                                              -> <StringQuotedChars4-LEX>
+    [\<\>]                                                  -> <QuotedBracket4-LEX>
+    "$"                                                     -> <Dollar4-LEX>
+   
+    %% Padding is a dummy lexical that will contain the indentation prefix of every quotation
+    <Padding-LEX>                                           -> Padding
+                                                            -> <Padding-LEX> {indentpadding}
+
+  lexical restrictions
+
+    StringQuotedChars1 -/- ~[\[\]\$]   
+    StringQuotedChars2 -/- ~[\{\}\$]    
+    StringQuotedChars3 -/- ~[\(\)\$]    
+    StringQuotedChars4 -/- ~[\<\>\$]
+    Dollar1            -/- [\[\]] . [\$]
+    Dollar2            -/- [\{\}] . [\$]
+    Dollar3            -/- [\(\)] . [\$]
+    Dollar4            -/- [\<\>] . [\$]
+

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing.aterm
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing.aterm	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,39 @@
+context-free-syntax(
+  [ prod(
+      [lit("\"testsuite\""), sort("Name"), sort("Options"), iter-star(sort("Test"))]
+    , sort("TestSuite")
+    , attrs(
+        [term(
+           default(appl(unquoted("cons"), [fun(quoted("\"testsuite\""))]))
+         )]
+      )
+    )
+  , prod(
+      [lit("\"topsort\""), sort("Sort")]
+    , sort("Options")
+    , attrs(
+        [term(
+           default(appl(unquoted("cons"), [fun(quoted("\"topsort\""))]))
+         )]
+      )
+    )
+  , prod(
+      [lit("\"options\""), iter(sort("Option"))]
+    , sort("Options")
+    , attrs(
+        [term(
+           default(appl(unquoted("cons"), [fun(quoted("\"options\""))]))
+         )]
+      )
+    )
+  , prod(
+      [sort("OptionValue"), sort("OptionValue")]
+    , sort("Option")
+    , attrs(
+        [term(
+           default(appl(unquoted("cons"), [fun(quoted("\"option\""))]))
+         )]
+      )
+    )
+  ]
+)
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing.generated.pp
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing.generated.pp	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,175 @@
+[
+   RegexPattern              -- KW["/"] _1 KW["/"],
+   SingleBranch              -- _1,
+   TupleBranch               -- _1 KW["|"] _2,
+   Pieces                    -- _1,
+   Pieces.1:iter             -- _1,
+   SingleAtom                -- _1,
+   QuantifiedAtom            -- _1 _2,
+   GreedyExactBound          -- KW["{"] _1 KW["}"],
+   GreedyLowerBound          -- KW["{"] _1 KW[","] KW["}"],
+   GreedyLowerUpperBound     -- KW["{"] _1 KW[","] _2 KW["}"],
+   GreedyOnceOrNot           -- KW["?"],
+   GreedyZeroOrMore          -- KW["*"],
+   GreedyOneOrMore           -- KW["+"],
+   ReluctantExactBound       -- KW["{"] _1 KW["}?"],
+   ReluctantLowerBound       -- KW["{"] _1 KW[","] KW["}?"],
+   ReluctantLowerUpperBound  -- KW["{"] _1 KW[","] _2 KW["}?"],
+   ReluctantOnceOrNot        -- KW["??"],
+   ReluctantZeroOrMore       -- KW["*?"],
+   ReluctantOneOrMore        -- KW["+?"],
+   PossessiveExactBound      -- KW["{"] _1 KW["}+"],
+   PossessiveLowerBound      -- KW["{"] _1 KW[","] KW["}+"],
+   PossessiveLowerUpperBound -- KW["{"] _1 KW[","] _2 KW["}+"],
+   PossessiveOnceOrNot       -- KW["?+"],
+   PossessiveZeroOrMore      -- KW["*+"],
+   PossessiveOneOrMore       -- KW["++"],
+   Capture                   -- KW["("] _1 KW[")"],
+   NonCapture                -- KW["(?:"] _1 KW[")"],
+   PositiveLookahead         -- KW["(?="] _1 KW[")"],
+   NegativeLookahead         -- KW["(?!"] _1 KW[")"],
+   PositiveLookbehind        -- KW["(?<="] _1 KW[")"],
+   NegativeLookbehind        -- KW["(?<!"] _1 KW[")"],
+   PythonCapture             -- KW["(?P<"] _1 KW[">"] _2 KW[")"],
+   RegexCapture              -- KW["("] _1 KW[")@{"] _2 KW["}"],
+   Empty                     -- KW["()"],
+   SingleCharacter           -- KW["."],
+   LineStart                 -- KW["^"],
+   LineEnd                   -- KW["$"],
+   CharacterClass            -- _1,
+   AtomLiteral               -- _1,
+   AtomCharacter             -- _1,
+   QuotedAtom                -- KW["\\Q"] _1 KW["\\E"],
+   BracketList               -- V  [V vs=2 [KW["["] _1] KW["]"]],
+   BracketList.1:iter        -- _1,
+   NegatedBracketList        -- V  [V vs=2 [KW["[^"] _1] KW["]"]],
+   NegatedBracketList.1:iter -- _1,
+   Range                     -- _1 KW["-"] _2,
+   Range.1:alt               -- _1 _2,
+   Range.2:alt               -- _1 _2,
+   Union                     -- _1,
+   BracketLiteral            -- _1,
+   BracketCharacter          -- _1,
+   LowerClass                -- KW["Lower"],
+   UpperClass                -- KW["Upper"],
+   ASCIIClass                -- KW["ASCII"],
+   AlphaClass                -- KW["Alpha"],
+   DigitClass                -- KW["Digit"],
+   AlnumClass                -- KW["Alnum"],
+   PunctClass                -- KW["Punct"],
+   GraphClass                -- KW["Graph"],
+   PrintClass                -- KW["Print"],
+   BlankClass                -- KW["Blank"],
+   CntrlClass                -- KW["Cntrl"],
+   XDigitClass               -- KW["XDigit"],
+   WhiteSpace                -- KW["Space"],
+   JavaIsLowerCase           -- KW["javaLowerCase"],
+   JavaIsLowerCase           -- KW["javaUpperCase"],
+   JavaIsWhitespace          -- KW["javaWhitespace"],
+   JavaIsMirrored            -- KW["javaMirrored"],
+   GreekBlock                -- KW["InGreek"],
+   UppercaseLetter           -- KW["Lu"],
+   CurrencySymbol            -- KW["Sc"],
+   DoubleQuote               -- KW["\""],
+   DoubleQuote               -- KW["\""],
+   OctalChar                 -- KW["\\0"] _1,
+   HexHexChar                -- KW["\\x"] _1,
+   DecHexChar                -- KW["\\u"] _1,
+   Tab                       -- KW["\\t"],
+   Newline                   -- KW["\\n"],
+   Return                    -- KW["\\r"],
+   Formfeed                  -- KW["\\f"],
+   Alarm                     -- KW["\\a"],
+   Escape                    -- KW["\\e"],
+   WordChar                  -- KW["\\w"],
+   NonWordChar               -- KW["\\W"],
+   WhiteSpaceChar            -- KW["\\s"],
+   NonWhiteSpaceChar         -- KW["\\S"],
+   DigitChar                 -- KW["\\d"],
+   NonDigitChar              -- KW["\\D"],
+   ControlCharacter          -- KW["\\c"] _1,
+   WordBoundry               -- KW["\\b"],
+   NonWordBoundry            -- KW["\\B"],
+   InputBeginBoundry         -- KW["\\A"],
+   PrevMatchEndBoundry       -- KW["\\G"],
+   EndInputBoundry           -- KW["\\Z"],
+   EndInputFinalBoundry      -- KW["\\z"],
+   BackReference             -- KW["\\"] _1,
+   Space                     -- KW["\\ "],
+   Tab                       -- KW["\\\t"],
+   Newline                   -- KW["\\\n"],
+   OctalChar                 -- KW["\\0"] _1,
+   HexHexChar                -- KW["\\x"] _1,
+   DecHexChar                -- KW["\\u"] _1,
+   Tab                       -- KW["\\t"],
+   Newline                   -- KW["\\n"],
+   Return                    -- KW["\\r"],
+   Formfeed                  -- KW["\\f"],
+   Alarm                     -- KW["\\a"],
+   Escape                    -- KW["\\e"],
+   WordChar                  -- KW["\\w"],
+   NonWordChar               -- KW["\\W"],
+   WhiteSpaceChar            -- KW["\\s"],
+   NonWhiteSpaceChar         -- KW["\\S"],
+   DigitChar                 -- KW["\\d"],
+   NonDigitChar              -- KW["\\D"],
+   ControlCharacter          -- KW["\\c"] _1,
+   WordBoundry               -- KW["\\b"],
+   NonWordBoundry            -- KW["\\B"],
+   InputBeginBoundry         -- KW["\\A"],
+   PrevMatchEndBoundry       -- KW["\\G"],
+   EndInputBoundry           -- KW["\\Z"],
+   EndInputFinalBoundry      -- KW["\\z"],
+   BackReference             -- KW["\\"] _1,
+   Space                     -- KW["\\ "],
+   Tab                       -- KW["\\\t"],
+   Newline                   -- KW["\\\n"],
+   Quoted                    -- KW["\\"] _1,
+   Quoted                    -- KW["\\"] _1,
+   DoubleQuote               -- KW["\""],
+   DoubleQuote               -- KW["\""],
+   RegexId                   -- _1,
+   present                   -- KW["e"] _1,
+   absent                    -- ,
+   real-con                  -- _1 KW["."] _2 _3,
+   natural                   -- _1,
+   positive                  -- KW["+"] _1,
+   negative                  -- KW["-"] _1,
+   quoted                    -- _1,
+   unquoted                  -- _1,
+   int                       -- _1,
+   real                      -- _1,
+   fun                       -- _1,
+   appl                      -- _1 KW["("] _2 KW[")"],
+   appl.2:iter-sep           -- _1 KW[","],
+   placeholder               -- KW["<"] _1 KW[">"],
+   list                      -- KW["["] _1 KW["]"],
+   list.1:iter-star-sep      -- _1 KW[","],
+   annotated                 -- _1 _2,
+   default                   -- KW["{"] _1 KW["}"],
+   default.1:iter-sep        -- _1 KW[","],
+   testsuite                 -- KW["testsuite"] _1 _2 _3,
+   testsuite.3:iter-star     -- _1,
+   topsort                   -- KW["topsort"] _1,
+   options                   -- V  [H  [KW["options"]] _1],
+   options.1:iter            -- _1,
+   option                    -- _1 _2,
+   file                      -- KW["->"] KW["file"] _1,
+   pattern                   -- KW["->"] _1,
+   wildcard                  -- KW["_"],
+   wildcardvar               -- KW["..."],
+   failure                   -- KW["fails"],
+   success                   -- KW["succeeds"],
+   file                      -- KW["file"] _1,
+   fun                       -- _1 KW["("] KW[")"],
+   name                      -- _1,
+   description               -- _1,
+   Constraints               -- _1,
+   Constraints.1:iter-sep    -- _1 KW[","],
+   NoErrors                  -- KW["no"] KW["errors"],
+   Error                     -- KW["1"] KW["error"],
+   Errors                    -- _1 KW["errors"],
+   NoWarnings                -- KW["no"] KW["warnings"],
+   Warnings                  -- _1 KW["warnings"],
+   Warning                   -- KW["1"] KW["warning"]
+]
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing.pp
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing.pp	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,2 @@
+%% Pretty printing table (see also Spoofax-Testing.generated.pp)
+[]

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing.sdf	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,169 @@
+%% Grammar for the Spoofax-Testing language
+%% By default, based on an example "entities" syntax
+module Spoofax-Testing
+
+imports Common
+imports Spoofax-Testing-String-Quotation
+imports languages/aterm/syntax/ATerms
+imports RegExp
+
+exports
+  context-free start-symbols TestSuite
+
+exports
+  sorts TestSuite TopSort Test Input Result
+  context-free syntax
+    "testsuite" Name Options Test* -> TestSuite {cons("testsuite")}
+    "topsort" Sort    -> Options {cons("topsort")}
+    "options" Option+ -> Options {cons("options")}
+    OptionValue OptionValue -> Option {cons("option")}
+
+  lexical syntax
+    ~[\ \t\n\r]+ -> OptionValue
+    "test"       -> OptionValue {reject}
+
+  lexical restrictions
+    OptionValue -/- ~[\ \t\n\r]
+
+  %% The description syntax is very ambiguous if comments are allowed around it. So, we forbid comments.
+  syntax
+    "parse" <LAYOUT?-CF> "test" <Space-LEX> <Description-CF> <LAYOUT?-CF> <Input-CF> <LAYOUT?-CF> <Result-CF> -> <Test-CF> {cons("parse-test")}
+    "parse" <LAYOUT?-CF> "test" <LAYOUT?-CF> <Input-CF> <LAYOUT?-CF> <Result-CF> -> <Test-CF>  {cons("parse-test")}
+
+  lexical syntax
+    [\ ]+ -> Space
+
+  lexical restrictions
+    Space -/- [\ ]
+
+  context-free syntax
+    "->" "file" PathName -> Result {cons("file")}
+    "->" ATerm           -> Result {cons("pattern")}
+    "_"                  -> ATerm  {cons("wildcard")}
+    "..."                -> { ATerm ","}+ {cons("wildcardvar")}
+
+    "fails"    -> Result {cons("failure")}
+    "succeeds" -> Result {cons("success")}
+
+    "file" PathName -> Input {cons("file")}
+
+  %% allow unquoted upper case AFuns
+  lexical syntax
+    "" -> IdCon {cons("empty")}
+
+  %% empty is ok, but cannot be a complete ATerm.
+  context-free syntax
+    ""-> ATerm {reject}
+
+  %% allow function applications without arguments
+  context-free syntax
+    fun:AFun "(" ")" -> ATerm {cons("fun")}
+
+  context-free syntax
+  	StringQuotation -> Input
+  	
+  sorts
+  syntax
+    <DQuote1-LEX> <InputChars1-LEX> <DQuote1-LEX> -> <Input-CF> {cons("string")}
+    <DQuote2-LEX> <InputChars2-LEX> <DQuote2-LEX> -> <Input-CF> {cons("string")}
+    <DQuote3-LEX> <InputChars3-LEX> <DQuote3-LEX> -> <Input-CF> {cons("string")}
+    <DQuote4-LEX> <InputChars4-LEX> <DQuote4-LEX> -> <Input-CF> {cons("string")}
+
+    <Bracket1-LEX> <InputChars21-LEX> <CloseBracket1-LEX> -> <Input-CF> {cons("string")}
+    <Bracket2-LEX> <InputChars22-LEX> <CloseBracket2-LEX> -> <Input-CF> {cons("string")}
+    <Bracket3-LEX> <InputChars23-LEX> <CloseBracket3-LEX> -> <Input-CF> {cons("string")}
+    <Bracket4-LEX> <InputChars24-LEX> <CloseBracket4-LEX> -> <Input-CF> {cons("string")}
+
+  sorts Name Description
+  context-free syntax
+    EOLString -> Name {cons("name")}
+    EOLString -> Description {cons("description")}
+
+  sorts Sort EOLString
+  lexical syntax
+    [A-Z]                          -> Sort
+    [A-Z][A-Za-z0-9\-]*[A-Za-z0-9] -> Sort
+
+    ~[\n]+ -> EOLString
+
+  sorts
+    InputChars1 InputChars2 InputChars3 InputChars4
+    DQuote1 DQuote2 DQuote3
+    InputChars21 InputChars22 InputChars23 InputChars24
+    Bracket1 Bracket2 Bracket3
+
+  lexical syntax
+    ~[\"]* -> InputChars1
+    (~[\"]  | DQuote1)*                      -> InputChars2
+    (~[\"]  | DQuote1 | DQuote2)*            -> InputChars3
+    (~[\"]  | DQuote1 | DQuote2 | DQuote3 )* -> InputChars4
+
+    "\""       -> DQuote1
+    "\"\""     -> DQuote2
+    "\"\"\""   -> DQuote3
+    "\"\"\"\"" -> DQuote4
+
+    ~[\[]* -> InputChars21
+    (~[\[]  | Bracket1)*                        -> InputChars22
+    (~[\[]  | Bracket1 | Bracket2)*             -> InputChars23
+    (~[\[]  | Bracket1 | Bracket2 | Bracket3 )* -> InputChars24
+
+    "["    -> Bracket1
+    "[["   -> Bracket2
+    "[[["  -> Bracket3
+    "[[[[" -> Bracket4
+
+    "]"    -> CloseBracket1
+    "]]"   -> CloseBracket2
+    "]]]"  -> CloseBracket3
+    "]]]]" -> CloseBracket4
+
+  sorts PathName
+  lexical syntax
+    [A-Za-z0-9\-\_\.\\\/]+ -> PathName
+
+  lexical restrictions
+    Sort      -/- [A-Za-z0-9\-]
+    EOLString -/- ~[\n]
+
+    DQuote1   -/- [\"]
+    DQuote2   -/- [\"]
+    DQuote3   -/- [\"]
+
+    Bracket1   -/- [\[]
+    Bracket2   -/- [\[]
+    Bracket3   -/- [\[]
+
+  sorts ShortCom LongCom CommChar Asterisk Eof
+  lexical syntax
+    "//" ~[\n]* ([\n] | Eof) -> ShortCom
+    "/*" CommChar* "*/"      -> LongCom
+                             -> Eof
+    
+    ~[\*]      -> CommChar
+
+    "*"        -> Asterisk
+    Asterisk   -> CommChar
+
+  lexical restrictions
+    Asterisk -/- [\/]
+
+  lexical syntax
+    ShortCom    -> LAYOUT
+    LongCom     -> LAYOUT
+
+  syntax
+    "editor" <LAYOUT?-CF> "test" <Space-LEX> <Description-CF> <LAYOUT?-CF> <Input-CF> <LAYOUT?-CF> <EditorResults-CF> -> <Test-CF> {cons("editor-test")}
+    
+  context-free syntax 
+    {Constraint ","}+ -> EditorResults {cons("Constraints")}
+
+    "no" "errors"     -> Constraint    {cons("NoErrors")} 
+    "1" "error"       -> Constraint    {cons("Error")}
+    INT "errors"      -> Constraint    {cons("Errors")}
+    
+    "no" "warnings"   -> Constraint    {cons("NoWarnings")} 
+    INT "warnings"    -> Constraint    {cons("Warnings")}
+    "1" "warning"     -> Constraint    {cons("Warning")}
+    
+    RegexExp          -> Constraint

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/ASCII.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/ASCII.sdf	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,25 @@
+module basic/ASCII
+
+imports basic/Strings
+	basic/Integers
+
+exports 
+
+context-free syntax
+
+ascii-val(String)  -> Integer
+
+hiddens
+
+imports basic/Comments
+
+context-free start-symbols
+  Integer
+
+variables
+"string" -> String
+"char+"[0-9\']* -> CHAR+
+"char*"[0-9\']* -> CHAR*
+"char"[0-9\']* -> CHAR
+
+

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Areas.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Areas.sdf	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,41 @@
+module basic/Areas
+
+imports basic/NatCon
+
+exports
+
+sorts Area
+context-free syntax
+  %% Areas describe the boundaries of substrings in files in a one dimensional
+  %% fashion, but taking newlines into account. The begin-line, begin-column
+  %% are styled after the UNIX standard. We offer both line-column and 
+  %% offset-length representations because neither representation can be 
+  %% computed from the other without the original file.
+
+  %% All characters, including tabs and newlines, are counted as one character.
+  %% Positions are calculated based on the original file, not as the file is
+  %% displayed on screen. The '\n' character increases the line and returns
+  %% the column position to 0.
+
+  %% begin-line: the first line in a file is 1
+  %% begin-column: the first column on a line is 0
+  %% end-line: line on which the end-column occurs
+  %% end-column: first column beyond last character
+
+  %% Example: describing the area starting at T of "This" up to and including 
+  %% R of "constructoR"
+
+  %%  0123456789012345
+  %% 1  This is an
+  %% 2area constructoR
+  %%       
+  %%  area(1,2,2,16,2,26)
+
+  "area" "("
+    begin-line:NatCon "," 
+    begin-column:NatCon ","
+    end-line:NatCon ","
+    end-column:NatCon ","
+    offset:NatCon ","
+    length:NatCon ")"
+  -> Area {cons("area")}

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/BoolCon.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/BoolCon.sdf	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,13 @@
+module basic/BoolCon
+
+exports
+
+sorts BoolCon 
+context-free syntax
+
+    "true"  -> BoolCon {cons("true")}
+    "false" -> BoolCon {cons("false")}
+
+hiddens
+context-free start-symbols
+  BoolCon

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/BytesCon.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/BytesCon.sdf	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,34 @@
+module basic/BytesCon
+
+%% This modules defines the 'Byte': any character in the 0-255 range.
+%% 
+%% But.. the syntax definition is not exported. This is too prevent
+%% everything from being recognized as a byte!
+%%
+%% What IS exported are the lexical constructor functions for bytes.
+%% In this manner, we can construct bytes without having to parse them
+%% literally.
+%%
+%% Note that this module only makes sense in the context of ASF+SDF,
+%% which supports lexical constructor functions. The definition below
+%% shows some of the implementation detail of ASF. Do not try this at 
+%% home.
+
+hiddens
+  lexical syntax
+    ~[]   -> Byte  {cons("byte")}
+    Byte* -> Bytes {cons("bytes")}
+
+exports 
+  sorts Bytes Byte
+
+  context-free syntax
+   bytes(CHARS[[Byte]]*) -> CHARS[[Bytes]] {cons("bytes"),lexical-constructor}
+   byte (CHARS[[~[]]]) 	 -> CHARS[[Byte]]  {cons("byte") ,lexical-constructor}
+
+   CHARS[[Bytes]]        -> Bytes
+   CHARS[[Byte]]         -> Byte
+   CHAR                  -> CHARS[[~[]]]
+
+
+

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Colors.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Colors.sdf	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,11 @@
+module basic/Colors
+
+imports basic/NatCon
+
+exports
+
+sorts Color 
+
+context-free syntax
+
+rgb(red:NatCon, green:NatCon, blue:NatCon) -> Color {cons("rgb")}

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Comments.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Comments.sdf	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,11 @@
+module basic/Comments
+
+imports
+  basic/Whitespace
+
+exports
+  lexical syntax
+    "%%" line:~[\n]* "\n"	-> LAYOUT {cons("line"),category("Comment")}
+    "%" content:~[\%\n]+ "%"	-> LAYOUT {cons("nested"),category("Comment")}
+  context-free restrictions
+    LAYOUT? -/- [\%]

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Configuration.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Configuration.sdf	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,69 @@
+module basic/Configuration
+
+imports basic/Keys
+imports basic/Colors
+
+exports
+
+context-free start-symbols Configuration
+
+sorts TermCon NatCon StrCon
+
+sorts Configuration
+context-free syntax
+  "configuration" "(" "[" list:{Property ","}* "]" ")" -> Configuration {cons("configuration")} 
+
+sorts Property
+context-free syntax
+  "import" "(" path:StrCon ")" -> Property {cons("import")}
+  "load-script" "(" path:StrCon ")" -> Property {cons("script")}
+  "script-path" "(" path:StrCon ")" -> Property {cons("script-path")}
+
+  "action" "(" "[" list:{ActionDescription ","}* "]" "," action:StrCon ")" -> Property {cons("action")}
+  "extension" "(" language:StrCon "," extension:StrCon ")" -> Property {cons("extension")}
+  "library-path" "(" label:StrCon "," path:StrCon ")" -> Property {cons("library-path")}
+  "module-path" "(" label:StrCon "," path:StrCon ")" -> Property {cons("module-path")}
+  "text-category" "(" category:TextCategoryName "," "[" map:{TextAttribute ","}* "]" ")" -> Property {cons("text-category")}
+
+sorts ActionDescription
+context-free syntax
+  "description" "(" context:TermCon "," event:Event ")" -> ActionDescription {cons("description")}
+
+sorts Event
+context-free syntax
+  "popup" -> Event {cons("popup")}
+  "click" "(" "[" list:{KeyModifier ","}* "]" "," button:VirtualButton ")" -> Event {cons("click")}
+
+  "icon" "(" title:StrCon "," path:StrCon ")" -> Event {cons("icon")}
+  "menu" "(" "[" labels:{Item ","}* "]" "," info:StrCon ")" -> Event {cons("menu")}
+  "menu-shortcut" "(" "[" labels:{Item ","}* "]" "," shortcut:ShortCut "," info:StrCon ")" -> Event {cons("menu-shortcut")}
+
+sorts Item
+context-free syntax
+  "label" "(" name:StrCon ")" -> Item {cons("label")}
+
+sorts TextCategoryName
+context-free syntax
+  "focus" -> TextCategoryName {cons("focus")}
+  "selection" -> TextCategoryName {cons("selection")}
+  "normal" -> TextCategoryName {cons("normal")}
+  "extern" "(" name:StrCon ")" -> TextCategoryName {cons("extern")}
+
+sorts TextAttribute
+context-free syntax
+  "foreground-color" "(" color:Color ")" -> TextAttribute {cons("foreground-color")}
+  "background-color" "(" color:Color ")" -> TextAttribute {cons("background-color")}
+  "style" "(" style:TextStyle ")" -> TextAttribute {cons("style")}
+  "font" "(" name:StrCon ")" -> TextAttribute {cons("font")}
+  "size" "(" point:NatCon ")" -> TextAttribute {cons("size")}
+
+sorts ShortCut
+context-free syntax
+  "shortcut" "(" "[" list:{KeyModifier ","}* "]" "," key:VirtualKey ")" -> ShortCut {cons("shortcut")}
+
+sorts TextStyle
+context-free syntax
+  "bold" -> TextStyle {cons("bold")}
+  "italics" -> TextStyle {cons("italics")}
+  "underlined" -> TextStyle {cons("underlined")}
+

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Errors.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Errors.sdf	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,39 @@
+module basic/Errors
+
+imports basic/Locations
+imports basic/StrCon
+
+hiddens
+  context-free start-symbols
+    Summary Error
+
+exports
+
+sorts Subject
+context-free syntax
+  "subject" "(" description:StrCon ")" -> Subject {cons("subject")}
+
+  "localized" "(" description:StrCon "," Location ")"
+    -> Subject {cons("localized")}
+
+
+sorts Error
+context-free syntax
+  "info" "(" description:StrCon "," "[" {Subject ","}* "]" ")"
+    -> Error {cons("info")}
+
+  "warning" "(" description:StrCon "," "[" {Subject ","}* "]" ")"
+    -> Error {cons("warning")}
+
+  "error" "(" description:StrCon "," "[" {Subject ","}* "]" ")"
+    -> Error {cons("error")}
+
+  "fatal" "(" description:StrCon "," "[" {Subject ","}* "]" ")"
+    -> Error {cons("fatal")}
+
+
+sorts Summary
+context-free syntax
+  "summary" "(" producer:StrCon "," id:StrCon "," 
+   "[" {Error ","}* "]" ")"  -> Summary {cons("summary")}
+

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/File.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/File.sdf	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,12 @@
+module basic/File
+
+imports basic/Path
+imports basic/StrCon
+
+exports
+
+context-free start-symbols File
+
+sorts File
+context-free syntax
+  "file" "(" path:Path "," name:StrCon "," extension:StrCon ")" -> File {cons("file")}

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Graphs.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Graphs.sdf	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,62 @@
+module languages/rscript/syntaxGraph
+
+imports languages/aterm/syntax/ATerms basic/Integers basic/Strings
+
+exports
+   sorts 
+	Graph NodeList Node NodeId
+	AttributeList Attribute Color
+	Shape Style Direction EdgeList Edge Polygon Point
+
+   context-free syntax
+	graph(NodeList, EdgeList,AttributeList)		-> Graph
+	"[" {Node ","}* "]"				-> NodeList
+	node(NodeId, AttributeList)			-> Node
+	String						-> NodeId
+	"[" {Attribute ","}* "]"			-> AttributeList
+
+	bounding-box(Point, Point)			-> Attribute
+	color(Color)					-> Attribute
+	curve-points(Polygon)				-> Attribute
+	direction(Direction)				-> Attribute
+	fill-color(Color)				-> Attribute
+	info(String, ATerm)				-> Attribute	
+	label(String)					-> Attribute
+	location(Integer,Integer)			-> Attribute
+	shape(Shape)					-> Attribute
+	size(Integer, Integer)				-> Attribute
+	style(Style)					-> Attribute
+
+	rgb(Integer, Integer, Integer)			-> Color
+
+	"bold"						-> Style
+	"dashed"					-> Style
+	"dotted"					-> Style
+	"filled"					-> Style
+	"invisible"					-> Style
+	"solid"						-> Style
+
+	"box"						-> Shape
+	"circle"					-> Shape
+	"diamond"					-> Shape
+	"egg"						-> Shape
+	"ellipse"					-> Shape
+	"hexagon"					-> Shape
+	"house"						-> Shape
+	"octagon"					-> Shape
+	"parallelogram"					-> Shape	
+	"plaintext"					-> Shape
+	"trapezium"					-> Shape
+	"triangle"					-> Shape
+
+	"forward"					-> Direction
+	"back"						-> Direction
+	"both"						-> Direction
+	"none"						-> Direction
+
+	"[" {Edge ","}*	"]"				-> EdgeList
+	edge(NodeId, NodeId, AttributeList)		-> Edge
+
+	"[" {Point ","}* "]"				-> Polygon
+	point(Integer, Integer)				-> Point
+		

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/IdentifierCon.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/IdentifierCon.sdf	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,14 @@
+module basic/IdentifierCon
+
+exports
+
+sorts IdCon
+
+lexical syntax
+
+head:[A-Za-z] tail:[A-Za-z\-0-9]* -> IdCon {cons("default")}
+
+lexical restrictions
+
+IdCon -/- [A-Za-z\-0-9]
+

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/IntCon.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/IntCon.sdf	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,17 @@
+module basic/IntCon
+
+imports basic/NatCon
+exports
+
+sorts Integer
+
+context-free syntax
+	NatCon -> Integer {cons("nat-con")}
+	"+" integer:Integer -> Integer {non-assoc, cons("positive")}
+	"-" integer:Integer -> Integer {non-assoc, cons("negative")}
+
+context-free priorities
+  {non-assoc:
+    "+" integer:Integer -> Integer {non-assoc, cons("positive")}
+    "-" integer:Integer -> Integer {non-assoc, cons("negative")}
+  }

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Keys.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Keys.sdf	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,118 @@
+module basic/Keys
+
+exports
+
+sorts VirtualButton
+context-free syntax
+"NOBUTTON" -> VirtualButton {cons("NOBUTTON")}
+"BUTTON1" -> VirtualButton {cons("BUTTON1")}
+"BUTTON2" -> VirtualButton {cons("BUTTON2")}
+"BUTTON3" -> VirtualButton {cons("BUTTON3")}
+
+sorts KeyModifier
+context-free syntax
+"M_ALT" -> KeyModifier {cons("M_ALT")}
+"M_CTRL" -> KeyModifier {cons("M_CTRL")}
+"M_SHIFT" -> KeyModifier {cons("M_SHIFT")}
+
+sorts VirtualKey
+context-free syntax
+"VK_0" -> VirtualKey {cons("VK_0")}
+"VK_1" -> VirtualKey {cons("VK_1")}
+"VK_2" -> VirtualKey {cons("VK_2")}
+"VK_3" -> VirtualKey {cons("VK_3")}
+"VK_4" -> VirtualKey {cons("VK_4")}
+"VK_5" -> VirtualKey {cons("VK_5")}
+"VK_6" -> VirtualKey {cons("VK_6")}
+"VK_7" -> VirtualKey {cons("VK_7")}
+"VK_8" -> VirtualKey {cons("VK_8")}
+"VK_9" -> VirtualKey {cons("VK_9")}
+"VK_A" -> VirtualKey {cons("VK_A")}
+"VK_B" -> VirtualKey {cons("VK_B")}
+"VK_C" -> VirtualKey {cons("VK_C")}
+"VK_D" -> VirtualKey {cons("VK_D")}
+"VK_E" -> VirtualKey {cons("VK_E")}
+"VK_F" -> VirtualKey {cons("VK_F")}
+"VK_G" -> VirtualKey {cons("VK_G")}
+"VK_H" -> VirtualKey {cons("VK_H")}
+"VK_I" -> VirtualKey {cons("VK_I")}
+"VK_J" -> VirtualKey {cons("VK_J")}
+"VK_K" -> VirtualKey {cons("VK_K")}
+"VK_L" -> VirtualKey {cons("VK_L")}
+"VK_M" -> VirtualKey {cons("VK_M")}
+"VK_N" -> VirtualKey {cons("VK_N")}
+"VK_O" -> VirtualKey {cons("VK_O")}
+"VK_P" -> VirtualKey {cons("VK_P")}
+"VK_Q" -> VirtualKey {cons("VK_Q")}
+"VK_R" -> VirtualKey {cons("VK_R")}
+"VK_S" -> VirtualKey {cons("VK_S")}
+"VK_T" -> VirtualKey {cons("VK_T")}
+"VK_U" -> VirtualKey {cons("VK_U")}
+"VK_V" -> VirtualKey {cons("VK_V")}
+"VK_W" -> VirtualKey {cons("VK_W")}
+"VK_X" -> VirtualKey {cons("VK_X")}
+"VK_Y" -> VirtualKey {cons("VK_Y")}
+"VK_Z" -> VirtualKey {cons("VK_Z")}
+"VK_AMPERSAND" -> VirtualKey {cons("VK_AMPERSAND")}
+"VK_ASTERISK" -> VirtualKey {cons("VK_ASTERISK")}
+"VK_AT" -> VirtualKey {cons("VK_AT")}
+"VK_BACK_QUOTE" -> VirtualKey {cons("VK_BACK_QUOTE")}
+"VK_BACK_SLASH" -> VirtualKey {cons("VK_BACK_SLASH")}
+"VK_BACK_SPACE" -> VirtualKey {cons("VK_BACK_SPACE")}
+"VK_BEGIN" -> VirtualKey {cons("VK_BEGIN")}
+"VK_BRACE_LEFT" -> VirtualKey {cons("VK_BRACE_LEFT")}
+"VK_BRACE_RIGHT" -> VirtualKey {cons("VK_BRACE_RIGHT")}
+"VK_CIRCUMFLEX" -> VirtualKey {cons("VK_CIRCUMFLEX")}
+"VK_CLEAR" -> VirtualKey {cons("VK_CLEAR")}
+"VK_CLOSE_BRACKET" -> VirtualKey {cons("VK_CLOSE_BRACKET")}
+"VK_COLON" -> VirtualKey {cons("VK_COLON")}
+"VK_COMMA" -> VirtualKey {cons("VK_COMMA")}
+"VK_DECIMAL" -> VirtualKey {cons("VK_DECIMAL")}
+"VK_DELETE" -> VirtualKey {cons("VK_DELETE")}
+"VK_DIVIDE" -> VirtualKey {cons("VK_DIVIDE")}
+"VK_DOLLAR" -> VirtualKey {cons("VK_DOLLAR")}
+"VK_DOWN" -> VirtualKey {cons("VK_DOWN")}
+"VK_END" -> VirtualKey {cons("VK_END")}
+"VK_ENTER" -> VirtualKey {cons("VK_ENTER")}
+"VK_EQUALS" -> VirtualKey {cons("VK_EQUALS")}
+"VK_ESCAPE" -> VirtualKey {cons("VK_ESCAPE")}
+"VK_EXCLAMATION_MARK" -> VirtualKey {cons("VK_EXCLAMATION_MARK")}
+"VK_F1" -> VirtualKey {cons("VK_F1")}
+"VK_F2" -> VirtualKey {cons("VK_F2")}
+"VK_F3" -> VirtualKey {cons("VK_F3")}
+"VK_F4" -> VirtualKey {cons("VK_F4")}
+"VK_F5" -> VirtualKey {cons("VK_F5")}
+"VK_F6" -> VirtualKey {cons("VK_F6")}
+"VK_F7" -> VirtualKey {cons("VK_F7")}
+"VK_F8" -> VirtualKey {cons("VK_F8")}
+"VK_F9" -> VirtualKey {cons("VK_F9")}
+"VK_F10" -> VirtualKey {cons("VK_F10")}
+"VK_F11" -> VirtualKey {cons("VK_F11")}
+"VK_F12" -> VirtualKey {cons("VK_F12")}
+"VK_GREATER" -> VirtualKey {cons("VK_GREATER")}
+"VK_HOME" -> VirtualKey {cons("VK_HOME")}
+"VK_INSERT" -> VirtualKey {cons("VK_INSERT")}
+"VK_LEFT" -> VirtualKey {cons("VK_LEFT")}
+"VK_LEFT_PARENTHESIS" -> VirtualKey {cons("VK_LEFT_PARENTHESIS")}
+"VK_MINUS" -> VirtualKey {cons("VK_MINUS")}
+"VK_MULTIPLY" -> VirtualKey {cons("VK_MULTIPLY")}
+"VK_NUMBER_SIGN" -> VirtualKey {cons("VK_NUMBER_SIGN")}
+"VK_OPEN_BRACKET" -> VirtualKey {cons("VK_OPEN_BRACKET")}
+"VK_PAGE_DOWN" -> VirtualKey {cons("VK_PAGE_DOWN")}
+"VK_PAGE_UP" -> VirtualKey {cons("VK_PAGE_UP")}
+"VK_PAUSE" -> VirtualKey {cons("VK_PAUSE")}
+"VK_PERIOD" -> VirtualKey {cons("VK_PERIOD")}
+"VK_PLUS" -> VirtualKey {cons("VK_PLUS")}
+"VK_PRINTSCREEN" -> VirtualKey {cons("VK_PRINTSCREEN")}
+"VK_QUOTE" -> VirtualKey {cons("VK_QUOTE")}
+"VK_QUOTEDBL" -> VirtualKey {cons("VK_QUOTEDBL")}
+"VK_RIGHT" -> VirtualKey {cons("VK_RIGHT")}
+"VK_RIGHT_PARENTHESIS" -> VirtualKey {cons("VK_RIGHT_PARENTHESIS")}
+"VK_SEMICOLON" -> VirtualKey {cons("VK_SEMICOLON")}
+"VK_SLASH" -> VirtualKey {cons("VK_SLASH")}
+"VK_SPACE" -> VirtualKey {cons("VK_SPACE")}
+"VK_SUBTRACT" -> VirtualKey {cons("VK_SUBTRACT")}
+"VK_TAB" -> VirtualKey {cons("VK_TAB")}
+"VK_UNDERSCORE" -> VirtualKey {cons("VK_UNDERSCORE")}
+"VK_UP" -> VirtualKey {cons("VK_UP")}
+

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Locations.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Locations.sdf	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,16 @@
+module basic/Locations
+
+imports basic/Areas
+imports basic/StrCon
+
+exports
+
+sorts Location
+context-free syntax
+
+  "file" "(" filename:StrCon ")" -> Location {cons("file")}
+
+  a:"area" "(" Area ")" -> Location {cons("area")}
+
+  "area-in-file" "(" filename:StrCon "," Area ")"
+    -> Location {cons("area-in-file")}

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Modules.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Modules.sdf	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,51 @@
+module basic/Modules
+
+imports basic/NatCon
+
+exports
+
+context-free start-symbols Module
+
+sorts TermCon
+
+sorts Modules
+context-free syntax
+  "modules" "(" "[" {Module ","}* "]"")" -> Modules {const("modules")}
+
+sorts Module 
+context-free syntax
+  %% A module constists of an identifier and optional attributes
+  "module" "(" id:ModuleId "," "[" store:{Attribute ","}* "]"")" -> Module {cons("module")}
+
+sorts ModuleId
+context-free syntax
+  %% An module-id is defined by a unique natcon
+  "mid" "(" id:NatCon ")" -> ModuleId {cons("mid")}
+
+sorts Attribute
+context-free syntax
+  %% An attribute consists of a namespace and a list of table-entries
+  "attribute" "(" namespace:TermCon "," "[" table:{TableEntry ","}* "]" ")" -> Attribute {cons("attribute")}
+
+sorts TableEntry
+context-free syntax
+  %% table-entry pairs are key-value pairs of TermCons
+  "table-entry" "(" key:TermCon "," value:TermCon ")" -> TableEntry {cons("table-entry")}
+
+sorts Dependencies
+context-free syntax
+  %% List of dependencies
+  "dependencies" "(" "[" {Dependency ","}* "]" ")" -> Dependencies {cons("dependencies")}
+
+sorts Dependency
+context-free syntax
+  %% A module depends on zero or more module-id
+  "dependency" "(" from:ModuleId "," list:{ModuleId ","}*")" -> Dependency {cons("dependency")}
+
+sorts AttributeMap
+context-free syntax
+  "attribute-map" "(" "[" {ModuleAttribute ","}* "]" ")" -> AttributeMap {cons("attribute-map")}
+
+sorts ModuleAttribute
+context-free syntax
+  "module-attribute" "(" id:ModuleId "," attribute:TermCon ")" -> ModuleAttribute {cons("module-attribute")}

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/NatCon.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/NatCon.sdf	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,14 @@
+module basic/NatCon
+
+exports
+
+sorts NatCon
+
+lexical syntax
+  
+ [0-9]+ -> NatCon {cons("digits")}
+
+lexical restrictions
+
+ NatCon -/- [0-9]
+

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/ParsetreeCon.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/ParsetreeCon.sdf	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,18 @@
+module basic/ParsetreeCon[X]
+
+imports basic/BytesCon
+imports basic/NatCon
+imports basic/Errors
+
+exports 
+
+context-free syntax
+
+  "parse-tree" "(" left-layout:Bytes  "," 
+                   tree:X             "," 
+                   right-layout:Bytes ","
+                   amb-cnt:NatCon
+               ")"                   -> Parsetree[[X]] {cons("success")}
+
+  "parse-error" "(" Summary ")"      -> Parsetree[[X]] {cons("failure")}
+ 

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Path.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Path.sdf	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,20 @@
+module basic/Path
+
+imports basic/StrCon
+
+exports
+
+context-free start-symbols Path
+
+sorts TermCon
+
+sorts Path
+context-free syntax
+  %% A path consists of a number of segments
+  "absolute" "(" "[" {Segment ","}* "]" ")" -> Path {cons("absolute")}
+
+  "relative" "(" "[" {Segment ","}* "]" ")" -> Path {cons("relative")}
+
+sorts Segment
+context-free syntax
+  "segment" "(" name:StrCon ")" -> Segment {cons("segment")}

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/RStores.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/RStores.sdf	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,42 @@
+module basic/RStores
+
+imports basic/StrCon
+imports basic/IntCon
+imports basic/BoolCon
+imports basic/Locations
+imports basic/IdentifierCon
+
+exports 
+sorts RElem RStore RType RTuple
+
+%% This module defines a syntax for stores of typed relations
+
+context-free syntax
+	Integer -> RElem {cons("int")}
+	StrCon -> RElem {cons("str")}
+	BoolCon -> RElem {cons("bool")}
+	Location -> RElem {cons("loc")}
+
+	"{" elements:{RElem ","}* "}" -> RElem {cons("set")}
+	"{|" elements:{RElem ","}* "|}" -> RElem {cons("bag")}
+	"<" elements:{RElem ","}+ ">" -> RElem {cons("tuple")}	
+	"int" -> RType {cons("int")}
+	"bool" -> RType {cons("bool")}
+	"str" -> RType {cons("str")}
+	"loc" -> RType {cons("loc")}
+
+	"<" column-types:{RType ","}+ ">" -> RType {cons("tuple")}	
+	"set" "[" element-type:RType  "]" -> RType {cons("set")}
+	"bag" "[" element-type:RType  "]" -> RType {cons("bag")}
+	"rel" "[" column-types:{RType ","}+ "]" -> RType {cons("relation")}
+	type-name:IdCon  -> RType {cons("user-defined")} 
+	"&" parameter-name:IdCon -> RType {cons("parameter")}                            
+
+	"<" variable:IdCon "," rtype:RType "," value:RElem ">" -> RTuple {cons("rtuple")}
+	 "rstore" "(" "[" rtuples:{ RTuple ","}* "]" ")" -> RStore {cons("rstore")}
+
+hiddens
+context-free start-symbols	
+		RStore
+
+

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/ReadWriteCon.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/ReadWriteCon.sdf	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,16 @@
+module basic/ReadWriteCon
+
+imports basic/BytesCon
+imports basic/Errors
+
+exports 
+
+sorts Read Write
+
+context-free syntax
+
+  "read" "(" value:Bytes ")"    -> Read  {cons("success")}
+  "read-error" "(" Summary ")"  -> Read  {cons("failure")}
+
+  "written"                     -> Write {cons("success")}
+  "write-error" "(" Summary ")" -> Write {cons("failure")}

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Shortcut.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Shortcut.sdf	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,11 @@
+module basic/Shortcut
+
+imports basic/Keys
+
+exports
+
+context-free start-symbols Shortcut
+
+sorts Shortcut
+context-free syntax
+  "shortcut" "(" Mask "," Key ")" -> Shortcut {cons("shortcut")}

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Slices.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Slices.sdf	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,12 @@
+module basic/Slices
+
+imports basic/Areas
+imports basic/StrCon
+
+exports
+
+sorts Slice
+
+context-free syntax
+
+"slice" "(" id:StrCon "," "[" areas:{Area","}* "]" ")" -> Slice {cons("slice")}

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/StrCon.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/StrCon.sdf	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,15 @@
+module basic/StrCon
+
+exports
+
+sorts StrCon StrChar
+
+lexical syntax
+    "\\n"                      -> StrChar {cons("newline")}
+    "\\t"                      -> StrChar {cons("tab")}
+    "\\\""                     -> StrChar {cons("quote")}
+    "\\\\"                     -> StrChar {cons("backslash")}
+    "\\" a:[0-9]b:[0-9]c:[0-9] -> StrChar {cons("decimal")}
+    ~[\0-\31\n\t\"\\]          -> StrChar {cons("normal")}
+
+    [\"] chars:StrChar* [\"]   -> StrCon  {cons("default")}

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Whitespace.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/basic/Whitespace.sdf	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,8 @@
+module basic/Whitespace
+
+exports
+  lexical syntax
+    [\ \t\n\r]	-> LAYOUT {cons("whitespace")}
+
+  context-free restrictions
+    LAYOUT? -/- [\ \t\n\r]

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/languages/aterm/syntax/ATerms.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/languages/aterm/syntax/ATerms.sdf	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,29 @@
+module languages/aterm/syntax/ATerms
+
+imports languages/aterm/syntax/IntCon 
+        languages/aterm/syntax/RealCon
+	basic/StrCon
+	basic/IdentifierCon
+
+exports
+  sorts AFun ATerm Annotation
+
+  context-free syntax
+	StrCon 	-> AFun {cons("quoted")}
+	IdCon 	-> AFun {cons("unquoted")}
+
+  context-free syntax
+	IntCon 					-> ATerm {cons("int")}
+	RealCon					-> ATerm {cons("real")}
+	fun:AFun 				-> ATerm {cons("fun")}
+	fun:AFun "(" args:{ATerm ","}+ ")" 	-> ATerm {cons("appl")}
+	"<" type:ATerm ">" 			-> ATerm {cons("placeholder")}
+	"[" elems:{ATerm ","}* "]" 		-> ATerm {cons("list")}
+	trm:ATerm Annotation 			-> ATerm {cons("annotated")}
+
+  context-free syntax
+	"{" annos:{ ATerm ","}+ "}" 		-> Annotation {cons("default")}
+
+hiddens
+  context-free start-symbols 
+    ATerm

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/languages/aterm/syntax/IntCon.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/languages/aterm/syntax/IntCon.sdf	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,15 @@
+module languages/aterm/syntax/IntCon
+
+imports basic/Whitespace
+	basic/NatCon
+
+hiddens
+  context-free start-symbols 
+    IntCon
+
+exports
+  sorts IntCon
+  context-free syntax
+    NatCon         -> IntCon {cons("natural")}
+    pos:"+" NatCon -> IntCon {cons("positive")}
+    neg:"-" NatCon -> IntCon {cons("negative")}
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/languages/aterm/syntax/RealCon.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/languages/aterm/syntax/RealCon.sdf	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,16 @@
+module languages/aterm/syntax/RealCon
+
+imports languages/aterm/syntax/IntCon
+
+hiddens
+  context-free start-symbols 
+    RealCon
+
+exports
+  sorts OptExp RealCon
+
+  context-free syntax
+    "e" IntCon -> OptExp {cons("present")}
+               -> OptExp {cons("absent")}
+
+    base:IntCon "." decimal:NatCon exp:OptExp  -> RealCon {cons("real-con")}
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/test.aterm
==============================================================================

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/test/asd.aterm
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/test/asd.aterm	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,10 @@
+testsuite(
+  name("ASD")
+, topsort("TypeDec")
+, [parse-test(
+     " "
+   , description("rob is gek")
+   , string("\"", "asd", "\"")
+   , failure()
+   )]
+)

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/test/asd2.aterm
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/test/asd2.aterm	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,10 @@
+testsuite(
+  name("ASD123")
+, topsort("TypeDec")
+, [parse-test(
+     " "
+   , description("rob is gek")
+   , string("\"", "asd", "\"")
+   , failure()
+   )]
+)
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/test/asd3.aterm
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/test/asd3.aterm	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,10 @@
+testsuite(
+  name("ASD123")
+, topsort("TypeDec")
+, [parse-test(
+     " "
+   , description("rob is gek")
+   , string("\"", "asd", "\"")
+   , failure()
+   )]
+)
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/test/example2.aterm
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/test/example2.aterm	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,11 @@
+testsuite(
+  name("ASD")
+, topsort("TypeDec")
+, [ parse-test(
+      " "
+    , description("rob is gek")
+    , string("\"", "asd", "\"")
+    , file("./test.spt")
+    )
+  ]
+)
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/test/example2.spt
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/test/example2.spt	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,4 @@
+testsuite ASD
+    topsort TypeDec
+    parse test rob is gek
+      "asd" fails
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/test/test.aterm
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/test/test.aterm	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1 @@
+file("./asd2.aterm")
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/test/test.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/test/test.java	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1 @@
+("editor/java/tests/Comments", "package tests;\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\n       class Comments {\n       \t    @Test\n       \t    public void test1() {\n       \t    \tassertEquals(5,4);\n       \t    } \n       }\n")
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/test/test.spt
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/test/test.spt	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,61 @@
+testsuite testsuites
+topsort TestSuite
+
+parse test testsuite (1)
+  ""
+    testsuite ASD
+    topsort TypeDec
+    parse test rob is gek
+       "asd" fails 
+  "" -> testsuite( name("ASD"), _, _)
+  
+parse test missing topsort
+  ""
+    testsuite ASD
+    parse test rob is gek
+      "asd" fails 
+  "" fails
+
+parse test file input test (self) (1)
+  file ./test.spt succeeds
+
+parse test file input test (2) 
+  file ./example2.spt succeeds
+ 
+parse test test 1
+  ""
+    testsuite ASD
+    topsort TypeDec
+    parse test rob is gek
+      "asd" fails 
+  "" -> file ./asd.aterm
+
+parse test test 2
+  ""
+    testsuite ASD123
+    topsort TypeDec
+    parse test rob is gek
+      "asd" fails 
+  "" -> file ./asd3.aterm
+
+/*
+
+editor test simple testsuite editor test (1)
+
+  ""
+    testsuite ASD
+    topsort TypeDec
+    parse test rob is gek
+      "asd" fails 
+  "" no errors, no warnings
+  
+editor test simple testsuite editor test (2)
+  ""
+    testsuite ASD
+    topsort TypeDec
+  ""  
+  no errors, 1 warning, /no tests in/
+
+*/
+
+ 
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/ATerms.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/ATerms.str	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,36 @@
+module ATerms
+
+signature
+  constructors
+    default     : List(ATerm) -> Annotation
+    annotated   : ATerm * Annotation -> ATerm
+    list        : List(ATerm) -> ATerm
+    placeholder : ATerm -> ATerm
+    appl        : AFun * List(ATerm) -> ATerm
+    fun         : AFun -> ATerm
+    real        : RealCon -> ATerm
+    int         : IntCon -> ATerm
+    unquoted    : IdCon -> AFun
+    quoted      : StrCon -> AFun
+                : String -> IdCon
+                : String -> StrCon
+    real-con    : IntCon * NatCon * OptExp -> RealCon
+    absent      : OptExp
+    present     : IntCon -> OptExp
+    negative    : NatCon -> IntCon
+    positive    : NatCon -> IntCon
+    natural     : NatCon -> IntCon
+                : String -> NatCon
+
+
+signature
+  constructors
+    Some : a -> Option(a)
+    None : Option(a)
+
+
+signature
+  constructors
+    Cons : a * List(a) -> List(a)
+    Nil  : List(a)
+    Conc : List(a) * List(a) -> List(a)

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/analysis.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/analysis.str	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,65 @@
+module analysis
+imports
+  libstratego-lib
+  libstratego-sglr
+  libstratego-sdf
+  include/Spoofax-Testing
+  lib/editor-common.generated
+
+strategies
+
+  record-all-sdfs =
+    record-all(record-sdf) 
+
+  record-all(s) =
+    <readdir> ".";
+    list-loop(
+      if <isdir> <filemode> then
+        chdir;
+        record-all(s);
+        <chdir> ".."
+      else
+        try(s)
+      end
+    )
+
+  record-sdf:
+    filename -> filename
+    where 
+      <has-extension(|"sdf")> filename;
+      <open-import(abspath, parse-sdf-module-file, topdown(try(record-constructs)))> filename
+
+  record-sdf:
+    filename -> filename
+    where 
+      <has-extension(|"def")> filename; 
+      <open-import(abspath, parse-sdf-definition-file, topdown(try(record-constructs)))> filename
+
+  record-constructs = record-start-symbol + record-prod + record-cons
+
+  record-prod:
+    prod @ prod(lhs, sort, attrs) -> <id>
+    where
+      !sort;
+      try(?cf(<id>) + ?lex(<id>));
+      repeat(?label(_, <id>));
+      (?sort(x) + ?parameterized-sort(x, _))
+    with
+      rules(
+        SortDeclaration   :  x -> x
+        SortProductionLHS :+ x -> lhs
+      )
+  record-cons: 
+    term(cons(x)) -> <id>
+    with 
+      rules(
+        Constructor : x -> x  
+      )
+      
+  record-start-symbol:
+    context-free-start-symbols(ss) -> <id>
+    where 
+      <map({s: ?sort(s); rules( TopSort : s -> s)})>ss
+      
+       
+        
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/aterm-eq.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/aterm-eq.str	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,95 @@
+/**
+ * Tests explodes ATerms for equivalence with wildcards.
+ *
+ * @author  Martin Bravenboer <martin.bravenboer at gmail.com>
+ */
+module aterm-eq
+imports
+  ATerms
+  include/Spoofax-Testing
+  libstratego-aterm
+
+strategies
+
+  aterm-eq(|p) =
+    <aterm-eq>(<explode-aterm>,<read-from-string>p)
+
+  aterm-eq =
+    rec x(
+        list-term-eq(x)
+    +    int-term-eq(x)
+    +    fun-term-eq(x)
+    +   appl-term-eq(x)
+    +        afun-eq(x)
+    +    wildcard-eq(x)
+    + wildcardvar-eq(x)
+    )
+
+rules
+
+  /**
+   * Wildcard
+   */
+  wildcard-eq(x) =
+    (id, wildcard())
+
+  wildcard-eq(x) =
+    (wildcard(), id)
+
+rules
+
+  wildcardvar-eq(x) =
+    ?(list(wildcardvar()), list(_))
+
+  wildcardvar-eq(x) =
+    ?(list(_), list(wildcardvar()))
+
+  wildcardvar-eq(x) =
+    ?(appl(s1, wildcardvar()), appl(s2, _))
+    ; where(<x> (s1, s2))
+
+  wildcardvar-eq(x) =
+    ?(appl(s1, _), appl(s2, wildcardvar()))
+    ; where(<x> (s1, s2))
+
+rules
+
+  /**
+   * list
+   */
+  list-term-eq(x) =
+    ?(list(xs1), list(xs2))
+    ; where(
+        <is-list> xs1
+      ; <is-list> xs2
+      ; <zip(x)> (xs1, xs2)
+      )
+
+  /**
+   * integer
+   */
+  int-term-eq(x) =
+    ?(int(natural(s)), int(natural(s)))
+
+  /**
+   * just fun
+   */
+  fun-term-eq(x) =
+    ?(fun(a1), fun(a2))
+    ; where(<x> (a1, a2))
+
+  /**
+   * appl
+   */
+  appl-term-eq(x) =
+    ?(appl(s1, x1*), appl(s2, x2*))
+    ; where(<x> (s1, s2))
+    ; where(<zip(x)> (x1*, x2*))
+
+rules
+
+  afun-eq(x) = 
+    ?(unquoted(s), unquoted(s))
+
+  afun-eq(x) = 
+    ?(quoted(s), quoted(s))

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check.str	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,51 @@
+module check
+
+imports
+  libstratego-lib
+  include/Spoofax-Testing
+  lib/editor-common.generated
+
+rules
+
+  // Analysis: does a topdown traversal of the tree,
+  // and tries to apply the record-entity rule.
+  analyze:
+    t -> t
+    with
+      <topdown(try(record-entity))> t
+
+  // Records the definition of an entity in a dynamic rule GetEntity.
+  record-entity:
+    Entity(x, body) -> Entity(x, body)
+    with
+      // For a name 'x', GetEntity will return the original 'x' tree node
+      rules(
+        GetEntity :+ x -> x
+      )
+rules
+    
+  // Reports an error if a property type is undefined.
+  // This error is reported on the type name 'type'.
+  constraint-error:
+    Property(x, Type(type)) -> (type, $[Type [type] is not defined])
+    where
+      not(!type => "String"); // String and Int are built-in types
+      not(!type => "Int");
+      not(<GetEntity> type) // no entity for this type
+  
+  // Reports an error if an entity is defined more than once.
+  // This constraint is implemented by testing if the "bag" of
+  // all entities x is not a singleton list.
+  constraint-error:
+    Entity(x, _) -> (x, $[Duplicate entity name])
+    where
+      not(<bagof-GetEntity> x => [_])
+  
+  constraint-warning:
+    Entity(x, _) -> (x, $[Entity names must start with a capital])
+    where
+      not(<string-starts-with-capital> x)
+  
+  constraint-note:
+    Module(x @ "example", _) -> (x, $[This is just an example program in the "entities" language
+                                      (this note is defined in trans/check.str) ])

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/file-resolving.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/file-resolving.str	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,79 @@
+module file-resolving
+imports
+  libstratego-lib
+  libstratego-gpp
+  libstratego-aterm
+  include/Spoofax-Testing
+  lib/editor-common.generated
+analysis
+strategies
+
+  scope-paths(s | path, project-path) =
+    {| current-path, current-project-path: 
+       rules( 
+         current-path         := path
+         current-project-path := project-path
+       ) ; s
+    |}
+ 
+  constraint-error :
+    file(f) -> (<id>, $[File '[f]' does not exist.])
+    where 
+      path := <current-path>
+    ; <resolve-path(|path)> f
+    ; not(file-exists)
+
+  resolve-path(|basepath) =
+    ?p
+  ; if <is-abspath>p then 
+        imp := p
+      else 
+        imp := <concat-strings> [ <abspath ; dirname>basepath, "/", p ] 
+      end 
+
+  editor-resolve:
+    (file(f), position, ast, path, project-path) ->  <resolve-path(|path); open-editor>f
+
+  external open-editor(|)
+
+  editor-complete:
+    (unquoted(COMPLETION(_)), _, _, _, _) -> proposals
+    where  
+      proposals := <all-keys-Constructor; string-sort>
+
+  editor-complete:
+    (topsort(COMPLETION(s)), _, _, _, _) -> proposals
+    where 
+      proposals := <all-keys-TopSort ; string-sort>
+
+  editor-complete:
+    (node, position, ast, path, project-path) -> proposals
+    where 
+      {| current-path, current-project-path: 
+        rules( 
+          current-path         := path
+          current-project-path := project-path
+        ) ;
+        proposals := <propose-completion <+ ![]> node
+      |}
+
+  propose-completion :
+    file(COMPLETION(s)) -> <complete-file(|s)> 
+ 
+  complete-file(|s) =
+    file := <base-filename <+ !"">s
+  ; dir  := <dirname>s
+  ; abs  := <resolve-path(|<current-path>)>dir 
+  ; readdir 
+  ; filter( 
+      where(string-starts-with(|file)) 
+    ; if !"/" => dir then 
+        <concat-strings>["/", <id>] 
+      else 
+        <concat-strings>[dir, "/", <id>] 
+      end 
+    )
+  ; string-sort
+    
+      
+      

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/generate.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/generate.str	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,143 @@
+module generate
+
+imports
+  libstratego-lib
+  libstratego-gpp
+  libstratego-sglr
+  libstratego-aterm
+  include/Spoofax-Testing
+  lib/editor-common.generated
+  spoofax_testing
+  aterm-eq
+  file-resolving
+
+rules
+  to-java:
+    testsuite(name(x), topsort(s), d*) ->
+       ($[editor/java/tests/[x].java], 
+        $[ package tests;
+        
+           import org.strategoxt.lang.Context;
+           import trans.trans;
+           import org.junit.Test;
+           import static org.junit.Assert.assertNull;
+           import static org.junit.Assert.assertNotNull;
+           import static org.junit.Assert.assertEquals;
+           import trans.parse_string_0_0;
+           import trans.aterm_eq_0_1;
+           import org.strategoxt.stratego_lib.read_text_file_0_0;
+           import org.spoofax.interpreter.terms.*;
+           import java.io.IOException;
+
+           public class [x] {
+               protected Context context;
+               
+               public [x]() {
+                   context = trans.init();
+               }
+               [d'*]
+           }
+        ])
+    with 
+      d'* := <map-with-index(try(desugar-test) ; test-to-java)> d*
+
+
+  desugar-test :
+    parse-test(i, r) -> parse-test(" ", description(""), i, r)
+
+  escape-string = 
+  	string-replace(|"\\","\\\\")
+  ; string-replace(|"\n","\\n")
+  ; string-replace(|"\"","\\\"") 
+
+  test-to-java :
+    (i, tst) ->  
+      $[
+          @Test
+          public void test[i]() {
+              [stmt*]
+          }  
+      ]  
+      with
+          stmt* := <test-to-java-stmts>tst
+
+  to-java-test-decl :
+    parse-test(_, description(d), string(_,s,_), _) -> 
+      $[
+          String input = "[s']"; 
+          String description = "[d']";
+          IStrategoTerm ast = parse_string_0_0.instance.invoke(context, context.getFactory().makeString(input));
+      ]
+      with 
+        d' := <escape-string>d
+      ; s' := <escape-string>s    
+
+  to-java-test-decl :
+    parse-test(_, description(d), file(f), _) -> 
+      $[
+          IStrategoTerm input = read_text_file_0_0.instance.invoke(context, context.getFactory().makeString("[f']")); 
+          String description = "[d']";
+          IStrategoTerm ast = parse_string_0_0.instance.invoke(context, input);
+      ]
+      with 
+        d' := <escape-string>d
+      ; f' := <resolve-path(|<current-path>) ; escape-string>f
+        
+  test-to-java-stmts:
+    parse-test(_, _, _, success()) ->
+      $[
+          [<to-java-test-decl>]
+          assertNotNull(description, ast); 
+       ]  
+
+  test-to-java-stmts:
+    parse-test(_, _, _, failure()) ->
+      $[
+          [<to-java-test-decl>]
+          assertNull(description, ast); 
+       ]  
+  test-to-java-stmts:
+    parse-test(_, _, _, file(f)) ->
+      $[ 
+          [<to-java-test-decl>]
+          IStrategoTerm expected = null;
+          try {
+          	 expected = context.getFactory().parseFromFile("[f']");
+          } catch (IOException e) {
+             // do some logging 	 	
+          }
+          assertEquals(description, parse_string_0_0.instance.invoke(context, context.getFactory().makeString(input)), expected ); 
+      ]  
+      with 
+        f' := <resolve-path(|<current-path>) ; escape-string>f
+
+  test-to-java-stmts:
+    parse-test(_, _, _, pattern(p)) ->
+      $[
+          [<to-java-test-decl>]
+          
+          assertNotNull(description, aterm_eq_0_1.instance.invoke(context, ast, context.getFactory().makeString("[p']")));
+       ]  
+      with p' := <write-to-string ; escape-string>p
+        
+strategies
+  
+  generate-ast-file = 
+    if ?(file(f), position, ast, path, project-path) then
+      abs := <resolve-path(|path)>f
+    ; if not(file-exists) then
+        if <oncetd(?parse-test(_, _, _, _) ; oncetd(?file(f)); ?parse-test(_, _, string(_,s,_), _))>ast then
+          result := <parse-string>s 
+        else
+          fatal-err-msg(|$[Could not find a string input for generating AST.])  
+        end 
+      else
+        fatal-err-msg(|$[File [f] already exists.])
+      end
+    else
+      fatal-err-msg(|$[Unable to determine which file to generate.])
+    end 
+  ; <queue-analysis> path  
+  ; !(abs, result)
+    
+    
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/spoofax_testing.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/spoofax_testing.str	Tue Dec 14 09:07:02 2010	(r21497)
@@ -0,0 +1,58 @@
+module spoofax_testing
+
+imports
+  libstratego-lib
+  libstratego-gpp
+  libstratego-aterm
+  include/Spoofax-Testing
+  lib/editor-common.generated
+  analysis
+  check
+  generate
+  file-resolving
+
+rules // Main editor interface (defined by editor/Spoofax-Testing-Builders and -References.esv)
+  
+  // Analyzes the current program, returning a tuple with errors, warnings, and notes;
+  // each a list of (term, message) tuples or simply (message) terms.
+  editor-analyze:
+    (ast, path, project-path) -> (ast, errors, warnings, notes)
+    with
+      scope-paths(
+        editor-init;
+        <chdir> project-path;
+        <record-all-sdfs> ".";
+        errors   := <collect-all(constraint-error, conc)> ast;
+        warnings := <collect-all(constraint-warning, conc)> ast;
+        notes    := <collect-all(constraint-note, conc)> ast;
+        if not([] := errors) then
+            rules ( HasErrors := () )
+        end
+      | path, project-path)
+  
+  // Transforms a selection to Java
+  generate-java:
+    (selected, position, ast, path, project-path) -> result
+    with
+      scope-paths( result := <to-java> selected | path, project-path)
+  
+  // Prints the abstract syntax ATerm of a selection.
+  generate-aterm:
+    (selected, position, ast, path, project-path) -> (filename, result)
+    with
+      filename := <guarantee-extension(|"aterm")> path;
+      result   := selected // we just return the input term
+  
+  // Returns "hover help" information for a particular node in the editor.
+  // For references, this rule is invoked using the resolved term.
+  editor-hover:
+    (string(_,s,_), _, _, _, _) -> hover
+    with
+      hover := <parse-string-and-pp-aterm ; string-replace(|"\n", "<br>")>s
+
+  parse-string-and-pp-aterm =
+    ast   := <parse-string>
+  ; pp    := <pp-aterm-box>ast
+  ; <box2text-string(|80)>pp
+
+

From R.B.Vermaas at tudelft.nl  Tue Dec 14 10:30:54 2010
From: R.B.Vermaas at tudelft.nl (Rob Vermaas)
Date: Tue, 14 Dec 2010 09:30:54 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21498 -
	spoofax-imp/trunk/org.strategoxt.imp.testing/trans
Message-ID: <201012140930.oBE9Usxp007304@proliant.st.ewi.tudelft.nl>

Author: rob
Date: Tue Dec 14 09:30:54 2010
New Revision: 21498
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21498&sc=1

Log:
add some html to make hover of parse-unit inputs strings clearer

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/spoofax_testing.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/spoofax_testing.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/trans/spoofax_testing.str	Tue Dec 14 09:07:02 2010	(r21497)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/spoofax_testing.str	Tue Dec 14 09:30:54 2010	(r21498)
@@ -48,7 +48,14 @@
   editor-hover:
     (string(_,s,_), _, _, _, _) -> hover
     with
-      hover := <parse-string-and-pp-aterm ; string-replace(|"\n", "<br>")>s
+      hover := <parse-string-and-pp-aterm ; hover-input-string>s
+
+  hover-input-string = 
+    <concat-strings>
+      [ "Using the current parsetable, the input string result in the following AST:<br>"
+      , "<br>"
+      , "<b><pre>",<id>,"</pre></b>"
+      ] 
 
   parse-string-and-pp-aterm =
     ast   := <parse-string>

From R.B.Vermaas at tudelft.nl  Tue Dec 14 10:52:37 2010
From: R.B.Vermaas at tudelft.nl (Rob Vermaas)
Date: Tue, 14 Dec 2010 09:52:37 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21499 - in
	spoofax-imp/trunk/org.strategoxt.imp.testing: editor test
Message-ID: <201012140952.oBE9qbLx007717@proliant.st.ewi.tudelft.nl>

Author: rob
Date: Tue Dec 14 09:52:37 2010
New Revision: 21499
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21499&sc=1

Log:
add some parse test completions

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Completions.esv
   spoofax-imp/trunk/org.strategoxt.imp.testing/test/test.spt

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Completions.esv
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Completions.esv	Tue Dec 14 09:30:54 2010	(r21498)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Completions.esv	Tue Dec 14 09:52:37 2010	(r21499)
@@ -15,4 +15,15 @@
                                          
   completion proposer                  : editor-complete
                                          
-  completion trigger                   : ":"
\ No newline at end of file
+  completion template : Test =
+    "parse test" " " <description> "\n\t" "\"\"\n\t\"\" " "succeeds" (blank)
+
+  completion template : Test =
+    "parse test" " " <description> "\n\t" "\"\"\n\t\"\" " "fails" (blank)
+    
+  completion template : Test =
+    "parse test" " " <description> "\n\t" "\"\"\n\t\"\" " "->" "file" <path> (blank)
+
+  completion template : Test =
+    "parse test" " " <description> "\n\t" "\"\"\n\t\"\" " "->" <pattern> (blank)
+    

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/test/test.spt
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/test/test.spt	Tue Dec 14 09:30:54 2010	(r21498)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/test/test.spt	Tue Dec 14 09:52:37 2010	(r21499)
@@ -38,6 +38,7 @@
       "asd" fails 
   "" -> file ./asd3.aterm
 
+
 /*
 
 editor test simple testsuite editor test (1)

From R.B.Vermaas at tudelft.nl  Tue Dec 14 10:58:00 2010
From: R.B.Vermaas at tudelft.nl (Rob Vermaas)
Date: Tue, 14 Dec 2010 09:58:00 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21500 - in
	spoofax-imp/trunk/org.strategoxt.imp.testing: editor test
Message-ID: <201012140958.oBE9w00g007760@proliant.st.ewi.tudelft.nl>

Author: rob
Date: Tue Dec 14 09:57:59 2010
New Revision: 21500
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21500&sc=1

Log:
make parse test description darkgreen

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Colorer.esv
   spoofax-imp/trunk/org.strategoxt.imp.testing/test/test.aterm

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Colorer.esv
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Colorer.esv	Tue Dec 14 09:52:37 2010	(r21499)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Colorer.esv	Tue Dec 14 09:57:59 2010	(r21500)
@@ -9,4 +9,5 @@
   // See the imported file for a brief introduction and examples.
   
   _.RegexPattern : darkgreen
-  _.AtomLiteral : darkgreen     
\ No newline at end of file
+  _.AtomLiteral : darkgreen   
+  _.description : darkgreen  
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/test/test.aterm
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/test/test.aterm	Tue Dec 14 09:52:37 2010	(r21499)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/test/test.aterm	Tue Dec 14 09:57:59 2010	(r21500)
@@ -1 +1,6 @@
-file("./asd2.aterm")
\ No newline at end of file
+parse-test(
+  " "
+, description("missing topsort")
+, string("\"\"", "\n    testsuite ASD\n    parse test rob is gek\n      \"asd\" fails \n  ", "\"\"")
+, failure()
+)
\ No newline at end of file

From R.B.Vermaas at tudelft.nl  Tue Dec 14 11:23:56 2010
From: R.B.Vermaas at tudelft.nl (Rob Vermaas)
Date: Tue, 14 Dec 2010 10:23:56 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21501 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans
Message-ID: <201012141023.oBEANuGY008314@proliant.st.ewi.tudelft.nl>

Author: rob
Date: Tue Dec 14 10:23:56 2010
New Revision: 21501
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21501&sc=1

Log:
add hover for concrete syntax parts in stratego code

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/stratego_sugar.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/stratego_sugar.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/stratego_sugar.str	Tue Dec 14 09:57:59 2010	(r21500)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/stratego_sugar.str	Tue Dec 14 10:23:56 2010	(r21501)
@@ -69,6 +69,12 @@
       <signature-of> node; // only show definitions
       text := <pp-stratego-string> node
 
+  editor-hover:
+    (node at ToMetaExpr(_), position, ast, path, project-path) -> text
+    where
+      str := <meta-explode(false)>node 
+    ; text := <concat-strings>["<pre>", <pp-stratego-string>str ,"</pre>"]
+
   generate-aterm:
     (selected, position, ast, path, project-path) -> (filename, result)
     with

From R.B.Vermaas at tudelft.nl  Tue Dec 14 11:27:16 2010
From: R.B.Vermaas at tudelft.nl (Rob Vermaas)
Date: Tue, 14 Dec 2010 10:27:16 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21502 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans
Message-ID: <201012141027.oBEARGoB008366@proliant.st.ewi.tudelft.nl>

Author: rob
Date: Tue Dec 14 10:27:15 2010
New Revision: 21502
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21502&sc=1

Log:
ensugar stratego code in concrete syntax hover

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/stratego_sugar.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/stratego_sugar.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/stratego_sugar.str	Tue Dec 14 10:23:56 2010	(r21501)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/stratego_sugar.str	Tue Dec 14 10:27:15 2010	(r21502)
@@ -72,7 +72,7 @@
   editor-hover:
     (node at ToMetaExpr(_), position, ast, path, project-path) -> text
     where
-      str := <meta-explode(false)>node 
+      str := <meta-explode(false) ; Stratego-Ensugar>node 
     ; text := <concat-strings>["<pre>", <pp-stratego-string>str ,"</pre>"]
 
   generate-aterm:

From r.t.lindeman at student.tudelft.nl  Tue Dec 14 13:10:29 2010
From: r.t.lindeman at student.tudelft.nl (Ricky Lindeman)
Date: Tue, 14 Dec 2010 12:10:29 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21503 - in
	spoofax-imp/trunk: org.strategoxt.imp.debug.stratego.core/doc
	org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control
	org.strategoxt.imp.de...
Message-ID: <201012141210.oBECAT73009938@proliant.st.ewi.tudelft.nl>

Author: RickyLindeman
Date: Tue Dec 14 12:10:26 2010
New Revision: 21503
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21503&sc=1

Log:
* added some extra program state checking before action step commands
 * First fix for "editor keeps instruction pointer marker after debugging is completed"

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/doc/BUILDING.txt
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/DebugSessionManager.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/EventThread.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/ThreadEventHandler.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/EventHandler.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/EventSpecManager.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/model/StrategoStackFrame.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/model/StrategoState.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.runtime/.externalToolBuilders/Strj-dbg-runtime-lib build.main.xml.launch
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.runtime/build.generated.xml
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/.externalToolBuilders/Test build.main.xml.launch
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/build.generated.custom.xml
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/build.generated.xml

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/doc/BUILDING.txt
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/doc/BUILDING.txt	Tue Dec 14 10:27:15 2010	(r21502)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/doc/BUILDING.txt	Tue Dec 14 12:10:26 2010	(r21503)
@@ -23,4 +23,10 @@
  * strategoxt.jar: the strategoxt java runtime
  * tools.jar: sun implementation of the java debug interface
  
- 
+
+
+eclipse settings:
+eclipse 3.6 has changed the meaning @SuppressWarnings("unchecked"). In Eclipse 3.5 unchecked was used to suppress the unchecked and raw types warnings.
+It has to be changed to @SuppressWarnings({"unchecked", "rawtypes"}). However if the project will still be edited in eclipse 3.5 the "rawtypes" is not supported. Add the -DsuppressRawWhenUnchecked=true argument to the -vmargs list in eclipse.ini to preserve the eclipse 3.5 behavior in eclipse 3.6.
+
+http://wiki.event-b.org/index.php/Migration_to_Eclipse_3.6#.40SuppressWarnings.28.22unchecked.22.29_does_not_ignore_raw_types_warnings_anymore

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/DebugSessionManager.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/DebugSessionManager.java	Tue Dec 14 10:27:15 2010	(r21502)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/DebugSessionManager.java	Tue Dec 14 12:10:26 2010	(r21503)
@@ -1,6 +1,7 @@
 package org.strategoxt.debug.core.control;
 
 import org.strategoxt.debug.core.eventspec.EventSpecManager;
+import org.strategoxt.debug.core.model.StrategoState;
 import org.strategoxt.debug.core.util.DebugSessionSettings;
 import org.strategoxt.debug.core.util.StreamRedirectThread;
 import org.strategoxt.debug.core.util.VMLauncherHelper;
@@ -16,6 +17,11 @@
 
 	public boolean running = false;
 	
+	/**
+	 * Will be true when terminateVM() is called.
+	 */
+	private boolean isTerminated = false;
+	
 	// Thread transferring remote error stream to our error stream
 	private StreamRedirectThread errThread = null;
 
@@ -54,10 +60,7 @@
 		this.vmMonitor = vmMonitor;
 	}
 	
-	public DebugSessionSettings getDebugSessionSettings()
-	{
-		return this.debugSessionSettings;
-	}
+
 	
 	/**
 	 * Initialize a new VM using the given VirtualMachineManager.
@@ -155,7 +158,7 @@
 		}
 	}
 
-
+	// next block of methods can be used to control the VM
 
 	public void runVM() {
 		System.out.println("runVM start");
@@ -179,6 +182,7 @@
 	 */
 	public void resumeVM()
 	{
+		System.out.println("RESUME");
 		if (this.eventThread.getVMDied())
 		{
 			// cannot resume a VM that has died
@@ -186,6 +190,7 @@
 		}
 		else
 		{
+			this.getStrategoState().setSuspended(false);
 			vm.resume();
 		}
 	}
@@ -200,31 +205,40 @@
 	
 	public void stepInto()
 	{
-		// stop at the first possible s-enter/r-enter event
-		// if the current statement is not a call to another method, we can only step over
-		ThreadEventHandler handler = this.eventThread.getMainThreadHandler();
-		this.eventSpecManager.setStepInto(handler.getStrategoState());
-		this.resumeVM();
+		if (canStepInto())
+		{
+			System.out.println("STEP INTO");
+			// stop at the first possible s-enter/r-enter event
+			// if the current statement is not a call to another method, we can only step over
+			this.eventSpecManager.setStepInto(this.getStrategoState());
+			this.resumeVM();
+		}
 	}
 	
 	public void stepOver()
 	{
-		// get the thread that is suspended, stratego programs are single threaded, so we always know which thread we need.
-		// just save the step info in the EventSpecManager, if stratego becomes multi-threaded, step info needs to be saved per Thread
-		ThreadEventHandler handler = this.eventThread.getMainThreadHandler();
-		this.eventSpecManager.setStepOver(handler.getStrategoState());
-		// stop at the next s-step that is in the same stackframe as the current one
-		// if the current StackFrame exists (s-exit or r-exit) continue at the returning stackframe
-		this.resumeVM();
+		if (this.canStepOver())
+		{
+			System.out.println("STEP OVER");
+			// get the thread that is suspended, stratego programs are single threaded, so we always know which thread we need.
+			// just save the step info in the EventSpecManager, if stratego becomes multi-threaded, step info needs to be saved per Thread
+			this.eventSpecManager.setStepOver(this.getStrategoState());
+			// stop at the next s-step that is in the same stackframe as the current one
+			// if the current StackFrame exists (s-exit or r-exit) continue at the returning stackframe
+			this.resumeVM();
+		}
 	}
 	
 	public void stepReturn()
 	{
-		// continue until the current stackframe fires an s-exit or r-exit event.
-		// we should stop at the next s-step in the parent stackframe.
-		ThreadEventHandler handler = this.eventThread.getMainThreadHandler();
-		this.eventSpecManager.setStepReturn(handler.getStrategoState());
-		this.resumeVM();
+		if (this.canStepReturn())
+		{
+			System.out.println("STEP RETURN");
+			// continue until the current stackframe fires an s-exit or r-exit event.
+			// we should stop at the next s-step in the parent stackframe.
+			this.eventSpecManager.setStepReturn(this.getStrategoState());
+			this.resumeVM();
+		}
 	}
 	
 	/**
@@ -232,17 +246,92 @@
 	 */
 	public void terminateVM()
 	{
-		vm.exit(1);
+		if (this.vm != null)
+		{
+			this.isTerminated = true;
+			vm.exit(1);
+		}
+		else
+		{
+			System.out.println("No VM!");
+		}
 	}
 	
+	// next block of methods can be used to ask the VM if we can perform the action
+	
+	public boolean canResume() {
+		return !isTerminated() && isSuspended();
+	}
+
+	public boolean canSuspend() {
+		return !isTerminated() && !isSuspended();
+	}
+	
+	public boolean canStepInto() {
+		return canStep();
+	}
+
+	public boolean canStepOver() {
+		return canStep();
+	}
+
+	public boolean canStepReturn() {
+		return canStep();
+	}
+	
+	/**
+	 * Returns whether this thread is in a valid state to
+	 * step.
+	 * 
+	 * @return whether this thread is in a valid state to
+	 * step
+	 */
+	protected boolean canStep() {
+		return isSuspended()
+			// && (!isPerformingEvaluation() || isInvokingMethod()) // TODO: implement "perform evaluation"
+			// && !isSuspendVoteInProgress() // TODO:  (conditional breakpoints, etc.).
+			&& !isStepping()
+			//&& getTopStackFrame() != null // just use the frame level
+			&& this.getStrategoState().getCurrentFrameLevel() > -1
+			// && !getJavaDebugTarget().isPerformingHotCodeReplace() // TODO: implement hot code replace
+			;
+	}
+	
+	
+	// next block of methods ask for the state of the VM
+	
+	public boolean isTerminated() {
+		return this.isTerminated;
+	}
+	
+	public boolean isSuspended() {
+		return this.getStrategoState().isSuspended();
+	}
+	
+	public boolean isStepping()
+	{
+		return this.getStrategoState().isStepping();
+	}
+	// get methods
+	
 	public EventSpecManager getEventSpecManager()
 	{
 		return this.eventSpecManager;
 	}
 
-	public void setStepExit() {
-		// TODO Auto-generated method stub
-		
+	public DebugSessionSettings getDebugSessionSettings()
+	{
+		return this.debugSessionSettings;
+	}
+	
+	/**
+	 * Returns the StrategoState of Stratego program. 
+	 * As long as Stratego programs remain single threaded we can just return the state of the single man thread.
+	 * @return
+	 */
+	private StrategoState getStrategoState()
+	{
+		return this.eventThread.getStrategoState();
 	}
 	
 	/**

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/EventThread.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/EventThread.java	Tue Dec 14 10:27:15 2010	(r21502)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/EventThread.java	Tue Dec 14 12:10:26 2010	(r21503)
@@ -161,7 +161,7 @@
 		}
 	}
 
-	private StrategoState getStrategoState() {
+	protected StrategoState getStrategoState() {
 		return this.strategoState;
 	}
 
@@ -187,7 +187,7 @@
 	private ThreadEventHandler getThreadEventHandler(ThreadReference thread) {
 		ThreadEventHandler handler = (ThreadEventHandler) traceMap.get(thread);
 		if (handler == null) {
-			handler = new ThreadEventHandler(thread, this.strategoState);
+			handler = new ThreadEventHandler(thread, this.strategoState); // share the state across threads because we only have one Stratego Program Thread
 			traceMap.put(thread, handler);
 		}
 		return handler;

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/ThreadEventHandler.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/ThreadEventHandler.java	Tue Dec 14 10:27:15 2010	(r21502)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/ThreadEventHandler.java	Tue Dec 14 12:10:26 2010	(r21503)
@@ -137,6 +137,7 @@
 
 				if (suspendThread)
 				{
+					// the stratego program is suspended
 					System.out.println("suspend");
 					Value output = h.getStackFrame().thisObject().invokeMethod(thread, method, arguments, ThreadReference.INVOKE_SINGLE_THREADED);
 					//Value output = thread.invokeMethod(thread, method, arguments, ThreadReference.INVOKE_SINGLE_THREADED);
@@ -146,6 +147,8 @@
 					System.out.println(term.toString());
 					String[] dynamicRuleNames = builder.convertToStringArray(term);
 					this.strategoState.currentFrame().setDynamicRuleNames(dynamicRuleNames);
+					
+					this.strategoState.setSuspended(true);
 				}
 			} catch(Exception e)
 			{
@@ -229,8 +232,21 @@
 		mgr.deleteEventRequest(event.request());
 	}
 
+	/**
+	 * Death occurs before termination
+	 * @param event
+	 */
 	void threadDeathEvent(ThreadDeathEvent event) {
 		// thread death event
+		if (this.strategoState != null && this.strategoState.getCurrentFrameLevel() > -1)
+		{
+			System.out.println("A thread death occured, but the StrategoState has some StackFrame left...");
+		}
+		else
+		{
+			System.out.println("Thread death...");
+		}
+
 	}
 	
 	public StrategoState getStrategoState()

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/EventHandler.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/EventHandler.java	Tue Dec 14 10:27:15 2010	(r21502)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/EventHandler.java	Tue Dec 14 12:10:26 2010	(r21503)
@@ -404,6 +404,17 @@
 	/**
 	 * Returns true if the thread should stay suspended.
 	 * Returns false if the thread should resume
+	 * 
+	 * If we hit a breakpoint we should always suspend and cancel all stepping.
+	 * If we are doing a step over we suspend 
+	 * 		at the next s-step,s-exit,r-exit that is in the same StackFrame
+	 * 		or in the first s-step,s-exit,r-exit in a parent StackFrame (we stepped over the last statement)
+	 * If we are doing a step into we should suspend
+	 * 		at the first s-enter or s-exit that is in a child StackFrame 
+	 * 		or at the first s-step,s-exit,r-exit that is in the current StackFrame (current statement cannot be stepping into) 
+	 * 		or at the first s-step,s-exit,r-exit that is in the parent StackFrame (doing a step into at an s-exit,r-exit)
+	 * If we are doing a step return we should suspend
+	 * 		at the first s-step,s-exit,r-exit in the parent StackFrame
 	 * @return
 	 */
 	public boolean shouldSuspend(StrategoState currentState, EventSpecManager eventSpecManager){
@@ -432,7 +443,7 @@
 			// if stepping is active it should be cancelled
 			if (eventSpecManager.isStepOverActive() || eventSpecManager.isStepIntoActive() || eventSpecManager.isStepReturnActive())
 			{
-				eventSpecManager.resetStep();
+				eventSpecManager.resetStep(currentState);
 			}
 			shouldSuspend = true;
 		}
@@ -452,7 +463,7 @@
 					{
 						// we hit the next s-step
 						shouldSuspend = true;
-						eventSpecManager.resetStep(); // reset step
+						eventSpecManager.resetStep(currentState); // reset step
 					}
 					// S_VAR we can ignore
 					// S_ENTER/R_ENTER should never happen is the same StackFrame
@@ -461,31 +472,54 @@
 					{
 						// we have hit the s-exit/r-exit of the frame in which the step occured.
 						shouldSuspend = true;
-						eventSpecManager.resetStep(); // reset step
+						eventSpecManager.resetStep(currentState); // reset step
 					}
 				}
 			}
-			// what if the current stackframe level is smaller that the stepFrameLevel? We must have missed an r-exit/s-exit
+			else if (eventSpecManager.getStepFrameLevel() > currentState.getCurrentFrameLevel()
+					&& (this.getEventType().equals(EventHandler.S_EXIT)
+							|| this.getEventType().equals(EventHandler.R_EXIT)
+							|| this.getEventType().equals(EventHandler.S_ENTER)
+							|| this.getEventType().equals(EventHandler.R_ENTER)
+							|| this.getEventType().equals(EventHandler.S_STEP)))
+			{
+				// what if the current stackframe level is smaller that the stepFrameLevel? We must have missed an r-exit/s-exit
+				// stop at the first s-step, s-exit, s-enter, r-exit, r-enter (s-var is ingnored)
+				System.out.println("Missed step over curLevel="+currentState.getCurrentFrameLevel() + " stepOverInLevel="+eventSpecManager.getStepFrameLevel());
+				shouldSuspend = true;
+				eventSpecManager.resetStep(currentState); // reset step
+				
+			}
 		} else if (eventSpecManager.isStepIntoActive())
 		{
 			// an new debug event was fired, this should be an s-enter or r-enter as we can only step into strategies or rules that are debuggable
 			// if the event is s-step we just did a normal step over, cancel the stepinto event and just resume
 			
 			// level of the current stackframe should equal (stepFrameLevel+1)
-			// an we should have stopped at a s-enter/r-enter
-			int stepIntoFrameLevel = eventSpecManager.getStepFrameLevel() + 1;
+			// and we should have stopped at a s-enter/r-enter
+			int stepIntoFrameLevel = eventSpecManager.getStepFrameLevel() + 1; 
+			// TODO: does the stacklevel really matter, or is it suffice to say currentState.getCurrentFrameLevel() > eventSpecManager.getStepFrameLevel()
+			// maybe the step into strategy has no debug information but it calls another strategy which does have step into information....?
 			if (stepIntoFrameLevel == currentState.getCurrentFrameLevel() && 
 					(this.getEventType().equals(EventHandler.S_ENTER)
 					|| this.getEventType().equals(EventHandler.R_ENTER))
 					)
 			{
 				shouldSuspend = true;
+				eventSpecManager.resetStep(currentState); // reset step
 			}
-			else
+			else if (this.getEventType().equals(EventHandler.S_ENTER)
+					||  this.getEventType().equals(EventHandler.R_ENTER)
+					||  this.getEventType().equals(EventHandler.R_EXIT)
+					|| this.getEventType().equals(EventHandler.S_EXIT)
+					|| this.getEventType().equals(EventHandler.S_STEP))
 			{
-				// could not do a s-enter
+
+				// could not do a s-enter, we just did an s-exit/r-exit or s-step
+				// just treat it as an s-step
+				shouldSuspend = true;
+				eventSpecManager.resetStep(currentState); // reset step
 			}
-			eventSpecManager.resetStep(); // reset step
 		}
 		else if (eventSpecManager.isStepReturnActive())
 		{
@@ -494,10 +528,32 @@
 			int parentFrameLevel = eventSpecManager.getStepFrameLevel() - 1;
 			if (parentFrameLevel == currentState.getCurrentFrameLevel())
 			{
-				// it does not matter what the eventType is of the fired debug event
-				shouldSuspend = true;
-				eventSpecManager.resetStep(); // reset step
+				// it does not matter what the eventType is of the fired debug event as long as it isn't an s-var
+				if (!this.getEventType().equals(EventHandler.S_VAR))
+				{
+					shouldSuspend = true;
+					eventSpecManager.resetStep(currentState); // reset step
+				}
 			}
+			else if (currentState.getCurrentFrameLevel() < parentFrameLevel)
+			{
+				// the direct parent frame did not have any debug information, but stop at the first
+				// debug event in one of the parent frames (ignore s-var events)
+				if (!this.getEventType().equals(EventHandler.S_VAR))
+				{
+					shouldSuspend = true;
+					eventSpecManager.resetStep(currentState); // reset step
+				}
+			}
+		}
+		
+		// TODO assert
+		if (shouldSuspend && currentState.isStepping())
+		{
+			// the program suspends but we are still stepping
+			// TODO: this should never occur...
+			System.out.println("The program suspended but we are still stepping!");
+			
 		}
 		
         return shouldSuspend; // if break point exists suspend thread

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/EventSpecManager.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/EventSpecManager.java	Tue Dec 14 10:27:15 2010	(r21502)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/EventSpecManager.java	Tue Dec 14 12:10:26 2010	(r21503)
@@ -126,6 +126,7 @@
 			{
 				// no parent index
 				// we are at the exit of the main strategy!
+				System.out.println("At exit of top level strategy, just continue..");
 				return;
 			}
 			stepFrame = state.get(parentIndex);
@@ -138,6 +139,8 @@
 			stepFrameLevel = state.size() - 1;
 			isStepOverActive = true;
 		}
+		
+		state.setStepping(true);
 	}
 	
 	
@@ -153,7 +156,11 @@
 		else
 		{
 			// current stackframe is suspend at a s-exit/r-exit/s-enter/r-enter
+			// just treat it as an step over
+			System.out.println("Cannot step into " + state.currentFrame().getEventType() + ", just do a step over...");
+			setStepOver(state);
 		}
+		state.setStepping(true);
 	}
 	
 	public void setStepReturn(StrategoState state)
@@ -161,14 +168,17 @@
 		if (state.getCurrentFrameLevel() == 0)
 		{
 			// we are at the main strategy, cannot step return
+			System.out.println("Cannot step return in top level strategy, just continue...");
 			return;
 		}
 		stepFrame = state.currentFrame();
 		stepFrameLevel = state.getCurrentFrameLevel();
 		isStepReturnActive = true;
+		
+		state.setStepping(true);
 	}
 
-	public void resetStep()
+	public void resetStep(StrategoState state)
 	{
 		this.stepFrame = null;
 		this.stepFrameLevel = -1;

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/model/StrategoStackFrame.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/model/StrategoStackFrame.java	Tue Dec 14 10:27:15 2010	(r21502)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/model/StrategoStackFrame.java	Tue Dec 14 12:10:26 2010	(r21503)
@@ -186,12 +186,12 @@
 			return false;
 		
 		boolean c1 = this.name.equals(other.name);
-		boolean c2 = this.current.equals(other.current);
+		//boolean c2 = this.current.equals(other.current); // TODO: do not equals on this.current, we should treat it as a variable
 		boolean c3 = this.currentLocationInfo.equals(other.currentLocationInfo);
 		boolean c4 = this.filename.equals(other.filename);
 		boolean c5 = this.locationInfo.equals(other.locationInfo); // TODO: use this one?
 		
-		if (c1 && c2 && c3 && c4 && c5)
+		if (c1 /*&& c2*/ && c3 && c4 && c5)
 			return true;
 		return false;
 	}
@@ -201,7 +201,7 @@
 		final int prime = 61;
 		
 		int result = 1;
-		result = prime * result + this.current.hashCode();
+		//result = prime * result + this.current.hashCode();
 		result = prime * result + this.currentLocationInfo.hashCode();
 		result = prime * result + this.filename.hashCode();
 		result = prime * result + this.locationInfo.hashCode(); // TODO: ise this one?

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/model/StrategoState.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/model/StrategoState.java	Tue Dec 14 10:27:15 2010	(r21502)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/model/StrategoState.java	Tue Dec 14 12:10:26 2010	(r21503)
@@ -8,6 +8,10 @@
 
 	//private LocationInfo locationInfo = null;
 	
+	private boolean isSuspended = false;
+	private boolean isStepping = false;
+	private boolean hasDied = false;
+	
 	private Stack<StrategoStackFrame> stack = new Stack<StrategoStackFrame>();
 	
 	/*
@@ -81,5 +85,43 @@
 		StrategoStackFrame[] a = new StrategoStackFrame[this.stack.size()];
 		return this.stack.toArray(a);
 	}
+	
+	/**
+	 * Returns true if the Stratego Program is suspended.
+	 * @return
+	 */
+	public boolean isSuspended()
+	{
+		return this.isSuspended;
+	}
+	
+	public void setSuspended(boolean isSuspended)
+	{
+		this.isSuspended = isSuspended;
+	}
+	
+	/**
+	 * Returns true if the client issued a stepping command.
+	 * @return
+	 */
+	public boolean isStepping()
+	{
+		return this.isStepping;
+	}
+	
+	public void setStepping(boolean isStepping)
+	{
+		this.isStepping = isStepping;
+	}
+	
+	public boolean hasDied()
+	{
+		return this.hasDied;
+	}
+	
+	public void setDeath(boolean hasDied)
+	{
+		this.hasDied = hasDied;
+	}
 
 }

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.runtime/.externalToolBuilders/Strj-dbg-runtime-lib build.main.xml.launch
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.runtime/.externalToolBuilders/Strj-dbg-runtime-lib build.main.xml.launch	Tue Dec 14 10:27:15 2010	(r21502)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.runtime/.externalToolBuilders/Strj-dbg-runtime-lib build.main.xml.launch	Tue Dec 14 12:10:26 2010	(r21503)
@@ -3,7 +3,7 @@
 <stringAttribute key="bad_container_name" value=".externalToolBuilders"/>
 <booleanAttribute key="org.eclipse.ant.ui.DEFAULT_VM_INSTALL" value="false"/>
 <listAttribute key="org.eclipse.debug.core.MAPPED_RESOURCE_PATHS">
-<listEntry value="/strj-dbg-runtime-lib/build.main.xml"/>
+<listEntry value="/org.strategoxt.imp.debug.stratego.runtime/build.main.xml"/>
 </listAttribute>
 <listAttribute key="org.eclipse.debug.core.MAPPED_RESOURCE_TYPES">
 <listEntry value="1"/>

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.runtime/build.generated.xml
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.runtime/build.generated.xml	Tue Dec 14 10:27:15 2010	(r21502)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.runtime/build.generated.xml	Tue Dec 14 12:10:26 2010	(r21503)
@@ -3,8 +3,8 @@
 <project name="build.generated">
 
         <target name="spoofaximp.default" depends="spoofaximp.default.ctree"/>
-        <target name="spoofaximp.default.ctree" depends="check-classpath,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.ctree,java.jar,sdf2imp,refresh"/>
-        <target name="spoofaximp.default.jar" depends="check-classpath,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.jar,  java.jar,sdf2imp,refresh"/>
+        <target name="spoofaximp.default.ctree" depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.ctree,java.jar,sdf2imp,refresh"/>
+        <target name="spoofaximp.default.jar" depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.jar,  java.jar,sdf2imp,refresh"/>
     
         <!-- Initialization -->
         <available file="${build}/org/strategoxt/imp/debug/stratego/runtime/strategies/Main.class" property="java.jar.enabled"/>
@@ -84,6 +84,13 @@
             <available classname="org.strategoxt.imp.generator.sdf2imp" property="check-classpath.available"/>
             <antcall target="check-classpath.helper"/>  
         </target>
+        
+        <target name="init" if="eclipse.running">
+            <!-- refresh one file/dir in the project to trigger an Ant rebuild with the next build command -->
+            <java classname="org.strategoxt.imp.metatooling.building.AntForceRefreshScheduler" failonerror="false">
+                <arg value="${include}"/>
+            </java>
+        </target>
   
         <target name="check-classpath.helper" unless="check-classpath.available">
             <echo level="error" message="Could not load the Spoofax plugin loading classes."/>

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/.externalToolBuilders/Test build.main.xml.launch
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/.externalToolBuilders/Test build.main.xml.launch	Tue Dec 14 10:27:15 2010	(r21502)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/.externalToolBuilders/Test build.main.xml.launch	Tue Dec 14 12:10:26 2010	(r21503)
@@ -3,7 +3,7 @@
 <stringAttribute key="bad_container_name" value=".externalToolBuilders"/>
 <booleanAttribute key="org.eclipse.ant.ui.DEFAULT_VM_INSTALL" value="false"/>
 <listAttribute key="org.eclipse.debug.core.MAPPED_RESOURCE_PATHS">
-<listEntry value="/strj-dbg-transformer/build.main.xml"/>
+<listEntry value="/org.strategoxt.imp.debug.stratego.transformer/build.main.xml"/>
 </listAttribute>
 <listAttribute key="org.eclipse.debug.core.MAPPED_RESOURCE_TYPES">
 <listEntry value="1"/>

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/build.generated.custom.xml
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/build.generated.custom.xml	Tue Dec 14 10:27:15 2010	(r21502)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/build.generated.custom.xml	Tue Dec 14 12:10:26 2010	(r21503)
@@ -18,7 +18,7 @@
 	</condition>
 	<available file="${trans}/${strmodule}.str" property="build.stratego.enabled" />
 	<dirname property="externaldefdir" file="${externaldef}" />
-	<condition property="externaldefimport" value="-I ${externaldefdir}" else="">
+	<condition property="externaldefimport" value="-I &quot;${externaldefdir}&quot;" else="">
 		<isset property="externaldef" />
 	</condition>
 	<condition property="externaljarimport" value=":${externaljar}" else="">

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/build.generated.xml
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/build.generated.xml	Tue Dec 14 10:27:15 2010	(r21502)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/build.generated.xml	Tue Dec 14 12:10:26 2010	(r21503)
@@ -3,8 +3,8 @@
 <project name="build.generated">
 
         <target name="spoofaximp.default" depends="spoofaximp.default.ctree"/>
-        <target name="spoofaximp.default.ctree" depends="check-classpath,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.ctree,java.jar,sdf2imp,refresh"/>
-        <target name="spoofaximp.default.jar" depends="check-classpath,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.jar,  java.jar,sdf2imp,refresh"/>
+        <target name="spoofaximp.default.ctree" depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.ctree,java.jar,sdf2imp,refresh"/>
+        <target name="spoofaximp.default.jar" depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.jar,  java.jar,sdf2imp,refresh"/>
     
         <!-- Initialization -->
         <available file="${build}/org/strategoxt/imp/debug/stratego/transformer/strategies/Main.class" property="java.jar.enabled"/>
@@ -84,6 +84,13 @@
             <available classname="org.strategoxt.imp.generator.sdf2imp" property="check-classpath.available"/>
             <antcall target="check-classpath.helper"/>  
         </target>
+        
+        <target name="init" if="eclipse.running">
+            <!-- refresh one file/dir in the project to trigger an Ant rebuild with the next build command -->
+            <java classname="org.strategoxt.imp.metatooling.building.AntForceRefreshScheduler" failonerror="false">
+                <arg value="${include}"/>
+            </java>
+        </target>
   
         <target name="check-classpath.helper" unless="check-classpath.available">
             <echo level="error" message="Could not load the Spoofax plugin loading classes."/>

From r.t.lindeman at student.tudelft.nl  Tue Dec 14 14:37:32 2010
From: r.t.lindeman at student.tudelft.nl (Ricky Lindeman)
Date: Tue, 14 Dec 2010 13:37:32 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21504 - in
	spoofax-imp/trunk:
	org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control
	org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/...
Message-ID: <201012141337.oBEDbWLM011604@proliant.st.ewi.tudelft.nl>

Author: RickyLindeman
Date: Tue Dec 14 13:37:32 2010
New Revision: 21504
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21504&sc=1

Log:
* Changed equals and hashCode method of StrategoStackFrame, it only compares on stackdepth, filename, rule/strategy name, rule/strategy locationinfo.
 * this change should also fix the eclipse widget disposed errors (I hope...)

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/ThreadEventHandler.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/EventHandler.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/RuleEnterHandler.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/RuleExitHandler.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyEnterHandler.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyExitHandler.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyStepHandler.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyVarHandler.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/EventSpecManager.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/model/StrategoStackFrame.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/VMStateTester.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/ThreadEventHandler.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/ThreadEventHandler.java	Tue Dec 14 12:10:26 2010	(r21503)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/ThreadEventHandler.java	Tue Dec 14 13:37:32 2010	(r21504)
@@ -12,7 +12,6 @@
 import org.strategoxt.debug.core.control.events.StrategyStepHandler;
 import org.strategoxt.debug.core.control.events.StrategyVarHandler;
 import org.strategoxt.debug.core.eventspec.EventSpecManager;
-import org.strategoxt.debug.core.model.LocationInfo;
 import org.strategoxt.debug.core.model.StrategoStackFrame;
 import org.strategoxt.debug.core.model.StrategoState;
 import org.strategoxt.debug.core.util.StrategoTermBuilder;
@@ -52,10 +51,14 @@
 	}
 	*/
 
+	/**
+	 * Remove the current StrategoStackFrame
+	 */
 	private void exitStrategoStackFrame(EventHandler h) {
 		if (h != null)
 		{
-			StrategoStackFrame frame = new StrategoStackFrame(h.getFilename(), h.getName(), h.getLocationInfo(), h.getGiven());
+			int level = this.strategoState.getCurrentFrameLevel();
+			StrategoStackFrame frame = new StrategoStackFrame(level, h.getFilename(), h.getName(), h.getLocationInfo(), h.getGiven());
 			this.strategoState.popFrame(frame);
 		}
 		else
@@ -120,9 +123,7 @@
 			try {
 				h.processDebugEvent(this.strategoState);
 				
-				// update the current location
-				LocationInfo locationInfo = h.getLocationInfo();
-				this.strategoState.currentFrame().setCurrentLocationInfo(locationInfo, h.getEventType());
+
 				
 				suspendThread = h.shouldSuspend(this.strategoState, eventSpecManager);
 				// if the thread will be suspended, update the Dynamic Rules. But first get it from the vm while it is suspended

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/EventHandler.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/EventHandler.java	Tue Dec 14 12:10:26 2010	(r21503)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/EventHandler.java	Tue Dec 14 13:37:32 2010	(r21504)
@@ -69,6 +69,11 @@
 	
 	protected StrategoTermBuilder builder = new StrategoTermBuilder();
 	
+	/**
+	 * The current com.sun.jdi.StackFrame.
+	 */
+	private StackFrame stackFrame = null;
+	
 	public EventHandler(MethodExitEvent event)
 	{
 		this.exit_event = event;
@@ -81,6 +86,10 @@
 		this.initLocalVariables();
 	}
 	
+	/**
+	 * Extract the method arguments. 
+	 * @return Returns a list of LocalVariables each represents a method argument.
+	 */
 	private List<LocalVariable> getMethodArguments()
 	{
 		List<LocalVariable> args = new ArrayList<LocalVariable>();
@@ -103,9 +112,10 @@
 		return args;
 	}
 	
-	private StackFrame stackFrame = null;
+	
+	
 	/**
-	 * Returns the current stack frame
+	 * Returns the current com.sun.jdi.StackFrame
 	 * @return
 	 */
 	public StackFrame getStackFrame()
@@ -561,10 +571,14 @@
 	
 	/**
 	 * Override this method when some stuff needs to be done if this DebugEvent occurs.
+	 * Always call super to update the location info..
 	 * @param strategoState 
 	 */
 	public void processDebugEvent(StrategoState strategoState) 
 	{
+		// update the current location
+		LocationInfo locationInfo = this.getLocationInfo();
+		strategoState.currentFrame().setCurrentLocationInfo(locationInfo, this.getEventType());
 	}
 	
 	protected abstract BreakPoint createBreakPoint();

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/RuleEnterHandler.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/RuleEnterHandler.java	Tue Dec 14 12:10:26 2010	(r21503)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/RuleEnterHandler.java	Tue Dec 14 13:37:32 2010	(r21504)
@@ -36,10 +36,12 @@
 	
 	@Override
 	public void processDebugEvent(StrategoState strategoState) {
-		super.processDebugEvent(strategoState);
 		// current event is an enter event, push a new StackFrame on the stack
-		StrategoStackFrame frame = new StrategoStackFrame(this.getFilename(), this.getName(), this.getLocationInfo(), this.getGiven());
+		int level = strategoState.getCurrentFrameLevel() + 1;
+		StrategoStackFrame frame = new StrategoStackFrame(level, this.getFilename(), this.getName(), this.getLocationInfo(), this.getGiven());
 		strategoState.pushFrame(frame);
+
+		super.processDebugEvent(strategoState); // update current location info
 	}
 
 }

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/RuleExitHandler.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/RuleExitHandler.java	Tue Dec 14 12:10:26 2010	(r21503)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/RuleExitHandler.java	Tue Dec 14 13:37:32 2010	(r21504)
@@ -35,7 +35,6 @@
 	
 	@Override
 	public void processDebugEvent(StrategoState strategoState) {
-		super.processDebugEvent(strategoState);
 		// do not pop the current stack frame here
 		// an exit breakpoint could also set the vm in the suspended state and then we will still need to access the current stack.
 		// Pop the frame in the method exit event, because no one can need it after the method has exited
@@ -45,6 +44,8 @@
 		// the current term on the frame should now be
 		//h.getGiven();
 		strategoState.currentFrame().setCurrentTerm(this.getGiven());
+
+		super.processDebugEvent(strategoState); // update current location info
 	}
 	
 

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyEnterHandler.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyEnterHandler.java	Tue Dec 14 12:10:26 2010	(r21503)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyEnterHandler.java	Tue Dec 14 13:37:32 2010	(r21504)
@@ -37,9 +37,10 @@
 
 	@Override
 	public void processDebugEvent(StrategoState strategoState) {
-		super.processDebugEvent(strategoState);
 		// current event is an enter event, push a new StackFrame on the stack
-		StrategoStackFrame frame = new StrategoStackFrame(this.getFilename(), this.getName(), this.getLocationInfo(), this.getGiven());
+		int level = strategoState.getCurrentFrameLevel() + 1;
+		StrategoStackFrame frame = new StrategoStackFrame(level, this.getFilename(), this.getName(), this.getLocationInfo(), this.getGiven());
 		strategoState.pushFrame(frame);
+		super.processDebugEvent(strategoState); // update current location info
 	}
 }

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyExitHandler.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyExitHandler.java	Tue Dec 14 12:10:26 2010	(r21503)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyExitHandler.java	Tue Dec 14 13:37:32 2010	(r21504)
@@ -39,7 +39,6 @@
 	
 	@Override
 	public void processDebugEvent(StrategoState strategoState) {
-		super.processDebugEvent(strategoState);
 		// do not pop the current stack frame here
 		// an exit breakpoint could also set the vm in the suspended state and then we will still need to access the current stack.
 		// Pop the frame in the method exit event, because no one can need it after the method has exited
@@ -49,5 +48,6 @@
 		// the current term on the frame should now be
 		//h.getGiven();
 		strategoState.currentFrame().setCurrentTerm(this.getGiven());
+		super.processDebugEvent(strategoState); // update current location info
 	}
 }

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyStepHandler.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyStepHandler.java	Tue Dec 14 12:10:26 2010	(r21503)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyStepHandler.java	Tue Dec 14 13:37:32 2010	(r21504)
@@ -36,7 +36,6 @@
 	
 	@Override
 	public void processDebugEvent(StrategoState strategoState) {
-		super.processDebugEvent(strategoState);
 		// the current term on the frame should now be
 		//h.getGiven();
 		
@@ -55,6 +54,7 @@
 		{
 			strategoState.currentFrame().setCurrentTerm(this.getGiven());
 		}
+		super.processDebugEvent(strategoState); // update current location info
 	}
 	
 }

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyVarHandler.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyVarHandler.java	Tue Dec 14 12:10:26 2010	(r21503)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/StrategyVarHandler.java	Tue Dec 14 13:37:32 2010	(r21504)
@@ -29,11 +29,11 @@
 	
 	@Override
 	public void processDebugEvent(StrategoState strategoState) {
-		super.processDebugEvent(strategoState);
 		
 		String varname = this.getVarname();
 		//System.out.println("localvar: " + varname);
 		// add the variable assignment to the currentStackFrame
 		strategoState.currentFrame().addVariable(varname, this.getGiven());
+		super.processDebugEvent(strategoState); // update current location info
 	}
 }

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/EventSpecManager.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/EventSpecManager.java	Tue Dec 14 12:10:26 2010	(r21503)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/eventspec/EventSpecManager.java	Tue Dec 14 13:37:32 2010	(r21504)
@@ -185,6 +185,7 @@
 		this.isStepOverActive = false;
 		this.isStepIntoActive = false;
 		this.isStepReturnActive = false;
+		state.setStepping(false);
 	}
 	
 	public EventTable getEventTable()

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/model/StrategoStackFrame.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/model/StrategoStackFrame.java	Tue Dec 14 12:10:26 2010	(r21503)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/model/StrategoStackFrame.java	Tue Dec 14 13:37:32 2010	(r21504)
@@ -7,6 +7,11 @@
 public class StrategoStackFrame {
 	
 	/**
+	 * Level represents the depth of the StackFrame.
+	 */
+	private int level;
+	
+	/**
 	 * The name of the current rule or strategy.
 	 */
 	private String name;
@@ -41,13 +46,15 @@
 	
 	/**
 	 * 
+	 * @param level The level of the frame. The top stackframe has level 0. 
 	 * @param filename The filename in which the current rule or strategy is defined.
 	 * @param name The name of the current rule or strategy.
 	 * @param locationInfo Location info about the current rule or strategy.
 	 * @param current The current stratego term.
 	 */
-	public StrategoStackFrame(String filename, String name, LocationInfo locationInfo,
+	public StrategoStackFrame(int level, String filename, String name, LocationInfo locationInfo,
 			IStrategoTerm current) {
+		this.level = level;
 		this.name = name;
 		this.filename = filename;
 		this.locationInfo = locationInfo;
@@ -57,7 +64,7 @@
 	
 	public String toString()
 	{
-		String val = "Frame @ " + this.name + "[" + this.filename + "]";
+		String val = "Frame "+this.level+" @ " + this.name + "[" + this.filename + "]";
 		if (currentLocationInfo != null) // specific location
 		{
 			val += "@"+currentLocationInfo.toShortString();
@@ -70,6 +77,11 @@
 		return val;
 	}
 	
+	public int getLevel()
+	{
+		return this.level;
+	}
+	
 	/**
 	 * Returns the name of the current rule or strategy.
 	 * 
@@ -165,6 +177,9 @@
 		return this.dynamicRuleNames;
 	}
 	
+	/**
+	 * Does not compare the current Term, the current LocationInfo and the eventType as these will change within a StackFrame during execution. 
+	 */
 	@Override
 	public boolean equals(Object obj) {
 		if (this == obj)
@@ -176,33 +191,38 @@
 		StrategoStackFrame other = (StrategoStackFrame) obj;
 		if (this.name == null || other.name == null)
 			return false;
-		if (this.current == null || other.current == null)
-			return false;
-		if (this.currentLocationInfo == null || other.currentLocationInfo == null)
-			return false;
+		//if (this.current == null || other.current == null)
+		//	return false;
+		//if (this.currentLocationInfo == null || other.currentLocationInfo == null)
+		//	return false;
 		if (this.filename == null || other.filename == null)
 			return false;
 		if (this.locationInfo == null || other.locationInfo == null)
 			return false;
 		
+		boolean c0 = this.level == other.level;
 		boolean c1 = this.name.equals(other.name);
 		//boolean c2 = this.current.equals(other.current); // TODO: do not equals on this.current, we should treat it as a variable
-		boolean c3 = this.currentLocationInfo.equals(other.currentLocationInfo);
+		//boolean c3 = this.currentLocationInfo.equals(other.currentLocationInfo);
 		boolean c4 = this.filename.equals(other.filename);
 		boolean c5 = this.locationInfo.equals(other.locationInfo); // TODO: use this one?
 		
-		if (c1 /*&& c2*/ && c3 && c4 && c5)
+		if (c0 && c1 /*&& c2 && c3*/ && c4 && c5)
 			return true;
 		return false;
 	}
 	
+	/**
+	 * Does not compare the current Term, the current LocationInfo and the eventType as these will change within a StackFrame during execution. 
+	 */
 	@Override
 	public int hashCode() {
 		final int prime = 61;
 		
 		int result = 1;
+		result = prime * result + this.level;
 		//result = prime * result + this.current.hashCode();
-		result = prime * result + this.currentLocationInfo.hashCode();
+		//result = prime * result + this.currentLocationInfo.hashCode();
 		result = prime * result + this.filename.hashCode();
 		result = prime * result + this.locationInfo.hashCode(); // TODO: ise this one?
 		result = prime * result + this.name.hashCode();

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/VMStateTester.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/VMStateTester.java	Tue Dec 14 12:10:26 2010	(r21503)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.test/test/java/org/strategoxt/debug/core/control/VMStateTester.java	Tue Dec 14 13:37:32 2010	(r21504)
@@ -116,7 +116,7 @@
 			// TODO: throw error
 		}
 		StrategoState state = new StrategoState();
-		StrategoStackFrame frame = new StrategoStackFrame(null, name, null, null);
+		StrategoStackFrame frame = new StrategoStackFrame(-1, null, name, null, null);
 		state.pushFrame(frame);
 		
 		this.willHitStates.add(state);
@@ -146,7 +146,8 @@
 		StrategoState state = new StrategoState();
 		LocationInfo currentLocationInfo = new LocationInfo(startLineNum, startTokenPos, endLineNum, endTokenPos);
 		IStrategoTerm current = null;
-		StrategoStackFrame frame = new StrategoStackFrame(filename, name, null, current);
+		// TODO: add stackframedepth
+		StrategoStackFrame frame = new StrategoStackFrame(-1, filename, name, null, current);
 		frame.setCurrentLocationInfo(currentLocationInfo, eventType);
 		state.pushFrame(frame);
 		return state;

From r.t.lindeman at student.tudelft.nl  Tue Dec 14 14:39:45 2010
From: r.t.lindeman at student.tudelft.nl (Ricky Lindeman)
Date: Tue, 14 Dec 2010 13:39:45 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21505 - in
	spoofax-imp/trunk: org.strategoxt.imp.debug.core
	org.strategoxt.imp.debug.core/lib
	org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model
	org.stra...
Message-ID: <201012141339.oBEDdj1B011630@proliant.st.ewi.tudelft.nl>

Author: RickyLindeman
Date: Tue Dec 14 13:39:45 2010
New Revision: 21505
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21505&sc=1

Log:
updated stratego-debug-core.jar in eclipse plugin:
 * Fixed stepping (into, over and return).
 * Fixed widget disposed problem (I hope)

Added:
   spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/AdapterDebug.java
Modified:
   spoofax-imp/trunk/org.strategoxt.imp.debug.core/.classpath
   spoofax-imp/trunk/org.strategoxt.imp.debug.core/lib/stratego-debug-core.jar
   spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/EStrategoStackFrame.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/StrategoDebugElement.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/StrategoDebugTarget.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/StrategoThread.java
   spoofax-imp/trunk/org.strategoxt.imp.debug.ui/.classpath

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.core/.classpath
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.core/.classpath	Tue Dec 14 13:37:32 2010	(r21504)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.core/.classpath	Tue Dec 14 13:39:45 2010	(r21505)
@@ -7,6 +7,5 @@
 	<classpathentry kind="lib" path="/org.strategoxt.imp.debug.stratego.transformer/utils/strategoxt.jar"/>
 	<classpathentry kind="lib" path="lib/stratego-transformer.jar"/>
 	<classpathentry kind="lib" path="lib/stratego-debug-runtime-java.jar"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.USER_LIBRARY/compiler-tools"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.core/lib/stratego-debug-core.jar
==============================================================================
Binary file (source and/or target). No diff available.

Added: spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/AdapterDebug.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/AdapterDebug.java	Tue Dec 14 13:39:45 2010	(r21505)
@@ -0,0 +1,23 @@
+package org.strjdbg.eclipse.core.str.model;
+
+/**
+ * Idea taken from pydev
+ * @author rlindeman
+ *
+ */
+public class AdapterDebug {
+
+	private static boolean log_adapter = false;
+	
+    public static void print(Object askedfor, Class<?> adapter) {
+        if(log_adapter){
+            System.out.println(askedfor.getClass().getName() + " requests "+adapter.toString());
+        }
+    }
+
+    public static void printDontKnow(Object askedfor, Class<?> adapter) {
+        if(log_adapter){
+            System.out.println("DONT KNOW: "+askedfor.getClass().getName() + " requests "+adapter.toString());
+        }
+    }
+}

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/EStrategoStackFrame.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/EStrategoStackFrame.java	Tue Dec 14 13:37:32 2010	(r21504)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/EStrategoStackFrame.java	Tue Dec 14 13:39:45 2010	(r21505)
@@ -49,37 +49,41 @@
 		extractVariablesFromFrame();
 	}
 	
+	private Object lock = new Object();
+	
 	/**
 	 * Saves the variables that are active in the current frame in fVariables.
 	 * The local variables emitted by the s-var debugger calls are shown
 	 * as well as the current Term, with the label *current* 
 	 * but also the dynamic rules.
 	 */
-	private void extractVariablesFromFrame()
+	private synchronized void extractVariablesFromFrame()
 	{		
-		List<EStrategoVariable> vars = new ArrayList<EStrategoVariable>();
-		EStrategoVariable currentVar = new EStrategoVariable(this.fTarget, this.frameData.getCurrentTerm(), "*current*");
-		currentVar.setValueChanged(true);
-		vars.add(currentVar);
-		for(Map.Entry<String, IStrategoTerm> entry : this.frameData.getVariables().entrySet())
-		{
-			EStrategoVariable v = new EStrategoVariable(this.fTarget, entry.getValue(), entry.getKey());
-			v.setValueChanged(true);
-			vars.add(v);
-		}
-		// add dynamic rules
-		if (this.frameData.getDynamicRules() != null)
-		{
-			for(String dynamicRuleName : this.frameData.getDynamicRules())
+		synchronized(lock){
+			List<EStrategoVariable> vars = new ArrayList<EStrategoVariable>();
+			EStrategoVariable currentVar = new EStrategoVariable(this.fTarget, this.frameData.getCurrentTerm(), "*current*");
+			currentVar.setValueChanged(true);
+			vars.add(currentVar);
+			for(Map.Entry<String, IStrategoTerm> entry : this.frameData.getVariables().entrySet())
 			{
-				EStrategoVariable v = new EStrategoVariable(this.fTarget, new BasicStrategoString("rule contents"), dynamicRuleName);
+				EStrategoVariable v = new EStrategoVariable(this.fTarget, entry.getValue(), entry.getKey());
 				v.setValueChanged(true);
 				vars.add(v);
 			}
+			// add dynamic rules
+			if (this.frameData.getDynamicRules() != null)
+			{
+				for(String dynamicRuleName : this.frameData.getDynamicRules())
+				{
+					EStrategoVariable v = new EStrategoVariable(this.fTarget, new BasicStrategoString("rule contents"), dynamicRuleName);
+					v.setValueChanged(true);
+					vars.add(v);
+				}
+			}
+			// TODO: use this.frameData to determine if the value was changed
+			fVariables = new IVariable[vars.size()];
+			fVariables = vars.toArray(fVariables);
 		}
-		// TODO: use this.frameData to determine if the value was changed
-		fVariables = new IVariable[vars.size()];
-		fVariables = vars.toArray(fVariables);
 		
 	}
 
@@ -295,5 +299,16 @@
 		}
 		return result;
 	}
+	
+	public String toString()
+	{
+		String s = "EStrategoStackFrame ";
+		if (this.getFrameData() != null)
+		{
+			// name of the file
+			s += this.getFrameData().toString();
+		}
+		return s;
+	}
 
 }

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/StrategoDebugElement.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/StrategoDebugElement.java	Tue Dec 14 13:37:32 2010	(r21504)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/StrategoDebugElement.java	Tue Dec 14 13:39:45 2010	(r21505)
@@ -57,6 +57,9 @@
 		{
 			return this.getLaunch();
 		}
+        //Platform.getAdapterManager().getAdapter(this, adapter);
+        AdapterDebug.printDontKnow(this, adapter);
+        // ongoing, I do not fully understand all the interfaces they'd like me to support
 		return super.getAdapter(adapter);
 	}
 	

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/StrategoDebugTarget.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/StrategoDebugTarget.java	Tue Dec 14 13:37:32 2010	(r21504)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/StrategoDebugTarget.java	Tue Dec 14 13:39:45 2010	(r21505)
@@ -159,7 +159,7 @@
 		this.fLaunch = launch;
 		// running threads
 		fThread = new StrategoThread(this);
-		fThreads = new IThread[] {fThread};
+		fThreads = new IThread[] {fThread}; // stratego is single threaded
 		
 		// handle events fired by the VM
 		fEventDispatch = new EventDispatchJob();

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/StrategoThread.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/StrategoThread.java	Tue Dec 14 13:37:32 2010	(r21504)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/StrategoThread.java	Tue Dec 14 13:39:45 2010	(r21505)
@@ -6,6 +6,11 @@
 import org.eclipse.debug.core.model.IStep;
 import org.eclipse.debug.core.model.IThread;
 
+/**
+ * As long as Stratego is single threaded this StrategoThread can directly access the single thread in the StrategoDebugTarget
+ * @author rlindeman
+ *
+ */
 public class StrategoThread extends StrategoDebugElement implements IThread {
 
 	/**
@@ -159,6 +164,7 @@
 				return;
 			}
 		}
+		System.out.println("ECLIPSE STEP INTO");
 		// TODO: the jdi eclipse plugin uses scheduling and such
 		((StrategoDebugTarget)getDebugTarget()).getDebugSessionManager().stepInto();
 	}
@@ -175,6 +181,7 @@
 				return;
 			}
 		}
+		System.out.println("ECLIPSE STEP OVER");
 		// TODO: the jdi eclipse plugin uses scheduling and such
 		((StrategoDebugTarget)getDebugTarget()).getDebugSessionManager().stepOver();
 	}
@@ -191,6 +198,7 @@
 				return;
 			}
 		}
+		System.out.println("ECLIPSE STEP RETURN");
 		// TODO: the jdi eclipse plugin uses scheduling and such
 		((StrategoDebugTarget)getDebugTarget()).getDebugSessionManager().stepReturn();
 	}
@@ -216,5 +224,12 @@
 		fStepping = stepping;
 	}
 	
+	public String toString()
+	{
+		String s = "StrategoThread";
+		
+		return s;
+	}
+	
 
 }

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.ui/.classpath
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.ui/.classpath	Tue Dec 14 13:37:32 2010	(r21504)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.ui/.classpath	Tue Dec 14 13:39:45 2010	(r21505)
@@ -3,6 +3,5 @@
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/J2SE-1.5"/>
 	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
 	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="lib" path="/usr/lib/eclipse/plugins/org.eclipse.swt.gtk.linux.x86_3.5.2.v3557f.jar"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>

From L.C.L.Kats at tudelft.nl  Tue Dec 14 15:05:31 2010
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Tue, 14 Dec 2010 14:05:31 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21506 -
	spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services
Message-ID: <201012141405.oBEE5VpU012154@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: Tue Dec 14 14:05:31 2010
New Revision: 21506
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21506&sc=1

Log:
Workaround for Spoofax/321.

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoObserver.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoObserver.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoObserver.java	Tue Dec 14 13:39:45 2010	(r21505)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoObserver.java	Tue Dec 14 14:05:31 2010	(r21506)
@@ -10,6 +10,7 @@
 import java.io.IOException;
 import java.net.URL;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
@@ -223,8 +224,12 @@
 					file = fileCopier.copyToTempFile(file);
 				classpath[i] = file.toURI().toURL();
 			}
-			ClassLoader loader = descriptor.getAttachmentProvider().getClassLoader();
-			runtime.loadJars(loader, classpath);
+			Class<?> attachments = descriptor.getAttachmentProvider();
+			Debug.log("Loading JARs from " + Arrays.toString(classpath));
+			Debug.log("Parent class loader: ", attachments.getName() + "; " + attachments.getClassLoader().getClass().getName());
+			// TODO: Use plugin's parent class loader? (Spoofax/322)
+			// runtime.loadJars(attachments.getClassLoader(), classpath);
+			runtime.loadJars(getClass().getClassLoader(), classpath);
 			Debug.stopTimer("Successfully loaded " + jars);
 		} catch (SecurityException e) {
 			reportLoadException(e, jars);

From L.C.L.Kats at tudelft.nl  Tue Dec 14 15:07:42 2010
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Tue, 14 Dec 2010 14:07:42 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21507 - in
	spoofax-imp/trunk: org.strategoxt.imp.feature
	org.strategoxt.imp.updatesite
Message-ID: <201012141407.oBEE7gpW012176@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: Tue Dec 14 14:07:42 2010
New Revision: 21507
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21507&sc=1

Log:
New release 0.6.0.2, fixing Spoofax/320 (a deployment bug) and Spoofax/321 (a bug that happened only post-deployment...)

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.feature/feature.xml
   spoofax-imp/trunk/org.strategoxt.imp.updatesite/site.xml

Modified: spoofax-imp/trunk/org.strategoxt.imp.feature/feature.xml
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.feature/feature.xml	Tue Dec 14 14:05:31 2010	(r21506)
+++ spoofax-imp/trunk/org.strategoxt.imp.feature/feature.xml	Tue Dec 14 14:07:42 2010	(r21507)
@@ -2,7 +2,7 @@
 <feature
       id="org.strategoxt.imp"
       label="Spoofax/IMP"
-      version="0.6.0.1"
+      version="0.6.0.2"
       plugin="org.strategoxt.imp.runtime">
 
    <description url="http://strategoxt.org/Stratego/Spoofax-IMP">

Modified: spoofax-imp/trunk/org.strategoxt.imp.updatesite/site.xml
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.updatesite/site.xml	Tue Dec 14 14:05:31 2010	(r21506)
+++ spoofax-imp/trunk/org.strategoxt.imp.updatesite/site.xml	Tue Dec 14 14:07:42 2010	(r21507)
@@ -3,7 +3,7 @@
    <description name="Spoofax/IMP" url="http://www.lclnet.nl/update/">
       Spoofax/IMP update site
    </description>
-   <feature url="features/org.strategoxt.imp_0.6.0.1.jar" id="org.strategoxt.imp" version="0.6.0.1">
+   <feature url="features/org.strategoxt.imp_0.6.0.2.jar" id="org.strategoxt.imp" version="0.6.0.2">
       <category name="Spoofax/IMP"/>
    </feature>
    <category-def name="Spoofax/IMP" label="Spoofax/IMP">

From R.B.Vermaas at tudelft.nl  Tue Dec 14 16:07:29 2010
From: R.B.Vermaas at tudelft.nl (Rob Vermaas)
Date: Tue, 14 Dec 2010 15:07:29 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21508 -
	spoofax-imp/trunk/org.strategoxt.imp.testing/editor
Message-ID: <201012141507.oBEF7TKP013148@proliant.st.ewi.tudelft.nl>

Author: rob
Date: Tue Dec 14 15:07:28 2010
New Revision: 21508
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21508&sc=1

Log:
make parse test description bold

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Colorer.esv

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Colorer.esv
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Colorer.esv	Tue Dec 14 14:07:42 2010	(r21507)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Colorer.esv	Tue Dec 14 15:07:28 2010	(r21508)
@@ -10,4 +10,6 @@
   
   _.RegexPattern : darkgreen
   _.AtomLiteral : darkgreen   
-  _.description : darkgreen  
\ No newline at end of file
+  _.description : 0 128 0 bold 
+  
+  
\ No newline at end of file

From R.B.Vermaas at tudelft.nl  Tue Dec 14 16:07:54 2010
From: R.B.Vermaas at tudelft.nl (Rob Vermaas)
Date: Tue, 14 Dec 2010 15:07:54 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21509 - in
	spoofax-imp/trunk/org.strategoxt.imp.testing:
	editor/java/org/strategoxt/imp/testing/strategies trans
Message-ID: <201012141507.oBEF7sXo013153@proliant.st.ewi.tudelft.nl>

Author: rob
Date: Tue Dec 14 15:07:53 2010
New Revision: 21509
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21509&sc=1

Log:
added input-dialog strategy for some user interaction

Added:
   spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/strategies/input_dialog_0_3.java
Modified:
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/spoofax_testing.str

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/strategies/input_dialog_0_3.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/strategies/input_dialog_0_3.java	Tue Dec 14 15:07:53 2010	(r21509)
@@ -0,0 +1,36 @@
+package org.strategoxt.imp.testing.strategies;
+
+import static org.spoofax.interpreter.core.Tools.isTermString;
+
+import org.eclipse.jface.dialogs.InputDialog;
+import org.eclipse.swt.widgets.Display;
+import org.spoofax.interpreter.terms.IStrategoString;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.strategoxt.lang.Context;
+import org.strategoxt.lang.Strategy;
+
+public class input_dialog_0_3 extends Strategy {
+
+	public static input_dialog_0_3 instance = new input_dialog_0_3();
+	
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3) {
+		if (!isTermString(t1)) return null;
+		if (!isTermString(t2)) return null;
+		if (!isTermString(t3)) return null;
+		
+		String title   = ((IStrategoString)t1).stringValue();
+		String message = ((IStrategoString)t2).stringValue();
+		String value   = ((IStrategoString)t3).stringValue();
+
+        final InputDialog d = new InputDialog(null, title, message, value, null);
+		Display.getDefault().syncExec(new Runnable() {
+            public void run() {
+            	d.open();
+            }
+        });		
+        
+		return context.getFactory().makeString(d.getValue());
+	}
+
+}

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/spoofax_testing.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/trans/spoofax_testing.str	Tue Dec 14 15:07:28 2010	(r21508)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/spoofax_testing.str	Tue Dec 14 15:07:53 2010	(r21509)
@@ -47,9 +47,10 @@
   // For references, this rule is invoked using the resolved term.
   editor-hover:
     (string(_,s,_), _, _, _, _) -> hover
-    with
-      hover := <parse-string-and-pp-aterm ; hover-input-string>s
+    where
+      hover := <parse-string-and-pp-aterm ; hover-input-string>s  
 
+  
   hover-input-string = 
     <concat-strings>
       [ "Using the current parsetable, the input string result in the following AST:<br>"
@@ -62,4 +63,4 @@
   ; pp    := <pp-aterm-box>ast
   ; <box2text-string(|80)>pp
 
-
+  external input-dialog(|title, message, initial)

From L.C.L.Kats at tudelft.nl  Tue Dec 14 23:16:57 2010
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Tue, 14 Dec 2010 22:16:57 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21510 - in
	spoofax/branches/jsglr-gwt: . jsglr-gwt
Message-ID: <201012142216.oBEMGvoS019296@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: Tue Dec 14 22:16:57 2010
New Revision: 21510
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21510&sc=1

Log:
jsglr-gwt branch, initial import (JSGLR trunk r21173)

Added:
   spoofax/branches/jsglr-gwt/
   spoofax/branches/jsglr-gwt/jsglr-gwt/
      - copied from r21173, spoofax/trunk/spoofax/org.spoofax.jsglr/

From R.B.Vermaas at tudelft.nl  Wed Dec 15 09:15:05 2010
From: R.B.Vermaas at tudelft.nl (Rob Vermaas)
Date: Wed, 15 Dec 2010 08:15:05 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21511 -
	spoofax-imp/trunk/org.strategoxt.imp.testing/trans
Message-ID: <201012150815.oBF8F506027505@proliant.st.ewi.tudelft.nl>

Author: rob
Date: Wed Dec 15 08:15:05 2010
New Revision: 21511
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21511&sc=1

Log:
for now, use first parsetable found in include/

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/file-resolving.str
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/generate.str
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/spoofax_testing.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/file-resolving.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/trans/file-resolving.str	Tue Dec 14 22:16:57 2010	(r21510)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/file-resolving.str	Wed Dec 15 08:15:05 2010	(r21511)
@@ -5,7 +5,7 @@
   libstratego-aterm
   include/Spoofax-Testing
   lib/editor-common.generated
-analysis
+  analysis
 strategies
 
   scope-paths(s | path, project-path) =
@@ -34,8 +34,6 @@
   editor-resolve:
     (file(f), position, ast, path, project-path) ->  <resolve-path(|path); open-editor>f
 
-  external open-editor(|)
-
   editor-complete:
     (unquoted(COMPLETION(_)), _, _, _, _) -> proposals
     where  
@@ -75,5 +73,5 @@
     )
   ; string-sort
     
-      
-      
+  external open-editor(|)
+

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/generate.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/trans/generate.str	Tue Dec 14 22:16:57 2010	(r21510)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/generate.str	Wed Dec 15 08:15:05 2010	(r21511)
@@ -127,7 +127,7 @@
       abs := <resolve-path(|path)>f
     ; if not(file-exists) then
         if <oncetd(?parse-test(_, _, _, _) ; oncetd(?file(f)); ?parse-test(_, _, string(_,s,_), _))>ast then
-          result := <parse-string>s 
+          result := <spt-parse-string>s 
         else
           fatal-err-msg(|$[Could not find a string input for generating AST.])  
         end 

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/spoofax_testing.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/trans/spoofax_testing.str	Tue Dec 14 22:16:57 2010	(r21510)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/spoofax_testing.str	Wed Dec 15 08:15:05 2010	(r21511)
@@ -4,6 +4,7 @@
   libstratego-lib
   libstratego-gpp
   libstratego-aterm
+  libstratego-sglr
   include/Spoofax-Testing
   lib/editor-common.generated
   analysis
@@ -11,10 +12,8 @@
   generate
   file-resolving
 
-rules // Main editor interface (defined by editor/Spoofax-Testing-Builders and -References.esv)
-  
-  // Analyzes the current program, returning a tuple with errors, warnings, and notes;
-  // each a list of (term, message) tuples or simply (message) terms.
+rules
+    
   editor-analyze:
     (ast, path, project-path) -> (ast, errors, warnings, notes)
     with
@@ -30,26 +29,20 @@
         end
       | path, project-path)
   
-  // Transforms a selection to Java
   generate-java:
     (selected, position, ast, path, project-path) -> result
     with
       scope-paths( result := <to-java> selected | path, project-path)
   
-  // Prints the abstract syntax ATerm of a selection.
   generate-aterm:
-    (selected, position, ast, path, project-path) -> (filename, result)
+    (selected, position, ast, path, project-path) -> (filename, selected)
     with
-      filename := <guarantee-extension(|"aterm")> path;
-      result   := selected // we just return the input term
+      filename := <guarantee-extension(|"aterm")> path
   
-  // Returns "hover help" information for a particular node in the editor.
-  // For references, this rule is invoked using the resolved term.
   editor-hover:
     (string(_,s,_), _, _, _, _) -> hover
     where
-      hover := <parse-string-and-pp-aterm ; hover-input-string>s  
-
+      hover := <parse-string-and-pp-aterm ; hover-input-string>s 
   
   hover-input-string = 
     <concat-strings>
@@ -59,8 +52,25 @@
       ] 
 
   parse-string-and-pp-aterm =
-    ast   := <parse-string>
+    ast   := <spt-parse-string>
   ; pp    := <pp-aterm-box>ast
   ; <box2text-string(|80)>pp
 
   external input-dialog(|title, message, initial)
+
+// 
+strategies
+
+  spt-get-parsetable =
+  	spt-parsetable
+   <+ <readdir>"./include" 
+    ; fetch-elem(has-extension(|"tbl")) 
+    ; pt := <ReadFromFile>$[./include/[<id>]]
+    ; rules( spt-parsetable := pt )    
+  	
+  spt-parse-string =
+    parse-string(
+      id
+    | <spt-get-parsetable>
+    )    
+    
\ No newline at end of file

From r.t.lindeman at student.tudelft.nl  Thu Dec 16 10:57:42 2010
From: r.t.lindeman at student.tudelft.nl (Ricky Lindeman)
Date: Thu, 16 Dec 2010 09:57:42 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21513 -
	strategoxt/trunk/strc-core/lib/stratego/strc/parse
Message-ID: <201012160957.oBG9vgDY019566@proliant.st.ewi.tudelft.nl>

Author: RickyLindeman
Date: Thu Dec 16 09:57:41 2010
New Revision: 21513
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21513&sc=1

Log:
Added "--preserve-locations" option to parse-stratego (this option also exists in sglri)

Modified:
   strategoxt/trunk/strc-core/lib/stratego/strc/parse/parse-stratego.str

Modified: strategoxt/trunk/strc-core/lib/stratego/strc/parse/parse-stratego.str
==============================================================================
--- strategoxt/trunk/strc-core/lib/stratego/strc/parse/parse-stratego.str	Wed Dec 15 12:11:24 2010	(r21512)
+++ strategoxt/trunk/strc-core/lib/stratego/strc/parse/parse-stratego.str	Thu Dec 16 09:57:41 2010	(r21513)
@@ -60,7 +60,8 @@
 
   + ps-preserve-comments-option
   + ps-preserve-positions-option
-
+  + ps-preserve-locations-option
+  
   + Option(fail, fail, !"")
   + Option(fail, fail, !"I/O options:")
 
@@ -99,6 +100,22 @@
 
 strategies
 
+  ps-preserve-locations-option =
+    Option("--preserve-locations"
+    , <ps-set-preserve-locations> "yes"
+    , !"--preserve-locations
+                    Preserve source code locations in the input file as annotations 
+                    of the abstract syntax tree. [off]"
+    )
+
+  ps-set-preserve-locations =
+    <set-config> ("preserve-locations", <id>)
+
+  ps-must-preserve-locations =
+    <get-config> "preserve-locations" => "yes"
+
+strategies
+
   parse-stratego-file =
     parse-stratego-trm(|["-i", <id>])
 
@@ -159,7 +176,11 @@
     ; if <ps-must-preserve-positions> meta then
         asfix-anno-position-info(|"")
       end
-
+      
+    ; if <ps-must-preserve-locations> meta then
+        asfix-anno-location
+      end
+        
     ; if <ps-must-preserve-asfix-in-quotes> meta then
         implode-asfix-skip-concrete-syntax
       else

From karltk at strategoxt.org  Thu Dec 16 13:01:00 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 12:01:00 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21514 -
	spoofax/branches/jsglr-gwt/jsglr-gwt
Message-ID: <201012161201.oBGC10R6022317@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 12:01:00 2010
New Revision: 21514
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21514&sc=1

Log:
Dummy change.

Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/AUTHORS

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/AUTHORS
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/AUTHORS	Thu Dec 16 09:57:41 2010	(r21513)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/AUTHORS	Thu Dec 16 12:01:00 2010	(r21514)
@@ -1,2 +1,3 @@
 
-Karl Trygve Kalleberg < karltk near strategoxt dot org > - Primary author and maintainer
\ No newline at end of file
+Karl Trygve Kalleberg < karltk near strategoxt dot org > - Primary author and maintainer
+Lennart Kats < l.c.l.kats near tudelft dot nl > - Parser guru and bugslinger extraordinaire 

From karltk at strategoxt.org  Thu Dec 16 15:59:08 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 14:59:08 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21515 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt: . src/org/spoofax
	src/org/spoofax/client src/org/spoofax/jsglr
	src/org/spoofax/jsglr/client src/org/spoofax/jsglr/server s...
Message-ID: <201012161459.oBGEx89x026722@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 14:59:08 2010
New Revision: 21515
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21515&sc=1

Log:
Initial import.

Added:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/JsglrGWT.gwt.xml
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/client/
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/client/JSGLREntryPoint.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Accept.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Accept.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Action.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Action.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ActionItem.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ActionItem.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ActionState.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ActionState.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Amb.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/AmbKey.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/AmbKey.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/AmbiguityManager.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/AmbiguityManager.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/AmbiguityMap.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/AmbiguityMap.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Associativity.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Associativity.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/BacktrackPosition.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/BacktrackPosition.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Disambiguator.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/FatalException.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/FatalException.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/FilterException.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/FilterException.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/FineGrainedOnRegion.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/FineGrainedOnRegion.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Frame.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Frame.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Goto.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Goto.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IParseNode.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/IParseNode.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IRecoveryParser.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/IRecoveryParser.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IRecoveryResult.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/IRecoveryResult.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentInfo.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/IndentInfo.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentTokenizer.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/IndentTokenizer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentationFilter.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/IndentationFilter.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentationHandler.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/IndentationHandler.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/InvalidParseTableException.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/InvalidParseTableException.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Label.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Label.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Link.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Link.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Main.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/MarkMap.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/MarkMap.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Measures.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Measures.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/MultiBadTokenException.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/MultiBadTokenException.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/NewStructureSkipper.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/NewStructureSkipper.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/NoRecoveryRulesException.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/NoRecoveryRulesException.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/NotImplementedException.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/NotImplementedException.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseAvoid.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseAvoid.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseException.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseException.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseNode.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParsePrefer.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParsePrefer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseProductionNode.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseProductionNode.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseReject.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseReject.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseTable.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTimeoutException.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseTimeoutException.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTreeTools.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseTreeTools.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParserException.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParserException.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParserHistory.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParserHistory.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Path.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Path.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/PositionMap.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/PositionMap.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Priority.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Priority.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Production.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Production.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ProductionAttributes.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ProductionAttributes.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ProductionType.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ProductionType.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Range.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Range.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/RangeList.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/RangeList.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/RecoverDisambiguator.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/RecoverDisambiguator.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/RecoverNode.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/RecoverNode.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/RecoveryConnector.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/RecoveryConnector.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Reduce.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Reduce.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ReduceLookahead.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ReduceLookahead.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/RegionRecovery.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/RegionRecovery.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/SGLR.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Shift.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Shift.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/StartSymbolException.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/StartSymbolException.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/State.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/State.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/StructuralTokenRecognizer.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/StructuralTokenRecognizer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/StructureSkipSuggestion.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/StructureSkipSuggestion.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Term.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Term.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/server/
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/server/ParseTableManager.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseTableManager.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/server/RemoteParseTableServiceImpl.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/BadTokenException.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/BadTokenException.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/RemoteParseTableService.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/RemoteParseTableServiceAsync.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/SGLRException.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/SGLRException.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/TokenExpectedException.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/TokenExpectedException.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/Tools.java
      - copied, changed from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Tools.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/AFun.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermAppl.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermFactory.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermInt.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ParseError.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/war/
   spoofax/branches/jsglr-gwt/jsglr-gwt/war/Jsglr_gwt.css
   spoofax/branches/jsglr-gwt/jsglr-gwt/war/Jsglr_gwt.html
   spoofax/branches/jsglr-gwt/jsglr-gwt/war/WEB-INF/
   spoofax/branches/jsglr-gwt/jsglr-gwt/war/WEB-INF/classes/
   spoofax/branches/jsglr-gwt/jsglr-gwt/war/WEB-INF/classes/org/
   spoofax/branches/jsglr-gwt/jsglr-gwt/war/WEB-INF/classes/org/spoofax/
   spoofax/branches/jsglr-gwt/jsglr-gwt/war/WEB-INF/classes/org/spoofax/JsglrGWT.gwt.xml
   spoofax/branches/jsglr-gwt/jsglr-gwt/war/WEB-INF/web.xml
Deleted:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Accept.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Action.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ActionItem.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ActionState.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Amb.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/AmbKey.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/AmbiguityManager.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/AmbiguityMap.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Associativity.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/BacktrackPosition.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/BadTokenException.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Disambiguator.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/FatalException.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/FilterException.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/FineGrainedOnRegion.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Frame.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Goto.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/IParseNode.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/IRecoveryParser.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/IRecoveryResult.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/IndentInfo.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/IndentTokenizer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/IndentationFilter.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/IndentationHandler.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/InvalidParseTableException.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Label.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Link.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/MarkMap.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Measures.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/MultiBadTokenException.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/NewStructureSkipper.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/NoRecoveryRulesException.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/NotImplementedException.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseAvoid.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseException.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseNode.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParsePrefer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseProductionNode.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseReject.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseTable.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseTableManager.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseTimeoutException.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseTreeTools.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParserException.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParserHistory.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Path.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/PositionMap.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Priority.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Production.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ProductionAttributes.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ProductionType.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Range.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/RangeList.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/RecoverDisambiguator.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/RecoverNode.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/RecoveryConnector.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Reduce.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ReduceLookahead.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/RegionRecovery.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/SGLR.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/SGLRException.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Shift.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/StartSymbolException.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/State.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/StructuralTokenRecognizer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/StructureSkipSuggestion.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Term.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/TokenExpectedException.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Tools.java
Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/.classpath
   spoofax/branches/jsglr-gwt/jsglr-gwt/.project
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/ParseTestCase.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestBooleans.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG1.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG2.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG_ambi.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG_avoid_1.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG_avoid_2.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG_left_assoc.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG_prefer_1.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG_prefer_2.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG_reject_1.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG_reject_2.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG_right_assoc.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestIParseNode.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestStratego.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/.classpath
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/.classpath	Thu Dec 16 12:01:00 2010	(r21514)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/.classpath	Thu Dec 16 14:59:08 2010	(r21515)
@@ -1,7 +1,9 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/J2SE-1.5"/>
-	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
 	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="output" path="bin"/>
+	<classpathentry kind="src" output="test-classes" path="test"/>
+	<classpathentry kind="con" path="com.google.gwt.eclipse.core.GWT_CONTAINER"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/3"/>
+	<classpathentry kind="output" path="war/WEB-INF/classes"/>
 </classpath>

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/.project
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/.project	Thu Dec 16 12:01:00 2010	(r21514)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/.project	Thu Dec 16 14:59:08 2010	(r21515)
@@ -1,40 +1,28 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <projectDescription>
-	<name>org.spoofax.jsglr</name>
+	<name>jsglr-gwt</name>
 	<comment></comment>
 	<projects>
 	</projects>
 	<buildSpec>
 		<buildCommand>
-			<name>net.sourceforge.texlipse.builder.TexlipseBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
 			<name>org.eclipse.jdt.core.javabuilder</name>
 			<arguments>
 			</arguments>
 		</buildCommand>
 		<buildCommand>
-			<name>org.eclipse.ajdt.core.ajbuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>org.eclipse.pde.ManifestBuilder</name>
+			<name>com.google.gdt.eclipse.core.webAppProjectValidator</name>
 			<arguments>
 			</arguments>
 		</buildCommand>
 		<buildCommand>
-			<name>org.eclipse.pde.SchemaBuilder</name>
+			<name>com.google.gwt.eclipse.core.gwtProjectValidator</name>
 			<arguments>
 			</arguments>
 		</buildCommand>
 	</buildSpec>
 	<natures>
-		<nature>org.eclipse.ajdt.ui.ajnature</nature>
-		<nature>net.sourceforge.texlipse.builder.TexlipseNature</nature>
 		<nature>org.eclipse.jdt.core.javanature</nature>
-		<nature>org.eclipse.pde.PluginNature</nature>
+		<nature>com.google.gwt.eclipse.core.gwtNature</nature>
 	</natures>
 </projectDescription>

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/JsglrGWT.gwt.xml
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/JsglrGWT.gwt.xml	Thu Dec 16 14:59:08 2010	(r21515)
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module rename-to='jsglrgwt'>
+
+  <inherits name='com.google.gwt.user.User'/>
+
+  <entry-point class='org.spoofax.client.JSGLREntryPoint'/>
+
+  <source path='jsglr.client'/>
+  <source path='jsglr.shared'/>
+  <source path='client'/>
+
+</module>

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/client/JSGLREntryPoint.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/client/JSGLREntryPoint.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -0,0 +1,52 @@
+package org.spoofax.client;
+
+import java.io.IOException;
+
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParseException;
+import org.spoofax.jsglr.client.ParseTable;
+import org.spoofax.jsglr.client.SGLR;
+import org.spoofax.jsglr.shared.BadTokenException;
+import org.spoofax.jsglr.shared.SGLRException;
+import org.spoofax.jsglr.shared.TokenExpectedException;
+import org.spoofax.jsglr.shared.terms.ATerm;
+import org.spoofax.jsglr.shared.terms.ATermFactory;
+
+import com.google.gwt.core.client.EntryPoint;
+import com.google.gwt.user.client.ui.Label;
+import com.google.gwt.user.client.ui.RootPanel;
+
+public class JSGLREntryPoint implements EntryPoint {
+
+	@Override
+	public void onModuleLoad() {
+		RootPanel.get().add(new Label("Booting"));
+		try {
+			SGLR sglr = new SGLR(new ATermFactory(), new ParseTable(null));
+			ATerm r = sglr.parse("foo bar baz");
+			if(r != null)
+				RootPanel.get().add(new Label(r.toString()));
+			else {
+				RootPanel.get().add(new Label("Parsing failed"));
+			}
+		} catch (InvalidParseTableException e) {
+			wrap(e);
+		} catch (TokenExpectedException e) {
+			wrap(e);
+		} catch (BadTokenException e) {
+			wrap(e);
+		} catch (ParseException e) {
+			wrap(e);
+		} catch (IOException e) {
+			wrap(e);
+		} catch (SGLRException e) {
+			wrap(e);
+		}
+
+	}
+
+	private static void wrap(Exception e) {
+		throw new RuntimeException(e);
+	}
+
+}

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Accept.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Accept.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Accept.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Accept.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -5,7 +5,8 @@
  * 
  * Licensed under the GNU Lesser General Public License, v2.1
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
+
 
 public class Accept extends ActionItem {
 

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Action.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Action.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Action.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Action.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -5,10 +5,12 @@
  * 
  * Licensed under the GNU Lesser General Public License, v2.1
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 import java.io.Serializable;
 
+import org.spoofax.jsglr.shared.Tools;
+
 
 public class Action implements Serializable {
 

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ActionItem.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ActionItem.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ActionItem.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ActionItem.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -5,7 +5,7 @@
  * 
  * Licensed under the GNU Lesser General Public License, v2.1
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 import java.io.Serializable;
 

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ActionState.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ActionState.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ActionState.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ActionState.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -5,11 +5,12 @@
  * 
  * Licensed under the GNU Lesser General Public License, v2.1
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 import java.io.Serializable;
 
 
+
 public class ActionState implements Serializable {
     static final long serialVersionUID = 2059615768756265051L;
 

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Amb.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Amb.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -2,22 +2,23 @@
  * Created on 30.mar.2006
  *
  * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
- * 
+ *
  * Licensed under the GNU General Public License, v2
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 import java.util.ArrayList;
 import java.util.List;
 
-import aterm.ATerm;
-import aterm.ATermList;
-import aterm.ATermFactory;
+import org.spoofax.jsglr.shared.terms.ATerm;
+import org.spoofax.jsglr.shared.terms.ATermFactory;
+import org.spoofax.jsglr.shared.terms.ATermList;
+
 
 public class Amb extends IParseNode {
-    
+
     private final List<IParseNode> alternatives;
-    
+
     private int cachedHashCode = NO_HASH_CODE;
 
     Amb(IParseNode left, IParseNode right) {
@@ -30,7 +31,8 @@
         this.alternatives = alternatives;
     }
 
-    public ATerm toParseTree(ParseTable pt) {
+    @Override
+	public ATerm toParseTree(ParseTable pt) {
 
         ATermFactory factory = pt.getFactory();
         ATermList list = factory.makeList();
@@ -40,7 +42,7 @@
 
     private ATermList addToParseTree(ParseTable pt, ATermFactory factory,
             ATermList list) {
-        
+
         for (int i = alternatives.size() - 1; i >= 0; i--) {
             IParseNode alt = alternatives.get(i);
             if (alt instanceof Amb) {
@@ -52,7 +54,8 @@
         return list;
     }
 
-    @Deprecated
+    @Override
+	@Deprecated
     void clear() {
         for (int i = 0; i < alternatives.size(); i++) {
             alternatives.get(i).clear();
@@ -73,7 +76,7 @@
     public List<IParseNode> getAlternatives() {
         return alternatives;
     }
-    
+
     @Override
     public boolean equals(Object obj) {
         if(!(obj instanceof Amb))
@@ -89,7 +92,7 @@
                 return false;
         return true;
     }
-    
+
     @Override
     public int hashCode() {
         if (cachedHashCode != NO_HASH_CODE) {

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/AmbKey.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/AmbKey.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/AmbKey.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/AmbKey.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -5,7 +5,8 @@
  * 
  * Licensed under the GNU General Public License, v2
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
+
 
 public class AmbKey {
 

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/AmbiguityManager.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/AmbiguityManager.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/AmbiguityManager.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/AmbiguityManager.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -5,11 +5,13 @@
  * 
  * Licensed under the GNU General Public License, v2
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 import java.util.HashMap;
 import java.util.Map;
 
+import org.spoofax.jsglr.shared.Tools;
+
 public class AmbiguityManager {
 
     private int injectionFilterSucceededCount;

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/AmbiguityMap.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/AmbiguityMap.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/AmbiguityMap.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/AmbiguityMap.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -5,7 +5,7 @@
  * 
  * Licensed under the GNU General Public License, v2
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 public class AmbiguityMap {
 

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Associativity.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Associativity.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Associativity.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Associativity.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -5,7 +5,7 @@
  * 
  * Licensed under the GNU General Public License, v2
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 public class Associativity {
 

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/BacktrackPosition.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/BacktrackPosition.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/BacktrackPosition.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/BacktrackPosition.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -1,4 +1,4 @@
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 import java.util.ArrayList;
 

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Disambiguator.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Disambiguator.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -2,18 +2,20 @@
  * Created on 11.apr.2006
  *
  * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
- * 
+ *
  * Licensed under the GNU General Public License, v2
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 import java.util.ArrayList;
 import java.util.LinkedList;
 import java.util.List;
 
-import aterm.AFun;
-import aterm.ATerm;
-import aterm.ParseError;
+import org.spoofax.jsglr.shared.SGLRException;
+import org.spoofax.jsglr.shared.Tools;
+import org.spoofax.jsglr.shared.terms.AFun;
+import org.spoofax.jsglr.shared.terms.ATerm;
+import org.spoofax.jsglr.shared.terms.ParseError;
 
 /**
  * @author Karl Trygve Kalleberg <karltk near strategoxt.org>
@@ -26,52 +28,52 @@
     private static final int FILTER_LEFT_WINS = 2;
 
     private static final int FILTER_RIGHT_WINS = 3;
-    
+
     private boolean filterAny;
-    
+
     private boolean filterCycles;
-    
+
     private boolean filterDirectPreference;
-    
+
     private boolean filterPreferenceCount;
-    
+
     private boolean filterInjectionCount;
-    
+
     private boolean filterTopSort;
-    
+
     private boolean filterReject;
-    
+
     private boolean filterAssociativity;
-    
+
     private boolean filterPriorities;
-    
+
     private boolean filterStrict;
-    
+
     // Current parser state
 
     private AmbiguityManager ambiguityManager;
-    
+
     private SGLR parser;
 
     private ParseTable parseTable;
 
     // private Map<AmbKey, IParseNode> resolvedTable = new HashMap<AmbKey, IParseNode>();
-    
+
     /**
      * Sets whether any filter should be applied at all (excluding the top sort filter).
      */
     public final void setFilterAny(boolean filterAny) {
         this.filterAny = filterAny;
     }
-    
+
     public final void setFilterDirectPreference(boolean filterDirectPreference) {
         this.filterDirectPreference = filterDirectPreference;
     }
-    
+
     public boolean getFilterDirectPreference() {
         return filterDirectPreference;
     }
-    
+
     /**
      * For preference count filtering, see {@link #setFilterPreferenceCount(boolean)}.
      */
@@ -79,7 +81,7 @@
     public final void setFilterIndirectPreference(boolean filterIndirectPreference) {
         throw new UnsupportedOperationException();
     }
-    
+
     /**
      * For preference count filtering, see {@link #getFilterPreferenceCount()}.
      */
@@ -87,55 +89,55 @@
     public boolean getFilterIndirectPreference() {
         throw new UnsupportedOperationException();
     }
-    
+
     public final void setFilterInjectionCount(boolean filterInjectionCount) {
         this.filterInjectionCount = filterInjectionCount;
     }
-    
+
     public boolean getFilterInjectionCount() {
         return filterInjectionCount;
     }
-    
+
     public final void setFilterPreferenceCount(boolean filterPreferenceCount) {
         this.filterPreferenceCount = filterPreferenceCount;
     }
-    
+
     public boolean getFilterPreferenceCount() {
         return filterPreferenceCount;
     }
-    
+
     public final void setFilterTopSort(boolean filterTopSort) {
         this.filterTopSort = filterTopSort;
     }
-    
+
     public boolean getFilterTopSort() {
         return filterTopSort;
     }
-    
+
     public void setFilterCycles(boolean filterCycles) {
         this.filterCycles = filterCycles;
     }
-    
+
     public boolean isFilterCycles() {
         return filterCycles;
     }
-    
+
     public void setFilterAssociativity(boolean filterAssociativity) {
         this.filterAssociativity = filterAssociativity;
     }
-    
+
     public boolean getFilterAssociativity() {
         return filterAssociativity;
     }
-    
+
     public void setFilterPriorities(boolean filterPriorities) {
         this.filterPriorities = filterPriorities;
     }
-    
+
     public boolean getFilterPriorities() {
         return filterPriorities;
     }
-    
+
     /**
      * Sets whether to enable strict filtering, triggering a
      * FilterException when the priorities filter encounters
@@ -144,37 +146,37 @@
     public void setFilterStrict(boolean filterStrict) {
         this.filterStrict = filterStrict;
     }
-    
+
     public boolean getFilterStrict() {
         return filterStrict;
     }
-    
+
     public final void setHeuristicFilters(boolean heuristicFilters) {
         setFilterPreferenceCount(heuristicFilters);
         setFilterInjectionCount(heuristicFilters);
     }
-    
+
     public void setFilterReject(boolean filterReject) {
         this.filterReject = filterReject;
     }
-    
+
     public boolean getFilterReject() {
         return filterReject;
     }
-    
+
     public final void setDefaultFilters() {
         filterAny = true;
         filterCycles = false; // TODO: filterCycles; enable by default
-        filterDirectPreference = true;  
-        filterPreferenceCount = false;        
-        filterInjectionCount = false;        
-        filterTopSort = true;        
+        filterDirectPreference = true;
+        filterPreferenceCount = false;
+        filterInjectionCount = false;
+        filterTopSort = true;
         filterReject = true;
         filterAssociativity = true;
         filterPriorities = true;
         filterStrict = false; // TODO: disable filterStrict hack
     }
-    
+
     public Disambiguator() {
         setDefaultFilters();
     }
@@ -184,21 +186,21 @@
             if(SGLR.isDebugging()) {
                 Tools.debug("applyFilters()");
             }
-            
+
             initializeFromParser(parser);
-    
+
             IParseNode t = root;
-    
+
             t = applyTopSortFilter(sort, t);
-            
+
             if (filterAny) {
                 t = applyCycleDetectFilter(t);
-        
+
                 // SG_FilterTree
                 ambiguityManager.resetClustersVisitedCount();
                 t = filterTree(t, false);
             }
-            
+
             // TODO: Move convertToATerm to SGLR.java and support IStrategoTerms
             ATerm result = convertToATerm(t);
             assert Term.asAppl(result).getAFun().getName().equals("parsetree");
@@ -236,16 +238,16 @@
     }
 
     private ATerm convertToATerm(IParseNode t) {
-        
+
         if (SGLR.isDebugging()) {
             Tools.debug("convertToATerm: ", t);
         }
 
         ambiguityManager.resetAmbiguityCount();
         ATerm r = yieldTree(t);
-        
+
         logStatus();
-        
+
         int ambCount = ambiguityManager.getAmbiguitiesCount();
         if (SGLR.isDebugging()) {
             Tools.debug("yield: ", r);
@@ -256,7 +258,7 @@
     }
 
     private IParseNode applyCycleDetectFilter(IParseNode t) throws FilterException {
-        
+
         if (SGLR.isDebugging()) {
             Tools.debug("applyCycleDetectFilter() - ", t);
         }
@@ -279,7 +281,7 @@
             return parseTable.getProduction(((ParseProductionNode) t).getProduction());
         }
     }
-    
+
     private IParseNode applyTopSortFilter(String sort, IParseNode t) throws SGLRException {
 
         if (SGLR.isDebugging()) {
@@ -291,10 +293,10 @@
             if (t == null)
                 throw new StartSymbolException(parser, "Desired start symbol not found: " + sort);
         }
-        
+
         return t;
     }
-    
+
     private boolean matchProdOnTopSort(ATerm prod, String sort) throws FilterException {
         try {
             sort = sort.replaceAll("\"", "");
@@ -306,13 +308,13 @@
             throw new FilterException(parser, "Could not select desired top sort: " + sort, e);
         }
     }
-    
+
     private IParseNode selectOnTopSort(IParseNode t, String sort) throws FilterException {
         List<IParseNode> results = new ArrayList<IParseNode>();
 
         if (t instanceof Amb) {
             addTopSortAlternatives(t, sort, results);
-  
+
             switch (results.size()) {
                 case 0: return null;
                 case 1: return results.get(0);
@@ -364,7 +366,7 @@
             List<IParseNode> newArgs = filterTree(args, false);
 
             if (filterReject && parseTable.hasRejects()) {
-                if (hasRejectProd(t) && !parser.useIntegratedRecovery) 
+                if (hasRejectProd(t) && !parser.useIntegratedRecovery)
                     throw new FilterException(parser, "Unexpected reject annotation in " + yieldTree(t));
             }
 
@@ -388,14 +390,14 @@
         if(SGLR.isDebugging()) {
             Tools.debug("filterTree(<nodes>) - ", args);
         }
-        
+
         List<IParseNode> newArgs = new ArrayList<IParseNode>();
         // boolean changed = false;
 
         for (int i = 0, max = args.size(); i < max; i++) {
             IParseNode n = args.get(i);
             IParseNode filtered = filterTree(n, false);
-            
+
             // changed = !filtered.equals(n) || changed;
             newArgs.add(filtered);
         }
@@ -419,13 +421,13 @@
     }
 
     private IParseNode applyAssociativityPriorityFilter(IParseNode t) throws FilterException {
-        // SG_Associativity_Priority_Filter(pt, t)   
+        // SG_Associativity_Priority_Filter(pt, t)
         // - ok
-        
+
         if(SGLR.isDebugging()) {
             Tools.debug("applyAssociativityPriorityFilter() - ", t);
         }
-        
+
         IParseNode r = t;
 
         if (t instanceof ParseNode) {
@@ -438,14 +440,14 @@
                 } else if (prodLabel.isRightAssociative()) {
                     r = applyRightAssociativeFilter(n, prodLabel);
                 }
-                
+
             }
 
             if (filterPriorities && parseTable.hasPriorities()) {
-                if(Tools.debugging) { 
+                if(Tools.debugging) {
                     Tools.debug(" - about to look up : ",  prodLabel.labelNumber);
                 }
-                
+
                 if (!lookupGtrPriority(prodLabel).isEmpty()) {
                     if(Tools.debugging) {
                         Tools.debug(" - found");
@@ -466,41 +468,41 @@
     private IParseNode applyRightAssociativeFilter(ParseNode t, Label prodLabel) throws FilterException {
         // SG_Right_Associativity_Filter(t, prodl)
         // - almost ok
-        
+
         if(SGLR.isDebugging()) {
             Tools.debug("applyRightAssociativeFilter() - ", t);
         }
-        
+
         List<IParseNode> newAmbiguities = new ArrayList<IParseNode>();
         List<IParseNode> kids = t.getKids();
         IParseNode firstKid = kids.get(0);
-        
+
         if(firstKid instanceof Amb) {
-            
+
             List<IParseNode> ambs = ((Amb)firstKid).getAlternatives();
             List<IParseNode> restKids = kids.subList(1, t.kids.size() - 1);
-            
+
             for (int i = 0, max = ambs.size(); i < max; i++) {
                 IParseNode amb = ambs.get(i);
                 if(((ParseNode)amb).getLabel() != prodLabel.labelNumber) {
                     newAmbiguities.add(amb);
                 }
             }
-        
+
             // FIXME is this correct?
             if(!newAmbiguities.isEmpty()) {
                 if(newAmbiguities.size() > 1)
                     firstKid = new Amb(newAmbiguities);
-                else 
+                else
                     firstKid = newAmbiguities.get(0);
                 restKids.add(firstKid);
             } else {
                 throw new FilterException(parser);
             }
-            
+
             // FIXME is this correct?
             return new ParseNode(t.label, restKids);
-            
+
         } else if(firstKid instanceof ParseNode) {
             if(((ParseNode)firstKid).getLabel() == prodLabel.labelNumber)
                 throw new FilterException(parser);
@@ -510,15 +512,15 @@
 
     private IParseNode applyPriorityFilter(ParseNode t, Label prodLabel) throws FilterException {
         // SG_Priority_Filter
-        
+
         if(SGLR.isDebugging()) {
             Tools.debug("applyPriorityFilter() - ", t);
         }
-        
+
         List<IParseNode> newAmbiguities = new ArrayList<IParseNode>();
         List<IParseNode> kids = t.getKids();
         List<IParseNode> newKids = new ArrayList<IParseNode>();
-        
+
         int l0 = prodLabel.labelNumber;
         int kidnumber = 0;
 
@@ -542,7 +544,7 @@
                         }
                     }
                 }
-                
+
                 if(!newAmbiguities.isEmpty()) {
                     IParseNode n = null;
                     if(newAmbiguities.size() > 1) {
@@ -566,7 +568,7 @@
                     throw new FilterException(parser);
                 }
             }
-            
+
             newKids.add(newKid);
             kidnumber++;
         }
@@ -577,14 +579,14 @@
     private IParseNode replaceUnderInjections(IParseNode alt, IParseNode injection, IParseNode n) {
         // SG_Replace_Under_Injections
         // - not ok
-        
+
         throw new NotImplementedException();
         /*
         if (ATisEqual(t, injT)) {
            return newTree;
         } else {
           ATermList sons = (ATermList)ATgetArgument((ATerm) t, 1);
-          tree newSon = SG_Replace_Under_Injections((tree)ATgetFirst(sons), 
+          tree newSon = SG_Replace_Under_Injections((tree)ATgetFirst(sons),
                                                     injT, newTree);
           return ATsetArgument((ATermAppl)t, (ATerm)ATmakeList1((ATerm)newSon), 1);
         }
@@ -605,7 +607,7 @@
                 IParseNode x = kids.get(0);
                 if(x instanceof ParseNode) {
                     n = (ParseNode)x;
-                    prod = n.label; 
+                    prod = n.label;
                 } else {
                     return x;
                 }
@@ -616,7 +618,7 @@
     }
 
     // TODO: shouldn't this be called isInjection?
-    
+
     private boolean isUserDefinedLabel(int prod) {
         Label l = parseTable.lookupInjection(prod);
         if(l == null)
@@ -626,7 +628,7 @@
 
     private boolean hasGreaterPriority(int l0, int l1, int arg) {
         List<Priority> prios = lookupGtrPriority(parseTable.getLabel(l0));
-        	
+
         for (int i = 0, size = prios.size(); i < size; i++) {
             Priority p = prios.get(i);
         	if (l1 == p.right)
@@ -643,7 +645,7 @@
 
     private IParseNode applyLeftAssociativeFilter(ParseNode t, Label prodLabel) throws FilterException {
         // SG_Right_Associativity_Filter()
-        
+
         if(SGLR.isDebugging()) {
             Tools.debug("applyLeftAssociativeFilter() - ", t);
         }
@@ -684,7 +686,7 @@
                 throw new FilterException(parser);
             }
         }
-        
+
         return t;
     }
 
@@ -703,7 +705,7 @@
 
     private IParseNode filterAmbiguities(List<IParseNode> ambs) throws FilterException {
         // SG_FilterAmb
-        
+
         if(SGLR.isDebugging()) {
             Tools.debug("filterAmbiguities() - [", ambs.size(), "]");
         }
@@ -739,7 +741,7 @@
 
     private List<IParseNode> filterAmbiguityList(List<IParseNode> ambs, IParseNode t) {
         // SG_FilterAmbList
-        
+
         boolean keepT = true;
         List<IParseNode> r = new ArrayList<IParseNode>();
 
@@ -769,7 +771,7 @@
 
     private int filter(IParseNode left, IParseNode right) {
         // SG_Filter(t0, t1)
-        
+
         if(SGLR.isDebugging()) {
             Tools.debug("filter()");
         }
@@ -785,14 +787,14 @@
                 return r;
         }
         */
-        
+
         // like C-SGLR, we use indirect preference filtering if the direct one is enabled
         if (filterDirectPreference && parseTable.hasPrefersOrAvoids()) {
             int r = filterOnIndirectPrefers(left, right);
             if (r != FILTER_DRAW)
                 return r;
         }
-        
+
         if (filterPreferenceCount && parseTable.hasPrefersOrAvoids()) {
             int r = filterOnPreferCount(left, right);
             if (r != FILTER_DRAW)
@@ -807,10 +809,10 @@
 
         return filterPermissiveLiterals(left, right);
     }
-    
+
     private int filterPermissiveLiterals(IParseNode left, IParseNode right) {
         // Work-around for http://bugs.strategoxt.org/browse/SPI-5 (Permissive grammars introduce ambiguities for literals)
-        
+
         if (left instanceof ParseNode && right instanceof ParseNode) {
             List<IParseNode> leftKids = ((ParseNode) left).kids;
             List<IParseNode> rightKids = ((ParseNode) right).kids;
@@ -830,7 +832,7 @@
         }
 
         ambiguityManager.increaseInjectionCount();
-        
+
         int leftInjectionCount = countAllInjections(left);
         int rightInjectionCount = countAllInjections(right);
 
@@ -878,7 +880,7 @@
         }
 
         ambiguityManager.increaseEagernessFilterCalledCount();
-        
+
         int r = FILTER_DRAW;
         if (parseTable.hasPrefers() || parseTable.hasAvoids()) {
             int leftPreferCount = countPrefers(left);
@@ -967,7 +969,7 @@
 
     private int filterOnIndirectPrefers(IParseNode left, IParseNode right) {
         // SG_Indirect_Eagerness_Filter
-        
+
         if(SGLR.isDebugging()) {
             Tools.debug("filterOnIndirectPrefers()");
         }
@@ -1002,7 +1004,7 @@
 
     private int filterOnDirectPrefers(IParseNode left, IParseNode right) {
         // SG_Direct_Eagerness_Filter
-        
+
         if(SGLR.isDebugging()) {
             Tools.debug("filterOnDirectPrefers()");
         }
@@ -1017,7 +1019,7 @@
     }
 
     private boolean isLeftMoreEager(IParseNode left, IParseNode right) {
-        assert !(left instanceof Amb || right instanceof Amb); 
+        assert !(left instanceof Amb || right instanceof Amb);
         if (isMoreEager(left, right))
             return true;
 
@@ -1046,7 +1048,7 @@
             while (prod.isInjection()) {
                 t = ((ParseNode) t).getKids().get(0);
 
-                
+
                 if (t instanceof ParseNode) {
                     int prodTypeX = getProductionType(t);
 
@@ -1153,7 +1155,7 @@
                 } else {
                     clusterIndex = -1;
                 }*/
-                
+
                 throw new NotImplementedException();
 /*
                 if (ambiguities == null) {
@@ -1194,7 +1196,7 @@
         return null;
     }
      */
-    
+
     private List<IParseNode> computeCyclicTerm(List<IParseNode> kids, boolean b, PositionMap visited) {
 
 

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/FatalException.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/FatalException.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/FatalException.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/FatalException.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -5,7 +5,7 @@
  * 
  * Licensed under the GNU General Public License, v2
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 public class FatalException extends IllegalStateException {
 

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/FilterException.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/FilterException.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/FilterException.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/FilterException.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -5,7 +5,9 @@
  * 
  * Licensed under the GNU General Public License, v2
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
+
+import org.spoofax.jsglr.shared.SGLRException;
 
 public class FilterException extends SGLRException {
 

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/FineGrainedOnRegion.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/FineGrainedOnRegion.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/FineGrainedOnRegion.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/FineGrainedOnRegion.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -1,4 +1,4 @@
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 import java.io.IOException;
 import java.util.ArrayList;

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Frame.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Frame.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Frame.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Frame.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -5,12 +5,14 @@
  * 
  * Licensed under the GNU Lesser General Public License, v2.1
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.List;
 
+import org.spoofax.jsglr.shared.Tools;
+
 
 public class Frame implements Serializable {
     

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Goto.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Goto.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Goto.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Goto.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -5,10 +5,11 @@
  * 
  * Licensed under the GNU Lesser General Public License, v2.1
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 import java.io.Serializable;
 
+
 public class Goto implements Serializable {
 
     static final long serialVersionUID = 4361136767191244085L;

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IParseNode.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/IParseNode.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/IParseNode.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IParseNode.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -2,12 +2,12 @@
  * Created on 30.mar.2006
  *
  * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
- * 
+ *
  * Licensed under the GNU General Public License, v2
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
-import aterm.ATerm;
+import org.spoofax.jsglr.shared.terms.ATerm;
 
 public abstract class IParseNode {
 
@@ -17,9 +17,12 @@
 
     @Deprecated
     abstract void clear();
-    abstract public boolean equals(Object obj);
-    abstract public int hashCode();
-    
-    abstract public String toStringShallow(); 
-    abstract public String toString();
+    @Override
+	abstract public boolean equals(Object obj);
+    @Override
+	abstract public int hashCode();
+
+    abstract public String toStringShallow();
+    @Override
+	abstract public String toString();
 }

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IRecoveryParser.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/IRecoveryParser.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/IRecoveryParser.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IRecoveryParser.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -1,4 +1,4 @@
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 public interface IRecoveryParser {
     IRecoveryResult recover(String text) throws Exception;

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IRecoveryResult.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/IRecoveryResult.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/IRecoveryResult.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IRecoveryResult.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -1,4 +1,4 @@
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 import java.util.Map;
 

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentInfo.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/IndentInfo.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/IndentInfo.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentInfo.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -1,4 +1,4 @@
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 import org.spoofax.ArrayDeque;
 

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentTokenizer.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/IndentTokenizer.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/IndentTokenizer.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentTokenizer.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -1,4 +1,4 @@
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 import java.io.IOException;
 import java.util.Stack;

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentationFilter.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/IndentationFilter.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/IndentationFilter.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentationFilter.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -1,16 +1,16 @@
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
-import static org.spoofax.jsglr.Term.*;
-import aterm.ATerm;
-import aterm.ATermAppl;
-import aterm.ATermList;
-import aterm.pure.ATermListImpl;
+import static org.spoofax.jsglr.client.Term.termAt;
+
+import org.spoofax.jsglr.shared.terms.ATerm;
+import org.spoofax.jsglr.shared.terms.ATermAppl;
+import org.spoofax.jsglr.shared.terms.ATermList;
 
 public class IndentationFilter {
-    
+
     public static void resolveAmbiguitiesByIndentation(ATerm node)
     {
-        if (node.getChildCount()>1)               
+        if (node.getChildCount()>1)
         {
             ATermList contents;
             if ("amb".equals(((ATermAppl) node).getName())){
@@ -18,16 +18,16 @@
             }
             else{
                 contents = termAt(node, 1);
-            }  
-            for (int i = 0; i < contents.getLength(); i++) {
-                resolveAmbiguitiesByIndentation(contents.elementAt(i));
             }
-        } 
+            for (int i = 0; i < contents.getChildCount(); i++) {
+                resolveAmbiguitiesByIndentation(contents.getChildAt(i));
+            }
+        }
 
         if ("amb".equals(((ATermAppl) node).getName())){
-            ATermListImpl ambs = termAt(node, 0);
-            node = ambs.elementAt(0);
-        }        
+            ATermList ambs = termAt(node, 0);
+            node = ambs.getChildAt(0);
+        }
     }
 
 }

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentationHandler.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/IndentationHandler.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/IndentationHandler.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentationHandler.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -1,4 +1,5 @@
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
+
 
 /*
  * Keeps up with indentation by inspecting characters

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/InvalidParseTableException.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/InvalidParseTableException.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/InvalidParseTableException.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/InvalidParseTableException.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -5,7 +5,7 @@
  * 
  * Licensed under the GNU Lesser General Public License, v2.1
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 
 public class InvalidParseTableException extends Exception {

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Label.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Label.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Label.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Label.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -2,30 +2,30 @@
  * Created on 06.des.2005
  *
  * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
- * 
+ *
  * Licensed under the GNU Lesser General Public License, v2.1
  */
-package org.spoofax.jsglr;
-
-import aterm.ATermAppl;
+package org.spoofax.jsglr.client;
 
 import java.io.Serializable;
 
+import org.spoofax.jsglr.shared.terms.ATermAppl;
+
 public class Label implements Serializable {
 
     private static final long serialVersionUID = -4080621639747161438L;
-    
+
     final int labelNumber;
     final ATermAppl prod;
     private final ProductionAttributes productionAttributes;
     private final boolean injection;
-    
+
     public Label(int labelNumber, ATermAppl prod, ProductionAttributes productionAttributes, boolean injection) {
         this.labelNumber = labelNumber;
         this.prod = prod;
         this.productionAttributes = productionAttributes;
         this.injection = injection;
-        
+
         if(productionAttributes == null)
             throw new RuntimeException();
     }
@@ -37,7 +37,7 @@
     public boolean isRightAssociative() {
         return productionAttributes.getType() == ProductionType.RIGHT_ASSOCIATIVE;
     }
-    
+
     public boolean isRecoverProduction() {
         return productionAttributes.isRecoverProduction();
     }
@@ -53,16 +53,16 @@
     public boolean isInjection() {
         return injection;
     }
-    
+
     public ATermAppl getProduction() {
         return prod;
     }
-    
+
     @Override
     public boolean equals(Object obj) {
         return obj == this || (obj instanceof Label && ((Label) obj).labelNumber == labelNumber);
     }
-    
+
     @Override
     public int hashCode() {
         return labelNumber;

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Link.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Link.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Link.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Link.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -5,7 +5,9 @@
  * 
  * Licensed under the GNU Lesser General Public License, v2.1
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
+
+import org.spoofax.jsglr.shared.Tools;
 
 
 public class Link {

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Main.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Main.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -2,10 +2,10 @@
  * Created on 03.des.2005
  *
  * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
- * 
+ *
  * Licensed under the GNU Lesser General Public License, v2.1
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 import java.io.BufferedInputStream;
 import java.io.FileInputStream;
@@ -15,12 +15,16 @@
 import java.io.InputStream;
 import java.io.OutputStream;
 
-import aterm.ATerm;
+import org.spoofax.jsglr.server.ParseTableManager;
+import org.spoofax.jsglr.shared.BadTokenException;
+import org.spoofax.jsglr.shared.SGLRException;
+import org.spoofax.jsglr.shared.Tools;
+import org.spoofax.jsglr.shared.terms.ATerm;
 
 public class Main {
 
     public static void main(String[] args) throws FileNotFoundException, IOException, InvalidParseTableException {
-        
+
         if(args.length < 2) {
             usage();
         }
@@ -36,7 +40,7 @@
         boolean waitForProfiler = false;
         boolean timing = false;
         boolean heuristicFilters = false;
-        
+
         for(int i=0;i<args.length;i++) {
             if(args[i].equals("-p")) {
                 parseTable = args[++i];
@@ -68,11 +72,11 @@
 
         if(parseTable == null)
             usage();
-        
+
 
         ParseTableManager ptm = new ParseTableManager();
-        long tableLoadingTime = System.currentTimeMillis(); 
-        SGLR sglr = new SGLR(ptm.getFactory(), ptm.loadFromFile(parseTable));        
+        long tableLoadingTime = System.currentTimeMillis();
+        SGLR sglr = new SGLR(ptm.getFactory(), ptm.loadFromFile(parseTable));
 
         tableLoadingTime = System.currentTimeMillis() - tableLoadingTime;
 
@@ -81,9 +85,9 @@
         sglr.getDisambiguator().setFilterCycles(detectCycles);
         sglr.getDisambiguator().setFilterAny(filter);
         sglr.getDisambiguator().setHeuristicFilters(heuristicFilters);
-        
+
         long parsingTime = parseFile(input, output, sglr, startSymbol);
-        
+
         if(waitForProfiler)
             System.in.read();
         if(timing) {
@@ -102,22 +106,22 @@
         OutputStream ous = null;
         if(output != null && !"-".equals(output))
             ous = new FileOutputStream(output);
-        else 
+        else
             ous = System.out;
 
         long parsingTime = 0;
         ATerm t=null;
         try {
         	parsingTime = System.currentTimeMillis();
-            t=sglr.parse(fis, startSymbol);            
-            parsingTime = System.currentTimeMillis() - parsingTime;            
+            t=sglr.parse(fis, startSymbol);
+            parsingTime = System.currentTimeMillis() - parsingTime;
         } catch(BadTokenException e) {
             System.err.println("Parsing failed : " + e.getMessage());
         } catch(SGLRException e) {
             // Detailed message for other exceptions
             System.err.println("Parsing failed : " + e);
         }
-        if(t != null && !"-".equals(output)){            
+        if(t != null && !"-".equals(output)){
             String outputString=t.toString();
             ous.write(outputString.getBytes());
         }

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/MarkMap.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/MarkMap.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/MarkMap.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/MarkMap.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -5,7 +5,7 @@
  * 
  * Licensed under the GNU General Public License, v2
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 public class MarkMap {
 

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Measures.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Measures.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Measures.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Measures.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -1,4 +1,4 @@
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 /**
  * 

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/MultiBadTokenException.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/MultiBadTokenException.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/MultiBadTokenException.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/MultiBadTokenException.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -1,7 +1,9 @@
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 import java.util.Set;
 
+import org.spoofax.jsglr.shared.BadTokenException;
+
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
  */

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/NewStructureSkipper.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/NewStructureSkipper.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/NewStructureSkipper.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/NewStructureSkipper.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -1,9 +1,10 @@
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
 
+
 public class NewStructureSkipper {
 
     private final static int MAX_NR_OF_LINES=15;

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/NoRecoveryRulesException.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/NoRecoveryRulesException.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/NoRecoveryRulesException.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/NoRecoveryRulesException.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -1,4 +1,5 @@
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
+
 
 /**
  * An exception thrown when recovery is enabled for a parse table with

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/NotImplementedException.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/NotImplementedException.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/NotImplementedException.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/NotImplementedException.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -5,7 +5,7 @@
  * 
  * Licensed under the GNU General Public License, v2
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 public class NotImplementedException extends RuntimeException {
 

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseAvoid.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseAvoid.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseAvoid.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseAvoid.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -2,14 +2,14 @@
  * Created on 17.apr.2006
  *
  * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
- * 
+ *
  * Licensed under the GNU General Public License, v2
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 import java.util.List;
 
-import aterm.ATerm;
+import org.spoofax.jsglr.shared.terms.ATerm;
 
 public class ParseAvoid extends ParseNode {
 
@@ -27,7 +27,7 @@
     public String toString() {
         return "avoid(aprod(" + label + "), " + kids + ")";
     }
-    
+
     @Override
     public boolean equals(Object obj) {
         if(!(obj instanceof ParseAvoid))

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseException.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseException.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseException.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseException.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -5,7 +5,9 @@
  * 
  * Licensed under the GNU General Public License, v2
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
+
+import org.spoofax.jsglr.shared.SGLRException;
 
 public class ParseException extends SGLRException {
 

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseNode.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseNode.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -2,24 +2,23 @@
  * Created on 30.mar.2006
  *
  * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
- * 
+ *
  * Licensed under the GNU General Public License, v2
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 import java.util.List;
 
-import aterm.ATerm;
-import aterm.ATermFactory;
-import aterm.ATermList;
-import aterm.pure.PureFactory;
+import org.spoofax.jsglr.shared.terms.ATerm;
+import org.spoofax.jsglr.shared.terms.ATermFactory;
+import org.spoofax.jsglr.shared.terms.ATermList;
 
 public class ParseNode extends IParseNode {
 
     public final int label;
-    
+
     protected final List<IParseNode> kids;
-    
+
     private int cachedHashCode;
 
     public ParseNode(int label, List<IParseNode> kids) {
@@ -27,7 +26,8 @@
         this.kids = kids;
     }
 
-    public ATerm toParseTree(ParseTable pt) {
+    @Override
+	public ATerm toParseTree(ParseTable pt) {
         ATermFactory factory = pt.getFactory();
 
         ATermList l1 = factory.makeList();
@@ -41,8 +41,8 @@
     /**
      * todo: stolen from TAFReader; move elsewhere
      */
-    public static ATermList makeList(PureFactory factory, List<ATerm> terms) {
-        ATermList result = factory.getEmpty();
+    public static ATermList makeList(ATermFactory factory, List<ATerm> terms) {
+        ATermList result = factory.makeList();
         for (int i = terms.size() - 1; i >= 0; i--) {
             result = factory.makeList(terms.get(i), result);
         }
@@ -55,10 +55,11 @@
     }
 
     public int getLabel() { return label; }
-    
+
     public List<IParseNode> getKids() { return kids; }
 
-    @Deprecated
+    @Override
+	@Deprecated
     void clear() {
         for (int i = 0; i < kids.size(); i++) {
             kids.get(i).clear();
@@ -66,7 +67,7 @@
         kids.clear();
         cachedHashCode = NO_HASH_CODE;
     }
-    
+
     @Override
     public boolean equals(Object obj) {
         if(!(obj instanceof ParseNode))
@@ -83,7 +84,7 @@
         }
         return true;
     }
-    
+
     @Override
     public int hashCode() {
         if (cachedHashCode != NO_HASH_CODE)

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParsePrefer.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParsePrefer.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParsePrefer.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParsePrefer.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -2,14 +2,14 @@
  * Created on 17.apr.2006
  *
  * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
- * 
+ *
  * Licensed under the GNU General Public License, v2
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 import java.util.List;
 
-import aterm.ATerm;
+import org.spoofax.jsglr.shared.terms.ATerm;
 
 public class ParsePrefer extends ParseNode {
 
@@ -27,7 +27,7 @@
     public String toString() {
         return "prefer(aprod(" + label + "), " + kids + ")";
     }
-    
+
     @Override
     public boolean equals(Object obj) {
         if(!(obj instanceof ParsePrefer))

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseProductionNode.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseProductionNode.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseProductionNode.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseProductionNode.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -2,29 +2,30 @@
  * Created on 30.mar.2006
  *
  * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
- * 
+ *
  * Licensed under the GNU General Public License, v2
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
-import aterm.ATerm;
+import org.spoofax.jsglr.shared.terms.ATerm;
 
 public class ParseProductionNode extends IParseNode {
 
     public final int prod;
-    
+
     public ParseProductionNode(int prod) {
         this.prod = prod;
     }
-    
-    public ATerm toParseTree(ParseTable pt) {
+
+    @Override
+	public ATerm toParseTree(ParseTable pt) {
     	return pt.getProduction(prod);
     }
     @Override
     public String toString() {
         return "" + prod;
     }
-    
+
     public int getProduction() { return prod; }
 
     @Override
@@ -33,10 +34,10 @@
             return false;
         return prod == ((ParseProductionNode)obj).prod;
     }
-    
+
     @Override
     void clear() {}
-    
+
     @Override
     public int hashCode() {
         return 6359 * prod;

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseReject.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseReject.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseReject.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseReject.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -2,14 +2,14 @@
  * Created on 17.apr.2006
  *
  * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
- * 
+ *
  * Licensed under the GNU General Public License, v2
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 import java.util.List;
 
-import aterm.ATerm;
+import org.spoofax.jsglr.shared.terms.ATerm;
 
 public class ParseReject extends ParseNode {
 
@@ -30,7 +30,7 @@
             return false;
         return super.equals(obj);
     }
-    
+
     @Override
     public String toString() {
         return "reject(" + label + "," + kids + ")";

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseTable.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseTable.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -2,10 +2,10 @@
  * Created on 04.des.2005
  *
  * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
- * 
+ *
  * Licensed under the GNU Lesser General Public License, v2.1
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 import static java.util.Arrays.asList;
 
@@ -16,20 +16,20 @@
 import java.util.List;
 import java.util.Map;
 
-import aterm.AFun;
-import aterm.ATerm;
-import aterm.ATermAppl;
-import aterm.ATermFactory;
-import aterm.ATermList;
+import org.spoofax.jsglr.shared.terms.AFun;
+import org.spoofax.jsglr.shared.terms.ATerm;
+import org.spoofax.jsglr.shared.terms.ATermAppl;
+import org.spoofax.jsglr.shared.terms.ATermFactory;
+import org.spoofax.jsglr.shared.terms.ATermList;
 
 public class ParseTable implements Serializable {
-    
+
     /**
      * Number of possible characters to expect
      * (0x10FFFF would be all chars of UTF-8, but is not yet
      *  supported by the parse table format.)
      */
-    protected static final int NUM_CHARS = 256; 
+    protected static final int NUM_CHARS = 256;
 
     private static final long serialVersionUID = -3372429249660900093L;
 
@@ -40,15 +40,15 @@
     private Label[] labels;
 
     private Priority[] priorities;
-    
+
     private Associativity[] associativities;
-    
+
     private boolean hasRejects;
-    
+
     private boolean hasAvoids;
-    
+
     private boolean hasPrefers;
-    
+
     private boolean hasRecovers;
 
     transient private ATermFactory factory;
@@ -56,15 +56,15 @@
     transient public AFun applAFun;
 
     transient public AFun ambAFun;
-    
+
     transient private ATerm injection1Appl;
-    
+
     transient private ATerm injection2Appl;
-    
+
     transient private ATerm litStringAppl;
 
     private Label[] injections;
-    
+
     // TODO: allocate prototypes to avoid measurable GC overhead in ParseTable construction
     //       (especially when using the CMS garbage collector, those gotos and stuff
     //        introduce a lot of overhead)
@@ -76,9 +76,9 @@
     private transient HashMap<Reduce, Reduce> reduceCache = new HashMap<Reduce, Reduce>();
 
     private transient HashMap<RangeList, RangeList> rangesCache = new HashMap<RangeList, RangeList>();
-    
+
     private transient Map<Label, List<Priority>> priorityCache;
-    
+
     public ParseTable(ATerm pt) throws InvalidParseTableException {
         initAFuns(pt.getFactory());
         parse(pt);
@@ -119,12 +119,12 @@
         for(int i=0;i<labels.length;i++)
             if(labels[i] != null && labels[i].isInjection())
                 injections[i] = labels[i];
-        
+
         gotoCache = null;
         shiftCache = null;
         reduceCache = null;
         rangesCache = null;
-        
+
         return true;
     }
 
@@ -132,11 +132,11 @@
 
         ATermList prods = Term.listAt(prioritiesTerm, 0);
         List<Priority> ret = new ArrayList<Priority>();
-        
+
         while (!prods.isEmpty()) {
             ATermAppl a = (ATermAppl) prods.getFirst();
             prods = prods.getNext();
-            
+
             int left = Term.intAt(a, 0);
             int right = Term.intAt(a, 1);
             if (a.getName().equals("left-prio")) {
@@ -164,7 +164,7 @@
 
         ATermList prods = Term.listAt(prioritiesTerm, 0);
         List<Associativity> ret = new ArrayList<Associativity>();
-        
+
         for (ATermAppl a = (ATermAppl) prods.getFirst(); !prods.getNext().isEmpty(); prods = prods.getNext()) {
             int left = Term.intAt(a, 0);
             int right = Term.intAt(a, 1);
@@ -191,7 +191,7 @@
     private Label[] parseLabels(ATermList labelsTerm) throws InvalidParseTableException {
 
         Label[] ret = new Label[labelsTerm.getChildCount() + NUM_CHARS + 1];
-        
+
         while (!labelsTerm.isEmpty()) {
             ATermAppl a = Term.applAt(labelsTerm, 0);
             labelsTerm = labelsTerm.getNext();
@@ -229,7 +229,7 @@
             int type = 0;
             boolean isRecover = false;
             ATerm term = null;
-            
+
             for (ATermList ls = (ATermList) attr.getChildAt(0); !ls.isEmpty(); ls = ls.getNext()) {
                 ATermAppl t = (ATermAppl) ls.getFirst();
                 String ctor = t.getName();
@@ -265,7 +265,7 @@
                     	if(t.getChildAt(0) instanceof ATermAppl) {
                     	    ATermAppl child = (ATermAppl) t.getChildAt(0);
                             if (child.getChildCount() == 1 && child.getName().equals("cons")) {
-                    			term = (ATerm) t.getChildAt(0).getChildAt(0);
+                    			term = t.getChildAt(0).getChildAt(0);
                     		} else if (child.getChildCount() == 0 && child.getName().equals("recover")) {
                     		    hasRecovers = isRecover = true;
                     		}
@@ -273,7 +273,7 @@
                     	// TODO Support other terms that are not a constructor (custom annotations)
                     } else if (ctor.equals("id")) {
                         // FIXME not certain about this
-                        term = (ATerm) t.getChildAt(0);
+                        term = t.getChildAt(0);
                     } else {
                         throw new InvalidParseTableException("Unknown attribute: " + t);
                     }
@@ -289,7 +289,7 @@
     private State[] parseStates(ATermAppl statesTerm) throws InvalidParseTableException {
 
         ATermList states = Term.listAt(statesTerm, 0);
-        State[] ret = new State[states.getLength()];
+        State[] ret = new State[states.getChildCount()];
         for(int i = 0; i < ret.length; i++) {
             ATermAppl stateRec = (ATermAppl) states.getFirst();
             states = states.getNext();
@@ -314,7 +314,7 @@
             return cached;
         }
     }
-    
+
 
     private Action[] parseActions(ATermList actionList) throws InvalidParseTableException {
         Action[] ret = new Action[actionList.getChildCount()];
@@ -350,7 +350,7 @@
                 int status = Term.intAt(a, 2);
                 RangeList[] charClasses = parseCharRanges(Term.listAt(a, 3));
                 item = makeReduceLookahead(productionArity, label, status, charClasses);
-                
+
             } else if (a.getName().equals("accept")) {
                 item = new Accept();
             } else if (a.getName().equals("shift")) {
@@ -365,11 +365,11 @@
     }
 
     private RangeList[] parseCharRanges(ATermList list) throws InvalidParseTableException {
-        RangeList[] ret = new RangeList[list.getLength()];
+        RangeList[] ret = new RangeList[list.getChildCount()];
         for (int i=0;i<ret.length; i++) {
             ATermAppl t = Term.asAppl(list.getFirst());
             list = list.getNext();
-            ATermList l, n;            
+            ATermList l, n;
             if (t.getName().equals("look")) { // sdf2bundle 2.4
                 l = Term.listAt(Term.applAt(t, 0), 0);
                 n = Term.listAt(t, 1);
@@ -378,17 +378,17 @@
                 l = Term.listAt(Term.termAt(Term.listAt(t, 0), 0), 0);
                 n = Term.listAt(t, 0).getNext();
             }
-            
+
             // FIXME: multiple lookahead are not fully supported or tested
             //        (and should work for both 2.4 and 2.6 tables)
-            
+
             if (Term.termAt(l, 1) == null) {
                 // This handles restrictions like:
                 //   LAYOUT? -/- [\/].[\/]
                 // where there is no other restriction that starts with a [\/]
-                
+
                 ret[i] = new RangeList(new Range(Term.intAt(l, 0)));
-            } else if (n.getLength() > 0) {
+            } else if (n.getChildCount() > 0) {
                 // This handles restrictions like:
                 //   LAYOUT? -/- [\/].[\/\+].[\*]
                 throw new InvalidParseTableException("Multiple lookahead not fully supported");
@@ -397,7 +397,7 @@
                 //   LAYOUT? -/- [\/].[\/]
                 //   LAYOUT? -/- [\/].[\*]
                 //   LAYOUT? -/- [\/].[\{]
-                
+
                 ret[i] = parseRanges(l);
             }
         }
@@ -407,7 +407,7 @@
     private ActionItem makeReduceLookahead(int productionArity, int label, int status, RangeList[] charClasses) {
         return new ReduceLookahead(productionArity, label, status, charClasses);
     }
-    
+
     private Reduce makeReduce(int arity, int label, int status, boolean isRecoverAction) {
         Reduce r = new Reduce(arity, label, status, isRecoverAction);
         Reduce cached = reduceCache.get(r);
@@ -480,7 +480,7 @@
                 ret[i] = makeRange(low, hi);
             }
         }
-        
+
         return makeRangeList(ret);
     }
 
@@ -566,11 +566,11 @@
     public boolean hasAvoids() {
         return hasAvoids;
     }
-    
+
     public boolean hasRecovers() {
         return hasRecovers;
     }
-    
+
     public boolean hasPrefersOrAvoids() {
         return hasAvoids() || hasPrefers();
     }
@@ -588,19 +588,19 @@
 
     public List<Priority> getPriorities(Label prodLabel) {
         if (priorityCache == null)
-            priorityCache = new HashMap<Label, List<Priority>>();        
+            priorityCache = new HashMap<Label, List<Priority>>();
         List<Priority> results = priorityCache.get(prodLabel);
         if (results != null) return results;
-        
+
         results = new ArrayList<Priority>();
         for (Priority p : priorities) {
             if (p.left == prodLabel.labelNumber && p.type == Priority.GTR) {
                 results.add(p);
             }
         }
-        
+
         priorityCache.put(prodLabel, results);
-        
+
         return results;
     }
 
@@ -611,7 +611,7 @@
 	public void lookupAction(int stateNumber, int peekNextToken) {
 		throw new NotImplementedException();
 	}
-	
+
 	public List<Label> getLabels() {
 	    return Collections.unmodifiableList(asList(labels));
 	}

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTimeoutException.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseTimeoutException.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseTimeoutException.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTimeoutException.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -1,7 +1,9 @@
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 import java.util.Set;
 
+import org.spoofax.jsglr.shared.BadTokenException;
+
 /**
  * Exception thrown when the parser times out.
  * 

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTreeTools.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseTreeTools.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseTreeTools.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTreeTools.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -1,143 +1,148 @@
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
-import aterm.*;
+import org.spoofax.jsglr.shared.terms.AFun;
+import org.spoofax.jsglr.shared.terms.ATerm;
+import org.spoofax.jsglr.shared.terms.ATermAppl;
+import org.spoofax.jsglr.shared.terms.ATermFactory;
+import org.spoofax.jsglr.shared.terms.ATermInt;
+import org.spoofax.jsglr.shared.terms.ATermList;
 
 public class ParseTreeTools {
 
-  private final static int PARSE_TREE = 0;
-  private final static int APPL_PROD = 0;
-  private final static int APPL_ARGS = 1;
-  private final static int PROD_ATTRS = 2;
-  private final static int ATTRS_LIST = 0;
-  private final static int TERM_CONS = 0;
-  private final static int CONS_NAME = 0;
-
-  private AFun parsetreeFun;
-  private AFun applFun;
-  private AFun termFun;
-  private AFun prodFun;
-  private AFun noattrsFun;
-  private AFun attrsFun;
-  private AFun consFun;
-
-  public ParseTreeTools(ATermFactory factory) {
-    super();
-    parsetreeFun = factory.makeAFun("parsetree", 2, false);
-    applFun = factory.makeAFun("appl", 2, false);
-    prodFun = factory.makeAFun("prod", 3, false);
-    noattrsFun = factory.makeAFun("no-attrs", 0, false);
-    attrsFun = factory.makeAFun("attrs", 1, false);
-    termFun = factory.makeAFun("term", 1, false);
-    consFun = factory.makeAFun("cons", 1, false);
-  }
-
-  private static ATermAppl assertAppl(ATerm t) {
-    if(t instanceof ATermAppl) {
-      return (ATermAppl) t;
-    }
-    else {
-      throw new IllegalArgumentException("Expected aterm application: " + t);
-    }
-  }
-
-  private static ATermAppl assertAppl(ATerm t, AFun fun) {
-    ATermAppl result = assertAppl(t);
-    if(result.getAFun() != fun) {
-      throw new IllegalArgumentException("Expected application of function " + fun + ": " + result.getAFun());
-    }
-
-    return result;
-  }
-
-  /**
-   * Given a production or application returns the constructor name
-   * attached to the production, or null if there is no constructor.
-   *
-   * @author Martin Bravenboer
-   * @author Lennart Kats
-   */
-  public String getConstructor(ATerm arg) {
-    ATermAppl appl = assertAppl(arg, applFun);
-
-    ATermAppl prod;
-    if(appl.getAFun() == prodFun) {
-      prod = appl;
-    }
-    else if(appl.getAFun() == applFun) {
-      prod = assertAppl(appl.getArgument(APPL_PROD), prodFun);
-    }
-    else {
-      throw new IllegalArgumentException("Expected prod or appl: " + arg);
-    }
-
-    ATermAppl attrs = assertAppl(prod.getArgument(PROD_ATTRS));
-    if(attrs.getAFun() == noattrsFun) {
-      return null;
-    }
-    else {
-      for(ATerm attr: (ATermList) attrs.getChildAt(ATTRS_LIST)) {
-	if (attr instanceof ATermAppl) {
-	  ATermAppl namedAttr = (ATermAppl) attr;
-	  if (namedAttr.getAFun() == termFun) {
-	    namedAttr = (ATermAppl) namedAttr.getArgument(TERM_CONS);
-	    if (namedAttr.getAFun() == consFun) {
-	      namedAttr = (ATermAppl) namedAttr.getArgument(CONS_NAME);
-	      return namedAttr.getName();
-	    }
-	  }
-	}
-      }
-    }
-
-    return null;
-  }
-
-  /**
-   * Yields a parse tree (parsetree or appl) to a String.
-   *
-   * @author Martin Bravenboer
-   */
-  public String yield(ATerm parsetree) {
-    StringBuilder builder = new StringBuilder();
-    yield(parsetree, builder);
-    return builder.toString();
-  }
-
-  /**
-   * Yields a parse tree (parsetree or appl) to a string builder.
-   *
-   * @author Martin Bravenboer
-   */
-  public void yield(ATerm parsetree, StringBuilder builder) {
-    ATermAppl appl = assertAppl(parsetree);
-    if(appl.getAFun() == parsetreeFun) {
-      appl = assertAppl(appl.getArgument(PARSE_TREE));
-    }
-
-    yieldAppl(appl, builder);
-  }
-
-  /**
-   * Private helper for the yield method.
-   */
-  private void yieldAppl(ATermAppl appl, StringBuilder builder) {
-    for(ATerm t : (ATermList) appl.getArgument(APPL_ARGS)) {
-      if(t instanceof ATermAppl) {
-	ATermAppl arg = (ATermAppl) t;
-	if(arg.getAFun() == applFun) {
-	  yieldAppl(arg, builder);
-	}
-	else {
-	  throw new IllegalArgumentException("Don't know how to yield " + arg);
-	}
-      }
-      else if(t instanceof ATermInt) {
-	ATermInt arg = (ATermInt) t;
-	builder.append((char) arg.getInt());	
-      }
-      else {
-	throw new IllegalArgumentException("Don't know how to yield " + t);
-      }
-    }
-  }
+	private final static int PARSE_TREE = 0;
+	private final static int APPL_PROD = 0;
+	private final static int APPL_ARGS = 1;
+	private final static int PROD_ATTRS = 2;
+	private final static int ATTRS_LIST = 0;
+	private final static int TERM_CONS = 0;
+	private final static int CONS_NAME = 0;
+
+	private AFun parsetreeFun;
+	private AFun applFun;
+	private AFun termFun;
+	private AFun prodFun;
+	private AFun noattrsFun;
+	private AFun attrsFun;
+	private AFun consFun;
+
+	public ParseTreeTools(ATermFactory factory) {
+		super();
+		parsetreeFun = factory.makeAFun("parsetree", 2, false);
+		applFun = factory.makeAFun("appl", 2, false);
+		prodFun = factory.makeAFun("prod", 3, false);
+		noattrsFun = factory.makeAFun("no-attrs", 0, false);
+		attrsFun = factory.makeAFun("attrs", 1, false);
+		termFun = factory.makeAFun("term", 1, false);
+		consFun = factory.makeAFun("cons", 1, false);
+	}
+
+	private static ATermAppl assertAppl(ATerm t) {
+		if(t instanceof ATermAppl) {
+			return (ATermAppl) t;
+		}
+		else {
+			throw new IllegalArgumentException("Expected aterm application: " + t);
+		}
+	}
+
+	private static ATermAppl assertAppl(ATerm t, AFun fun) {
+		ATermAppl result = assertAppl(t);
+		if(result.getAFun() != fun) {
+			throw new IllegalArgumentException("Expected application of function " + fun + ": " + result.getAFun());
+		}
+
+		return result;
+	}
+
+	/**
+	 * Given a production or application returns the constructor name
+	 * attached to the production, or null if there is no constructor.
+	 *
+	 * @author Martin Bravenboer
+	 * @author Lennart Kats
+	 */
+	public String getConstructor(ATerm arg) {
+		ATermAppl appl = assertAppl(arg, applFun);
+
+		ATermAppl prod;
+		if(appl.getAFun() == prodFun) {
+			prod = appl;
+		}
+		else if(appl.getAFun() == applFun) {
+			prod = assertAppl(appl.getChildAt(APPL_PROD), prodFun);
+		}
+		else {
+			throw new IllegalArgumentException("Expected prod or appl: " + arg);
+		}
+
+		ATermAppl attrs = assertAppl(prod.getChildAt(PROD_ATTRS));
+		if(attrs.getAFun() == noattrsFun) {
+			return null;
+		}
+		else {
+			for(ATerm attr: (ATermList) attrs.getChildAt(ATTRS_LIST)) {
+				if (attr instanceof ATermAppl) {
+					ATermAppl namedAttr = (ATermAppl) attr;
+					if (namedAttr.getAFun() == termFun) {
+						namedAttr = (ATermAppl) namedAttr.getChildAt(TERM_CONS);
+						if (namedAttr.getAFun() == consFun) {
+							namedAttr = (ATermAppl) namedAttr.getChildAt(CONS_NAME);
+							return namedAttr.getName();
+						}
+					}
+				}
+			}
+		}
+
+		return null;
+	}
+
+	/**
+	 * Yields a parse tree (parsetree or appl) to a String.
+	 *
+	 * @author Martin Bravenboer
+	 */
+	public String yield(ATerm parsetree) {
+		StringBuilder builder = new StringBuilder();
+		yield(parsetree, builder);
+		return builder.toString();
+	}
+
+	/**
+	 * Yields a parse tree (parsetree or appl) to a string builder.
+	 *
+	 * @author Martin Bravenboer
+	 */
+	public void yield(ATerm parsetree, StringBuilder builder) {
+		ATermAppl appl = assertAppl(parsetree);
+		if(appl.getAFun() == parsetreeFun) {
+			appl = assertAppl(appl.getChildAt(PARSE_TREE));
+		}
+
+		yieldAppl(appl, builder);
+	}
+
+	/**
+	 * Private helper for the yield method.
+	 */
+	private void yieldAppl(ATermAppl appl, StringBuilder builder) {
+		for(ATerm t : (ATermList) appl.getChildAt(APPL_ARGS)) {
+			if(t instanceof ATermAppl) {
+				ATermAppl arg = (ATermAppl) t;
+				if(arg.getAFun() == applFun) {
+					yieldAppl(arg, builder);
+				}
+				else {
+					throw new IllegalArgumentException("Don't know how to yield " + arg);
+				}
+			}
+			else if(t instanceof ATermInt) {
+				ATermInt arg = (ATermInt) t;
+				builder.append((char) arg.getInt());
+			}
+			else {
+				throw new IllegalArgumentException("Don't know how to yield " + t);
+			}
+		}
+	}
 }
\ No newline at end of file

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParserException.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParserException.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParserException.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParserException.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -5,7 +5,7 @@
  * 
  * Licensed under the GNU Lesser General Public License, v2.1
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 public class ParserException extends Exception {
 

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParserHistory.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParserHistory.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParserHistory.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParserHistory.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -1,8 +1,9 @@
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 import java.io.IOException;
 import java.util.ArrayList;
 
+
 public class ParserHistory {
     
     private final static int MAX_SIZE_NEW_LINE_POINTS = 150;

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Path.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Path.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Path.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Path.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -5,7 +5,7 @@
  * 
  * Licensed under the GNU Lesser General Public License, v2.1
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 //todo managed
 //import javolution.realtime.ObjectFactory;
@@ -16,6 +16,7 @@
 import java.util.ArrayList;
 import java.util.List;
 
+
 public class Path /*todo managed extends RealtimeObject*/ {
 
     public final Path parent;

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/PositionMap.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/PositionMap.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/PositionMap.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/PositionMap.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -5,7 +5,7 @@
  * 
  * Licensed under the GNU General Public License, v2
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 public class PositionMap {
 

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Priority.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Priority.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Priority.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Priority.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -5,7 +5,7 @@
  * 
  * Licensed under the GNU Lesser General Public License, v2.1
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 import java.io.Serializable;
 

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Production.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Production.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Production.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Production.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -5,9 +5,9 @@
  * 
  * Licensed under the GNU Lesser General Public License, v2.1
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
-import static org.spoofax.jsglr.ProductionType.*;
+import static org.spoofax.jsglr.client.ProductionType.*;
 
 import java.io.Serializable;
 import java.util.List;

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ProductionAttributes.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ProductionAttributes.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ProductionAttributes.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ProductionAttributes.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -2,23 +2,24 @@
  * Created on 16.apr.2006
  *
  * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
- * 
+ *
  * Licensed under the GNU General Public License, v2
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
-import static org.spoofax.jsglr.ProductionType.*;
+import static org.spoofax.jsglr.client.ProductionType.AVOID;
+import static org.spoofax.jsglr.client.ProductionType.PREFER;
 
 import java.io.Serializable;
 
-import aterm.ATerm;
+import org.spoofax.jsglr.shared.terms.ATerm;
 
 public class ProductionAttributes implements Serializable {
 
     private static final long serialVersionUID = 556855017447626835L;
 
     private final int type;
-    
+
     private final boolean isRecover;
 
     private final transient ATerm abstractCtor;
@@ -36,7 +37,7 @@
     public final ATerm getTerm() {
         return abstractCtor;
     }
-    
+
     public boolean isRecoverProduction() {
         return isRecover;
     }

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ProductionType.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ProductionType.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ProductionType.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ProductionType.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -1,4 +1,4 @@
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 /**
  * SGLR production types, used in the parse table format.

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Range.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Range.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Range.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Range.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -5,7 +5,7 @@
  * 
  * Licensed under the GNU Lesser General Public License, v2.1
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 import java.io.Serializable;
 

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/RangeList.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/RangeList.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/RangeList.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/RangeList.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -1,4 +1,4 @@
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 import java.util.ArrayList;
 import java.util.Arrays;

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/RecoverDisambiguator.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/RecoverDisambiguator.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/RecoverDisambiguator.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/RecoverDisambiguator.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -1,4 +1,5 @@
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
+
 
 public class RecoverDisambiguator {
     

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/RecoverNode.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/RecoverNode.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/RecoverNode.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/RecoverNode.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -1,4 +1,5 @@
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
+
 
 public class RecoverNode {
     public final int tokensSeen;

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/RecoveryConnector.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/RecoveryConnector.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/RecoveryConnector.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/RecoveryConnector.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -1,10 +1,14 @@
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 import java.io.IOException;
 import java.util.HashMap;
 import java.util.Map;
 
 import org.spoofax.ArrayDeque;
+import org.spoofax.jsglr.shared.BadTokenException;
+import org.spoofax.jsglr.shared.SGLRException;
+import org.spoofax.jsglr.shared.TokenExpectedException;
+import org.spoofax.jsglr.shared.Tools;
 
 //TODO: keep recovered lines (Testcase: two separated errors)
 public class RecoveryConnector {

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Reduce.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Reduce.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Reduce.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Reduce.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -2,13 +2,12 @@
  * Created on 05.des.2005
  *
  * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
- * 
+ *
  * Licensed under the GNU Lesser General Public License, v2.1
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
+
 
-import org.spoofax.jsglr.rnsglr.Arguments;
-import org.spoofax.jsglr.rnsglr.SpecialAttribute;
 
 public class Reduce extends ActionItem {
 
@@ -22,23 +21,18 @@
 
     public final Production production;
 
-	public SpecialAttribute specialAttribute;
-
-	public Arguments eTree;
-
-    
     public Reduce(int arity, int label, int status, boolean isRecoverAction) {
-        
+
         super(REDUCE);
-        
+
         this.arity = arity;
         this.label = label;
         this.status = status;
-      
+
         production = new Production(arity, label, status, isRecoverAction);
     }
-    
-    
+
+
     @Override
     public boolean equals(Object obj) {
         if(!(obj instanceof Reduce))
@@ -46,14 +40,15 @@
         Reduce o = (Reduce)obj;
         return arity == o.arity && label == o.label && status == o.status;
     }
-    
+
     @Override
     public int hashCode() {
         return arity + status * 10 + label * 100;
     }
-    
-    
-    public String toString() {
+
+
+    @Override
+	public String toString() {
         return "reduce(" + arity + ", " + label + ", " + status + ")";
     }
 }

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ReduceLookahead.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ReduceLookahead.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ReduceLookahead.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ReduceLookahead.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -5,7 +5,8 @@
  * 
  * Licensed under the GNU General Public License, v2
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
+
 
 public class ReduceLookahead extends ActionItem {
 

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/RegionRecovery.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/RegionRecovery.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/RegionRecovery.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/RegionRecovery.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -1,9 +1,10 @@
 //TODO: samenwerking met recovery connector eenduidiger
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 import java.io.IOException;
 import java.util.ArrayList;
 
+
 /**
  * Supports error recovery by selecting the region containing the error.
  * This region can be discarded (parsed as layout) or can be inspected by a refined recover method

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/SGLR.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/SGLR.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -2,10 +2,10 @@
  * Created on 03.des.2005
  *
  * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
- * 
+ *
  * Licensed under the GNU Lesser General Public License, v2.1
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -21,37 +21,39 @@
 import java.util.concurrent.CancellationException;
 
 import org.spoofax.ArrayDeque;
+import org.spoofax.jsglr.shared.BadTokenException;
+import org.spoofax.jsglr.shared.SGLRException;
+import org.spoofax.jsglr.shared.TokenExpectedException;
+import org.spoofax.jsglr.shared.Tools;
+import org.spoofax.jsglr.shared.terms.ATerm;
+import org.spoofax.jsglr.shared.terms.ATermFactory;
 
-import aterm.ATerm;
-import aterm.ATermFactory;
-import aterm.pure.PureFactory;
+public class SGLR {
 
-public class SGLR {             
-   
     private final Set<BadTokenException> collectedErrors = new LinkedHashSet<BadTokenException>();
-    
-    static final int EOF = ParseTable.NUM_CHARS;
-    
+
+    public static final int EOF = ParseTable.NUM_CHARS;
+
     static final int TAB_SIZE = 4;//8;
-    
+
     private static final Timer abortTimer = new Timer(true);
-    
+
     private int abortTimerJobId;
 
     protected static boolean WORK_AROUND_MULTIPLE_LOOKAHEAD;
-    
+
     //Performance testing
     private static long parseTime=0;
     private static int parseCount=0;
-    
+
     private int timeout;
-        
-    public Frame startFrame; 
-    
+
+    public Frame startFrame;
+
     private long startTime;
-    
+
     private volatile boolean asyncAborted;
-    
+
     private ATermFactory factory;
 
     public Frame acceptingStack;
@@ -93,27 +95,27 @@
     private int reductionCount;
 
     private PushbackInputStream currentInputStream;
-   
+
     //Creates indent- and dedent- tokens
     //Meant for parsing of indentation based languages
     //TODO: still under construction
     private IndentTokenizer indentTokenHandler;
-    
+
     // ------------------------------------- Integrated recovery  ------------------------
   //Keeps track of the indentation for each line
    // private IndentationHandler indentHandler;
-    
+
     private ParserHistory history;
-    
+
     private RecoveryConnector recoverIntegrator;
-    
+
     protected boolean useIntegratedRecovery;
-    
+
     public ParserHistory getHistory() {
         return history;
-    }    
-     
-    
+    }
+
+
     /* START: FINE GRAINED ON REGION */
     private boolean fineGrainedOnRegion;
     protected void setFineGrainedOnRegion(boolean fineGrainedMode) {
@@ -124,24 +126,24 @@
     public void clearRecoverStacks(){
         recoverStacks.clear(false);
     }
-    
+
     private ArrayDeque<Frame> recoverStacks;
     public ArrayDeque<Frame> getRecoverStacks() {
         return recoverStacks;
     }
 
     protected void setUseFineGrained(boolean useFG) {
-        recoverIntegrator.setUseFineGrained(useFG);        
+        recoverIntegrator.setUseFineGrained(useFG);
     }
     /* END: FINE GRAINED ON REGION */
-    
+
     public Set<BadTokenException> getCollectedErrors() {
         return collectedErrors;
     }
-    
+
     //-------------------------- fine-grained recovery ----------------------------------
     private RecoverDisambiguator recoverDisambiguator;
-       
+
     SGLR() {
         basicInit(null);
     }
@@ -151,22 +153,22 @@
         assert parseTable != null;
         // Init with a new factory for both serialized or BAF instances.
         this.parseTable = parseTable;
-        basicInit(pf);        
+        basicInit(pf);
     }
 
     public void setUseStructureRecovery(boolean useRecovery, IRecoveryParser parser) {
         useIntegratedRecovery = useRecovery;
         recoverIntegrator = new RecoveryConnector(this, parser);
     }
-    
+
     /**
      * Structure-based recovery without bridge parsing.
-     * 
+     *
     */
-    public final void setUseStructureRecovery(boolean useRecovery) throws NoRecoveryRulesException {        
+    public final void setUseStructureRecovery(boolean useRecovery) throws NoRecoveryRulesException {
         setUseStructureRecovery(useRecovery, null);
     }
-    
+
     /**
      * @deprecated Use {@link #asyncCancel()} instead.
      */
@@ -174,16 +176,16 @@
     public void asyncAbort() {
         asyncCancel();
     }
-    
+
     /**
      * Aborts an asynchronously running parse job, causing it to throw an exception.
-     *  
+     *
      * (Provides no guarantee that the parser is actually cancelled.)
      */
     public void asyncCancel() {
         asyncAborted = true;
     }
-    
+
     public void asyncCancelReset() {
         asyncAborted = false;
     }
@@ -191,8 +193,8 @@
     private void basicInit(ATermFactory factory) {
         this.factory = factory;
         if (factory == null)
-            factory = new PureFactory();
-        activeStacks = new ArrayDeque<Frame>();     
+            factory = new ATermFactory();
+        activeStacks = new ArrayDeque<Frame>();
         forActor = new ArrayDeque<Frame>();
         forActorDelayed = new ArrayDeque<Frame>();
         forShifter = new ArrayDeque<ActionState>();
@@ -202,7 +204,7 @@
 
         disambiguator = new Disambiguator();
         //indentHandler = new IndentationHandler();
-       // indentTokenHandler = new IndentTokenizer(indentHandler, false);  
+       // indentTokenHandler = new IndentTokenizer(indentHandler, false);
         useIntegratedRecovery = false;
         recoverIntegrator = null;
         history=new ParserHistory();
@@ -221,7 +223,7 @@
      * Initializes the active stacks. At the start of parsing there is only one
      * active stack, and this stack contains the start symbol obtained from the
      * parse table.
-     * 
+     *
      * @return the initial stack
      */
     private Frame initActiveStacks() {
@@ -230,33 +232,33 @@
         addStack(st0);
         return st0;
     }
-    
-    public final ATerm parse(InputStream fis)  throws IOException, SGLRException {        
+
+    public final ATerm parse(InputStream fis)  throws IOException, SGLRException {
         return parse(fis, null);
-    }   
-    
+    }
+
     public ATerm parse(InputStream fis, String startSymbol) throws IOException,
             BadTokenException, TokenExpectedException, ParseException,
             SGLRException {
-        logBeforeParsing();        
-        initParseVariables(fis);        
+        logBeforeParsing();
+        initParseVariables(fis);
         startTime = System.currentTimeMillis();
         initParseTimer();
         return sglrParse(startSymbol);
     }
-    
+
     public final ATerm parse(String input) throws IOException, BadTokenException,
             TokenExpectedException, ParseException, SGLRException {
-        
+
         return parse(input, null);
     }
-    
+
     public ATerm parse(String input, String startSymbol) throws IOException, BadTokenException, TokenExpectedException, ParseException,
         SGLRException {
-        
+
         return parse(new ByteArrayInputStream(input.getBytes("ISO-8859-1")), startSymbol);
     }
-    
+
     private void initParseTimer() {
         if (timeout > 0) {
             // We use a single shared timer to conserve native threads
@@ -280,11 +282,11 @@
             asyncAborted = false;
         }
     }
-    
+
     /**
      * Sets the maximum amount of time to try and parse a file,
      * before a {@link ParseTimeoutException} is thrown.
-     * 
+     *
      * @param timeout  The maximum time to parse, in milliseconds.
      */
     public void setTimeout(int timeout) {
@@ -293,26 +295,26 @@
 
     private ATerm sglrParse(String startSymbol)
             throws IOException, BadTokenException, TokenExpectedException,
-            ParseException, SGLRException {       
-        
+            ParseException, SGLRException {
+
         try {
             do {
-                readNextToken();                
+                readNextToken();
                 //indentHandler.updateIndentation(currentToken);
-                //indentTokenHandler.handleIndentShifts(this);                
+                //indentTokenHandler.handleIndentShifts(this);
                 //recoverHandler.afterStreamRead(currentToken);
                 history.keepTokenAndState(this);
-                doParseStep(); 
+                doParseStep();
                 //recoverHandler.afterParseStep();
-               // System.out.print((char)currentToken);             
+               // System.out.print((char)currentToken);
             } while (currentToken != SGLR.EOF && activeStacks.size() > 0);
-            
+
             if (acceptingStack == null) {
-                collectedErrors.add(createBadTokenException()); 
+                collectedErrors.add(createBadTokenException());
             }
-            
-            if(useIntegratedRecovery && acceptingStack==null){                
-                recoverIntegrator.recover();                              
+
+            if(useIntegratedRecovery && acceptingStack==null){
+                recoverIntegrator.recover();
                 if(acceptingStack==null && activeStacks.size()>0)
                     return sglrParse(startSymbol);
             } /*else if(recoverHandler.meetsRecoverCriteria()){
@@ -320,46 +322,46 @@
                 if(acceptingStack==null)
                     return sglrParse(startSymbol);
             }*/
-           
+
         } catch (CancellationException e) {
             throw new ParseTimeoutException(this, currentToken, tokensSeen - 1, lineNumber,
                     columnNumber, collectedErrors);
-        }           
-                
-        logAfterParsing();    
-        
+        }
+
+        logAfterParsing();
+
         Link s = acceptingStack.findDirectLink(startFrame);
-                
+
         if (s == null)
             throw new ParseException(this, "Accepting stack has no link");
-     
+
         logParseResult(s);
         Tools.debug("avoids: ", s.recoverCount);
         //Tools.debug(s.label.toParseTree(parseTable));
-        
+
         return disambiguator.applyFilters(this, s.label, startSymbol, tokensSeen);
     }
 
     void readNextToken() throws IOException {
-        logCurrentToken();            
-        currentToken = getNextToken();    
+        logCurrentToken();
+        currentToken = getNextToken();
     }
 
-    public void doParseStep() throws IOException {               
-        parseCharacter(); //applies reductions on active stack structure and fills forshifter                      
+    public void doParseStep() throws IOException {
+        parseCharacter(); //applies reductions on active stack structure and fills forshifter
         shifter(); //renewes active stacks with states in forshifter
-    }    
+    }
 
-    private void initParseVariables(InputStream fis) {        
+    private void initParseVariables(InputStream fis) {
         startFrame = initActiveStacks();
         tokensSeen = 0;
         columnNumber = 0;
-        lineNumber = 1;        
+        lineNumber = 1;
         currentInputStream = new PushbackInputStream(fis, 1024);
-        acceptingStack = null; 
+        acceptingStack = null;
         //history.keepInitialState(this);
         collectedErrors.clear();
-    }    
+    }
 
      private BadTokenException createBadTokenException() {
         Frame singlePreviousStack = activeStacks.size() == 1
@@ -367,23 +369,23 @@
                 : null;
         if (singlePreviousStack != null) {
             Action action = singlePreviousStack.peek().getSingularAction();
-            
+
             if (action != null && action.getActionItems().length == 1) {
                 StringBuilder expected = new StringBuilder();
-                
+
                 do {
                     int token = action.getSingularRange();
                     if (token == -1) break;
                     expected.append((char) token);
-                    
+
                     ActionItem[] items = action.getActionItems();
-                    
+
                     if (!(items.length == 1 && items[0].type == ActionItem.SHIFT))
                         break;
-                    
+
                     Shift shift = (Shift) items[0];
                     action = parseTable.getState(shift.nextState).getSingularAction();
-                                        
+
                 } while (action != null);
 
                 if (expected.length() > 0)
@@ -391,7 +393,7 @@
                                                      tokensSeen - 1, lineNumber, columnNumber);
             }
         }
-        
+
         return new BadTokenException(this, currentToken, tokensSeen - 1, lineNumber,
                                            columnNumber);
     }
@@ -419,19 +421,19 @@
             }
         }
         logAfterShifter();
-    }    
+    }
 
     public void addStack(Frame st1) {
         if(Tools.tracing) {
             TRACE("SG_AddStack() - " + st1.state.stateNumber);
         }
         activeStacks.addFirst(st1);
-    }    
+    }
 
     private void parseCharacter() throws IOException {
         logBeforeParseCharacter();
 
-        ArrayDeque<Frame> actives = new ArrayDeque<Frame>(activeStacks); // FIXME avoid garbage        
+        ArrayDeque<Frame> actives = new ArrayDeque<Frame>(activeStacks); // FIXME avoid garbage
         clearForActorDelayed(false);
         clearForShifter(false);
         while (actives.size() > 0 || forActor.size() > 0) {
@@ -440,7 +442,7 @@
             if (!st.allLinksRejected()) {
                 actor(st);
             }
-            
+
             if(actives.size() == 0 && forActor.size() == 0) {
                 fillForActorWithDelayedFrames(); //Fills foractor, clears foractor delayed
             }
@@ -470,19 +472,19 @@
             st = forActor.remove();
         }
         return st;
-    }    
+    }
 
     private void actor(Frame st) throws IOException {
         State s = st.peek();
-        logBeforeActor(st, s);        
+        logBeforeActor(st, s);
         for (Action action : s.getActions()) {
             if (action.accepts(currentToken)) {
-                for (ActionItem ai : action.getActionItems()) {                    
+                for (ActionItem ai : action.getActionItems()) {
                     switch (ai.type) {
                         case ActionItem.SHIFT: {
                             Shift sh = (Shift) ai;
                             ActionState actState = new ActionState(st, parseTable.getState(sh.nextState));
-                            actState.currentToken = currentToken;                            
+                            actState.currentToken = currentToken;
                             addShiftPair(actState); //Adds StackNode to forshifter
                             statsRecordParsers(); //sets some values un current parse state
                             break;
@@ -502,7 +504,7 @@
                             }
                             break;
                         }
-                        case ActionItem.ACCEPT: {                            
+                        case ActionItem.ACCEPT: {
                             if (!st.allLinksRejected()) {
                                 acceptingStack = st;
                                 if (Tools.logging) {
@@ -515,31 +517,31 @@
                             throw new NotImplementedException();
                      }
                 }
-            }            
+            }
         }
-        
+
         if(Tools.tracing) {
             TRACE("SG_ - actor done");
         }
-    }    
+    }
 
     private boolean checkLookahead(ReduceLookahead red) throws IOException {
         return doCheckLookahead(red, red.getCharRanges(), 0);
     }
-    
+
     private boolean doCheckLookahead(ReduceLookahead red, RangeList[] charClass, int pos) throws IOException {
         if(Tools.tracing) {
             TRACE("SG_CheckLookAhead() - ");
         }
-        
+
         int c = currentInputStream.read();
-        
+
         // EOF
-        if(c == -1) 
+        if(c == -1)
             return true;
-        
+
         boolean permit = true;
-        
+
         if(pos < charClass.length)
             permit = charClass[pos].within(c) ? false : doCheckLookahead(red, charClass, pos + 1);
 
@@ -566,16 +568,16 @@
 
     private void doReductions(Frame st, Production prod) throws IOException {
         if(recoverModeOk(st, prod)){
-            List<Path> paths = st.findAllPaths(prod.arity);         
+            List<Path> paths = st.findAllPaths(prod.arity);
             logBeforeDoReductions(st, prod, paths.size());
             reduceAllPaths(prod, paths);
             logAfterDoReductions();
         }
     }
-    
+
     private boolean recoverModeOk(Frame st, Production prod) {
         return !prod.isRecoverProduction() || fineGrainedOnRegion;
-        
+
     }
     /*
     private boolean recoverModeOk(Frame st, Production prod) {
@@ -587,18 +589,18 @@
         // TODO: is this condition right??
         return !useIntegratedRecovery || prod.isRecoverProduction() == reduceRecoverOnly;
     }*/
-    
+
     private void doLimitedReductions(Frame st, Production prod, Link l) throws IOException { //Todo: Look add sharing code with doReductions
         if(recoverModeOk(st, prod)){
-            List<Path> paths = st.findLimitedPaths(prod.arity, l); //find paths containing the link         
-            logBeforeLimitedReductions(st, prod, l, paths);        
+            List<Path> paths = st.findLimitedPaths(prod.arity, l); //find paths containing the link
+            logBeforeLimitedReductions(st, prod, l, paths);
             reduceAllPaths(prod, paths);
         }
     }
 
     private void reduceAllPaths(Production prod, List<Path> paths)
             throws IOException {
-        
+
         for (int i = paths.size() - 1; i >= 0; i--) {
             Path path = paths.get(i);
             List<IParseNode> kids = path.getATerms();
@@ -608,14 +610,14 @@
             reducer(st0, next, prod, kids, path);
         }
         clearPath(paths);
-        
+
         if (asyncAborted) {
             // Rethrown as ParseTimeoutException in SGLR.sglrParse()
             throw new CancellationException("Long-running parse job aborted");
         }
     }
 
-    
+
     private void clearPath(List<Path> paths) {
         if(Tools.tracing) {
             SGLR.TRACE("SG_ClearPath() - " + paths.size());
@@ -624,53 +626,53 @@
     }
 
     private void reducer(Frame st0, State s, Production prod, List<IParseNode> kids, Path path) throws IOException {
-        int length = path.getLength();        
-        int numberOfRecoveries = calcRecoverCount(prod, path); 
+        int length = path.getLength();
+        int numberOfRecoveries = calcRecoverCount(prod, path);
         IParseNode t = prod.apply(kids);
-        Frame st1; 
-        Link nl;                   
+        Frame st1;
+        Link nl;
         logBeforeReducer(s, prod, length);
-        increaseReductionCount();        
+        increaseReductionCount();
         st1 = findStack(activeStacks, s);
-        if (st1 == null) {             
-            if(prod.isRecoverProduction()){           
-                addNewRecoverStack(st0, s, prod, length, numberOfRecoveries, t); 
+        if (st1 == null) {
+            if(prod.isRecoverProduction()){
+                addNewRecoverStack(st0, s, prod, length, numberOfRecoveries, t);
                 return;
-            } 
-            addNewStack(st0, s, prod, length, numberOfRecoveries, t); 
+            }
+            addNewStack(st0, s, prod, length, numberOfRecoveries, t);
         } else {
             /* A stack with state s exists; check for ambiguities */
             nl = st1.findDirectLink(st0);
 
             if (nl != null) {
-                if(prod.isRecoverProduction()){           
-                    return;               
-                }   
+                if(prod.isRecoverProduction()){
+                    return;
+                }
                 logAmbiguity(st0, prod, st1, nl);
                 if (prod.isRejectProduction())
-                    nl.reject();               
+                    nl.reject();
                 if(numberOfRecoveries==0 && nl.recoverCount==0 || nl.isRejected())
                     createAmbNode(t, nl);
-                else if (numberOfRecoveries < nl.recoverCount){                    
+                else if (numberOfRecoveries < nl.recoverCount){
                     nl.label=t;
                     nl.recoverCount=numberOfRecoveries;
-                    actorOnActiveStacksOverNewLink(nl);                   
+                    actorOnActiveStacksOverNewLink(nl);
                 }
-                else if (numberOfRecoveries == nl.recoverCount){                    
-                    nl.label=t;                                      
+                else if (numberOfRecoveries == nl.recoverCount){
+                    nl.label=t;
                 }
             } else {
-                if(prod.isRecoverProduction()){           
+                if(prod.isRecoverProduction()){
                     addNewRecoverStack(st0, s, prod, length, numberOfRecoveries, t);
                     return;
-                }    
+                }
                 nl = st1.addLink(st0, t, length);
                 nl.recoverCount = numberOfRecoveries;
                 if (prod.isRejectProduction()){
-                    nl.reject();    
+                    nl.reject();
                     increaseRejectCount();
-                } 
-                logAddedLink(st0, st1, nl);              
+                }
+                logAddedLink(st0, st1, nl);
                 actorOnActiveStacksOverNewLink(nl);
             }
         }
@@ -679,39 +681,39 @@
             TRACE("SG_ - reducer done");
         }
     }
-    
-    /*private void handleAmbiguity(int numberOfRecoveries, IParseNode t, Link nl) throws IOException {        
+
+    /*private void handleAmbiguity(int numberOfRecoveries, IParseNode t, Link nl) throws IOException {
         //if both branches contain no recover productions and not in recover mode, create an Amb node.
-        //if(numberOfRecoveries == 0 && nl.recoverCount==0){            
+        //if(numberOfRecoveries == 0 && nl.recoverCount==0){
             if(recoverIntegrator==null)
                 createAmbNode(t, nl);
             else if (!recoverIntegrator.isActive())
                 createAmbNode(t, nl);
             return;
         //}
-        //if (!nl.isRejected()) {            
+        //if (!nl.isRejected()) {
           //  int nlOld = nl.recoverCount;
            // recoverDisambiguator.handleAmbiguity(numberOfRecoveries, t, nl);
            // if (nl.recoverCount < nlOld)
              //   actorOnActiveStacksOverNewLink(nl);
         //}
-                        
+
     }*/
 
     void createAmbNode(IParseNode t, Link nl) {
         nl.addAmbiguity(t, tokensSeen);
         ambiguityManager.increaseAmbiguityCalls();
     }
-    
+
     private void addNewStack(Frame st0, State s, Production prod, int length,
             int numberOfRecoveries, IParseNode t) {
         Frame st1;
         Link nl;
         /* Found no existing stack with for state s; make new stack */
-        st1 = newStack(s);            
+        st1 = newStack(s);
         nl = st1.addLink(st0, t, length);
-        nl.recoverCount = numberOfRecoveries;   
-        addStack(st1);            
+        nl.recoverCount = numberOfRecoveries;
+        addStack(st1);
         forActorDelayed.addFirst(st1);
         if(Tools.tracing) {
             TRACE("SG_AddStack() - " + st1.state.stateNumber);
@@ -723,8 +725,8 @@
             nl.reject();
             increaseRejectCount();
         }
-    }  
-    
+    }
+
     private void addNewRecoverStack(Frame st0, State s, Production prod, int length,
             int numberOfRecoveries, IParseNode t) {
         if (fineGrainedOnRegion && !prod.isRejectProduction()) {
@@ -734,9 +736,9 @@
             st1 = newStack(s);
             nl = st1.addLink(st0, t, length);
             nl.recoverCount = numberOfRecoveries;
-            recoverStacks.addFirst(st1);            
+            recoverStacks.addFirst(st1);
         }
-    }  
+    }
 
     private void actorOnActiveStacksOverNewLink(Link nl) throws IOException {
         // Note: ActiveStacks can be modified inside doLimitedReductions
@@ -754,16 +756,16 @@
 
             for (Action action : st2.peek().getActions()) {
                 if (action.accepts(currentToken)) {
-                    for (ActionItem ai : action.getActionItems()) {                  
+                    for (ActionItem ai : action.getActionItems()) {
                         switch(ai.type) {
                             case ActionItem.REDUCE:
                                 Reduce red = (Reduce) ai;
-                                doLimitedReductions(st2, red.production, nl);                           
+                                doLimitedReductions(st2, red.production, nl);
                                 break;
                             case ActionItem.REDUCE_LOOKAHEAD:
-                                ReduceLookahead red2 = (ReduceLookahead) ai;                         
+                                ReduceLookahead red2 = (ReduceLookahead) ai;
                                 if(checkLookahead(red2)) {
-                                    doLimitedReductions(st2, red2.production, nl);                               
+                                    doLimitedReductions(st2, red2.production, nl);
                                 }
                                 break;
                         }
@@ -771,7 +773,7 @@
                 }
             }
         }
-    }    
+    }
 
     private int calcRecoverCount(Production prod, Path path) {
         int numberOfRecoveries = path.getRecoverCount();
@@ -781,7 +783,7 @@
         }
         return numberOfRecoveries;
     }
-    
+
     private boolean inReduceStacks(Queue<Frame> q, Frame frame) {
         if(Tools.tracing) {
             TRACE("SG_InReduceStacks() - " + frame.state.stateNumber);
@@ -832,8 +834,8 @@
             TRACE("SG_ - stack not found");
         }
         return null;
-    }     
-   
+    }
+
 
     private int getNextToken() throws IOException {
         if(Tools.tracing) {
@@ -934,11 +936,11 @@
     AmbiguityManager getAmbiguityManager() {
         return ambiguityManager;
     }
-    
+
     public Disambiguator getDisambiguator() {
         return disambiguator;
     }
-    
+
     public void setDisambiguator(Disambiguator disambiguator) {
         this.disambiguator = disambiguator;
     }
@@ -954,18 +956,18 @@
     public int getRejectionCount() {
         return rejectCount;
     }
-    
+
     @Deprecated
     public static void setWorkAroundMultipleLookahead(boolean value) {
         WORK_AROUND_MULTIPLE_LOOKAHEAD = value;
-    }   
-       
+    }
+
+
+
+
 
-      
-      
-    
     ////////////////////////////////////////////////////// Log functions ///////////////////////////////////////////////////////////////////////////////
-    
+
     static void TRACE(String string) {
         System.err.println("[" + num + "] " + string);
         num++;
@@ -988,7 +990,7 @@
         return sb.toString();
     }
 
-    
+
     private void logParseResult(Link s) {
         if (isDebugging()) {
             Tools.debug("internal parse tree:\n", s.label);
@@ -996,8 +998,8 @@
 
         if(Tools.tracing) {
             TRACE("SG_ - internal tree: " + s.label);
-        }       
-                
+        }
+
         if (Tools.measuring) {
             Measures m = new Measures();
             //Tools.debug("Time (ms): " + (System.currentTimeMillis()-startTime));
@@ -1020,7 +1022,7 @@
             Tools.setMeasures(m);
         }
     }
-    
+
 
     private void logBeforeParsing() {
         if(Tools.tracing) {
@@ -1031,7 +1033,7 @@
             Tools.debug("parse() - ", dumpActiveStacks());
         }
     }
-    
+
     private void logAfterParsing()
             throws BadTokenException, TokenExpectedException {
         if (isLogging()) {
@@ -1069,7 +1071,7 @@
             Tools.logger("Current token (#", tokensSeen, "): ", logCharify(currentToken));
         }
     }
-    
+
     private void logAfterShifter() {
         if(Tools.tracing) {
             TRACE("SG_DiscardShiftPairs() - ");
@@ -1082,7 +1084,7 @@
             TRACE("SG_Shifter() - ");
             TRACE_ActiveStacks();
         }
-        
+
         if (Tools.logging) {
             Tools.logger("#", tokensSeen, ": shifting ", forShifter.size(), " parser(s) -- token ",
                          logCharify(currentToken), ", line ", lineNumber, ", column ", columnNumber);
@@ -1095,7 +1097,7 @@
             Tools.debug(" parsers : " + forShifter.size());
         }
     }
-    
+
     private void logBeforeParseCharacter() {
         if(Tools.tracing) {
             TRACE("SG_ParseToken() - ");
@@ -1112,7 +1114,7 @@
             Tools.debug(" # for actor     : " + forActor.size());
         }
     }
-    
+
     private String logCharify(int currentToken) {
         switch (currentToken) {
         case 32:
@@ -1127,42 +1129,42 @@
             return "" + (char) currentToken;
         }
     }
-    
+
     private void logBeforeActor(Frame st, State s) {
         List<ActionItem> actionItems = null;
-        
+
         if (Tools.debugging || Tools.tracing) {
             actionItems = s.getActionItems(currentToken);
         }
-        
+
         if(Tools.tracing) {
             TRACE("SG_Actor() - " + st.state.stateNumber);
             TRACE_ActiveStacks();
         }
-        
+
         if (Tools.debugging) {
             Tools.debug("actor() - ", dumpActiveStacks());
-        }       
+        }
 
         if (Tools.debugging) {
             Tools.debug(" state   : ", s.stateNumber);
             Tools.debug(" token   : ", currentToken);
-        }        
+        }
 
         if (Tools.debugging) {
             Tools.debug(" actions : ", actionItems);
         }
-        
+
         if(Tools.tracing) {
             TRACE("SG_ - actions: " + actionItems.size());
         }
     }
-    
+
     private void logAfterDoReductions() {
         if (Tools.debugging) {
             Tools.debug("<doReductions() - " + dumpActiveStacks());
         }
-        
+
         if(Tools.tracing) {
             TRACE("SG_ - doreductions done");
         }
@@ -1172,16 +1174,16 @@
             List<IParseNode> kids, Frame st0, State next) {
         if (Tools.debugging) {
             Tools.debug(" path: ", path);
-            Tools.debug(" kids: ", kids);        
+            Tools.debug(" kids: ", kids);
             Tools.debug(st0.state);
-        }            
+        }
 
         if (Tools.logging) {
             Tools.logger("Goto(", st0.peek().stateNumber, ",", prod.label + ") == ",
                          next.stateNumber);
         }
-    }   
-    
+    }
+
 
     private void logBeforeDoReductions(Frame st, Production prod,
             final int pathsCount) {
@@ -1191,11 +1193,11 @@
 
         if (Tools.debugging) {
             Tools.debug("doReductions() - " + dumpActiveStacks());
-            logReductionInfo(st, prod);       
+            logReductionInfo(st, prod);
             Tools.debug(" paths : " + pathsCount);
         }
     }
-    
+
     private void logBeforeLimitedReductions(Frame st, Production prod, Link l,
             List<Path> paths) {
         if(Tools.tracing) {
@@ -1225,13 +1227,13 @@
         if (Tools.debugging) {
             Tools.debug(" added link ", nl, " from ", st1.state.stateNumber, " to ",
                         st0.state.stateNumber);
-        }               
+        }
 
         if(Tools.tracing) {
             TRACE_ActiveStacks();
         }
     }
-    
+
     private void logBeforeReducer(State s, Production prod, int length) {
         if(Tools.tracing) {
             TRACE("SG_Reducer() - " + s.stateNumber + ", " + length + ", " + prod.label);
@@ -1258,7 +1260,7 @@
         TRACE("SG_ - for_actor_delayed stacks: " + forActorDelayed.size());
     }
 
-   
+
     private void logAmbiguity(Frame st0, Production prod, Frame st1, Link nl) {
         if (Tools.logging) {
             Tools.logger("Ambiguity: direct link ", st0.state.stateNumber, " -> ",
@@ -1273,9 +1275,9 @@
             Tools.debug("createAmbiguityCluster - ", tokensSeen - nl.getLength() - 1, "/",
                         nl.getLength());
         }
-    }    
+    }
     //-------------------------------------------------- mj: debug and recovery ------------------------
-        
+
     //Used for debugging
     private String mjInfo() {
         String result = "";
@@ -1285,7 +1287,7 @@
             result += f.state.stateNumber;
             if(f.minAvoidValue() > 0)
                 result += "$"+f.minAvoidValue() + "$";
-            result += "; ";            
+            result += "; ";
         }
         result += " FORACTOR: ";
         for (Frame f : forActor) {
@@ -1302,12 +1304,12 @@
             result += "{ ";
             result += as.st.state.stateNumber;
             result+=",";
-            result += as.s.stateNumber;            
+            result += as.s.stateNumber;
             result += "} ; ";
         }
-        return result;        
-    } 
-    
+        return result;
+    }
+
     private String[] viewStackObject(boolean avoidFiltered){
         List<String> stackPaths = new ArrayList<String>();
         for (Frame actNode : activeStacks) {
@@ -1315,19 +1317,19 @@
             stackPaths.addAll(testMJ);
         }
         return stackPaths.toArray(new String[stackPaths.size()]);
-    }  
-    
+    }
+
     private String[] viewStackObject()
     {
         return viewStackObject(false);
     }
-    
+
     private String[] viewFilteredStackObject()
     {
         return viewStackObject(true);
     }
-    
-    private void mjTesting() {        
-        Tools.debug((char)currentToken); 
-    }   
+
+    private void mjTesting() {
+        Tools.debug((char)currentToken);
+    }
 }

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Shift.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Shift.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Shift.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Shift.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -5,7 +5,8 @@
  * 
  * Licensed under the GNU Lesser General Public License, v2.1
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
+
 
 public class Shift extends ActionItem {
 

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/StartSymbolException.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/StartSymbolException.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/StartSymbolException.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/StartSymbolException.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -1,4 +1,6 @@
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
+
+import org.spoofax.jsglr.shared.SGLRException;
 
 /**
  * Exception thrown when the specified start symbol could not be found.

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/State.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/State.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/State.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/State.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -5,12 +5,13 @@
  * 
  * Licensed under the GNU Lesser General Public License, v2.1
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.List;
 
+
 public class State implements Serializable {
 
     static final long serialVersionUID = 3383369639779986307L;

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/StructuralTokenRecognizer.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/StructuralTokenRecognizer.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/StructuralTokenRecognizer.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/StructuralTokenRecognizer.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -1,4 +1,4 @@
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 public class StructuralTokenRecognizer {
     

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/StructureSkipSuggestion.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/StructureSkipSuggestion.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/StructureSkipSuggestion.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/StructureSkipSuggestion.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -1,4 +1,5 @@
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
+
 
 public class StructureSkipSuggestion {
     

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Term.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Term.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Term.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Term.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -2,19 +2,18 @@
  * Created on 04.des.2005
  *
  * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
- * 
+ *
  * Licensed under the GNU Lesser General Public License, v2.1
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 import java.util.List;
 
-import jjtraveler.Visitable;
-import aterm.ATerm;
-import aterm.ATermAppl;
-import aterm.ATermFactory;
-import aterm.ATermInt;
-import aterm.ATermList;
+import org.spoofax.jsglr.shared.terms.ATerm;
+import org.spoofax.jsglr.shared.terms.ATermAppl;
+import org.spoofax.jsglr.shared.terms.ATermFactory;
+import org.spoofax.jsglr.shared.terms.ATermInt;
+import org.spoofax.jsglr.shared.terms.ATermList;
 
 public class Term {
 
@@ -22,18 +21,11 @@
         return (ATermInt) t;
     }
 
-    public static ATermInt asInt(Visitable v) {
-        return (ATermInt) v;
-    }
-    
+
     public static ATermAppl asAppl(ATerm t) {
         return (ATermAppl) t;
     }
 
-    public static ATermAppl asAppl(Visitable v) {
-        return (ATermAppl) v;
-    }
-    
     public static int toInt(ATermInt t) {
         return t.getInt();
     }
@@ -41,7 +33,7 @@
     public static int toInt(ATerm t) {
         return ((ATermInt)t).getInt();
     }
-    
+
     public static int intAt(ATerm pt, int i) {
         return asInt(pt.getChildAt(i)).getInt();
     }

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/server/ParseTableManager.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseTableManager.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseTableManager.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/server/ParseTableManager.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -2,10 +2,10 @@
  * Created on 26. nov.. 2006
  *
  * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
- * 
+ *
  * Licensed under the GNU General Public License, v2
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.server;
 
 import java.io.File;
 import java.io.FileInputStream;
@@ -18,39 +18,42 @@
 import java.util.HashMap;
 import java.util.Map;
 
-import aterm.ATerm;
-import aterm.ATermFactory;
-import aterm.pure.PureFactory;
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParseTable;
+import org.spoofax.jsglr.client.SGLR;
+import org.spoofax.jsglr.shared.Tools;
+import org.spoofax.jsglr.shared.terms.ATerm;
+import org.spoofax.jsglr.shared.terms.ATermFactory;
 
 public class ParseTableManager {
-    
+
     private Map<String, ParseTable> knownTables;
     private ATermFactory factory;
-    
+
     private static boolean cacheTables = false;
-    
+
     public ParseTableManager() {
-        factory = new PureFactory();
+        factory = new ATermFactory();
         knownTables = new HashMap<String, ParseTable>();
     }
-    
+
     public ParseTableManager(ATermFactory factory) {
         this.factory = factory;
         knownTables = new HashMap<String, ParseTable>();
     }
-    
+
     public ParseTable loadFromFile(String filename) throws FileNotFoundException, IOException, InvalidParseTableException {
-        
+
     	if(knownTables.containsKey(filename))
             return knownTables.get(filename);
-    	
+
     	ParseTable pt = null;
-    	
+
         if(cacheTables) {
         	final String cachedTable = hashFilename(filename);
         	File cached = new File(cachedTable);
         	File table = new File(filename);
-        	if(cached.exists() && 
+        	if(cached.exists() &&
         			cached.lastModified() >= table.lastModified()) {
         		try {
 					pt = loadFromCache(cachedTable);
@@ -66,11 +69,11 @@
         		storeInCache(pt, filename);
         	}
         }
-        
+
         knownTables.put(filename, pt);
         return pt;
     }
-    
+
     private void storeInCache(ParseTable pt, String filename) throws FileNotFoundException, IOException {
     	String storeName = hashFilename(filename);
     	File dir = new File(System.getProperty("user.home") + "/.jsglr/cache/");
@@ -98,7 +101,7 @@
         if(SGLR.isDebugging()) {
             Tools.debug("loadFromStream()");
         }
-        
+
         if (stream == null) {
             throw new InvalidParseTableException("stream is null");
         }
@@ -123,7 +126,7 @@
             Tools.logger((parseTable.hasPrefers() ? "Includes" : "Excludes"), " prefer actions");
             Tools.logger((parseTable.hasAvoids() ? "Includes" : "Excludes"), " avoid actions");
         }
-        
+
         return parseTable;
 	}
 

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/server/RemoteParseTableServiceImpl.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/server/RemoteParseTableServiceImpl.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -0,0 +1,15 @@
+package org.spoofax.jsglr.server;
+
+import org.spoofax.jsglr.shared.RemoteParseTableService;
+import org.spoofax.jsglr.shared.terms.ATerm;
+import org.spoofax.jsglr.shared.terms.ATermFactory;
+
+import com.google.gwt.user.server.rpc.RemoteServiceServlet;
+
+ at SuppressWarnings("serial")
+public class RemoteParseTableServiceImpl extends RemoteServiceServlet implements RemoteParseTableService {
+
+	public ATerm findParseTable(String resourceName) {
+		return	new ATermFactory().makeInt(0);
+	}
+}

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/BadTokenException.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/BadTokenException.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/BadTokenException.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/BadTokenException.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -1,11 +1,12 @@
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.shared;
 
-import aterm.ATerm;
-import aterm.ATermFactory;
+import org.spoofax.jsglr.client.SGLR;
+import org.spoofax.jsglr.shared.terms.ATerm;
+import org.spoofax.jsglr.shared.terms.ATermFactory;
 
 /**
  * Exception thrown when a specific token was unexpected by the parser.
- * 
+ *
  * @author Lennart Kats <L.C.L.Kats add tudelft.nl>
  */
 public class BadTokenException extends SGLRException {
@@ -28,16 +29,16 @@
     public int getToken() {
         return token;
     }
-    
+
     public boolean isEOFToken() {
         return token == SGLR.EOF;
     }
-    
+
     @Override
     public String getMessage() {
         return getShortMessage() + " at line " + lineNumber + ", column " + columnNumber;
     }
-    
+
     @Override
     public String getShortMessage() {
         if (isEOFToken())
@@ -53,7 +54,7 @@
         this.lineNumber = lineNumber;
         this.columnNumber = columnNumber;
     }
-    
+
 
     @Override
     protected ATerm toLocationATerm() {

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/RemoteParseTableService.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/RemoteParseTableService.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -0,0 +1,11 @@
+package org.spoofax.jsglr.shared;
+
+import org.spoofax.jsglr.shared.terms.ATerm;
+
+import com.google.gwt.user.client.rpc.RemoteServiceRelativePath;
+
+ at RemoteServiceRelativePath("parsetable")
+public interface RemoteParseTableService {
+
+	ATerm findParseTable(String resourceName);
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/RemoteParseTableServiceAsync.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/RemoteParseTableServiceAsync.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -0,0 +1,12 @@
+package org.spoofax.jsglr.shared;
+
+import org.spoofax.jsglr.shared.terms.ATerm;
+
+import com.google.gwt.user.client.rpc.AsyncCallback;
+
+
+public interface RemoteParseTableServiceAsync {
+
+	void findParseTable(String resourcePath, AsyncCallback<ATerm> asyncCallback);
+
+}

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/SGLRException.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/SGLRException.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/SGLRException.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/SGLRException.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -2,49 +2,50 @@
  * Created on 3. aug.. 2006
  *
  * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
- * 
+ *
  * Licensed under the GNU General Public License, v2
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.shared;
 
-import aterm.ATerm;
-import aterm.ATermFactory;
+import org.spoofax.jsglr.client.SGLR;
+import org.spoofax.jsglr.shared.terms.ATerm;
+import org.spoofax.jsglr.shared.terms.ATermFactory;
 
 public class SGLRException extends Exception {
 
     private static final long serialVersionUID = -8467572969588110480L;
-    
+
     private final SGLR parser;
-    
+
     public SGLRException(SGLR parser, String message, Throwable cause) {
         super(message, cause);
         this.parser = parser;
     }
-    
+
     public SGLRException(SGLR parser, String message) {
         this(parser, message, null);
     }
-    
+
     public SGLRException(SGLR parser) {
         this(parser, null, null);
     }
-    
+
     public final SGLR getParser() {
         return parser;
     }
-    
+
     public final ATerm toTerm() {
         return toTerm("-");
     }
-    
+
     protected String getShortMessage() {
         return getMessage();
     }
-    
+
     public ATerm toTerm(String filename) {
         if (parser == null)
             throw new UnsupportedOperationException();
-        
+
         ATermFactory factory = parser.getFactory();
         return factory.makeAppl(
             factory.makeAFun("error", 2, false),
@@ -62,7 +63,7 @@
             )
         );
     }
-    
+
     protected ATerm toLocationATerm() {
         ATermFactory factory = parser.getFactory();
         return factory.makeAppl(

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/TokenExpectedException.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/TokenExpectedException.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/TokenExpectedException.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/TokenExpectedException.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -1,4 +1,6 @@
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.shared;
+
+import org.spoofax.jsglr.client.SGLR;
 
 /**
  * Exception thrown when a specific token was expected by the parser.

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/Tools.java (from r21514, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Tools.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Tools.java	Thu Dec 16 12:01:00 2010	(r21514, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/Tools.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -2,106 +2,57 @@
  * Created on 04.des.2005
  *
  * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
- * 
+ *
  * Licensed under the GNU Lesser General Public License, v2.1
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.shared;
+
+import org.spoofax.jsglr.client.Measures;
 
-import java.io.BufferedOutputStream;
-import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.OutputStream;
 
 public class Tools {
-    
-    private static OutputStream fos;
-    private static String outfile = ".jsglr-log";
-
-    static boolean debugging = false;
-    static boolean logging = false;
-    static boolean tracing = false;
-    static boolean measuring = false;
-    
+
+    public static boolean debugging = false;
+    public static boolean logging = false;
+    public static boolean tracing = false;
+    public static boolean measuring = false;
+
     private static Measures measures;
-    
-    public static void setOutput(String d) {
-        outfile = d;
-        initOutput();
-    }
-
-    private static void initOutput() {
-        if(fos == null) {
-            try {
-                fos = new BufferedOutputStream(new FileOutputStream(outfile));
-            } catch (FileNotFoundException e) {
-                e.printStackTrace();
-            }
-        }
-    }
-    
+
     public static void debug(Object ...s) {
-        if (debugging) {
-            // FIXME Copy debug() from org.spoofax.interpreter
-            for(Object o : s) {
-                System.err.print(o);
-            }
-            System.err.println("");
-        }
+    	if(debugging)
+    		System.err.println(s);
     }
 
     public static void logger(Object ...s) {
-        if (logging) {
-            if (fos == null)
-                initOutput();
-            try {
-                for(Object o : s)
-                    fos.write(o.toString().getBytes());
-                fos.write("\n".getBytes());
-                fos.flush();
-            } catch (IOException e) {
-                e.printStackTrace();
-            }
-        }
+    	if(logging)
+    		System.out.println(s);
     }
- 
+
     public static void setTracing(boolean enableTracing) {
         tracing = enableTracing;
     }
-    
+
     public static void setDebug(boolean enableDebug) {
         debugging = enableDebug;
     }
 
     public static void setLogging(boolean enableLogging) {
         logging = enableLogging;
-        if (enableLogging) setOutput(outfile);
     }
-    
+
     // Measuring
-    
+
     public static void setMeasuring(boolean enableMeasuring) {
         measuring = enableMeasuring;
     }
-    
+
     public static void setMeasures(Measures m) {
         measures = m;
     }
-    
+
     public static Measures getMeasures() {
         return measures;
     }
-    
-    /**
-     * Sets the maximum amount of time to try and parse a file,
-     * before a {@link ParseTimeoutException} is thrown.
-     * 
-     * @param timeout  The maximum time to parse, in milliseconds.
-     * 
-     * @Deprecated Use SGLR.setTimeout instead
-     */
-    @Deprecated
-    public static void setTimeout(int timeout) {
-        // noop
-    }
+
 }

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/AFun.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/AFun.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -0,0 +1,23 @@
+package org.spoofax.jsglr.shared.terms;
+
+public class AFun {
+
+	private final String name;
+	private final int arity;
+	private final boolean quoted;
+
+	public AFun(String name, int arity, boolean quoted) {
+		this.name = name;
+		this.arity = arity;
+		this.quoted = quoted;
+	}
+
+	public int getArity() {
+		return arity;
+	}
+
+	public String getName() {
+		return name;
+	}
+
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -0,0 +1,37 @@
+package org.spoofax.jsglr.shared.terms;
+
+import java.util.List;
+
+import org.spoofax.jsglr.client.NotImplementedException;
+
+public abstract class ATerm {
+
+	public static final int INT = 1;
+	public static final int APPL = 2;
+	public static final int LIST = 3;
+
+	protected final ATermFactory factory;
+
+	protected ATerm(ATermFactory factory) {
+		this.factory = factory;
+	}
+
+	public abstract int getChildCount();
+
+	public abstract ATerm getChildAt(int i);
+
+	public abstract int getType();
+
+	public ATermFactory getFactory() {
+		return factory;
+	}
+
+	public List match(String termAsString) throws ParseError {
+		throw new NotImplementedException();
+	}
+
+	public List match(ATerm litStringAppl) {
+		throw new NotImplementedException();
+	}
+
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermAppl.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermAppl.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -0,0 +1,46 @@
+package org.spoofax.jsglr.shared.terms;
+
+import java.util.List;
+
+import org.spoofax.jsglr.client.NotImplementedException;
+
+public class ATermAppl extends ATerm {
+
+	private final AFun ctor;
+	private final ATerm[] kids;
+
+	ATermAppl(ATermFactory factory, AFun ctor, ATerm... kids) {
+		super(factory);
+		this.ctor = ctor;
+		this.kids = kids;
+	}
+
+	@Override
+	public int getChildCount() {
+		return ctor.getArity();
+	}
+
+	public String getName() {
+		return ctor.getName();
+	}
+
+	@Override
+	public ATerm getChildAt(int i) {
+		return kids[i];
+	}
+
+	@Override
+	public int getType() {
+		return ATerm.APPL;
+	}
+
+	public List match(ATerm term) {
+		throw new NotImplementedException();
+	}
+
+	public AFun getAFun() {
+		return ctor;
+	}
+
+
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermFactory.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermFactory.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -0,0 +1,45 @@
+package org.spoofax.jsglr.shared.terms;
+
+import java.io.InputStream;
+
+import org.spoofax.jsglr.client.NotImplementedException;
+
+public class ATermFactory {
+
+	public AFun makeAFun(String ctorName, int arity, boolean quoted) {
+		return new AFun(ctorName, arity, quoted);
+	}
+
+	public ATermList makeList() {
+		return new ATermList(this);
+	}
+
+	public ATermList makeList(ATerm... elements) {
+		return new ATermList(this, elements);
+	}
+
+	public ATerm parse(String string) {
+		throw new NotImplementedException();
+	}
+
+	public ATerm makeAppl(AFun afun, ATermList kids) {
+		return new ATermAppl(this, afun, kids);
+	}
+
+	public ATerm readFromFile(InputStream stream) {
+		throw new NotImplementedException();
+	}
+
+	public ATerm readFromFile(String stream) {
+		throw new NotImplementedException();
+	}
+
+	public ATerm makeAppl(AFun afun, ATerm... kids) {
+		return new ATermAppl(this, afun, kids);
+	}
+
+	public ATerm makeInt(int i) {
+		return new ATermInt(this, i);
+	}
+
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermInt.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermInt.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -0,0 +1,31 @@
+package org.spoofax.jsglr.shared.terms;
+
+public class ATermInt extends ATerm {
+
+	private final int value;
+
+	ATermInt(ATermFactory factory, int value) {
+		super(factory);
+		this.value = value;
+	}
+
+	@Override
+	public int getChildCount() {
+		return 0;
+	}
+
+	public int getInt() {
+		return value;
+	}
+
+	@Override
+	public ATerm getChildAt(int i) {
+		return null;
+	}
+
+	@Override
+	public int getType() {
+		return ATerm.INT;
+	}
+
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -0,0 +1,92 @@
+package org.spoofax.jsglr.shared.terms;
+
+import java.util.Iterator;
+
+public class ATermList extends ATerm implements Iterable<ATerm> {
+
+	private final ATerm[] elements;
+
+	ATermList(ATermFactory factory) {
+		super(factory);
+		elements = new ATerm[0];
+	}
+
+	ATermList(ATermFactory factory, ATerm... terms) {
+		super(factory);
+		elements = terms;
+	}
+
+	public ATermList prepend(ATerm t) {
+		ATerm[] newList = new ATerm[elements.length+1];
+		System.arraycopy(elements, 0, newList, 1, elements.length);
+		newList[0] = t;
+		return new ATermList(factory, newList);
+	}
+
+	public ATermList append(ATerm t) {
+		ATerm[] newList = new ATerm[elements.length+1];
+		System.arraycopy(elements, 0, newList, 0, elements.length);
+		newList[elements.length] = t;
+		return new ATermList(factory, newList);
+	}
+
+	public boolean isEmpty() {
+		return elements.length == 0;
+	}
+
+	public ATerm getFirst() {
+		return elements[0];
+	}
+
+	public ATermList getNext() {
+		ATerm[] newList = new ATerm[elements.length-1];
+		System.arraycopy(elements, 1, newList, 0, elements.length-1);
+		return new ATermList(factory, newList);
+	}
+
+	@Override
+	public ATerm getChildAt(int i) {
+		return elements[i];
+	}
+
+	@Override
+	public int getChildCount() {
+		return elements.length;
+	}
+
+	@Override
+	public int getType() {
+		return ATerm.LIST;
+	}
+
+	private static class ATermListIterator implements Iterator<ATerm> {
+		private final ATermList underlying;
+		private int position;
+
+		ATermListIterator(ATermList underlying) {
+			this.underlying = underlying;
+			position = 0;
+		}
+
+		@Override
+		public boolean hasNext() {
+			return position < underlying.elements.length;
+		}
+
+		@Override
+		public ATerm next() {
+			return underlying.elements[position++];
+		}
+
+		@Override
+		public void remove() {
+			throw new RuntimeException("Not supported");
+		}
+	}
+
+	@Override
+	public Iterator iterator() {
+		return new ATermListIterator(this);
+	}
+
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ParseError.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ParseError.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -0,0 +1,7 @@
+package org.spoofax.jsglr.shared.terms;
+
+public class ParseError extends RuntimeException {
+
+	private static final long serialVersionUID = 1L;
+
+}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/ParseTestCase.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 12:01:00 2010	(r21514)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -2,56 +2,75 @@
  * Created on 13.des.2005
  *
  * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
- * 
+ *
  * Licensed under the GNU Lesser General Public License, v2.1
  */
 package org.spoofax.jsglr.tests;
 
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.PrintWriter;
-import java.io.FileOutputStream;
 
-import junit.framework.TestCase;
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParseTable;
+import org.spoofax.jsglr.client.ParserException;
+import org.spoofax.jsglr.client.SGLR;
+import org.spoofax.jsglr.shared.RemoteParseTableService;
+import org.spoofax.jsglr.shared.RemoteParseTableServiceAsync;
+import org.spoofax.jsglr.shared.SGLRException;
+import org.spoofax.jsglr.shared.Tools;
+import org.spoofax.jsglr.shared.terms.ATerm;
+import org.spoofax.jsglr.shared.terms.ATermFactory;
+
+import com.google.gwt.core.client.GWT;
+import com.google.gwt.junit.client.GWTTestCase;
+import com.google.gwt.user.client.rpc.AsyncCallback;
 
-import org.spoofax.jsglr.ParseTable;
-import org.spoofax.jsglr.ParseTableManager;
-import org.spoofax.jsglr.ParserException;
-import org.spoofax.jsglr.InvalidParseTableException;
-import org.spoofax.jsglr.SGLR;
-import org.spoofax.jsglr.SGLRException;
-import org.spoofax.jsglr.Tools;
+public abstract class ParseTestCase extends GWTTestCase {
 
-import aterm.ATerm;
-import aterm.pure.PureFactory;
+	protected SGLR sglr;
+    protected String suffix;
 
-public abstract class ParseTestCase extends TestCase {
-
-    SGLR sglr;
-    String suffix;
     // shared by all tests
-    static final PureFactory pf = new PureFactory();
+    static final ATermFactory pf = new ATermFactory();
+    RemoteParseTableServiceAsync parseTableService = GWT.create(RemoteParseTableService.class);
 
-    public void setUp(String grammar, String suffix) throws FileNotFoundException, IOException, ParserException, InvalidParseTableException {
+    public void gwtSetUp(String grammar, String suffix) throws ParserException, InvalidParseTableException {
         this.suffix = suffix;
         Tools.setDebug(false);
         Tools.setLogging(false);
-        ParseTableManager ptm = new ParseTableManager(pf);
-        ParseTable pt = ptm.loadFromFile("tests/grammars/" + grammar + ".tbl");
-        sglr = new SGLR(pf, pt);
+        parseTableService.findParseTable("tests/grammars/" + grammar + ".tbl",
+        		new AsyncCallback<ATerm>() {
+
+					@Override
+					public void onFailure(Throwable caught) {
+						// TODO Auto-generated method stub
+
+					}
+
+					@Override
+					public void onSuccess(ATerm result) {
+				        try {
+							sglr = new SGLR(pf, new ParseTable(result));
+						} catch (InvalidParseTableException e) {
+							throw new RuntimeException(e);
+						}
+					}
+				});
+
     }
 
-    protected void tearDown()
-      throws Exception {
-        super.tearDown();
+    @Override
+	protected void gwtTearDown() throws Exception {
+        super.gwtTearDown();
 
         sglr.clear();
     }
 
     final static boolean doCompare = true;
     public void doParseTest(String s) throws FileNotFoundException, IOException {
-        Tools.setOutput("tests/jsglr-full-trace-" + s);
 
         long parseTime = System.nanoTime();
         ATerm parsed = null;
@@ -78,7 +97,7 @@
                 System.err.println("Saw    : " + parsed);
                 System.err.println("Wanted : " + loaded);
                 System.err.println("Trying to compare to the alternative file.");
-                
+
                 loaded = sglr.getFactory().readFromFile("tests/data/" + s + "-bis.trm");
 
                 assertNotNull(loaded);
@@ -94,4 +113,9 @@
             }
         }
     }
+
+    @Override
+    public String getModuleName() {
+    	return "org.spoofax.JsglrGWT";
+    }
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestBooleans.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestBooleans.java	Thu Dec 16 12:01:00 2010	(r21514)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestBooleans.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -2,7 +2,7 @@
  * Created on 05.des.2005
  *
  * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
- * 
+ *
  * Licensed under the GNU Lesser General Public License, v2.1
  */
 package org.spoofax.jsglr.tests;
@@ -13,8 +13,8 @@
 public class TestBooleans extends ParseTestCase {
 
     @Override
-    protected void setUp() throws Exception {
-        super.setUp("Booleans", "txt");
+    protected void gwtSetUp() throws Exception {
+        super.gwtSetUp("Booleans", "txt");
     }
 
     public void testB0() throws FileNotFoundException, IOException {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG1.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG1.java	Thu Dec 16 12:01:00 2010	(r21514)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG1.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -2,7 +2,7 @@
  * Created on 05.des.2005
  *
  * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
- * 
+ *
  * Licensed under the GNU Lesser General Public License, v2.1
  */
 package org.spoofax.jsglr.tests;
@@ -10,14 +10,15 @@
 import java.io.FileNotFoundException;
 import java.io.IOException;
 
-import org.spoofax.jsglr.ParserException;
-import org.spoofax.jsglr.InvalidParseTableException;
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParserException;
 
 public class TestG1 extends ParseTestCase {
 
-    public void setUp() throws FileNotFoundException, IOException,
+    @Override
+	public void gwtSetUp() throws FileNotFoundException, IOException,
             ParserException, InvalidParseTableException {
-        super.setUp("G1", "txt");
+        super.gwtSetUp("G1", "txt");
     }
 
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG2.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG2.java	Thu Dec 16 12:01:00 2010	(r21514)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG2.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -2,7 +2,7 @@
  * Created on 05.des.2005
  *
  * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
- * 
+ *
  * Licensed under the GNU Lesser General Public License, v2.1
  */
 package org.spoofax.jsglr.tests;
@@ -10,14 +10,15 @@
 import java.io.FileNotFoundException;
 import java.io.IOException;
 
-import org.spoofax.jsglr.ParserException;
-import org.spoofax.jsglr.InvalidParseTableException;
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParserException;
 
 public class TestG2 extends ParseTestCase {
 
-    public void setUp() throws FileNotFoundException, IOException,
+    @Override
+	public void gwtSetUp() throws FileNotFoundException, IOException,
             ParserException, InvalidParseTableException {
-        super.setUp("G2", "txt");
+        super.gwtSetUp("G2", "txt");
     }
 
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG_ambi.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG_ambi.java	Thu Dec 16 12:01:00 2010	(r21514)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG_ambi.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -2,7 +2,7 @@
  * Created on 05.des.2005
  *
  * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
- * 
+ *
  * Licensed under the GNU Lesser General Public License, v2.1
  */
 package org.spoofax.jsglr.tests;
@@ -10,14 +10,15 @@
 import java.io.FileNotFoundException;
 import java.io.IOException;
 
-import org.spoofax.jsglr.ParserException;
-import org.spoofax.jsglr.InvalidParseTableException;
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParserException;
 
 public class TestG_ambi extends ParseTestCase {
 
-    public void setUp() throws FileNotFoundException, IOException,
+    @Override
+	public void gwtSetUp() throws FileNotFoundException, IOException,
             ParserException, InvalidParseTableException {
-        super.setUp("G-ambi", "txt");
+        super.gwtSetUp("G-ambi", "txt");
     }
 
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG_avoid_1.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG_avoid_1.java	Thu Dec 16 12:01:00 2010	(r21514)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG_avoid_1.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -2,7 +2,7 @@
  * Created on 05.des.2005
  *
  * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
- * 
+ *
  * Licensed under the GNU Lesser General Public License, v2.1
  */
 package org.spoofax.jsglr.tests;
@@ -10,14 +10,15 @@
 import java.io.FileNotFoundException;
 import java.io.IOException;
 
-import org.spoofax.jsglr.ParserException;
-import org.spoofax.jsglr.InvalidParseTableException;
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParserException;
 
 public class TestG_avoid_1 extends ParseTestCase {
 
-    public void setUp() throws FileNotFoundException, IOException,
+    @Override
+	public void gwtSetUp() throws FileNotFoundException, IOException,
             ParserException, InvalidParseTableException {
-        super.setUp("G-avoid-1", "txt");
+        super.gwtSetUp("G-avoid-1", "txt");
     }
 
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG_avoid_2.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG_avoid_2.java	Thu Dec 16 12:01:00 2010	(r21514)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG_avoid_2.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -2,7 +2,7 @@
  * Created on 05.des.2005
  *
  * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
- * 
+ *
  * Licensed under the GNU Lesser General Public License, v2.1
  */
 package org.spoofax.jsglr.tests;
@@ -10,14 +10,15 @@
 import java.io.FileNotFoundException;
 import java.io.IOException;
 
-import org.spoofax.jsglr.ParserException;
-import org.spoofax.jsglr.InvalidParseTableException;
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParserException;
 
 public class TestG_avoid_2 extends ParseTestCase {
 
-    public void setUp() throws FileNotFoundException, IOException,
+    @Override
+	public void gwtSetUp() throws FileNotFoundException, IOException,
             ParserException, InvalidParseTableException {
-        super.setUp("G-avoid-2", "txt");
+        super.gwtSetUp("G-avoid-2", "txt");
     }
 
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG_left_assoc.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG_left_assoc.java	Thu Dec 16 12:01:00 2010	(r21514)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG_left_assoc.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -2,7 +2,7 @@
  * Created on 05.des.2005
  *
  * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
- * 
+ *
  * Licensed under the GNU Lesser General Public License, v2.1
  */
 package org.spoofax.jsglr.tests;
@@ -10,14 +10,15 @@
 import java.io.FileNotFoundException;
 import java.io.IOException;
 
-import org.spoofax.jsglr.ParserException;
-import org.spoofax.jsglr.InvalidParseTableException;
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParserException;
 
 public class TestG_left_assoc extends ParseTestCase {
 
-    public void setUp() throws FileNotFoundException, IOException,
+    @Override
+	public void gwtSetUp() throws FileNotFoundException, IOException,
             ParserException, InvalidParseTableException {
-        super.setUp("G-left-assoc", "txt");
+        super.gwtSetUp("G-left-assoc", "txt");
     }
 
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG_prefer_1.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG_prefer_1.java	Thu Dec 16 12:01:00 2010	(r21514)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG_prefer_1.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -2,7 +2,7 @@
  * Created on 05.des.2005
  *
  * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
- * 
+ *
  * Licensed under the GNU Lesser General Public License, v2.1
  */
 package org.spoofax.jsglr.tests;
@@ -10,14 +10,15 @@
 import java.io.FileNotFoundException;
 import java.io.IOException;
 
-import org.spoofax.jsglr.ParserException;
-import org.spoofax.jsglr.InvalidParseTableException;
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParserException;
 
 public class TestG_prefer_1 extends ParseTestCase {
 
-    public void setUp() throws FileNotFoundException, IOException,
+    @Override
+	public void gwtSetUp() throws FileNotFoundException, IOException,
             ParserException, InvalidParseTableException {
-        super.setUp("G-prefer-1", "txt");
+        super.gwtSetUp("G-prefer-1", "txt");
     }
 
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG_prefer_2.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG_prefer_2.java	Thu Dec 16 12:01:00 2010	(r21514)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG_prefer_2.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -2,7 +2,7 @@
  * Created on 05.des.2005
  *
  * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
- * 
+ *
  * Licensed under the GNU Lesser General Public License, v2.1
  */
 package org.spoofax.jsglr.tests;
@@ -10,14 +10,15 @@
 import java.io.FileNotFoundException;
 import java.io.IOException;
 
-import org.spoofax.jsglr.ParserException;
-import org.spoofax.jsglr.InvalidParseTableException;
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParserException;
 
 public class TestG_prefer_2 extends ParseTestCase {
 
-    public void setUp() throws FileNotFoundException, IOException,
+    @Override
+	public void gwtSetUp() throws FileNotFoundException, IOException,
             ParserException, InvalidParseTableException {
-        super.setUp("G-prefer-2", "txt");
+        super.gwtSetUp("G-prefer-2", "txt");
     }
 
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG_reject_1.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG_reject_1.java	Thu Dec 16 12:01:00 2010	(r21514)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG_reject_1.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -2,7 +2,7 @@
  * Created on 05.des.2005
  *
  * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
- * 
+ *
  * Licensed under the GNU Lesser General Public License, v2.1
  */
 package org.spoofax.jsglr.tests;
@@ -10,14 +10,15 @@
 import java.io.FileNotFoundException;
 import java.io.IOException;
 
-import org.spoofax.jsglr.ParserException;
-import org.spoofax.jsglr.InvalidParseTableException;
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParserException;
 
 public class TestG_reject_1 extends ParseTestCase {
 
-    public void setUp() throws FileNotFoundException, IOException,
+    @Override
+	public void gwtSetUp() throws FileNotFoundException, IOException,
             ParserException, InvalidParseTableException {
-        super.setUp("G-reject-1", "txt");
+        super.gwtSetUp("G-reject-1", "txt");
     }
 
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG_reject_2.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG_reject_2.java	Thu Dec 16 12:01:00 2010	(r21514)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG_reject_2.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -2,7 +2,7 @@
  * Created on 05.des.2005
  *
  * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
- * 
+ *
  * Licensed under the GNU Lesser General Public License, v2.1
  */
 package org.spoofax.jsglr.tests;
@@ -10,14 +10,15 @@
 import java.io.FileNotFoundException;
 import java.io.IOException;
 
-import org.spoofax.jsglr.ParserException;
-import org.spoofax.jsglr.InvalidParseTableException;
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParserException;
 
 public class TestG_reject_2 extends ParseTestCase {
 
-    public void setUp() throws FileNotFoundException, IOException,
+    @Override
+	public void gwtSetUp() throws FileNotFoundException, IOException,
             ParserException, InvalidParseTableException {
-        super.setUp("G-reject-2", "txt");
+        super.gwtSetUp("G-reject-2", "txt");
     }
 
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG_right_assoc.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG_right_assoc.java	Thu Dec 16 12:01:00 2010	(r21514)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestG_right_assoc.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -2,7 +2,7 @@
  * Created on 05.des.2005
  *
  * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
- * 
+ *
  * Licensed under the GNU Lesser General Public License, v2.1
  */
 package org.spoofax.jsglr.tests;
@@ -10,14 +10,15 @@
 import java.io.FileNotFoundException;
 import java.io.IOException;
 
-import org.spoofax.jsglr.ParserException;
-import org.spoofax.jsglr.InvalidParseTableException;
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParserException;
 
 public class TestG_right_assoc extends ParseTestCase {
 
-    public void setUp() throws FileNotFoundException, IOException,
+    @Override
+	public void gwtSetUp() throws FileNotFoundException, IOException,
             ParserException, InvalidParseTableException {
-        super.setUp("G-right-assoc", "txt");
+        super.gwtSetUp("G-right-assoc", "txt");
     }
 
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestIParseNode.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestIParseNode.java	Thu Dec 16 12:01:00 2010	(r21514)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestIParseNode.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -10,9 +10,9 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import org.spoofax.jsglr.IParseNode;
-import org.spoofax.jsglr.ParseNode;
-import org.spoofax.jsglr.ParseProductionNode;
+import org.spoofax.jsglr.client.IParseNode;
+import org.spoofax.jsglr.client.ParseNode;
+import org.spoofax.jsglr.client.ParseProductionNode;
 
 import junit.framework.TestCase;
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestStratego.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestStratego.java	Thu Dec 16 12:01:00 2010	(r21514)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/TestStratego.java	Thu Dec 16 14:59:08 2010	(r21515)
@@ -2,7 +2,7 @@
  * Created on 05.des.2005
  *
  * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
- * 
+ *
  * Licensed under the GNU Lesser General Public License, v2.1
  */
 package org.spoofax.jsglr.tests;
@@ -10,14 +10,14 @@
 import java.io.FileNotFoundException;
 import java.io.IOException;
 
-import org.spoofax.jsglr.ParserException;
-import org.spoofax.jsglr.InvalidParseTableException;
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParserException;
 
 public class TestStratego extends ParseTestCase {
 
-    public void setUp() throws FileNotFoundException, IOException,
-            ParserException, InvalidParseTableException {
-        super.setUp("Stratego", "str");
+    @Override
+	public void gwtSetUp() throws ParserException, InvalidParseTableException {
+        super.gwtSetUp("Stratego", "str");
     }
 
 

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/war/Jsglr_gwt.css
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/war/Jsglr_gwt.css	Thu Dec 16 14:59:08 2010	(r21515)
@@ -0,0 +1,34 @@
+/** Add css rules here for your application. */
+
+
+/** Example rules used by the template application (remove for your app) */
+h1 {
+  font-size: 2em;
+  font-weight: bold;
+  color: #777777;
+  margin: 40px 0px 70px;
+  text-align: center;
+}
+
+.sendButton {
+  display: block;
+  font-size: 16pt;
+}
+
+/** Most GWT widgets already have a style name defined */
+.gwt-DialogBox {
+  width: 400px;
+}
+
+.dialogVPanel {
+  margin: 5px;
+}
+
+.serverResponseLabelError {
+  color: red;
+}
+
+/** Set ids using widget.getElement().setId("idOfElement") */
+#closeButton {
+  margin: 15px 6px 6px;
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/war/Jsglr_gwt.html
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/war/Jsglr_gwt.html	Thu Dec 16 14:59:08 2010	(r21515)
@@ -0,0 +1,24 @@
+<!doctype html>
+<html>
+  <head>
+    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
+    <link type="text/css" rel="stylesheet" href="Jsglr_gwt.css">
+
+    <title>Web Application Starter Project</title>
+    
+    <script type="text/javascript" language="javascript" src="jsglrgwt/jsglrgwt.nocache.js"></script>
+  </head>
+
+  <body>
+
+    <iframe src="javascript:''" id="__gwt_historyFrame" tabIndex='-1' style="position:absolute;width:0;height:0;border:0"></iframe>
+    <noscript>
+      <div style="width: 22em; position: absolute; left: 50%; margin-left: -11em; color: red; background-color: white; border: 1px solid red; padding: 4px; font-family: sans-serif">
+        Your web browser must have JavaScript enabled
+        in order for this application to display correctly.
+      </div>
+    </noscript>
+
+    <h1>JSGLR for GWT</h1>
+  </body>
+</html>

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/war/WEB-INF/classes/org/spoofax/JsglrGWT.gwt.xml
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/war/WEB-INF/classes/org/spoofax/JsglrGWT.gwt.xml	Thu Dec 16 14:59:08 2010	(r21515)
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module rename-to='jsglrgwt'>
+
+  <inherits name='com.google.gwt.user.User'/>
+
+  <entry-point class='org.spoofax.client.JSGLREntryPoint'/>
+
+  <source path='jsglr.client'/>
+  <source path='jsglr.shared'/>
+  <source path='client'/>
+
+</module>

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/war/WEB-INF/web.xml
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/war/WEB-INF/web.xml	Thu Dec 16 14:59:08 2010	(r21515)
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE web-app
+    PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
+    "http://java.sun.com/dtd/web-app_2_3.dtd">
+
+<web-app>
+  
+  <welcome-file-list>
+    <welcome-file>Jsglr_gwt.html</welcome-file>
+  </welcome-file-list>
+
+</web-app>

From karltk at strategoxt.org  Thu Dec 16 16:01:43 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:01:43 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21516 - in
	spoofax/branches/jsglr-gwt: . jsglr-gwt/src/org/spoofax
	jsglr-gwt/src/org/spoofax/client
	jsglr-gwt/src/org/spoofax/jsglr/client
	jsglr-gwt/src/org/spoofax/jsglr/...
Message-ID: <201012161501.oBGF1h1d026945@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:01:43 2010
New Revision: 21516
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21516&sc=1

Log:
* Removed all references to Java IO.
 * Operate entirely on strings instead.
 * Hacked together minimal ATerm implementation necessary for supporting the parser.
 * Set up a simple test case, parsing a single literal with the Booleans grammar. And that works. Woohoo.
 * Added Stratego parse table (text form).
 * Added workaround (fix?) for parse table loading bug (lookahead-related).
 * Dropped GWT-based serialization of parse tables, and moved ATerm parsing to client-side.
 * Can now actually parse small Stratego fragments. Dead slow on Firefox. Decent on Chrome.

Added:
   spoofax/branches/jsglr-gwt/.hgignore
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/PushbackStringIterator.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/TaskCancellationException.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/ArrayDeque.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermPlaceholder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermString.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermTuple.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/AllTests.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestBooleans.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestG1.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestG2.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestG_ambi.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestG_avoid_1.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestG_avoid_2.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestG_left_assoc.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestG_prefer_1.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestG_prefer_2.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestG_reject_1.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestG_reject_2.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestG_right_assoc.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIParseNode.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestStratego.java
Deleted:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Main.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/server/ParseTableManager.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/tests/
Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/JsglrGWT.gwt.xml
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/client/JSGLREntryPoint.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/BacktrackPosition.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/FineGrainedOnRegion.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentInfo.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentTokenizer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/NewStructureSkipper.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParserHistory.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/RecoveryConnector.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/RegionRecovery.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/server/RemoteParseTableServiceImpl.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/RemoteParseTableService.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/RemoteParseTableServiceAsync.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/AFun.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermAppl.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermFactory.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermInt.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ParseError.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/war/Jsglr_gwt.html
   spoofax/branches/jsglr-gwt/jsglr-gwt/war/WEB-INF/classes/org/spoofax/JsglrGWT.gwt.xml
   spoofax/branches/jsglr-gwt/jsglr-gwt/war/WEB-INF/web.xml

Added: spoofax/branches/jsglr-gwt/.hgignore
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/.hgignore	Thu Dec 16 15:01:43 2010	(r21516)
@@ -0,0 +1,8 @@
+syntax: glob
+*.class
+*.cache.*
+.metadata
+*.jar
+jsglr-gwt/war/jsglrgwt
+jsglr-gwt/war/*.tbl
+jsglr-gwt/.settings

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/JsglrGWT.gwt.xml
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/JsglrGWT.gwt.xml	Thu Dec 16 14:59:08 2010	(r21515)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/JsglrGWT.gwt.xml	Thu Dec 16 15:01:43 2010	(r21516)
@@ -2,11 +2,12 @@
 <module rename-to='jsglrgwt'>
 
   <inherits name='com.google.gwt.user.User'/>
+  <inherits name="com.google.gwt.http.HTTP"/>
 
-  <entry-point class='org.spoofax.client.JSGLREntryPoint'/>
-
-  <source path='jsglr.client'/>
-  <source path='jsglr.shared'/>
+  <source path='jsglr/client'/>
+  <source path='jsglr/shared'/>
   <source path='client'/>
 
+  <entry-point class='org.spoofax.client.JSGLREntryPoint'/>
+
 </module>

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/client/JSGLREntryPoint.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/client/JSGLREntryPoint.java	Thu Dec 16 14:59:08 2010	(r21515)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/client/JSGLREntryPoint.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -1,7 +1,5 @@
 package org.spoofax.client;
 
-import java.io.IOException;
-
 import org.spoofax.jsglr.client.InvalidParseTableException;
 import org.spoofax.jsglr.client.ParseException;
 import org.spoofax.jsglr.client.ParseTable;
@@ -13,20 +11,67 @@
 import org.spoofax.jsglr.shared.terms.ATermFactory;
 
 import com.google.gwt.core.client.EntryPoint;
+import com.google.gwt.core.client.GWT;
+import com.google.gwt.http.client.Request;
+import com.google.gwt.http.client.RequestBuilder;
+import com.google.gwt.http.client.RequestCallback;
+import com.google.gwt.http.client.RequestException;
+import com.google.gwt.http.client.Response;
 import com.google.gwt.user.client.ui.Label;
 import com.google.gwt.user.client.ui.RootPanel;
 
 public class JSGLREntryPoint implements EntryPoint {
 
+	private void fetchParseTable(String parseTable) {
+		RequestBuilder builder = new RequestBuilder(RequestBuilder.GET, parseTable);
+		try {
+			builder.sendRequest( null,  new RequestCallback() {
+				public void onError(Request request, Throwable exception)
+				{ 
+					GWT.log( "error", exception ); 
+				}
+				@Override
+				public void onResponseReceived(Request request, Response response) {
+					parseAndGo(response.getText());
+				}
+			});
+		} catch (RequestException e) { 
+			GWT.log( "error", e); 
+		}
+	}
 	@Override
 	public void onModuleLoad() {
-		RootPanel.get().add(new Label("Booting"));
+		RootPanel.get().add(new Label("Loading parse table from server"));
+		fetchParseTable("/Stratego.tbl");
+//		RemoteParseTableServiceAsync rpts = GWT.create(RemoteParseTableService.class);
+//		rpts.fetchParseTable("Stratego2.tbl", new AsyncCallback<ATerm>() {
+//
+//			@Override
+//			public void onSuccess(ATerm result) {
+//				parseAndGo(result);
+//			}
+//
+//			@Override
+//			public void onFailure(Throwable caught) {
+//				RootPanel.get().add(new Label("Failed to fetch parse table"));
+//			}
+//		});
+	}
+
+	private void parseAndGo(String table) {
 		try {
-			SGLR sglr = new SGLR(new ATermFactory(), new ParseTable(null));
-			ATerm r = sglr.parse("foo bar baz");
-			if(r != null)
+			System.out.println(table.length());
+			ATermFactory af = new ATermFactory();
+			ATerm pt = af.parse(table);
+			System.out.println(pt.toString().length());
+			SGLR sglr = new SGLR(af, new ParseTable(pt));
+			long now = System.currentTimeMillis();
+			ATerm r = sglr.parse(strategoSampleCode());
+			now = System.currentTimeMillis() - now;
+			if(r != null) {
 				RootPanel.get().add(new Label(r.toString()));
-			else {
+				RootPanel.get().add(new Label("Parse time : " + now + " ms"));
+			} else {
 				RootPanel.get().add(new Label("Parsing failed"));
 			}
 		} catch (InvalidParseTableException e) {
@@ -37,16 +82,38 @@
 			wrap(e);
 		} catch (ParseException e) {
 			wrap(e);
-		} catch (IOException e) {
-			wrap(e);
 		} catch (SGLRException e) {
 			wrap(e);
 		}
 
 	}
-
 	private static void wrap(Exception e) {
+		System.err.println(e);
 		throw new RuntimeException(e);
 	}
 
+	private String strategoSampleCode() {
+		return "module common\n" +
+		"imports\n" +
+		"  include/Stratify\n" +
+		"strategies\n" +
+		"collect-meta-prop =\n" + 
+		"         ?Prop(n, v)\n" + 
+		"       ; rules(meta-prop : n -> v)\n" + 
+		"       ; <debug> (\"registered\", n, \"->\", v)\n" + 
+		"       ; <meta-prop> n\n" +
+		"       ; <debug> (\"looked up\", n, \"->\", <id>)\n" + 
+		" apply-with-props(s | props) =\n" + 
+		"        {meta-props:\n" +
+		"              where(<map(collect-meta-prop)> props)\n" + 
+		"          ; s\n" + 
+		"        }\n" +
+		" string-join(|c) =\n" +
+		"          <foldl(\\(x,y) -> <concat-strings> [y, c, x]\\)> (<id>, \"\")\n" +
+		"        ; trim-chars(?',')";
+	}
+
+	private String booleanSampleCode() {
+		return "(T&T|F)&not(F)|Bool293";
+	}
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/BacktrackPosition.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/BacktrackPosition.java	Thu Dec 16 14:59:08 2010	(r21515)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/BacktrackPosition.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -2,7 +2,7 @@
 
 import java.util.ArrayList;
 
-import org.spoofax.ArrayDeque;
+import org.spoofax.jsglr.shared.ArrayDeque;
 
 public class BacktrackPosition {
     public final int tokensSeen;

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/FineGrainedOnRegion.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/FineGrainedOnRegion.java	Thu Dec 16 14:59:08 2010	(r21515)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/FineGrainedOnRegion.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -1,17 +1,13 @@
 package org.spoofax.jsglr.client;
 
-import java.io.IOException;
 import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
 
-import org.spoofax.ArrayDeque;
+import org.spoofax.jsglr.shared.ArrayDeque;
 
 public class FineGrainedOnRegion {
     private static final int MAX_RECOVERIES_PER_LINE = 3;
     private static final int MAX_NR_OF_LINES = 25;
     private int acceptRecoveryPosition;
-    private int regionStartPosition;
     private int regionEndPosition;
     private ArrayList<BacktrackPosition> choicePoints;
     private SGLR mySGLR;
@@ -22,7 +18,6 @@
     }
    
     public void setRegionInfo(StructureSkipSuggestion erroneousRegion, int acceptPosition){
-        regionStartPosition=erroneousRegion.getStartSkip().getTokensSeen();
         regionEndPosition=erroneousRegion.getEndSkip().getTokensSeen();
         acceptRecoveryPosition=acceptPosition;
         int lastIndex=Math.min(erroneousRegion.getIndexHistoryEnd(), getHistory().getIndexLastLine());
@@ -44,7 +39,7 @@
         }
     }
     
-    public boolean recover() throws IOException{
+    public boolean recover() {
        // System.out.println("FINE GRAINED RECOVERY STARTED");
         mySGLR.setFineGrainedOnRegion(true);
         boolean succeeded=recoverFrom(choicePoints.size()-1, new ArrayList<RecoverNode>());
@@ -52,7 +47,7 @@
         return succeeded;
     }
     
-    private boolean recoverFrom(int indexCP, ArrayList<RecoverNode> candidates) throws IOException {        
+    private boolean recoverFrom(int indexCP, ArrayList<RecoverNode> candidates) {        
         int loops=choicePoints.size()-1-indexCP;
         if(indexCP<-1*maxPerLine)//first line 3 times explored
             return false;
@@ -91,7 +86,7 @@
         return recoverFrom(indexCP-1, newCandidates);    
     }
 
-    private ArrayList<RecoverNode> recoverParse(ArrayList<RecoverNode> candidates, int endRecoverSearchPos, boolean keepHistory) throws IOException {
+    private ArrayList<RecoverNode> recoverParse(ArrayList<RecoverNode> candidates, int endRecoverSearchPos, boolean keepHistory) {
        // System.out.println("RECOVER PARSE");
         ArrayList<RecoverNode> newCandidates=new ArrayList<RecoverNode>();
         boolean firstRound=false;//true;
@@ -105,7 +100,6 @@
             //if(logToken==SGLR.EOF){logToken='$';}
             //System.out.print(logToken);
             if(curTokIndex<=endRecoverSearchPos && !firstRound){
-                int oldSize=newCandidates.size();
                 newCandidates.addAll(collectNewRecoverCandidates(curTokIndex));
                 //if(newCandidates.size()>oldSize)
                   //  System.out.println("CANDIDATES: " + (newCandidates.size()-oldSize));
@@ -144,7 +138,7 @@
         choicePoints=new ArrayList<BacktrackPosition>();
     }
 
-    public boolean parseRemainingTokens() throws IOException {
+    public boolean parseRemainingTokens() {
         // TODO what if parsing fails here???
         while(!getHistory().hasFinishedRecoverTokens() && mySGLR.activeStacks.size()>0 && mySGLR.acceptingStack==null){        
             getHistory().readRecoverToken(mySGLR, true);

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentInfo.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentInfo.java	Thu Dec 16 14:59:08 2010	(r21515)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentInfo.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -1,6 +1,6 @@
 package org.spoofax.jsglr.client;
 
-import org.spoofax.ArrayDeque;
+import org.spoofax.jsglr.shared.ArrayDeque;
 
 /*
  * Should be created before parsing the first character of a line

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentTokenizer.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentTokenizer.java	Thu Dec 16 14:59:08 2010	(r21515)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentTokenizer.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -1,9 +1,8 @@
 package org.spoofax.jsglr.client;
 
 import java.io.IOException;
-import java.util.Stack;
 
-import org.spoofax.ArrayDeque;
+import org.spoofax.jsglr.shared.ArrayDeque;
 
 /*
  * Creates tokens DEDENT and INDENT based on indentation.

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/NewStructureSkipper.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/NewStructureSkipper.java	Thu Dec 16 14:59:08 2010	(r21515)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/NewStructureSkipper.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -1,6 +1,5 @@
 package org.spoofax.jsglr.client;
 
-import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
 
@@ -28,19 +27,17 @@
         structTokens=new StructuralTokenRecognizer();
     }
 
-    public ArrayList<StructureSkipSuggestion> getPreviousSkipSuggestions(int failureIndex)
-    throws IOException {
+    public ArrayList<StructureSkipSuggestion> getPreviousSkipSuggestions(int failureIndex) {
         return selectPrevRegion(failureIndex);
     }
     
-    public ArrayList<StructureSkipSuggestion> getCurrentSkipSuggestions(int failureIndex) throws IOException {
+    public ArrayList<StructureSkipSuggestion> getCurrentSkipSuggestions(int failureIndex) {
         ArrayList<StructureSkipSuggestion> result = getCurrentRegionSkips(failureIndex);  
         addNextRegionMerges(result);
         return result;
     }
 
-    private void addNextRegionMerges(ArrayList<StructureSkipSuggestion> result)
-            throws IOException {
+    private void addNextRegionMerges(ArrayList<StructureSkipSuggestion> result) {
         ArrayList<StructureSkipSuggestion> includeNexts=new ArrayList<StructureSkipSuggestion>();
         for (StructureSkipSuggestion skip : result) {            
             for (StructureSkipSuggestion skipFW : selectRegion(skip.getIndexHistoryEnd())) {
@@ -50,8 +47,7 @@
         result.addAll(includeNexts);
     }
 
-    private ArrayList<StructureSkipSuggestion> getCurrentRegionSkips(
-            int failureIndex) throws IOException {
+    private ArrayList<StructureSkipSuggestion> getCurrentRegionSkips(int failureIndex) {
         ArrayList<StructureSkipSuggestion> result=new ArrayList<StructureSkipSuggestion>();
         if (failureIndex>0 && isScopeOpeningLine(failureIndex) && getHistory().getLine(failureIndex-1).getIndentValue()==getHistory().getLine(failureIndex).getIndentValue())
             result.addAll(selectRegion(failureIndex-1));
@@ -59,12 +55,11 @@
         return result;
     }
     
-    public ArrayList<StructureSkipSuggestion> getPriorSkipSuggestions(int failureIndex) throws IOException {
+    public ArrayList<StructureSkipSuggestion> getPriorSkipSuggestions(int failureIndex) {
         return getPriorRegions(failureIndex);
     }
     
-    public ArrayList<StructureSkipSuggestion> getSibblingBackwardSuggestions(int failureIndex)
-    throws IOException {
+    public ArrayList<StructureSkipSuggestion> getSibblingBackwardSuggestions(int failureIndex) {
         ArrayList<StructureSkipSuggestion> bwSkips=new ArrayList<StructureSkipSuggestion>();
         ArrayList<StructureSkipSuggestion> priorSiblings=getPriorRegions(failureIndex);
         ArrayList<StructureSkipSuggestion> currentRegionSuggestions=selectRegion(failureIndex);
@@ -82,8 +77,7 @@
         return bwSkips;
     }
     
-    public ArrayList<StructureSkipSuggestion> getSibblingForwardSuggestions(int failureIndex)
-    throws IOException {
+    public ArrayList<StructureSkipSuggestion> getSibblingForwardSuggestions(int failureIndex) {
         ArrayList<StructureSkipSuggestion> fwSkips=new ArrayList<StructureSkipSuggestion>();
         ArrayList<StructureSkipSuggestion> nextSiblings=getCurrentAndNextSkipSuggestions(failureIndex);
         ArrayList<StructureSkipSuggestion> prevRegionSuggestions=selectPrevRegion(failureIndex);
@@ -101,8 +95,7 @@
         return fwSkips;
     }
     
-    public ArrayList<StructureSkipSuggestion> getSibblingSurroundingSuggestions(int failureIndex)
-    throws IOException {
+    public ArrayList<StructureSkipSuggestion> getSibblingSurroundingSuggestions(int failureIndex) {
         ArrayList<StructureSkipSuggestion> surroundingSkips=new ArrayList<StructureSkipSuggestion>();
         ArrayList<StructureSkipSuggestion> priorSiblings=getPriorRegions(failureIndex);
         ArrayList<StructureSkipSuggestion> nextSiblings=getCurrentAndNextSkipSuggestions(failureIndex);
@@ -136,7 +129,7 @@
         return surroundingSkips;
     }
 
-    public ArrayList<StructureSkipSuggestion> getParentSkipSuggestions(int failureIndex) throws IOException{
+    public ArrayList<StructureSkipSuggestion> getParentSkipSuggestions(int failureIndex) {
         ArrayList<StructureSkipSuggestion> parentSkips = new ArrayList<StructureSkipSuggestion>();
         int errorLineIndex=failureIndex;
         int maxBW=Math.max(failureIndex-MAX_NR_OF_LINES, 0);
@@ -160,14 +153,14 @@
         return parentSkips;
     }
 
-    public StructureSkipSuggestion getErroneousPrefix(int failureIndex) throws IOException {
+    public StructureSkipSuggestion getErroneousPrefix(int failureIndex) {
         StructureSkipSuggestion prefix=new StructureSkipSuggestion();
         if(getHistory().getIndexLastLine()>=0)
             prefix.setSkipLocations(IndentInfo.cloneIndentInfo(getHistory().getLine(0)), IndentInfo.cloneIndentInfo(getHistory().getLine(failureIndex)), 0, failureIndex);
         return prefix;
     }
 
-    public ArrayList<StructureSkipSuggestion> getZoomOnPreviousSuggestions(StructureSkipSuggestion prevRegion) throws IOException{
+    public ArrayList<StructureSkipSuggestion> getZoomOnPreviousSuggestions(StructureSkipSuggestion prevRegion) {
         ArrayList<StructureSkipSuggestion> result = new ArrayList<StructureSkipSuggestion>();
         if(!prevRegion.canBeDecomposed()){
             return result;
@@ -212,7 +205,7 @@
         return result;
     } 
 
-    private ArrayList<StructureSkipSuggestion> selectRegion(int indexLine) throws IOException {           
+    private ArrayList<StructureSkipSuggestion> selectRegion(int indexLine) {           
         if (isScopeClosingLine(indexLine))
             return new ArrayList<StructureSkipSuggestion>();        
         ArrayList<Integer> endLocations=findCurrentEnd(indexLine);
@@ -235,8 +228,7 @@
         return skipSuggestions;
     }
 
-    private ArrayList<StructureSkipSuggestion> selectPrevRegion(int indexEnd)
-    throws IOException {
+    private ArrayList<StructureSkipSuggestion> selectPrevRegion(int indexEnd) {
         ArrayList<StructureSkipSuggestion> prevRegions=new ArrayList<StructureSkipSuggestion>();       
         boolean onClosing=isScopeClosingLine(indexEnd);
         int indexStart = findPreviousBegin(indexEnd, onClosing);
@@ -262,8 +254,8 @@
     }
 
     private void addSeperatorIncludingRegion_Backwards(
-            ArrayList<StructureSkipSuggestion> prevRegions, 
-            StructureSkipSuggestion previousRegion) throws IOException {
+    		ArrayList<StructureSkipSuggestion> prevRegions, 
+            StructureSkipSuggestion previousRegion) {
         int indexStart=previousRegion.getIndexHistoryStart();
         if(indexStart>0 && isSeparatorEndingLine(indexStart-1)){
             char[] toParse = structTokens.removeSeparatorAtTheEnd(readLine(indexStart-1));
@@ -278,7 +270,7 @@
 
     private void addSeparatorIncludingRegion_Forwards(
             ArrayList<StructureSkipSuggestion> regions,
-            StructureSkipSuggestion aRegion) throws IOException {
+            StructureSkipSuggestion aRegion) {
         if(isSeparatorStartingLine(aRegion.getIndexHistoryEnd())){
             IndentInfo startSkip=IndentInfo.cloneIndentInfo(aRegion.getStartSkip());
             IndentInfo endSkip=IndentInfo.cloneIndentInfo(aRegion.getEndSkip());
@@ -290,8 +282,7 @@
         }
     }
 
-    private ArrayList<StructureSkipSuggestion> getPriorRegions(int pos)
-    throws IOException {
+    private ArrayList<StructureSkipSuggestion> getPriorRegions(int pos) {
         ArrayList<StructureSkipSuggestion> priorRegions= new ArrayList<StructureSkipSuggestion>();
         ArrayList<StructureSkipSuggestion> prevRegions=selectPrevRegion(pos);
         int bwMax=Math.max(pos-MAX_NR_OF_LINES, 0);
@@ -306,8 +297,7 @@
         return priorRegions;
     }
 
-    private ArrayList<StructureSkipSuggestion> getCurrentAndNextSkipSuggestions(int failureIndex)
-    throws IOException {
+    private ArrayList<StructureSkipSuggestion> getCurrentAndNextSkipSuggestions(int failureIndex) {
         ArrayList<StructureSkipSuggestion> nextRegions= new ArrayList<StructureSkipSuggestion>();
         ArrayList<StructureSkipSuggestion> currRegions=selectRegion(failureIndex);
         int fwMax=failureIndex+MAX_NR_OF_LINES;
@@ -336,7 +326,7 @@
         return nextRegions;
     }
     
-    private ArrayList<Integer> findCurrentEnd(int indexStartLine) throws IOException{
+    private ArrayList<Integer> findCurrentEnd(int indexStartLine) {
         int indentStartLine=separatorIndent(indexStartLine);        
         boolean hasIndentChilds=false;
         boolean isSecondLine=true;
@@ -375,7 +365,7 @@
         return endLocations;
     }
     
-    private int findPreviousBegin(int indexLine, boolean onClosing) throws IOException { 
+    private int findPreviousBegin(int indexLine, boolean onClosing) { 
         int indentValue = getHistory().getLine(indexLine).getIndentValue();
         boolean sawChilds=false;
         boolean closingSeen=onClosing;
@@ -414,7 +404,7 @@
         return 0;
     }  
     
-    private int findParentBegin(int startLineIndex) throws IOException{
+    private int findParentBegin(int startLineIndex) {
         int indentStartLine=separatorIndent(startLineIndex); 
         int indexHistoryLines=startLineIndex;
         while(indexHistoryLines > 0){
@@ -435,33 +425,33 @@
         return 0; //SOF
     }
 
-    private int separatorIndent(int indexLine) throws IOException {
+    private int separatorIndent(int indexLine) {
         int indentValue = getHistory().getLine(indexLine).getIndentValue();
         String lineContent = readLine(indexLine);
         return indentValue+structTokens.separatorIndent(lineContent);
     }
 
-    private boolean isScopeOpeningLine(int index) throws IOException {
+    private boolean isScopeOpeningLine(int index) {
         String lineContent = readLine(index);
         return structTokens.isScopeOpeningLine(lineContent);
     }
 
-    private boolean isScopeClosingLine(int index) throws IOException {
+    private boolean isScopeClosingLine(int index) {
         String lineContent = readLine(index);
         return structTokens.isScopeClosingLine(lineContent);
     }
 
-    private boolean isSeparatorStartingLine(int index) throws IOException {
+    private boolean isSeparatorStartingLine(int index) {
         String lineContent = readLine(index);
         return structTokens.isSeparatorStartedLine(lineContent);
     }
 
-    private boolean isSeparatorEndingLine(int index) throws IOException {
+    private boolean isSeparatorEndingLine(int index) {
         String lineContent = readLine(index);
         return structTokens.isSeparatorEndingLine(lineContent);
     }
 
-    private String readLine(int index) throws IOException {
+    private String readLine(int index) {
         while(getHistory().getIndexLastLine()<=index && myParser.currentToken!=SGLR.EOF)
             getHistory().readRecoverToken(myParser, false);
         if(index<=getHistory().getIndexLastLine()){
@@ -486,7 +476,7 @@
         return indentShift.SAME_INDENT;
     }
 
-    private int skipLine(int indexLine) throws IOException {
+    private int skipLine(int indexLine) {
         IndentInfo line =getHistory().getLine(indexLine);
         IndentationHandler skipIndentHandler=new IndentationHandler();
         getHistory().setTokenIndex(Math.max(0, line.getTokensSeen()-1));        
@@ -510,8 +500,7 @@
         return mergedSkip;
     }
 
-    public ArrayList<StructureSkipSuggestion> getBlockSuggestions(
-            int structStartIndex) throws IOException {
+    public ArrayList<StructureSkipSuggestion> getBlockSuggestions(int structStartIndex)  {
         ArrayList<StructureSkipSuggestion> result=getCurrentRegionSkips(structStartIndex);
         int endIndex=Math.min(getHistory().getIndexLastLine()+1, structStartIndex + MAX_NR_OF_LINES);
         for (int i = structStartIndex; i < endIndex; i++) {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java	Thu Dec 16 14:59:08 2010	(r21515)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -208,19 +208,35 @@
     @SuppressWarnings("rawtypes")
     private boolean isInjection(ATermAppl prod) {
 
-        List r = prod.match(injection1Appl);
-        if (r != null && r.size() >= 1) {
-            ATerm x = (ATerm) r.get(0);
-            return x.match(litStringAppl) == null;
-        }
-
-        r = prod.match(injection2Appl);
-        if (r != null && r.size() >= 1) {
-            ATerm x = (ATerm) r.get(0);
-            return x.match("lit(<str>)") == null;
-        }
-
-        return false;
+//        injection1Appl = factory.parse("prod([<term>],cf(<term>),<term>)");
+//        injection2Appl = factory.parse("prod([<term>],lex(sort(<str>)),<term>)");
+//        litStringAppl = factory.parse("lit(<str>)");
+
+        if(!prod.getAFun().getName().equals("prod"))
+        	return false;
+        
+        
+        if(prod.getChildAt(1).getType() != ATerm.APPL)
+        	return false;
+        
+        final String nm = ((ATermAppl)prod.getChildAt(1)).getName();
+        
+        if(!(nm.equals("cf") || nm.equals("lex")))
+        	return false;
+
+        if(prod.getChildAt(0).getType() != ATerm.LIST)
+        	return false;
+
+        ATermList ls = ((ATermList)prod.getChildAt(0));
+
+        if(ls.getChildCount() < 1)
+        	return false;
+        
+        if(ls.getChildAt(0).getType() != ATerm.APPL)
+        	return false;
+        
+        final AFun fun = ((ATermAppl)ls.getChildAt(0)).getAFun();
+        return fun.getName().equals("lit") && fun.getArity() == 1;
     }
 
     private ProductionAttributes parseProductionAttributes(ATermAppl attr)
@@ -382,7 +398,7 @@
             // FIXME: multiple lookahead are not fully supported or tested
             //        (and should work for both 2.4 and 2.6 tables)
 
-            if (Term.termAt(l, 1) == null) {
+            if (n.getChildCount() > 0 && Term.termAt(l, 1) == null) {
                 // This handles restrictions like:
                 //   LAYOUT? -/- [\/].[\/]
                 // where there is no other restriction that starts with a [\/]

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParserHistory.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParserHistory.java	Thu Dec 16 14:59:08 2010	(r21515)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParserHistory.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -1,9 +1,7 @@
 package org.spoofax.jsglr.client;
 
-import java.io.IOException;
 import java.util.ArrayList;
 
-
 public class ParserHistory {
     
     private final static int MAX_SIZE_NEW_LINE_POINTS = 150;
@@ -50,7 +48,7 @@
     /*
      * Set current token of parser based on recover tokens or read from new tokens
      */
-    public void readRecoverToken(SGLR myParser, boolean keepRecoveredLines) throws IOException{  
+    public void readRecoverToken(SGLR myParser, boolean keepRecoveredLines) {  
         if (hasFinishedRecoverTokens()) {             
             if(myParser.currentToken!=SGLR.EOF){                
                 if(getIndexLastToken()>=0 && recoverTokenStream[getIndexLastToken()]!=SGLR.EOF){

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/PushbackStringIterator.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/PushbackStringIterator.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -0,0 +1,27 @@
+package org.spoofax.jsglr.client;
+
+public class PushbackStringIterator {
+
+	private final String data;
+	private int position;
+
+	public PushbackStringIterator(String data) {
+		this.data = data;
+		position = 0;
+		
+	}
+	
+	public int read() {
+		if(position >= data.length())
+			return -1;
+		return data.charAt(position++);
+	}
+	
+	public void unread(int c) {
+		position--;
+	}
+
+	public int getOffset() {
+		return position;
+	}
+}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/RecoveryConnector.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/RecoveryConnector.java	Thu Dec 16 14:59:08 2010	(r21515)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/RecoveryConnector.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -1,10 +1,6 @@
 package org.spoofax.jsglr.client;
 
-import java.io.IOException;
-import java.util.HashMap;
-import java.util.Map;
-
-import org.spoofax.ArrayDeque;
+import org.spoofax.jsglr.shared.ArrayDeque;
 import org.spoofax.jsglr.shared.BadTokenException;
 import org.spoofax.jsglr.shared.SGLRException;
 import org.spoofax.jsglr.shared.TokenExpectedException;
@@ -38,43 +34,20 @@
             useBridgeParser=false;
         
     }    
-    
-    
-    private Map<Integer, char[]> getBPSuggestions(){
-        Map<Integer, char[]> bpSuggestions = getBridges();
-        int startPos = skipRecovery.getStartPositionErrorFragment_InclLeftMargin();
-        
-        Map<Integer, char[]> bpSuggestAbsolute = new HashMap<Integer, char[]>();
-        for (Integer aKey : bpSuggestions.keySet()) {
-            Integer newKey=new Integer(startPos+aKey.intValue());
-            char[] newValue=bpSuggestions.get(aKey);
-            bpSuggestAbsolute.put(newKey, newValue);
-        }
-        return bpSuggestAbsolute;
-    }
 
-    private Map<Integer, char[]> getBridges() {
-        if (bpResult != null) {
-            return bpResult.getSuggestions();
-        }
-        return new HashMap<Integer, char[]>();
-    }
-    
-    
-    
     private ParserHistory getHistory() {
         return mySGLR.getHistory();
     }
     
-    public void recover() throws IOException{
-        long startSkip=System.currentTimeMillis();
+    public void recover() {
+        //long startSkip=System.currentTimeMillis();
         //System.err.print("***************** Recover");
         doRecoverSteps();
-        long durationSkip=System.currentTimeMillis()-startSkip;
+        //long durationSkip=System.currentTimeMillis()-startSkip;
         //System.err.print(" Recovertime: "+durationSkip);
     }
 
-    private void doRecoverSteps() throws IOException {
+    private void doRecoverSteps() {
         active=true;
         boolean skipSucceeded = skipRecovery.selectErroneousFragment(); //decides whether whitespace parse makes sense
         mySGLR.acceptingStack=null;
@@ -198,14 +171,14 @@
         return hasSucceeded;
     }
 
-    private void whiteSpaceParse() throws IOException {
+    private void whiteSpaceParse() {
         String errorFragment=skipRecovery.getErrorFragment();
         mySGLR.activeStacks.addAll(skipRecovery.getStartLineErrorFragment().getStackNodes());            
         tryParsing(errorFragment, true);
         parseRemainingTokens(true);
     }
 
-    private void tryFineGrainedRepair() throws IOException {
+    private void tryFineGrainedRepair() {
         FineGrainedOnRegion fgRepair=new FineGrainedOnRegion(mySGLR);        
         fgRepair.setRegionInfo(skipRecovery.getErroneousRegion(), skipRecovery.getAcceptPosition());
         fgRepair.recover();
@@ -220,7 +193,7 @@
         fineGrained.findRecoverBranch(skipRecovery.getSkippedLines(), skipRecovery.getEndPositionErrorFragment());        
     }*/
 
-    private boolean tryBridgeRepair(String errorFragment) throws IOException {
+    private boolean tryBridgeRepair(String errorFragment) {
         String repairedFragment = repairBridges(errorFragment);
         mySGLR.activeStacks.addAll(skipRecovery.getStartLineErrorFragment().getStackNodes());   
         tryParsing(repairedFragment, false);      
@@ -239,15 +212,13 @@
             e.printStackTrace();
         } catch (SGLRException e) {
             e.printStackTrace();
-        } catch (IOException e) {
-            e.printStackTrace();
         } catch (Exception e) {
             e.printStackTrace();
         }
         return "/*" + errorFragment + "*/";
     }
     
-    private void tryParsing(String fragment, boolean asLayout) throws IOException{
+    private void tryParsing(String fragment, boolean asLayout) {
         // Skip any leading whitespace, since we already parsed up to that point
         int indexFragment = findFirstNonLayoutToken(fragment);      
         //System.out.println("&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&");
@@ -264,7 +235,7 @@
         }       
     }
     
-    public boolean parseErrorFragmentAsWhiteSpace(boolean keepLines) throws IOException{
+    public boolean parseErrorFragmentAsWhiteSpace(boolean keepLines) {
         //System.out.println("---------- Start WhiteSpace Parsing ----------");
         mySGLR.activeStacks.clear();
         mySGLR.activeStacks.addAll(skipRecovery.getStartLineErrorFragment().getStackNodes());
@@ -278,7 +249,7 @@
         return recoverySucceeded();
     }
     
-    public boolean parseRemainingTokens(boolean keepHistory) throws IOException{
+    public boolean parseRemainingTokens(boolean keepHistory) {
         //System.out.println("------------- REMAINING CHARACTERS --------------- ");
         getHistory().setTokenIndex(skipRecovery.getEndPositionErrorFragment());        
         while(!getHistory().hasFinishedRecoverTokens() && mySGLR.activeStacks.size()>0 && mySGLR.acceptingStack==null){        
@@ -291,7 +262,7 @@
 
     
     
-    private void parseAsLayout() throws IOException {
+    private void parseAsLayout() {
         if(isLayoutCharacter((char)mySGLR.currentToken) || mySGLR.currentToken==SGLR.EOF)
             mySGLR.doParseStep();
         else{

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/RegionRecovery.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/RegionRecovery.java	Thu Dec 16 14:59:08 2010	(r21515)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/RegionRecovery.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -1,7 +1,6 @@
 //TODO: samenwerking met recovery connector eenduidiger
 package org.spoofax.jsglr.client;
 
-import java.io.IOException;
 import java.util.ArrayList;
 
 
@@ -78,7 +77,7 @@
     /**
      * Selects erroneous region based on layout 
      */
-    public boolean selectErroneousFragment() throws IOException { 
+    public boolean selectErroneousFragment() { 
         boolean eofReached=myParser.currentToken==SGLR.EOF;
         acceptPosition=-1;
         NewStructureSkipper newRegionSelector=new NewStructureSkipper(myParser);
@@ -158,7 +157,7 @@
         return true; 
     }
 
-    private boolean trySetErroneousRegion(ArrayList<StructureSkipSuggestion> regions) throws IOException {
+    private boolean trySetErroneousRegion(ArrayList<StructureSkipSuggestion> regions) {
         StructureSkipSuggestion aSkip=new StructureSkipSuggestion();
         int indexSkips=0;
         myParser.acceptingStack=null; 
@@ -176,7 +175,7 @@
         return hasFoundErroneousRegion;
     }
 
-    private boolean testRegion(StructureSkipSuggestion aSkip) throws IOException {
+    private boolean testRegion(StructureSkipSuggestion aSkip) {
         //System.out.println("%%%%%%%%%%% TEST REGION %%%%%%%%%%%");
         //System.out.println(getInputFragment(aSkip));
         //System.out.printlnBlock(getInputFragment(aSkip));           
@@ -207,7 +206,7 @@
     }
 
     private void parseAdditionalTokens(
-            StructureSkipSuggestion aSkip) throws IOException {
+            StructureSkipSuggestion aSkip) {
         for (char aChar : aSkip.getAdditionalTokens()) {
             myParser.currentToken=aChar;           
             myParser.doParseStep();

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 14:59:08 2010	(r21515)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -6,21 +6,15 @@
  * Licensed under the GNU Lesser General Public License, v2.1
  */
 package org.spoofax.jsglr.client;
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.PushbackInputStream;
+
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Queue;
 import java.util.Set;
-import java.util.Timer;
-import java.util.TimerTask;
-import java.util.concurrent.CancellationException;
 
-import org.spoofax.ArrayDeque;
+import org.spoofax.jsglr.shared.ArrayDeque;
 import org.spoofax.jsglr.shared.BadTokenException;
 import org.spoofax.jsglr.shared.SGLRException;
 import org.spoofax.jsglr.shared.TokenExpectedException;
@@ -36,18 +30,12 @@
 
     static final int TAB_SIZE = 4;//8;
 
-    private static final Timer abortTimer = new Timer(true);
-
-    private int abortTimerJobId;
-
     protected static boolean WORK_AROUND_MULTIPLE_LOOKAHEAD;
 
     //Performance testing
     private static long parseTime=0;
     private static int parseCount=0;
 
-    private int timeout;
-
     public Frame startFrame;
 
     private long startTime;
@@ -94,12 +82,12 @@
 
     private int reductionCount;
 
-    private PushbackInputStream currentInputStream;
+    private PushbackStringIterator currentInputStream;
 
     //Creates indent- and dedent- tokens
     //Meant for parsing of indentation based languages
     //TODO: still under construction
-    private IndentTokenizer indentTokenHandler;
+//    private IndentTokenizer indentTokenHandler;
 
     // ------------------------------------- Integrated recovery  ------------------------
   //Keeps track of the indentation for each line
@@ -142,7 +130,7 @@
     }
 
     //-------------------------- fine-grained recovery ----------------------------------
-    private RecoverDisambiguator recoverDisambiguator;
+    //private RecoverDisambiguator recoverDisambiguator;
 
     SGLR() {
         basicInit(null);
@@ -208,7 +196,7 @@
         useIntegratedRecovery = false;
         recoverIntegrator = null;
         history=new ParserHistory();
-        recoverDisambiguator=new RecoverDisambiguator(this.parseTable);
+        //recoverDisambiguator=new RecoverDisambiguator(this.parseTable);
     }
 
     public static boolean isDebugging() {
@@ -233,68 +221,22 @@
         return st0;
     }
 
-    public final ATerm parse(InputStream fis)  throws IOException, SGLRException {
-        return parse(fis, null);
-    }
-
-    public ATerm parse(InputStream fis, String startSymbol) throws IOException,
-            BadTokenException, TokenExpectedException, ParseException,
+    public ATerm parse(String fis, String startSymbol) throws BadTokenException, TokenExpectedException, ParseException,
             SGLRException {
         logBeforeParsing();
         initParseVariables(fis);
         startTime = System.currentTimeMillis();
-        initParseTimer();
         return sglrParse(startSymbol);
     }
 
-    public final ATerm parse(String input) throws IOException, BadTokenException,
+    public final ATerm parse(String input) throws BadTokenException,
             TokenExpectedException, ParseException, SGLRException {
 
         return parse(input, null);
     }
 
-    public ATerm parse(String input, String startSymbol) throws IOException, BadTokenException, TokenExpectedException, ParseException,
-        SGLRException {
-
-        return parse(new ByteArrayInputStream(input.getBytes("ISO-8859-1")), startSymbol);
-    }
-
-    private void initParseTimer() {
-        if (timeout > 0) {
-            // We use a single shared timer to conserve native threads
-            // and a jobId to recognize stale abort events
-            synchronized (abortTimer) {
-                asyncAborted = false;
-                ++abortTimerJobId;
-            }
-            final int jobId = abortTimerJobId;
-            abortTimer.schedule(new TimerTask() {
-                @Override
-                public void run() {
-                    synchronized (abortTimer) {
-                        if (abortTimerJobId == jobId)
-                            asyncAbort();
-                    }
-                }
-            }, timeout
-            );
-        } else {
-            asyncAborted = false;
-        }
-    }
-
-    /**
-     * Sets the maximum amount of time to try and parse a file,
-     * before a {@link ParseTimeoutException} is thrown.
-     *
-     * @param timeout  The maximum time to parse, in milliseconds.
-     */
-    public void setTimeout(int timeout) {
-        this.timeout = timeout;
-    }
-
     private ATerm sglrParse(String startSymbol)
-            throws IOException, BadTokenException, TokenExpectedException,
+            throws BadTokenException, TokenExpectedException,
             ParseException, SGLRException {
 
         try {
@@ -323,7 +265,7 @@
                     return sglrParse(startSymbol);
             }*/
 
-        } catch (CancellationException e) {
+        } catch (TaskCancellationException e) {
             throw new ParseTimeoutException(this, currentToken, tokensSeen - 1, lineNumber,
                     columnNumber, collectedErrors);
         }
@@ -342,22 +284,22 @@
         return disambiguator.applyFilters(this, s.label, startSymbol, tokensSeen);
     }
 
-    void readNextToken() throws IOException {
+    void readNextToken() {
         logCurrentToken();
         currentToken = getNextToken();
     }
 
-    public void doParseStep() throws IOException {
+    public void doParseStep() {
         parseCharacter(); //applies reductions on active stack structure and fills forshifter
         shifter(); //renewes active stacks with states in forshifter
     }
 
-    private void initParseVariables(InputStream fis) {
+    private void initParseVariables(String input) {
         startFrame = initActiveStacks();
         tokensSeen = 0;
         columnNumber = 0;
         lineNumber = 1;
-        currentInputStream = new PushbackInputStream(fis, 1024);
+        currentInputStream = new PushbackStringIterator(input);
         acceptingStack = null;
         //history.keepInitialState(this);
         collectedErrors.clear();
@@ -430,7 +372,7 @@
         activeStacks.addFirst(st1);
     }
 
-    private void parseCharacter() throws IOException {
+    private void parseCharacter() {
         logBeforeParseCharacter();
 
         ArrayDeque<Frame> actives = new ArrayDeque<Frame>(activeStacks); // FIXME avoid garbage
@@ -474,7 +416,7 @@
         return st;
     }
 
-    private void actor(Frame st) throws IOException {
+    private void actor(Frame st) {
         State s = st.peek();
         logBeforeActor(st, s);
         for (Action action : s.getActions()) {
@@ -525,11 +467,11 @@
         }
     }
 
-    private boolean checkLookahead(ReduceLookahead red) throws IOException {
+    private boolean checkLookahead(ReduceLookahead red) {
         return doCheckLookahead(red, red.getCharRanges(), 0);
     }
 
-    private boolean doCheckLookahead(ReduceLookahead red, RangeList[] charClass, int pos) throws IOException {
+    private boolean doCheckLookahead(ReduceLookahead red, RangeList[] charClass, int pos) {
         if(Tools.tracing) {
             TRACE("SG_CheckLookAhead() - ");
         }
@@ -566,7 +508,7 @@
         }
     }
 
-    private void doReductions(Frame st, Production prod) throws IOException {
+    private void doReductions(Frame st, Production prod) {
         if(recoverModeOk(st, prod)){
             List<Path> paths = st.findAllPaths(prod.arity);
             logBeforeDoReductions(st, prod, paths.size());
@@ -590,7 +532,7 @@
         return !useIntegratedRecovery || prod.isRecoverProduction() == reduceRecoverOnly;
     }*/
 
-    private void doLimitedReductions(Frame st, Production prod, Link l) throws IOException { //Todo: Look add sharing code with doReductions
+    private void doLimitedReductions(Frame st, Production prod, Link l) { //Todo: Look add sharing code with doReductions
         if(recoverModeOk(st, prod)){
             List<Path> paths = st.findLimitedPaths(prod.arity, l); //find paths containing the link
             logBeforeLimitedReductions(st, prod, l, paths);
@@ -598,8 +540,7 @@
         }
     }
 
-    private void reduceAllPaths(Production prod, List<Path> paths)
-            throws IOException {
+    private void reduceAllPaths(Production prod, List<Path> paths) {
 
         for (int i = paths.size() - 1; i >= 0; i--) {
             Path path = paths.get(i);
@@ -613,7 +554,7 @@
 
         if (asyncAborted) {
             // Rethrown as ParseTimeoutException in SGLR.sglrParse()
-            throw new CancellationException("Long-running parse job aborted");
+            throw new TaskCancellationException("Long-running parse job aborted");
         }
     }
 
@@ -625,7 +566,7 @@
         paths.clear();
     }
 
-    private void reducer(Frame st0, State s, Production prod, List<IParseNode> kids, Path path) throws IOException {
+    private void reducer(Frame st0, State s, Production prod, List<IParseNode> kids, Path path) {
         int length = path.getLength();
         int numberOfRecoveries = calcRecoverCount(prod, path);
         IParseNode t = prod.apply(kids);
@@ -740,7 +681,7 @@
         }
     }
 
-    private void actorOnActiveStacksOverNewLink(Link nl) throws IOException {
+    private void actorOnActiveStacksOverNewLink(Link nl) {
         // Note: ActiveStacks can be modified inside doLimitedReductions
         // new elements may be inserted at the beginning
         final int sz = activeStacks.size();
@@ -837,7 +778,7 @@
     }
 
 
-    private int getNextToken() throws IOException {
+    private int getNextToken() {
         if(Tools.tracing) {
             TRACE("SG_NextToken() - ");
         }
@@ -1276,60 +1217,4 @@
                         nl.getLength());
         }
     }
-    //-------------------------------------------------- mj: debug and recovery ------------------------
-
-    //Used for debugging
-    private String mjInfo() {
-        String result = "";
-        result += "CURR TOKEN: " + (char)currentToken;
-        result += " ACTIVESTACKS: ";
-        for (Frame f : activeStacks) {
-            result += f.state.stateNumber;
-            if(f.minAvoidValue() > 0)
-                result += "$"+f.minAvoidValue() + "$";
-            result += "; ";
-        }
-        result += " FORACTOR: ";
-        for (Frame f : forActor) {
-            result += f.state.stateNumber;
-            result += "; ";
-        }
-        result += " FORACTOR_DELAYED: ";
-        for (Frame f : forActorDelayed) {
-            result += f.state.stateNumber;
-            result += "; ";
-        }
-        result += " FORSHIFTER: ";
-        for (ActionState as : forShifter) {
-            result += "{ ";
-            result += as.st.state.stateNumber;
-            result+=",";
-            result += as.s.stateNumber;
-            result += "} ; ";
-        }
-        return result;
-    }
-
-    private String[] viewStackObject(boolean avoidFiltered){
-        List<String> stackPaths = new ArrayList<String>();
-        for (Frame actNode : activeStacks) {
-            List<String> testMJ = actNode.getStackPaths("", avoidFiltered);
-            stackPaths.addAll(testMJ);
-        }
-        return stackPaths.toArray(new String[stackPaths.size()]);
-    }
-
-    private String[] viewStackObject()
-    {
-        return viewStackObject(false);
-    }
-
-    private String[] viewFilteredStackObject()
-    {
-        return viewStackObject(true);
-    }
-
-    private void mjTesting() {
-        Tools.debug((char)currentToken);
-    }
 }

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/TaskCancellationException.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/TaskCancellationException.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -0,0 +1,11 @@
+package org.spoofax.jsglr.client;
+
+public class TaskCancellationException extends RuntimeException {
+
+	private static final long serialVersionUID = 1L;
+	
+	public TaskCancellationException(String message) {
+		super(message);
+	}
+
+}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/server/RemoteParseTableServiceImpl.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/server/RemoteParseTableServiceImpl.java	Thu Dec 16 14:59:08 2010	(r21515)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/server/RemoteParseTableServiceImpl.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -1,5 +1,10 @@
 package org.spoofax.jsglr.server;
 
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+
 import org.spoofax.jsglr.shared.RemoteParseTableService;
 import org.spoofax.jsglr.shared.terms.ATerm;
 import org.spoofax.jsglr.shared.terms.ATermFactory;
@@ -9,7 +14,36 @@
 @SuppressWarnings("serial")
 public class RemoteParseTableServiceImpl extends RemoteServiceServlet implements RemoteParseTableService {
 
-	public ATerm findParseTable(String resourceName) {
-		return	new ATermFactory().makeInt(0);
+	public ATerm fetchParseTable(String resourceName) {
+		ATermFactory f = new ATermFactory();
+		try {
+			InputStream is = new FileInputStream(resourceName);
+			System.out.println("Loading into buffer");
+			char[] buffer = new char[12*1024*1024]; // FIXME 12 MBs should be enough for everyone
+			for(int i = 0; i < buffer.length; i++) {
+				int ch = is.read();
+				if(ch == -1)
+					break;
+				buffer[i] = (char)ch;
+			}
+			System.out.println("Loading from buffer");
+			ATerm e = f.parse(new String(buffer));
+			System.out.println("Loaded term, serializing");
+			return e;
+		} catch(FileNotFoundException e) {
+		} catch(IOException e) {
+		}
+		System.err.println("Failed to load parse table " + resourceName);
+		return null;
+	}
+
+	@Override
+	public ATerm readTermFromFile(String string) {
+		return new ATermFactory().makeInt(0);
+	}
+
+	@Override
+	public String fetchText(String string) {
+		return "abc";
 	}
 }

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/ArrayDeque.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/ArrayDeque.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -0,0 +1,812 @@
+/*
+ * Written by Josh Bloch of Google Inc. and released to the public domain,
+ * as explained at http://creativecommons.org/licenses/publicdomain.
+ */
+
+package org.spoofax.jsglr.shared;
+
+import java.io.Serializable;
+import java.util.AbstractCollection;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.ConcurrentModificationException;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.NoSuchElementException;
+import java.util.Queue;
+import java.util.Stack;
+
+
+/**
+ * Resizable-array implementation of the Java 1.6 Deque interface.  Array
+ * deques have no capacity restrictions; they grow as necessary to support
+ * usage.  They are not thread-safe; in the absence of external
+ * synchronization, they do not support concurrent access by multiple threads.
+ * Null elements are prohibited.  This class is likely to be faster than
+ * {@link Stack} when used as a stack, and faster than {@link LinkedList}
+ * when used as a queue.
+ *
+ * <p>Most <tt>ArrayDeque</tt> operations run in amortized constant time.
+ * Exceptions include {@link #remove(Object) remove}, {@link
+ * #removeFirstOccurrence removeFirstOccurrence}, {@link #removeLastOccurrence
+ * removeLastOccurrence}, {@link #contains contains}, {@link #iterator
+ * iterator.remove()}, and the bulk operations, all of which run in linear
+ * time.
+ *
+ * <p>The iterators returned by this class's <tt>iterator</tt> method are
+ * <i>fail-fast</i>: If the deque is modified at any time after the iterator
+ * is created, in any way except through the iterator's own <tt>remove</tt>
+ * method, the iterator will generally throw a {@link
+ * ConcurrentModificationException}.  Thus, in the face of concurrent
+ * modification, the iterator fails quickly and cleanly, rather than risking
+ * arbitrary, non-deterministic behavior at an undetermined time in the
+ * future.
+ *
+ * <p>Note that the fail-fast behavior of an iterator cannot be guaranteed
+ * as it is, generally speaking, impossible to make any hard guarantees in the
+ * presence of unsynchronized concurrent modification.  Fail-fast iterators
+ * throw <tt>ConcurrentModificationException</tt> on a best-effort basis.
+ * Therefore, it would be wrong to write a program that depended on this
+ * exception for its correctness: <i>the fail-fast behavior of iterators
+ * should be used only to detect bugs.</i>
+ *
+ * <p>This class and its iterator implement all of the
+ * <em>optional</em> methods of the {@link Collection} and {@link
+ * Iterator} interfaces.
+ *
+ * <p>This class is a member of the
+ * <a href="{@docRoot}/../technotes/guides/collections/index.html">
+ * Java Collections Framework</a>.
+ *
+ * @author  Josh Bloch and Doug Lea
+ * @author  Lennart Kats (adapted for Java 1.5; added get() method)
+ * @since   1.6
+ * @param <E> the type of elements held in this collection
+ */
+ at SuppressWarnings("unchecked")
+public class ArrayDeque<E> extends AbstractCollection<E>
+                           implements /*Deque<E>,*/ Queue<E>, Serializable
+{
+    /**
+     * The array in which the elements of the deque are stored.
+     * The capacity of the deque is the length of this array, which is
+     * always a power of two. The array is never allowed to become
+     * full, except transiently within an addX method where it is
+     * resized (see doubleCapacity) immediately upon becoming full,
+     * thus avoiding head and tail wrapping around to equal each
+     * other.  We also guarantee that all array cells not holding
+     * deque elements are always null.
+     */
+    private transient E[] elements;
+
+    /**
+     * The index of the element at the head of the deque (which is the
+     * element that would be removed by remove() or pop()); or an
+     * arbitrary number equal to tail if the deque is empty.
+     */
+    private transient int head;
+
+    /**
+     * The index at which the next element would be added to the tail
+     * of the deque (via addLast(E), add(E), or push(E)).
+     */
+    private transient int tail;
+
+    /**
+     * The minimum capacity that we'll use for a newly created deque.
+     * Must be a power of 2.
+     */
+    private static final int MIN_INITIAL_CAPACITY = 8;
+
+    // ******  Array allocation and resizing utilities ******
+
+    /**
+     * Allocate empty array to hold the given number of elements.
+     *
+     * @param numElements  the number of elements to hold
+     */
+    private void allocateElements(int numElements) {
+        int initialCapacity = MIN_INITIAL_CAPACITY;
+        // Find the best power of two to hold elements.
+        // Tests "<=" because arrays aren't kept full.
+        if (numElements >= initialCapacity) {
+            initialCapacity = numElements;
+            initialCapacity |= (initialCapacity >>>  1);
+            initialCapacity |= (initialCapacity >>>  2);
+            initialCapacity |= (initialCapacity >>>  4);
+            initialCapacity |= (initialCapacity >>>  8);
+            initialCapacity |= (initialCapacity >>> 16);
+            initialCapacity++;
+
+            if (initialCapacity < 0)   // Too many elements, must back off
+                initialCapacity >>>= 1;// Good luck allocating 2 ^ 30 elements
+        }
+        elements = (E[]) new Object[initialCapacity];
+    }
+
+    /**
+     * Double the capacity of this deque.  Call only when full, i.e.,
+     * when head and tail have wrapped around to become equal.
+     */
+    private void doubleCapacity() {
+        assert head == tail;
+        int p = head;
+        int n = elements.length;
+        int r = n - p; // number of elements to the right of p
+        int newCapacity = n << 1;
+        if (newCapacity < 0)
+            throw new IllegalStateException("Sorry, deque too big");
+        Object[] a = new Object[newCapacity];
+        System.arraycopy(elements, p, a, 0, r);
+        System.arraycopy(elements, 0, a, r, p);
+        elements = (E[])a;
+        head = 0;
+        tail = n;
+    }
+
+    /**
+     * Copies the elements from our element array into the specified array,
+     * in order (from first to last element in the deque).  It is assumed
+     * that the array is large enough to hold all elements in the deque.
+     *
+     * @return its argument
+     */
+    private <T> T[] copyElements(T[] a) {
+        if (head < tail) {
+            System.arraycopy(elements, head, a, 0, size());
+        } else if (head > tail) {
+            int headPortionLen = elements.length - head;
+            System.arraycopy(elements, head, a, 0, headPortionLen);
+            System.arraycopy(elements, 0, a, headPortionLen, tail);
+        }
+        return a;
+    }
+
+    /**
+     * Constructs an empty array deque with an initial capacity
+     * sufficient to hold 16 elements.
+     */
+    public ArrayDeque() {
+        elements = (E[]) new Object[16];
+    }
+
+    /**
+     * Constructs an empty array deque with an initial capacity
+     * sufficient to hold the specified number of elements.
+     *
+     * @param numElements  lower bound on initial capacity of the deque
+     */
+    public ArrayDeque(int numElements) {
+        allocateElements(numElements);
+    }
+
+    /**
+     * Constructs a deque containing the elements of the specified
+     * collection, in the order they are returned by the collection's
+     * iterator.  (The first element returned by the collection's
+     * iterator becomes the first element, or <i>front</i> of the
+     * deque.)
+     *
+     * @param c the collection whose elements are to be placed into the deque
+     * @throws NullPointerException if the specified collection is null
+     */
+    public ArrayDeque(Collection<? extends E> c) {
+        allocateElements(c.size());
+        addAll(c);
+    }
+
+    // The main insertion and extraction methods are addFirst,
+    // addLast, pollFirst, pollLast. The other methods are defined in
+    // terms of these.
+
+    /**
+     * Inserts the specified element at the front of this deque.
+     *
+     * @param e the element to add
+     * @throws NullPointerException if the specified element is null
+     */
+    public void addFirst(E e) {
+        if (e == null)
+            throw new NullPointerException();
+        elements[head = (head - 1) & (elements.length - 1)] = e;
+        if (head == tail)
+            doubleCapacity();
+    }
+
+    /**
+     * Inserts the specified element at the end of this deque.
+     *
+     * <p>This method is equivalent to {@link #add}.
+     *
+     * @param e the element to add
+     * @throws NullPointerException if the specified element is null
+     */
+    public void addLast(E e) {
+        if (e == null)
+            throw new NullPointerException();
+        elements[tail] = e;
+        if ( (tail = (tail + 1) & (elements.length - 1)) == head)
+            doubleCapacity();
+    }
+
+    /**
+     * Inserts the specified element at the front of this deque.
+     *
+     * @param e the element to add
+     * @return <tt>true</tt> (as specified by Deque.offerFirst)
+     * @throws NullPointerException if the specified element is null
+     */
+    public boolean offerFirst(E e) {
+        addFirst(e);
+        return true;
+    }
+
+    /**
+     * Inserts the specified element at the end of this deque.
+     *
+     * @param e the element to add
+     * @return <tt>true</tt> (as specified by Deque.offerLast)
+     * @throws NullPointerException if the specified element is null
+     */
+    public boolean offerLast(E e) {
+        addLast(e);
+        return true;
+    }
+
+    /**
+     * @throws NoSuchElementException {@inheritDoc}
+     */
+    public E removeFirst() {
+        E x = pollFirst();
+        if (x == null)
+            throw new NoSuchElementException();
+        return x;
+    }
+
+    /**
+     * @throws NoSuchElementException {@inheritDoc}
+     */
+    public E removeLast() {
+        E x = pollLast();
+        if (x == null)
+            throw new NoSuchElementException();
+        return x;
+    }
+
+    public E pollFirst() {
+        int h = head;
+        E result = elements[h]; // Element is null if deque empty
+        if (result == null)
+            return null;
+        elements[h] = null;     // Must null out slot
+        head = (h + 1) & (elements.length - 1);
+        return result;
+    }
+
+    public E pollLast() {
+        int t = (tail - 1) & (elements.length - 1);
+        E result = elements[t];
+        if (result == null)
+            return null;
+        elements[t] = null;
+        tail = t;
+        return result;
+    }
+
+    /**
+     * @throws NoSuchElementException {@inheritDoc}
+     */
+    public E getFirst() {
+        E x = elements[head];
+        if (x == null)
+            throw new NoSuchElementException();
+        return x;
+    }
+    
+    public E get(int i) {
+        if (i < 0 || i >= size())
+            throw new NoSuchElementException();
+        return elements[(head + i) & (elements.length - 1)];
+    }
+
+    /**
+     * @throws NoSuchElementException {@inheritDoc}
+     */
+    public E getLast() {
+        E x = elements[(tail - 1) & (elements.length - 1)];
+        if (x == null)
+            throw new NoSuchElementException();
+        return x;
+    }
+
+    public E peekFirst() {
+        return elements[head]; // elements[head] is null if deque empty
+    }
+
+    public E peekLast() {
+        return elements[(tail - 1) & (elements.length - 1)];
+    }
+
+    /**
+     * Removes the first occurrence of the specified element in this
+     * deque (when traversing the deque from head to tail).
+     * If the deque does not contain the element, it is unchanged.
+     * More formally, removes the first element <tt>e</tt> such that
+     * <tt>o.equals(e)</tt> (if such an element exists).
+     * Returns <tt>true</tt> if this deque contained the specified element
+     * (or equivalently, if this deque changed as a result of the call).
+     *
+     * @param o element to be removed from this deque, if present
+     * @return <tt>true</tt> if the deque contained the specified element
+     */
+    public boolean removeFirstOccurrence(Object o) {
+        if (o == null)
+            return false;
+        int mask = elements.length - 1;
+        int i = head;
+        E x;
+        while ( (x = elements[i]) != null) {
+            if (o.equals(x)) {
+                delete(i);
+                return true;
+            }
+            i = (i + 1) & mask;
+        }
+        return false;
+    }
+
+    /**
+     * Removes the last occurrence of the specified element in this
+     * deque (when traversing the deque from head to tail).
+     * If the deque does not contain the element, it is unchanged.
+     * More formally, removes the last element <tt>e</tt> such that
+     * <tt>o.equals(e)</tt> (if such an element exists).
+     * Returns <tt>true</tt> if this deque contained the specified element
+     * (or equivalently, if this deque changed as a result of the call).
+     *
+     * @param o element to be removed from this deque, if present
+     * @return <tt>true</tt> if the deque contained the specified element
+     */
+    public boolean removeLastOccurrence(Object o) {
+        if (o == null)
+            return false;
+        int mask = elements.length - 1;
+        int i = (tail - 1) & mask;
+        E x;
+        while ( (x = elements[i]) != null) {
+            if (o.equals(x)) {
+                delete(i);
+                return true;
+            }
+            i = (i - 1) & mask;
+        }
+        return false;
+    }
+
+    // *** Queue methods ***
+
+    /**
+     * Inserts the specified element at the end of this deque.
+     *
+     * <p>This method is equivalent to {@link #addLast}.
+     *
+     * @param e the element to add
+     * @return <tt>true</tt> (as specified by {@link Collection#add})
+     * @throws NullPointerException if the specified element is null
+     */
+    public boolean add(E e) {
+        addLast(e);
+        return true;
+    }
+
+    /**
+     * Inserts the specified element at the end of this deque.
+     *
+     * <p>This method is equivalent to {@link #offerLast}.
+     *
+     * @param e the element to add
+     * @return <tt>true</tt> (as specified by {@link Queue#offer})
+     * @throws NullPointerException if the specified element is null
+     */
+    public boolean offer(E e) {
+        return offerLast(e);
+    }
+
+    /**
+     * Retrieves and removes the head of the queue represented by this deque.
+     *
+     * This method differs from {@link #poll poll} only in that it throws an
+     * exception if this deque is empty.
+     *
+     * <p>This method is equivalent to {@link #removeFirst}.
+     *
+     * @return the head of the queue represented by this deque
+     * @throws NoSuchElementException {@inheritDoc}
+     */
+    public E remove() {
+        return removeFirst();
+    }
+
+    /**
+     * Retrieves and removes the head of the queue represented by this deque
+     * (in other words, the first element of this deque), or returns
+     * <tt>null</tt> if this deque is empty.
+     *
+     * <p>This method is equivalent to {@link #pollFirst}.
+     *
+     * @return the head of the queue represented by this deque, or
+     *         <tt>null</tt> if this deque is empty
+     */
+    public E poll() {
+        return pollFirst();
+    }
+
+    /**
+     * Retrieves, but does not remove, the head of the queue represented by
+     * this deque.  This method differs from {@link #peek peek} only in
+     * that it throws an exception if this deque is empty.
+     *
+     * <p>This method is equivalent to {@link #getFirst}.
+     *
+     * @return the head of the queue represented by this deque
+     * @throws NoSuchElementException {@inheritDoc}
+     */
+    public E element() {
+        return getFirst();
+    }
+
+    /**
+     * Retrieves, but does not remove, the head of the queue represented by
+     * this deque, or returns <tt>null</tt> if this deque is empty.
+     *
+     * <p>This method is equivalent to {@link #peekFirst}.
+     *
+     * @return the head of the queue represented by this deque, or
+     *         <tt>null</tt> if this deque is empty
+     */
+    public E peek() {
+        return peekFirst();
+    }
+
+    // *** Stack methods ***
+
+    /**
+     * Pushes an element onto the stack represented by this deque.  In other
+     * words, inserts the element at the front of this deque.
+     *
+     * <p>This method is equivalent to {@link #addFirst}.
+     *
+     * @param e the element to push
+     * @throws NullPointerException if the specified element is null
+     */
+    public void push(E e) {
+        addFirst(e);
+    }
+
+    /**
+     * Pops an element from the stack represented by this deque.  In other
+     * words, removes and returns the first element of this deque.
+     *
+     * <p>This method is equivalent to {@link #removeFirst()}.
+     *
+     * @return the element at the front of this deque (which is the top
+     *         of the stack represented by this deque)
+     * @throws NoSuchElementException {@inheritDoc}
+     */
+    public E pop() {
+        return removeFirst();
+    }
+
+    private void checkInvariants() {
+        assert elements[tail] == null;
+        assert head == tail ? elements[head] == null :
+            (elements[head] != null &&
+             elements[(tail - 1) & (elements.length - 1)] != null);
+        assert elements[(head - 1) & (elements.length - 1)] == null;
+    }
+
+    /**
+     * Removes the element at the specified position in the elements array,
+     * adjusting head and tail as necessary.  This can result in motion of
+     * elements backwards or forwards in the array.
+     *
+     * <p>This method is called delete rather than remove to emphasize
+     * that its semantics differ from those of {@link List#remove(int)}.
+     *
+     * @return true if elements moved backwards
+     */
+    private boolean delete(int i) {
+        checkInvariants();
+        final E[] elements = this.elements;
+        final int mask = elements.length - 1;
+        final int h = head;
+        final int t = tail;
+        final int front = (i - h) & mask;
+        final int back  = (t - i) & mask;
+
+        // Invariant: head <= i < tail mod circularity
+        if (front >= ((t - h) & mask))
+            throw new ConcurrentModificationException();
+
+        // Optimize for least element motion
+        if (front < back) {
+            if (h <= i) {
+                System.arraycopy(elements, h, elements, h + 1, front);
+            } else { // Wrap around
+                System.arraycopy(elements, 0, elements, 1, i);
+                elements[0] = elements[mask];
+                System.arraycopy(elements, h, elements, h + 1, mask - h);
+            }
+            elements[h] = null;
+            head = (h + 1) & mask;
+            return false;
+        } else {
+            if (i < t) { // Copy the null tail as well
+                System.arraycopy(elements, i + 1, elements, i, back);
+                tail = t - 1;
+            } else { // Wrap around
+                System.arraycopy(elements, i + 1, elements, i, mask - i);
+                elements[mask] = elements[0];
+                System.arraycopy(elements, 1, elements, 0, t);
+                tail = (t - 1) & mask;
+            }
+            return true;
+        }
+    }
+
+    // *** Collection Methods ***
+
+    /**
+     * Returns the number of elements in this deque.
+     *
+     * @return the number of elements in this deque
+     */
+    public int size() {
+        return (tail - head) & (elements.length - 1);
+    }
+
+    /**
+     * Returns <tt>true</tt> if this deque contains no elements.
+     *
+     * @return <tt>true</tt> if this deque contains no elements
+     */
+    public boolean isEmpty() {
+        return head == tail;
+    }
+
+    /**
+     * Returns an iterator over the elements in this deque.  The elements
+     * will be ordered from first (head) to last (tail).  This is the same
+     * order that elements would be dequeued (via successive calls to
+     * {@link #remove} or popped (via successive calls to {@link #pop}).
+     *
+     * @return an iterator over the elements in this deque
+     */
+    public Iterator<E> iterator() {
+        return new DeqIterator();
+    }
+
+    public Iterator<E> descendingIterator() {
+        return new DescendingIterator();
+    }
+
+    private class DeqIterator implements Iterator<E> {
+        /**
+         * Index of element to be returned by subsequent call to next.
+         */
+        private int cursor = head;
+
+        /**
+         * Tail recorded at construction (also in remove), to stop
+         * iterator and also to check for comodification.
+         */
+        private int fence = tail;
+
+        /**
+         * Index of element returned by most recent call to next.
+         * Reset to -1 if element is deleted by a call to remove.
+         */
+        private int lastRet = -1;
+
+        public boolean hasNext() {
+            return cursor != fence;
+        }
+
+        public E next() {
+            if (cursor == fence)
+                throw new NoSuchElementException();
+            E result = elements[cursor];
+            // This check doesn't catch all possible comodifications,
+            // but does catch the ones that corrupt traversal
+            if (tail != fence || result == null)
+                throw new ConcurrentModificationException();
+            lastRet = cursor;
+            cursor = (cursor + 1) & (elements.length - 1);
+            return result;
+        }
+
+        public void remove() {
+            if (lastRet < 0)
+                throw new IllegalStateException();
+            if (delete(lastRet)) { // if left-shifted, undo increment in next()
+                cursor = (cursor - 1) & (elements.length - 1);
+                fence = tail;
+            }
+            lastRet = -1;
+        }
+    }
+
+    private class DescendingIterator implements Iterator<E> {
+        /*
+         * This class is nearly a mirror-image of DeqIterator, using
+         * tail instead of head for initial cursor, and head instead of
+         * tail for fence.
+         */
+        private int cursor = tail;
+        private int fence = head;
+        private int lastRet = -1;
+
+        public boolean hasNext() {
+            return cursor != fence;
+        }
+
+        public E next() {
+            if (cursor == fence)
+                throw new NoSuchElementException();
+            cursor = (cursor - 1) & (elements.length - 1);
+            E result = elements[cursor];
+            if (head != fence || result == null)
+                throw new ConcurrentModificationException();
+            lastRet = cursor;
+            return result;
+        }
+
+        public void remove() {
+            if (lastRet < 0)
+                throw new IllegalStateException();
+            if (!delete(lastRet)) {
+                cursor = (cursor + 1) & (elements.length - 1);
+                fence = head;
+            }
+            lastRet = -1;
+        }
+    }
+
+    /**
+     * Returns <tt>true</tt> if this deque contains the specified element.
+     * More formally, returns <tt>true</tt> if and only if this deque contains
+     * at least one element <tt>e</tt> such that <tt>o.equals(e)</tt>.
+     *
+     * @param o object to be checked for containment in this deque
+     * @return <tt>true</tt> if this deque contains the specified element
+     */
+    public boolean contains(Object o) {
+        if (o == null)
+            return false;
+        int mask = elements.length - 1;
+        int i = head;
+        E x;
+        while ( (x = elements[i]) != null) {
+            if (o.equals(x))
+                return true;
+            i = (i + 1) & mask;
+        }
+        return false;
+    }
+
+    /**
+     * Removes a single instance of the specified element from this deque.
+     * If the deque does not contain the element, it is unchanged.
+     * More formally, removes the first element <tt>e</tt> such that
+     * <tt>o.equals(e)</tt> (if such an element exists).
+     * Returns <tt>true</tt> if this deque contained the specified element
+     * (or equivalently, if this deque changed as a result of the call).
+     *
+     * <p>This method is equivalent to {@link #removeFirstOccurrence}.
+     *
+     * @param o element to be removed from this deque, if present
+     * @return <tt>true</tt> if this deque contained the specified element
+     */
+    public boolean remove(Object o) {
+        return removeFirstOccurrence(o);
+    }
+
+    /**
+     * Removes all of the elements from this deque.
+     * The deque will be empty after this call returns.
+     */
+    public void clear() {
+        int h = head;
+        int t = tail;
+        if (h != t) { // clear all cells
+            head = tail = 0;
+            int i = h;
+            int mask = elements.length - 1;
+            do {
+                elements[i] = null;
+                i = (i + 1) & mask;
+            } while (i != t);
+        }
+    }
+    
+    public void clear(boolean skipCellNulling) {
+        if (skipCellNulling) {
+            head = tail = 0;
+        } else {
+            clear();
+        }
+    }
+
+    /**
+     * Returns an array containing all of the elements in this deque
+     * in proper sequence (from first to last element).
+     *
+     * <p>The returned array will be "safe" in that no references to it are
+     * maintained by this deque.  (In other words, this method must allocate
+     * a new array).  The caller is thus free to modify the returned array.
+     *
+     * <p>This method acts as bridge between array-based and collection-based
+     * APIs.
+     *
+     * @return an array containing all of the elements in this deque
+     */
+    public Object[] toArray() {
+        return copyElements(new Object[size()]);
+    }
+
+    /**
+     * Returns an array containing all of the elements in this deque in
+     * proper sequence (from first to last element); the runtime type of the
+     * returned array is that of the specified array.  If the deque fits in
+     * the specified array, it is returned therein.  Otherwise, a new array
+     * is allocated with the runtime type of the specified array and the
+     * size of this deque.
+     *
+     * <p>If this deque fits in the specified array with room to spare
+     * (i.e., the array has more elements than this deque), the element in
+     * the array immediately following the end of the deque is set to
+     * <tt>null</tt>.
+     *
+     * <p>Like the {@link #toArray()} method, this method acts as bridge between
+     * array-based and collection-based APIs.  Further, this method allows
+     * precise control over the runtime type of the output array, and may,
+     * under certain circumstances, be used to save allocation costs.
+     *
+     * <p>Suppose <tt>x</tt> is a deque known to contain only strings.
+     * The following code can be used to dump the deque into a newly
+     * allocated array of <tt>String</tt>:
+     *
+     * <pre>
+     *     String[] y = x.toArray(new String[0]);</pre>
+     *
+     * Note that <tt>toArray(new Object[0])</tt> is identical in function to
+     * <tt>toArray()</tt>.
+     *
+     * @param a the array into which the elements of the deque are to
+     *          be stored, if it is big enough; otherwise, a new array of the
+     *          same runtime type is allocated for this purpose
+     * @return an array containing all of the elements in this deque
+     * @throws ArrayStoreException if the runtime type of the specified array
+     *         is not a supertype of the runtime type of every element in
+     *         this deque
+     * @throws NullPointerException if the specified array is null
+     */
+    public <T> T[] toArray(T[] a) {
+        int size = size();
+        if (a.length < size)
+        	a = new ArrayList<T>(size).toArray(a);
+        copyElements(a);
+        if (a.length > size)
+            a[size] = null;
+        return a;
+    }
+
+    // *** Object methods ***
+
+    /**
+     * Appease the serialization gods.
+     */
+    private static final long serialVersionUID = 2340985798034038923L;
+
+}
\ No newline at end of file

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/RemoteParseTableService.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/RemoteParseTableService.java	Thu Dec 16 14:59:08 2010	(r21515)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/RemoteParseTableService.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -2,10 +2,15 @@
 
 import org.spoofax.jsglr.shared.terms.ATerm;
 
+import com.google.gwt.user.client.rpc.RemoteService;
 import com.google.gwt.user.client.rpc.RemoteServiceRelativePath;
 
 @RemoteServiceRelativePath("parsetable")
-public interface RemoteParseTableService {
+public interface RemoteParseTableService extends RemoteService {
 
-	ATerm findParseTable(String resourceName);
+	ATerm fetchParseTable(String resourceName);
+
+	ATerm readTermFromFile(String string);
+
+	String fetchText(String string);
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/RemoteParseTableServiceAsync.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/RemoteParseTableServiceAsync.java	Thu Dec 16 14:59:08 2010	(r21515)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/RemoteParseTableServiceAsync.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -7,6 +7,10 @@
 
 public interface RemoteParseTableServiceAsync {
 
-	void findParseTable(String resourcePath, AsyncCallback<ATerm> asyncCallback);
+	void fetchParseTable(String resourcePath, AsyncCallback<ATerm> callback);
+
+	void readTermFromFile(String string, AsyncCallback<ATerm> callback);
+
+	void fetchText(String string, AsyncCallback<String> callback);
 
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/AFun.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/AFun.java	Thu Dec 16 14:59:08 2010	(r21515)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/AFun.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -1,15 +1,19 @@
 package org.spoofax.jsglr.shared.terms;
 
-public class AFun {
+import java.io.Serializable;
 
-	private final String name;
-	private final int arity;
-	private final boolean quoted;
+public class AFun implements Serializable {
 
+	private static final long serialVersionUID = 1L;
+	
+	private String name;
+	private int arity;
+
+	AFun() {}
+	
 	public AFun(String name, int arity, boolean quoted) {
 		this.name = name;
 		this.arity = arity;
-		this.quoted = quoted;
 	}
 
 	public int getArity() {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java	Thu Dec 16 14:59:08 2010	(r21515)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -1,17 +1,25 @@
 package org.spoofax.jsglr.shared.terms;
 
+import java.io.Serializable;
 import java.util.List;
 
 import org.spoofax.jsglr.client.NotImplementedException;
 
-public abstract class ATerm {
+public abstract class ATerm implements Serializable {
 
+	private static final long serialVersionUID = 1L;
+	
 	public static final int INT = 1;
 	public static final int APPL = 2;
 	public static final int LIST = 3;
+	public static final int STRING = 4;
+	public static final int TUPLE = 5;
+	public static final int PLACEHOLDER = 6;
 
-	protected final ATermFactory factory;
+	protected ATermFactory factory;
 
+	ATerm() {}
+	
 	protected ATerm(ATermFactory factory) {
 		this.factory = factory;
 	}
@@ -30,7 +38,7 @@
 		throw new NotImplementedException();
 	}
 
-	public List match(ATerm litStringAppl) {
+	public boolean match(ATerm litStringAppl) {
 		throw new NotImplementedException();
 	}
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermAppl.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermAppl.java	Thu Dec 16 14:59:08 2010	(r21515)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermAppl.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -6,9 +6,13 @@
 
 public class ATermAppl extends ATerm {
 
-	private final AFun ctor;
-	private final ATerm[] kids;
+	private static final long serialVersionUID = 1L;
+	
+	private AFun ctor;
+	private ATerm[] kids;
 
+	ATermAppl() {}
+	
 	ATermAppl(ATermFactory factory, AFun ctor, ATerm... kids) {
 		super(factory);
 		this.ctor = ctor;
@@ -34,7 +38,7 @@
 		return ATerm.APPL;
 	}
 
-	public List match(ATerm term) {
+	public boolean match(ATerm term) {
 		throw new NotImplementedException();
 	}
 
@@ -42,5 +46,18 @@
 		return ctor;
 	}
 
+	@Override
+	public String toString() {
+		StringBuilder sb = new StringBuilder();
+		sb.append(ctor.getName());
+		sb.append('(');
+		for(int i = 0; i < kids.length; i++) {
+			if(i > 0)
+				sb.append(",");
+			sb.append(kids[i].toString());
+		}
+		sb.append(')');
+		return sb.toString();
+	}
 
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermFactory.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermFactory.java	Thu Dec 16 14:59:08 2010	(r21515)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermFactory.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -1,15 +1,26 @@
 package org.spoofax.jsglr.shared.terms;
 
-import java.io.InputStream;
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
 
 import org.spoofax.jsglr.client.NotImplementedException;
+import org.spoofax.jsglr.client.PushbackStringIterator;
 
-public class ATermFactory {
+public class ATermFactory implements Serializable {
+
+	private static final long serialVersionUID = 1L;
+	private static final ATerm[] EMPTY = new ATerm[0];
 
 	public AFun makeAFun(String ctorName, int arity, boolean quoted) {
 		return new AFun(ctorName, arity, quoted);
 	}
 
+	public ATermPlaceholder makePlaceholder(ATerm template) {
+		return new ATermPlaceholder(this, makeConstructor("<>", 1), template);
+	}
+	
 	public ATermList makeList() {
 		return new ATermList(this);
 	}
@@ -18,20 +29,16 @@
 		return new ATermList(this, elements);
 	}
 
-	public ATerm parse(String string) {
-		throw new NotImplementedException();
-	}
-
-	public ATerm makeAppl(AFun afun, ATermList kids) {
-		return new ATermAppl(this, afun, kids);
+	public ATermList makeList(List<ATerm> elements) {
+		return new ATermList(this, elements.toArray(new ATerm[0]));
 	}
 
-	public ATerm readFromFile(InputStream stream) {
-		throw new NotImplementedException();
+	public ATerm parse(String text) {
+		return parseFromString(text);
 	}
 
-	public ATerm readFromFile(String stream) {
-		throw new NotImplementedException();
+	public ATerm makeAppl(AFun afun, ATermList kids) {
+		return new ATermAppl(this, afun, kids);
 	}
 
 	public ATerm makeAppl(AFun afun, ATerm... kids) {
@@ -42,4 +49,244 @@
 		return new ATermInt(this, i);
 	}
 
+	
+	protected ATerm parseFromStream(PushbackStringIterator bis) {
+        parseSkip(bis);
+        final int ch = bis.read();
+        switch(ch) {
+        case '[': return parseAnno(bis, parseList(bis));
+        case '(': return parseAnno(bis, parseTuple(bis));
+        case '"': return parseAnno(bis, parseString(bis));
+        case '<': return parsePlaceholder(bis);
+        default:
+            bis.unread(ch);
+            if (Character.isLetter((char)ch)) {
+                return parseAnno(bis, parseAppl(bis));
+            }
+            else if(Character.isDigit((char)ch))
+                return parseAnno(bis, parseNumber(bis));
+        }
+        throw new ParseError("Invalid term: '" + (char)ch + "'");
+    }
+    
+    private ATerm parseAnno(PushbackStringIterator bis, ATerm term) {
+        parseSkip(bis);
+        final int ch = bis.read();
+        if (ch == '{') {
+            List<ATerm> annos = parseTermSequence(bis, '}');
+            return annotateTerm(term, makeList(annos));
+        } else {
+            bis.unread(ch);
+            return term;
+        }
+    }
+
+    private ATerm parseString(PushbackStringIterator bis) {
+        int ch = bis.read();
+        if(ch == '"')
+            return makeString("");
+        StringBuilder sb = new StringBuilder();
+        boolean escaped = false;
+        do {
+            escaped = false;
+            if(ch == '\\') {
+                escaped = true;
+                ch = bis.read();
+            }
+            if(escaped) {
+                switch(ch) {
+                case 'n':
+                    sb.append('\n');
+                    break;
+                case 't':
+                    sb.append('\t');
+                    break;
+                case 'b':
+                    sb.append('\b');
+                    break;
+                case 'f':
+                    sb.append('\f');
+                    break;
+                case 'r':
+                    sb.append('\r');
+                    break;
+                case '\\':
+                    sb.append('\\');
+                    break;
+                case '\'':
+                    sb.append('\'');
+                    break;
+                case '\"':
+                    sb.append('\"');
+                    break;
+                case '0':
+                case '1':
+                case '2':
+                case '3':
+                case '4':
+                case '5':
+                case '6':
+                case '7':
+                case '8':
+                case '9':
+                    throw new NotImplementedException();
+                default:
+                    sb.append("\\" + (char)ch); 
+                }
+                ch = bis.read();
+            } else if(ch != '\"') {
+                if (ch == -1)
+                    throw new ParseError("Unterminated string: " + sb);
+                sb.append((char)ch);
+                ch = bis.read();
+            }
+        } while(escaped || ch != '\"');
+        return makeString(sb.toString());
+    }
+
+    private ATermString makeString(String string) {
+    	return new ATermString(this, string);
+	}
+
+	private ATerm parseAppl(PushbackStringIterator bis) {
+        //System.err.println("appl");
+        // TODO: share stringbuilder instances?
+        StringBuilder sb = new StringBuilder();
+        int ch = bis.read();
+        do {
+            sb.append((char)ch);
+            ch = bis.read();
+        } // TODO: use a switch for this
+          while(Character.isLetterOrDigit((char)ch) || ch == '_' || ch == '-'
+            || ch == '+' || ch == '*' || ch == '$');
+        
+        //System.err.println(" - " + sb.toString());
+        
+        bis.unread(ch);
+        parseSkip(bis);
+        ch = bis.read();
+
+        if(ch == '(') {
+            List<ATerm> l = parseTermSequence(bis, ')');
+            AFun c = makeConstructor(sb.toString(), l.size());
+            return makeAppl(c, l.toArray(EMPTY));
+        } else {
+            bis.unread(ch);
+            AFun c = makeConstructor(sb.toString(), 0);
+            return makeAppl(c, EMPTY);
+        }
+    }
+
+	
+	private AFun makeConstructor(String ctorName, int arity) {
+		return makeAFun(ctorName, arity, false);
+	}
+
+	private ATerm parsePlaceholder(PushbackStringIterator bis) {
+        ATerm template = parseFromStream(bis);
+        parseSkip(bis);
+        if (bis.read() != '>')
+            throw new ParseError("Expected: '>'");
+        return makePlaceholder(template);
+    }
+
+    private ATerm parseTuple(PushbackStringIterator bis) {
+        //System.err.println("tuple");
+        return makeTuple(parseTermSequence(bis, ')').toArray(EMPTY));
+    }
+
+    private ATermTuple makeTuple(ATerm[] elements) {
+    	return new ATermTuple(this, elements);
+	}
+
+	private List<ATerm> parseTermSequence(PushbackStringIterator bis, char endChar) {
+        //System.err.println("sequence");
+		int pos = bis.getOffset();
+        List<ATerm> els = Collections.emptyList();
+        parseSkip(bis);
+        int ch = bis.read();
+        if(ch == endChar)
+            return els;
+        els = new ArrayList<ATerm>();
+        bis.unread(ch);
+        do {
+            els.add(parseFromStream(bis));
+            parseSkip(bis);
+            ch = bis.read();
+        } while(ch == ',');
+        
+        if (ch != endChar) {
+            bis.unread(ch);
+            parseSkip(bis);
+            ch = bis.read();
+        }
+
+        if(ch != endChar)
+            throw new ParseError("Sequence starting at offset " + pos + " must end with '" + endChar + "', saw '" + (char)ch + "'");
+        
+        return els;
+    }
+
+    private ATerm parseList(PushbackStringIterator bis) {
+        //System.err.println("list");
+        return makeList(parseTermSequence(bis, ']'));
+    }
+
+    private ATerm parseNumber(PushbackStringIterator bis) {
+        //System.err.println("number");
+        String whole = parseDigitSequence(bis);
+        
+        int ch = bis.read();
+        if(ch == '.') {
+            String frac = parseDigitSequence(bis);
+            ch = bis.read();
+            if(ch == 'e' || ch == 'E') {
+                String exp = parseDigitSequence(bis);
+                double d = Double.parseDouble(whole + "." + frac + "e" + exp);
+                return makeReal(d);
+            }
+            bis.unread(ch);
+            double d = Double.parseDouble(whole + "." + frac);
+            return makeReal(d);
+        }
+        bis.unread(ch);
+        return makeInt(Integer.parseInt(whole));
+    }
+
+    public ATerm makeReal(double d) {
+    	throw new NotImplementedException();
+	}
+
+	private String parseDigitSequence(PushbackStringIterator bis) {
+        StringBuilder sb = new StringBuilder();
+        int ch = bis.read();
+        do {
+            sb.append((char)ch);
+            ch = bis.read();
+        } while(Character.isDigit((char)ch));
+        bis.unread(ch);
+        return sb.toString(); 
+    }
+
+    public ATerm parseFromString(String text) {
+    	return parseFromStream(new PushbackStringIterator(text));
+    }
+    
+    private void parseSkip(PushbackStringIterator input){
+        for (;;) {
+            int b = input.read();
+            switch (b) {
+                case ' ': case '\t': case '\n':
+                    continue;
+                default:
+                    input.unread(b);
+                    return;
+            }
+        }
+    }
+    
+    public ATerm annotateTerm(ATerm term, ATerm annotations) {
+    	throw new NotImplementedException();
+    }
+
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermInt.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermInt.java	Thu Dec 16 14:59:08 2010	(r21515)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermInt.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -2,7 +2,11 @@
 
 public class ATermInt extends ATerm {
 
-	private final int value;
+	private static final long serialVersionUID = 1L;
+	
+	private int value;
+	
+	ATermInt() {}
 
 	ATermInt(ATermFactory factory, int value) {
 		super(factory);
@@ -28,4 +32,8 @@
 		return ATerm.INT;
 	}
 
+	@Override
+	public String toString() {
+		return Integer.toString(value);
+	}
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java	Thu Dec 16 14:59:08 2010	(r21515)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -4,8 +4,12 @@
 
 public class ATermList extends ATerm implements Iterable<ATerm> {
 
-	private final ATerm[] elements;
+	private static final long serialVersionUID = 1L;
 
+	private ATerm[] elements;
+
+	ATermList() {}
+	
 	ATermList(ATermFactory factory) {
 		super(factory);
 		elements = new ATerm[0];
@@ -89,4 +93,16 @@
 		return new ATermListIterator(this);
 	}
 
+	@Override
+	public String toString() {
+		StringBuilder sb = new StringBuilder();
+		sb.append('[');
+		for(int i = 0 ; i < elements.length; i++) {
+			if(i > 0)
+				sb.append(",");
+			sb.append(elements[i].toString());
+		}
+		sb.append(']');
+		return sb.toString();
+	}
 }

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermPlaceholder.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermPlaceholder.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -0,0 +1,18 @@
+package org.spoofax.jsglr.shared.terms;
+
+public class ATermPlaceholder extends ATermAppl {
+
+	private static final long serialVersionUID = 1L;
+	
+	ATermPlaceholder() {}
+	
+	public ATermPlaceholder(ATermFactory factory, AFun fun, ATerm template) {
+		super(factory, fun, template);
+	}
+
+	@Override
+	public int getType() {
+		return ATerm.PLACEHOLDER;
+	}
+
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermString.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermString.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -0,0 +1,35 @@
+package org.spoofax.jsglr.shared.terms;
+
+public class ATermString extends ATerm {
+
+	private static final long serialVersionUID = 1L;
+	
+	private String value;
+	
+	ATermString() {}
+	
+	ATermString(ATermFactory factory, String value) {
+		super(factory);
+		this.value = value;
+	}
+	
+	@Override
+	public int getChildCount() {
+		return 0;
+	}
+
+	@Override
+	public ATerm getChildAt(int i) {
+		throw new ArrayIndexOutOfBoundsException();
+	}
+
+	@Override
+	public int getType() {
+		return ATerm.STRING;
+	} 
+	
+	@Override
+	public String toString() {
+		return "\"" + value + "\"";
+	}
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermTuple.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermTuple.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -0,0 +1,30 @@
+package org.spoofax.jsglr.shared.terms;
+
+public class ATermTuple extends ATerm {
+
+	private static final long serialVersionUID = 1L;
+	private ATerm[] elements;
+
+	ATermTuple() {}
+	
+	ATermTuple(ATermFactory factory, ATerm[] elements) {
+		super(factory);
+		this.elements = elements;
+	}
+	
+	@Override
+	public int getChildCount() {
+		return elements.length;
+	}
+
+	@Override
+	public ATerm getChildAt(int i) {
+		return elements[i];
+	}
+
+	@Override
+	public int getType() {
+		return ATerm.TUPLE;
+	}
+
+}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ParseError.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ParseError.java	Thu Dec 16 14:59:08 2010	(r21515)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ParseError.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -4,4 +4,9 @@
 
 	private static final long serialVersionUID = 1L;
 
+	public ParseError(String message) {
+		super(message);
+	}
+
+
 }

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/AllTests.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/AllTests.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -0,0 +1,35 @@
+/*
+ * Created on 17.apr.2006
+ *
+ * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
+ * 
+ * Licensed under the GNU General Public License, v2
+ */
+package org.spoofax.jsglr.tests;
+
+import junit.framework.Test;
+import junit.framework.TestSuite;
+
+public class AllTests {
+
+    public static Test suite() {
+        TestSuite suite = new TestSuite("Test for org.spoofax.jsglr.tests");
+        //$JUnit-BEGIN$
+        suite.addTestSuite(TestG_ambi.class);
+        suite.addTestSuite(TestG_avoid_1.class);
+        suite.addTestSuite(TestG_avoid_2.class);
+        suite.addTestSuite(TestG_prefer_1.class);
+        suite.addTestSuite(TestG_prefer_2.class);
+        suite.addTestSuite(TestG_reject_1.class);
+        suite.addTestSuite(TestG_reject_2.class);
+        suite.addTestSuite(TestG_right_assoc.class);
+        suite.addTestSuite(TestG_left_assoc.class);
+        suite.addTestSuite(TestG1.class);
+        suite.addTestSuite(TestG2.class);
+        suite.addTestSuite(TestStratego.class);
+        suite.addTestSuite(TestBooleans.class);
+        //$JUnit-END$
+        return suite;
+    }
+
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -0,0 +1,120 @@
+/*
+ * Created on 13.des.2005
+ *
+ * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
+ *
+ * Licensed under the GNU Lesser General Public License, v2.1
+ */
+package org.spoofax.jsglr.tests;
+
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParseTable;
+import org.spoofax.jsglr.client.ParserException;
+import org.spoofax.jsglr.client.SGLR;
+import org.spoofax.jsglr.shared.RemoteParseTableService;
+import org.spoofax.jsglr.shared.RemoteParseTableServiceAsync;
+import org.spoofax.jsglr.shared.Tools;
+import org.spoofax.jsglr.shared.terms.ATerm;
+import org.spoofax.jsglr.shared.terms.ATermFactory;
+
+import com.google.gwt.core.client.GWT;
+import com.google.gwt.junit.client.GWTTestCase;
+import com.google.gwt.user.client.rpc.AsyncCallback;
+
+public abstract class ParseTestCase extends GWTTestCase {
+
+	protected SGLR sglr;
+    protected String suffix;
+
+    // shared by all tests
+    static final ATermFactory pf = new ATermFactory();
+    RemoteParseTableServiceAsync parseTableService = GWT.create(RemoteParseTableService.class);
+
+    public void gwtSetUp(String grammar, String suffix) throws ParserException, InvalidParseTableException {
+        this.suffix = suffix;
+        Tools.setDebug(false);
+        Tools.setLogging(false);
+        parseTableService.fetchParseTable("tests/grammars/" + grammar + ".tbl",
+        		new AsyncCallback<ATerm>() {
+
+					@Override
+					public void onFailure(Throwable caught) {
+						// TODO Auto-generated method stub
+
+					}
+
+					@Override
+					public void onSuccess(ATerm result) {
+				        try {
+							sglr = new SGLR(pf, new ParseTable(result));
+						} catch (InvalidParseTableException e) {
+							throw new RuntimeException(e);
+						}
+					}
+				});
+
+    }
+
+    @Override
+	protected void gwtTearDown() throws Exception {
+        super.gwtTearDown();
+
+        sglr.clear();
+    }
+
+    final static boolean doCompare = true;
+    public void doParseTest(final String s) {
+
+    	parseTableService.fetchText("tests/data/" + s + "." + suffix,
+    			new AsyncCallback<String>() {
+
+					@Override
+					public void onFailure(Throwable caught) {
+						fail();
+					}
+
+					@Override
+					public void onSuccess(String result) {
+				        long parseTime = System.nanoTime();
+				        ATerm parsed = null;
+				        try {
+							parsed = sglr.parse(result);
+						} catch (Exception e) {
+							fail(e.toString());
+						}
+				        parseTime = System.nanoTime() - parseTime;
+				        System.out.println("Parsing " + s + " took " + parseTime/1000/1000 + " millis.");
+				        assertNotNull(parsed);
+				        if(doCompare)
+				        	doCompare(s, parsed);
+					}
+    		
+    	});
+    	
+    }
+    
+    private void doCompare(String s, final ATerm parsed) {
+    	parseTableService.readTermFromFile("tests/data/" + s + ".trm", new AsyncCallback<ATerm>() {
+
+			@Override
+			public void onFailure(Throwable caught) {
+				fail();
+			}
+
+			@Override
+			public void onSuccess(ATerm loaded) {
+	            assertNotNull(loaded);
+
+	            if(parsed.match(loaded) == false) {
+	            	fail();
+	            }
+	        }
+		});
+
+    }
+
+    @Override
+    public String getModuleName() {
+    	return "org.spoofax.JsglrGWT";
+    }
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestBooleans.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestBooleans.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -0,0 +1,44 @@
+/*
+ * Created on 05.des.2005
+ *
+ * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
+ *
+ * Licensed under the GNU Lesser General Public License, v2.1
+ */
+package org.spoofax.jsglr.tests;
+
+public class TestBooleans extends ParseTestCase {
+
+    @Override
+    protected void gwtSetUp() throws Exception {
+        super.gwtSetUp("Booleans", "txt");
+    }
+
+    public void testB0() {
+        doParseTest("b0");
+    }
+
+    public void testB1() {
+        doParseTest("b1");
+    }
+
+    public void testB2() {
+        doParseTest("b2");
+    }
+
+    public void testB3() {
+        doParseTest("b3");
+    }
+
+    public void testB4() {
+        doParseTest("b4");
+    }
+
+    public void testB5() {
+        doParseTest("b5");
+    }
+
+    public void testB6() {
+        doParseTest("b6");
+    }
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestG1.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestG1.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -0,0 +1,25 @@
+/*
+ * Created on 05.des.2005
+ *
+ * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
+ *
+ * Licensed under the GNU Lesser General Public License, v2.1
+ */
+package org.spoofax.jsglr.tests;
+
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParserException;
+
+public class TestG1 extends ParseTestCase {
+
+    @Override
+	public void gwtSetUp() throws 
+            ParserException, InvalidParseTableException {
+        super.gwtSetUp("G1", "txt");
+    }
+
+
+    public void testG1_1() {
+        doParseTest("g1_1");
+    }
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestG2.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestG2.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -0,0 +1,28 @@
+/*
+ * Created on 05.des.2005
+ *
+ * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
+ *
+ * Licensed under the GNU Lesser General Public License, v2.1
+ */
+package org.spoofax.jsglr.tests;
+
+import java.io.FileNotFoundException;
+import java.io.IOException;
+
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParserException;
+
+public class TestG2 extends ParseTestCase {
+
+    @Override
+	public void gwtSetUp() throws FileNotFoundException, IOException,
+            ParserException, InvalidParseTableException {
+        super.gwtSetUp("G2", "txt");
+    }
+
+
+    public void testG2_1() throws FileNotFoundException, IOException {
+        doParseTest("g2_1");
+    }
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestG_ambi.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestG_ambi.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -0,0 +1,28 @@
+/*
+ * Created on 05.des.2005
+ *
+ * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
+ *
+ * Licensed under the GNU Lesser General Public License, v2.1
+ */
+package org.spoofax.jsglr.tests;
+
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParserException;
+
+public class TestG_ambi extends ParseTestCase {
+
+    @Override
+	public void gwtSetUp() throws ParserException, InvalidParseTableException {
+        super.gwtSetUp("G-ambi", "txt");
+    }
+
+
+    public void testG_ambi_1() {
+        doParseTest("g-ambi-1");
+    }
+
+    public void testG_ambi_2() {
+        doParseTest("g-ambi-2");
+    }
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestG_avoid_1.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestG_avoid_1.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -0,0 +1,25 @@
+/*
+ * Created on 05.des.2005
+ *
+ * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
+ *
+ * Licensed under the GNU Lesser General Public License, v2.1
+ */
+package org.spoofax.jsglr.tests;
+
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParserException;
+
+public class TestG_avoid_1 extends ParseTestCase {
+
+    @Override
+	public void gwtSetUp() throws 
+            ParserException, InvalidParseTableException {
+        super.gwtSetUp("G-avoid-1", "txt");
+    }
+
+
+    public void testG_avoid_1_1() {
+        doParseTest("g-avoid-1_1");
+    }
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestG_avoid_2.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestG_avoid_2.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -0,0 +1,25 @@
+/*
+ * Created on 05.des.2005
+ *
+ * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
+ *
+ * Licensed under the GNU Lesser General Public License, v2.1
+ */
+package org.spoofax.jsglr.tests;
+
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParserException;
+
+public class TestG_avoid_2 extends ParseTestCase {
+
+    @Override
+	public void gwtSetUp() throws 
+            ParserException, InvalidParseTableException {
+        super.gwtSetUp("G-avoid-2", "txt");
+    }
+
+
+    public void testG_avoid_2_1() {
+        doParseTest("g-avoid-2_1");
+    }
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestG_left_assoc.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestG_left_assoc.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -0,0 +1,25 @@
+/*
+ * Created on 05.des.2005
+ *
+ * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
+ *
+ * Licensed under the GNU Lesser General Public License, v2.1
+ */
+package org.spoofax.jsglr.tests;
+
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParserException;
+
+public class TestG_left_assoc extends ParseTestCase {
+
+    @Override
+	public void gwtSetUp() throws 
+            ParserException, InvalidParseTableException {
+        super.gwtSetUp("G-left-assoc", "txt");
+    }
+
+
+    public void testG_left_assoc_1() {
+        doParseTest("g-left-assoc-1");
+    }
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestG_prefer_1.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestG_prefer_1.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -0,0 +1,25 @@
+/*
+ * Created on 05.des.2005
+ *
+ * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
+ *
+ * Licensed under the GNU Lesser General Public License, v2.1
+ */
+package org.spoofax.jsglr.tests;
+
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParserException;
+
+public class TestG_prefer_1 extends ParseTestCase {
+
+    @Override
+	public void gwtSetUp() throws 
+            ParserException, InvalidParseTableException {
+        super.gwtSetUp("G-prefer-1", "txt");
+    }
+
+
+    public void testG_prefer_1_1() {
+        doParseTest("g-prefer-1_1");
+    }
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestG_prefer_2.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestG_prefer_2.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -0,0 +1,25 @@
+/*
+ * Created on 05.des.2005
+ *
+ * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
+ *
+ * Licensed under the GNU Lesser General Public License, v2.1
+ */
+package org.spoofax.jsglr.tests;
+
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParserException;
+
+public class TestG_prefer_2 extends ParseTestCase {
+
+    @Override
+	public void gwtSetUp() throws 
+            ParserException, InvalidParseTableException {
+        super.gwtSetUp("G-prefer-2", "txt");
+    }
+
+
+    public void testG_prefer_2_1() {
+        doParseTest("g-prefer-2_1");
+    }
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestG_reject_1.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestG_reject_1.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -0,0 +1,25 @@
+/*
+ * Created on 05.des.2005
+ *
+ * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
+ *
+ * Licensed under the GNU Lesser General Public License, v2.1
+ */
+package org.spoofax.jsglr.tests;
+
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParserException;
+
+public class TestG_reject_1 extends ParseTestCase {
+
+    @Override
+	public void gwtSetUp() throws
+            ParserException, InvalidParseTableException {
+        super.gwtSetUp("G-reject-1", "txt");
+    }
+
+
+    public void testG_reject_1_1() {
+        doParseTest("g-reject-1_1");
+    }
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestG_reject_2.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestG_reject_2.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -0,0 +1,25 @@
+/*
+ * Created on 05.des.2005
+ *
+ * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
+ *
+ * Licensed under the GNU Lesser General Public License, v2.1
+ */
+package org.spoofax.jsglr.tests;
+
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParserException;
+
+public class TestG_reject_2 extends ParseTestCase {
+
+    @Override
+	public void gwtSetUp() throws 
+            ParserException, InvalidParseTableException {
+        super.gwtSetUp("G-reject-2", "txt");
+    }
+
+
+    public void testG_reject_2_1() {
+        doParseTest("g-reject-2_1");
+    }
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestG_right_assoc.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestG_right_assoc.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -0,0 +1,25 @@
+/*
+ * Created on 05.des.2005
+ *
+ * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
+ *
+ * Licensed under the GNU Lesser General Public License, v2.1
+ */
+package org.spoofax.jsglr.tests;
+
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParserException;
+
+public class TestG_right_assoc extends ParseTestCase {
+
+    @Override
+	public void gwtSetUp() throws 
+            ParserException, InvalidParseTableException {
+        super.gwtSetUp("G-right-assoc", "txt");
+    }
+
+
+    public void testG_right_assoc_1() {
+        doParseTest("g-right-assoc-1");
+    }
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIParseNode.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIParseNode.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -0,0 +1,44 @@
+/*
+ * Created on 21.apr.2006
+ *
+ * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
+ * 
+ * Licensed under the GNU General Public License, v2
+ */
+package org.spoofax.jsglr.tests;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.spoofax.jsglr.client.IParseNode;
+import org.spoofax.jsglr.client.ParseNode;
+import org.spoofax.jsglr.client.ParseProductionNode;
+
+import junit.framework.TestCase;
+
+public class TestIParseNode extends TestCase {
+
+    private IParseNode pn0; 
+    private IParseNode pn1;
+    
+    @Override
+    protected void setUp() throws Exception {
+        List<IParseNode> r0 = new ArrayList<IParseNode>();
+        r0.add(new ParseProductionNode(123));
+        pn0 = new ParseNode(233, r0);
+
+        List<IParseNode> r1 = new ArrayList<IParseNode>();
+        r1.add(new ParseProductionNode(123));
+        pn1 = new ParseNode(233, r1);
+    }
+
+    public void testHashCode() {
+        assertTrue(pn0.hashCode() == pn1.hashCode());
+    }
+
+    public void testEquals() {
+        assertTrue(pn0.equals(pn1));
+    }
+
+
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestStratego.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestStratego.java	Thu Dec 16 15:01:43 2010	(r21516)
@@ -0,0 +1,52 @@
+/*
+ * Created on 05.des.2005
+ *
+ * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
+ *
+ * Licensed under the GNU Lesser General Public License, v2.1
+ */
+package org.spoofax.jsglr.tests;
+
+import java.io.FileNotFoundException;
+import java.io.IOException;
+
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParserException;
+
+public class TestStratego extends ParseTestCase {
+
+    @Override
+	public void gwtSetUp() throws ParserException, InvalidParseTableException {
+        super.gwtSetUp("Stratego", "str");
+    }
+
+
+    public void testS0() throws FileNotFoundException, IOException {
+        doParseTest("s0");
+    }
+
+    public void testS1() throws FileNotFoundException, IOException {
+        doParseTest("s1");
+    }
+
+    public void testS2() throws FileNotFoundException, IOException {
+        doParseTest("s2");
+    }
+
+    public void testS3() throws FileNotFoundException, IOException {
+        doParseTest("s3");
+    }
+
+    public void testS4() throws FileNotFoundException, IOException {
+        doParseTest("s4");
+    }
+
+    public void testS5() throws FileNotFoundException, IOException {
+        doParseTest("s5");
+    }
+
+    public void testS6() throws FileNotFoundException, IOException {
+        doParseTest("s6");
+    }
+
+}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/war/Jsglr_gwt.html
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/war/Jsglr_gwt.html	Thu Dec 16 14:59:08 2010	(r21515)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/war/Jsglr_gwt.html	Thu Dec 16 15:01:43 2010	(r21516)
@@ -4,7 +4,7 @@
     <meta http-equiv="content-type" content="text/html; charset=UTF-8">
     <link type="text/css" rel="stylesheet" href="Jsglr_gwt.css">
 
-    <title>Web Application Starter Project</title>
+    <title>JSGLR for GWT</title>
     
     <script type="text/javascript" language="javascript" src="jsglrgwt/jsglrgwt.nocache.js"></script>
   </head>
@@ -20,5 +20,8 @@
     </noscript>
 
     <h1>JSGLR for GWT</h1>
+    
+    <div id="sourcecode">
+    </div>
   </body>
 </html>

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/war/WEB-INF/classes/org/spoofax/JsglrGWT.gwt.xml
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/war/WEB-INF/classes/org/spoofax/JsglrGWT.gwt.xml	Thu Dec 16 14:59:08 2010	(r21515)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/war/WEB-INF/classes/org/spoofax/JsglrGWT.gwt.xml	Thu Dec 16 15:01:43 2010	(r21516)
@@ -2,11 +2,12 @@
 <module rename-to='jsglrgwt'>
 
   <inherits name='com.google.gwt.user.User'/>
+  <inherits name="com.google.gwt.http.HTTP"/>
 
-  <entry-point class='org.spoofax.client.JSGLREntryPoint'/>
-
-  <source path='jsglr.client'/>
-  <source path='jsglr.shared'/>
+  <source path='jsglr/client'/>
+  <source path='jsglr/shared'/>
   <source path='client'/>
 
+  <entry-point class='org.spoofax.client.JSGLREntryPoint'/>
+
 </module>

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/war/WEB-INF/web.xml
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/war/WEB-INF/web.xml	Thu Dec 16 14:59:08 2010	(r21515)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/war/WEB-INF/web.xml	Thu Dec 16 15:01:43 2010	(r21516)
@@ -4,6 +4,16 @@
     "http://java.sun.com/dtd/web-app_2_3.dtd">
 
 <web-app>
+
+  <servlet>
+    <servlet-name>parsetable</servlet-name>
+    <servlet-class>org.spoofax.jsglr.server.RemoteParseTableServiceImpl</servlet-class>
+  </servlet>
+
+  <servlet-mapping>
+    <servlet-name>parsetable</servlet-name>
+    <url-pattern>/jsglrgwt/parsetable</url-pattern>
+  </servlet-mapping>
   
   <welcome-file-list>
     <welcome-file>Jsglr_gwt.html</welcome-file>

From karltk at strategoxt.org  Thu Dec 16 16:01:55 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:01:55 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21517 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt: src/org/spoofax
	src/org/spoofax/jsglr/client src/org/spoofax/jsglr/shared
	src/org/spoofax/jsglr/shared/terms test/org/spoo...
Message-ID: <201012161501.oBGF1tFi026949@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:01:54 2010
New Revision: 21517
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21517&sc=1

Log:
* Improved error reporting for weird characters.
 * Added simple term matching for unit tests.

Deleted:
   spoofax/branches/jsglr-gwt/jsglr-gwt/war/WEB-INF/classes/
Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/JsglrGWT.gwt.xml
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/MultiBadTokenException.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/PushbackStringIterator.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/BadTokenException.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/AFun.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermAppl.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermInt.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermString.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermTuple.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/JsglrGWT.gwt.xml
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/JsglrGWT.gwt.xml	Thu Dec 16 15:01:43 2010	(r21516)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/JsglrGWT.gwt.xml	Thu Dec 16 15:01:54 2010	(r21517)
@@ -7,6 +7,7 @@
   <source path='jsglr/client'/>
   <source path='jsglr/shared'/>
   <source path='client'/>
+  <source path='jsglr/tests'/>
 
   <entry-point class='org.spoofax.client.JSGLREntryPoint'/>
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/MultiBadTokenException.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/MultiBadTokenException.java	Thu Dec 16 15:01:43 2010	(r21516)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/MultiBadTokenException.java	Thu Dec 16 15:01:54 2010	(r21517)
@@ -47,4 +47,5 @@
         if (causes != null && !causes.isEmpty()) return causes.iterator().next();
         return null;
     }
+    
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/PushbackStringIterator.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/PushbackStringIterator.java	Thu Dec 16 15:01:43 2010	(r21516)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/PushbackStringIterator.java	Thu Dec 16 15:01:54 2010	(r21517)
@@ -8,7 +8,6 @@
 	public PushbackStringIterator(String data) {
 		this.data = data;
 		position = 0;
-		
 	}
 	
 	public int read() {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/BadTokenException.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/BadTokenException.java	Thu Dec 16 15:01:43 2010	(r21516)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/BadTokenException.java	Thu Dec 16 15:01:54 2010	(r21517)
@@ -44,10 +44,17 @@
         if (isEOFToken())
             return "Unexpected end of file";
         else
-            return "Syntax error near unexpected character '" + (char) token + "'";
+            return "Syntax error near unexpected character '" + escape(token) + "'";
     }
 
-    public BadTokenException(SGLR parser, int token, int offset, int lineNumber, int columnNumber) {
+    private String escape(int ch) {
+    	switch(ch) {
+    	case 0: return "\\0";
+    	default: return ""+ch;
+    	}
+	}
+
+	public BadTokenException(SGLR parser, int token, int offset, int lineNumber, int columnNumber) {
         super(parser);
         this.token = token;
         this.offset = offset;
@@ -69,4 +76,9 @@
             factory.makeInt(0)
         );
     }
+    
+    @Override
+    public String toString() {
+    	return getMessage();
+    }
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/AFun.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/AFun.java	Thu Dec 16 15:01:43 2010	(r21516)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/AFun.java	Thu Dec 16 15:01:54 2010	(r21517)
@@ -24,4 +24,11 @@
 		return name;
 	}
 
+	@Override
+	public boolean equals(Object obj) {
+		if(!(obj instanceof AFun))
+			return false;
+		AFun o = (AFun)obj;
+		return o.arity == arity && o.name.equals(name);
+	}
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java	Thu Dec 16 15:01:43 2010	(r21516)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java	Thu Dec 16 15:01:54 2010	(r21517)
@@ -1,6 +1,7 @@
 package org.spoofax.jsglr.shared.terms;
 
 import java.io.Serializable;
+import java.util.LinkedList;
 import java.util.List;
 
 import org.spoofax.jsglr.client.NotImplementedException;
@@ -35,9 +36,16 @@
 	}
 
 	public List match(String termAsString) throws ParseError {
-		throw new NotImplementedException();
+		ATerm t = factory.parse(termAsString);
+		if(t.simpleMatch(t)) {
+			return new LinkedList();
+		} else {
+			return null;
+		}
 	}
 
+	protected abstract boolean simpleMatch(ATerm t);
+
 	public boolean match(ATerm litStringAppl) {
 		throw new NotImplementedException();
 	}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermAppl.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermAppl.java	Thu Dec 16 15:01:43 2010	(r21516)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermAppl.java	Thu Dec 16 15:01:54 2010	(r21517)
@@ -60,4 +60,17 @@
 		return sb.toString();
 	}
 
+	@Override
+	protected boolean simpleMatch(ATerm t) {
+		if(!(t instanceof ATermAppl))
+			return false;
+		ATermAppl o = (ATermAppl)t;
+		if(o.kids.length != kids.length)
+			return false;
+		for(int i = 0; i < kids.length; i++)
+			if(!kids[i].simpleMatch(o.kids[i]))
+				return false;
+		return ctor.equals(o.ctor);
+	}
+
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermInt.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermInt.java	Thu Dec 16 15:01:43 2010	(r21516)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermInt.java	Thu Dec 16 15:01:54 2010	(r21517)
@@ -36,4 +36,12 @@
 	public String toString() {
 		return Integer.toString(value);
 	}
+
+	@Override
+	protected boolean simpleMatch(ATerm t) {
+		if(!(t instanceof ATermInt))
+			return false;
+		ATermInt a = (ATermInt)t;
+		return a.value == value;
+	}
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java	Thu Dec 16 15:01:43 2010	(r21516)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java	Thu Dec 16 15:01:54 2010	(r21517)
@@ -105,4 +105,17 @@
 		sb.append(']');
 		return sb.toString();
 	}
+
+	@Override
+	protected boolean simpleMatch(ATerm t) {
+		if(!(t instanceof ATermList))
+			return false;
+		ATermList o = (ATermList)t;
+		if(elements.length != o.elements.length)
+			return false;
+		for(int i = 0; i < elements.length; i++)
+			if(!o.elements[i].simpleMatch(elements[i]))
+				return false;
+		return true;
+	}
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermString.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermString.java	Thu Dec 16 15:01:43 2010	(r21516)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermString.java	Thu Dec 16 15:01:54 2010	(r21517)
@@ -32,4 +32,12 @@
 	public String toString() {
 		return "\"" + value + "\"";
 	}
+
+	@Override
+	protected boolean simpleMatch(ATerm t) {
+		if(!(t instanceof ATermString))
+			return false;
+		ATermString o = (ATermString)t;
+		return o.value.equals(value);
+	}
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermTuple.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermTuple.java	Thu Dec 16 15:01:43 2010	(r21516)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermTuple.java	Thu Dec 16 15:01:54 2010	(r21517)
@@ -27,4 +27,17 @@
 		return ATerm.TUPLE;
 	}
 
+	@Override
+	protected boolean simpleMatch(ATerm t) {
+		if(!(t instanceof ATermTuple))
+			return false;
+		ATermTuple o = (ATermTuple)t;
+		if(elements.length != o.elements.length)
+			return false;
+		for(int i = 0; i < elements.length; i++)
+			if(elements[i].equals(o.elements[i]))
+					return false;
+		return true;
+	}
+
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:01:43 2010	(r21516)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:01:54 2010	(r21517)
@@ -7,114 +7,140 @@
  */
 package org.spoofax.jsglr.tests;
 
+import java.io.BufferedReader;
+import java.io.FileReader;
+import java.io.IOException;
+
+import junit.framework.TestCase;
+
 import org.spoofax.jsglr.client.InvalidParseTableException;
 import org.spoofax.jsglr.client.ParseTable;
 import org.spoofax.jsglr.client.ParserException;
 import org.spoofax.jsglr.client.SGLR;
-import org.spoofax.jsglr.shared.RemoteParseTableService;
-import org.spoofax.jsglr.shared.RemoteParseTableServiceAsync;
 import org.spoofax.jsglr.shared.Tools;
 import org.spoofax.jsglr.shared.terms.ATerm;
 import org.spoofax.jsglr.shared.terms.ATermFactory;
 
-import com.google.gwt.core.client.GWT;
-import com.google.gwt.junit.client.GWTTestCase;
-import com.google.gwt.user.client.rpc.AsyncCallback;
-
-public abstract class ParseTestCase extends GWTTestCase {
+public abstract class ParseTestCase extends TestCase {
 
 	protected SGLR sglr;
-    protected String suffix;
+	protected String suffix;
 
-    // shared by all tests
-    static final ATermFactory pf = new ATermFactory();
-    RemoteParseTableServiceAsync parseTableService = GWT.create(RemoteParseTableService.class);
-
-    public void gwtSetUp(String grammar, String suffix) throws ParserException, InvalidParseTableException {
-        this.suffix = suffix;
-        Tools.setDebug(false);
-        Tools.setLogging(false);
-        parseTableService.fetchParseTable("tests/grammars/" + grammar + ".tbl",
-        		new AsyncCallback<ATerm>() {
-
-					@Override
-					public void onFailure(Throwable caught) {
-						// TODO Auto-generated method stub
-
-					}
-
-					@Override
-					public void onSuccess(ATerm result) {
-				        try {
-							sglr = new SGLR(pf, new ParseTable(result));
-						} catch (InvalidParseTableException e) {
-							throw new RuntimeException(e);
-						}
-					}
-				});
-
-    }
-
-    @Override
-	protected void gwtTearDown() throws Exception {
-        super.gwtTearDown();
-
-        sglr.clear();
-    }
-
-    final static boolean doCompare = true;
-    public void doParseTest(final String s) {
-
-    	parseTableService.fetchText("tests/data/" + s + "." + suffix,
-    			new AsyncCallback<String>() {
-
-					@Override
-					public void onFailure(Throwable caught) {
-						fail();
-					}
-
-					@Override
-					public void onSuccess(String result) {
-				        long parseTime = System.nanoTime();
-				        ATerm parsed = null;
-				        try {
-							parsed = sglr.parse(result);
-						} catch (Exception e) {
-							fail(e.toString());
-						}
-				        parseTime = System.nanoTime() - parseTime;
-				        System.out.println("Parsing " + s + " took " + parseTime/1000/1000 + " millis.");
-				        assertNotNull(parsed);
-				        if(doCompare)
-				        	doCompare(s, parsed);
-					}
-    		
-    	});
-    	
-    }
-    
-    private void doCompare(String s, final ATerm parsed) {
-    	parseTableService.readTermFromFile("tests/data/" + s + ".trm", new AsyncCallback<ATerm>() {
-
-			@Override
-			public void onFailure(Throwable caught) {
-				fail();
-			}
-
-			@Override
-			public void onSuccess(ATerm loaded) {
-	            assertNotNull(loaded);
-
-	            if(parsed.match(loaded) == false) {
-	            	fail();
-	            }
-	        }
-		});
-
-    }
-
-    @Override
-    public String getModuleName() {
-    	return "org.spoofax.JsglrGWT";
-    }
+	// shared by all tests
+	static final ATermFactory pf = new ATermFactory();
+	//RemoteParseTableServiceAsync parseTableService = GWT.create(RemoteParseTableService.class);
+
+	@Override
+	protected void setUp() throws Exception {
+		gwtSetUp();
+	}
+
+	protected abstract void gwtSetUp() throws Exception;
+
+	public void gwtSetUp(String grammar, String suffix) throws ParserException, InvalidParseTableException {
+		this.suffix = suffix;
+		Tools.setDebug(false);
+		Tools.setLogging(false);
+		String fn = "tests/grammars/" + grammar + ".tbl";
+
+		ATerm result = pf.parseFromString(loadFileAsString(fn));
+		sglr = new SGLR(pf, new ParseTable(result));
+		//        parseTableService.fetchParseTable("tests/grammars/" + grammar + ".tbl",
+		//        		new AsyncCallback<ATerm>() {
+		//
+		//					@Override
+		//					public void onFailure(Throwable caught) {
+		//						// TODO Auto-generated method stub
+		//
+		//					}
+		//
+		//					@Override
+		//					public void onSuccess(ATerm result) {
+		//				        try {
+		//							sglr = new SGLR(pf, new ParseTable(result));
+		//						} catch (InvalidParseTableException e) {
+		//							throw new RuntimeException(e);
+		//						}
+		//					}
+		//				});
+
+	}
+
+	private String loadFileAsString(String fn) {
+		char[] cbuf = new char[1024*1024*12];
+		try {
+			BufferedReader br = new BufferedReader(new FileReader(fn));
+			int len = br.read(cbuf);
+			return new String(cbuf, 0, len);
+		} catch (IOException e) {
+			e.printStackTrace();
+			return null;
+		}
+	}
+
+	@Override
+	protected void tearDown() throws Exception {
+		//super.gwtTearDown();
+
+		sglr.clear();
+	}
+
+	final static boolean doCompare = true;
+	public void doParseTest(final String s) {
+
+		//		parseTableService.fetchText("tests/data/" + s + "." + suffix,
+		//				new AsyncCallback<String>() {
+		//
+		//			@Override
+		//			public void onFailure(Throwable caught) {
+		//				fail();
+		//			}
+		//
+		//			@Override
+		//			public void onSuccess(String result) {
+		String result = loadFileAsString("tests/data/" + s + "." + suffix);
+		assertNotNull("Data file is missing", result);
+		long parseTime = System.nanoTime();
+		ATerm parsed = null;
+		try {
+			parsed = sglr.parse(result);
+		} catch (Exception e) {
+			e.printStackTrace();
+			fail(e.toString());
+		}
+		parseTime = System.nanoTime() - parseTime;
+		System.out.println("Parsing " + s + " took " + parseTime/1000/1000 + " millis.");
+		assertNotNull(parsed);
+		if(doCompare)
+			doCompare(s, parsed);
+		//			}
+		//
+		//		});
+
+	}
+
+	private void doCompare(String s, final ATerm parsed) {
+		//parseTableService.readTermFromFile("tests/data/" + s + ".trm", new AsyncCallback<ATerm>() {
+		String loaded = loadFileAsString("tests/data/" + s + ".trm");
+
+		//			@Override
+		//			public void onFailure(Throwable caught) {
+		//				fail();
+		//			}
+		//
+		//			@Override
+		//			public void onSuccess(ATerm loaded) {
+		assertNotNull(loaded);
+
+		if(parsed.match(loaded) == null) {
+			fail();
+		}
+		//			}
+		//		});
+
+	}
+
+	public String getModuleName() {
+		return "org.spoofax.JsglrGWT";
+	}
 }

From karltk at strategoxt.org  Thu Dec 16 16:02:04 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:02:04 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21518 - in
	spoofax/branches/jsglr-gwt: . jsglr-gwt/src/org/spoofax/jsglr
	jsglr-gwt/src/org/spoofax/jsglr/client
	jsglr-gwt/src/org/spoofax/jsglr/shared/terms jsglr-gwt/test...
Message-ID: <201012161502.oBGF244x026954@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:02:04 2010
New Revision: 21518
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21518&sc=1

Log:
* Added performance test harness.
 * Started reducing garbage creation in parser.

Added:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/FileTools.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestJava.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestWebDSL.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java0.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java1.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java2.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java3.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java4.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/webdsl0.app
Modified:
   spoofax/branches/jsglr-gwt/.hgignore
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Frame.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentInfo.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Path.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Term.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermAppl.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermInt.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermString.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermTuple.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/AllTests.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java

Modified: spoofax/branches/jsglr-gwt/.hgignore
==============================================================================
--- spoofax/branches/jsglr-gwt/.hgignore	Thu Dec 16 15:01:54 2010	(r21517)
+++ spoofax/branches/jsglr-gwt/.hgignore	Thu Dec 16 15:02:04 2010	(r21518)
@@ -3,6 +3,11 @@
 *.cache.*
 .metadata
 *.jar
+*.tbl
+*.trm
+.sglr-log
 jsglr-gwt/war/jsglrgwt
 jsglr-gwt/war/*.tbl
 jsglr-gwt/.settings
+jsglr-gwt/war/WEB-INF/classes
+jsglr-gwt/tomcat

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/FileTools.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/FileTools.java	Thu Dec 16 15:02:04 2010	(r21518)
@@ -0,0 +1,22 @@
+package org.spoofax.jsglr;
+
+import java.io.BufferedReader;
+import java.io.FileReader;
+import java.io.IOException;
+
+public class FileTools {
+
+	public static String loadFileAsString(String fn) {
+		// FIXME (KTK) static allocation of 7MB must be replaced with something dynamic  
+		char[] cbuf = new char[1024*1024*7];
+		try {
+			BufferedReader br = new BufferedReader(new FileReader(fn));
+			int len = br.read(cbuf);
+			return new String(cbuf, 0, len);
+		} catch (IOException e) {
+			e.printStackTrace();
+			return null;
+		}
+	}
+
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java	Thu Dec 16 15:02:04 2010	(r21518)
@@ -0,0 +1,147 @@
+/*
+ * Created on 03.des.2005
+ *
+ * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
+ * 
+ * Licensed under the GNU Lesser General Public License, v2.1
+ */
+package org.spoofax.jsglr;
+
+import java.io.BufferedInputStream;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParseTable;
+import org.spoofax.jsglr.client.SGLR;
+import org.spoofax.jsglr.shared.BadTokenException;
+import org.spoofax.jsglr.shared.SGLRException;
+import org.spoofax.jsglr.shared.Tools;
+import org.spoofax.jsglr.shared.terms.ATerm;
+import org.spoofax.jsglr.shared.terms.ATermFactory;
+
+public class Main {
+
+    public static void main(String[] args) throws FileNotFoundException, IOException, InvalidParseTableException {
+
+        if(args.length < 2) {
+            usage();
+        }
+
+        String parseTableFile = null;
+        String input = null;
+        String output = null;
+        String startSymbol = null;
+        boolean debugging = false;
+        boolean logging = false;
+        boolean detectCycles = true;
+        boolean filter = true;
+        boolean waitForProfiler = false;
+        boolean timing = false;
+        boolean heuristicFilters = false;
+        int profilingRuns = 0;
+        
+        for(int i=0;i<args.length;i++) {
+            if(args[i].equals("-p")) {
+                parseTableFile = args[++i];
+            } else if(args[i].equals("-i")) {
+                input = args[++i];
+            } else if(args[i].equals("-o")) {
+                output = args[++i];
+            } else if(args[i].equals("-d")) {
+                debugging = true;
+            } else if(args[i].equals("-v")) {
+                logging = true;
+            } else if(args[i].equals("-f")) {
+                filter = false;
+            } else if(args[i].equals("-c")) {
+                detectCycles = false;
+            } else if(args[i].equals("-s")) {
+                startSymbol = args[++i];
+            } else if(args[i].equals("--heuristic-filters")) {
+                heuristicFilters = args[++i].equals("on");
+            } else if(args[i].equals("--wait-for-profiler")) {
+                waitForProfiler = true;
+            } else if(args[i].equals("--profiler-runs")) {
+            	profilingRuns = Integer.parseInt(args[++i]);
+            } else if(args[i].equals("--timing")) {
+            	timing = true;
+            } else {
+                System.err.println("Unknown option: " + args[i]);
+                System.exit(1);
+            }
+        }
+
+        if(parseTableFile == null)
+            usage();
+        
+        ATermFactory factory = new ATermFactory();
+        long tableLoadingTime = System.currentTimeMillis(); 
+        ParseTable pt = new ParseTable(factory.parseFromString(FileTools.loadFileAsString(parseTableFile)));
+        SGLR sglr = new SGLR(factory, pt);        
+
+        tableLoadingTime = System.currentTimeMillis() - tableLoadingTime;
+
+        Tools.setDebug(debugging);
+        Tools.setLogging(logging);
+        sglr.getDisambiguator().setFilterCycles(detectCycles);
+        sglr.getDisambiguator().setFilterAny(filter);
+        sglr.getDisambiguator().setHeuristicFilters(heuristicFilters);
+        
+        if(waitForProfiler) {
+        	System.err.println("Hit enter to start profiling...");
+            System.in.read();
+        }
+
+        for(int i = 0; i < profilingRuns - 1; i++)
+        	parseFile(input, null, sglr, startSymbol);
+        
+        long parsingTime = parseFile(input, output, sglr, startSymbol);
+
+        if(timing) {
+        	System.err.println("Parse table loading time : " + tableLoadingTime + "ms");
+        	System.err.println("Parsing time             : " + parsingTime + "ms");
+        }
+    }
+
+    public static long parseFile(String input, String output, SGLR sglr, String startSymbol)
+            throws FileNotFoundException, IOException {
+        InputStream fis = null;
+        if(input == null)
+            fis = System.in;
+        else
+            fis = new BufferedInputStream(new FileInputStream(input));
+        OutputStream ous = null;
+        if(output != null && !"-".equals(output))
+            ous = new FileOutputStream(output);
+        else 
+            ous = System.out;
+
+        long parsingTime = 0;
+        ATerm t=null;
+        try {
+        	parsingTime = System.currentTimeMillis();
+            t=sglr.parse(FileTools.loadFileAsString(input), startSymbol);            
+            parsingTime = System.currentTimeMillis() - parsingTime;            
+        } catch(BadTokenException e) {
+            System.err.println("Parsing failed : " + e.getMessage());
+        } catch(SGLRException e) {
+            // Detailed message for other exceptions
+            System.err.println("Parsing failed : " + e);
+        }
+        if(t != null && !"-".equals(output)){            
+            String outputString=t.toString();
+            ous.write(outputString.getBytes());
+        }
+        return parsingTime;
+    }
+
+    private static void usage() {
+        System.out.println("Usage: org.spoofax.jsglr.Main [-f -d -v] -p <parsetable.tbl> -i <inputfile>");
+        System.exit(-1);
+    }
+}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java	Thu Dec 16 15:01:54 2010	(r21517)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java	Thu Dec 16 15:02:04 2010	(r21518)
@@ -48,7 +48,7 @@
             if (alt instanceof Amb) {
                 list = ((Amb) alt).addToParseTree(pt, factory, list);
             } else {
-                list = factory.makeList(alt.toParseTree(pt), list);
+                list = list.prepend(alt.toParseTree(pt));
             }
         }
         return list;

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Frame.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Frame.java	Thu Dec 16 15:01:54 2010	(r21517)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Frame.java	Thu Dec 16 15:02:04 2010	(r21518)
@@ -9,6 +9,7 @@
 
 import java.io.Serializable;
 import java.util.ArrayList;
+import java.util.LinkedList;
 import java.util.List;
 
 import org.spoofax.jsglr.shared.Tools;
@@ -63,7 +64,7 @@
     }
 
     public List<Path> findAllPaths(int arity) {
-        ArrayList<Path> ret = new ArrayList<Path>();
+        ArrayList<Path> ret = new ArrayList<Path>(arity);
         doComputePathsToRoot(ret, null, arity, 0);
         return ret;
     }
@@ -208,7 +209,7 @@
             SGLR.TRACE("SG_FindLimitedPaths() - " + arity + ", " + l.getLength() + ", " + l.parent.state.stateNumber);
             TRACE_DumpLinks(steps);
         }
-        List<Path> ret = new ArrayList<Path>();
+        List<Path> ret = new ArrayList<Path>(arity);
         if(findLink(arity, l)) { 
             doComputePathsToRoot(ret, null, l, false, arity, 0);
         } 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentInfo.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentInfo.java	Thu Dec 16 15:01:54 2010	(r21517)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentInfo.java	Thu Dec 16 15:02:04 2010	(r21518)
@@ -88,7 +88,7 @@
                 if(length > maxPathLength){
                     maxPathLength = length;
                     if(p.parent.label!=null)
-                        result =p.parent.lnk;
+                        result =p.parent.link;
                 }
             }
         }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java	Thu Dec 16 15:01:54 2010	(r21517)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java	Thu Dec 16 15:02:04 2010	(r21518)
@@ -32,7 +32,7 @@
 
         ATermList l1 = factory.makeList();
         for (int i = kids.size() - 1; i >= 0; i--) {
-            l1 = factory.makeList(kids.get(i).toParseTree(pt), l1);
+            l1 = l1.prepend(kids.get(i).toParseTree(pt));
         }
 
         return factory.makeAppl(pt.applAFun, pt.getProduction(label), l1);
@@ -44,7 +44,7 @@
     public static ATermList makeList(ATermFactory factory, List<ATerm> terms) {
         ATermList result = factory.makeList();
         for (int i = terms.size() - 1; i >= 0; i--) {
-            result = factory.makeList(terms.get(i), result);
+            result = result.prepend(terms.get(i));
         }
         return result;
     }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java	Thu Dec 16 15:01:54 2010	(r21517)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java	Thu Dec 16 15:02:04 2010	(r21518)
@@ -236,7 +236,7 @@
         	return false;
         
         final AFun fun = ((ATermAppl)ls.getChildAt(0)).getAFun();
-        return fun.getName().equals("lit") && fun.getArity() == 1;
+        return !(fun.getName().equals("lit") && fun.getArity() == 1);
     }
 
     private ProductionAttributes parseProductionAttributes(ATermAppl attr)

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Path.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Path.java	Thu Dec 16 15:01:54 2010	(r21517)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Path.java	Thu Dec 16 15:02:04 2010	(r21518)
@@ -7,17 +7,11 @@
  */
 package org.spoofax.jsglr.client;
 
-//todo managed
-//import javolution.realtime.ObjectFactory;
-//import javolution.realtime.ObjectPool;
-//import javolution.realtime.PoolContext;
-//import javolution.realtime.Context;
-
 import java.util.ArrayList;
+import java.util.Iterator;
 import java.util.List;
 
-
-public class Path /*todo managed extends RealtimeObject*/ {
+public class Path /*implements Iterable<IParseNode>*/ {
 
     public final Path parent;
 
@@ -27,19 +21,28 @@
 
     protected final int length;
     
-    public static int totalCount = 0;
-    
-    public Link lnk;
-    
+    public final Link link;
+
+    Path(Path parent, Link link, Frame frame, int length) {
+    	this.parent = parent;
+        this.link = link;
+        if(link != null){
+            this.label = link.label;
+        } else {
+            this.label = null;
+        }
+        this.frame = frame;
+        this.length = length;
+    }
+
     public int getRecoverCount()
     {
         int result = 0;
-        if(lnk!=null)
-        {
-            result+=lnk.recoverCount;           
+        if(link != null) {
+            result += link.recoverCount;           
         }
-        if(parent!=null) //Todo: find out relation linktoparent/parent
-        {
+        if(parent != null) {
+        	// TODO find out relation linktoparent/parent
             result += parent.getRecoverCount();
         }
         return result;        
@@ -47,46 +50,18 @@
     
     public int getRecoverCount(int maxCharLength)
     {
-        if(parent==null || this.length<=maxCharLength)
+        if(parent == null || this.length <= maxCharLength)
             return getRecoverCount();
         return parent.getRecoverCount(maxCharLength);
     }
 
-    //todo managed
-    //public static final PathObjectFactory FACTORY = new PathObjectFactory();
-
     public static boolean logNewInstanceCreation = false;
 
-/*    Path() {
-        super();
-    }
-*/
     public static Path valueOf(Path parent, Link ln, Frame frame, int length) {
-        Path _this = new Path(parent, ln, frame, length);
-        
-        //(Path)FACTORY.object(); //todo managed
-/*
-        _this.parent = parent;
-        _this.label = label;
-        _this.frame = frame;
-*/
-        return _this;
-    }
-
-    Path(Path parent, Link ln, Frame frame, int length) {
-        this.parent = parent;
-        lnk = ln;
-        if(ln!=null){
-            this.label = lnk.label;
-        }
-        else
-        {
-            this.label = null;
-        }
-        this.frame = frame;
-        this.length = length;
+        return new Path(parent, ln, frame, length);
     }
 
+
     public Frame getEnd() {
         return frame;
     }
@@ -114,39 +89,16 @@
         return sb.toString();
     }
 
-    public int getLength() { 
-        if (parent == null) {
-            return length;
-        }
-        else {
-            return length; //+ parent.getLength();
-        }
+    public int getLength() {
+    	return length;
     }
 
-    //todo managed
-//    public static final class PathObjectFactory extends ObjectFactory {
-//        protected Path create() {
-//            return new Path();
-//        }
-//
-//        private ObjectPool _cachedPool;
-//
-//        /**
-//         * This needs to be called once per thread
-//         *
-//         * @param poolContext
-//         */
-//        public final void attach(final Context poolContext) {
-//            _cachedPool = ((PoolContext)poolContext).getPool(_index);
-//        }
-//
-//        public Object/*T*/object() {
-//            return _cachedPool.next();
-//        }
-//
-////        protected void cleanup(Object/*T*/obj) {
-////            //((Path)obj).clear(false);
-////        }
-//    }
+//    private class 
+//	@Override
+//	public Iterator<IParseNode> iterator() {
+//		// TODO Auto-generated method stub
+//		return null;
+//	}
+
 }
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 15:01:54 2010	(r21517)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 15:02:04 2010	(r21518)
@@ -342,7 +342,7 @@
 
     private void shifter() {
         logBeforeShifter();
-        clearActiveStacks(false);
+        clearActiveStacks();
 
         IParseNode prod = parseTable.lookupProduction(currentToken);
 
@@ -372,12 +372,13 @@
         activeStacks.addFirst(st1);
     }
 
+    int x = 0;
     private void parseCharacter() {
         logBeforeParseCharacter();
 
         ArrayDeque<Frame> actives = new ArrayDeque<Frame>(activeStacks); // FIXME avoid garbage
-        clearForActorDelayed(false);
-        clearForShifter(false);
+        clearForActorDelayed();
+        clearForShifter();
         while (actives.size() > 0 || forActor.size() > 0) {
             Frame st;
             st = pickStackNodeFromActivesOrForActor(actives);
@@ -396,8 +397,10 @@
         if(Tools.tracing) {
             TRACE("SG_ - both empty");
         }
+        ArrayDeque<Frame> tmp = forActor;
         forActor = forActorDelayed;
-        forActorDelayed = new ArrayDeque<Frame>(); // FIXME: avoid garbage
+        tmp.clear();
+        forActorDelayed = tmp;
     }
 
     private Frame pickStackNodeFromActivesOrForActor(ArrayDeque<Frame> actives) {
@@ -824,49 +827,58 @@
             this.acceptingStack.clear();
         }
 
-        clearActiveStacks(true);
-        clearForActorDelayed(true);
-        clearForActor(true);
-        clearForShifter(true);
+        clearActiveStacksDeep();
+        clearForActorDelayedDeep();
+        clearForActorDeep();
+        clearForShifterDeep();
 
         this.parseTable = null;
         this.factory = null;
-        this.ambiguityManager = null; // todo clear
+        this.ambiguityManager = null;
     }
 
-    private void clearForShifter(boolean all) {
-        if (all) {
-            for (ActionState as : forShifter) {
-                as.clear(all);
-            }
-        }
-        this.forShifter.clear();
+    private void clearForShifterDeep() {
+    	for (ActionState as : forShifter) {
+    		as.clear(true);
+    	}
+    	clearForShifter();
     }
 
-    private void clearForActor(boolean all) {
-        if (all) {
-            for (Frame frame : forActor) {
-                frame.clear();
-            }
-        }
+    private void clearForShifter() {
+        forShifter.clear();
+    }
+
+    private void clearForActor() {
         forActor.clear();
     }
 
-    private void clearForActorDelayed(boolean all) {
-        if (all) {
-            for (Frame frame : forActorDelayed) {
-                frame.clear();
-            }
+    private void clearForActorDeep() {
+    	for (Frame frame : forActor) {
+    		frame.clear();
+    	}
+    	clearForActor();
+    }
+
+    private void clearForActorDelayedDeep() {
+    	for (Frame frame : forActorDelayed) {
+    		frame.clear();
+            	
         }
+    	clearForActorDelayed();
+    }
+
+    private void clearForActorDelayed() {
         forActorDelayed.clear(true);
     }
 
-    private void clearActiveStacks(boolean all) {
-        if (all) {
-            for (Frame frame : activeStacks) {
-                frame.clear();
-            }
-        }
+    private void clearActiveStacksDeep() {
+    	for (Frame frame : activeStacks) {
+    		frame.clear();
+    	}
+    	clearActiveStacks();
+    }
+
+    private void clearActiveStacks() {
         activeStacks.clear(true);
     }
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Term.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Term.java	Thu Dec 16 15:01:54 2010	(r21517)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Term.java	Thu Dec 16 15:02:04 2010	(r21518)
@@ -55,13 +55,9 @@
         return t.getType() == ATerm.INT;
     }
 
-    public static ATermList makeList(ATermFactory f, List<ATerm> kids) {
-        ATermList ret = f.makeList();
-        // FIXME: Slowest insertion method
-        for(ATerm t : kids)
-            ret = ret.append(t);
-        return ret;
-    }
+//    public static ATermList makeList(ATermFactory f, List<ATerm> kids) {
+//    	return f.makeList(kids);
+//    }
 
     public static boolean isAppl(ATerm t) {
         return t.getType() == ATerm.APPL;

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java	Thu Dec 16 15:01:54 2010	(r21517)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java	Thu Dec 16 15:02:04 2010	(r21518)
@@ -37,17 +37,25 @@
 
 	public List match(String termAsString) throws ParseError {
 		ATerm t = factory.parse(termAsString);
-		if(t.simpleMatch(t)) {
+		if(simpleMatch(t)) {
 			return new LinkedList();
 		} else {
 			return null;
 		}
 	}
 
-	protected abstract boolean simpleMatch(ATerm t);
+	public abstract boolean simpleMatch(ATerm t);
 
 	public boolean match(ATerm litStringAppl) {
 		throw new NotImplementedException();
 	}
 
+	@Override
+	public final String toString() {
+		StringBuilder sb = new StringBuilder();
+		toString(8, sb);
+		return sb.toString();
+	}
+
+	protected abstract void toString(int depth, StringBuilder sb);
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermAppl.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermAppl.java	Thu Dec 16 15:01:54 2010	(r21517)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermAppl.java	Thu Dec 16 15:02:04 2010	(r21518)
@@ -7,12 +7,12 @@
 public class ATermAppl extends ATerm {
 
 	private static final long serialVersionUID = 1L;
-	
+
 	private AFun ctor;
 	private ATerm[] kids;
 
 	ATermAppl() {}
-	
+
 	ATermAppl(ATermFactory factory, AFun ctor, ATerm... kids) {
 		super(factory);
 		this.ctor = ctor;
@@ -47,29 +47,33 @@
 	}
 
 	@Override
-	public String toString() {
-		StringBuilder sb = new StringBuilder();
-		sb.append(ctor.getName());
-		sb.append('(');
-		for(int i = 0; i < kids.length; i++) {
-			if(i > 0)
-				sb.append(",");
-			sb.append(kids[i].toString());
+	protected void toString(int depth, StringBuilder sb) {
+		if(depth == 0) {
+			sb.append("...");
+		} else {
+			sb.append(ctor.getName());
+			sb.append('(');
+			for(int i = 0; i < kids.length; i++) {
+				if(i > 0)
+					sb.append(",");
+				kids[i].toString(depth - 1, sb);
+			}
+			sb.append(')');
 		}
-		sb.append(')');
-		return sb.toString();
 	}
 
 	@Override
-	protected boolean simpleMatch(ATerm t) {
+	public boolean simpleMatch(ATerm t) {
 		if(!(t instanceof ATermAppl))
 			return false;
 		ATermAppl o = (ATermAppl)t;
 		if(o.kids.length != kids.length)
 			return false;
 		for(int i = 0; i < kids.length; i++)
-			if(!kids[i].simpleMatch(o.kids[i]))
+			if(!kids[i].simpleMatch(o.kids[i])) {
+				System.out.println(kids[i] + "\n  !=  \n"   + o.kids[i]);
 				return false;
+			}
 		return ctor.equals(o.ctor);
 	}
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermInt.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermInt.java	Thu Dec 16 15:01:54 2010	(r21517)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermInt.java	Thu Dec 16 15:02:04 2010	(r21518)
@@ -33,12 +33,17 @@
 	}
 
 	@Override
-	public String toString() {
-		return Integer.toString(value);
+	protected void toString(int depth, StringBuilder sb) {
+		if(depth == 0) {
+			sb.append("...");
+		}
+		else {
+			sb.append(Integer.toString(value));
+		}
 	}
 
 	@Override
-	protected boolean simpleMatch(ATerm t) {
+	public boolean simpleMatch(ATerm t) {
 		if(!(t instanceof ATermInt))
 			return false;
 		ATermInt a = (ATermInt)t;

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java	Thu Dec 16 15:01:54 2010	(r21517)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java	Thu Dec 16 15:02:04 2010	(r21518)
@@ -9,7 +9,7 @@
 	private ATerm[] elements;
 
 	ATermList() {}
-	
+
 	ATermList(ATermFactory factory) {
 		super(factory);
 		elements = new ATerm[0];
@@ -26,13 +26,13 @@
 		newList[0] = t;
 		return new ATermList(factory, newList);
 	}
-
-	public ATermList append(ATerm t) {
-		ATerm[] newList = new ATerm[elements.length+1];
-		System.arraycopy(elements, 0, newList, 0, elements.length);
-		newList[elements.length] = t;
-		return new ATermList(factory, newList);
-	}
+	//
+	//	public ATermList append(ATerm t) {
+	//		ATerm[] newList = new ATerm[elements.length+1];
+	//		System.arraycopy(elements, 0, newList, 0, elements.length);
+	//		newList[elements.length] = t;
+	//		return new ATermList(factory, newList);
+	//	}
 
 	public boolean isEmpty() {
 		return elements.length == 0;
@@ -94,20 +94,22 @@
 	}
 
 	@Override
-	public String toString() {
-		StringBuilder sb = new StringBuilder();
-		sb.append('[');
-		for(int i = 0 ; i < elements.length; i++) {
-			if(i > 0)
-				sb.append(",");
-			sb.append(elements[i].toString());
+	protected void toString(int depth, StringBuilder sb) {
+		if(depth == 0) {
+			sb.append("...");
+		} else { 
+			sb.append('[');
+			for(int i = 0 ; i < elements.length; i++) {
+				if(i > 0)
+					sb.append(",");
+				elements[i].toString(depth - 1, sb);
+			}
+			sb.append(']');
 		}
-		sb.append(']');
-		return sb.toString();
 	}
 
 	@Override
-	protected boolean simpleMatch(ATerm t) {
+	public boolean simpleMatch(ATerm t) {
 		if(!(t instanceof ATermList))
 			return false;
 		ATermList o = (ATermList)t;

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermString.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermString.java	Thu Dec 16 15:01:54 2010	(r21517)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermString.java	Thu Dec 16 15:02:04 2010	(r21518)
@@ -29,12 +29,18 @@
 	} 
 	
 	@Override
-	public String toString() {
-		return "\"" + value + "\"";
+	public void toString(int depth, StringBuilder sb) {
+		if(depth == 0) {
+			sb.append("...");
+		} else {
+			sb.append('"');
+			sb.append(value);
+			sb.append('\"');
+		}
 	}
 
 	@Override
-	protected boolean simpleMatch(ATerm t) {
+	public boolean simpleMatch(ATerm t) {
 		if(!(t instanceof ATermString))
 			return false;
 		ATermString o = (ATermString)t;

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermTuple.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermTuple.java	Thu Dec 16 15:01:54 2010	(r21517)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermTuple.java	Thu Dec 16 15:02:04 2010	(r21518)
@@ -1,5 +1,7 @@
 package org.spoofax.jsglr.shared.terms;
 
+import org.spoofax.jsglr.client.NotImplementedException;
+
 public class ATermTuple extends ATerm {
 
 	private static final long serialVersionUID = 1L;
@@ -28,7 +30,7 @@
 	}
 
 	@Override
-	protected boolean simpleMatch(ATerm t) {
+	public boolean simpleMatch(ATerm t) {
 		if(!(t instanceof ATermTuple))
 			return false;
 		ATermTuple o = (ATermTuple)t;
@@ -36,8 +38,12 @@
 			return false;
 		for(int i = 0; i < elements.length; i++)
 			if(elements[i].equals(o.elements[i]))
-					return false;
+				return false;
 		return true;
 	}
 
+	@Override
+	protected void toString(int depth, StringBuilder sb) {
+		throw new NotImplementedException();
+	}
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/AllTests.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/AllTests.java	Thu Dec 16 15:01:54 2010	(r21517)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/AllTests.java	Thu Dec 16 15:02:04 2010	(r21518)
@@ -27,6 +27,8 @@
         suite.addTestSuite(TestG1.class);
         suite.addTestSuite(TestG2.class);
         suite.addTestSuite(TestStratego.class);
+        suite.addTestSuite(TestJava.class);
+        suite.addTestSuite(TestWebDSL.class);
         suite.addTestSuite(TestBooleans.class);
         //$JUnit-END$
         return suite;

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:01:54 2010	(r21517)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:02:04 2010	(r21518)
@@ -13,6 +13,7 @@
 
 import junit.framework.TestCase;
 
+import org.spoofax.jsglr.FileTools;
 import org.spoofax.jsglr.client.InvalidParseTableException;
 import org.spoofax.jsglr.client.ParseTable;
 import org.spoofax.jsglr.client.ParserException;
@@ -43,7 +44,7 @@
 		Tools.setLogging(false);
 		String fn = "tests/grammars/" + grammar + ".tbl";
 
-		ATerm result = pf.parseFromString(loadFileAsString(fn));
+		ATerm result = pf.parseFromString(FileTools.loadFileAsString(fn));
 		sglr = new SGLR(pf, new ParseTable(result));
 		//        parseTableService.fetchParseTable("tests/grammars/" + grammar + ".tbl",
 		//        		new AsyncCallback<ATerm>() {
@@ -66,17 +67,6 @@
 
 	}
 
-	private String loadFileAsString(String fn) {
-		char[] cbuf = new char[1024*1024*12];
-		try {
-			BufferedReader br = new BufferedReader(new FileReader(fn));
-			int len = br.read(cbuf);
-			return new String(cbuf, 0, len);
-		} catch (IOException e) {
-			e.printStackTrace();
-			return null;
-		}
-	}
 
 	@Override
 	protected void tearDown() throws Exception {
@@ -98,7 +88,7 @@
 		//
 		//			@Override
 		//			public void onSuccess(String result) {
-		String result = loadFileAsString("tests/data/" + s + "." + suffix);
+		String result = FileTools.loadFileAsString("tests/data/" + s + "." + suffix);
 		assertNotNull("Data file is missing", result);
 		long parseTime = System.nanoTime();
 		ATerm parsed = null;
@@ -121,8 +111,8 @@
 
 	private void doCompare(String s, final ATerm parsed) {
 		//parseTableService.readTermFromFile("tests/data/" + s + ".trm", new AsyncCallback<ATerm>() {
-		String loaded = loadFileAsString("tests/data/" + s + ".trm");
-
+		String x = FileTools.loadFileAsString("tests/data/" + s + ".trm");
+		ATerm wanted = parsed.getFactory().parse(x);
 		//			@Override
 		//			public void onFailure(Throwable caught) {
 		//				fail();
@@ -130,9 +120,11 @@
 		//
 		//			@Override
 		//			public void onSuccess(ATerm loaded) {
-		assertNotNull(loaded);
+		assertNotNull(x);
 
-		if(parsed.match(loaded) == null) {
+		System.out.println(parsed);
+		System.out.println(wanted);
+		if(!parsed.simpleMatch(wanted)) {
 			fail();
 		}
 		//			}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestJava.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestJava.java	Thu Dec 16 15:02:04 2010	(r21518)
@@ -0,0 +1,29 @@
+/*
+ * Created on 05.des.2005
+ *
+ * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
+ *
+ * Licensed under the GNU Lesser General Public License, v2.1
+ */
+package org.spoofax.jsglr.tests;
+
+import java.io.FileNotFoundException;
+import java.io.IOException;
+
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParserException;
+
+public class TestJava extends ParseTestCase {
+
+    @Override
+	public void gwtSetUp() throws ParserException, InvalidParseTableException {
+        super.gwtSetUp("Java-15", "java");
+    }
+
+    public void testJava0() throws FileNotFoundException, IOException { doParseTest("java0"); }
+//    public void testJava1() throws FileNotFoundException, IOException { doParseTest("java1"); }
+    public void testJava2() throws FileNotFoundException, IOException { doParseTest("java2"); }
+//    public void testJava3() throws FileNotFoundException, IOException { doParseTest("java3"); }
+    public void testJava4() throws FileNotFoundException, IOException { doParseTest("java4"); }
+    
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestWebDSL.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestWebDSL.java	Thu Dec 16 15:02:04 2010	(r21518)
@@ -0,0 +1,26 @@
+/*
+ * Created on 05.des.2005
+ *
+ * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
+ *
+ * Licensed under the GNU Lesser General Public License, v2.1
+ */
+package org.spoofax.jsglr.tests;
+
+import java.io.FileNotFoundException;
+import java.io.IOException;
+
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParserException;
+
+public class TestWebDSL extends ParseTestCase {
+
+    @Override
+	public void gwtSetUp() throws ParserException, InvalidParseTableException {
+        super.gwtSetUp("WebDSL", "app");
+    }
+
+    public void testWebDSL0() throws FileNotFoundException, IOException {
+        doParseTest("webdsl0");
+    }
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java0.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java0.java	Thu Dec 16 15:02:04 2010	(r21518)
@@ -0,0 +1,954 @@
+/*
+ * Created on 11.apr.2006
+ *
+ * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
+ * 
+ * Licensed under the GNU General Public License, v2
+ */
+package org.spoofax.jsglr;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+
+import aterm.AFun;
+import aterm.ATerm;
+
+public class Disambiguator {
+
+    private static final int FILTER_DRAW = 1;
+
+    private static final int FILTER_LEFT_WINS = 2;
+
+    private static final int FILTER_RIGHT_WINS = 3;
+
+    SGLR parser;
+
+    AmbiguityManager ambiguityManager;
+
+    ParseTable parseTable;
+
+    Map<AmbKey, IParseNode> resolvedTable;
+
+    Disambiguator(SGLR parser) {
+        this.parser = parser;
+        resolvedTable = new HashMap<AmbKey, IParseNode>();
+    }
+
+    private void initializeFromParser() {
+        parseTable = parser.getParseTable();
+        ambiguityManager = parser.getAmbiguityManager();
+    }
+
+    protected ATerm applyFilters(IParseNode root, String sort, int inputLength) throws SGLRException {
+        
+        if(SGLR.isDebugging()) {
+            Tools.debug("applyFilters()");
+        }
+        
+        initializeFromParser();
+
+        IParseNode t = root;
+
+        t = applyTopSortFilter(sort, t);
+
+        t = applyCycleDetectFilter(t);
+
+        t = applyOtherFilters(t);
+
+        return convertToATerm(t);
+        
+    }
+
+    private ATerm convertToATerm(IParseNode t) {
+        
+        if (SGLR.isDebugging()) {
+            Tools.debug("convertToATerm: ", t);
+        }
+
+        ambiguityManager.resetAmbiguityCount();
+        ATerm r = yieldTree(t);
+        
+        logStatus();
+        
+        int ambCount = ambiguityManager.getAmbiguitiesCount();
+        if (SGLR.isDebugging()) {
+            Tools.debug("yield: ", r);
+        }
+        final AFun parseTreeAfun = parseTable.getFactory().makeAFun("parsetree", 2, false);
+        return parseTable.getFactory().makeAppl(parseTreeAfun, r,
+                                                parseTable.getFactory().makeInt(ambCount));
+    }
+
+    private IParseNode applyOtherFilters(IParseNode t) throws FilterException {
+
+        if (SGLR.isDebugging()) {
+            Tools.debug("applyOtherFilters() - ", t);
+        }
+
+        if (parser.isFilteringEnabled()) {
+            t = disambiguate(t);
+        }
+        return t;
+    }
+
+    private IParseNode applyCycleDetectFilter(IParseNode t) throws FilterException {
+        
+        if (SGLR.isDebugging()) {
+            Tools.debug("applyCycleDetectFilter() - ", t);
+        }
+
+        if (parser.isDetectCyclesEnabled()) {
+            if (ambiguityManager.getMaxNumberOfAmbiguities() > 0) {
+                if (isCyclicTerm(t)) {
+                    throw new FilterException("Term is cyclic");
+                }
+            }
+        }
+
+        return t;
+    }
+
+    private IParseNode applyTopSortFilter(String sort, IParseNode t) throws SGLRException {
+
+        if (SGLR.isDebugging()) {
+            Tools.debug("applyTopSortFilter() - ", t);
+        }
+
+        if (sort != null) {
+            t = selectOnTopSort();
+            if (t == null) {
+                throw new FilterException("Desired top sort not found");
+            }
+        }
+        
+        return t;
+    }
+
+    private void logStatus() {
+        Tools.logger("Number of rejects: ", parser.getRejectCount());
+        Tools.logger("Number of reductions: ", parser.getReductionCount());
+        Tools.logger("Number of ambiguities: ", ambiguityManager.getMaxNumberOfAmbiguities());
+        Tools.logger("Number of calls to Amb: ", ambiguityManager.getAmbiguityCallsCount());
+        Tools.logger("Count Eagerness Comparisons: ", ambiguityManager.getEagernessComparisonCount(), " / ", ambiguityManager.getEagernessSucceededCount());
+        Tools.logger("Number of Injection Counts: ", ambiguityManager.getInjectionCount());
+    }
+
+    private ATerm yieldTree(IParseNode t) {
+        return t.toParseTree(parser.getParseTable());
+    }
+
+    private IParseNode disambiguate(IParseNode t) throws FilterException {
+        // SG_FilterTree
+        ambiguityManager.resetClustersVisitedCount();
+        return filterTree(t, false);
+    }
+
+    private IParseNode filterTree(IParseNode t, boolean inAmbiguityCluster) throws FilterException {
+        // SG_FilterTreeRecursive
+        if (SGLR.isDebugging()) {
+            Tools.debug("filterTree(node)    - ", t);
+        }
+
+        if (t instanceof Amb) {
+            if (!inAmbiguityCluster) {
+                List<IParseNode> ambs = ((Amb)t).getAlternatives();
+                t = filterAmbiguities(ambs);
+            } else {
+                throw new NotImplementedException();
+            }
+        } else if(t instanceof ParseNode) {
+            ParseNode node = (ParseNode) t;
+            List<IParseNode> args = node.getKids();
+            List<IParseNode> newArgs = filterTree(args, false);
+
+            if (isRejectFilterEnabled() && parseTable.hasRejects()) {
+                if (hasRejectProd(t))
+                    throw new FilterException("");
+            }
+
+            t = new ParseNode(node.label, newArgs);
+        } else if(t instanceof ParseProductionNode) {
+            // leaf node -- do thing (cannot be any ambiguities here)
+            return t;
+        } else {
+            throw new FatalException();
+        }
+
+        if (parser.isAssociativityFilterEnabled()) {
+            return applyAssociativityPriorityFilter(t);
+        } else {
+            return t;
+        }
+    }
+
+    private boolean isRejectFilterEnabled() {
+        return parser.isRejectFilterEnabled();
+    }
+
+    private List<IParseNode> filterTree(List<IParseNode> args, boolean inAmbiguityCluster) throws FilterException {
+
+        if(SGLR.isDebugging()) {
+            Tools.debug("filterTree(<nodes>) - ", args);
+        }
+        
+        List<IParseNode> newArgs = new LinkedList<IParseNode>();
+        boolean changed = false;
+
+        for (IParseNode n : args) {
+            IParseNode filtered = filterTree(n, false);
+            
+            changed = !filtered.equals(n) || changed;
+            newArgs.add(filtered);
+        }
+
+        /*
+         * FIXME Shouldn't we do some filtering here?
+        if (!changed) {
+            Tools.debug("Dropping: ", args);
+            newArgs = getEmptyList();
+        }*/
+
+        if (parser.isFilteringEnabled()) {
+            List<IParseNode> filtered = new ArrayList<IParseNode>();
+            for (IParseNode n : newArgs)
+                filtered.add(applyAssociativityPriorityFilter(n));
+            return filtered;
+        } else {
+            return newArgs;
+        }
+    }
+
+    private IParseNode applyAssociativityPriorityFilter(IParseNode t) throws FilterException {
+        // SG_Associativity_Priority_Filter(pt, t)   
+        // - ok
+        
+        if(SGLR.isDebugging()) {
+            Tools.debug("applyAssociativityPriorityFilter() - ", t);
+        }
+        
+        IParseNode r = t;
+
+        if (t instanceof ParseNode) {
+            Label prodLabel = getProductionLabel(t);
+            ParseNode n = (ParseNode) t;
+
+            if (parser.isAssociativityFilterEnabled()) {
+                if (prodLabel.isLeftAssociative()) {
+                    r = applyLeftAssociativeFilter(n, prodLabel);
+                } else if (prodLabel.isRightAssociative()) {
+                    r = applyRightAssociativeFilter(n, prodLabel);
+                }
+                
+            }
+
+            if (parser.isPriorityFilterEnabled()) {
+                if(Tools.debugging) { 
+                    Tools.debug(" - about to look up : ",  prodLabel.labelNumber);
+                }
+                
+                if (!lookupGtrPriority(prodLabel).isEmpty()) {
+                    if(Tools.debugging) {
+                        Tools.debug(" - found");
+                    }
+                    return applyPriorityFilter((ParseNode) r, prodLabel);
+                }
+                if(Tools.debugging) {
+                    Tools.debug(" - not found");
+                }
+            }
+        }
+
+        return r;
+    }
+
+    private IParseNode applyRightAssociativeFilter(ParseNode t, Label prodLabel) throws FilterException {
+        // SG_Right_Associativity_Filter(t, prodl)
+        // - almost ok
+        
+        if(SGLR.isDebugging()) {
+            Tools.debug("applyRightAssociativeFilter() - ", t);
+        }
+        
+        List<IParseNode> newAmbiguities = new LinkedList<IParseNode>();
+        List<IParseNode> kids = t.getKids();
+        IParseNode firstKid = kids.get(0);
+        
+        if(firstKid instanceof Amb) {
+            
+            List<IParseNode> ambs = ((Amb)firstKid).getAlternatives();
+            List<IParseNode> restKids = kids.subList(1, t.kids.size() - 1);
+            
+            for(IParseNode amb : ambs) {
+                if(((ParseNode)amb).getLabel() != prodLabel.labelNumber) {
+                    newAmbiguities.add(amb);
+                }
+            }
+        
+            // FIXME is this correct?
+            if(!newAmbiguities.isEmpty()) {
+                if(newAmbiguities.size() > 1)
+                    firstKid = new Amb(newAmbiguities);
+                else 
+                    firstKid = newAmbiguities.get(0);
+                restKids.add(firstKid);
+            } else {
+                throw new FilterException("");
+            }
+            
+            // FIXME is this correct?
+            return new ParseNode(t.label, restKids);
+            
+        } else if(firstKid instanceof ParseNode) {
+            if(((ParseNode)firstKid).getLabel() == prodLabel.labelNumber)
+                throw new FilterException("");
+        }
+        return t;
+    }
+
+    private IParseNode applyPriorityFilter(ParseNode t, Label prodLabel) throws FilterException {
+        // SG_Priority_Filter
+        // - fishy
+        
+        if(SGLR.isDebugging()) {
+            Tools.debug("applyPriorityFilter() - ", t);
+        }
+        
+        List<IParseNode> newAmbiguities = new ArrayList<IParseNode>();
+        List<IParseNode> kids = t.getKids();
+        List<IParseNode> newKids = new LinkedList<IParseNode>();
+        
+        int l0 = prodLabel.labelNumber;
+        int kidnumber = 0;
+
+        for (IParseNode alt : kids) {
+            IParseNode newKid = alt;
+            IParseNode injection = jumpOverInjections(alt);
+
+            if (injection instanceof Amb) {
+                List<IParseNode> ambs = ((Amb) injection).getAlternatives();
+
+                newAmbiguities.clear();
+                for (IParseNode amb : ambs) {
+                    IParseNode injAmb = jumpOverInjections(amb);
+
+                    if (injAmb instanceof ParseNode) {
+                        Label label = getProductionLabel(t);
+                        if(hasGreaterPriority(l0, label.labelNumber, kidnumber)) {
+                            newAmbiguities.add(amb);
+                        }
+                    }
+                }
+                
+                if(!newAmbiguities.isEmpty()) {
+                    IParseNode n = null;
+                    if(newAmbiguities.size() > 1) {
+                        n = new Amb(newAmbiguities);
+                    } else {
+                        n = newAmbiguities.get(0);
+                    }
+                    newKid = replaceUnderInjections(alt, injection, n);
+                } else {
+                    throw new FilterException("");
+                }
+            } else if (injection instanceof ParseNode) {
+                int l1 = ((ParseNode) injection).label;
+                if (hasGreaterPriority(l0, l1, kidnumber)) {
+                    throw new FilterException("");
+                }
+            }
+            
+            newKids.add(newKid);
+            kidnumber++;
+        }
+
+        return new ParseNode(t.label, newKids);
+    }
+
+    private IParseNode replaceUnderInjections(IParseNode alt, IParseNode injection, IParseNode n) {
+        // SG_Replace_Under_Injections
+        // - not ok
+        
+        throw new NotImplementedException();
+    }
+
+    private IParseNode jumpOverInjections(IParseNode t) {
+
+        if(SGLR.isDebugging()) {
+            Tools.debug("jumpOverInjections() - ", t);
+        }
+
+        if (t instanceof ParseNode) {
+            int prod = ((ParseNode) t).label;
+            ParseNode n = (ParseNode)t;
+            while (isUserDefinedLabel(prod)) {
+                List<IParseNode> kids = n.getKids();
+                IParseNode x = kids.get(0);
+                if(x instanceof ParseNode) {
+                    n = (ParseNode)x;
+                    prod = n.label; 
+                } else {
+                    return x;
+                }
+            }
+        }
+
+        return t;
+    }
+
+    // TODO: shouldn't this be called isInjection?
+    
+    private boolean isUserDefinedLabel(int prod) {
+        Label l = parseTable.lookupInjection(prod);
+        if(l == null)
+            return false;
+        return l.isInjection();
+    }
+
+    private boolean hasGreaterPriority(int l0, int l1, int arg) {
+        List<Priority> prios = lookupGtrPriority(parseTable.getLabel(l0));
+        	
+        for (Priority p : prios) {
+        	if (l1 == p.right)
+        		if (p.arg == -1 || p.arg == arg) {
+        			return true;
+        	}
+        }
+        return false;
+    }
+
+    private List<Priority> lookupGtrPriority(Label prodLabel) {
+        return parseTable.getPriorities(prodLabel);
+    }
+
+    private IParseNode applyLeftAssociativeFilter(ParseNode t, Label prodLabel) throws FilterException {
+        // SG_Right_Associativity_Filter()
+        
+        if(SGLR.isDebugging()) {
+            Tools.debug("applyLeftAssociativeFilter() - ", t);
+        }
+
+        List<IParseNode> newAmbiguities = new ArrayList<IParseNode>();
+        List<IParseNode> kids = t.getKids();
+        IParseNode last = kids.get(kids.size() - 1);
+
+        if (last instanceof Amb) {
+            List<IParseNode> rest = new ArrayList<IParseNode>();
+            rest.addAll(kids);
+            rest.remove(rest.size() - 1);
+
+            List<IParseNode> ambs = ((Amb) last).getAlternatives();
+            for (IParseNode amb : ambs) {
+                Label other = parseTable.getLabel(((ParseNode) amb).getLabel());
+                if (!prodLabel.equals(other)) {
+                    newAmbiguities.add(amb);
+                }
+            }
+
+            if (!newAmbiguities.isEmpty()) {
+                if (newAmbiguities.size() > 1) {
+                    last = new Amb(newAmbiguities);
+                } else {
+                    last = newAmbiguities.get(0);
+                }
+                rest.add(last);
+                return new Amb(rest);
+            } else {
+                throw new FilterException("");
+            }
+        } else if (last instanceof ParseNode) {
+            Label other = parseTable.getLabel(((ParseNode) last).getLabel());
+            if (prodLabel.equals(other)) {
+                throw new FilterException("");
+            }
+        }
+        
+        return t;
+    }
+
+    private Label getProductionLabel(IParseNode t) {
+        if (t instanceof ParseNode) {
+            return parseTable.getLabel(((ParseNode) t).getLabel());
+        } else if (t instanceof ParseProductionNode) {
+            return parseTable.getLabel(((ParseProductionNode) t).getProduction());
+        }
+        return null;
+    }
+
+    private boolean hasRejectProd(IParseNode t) {
+        return t instanceof ParseReject;
+    }
+
+    private IParseNode filterAmbiguities(List<IParseNode> ambs) throws FilterException {
+        // SG_FilterAmb
+        
+        if(SGLR.isDebugging()) {
+            Tools.debug("filterAmbiguities() - [", ambs.size(), "]");
+        }
+
+        List<IParseNode> newAmbiguities = new LinkedList<IParseNode>();
+
+        for (IParseNode amb : ambs) {
+            newAmbiguities.add(filterTree(amb, true));
+        }
+
+        if (newAmbiguities.size() > 1) {
+            /* Handle ambiguities inside this ambiguity cluster */
+            List<IParseNode> oldAmbiguities = new LinkedList<IParseNode>();
+            oldAmbiguities.addAll(newAmbiguities);
+            for (IParseNode amb : oldAmbiguities) {
+                if (newAmbiguities.remove(amb)) {
+                    newAmbiguities = filterAmbiguityList(newAmbiguities, amb);
+                }
+            }
+        }
+
+        if (newAmbiguities.isEmpty())
+            throw new FilterException("");
+
+        if (newAmbiguities.size() == 1)
+            return newAmbiguities.get(0);
+
+        return new Amb(newAmbiguities);
+    }
+
+    private List<IParseNode> filterAmbiguityList(List<IParseNode> ambiguities, IParseNode t) {
+        // SG_FilterAmbList
+        
+        boolean keepT = true;
+        List<IParseNode> r = new LinkedList<IParseNode>();
+
+        if (ambiguities.isEmpty()) {
+            r.add(t);
+            return r;
+        }
+
+        for (IParseNode amb : ambiguities) {
+
+            switch (filter(t, amb)) {
+            case FILTER_DRAW:
+                r.add(amb);
+                break;
+            case FILTER_RIGHT_WINS:
+                r.add(amb);
+                keepT = false;
+            }
+        }
+
+        if (keepT) {
+            r.add(t);
+        }
+
+        return r;
+    }
+
+    private int filter(IParseNode left, IParseNode right) {
+        // SG_Filter(t0, t1)
+        
+        if(SGLR.isDebugging()) {
+            Tools.debug("filter()");
+        }
+
+        if (left.equals(right)) {
+            return FILTER_LEFT_WINS;
+        }
+
+        // FIXME priority filter == preferences?
+        if (parser.isPriorityFilterEnabled() && parseTable.hasPriorities()) {
+            int r = filterOnIndirectPrefers(left, right);
+            if (r != FILTER_DRAW)
+                return r;
+        }
+        
+        if (parser.isPriorityFilterEnabled() && parseTable.hasPriorities()) {
+            int r = filterOnPreferCount(left, right);
+            if (r != FILTER_DRAW)
+                return r;
+        }
+
+        if (parser.isInjectionCountFilterEnabled()) {
+            int r = filterOnInjectionCount(left, right);
+            if (r != FILTER_DRAW)
+                return r;
+        }
+
+        return FILTER_DRAW;
+    }
+
+    private int filterOnInjectionCount(IParseNode left, IParseNode right) {
+
+        if(SGLR.isDebugging()) {
+            Tools.debug("filterOnInjectionCount()");
+        }
+
+        ambiguityManager.increaseInjectionCount();
+        
+        int leftInjectionCount = countAllInjections(left);
+        int rightInjectionCount = countAllInjections(right);
+
+        if (leftInjectionCount != rightInjectionCount) {
+            ambiguityManager.increaseInjectionFilterSucceededCount();
+        }
+
+        if (leftInjectionCount > rightInjectionCount) {
+            return FILTER_RIGHT_WINS;
+        } else if (rightInjectionCount > leftInjectionCount) {
+            return FILTER_LEFT_WINS;
+        }
+
+        return FILTER_DRAW;
+    }
+
+    private int countAllInjections(IParseNode t) {
+        // SG_CountAllInjectionsInTree
+        // - ok
+        if (t instanceof Amb) {
+            // Trick from forest.c
+            return countAllInjections(((Amb) t).getAlternatives().get(0));
+        } else if (t instanceof ParseNode) {
+            int c = getProductionLabel(t).isInjection() ? 1 : 0;
+            return c + countAllInjections(((ParseNode) t).getKids());
+        }
+        return 0;
+    }
+
+    private int countAllInjections(List<IParseNode> ls) {
+        // SG_CountAllInjectionsInTree
+        // - ok
+        int r = 0;
+        for (IParseNode n : ls)
+            r += countAllInjections(n);
+        return r;
+    }
+
+    private int filterOnPreferCount(IParseNode left, IParseNode right) {
+
+        if(SGLR.isDebugging()) {
+            Tools.debug("filterOnPreferCount()");
+        }
+
+        ambiguityManager.increaseEagernessFilterCalledCount();
+        
+        int r = FILTER_DRAW;
+        if (parseTable.hasPrefers() || parseTable.hasAvoids()) {
+            int leftPreferCount = countPrefers(left);
+            int rightPreferCount = countPrefers(right);
+            int leftAvoidCount = countAvoids(left);
+            int rightAvoidCount = countAvoids(right);
+
+            if ((leftPreferCount > rightPreferCount && leftAvoidCount <= rightAvoidCount)
+                    || (leftPreferCount == rightPreferCount && leftAvoidCount < rightAvoidCount)) {
+                Tools.logger("Eagerness priority: ", left, " > ", right);
+                r = FILTER_LEFT_WINS;
+            }
+
+            if ((rightPreferCount > leftPreferCount && rightAvoidCount <= leftAvoidCount)
+                    || (rightPreferCount == leftPreferCount && rightAvoidCount < leftPreferCount)) {
+                if (r != FILTER_DRAW) {
+                    Tools.logger("Symmetric eagerness priority: ", left, " == ", right);
+                    r = FILTER_DRAW;
+                } else {
+                    Tools.logger("Eagerness priority: ", right, " > ", left);
+                    r = FILTER_RIGHT_WINS;
+                }
+            }
+        }
+
+        if (r != FILTER_DRAW) {
+            ambiguityManager.increaseEagernessFilterSucceededCount();
+        }
+
+        return r;
+    }
+
+    private int countPrefers(IParseNode t) {
+        // SG_CountPrefersInTree
+        // - ok
+        if (t instanceof Amb) {
+            return countPrefers(((Amb) t).getAlternatives());
+        } else if (t instanceof ParseNode) {
+            int type = getProductionType(t);
+            if (type == ProductionAttributes.PREFER)
+                return 1;
+            else if (type == ProductionAttributes.AVOID)
+                return 0;
+            return countPrefers(((ParseNode) t).getKids());
+        }
+        return 0;
+    }
+
+    private int countPrefers(List<IParseNode> ls) {
+        // SG_CountPrefersInTree
+        // - ok
+        int r = 0;
+        for (IParseNode n : ls)
+            r += countPrefers(n);
+        return r;
+    }
+
+    private int countAvoids(IParseNode t) {
+        // SG_CountAvoidsInTree
+        // - ok
+        if (t instanceof Amb) {
+            return countAvoids(((Amb) t).getAlternatives());
+        } else if (t instanceof ParseNode) {
+            int type = getProductionType(t);
+            if (type == ProductionAttributes.PREFER)
+                return 0;
+            else if (type == ProductionAttributes.AVOID)
+                return 1;
+            return countAvoids(((ParseNode) t).getKids());
+        }
+        return 0;
+    }
+
+    private int countAvoids(List<IParseNode> ls) {
+        // SG_CountAvoidsInTree
+        // - ok
+        int r = 0;
+        for (IParseNode n : ls)
+            r += countAvoids(n);
+        return r;
+    }
+
+    private int filterOnIndirectPrefers(IParseNode left, IParseNode right) {
+        // SG_Indirect_Eagerness_Filter
+        
+        if(SGLR.isDebugging()) {
+            Tools.debug("filterOnIndirectPrefers()");
+        }
+
+        if (left instanceof Amb || right instanceof Amb)
+            return FILTER_DRAW;
+
+        if (!left.equals(right))
+            return filterOnDirectPrefers(left, right);
+
+        ParseNode l = (ParseNode) left;
+        ParseNode r = (ParseNode) right;
+
+        List<IParseNode> leftArgs = l.getKids();
+        List<IParseNode> rightArgs = r.getKids();
+
+        int diffs = computeDistinctArguments(leftArgs, rightArgs);
+
+        if (diffs == 1) {
+            for (int i = 0; i < leftArgs.size(); i++) {
+                IParseNode leftArg = leftArgs.get(i);
+                IParseNode rightArg = rightArgs.get(i);
+
+                if (!leftArg.equals(rightArg)) {
+                    return filterOnIndirectPrefers(leftArg, rightArg);
+                }
+            }
+
+        }
+        return FILTER_DRAW;
+    }
+
+    private int filterOnDirectPrefers(IParseNode left, IParseNode right) {
+        // SG_Direct_Eagerness_Filter
+        
+        if(SGLR.isDebugging()) {
+            Tools.debug("filterOnDirectPrefers()");
+        }
+
+        if (isLeftMoreEager(left, right))
+            return FILTER_LEFT_WINS;
+        if (isLeftMoreEager(right, left))
+            return FILTER_RIGHT_WINS;
+
+        return FILTER_DRAW;
+    }
+
+    private boolean isLeftMoreEager(IParseNode left, IParseNode right) {
+
+        if (isMoreEager(left, right))
+            return true;
+
+        IParseNode newLeft = jumpOverInjectionsModuloEagerness(left);
+        IParseNode newRight = jumpOverInjectionsModuloEagerness(right);
+
+        if (newLeft instanceof ParseNode && newRight instanceof ParseNode)
+            return isMoreEager(left, right);
+
+        return false;
+    }
+
+    private IParseNode jumpOverInjectionsModuloEagerness(IParseNode t) {
+
+        if(SGLR.isDebugging()) {
+            Tools.debug("jumpOverInjectionsModuloEagerness()");
+        }
+
+        int prodType = getProductionType(t);
+
+        if (t instanceof ParseNode && prodType != ProductionAttributes.PREFER
+                && prodType != ProductionAttributes.AVOID) {
+
+            Label prod = getLabel(t);
+            ParseNode n = (ParseNode) t;
+
+            while (prod.isInjection()) {
+                IParseNode x = n.getKids().get(0);
+
+                int prodTypeX = getProductionType(x);
+
+                if (x instanceof ParseNode && prodTypeX != ProductionAttributes.PREFER
+                        && prodTypeX != ProductionAttributes.AVOID) {
+                    prod = getLabel(x);
+                } else {
+                    return n;
+                }
+            }
+        }
+        return t;
+    }
+
+    private Label getLabel(IParseNode t) {
+        if (t instanceof ParseNode) {
+            ParseNode n = (ParseNode) t;
+            return parseTable.getLabel(n.label);
+        } else if (t instanceof ParseProductionNode) {
+            ParseProductionNode n = (ParseProductionNode) t;
+            return parseTable.getLabel(n.prod);
+        }
+        return null;
+    }
+
+    private int getProductionType(IParseNode t) {
+        return getLabel(t).getAttributes().type;
+    }
+
+    private boolean isMoreEager(IParseNode left, IParseNode right) {
+        int leftLabel = ((ParseNode) left).getLabel();
+        int rightLabel = ((ParseNode) right).getLabel();
+
+        Label leftProd = parseTable.getLabel(leftLabel);
+        Label rightProd = parseTable.getLabel(rightLabel);
+
+        if (leftProd.isMoreEager(rightProd))
+            return true;
+
+        return false;
+    }
+
+    private int computeDistinctArguments(List<IParseNode> leftArgs, List<IParseNode> rightArgs) {
+        // countDistinctArguments
+        int r = 0;
+        for (int i = 0; i < leftArgs.size(); i++) {
+            if (!leftArgs.equals(rightArgs))
+                r++;
+        }
+        return r;
+    }
+
+    private boolean isCyclicTerm(IParseNode t) {
+
+        ambiguityManager.dumpIndexTable();
+
+        List<IParseNode> cycles = computeCyclicTerm(t);
+
+        return cycles != null && cycles.size() > 0;
+    }
+
+    private List<IParseNode> computeCyclicTerm(IParseNode t) {
+        // FIXME rewrite to use HashMap and object id
+        PositionMap visited = new PositionMap(ambiguityManager.getMaxNumberOfAmbiguities());
+
+        ambiguityManager.resetAmbiguityCount();
+
+        return computeCyclicTerm(t, false, visited);
+    }
+
+    private List<IParseNode> computeCyclicTerm(IParseNode t, boolean inAmbiguityCluster,
+            PositionMap visited) {
+
+        if (SGLR.isDebugging()) {
+            Tools.debug("computeCyclicTerm() - ", t);
+        }
+
+        if (t instanceof ParseProductionNode) {
+            if (SGLR.isDebugging()) {
+                Tools.debug(" bumping");
+            }
+            return null;
+        } else if (t instanceof ParseNode) {
+            //Amb ambiguities = null;
+            List<IParseNode> cycle = null;
+            //int clusterIndex;
+            ParseNode n = (ParseNode) t;
+
+            if (inAmbiguityCluster) {
+                cycle = computeCyclicTerm(n.getKids(), false, visited);
+            } else {
+                /*
+                if (ambiguityManager.isInputAmbiguousAt(parseTreePosition)) {
+                    ambiguityManager.increaseAmbiguityCount();
+                    clusterIndex = ambiguityManager.getClusterIndex(t, parseTreePosition);
+                    if (SGLR.isDebugging()) {
+                        Tools.debug(" - clusterIndex : ", clusterIndex);
+                    }
+                    if (markMap.isMarked(clusterIndex)) {
+                        return new ArrayList<IParseNode>();
+                    }
+                    ambiguities = ambiguityManager.getClusterOnIndex(clusterIndex);
+                } else {
+                    clusterIndex = -1;
+                }*/
+                
+                throw new NotImplementedException();
+/*
+                if (ambiguities == null) {
+                    cycle = computeCyclicTerm(((ParseNode) t).getKids(), false, visited);
+                } else {
+                    int length = visited.getValue(clusterIndex);
+                    int savePos = parseTreePosition;
+
+                    if (length == -1) {
+                        //markMap.mark(clusterIndex);
+                        cycle = computeCyclicTermInAmbiguityCluster(ambiguities, visited);
+                        visited.put(clusterIndex, parseTreePosition - savePos);
+                        //markMap.unmark(clusterIndex);
+                    } else {
+                        parseTreePosition += length;
+                    }
+                }
+ */
+            }
+            return cycle;
+        } else {
+            throw new FatalException();
+        }
+    }
+
+    /*
+    private List<IParseNode> computeCyclicTermInAmbiguityCluster(Amb ambiguities,
+            PositionMap visited) {
+
+        for (IParseNode n : ambiguities.getAlternatives()) {
+            List<IParseNode> cycle = computeCyclicTerm(n, true, visited);
+            if (cycle != null)
+                return cycle;
+        }
+        return null;
+    }
+     */
+    
+    private List<IParseNode> computeCyclicTerm(List<IParseNode> kids, boolean b, PositionMap visited) {
+
+        for (IParseNode kid : kids) {
+            List<IParseNode> cycle = computeCyclicTerm(kid, false, visited);
+            if (cycle != null)
+                return cycle;
+        }
+        return null;
+    }
+
+    private IParseNode selectOnTopSort() {
+        throw new NotImplementedException();
+    }
+
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java1.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java1.java	Thu Dec 16 15:02:04 2010	(r21518)
@@ -0,0 +1,18960 @@
+package parser.ast;
+
+public abstract class AbstractVisitor  
+{ 
+  public abstract void unimplementedVisitor(java.lang.String source);
+
+  public boolean preVisit(ASTNode node)
+  { 
+    return true;
+  }
+
+  public void postVisit(ASTNode node)
+  { }
+
+  public void endVisit(Ws node)
+  { 
+    unimplementedVisitor("endVisit(" + "Ws" + ")");
+  }
+
+  public boolean visit(Ws node)
+  { 
+    unimplementedVisitor("visit(" + "Ws" + ")");
+    return true;
+  }
+
+  public void endVisit(ShortCom node)
+  { 
+    unimplementedVisitor("endVisit(" + "ShortCom" + ")");
+  }
+
+  public boolean visit(ShortCom node)
+  { 
+    unimplementedVisitor("visit(" + "ShortCom" + ")");
+    return true;
+  }
+
+  public void endVisit(LongCom node)
+  { 
+    unimplementedVisitor("endVisit(" + "LongCom" + ")");
+  }
+
+  public boolean visit(LongCom node)
+  { 
+    unimplementedVisitor("visit(" + "LongCom" + ")");
+    return true;
+  }
+
+  public void endVisit(Eof node)
+  { 
+    unimplementedVisitor("endVisit(" + "Eof" + ")");
+  }
+
+  public boolean visit(Eof node)
+  { 
+    unimplementedVisitor("visit(" + "Eof" + ")");
+    return true;
+  }
+
+  public void endVisit(CommChar node)
+  { 
+    unimplementedVisitor("endVisit(" + "CommChar" + ")");
+  }
+
+  public boolean visit(CommChar node)
+  { 
+    unimplementedVisitor("visit(" + "CommChar" + ")");
+    return true;
+  }
+
+  public void endVisit(Asterisk node)
+  { 
+    unimplementedVisitor("endVisit(" + "Asterisk" + ")");
+  }
+
+  public boolean visit(Asterisk node)
+  { 
+    unimplementedVisitor("visit(" + "Asterisk" + ")");
+    return true;
+  }
+
+  public void endVisit(ModName_StrategoHost node)
+  { 
+    unimplementedVisitor("endVisit(" + "ModName_StrategoHost" + ")");
+  }
+
+  public boolean visit(ModName_StrategoHost node)
+  { 
+    unimplementedVisitor("visit(" + "ModName_StrategoHost" + ")");
+    return true;
+  }
+
+  public void endVisit(ModNamePart_StrategoHost node)
+  { 
+    unimplementedVisitor("endVisit(" + "ModNamePart_StrategoHost" + ")");
+  }
+
+  public boolean visit(ModNamePart_StrategoHost node)
+  { 
+    unimplementedVisitor("visit(" + "ModNamePart_StrategoHost" + ")");
+    return true;
+  }
+
+  public void endVisit(Id_StrategoHost node)
+  { 
+    unimplementedVisitor("endVisit(" + "Id_StrategoHost" + ")");
+  }
+
+  public boolean visit(Id_StrategoHost node)
+  { 
+    unimplementedVisitor("visit(" + "Id_StrategoHost" + ")");
+    return true;
+  }
+
+  public void endVisit(LId_StrategoHost node)
+  { 
+    unimplementedVisitor("endVisit(" + "LId_StrategoHost" + ")");
+  }
+
+  public boolean visit(LId_StrategoHost node)
+  { 
+    unimplementedVisitor("visit(" + "LId_StrategoHost" + ")");
+    return true;
+  }
+
+  public void endVisit(LCID_StrategoHost node)
+  { 
+    unimplementedVisitor("endVisit(" + "LCID_StrategoHost" + ")");
+  }
+
+  public boolean visit(LCID_StrategoHost node)
+  { 
+    unimplementedVisitor("visit(" + "LCID_StrategoHost" + ")");
+    return true;
+  }
+
+  public void endVisit(UCID_StrategoHost node)
+  { 
+    unimplementedVisitor("endVisit(" + "UCID_StrategoHost" + ")");
+  }
+
+  public boolean visit(UCID_StrategoHost node)
+  { 
+    unimplementedVisitor("visit(" + "UCID_StrategoHost" + ")");
+    return true;
+  }
+
+  public void endVisit(Keyword_StrategoHost node)
+  { 
+    unimplementedVisitor("endVisit(" + "Keyword_StrategoHost" + ")");
+  }
+
+  public boolean visit(Keyword_StrategoHost node)
+  { 
+    unimplementedVisitor("visit(" + "Keyword_StrategoHost" + ")");
+    return true;
+  }
+
+  public void endVisit(Int_StrategoHost node)
+  { 
+    unimplementedVisitor("endVisit(" + "Int_StrategoHost" + ")");
+  }
+
+  public boolean visit(Int_StrategoHost node)
+  { 
+    unimplementedVisitor("visit(" + "Int_StrategoHost" + ")");
+    return true;
+  }
+
+  public void endVisit(Real_StrategoHost node)
+  { 
+    unimplementedVisitor("endVisit(" + "Real_StrategoHost" + ")");
+  }
+
+  public boolean visit(Real_StrategoHost node)
+  { 
+    unimplementedVisitor("visit(" + "Real_StrategoHost" + ")");
+    return true;
+  }
+
+  public void endVisit(String_StrategoHost node)
+  { 
+    unimplementedVisitor("endVisit(" + "String_StrategoHost" + ")");
+  }
+
+  public boolean visit(String_StrategoHost node)
+  { 
+    unimplementedVisitor("visit(" + "String_StrategoHost" + ")");
+    return true;
+  }
+
+  public void endVisit(StrChar_StrategoHost node)
+  { 
+    unimplementedVisitor("endVisit(" + "StrChar_StrategoHost" + ")");
+  }
+
+  public boolean visit(StrChar_StrategoHost node)
+  { 
+    unimplementedVisitor("visit(" + "StrChar_StrategoHost" + ")");
+    return true;
+  }
+
+  public void endVisit(Char_StrategoHost node)
+  { 
+    unimplementedVisitor("endVisit(" + "Char_StrategoHost" + ")");
+  }
+
+  public boolean visit(Char_StrategoHost node)
+  { 
+    unimplementedVisitor("visit(" + "Char_StrategoHost" + ")");
+    return true;
+  }
+
+  public void endVisit(CharChar_StrategoHost node)
+  { 
+    unimplementedVisitor("endVisit(" + "CharChar_StrategoHost" + ")");
+  }
+
+  public boolean visit(CharChar_StrategoHost node)
+  { 
+    unimplementedVisitor("visit(" + "CharChar_StrategoHost" + ")");
+    return true;
+  }
+
+  public void endVisit(Var0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Var0" + ")");
+  }
+
+  public boolean visit(Var0 node)
+  { 
+    unimplementedVisitor("visit(" + "Var0" + ")");
+    return true;
+  }
+
+  public void endVisit(ID_StrategoHost0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ID_StrategoHost0" + ")");
+  }
+
+  public boolean visit(ID_StrategoHost0 node)
+  { 
+    unimplementedVisitor("visit(" + "ID_StrategoHost0" + ")");
+    return true;
+  }
+
+  public void endVisit(PreTerm_StrategoHost node)
+  { 
+    unimplementedVisitor("endVisit(" + "PreTerm_StrategoHost" + ")");
+  }
+
+  public boolean visit(PreTerm_StrategoHost node)
+  { 
+    unimplementedVisitor("visit(" + "PreTerm_StrategoHost" + ")");
+    return true;
+  }
+
+  public void endVisit(Term_StrategoHost node)
+  { 
+    unimplementedVisitor("endVisit(" + "Term_StrategoHost" + ")");
+  }
+
+  public boolean visit(Term_StrategoHost node)
+  { 
+    unimplementedVisitor("visit(" + "Term_StrategoHost" + ")");
+    return true;
+  }
+
+  public void endVisit(Wld0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Wld0" + ")");
+  }
+
+  public boolean visit(Wld0 node)
+  { 
+    unimplementedVisitor("visit(" + "Wld0" + ")");
+    return true;
+  }
+
+  public void endVisit(Wld node)
+  { 
+    unimplementedVisitor("endVisit(" + "Wld" + ")");
+  }
+
+  public boolean visit(Wld node)
+  { 
+    unimplementedVisitor("visit(" + "Wld" + ")");
+    return true;
+  }
+
+  public void endVisit(Int0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Int0" + ")");
+  }
+
+  public boolean visit(Int0 node)
+  { 
+    unimplementedVisitor("visit(" + "Int0" + ")");
+    return true;
+  }
+
+  public void endVisit(Real node)
+  { 
+    unimplementedVisitor("endVisit(" + "Real" + ")");
+  }
+
+  public boolean visit(Real node)
+  { 
+    unimplementedVisitor("visit(" + "Real" + ")");
+    return true;
+  }
+
+  public void endVisit(Str node)
+  { 
+    unimplementedVisitor("endVisit(" + "Str" + ")");
+  }
+
+  public boolean visit(Str node)
+  { 
+    unimplementedVisitor("visit(" + "Str" + ")");
+    return true;
+  }
+
+  public void endVisit(Op node)
+  { 
+    unimplementedVisitor("endVisit(" + "Op" + ")");
+  }
+
+  public boolean visit(Op node)
+  { 
+    unimplementedVisitor("visit(" + "Op" + ")");
+    return true;
+  }
+
+  public void endVisit(OpQ node)
+  { 
+    unimplementedVisitor("endVisit(" + "OpQ" + ")");
+  }
+
+  public boolean visit(OpQ node)
+  { 
+    unimplementedVisitor("visit(" + "OpQ" + ")");
+    return true;
+  }
+
+  public void endVisit(Explode node)
+  { 
+    unimplementedVisitor("endVisit(" + "Explode" + ")");
+  }
+
+  public boolean visit(Explode node)
+  { 
+    unimplementedVisitor("visit(" + "Explode" + ")");
+    return true;
+  }
+
+  public void endVisit(Anno0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Anno0" + ")");
+  }
+
+  public boolean visit(Anno0 node)
+  { 
+    unimplementedVisitor("visit(" + "Anno0" + ")");
+    return true;
+  }
+
+  public void endVisit(As0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "As0" + ")");
+  }
+
+  public boolean visit(As0 node)
+  { 
+    unimplementedVisitor("visit(" + "As0" + ")");
+    return true;
+  }
+
+  public void endVisit(As node)
+  { 
+    unimplementedVisitor("endVisit(" + "As" + ")");
+  }
+
+  public boolean visit(As node)
+  { 
+    unimplementedVisitor("visit(" + "As" + ")");
+    return true;
+  }
+
+  public void endVisit(Sorts node)
+  { 
+    unimplementedVisitor("endVisit(" + "Sorts" + ")");
+  }
+
+  public boolean visit(Sorts node)
+  { 
+    unimplementedVisitor("visit(" + "Sorts" + ")");
+    return true;
+  }
+
+  public void endVisit(Constructors node)
+  { 
+    unimplementedVisitor("endVisit(" + "Constructors" + ")");
+  }
+
+  public boolean visit(Constructors node)
+  { 
+    unimplementedVisitor("visit(" + "Constructors" + ")");
+    return true;
+  }
+
+  public void endVisit(SortVar node)
+  { 
+    unimplementedVisitor("endVisit(" + "SortVar" + ")");
+  }
+
+  public boolean visit(SortVar node)
+  { 
+    unimplementedVisitor("visit(" + "SortVar" + ")");
+    return true;
+  }
+
+  public void endVisit(SortNoArgs node)
+  { 
+    unimplementedVisitor("endVisit(" + "SortNoArgs" + ")");
+  }
+
+  public boolean visit(SortNoArgs node)
+  { 
+    unimplementedVisitor("visit(" + "SortNoArgs" + ")");
+    return true;
+  }
+
+  public void endVisit(Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Sort" + ")");
+  }
+
+  public boolean visit(Sort node)
+  { 
+    unimplementedVisitor("visit(" + "Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(OpDecl node)
+  { 
+    unimplementedVisitor("endVisit(" + "OpDecl" + ")");
+  }
+
+  public boolean visit(OpDecl node)
+  { 
+    unimplementedVisitor("visit(" + "OpDecl" + ")");
+    return true;
+  }
+
+  public void endVisit(OpDeclQ node)
+  { 
+    unimplementedVisitor("endVisit(" + "OpDeclQ" + ")");
+  }
+
+  public boolean visit(OpDeclQ node)
+  { 
+    unimplementedVisitor("visit(" + "OpDeclQ" + ")");
+    return true;
+  }
+
+  public void endVisit(OpDeclInj node)
+  { 
+    unimplementedVisitor("endVisit(" + "OpDeclInj" + ")");
+  }
+
+  public boolean visit(OpDeclInj node)
+  { 
+    unimplementedVisitor("visit(" + "OpDeclInj" + ")");
+    return true;
+  }
+
+  public void endVisit(ConstType node)
+  { 
+    unimplementedVisitor("endVisit(" + "ConstType" + ")");
+  }
+
+  public boolean visit(ConstType node)
+  { 
+    unimplementedVisitor("visit(" + "ConstType" + ")");
+    return true;
+  }
+
+  public void endVisit(FunType node)
+  { 
+    unimplementedVisitor("endVisit(" + "FunType" + ")");
+  }
+
+  public boolean visit(FunType node)
+  { 
+    unimplementedVisitor("visit(" + "FunType" + ")");
+    return true;
+  }
+
+  public void endVisit(ArgType node)
+  { 
+    unimplementedVisitor("endVisit(" + "ArgType" + ")");
+  }
+
+  public boolean visit(ArgType node)
+  { 
+    unimplementedVisitor("visit(" + "ArgType" + ")");
+    return true;
+  }
+
+  public void endVisit(ArgType_StrategoHost node)
+  { 
+    unimplementedVisitor("endVisit(" + "ArgType_StrategoHost" + ")");
+  }
+
+  public boolean visit(ArgType_StrategoHost node)
+  { 
+    unimplementedVisitor("visit(" + "ArgType_StrategoHost" + ")");
+    return true;
+  }
+
+  public void endVisit(RetType_StrategoHost node)
+  { 
+    unimplementedVisitor("endVisit(" + "RetType_StrategoHost" + ")");
+  }
+
+  public boolean visit(RetType_StrategoHost node)
+  { 
+    unimplementedVisitor("visit(" + "RetType_StrategoHost" + ")");
+    return true;
+  }
+
+  public void endVisit(Type_StrategoHost0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Type_StrategoHost0" + ")");
+  }
+
+  public boolean visit(Type_StrategoHost0 node)
+  { 
+    unimplementedVisitor("visit(" + "Type_StrategoHost0" + ")");
+    return true;
+  }
+
+  public void endVisit(Type_StrategoHost node)
+  { 
+    unimplementedVisitor("endVisit(" + "Type_StrategoHost" + ")");
+  }
+
+  public boolean visit(Type_StrategoHost node)
+  { 
+    unimplementedVisitor("visit(" + "Type_StrategoHost" + ")");
+    return true;
+  }
+
+  public void endVisit(Def_StrategoHost0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Def_StrategoHost0" + ")");
+  }
+
+  public boolean visit(Def_StrategoHost0 node)
+  { 
+    unimplementedVisitor("visit(" + "Def_StrategoHost0" + ")");
+    return true;
+  }
+
+  public void endVisit(SVar node)
+  { 
+    unimplementedVisitor("endVisit(" + "SVar" + ")");
+  }
+
+  public boolean visit(SVar node)
+  { 
+    unimplementedVisitor("visit(" + "SVar" + ")");
+    return true;
+  }
+
+  public void endVisit(Let node)
+  { 
+    unimplementedVisitor("endVisit(" + "Let" + ")");
+  }
+
+  public boolean visit(Let node)
+  { 
+    unimplementedVisitor("visit(" + "Let" + ")");
+    return true;
+  }
+
+  public void endVisit(CallT node)
+  { 
+    unimplementedVisitor("endVisit(" + "CallT" + ")");
+  }
+
+  public boolean visit(CallT node)
+  { 
+    unimplementedVisitor("visit(" + "CallT" + ")");
+    return true;
+  }
+
+  public void endVisit(CallDynamic node)
+  { 
+    unimplementedVisitor("endVisit(" + "CallDynamic" + ")");
+  }
+
+  public boolean visit(CallDynamic node)
+  { 
+    unimplementedVisitor("visit(" + "CallDynamic" + ")");
+    return true;
+  }
+
+  public void endVisit(SDefT node)
+  { 
+    unimplementedVisitor("endVisit(" + "SDefT" + ")");
+  }
+
+  public boolean visit(SDefT node)
+  { 
+    unimplementedVisitor("visit(" + "SDefT" + ")");
+    return true;
+  }
+
+  public void endVisit(ExtSDefInl node)
+  { 
+    unimplementedVisitor("endVisit(" + "ExtSDefInl" + ")");
+  }
+
+  public boolean visit(ExtSDefInl node)
+  { 
+    unimplementedVisitor("visit(" + "ExtSDefInl" + ")");
+    return true;
+  }
+
+  public void endVisit(ExtSDef node)
+  { 
+    unimplementedVisitor("endVisit(" + "ExtSDef" + ")");
+  }
+
+  public boolean visit(ExtSDef node)
+  { 
+    unimplementedVisitor("visit(" + "ExtSDef" + ")");
+    return true;
+  }
+
+  public void endVisit(VarDec1 node)
+  { 
+    unimplementedVisitor("endVisit(" + "VarDec1" + ")");
+  }
+
+  public boolean visit(VarDec1 node)
+  { 
+    unimplementedVisitor("visit(" + "VarDec1" + ")");
+    return true;
+  }
+
+  public void endVisit(ParenStrat node)
+  { 
+    unimplementedVisitor("endVisit(" + "ParenStrat" + ")");
+  }
+
+  public boolean visit(ParenStrat node)
+  { 
+    unimplementedVisitor("visit(" + "ParenStrat" + ")");
+    return true;
+  }
+
+  public void endVisit(Fail node)
+  { 
+    unimplementedVisitor("endVisit(" + "Fail" + ")");
+  }
+
+  public boolean visit(Fail node)
+  { 
+    unimplementedVisitor("visit(" + "Fail" + ")");
+    return true;
+  }
+
+  public void endVisit(Id0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Id0" + ")");
+  }
+
+  public boolean visit(Id0 node)
+  { 
+    unimplementedVisitor("visit(" + "Id0" + ")");
+    return true;
+  }
+
+  public void endVisit(Match node)
+  { 
+    unimplementedVisitor("endVisit(" + "Match" + ")");
+  }
+
+  public boolean visit(Match node)
+  { 
+    unimplementedVisitor("visit(" + "Match" + ")");
+    return true;
+  }
+
+  public void endVisit(Build node)
+  { 
+    unimplementedVisitor("endVisit(" + "Build" + ")");
+  }
+
+  public boolean visit(Build node)
+  { 
+    unimplementedVisitor("visit(" + "Build" + ")");
+    return true;
+  }
+
+  public void endVisit(Scope node)
+  { 
+    unimplementedVisitor("endVisit(" + "Scope" + ")");
+  }
+
+  public boolean visit(Scope node)
+  { 
+    unimplementedVisitor("visit(" + "Scope" + ")");
+    return true;
+  }
+
+  public void endVisit(Seq node)
+  { 
+    unimplementedVisitor("endVisit(" + "Seq" + ")");
+  }
+
+  public boolean visit(Seq node)
+  { 
+    unimplementedVisitor("visit(" + "Seq" + ")");
+    return true;
+  }
+
+  public void endVisit(GuardedLChoice node)
+  { 
+    unimplementedVisitor("endVisit(" + "GuardedLChoice" + ")");
+  }
+
+  public boolean visit(GuardedLChoice node)
+  { 
+    unimplementedVisitor("visit(" + "GuardedLChoice" + ")");
+    return true;
+  }
+
+  public void endVisit(StrategyMid_StrategoHost node)
+  { 
+    unimplementedVisitor("endVisit(" + "StrategyMid_StrategoHost" + ")");
+  }
+
+  public boolean visit(StrategyMid_StrategoHost node)
+  { 
+    unimplementedVisitor("visit(" + "StrategyMid_StrategoHost" + ")");
+    return true;
+  }
+
+  public void endVisit(PrimT node)
+  { 
+    unimplementedVisitor("endVisit(" + "PrimT" + ")");
+  }
+
+  public boolean visit(PrimT node)
+  { 
+    unimplementedVisitor("visit(" + "PrimT" + ")");
+    return true;
+  }
+
+  public void endVisit(Some node)
+  { 
+    unimplementedVisitor("endVisit(" + "Some" + ")");
+  }
+
+  public boolean visit(Some node)
+  { 
+    unimplementedVisitor("visit(" + "Some" + ")");
+    return true;
+  }
+
+  public void endVisit(One node)
+  { 
+    unimplementedVisitor("endVisit(" + "One" + ")");
+  }
+
+  public boolean visit(One node)
+  { 
+    unimplementedVisitor("visit(" + "One" + ")");
+    return true;
+  }
+
+  public void endVisit(All node)
+  { 
+    unimplementedVisitor("endVisit(" + "All" + ")");
+  }
+
+  public boolean visit(All node)
+  { 
+    unimplementedVisitor("visit(" + "All" + ")");
+    return true;
+  }
+
+  public void endVisit(ImportTerm node)
+  { 
+    unimplementedVisitor("endVisit(" + "ImportTerm" + ")");
+  }
+
+  public boolean visit(ImportTerm node)
+  { 
+    unimplementedVisitor("visit(" + "ImportTerm" + ")");
+    return true;
+  }
+
+  public void endVisit(Module node)
+  { 
+    unimplementedVisitor("endVisit(" + "Module" + ")");
+  }
+
+  public boolean visit(Module node)
+  { 
+    unimplementedVisitor("visit(" + "Module" + ")");
+    return true;
+  }
+
+  public void endVisit(Specification node)
+  { 
+    unimplementedVisitor("endVisit(" + "Specification" + ")");
+  }
+
+  public boolean visit(Specification node)
+  { 
+    unimplementedVisitor("visit(" + "Specification" + ")");
+    return true;
+  }
+
+  public void endVisit(Imports node)
+  { 
+    unimplementedVisitor("endVisit(" + "Imports" + ")");
+  }
+
+  public boolean visit(Imports node)
+  { 
+    unimplementedVisitor("visit(" + "Imports" + ")");
+    return true;
+  }
+
+  public void endVisit(Strategies node)
+  { 
+    unimplementedVisitor("endVisit(" + "Strategies" + ")");
+  }
+
+  public boolean visit(Strategies node)
+  { 
+    unimplementedVisitor("visit(" + "Strategies" + ")");
+    return true;
+  }
+
+  public void endVisit(Signature node)
+  { 
+    unimplementedVisitor("endVisit(" + "Signature" + ")");
+  }
+
+  public boolean visit(Signature node)
+  { 
+    unimplementedVisitor("visit(" + "Signature" + ")");
+    return true;
+  }
+
+  public void endVisit(Import node)
+  { 
+    unimplementedVisitor("endVisit(" + "Import" + ")");
+  }
+
+  public boolean visit(Import node)
+  { 
+    unimplementedVisitor("visit(" + "Import" + ")");
+    return true;
+  }
+
+  public void endVisit(ImportWildcard node)
+  { 
+    unimplementedVisitor("endVisit(" + "ImportWildcard" + ")");
+  }
+
+  public boolean visit(ImportWildcard node)
+  { 
+    unimplementedVisitor("visit(" + "ImportWildcard" + ")");
+    return true;
+  }
+
+  public void endVisit(ListVar node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListVar" + ")");
+  }
+
+  public boolean visit(ListVar node)
+  { 
+    unimplementedVisitor("visit(" + "ListVar" + ")");
+    return true;
+  }
+
+  public void endVisit(Var node)
+  { 
+    unimplementedVisitor("endVisit(" + "Var" + ")");
+  }
+
+  public boolean visit(Var node)
+  { 
+    unimplementedVisitor("visit(" + "Var" + ")");
+    return true;
+  }
+
+  public void endVisit(ID_StrategoHost node)
+  { 
+    unimplementedVisitor("endVisit(" + "ID_StrategoHost" + ")");
+  }
+
+  public boolean visit(ID_StrategoHost node)
+  { 
+    unimplementedVisitor("visit(" + "ID_StrategoHost" + ")");
+    return true;
+  }
+
+  public void endVisit(BuildDefaultPT node)
+  { 
+    unimplementedVisitor("endVisit(" + "BuildDefaultPT" + ")");
+  }
+
+  public boolean visit(BuildDefaultPT node)
+  { 
+    unimplementedVisitor("visit(" + "BuildDefaultPT" + ")");
+    return true;
+  }
+
+  public void endVisit(BuildDefault node)
+  { 
+    unimplementedVisitor("endVisit(" + "BuildDefault" + ")");
+  }
+
+  public boolean visit(BuildDefault node)
+  { 
+    unimplementedVisitor("visit(" + "BuildDefault" + ")");
+    return true;
+  }
+
+  public void endVisit(Char1 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Char1" + ")");
+  }
+
+  public boolean visit(Char1 node)
+  { 
+    unimplementedVisitor("visit(" + "Char1" + ")");
+    return true;
+  }
+
+  public void endVisit(AnnoList node)
+  { 
+    unimplementedVisitor("endVisit(" + "AnnoList" + ")");
+  }
+
+  public boolean visit(AnnoList node)
+  { 
+    unimplementedVisitor("visit(" + "AnnoList" + ")");
+    return true;
+  }
+
+  public void endVisit(NoAnnoList node)
+  { 
+    unimplementedVisitor("endVisit(" + "NoAnnoList" + ")");
+  }
+
+  public boolean visit(NoAnnoList node)
+  { 
+    unimplementedVisitor("visit(" + "NoAnnoList" + ")");
+    return true;
+  }
+
+  public void endVisit(App0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "App0" + ")");
+  }
+
+  public boolean visit(App0 node)
+  { 
+    unimplementedVisitor("visit(" + "App0" + ")");
+    return true;
+  }
+
+  public void endVisit(App node)
+  { 
+    unimplementedVisitor("endVisit(" + "App" + ")");
+  }
+
+  public boolean visit(App node)
+  { 
+    unimplementedVisitor("visit(" + "App" + ")");
+    return true;
+  }
+
+  public void endVisit(RootApp0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "RootApp0" + ")");
+  }
+
+  public boolean visit(RootApp0 node)
+  { 
+    unimplementedVisitor("visit(" + "RootApp0" + ")");
+    return true;
+  }
+
+  public void endVisit(RootApp node)
+  { 
+    unimplementedVisitor("endVisit(" + "RootApp" + ")");
+  }
+
+  public boolean visit(RootApp node)
+  { 
+    unimplementedVisitor("visit(" + "RootApp" + ")");
+    return true;
+  }
+
+  public void endVisit(Tuple node)
+  { 
+    unimplementedVisitor("endVisit(" + "Tuple" + ")");
+  }
+
+  public boolean visit(Tuple node)
+  { 
+    unimplementedVisitor("visit(" + "Tuple" + ")");
+    return true;
+  }
+
+  public void endVisit(List0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "List0" + ")");
+  }
+
+  public boolean visit(List0 node)
+  { 
+    unimplementedVisitor("visit(" + "List0" + ")");
+    return true;
+  }
+
+  public void endVisit(ListTail node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListTail" + ")");
+  }
+
+  public boolean visit(ListTail node)
+  { 
+    unimplementedVisitor("visit(" + "ListTail" + ")");
+    return true;
+  }
+
+  public void endVisit(SortList node)
+  { 
+    unimplementedVisitor("endVisit(" + "SortList" + ")");
+  }
+
+  public boolean visit(SortList node)
+  { 
+    unimplementedVisitor("visit(" + "SortList" + ")");
+    return true;
+  }
+
+  public void endVisit(SortListTl node)
+  { 
+    unimplementedVisitor("endVisit(" + "SortListTl" + ")");
+  }
+
+  public boolean visit(SortListTl node)
+  { 
+    unimplementedVisitor("visit(" + "SortListTl" + ")");
+    return true;
+  }
+
+  public void endVisit(SortTuple node)
+  { 
+    unimplementedVisitor("endVisit(" + "SortTuple" + ")");
+  }
+
+  public boolean visit(SortTuple node)
+  { 
+    unimplementedVisitor("visit(" + "SortTuple" + ")");
+    return true;
+  }
+
+  public void endVisit(Star node)
+  { 
+    unimplementedVisitor("endVisit(" + "Star" + ")");
+  }
+
+  public boolean visit(Star node)
+  { 
+    unimplementedVisitor("visit(" + "Star" + ")");
+    return true;
+  }
+
+  public void endVisit(StarStar node)
+  { 
+    unimplementedVisitor("endVisit(" + "StarStar" + ")");
+  }
+
+  public boolean visit(StarStar node)
+  { 
+    unimplementedVisitor("visit(" + "StarStar" + ")");
+    return true;
+  }
+
+  public void endVisit(SDefNoArgs node)
+  { 
+    unimplementedVisitor("endVisit(" + "SDefNoArgs" + ")");
+  }
+
+  public boolean visit(SDefNoArgs node)
+  { 
+    unimplementedVisitor("visit(" + "SDefNoArgs" + ")");
+    return true;
+  }
+
+  public void endVisit(SDef node)
+  { 
+    unimplementedVisitor("endVisit(" + "SDef" + ")");
+  }
+
+  public boolean visit(SDef node)
+  { 
+    unimplementedVisitor("visit(" + "SDef" + ")");
+    return true;
+  }
+
+  public void endVisit(DefaultVarDec node)
+  { 
+    unimplementedVisitor("endVisit(" + "DefaultVarDec" + ")");
+  }
+
+  public boolean visit(DefaultVarDec node)
+  { 
+    unimplementedVisitor("visit(" + "DefaultVarDec" + ")");
+    return true;
+  }
+
+  public void endVisit(Call node)
+  { 
+    unimplementedVisitor("endVisit(" + "Call" + ")");
+  }
+
+  public boolean visit(Call node)
+  { 
+    unimplementedVisitor("visit(" + "Call" + ")");
+    return true;
+  }
+
+  public void endVisit(ScopeDefault node)
+  { 
+    unimplementedVisitor("endVisit(" + "ScopeDefault" + ")");
+  }
+
+  public boolean visit(ScopeDefault node)
+  { 
+    unimplementedVisitor("visit(" + "ScopeDefault" + ")");
+    return true;
+  }
+
+  public void endVisit(BA node)
+  { 
+    unimplementedVisitor("endVisit(" + "BA" + ")");
+  }
+
+  public boolean visit(BA node)
+  { 
+    unimplementedVisitor("visit(" + "BA" + ")");
+    return true;
+  }
+
+  public void endVisit(StrategyAngle node)
+  { 
+    unimplementedVisitor("endVisit(" + "StrategyAngle" + ")");
+  }
+
+  public boolean visit(StrategyAngle node)
+  { 
+    unimplementedVisitor("visit(" + "StrategyAngle" + ")");
+    return true;
+  }
+
+  public void endVisit(LChoice node)
+  { 
+    unimplementedVisitor("endVisit(" + "LChoice" + ")");
+  }
+
+  public boolean visit(LChoice node)
+  { 
+    unimplementedVisitor("visit(" + "LChoice" + ")");
+    return true;
+  }
+
+  public void endVisit(Rec node)
+  { 
+    unimplementedVisitor("endVisit(" + "Rec" + ")");
+  }
+
+  public boolean visit(Rec node)
+  { 
+    unimplementedVisitor("visit(" + "Rec" + ")");
+    return true;
+  }
+
+  public void endVisit(Not0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Not0" + ")");
+  }
+
+  public boolean visit(Not0 node)
+  { 
+    unimplementedVisitor("visit(" + "Not0" + ")");
+    return true;
+  }
+
+  public void endVisit(Where node)
+  { 
+    unimplementedVisitor("endVisit(" + "Where" + ")");
+  }
+
+  public boolean visit(Where node)
+  { 
+    unimplementedVisitor("visit(" + "Where" + ")");
+    return true;
+  }
+
+  public void endVisit(Test node)
+  { 
+    unimplementedVisitor("endVisit(" + "Test" + ")");
+  }
+
+  public boolean visit(Test node)
+  { 
+    unimplementedVisitor("visit(" + "Test" + ")");
+    return true;
+  }
+
+  public void endVisit(PrimNoArgs node)
+  { 
+    unimplementedVisitor("endVisit(" + "PrimNoArgs" + ")");
+  }
+
+  public boolean visit(PrimNoArgs node)
+  { 
+    unimplementedVisitor("visit(" + "PrimNoArgs" + ")");
+    return true;
+  }
+
+  public void endVisit(Prim node)
+  { 
+    unimplementedVisitor("endVisit(" + "Prim" + ")");
+  }
+
+  public boolean visit(Prim node)
+  { 
+    unimplementedVisitor("visit(" + "Prim" + ")");
+    return true;
+  }
+
+  public void endVisit(StrCong node)
+  { 
+    unimplementedVisitor("endVisit(" + "StrCong" + ")");
+  }
+
+  public boolean visit(StrCong node)
+  { 
+    unimplementedVisitor("visit(" + "StrCong" + ")");
+    return true;
+  }
+
+  public void endVisit(IntCong node)
+  { 
+    unimplementedVisitor("endVisit(" + "IntCong" + ")");
+  }
+
+  public boolean visit(IntCong node)
+  { 
+    unimplementedVisitor("visit(" + "IntCong" + ")");
+    return true;
+  }
+
+  public void endVisit(RealCong node)
+  { 
+    unimplementedVisitor("endVisit(" + "RealCong" + ")");
+  }
+
+  public boolean visit(RealCong node)
+  { 
+    unimplementedVisitor("visit(" + "RealCong" + ")");
+    return true;
+  }
+
+  public void endVisit(CharCong node)
+  { 
+    unimplementedVisitor("endVisit(" + "CharCong" + ")");
+  }
+
+  public boolean visit(CharCong node)
+  { 
+    unimplementedVisitor("visit(" + "CharCong" + ")");
+    return true;
+  }
+
+  public void endVisit(CongQ node)
+  { 
+    unimplementedVisitor("endVisit(" + "CongQ" + ")");
+  }
+
+  public boolean visit(CongQ node)
+  { 
+    unimplementedVisitor("visit(" + "CongQ" + ")");
+    return true;
+  }
+
+  public void endVisit(AnnoCong node)
+  { 
+    unimplementedVisitor("endVisit(" + "AnnoCong" + ")");
+  }
+
+  public boolean visit(AnnoCong node)
+  { 
+    unimplementedVisitor("visit(" + "AnnoCong" + ")");
+    return true;
+  }
+
+  public void endVisit(StrategyCurly node)
+  { 
+    unimplementedVisitor("endVisit(" + "StrategyCurly" + ")");
+  }
+
+  public boolean visit(StrategyCurly node)
+  { 
+    unimplementedVisitor("visit(" + "StrategyCurly" + ")");
+    return true;
+  }
+
+  public void endVisit(EmptyTupleCong node)
+  { 
+    unimplementedVisitor("endVisit(" + "EmptyTupleCong" + ")");
+  }
+
+  public boolean visit(EmptyTupleCong node)
+  { 
+    unimplementedVisitor("visit(" + "EmptyTupleCong" + ")");
+    return true;
+  }
+
+  public void endVisit(Strategy node)
+  { 
+    unimplementedVisitor("endVisit(" + "Strategy" + ")");
+  }
+
+  public boolean visit(Strategy node)
+  { 
+    unimplementedVisitor("visit(" + "Strategy" + ")");
+    return true;
+  }
+
+  public void endVisit(TupleCong node)
+  { 
+    unimplementedVisitor("endVisit(" + "TupleCong" + ")");
+  }
+
+  public boolean visit(TupleCong node)
+  { 
+    unimplementedVisitor("visit(" + "TupleCong" + ")");
+    return true;
+  }
+
+  public void endVisit(ListCongNoTail node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListCongNoTail" + ")");
+  }
+
+  public boolean visit(ListCongNoTail node)
+  { 
+    unimplementedVisitor("visit(" + "ListCongNoTail" + ")");
+    return true;
+  }
+
+  public void endVisit(ListCong node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListCong" + ")");
+  }
+
+  public boolean visit(ListCong node)
+  { 
+    unimplementedVisitor("visit(" + "ListCong" + ")");
+    return true;
+  }
+
+  public void endVisit(ExplodeCong node)
+  { 
+    unimplementedVisitor("endVisit(" + "ExplodeCong" + ")");
+  }
+
+  public boolean visit(ExplodeCong node)
+  { 
+    unimplementedVisitor("visit(" + "ExplodeCong" + ")");
+    return true;
+  }
+
+  public void endVisit(CallNoArgs node)
+  { 
+    unimplementedVisitor("endVisit(" + "CallNoArgs" + ")");
+  }
+
+  public boolean visit(CallNoArgs node)
+  { 
+    unimplementedVisitor("visit(" + "CallNoArgs" + ")");
+    return true;
+  }
+
+  public void endVisit(LRule node)
+  { 
+    unimplementedVisitor("endVisit(" + "LRule" + ")");
+  }
+
+  public boolean visit(LRule node)
+  { 
+    unimplementedVisitor("visit(" + "LRule" + ")");
+    return true;
+  }
+
+  public void endVisit(SRule node)
+  { 
+    unimplementedVisitor("endVisit(" + "SRule" + ")");
+  }
+
+  public boolean visit(SRule node)
+  { 
+    unimplementedVisitor("visit(" + "SRule" + ")");
+    return true;
+  }
+
+  public void endVisit(Choice node)
+  { 
+    unimplementedVisitor("endVisit(" + "Choice" + ")");
+  }
+
+  public boolean visit(Choice node)
+  { 
+    unimplementedVisitor("visit(" + "Choice" + ")");
+    return true;
+  }
+
+  public void endVisit(RChoice node)
+  { 
+    unimplementedVisitor("endVisit(" + "RChoice" + ")");
+  }
+
+  public boolean visit(RChoice node)
+  { 
+    unimplementedVisitor("visit(" + "RChoice" + ")");
+    return true;
+  }
+
+  public void endVisit(CondChoice node)
+  { 
+    unimplementedVisitor("endVisit(" + "CondChoice" + ")");
+  }
+
+  public boolean visit(CondChoice node)
+  { 
+    unimplementedVisitor("visit(" + "CondChoice" + ")");
+    return true;
+  }
+
+  public void endVisit(IfThen node)
+  { 
+    unimplementedVisitor("endVisit(" + "IfThen" + ")");
+  }
+
+  public boolean visit(IfThen node)
+  { 
+    unimplementedVisitor("visit(" + "IfThen" + ")");
+    return true;
+  }
+
+  public void endVisit(SwitchChoiceNoOtherwise node)
+  { 
+    unimplementedVisitor("endVisit(" + "SwitchChoiceNoOtherwise" + ")");
+  }
+
+  public boolean visit(SwitchChoiceNoOtherwise node)
+  { 
+    unimplementedVisitor("visit(" + "SwitchChoiceNoOtherwise" + ")");
+    return true;
+  }
+
+  public void endVisit(SwitchChoice node)
+  { 
+    unimplementedVisitor("endVisit(" + "SwitchChoice" + ")");
+  }
+
+  public boolean visit(SwitchChoice node)
+  { 
+    unimplementedVisitor("visit(" + "SwitchChoice" + ")");
+    return true;
+  }
+
+  public void endVisit(SwitchCase node)
+  { 
+    unimplementedVisitor("endVisit(" + "SwitchCase" + ")");
+  }
+
+  public boolean visit(SwitchCase node)
+  { 
+    unimplementedVisitor("visit(" + "SwitchCase" + ")");
+    return true;
+  }
+
+  public void endVisit(AM node)
+  { 
+    unimplementedVisitor("endVisit(" + "AM" + ")");
+  }
+
+  public boolean visit(AM node)
+  { 
+    unimplementedVisitor("visit(" + "AM" + ")");
+    return true;
+  }
+
+  public void endVisit(Assign0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Assign0" + ")");
+  }
+
+  public boolean visit(Assign0 node)
+  { 
+    unimplementedVisitor("visit(" + "Assign0" + ")");
+    return true;
+  }
+
+  public void endVisit(OverlayNoArgs node)
+  { 
+    unimplementedVisitor("endVisit(" + "OverlayNoArgs" + ")");
+  }
+
+  public boolean visit(OverlayNoArgs node)
+  { 
+    unimplementedVisitor("visit(" + "OverlayNoArgs" + ")");
+    return true;
+  }
+
+  public void endVisit(Overlay node)
+  { 
+    unimplementedVisitor("endVisit(" + "Overlay" + ")");
+  }
+
+  public boolean visit(Overlay node)
+  { 
+    unimplementedVisitor("visit(" + "Overlay" + ")");
+    return true;
+  }
+
+  public void endVisit(RDefNoArgs node)
+  { 
+    unimplementedVisitor("endVisit(" + "RDefNoArgs" + ")");
+  }
+
+  public boolean visit(RDefNoArgs node)
+  { 
+    unimplementedVisitor("visit(" + "RDefNoArgs" + ")");
+    return true;
+  }
+
+  public void endVisit(RDef node)
+  { 
+    unimplementedVisitor("endVisit(" + "RDef" + ")");
+  }
+
+  public boolean visit(RDef node)
+  { 
+    unimplementedVisitor("visit(" + "RDef" + ")");
+    return true;
+  }
+
+  public void endVisit(RDefT node)
+  { 
+    unimplementedVisitor("endVisit(" + "RDefT" + ")");
+  }
+
+  public boolean visit(RDefT node)
+  { 
+    unimplementedVisitor("visit(" + "RDefT" + ")");
+    return true;
+  }
+
+  public void endVisit(RuleNoCond node)
+  { 
+    unimplementedVisitor("endVisit(" + "RuleNoCond" + ")");
+  }
+
+  public boolean visit(RuleNoCond node)
+  { 
+    unimplementedVisitor("visit(" + "RuleNoCond" + ")");
+    return true;
+  }
+
+  public void endVisit(Rule node)
+  { 
+    unimplementedVisitor("endVisit(" + "Rule" + ")");
+  }
+
+  public boolean visit(Rule node)
+  { 
+    unimplementedVisitor("visit(" + "Rule" + ")");
+    return true;
+  }
+
+  public void endVisit(Rules node)
+  { 
+    unimplementedVisitor("endVisit(" + "Rules" + ")");
+  }
+
+  public boolean visit(Rules node)
+  { 
+    unimplementedVisitor("visit(" + "Rules" + ")");
+    return true;
+  }
+
+  public void endVisit(Overlays node)
+  { 
+    unimplementedVisitor("endVisit(" + "Overlays" + ")");
+  }
+
+  public boolean visit(Overlays node)
+  { 
+    unimplementedVisitor("visit(" + "Overlays" + ")");
+    return true;
+  }
+
+  public void endVisit(Def_StrategoHost node)
+  { 
+    unimplementedVisitor("endVisit(" + "Def_StrategoHost" + ")");
+  }
+
+  public boolean visit(Def_StrategoHost node)
+  { 
+    unimplementedVisitor("visit(" + "Def_StrategoHost" + ")");
+    return true;
+  }
+
+  public void endVisit(DynRuleScope node)
+  { 
+    unimplementedVisitor("endVisit(" + "DynRuleScope" + ")");
+  }
+
+  public boolean visit(DynRuleScope node)
+  { 
+    unimplementedVisitor("visit(" + "DynRuleScope" + ")");
+    return true;
+  }
+
+  public void endVisit(ScopeLabels_StrategoHost node)
+  { 
+    unimplementedVisitor("endVisit(" + "ScopeLabels_StrategoHost" + ")");
+  }
+
+  public boolean visit(ScopeLabels_StrategoHost node)
+  { 
+    unimplementedVisitor("visit(" + "ScopeLabels_StrategoHost" + ")");
+    return true;
+  }
+
+  public void endVisit(ScopeLabels node)
+  { 
+    unimplementedVisitor("endVisit(" + "ScopeLabels" + ")");
+  }
+
+  public boolean visit(ScopeLabels node)
+  { 
+    unimplementedVisitor("visit(" + "ScopeLabels" + ")");
+    return true;
+  }
+
+  public void endVisit(GenDynRules node)
+  { 
+    unimplementedVisitor("endVisit(" + "GenDynRules" + ")");
+  }
+
+  public boolean visit(GenDynRules node)
+  { 
+    unimplementedVisitor("visit(" + "GenDynRules" + ")");
+    return true;
+  }
+
+  public void endVisit(AddScopeLabel node)
+  { 
+    unimplementedVisitor("endVisit(" + "AddScopeLabel" + ")");
+  }
+
+  public boolean visit(AddScopeLabel node)
+  { 
+    unimplementedVisitor("visit(" + "AddScopeLabel" + ")");
+    return true;
+  }
+
+  public void endVisit(UndefineDynRule node)
+  { 
+    unimplementedVisitor("endVisit(" + "UndefineDynRule" + ")");
+  }
+
+  public boolean visit(UndefineDynRule node)
+  { 
+    unimplementedVisitor("visit(" + "UndefineDynRule" + ")");
+    return true;
+  }
+
+  public void endVisit(SetDynRule node)
+  { 
+    unimplementedVisitor("endVisit(" + "SetDynRule" + ")");
+  }
+
+  public boolean visit(SetDynRule node)
+  { 
+    unimplementedVisitor("visit(" + "SetDynRule" + ")");
+    return true;
+  }
+
+  public void endVisit(AddDynRule node)
+  { 
+    unimplementedVisitor("endVisit(" + "AddDynRule" + ")");
+  }
+
+  public boolean visit(AddDynRule node)
+  { 
+    unimplementedVisitor("visit(" + "AddDynRule" + ")");
+    return true;
+  }
+
+  public void endVisit(SetDynRuleMatch node)
+  { 
+    unimplementedVisitor("endVisit(" + "SetDynRuleMatch" + ")");
+  }
+
+  public boolean visit(SetDynRuleMatch node)
+  { 
+    unimplementedVisitor("visit(" + "SetDynRuleMatch" + ")");
+    return true;
+  }
+
+  public void endVisit(DynRuleAssign node)
+  { 
+    unimplementedVisitor("endVisit(" + "DynRuleAssign" + ")");
+  }
+
+  public boolean visit(DynRuleAssign node)
+  { 
+    unimplementedVisitor("visit(" + "DynRuleAssign" + ")");
+    return true;
+  }
+
+  public void endVisit(DynRuleAssignAdd node)
+  { 
+    unimplementedVisitor("endVisit(" + "DynRuleAssignAdd" + ")");
+  }
+
+  public boolean visit(DynRuleAssignAdd node)
+  { 
+    unimplementedVisitor("visit(" + "DynRuleAssignAdd" + ")");
+    return true;
+  }
+
+  public void endVisit(SetDynRuleDepends node)
+  { 
+    unimplementedVisitor("endVisit(" + "SetDynRuleDepends" + ")");
+  }
+
+  public boolean visit(SetDynRuleDepends node)
+  { 
+    unimplementedVisitor("visit(" + "SetDynRuleDepends" + ")");
+    return true;
+  }
+
+  public void endVisit(LabeledDynRuleId node)
+  { 
+    unimplementedVisitor("endVisit(" + "LabeledDynRuleId" + ")");
+  }
+
+  public boolean visit(LabeledDynRuleId node)
+  { 
+    unimplementedVisitor("visit(" + "LabeledDynRuleId" + ")");
+    return true;
+  }
+
+  public void endVisit(AddLabelDynRuleId node)
+  { 
+    unimplementedVisitor("endVisit(" + "AddLabelDynRuleId" + ")");
+  }
+
+  public boolean visit(AddLabelDynRuleId node)
+  { 
+    unimplementedVisitor("visit(" + "AddLabelDynRuleId" + ")");
+    return true;
+  }
+
+  public void endVisit(DynRuleId node)
+  { 
+    unimplementedVisitor("endVisit(" + "DynRuleId" + ")");
+  }
+
+  public boolean visit(DynRuleId node)
+  { 
+    unimplementedVisitor("visit(" + "DynRuleId" + ")");
+    return true;
+  }
+
+  public void endVisit(LabeledDynRuleScopeId node)
+  { 
+    unimplementedVisitor("endVisit(" + "LabeledDynRuleScopeId" + ")");
+  }
+
+  public boolean visit(LabeledDynRuleScopeId node)
+  { 
+    unimplementedVisitor("visit(" + "LabeledDynRuleScopeId" + ")");
+    return true;
+  }
+
+  public void endVisit(DynRuleScopeId node)
+  { 
+    unimplementedVisitor("endVisit(" + "DynRuleScopeId" + ")");
+  }
+
+  public boolean visit(DynRuleScopeId node)
+  { 
+    unimplementedVisitor("visit(" + "DynRuleScopeId" + ")");
+    return true;
+  }
+
+  public void endVisit(RDecNoArgs node)
+  { 
+    unimplementedVisitor("endVisit(" + "RDecNoArgs" + ")");
+  }
+
+  public boolean visit(RDecNoArgs node)
+  { 
+    unimplementedVisitor("visit(" + "RDecNoArgs" + ")");
+    return true;
+  }
+
+  public void endVisit(RDec node)
+  { 
+    unimplementedVisitor("endVisit(" + "RDec" + ")");
+  }
+
+  public boolean visit(RDec node)
+  { 
+    unimplementedVisitor("visit(" + "RDec" + ")");
+    return true;
+  }
+
+  public void endVisit(RDecT node)
+  { 
+    unimplementedVisitor("endVisit(" + "RDecT" + ")");
+  }
+
+  public boolean visit(RDecT node)
+  { 
+    unimplementedVisitor("visit(" + "RDecT" + ")");
+    return true;
+  }
+
+  public void endVisit(RuleNames_StrategoHost node)
+  { 
+    unimplementedVisitor("endVisit(" + "RuleNames_StrategoHost" + ")");
+  }
+
+  public boolean visit(RuleNames_StrategoHost node)
+  { 
+    unimplementedVisitor("visit(" + "RuleNames_StrategoHost" + ")");
+    return true;
+  }
+
+  public void endVisit(RuleNames node)
+  { 
+    unimplementedVisitor("endVisit(" + "RuleNames" + ")");
+  }
+
+  public boolean visit(RuleNames node)
+  { 
+    unimplementedVisitor("visit(" + "RuleNames" + ")");
+    return true;
+  }
+
+  public void endVisit(DynRuleIntersectFix node)
+  { 
+    unimplementedVisitor("endVisit(" + "DynRuleIntersectFix" + ")");
+  }
+
+  public boolean visit(DynRuleIntersectFix node)
+  { 
+    unimplementedVisitor("visit(" + "DynRuleIntersectFix" + ")");
+    return true;
+  }
+
+  public void endVisit(DynRuleUnionFix0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "DynRuleUnionFix0" + ")");
+  }
+
+  public boolean visit(DynRuleUnionFix0 node)
+  { 
+    unimplementedVisitor("visit(" + "DynRuleUnionFix0" + ")");
+    return true;
+  }
+
+  public void endVisit(DynRuleUnionFix node)
+  { 
+    unimplementedVisitor("endVisit(" + "DynRuleUnionFix" + ")");
+  }
+
+  public boolean visit(DynRuleUnionFix node)
+  { 
+    unimplementedVisitor("visit(" + "DynRuleUnionFix" + ")");
+    return true;
+  }
+
+  public void endVisit(DynRuleIntersectUnionFix0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "DynRuleIntersectUnionFix0" + ")");
+  }
+
+  public boolean visit(DynRuleIntersectUnionFix0 node)
+  { 
+    unimplementedVisitor("visit(" + "DynRuleIntersectUnionFix0" + ")");
+    return true;
+  }
+
+  public void endVisit(DynRuleIntersectUnionFix node)
+  { 
+    unimplementedVisitor("endVisit(" + "DynRuleIntersectUnionFix" + ")");
+  }
+
+  public boolean visit(DynRuleIntersectUnionFix node)
+  { 
+    unimplementedVisitor("visit(" + "DynRuleIntersectUnionFix" + ")");
+    return true;
+  }
+
+  public void endVisit(DynRuleIntersect node)
+  { 
+    unimplementedVisitor("endVisit(" + "DynRuleIntersect" + ")");
+  }
+
+  public boolean visit(DynRuleIntersect node)
+  { 
+    unimplementedVisitor("visit(" + "DynRuleIntersect" + ")");
+    return true;
+  }
+
+  public void endVisit(DynRuleUnion node)
+  { 
+    unimplementedVisitor("endVisit(" + "DynRuleUnion" + ")");
+  }
+
+  public boolean visit(DynRuleUnion node)
+  { 
+    unimplementedVisitor("visit(" + "DynRuleUnion" + ")");
+    return true;
+  }
+
+  public void endVisit(DynRuleIntersectUnion node)
+  { 
+    unimplementedVisitor("endVisit(" + "DynRuleIntersectUnion" + ")");
+  }
+
+  public boolean visit(DynRuleIntersectUnion node)
+  { 
+    unimplementedVisitor("visit(" + "DynRuleIntersectUnion" + ")");
+    return true;
+  }
+
+  public void endVisit(UnicodeEscape0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "UnicodeEscape0" + ")");
+  }
+
+  public boolean visit(UnicodeEscape0 node)
+  { 
+    unimplementedVisitor("visit(" + "UnicodeEscape0" + ")");
+    return true;
+  }
+
+  public void endVisit(LineTerminator node)
+  { 
+    unimplementedVisitor("endVisit(" + "LineTerminator" + ")");
+  }
+
+  public boolean visit(LineTerminator node)
+  { 
+    unimplementedVisitor("visit(" + "LineTerminator" + ")");
+    return true;
+  }
+
+  public void endVisit(CarriageReturn node)
+  { 
+    unimplementedVisitor("endVisit(" + "CarriageReturn" + ")");
+  }
+
+  public boolean visit(CarriageReturn node)
+  { 
+    unimplementedVisitor("visit(" + "CarriageReturn" + ")");
+    return true;
+  }
+
+  public void endVisit(EndOfFile node)
+  { 
+    unimplementedVisitor("endVisit(" + "EndOfFile" + ")");
+  }
+
+  public boolean visit(EndOfFile node)
+  { 
+    unimplementedVisitor("visit(" + "EndOfFile" + ")");
+    return true;
+  }
+
+  public void endVisit(Comment node)
+  { 
+    unimplementedVisitor("endVisit(" + "Comment" + ")");
+  }
+
+  public boolean visit(Comment node)
+  { 
+    unimplementedVisitor("visit(" + "Comment" + ")");
+    return true;
+  }
+
+  public void endVisit(EOLCommentChars node)
+  { 
+    unimplementedVisitor("endVisit(" + "EOLCommentChars" + ")");
+  }
+
+  public boolean visit(EOLCommentChars node)
+  { 
+    unimplementedVisitor("visit(" + "EOLCommentChars" + ")");
+    return true;
+  }
+
+  public void endVisit(CommentPart node)
+  { 
+    unimplementedVisitor("endVisit(" + "CommentPart" + ")");
+  }
+
+  public boolean visit(CommentPart node)
+  { 
+    unimplementedVisitor("visit(" + "CommentPart" + ")");
+    return true;
+  }
+
+  public void endVisit(BlockCommentChars node)
+  { 
+    unimplementedVisitor("endVisit(" + "BlockCommentChars" + ")");
+  }
+
+  public boolean visit(BlockCommentChars node)
+  { 
+    unimplementedVisitor("visit(" + "BlockCommentChars" + ")");
+    return true;
+  }
+
+  public void endVisit(EscEscChar node)
+  { 
+    unimplementedVisitor("endVisit(" + "EscEscChar" + ")");
+  }
+
+  public boolean visit(EscEscChar node)
+  { 
+    unimplementedVisitor("visit(" + "EscEscChar" + ")");
+    return true;
+  }
+
+  public void endVisit(EscChar node)
+  { 
+    unimplementedVisitor("endVisit(" + "EscChar" + ")");
+  }
+
+  public boolean visit(EscChar node)
+  { 
+    unimplementedVisitor("visit(" + "EscChar" + ")");
+    return true;
+  }
+
+  public void endVisit(UnicodeEscape node)
+  { 
+    unimplementedVisitor("endVisit(" + "UnicodeEscape" + ")");
+  }
+
+  public boolean visit(UnicodeEscape node)
+  { 
+    unimplementedVisitor("visit(" + "UnicodeEscape" + ")");
+    return true;
+  }
+
+  public void endVisit(Keyword_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "Keyword_JavaObject" + ")");
+  }
+
+  public boolean visit(Keyword_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "Keyword_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(ID_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "ID_JavaObject" + ")");
+  }
+
+  public boolean visit(ID_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "ID_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(Id node)
+  { 
+    unimplementedVisitor("endVisit(" + "Id" + ")");
+  }
+
+  public boolean visit(Id node)
+  { 
+    unimplementedVisitor("visit(" + "Id" + ")");
+    return true;
+  }
+
+  public void endVisit(Public node)
+  { 
+    unimplementedVisitor("endVisit(" + "Public" + ")");
+  }
+
+  public boolean visit(Public node)
+  { 
+    unimplementedVisitor("visit(" + "Public" + ")");
+    return true;
+  }
+
+  public void endVisit(Private node)
+  { 
+    unimplementedVisitor("endVisit(" + "Private" + ")");
+  }
+
+  public boolean visit(Private node)
+  { 
+    unimplementedVisitor("visit(" + "Private" + ")");
+    return true;
+  }
+
+  public void endVisit(Protected node)
+  { 
+    unimplementedVisitor("endVisit(" + "Protected" + ")");
+  }
+
+  public boolean visit(Protected node)
+  { 
+    unimplementedVisitor("visit(" + "Protected" + ")");
+    return true;
+  }
+
+  public void endVisit(Abstract node)
+  { 
+    unimplementedVisitor("endVisit(" + "Abstract" + ")");
+  }
+
+  public boolean visit(Abstract node)
+  { 
+    unimplementedVisitor("visit(" + "Abstract" + ")");
+    return true;
+  }
+
+  public void endVisit(Final node)
+  { 
+    unimplementedVisitor("endVisit(" + "Final" + ")");
+  }
+
+  public boolean visit(Final node)
+  { 
+    unimplementedVisitor("visit(" + "Final" + ")");
+    return true;
+  }
+
+  public void endVisit(Static node)
+  { 
+    unimplementedVisitor("endVisit(" + "Static" + ")");
+  }
+
+  public boolean visit(Static node)
+  { 
+    unimplementedVisitor("visit(" + "Static" + ")");
+    return true;
+  }
+
+  public void endVisit(Native node)
+  { 
+    unimplementedVisitor("endVisit(" + "Native" + ")");
+  }
+
+  public boolean visit(Native node)
+  { 
+    unimplementedVisitor("visit(" + "Native" + ")");
+    return true;
+  }
+
+  public void endVisit(Transient node)
+  { 
+    unimplementedVisitor("endVisit(" + "Transient" + ")");
+  }
+
+  public boolean visit(Transient node)
+  { 
+    unimplementedVisitor("visit(" + "Transient" + ")");
+    return true;
+  }
+
+  public void endVisit(Volatile node)
+  { 
+    unimplementedVisitor("endVisit(" + "Volatile" + ")");
+  }
+
+  public boolean visit(Volatile node)
+  { 
+    unimplementedVisitor("visit(" + "Volatile" + ")");
+    return true;
+  }
+
+  public void endVisit(Synchronized0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Synchronized0" + ")");
+  }
+
+  public boolean visit(Synchronized0 node)
+  { 
+    unimplementedVisitor("visit(" + "Synchronized0" + ")");
+    return true;
+  }
+
+  public void endVisit(StrictFP node)
+  { 
+    unimplementedVisitor("endVisit(" + "StrictFP" + ")");
+  }
+
+  public boolean visit(StrictFP node)
+  { 
+    unimplementedVisitor("visit(" + "StrictFP" + ")");
+    return true;
+  }
+
+  public void endVisit(Modifier_JavaObject9 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Modifier_JavaObject9" + ")");
+  }
+
+  public boolean visit(Modifier_JavaObject9 node)
+  { 
+    unimplementedVisitor("visit(" + "Modifier_JavaObject9" + ")");
+    return true;
+  }
+
+  public void endVisit(Modifier_JavaObject8 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Modifier_JavaObject8" + ")");
+  }
+
+  public boolean visit(Modifier_JavaObject8 node)
+  { 
+    unimplementedVisitor("visit(" + "Modifier_JavaObject8" + ")");
+    return true;
+  }
+
+  public void endVisit(Modifier_JavaObject7 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Modifier_JavaObject7" + ")");
+  }
+
+  public boolean visit(Modifier_JavaObject7 node)
+  { 
+    unimplementedVisitor("visit(" + "Modifier_JavaObject7" + ")");
+    return true;
+  }
+
+  public void endVisit(Modifier_JavaObject6 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Modifier_JavaObject6" + ")");
+  }
+
+  public boolean visit(Modifier_JavaObject6 node)
+  { 
+    unimplementedVisitor("visit(" + "Modifier_JavaObject6" + ")");
+    return true;
+  }
+
+  public void endVisit(Modifier_JavaObject5 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Modifier_JavaObject5" + ")");
+  }
+
+  public boolean visit(Modifier_JavaObject5 node)
+  { 
+    unimplementedVisitor("visit(" + "Modifier_JavaObject5" + ")");
+    return true;
+  }
+
+  public void endVisit(Modifier_JavaObject4 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Modifier_JavaObject4" + ")");
+  }
+
+  public boolean visit(Modifier_JavaObject4 node)
+  { 
+    unimplementedVisitor("visit(" + "Modifier_JavaObject4" + ")");
+    return true;
+  }
+
+  public void endVisit(Modifier_JavaObject3 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Modifier_JavaObject3" + ")");
+  }
+
+  public boolean visit(Modifier_JavaObject3 node)
+  { 
+    unimplementedVisitor("visit(" + "Modifier_JavaObject3" + ")");
+    return true;
+  }
+
+  public void endVisit(Modifier_JavaObject2 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Modifier_JavaObject2" + ")");
+  }
+
+  public boolean visit(Modifier_JavaObject2 node)
+  { 
+    unimplementedVisitor("visit(" + "Modifier_JavaObject2" + ")");
+    return true;
+  }
+
+  public void endVisit(Modifier_JavaObject1 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Modifier_JavaObject1" + ")");
+  }
+
+  public boolean visit(Modifier_JavaObject1 node)
+  { 
+    unimplementedVisitor("visit(" + "Modifier_JavaObject1" + ")");
+    return true;
+  }
+
+  public void endVisit(Modifier_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Modifier_JavaObject0" + ")");
+  }
+
+  public boolean visit(Modifier_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "Modifier_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(Modifier_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "Modifier_JavaObject" + ")");
+  }
+
+  public boolean visit(Modifier_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "Modifier_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(DeciLiteral_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "DeciLiteral_JavaObject" + ")");
+  }
+
+  public boolean visit(DeciLiteral_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "DeciLiteral_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(HexaLiteral_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "HexaLiteral_JavaObject" + ")");
+  }
+
+  public boolean visit(HexaLiteral_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "HexaLiteral_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(OctaLiteral_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "OctaLiteral_JavaObject" + ")");
+  }
+
+  public boolean visit(OctaLiteral_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "OctaLiteral_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(DeciNumeral_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "DeciNumeral_JavaObject" + ")");
+  }
+
+  public boolean visit(DeciNumeral_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "DeciNumeral_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(HexaNumeral_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "HexaNumeral_JavaObject" + ")");
+  }
+
+  public boolean visit(HexaNumeral_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "HexaNumeral_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(OctaNumeral_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "OctaNumeral_JavaObject" + ")");
+  }
+
+  public boolean visit(OctaNumeral_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "OctaNumeral_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(Deci node)
+  { 
+    unimplementedVisitor("endVisit(" + "Deci" + ")");
+  }
+
+  public boolean visit(Deci node)
+  { 
+    unimplementedVisitor("visit(" + "Deci" + ")");
+    return true;
+  }
+
+  public void endVisit(Hexa node)
+  { 
+    unimplementedVisitor("endVisit(" + "Hexa" + ")");
+  }
+
+  public boolean visit(Hexa node)
+  { 
+    unimplementedVisitor("visit(" + "Hexa" + ")");
+    return true;
+  }
+
+  public void endVisit(Octa node)
+  { 
+    unimplementedVisitor("endVisit(" + "Octa" + ")");
+  }
+
+  public boolean visit(Octa node)
+  { 
+    unimplementedVisitor("visit(" + "Octa" + ")");
+    return true;
+  }
+
+  public void endVisit(DeciFloatLiteral_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "DeciFloatLiteral_JavaObject" + ")");
+  }
+
+  public boolean visit(DeciFloatLiteral_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "DeciFloatLiteral_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(HexaFloatLiteral_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "HexaFloatLiteral_JavaObject" + ")");
+  }
+
+  public boolean visit(HexaFloatLiteral_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "HexaFloatLiteral_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(Float1 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Float1" + ")");
+  }
+
+  public boolean visit(Float1 node)
+  { 
+    unimplementedVisitor("visit(" + "Float1" + ")");
+    return true;
+  }
+
+  public void endVisit(Float0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Float0" + ")");
+  }
+
+  public boolean visit(Float0 node)
+  { 
+    unimplementedVisitor("visit(" + "Float0" + ")");
+    return true;
+  }
+
+  public void endVisit(DeciFloatNumeral_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "DeciFloatNumeral_JavaObject" + ")");
+  }
+
+  public boolean visit(DeciFloatNumeral_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "DeciFloatNumeral_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(DeciFloatDigits_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "DeciFloatDigits_JavaObject" + ")");
+  }
+
+  public boolean visit(DeciFloatDigits_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "DeciFloatDigits_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(DeciFloatExponentPart_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "DeciFloatExponentPart_JavaObject" + ")");
+  }
+
+  public boolean visit(DeciFloatExponentPart_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "DeciFloatExponentPart_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(SignedInteger_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "SignedInteger_JavaObject" + ")");
+  }
+
+  public boolean visit(SignedInteger_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "SignedInteger_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(HexaFloatNumeral_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "HexaFloatNumeral_JavaObject" + ")");
+  }
+
+  public boolean visit(HexaFloatNumeral_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "HexaFloatNumeral_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(HexaSignificand_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "HexaSignificand_JavaObject" + ")");
+  }
+
+  public boolean visit(HexaSignificand_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "HexaSignificand_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(BinaryExponent_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "BinaryExponent_JavaObject" + ")");
+  }
+
+  public boolean visit(BinaryExponent_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "BinaryExponent_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(Bool node)
+  { 
+    unimplementedVisitor("endVisit(" + "Bool" + ")");
+  }
+
+  public boolean visit(Bool node)
+  { 
+    unimplementedVisitor("visit(" + "Bool" + ")");
+    return true;
+  }
+
+  public void endVisit(True node)
+  { 
+    unimplementedVisitor("endVisit(" + "True" + ")");
+  }
+
+  public boolean visit(True node)
+  { 
+    unimplementedVisitor("visit(" + "True" + ")");
+    return true;
+  }
+
+  public void endVisit(False node)
+  { 
+    unimplementedVisitor("endVisit(" + "False" + ")");
+  }
+
+  public boolean visit(False node)
+  { 
+    unimplementedVisitor("visit(" + "False" + ")");
+    return true;
+  }
+
+  public void endVisit(EscapeSeq_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "EscapeSeq_JavaObject0" + ")");
+  }
+
+  public boolean visit(EscapeSeq_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "EscapeSeq_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(EscapeSeq_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "EscapeSeq_JavaObject" + ")");
+  }
+
+  public boolean visit(EscapeSeq_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "EscapeSeq_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(NamedEscape node)
+  { 
+    unimplementedVisitor("endVisit(" + "NamedEscape" + ")");
+  }
+
+  public boolean visit(NamedEscape node)
+  { 
+    unimplementedVisitor("visit(" + "NamedEscape" + ")");
+    return true;
+  }
+
+  public void endVisit(OctaEscape1 node)
+  { 
+    unimplementedVisitor("endVisit(" + "OctaEscape1" + ")");
+  }
+
+  public boolean visit(OctaEscape1 node)
+  { 
+    unimplementedVisitor("visit(" + "OctaEscape1" + ")");
+    return true;
+  }
+
+  public void endVisit(OctaEscape20 node)
+  { 
+    unimplementedVisitor("endVisit(" + "OctaEscape20" + ")");
+  }
+
+  public boolean visit(OctaEscape20 node)
+  { 
+    unimplementedVisitor("visit(" + "OctaEscape20" + ")");
+    return true;
+  }
+
+  public void endVisit(OctaEscape2 node)
+  { 
+    unimplementedVisitor("endVisit(" + "OctaEscape2" + ")");
+  }
+
+  public boolean visit(OctaEscape2 node)
+  { 
+    unimplementedVisitor("visit(" + "OctaEscape2" + ")");
+    return true;
+  }
+
+  public void endVisit(OctaEscape3 node)
+  { 
+    unimplementedVisitor("endVisit(" + "OctaEscape3" + ")");
+  }
+
+  public boolean visit(OctaEscape3 node)
+  { 
+    unimplementedVisitor("visit(" + "OctaEscape3" + ")");
+    return true;
+  }
+
+  public void endVisit(LastOcta_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "LastOcta_JavaObject" + ")");
+  }
+
+  public boolean visit(LastOcta_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "LastOcta_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(Char0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Char0" + ")");
+  }
+
+  public boolean visit(Char0 node)
+  { 
+    unimplementedVisitor("visit(" + "Char0" + ")");
+    return true;
+  }
+
+  public void endVisit(Single node)
+  { 
+    unimplementedVisitor("endVisit(" + "Single" + ")");
+  }
+
+  public boolean visit(Single node)
+  { 
+    unimplementedVisitor("visit(" + "Single" + ")");
+    return true;
+  }
+
+  public void endVisit(CharContent_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "CharContent_JavaObject0" + ")");
+  }
+
+  public boolean visit(CharContent_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "CharContent_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(CharContent_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "CharContent_JavaObject" + ")");
+  }
+
+  public boolean visit(CharContent_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "CharContent_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(SingleChar_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "SingleChar_JavaObject" + ")");
+  }
+
+  public boolean visit(SingleChar_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "SingleChar_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(String node)
+  { 
+    unimplementedVisitor("endVisit(" + "String" + ")");
+  }
+
+  public boolean visit(String node)
+  { 
+    unimplementedVisitor("visit(" + "String" + ")");
+    return true;
+  }
+
+  public void endVisit(Chars node)
+  { 
+    unimplementedVisitor("endVisit(" + "Chars" + ")");
+  }
+
+  public boolean visit(Chars node)
+  { 
+    unimplementedVisitor("visit(" + "Chars" + ")");
+    return true;
+  }
+
+  public void endVisit(StringPart_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "StringPart_JavaObject0" + ")");
+  }
+
+  public boolean visit(StringPart_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "StringPart_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(StringPart_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "StringPart_JavaObject" + ")");
+  }
+
+  public boolean visit(StringPart_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "StringPart_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(StringChars_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "StringChars_JavaObject" + ")");
+  }
+
+  public boolean visit(StringChars_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "StringChars_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(Null node)
+  { 
+    unimplementedVisitor("endVisit(" + "Null" + ")");
+  }
+
+  public boolean visit(Null node)
+  { 
+    unimplementedVisitor("visit(" + "Null" + ")");
+    return true;
+  }
+
+  public void endVisit(PrimType_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "PrimType_JavaObject" + ")");
+  }
+
+  public boolean visit(PrimType_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "PrimType_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(Boolean node)
+  { 
+    unimplementedVisitor("endVisit(" + "Boolean" + ")");
+  }
+
+  public boolean visit(Boolean node)
+  { 
+    unimplementedVisitor("visit(" + "Boolean" + ")");
+    return true;
+  }
+
+  public void endVisit(NumType_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "NumType_JavaObject0" + ")");
+  }
+
+  public boolean visit(NumType_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "NumType_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(NumType_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "NumType_JavaObject" + ")");
+  }
+
+  public boolean visit(NumType_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "NumType_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(Byte node)
+  { 
+    unimplementedVisitor("endVisit(" + "Byte" + ")");
+  }
+
+  public boolean visit(Byte node)
+  { 
+    unimplementedVisitor("visit(" + "Byte" + ")");
+    return true;
+  }
+
+  public void endVisit(Short node)
+  { 
+    unimplementedVisitor("endVisit(" + "Short" + ")");
+  }
+
+  public boolean visit(Short node)
+  { 
+    unimplementedVisitor("visit(" + "Short" + ")");
+    return true;
+  }
+
+  public void endVisit(Int node)
+  { 
+    unimplementedVisitor("endVisit(" + "Int" + ")");
+  }
+
+  public boolean visit(Int node)
+  { 
+    unimplementedVisitor("visit(" + "Int" + ")");
+    return true;
+  }
+
+  public void endVisit(Long node)
+  { 
+    unimplementedVisitor("endVisit(" + "Long" + ")");
+  }
+
+  public boolean visit(Long node)
+  { 
+    unimplementedVisitor("visit(" + "Long" + ")");
+    return true;
+  }
+
+  public void endVisit(Char node)
+  { 
+    unimplementedVisitor("endVisit(" + "Char" + ")");
+  }
+
+  public boolean visit(Char node)
+  { 
+    unimplementedVisitor("visit(" + "Char" + ")");
+    return true;
+  }
+
+  public void endVisit(Float node)
+  { 
+    unimplementedVisitor("endVisit(" + "Float" + ")");
+  }
+
+  public boolean visit(Float node)
+  { 
+    unimplementedVisitor("visit(" + "Float" + ")");
+    return true;
+  }
+
+  public void endVisit(Double node)
+  { 
+    unimplementedVisitor("endVisit(" + "Double" + ")");
+  }
+
+  public boolean visit(Double node)
+  { 
+    unimplementedVisitor("visit(" + "Double" + ")");
+    return true;
+  }
+
+  public void endVisit(PackageName node)
+  { 
+    unimplementedVisitor("endVisit(" + "PackageName" + ")");
+  }
+
+  public boolean visit(PackageName node)
+  { 
+    unimplementedVisitor("visit(" + "PackageName" + ")");
+    return true;
+  }
+
+  public void endVisit(AmbName0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "AmbName0" + ")");
+  }
+
+  public boolean visit(AmbName0 node)
+  { 
+    unimplementedVisitor("visit(" + "AmbName0" + ")");
+    return true;
+  }
+
+  public void endVisit(AmbName node)
+  { 
+    unimplementedVisitor("endVisit(" + "AmbName" + ")");
+  }
+
+  public boolean visit(AmbName node)
+  { 
+    unimplementedVisitor("visit(" + "AmbName" + ")");
+    return true;
+  }
+
+  public void endVisit(TypeName0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "TypeName0" + ")");
+  }
+
+  public boolean visit(TypeName0 node)
+  { 
+    unimplementedVisitor("visit(" + "TypeName0" + ")");
+    return true;
+  }
+
+  public void endVisit(TypeName node)
+  { 
+    unimplementedVisitor("endVisit(" + "TypeName" + ")");
+  }
+
+  public boolean visit(TypeName node)
+  { 
+    unimplementedVisitor("visit(" + "TypeName" + ")");
+    return true;
+  }
+
+  public void endVisit(ExprName0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ExprName0" + ")");
+  }
+
+  public boolean visit(ExprName0 node)
+  { 
+    unimplementedVisitor("visit(" + "ExprName0" + ")");
+    return true;
+  }
+
+  public void endVisit(ExprName node)
+  { 
+    unimplementedVisitor("endVisit(" + "ExprName" + ")");
+  }
+
+  public boolean visit(ExprName node)
+  { 
+    unimplementedVisitor("visit(" + "ExprName" + ")");
+    return true;
+  }
+
+  public void endVisit(MethodName0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "MethodName0" + ")");
+  }
+
+  public boolean visit(MethodName0 node)
+  { 
+    unimplementedVisitor("visit(" + "MethodName0" + ")");
+    return true;
+  }
+
+  public void endVisit(MethodName node)
+  { 
+    unimplementedVisitor("endVisit(" + "MethodName" + ")");
+  }
+
+  public boolean visit(MethodName node)
+  { 
+    unimplementedVisitor("visit(" + "MethodName" + ")");
+    return true;
+  }
+
+  public void endVisit(PackageOrTypeName0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "PackageOrTypeName0" + ")");
+  }
+
+  public boolean visit(PackageOrTypeName0 node)
+  { 
+    unimplementedVisitor("visit(" + "PackageOrTypeName0" + ")");
+    return true;
+  }
+
+  public void endVisit(PackageOrTypeName node)
+  { 
+    unimplementedVisitor("endVisit(" + "PackageOrTypeName" + ")");
+  }
+
+  public boolean visit(PackageOrTypeName node)
+  { 
+    unimplementedVisitor("visit(" + "PackageOrTypeName" + ")");
+    return true;
+  }
+
+  public void endVisit(TypeArgs node)
+  { 
+    unimplementedVisitor("endVisit(" + "TypeArgs" + ")");
+  }
+
+  public boolean visit(TypeArgs node)
+  { 
+    unimplementedVisitor("visit(" + "TypeArgs" + ")");
+    return true;
+  }
+
+  public void endVisit(ActualTypeArg_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "ActualTypeArg_JavaObject" + ")");
+  }
+
+  public boolean visit(ActualTypeArg_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "ActualTypeArg_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(Wildcard node)
+  { 
+    unimplementedVisitor("endVisit(" + "Wildcard" + ")");
+  }
+
+  public boolean visit(Wildcard node)
+  { 
+    unimplementedVisitor("visit(" + "Wildcard" + ")");
+    return true;
+  }
+
+  public void endVisit(WildcardUpperBound node)
+  { 
+    unimplementedVisitor("endVisit(" + "WildcardUpperBound" + ")");
+  }
+
+  public boolean visit(WildcardUpperBound node)
+  { 
+    unimplementedVisitor("visit(" + "WildcardUpperBound" + ")");
+    return true;
+  }
+
+  public void endVisit(WildcardLowerBound node)
+  { 
+    unimplementedVisitor("endVisit(" + "WildcardLowerBound" + ")");
+  }
+
+  public boolean visit(WildcardLowerBound node)
+  { 
+    unimplementedVisitor("visit(" + "WildcardLowerBound" + ")");
+    return true;
+  }
+
+  public void endVisit(TypeParam node)
+  { 
+    unimplementedVisitor("endVisit(" + "TypeParam" + ")");
+  }
+
+  public boolean visit(TypeParam node)
+  { 
+    unimplementedVisitor("visit(" + "TypeParam" + ")");
+    return true;
+  }
+
+  public void endVisit(TypeBound node)
+  { 
+    unimplementedVisitor("endVisit(" + "TypeBound" + ")");
+  }
+
+  public boolean visit(TypeBound node)
+  { 
+    unimplementedVisitor("visit(" + "TypeBound" + ")");
+    return true;
+  }
+
+  public void endVisit(TypeParams node)
+  { 
+    unimplementedVisitor("endVisit(" + "TypeParams" + ")");
+  }
+
+  public boolean visit(TypeParams node)
+  { 
+    unimplementedVisitor("visit(" + "TypeParams" + ")");
+    return true;
+  }
+
+  public void endVisit(TypeVarId_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "TypeVarId_JavaObject" + ")");
+  }
+
+  public boolean visit(TypeVarId_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "TypeVarId_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(RefType_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "RefType_JavaObject0" + ")");
+  }
+
+  public boolean visit(RefType_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "RefType_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(RefType_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "RefType_JavaObject" + ")");
+  }
+
+  public boolean visit(RefType_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "RefType_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(ClassOrInterfaceType node)
+  { 
+    unimplementedVisitor("endVisit(" + "ClassOrInterfaceType" + ")");
+  }
+
+  public boolean visit(ClassOrInterfaceType node)
+  { 
+    unimplementedVisitor("visit(" + "ClassOrInterfaceType" + ")");
+    return true;
+  }
+
+  public void endVisit(ClassType node)
+  { 
+    unimplementedVisitor("endVisit(" + "ClassType" + ")");
+  }
+
+  public boolean visit(ClassType node)
+  { 
+    unimplementedVisitor("visit(" + "ClassType" + ")");
+    return true;
+  }
+
+  public void endVisit(InterfaceType node)
+  { 
+    unimplementedVisitor("endVisit(" + "InterfaceType" + ")");
+  }
+
+  public boolean visit(InterfaceType node)
+  { 
+    unimplementedVisitor("visit(" + "InterfaceType" + ")");
+    return true;
+  }
+
+  public void endVisit(TypeDecSpec_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "TypeDecSpec_JavaObject" + ")");
+  }
+
+  public boolean visit(TypeDecSpec_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "TypeDecSpec_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(Member node)
+  { 
+    unimplementedVisitor("endVisit(" + "Member" + ")");
+  }
+
+  public boolean visit(Member node)
+  { 
+    unimplementedVisitor("visit(" + "Member" + ")");
+    return true;
+  }
+
+  public void endVisit(TypeVar node)
+  { 
+    unimplementedVisitor("endVisit(" + "TypeVar" + ")");
+  }
+
+  public boolean visit(TypeVar node)
+  { 
+    unimplementedVisitor("visit(" + "TypeVar" + ")");
+    return true;
+  }
+
+  public void endVisit(ArrayType node)
+  { 
+    unimplementedVisitor("endVisit(" + "ArrayType" + ")");
+  }
+
+  public boolean visit(ArrayType node)
+  { 
+    unimplementedVisitor("visit(" + "ArrayType" + ")");
+    return true;
+  }
+
+  public void endVisit(Type_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Type_JavaObject0" + ")");
+  }
+
+  public boolean visit(Type_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "Type_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(Type_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "Type_JavaObject" + ")");
+  }
+
+  public boolean visit(Type_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "Type_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(Lit node)
+  { 
+    unimplementedVisitor("endVisit(" + "Lit" + ")");
+  }
+
+  public boolean visit(Lit node)
+  { 
+    unimplementedVisitor("visit(" + "Lit" + ")");
+    return true;
+  }
+
+  public void endVisit(Literal_JavaObject5 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Literal_JavaObject5" + ")");
+  }
+
+  public boolean visit(Literal_JavaObject5 node)
+  { 
+    unimplementedVisitor("visit(" + "Literal_JavaObject5" + ")");
+    return true;
+  }
+
+  public void endVisit(Literal_JavaObject4 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Literal_JavaObject4" + ")");
+  }
+
+  public boolean visit(Literal_JavaObject4 node)
+  { 
+    unimplementedVisitor("visit(" + "Literal_JavaObject4" + ")");
+    return true;
+  }
+
+  public void endVisit(Literal_JavaObject3 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Literal_JavaObject3" + ")");
+  }
+
+  public boolean visit(Literal_JavaObject3 node)
+  { 
+    unimplementedVisitor("visit(" + "Literal_JavaObject3" + ")");
+    return true;
+  }
+
+  public void endVisit(Literal_JavaObject2 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Literal_JavaObject2" + ")");
+  }
+
+  public boolean visit(Literal_JavaObject2 node)
+  { 
+    unimplementedVisitor("visit(" + "Literal_JavaObject2" + ")");
+    return true;
+  }
+
+  public void endVisit(Literal_JavaObject1 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Literal_JavaObject1" + ")");
+  }
+
+  public boolean visit(Literal_JavaObject1 node)
+  { 
+    unimplementedVisitor("visit(" + "Literal_JavaObject1" + ")");
+    return true;
+  }
+
+  public void endVisit(Literal_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Literal_JavaObject0" + ")");
+  }
+
+  public boolean visit(Literal_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "Literal_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(Literal_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "Literal_JavaObject" + ")");
+  }
+
+  public boolean visit(Literal_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "Literal_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(Class node)
+  { 
+    unimplementedVisitor("endVisit(" + "Class" + ")");
+  }
+
+  public boolean visit(Class node)
+  { 
+    unimplementedVisitor("visit(" + "Class" + ")");
+    return true;
+  }
+
+  public void endVisit(VoidClass node)
+  { 
+    unimplementedVisitor("endVisit(" + "VoidClass" + ")");
+  }
+
+  public boolean visit(VoidClass node)
+  { 
+    unimplementedVisitor("visit(" + "VoidClass" + ")");
+    return true;
+  }
+
+  public void endVisit(This node)
+  { 
+    unimplementedVisitor("endVisit(" + "This" + ")");
+  }
+
+  public boolean visit(This node)
+  { 
+    unimplementedVisitor("visit(" + "This" + ")");
+    return true;
+  }
+
+  public void endVisit(QThis node)
+  { 
+    unimplementedVisitor("endVisit(" + "QThis" + ")");
+  }
+
+  public boolean visit(QThis node)
+  { 
+    unimplementedVisitor("visit(" + "QThis" + ")");
+    return true;
+  }
+
+  public void endVisit(Expr node)
+  { 
+    unimplementedVisitor("endVisit(" + "Expr" + ")");
+  }
+
+  public boolean visit(Expr node)
+  { 
+    unimplementedVisitor("visit(" + "Expr" + ")");
+    return true;
+  }
+
+  public void endVisit(ArrayInit0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ArrayInit0" + ")");
+  }
+
+  public boolean visit(ArrayInit0 node)
+  { 
+    unimplementedVisitor("visit(" + "ArrayInit0" + ")");
+    return true;
+  }
+
+  public void endVisit(ArrayInit node)
+  { 
+    unimplementedVisitor("endVisit(" + "ArrayInit" + ")");
+  }
+
+  public boolean visit(ArrayInit node)
+  { 
+    unimplementedVisitor("visit(" + "ArrayInit" + ")");
+    return true;
+  }
+
+  public void endVisit(FieldDec node)
+  { 
+    unimplementedVisitor("endVisit(" + "FieldDec" + ")");
+  }
+
+  public boolean visit(FieldDec node)
+  { 
+    unimplementedVisitor("visit(" + "FieldDec" + ")");
+    return true;
+  }
+
+  public void endVisit(VarDec0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "VarDec0" + ")");
+  }
+
+  public boolean visit(VarDec0 node)
+  { 
+    unimplementedVisitor("visit(" + "VarDec0" + ")");
+    return true;
+  }
+
+  public void endVisit(VarDec node)
+  { 
+    unimplementedVisitor("endVisit(" + "VarDec" + ")");
+  }
+
+  public boolean visit(VarDec node)
+  { 
+    unimplementedVisitor("visit(" + "VarDec" + ")");
+    return true;
+  }
+
+  public void endVisit(VarDecId_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "VarDecId_JavaObject" + ")");
+  }
+
+  public boolean visit(VarDecId_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "VarDecId_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(ArrayVarDecId node)
+  { 
+    unimplementedVisitor("endVisit(" + "ArrayVarDecId" + ")");
+  }
+
+  public boolean visit(ArrayVarDecId node)
+  { 
+    unimplementedVisitor("visit(" + "ArrayVarDecId" + ")");
+    return true;
+  }
+
+  public void endVisit(Dim0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Dim0" + ")");
+  }
+
+  public boolean visit(Dim0 node)
+  { 
+    unimplementedVisitor("visit(" + "Dim0" + ")");
+    return true;
+  }
+
+  public void endVisit(VarInit_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "VarInit_JavaObject0" + ")");
+  }
+
+  public boolean visit(VarInit_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "VarInit_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(VarInit_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "VarInit_JavaObject" + ")");
+  }
+
+  public boolean visit(VarInit_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "VarInit_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(FieldMod_JavaObject5 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FieldMod_JavaObject5" + ")");
+  }
+
+  public boolean visit(FieldMod_JavaObject5 node)
+  { 
+    unimplementedVisitor("visit(" + "FieldMod_JavaObject5" + ")");
+    return true;
+  }
+
+  public void endVisit(FieldMod_JavaObject4 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FieldMod_JavaObject4" + ")");
+  }
+
+  public boolean visit(FieldMod_JavaObject4 node)
+  { 
+    unimplementedVisitor("visit(" + "FieldMod_JavaObject4" + ")");
+    return true;
+  }
+
+  public void endVisit(FieldMod_JavaObject3 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FieldMod_JavaObject3" + ")");
+  }
+
+  public boolean visit(FieldMod_JavaObject3 node)
+  { 
+    unimplementedVisitor("visit(" + "FieldMod_JavaObject3" + ")");
+    return true;
+  }
+
+  public void endVisit(FieldMod_JavaObject2 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FieldMod_JavaObject2" + ")");
+  }
+
+  public boolean visit(FieldMod_JavaObject2 node)
+  { 
+    unimplementedVisitor("visit(" + "FieldMod_JavaObject2" + ")");
+    return true;
+  }
+
+  public void endVisit(FieldMod_JavaObject1 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FieldMod_JavaObject1" + ")");
+  }
+
+  public boolean visit(FieldMod_JavaObject1 node)
+  { 
+    unimplementedVisitor("visit(" + "FieldMod_JavaObject1" + ")");
+    return true;
+  }
+
+  public void endVisit(FieldMod_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FieldMod_JavaObject0" + ")");
+  }
+
+  public boolean visit(FieldMod_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "FieldMod_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(FieldMod_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "FieldMod_JavaObject" + ")");
+  }
+
+  public boolean visit(FieldMod_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "FieldMod_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(LocalVarDecStm node)
+  { 
+    unimplementedVisitor("endVisit(" + "LocalVarDecStm" + ")");
+  }
+
+  public boolean visit(LocalVarDecStm node)
+  { 
+    unimplementedVisitor("visit(" + "LocalVarDecStm" + ")");
+    return true;
+  }
+
+  public void endVisit(LocalVarDec node)
+  { 
+    unimplementedVisitor("endVisit(" + "LocalVarDec" + ")");
+  }
+
+  public boolean visit(LocalVarDec node)
+  { 
+    unimplementedVisitor("visit(" + "LocalVarDec" + ")");
+    return true;
+  }
+
+  public void endVisit(Stm_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "Stm_JavaObject" + ")");
+  }
+
+  public boolean visit(Stm_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "Stm_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(Empty node)
+  { 
+    unimplementedVisitor("endVisit(" + "Empty" + ")");
+  }
+
+  public boolean visit(Empty node)
+  { 
+    unimplementedVisitor("visit(" + "Empty" + ")");
+    return true;
+  }
+
+  public void endVisit(Labeled node)
+  { 
+    unimplementedVisitor("endVisit(" + "Labeled" + ")");
+  }
+
+  public boolean visit(Labeled node)
+  { 
+    unimplementedVisitor("visit(" + "Labeled" + ")");
+    return true;
+  }
+
+  public void endVisit(ExprStm node)
+  { 
+    unimplementedVisitor("endVisit(" + "ExprStm" + ")");
+  }
+
+  public boolean visit(ExprStm node)
+  { 
+    unimplementedVisitor("visit(" + "ExprStm" + ")");
+    return true;
+  }
+
+  public void endVisit(If0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "If0" + ")");
+  }
+
+  public boolean visit(If0 node)
+  { 
+    unimplementedVisitor("visit(" + "If0" + ")");
+    return true;
+  }
+
+  public void endVisit(If node)
+  { 
+    unimplementedVisitor("endVisit(" + "If" + ")");
+  }
+
+  public boolean visit(If node)
+  { 
+    unimplementedVisitor("visit(" + "If" + ")");
+    return true;
+  }
+
+  public void endVisit(AssertStm0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "AssertStm0" + ")");
+  }
+
+  public boolean visit(AssertStm0 node)
+  { 
+    unimplementedVisitor("visit(" + "AssertStm0" + ")");
+    return true;
+  }
+
+  public void endVisit(AssertStm node)
+  { 
+    unimplementedVisitor("endVisit(" + "AssertStm" + ")");
+  }
+
+  public boolean visit(AssertStm node)
+  { 
+    unimplementedVisitor("visit(" + "AssertStm" + ")");
+    return true;
+  }
+
+  public void endVisit(Switch node)
+  { 
+    unimplementedVisitor("endVisit(" + "Switch" + ")");
+  }
+
+  public boolean visit(Switch node)
+  { 
+    unimplementedVisitor("visit(" + "Switch" + ")");
+    return true;
+  }
+
+  public void endVisit(SwitchBlock node)
+  { 
+    unimplementedVisitor("endVisit(" + "SwitchBlock" + ")");
+  }
+
+  public boolean visit(SwitchBlock node)
+  { 
+    unimplementedVisitor("visit(" + "SwitchBlock" + ")");
+    return true;
+  }
+
+  public void endVisit(SwitchGroup node)
+  { 
+    unimplementedVisitor("endVisit(" + "SwitchGroup" + ")");
+  }
+
+  public boolean visit(SwitchGroup node)
+  { 
+    unimplementedVisitor("visit(" + "SwitchGroup" + ")");
+    return true;
+  }
+
+  public void endVisit(Case node)
+  { 
+    unimplementedVisitor("endVisit(" + "Case" + ")");
+  }
+
+  public boolean visit(Case node)
+  { 
+    unimplementedVisitor("visit(" + "Case" + ")");
+    return true;
+  }
+
+  public void endVisit(Default node)
+  { 
+    unimplementedVisitor("endVisit(" + "Default" + ")");
+  }
+
+  public boolean visit(Default node)
+  { 
+    unimplementedVisitor("visit(" + "Default" + ")");
+    return true;
+  }
+
+  public void endVisit(While node)
+  { 
+    unimplementedVisitor("endVisit(" + "While" + ")");
+  }
+
+  public boolean visit(While node)
+  { 
+    unimplementedVisitor("visit(" + "While" + ")");
+    return true;
+  }
+
+  public void endVisit(DoWhile node)
+  { 
+    unimplementedVisitor("endVisit(" + "DoWhile" + ")");
+  }
+
+  public boolean visit(DoWhile node)
+  { 
+    unimplementedVisitor("visit(" + "DoWhile" + ")");
+    return true;
+  }
+
+  public void endVisit(For0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "For0" + ")");
+  }
+
+  public boolean visit(For0 node)
+  { 
+    unimplementedVisitor("visit(" + "For0" + ")");
+    return true;
+  }
+
+  public void endVisit(For node)
+  { 
+    unimplementedVisitor("endVisit(" + "For" + ")");
+  }
+
+  public boolean visit(For node)
+  { 
+    unimplementedVisitor("visit(" + "For" + ")");
+    return true;
+  }
+
+  public void endVisit(ForEach node)
+  { 
+    unimplementedVisitor("endVisit(" + "ForEach" + ")");
+  }
+
+  public boolean visit(ForEach node)
+  { 
+    unimplementedVisitor("visit(" + "ForEach" + ")");
+    return true;
+  }
+
+  public void endVisit(Break node)
+  { 
+    unimplementedVisitor("endVisit(" + "Break" + ")");
+  }
+
+  public boolean visit(Break node)
+  { 
+    unimplementedVisitor("visit(" + "Break" + ")");
+    return true;
+  }
+
+  public void endVisit(Continue node)
+  { 
+    unimplementedVisitor("endVisit(" + "Continue" + ")");
+  }
+
+  public boolean visit(Continue node)
+  { 
+    unimplementedVisitor("visit(" + "Continue" + ")");
+    return true;
+  }
+
+  public void endVisit(Return node)
+  { 
+    unimplementedVisitor("endVisit(" + "Return" + ")");
+  }
+
+  public boolean visit(Return node)
+  { 
+    unimplementedVisitor("visit(" + "Return" + ")");
+    return true;
+  }
+
+  public void endVisit(Throw node)
+  { 
+    unimplementedVisitor("endVisit(" + "Throw" + ")");
+  }
+
+  public boolean visit(Throw node)
+  { 
+    unimplementedVisitor("visit(" + "Throw" + ")");
+    return true;
+  }
+
+  public void endVisit(Synchronized node)
+  { 
+    unimplementedVisitor("endVisit(" + "Synchronized" + ")");
+  }
+
+  public boolean visit(Synchronized node)
+  { 
+    unimplementedVisitor("visit(" + "Synchronized" + ")");
+    return true;
+  }
+
+  public void endVisit(Try0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Try0" + ")");
+  }
+
+  public boolean visit(Try0 node)
+  { 
+    unimplementedVisitor("visit(" + "Try0" + ")");
+    return true;
+  }
+
+  public void endVisit(Try node)
+  { 
+    unimplementedVisitor("endVisit(" + "Try" + ")");
+  }
+
+  public boolean visit(Try node)
+  { 
+    unimplementedVisitor("visit(" + "Try" + ")");
+    return true;
+  }
+
+  public void endVisit(Catch node)
+  { 
+    unimplementedVisitor("endVisit(" + "Catch" + ")");
+  }
+
+  public boolean visit(Catch node)
+  { 
+    unimplementedVisitor("visit(" + "Catch" + ")");
+    return true;
+  }
+
+  public void endVisit(Block node)
+  { 
+    unimplementedVisitor("endVisit(" + "Block" + ")");
+  }
+
+  public boolean visit(Block node)
+  { 
+    unimplementedVisitor("visit(" + "Block" + ")");
+    return true;
+  }
+
+  public void endVisit(BlockStm_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "BlockStm_JavaObject0" + ")");
+  }
+
+  public boolean visit(BlockStm_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "BlockStm_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(ClassDecStm node)
+  { 
+    unimplementedVisitor("endVisit(" + "ClassDecStm" + ")");
+  }
+
+  public boolean visit(ClassDecStm node)
+  { 
+    unimplementedVisitor("visit(" + "ClassDecStm" + ")");
+    return true;
+  }
+
+  public void endVisit(BlockStm_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "BlockStm_JavaObject" + ")");
+  }
+
+  public boolean visit(BlockStm_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "BlockStm_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(MethodDec node)
+  { 
+    unimplementedVisitor("endVisit(" + "MethodDec" + ")");
+  }
+
+  public boolean visit(MethodDec node)
+  { 
+    unimplementedVisitor("visit(" + "MethodDec" + ")");
+    return true;
+  }
+
+  public void endVisit(MethodDecHead node)
+  { 
+    unimplementedVisitor("endVisit(" + "MethodDecHead" + ")");
+  }
+
+  public boolean visit(MethodDecHead node)
+  { 
+    unimplementedVisitor("visit(" + "MethodDecHead" + ")");
+    return true;
+  }
+
+  public void endVisit(DeprMethodDecHead node)
+  { 
+    unimplementedVisitor("endVisit(" + "DeprMethodDecHead" + ")");
+  }
+
+  public boolean visit(DeprMethodDecHead node)
+  { 
+    unimplementedVisitor("visit(" + "DeprMethodDecHead" + ")");
+    return true;
+  }
+
+  public void endVisit(ResultType_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "ResultType_JavaObject" + ")");
+  }
+
+  public boolean visit(ResultType_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "ResultType_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(Void node)
+  { 
+    unimplementedVisitor("endVisit(" + "Void" + ")");
+  }
+
+  public boolean visit(Void node)
+  { 
+    unimplementedVisitor("visit(" + "Void" + ")");
+    return true;
+  }
+
+  public void endVisit(Param node)
+  { 
+    unimplementedVisitor("endVisit(" + "Param" + ")");
+  }
+
+  public boolean visit(Param node)
+  { 
+    unimplementedVisitor("visit(" + "Param" + ")");
+    return true;
+  }
+
+  public void endVisit(VarArityParam node)
+  { 
+    unimplementedVisitor("endVisit(" + "VarArityParam" + ")");
+  }
+
+  public boolean visit(VarArityParam node)
+  { 
+    unimplementedVisitor("visit(" + "VarArityParam" + ")");
+    return true;
+  }
+
+  public void endVisit(VarMod_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "VarMod_JavaObject" + ")");
+  }
+
+  public boolean visit(VarMod_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "VarMod_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(MethodMod_JavaObject7 node)
+  { 
+    unimplementedVisitor("endVisit(" + "MethodMod_JavaObject7" + ")");
+  }
+
+  public boolean visit(MethodMod_JavaObject7 node)
+  { 
+    unimplementedVisitor("visit(" + "MethodMod_JavaObject7" + ")");
+    return true;
+  }
+
+  public void endVisit(MethodMod_JavaObject6 node)
+  { 
+    unimplementedVisitor("endVisit(" + "MethodMod_JavaObject6" + ")");
+  }
+
+  public boolean visit(MethodMod_JavaObject6 node)
+  { 
+    unimplementedVisitor("visit(" + "MethodMod_JavaObject6" + ")");
+    return true;
+  }
+
+  public void endVisit(MethodMod_JavaObject5 node)
+  { 
+    unimplementedVisitor("endVisit(" + "MethodMod_JavaObject5" + ")");
+  }
+
+  public boolean visit(MethodMod_JavaObject5 node)
+  { 
+    unimplementedVisitor("visit(" + "MethodMod_JavaObject5" + ")");
+    return true;
+  }
+
+  public void endVisit(MethodMod_JavaObject4 node)
+  { 
+    unimplementedVisitor("endVisit(" + "MethodMod_JavaObject4" + ")");
+  }
+
+  public boolean visit(MethodMod_JavaObject4 node)
+  { 
+    unimplementedVisitor("visit(" + "MethodMod_JavaObject4" + ")");
+    return true;
+  }
+
+  public void endVisit(MethodMod_JavaObject3 node)
+  { 
+    unimplementedVisitor("endVisit(" + "MethodMod_JavaObject3" + ")");
+  }
+
+  public boolean visit(MethodMod_JavaObject3 node)
+  { 
+    unimplementedVisitor("visit(" + "MethodMod_JavaObject3" + ")");
+    return true;
+  }
+
+  public void endVisit(MethodMod_JavaObject2 node)
+  { 
+    unimplementedVisitor("endVisit(" + "MethodMod_JavaObject2" + ")");
+  }
+
+  public boolean visit(MethodMod_JavaObject2 node)
+  { 
+    unimplementedVisitor("visit(" + "MethodMod_JavaObject2" + ")");
+    return true;
+  }
+
+  public void endVisit(MethodMod_JavaObject1 node)
+  { 
+    unimplementedVisitor("endVisit(" + "MethodMod_JavaObject1" + ")");
+  }
+
+  public boolean visit(MethodMod_JavaObject1 node)
+  { 
+    unimplementedVisitor("visit(" + "MethodMod_JavaObject1" + ")");
+    return true;
+  }
+
+  public void endVisit(MethodMod_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "MethodMod_JavaObject0" + ")");
+  }
+
+  public boolean visit(MethodMod_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "MethodMod_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(MethodMod_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "MethodMod_JavaObject" + ")");
+  }
+
+  public boolean visit(MethodMod_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "MethodMod_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(ThrowsDec node)
+  { 
+    unimplementedVisitor("endVisit(" + "ThrowsDec" + ")");
+  }
+
+  public boolean visit(ThrowsDec node)
+  { 
+    unimplementedVisitor("visit(" + "ThrowsDec" + ")");
+    return true;
+  }
+
+  public void endVisit(ExceptionType_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "ExceptionType_JavaObject" + ")");
+  }
+
+  public boolean visit(ExceptionType_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "ExceptionType_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(MethodBody_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "MethodBody_JavaObject" + ")");
+  }
+
+  public boolean visit(MethodBody_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "MethodBody_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(NoMethodBody node)
+  { 
+    unimplementedVisitor("endVisit(" + "NoMethodBody" + ")");
+  }
+
+  public boolean visit(NoMethodBody node)
+  { 
+    unimplementedVisitor("visit(" + "NoMethodBody" + ")");
+    return true;
+  }
+
+  public void endVisit(InstanceInit node)
+  { 
+    unimplementedVisitor("endVisit(" + "InstanceInit" + ")");
+  }
+
+  public boolean visit(InstanceInit node)
+  { 
+    unimplementedVisitor("visit(" + "InstanceInit" + ")");
+    return true;
+  }
+
+  public void endVisit(StaticInit node)
+  { 
+    unimplementedVisitor("endVisit(" + "StaticInit" + ")");
+  }
+
+  public boolean visit(StaticInit node)
+  { 
+    unimplementedVisitor("visit(" + "StaticInit" + ")");
+    return true;
+  }
+
+  public void endVisit(ConstrDec node)
+  { 
+    unimplementedVisitor("endVisit(" + "ConstrDec" + ")");
+  }
+
+  public boolean visit(ConstrDec node)
+  { 
+    unimplementedVisitor("visit(" + "ConstrDec" + ")");
+    return true;
+  }
+
+  public void endVisit(ConstrDecHead node)
+  { 
+    unimplementedVisitor("endVisit(" + "ConstrDecHead" + ")");
+  }
+
+  public boolean visit(ConstrDecHead node)
+  { 
+    unimplementedVisitor("visit(" + "ConstrDecHead" + ")");
+    return true;
+  }
+
+  public void endVisit(ConstrBody node)
+  { 
+    unimplementedVisitor("endVisit(" + "ConstrBody" + ")");
+  }
+
+  public boolean visit(ConstrBody node)
+  { 
+    unimplementedVisitor("visit(" + "ConstrBody" + ")");
+    return true;
+  }
+
+  public void endVisit(AltConstrInv node)
+  { 
+    unimplementedVisitor("endVisit(" + "AltConstrInv" + ")");
+  }
+
+  public boolean visit(AltConstrInv node)
+  { 
+    unimplementedVisitor("visit(" + "AltConstrInv" + ")");
+    return true;
+  }
+
+  public void endVisit(SuperConstrInv node)
+  { 
+    unimplementedVisitor("endVisit(" + "SuperConstrInv" + ")");
+  }
+
+  public boolean visit(SuperConstrInv node)
+  { 
+    unimplementedVisitor("visit(" + "SuperConstrInv" + ")");
+    return true;
+  }
+
+  public void endVisit(QSuperConstrInv node)
+  { 
+    unimplementedVisitor("endVisit(" + "QSuperConstrInv" + ")");
+  }
+
+  public boolean visit(QSuperConstrInv node)
+  { 
+    unimplementedVisitor("visit(" + "QSuperConstrInv" + ")");
+    return true;
+  }
+
+  public void endVisit(ConstrMod_JavaObject1 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ConstrMod_JavaObject1" + ")");
+  }
+
+  public boolean visit(ConstrMod_JavaObject1 node)
+  { 
+    unimplementedVisitor("visit(" + "ConstrMod_JavaObject1" + ")");
+    return true;
+  }
+
+  public void endVisit(ConstrMod_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ConstrMod_JavaObject0" + ")");
+  }
+
+  public boolean visit(ConstrMod_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "ConstrMod_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(ConstrMod_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "ConstrMod_JavaObject" + ")");
+  }
+
+  public boolean visit(ConstrMod_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "ConstrMod_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(EnumDec node)
+  { 
+    unimplementedVisitor("endVisit(" + "EnumDec" + ")");
+  }
+
+  public boolean visit(EnumDec node)
+  { 
+    unimplementedVisitor("visit(" + "EnumDec" + ")");
+    return true;
+  }
+
+  public void endVisit(EnumDecHead node)
+  { 
+    unimplementedVisitor("endVisit(" + "EnumDecHead" + ")");
+  }
+
+  public boolean visit(EnumDecHead node)
+  { 
+    unimplementedVisitor("visit(" + "EnumDecHead" + ")");
+    return true;
+  }
+
+  public void endVisit(EnumBody0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "EnumBody0" + ")");
+  }
+
+  public boolean visit(EnumBody0 node)
+  { 
+    unimplementedVisitor("visit(" + "EnumBody0" + ")");
+    return true;
+  }
+
+  public void endVisit(EnumBody node)
+  { 
+    unimplementedVisitor("endVisit(" + "EnumBody" + ")");
+  }
+
+  public boolean visit(EnumBody node)
+  { 
+    unimplementedVisitor("visit(" + "EnumBody" + ")");
+    return true;
+  }
+
+  public void endVisit(EnumConst node)
+  { 
+    unimplementedVisitor("endVisit(" + "EnumConst" + ")");
+  }
+
+  public boolean visit(EnumConst node)
+  { 
+    unimplementedVisitor("visit(" + "EnumConst" + ")");
+    return true;
+  }
+
+  public void endVisit(EnumConstArgs node)
+  { 
+    unimplementedVisitor("endVisit(" + "EnumConstArgs" + ")");
+  }
+
+  public boolean visit(EnumConstArgs node)
+  { 
+    unimplementedVisitor("visit(" + "EnumConstArgs" + ")");
+    return true;
+  }
+
+  public void endVisit(EnumBodyDecs node)
+  { 
+    unimplementedVisitor("endVisit(" + "EnumBodyDecs" + ")");
+  }
+
+  public boolean visit(EnumBodyDecs node)
+  { 
+    unimplementedVisitor("visit(" + "EnumBodyDecs" + ")");
+    return true;
+  }
+
+  public void endVisit(ConstantDec node)
+  { 
+    unimplementedVisitor("endVisit(" + "ConstantDec" + ")");
+  }
+
+  public boolean visit(ConstantDec node)
+  { 
+    unimplementedVisitor("visit(" + "ConstantDec" + ")");
+    return true;
+  }
+
+  public void endVisit(ConstantMod_JavaObject1 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ConstantMod_JavaObject1" + ")");
+  }
+
+  public boolean visit(ConstantMod_JavaObject1 node)
+  { 
+    unimplementedVisitor("visit(" + "ConstantMod_JavaObject1" + ")");
+    return true;
+  }
+
+  public void endVisit(ConstantMod_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ConstantMod_JavaObject0" + ")");
+  }
+
+  public boolean visit(ConstantMod_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "ConstantMod_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(ConstantMod_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "ConstantMod_JavaObject" + ")");
+  }
+
+  public boolean visit(ConstantMod_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "ConstantMod_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(AbstractMethodDec node)
+  { 
+    unimplementedVisitor("endVisit(" + "AbstractMethodDec" + ")");
+  }
+
+  public boolean visit(AbstractMethodDec node)
+  { 
+    unimplementedVisitor("visit(" + "AbstractMethodDec" + ")");
+    return true;
+  }
+
+  public void endVisit(DeprAbstractMethodDec node)
+  { 
+    unimplementedVisitor("endVisit(" + "DeprAbstractMethodDec" + ")");
+  }
+
+  public boolean visit(DeprAbstractMethodDec node)
+  { 
+    unimplementedVisitor("visit(" + "DeprAbstractMethodDec" + ")");
+    return true;
+  }
+
+  public void endVisit(AbstractMethodMod_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "AbstractMethodMod_JavaObject0" + ")");
+  }
+
+  public boolean visit(AbstractMethodMod_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "AbstractMethodMod_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(AbstractMethodMod_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "AbstractMethodMod_JavaObject" + ")");
+  }
+
+  public boolean visit(AbstractMethodMod_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "AbstractMethodMod_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(AnnoDec node)
+  { 
+    unimplementedVisitor("endVisit(" + "AnnoDec" + ")");
+  }
+
+  public boolean visit(AnnoDec node)
+  { 
+    unimplementedVisitor("visit(" + "AnnoDec" + ")");
+    return true;
+  }
+
+  public void endVisit(AnnoDecHead node)
+  { 
+    unimplementedVisitor("endVisit(" + "AnnoDecHead" + ")");
+  }
+
+  public boolean visit(AnnoDecHead node)
+  { 
+    unimplementedVisitor("visit(" + "AnnoDecHead" + ")");
+    return true;
+  }
+
+  public void endVisit(AnnoMethodDec node)
+  { 
+    unimplementedVisitor("endVisit(" + "AnnoMethodDec" + ")");
+  }
+
+  public boolean visit(AnnoMethodDec node)
+  { 
+    unimplementedVisitor("visit(" + "AnnoMethodDec" + ")");
+    return true;
+  }
+
+  public void endVisit(AnnoElemDec_JavaObject3 node)
+  { 
+    unimplementedVisitor("endVisit(" + "AnnoElemDec_JavaObject3" + ")");
+  }
+
+  public boolean visit(AnnoElemDec_JavaObject3 node)
+  { 
+    unimplementedVisitor("visit(" + "AnnoElemDec_JavaObject3" + ")");
+    return true;
+  }
+
+  public void endVisit(AnnoElemDec_JavaObject2 node)
+  { 
+    unimplementedVisitor("endVisit(" + "AnnoElemDec_JavaObject2" + ")");
+  }
+
+  public boolean visit(AnnoElemDec_JavaObject2 node)
+  { 
+    unimplementedVisitor("visit(" + "AnnoElemDec_JavaObject2" + ")");
+    return true;
+  }
+
+  public void endVisit(AnnoElemDec_JavaObject1 node)
+  { 
+    unimplementedVisitor("endVisit(" + "AnnoElemDec_JavaObject1" + ")");
+  }
+
+  public boolean visit(AnnoElemDec_JavaObject1 node)
+  { 
+    unimplementedVisitor("visit(" + "AnnoElemDec_JavaObject1" + ")");
+    return true;
+  }
+
+  public void endVisit(AnnoElemDec_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "AnnoElemDec_JavaObject0" + ")");
+  }
+
+  public boolean visit(AnnoElemDec_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "AnnoElemDec_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(AnnoElemDec_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "AnnoElemDec_JavaObject" + ")");
+  }
+
+  public boolean visit(AnnoElemDec_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "AnnoElemDec_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(Semicolon2 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Semicolon2" + ")");
+  }
+
+  public boolean visit(Semicolon2 node)
+  { 
+    unimplementedVisitor("visit(" + "Semicolon2" + ")");
+    return true;
+  }
+
+  public void endVisit(DefaultVal node)
+  { 
+    unimplementedVisitor("endVisit(" + "DefaultVal" + ")");
+  }
+
+  public boolean visit(DefaultVal node)
+  { 
+    unimplementedVisitor("visit(" + "DefaultVal" + ")");
+    return true;
+  }
+
+  public void endVisit(InterfaceDec_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "InterfaceDec_JavaObject" + ")");
+  }
+
+  public boolean visit(InterfaceDec_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "InterfaceDec_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(InterfaceDec node)
+  { 
+    unimplementedVisitor("endVisit(" + "InterfaceDec" + ")");
+  }
+
+  public boolean visit(InterfaceDec node)
+  { 
+    unimplementedVisitor("visit(" + "InterfaceDec" + ")");
+    return true;
+  }
+
+  public void endVisit(InterfaceDecHead node)
+  { 
+    unimplementedVisitor("endVisit(" + "InterfaceDecHead" + ")");
+  }
+
+  public boolean visit(InterfaceDecHead node)
+  { 
+    unimplementedVisitor("visit(" + "InterfaceDecHead" + ")");
+    return true;
+  }
+
+  public void endVisit(ExtendsInterfaces node)
+  { 
+    unimplementedVisitor("endVisit(" + "ExtendsInterfaces" + ")");
+  }
+
+  public boolean visit(ExtendsInterfaces node)
+  { 
+    unimplementedVisitor("visit(" + "ExtendsInterfaces" + ")");
+    return true;
+  }
+
+  public void endVisit(InterfaceMemberDec_JavaObject2 node)
+  { 
+    unimplementedVisitor("endVisit(" + "InterfaceMemberDec_JavaObject2" + ")");
+  }
+
+  public boolean visit(InterfaceMemberDec_JavaObject2 node)
+  { 
+    unimplementedVisitor("visit(" + "InterfaceMemberDec_JavaObject2" + ")");
+    return true;
+  }
+
+  public void endVisit(InterfaceMemberDec_JavaObject1 node)
+  { 
+    unimplementedVisitor("endVisit(" + "InterfaceMemberDec_JavaObject1" + ")");
+  }
+
+  public boolean visit(InterfaceMemberDec_JavaObject1 node)
+  { 
+    unimplementedVisitor("visit(" + "InterfaceMemberDec_JavaObject1" + ")");
+    return true;
+  }
+
+  public void endVisit(InterfaceMemberDec_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "InterfaceMemberDec_JavaObject0" + ")");
+  }
+
+  public boolean visit(InterfaceMemberDec_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "InterfaceMemberDec_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(InterfaceMemberDec_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "InterfaceMemberDec_JavaObject" + ")");
+  }
+
+  public boolean visit(InterfaceMemberDec_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "InterfaceMemberDec_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(Semicolon1 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Semicolon1" + ")");
+  }
+
+  public boolean visit(Semicolon1 node)
+  { 
+    unimplementedVisitor("visit(" + "Semicolon1" + ")");
+    return true;
+  }
+
+  public void endVisit(InterfaceMod_JavaObject4 node)
+  { 
+    unimplementedVisitor("endVisit(" + "InterfaceMod_JavaObject4" + ")");
+  }
+
+  public boolean visit(InterfaceMod_JavaObject4 node)
+  { 
+    unimplementedVisitor("visit(" + "InterfaceMod_JavaObject4" + ")");
+    return true;
+  }
+
+  public void endVisit(InterfaceMod_JavaObject3 node)
+  { 
+    unimplementedVisitor("endVisit(" + "InterfaceMod_JavaObject3" + ")");
+  }
+
+  public boolean visit(InterfaceMod_JavaObject3 node)
+  { 
+    unimplementedVisitor("visit(" + "InterfaceMod_JavaObject3" + ")");
+    return true;
+  }
+
+  public void endVisit(InterfaceMod_JavaObject2 node)
+  { 
+    unimplementedVisitor("endVisit(" + "InterfaceMod_JavaObject2" + ")");
+  }
+
+  public boolean visit(InterfaceMod_JavaObject2 node)
+  { 
+    unimplementedVisitor("visit(" + "InterfaceMod_JavaObject2" + ")");
+    return true;
+  }
+
+  public void endVisit(InterfaceMod_JavaObject1 node)
+  { 
+    unimplementedVisitor("endVisit(" + "InterfaceMod_JavaObject1" + ")");
+  }
+
+  public boolean visit(InterfaceMod_JavaObject1 node)
+  { 
+    unimplementedVisitor("visit(" + "InterfaceMod_JavaObject1" + ")");
+    return true;
+  }
+
+  public void endVisit(InterfaceMod_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "InterfaceMod_JavaObject0" + ")");
+  }
+
+  public boolean visit(InterfaceMod_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "InterfaceMod_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(InterfaceMod_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "InterfaceMod_JavaObject" + ")");
+  }
+
+  public boolean visit(InterfaceMod_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "InterfaceMod_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(ClassDec_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "ClassDec_JavaObject" + ")");
+  }
+
+  public boolean visit(ClassDec_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "ClassDec_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(ClassDec node)
+  { 
+    unimplementedVisitor("endVisit(" + "ClassDec" + ")");
+  }
+
+  public boolean visit(ClassDec node)
+  { 
+    unimplementedVisitor("visit(" + "ClassDec" + ")");
+    return true;
+  }
+
+  public void endVisit(ClassBody node)
+  { 
+    unimplementedVisitor("endVisit(" + "ClassBody" + ")");
+  }
+
+  public boolean visit(ClassBody node)
+  { 
+    unimplementedVisitor("visit(" + "ClassBody" + ")");
+    return true;
+  }
+
+  public void endVisit(ClassDecHead node)
+  { 
+    unimplementedVisitor("endVisit(" + "ClassDecHead" + ")");
+  }
+
+  public boolean visit(ClassDecHead node)
+  { 
+    unimplementedVisitor("visit(" + "ClassDecHead" + ")");
+    return true;
+  }
+
+  public void endVisit(ClassMod_JavaObject5 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ClassMod_JavaObject5" + ")");
+  }
+
+  public boolean visit(ClassMod_JavaObject5 node)
+  { 
+    unimplementedVisitor("visit(" + "ClassMod_JavaObject5" + ")");
+    return true;
+  }
+
+  public void endVisit(ClassMod_JavaObject4 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ClassMod_JavaObject4" + ")");
+  }
+
+  public boolean visit(ClassMod_JavaObject4 node)
+  { 
+    unimplementedVisitor("visit(" + "ClassMod_JavaObject4" + ")");
+    return true;
+  }
+
+  public void endVisit(ClassMod_JavaObject3 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ClassMod_JavaObject3" + ")");
+  }
+
+  public boolean visit(ClassMod_JavaObject3 node)
+  { 
+    unimplementedVisitor("visit(" + "ClassMod_JavaObject3" + ")");
+    return true;
+  }
+
+  public void endVisit(ClassMod_JavaObject2 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ClassMod_JavaObject2" + ")");
+  }
+
+  public boolean visit(ClassMod_JavaObject2 node)
+  { 
+    unimplementedVisitor("visit(" + "ClassMod_JavaObject2" + ")");
+    return true;
+  }
+
+  public void endVisit(ClassMod_JavaObject1 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ClassMod_JavaObject1" + ")");
+  }
+
+  public boolean visit(ClassMod_JavaObject1 node)
+  { 
+    unimplementedVisitor("visit(" + "ClassMod_JavaObject1" + ")");
+    return true;
+  }
+
+  public void endVisit(ClassMod_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ClassMod_JavaObject0" + ")");
+  }
+
+  public boolean visit(ClassMod_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "ClassMod_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(ClassMod_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "ClassMod_JavaObject" + ")");
+  }
+
+  public boolean visit(ClassMod_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "ClassMod_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(SuperDec node)
+  { 
+    unimplementedVisitor("endVisit(" + "SuperDec" + ")");
+  }
+
+  public boolean visit(SuperDec node)
+  { 
+    unimplementedVisitor("visit(" + "SuperDec" + ")");
+    return true;
+  }
+
+  public void endVisit(ImplementsDec node)
+  { 
+    unimplementedVisitor("endVisit(" + "ImplementsDec" + ")");
+  }
+
+  public boolean visit(ImplementsDec node)
+  { 
+    unimplementedVisitor("visit(" + "ImplementsDec" + ")");
+    return true;
+  }
+
+  public void endVisit(ClassBodyDec_JavaObject2 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ClassBodyDec_JavaObject2" + ")");
+  }
+
+  public boolean visit(ClassBodyDec_JavaObject2 node)
+  { 
+    unimplementedVisitor("visit(" + "ClassBodyDec_JavaObject2" + ")");
+    return true;
+  }
+
+  public void endVisit(ClassBodyDec_JavaObject1 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ClassBodyDec_JavaObject1" + ")");
+  }
+
+  public boolean visit(ClassBodyDec_JavaObject1 node)
+  { 
+    unimplementedVisitor("visit(" + "ClassBodyDec_JavaObject1" + ")");
+    return true;
+  }
+
+  public void endVisit(ClassBodyDec_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ClassBodyDec_JavaObject0" + ")");
+  }
+
+  public boolean visit(ClassBodyDec_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "ClassBodyDec_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(ClassBodyDec_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "ClassBodyDec_JavaObject" + ")");
+  }
+
+  public boolean visit(ClassBodyDec_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "ClassBodyDec_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(ClassMemberDec_JavaObject2 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ClassMemberDec_JavaObject2" + ")");
+  }
+
+  public boolean visit(ClassMemberDec_JavaObject2 node)
+  { 
+    unimplementedVisitor("visit(" + "ClassMemberDec_JavaObject2" + ")");
+    return true;
+  }
+
+  public void endVisit(ClassMemberDec_JavaObject1 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ClassMemberDec_JavaObject1" + ")");
+  }
+
+  public boolean visit(ClassMemberDec_JavaObject1 node)
+  { 
+    unimplementedVisitor("visit(" + "ClassMemberDec_JavaObject1" + ")");
+    return true;
+  }
+
+  public void endVisit(ClassMemberDec_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ClassMemberDec_JavaObject0" + ")");
+  }
+
+  public boolean visit(ClassMemberDec_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "ClassMemberDec_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(ClassMemberDec_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "ClassMemberDec_JavaObject" + ")");
+  }
+
+  public boolean visit(ClassMemberDec_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "ClassMemberDec_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(Semicolon0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Semicolon0" + ")");
+  }
+
+  public boolean visit(Semicolon0 node)
+  { 
+    unimplementedVisitor("visit(" + "Semicolon0" + ")");
+    return true;
+  }
+
+  public void endVisit(NewInstance node)
+  { 
+    unimplementedVisitor("endVisit(" + "NewInstance" + ")");
+  }
+
+  public boolean visit(NewInstance node)
+  { 
+    unimplementedVisitor("visit(" + "NewInstance" + ")");
+    return true;
+  }
+
+  public void endVisit(QNewInstance node)
+  { 
+    unimplementedVisitor("endVisit(" + "QNewInstance" + ")");
+  }
+
+  public boolean visit(QNewInstance node)
+  { 
+    unimplementedVisitor("visit(" + "QNewInstance" + ")");
+    return true;
+  }
+
+  public void endVisit(Expr_JavaObject3 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Expr_JavaObject3" + ")");
+  }
+
+  public boolean visit(Expr_JavaObject3 node)
+  { 
+    unimplementedVisitor("visit(" + "Expr_JavaObject3" + ")");
+    return true;
+  }
+
+  public void endVisit(NewArray0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "NewArray0" + ")");
+  }
+
+  public boolean visit(NewArray0 node)
+  { 
+    unimplementedVisitor("visit(" + "NewArray0" + ")");
+    return true;
+  }
+
+  public void endVisit(NewArray node)
+  { 
+    unimplementedVisitor("endVisit(" + "NewArray" + ")");
+  }
+
+  public boolean visit(NewArray node)
+  { 
+    unimplementedVisitor("visit(" + "NewArray" + ")");
+    return true;
+  }
+
+  public void endVisit(ArrayBaseType_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ArrayBaseType_JavaObject0" + ")");
+  }
+
+  public boolean visit(ArrayBaseType_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "ArrayBaseType_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(ArrayBaseType_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "ArrayBaseType_JavaObject" + ")");
+  }
+
+  public boolean visit(ArrayBaseType_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "ArrayBaseType_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(UnboundWld node)
+  { 
+    unimplementedVisitor("endVisit(" + "UnboundWld" + ")");
+  }
+
+  public boolean visit(UnboundWld node)
+  { 
+    unimplementedVisitor("visit(" + "UnboundWld" + ")");
+    return true;
+  }
+
+  public void endVisit(Dim node)
+  { 
+    unimplementedVisitor("endVisit(" + "Dim" + ")");
+  }
+
+  public boolean visit(Dim node)
+  { 
+    unimplementedVisitor("visit(" + "Dim" + ")");
+    return true;
+  }
+
+  public void endVisit(Expr_JavaObject2 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Expr_JavaObject2" + ")");
+  }
+
+  public boolean visit(Expr_JavaObject2 node)
+  { 
+    unimplementedVisitor("visit(" + "Expr_JavaObject2" + ")");
+    return true;
+  }
+
+  public void endVisit(Field node)
+  { 
+    unimplementedVisitor("endVisit(" + "Field" + ")");
+  }
+
+  public boolean visit(Field node)
+  { 
+    unimplementedVisitor("visit(" + "Field" + ")");
+    return true;
+  }
+
+  public void endVisit(SuperField node)
+  { 
+    unimplementedVisitor("endVisit(" + "SuperField" + ")");
+  }
+
+  public boolean visit(SuperField node)
+  { 
+    unimplementedVisitor("visit(" + "SuperField" + ")");
+    return true;
+  }
+
+  public void endVisit(QSuperField node)
+  { 
+    unimplementedVisitor("endVisit(" + "QSuperField" + ")");
+  }
+
+  public boolean visit(QSuperField node)
+  { 
+    unimplementedVisitor("visit(" + "QSuperField" + ")");
+    return true;
+  }
+
+  public void endVisit(Expr_JavaObject1 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Expr_JavaObject1" + ")");
+  }
+
+  public boolean visit(Expr_JavaObject1 node)
+  { 
+    unimplementedVisitor("visit(" + "Expr_JavaObject1" + ")");
+    return true;
+  }
+
+  public void endVisit(ArrayAccess node)
+  { 
+    unimplementedVisitor("endVisit(" + "ArrayAccess" + ")");
+  }
+
+  public boolean visit(ArrayAccess node)
+  { 
+    unimplementedVisitor("visit(" + "ArrayAccess" + ")");
+    return true;
+  }
+
+  public void endVisit(ArraySubscript node)
+  { 
+    unimplementedVisitor("endVisit(" + "ArraySubscript" + ")");
+  }
+
+  public boolean visit(ArraySubscript node)
+  { 
+    unimplementedVisitor("visit(" + "ArraySubscript" + ")");
+    return true;
+  }
+
+  public void endVisit(Invoke node)
+  { 
+    unimplementedVisitor("endVisit(" + "Invoke" + ")");
+  }
+
+  public boolean visit(Invoke node)
+  { 
+    unimplementedVisitor("visit(" + "Invoke" + ")");
+    return true;
+  }
+
+  public void endVisit(Method0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Method0" + ")");
+  }
+
+  public boolean visit(Method0 node)
+  { 
+    unimplementedVisitor("visit(" + "Method0" + ")");
+    return true;
+  }
+
+  public void endVisit(Method node)
+  { 
+    unimplementedVisitor("endVisit(" + "Method" + ")");
+  }
+
+  public boolean visit(Method node)
+  { 
+    unimplementedVisitor("visit(" + "Method" + ")");
+    return true;
+  }
+
+  public void endVisit(SuperMethod node)
+  { 
+    unimplementedVisitor("endVisit(" + "SuperMethod" + ")");
+  }
+
+  public boolean visit(SuperMethod node)
+  { 
+    unimplementedVisitor("visit(" + "SuperMethod" + ")");
+    return true;
+  }
+
+  public void endVisit(QSuperMethod node)
+  { 
+    unimplementedVisitor("endVisit(" + "QSuperMethod" + ")");
+  }
+
+  public boolean visit(QSuperMethod node)
+  { 
+    unimplementedVisitor("visit(" + "QSuperMethod" + ")");
+    return true;
+  }
+
+  public void endVisit(GenericMethod node)
+  { 
+    unimplementedVisitor("endVisit(" + "GenericMethod" + ")");
+  }
+
+  public boolean visit(GenericMethod node)
+  { 
+    unimplementedVisitor("visit(" + "GenericMethod" + ")");
+    return true;
+  }
+
+  public void endVisit(Expr_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Expr_JavaObject0" + ")");
+  }
+
+  public boolean visit(Expr_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "Expr_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(PostIncr node)
+  { 
+    unimplementedVisitor("endVisit(" + "PostIncr" + ")");
+  }
+
+  public boolean visit(PostIncr node)
+  { 
+    unimplementedVisitor("visit(" + "PostIncr" + ")");
+    return true;
+  }
+
+  public void endVisit(PostDecr node)
+  { 
+    unimplementedVisitor("endVisit(" + "PostDecr" + ")");
+  }
+
+  public boolean visit(PostDecr node)
+  { 
+    unimplementedVisitor("visit(" + "PostDecr" + ")");
+    return true;
+  }
+
+  public void endVisit(Plus0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Plus0" + ")");
+  }
+
+  public boolean visit(Plus0 node)
+  { 
+    unimplementedVisitor("visit(" + "Plus0" + ")");
+    return true;
+  }
+
+  public void endVisit(Minus0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Minus0" + ")");
+  }
+
+  public boolean visit(Minus0 node)
+  { 
+    unimplementedVisitor("visit(" + "Minus0" + ")");
+    return true;
+  }
+
+  public void endVisit(PreIncr node)
+  { 
+    unimplementedVisitor("endVisit(" + "PreIncr" + ")");
+  }
+
+  public boolean visit(PreIncr node)
+  { 
+    unimplementedVisitor("visit(" + "PreIncr" + ")");
+    return true;
+  }
+
+  public void endVisit(PreDecr node)
+  { 
+    unimplementedVisitor("endVisit(" + "PreDecr" + ")");
+  }
+
+  public boolean visit(PreDecr node)
+  { 
+    unimplementedVisitor("visit(" + "PreDecr" + ")");
+    return true;
+  }
+
+  public void endVisit(Complement node)
+  { 
+    unimplementedVisitor("endVisit(" + "Complement" + ")");
+  }
+
+  public boolean visit(Complement node)
+  { 
+    unimplementedVisitor("visit(" + "Complement" + ")");
+    return true;
+  }
+
+  public void endVisit(Not node)
+  { 
+    unimplementedVisitor("endVisit(" + "Not" + ")");
+  }
+
+  public boolean visit(Not node)
+  { 
+    unimplementedVisitor("visit(" + "Not" + ")");
+    return true;
+  }
+
+  public void endVisit(CastPrim node)
+  { 
+    unimplementedVisitor("endVisit(" + "CastPrim" + ")");
+  }
+
+  public boolean visit(CastPrim node)
+  { 
+    unimplementedVisitor("visit(" + "CastPrim" + ")");
+    return true;
+  }
+
+  public void endVisit(CastRef node)
+  { 
+    unimplementedVisitor("endVisit(" + "CastRef" + ")");
+  }
+
+  public boolean visit(CastRef node)
+  { 
+    unimplementedVisitor("visit(" + "CastRef" + ")");
+    return true;
+  }
+
+  public void endVisit(Expr_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "Expr_JavaObject" + ")");
+  }
+
+  public boolean visit(Expr_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "Expr_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(InstanceOf node)
+  { 
+    unimplementedVisitor("endVisit(" + "InstanceOf" + ")");
+  }
+
+  public boolean visit(InstanceOf node)
+  { 
+    unimplementedVisitor("visit(" + "InstanceOf" + ")");
+    return true;
+  }
+
+  public void endVisit(Mul node)
+  { 
+    unimplementedVisitor("endVisit(" + "Mul" + ")");
+  }
+
+  public boolean visit(Mul node)
+  { 
+    unimplementedVisitor("visit(" + "Mul" + ")");
+    return true;
+  }
+
+  public void endVisit(Div node)
+  { 
+    unimplementedVisitor("endVisit(" + "Div" + ")");
+  }
+
+  public boolean visit(Div node)
+  { 
+    unimplementedVisitor("visit(" + "Div" + ")");
+    return true;
+  }
+
+  public void endVisit(Remain node)
+  { 
+    unimplementedVisitor("endVisit(" + "Remain" + ")");
+  }
+
+  public boolean visit(Remain node)
+  { 
+    unimplementedVisitor("visit(" + "Remain" + ")");
+    return true;
+  }
+
+  public void endVisit(Plus node)
+  { 
+    unimplementedVisitor("endVisit(" + "Plus" + ")");
+  }
+
+  public boolean visit(Plus node)
+  { 
+    unimplementedVisitor("visit(" + "Plus" + ")");
+    return true;
+  }
+
+  public void endVisit(Minus node)
+  { 
+    unimplementedVisitor("endVisit(" + "Minus" + ")");
+  }
+
+  public boolean visit(Minus node)
+  { 
+    unimplementedVisitor("visit(" + "Minus" + ")");
+    return true;
+  }
+
+  public void endVisit(LeftShift node)
+  { 
+    unimplementedVisitor("endVisit(" + "LeftShift" + ")");
+  }
+
+  public boolean visit(LeftShift node)
+  { 
+    unimplementedVisitor("visit(" + "LeftShift" + ")");
+    return true;
+  }
+
+  public void endVisit(RightShift node)
+  { 
+    unimplementedVisitor("endVisit(" + "RightShift" + ")");
+  }
+
+  public boolean visit(RightShift node)
+  { 
+    unimplementedVisitor("visit(" + "RightShift" + ")");
+    return true;
+  }
+
+  public void endVisit(URightShift node)
+  { 
+    unimplementedVisitor("endVisit(" + "URightShift" + ")");
+  }
+
+  public boolean visit(URightShift node)
+  { 
+    unimplementedVisitor("visit(" + "URightShift" + ")");
+    return true;
+  }
+
+  public void endVisit(Lt node)
+  { 
+    unimplementedVisitor("endVisit(" + "Lt" + ")");
+  }
+
+  public boolean visit(Lt node)
+  { 
+    unimplementedVisitor("visit(" + "Lt" + ")");
+    return true;
+  }
+
+  public void endVisit(Gt node)
+  { 
+    unimplementedVisitor("endVisit(" + "Gt" + ")");
+  }
+
+  public boolean visit(Gt node)
+  { 
+    unimplementedVisitor("visit(" + "Gt" + ")");
+    return true;
+  }
+
+  public void endVisit(LtEq node)
+  { 
+    unimplementedVisitor("endVisit(" + "LtEq" + ")");
+  }
+
+  public boolean visit(LtEq node)
+  { 
+    unimplementedVisitor("visit(" + "LtEq" + ")");
+    return true;
+  }
+
+  public void endVisit(GtEq node)
+  { 
+    unimplementedVisitor("endVisit(" + "GtEq" + ")");
+  }
+
+  public boolean visit(GtEq node)
+  { 
+    unimplementedVisitor("visit(" + "GtEq" + ")");
+    return true;
+  }
+
+  public void endVisit(Eq node)
+  { 
+    unimplementedVisitor("endVisit(" + "Eq" + ")");
+  }
+
+  public boolean visit(Eq node)
+  { 
+    unimplementedVisitor("visit(" + "Eq" + ")");
+    return true;
+  }
+
+  public void endVisit(NotEq node)
+  { 
+    unimplementedVisitor("endVisit(" + "NotEq" + ")");
+  }
+
+  public boolean visit(NotEq node)
+  { 
+    unimplementedVisitor("visit(" + "NotEq" + ")");
+    return true;
+  }
+
+  public void endVisit(LazyAnd node)
+  { 
+    unimplementedVisitor("endVisit(" + "LazyAnd" + ")");
+  }
+
+  public boolean visit(LazyAnd node)
+  { 
+    unimplementedVisitor("visit(" + "LazyAnd" + ")");
+    return true;
+  }
+
+  public void endVisit(LazyOr node)
+  { 
+    unimplementedVisitor("endVisit(" + "LazyOr" + ")");
+  }
+
+  public boolean visit(LazyOr node)
+  { 
+    unimplementedVisitor("visit(" + "LazyOr" + ")");
+    return true;
+  }
+
+  public void endVisit(And node)
+  { 
+    unimplementedVisitor("endVisit(" + "And" + ")");
+  }
+
+  public boolean visit(And node)
+  { 
+    unimplementedVisitor("visit(" + "And" + ")");
+    return true;
+  }
+
+  public void endVisit(ExcOr node)
+  { 
+    unimplementedVisitor("endVisit(" + "ExcOr" + ")");
+  }
+
+  public boolean visit(ExcOr node)
+  { 
+    unimplementedVisitor("visit(" + "ExcOr" + ")");
+    return true;
+  }
+
+  public void endVisit(Or node)
+  { 
+    unimplementedVisitor("endVisit(" + "Or" + ")");
+  }
+
+  public boolean visit(Or node)
+  { 
+    unimplementedVisitor("visit(" + "Or" + ")");
+    return true;
+  }
+
+  public void endVisit(Cond node)
+  { 
+    unimplementedVisitor("endVisit(" + "Cond" + ")");
+  }
+
+  public boolean visit(Cond node)
+  { 
+    unimplementedVisitor("visit(" + "Cond" + ")");
+    return true;
+  }
+
+  public void endVisit(CondMid node)
+  { 
+    unimplementedVisitor("endVisit(" + "CondMid" + ")");
+  }
+
+  public boolean visit(CondMid node)
+  { 
+    unimplementedVisitor("visit(" + "CondMid" + ")");
+    return true;
+  }
+
+  public void endVisit(Assign node)
+  { 
+    unimplementedVisitor("endVisit(" + "Assign" + ")");
+  }
+
+  public boolean visit(Assign node)
+  { 
+    unimplementedVisitor("visit(" + "Assign" + ")");
+    return true;
+  }
+
+  public void endVisit(AssignMul node)
+  { 
+    unimplementedVisitor("endVisit(" + "AssignMul" + ")");
+  }
+
+  public boolean visit(AssignMul node)
+  { 
+    unimplementedVisitor("visit(" + "AssignMul" + ")");
+    return true;
+  }
+
+  public void endVisit(AssignDiv node)
+  { 
+    unimplementedVisitor("endVisit(" + "AssignDiv" + ")");
+  }
+
+  public boolean visit(AssignDiv node)
+  { 
+    unimplementedVisitor("visit(" + "AssignDiv" + ")");
+    return true;
+  }
+
+  public void endVisit(AssignRemain node)
+  { 
+    unimplementedVisitor("endVisit(" + "AssignRemain" + ")");
+  }
+
+  public boolean visit(AssignRemain node)
+  { 
+    unimplementedVisitor("visit(" + "AssignRemain" + ")");
+    return true;
+  }
+
+  public void endVisit(AssignPlus node)
+  { 
+    unimplementedVisitor("endVisit(" + "AssignPlus" + ")");
+  }
+
+  public boolean visit(AssignPlus node)
+  { 
+    unimplementedVisitor("visit(" + "AssignPlus" + ")");
+    return true;
+  }
+
+  public void endVisit(AssignMinus node)
+  { 
+    unimplementedVisitor("endVisit(" + "AssignMinus" + ")");
+  }
+
+  public boolean visit(AssignMinus node)
+  { 
+    unimplementedVisitor("visit(" + "AssignMinus" + ")");
+    return true;
+  }
+
+  public void endVisit(AssignLeftShift node)
+  { 
+    unimplementedVisitor("endVisit(" + "AssignLeftShift" + ")");
+  }
+
+  public boolean visit(AssignLeftShift node)
+  { 
+    unimplementedVisitor("visit(" + "AssignLeftShift" + ")");
+    return true;
+  }
+
+  public void endVisit(AssignRightShift node)
+  { 
+    unimplementedVisitor("endVisit(" + "AssignRightShift" + ")");
+  }
+
+  public boolean visit(AssignRightShift node)
+  { 
+    unimplementedVisitor("visit(" + "AssignRightShift" + ")");
+    return true;
+  }
+
+  public void endVisit(AssignURightShift node)
+  { 
+    unimplementedVisitor("endVisit(" + "AssignURightShift" + ")");
+  }
+
+  public boolean visit(AssignURightShift node)
+  { 
+    unimplementedVisitor("visit(" + "AssignURightShift" + ")");
+    return true;
+  }
+
+  public void endVisit(AssignAnd node)
+  { 
+    unimplementedVisitor("endVisit(" + "AssignAnd" + ")");
+  }
+
+  public boolean visit(AssignAnd node)
+  { 
+    unimplementedVisitor("visit(" + "AssignAnd" + ")");
+    return true;
+  }
+
+  public void endVisit(AssignExcOr node)
+  { 
+    unimplementedVisitor("endVisit(" + "AssignExcOr" + ")");
+  }
+
+  public boolean visit(AssignExcOr node)
+  { 
+    unimplementedVisitor("visit(" + "AssignExcOr" + ")");
+    return true;
+  }
+
+  public void endVisit(AssignOr node)
+  { 
+    unimplementedVisitor("endVisit(" + "AssignOr" + ")");
+  }
+
+  public boolean visit(AssignOr node)
+  { 
+    unimplementedVisitor("visit(" + "AssignOr" + ")");
+    return true;
+  }
+
+  public void endVisit(LHS_JavaObject1 node)
+  { 
+    unimplementedVisitor("endVisit(" + "LHS_JavaObject1" + ")");
+  }
+
+  public boolean visit(LHS_JavaObject1 node)
+  { 
+    unimplementedVisitor("visit(" + "LHS_JavaObject1" + ")");
+    return true;
+  }
+
+  public void endVisit(LHS_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "LHS_JavaObject0" + ")");
+  }
+
+  public boolean visit(LHS_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "LHS_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(LHS_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "LHS_JavaObject" + ")");
+  }
+
+  public boolean visit(LHS_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "LHS_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(Anno node)
+  { 
+    unimplementedVisitor("endVisit(" + "Anno" + ")");
+  }
+
+  public boolean visit(Anno node)
+  { 
+    unimplementedVisitor("visit(" + "Anno" + ")");
+    return true;
+  }
+
+  public void endVisit(SingleElemAnno node)
+  { 
+    unimplementedVisitor("endVisit(" + "SingleElemAnno" + ")");
+  }
+
+  public boolean visit(SingleElemAnno node)
+  { 
+    unimplementedVisitor("visit(" + "SingleElemAnno" + ")");
+    return true;
+  }
+
+  public void endVisit(MarkerAnno node)
+  { 
+    unimplementedVisitor("endVisit(" + "MarkerAnno" + ")");
+  }
+
+  public boolean visit(MarkerAnno node)
+  { 
+    unimplementedVisitor("visit(" + "MarkerAnno" + ")");
+    return true;
+  }
+
+  public void endVisit(ElemValPair node)
+  { 
+    unimplementedVisitor("endVisit(" + "ElemValPair" + ")");
+  }
+
+  public boolean visit(ElemValPair node)
+  { 
+    unimplementedVisitor("visit(" + "ElemValPair" + ")");
+    return true;
+  }
+
+  public void endVisit(ElemVal_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ElemVal_JavaObject0" + ")");
+  }
+
+  public boolean visit(ElemVal_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "ElemVal_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(ElemVal_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "ElemVal_JavaObject" + ")");
+  }
+
+  public boolean visit(ElemVal_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "ElemVal_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(ElemValArrayInit0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ElemValArrayInit0" + ")");
+  }
+
+  public boolean visit(ElemValArrayInit0 node)
+  { 
+    unimplementedVisitor("visit(" + "ElemValArrayInit0" + ")");
+    return true;
+  }
+
+  public void endVisit(ElemValArrayInit node)
+  { 
+    unimplementedVisitor("endVisit(" + "ElemValArrayInit" + ")");
+  }
+
+  public boolean visit(ElemValArrayInit node)
+  { 
+    unimplementedVisitor("visit(" + "ElemValArrayInit" + ")");
+    return true;
+  }
+
+  public void endVisit(PackageDec node)
+  { 
+    unimplementedVisitor("endVisit(" + "PackageDec" + ")");
+  }
+
+  public boolean visit(PackageDec node)
+  { 
+    unimplementedVisitor("visit(" + "PackageDec" + ")");
+    return true;
+  }
+
+  public void endVisit(TypeImportDec node)
+  { 
+    unimplementedVisitor("endVisit(" + "TypeImportDec" + ")");
+  }
+
+  public boolean visit(TypeImportDec node)
+  { 
+    unimplementedVisitor("visit(" + "TypeImportDec" + ")");
+    return true;
+  }
+
+  public void endVisit(TypeImportOnDemandDec node)
+  { 
+    unimplementedVisitor("endVisit(" + "TypeImportOnDemandDec" + ")");
+  }
+
+  public boolean visit(TypeImportOnDemandDec node)
+  { 
+    unimplementedVisitor("visit(" + "TypeImportOnDemandDec" + ")");
+    return true;
+  }
+
+  public void endVisit(StaticImportDec node)
+  { 
+    unimplementedVisitor("endVisit(" + "StaticImportDec" + ")");
+  }
+
+  public boolean visit(StaticImportDec node)
+  { 
+    unimplementedVisitor("visit(" + "StaticImportDec" + ")");
+    return true;
+  }
+
+  public void endVisit(StaticImportOnDemandDec node)
+  { 
+    unimplementedVisitor("endVisit(" + "StaticImportOnDemandDec" + ")");
+  }
+
+  public boolean visit(StaticImportOnDemandDec node)
+  { 
+    unimplementedVisitor("visit(" + "StaticImportOnDemandDec" + ")");
+    return true;
+  }
+
+  public void endVisit(TypeDec_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "TypeDec_JavaObject0" + ")");
+  }
+
+  public boolean visit(TypeDec_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "TypeDec_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(TypeDec_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "TypeDec_JavaObject" + ")");
+  }
+
+  public boolean visit(TypeDec_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "TypeDec_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(Semicolon node)
+  { 
+    unimplementedVisitor("endVisit(" + "Semicolon" + ")");
+  }
+
+  public boolean visit(Semicolon node)
+  { 
+    unimplementedVisitor("visit(" + "Semicolon" + ")");
+    return true;
+  }
+
+  public void endVisit(CompilationUnit node)
+  { 
+    unimplementedVisitor("endVisit(" + "CompilationUnit" + ")");
+  }
+
+  public boolean visit(CompilationUnit node)
+  { 
+    unimplementedVisitor("visit(" + "CompilationUnit" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar41 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar41" + ")");
+  }
+
+  public boolean visit(Metavar41 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar41" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar40 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar40" + ")");
+  }
+
+  public boolean visit(Metavar40 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar40" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar39 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar39" + ")");
+  }
+
+  public boolean visit(Metavar39 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar39" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar38 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar38" + ")");
+  }
+
+  public boolean visit(Metavar38 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar38" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar37 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar37" + ")");
+  }
+
+  public boolean visit(Metavar37 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar37" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar36 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar36" + ")");
+  }
+
+  public boolean visit(Metavar36 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar36" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr80 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr80" + ")");
+  }
+
+  public boolean visit(ToMetaExpr80 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr80" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr79 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr79" + ")");
+  }
+
+  public boolean visit(ToMetaExpr79 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr79" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr78 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr78" + ")");
+  }
+
+  public boolean visit(ToMetaExpr78 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr78" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr77 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr77" + ")");
+  }
+
+  public boolean visit(ToMetaExpr77 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr77" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr76 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr76" + ")");
+  }
+
+  public boolean visit(ToMetaExpr76 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr76" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr75 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr75" + ")");
+  }
+
+  public boolean visit(ToMetaExpr75 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr75" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr74 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr74" + ")");
+  }
+
+  public boolean visit(ToMetaExpr74 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr74" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr73 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr73" + ")");
+  }
+
+  public boolean visit(ToMetaExpr73 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr73" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr72 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr72" + ")");
+  }
+
+  public boolean visit(ToMetaExpr72 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr72" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr71 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr71" + ")");
+  }
+
+  public boolean visit(ToMetaExpr71 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr71" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaListExpr7 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaListExpr7" + ")");
+  }
+
+  public boolean visit(ToMetaListExpr7 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaListExpr7" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaListExpr6 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaListExpr6" + ")");
+  }
+
+  public boolean visit(ToMetaListExpr6 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaListExpr6" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr70 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr70" + ")");
+  }
+
+  public boolean visit(ToMetaExpr70 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr70" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr69 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr69" + ")");
+  }
+
+  public boolean visit(ToMetaExpr69 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr69" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaListExpr5 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaListExpr5" + ")");
+  }
+
+  public boolean visit(ToMetaListExpr5 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaListExpr5" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaListExpr4 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaListExpr4" + ")");
+  }
+
+  public boolean visit(ToMetaListExpr4 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaListExpr4" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr68 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr68" + ")");
+  }
+
+  public boolean visit(ToMetaExpr68 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr68" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr67 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr67" + ")");
+  }
+
+  public boolean visit(ToMetaExpr67 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr67" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaListExpr3 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaListExpr3" + ")");
+  }
+
+  public boolean visit(ToMetaListExpr3 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaListExpr3" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaListExpr2 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaListExpr2" + ")");
+  }
+
+  public boolean visit(ToMetaListExpr2 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaListExpr2" + ")");
+    return true;
+  }
+
+  public void endVisit(FromMetaExpr33 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FromMetaExpr33" + ")");
+  }
+
+  public boolean visit(FromMetaExpr33 node)
+  { 
+    unimplementedVisitor("visit(" + "FromMetaExpr33" + ")");
+    return true;
+  }
+
+  public void endVisit(FromMetaExpr32 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FromMetaExpr32" + ")");
+  }
+
+  public boolean visit(FromMetaExpr32 node)
+  { 
+    unimplementedVisitor("visit(" + "FromMetaExpr32" + ")");
+    return true;
+  }
+
+  public void endVisit(FromMetaExpr31 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FromMetaExpr31" + ")");
+  }
+
+  public boolean visit(FromMetaExpr31 node)
+  { 
+    unimplementedVisitor("visit(" + "FromMetaExpr31" + ")");
+    return true;
+  }
+
+  public void endVisit(FromMetaExpr30 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FromMetaExpr30" + ")");
+  }
+
+  public boolean visit(FromMetaExpr30 node)
+  { 
+    unimplementedVisitor("visit(" + "FromMetaExpr30" + ")");
+    return true;
+  }
+
+  public void endVisit(FromMetaExpr29 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FromMetaExpr29" + ")");
+  }
+
+  public boolean visit(FromMetaExpr29 node)
+  { 
+    unimplementedVisitor("visit(" + "FromMetaExpr29" + ")");
+    return true;
+  }
+
+  public void endVisit(FromMetaExpr28 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FromMetaExpr28" + ")");
+  }
+
+  public boolean visit(FromMetaExpr28 node)
+  { 
+    unimplementedVisitor("visit(" + "FromMetaExpr28" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar35 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar35" + ")");
+  }
+
+  public boolean visit(Metavar35 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar35" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar34 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar34" + ")");
+  }
+
+  public boolean visit(Metavar34 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar34" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar33 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar33" + ")");
+  }
+
+  public boolean visit(Metavar33 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar33" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar32 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar32" + ")");
+  }
+
+  public boolean visit(Metavar32 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar32" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar31 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar31" + ")");
+  }
+
+  public boolean visit(Metavar31 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar31" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar30 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar30" + ")");
+  }
+
+  public boolean visit(Metavar30 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar30" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar29 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar29" + ")");
+  }
+
+  public boolean visit(Metavar29 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar29" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar28 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar28" + ")");
+  }
+
+  public boolean visit(Metavar28 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar28" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr66 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr66" + ")");
+  }
+
+  public boolean visit(ToMetaExpr66 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr66" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr65 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr65" + ")");
+  }
+
+  public boolean visit(ToMetaExpr65 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr65" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr64 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr64" + ")");
+  }
+
+  public boolean visit(ToMetaExpr64 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr64" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr63 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr63" + ")");
+  }
+
+  public boolean visit(ToMetaExpr63 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr63" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar27 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar27" + ")");
+  }
+
+  public boolean visit(Metavar27 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar27" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar26 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar26" + ")");
+  }
+
+  public boolean visit(Metavar26 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar26" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar25 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar25" + ")");
+  }
+
+  public boolean visit(Metavar25 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar25" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar24 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar24" + ")");
+  }
+
+  public boolean visit(Metavar24 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar24" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar23 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar23" + ")");
+  }
+
+  public boolean visit(Metavar23 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar23" + ")");
+    return true;
+  }
+
+  public void endVisit(MetaTypeVar_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "MetaTypeVar_JavaObject" + ")");
+  }
+
+  public boolean visit(MetaTypeVar_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "MetaTypeVar_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(MetaPrimTypeVar_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "MetaPrimTypeVar_JavaObject" + ")");
+  }
+
+  public boolean visit(MetaPrimTypeVar_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "MetaPrimTypeVar_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(MetaRefTypeVar_JavaObject node)
+  { 
+    unimplementedVisitor("endVisit(" + "MetaRefTypeVar_JavaObject" + ")");
+  }
+
+  public boolean visit(MetaRefTypeVar_JavaObject node)
+  { 
+    unimplementedVisitor("visit(" + "MetaRefTypeVar_JavaObject" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr62 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr62" + ")");
+  }
+
+  public boolean visit(ToMetaExpr62 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr62" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr61 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr61" + ")");
+  }
+
+  public boolean visit(ToMetaExpr61 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr61" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr60 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr60" + ")");
+  }
+
+  public boolean visit(ToMetaExpr60 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr60" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr59 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr59" + ")");
+  }
+
+  public boolean visit(ToMetaExpr59 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr59" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr58 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr58" + ")");
+  }
+
+  public boolean visit(ToMetaExpr58 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr58" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr57 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr57" + ")");
+  }
+
+  public boolean visit(ToMetaExpr57 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr57" + ")");
+    return true;
+  }
+
+  public void endVisit(FromMetaExpr27 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FromMetaExpr27" + ")");
+  }
+
+  public boolean visit(FromMetaExpr27 node)
+  { 
+    unimplementedVisitor("visit(" + "FromMetaExpr27" + ")");
+    return true;
+  }
+
+  public void endVisit(FromMetaExpr26 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FromMetaExpr26" + ")");
+  }
+
+  public boolean visit(FromMetaExpr26 node)
+  { 
+    unimplementedVisitor("visit(" + "FromMetaExpr26" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr56 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr56" + ")");
+  }
+
+  public boolean visit(ToMetaExpr56 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr56" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr55 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr55" + ")");
+  }
+
+  public boolean visit(ToMetaExpr55 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr55" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr54 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr54" + ")");
+  }
+
+  public boolean visit(ToMetaExpr54 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr54" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr53 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr53" + ")");
+  }
+
+  public boolean visit(ToMetaExpr53 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr53" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr52 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr52" + ")");
+  }
+
+  public boolean visit(ToMetaExpr52 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr52" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr51 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr51" + ")");
+  }
+
+  public boolean visit(ToMetaExpr51 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr51" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr50 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr50" + ")");
+  }
+
+  public boolean visit(ToMetaExpr50 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr50" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr49 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr49" + ")");
+  }
+
+  public boolean visit(ToMetaExpr49 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr49" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr48 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr48" + ")");
+  }
+
+  public boolean visit(ToMetaExpr48 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr48" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr47 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr47" + ")");
+  }
+
+  public boolean visit(ToMetaExpr47 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr47" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr46 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr46" + ")");
+  }
+
+  public boolean visit(ToMetaExpr46 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr46" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr45 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr45" + ")");
+  }
+
+  public boolean visit(ToMetaExpr45 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr45" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr44 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr44" + ")");
+  }
+
+  public boolean visit(ToMetaExpr44 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr44" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr43 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr43" + ")");
+  }
+
+  public boolean visit(ToMetaExpr43 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr43" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr42 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr42" + ")");
+  }
+
+  public boolean visit(ToMetaExpr42 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr42" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr41 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr41" + ")");
+  }
+
+  public boolean visit(ToMetaExpr41 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr41" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr40 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr40" + ")");
+  }
+
+  public boolean visit(ToMetaExpr40 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr40" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr39 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr39" + ")");
+  }
+
+  public boolean visit(ToMetaExpr39 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr39" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr38 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr38" + ")");
+  }
+
+  public boolean visit(ToMetaExpr38 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr38" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr37 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr37" + ")");
+  }
+
+  public boolean visit(ToMetaExpr37 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr37" + ")");
+    return true;
+  }
+
+  public void endVisit(FromMetaExpr25 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FromMetaExpr25" + ")");
+  }
+
+  public boolean visit(FromMetaExpr25 node)
+  { 
+    unimplementedVisitor("visit(" + "FromMetaExpr25" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr36 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr36" + ")");
+  }
+
+  public boolean visit(ToMetaExpr36 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr36" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr35 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr35" + ")");
+  }
+
+  public boolean visit(ToMetaExpr35 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr35" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr34 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr34" + ")");
+  }
+
+  public boolean visit(ToMetaExpr34 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr34" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr33 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr33" + ")");
+  }
+
+  public boolean visit(ToMetaExpr33 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr33" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr32 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr32" + ")");
+  }
+
+  public boolean visit(ToMetaExpr32 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr32" + ")");
+    return true;
+  }
+
+  public void endVisit(FromMetaExpr24 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FromMetaExpr24" + ")");
+  }
+
+  public boolean visit(FromMetaExpr24 node)
+  { 
+    unimplementedVisitor("visit(" + "FromMetaExpr24" + ")");
+    return true;
+  }
+
+  public void endVisit(FromMetaExpr23 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FromMetaExpr23" + ")");
+  }
+
+  public boolean visit(FromMetaExpr23 node)
+  { 
+    unimplementedVisitor("visit(" + "FromMetaExpr23" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr31 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr31" + ")");
+  }
+
+  public boolean visit(ToMetaExpr31 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr31" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr30 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr30" + ")");
+  }
+
+  public boolean visit(ToMetaExpr30 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr30" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr29 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr29" + ")");
+  }
+
+  public boolean visit(ToMetaExpr29 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr29" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaListExpr1 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaListExpr1" + ")");
+  }
+
+  public boolean visit(ToMetaListExpr1 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaListExpr1" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaListExpr0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaListExpr0" + ")");
+  }
+
+  public boolean visit(ToMetaListExpr0 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaListExpr0" + ")");
+    return true;
+  }
+
+  public void endVisit(FromMetaExpr22 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FromMetaExpr22" + ")");
+  }
+
+  public boolean visit(FromMetaExpr22 node)
+  { 
+    unimplementedVisitor("visit(" + "FromMetaExpr22" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr28 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr28" + ")");
+  }
+
+  public boolean visit(ToMetaExpr28 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr28" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr27 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr27" + ")");
+  }
+
+  public boolean visit(ToMetaExpr27 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr27" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr26 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr26" + ")");
+  }
+
+  public boolean visit(ToMetaExpr26 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr26" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr25 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr25" + ")");
+  }
+
+  public boolean visit(ToMetaExpr25 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr25" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr24 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr24" + ")");
+  }
+
+  public boolean visit(ToMetaExpr24 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr24" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr23 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr23" + ")");
+  }
+
+  public boolean visit(ToMetaExpr23 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr23" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr22 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr22" + ")");
+  }
+
+  public boolean visit(ToMetaExpr22 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr22" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr21 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr21" + ")");
+  }
+
+  public boolean visit(ToMetaExpr21 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr21" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr20 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr20" + ")");
+  }
+
+  public boolean visit(ToMetaExpr20 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr20" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr19 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr19" + ")");
+  }
+
+  public boolean visit(ToMetaExpr19 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr19" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr18 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr18" + ")");
+  }
+
+  public boolean visit(ToMetaExpr18 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr18" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr17 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr17" + ")");
+  }
+
+  public boolean visit(ToMetaExpr17 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr17" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr16 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr16" + ")");
+  }
+
+  public boolean visit(ToMetaExpr16 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr16" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr15 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr15" + ")");
+  }
+
+  public boolean visit(ToMetaExpr15 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr15" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr14 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr14" + ")");
+  }
+
+  public boolean visit(ToMetaExpr14 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr14" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr13 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr13" + ")");
+  }
+
+  public boolean visit(ToMetaExpr13 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr13" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr12 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr12" + ")");
+  }
+
+  public boolean visit(ToMetaExpr12 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr12" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr11 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr11" + ")");
+  }
+
+  public boolean visit(ToMetaExpr11 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr11" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr10 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr10" + ")");
+  }
+
+  public boolean visit(ToMetaExpr10 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr10" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr9 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr9" + ")");
+  }
+
+  public boolean visit(ToMetaExpr9 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr9" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr8 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr8" + ")");
+  }
+
+  public boolean visit(ToMetaExpr8 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr8" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr7 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr7" + ")");
+  }
+
+  public boolean visit(ToMetaExpr7 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr7" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaListExpr node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaListExpr" + ")");
+  }
+
+  public boolean visit(ToMetaListExpr node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaListExpr" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr6 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr6" + ")");
+  }
+
+  public boolean visit(ToMetaExpr6 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr6" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr5 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr5" + ")");
+  }
+
+  public boolean visit(ToMetaExpr5 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr5" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr4 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr4" + ")");
+  }
+
+  public boolean visit(ToMetaExpr4 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr4" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr3 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr3" + ")");
+  }
+
+  public boolean visit(ToMetaExpr3 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr3" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr2 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr2" + ")");
+  }
+
+  public boolean visit(ToMetaExpr2 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr2" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr1 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr1" + ")");
+  }
+
+  public boolean visit(ToMetaExpr1 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr1" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr0" + ")");
+  }
+
+  public boolean visit(ToMetaExpr0 node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr0" + ")");
+    return true;
+  }
+
+  public void endVisit(ToMetaExpr node)
+  { 
+    unimplementedVisitor("endVisit(" + "ToMetaExpr" + ")");
+  }
+
+  public boolean visit(ToMetaExpr node)
+  { 
+    unimplementedVisitor("visit(" + "ToMetaExpr" + ")");
+    return true;
+  }
+
+  public void endVisit(FromMetaExpr21 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FromMetaExpr21" + ")");
+  }
+
+  public boolean visit(FromMetaExpr21 node)
+  { 
+    unimplementedVisitor("visit(" + "FromMetaExpr21" + ")");
+    return true;
+  }
+
+  public void endVisit(FromMetaExpr20 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FromMetaExpr20" + ")");
+  }
+
+  public boolean visit(FromMetaExpr20 node)
+  { 
+    unimplementedVisitor("visit(" + "FromMetaExpr20" + ")");
+    return true;
+  }
+
+  public void endVisit(FromMetaExpr19 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FromMetaExpr19" + ")");
+  }
+
+  public boolean visit(FromMetaExpr19 node)
+  { 
+    unimplementedVisitor("visit(" + "FromMetaExpr19" + ")");
+    return true;
+  }
+
+  public void endVisit(FromMetaExpr18 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FromMetaExpr18" + ")");
+  }
+
+  public boolean visit(FromMetaExpr18 node)
+  { 
+    unimplementedVisitor("visit(" + "FromMetaExpr18" + ")");
+    return true;
+  }
+
+  public void endVisit(FromMetaExpr17 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FromMetaExpr17" + ")");
+  }
+
+  public boolean visit(FromMetaExpr17 node)
+  { 
+    unimplementedVisitor("visit(" + "FromMetaExpr17" + ")");
+    return true;
+  }
+
+  public void endVisit(FromMetaExpr16 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FromMetaExpr16" + ")");
+  }
+
+  public boolean visit(FromMetaExpr16 node)
+  { 
+    unimplementedVisitor("visit(" + "FromMetaExpr16" + ")");
+    return true;
+  }
+
+  public void endVisit(FromMetaExpr15 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FromMetaExpr15" + ")");
+  }
+
+  public boolean visit(FromMetaExpr15 node)
+  { 
+    unimplementedVisitor("visit(" + "FromMetaExpr15" + ")");
+    return true;
+  }
+
+  public void endVisit(FromMetaExpr14 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FromMetaExpr14" + ")");
+  }
+
+  public boolean visit(FromMetaExpr14 node)
+  { 
+    unimplementedVisitor("visit(" + "FromMetaExpr14" + ")");
+    return true;
+  }
+
+  public void endVisit(FromMetaExpr13 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FromMetaExpr13" + ")");
+  }
+
+  public boolean visit(FromMetaExpr13 node)
+  { 
+    unimplementedVisitor("visit(" + "FromMetaExpr13" + ")");
+    return true;
+  }
+
+  public void endVisit(FromMetaExpr12 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FromMetaExpr12" + ")");
+  }
+
+  public boolean visit(FromMetaExpr12 node)
+  { 
+    unimplementedVisitor("visit(" + "FromMetaExpr12" + ")");
+    return true;
+  }
+
+  public void endVisit(FromMetaExpr11 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FromMetaExpr11" + ")");
+  }
+
+  public boolean visit(FromMetaExpr11 node)
+  { 
+    unimplementedVisitor("visit(" + "FromMetaExpr11" + ")");
+    return true;
+  }
+
+  public void endVisit(FromMetaExpr10 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FromMetaExpr10" + ")");
+  }
+
+  public boolean visit(FromMetaExpr10 node)
+  { 
+    unimplementedVisitor("visit(" + "FromMetaExpr10" + ")");
+    return true;
+  }
+
+  public void endVisit(FromMetaExpr9 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FromMetaExpr9" + ")");
+  }
+
+  public boolean visit(FromMetaExpr9 node)
+  { 
+    unimplementedVisitor("visit(" + "FromMetaExpr9" + ")");
+    return true;
+  }
+
+  public void endVisit(FromMetaExpr8 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FromMetaExpr8" + ")");
+  }
+
+  public boolean visit(FromMetaExpr8 node)
+  { 
+    unimplementedVisitor("visit(" + "FromMetaExpr8" + ")");
+    return true;
+  }
+
+  public void endVisit(FromMetaExpr7 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FromMetaExpr7" + ")");
+  }
+
+  public boolean visit(FromMetaExpr7 node)
+  { 
+    unimplementedVisitor("visit(" + "FromMetaExpr7" + ")");
+    return true;
+  }
+
+  public void endVisit(FromMetaExpr6 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FromMetaExpr6" + ")");
+  }
+
+  public boolean visit(FromMetaExpr6 node)
+  { 
+    unimplementedVisitor("visit(" + "FromMetaExpr6" + ")");
+    return true;
+  }
+
+  public void endVisit(FromMetaExpr5 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FromMetaExpr5" + ")");
+  }
+
+  public boolean visit(FromMetaExpr5 node)
+  { 
+    unimplementedVisitor("visit(" + "FromMetaExpr5" + ")");
+    return true;
+  }
+
+  public void endVisit(FromMetaExpr4 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FromMetaExpr4" + ")");
+  }
+
+  public boolean visit(FromMetaExpr4 node)
+  { 
+    unimplementedVisitor("visit(" + "FromMetaExpr4" + ")");
+    return true;
+  }
+
+  public void endVisit(FromMetaExpr3 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FromMetaExpr3" + ")");
+  }
+
+  public boolean visit(FromMetaExpr3 node)
+  { 
+    unimplementedVisitor("visit(" + "FromMetaExpr3" + ")");
+    return true;
+  }
+
+  public void endVisit(FromMetaExpr2 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FromMetaExpr2" + ")");
+  }
+
+  public boolean visit(FromMetaExpr2 node)
+  { 
+    unimplementedVisitor("visit(" + "FromMetaExpr2" + ")");
+    return true;
+  }
+
+  public void endVisit(FromMetaExpr1 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FromMetaExpr1" + ")");
+  }
+
+  public boolean visit(FromMetaExpr1 node)
+  { 
+    unimplementedVisitor("visit(" + "FromMetaExpr1" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar22 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar22" + ")");
+  }
+
+  public boolean visit(Metavar22 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar22" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar21 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar21" + ")");
+  }
+
+  public boolean visit(Metavar21 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar21" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar20 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar20" + ")");
+  }
+
+  public boolean visit(Metavar20 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar20" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar19 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar19" + ")");
+  }
+
+  public boolean visit(Metavar19 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar19" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar18 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar18" + ")");
+  }
+
+  public boolean visit(Metavar18 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar18" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar17 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar17" + ")");
+  }
+
+  public boolean visit(Metavar17 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar17" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar16 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar16" + ")");
+  }
+
+  public boolean visit(Metavar16 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar16" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar15 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar15" + ")");
+  }
+
+  public boolean visit(Metavar15 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar15" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar14 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar14" + ")");
+  }
+
+  public boolean visit(Metavar14 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar14" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar13 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar13" + ")");
+  }
+
+  public boolean visit(Metavar13 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar13" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar12 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar12" + ")");
+  }
+
+  public boolean visit(Metavar12 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar12" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar11 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar11" + ")");
+  }
+
+  public boolean visit(Metavar11 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar11" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar10 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar10" + ")");
+  }
+
+  public boolean visit(Metavar10 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar10" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar9 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar9" + ")");
+  }
+
+  public boolean visit(Metavar9 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar9" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar8 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar8" + ")");
+  }
+
+  public boolean visit(Metavar8 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar8" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar7 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar7" + ")");
+  }
+
+  public boolean visit(Metavar7 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar7" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar6 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar6" + ")");
+  }
+
+  public boolean visit(Metavar6 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar6" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar5 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar5" + ")");
+  }
+
+  public boolean visit(Metavar5 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar5" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar4 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar4" + ")");
+  }
+
+  public boolean visit(Metavar4 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar4" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar3 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar3" + ")");
+  }
+
+  public boolean visit(Metavar3 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar3" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar2 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar2" + ")");
+  }
+
+  public boolean visit(Metavar2 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar2" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar1 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar1" + ")");
+  }
+
+  public boolean visit(Metavar1 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar1" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar0" + ")");
+  }
+
+  public boolean visit(Metavar0 node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar0" + ")");
+    return true;
+  }
+
+  public void endVisit(Metavar node)
+  { 
+    unimplementedVisitor("endVisit(" + "Metavar" + ")");
+  }
+
+  public boolean visit(Metavar node)
+  { 
+    unimplementedVisitor("visit(" + "Metavar" + ")");
+    return true;
+  }
+
+  public void endVisit(FromMetaExpr0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "FromMetaExpr0" + ")");
+  }
+
+  public boolean visit(FromMetaExpr0 node)
+  { 
+    unimplementedVisitor("visit(" + "FromMetaExpr0" + ")");
+    return true;
+  }
+
+  public void endVisit(FromMetaExpr node)
+  { 
+    unimplementedVisitor("endVisit(" + "FromMetaExpr" + ")");
+  }
+
+  public boolean visit(FromMetaExpr node)
+  { 
+    unimplementedVisitor("visit(" + "FromMetaExpr" + ")");
+    return true;
+  }
+
+  public void endVisit(ListPlusOfCommChar0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListPlusOfCommChar0" + ")");
+  }
+
+  public boolean visit(ListPlusOfCommChar0 node)
+  { 
+    unimplementedVisitor("visit(" + "ListPlusOfCommChar0" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfCommChar0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfCommChar0" + ")");
+  }
+
+  public boolean visit(ListStarOfCommChar0 node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfCommChar0" + ")");
+    return true;
+  }
+
+  public void endVisit(ListPlusOfModNamePart_StrategoHost0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListPlusOfModNamePart_StrategoHost0" + ")");
+  }
+
+  public boolean visit(ListPlusOfModNamePart_StrategoHost0 node)
+  { 
+    unimplementedVisitor("visit(" + "ListPlusOfModNamePart_StrategoHost0" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfModNamePart_StrategoHost0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfModNamePart_StrategoHost0" + ")");
+  }
+
+  public boolean visit(ListStarOfModNamePart_StrategoHost0 node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfModNamePart_StrategoHost0" + ")");
+    return true;
+  }
+
+  public void endVisit(ListPlusOfStrChar_StrategoHost0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListPlusOfStrChar_StrategoHost0" + ")");
+  }
+
+  public boolean visit(ListPlusOfStrChar_StrategoHost0 node)
+  { 
+    unimplementedVisitor("visit(" + "ListPlusOfStrChar_StrategoHost0" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfStrChar_StrategoHost0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfStrChar_StrategoHost0" + ")");
+  }
+
+  public boolean visit(ListStarOfStrChar_StrategoHost0 node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfStrChar_StrategoHost0" + ")");
+    return true;
+  }
+
+  public void endVisit(ListPlusOfCommentPart0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListPlusOfCommentPart0" + ")");
+  }
+
+  public boolean visit(ListPlusOfCommentPart0 node)
+  { 
+    unimplementedVisitor("visit(" + "ListPlusOfCommentPart0" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfCommentPart0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfCommentPart0" + ")");
+  }
+
+  public boolean visit(ListStarOfCommentPart0 node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfCommentPart0" + ")");
+    return true;
+  }
+
+  public void endVisit(OptDeciFloatExponentPart_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "OptDeciFloatExponentPart_JavaObject0" + ")");
+  }
+
+  public boolean visit(OptDeciFloatExponentPart_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "OptDeciFloatExponentPart_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(OptWildcardBound_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "OptWildcardBound_JavaObject0" + ")");
+  }
+
+  public boolean visit(OptWildcardBound_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "OptWildcardBound_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(OptTypeBound_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "OptTypeBound_JavaObject0" + ")");
+  }
+
+  public boolean visit(OptTypeBound_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "OptTypeBound_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(OptId_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "OptId_JavaObject0" + ")");
+  }
+
+  public boolean visit(OptId_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "OptId_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(OptExpr_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "OptExpr_JavaObject0" + ")");
+  }
+
+  public boolean visit(OptExpr_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "OptExpr_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(OptConstrInv_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "OptConstrInv_JavaObject0" + ")");
+  }
+
+  public boolean visit(OptConstrInv_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "OptConstrInv_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(OptEnumBodyDecs_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "OptEnumBodyDecs_JavaObject0" + ")");
+  }
+
+  public boolean visit(OptEnumBodyDecs_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "OptEnumBodyDecs_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(OptEnumConstArgs_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "OptEnumConstArgs_JavaObject0" + ")");
+  }
+
+  public boolean visit(OptEnumConstArgs_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "OptEnumConstArgs_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(Anno_JavaObject_ConstantMod_JavaObject00 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Anno_JavaObject_ConstantMod_JavaObject00" + ")");
+  }
+
+  public boolean visit(Anno_JavaObject_ConstantMod_JavaObject00 node)
+  { 
+    unimplementedVisitor("visit(" + "Anno_JavaObject_ConstantMod_JavaObject00" + ")");
+    return true;
+  }
+
+  public void endVisit(Anno_JavaObject_ConstantMod_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Anno_JavaObject_ConstantMod_JavaObject0" + ")");
+  }
+
+  public boolean visit(Anno_JavaObject_ConstantMod_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "Anno_JavaObject_ConstantMod_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(Anno_JavaObject_AbstractMethodMod_JavaObject00 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Anno_JavaObject_AbstractMethodMod_JavaObject00" + ")");
+  }
+
+  public boolean visit(Anno_JavaObject_AbstractMethodMod_JavaObject00 node)
+  { 
+    unimplementedVisitor("visit(" + "Anno_JavaObject_AbstractMethodMod_JavaObject00" + ")");
+    return true;
+  }
+
+  public void endVisit(Anno_JavaObject_AbstractMethodMod_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Anno_JavaObject_AbstractMethodMod_JavaObject0" + ")");
+  }
+
+  public boolean visit(Anno_JavaObject_AbstractMethodMod_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "Anno_JavaObject_AbstractMethodMod_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(OptThrows_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "OptThrows_JavaObject0" + ")");
+  }
+
+  public boolean visit(OptThrows_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "OptThrows_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(OptDefaultVal_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "OptDefaultVal_JavaObject0" + ")");
+  }
+
+  public boolean visit(OptDefaultVal_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "OptDefaultVal_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(Anno_JavaObject_InterfaceMod_JavaObject00 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Anno_JavaObject_InterfaceMod_JavaObject00" + ")");
+  }
+
+  public boolean visit(Anno_JavaObject_InterfaceMod_JavaObject00 node)
+  { 
+    unimplementedVisitor("visit(" + "Anno_JavaObject_InterfaceMod_JavaObject00" + ")");
+    return true;
+  }
+
+  public void endVisit(Anno_JavaObject_InterfaceMod_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Anno_JavaObject_InterfaceMod_JavaObject0" + ")");
+  }
+
+  public boolean visit(Anno_JavaObject_InterfaceMod_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "Anno_JavaObject_InterfaceMod_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(OptExtendsInterfaces_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "OptExtendsInterfaces_JavaObject0" + ")");
+  }
+
+  public boolean visit(OptExtendsInterfaces_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "OptExtendsInterfaces_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(OptTypeParams_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "OptTypeParams_JavaObject0" + ")");
+  }
+
+  public boolean visit(OptTypeParams_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "OptTypeParams_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(OptSuper_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "OptSuper_JavaObject0" + ")");
+  }
+
+  public boolean visit(OptSuper_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "OptSuper_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(OptInterfaces_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "OptInterfaces_JavaObject0" + ")");
+  }
+
+  public boolean visit(OptInterfaces_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "OptInterfaces_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(OptTypeArgs_JavaObject00 node)
+  { 
+    unimplementedVisitor("endVisit(" + "OptTypeArgs_JavaObject00" + ")");
+  }
+
+  public boolean visit(OptTypeArgs_JavaObject00 node)
+  { 
+    unimplementedVisitor("visit(" + "OptTypeArgs_JavaObject00" + ")");
+    return true;
+  }
+
+  public void endVisit(OptPackageDec_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "OptPackageDec_JavaObject0" + ")");
+  }
+
+  public boolean visit(OptPackageDec_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "OptPackageDec_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(Anno_JavaObject_MethodMod_JavaObject00 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Anno_JavaObject_MethodMod_JavaObject00" + ")");
+  }
+
+  public boolean visit(Anno_JavaObject_MethodMod_JavaObject00 node)
+  { 
+    unimplementedVisitor("visit(" + "Anno_JavaObject_MethodMod_JavaObject00" + ")");
+    return true;
+  }
+
+  public void endVisit(Anno_JavaObject_MethodMod_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Anno_JavaObject_MethodMod_JavaObject0" + ")");
+  }
+
+  public boolean visit(Anno_JavaObject_MethodMod_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "Anno_JavaObject_MethodMod_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(Anno_JavaObject_ClassMod_JavaObject00 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Anno_JavaObject_ClassMod_JavaObject00" + ")");
+  }
+
+  public boolean visit(Anno_JavaObject_ClassMod_JavaObject00 node)
+  { 
+    unimplementedVisitor("visit(" + "Anno_JavaObject_ClassMod_JavaObject00" + ")");
+    return true;
+  }
+
+  public void endVisit(Anno_JavaObject_ClassMod_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Anno_JavaObject_ClassMod_JavaObject0" + ")");
+  }
+
+  public boolean visit(Anno_JavaObject_ClassMod_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "Anno_JavaObject_ClassMod_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(Anno_JavaObject_ConstrMod_JavaObject00 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Anno_JavaObject_ConstrMod_JavaObject00" + ")");
+  }
+
+  public boolean visit(Anno_JavaObject_ConstrMod_JavaObject00 node)
+  { 
+    unimplementedVisitor("visit(" + "Anno_JavaObject_ConstrMod_JavaObject00" + ")");
+    return true;
+  }
+
+  public void endVisit(Anno_JavaObject_ConstrMod_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Anno_JavaObject_ConstrMod_JavaObject0" + ")");
+  }
+
+  public boolean visit(Anno_JavaObject_ConstrMod_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "Anno_JavaObject_ConstrMod_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(Anno_JavaObject_VarMod_JavaObject00 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Anno_JavaObject_VarMod_JavaObject00" + ")");
+  }
+
+  public boolean visit(Anno_JavaObject_VarMod_JavaObject00 node)
+  { 
+    unimplementedVisitor("visit(" + "Anno_JavaObject_VarMod_JavaObject00" + ")");
+    return true;
+  }
+
+  public void endVisit(Anno_JavaObject_VarMod_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Anno_JavaObject_VarMod_JavaObject0" + ")");
+  }
+
+  public boolean visit(Anno_JavaObject_VarMod_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "Anno_JavaObject_VarMod_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(Anno_JavaObject_FieldMod_JavaObject00 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Anno_JavaObject_FieldMod_JavaObject00" + ")");
+  }
+
+  public boolean visit(Anno_JavaObject_FieldMod_JavaObject00 node)
+  { 
+    unimplementedVisitor("visit(" + "Anno_JavaObject_FieldMod_JavaObject00" + ")");
+    return true;
+  }
+
+  public void endVisit(Anno_JavaObject_FieldMod_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "Anno_JavaObject_FieldMod_JavaObject0" + ")");
+  }
+
+  public boolean visit(Anno_JavaObject_FieldMod_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "Anno_JavaObject_FieldMod_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(OptClassBody_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "OptClassBody_JavaObject0" + ")");
+  }
+
+  public boolean visit(OptClassBody_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "OptClassBody_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(OptTypeArgs_JavaObject0 node)
+  { 
+    unimplementedVisitor("endVisit(" + "OptTypeArgs_JavaObject0" + ")");
+  }
+
+  public boolean visit(OptTypeArgs_JavaObject0 node)
+  { 
+    unimplementedVisitor("visit(" + "OptTypeArgs_JavaObject0" + ")");
+    return true;
+  }
+
+  public void endVisit(WsSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "WsSort" + ")");
+  }
+
+  public boolean visit(WsSort node)
+  { 
+    unimplementedVisitor("visit(" + "WsSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ShortComSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ShortComSort" + ")");
+  }
+
+  public boolean visit(ShortComSort node)
+  { 
+    unimplementedVisitor("visit(" + "ShortComSort" + ")");
+    return true;
+  }
+
+  public void endVisit(LongComSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "LongComSort" + ")");
+  }
+
+  public boolean visit(LongComSort node)
+  { 
+    unimplementedVisitor("visit(" + "LongComSort" + ")");
+    return true;
+  }
+
+  public void endVisit(EofSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "EofSort" + ")");
+  }
+
+  public boolean visit(EofSort node)
+  { 
+    unimplementedVisitor("visit(" + "EofSort" + ")");
+    return true;
+  }
+
+  public void endVisit(CommCharSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "CommCharSort" + ")");
+  }
+
+  public boolean visit(CommCharSort node)
+  { 
+    unimplementedVisitor("visit(" + "CommCharSort" + ")");
+    return true;
+  }
+
+  public void endVisit(AsteriskSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "AsteriskSort" + ")");
+  }
+
+  public boolean visit(AsteriskSort node)
+  { 
+    unimplementedVisitor("visit(" + "AsteriskSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ModName_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ModName_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(ModName_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "ModName_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ModNamePart_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ModNamePart_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(ModNamePart_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "ModNamePart_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Id_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Id_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(Id_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "Id_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(LId_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "LId_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(LId_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "LId_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(LCID_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "LCID_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(LCID_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "LCID_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(UCID_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "UCID_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(UCID_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "UCID_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Keyword_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Keyword_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(Keyword_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "Keyword_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Int_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Int_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(Int_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "Int_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Real_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Real_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(Real_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "Real_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(String_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "String_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(String_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "String_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(StrChar_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "StrChar_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(StrChar_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "StrChar_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Char_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Char_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(Char_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "Char_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(CharChar_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "CharChar_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(CharChar_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "CharChar_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Sdecl_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Sdecl_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(Sdecl_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "Sdecl_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Opdecl_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Opdecl_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(Opdecl_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "Opdecl_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ConstType_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ConstType_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(ConstType_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "ConstType_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(FunType_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "FunType_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(FunType_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "FunType_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ArgTypeSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ArgTypeSort" + ")");
+  }
+
+  public boolean visit(ArgTypeSort node)
+  { 
+    unimplementedVisitor("visit(" + "ArgTypeSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ArgType_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ArgType_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(ArgType_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "ArgType_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(RetType_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "RetType_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(RetType_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "RetType_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Type_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Type_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(Type_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "Type_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(SVar_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "SVar_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(SVar_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "SVar_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(StrategyParen_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "StrategyParen_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(StrategyParen_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "StrategyParen_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(StrategyMid_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "StrategyMid_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(StrategyMid_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "StrategyMid_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Module_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Module_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(Module_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "Module_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ImportModName_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ImportModName_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(ImportModName_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "ImportModName_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(LID_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "LID_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(LID_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "LID_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Var_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Var_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(Var_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "Var_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ID_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ID_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(ID_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "ID_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(PreTerm_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "PreTerm_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(PreTerm_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "PreTerm_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Sort_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Sort_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(Sort_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "Sort_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Kind_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Kind_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(Kind_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "Kind_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(StrategyDef_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "StrategyDef_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(StrategyDef_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "StrategyDef_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Typedid_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Typedid_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(Typedid_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "Typedid_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(StrategyAngleSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "StrategyAngleSort" + ")");
+  }
+
+  public boolean visit(StrategyAngleSort node)
+  { 
+    unimplementedVisitor("visit(" + "StrategyAngleSort" + ")");
+    return true;
+  }
+
+  public void endVisit(StrategyCurly_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "StrategyCurly_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(StrategyCurly_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "StrategyCurly_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(StrategySort node)
+  { 
+    unimplementedVisitor("endVisit(" + "StrategySort" + ")");
+  }
+
+  public boolean visit(StrategySort node)
+  { 
+    unimplementedVisitor("visit(" + "StrategySort" + ")");
+    return true;
+  }
+
+  public void endVisit(SwitchCase_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "SwitchCase_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(SwitchCase_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "SwitchCase_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Overlay_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Overlay_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(Overlay_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "Overlay_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(RuleDef_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "RuleDef_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(RuleDef_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "RuleDef_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Rule_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Rule_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(Rule_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "Rule_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Decl_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Decl_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(Decl_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "Decl_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Def_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Def_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(Def_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "Def_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ScopeLabels_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ScopeLabels_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(ScopeLabels_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "ScopeLabels_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(DynRuleDef_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "DynRuleDef_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(DynRuleDef_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "DynRuleDef_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(DynRuleId_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "DynRuleId_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(DynRuleId_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "DynRuleId_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(DynRuleScopeId_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "DynRuleScopeId_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(DynRuleScopeId_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "DynRuleScopeId_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(RuleDec_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "RuleDec_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(RuleDec_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "RuleDec_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(RuleNames_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "RuleNames_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(RuleNames_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "RuleNames_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Strategy_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Strategy_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(Strategy_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "Strategy_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(LineTerminatorSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "LineTerminatorSort" + ")");
+  }
+
+  public boolean visit(LineTerminatorSort node)
+  { 
+    unimplementedVisitor("visit(" + "LineTerminatorSort" + ")");
+    return true;
+  }
+
+  public void endVisit(CarriageReturnSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "CarriageReturnSort" + ")");
+  }
+
+  public boolean visit(CarriageReturnSort node)
+  { 
+    unimplementedVisitor("visit(" + "CarriageReturnSort" + ")");
+    return true;
+  }
+
+  public void endVisit(EndOfFileSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "EndOfFileSort" + ")");
+  }
+
+  public boolean visit(EndOfFileSort node)
+  { 
+    unimplementedVisitor("visit(" + "EndOfFileSort" + ")");
+    return true;
+  }
+
+  public void endVisit(CommentSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "CommentSort" + ")");
+  }
+
+  public boolean visit(CommentSort node)
+  { 
+    unimplementedVisitor("visit(" + "CommentSort" + ")");
+    return true;
+  }
+
+  public void endVisit(EOLCommentCharsSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "EOLCommentCharsSort" + ")");
+  }
+
+  public boolean visit(EOLCommentCharsSort node)
+  { 
+    unimplementedVisitor("visit(" + "EOLCommentCharsSort" + ")");
+    return true;
+  }
+
+  public void endVisit(CommentPartSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "CommentPartSort" + ")");
+  }
+
+  public boolean visit(CommentPartSort node)
+  { 
+    unimplementedVisitor("visit(" + "CommentPartSort" + ")");
+    return true;
+  }
+
+  public void endVisit(BlockCommentCharsSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "BlockCommentCharsSort" + ")");
+  }
+
+  public boolean visit(BlockCommentCharsSort node)
+  { 
+    unimplementedVisitor("visit(" + "BlockCommentCharsSort" + ")");
+    return true;
+  }
+
+  public void endVisit(EscEscCharSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "EscEscCharSort" + ")");
+  }
+
+  public boolean visit(EscEscCharSort node)
+  { 
+    unimplementedVisitor("visit(" + "EscEscCharSort" + ")");
+    return true;
+  }
+
+  public void endVisit(EscCharSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "EscCharSort" + ")");
+  }
+
+  public boolean visit(EscCharSort node)
+  { 
+    unimplementedVisitor("visit(" + "EscCharSort" + ")");
+    return true;
+  }
+
+  public void endVisit(UnicodeEscapeSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "UnicodeEscapeSort" + ")");
+  }
+
+  public boolean visit(UnicodeEscapeSort node)
+  { 
+    unimplementedVisitor("visit(" + "UnicodeEscapeSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Keyword_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Keyword_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(Keyword_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "Keyword_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Public_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Public_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(Public_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "Public_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Private_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Private_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(Private_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "Private_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Protected_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Protected_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(Protected_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "Protected_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Abstract_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Abstract_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(Abstract_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "Abstract_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Final_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Final_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(Final_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "Final_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Static_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Static_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(Static_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "Static_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Native_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Native_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(Native_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "Native_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Transient_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Transient_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(Transient_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "Transient_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Volatile_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Volatile_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(Volatile_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "Volatile_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Synchronized_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Synchronized_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(Synchronized_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "Synchronized_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(StrictFP_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "StrictFP_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(StrictFP_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "StrictFP_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Modifier_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Modifier_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(Modifier_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "Modifier_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(DeciNumeral_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "DeciNumeral_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(DeciNumeral_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "DeciNumeral_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(HexaNumeral_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "HexaNumeral_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(HexaNumeral_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "HexaNumeral_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(OctaNumeral_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "OctaNumeral_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(OctaNumeral_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "OctaNumeral_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(IntLiteral_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "IntLiteral_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(IntLiteral_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "IntLiteral_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(DeciFloatLiteral_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "DeciFloatLiteral_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(DeciFloatLiteral_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "DeciFloatLiteral_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(HexaFloatLiteral_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "HexaFloatLiteral_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(HexaFloatLiteral_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "HexaFloatLiteral_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(DeciFloatNumeral_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "DeciFloatNumeral_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(DeciFloatNumeral_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "DeciFloatNumeral_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(DeciFloatDigits_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "DeciFloatDigits_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(DeciFloatDigits_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "DeciFloatDigits_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(DeciFloatExponentPart_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "DeciFloatExponentPart_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(DeciFloatExponentPart_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "DeciFloatExponentPart_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(SignedInteger_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "SignedInteger_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(SignedInteger_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "SignedInteger_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(HexaFloatNumeral_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "HexaFloatNumeral_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(HexaFloatNumeral_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "HexaFloatNumeral_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(HexaSignificand_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "HexaSignificand_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(HexaSignificand_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "HexaSignificand_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(BinaryExponent_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "BinaryExponent_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(BinaryExponent_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "BinaryExponent_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(BoolLiteral_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "BoolLiteral_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(BoolLiteral_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "BoolLiteral_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Bool_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Bool_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(Bool_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "Bool_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(EscapeSeq_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "EscapeSeq_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(EscapeSeq_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "EscapeSeq_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(NamedEscape_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "NamedEscape_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(NamedEscape_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "NamedEscape_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(OctaEscape_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "OctaEscape_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(OctaEscape_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "OctaEscape_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(LastOcta_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "LastOcta_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(LastOcta_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "LastOcta_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(CharContent_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "CharContent_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(CharContent_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "CharContent_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(StringPart_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "StringPart_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(StringPart_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "StringPart_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(NullLiteral_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "NullLiteral_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(NullLiteral_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "NullLiteral_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(NumType_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "NumType_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(NumType_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "NumType_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(IntType_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "IntType_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(IntType_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "IntType_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(FloatType_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "FloatType_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(FloatType_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "FloatType_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(TypeArgs_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "TypeArgs_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(TypeArgs_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "TypeArgs_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ActualTypeArg_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ActualTypeArg_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(ActualTypeArg_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "ActualTypeArg_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(WildcardBound_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "WildcardBound_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(WildcardBound_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "WildcardBound_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(TypeBound_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "TypeBound_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(TypeBound_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "TypeBound_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(TypeParams_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "TypeParams_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(TypeParams_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "TypeParams_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(TypeVarId_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "TypeVarId_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(TypeVarId_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "TypeVarId_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ClassOrInterfaceType_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ClassOrInterfaceType_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(ClassOrInterfaceType_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "ClassOrInterfaceType_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ClassType_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ClassType_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(ClassType_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "ClassType_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(InterfaceType_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "InterfaceType_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(InterfaceType_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "InterfaceType_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(TypeDecSpec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "TypeDecSpec_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(TypeDecSpec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "TypeDecSpec_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(TypeVar_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "TypeVar_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(TypeVar_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "TypeVar_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ArrayType_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ArrayType_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(ArrayType_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "ArrayType_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Literal_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Literal_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(Literal_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "Literal_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ClassLiteral_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ClassLiteral_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(ClassLiteral_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "ClassLiteral_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ExprSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ExprSort" + ")");
+  }
+
+  public boolean visit(ExprSort node)
+  { 
+    unimplementedVisitor("visit(" + "ExprSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ArrayInit_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ArrayInit_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(ArrayInit_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "ArrayInit_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(FieldDec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "FieldDec_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(FieldDec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "FieldDec_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(VarDecId_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "VarDecId_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(VarDecId_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "VarDecId_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Dim_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Dim_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(Dim_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "Dim_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(VarInit_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "VarInit_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(VarInit_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "VarInit_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(LocalVarDecStm_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "LocalVarDecStm_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(LocalVarDecStm_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "LocalVarDecStm_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(SwitchBlock_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "SwitchBlock_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(SwitchBlock_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "SwitchBlock_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(SwitchLabel_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "SwitchLabel_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(SwitchLabel_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "SwitchLabel_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(CatchClause_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "CatchClause_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(CatchClause_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "CatchClause_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Block_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Block_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(Block_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "Block_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(MethodDec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "MethodDec_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(MethodDec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "MethodDec_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(MethodDecHead_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "MethodDecHead_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(MethodDecHead_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "MethodDecHead_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ResultType_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ResultType_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(ResultType_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "ResultType_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Throws_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Throws_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(Throws_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "Throws_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ExceptionType_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ExceptionType_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(ExceptionType_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "ExceptionType_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(MethodBody_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "MethodBody_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(MethodBody_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "MethodBody_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(InstanceInit_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "InstanceInit_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(InstanceInit_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "InstanceInit_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(StaticInit_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "StaticInit_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(StaticInit_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "StaticInit_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ConstrDec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ConstrDec_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(ConstrDec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "ConstrDec_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ConstrHead_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ConstrHead_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(ConstrHead_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "ConstrHead_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ConstrBody_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ConstrBody_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(ConstrBody_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "ConstrBody_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ConstrInv_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ConstrInv_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(ConstrInv_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "ConstrInv_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(EnumDec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "EnumDec_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(EnumDec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "EnumDec_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(EnumDecHead_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "EnumDecHead_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(EnumDecHead_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "EnumDecHead_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(EnumBody_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "EnumBody_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(EnumBody_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "EnumBody_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(EnumConst_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "EnumConst_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(EnumConst_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "EnumConst_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(EnumConstArgsSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "EnumConstArgsSort" + ")");
+  }
+
+  public boolean visit(EnumConstArgsSort node)
+  { 
+    unimplementedVisitor("visit(" + "EnumConstArgsSort" + ")");
+    return true;
+  }
+
+  public void endVisit(EnumBodyDecs_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "EnumBodyDecs_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(EnumBodyDecs_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "EnumBodyDecs_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ConstantDec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ConstantDec_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(ConstantDec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "ConstantDec_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ConstantMod_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ConstantMod_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(ConstantMod_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "ConstantMod_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(AbstractMethodDec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "AbstractMethodDec_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(AbstractMethodDec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "AbstractMethodDec_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(AbstractMethodMod_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "AbstractMethodMod_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(AbstractMethodMod_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "AbstractMethodMod_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(AnnoDec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "AnnoDec_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(AnnoDec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "AnnoDec_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(AnnoDecHead_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "AnnoDecHead_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(AnnoDecHead_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "AnnoDecHead_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(AnnoElemDec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "AnnoElemDec_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(AnnoElemDec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "AnnoElemDec_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(DefaultVal_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "DefaultVal_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(DefaultVal_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "DefaultVal_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(InterfaceDec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "InterfaceDec_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(InterfaceDec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "InterfaceDec_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(InterfaceDecHead_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "InterfaceDecHead_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(InterfaceDecHead_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "InterfaceDecHead_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ExtendsInterfaces_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ExtendsInterfaces_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(ExtendsInterfaces_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "ExtendsInterfaces_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(InterfaceMod_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "InterfaceMod_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(InterfaceMod_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "InterfaceMod_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ClassDec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ClassDec_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(ClassDec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "ClassDec_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ClassBody_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ClassBody_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(ClassBody_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "ClassBody_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ClassDecHead_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ClassDecHead_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(ClassDecHead_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "ClassDecHead_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Super_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Super_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(Super_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "Super_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Interfaces_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Interfaces_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(Interfaces_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "Interfaces_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ClassMemberDec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ClassMemberDec_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(ClassMemberDec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "ClassMemberDec_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ArrayCreationExpr_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ArrayCreationExpr_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(ArrayCreationExpr_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "ArrayCreationExpr_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ArrayBaseType_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ArrayBaseType_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(ArrayBaseType_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "ArrayBaseType_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(DimExpr_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "DimExpr_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(DimExpr_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "DimExpr_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(FieldAccess_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "FieldAccess_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(FieldAccess_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "FieldAccess_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ArrayAccess_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ArrayAccess_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(ArrayAccess_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "ArrayAccess_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ArraySubscriptSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ArraySubscriptSort" + ")");
+  }
+
+  public boolean visit(ArraySubscriptSort node)
+  { 
+    unimplementedVisitor("visit(" + "ArraySubscriptSort" + ")");
+    return true;
+  }
+
+  public void endVisit(MethodSpec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "MethodSpec_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(MethodSpec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "MethodSpec_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(CondMidSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "CondMidSort" + ")");
+  }
+
+  public boolean visit(CondMidSort node)
+  { 
+    unimplementedVisitor("visit(" + "CondMidSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Anno_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Anno_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(Anno_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "Anno_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ElemValPair_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ElemValPair_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(ElemValPair_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "ElemValPair_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ElemVal_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ElemVal_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(ElemVal_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "ElemVal_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(CompilationUnit_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "CompilationUnit_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(CompilationUnit_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "CompilationUnit_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(SwitchGroup_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "SwitchGroup_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(SwitchGroup_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "SwitchGroup_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Stm_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Stm_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(Stm_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "Stm_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(BlockStm_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "BlockStm_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(BlockStm_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "BlockStm_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(LocalVarDec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "LocalVarDec_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(LocalVarDec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "LocalVarDec_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(VarDec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "VarDec_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(VarDec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "VarDec_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(LHS_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "LHS_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(LHS_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "LHS_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(PrimType_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "PrimType_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(PrimType_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "PrimType_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(RefType_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "RefType_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(RefType_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "RefType_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(MetaTypeVar_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "MetaTypeVar_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(MetaTypeVar_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "MetaTypeVar_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(MetaPrimTypeVar_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "MetaPrimTypeVar_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(MetaPrimTypeVar_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "MetaPrimTypeVar_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(MetaRefTypeVar_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "MetaRefTypeVar_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(MetaRefTypeVar_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "MetaRefTypeVar_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Type_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Type_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(Type_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "Type_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(PackageDec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "PackageDec_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(PackageDec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "PackageDec_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(OptPackageDec_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "OptPackageDec_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(OptPackageDec_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "OptPackageDec_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ImportDec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ImportDec_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(ImportDec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "ImportDec_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Term_StrategoHostSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Term_StrategoHostSort" + ")");
+  }
+
+  public boolean visit(Term_StrategoHostSort node)
+  { 
+    unimplementedVisitor("visit(" + "Term_StrategoHostSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Name_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Name_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(Name_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "Name_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Id_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Id_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(Id_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "Id_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ID_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ID_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(ID_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "ID_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(TypeParam_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "TypeParam_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(TypeParam_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "TypeParam_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(Expr_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Expr_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(Expr_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "Expr_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(TypeDec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "TypeDec_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(TypeDec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "TypeDec_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ClassBodyDec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ClassBodyDec_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(ClassBodyDec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "ClassBodyDec_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(InterfaceMemberDec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "InterfaceMemberDec_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(InterfaceMemberDec_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "InterfaceMemberDec_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(DeciLiteral_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "DeciLiteral_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(DeciLiteral_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "DeciLiteral_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(HexaLiteral_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "HexaLiteral_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(HexaLiteral_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "HexaLiteral_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(OctaLiteral_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "OctaLiteral_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(OctaLiteral_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "OctaLiteral_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(FloatLiteral_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "FloatLiteral_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(FloatLiteral_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "FloatLiteral_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(StringLiteral_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "StringLiteral_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(StringLiteral_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "StringLiteral_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(CharLiteral_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "CharLiteral_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(CharLiteral_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "CharLiteral_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(AmbName_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "AmbName_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(AmbName_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "AmbName_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ExprName_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ExprName_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(ExprName_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "ExprName_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(MethodName_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "MethodName_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(MethodName_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "MethodName_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(TypeName_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "TypeName_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(TypeName_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "TypeName_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(PackageOrTypeName_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "PackageOrTypeName_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(PackageOrTypeName_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "PackageOrTypeName_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(PackageName_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "PackageName_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(PackageName_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "PackageName_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(MethodMod_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "MethodMod_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(MethodMod_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "MethodMod_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ClassMod_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ClassMod_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(ClassMod_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "ClassMod_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ConstrMod_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ConstrMod_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(ConstrMod_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "ConstrMod_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(VarMod_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "VarMod_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(VarMod_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "VarMod_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(FieldMod_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "FieldMod_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(FieldMod_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "FieldMod_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(FormalParam_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "FormalParam_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(FormalParam_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "FormalParam_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(StringChars_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "StringChars_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(StringChars_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "StringChars_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(SingleChar_JavaObjectSort node)
+  { 
+    unimplementedVisitor("endVisit(" + "SingleChar_JavaObjectSort" + ")");
+  }
+
+  public boolean visit(SingleChar_JavaObjectSort node)
+  { 
+    unimplementedVisitor("visit(" + "SingleChar_JavaObjectSort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListPlusOfCommChar0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListPlusOfCommChar0Sort" + ")");
+  }
+
+  public boolean visit(ListPlusOfCommChar0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListPlusOfCommChar0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfCommChar0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfCommChar0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfCommChar0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfCommChar0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListPlusOfModNamePart_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListPlusOfModNamePart_StrategoHost0Sort" + ")");
+  }
+
+  public boolean visit(ListPlusOfModNamePart_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListPlusOfModNamePart_StrategoHost0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfModNamePart_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfModNamePart_StrategoHost0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfModNamePart_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfModNamePart_StrategoHost0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListPlusOfStrChar_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListPlusOfStrChar_StrategoHost0Sort" + ")");
+  }
+
+  public boolean visit(ListPlusOfStrChar_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListPlusOfStrChar_StrategoHost0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfStrChar_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfStrChar_StrategoHost0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfStrChar_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfStrChar_StrategoHost0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfSort_StrategoHost1Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfSort_StrategoHost1Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfSort_StrategoHost1Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfSort_StrategoHost1Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfOpdecl_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfOpdecl_StrategoHost0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfOpdecl_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfOpdecl_StrategoHost0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfArgType_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfArgType_StrategoHost0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfArgType_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfArgType_StrategoHost0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfID_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfID_StrategoHost0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfID_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfID_StrategoHost0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfDecl_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfDecl_StrategoHost0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfDecl_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfDecl_StrategoHost0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfImportModName_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfImportModName_StrategoHost0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfImportModName_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfImportModName_StrategoHost0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfSdecl_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfSdecl_StrategoHost0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfSdecl_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfSdecl_StrategoHost0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfSort_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfSort_StrategoHost0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfSort_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfSort_StrategoHost0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfStrategy_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfStrategy_StrategoHost0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfStrategy_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfStrategy_StrategoHost0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfSwitchCase_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfSwitchCase_StrategoHost0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfSwitchCase_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfSwitchCase_StrategoHost0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfDef_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfDef_StrategoHost0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfDef_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfDef_StrategoHost0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfOverlay_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfOverlay_StrategoHost0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfOverlay_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfOverlay_StrategoHost0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfDynRuleScopeId_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfDynRuleScopeId_StrategoHost0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfDynRuleScopeId_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfDynRuleScopeId_StrategoHost0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfDynRuleDef_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfDynRuleDef_StrategoHost0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfDynRuleDef_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfDynRuleDef_StrategoHost0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfTypedid_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfTypedid_StrategoHost0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfTypedid_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfTypedid_StrategoHost0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfId_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfId_StrategoHost0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfId_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfId_StrategoHost0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfCharClass1Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfCharClass1Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfCharClass1Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfCharClass1Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListPlusOfCommentPart0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListPlusOfCommentPart0Sort" + ")");
+  }
+
+  public boolean visit(ListPlusOfCommentPart0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListPlusOfCommentPart0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfCommentPart0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfCommentPart0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfCommentPart0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfCommentPart0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(OptDeciFloatExponentPart_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "OptDeciFloatExponentPart_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(OptDeciFloatExponentPart_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "OptDeciFloatExponentPart_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfStringPart_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfStringPart_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfStringPart_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfStringPart_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfCharClass0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfCharClass0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfCharClass0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfCharClass0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfId_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfId_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfId_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfId_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfActualTypeArg_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfActualTypeArg_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfActualTypeArg_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfActualTypeArg_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfClassOrInterfaceType_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfClassOrInterfaceType_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfClassOrInterfaceType_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfClassOrInterfaceType_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfSwitchLabel_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfSwitchLabel_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfSwitchLabel_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfSwitchLabel_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfBlockStm_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfBlockStm_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfBlockStm_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfBlockStm_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfCatchClause_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfCatchClause_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfCatchClause_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfCatchClause_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfExceptionType_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfExceptionType_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfExceptionType_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfExceptionType_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfEnumConst_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfEnumConst_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfEnumConst_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfEnumConst_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfAnno_JavaObject_ConstantMod_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfAnno_JavaObject_ConstantMod_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfAnno_JavaObject_ConstantMod_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfAnno_JavaObject_ConstantMod_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(Anno_JavaObject_ConstantMod_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Anno_JavaObject_ConstantMod_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(Anno_JavaObject_ConstantMod_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "Anno_JavaObject_ConstantMod_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfAnno_JavaObject_AbstractMethodMod_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfAnno_JavaObject_AbstractMethodMod_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfAnno_JavaObject_AbstractMethodMod_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfAnno_JavaObject_AbstractMethodMod_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(Anno_JavaObject_AbstractMethodMod_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Anno_JavaObject_AbstractMethodMod_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(Anno_JavaObject_AbstractMethodMod_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "Anno_JavaObject_AbstractMethodMod_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfAnnoElemDec_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfAnnoElemDec_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfAnnoElemDec_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfAnnoElemDec_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfAbstractMethodMod_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfAbstractMethodMod_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfAbstractMethodMod_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfAbstractMethodMod_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfAnno_JavaObject_InterfaceMod_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfAnno_JavaObject_InterfaceMod_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfAnno_JavaObject_InterfaceMod_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfAnno_JavaObject_InterfaceMod_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(Anno_JavaObject_InterfaceMod_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Anno_JavaObject_InterfaceMod_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(Anno_JavaObject_InterfaceMod_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "Anno_JavaObject_InterfaceMod_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfInterfaceType_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfInterfaceType_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfInterfaceType_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfInterfaceType_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfDimExpr_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfDimExpr_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfDimExpr_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfDimExpr_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfDim_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfDim_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfDim_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfDim_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(OptTypeArgs_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "OptTypeArgs_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(OptTypeArgs_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "OptTypeArgs_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfElemValPair_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfElemValPair_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfElemValPair_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfElemValPair_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfElemVal_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfElemVal_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfElemVal_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfElemVal_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfAnno_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfAnno_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfAnno_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfAnno_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfTypeDec_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfTypeDec_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfTypeDec_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfTypeDec_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfVarInit_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfVarInit_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfVarInit_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfVarInit_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfExpr_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfExpr_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfExpr_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfExpr_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfSwitchGroup_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfSwitchGroup_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfSwitchGroup_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfSwitchGroup_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfVarDec_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfVarDec_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfVarDec_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfVarDec_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfImportDec_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfImportDec_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfImportDec_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfImportDec_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfAbstractMethodDec_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfAbstractMethodDec_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfAbstractMethodDec_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfAbstractMethodDec_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfTypeParam_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfTypeParam_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfTypeParam_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfTypeParam_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfClassBodyDec_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfClassBodyDec_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfClassBodyDec_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfClassBodyDec_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfInterfaceMemberDec_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfInterfaceMemberDec_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfInterfaceMemberDec_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfInterfaceMemberDec_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfAnno_JavaObject_MethodMod_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfAnno_JavaObject_MethodMod_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfAnno_JavaObject_MethodMod_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfAnno_JavaObject_MethodMod_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(Anno_JavaObject_MethodMod_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Anno_JavaObject_MethodMod_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(Anno_JavaObject_MethodMod_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "Anno_JavaObject_MethodMod_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfAnno_JavaObject_ClassMod_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfAnno_JavaObject_ClassMod_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfAnno_JavaObject_ClassMod_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfAnno_JavaObject_ClassMod_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(Anno_JavaObject_ClassMod_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Anno_JavaObject_ClassMod_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(Anno_JavaObject_ClassMod_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "Anno_JavaObject_ClassMod_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfAnno_JavaObject_ConstrMod_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfAnno_JavaObject_ConstrMod_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfAnno_JavaObject_ConstrMod_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfAnno_JavaObject_ConstrMod_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(Anno_JavaObject_ConstrMod_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Anno_JavaObject_ConstrMod_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(Anno_JavaObject_ConstrMod_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "Anno_JavaObject_ConstrMod_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfAnno_JavaObject_VarMod_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfAnno_JavaObject_VarMod_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfAnno_JavaObject_VarMod_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfAnno_JavaObject_VarMod_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(Anno_JavaObject_VarMod_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Anno_JavaObject_VarMod_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(Anno_JavaObject_VarMod_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "Anno_JavaObject_VarMod_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfAnno_JavaObject_FieldMod_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfAnno_JavaObject_FieldMod_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfAnno_JavaObject_FieldMod_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfAnno_JavaObject_FieldMod_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(Anno_JavaObject_FieldMod_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "Anno_JavaObject_FieldMod_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(Anno_JavaObject_FieldMod_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "Anno_JavaObject_FieldMod_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfFormalParam_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfFormalParam_JavaObject0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfFormalParam_JavaObject0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfFormalParam_JavaObject0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ListStarOfTerm_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("endVisit(" + "ListStarOfTerm_StrategoHost0Sort" + ")");
+  }
+
+  public boolean visit(ListStarOfTerm_StrategoHost0Sort node)
+  { 
+    unimplementedVisitor("visit(" + "ListStarOfTerm_StrategoHost0Sort" + ")");
+    return true;
+  }
+
+  public void endVisit(ASTString node)
+  { 
+    unimplementedVisitor("endVisit(" + "ASTString" + ")");
+  }
+
+  public boolean visit(ASTString node)
+  { 
+    unimplementedVisitor("visit(" + "ASTString" + ")");
+    return true;
+  }
+
+  public void endVisit(List node)
+  { 
+    unimplementedVisitor("endVisit(" + "List" + ")");
+  }
+
+  public boolean visit(List node)
+  { 
+    unimplementedVisitor("visit(" + "List" + ")");
+    return true;
+  }
+
+  public boolean visit(ASTNode node)
+  { 
+    if(node instanceof Ws)
+      return visit((Ws)node);
+    if(node instanceof ShortCom)
+      return visit((ShortCom)node);
+    if(node instanceof LongCom)
+      return visit((LongCom)node);
+    if(node instanceof Eof)
+      return visit((Eof)node);
+    if(node instanceof CommChar)
+      return visit((CommChar)node);
+    if(node instanceof Asterisk)
+      return visit((Asterisk)node);
+    if(node instanceof ModName_StrategoHost)
+      return visit((ModName_StrategoHost)node);
+    if(node instanceof ModNamePart_StrategoHost)
+      return visit((ModNamePart_StrategoHost)node);
+    if(node instanceof Id_StrategoHost)
+      return visit((Id_StrategoHost)node);
+    if(node instanceof LId_StrategoHost)
+      return visit((LId_StrategoHost)node);
+    if(node instanceof LCID_StrategoHost)
+      return visit((LCID_StrategoHost)node);
+    if(node instanceof UCID_StrategoHost)
+      return visit((UCID_StrategoHost)node);
+    if(node instanceof Keyword_StrategoHost)
+      return visit((Keyword_StrategoHost)node);
+    if(node instanceof Int_StrategoHost)
+      return visit((Int_StrategoHost)node);
+    if(node instanceof Real_StrategoHost)
+      return visit((Real_StrategoHost)node);
+    if(node instanceof String_StrategoHost)
+      return visit((String_StrategoHost)node);
+    if(node instanceof StrChar_StrategoHost)
+      return visit((StrChar_StrategoHost)node);
+    if(node instanceof Char_StrategoHost)
+      return visit((Char_StrategoHost)node);
+    if(node instanceof CharChar_StrategoHost)
+      return visit((CharChar_StrategoHost)node);
+    if(node instanceof Var0)
+      return visit((Var0)node);
+    if(node instanceof ID_StrategoHost0)
+      return visit((ID_StrategoHost0)node);
+    if(node instanceof PreTerm_StrategoHost)
+      return visit((PreTerm_StrategoHost)node);
+    if(node instanceof Term_StrategoHost)
+      return visit((Term_StrategoHost)node);
+    if(node instanceof Wld0)
+      return visit((Wld0)node);
+    if(node instanceof Wld)
+      return visit((Wld)node);
+    if(node instanceof Int0)
+      return visit((Int0)node);
+    if(node instanceof Real)
+      return visit((Real)node);
+    if(node instanceof Str)
+      return visit((Str)node);
+    if(node instanceof Op)
+      return visit((Op)node);
+    if(node instanceof OpQ)
+      return visit((OpQ)node);
+    if(node instanceof Explode)
+      return visit((Explode)node);
+    if(node instanceof Anno0)
+      return visit((Anno0)node);
+    if(node instanceof As0)
+      return visit((As0)node);
+    if(node instanceof As)
+      return visit((As)node);
+    if(node instanceof Sorts)
+      return visit((Sorts)node);
+    if(node instanceof Constructors)
+      return visit((Constructors)node);
+    if(node instanceof SortVar)
+      return visit((SortVar)node);
+    if(node instanceof SortNoArgs)
+      return visit((SortNoArgs)node);
+    if(node instanceof Sort)
+      return visit((Sort)node);
+    if(node instanceof OpDecl)
+      return visit((OpDecl)node);
+    if(node instanceof OpDeclQ)
+      return visit((OpDeclQ)node);
+    if(node instanceof OpDeclInj)
+      return visit((OpDeclInj)node);
+    if(node instanceof ConstType)
+      return visit((ConstType)node);
+    if(node instanceof FunType)
+      return visit((FunType)node);
+    if(node instanceof ArgType)
+      return visit((ArgType)node);
+    if(node instanceof ArgType_StrategoHost)
+      return visit((ArgType_StrategoHost)node);
+    if(node instanceof RetType_StrategoHost)
+      return visit((RetType_StrategoHost)node);
+    if(node instanceof Type_StrategoHost0)
+      return visit((Type_StrategoHost0)node);
+    if(node instanceof Type_StrategoHost)
+      return visit((Type_StrategoHost)node);
+    if(node instanceof Def_StrategoHost0)
+      return visit((Def_StrategoHost0)node);
+    if(node instanceof SVar)
+      return visit((SVar)node);
+    if(node instanceof Let)
+      return visit((Let)node);
+    if(node instanceof CallT)
+      return visit((CallT)node);
+    if(node instanceof CallDynamic)
+      return visit((CallDynamic)node);
+    if(node instanceof SDefT)
+      return visit((SDefT)node);
+    if(node instanceof ExtSDefInl)
+      return visit((ExtSDefInl)node);
+    if(node instanceof ExtSDef)
+      return visit((ExtSDef)node);
+    if(node instanceof VarDec1)
+      return visit((VarDec1)node);
+    if(node instanceof ParenStrat)
+      return visit((ParenStrat)node);
+    if(node instanceof Fail)
+      return visit((Fail)node);
+    if(node instanceof Id0)
+      return visit((Id0)node);
+    if(node instanceof Match)
+      return visit((Match)node);
+    if(node instanceof Build)
+      return visit((Build)node);
+    if(node instanceof Scope)
+      return visit((Scope)node);
+    if(node instanceof Seq)
+      return visit((Seq)node);
+    if(node instanceof GuardedLChoice)
+      return visit((GuardedLChoice)node);
+    if(node instanceof StrategyMid_StrategoHost)
+      return visit((StrategyMid_StrategoHost)node);
+    if(node instanceof PrimT)
+      return visit((PrimT)node);
+    if(node instanceof Some)
+      return visit((Some)node);
+    if(node instanceof One)
+      return visit((One)node);
+    if(node instanceof All)
+      return visit((All)node);
+    if(node instanceof ImportTerm)
+      return visit((ImportTerm)node);
+    if(node instanceof Module)
+      return visit((Module)node);
+    if(node instanceof Specification)
+      return visit((Specification)node);
+    if(node instanceof Imports)
+      return visit((Imports)node);
+    if(node instanceof Strategies)
+      return visit((Strategies)node);
+    if(node instanceof Signature)
+      return visit((Signature)node);
+    if(node instanceof Import)
+      return visit((Import)node);
+    if(node instanceof ImportWildcard)
+      return visit((ImportWildcard)node);
+    if(node instanceof ListVar)
+      return visit((ListVar)node);
+    if(node instanceof Var)
+      return visit((Var)node);
+    if(node instanceof ID_StrategoHost)
+      return visit((ID_StrategoHost)node);
+    if(node instanceof BuildDefaultPT)
+      return visit((BuildDefaultPT)node);
+    if(node instanceof BuildDefault)
+      return visit((BuildDefault)node);
+    if(node instanceof Char1)
+      return visit((Char1)node);
+    if(node instanceof AnnoList)
+      return visit((AnnoList)node);
+    if(node instanceof NoAnnoList)
+      return visit((NoAnnoList)node);
+    if(node instanceof App0)
+      return visit((App0)node);
+    if(node instanceof App)
+      return visit((App)node);
+    if(node instanceof RootApp0)
+      return visit((RootApp0)node);
+    if(node instanceof RootApp)
+      return visit((RootApp)node);
+    if(node instanceof Tuple)
+      return visit((Tuple)node);
+    if(node instanceof List0)
+      return visit((List0)node);
+    if(node instanceof ListTail)
+      return visit((ListTail)node);
+    if(node instanceof SortList)
+      return visit((SortList)node);
+    if(node instanceof SortListTl)
+      return visit((SortListTl)node);
+    if(node instanceof SortTuple)
+      return visit((SortTuple)node);
+    if(node instanceof Star)
+      return visit((Star)node);
+    if(node instanceof StarStar)
+      return visit((StarStar)node);
+    if(node instanceof SDefNoArgs)
+      return visit((SDefNoArgs)node);
+    if(node instanceof SDef)
+      return visit((SDef)node);
+    if(node instanceof DefaultVarDec)
+      return visit((DefaultVarDec)node);
+    if(node instanceof Call)
+      return visit((Call)node);
+    if(node instanceof ScopeDefault)
+      return visit((ScopeDefault)node);
+    if(node instanceof BA)
+      return visit((BA)node);
+    if(node instanceof StrategyAngle)
+      return visit((StrategyAngle)node);
+    if(node instanceof LChoice)
+      return visit((LChoice)node);
+    if(node instanceof Rec)
+      return visit((Rec)node);
+    if(node instanceof Not0)
+      return visit((Not0)node);
+    if(node instanceof Where)
+      return visit((Where)node);
+    if(node instanceof Test)
+      return visit((Test)node);
+    if(node instanceof PrimNoArgs)
+      return visit((PrimNoArgs)node);
+    if(node instanceof Prim)
+      return visit((Prim)node);
+    if(node instanceof StrCong)
+      return visit((StrCong)node);
+    if(node instanceof IntCong)
+      return visit((IntCong)node);
+    if(node instanceof RealCong)
+      return visit((RealCong)node);
+    if(node instanceof CharCong)
+      return visit((CharCong)node);
+    if(node instanceof CongQ)
+      return visit((CongQ)node);
+    if(node instanceof AnnoCong)
+      return visit((AnnoCong)node);
+    if(node instanceof StrategyCurly)
+      return visit((StrategyCurly)node);
+    if(node instanceof EmptyTupleCong)
+      return visit((EmptyTupleCong)node);
+    if(node instanceof Strategy)
+      return visit((Strategy)node);
+    if(node instanceof TupleCong)
+      return visit((TupleCong)node);
+    if(node instanceof ListCongNoTail)
+      return visit((ListCongNoTail)node);
+    if(node instanceof ListCong)
+      return visit((ListCong)node);
+    if(node instanceof ExplodeCong)
+      return visit((ExplodeCong)node);
+    if(node instanceof CallNoArgs)
+      return visit((CallNoArgs)node);
+    if(node instanceof LRule)
+      return visit((LRule)node);
+    if(node instanceof SRule)
+      return visit((SRule)node);
+    if(node instanceof Choice)
+      return visit((Choice)node);
+    if(node instanceof RChoice)
+      return visit((RChoice)node);
+    if(node instanceof CondChoice)
+      return visit((CondChoice)node);
+    if(node instanceof IfThen)
+      return visit((IfThen)node);
+    if(node instanceof SwitchChoiceNoOtherwise)
+      return visit((SwitchChoiceNoOtherwise)node);
+    if(node instanceof SwitchChoice)
+      return visit((SwitchChoice)node);
+    if(node instanceof SwitchCase)
+      return visit((SwitchCase)node);
+    if(node instanceof AM)
+      return visit((AM)node);
+    if(node instanceof Assign0)
+      return visit((Assign0)node);
+    if(node instanceof OverlayNoArgs)
+      return visit((OverlayNoArgs)node);
+    if(node instanceof Overlay)
+      return visit((Overlay)node);
+    if(node instanceof RDefNoArgs)
+      return visit((RDefNoArgs)node);
+    if(node instanceof RDef)
+      return visit((RDef)node);
+    if(node instanceof RDefT)
+      return visit((RDefT)node);
+    if(node instanceof RuleNoCond)
+      return visit((RuleNoCond)node);
+    if(node instanceof Rule)
+      return visit((Rule)node);
+    if(node instanceof Rules)
+      return visit((Rules)node);
+    if(node instanceof Overlays)
+      return visit((Overlays)node);
+    if(node instanceof Def_StrategoHost)
+      return visit((Def_StrategoHost)node);
+    if(node instanceof DynRuleScope)
+      return visit((DynRuleScope)node);
+    if(node instanceof ScopeLabels_StrategoHost)
+      return visit((ScopeLabels_StrategoHost)node);
+    if(node instanceof ScopeLabels)
+      return visit((ScopeLabels)node);
+    if(node instanceof GenDynRules)
+      return visit((GenDynRules)node);
+    if(node instanceof AddScopeLabel)
+      return visit((AddScopeLabel)node);
+    if(node instanceof UndefineDynRule)
+      return visit((UndefineDynRule)node);
+    if(node instanceof SetDynRule)
+      return visit((SetDynRule)node);
+    if(node instanceof AddDynRule)
+      return visit((AddDynRule)node);
+    if(node instanceof SetDynRuleMatch)
+      return visit((SetDynRuleMatch)node);
+    if(node instanceof DynRuleAssign)
+      return visit((DynRuleAssign)node);
+    if(node instanceof DynRuleAssignAdd)
+      return visit((DynRuleAssignAdd)node);
+    if(node instanceof SetDynRuleDepends)
+      return visit((SetDynRuleDepends)node);
+    if(node instanceof LabeledDynRuleId)
+      return visit((LabeledDynRuleId)node);
+    if(node instanceof AddLabelDynRuleId)
+      return visit((AddLabelDynRuleId)node);
+    if(node instanceof DynRuleId)
+      return visit((DynRuleId)node);
+    if(node instanceof LabeledDynRuleScopeId)
+      return visit((LabeledDynRuleScopeId)node);
+    if(node instanceof DynRuleScopeId)
+      return visit((DynRuleScopeId)node);
+    if(node instanceof RDecNoArgs)
+      return visit((RDecNoArgs)node);
+    if(node instanceof RDec)
+      return visit((RDec)node);
+    if(node instanceof RDecT)
+      return visit((RDecT)node);
+    if(node instanceof RuleNames_StrategoHost)
+      return visit((RuleNames_StrategoHost)node);
+    if(node instanceof RuleNames)
+      return visit((RuleNames)node);
+    if(node instanceof DynRuleIntersectFix)
+      return visit((DynRuleIntersectFix)node);
+    if(node instanceof DynRuleUnionFix0)
+      return visit((DynRuleUnionFix0)node);
+    if(node instanceof DynRuleUnionFix)
+      return visit((DynRuleUnionFix)node);
+    if(node instanceof DynRuleIntersectUnionFix0)
+      return visit((DynRuleIntersectUnionFix0)node);
+    if(node instanceof DynRuleIntersectUnionFix)
+      return visit((DynRuleIntersectUnionFix)node);
+    if(node instanceof DynRuleIntersect)
+      return visit((DynRuleIntersect)node);
+    if(node instanceof DynRuleUnion)
+      return visit((DynRuleUnion)node);
+    if(node instanceof DynRuleIntersectUnion)
+      return visit((DynRuleIntersectUnion)node);
+    if(node instanceof UnicodeEscape0)
+      return visit((UnicodeEscape0)node);
+    if(node instanceof LineTerminator)
+      return visit((LineTerminator)node);
+    if(node instanceof CarriageReturn)
+      return visit((CarriageReturn)node);
+    if(node instanceof EndOfFile)
+      return visit((EndOfFile)node);
+    if(node instanceof Comment)
+      return visit((Comment)node);
+    if(node instanceof EOLCommentChars)
+      return visit((EOLCommentChars)node);
+    if(node instanceof CommentPart)
+      return visit((CommentPart)node);
+    if(node instanceof BlockCommentChars)
+      return visit((BlockCommentChars)node);
+    if(node instanceof EscEscChar)
+      return visit((EscEscChar)node);
+    if(node instanceof EscChar)
+      return visit((EscChar)node);
+    if(node instanceof UnicodeEscape)
+      return visit((UnicodeEscape)node);
+    if(node instanceof Keyword_JavaObject)
+      return visit((Keyword_JavaObject)node);
+    if(node instanceof ID_JavaObject)
+      return visit((ID_JavaObject)node);
+    if(node instanceof Id)
+      return visit((Id)node);
+    if(node instanceof Public)
+      return visit((Public)node);
+    if(node instanceof Private)
+      return visit((Private)node);
+    if(node instanceof Protected)
+      return visit((Protected)node);
+    if(node instanceof Abstract)
+      return visit((Abstract)node);
+    if(node instanceof Final)
+      return visit((Final)node);
+    if(node instanceof Static)
+      return visit((Static)node);
+    if(node instanceof Native)
+      return visit((Native)node);
+    if(node instanceof Transient)
+      return visit((Transient)node);
+    if(node instanceof Volatile)
+      return visit((Volatile)node);
+    if(node instanceof Synchronized0)
+      return visit((Synchronized0)node);
+    if(node instanceof StrictFP)
+      return visit((StrictFP)node);
+    if(node instanceof Modifier_JavaObject9)
+      return visit((Modifier_JavaObject9)node);
+    if(node instanceof Modifier_JavaObject8)
+      return visit((Modifier_JavaObject8)node);
+    if(node instanceof Modifier_JavaObject7)
+      return visit((Modifier_JavaObject7)node);
+    if(node instanceof Modifier_JavaObject6)
+      return visit((Modifier_JavaObject6)node);
+    if(node instanceof Modifier_JavaObject5)
+      return visit((Modifier_JavaObject5)node);
+    if(node instanceof Modifier_JavaObject4)
+      return visit((Modifier_JavaObject4)node);
+    if(node instanceof Modifier_JavaObject3)
+      return visit((Modifier_JavaObject3)node);
+    if(node instanceof Modifier_JavaObject2)
+      return visit((Modifier_JavaObject2)node);
+    if(node instanceof Modifier_JavaObject1)
+      return visit((Modifier_JavaObject1)node);
+    if(node instanceof Modifier_JavaObject0)
+      return visit((Modifier_JavaObject0)node);
+    if(node instanceof Modifier_JavaObject)
+      return visit((Modifier_JavaObject)node);
+    if(node instanceof DeciLiteral_JavaObject)
+      return visit((DeciLiteral_JavaObject)node);
+    if(node instanceof HexaLiteral_JavaObject)
+      return visit((HexaLiteral_JavaObject)node);
+    if(node instanceof OctaLiteral_JavaObject)
+      return visit((OctaLiteral_JavaObject)node);
+    if(node instanceof DeciNumeral_JavaObject)
+      return visit((DeciNumeral_JavaObject)node);
+    if(node instanceof HexaNumeral_JavaObject)
+      return visit((HexaNumeral_JavaObject)node);
+    if(node instanceof OctaNumeral_JavaObject)
+      return visit((OctaNumeral_JavaObject)node);
+    if(node instanceof Deci)
+      return visit((Deci)node);
+    if(node instanceof Hexa)
+      return visit((Hexa)node);
+    if(node instanceof Octa)
+      return visit((Octa)node);
+    if(node instanceof DeciFloatLiteral_JavaObject)
+      return visit((DeciFloatLiteral_JavaObject)node);
+    if(node instanceof HexaFloatLiteral_JavaObject)
+      return visit((HexaFloatLiteral_JavaObject)node);
+    if(node instanceof Float1)
+      return visit((Float1)node);
+    if(node instanceof Float0)
+      return visit((Float0)node);
+    if(node instanceof DeciFloatNumeral_JavaObject)
+      return visit((DeciFloatNumeral_JavaObject)node);
+    if(node instanceof DeciFloatDigits_JavaObject)
+      return visit((DeciFloatDigits_JavaObject)node);
+    if(node instanceof DeciFloatExponentPart_JavaObject)
+      return visit((DeciFloatExponentPart_JavaObject)node);
+    if(node instanceof SignedInteger_JavaObject)
+      return visit((SignedInteger_JavaObject)node);
+    if(node instanceof HexaFloatNumeral_JavaObject)
+      return visit((HexaFloatNumeral_JavaObject)node);
+    if(node instanceof HexaSignificand_JavaObject)
+      return visit((HexaSignificand_JavaObject)node);
+    if(node instanceof BinaryExponent_JavaObject)
+      return visit((BinaryExponent_JavaObject)node);
+    if(node instanceof Bool)
+      return visit((Bool)node);
+    if(node instanceof True)
+      return visit((True)node);
+    if(node instanceof False)
+      return visit((False)node);
+    if(node instanceof EscapeSeq_JavaObject0)
+      return visit((EscapeSeq_JavaObject0)node);
+    if(node instanceof EscapeSeq_JavaObject)
+      return visit((EscapeSeq_JavaObject)node);
+    if(node instanceof NamedEscape)
+      return visit((NamedEscape)node);
+    if(node instanceof OctaEscape1)
+      return visit((OctaEscape1)node);
+    if(node instanceof OctaEscape20)
+      return visit((OctaEscape20)node);
+    if(node instanceof OctaEscape2)
+      return visit((OctaEscape2)node);
+    if(node instanceof OctaEscape3)
+      return visit((OctaEscape3)node);
+    if(node instanceof LastOcta_JavaObject)
+      return visit((LastOcta_JavaObject)node);
+    if(node instanceof Char0)
+      return visit((Char0)node);
+    if(node instanceof Single)
+      return visit((Single)node);
+    if(node instanceof CharContent_JavaObject0)
+      return visit((CharContent_JavaObject0)node);
+    if(node instanceof CharContent_JavaObject)
+      return visit((CharContent_JavaObject)node);
+    if(node instanceof SingleChar_JavaObject)
+      return visit((SingleChar_JavaObject)node);
+    if(node instanceof String)
+      return visit((String)node);
+    if(node instanceof Chars)
+      return visit((Chars)node);
+    if(node instanceof StringPart_JavaObject0)
+      return visit((StringPart_JavaObject0)node);
+    if(node instanceof StringPart_JavaObject)
+      return visit((StringPart_JavaObject)node);
+    if(node instanceof StringChars_JavaObject)
+      return visit((StringChars_JavaObject)node);
+    if(node instanceof Null)
+      return visit((Null)node);
+    if(node instanceof PrimType_JavaObject)
+      return visit((PrimType_JavaObject)node);
+    if(node instanceof Boolean)
+      return visit((Boolean)node);
+    if(node instanceof NumType_JavaObject0)
+      return visit((NumType_JavaObject0)node);
+    if(node instanceof NumType_JavaObject)
+      return visit((NumType_JavaObject)node);
+    if(node instanceof Byte)
+      return visit((Byte)node);
+    if(node instanceof Short)
+      return visit((Short)node);
+    if(node instanceof Int)
+      return visit((Int)node);
+    if(node instanceof Long)
+      return visit((Long)node);
+    if(node instanceof Char)
+      return visit((Char)node);
+    if(node instanceof Float)
+      return visit((Float)node);
+    if(node instanceof Double)
+      return visit((Double)node);
+    if(node instanceof PackageName)
+      return visit((PackageName)node);
+    if(node instanceof AmbName0)
+      return visit((AmbName0)node);
+    if(node instanceof AmbName)
+      return visit((AmbName)node);
+    if(node instanceof TypeName0)
+      return visit((TypeName0)node);
+    if(node instanceof TypeName)
+      return visit((TypeName)node);
+    if(node instanceof ExprName0)
+      return visit((ExprName0)node);
+    if(node instanceof ExprName)
+      return visit((ExprName)node);
+    if(node instanceof MethodName0)
+      return visit((MethodName0)node);
+    if(node instanceof MethodName)
+      return visit((MethodName)node);
+    if(node instanceof PackageOrTypeName0)
+      return visit((PackageOrTypeName0)node);
+    if(node instanceof PackageOrTypeName)
+      return visit((PackageOrTypeName)node);
+    if(node instanceof TypeArgs)
+      return visit((TypeArgs)node);
+    if(node instanceof ActualTypeArg_JavaObject)
+      return visit((ActualTypeArg_JavaObject)node);
+    if(node instanceof Wildcard)
+      return visit((Wildcard)node);
+    if(node instanceof WildcardUpperBound)
+      return visit((WildcardUpperBound)node);
+    if(node instanceof WildcardLowerBound)
+      return visit((WildcardLowerBound)node);
+    if(node instanceof TypeParam)
+      return visit((TypeParam)node);
+    if(node instanceof TypeBound)
+      return visit((TypeBound)node);
+    if(node instanceof TypeParams)
+      return visit((TypeParams)node);
+    if(node instanceof TypeVarId_JavaObject)
+      return visit((TypeVarId_JavaObject)node);
+    if(node instanceof RefType_JavaObject0)
+      return visit((RefType_JavaObject0)node);
+    if(node instanceof RefType_JavaObject)
+      return visit((RefType_JavaObject)node);
+    if(node instanceof ClassOrInterfaceType)
+      return visit((ClassOrInterfaceType)node);
+    if(node instanceof ClassType)
+      return visit((ClassType)node);
+    if(node instanceof InterfaceType)
+      return visit((InterfaceType)node);
+    if(node instanceof TypeDecSpec_JavaObject)
+      return visit((TypeDecSpec_JavaObject)node);
+    if(node instanceof Member)
+      return visit((Member)node);
+    if(node instanceof TypeVar)
+      return visit((TypeVar)node);
+    if(node instanceof ArrayType)
+      return visit((ArrayType)node);
+    if(node instanceof Type_JavaObject0)
+      return visit((Type_JavaObject0)node);
+    if(node instanceof Type_JavaObject)
+      return visit((Type_JavaObject)node);
+    if(node instanceof Lit)
+      return visit((Lit)node);
+    if(node instanceof Literal_JavaObject5)
+      return visit((Literal_JavaObject5)node);
+    if(node instanceof Literal_JavaObject4)
+      return visit((Literal_JavaObject4)node);
+    if(node instanceof Literal_JavaObject3)
+      return visit((Literal_JavaObject3)node);
+    if(node instanceof Literal_JavaObject2)
+      return visit((Literal_JavaObject2)node);
+    if(node instanceof Literal_JavaObject1)
+      return visit((Literal_JavaObject1)node);
+    if(node instanceof Literal_JavaObject0)
+      return visit((Literal_JavaObject0)node);
+    if(node instanceof Literal_JavaObject)
+      return visit((Literal_JavaObject)node);
+    if(node instanceof Class)
+      return visit((Class)node);
+    if(node instanceof VoidClass)
+      return visit((VoidClass)node);
+    if(node instanceof This)
+      return visit((This)node);
+    if(node instanceof QThis)
+      return visit((QThis)node);
+    if(node instanceof Expr)
+      return visit((Expr)node);
+    if(node instanceof ArrayInit0)
+      return visit((ArrayInit0)node);
+    if(node instanceof ArrayInit)
+      return visit((ArrayInit)node);
+    if(node instanceof FieldDec)
+      return visit((FieldDec)node);
+    if(node instanceof VarDec0)
+      return visit((VarDec0)node);
+    if(node instanceof VarDec)
+      return visit((VarDec)node);
+    if(node instanceof VarDecId_JavaObject)
+      return visit((VarDecId_JavaObject)node);
+    if(node instanceof ArrayVarDecId)
+      return visit((ArrayVarDecId)node);
+    if(node instanceof Dim0)
+      return visit((Dim0)node);
+    if(node instanceof VarInit_JavaObject0)
+      return visit((VarInit_JavaObject0)node);
+    if(node instanceof VarInit_JavaObject)
+      return visit((VarInit_JavaObject)node);
+    if(node instanceof FieldMod_JavaObject5)
+      return visit((FieldMod_JavaObject5)node);
+    if(node instanceof FieldMod_JavaObject4)
+      return visit((FieldMod_JavaObject4)node);
+    if(node instanceof FieldMod_JavaObject3)
+      return visit((FieldMod_JavaObject3)node);
+    if(node instanceof FieldMod_JavaObject2)
+      return visit((FieldMod_JavaObject2)node);
+    if(node instanceof FieldMod_JavaObject1)
+      return visit((FieldMod_JavaObject1)node);
+    if(node instanceof FieldMod_JavaObject0)
+      return visit((FieldMod_JavaObject0)node);
+    if(node instanceof FieldMod_JavaObject)
+      return visit((FieldMod_JavaObject)node);
+    if(node instanceof LocalVarDecStm)
+      return visit((LocalVarDecStm)node);
+    if(node instanceof LocalVarDec)
+      return visit((LocalVarDec)node);
+    if(node instanceof Stm_JavaObject)
+      return visit((Stm_JavaObject)node);
+    if(node instanceof Empty)
+      return visit((Empty)node);
+    if(node instanceof Labeled)
+      return visit((Labeled)node);
+    if(node instanceof ExprStm)
+      return visit((ExprStm)node);
+    if(node instanceof If0)
+      return visit((If0)node);
+    if(node instanceof If)
+      return visit((If)node);
+    if(node instanceof AssertStm0)
+      return visit((AssertStm0)node);
+    if(node instanceof AssertStm)
+      return visit((AssertStm)node);
+    if(node instanceof Switch)
+      return visit((Switch)node);
+    if(node instanceof SwitchBlock)
+      return visit((SwitchBlock)node);
+    if(node instanceof SwitchGroup)
+      return visit((SwitchGroup)node);
+    if(node instanceof Case)
+      return visit((Case)node);
+    if(node instanceof Default)
+      return visit((Default)node);
+    if(node instanceof While)
+      return visit((While)node);
+    if(node instanceof DoWhile)
+      return visit((DoWhile)node);
+    if(node instanceof For0)
+      return visit((For0)node);
+    if(node instanceof For)
+      return visit((For)node);
+    if(node instanceof ForEach)
+      return visit((ForEach)node);
+    if(node instanceof Break)
+      return visit((Break)node);
+    if(node instanceof Continue)
+      return visit((Continue)node);
+    if(node instanceof Return)
+      return visit((Return)node);
+    if(node instanceof Throw)
+      return visit((Throw)node);
+    if(node instanceof Synchronized)
+      return visit((Synchronized)node);
+    if(node instanceof Try0)
+      return visit((Try0)node);
+    if(node instanceof Try)
+      return visit((Try)node);
+    if(node instanceof Catch)
+      return visit((Catch)node);
+    if(node instanceof Block)
+      return visit((Block)node);
+    if(node instanceof BlockStm_JavaObject0)
+      return visit((BlockStm_JavaObject0)node);
+    if(node instanceof ClassDecStm)
+      return visit((ClassDecStm)node);
+    if(node instanceof BlockStm_JavaObject)
+      return visit((BlockStm_JavaObject)node);
+    if(node instanceof MethodDec)
+      return visit((MethodDec)node);
+    if(node instanceof MethodDecHead)
+      return visit((MethodDecHead)node);
+    if(node instanceof DeprMethodDecHead)
+      return visit((DeprMethodDecHead)node);
+    if(node instanceof ResultType_JavaObject)
+      return visit((ResultType_JavaObject)node);
+    if(node instanceof Void)
+      return visit((Void)node);
+    if(node instanceof Param)
+      return visit((Param)node);
+    if(node instanceof VarArityParam)
+      return visit((VarArityParam)node);
+    if(node instanceof VarMod_JavaObject)
+      return visit((VarMod_JavaObject)node);
+    if(node instanceof MethodMod_JavaObject7)
+      return visit((MethodMod_JavaObject7)node);
+    if(node instanceof MethodMod_JavaObject6)
+      return visit((MethodMod_JavaObject6)node);
+    if(node instanceof MethodMod_JavaObject5)
+      return visit((MethodMod_JavaObject5)node);
+    if(node instanceof MethodMod_JavaObject4)
+      return visit((MethodMod_JavaObject4)node);
+    if(node instanceof MethodMod_JavaObject3)
+      return visit((MethodMod_JavaObject3)node);
+    if(node instanceof MethodMod_JavaObject2)
+      return visit((MethodMod_JavaObject2)node);
+    if(node instanceof MethodMod_JavaObject1)
+      return visit((MethodMod_JavaObject1)node);
+    if(node instanceof MethodMod_JavaObject0)
+      return visit((MethodMod_JavaObject0)node);
+    if(node instanceof MethodMod_JavaObject)
+      return visit((MethodMod_JavaObject)node);
+    if(node instanceof ThrowsDec)
+      return visit((ThrowsDec)node);
+    if(node instanceof ExceptionType_JavaObject)
+      return visit((ExceptionType_JavaObject)node);
+    if(node instanceof MethodBody_JavaObject)
+      return visit((MethodBody_JavaObject)node);
+    if(node instanceof NoMethodBody)
+      return visit((NoMethodBody)node);
+    if(node instanceof InstanceInit)
+      return visit((InstanceInit)node);
+    if(node instanceof StaticInit)
+      return visit((StaticInit)node);
+    if(node instanceof ConstrDec)
+      return visit((ConstrDec)node);
+    if(node instanceof ConstrDecHead)
+      return visit((ConstrDecHead)node);
+    if(node instanceof ConstrBody)
+      return visit((ConstrBody)node);
+    if(node instanceof AltConstrInv)
+      return visit((AltConstrInv)node);
+    if(node instanceof SuperConstrInv)
+      return visit((SuperConstrInv)node);
+    if(node instanceof QSuperConstrInv)
+      return visit((QSuperConstrInv)node);
+    if(node instanceof ConstrMod_JavaObject1)
+      return visit((ConstrMod_JavaObject1)node);
+    if(node instanceof ConstrMod_JavaObject0)
+      return visit((ConstrMod_JavaObject0)node);
+    if(node instanceof ConstrMod_JavaObject)
+      return visit((ConstrMod_JavaObject)node);
+    if(node instanceof EnumDec)
+      return visit((EnumDec)node);
+    if(node instanceof EnumDecHead)
+      return visit((EnumDecHead)node);
+    if(node instanceof EnumBody0)
+      return visit((EnumBody0)node);
+    if(node instanceof EnumBody)
+      return visit((EnumBody)node);
+    if(node instanceof EnumConst)
+      return visit((EnumConst)node);
+    if(node instanceof EnumConstArgs)
+      return visit((EnumConstArgs)node);
+    if(node instanceof EnumBodyDecs)
+      return visit((EnumBodyDecs)node);
+    if(node instanceof ConstantDec)
+      return visit((ConstantDec)node);
+    if(node instanceof ConstantMod_JavaObject1)
+      return visit((ConstantMod_JavaObject1)node);
+    if(node instanceof ConstantMod_JavaObject0)
+      return visit((ConstantMod_JavaObject0)node);
+    if(node instanceof ConstantMod_JavaObject)
+      return visit((ConstantMod_JavaObject)node);
+    if(node instanceof AbstractMethodDec)
+      return visit((AbstractMethodDec)node);
+    if(node instanceof DeprAbstractMethodDec)
+      return visit((DeprAbstractMethodDec)node);
+    if(node instanceof AbstractMethodMod_JavaObject0)
+      return visit((AbstractMethodMod_JavaObject0)node);
+    if(node instanceof AbstractMethodMod_JavaObject)
+      return visit((AbstractMethodMod_JavaObject)node);
+    if(node instanceof AnnoDec)
+      return visit((AnnoDec)node);
+    if(node instanceof AnnoDecHead)
+      return visit((AnnoDecHead)node);
+    if(node instanceof AnnoMethodDec)
+      return visit((AnnoMethodDec)node);
+    if(node instanceof AnnoElemDec_JavaObject3)
+      return visit((AnnoElemDec_JavaObject3)node);
+    if(node instanceof AnnoElemDec_JavaObject2)
+      return visit((AnnoElemDec_JavaObject2)node);
+    if(node instanceof AnnoElemDec_JavaObject1)
+      return visit((AnnoElemDec_JavaObject1)node);
+    if(node instanceof AnnoElemDec_JavaObject0)
+      return visit((AnnoElemDec_JavaObject0)node);
+    if(node instanceof AnnoElemDec_JavaObject)
+      return visit((AnnoElemDec_JavaObject)node);
+    if(node instanceof Semicolon2)
+      return visit((Semicolon2)node);
+    if(node instanceof DefaultVal)
+      return visit((DefaultVal)node);
+    if(node instanceof InterfaceDec_JavaObject)
+      return visit((InterfaceDec_JavaObject)node);
+    if(node instanceof InterfaceDec)
+      return visit((InterfaceDec)node);
+    if(node instanceof InterfaceDecHead)
+      return visit((InterfaceDecHead)node);
+    if(node instanceof ExtendsInterfaces)
+      return visit((ExtendsInterfaces)node);
+    if(node instanceof InterfaceMemberDec_JavaObject2)
+      return visit((InterfaceMemberDec_JavaObject2)node);
+    if(node instanceof InterfaceMemberDec_JavaObject1)
+      return visit((InterfaceMemberDec_JavaObject1)node);
+    if(node instanceof InterfaceMemberDec_JavaObject0)
+      return visit((InterfaceMemberDec_JavaObject0)node);
+    if(node instanceof InterfaceMemberDec_JavaObject)
+      return visit((InterfaceMemberDec_JavaObject)node);
+    if(node instanceof Semicolon1)
+      return visit((Semicolon1)node);
+    if(node instanceof InterfaceMod_JavaObject4)
+      return visit((InterfaceMod_JavaObject4)node);
+    if(node instanceof InterfaceMod_JavaObject3)
+      return visit((InterfaceMod_JavaObject3)node);
+    if(node instanceof InterfaceMod_JavaObject2)
+      return visit((InterfaceMod_JavaObject2)node);
+    if(node instanceof InterfaceMod_JavaObject1)
+      return visit((InterfaceMod_JavaObject1)node);
+    if(node instanceof InterfaceMod_JavaObject0)
+      return visit((InterfaceMod_JavaObject0)node);
+    if(node instanceof InterfaceMod_JavaObject)
+      return visit((InterfaceMod_JavaObject)node);
+    if(node instanceof ClassDec_JavaObject)
+      return visit((ClassDec_JavaObject)node);
+    if(node instanceof ClassDec)
+      return visit((ClassDec)node);
+    if(node instanceof ClassBody)
+      return visit((ClassBody)node);
+    if(node instanceof ClassDecHead)
+      return visit((ClassDecHead)node);
+    if(node instanceof ClassMod_JavaObject5)
+      return visit((ClassMod_JavaObject5)node);
+    if(node instanceof ClassMod_JavaObject4)
+      return visit((ClassMod_JavaObject4)node);
+    if(node instanceof ClassMod_JavaObject3)
+      return visit((ClassMod_JavaObject3)node);
+    if(node instanceof ClassMod_JavaObject2)
+      return visit((ClassMod_JavaObject2)node);
+    if(node instanceof ClassMod_JavaObject1)
+      return visit((ClassMod_JavaObject1)node);
+    if(node instanceof ClassMod_JavaObject0)
+      return visit((ClassMod_JavaObject0)node);
+    if(node instanceof ClassMod_JavaObject)
+      return visit((ClassMod_JavaObject)node);
+    if(node instanceof SuperDec)
+      return visit((SuperDec)node);
+    if(node instanceof ImplementsDec)
+      return visit((ImplementsDec)node);
+    if(node instanceof ClassBodyDec_JavaObject2)
+      return visit((ClassBodyDec_JavaObject2)node);
+    if(node instanceof ClassBodyDec_JavaObject1)
+      return visit((ClassBodyDec_JavaObject1)node);
+    if(node instanceof ClassBodyDec_JavaObject0)
+      return visit((ClassBodyDec_JavaObject0)node);
+    if(node instanceof ClassBodyDec_JavaObject)
+      return visit((ClassBodyDec_JavaObject)node);
+    if(node instanceof ClassMemberDec_JavaObject2)
+      return visit((ClassMemberDec_JavaObject2)node);
+    if(node instanceof ClassMemberDec_JavaObject1)
+      return visit((ClassMemberDec_JavaObject1)node);
+    if(node instanceof ClassMemberDec_JavaObject0)
+      return visit((ClassMemberDec_JavaObject0)node);
+    if(node instanceof ClassMemberDec_JavaObject)
+      return visit((ClassMemberDec_JavaObject)node);
+    if(node instanceof Semicolon0)
+      return visit((Semicolon0)node);
+    if(node instanceof NewInstance)
+      return visit((NewInstance)node);
+    if(node instanceof QNewInstance)
+      return visit((QNewInstance)node);
+    if(node instanceof Expr_JavaObject3)
+      return visit((Expr_JavaObject3)node);
+    if(node instanceof NewArray0)
+      return visit((NewArray0)node);
+    if(node instanceof NewArray)
+      return visit((NewArray)node);
+    if(node instanceof ArrayBaseType_JavaObject0)
+      return visit((ArrayBaseType_JavaObject0)node);
+    if(node instanceof ArrayBaseType_JavaObject)
+      return visit((ArrayBaseType_JavaObject)node);
+    if(node instanceof UnboundWld)
+      return visit((UnboundWld)node);
+    if(node instanceof Dim)
+      return visit((Dim)node);
+    if(node instanceof Expr_JavaObject2)
+      return visit((Expr_JavaObject2)node);
+    if(node instanceof Field)
+      return visit((Field)node);
+    if(node instanceof SuperField)
+      return visit((SuperField)node);
+    if(node instanceof QSuperField)
+      return visit((QSuperField)node);
+    if(node instanceof Expr_JavaObject1)
+      return visit((Expr_JavaObject1)node);
+    if(node instanceof ArrayAccess)
+      return visit((ArrayAccess)node);
+    if(node instanceof ArraySubscript)
+      return visit((ArraySubscript)node);
+    if(node instanceof Invoke)
+      return visit((Invoke)node);
+    if(node instanceof Method0)
+      return visit((Method0)node);
+    if(node instanceof Method)
+      return visit((Method)node);
+    if(node instanceof SuperMethod)
+      return visit((SuperMethod)node);
+    if(node instanceof QSuperMethod)
+      return visit((QSuperMethod)node);
+    if(node instanceof GenericMethod)
+      return visit((GenericMethod)node);
+    if(node instanceof Expr_JavaObject0)
+      return visit((Expr_JavaObject0)node);
+    if(node instanceof PostIncr)
+      return visit((PostIncr)node);
+    if(node instanceof PostDecr)
+      return visit((PostDecr)node);
+    if(node instanceof Plus0)
+      return visit((Plus0)node);
+    if(node instanceof Minus0)
+      return visit((Minus0)node);
+    if(node instanceof PreIncr)
+      return visit((PreIncr)node);
+    if(node instanceof PreDecr)
+      return visit((PreDecr)node);
+    if(node instanceof Complement)
+      return visit((Complement)node);
+    if(node instanceof Not)
+      return visit((Not)node);
+    if(node instanceof CastPrim)
+      return visit((CastPrim)node);
+    if(node instanceof CastRef)
+      return visit((CastRef)node);
+    if(node instanceof Expr_JavaObject)
+      return visit((Expr_JavaObject)node);
+    if(node instanceof InstanceOf)
+      return visit((InstanceOf)node);
+    if(node instanceof Mul)
+      return visit((Mul)node);
+    if(node instanceof Div)
+      return visit((Div)node);
+    if(node instanceof Remain)
+      return visit((Remain)node);
+    if(node instanceof Plus)
+      return visit((Plus)node);
+    if(node instanceof Minus)
+      return visit((Minus)node);
+    if(node instanceof LeftShift)
+      return visit((LeftShift)node);
+    if(node instanceof RightShift)
+      return visit((RightShift)node);
+    if(node instanceof URightShift)
+      return visit((URightShift)node);
+    if(node instanceof Lt)
+      return visit((Lt)node);
+    if(node instanceof Gt)
+      return visit((Gt)node);
+    if(node instanceof LtEq)
+      return visit((LtEq)node);
+    if(node instanceof GtEq)
+      return visit((GtEq)node);
+    if(node instanceof Eq)
+      return visit((Eq)node);
+    if(node instanceof NotEq)
+      return visit((NotEq)node);
+    if(node instanceof LazyAnd)
+      return visit((LazyAnd)node);
+    if(node instanceof LazyOr)
+      return visit((LazyOr)node);
+    if(node instanceof And)
+      return visit((And)node);
+    if(node instanceof ExcOr)
+      return visit((ExcOr)node);
+    if(node instanceof Or)
+      return visit((Or)node);
+    if(node instanceof Cond)
+      return visit((Cond)node);
+    if(node instanceof CondMid)
+      return visit((CondMid)node);
+    if(node instanceof Assign)
+      return visit((Assign)node);
+    if(node instanceof AssignMul)
+      return visit((AssignMul)node);
+    if(node instanceof AssignDiv)
+      return visit((AssignDiv)node);
+    if(node instanceof AssignRemain)
+      return visit((AssignRemain)node);
+    if(node instanceof AssignPlus)
+      return visit((AssignPlus)node);
+    if(node instanceof AssignMinus)
+      return visit((AssignMinus)node);
+    if(node instanceof AssignLeftShift)
+      return visit((AssignLeftShift)node);
+    if(node instanceof AssignRightShift)
+      return visit((AssignRightShift)node);
+    if(node instanceof AssignURightShift)
+      return visit((AssignURightShift)node);
+    if(node instanceof AssignAnd)
+      return visit((AssignAnd)node);
+    if(node instanceof AssignExcOr)
+      return visit((AssignExcOr)node);
+    if(node instanceof AssignOr)
+      return visit((AssignOr)node);
+    if(node instanceof LHS_JavaObject1)
+      return visit((LHS_JavaObject1)node);
+    if(node instanceof LHS_JavaObject0)
+      return visit((LHS_JavaObject0)node);
+    if(node instanceof LHS_JavaObject)
+      return visit((LHS_JavaObject)node);
+    if(node instanceof Anno)
+      return visit((Anno)node);
+    if(node instanceof SingleElemAnno)
+      return visit((SingleElemAnno)node);
+    if(node instanceof MarkerAnno)
+      return visit((MarkerAnno)node);
+    if(node instanceof ElemValPair)
+      return visit((ElemValPair)node);
+    if(node instanceof ElemVal_JavaObject0)
+      return visit((ElemVal_JavaObject0)node);
+    if(node instanceof ElemVal_JavaObject)
+      return visit((ElemVal_JavaObject)node);
+    if(node instanceof ElemValArrayInit0)
+      return visit((ElemValArrayInit0)node);
+    if(node instanceof ElemValArrayInit)
+      return visit((ElemValArrayInit)node);
+    if(node instanceof PackageDec)
+      return visit((PackageDec)node);
+    if(node instanceof TypeImportDec)
+      return visit((TypeImportDec)node);
+    if(node instanceof TypeImportOnDemandDec)
+      return visit((TypeImportOnDemandDec)node);
+    if(node instanceof StaticImportDec)
+      return visit((StaticImportDec)node);
+    if(node instanceof StaticImportOnDemandDec)
+      return visit((StaticImportOnDemandDec)node);
+    if(node instanceof TypeDec_JavaObject0)
+      return visit((TypeDec_JavaObject0)node);
+    if(node instanceof TypeDec_JavaObject)
+      return visit((TypeDec_JavaObject)node);
+    if(node instanceof Semicolon)
+      return visit((Semicolon)node);
+    if(node instanceof CompilationUnit)
+      return visit((CompilationUnit)node);
+    if(node instanceof Metavar41)
+      return visit((Metavar41)node);
+    if(node instanceof Metavar40)
+      return visit((Metavar40)node);
+    if(node instanceof Metavar39)
+      return visit((Metavar39)node);
+    if(node instanceof Metavar38)
+      return visit((Metavar38)node);
+    if(node instanceof Metavar37)
+      return visit((Metavar37)node);
+    if(node instanceof Metavar36)
+      return visit((Metavar36)node);
+    if(node instanceof ToMetaExpr80)
+      return visit((ToMetaExpr80)node);
+    if(node instanceof ToMetaExpr79)
+      return visit((ToMetaExpr79)node);
+    if(node instanceof ToMetaExpr78)
+      return visit((ToMetaExpr78)node);
+    if(node instanceof ToMetaExpr77)
+      return visit((ToMetaExpr77)node);
+    if(node instanceof ToMetaExpr76)
+      return visit((ToMetaExpr76)node);
+    if(node instanceof ToMetaExpr75)
+      return visit((ToMetaExpr75)node);
+    if(node instanceof ToMetaExpr74)
+      return visit((ToMetaExpr74)node);
+    if(node instanceof ToMetaExpr73)
+      return visit((ToMetaExpr73)node);
+    if(node instanceof ToMetaExpr72)
+      return visit((ToMetaExpr72)node);
+    if(node instanceof ToMetaExpr71)
+      return visit((ToMetaExpr71)node);
+    if(node instanceof ToMetaListExpr7)
+      return visit((ToMetaListExpr7)node);
+    if(node instanceof ToMetaListExpr6)
+      return visit((ToMetaListExpr6)node);
+    if(node instanceof ToMetaExpr70)
+      return visit((ToMetaExpr70)node);
+    if(node instanceof ToMetaExpr69)
+      return visit((ToMetaExpr69)node);
+    if(node instanceof ToMetaListExpr5)
+      return visit((ToMetaListExpr5)node);
+    if(node instanceof ToMetaListExpr4)
+      return visit((ToMetaListExpr4)node);
+    if(node instanceof ToMetaExpr68)
+      return visit((ToMetaExpr68)node);
+    if(node instanceof ToMetaExpr67)
+      return visit((ToMetaExpr67)node);
+    if(node instanceof ToMetaListExpr3)
+      return visit((ToMetaListExpr3)node);
+    if(node instanceof ToMetaListExpr2)
+      return visit((ToMetaListExpr2)node);
+    if(node instanceof FromMetaExpr33)
+      return visit((FromMetaExpr33)node);
+    if(node instanceof FromMetaExpr32)
+      return visit((FromMetaExpr32)node);
+    if(node instanceof FromMetaExpr31)
+      return visit((FromMetaExpr31)node);
+    if(node instanceof FromMetaExpr30)
+      return visit((FromMetaExpr30)node);
+    if(node instanceof FromMetaExpr29)
+      return visit((FromMetaExpr29)node);
+    if(node instanceof FromMetaExpr28)
+      return visit((FromMetaExpr28)node);
+    if(node instanceof Metavar35)
+      return visit((Metavar35)node);
+    if(node instanceof Metavar34)
+      return visit((Metavar34)node);
+    if(node instanceof Metavar33)
+      return visit((Metavar33)node);
+    if(node instanceof Metavar32)
+      return visit((Metavar32)node);
+    if(node instanceof Metavar31)
+      return visit((Metavar31)node);
+    if(node instanceof Metavar30)
+      return visit((Metavar30)node);
+    if(node instanceof Metavar29)
+      return visit((Metavar29)node);
+    if(node instanceof Metavar28)
+      return visit((Metavar28)node);
+    if(node instanceof ToMetaExpr66)
+      return visit((ToMetaExpr66)node);
+    if(node instanceof ToMetaExpr65)
+      return visit((ToMetaExpr65)node);
+    if(node instanceof ToMetaExpr64)
+      return visit((ToMetaExpr64)node);
+    if(node instanceof ToMetaExpr63)
+      return visit((ToMetaExpr63)node);
+    if(node instanceof Metavar27)
+      return visit((Metavar27)node);
+    if(node instanceof Metavar26)
+      return visit((Metavar26)node);
+    if(node instanceof Metavar25)
+      return visit((Metavar25)node);
+    if(node instanceof Metavar24)
+      return visit((Metavar24)node);
+    if(node instanceof Metavar23)
+      return visit((Metavar23)node);
+    if(node instanceof MetaTypeVar_JavaObject)
+      return visit((MetaTypeVar_JavaObject)node);
+    if(node instanceof MetaPrimTypeVar_JavaObject)
+      return visit((MetaPrimTypeVar_JavaObject)node);
+    if(node instanceof MetaRefTypeVar_JavaObject)
+      return visit((MetaRefTypeVar_JavaObject)node);
+    if(node instanceof ToMetaExpr62)
+      return visit((ToMetaExpr62)node);
+    if(node instanceof ToMetaExpr61)
+      return visit((ToMetaExpr61)node);
+    if(node instanceof ToMetaExpr60)
+      return visit((ToMetaExpr60)node);
+    if(node instanceof ToMetaExpr59)
+      return visit((ToMetaExpr59)node);
+    if(node instanceof ToMetaExpr58)
+      return visit((ToMetaExpr58)node);
+    if(node instanceof ToMetaExpr57)
+      return visit((ToMetaExpr57)node);
+    if(node instanceof FromMetaExpr27)
+      return visit((FromMetaExpr27)node);
+    if(node instanceof FromMetaExpr26)
+      return visit((FromMetaExpr26)node);
+    if(node instanceof ToMetaExpr56)
+      return visit((ToMetaExpr56)node);
+    if(node instanceof ToMetaExpr55)
+      return visit((ToMetaExpr55)node);
+    if(node instanceof ToMetaExpr54)
+      return visit((ToMetaExpr54)node);
+    if(node instanceof ToMetaExpr53)
+      return visit((ToMetaExpr53)node);
+    if(node instanceof ToMetaExpr52)
+      return visit((ToMetaExpr52)node);
+    if(node instanceof ToMetaExpr51)
+      return visit((ToMetaExpr51)node);
+    if(node instanceof ToMetaExpr50)
+      return visit((ToMetaExpr50)node);
+    if(node instanceof ToMetaExpr49)
+      return visit((ToMetaExpr49)node);
+    if(node instanceof ToMetaExpr48)
+      return visit((ToMetaExpr48)node);
+    if(node instanceof ToMetaExpr47)
+      return visit((ToMetaExpr47)node);
+    if(node instanceof ToMetaExpr46)
+      return visit((ToMetaExpr46)node);
+    if(node instanceof ToMetaExpr45)
+      return visit((ToMetaExpr45)node);
+    if(node instanceof ToMetaExpr44)
+      return visit((ToMetaExpr44)node);
+    if(node instanceof ToMetaExpr43)
+      return visit((ToMetaExpr43)node);
+    if(node instanceof ToMetaExpr42)
+      return visit((ToMetaExpr42)node);
+    if(node instanceof ToMetaExpr41)
+      return visit((ToMetaExpr41)node);
+    if(node instanceof ToMetaExpr40)
+      return visit((ToMetaExpr40)node);
+    if(node instanceof ToMetaExpr39)
+      return visit((ToMetaExpr39)node);
+    if(node instanceof ToMetaExpr38)
+      return visit((ToMetaExpr38)node);
+    if(node instanceof ToMetaExpr37)
+      return visit((ToMetaExpr37)node);
+    if(node instanceof FromMetaExpr25)
+      return visit((FromMetaExpr25)node);
+    if(node instanceof ToMetaExpr36)
+      return visit((ToMetaExpr36)node);
+    if(node instanceof ToMetaExpr35)
+      return visit((ToMetaExpr35)node);
+    if(node instanceof ToMetaExpr34)
+      return visit((ToMetaExpr34)node);
+    if(node instanceof ToMetaExpr33)
+      return visit((ToMetaExpr33)node);
+    if(node instanceof ToMetaExpr32)
+      return visit((ToMetaExpr32)node);
+    if(node instanceof FromMetaExpr24)
+      return visit((FromMetaExpr24)node);
+    if(node instanceof FromMetaExpr23)
+      return visit((FromMetaExpr23)node);
+    if(node instanceof ToMetaExpr31)
+      return visit((ToMetaExpr31)node);
+    if(node instanceof ToMetaExpr30)
+      return visit((ToMetaExpr30)node);
+    if(node instanceof ToMetaExpr29)
+      return visit((ToMetaExpr29)node);
+    if(node instanceof ToMetaListExpr1)
+      return visit((ToMetaListExpr1)node);
+    if(node instanceof ToMetaListExpr0)
+      return visit((ToMetaListExpr0)node);
+    if(node instanceof FromMetaExpr22)
+      return visit((FromMetaExpr22)node);
+    if(node instanceof ToMetaExpr28)
+      return visit((ToMetaExpr28)node);
+    if(node instanceof ToMetaExpr27)
+      return visit((ToMetaExpr27)node);
+    if(node instanceof ToMetaExpr26)
+      return visit((ToMetaExpr26)node);
+    if(node instanceof ToMetaExpr25)
+      return visit((ToMetaExpr25)node);
+    if(node instanceof ToMetaExpr24)
+      return visit((ToMetaExpr24)node);
+    if(node instanceof ToMetaExpr23)
+      return visit((ToMetaExpr23)node);
+    if(node instanceof ToMetaExpr22)
+      return visit((ToMetaExpr22)node);
+    if(node instanceof ToMetaExpr21)
+      return visit((ToMetaExpr21)node);
+    if(node instanceof ToMetaExpr20)
+      return visit((ToMetaExpr20)node);
+    if(node instanceof ToMetaExpr19)
+      return visit((ToMetaExpr19)node);
+    if(node instanceof ToMetaExpr18)
+      return visit((ToMetaExpr18)node);
+    if(node instanceof ToMetaExpr17)
+      return visit((ToMetaExpr17)node);
+    if(node instanceof ToMetaExpr16)
+      return visit((ToMetaExpr16)node);
+    if(node instanceof ToMetaExpr15)
+      return visit((ToMetaExpr15)node);
+    if(node instanceof ToMetaExpr14)
+      return visit((ToMetaExpr14)node);
+    if(node instanceof ToMetaExpr13)
+      return visit((ToMetaExpr13)node);
+    if(node instanceof ToMetaExpr12)
+      return visit((ToMetaExpr12)node);
+    if(node instanceof ToMetaExpr11)
+      return visit((ToMetaExpr11)node);
+    if(node instanceof ToMetaExpr10)
+      return visit((ToMetaExpr10)node);
+    if(node instanceof ToMetaExpr9)
+      return visit((ToMetaExpr9)node);
+    if(node instanceof ToMetaExpr8)
+      return visit((ToMetaExpr8)node);
+    if(node instanceof ToMetaExpr7)
+      return visit((ToMetaExpr7)node);
+    if(node instanceof ToMetaListExpr)
+      return visit((ToMetaListExpr)node);
+    if(node instanceof ToMetaExpr6)
+      return visit((ToMetaExpr6)node);
+    if(node instanceof ToMetaExpr5)
+      return visit((ToMetaExpr5)node);
+    if(node instanceof ToMetaExpr4)
+      return visit((ToMetaExpr4)node);
+    if(node instanceof ToMetaExpr3)
+      return visit((ToMetaExpr3)node);
+    if(node instanceof ToMetaExpr2)
+      return visit((ToMetaExpr2)node);
+    if(node instanceof ToMetaExpr1)
+      return visit((ToMetaExpr1)node);
+    if(node instanceof ToMetaExpr0)
+      return visit((ToMetaExpr0)node);
+    if(node instanceof ToMetaExpr)
+      return visit((ToMetaExpr)node);
+    if(node instanceof FromMetaExpr21)
+      return visit((FromMetaExpr21)node);
+    if(node instanceof FromMetaExpr20)
+      return visit((FromMetaExpr20)node);
+    if(node instanceof FromMetaExpr19)
+      return visit((FromMetaExpr19)node);
+    if(node instanceof FromMetaExpr18)
+      return visit((FromMetaExpr18)node);
+    if(node instanceof FromMetaExpr17)
+      return visit((FromMetaExpr17)node);
+    if(node instanceof FromMetaExpr16)
+      return visit((FromMetaExpr16)node);
+    if(node instanceof FromMetaExpr15)
+      return visit((FromMetaExpr15)node);
+    if(node instanceof FromMetaExpr14)
+      return visit((FromMetaExpr14)node);
+    if(node instanceof FromMetaExpr13)
+      return visit((FromMetaExpr13)node);
+    if(node instanceof FromMetaExpr12)
+      return visit((FromMetaExpr12)node);
+    if(node instanceof FromMetaExpr11)
+      return visit((FromMetaExpr11)node);
+    if(node instanceof FromMetaExpr10)
+      return visit((FromMetaExpr10)node);
+    if(node instanceof FromMetaExpr9)
+      return visit((FromMetaExpr9)node);
+    if(node instanceof FromMetaExpr8)
+      return visit((FromMetaExpr8)node);
+    if(node instanceof FromMetaExpr7)
+      return visit((FromMetaExpr7)node);
+    if(node instanceof FromMetaExpr6)
+      return visit((FromMetaExpr6)node);
+    if(node instanceof FromMetaExpr5)
+      return visit((FromMetaExpr5)node);
+    if(node instanceof FromMetaExpr4)
+      return visit((FromMetaExpr4)node);
+    if(node instanceof FromMetaExpr3)
+      return visit((FromMetaExpr3)node);
+    if(node instanceof FromMetaExpr2)
+      return visit((FromMetaExpr2)node);
+    if(node instanceof FromMetaExpr1)
+      return visit((FromMetaExpr1)node);
+    if(node instanceof Metavar22)
+      return visit((Metavar22)node);
+    if(node instanceof Metavar21)
+      return visit((Metavar21)node);
+    if(node instanceof Metavar20)
+      return visit((Metavar20)node);
+    if(node instanceof Metavar19)
+      return visit((Metavar19)node);
+    if(node instanceof Metavar18)
+      return visit((Metavar18)node);
+    if(node instanceof Metavar17)
+      return visit((Metavar17)node);
+    if(node instanceof Metavar16)
+      return visit((Metavar16)node);
+    if(node instanceof Metavar15)
+      return visit((Metavar15)node);
+    if(node instanceof Metavar14)
+      return visit((Metavar14)node);
+    if(node instanceof Metavar13)
+      return visit((Metavar13)node);
+    if(node instanceof Metavar12)
+      return visit((Metavar12)node);
+    if(node instanceof Metavar11)
+      return visit((Metavar11)node);
+    if(node instanceof Metavar10)
+      return visit((Metavar10)node);
+    if(node instanceof Metavar9)
+      return visit((Metavar9)node);
+    if(node instanceof Metavar8)
+      return visit((Metavar8)node);
+    if(node instanceof Metavar7)
+      return visit((Metavar7)node);
+    if(node instanceof Metavar6)
+      return visit((Metavar6)node);
+    if(node instanceof Metavar5)
+      return visit((Metavar5)node);
+    if(node instanceof Metavar4)
+      return visit((Metavar4)node);
+    if(node instanceof Metavar3)
+      return visit((Metavar3)node);
+    if(node instanceof Metavar2)
+      return visit((Metavar2)node);
+    if(node instanceof Metavar1)
+      return visit((Metavar1)node);
+    if(node instanceof Metavar0)
+      return visit((Metavar0)node);
+    if(node instanceof Metavar)
+      return visit((Metavar)node);
+    if(node instanceof FromMetaExpr0)
+      return visit((FromMetaExpr0)node);
+    if(node instanceof FromMetaExpr)
+      return visit((FromMetaExpr)node);
+    if(node instanceof ListPlusOfCommChar0)
+      return visit((ListPlusOfCommChar0)node);
+    if(node instanceof ListStarOfCommChar0)
+      return visit((ListStarOfCommChar0)node);
+    if(node instanceof ListPlusOfModNamePart_StrategoHost0)
+      return visit((ListPlusOfModNamePart_StrategoHost0)node);
+    if(node instanceof ListStarOfModNamePart_StrategoHost0)
+      return visit((ListStarOfModNamePart_StrategoHost0)node);
+    if(node instanceof ListPlusOfStrChar_StrategoHost0)
+      return visit((ListPlusOfStrChar_StrategoHost0)node);
+    if(node instanceof ListStarOfStrChar_StrategoHost0)
+      return visit((ListStarOfStrChar_StrategoHost0)node);
+    if(node instanceof ListPlusOfCommentPart0)
+      return visit((ListPlusOfCommentPart0)node);
+    if(node instanceof ListStarOfCommentPart0)
+      return visit((ListStarOfCommentPart0)node);
+    if(node instanceof OptDeciFloatExponentPart_JavaObject0)
+      return visit((OptDeciFloatExponentPart_JavaObject0)node);
+    if(node instanceof OptWildcardBound_JavaObject0)
+      return visit((OptWildcardBound_JavaObject0)node);
+    if(node instanceof OptTypeBound_JavaObject0)
+      return visit((OptTypeBound_JavaObject0)node);
+    if(node instanceof OptId_JavaObject0)
+      return visit((OptId_JavaObject0)node);
+    if(node instanceof OptExpr_JavaObject0)
+      return visit((OptExpr_JavaObject0)node);
+    if(node instanceof OptConstrInv_JavaObject0)
+      return visit((OptConstrInv_JavaObject0)node);
+    if(node instanceof OptEnumBodyDecs_JavaObject0)
+      return visit((OptEnumBodyDecs_JavaObject0)node);
+    if(node instanceof OptEnumConstArgs_JavaObject0)
+      return visit((OptEnumConstArgs_JavaObject0)node);
+    if(node instanceof Anno_JavaObject_ConstantMod_JavaObject00)
+      return visit((Anno_JavaObject_ConstantMod_JavaObject00)node);
+    if(node instanceof Anno_JavaObject_ConstantMod_JavaObject0)
+      return visit((Anno_JavaObject_ConstantMod_JavaObject0)node);
+    if(node instanceof Anno_JavaObject_AbstractMethodMod_JavaObject00)
+      return visit((Anno_JavaObject_AbstractMethodMod_JavaObject00)node);
+    if(node instanceof Anno_JavaObject_AbstractMethodMod_JavaObject0)
+      return visit((Anno_JavaObject_AbstractMethodMod_JavaObject0)node);
+    if(node instanceof OptThrows_JavaObject0)
+      return visit((OptThrows_JavaObject0)node);
+    if(node instanceof OptDefaultVal_JavaObject0)
+      return visit((OptDefaultVal_JavaObject0)node);
+    if(node instanceof Anno_JavaObject_InterfaceMod_JavaObject00)
+      return visit((Anno_JavaObject_InterfaceMod_JavaObject00)node);
+    if(node instanceof Anno_JavaObject_InterfaceMod_JavaObject0)
+      return visit((Anno_JavaObject_InterfaceMod_JavaObject0)node);
+    if(node instanceof OptExtendsInterfaces_JavaObject0)
+      return visit((OptExtendsInterfaces_JavaObject0)node);
+    if(node instanceof OptTypeParams_JavaObject0)
+      return visit((OptTypeParams_JavaObject0)node);
+    if(node instanceof OptSuper_JavaObject0)
+      return visit((OptSuper_JavaObject0)node);
+    if(node instanceof OptInterfaces_JavaObject0)
+      return visit((OptInterfaces_JavaObject0)node);
+    if(node instanceof OptTypeArgs_JavaObject00)
+      return visit((OptTypeArgs_JavaObject00)node);
+    if(node instanceof OptPackageDec_JavaObject0)
+      return visit((OptPackageDec_JavaObject0)node);
+    if(node instanceof Anno_JavaObject_MethodMod_JavaObject00)
+      return visit((Anno_JavaObject_MethodMod_JavaObject00)node);
+    if(node instanceof Anno_JavaObject_MethodMod_JavaObject0)
+      return visit((Anno_JavaObject_MethodMod_JavaObject0)node);
+    if(node instanceof Anno_JavaObject_ClassMod_JavaObject00)
+      return visit((Anno_JavaObject_ClassMod_JavaObject00)node);
+    if(node instanceof Anno_JavaObject_ClassMod_JavaObject0)
+      return visit((Anno_JavaObject_ClassMod_JavaObject0)node);
+    if(node instanceof Anno_JavaObject_ConstrMod_JavaObject00)
+      return visit((Anno_JavaObject_ConstrMod_JavaObject00)node);
+    if(node instanceof Anno_JavaObject_ConstrMod_JavaObject0)
+      return visit((Anno_JavaObject_ConstrMod_JavaObject0)node);
+    if(node instanceof Anno_JavaObject_VarMod_JavaObject00)
+      return visit((Anno_JavaObject_VarMod_JavaObject00)node);
+    if(node instanceof Anno_JavaObject_VarMod_JavaObject0)
+      return visit((Anno_JavaObject_VarMod_JavaObject0)node);
+    if(node instanceof Anno_JavaObject_FieldMod_JavaObject00)
+      return visit((Anno_JavaObject_FieldMod_JavaObject00)node);
+    if(node instanceof Anno_JavaObject_FieldMod_JavaObject0)
+      return visit((Anno_JavaObject_FieldMod_JavaObject0)node);
+    if(node instanceof OptClassBody_JavaObject0)
+      return visit((OptClassBody_JavaObject0)node);
+    if(node instanceof OptTypeArgs_JavaObject0)
+      return visit((OptTypeArgs_JavaObject0)node);
+    if(node instanceof WsSort)
+      return visit((WsSort)node);
+    if(node instanceof ShortComSort)
+      return visit((ShortComSort)node);
+    if(node instanceof LongComSort)
+      return visit((LongComSort)node);
+    if(node instanceof EofSort)
+      return visit((EofSort)node);
+    if(node instanceof CommCharSort)
+      return visit((CommCharSort)node);
+    if(node instanceof AsteriskSort)
+      return visit((AsteriskSort)node);
+    if(node instanceof ModName_StrategoHostSort)
+      return visit((ModName_StrategoHostSort)node);
+    if(node instanceof ModNamePart_StrategoHostSort)
+      return visit((ModNamePart_StrategoHostSort)node);
+    if(node instanceof Id_StrategoHostSort)
+      return visit((Id_StrategoHostSort)node);
+    if(node instanceof LId_StrategoHostSort)
+      return visit((LId_StrategoHostSort)node);
+    if(node instanceof LCID_StrategoHostSort)
+      return visit((LCID_StrategoHostSort)node);
+    if(node instanceof UCID_StrategoHostSort)
+      return visit((UCID_StrategoHostSort)node);
+    if(node instanceof Keyword_StrategoHostSort)
+      return visit((Keyword_StrategoHostSort)node);
+    if(node instanceof Int_StrategoHostSort)
+      return visit((Int_StrategoHostSort)node);
+    if(node instanceof Real_StrategoHostSort)
+      return visit((Real_StrategoHostSort)node);
+    if(node instanceof String_StrategoHostSort)
+      return visit((String_StrategoHostSort)node);
+    if(node instanceof StrChar_StrategoHostSort)
+      return visit((StrChar_StrategoHostSort)node);
+    if(node instanceof Char_StrategoHostSort)
+      return visit((Char_StrategoHostSort)node);
+    if(node instanceof CharChar_StrategoHostSort)
+      return visit((CharChar_StrategoHostSort)node);
+    if(node instanceof Sdecl_StrategoHostSort)
+      return visit((Sdecl_StrategoHostSort)node);
+    if(node instanceof Opdecl_StrategoHostSort)
+      return visit((Opdecl_StrategoHostSort)node);
+    if(node instanceof ConstType_StrategoHostSort)
+      return visit((ConstType_StrategoHostSort)node);
+    if(node instanceof FunType_StrategoHostSort)
+      return visit((FunType_StrategoHostSort)node);
+    if(node instanceof ArgTypeSort)
+      return visit((ArgTypeSort)node);
+    if(node instanceof ArgType_StrategoHostSort)
+      return visit((ArgType_StrategoHostSort)node);
+    if(node instanceof RetType_StrategoHostSort)
+      return visit((RetType_StrategoHostSort)node);
+    if(node instanceof Type_StrategoHostSort)
+      return visit((Type_StrategoHostSort)node);
+    if(node instanceof SVar_StrategoHostSort)
+      return visit((SVar_StrategoHostSort)node);
+    if(node instanceof StrategyParen_StrategoHostSort)
+      return visit((StrategyParen_StrategoHostSort)node);
+    if(node instanceof StrategyMid_StrategoHostSort)
+      return visit((StrategyMid_StrategoHostSort)node);
+    if(node instanceof Module_StrategoHostSort)
+      return visit((Module_StrategoHostSort)node);
+    if(node instanceof ImportModName_StrategoHostSort)
+      return visit((ImportModName_StrategoHostSort)node);
+    if(node instanceof LID_StrategoHostSort)
+      return visit((LID_StrategoHostSort)node);
+    if(node instanceof Var_StrategoHostSort)
+      return visit((Var_StrategoHostSort)node);
+    if(node instanceof ID_StrategoHostSort)
+      return visit((ID_StrategoHostSort)node);
+    if(node instanceof PreTerm_StrategoHostSort)
+      return visit((PreTerm_StrategoHostSort)node);
+    if(node instanceof Sort_StrategoHostSort)
+      return visit((Sort_StrategoHostSort)node);
+    if(node instanceof Kind_StrategoHostSort)
+      return visit((Kind_StrategoHostSort)node);
+    if(node instanceof StrategyDef_StrategoHostSort)
+      return visit((StrategyDef_StrategoHostSort)node);
+    if(node instanceof Typedid_StrategoHostSort)
+      return visit((Typedid_StrategoHostSort)node);
+    if(node instanceof StrategyAngleSort)
+      return visit((StrategyAngleSort)node);
+    if(node instanceof StrategyCurly_StrategoHostSort)
+      return visit((StrategyCurly_StrategoHostSort)node);
+    if(node instanceof StrategySort)
+      return visit((StrategySort)node);
+    if(node instanceof SwitchCase_StrategoHostSort)
+      return visit((SwitchCase_StrategoHostSort)node);
+    if(node instanceof Overlay_StrategoHostSort)
+      return visit((Overlay_StrategoHostSort)node);
+    if(node instanceof RuleDef_StrategoHostSort)
+      return visit((RuleDef_StrategoHostSort)node);
+    if(node instanceof Rule_StrategoHostSort)
+      return visit((Rule_StrategoHostSort)node);
+    if(node instanceof Decl_StrategoHostSort)
+      return visit((Decl_StrategoHostSort)node);
+    if(node instanceof Def_StrategoHostSort)
+      return visit((Def_StrategoHostSort)node);
+    if(node instanceof ScopeLabels_StrategoHostSort)
+      return visit((ScopeLabels_StrategoHostSort)node);
+    if(node instanceof DynRuleDef_StrategoHostSort)
+      return visit((DynRuleDef_StrategoHostSort)node);
+    if(node instanceof DynRuleId_StrategoHostSort)
+      return visit((DynRuleId_StrategoHostSort)node);
+    if(node instanceof DynRuleScopeId_StrategoHostSort)
+      return visit((DynRuleScopeId_StrategoHostSort)node);
+    if(node instanceof RuleDec_StrategoHostSort)
+      return visit((RuleDec_StrategoHostSort)node);
+    if(node instanceof RuleNames_StrategoHostSort)
+      return visit((RuleNames_StrategoHostSort)node);
+    if(node instanceof Strategy_StrategoHostSort)
+      return visit((Strategy_StrategoHostSort)node);
+    if(node instanceof LineTerminatorSort)
+      return visit((LineTerminatorSort)node);
+    if(node instanceof CarriageReturnSort)
+      return visit((CarriageReturnSort)node);
+    if(node instanceof EndOfFileSort)
+      return visit((EndOfFileSort)node);
+    if(node instanceof CommentSort)
+      return visit((CommentSort)node);
+    if(node instanceof EOLCommentCharsSort)
+      return visit((EOLCommentCharsSort)node);
+    if(node instanceof CommentPartSort)
+      return visit((CommentPartSort)node);
+    if(node instanceof BlockCommentCharsSort)
+      return visit((BlockCommentCharsSort)node);
+    if(node instanceof EscEscCharSort)
+      return visit((EscEscCharSort)node);
+    if(node instanceof EscCharSort)
+      return visit((EscCharSort)node);
+    if(node instanceof UnicodeEscapeSort)
+      return visit((UnicodeEscapeSort)node);
+    if(node instanceof Keyword_JavaObjectSort)
+      return visit((Keyword_JavaObjectSort)node);
+    if(node instanceof Public_JavaObjectSort)
+      return visit((Public_JavaObjectSort)node);
+    if(node instanceof Private_JavaObjectSort)
+      return visit((Private_JavaObjectSort)node);
+    if(node instanceof Protected_JavaObjectSort)
+      return visit((Protected_JavaObjectSort)node);
+    if(node instanceof Abstract_JavaObjectSort)
+      return visit((Abstract_JavaObjectSort)node);
+    if(node instanceof Final_JavaObjectSort)
+      return visit((Final_JavaObjectSort)node);
+    if(node instanceof Static_JavaObjectSort)
+      return visit((Static_JavaObjectSort)node);
+    if(node instanceof Native_JavaObjectSort)
+      return visit((Native_JavaObjectSort)node);
+    if(node instanceof Transient_JavaObjectSort)
+      return visit((Transient_JavaObjectSort)node);
+    if(node instanceof Volatile_JavaObjectSort)
+      return visit((Volatile_JavaObjectSort)node);
+    if(node instanceof Synchronized_JavaObjectSort)
+      return visit((Synchronized_JavaObjectSort)node);
+    if(node instanceof StrictFP_JavaObjectSort)
+      return visit((StrictFP_JavaObjectSort)node);
+    if(node instanceof Modifier_JavaObjectSort)
+      return visit((Modifier_JavaObjectSort)node);
+    if(node instanceof DeciNumeral_JavaObjectSort)
+      return visit((DeciNumeral_JavaObjectSort)node);
+    if(node instanceof HexaNumeral_JavaObjectSort)
+      return visit((HexaNumeral_JavaObjectSort)node);
+    if(node instanceof OctaNumeral_JavaObjectSort)
+      return visit((OctaNumeral_JavaObjectSort)node);
+    if(node instanceof IntLiteral_JavaObjectSort)
+      return visit((IntLiteral_JavaObjectSort)node);
+    if(node instanceof DeciFloatLiteral_JavaObjectSort)
+      return visit((DeciFloatLiteral_JavaObjectSort)node);
+    if(node instanceof HexaFloatLiteral_JavaObjectSort)
+      return visit((HexaFloatLiteral_JavaObjectSort)node);
+    if(node instanceof DeciFloatNumeral_JavaObjectSort)
+      return visit((DeciFloatNumeral_JavaObjectSort)node);
+    if(node instanceof DeciFloatDigits_JavaObjectSort)
+      return visit((DeciFloatDigits_JavaObjectSort)node);
+    if(node instanceof DeciFloatExponentPart_JavaObjectSort)
+      return visit((DeciFloatExponentPart_JavaObjectSort)node);
+    if(node instanceof SignedInteger_JavaObjectSort)
+      return visit((SignedInteger_JavaObjectSort)node);
+    if(node instanceof HexaFloatNumeral_JavaObjectSort)
+      return visit((HexaFloatNumeral_JavaObjectSort)node);
+    if(node instanceof HexaSignificand_JavaObjectSort)
+      return visit((HexaSignificand_JavaObjectSort)node);
+    if(node instanceof BinaryExponent_JavaObjectSort)
+      return visit((BinaryExponent_JavaObjectSort)node);
+    if(node instanceof BoolLiteral_JavaObjectSort)
+      return visit((BoolLiteral_JavaObjectSort)node);
+    if(node instanceof Bool_JavaObjectSort)
+      return visit((Bool_JavaObjectSort)node);
+    if(node instanceof EscapeSeq_JavaObjectSort)
+      return visit((EscapeSeq_JavaObjectSort)node);
+    if(node instanceof NamedEscape_JavaObjectSort)
+      return visit((NamedEscape_JavaObjectSort)node);
+    if(node instanceof OctaEscape_JavaObjectSort)
+      return visit((OctaEscape_JavaObjectSort)node);
+    if(node instanceof LastOcta_JavaObjectSort)
+      return visit((LastOcta_JavaObjectSort)node);
+    if(node instanceof CharContent_JavaObjectSort)
+      return visit((CharContent_JavaObjectSort)node);
+    if(node instanceof StringPart_JavaObjectSort)
+      return visit((StringPart_JavaObjectSort)node);
+    if(node instanceof NullLiteral_JavaObjectSort)
+      return visit((NullLiteral_JavaObjectSort)node);
+    if(node instanceof NumType_JavaObjectSort)
+      return visit((NumType_JavaObjectSort)node);
+    if(node instanceof IntType_JavaObjectSort)
+      return visit((IntType_JavaObjectSort)node);
+    if(node instanceof FloatType_JavaObjectSort)
+      return visit((FloatType_JavaObjectSort)node);
+    if(node instanceof TypeArgs_JavaObjectSort)
+      return visit((TypeArgs_JavaObjectSort)node);
+    if(node instanceof ActualTypeArg_JavaObjectSort)
+      return visit((ActualTypeArg_JavaObjectSort)node);
+    if(node instanceof WildcardBound_JavaObjectSort)
+      return visit((WildcardBound_JavaObjectSort)node);
+    if(node instanceof TypeBound_JavaObjectSort)
+      return visit((TypeBound_JavaObjectSort)node);
+    if(node instanceof TypeParams_JavaObjectSort)
+      return visit((TypeParams_JavaObjectSort)node);
+    if(node instanceof TypeVarId_JavaObjectSort)
+      return visit((TypeVarId_JavaObjectSort)node);
+    if(node instanceof ClassOrInterfaceType_JavaObjectSort)
+      return visit((ClassOrInterfaceType_JavaObjectSort)node);
+    if(node instanceof ClassType_JavaObjectSort)
+      return visit((ClassType_JavaObjectSort)node);
+    if(node instanceof InterfaceType_JavaObjectSort)
+      return visit((InterfaceType_JavaObjectSort)node);
+    if(node instanceof TypeDecSpec_JavaObjectSort)
+      return visit((TypeDecSpec_JavaObjectSort)node);
+    if(node instanceof TypeVar_JavaObjectSort)
+      return visit((TypeVar_JavaObjectSort)node);
+    if(node instanceof ArrayType_JavaObjectSort)
+      return visit((ArrayType_JavaObjectSort)node);
+    if(node instanceof Literal_JavaObjectSort)
+      return visit((Literal_JavaObjectSort)node);
+    if(node instanceof ClassLiteral_JavaObjectSort)
+      return visit((ClassLiteral_JavaObjectSort)node);
+    if(node instanceof ExprSort)
+      return visit((ExprSort)node);
+    if(node instanceof ArrayInit_JavaObjectSort)
+      return visit((ArrayInit_JavaObjectSort)node);
+    if(node instanceof FieldDec_JavaObjectSort)
+      return visit((FieldDec_JavaObjectSort)node);
+    if(node instanceof VarDecId_JavaObjectSort)
+      return visit((VarDecId_JavaObjectSort)node);
+    if(node instanceof Dim_JavaObjectSort)
+      return visit((Dim_JavaObjectSort)node);
+    if(node instanceof VarInit_JavaObjectSort)
+      return visit((VarInit_JavaObjectSort)node);
+    if(node instanceof LocalVarDecStm_JavaObjectSort)
+      return visit((LocalVarDecStm_JavaObjectSort)node);
+    if(node instanceof SwitchBlock_JavaObjectSort)
+      return visit((SwitchBlock_JavaObjectSort)node);
+    if(node instanceof SwitchLabel_JavaObjectSort)
+      return visit((SwitchLabel_JavaObjectSort)node);
+    if(node instanceof CatchClause_JavaObjectSort)
+      return visit((CatchClause_JavaObjectSort)node);
+    if(node instanceof Block_JavaObjectSort)
+      return visit((Block_JavaObjectSort)node);
+    if(node instanceof MethodDec_JavaObjectSort)
+      return visit((MethodDec_JavaObjectSort)node);
+    if(node instanceof MethodDecHead_JavaObjectSort)
+      return visit((MethodDecHead_JavaObjectSort)node);
+    if(node instanceof ResultType_JavaObjectSort)
+      return visit((ResultType_JavaObjectSort)node);
+    if(node instanceof Throws_JavaObjectSort)
+      return visit((Throws_JavaObjectSort)node);
+    if(node instanceof ExceptionType_JavaObjectSort)
+      return visit((ExceptionType_JavaObjectSort)node);
+    if(node instanceof MethodBody_JavaObjectSort)
+      return visit((MethodBody_JavaObjectSort)node);
+    if(node instanceof InstanceInit_JavaObjectSort)
+      return visit((InstanceInit_JavaObjectSort)node);
+    if(node instanceof StaticInit_JavaObjectSort)
+      return visit((StaticInit_JavaObjectSort)node);
+    if(node instanceof ConstrDec_JavaObjectSort)
+      return visit((ConstrDec_JavaObjectSort)node);
+    if(node instanceof ConstrHead_JavaObjectSort)
+      return visit((ConstrHead_JavaObjectSort)node);
+    if(node instanceof ConstrBody_JavaObjectSort)
+      return visit((ConstrBody_JavaObjectSort)node);
+    if(node instanceof ConstrInv_JavaObjectSort)
+      return visit((ConstrInv_JavaObjectSort)node);
+    if(node instanceof EnumDec_JavaObjectSort)
+      return visit((EnumDec_JavaObjectSort)node);
+    if(node instanceof EnumDecHead_JavaObjectSort)
+      return visit((EnumDecHead_JavaObjectSort)node);
+    if(node instanceof EnumBody_JavaObjectSort)
+      return visit((EnumBody_JavaObjectSort)node);
+    if(node instanceof EnumConst_JavaObjectSort)
+      return visit((EnumConst_JavaObjectSort)node);
+    if(node instanceof EnumConstArgsSort)
+      return visit((EnumConstArgsSort)node);
+    if(node instanceof EnumBodyDecs_JavaObjectSort)
+      return visit((EnumBodyDecs_JavaObjectSort)node);
+    if(node instanceof ConstantDec_JavaObjectSort)
+      return visit((ConstantDec_JavaObjectSort)node);
+    if(node instanceof ConstantMod_JavaObjectSort)
+      return visit((ConstantMod_JavaObjectSort)node);
+    if(node instanceof AbstractMethodDec_JavaObjectSort)
+      return visit((AbstractMethodDec_JavaObjectSort)node);
+    if(node instanceof AbstractMethodMod_JavaObjectSort)
+      return visit((AbstractMethodMod_JavaObjectSort)node);
+    if(node instanceof AnnoDec_JavaObjectSort)
+      return visit((AnnoDec_JavaObjectSort)node);
+    if(node instanceof AnnoDecHead_JavaObjectSort)
+      return visit((AnnoDecHead_JavaObjectSort)node);
+    if(node instanceof AnnoElemDec_JavaObjectSort)
+      return visit((AnnoElemDec_JavaObjectSort)node);
+    if(node instanceof DefaultVal_JavaObjectSort)
+      return visit((DefaultVal_JavaObjectSort)node);
+    if(node instanceof InterfaceDec_JavaObjectSort)
+      return visit((InterfaceDec_JavaObjectSort)node);
+    if(node instanceof InterfaceDecHead_JavaObjectSort)
+      return visit((InterfaceDecHead_JavaObjectSort)node);
+    if(node instanceof ExtendsInterfaces_JavaObjectSort)
+      return visit((ExtendsInterfaces_JavaObjectSort)node);
+    if(node instanceof InterfaceMod_JavaObjectSort)
+      return visit((InterfaceMod_JavaObjectSort)node);
+    if(node instanceof ClassDec_JavaObjectSort)
+      return visit((ClassDec_JavaObjectSort)node);
+    if(node instanceof ClassBody_JavaObjectSort)
+      return visit((ClassBody_JavaObjectSort)node);
+    if(node instanceof ClassDecHead_JavaObjectSort)
+      return visit((ClassDecHead_JavaObjectSort)node);
+    if(node instanceof Super_JavaObjectSort)
+      return visit((Super_JavaObjectSort)node);
+    if(node instanceof Interfaces_JavaObjectSort)
+      return visit((Interfaces_JavaObjectSort)node);
+    if(node instanceof ClassMemberDec_JavaObjectSort)
+      return visit((ClassMemberDec_JavaObjectSort)node);
+    if(node instanceof ArrayCreationExpr_JavaObjectSort)
+      return visit((ArrayCreationExpr_JavaObjectSort)node);
+    if(node instanceof ArrayBaseType_JavaObjectSort)
+      return visit((ArrayBaseType_JavaObjectSort)node);
+    if(node instanceof DimExpr_JavaObjectSort)
+      return visit((DimExpr_JavaObjectSort)node);
+    if(node instanceof FieldAccess_JavaObjectSort)
+      return visit((FieldAccess_JavaObjectSort)node);
+    if(node instanceof ArrayAccess_JavaObjectSort)
+      return visit((ArrayAccess_JavaObjectSort)node);
+    if(node instanceof ArraySubscriptSort)
+      return visit((ArraySubscriptSort)node);
+    if(node instanceof MethodSpec_JavaObjectSort)
+      return visit((MethodSpec_JavaObjectSort)node);
+    if(node instanceof CondMidSort)
+      return visit((CondMidSort)node);
+    if(node instanceof Anno_JavaObjectSort)
+      return visit((Anno_JavaObjectSort)node);
+    if(node instanceof ElemValPair_JavaObjectSort)
+      return visit((ElemValPair_JavaObjectSort)node);
+    if(node instanceof ElemVal_JavaObjectSort)
+      return visit((ElemVal_JavaObjectSort)node);
+    if(node instanceof CompilationUnit_JavaObjectSort)
+      return visit((CompilationUnit_JavaObjectSort)node);
+    if(node instanceof SwitchGroup_JavaObjectSort)
+      return visit((SwitchGroup_JavaObjectSort)node);
+    if(node instanceof Stm_JavaObjectSort)
+      return visit((Stm_JavaObjectSort)node);
+    if(node instanceof BlockStm_JavaObjectSort)
+      return visit((BlockStm_JavaObjectSort)node);
+    if(node instanceof LocalVarDec_JavaObjectSort)
+      return visit((LocalVarDec_JavaObjectSort)node);
+    if(node instanceof VarDec_JavaObjectSort)
+      return visit((VarDec_JavaObjectSort)node);
+    if(node instanceof LHS_JavaObjectSort)
+      return visit((LHS_JavaObjectSort)node);
+    if(node instanceof PrimType_JavaObjectSort)
+      return visit((PrimType_JavaObjectSort)node);
+    if(node instanceof RefType_JavaObjectSort)
+      return visit((RefType_JavaObjectSort)node);
+    if(node instanceof MetaTypeVar_JavaObjectSort)
+      return visit((MetaTypeVar_JavaObjectSort)node);
+    if(node instanceof MetaPrimTypeVar_JavaObjectSort)
+      return visit((MetaPrimTypeVar_JavaObjectSort)node);
+    if(node instanceof MetaRefTypeVar_JavaObjectSort)
+      return visit((MetaRefTypeVar_JavaObjectSort)node);
+    if(node instanceof Type_JavaObjectSort)
+      return visit((Type_JavaObjectSort)node);
+    if(node instanceof PackageDec_JavaObjectSort)
+      return visit((PackageDec_JavaObjectSort)node);
+    if(node instanceof OptPackageDec_JavaObject0Sort)
+      return visit((OptPackageDec_JavaObject0Sort)node);
+    if(node instanceof ImportDec_JavaObjectSort)
+      return visit((ImportDec_JavaObjectSort)node);
+    if(node instanceof Term_StrategoHostSort)
+      return visit((Term_StrategoHostSort)node);
+    if(node instanceof Name_JavaObjectSort)
+      return visit((Name_JavaObjectSort)node);
+    if(node instanceof Id_JavaObjectSort)
+      return visit((Id_JavaObjectSort)node);
+    if(node instanceof ID_JavaObjectSort)
+      return visit((ID_JavaObjectSort)node);
+    if(node instanceof TypeParam_JavaObjectSort)
+      return visit((TypeParam_JavaObjectSort)node);
+    if(node instanceof Expr_JavaObjectSort)
+      return visit((Expr_JavaObjectSort)node);
+    if(node instanceof TypeDec_JavaObjectSort)
+      return visit((TypeDec_JavaObjectSort)node);
+    if(node instanceof ClassBodyDec_JavaObjectSort)
+      return visit((ClassBodyDec_JavaObjectSort)node);
+    if(node instanceof InterfaceMemberDec_JavaObjectSort)
+      return visit((InterfaceMemberDec_JavaObjectSort)node);
+    if(node instanceof DeciLiteral_JavaObjectSort)
+      return visit((DeciLiteral_JavaObjectSort)node);
+    if(node instanceof HexaLiteral_JavaObjectSort)
+      return visit((HexaLiteral_JavaObjectSort)node);
+    if(node instanceof OctaLiteral_JavaObjectSort)
+      return visit((OctaLiteral_JavaObjectSort)node);
+    if(node instanceof FloatLiteral_JavaObjectSort)
+      return visit((FloatLiteral_JavaObjectSort)node);
+    if(node instanceof StringLiteral_JavaObjectSort)
+      return visit((StringLiteral_JavaObjectSort)node);
+    if(node instanceof CharLiteral_JavaObjectSort)
+      return visit((CharLiteral_JavaObjectSort)node);
+    if(node instanceof AmbName_JavaObjectSort)
+      return visit((AmbName_JavaObjectSort)node);
+    if(node instanceof ExprName_JavaObjectSort)
+      return visit((ExprName_JavaObjectSort)node);
+    if(node instanceof MethodName_JavaObjectSort)
+      return visit((MethodName_JavaObjectSort)node);
+    if(node instanceof TypeName_JavaObjectSort)
+      return visit((TypeName_JavaObjectSort)node);
+    if(node instanceof PackageOrTypeName_JavaObjectSort)
+      return visit((PackageOrTypeName_JavaObjectSort)node);
+    if(node instanceof PackageName_JavaObjectSort)
+      return visit((PackageName_JavaObjectSort)node);
+    if(node instanceof MethodMod_JavaObjectSort)
+      return visit((MethodMod_JavaObjectSort)node);
+    if(node instanceof ClassMod_JavaObjectSort)
+      return visit((ClassMod_JavaObjectSort)node);
+    if(node instanceof ConstrMod_JavaObjectSort)
+      return visit((ConstrMod_JavaObjectSort)node);
+    if(node instanceof VarMod_JavaObjectSort)
+      return visit((VarMod_JavaObjectSort)node);
+    if(node instanceof FieldMod_JavaObjectSort)
+      return visit((FieldMod_JavaObjectSort)node);
+    if(node instanceof FormalParam_JavaObjectSort)
+      return visit((FormalParam_JavaObjectSort)node);
+    if(node instanceof StringChars_JavaObjectSort)
+      return visit((StringChars_JavaObjectSort)node);
+    if(node instanceof SingleChar_JavaObjectSort)
+      return visit((SingleChar_JavaObjectSort)node);
+    if(node instanceof ListPlusOfCommChar0Sort)
+      return visit((ListPlusOfCommChar0Sort)node);
+    if(node instanceof ListStarOfCommChar0Sort)
+      return visit((ListStarOfCommChar0Sort)node);
+    if(node instanceof ListPlusOfModNamePart_StrategoHost0Sort)
+      return visit((ListPlusOfModNamePart_StrategoHost0Sort)node);
+    if(node instanceof ListStarOfModNamePart_StrategoHost0Sort)
+      return visit((ListStarOfModNamePart_StrategoHost0Sort)node);
+    if(node instanceof ListPlusOfStrChar_StrategoHost0Sort)
+      return visit((ListPlusOfStrChar_StrategoHost0Sort)node);
+    if(node instanceof ListStarOfStrChar_StrategoHost0Sort)
+      return visit((ListStarOfStrChar_StrategoHost0Sort)node);
+    if(node instanceof ListStarOfSort_StrategoHost1Sort)
+      return visit((ListStarOfSort_StrategoHost1Sort)node);
+    if(node instanceof ListStarOfOpdecl_StrategoHost0Sort)
+      return visit((ListStarOfOpdecl_StrategoHost0Sort)node);
+    if(node instanceof ListStarOfArgType_StrategoHost0Sort)
+      return visit((ListStarOfArgType_StrategoHost0Sort)node);
+    if(node instanceof ListStarOfID_StrategoHost0Sort)
+      return visit((ListStarOfID_StrategoHost0Sort)node);
+    if(node instanceof ListStarOfDecl_StrategoHost0Sort)
+      return visit((ListStarOfDecl_StrategoHost0Sort)node);
+    if(node instanceof ListStarOfImportModName_StrategoHost0Sort)
+      return visit((ListStarOfImportModName_StrategoHost0Sort)node);
+    if(node instanceof ListStarOfSdecl_StrategoHost0Sort)
+      return visit((ListStarOfSdecl_StrategoHost0Sort)node);
+    if(node instanceof ListStarOfSort_StrategoHost0Sort)
+      return visit((ListStarOfSort_StrategoHost0Sort)node);
+    if(node instanceof ListStarOfStrategy_StrategoHost0Sort)
+      return visit((ListStarOfStrategy_StrategoHost0Sort)node);
+    if(node instanceof ListStarOfSwitchCase_StrategoHost0Sort)
+      return visit((ListStarOfSwitchCase_StrategoHost0Sort)node);
+    if(node instanceof ListStarOfDef_StrategoHost0Sort)
+      return visit((ListStarOfDef_StrategoHost0Sort)node);
+    if(node instanceof ListStarOfOverlay_StrategoHost0Sort)
+      return visit((ListStarOfOverlay_StrategoHost0Sort)node);
+    if(node instanceof ListStarOfDynRuleScopeId_StrategoHost0Sort)
+      return visit((ListStarOfDynRuleScopeId_StrategoHost0Sort)node);
+    if(node instanceof ListStarOfDynRuleDef_StrategoHost0Sort)
+      return visit((ListStarOfDynRuleDef_StrategoHost0Sort)node);
+    if(node instanceof ListStarOfTypedid_StrategoHost0Sort)
+      return visit((ListStarOfTypedid_StrategoHost0Sort)node);
+    if(node instanceof ListStarOfId_StrategoHost0Sort)
+      return visit((ListStarOfId_StrategoHost0Sort)node);
+    if(node instanceof ListStarOfCharClass1Sort)
+      return visit((ListStarOfCharClass1Sort)node);
+    if(node instanceof ListPlusOfCommentPart0Sort)
+      return visit((ListPlusOfCommentPart0Sort)node);
+    if(node instanceof ListStarOfCommentPart0Sort)
+      return visit((ListStarOfCommentPart0Sort)node);
+    if(node instanceof OptDeciFloatExponentPart_JavaObject0Sort)
+      return visit((OptDeciFloatExponentPart_JavaObject0Sort)node);
+    if(node instanceof ListStarOfStringPart_JavaObject0Sort)
+      return visit((ListStarOfStringPart_JavaObject0Sort)node);
+    if(node instanceof ListStarOfCharClass0Sort)
+      return visit((ListStarOfCharClass0Sort)node);
+    if(node instanceof ListStarOfId_JavaObject0Sort)
+      return visit((ListStarOfId_JavaObject0Sort)node);
+    if(node instanceof ListStarOfActualTypeArg_JavaObject0Sort)
+      return visit((ListStarOfActualTypeArg_JavaObject0Sort)node);
+    if(node instanceof ListStarOfClassOrInterfaceType_JavaObject0Sort)
+      return visit((ListStarOfClassOrInterfaceType_JavaObject0Sort)node);
+    if(node instanceof ListStarOfSwitchLabel_JavaObject0Sort)
+      return visit((ListStarOfSwitchLabel_JavaObject0Sort)node);
+    if(node instanceof ListStarOfBlockStm_JavaObject0Sort)
+      return visit((ListStarOfBlockStm_JavaObject0Sort)node);
+    if(node instanceof ListStarOfCatchClause_JavaObject0Sort)
+      return visit((ListStarOfCatchClause_JavaObject0Sort)node);
+    if(node instanceof ListStarOfExceptionType_JavaObject0Sort)
+      return visit((ListStarOfExceptionType_JavaObject0Sort)node);
+    if(node instanceof ListStarOfEnumConst_JavaObject0Sort)
+      return visit((ListStarOfEnumConst_JavaObject0Sort)node);
+    if(node instanceof ListStarOfAnno_JavaObject_ConstantMod_JavaObject0Sort)
+      return visit((ListStarOfAnno_JavaObject_ConstantMod_JavaObject0Sort)node);
+    if(node instanceof Anno_JavaObject_ConstantMod_JavaObject0Sort)
+      return visit((Anno_JavaObject_ConstantMod_JavaObject0Sort)node);
+    if(node instanceof ListStarOfAnno_JavaObject_AbstractMethodMod_JavaObject0Sort)
+      return visit((ListStarOfAnno_JavaObject_AbstractMethodMod_JavaObject0Sort)node);
+    if(node instanceof Anno_JavaObject_AbstractMethodMod_JavaObject0Sort)
+      return visit((Anno_JavaObject_AbstractMethodMod_JavaObject0Sort)node);
+    if(node instanceof ListStarOfAnnoElemDec_JavaObject0Sort)
+      return visit((ListStarOfAnnoElemDec_JavaObject0Sort)node);
+    if(node instanceof ListStarOfAbstractMethodMod_JavaObject0Sort)
+      return visit((ListStarOfAbstractMethodMod_JavaObject0Sort)node);
+    if(node instanceof ListStarOfAnno_JavaObject_InterfaceMod_JavaObject0Sort)
+      return visit((ListStarOfAnno_JavaObject_InterfaceMod_JavaObject0Sort)node);
+    if(node instanceof Anno_JavaObject_InterfaceMod_JavaObject0Sort)
+      return visit((Anno_JavaObject_InterfaceMod_JavaObject0Sort)node);
+    if(node instanceof ListStarOfInterfaceType_JavaObject0Sort)
+      return visit((ListStarOfInterfaceType_JavaObject0Sort)node);
+    if(node instanceof ListStarOfDimExpr_JavaObject0Sort)
+      return visit((ListStarOfDimExpr_JavaObject0Sort)node);
+    if(node instanceof ListStarOfDim_JavaObject0Sort)
+      return visit((ListStarOfDim_JavaObject0Sort)node);
+    if(node instanceof OptTypeArgs_JavaObject0Sort)
+      return visit((OptTypeArgs_JavaObject0Sort)node);
+    if(node instanceof ListStarOfElemValPair_JavaObject0Sort)
+      return visit((ListStarOfElemValPair_JavaObject0Sort)node);
+    if(node instanceof ListStarOfElemVal_JavaObject0Sort)
+      return visit((ListStarOfElemVal_JavaObject0Sort)node);
+    if(node instanceof ListStarOfAnno_JavaObject0Sort)
+      return visit((ListStarOfAnno_JavaObject0Sort)node);
+    if(node instanceof ListStarOfTypeDec_JavaObject0Sort)
+      return visit((ListStarOfTypeDec_JavaObject0Sort)node);
+    if(node instanceof ListStarOfVarInit_JavaObject0Sort)
+      return visit((ListStarOfVarInit_JavaObject0Sort)node);
+    if(node instanceof ListStarOfExpr_JavaObject0Sort)
+      return visit((ListStarOfExpr_JavaObject0Sort)node);
+    if(node instanceof ListStarOfSwitchGroup_JavaObject0Sort)
+      return visit((ListStarOfSwitchGroup_JavaObject0Sort)node);
+    if(node instanceof ListStarOfVarDec_JavaObject0Sort)
+      return visit((ListStarOfVarDec_JavaObject0Sort)node);
+    if(node instanceof ListStarOfImportDec_JavaObject0Sort)
+      return visit((ListStarOfImportDec_JavaObject0Sort)node);
+    if(node instanceof ListStarOfAbstractMethodDec_JavaObject0Sort)
+      return visit((ListStarOfAbstractMethodDec_JavaObject0Sort)node);
+    if(node instanceof ListStarOfTypeParam_JavaObject0Sort)
+      return visit((ListStarOfTypeParam_JavaObject0Sort)node);
+    if(node instanceof ListStarOfClassBodyDec_JavaObject0Sort)
+      return visit((ListStarOfClassBodyDec_JavaObject0Sort)node);
+    if(node instanceof ListStarOfInterfaceMemberDec_JavaObject0Sort)
+      return visit((ListStarOfInterfaceMemberDec_JavaObject0Sort)node);
+    if(node instanceof ListStarOfAnno_JavaObject_MethodMod_JavaObject0Sort)
+      return visit((ListStarOfAnno_JavaObject_MethodMod_JavaObject0Sort)node);
+    if(node instanceof Anno_JavaObject_MethodMod_JavaObject0Sort)
+      return visit((Anno_JavaObject_MethodMod_JavaObject0Sort)node);
+    if(node instanceof ListStarOfAnno_JavaObject_ClassMod_JavaObject0Sort)
+      return visit((ListStarOfAnno_JavaObject_ClassMod_JavaObject0Sort)node);
+    if(node instanceof Anno_JavaObject_ClassMod_JavaObject0Sort)
+      return visit((Anno_JavaObject_ClassMod_JavaObject0Sort)node);
+    if(node instanceof ListStarOfAnno_JavaObject_ConstrMod_JavaObject0Sort)
+      return visit((ListStarOfAnno_JavaObject_ConstrMod_JavaObject0Sort)node);
+    if(node instanceof Anno_JavaObject_ConstrMod_JavaObject0Sort)
+      return visit((Anno_JavaObject_ConstrMod_JavaObject0Sort)node);
+    if(node instanceof ListStarOfAnno_JavaObject_VarMod_JavaObject0Sort)
+      return visit((ListStarOfAnno_JavaObject_VarMod_JavaObject0Sort)node);
+    if(node instanceof Anno_JavaObject_VarMod_JavaObject0Sort)
+      return visit((Anno_JavaObject_VarMod_JavaObject0Sort)node);
+    if(node instanceof ListStarOfAnno_JavaObject_FieldMod_JavaObject0Sort)
+      return visit((ListStarOfAnno_JavaObject_FieldMod_JavaObject0Sort)node);
+    if(node instanceof Anno_JavaObject_FieldMod_JavaObject0Sort)
+      return visit((Anno_JavaObject_FieldMod_JavaObject0Sort)node);
+    if(node instanceof ListStarOfFormalParam_JavaObject0Sort)
+      return visit((ListStarOfFormalParam_JavaObject0Sort)node);
+    if(node instanceof ListStarOfTerm_StrategoHost0Sort)
+      return visit((ListStarOfTerm_StrategoHost0Sort)node);
+    if(node instanceof ASTString)
+      return visit((ASTString)node);
+    if(node instanceof List)
+      return visit((List)node);
+    throw new java.lang.IllegalArgumentException("Node of type " + node.getClass().getSimpleName() + "not expected.");
+  }
+
+  public void endVisit(ASTNode node)
+  { 
+    if(node instanceof Ws)
+    { 
+      endVisit((Ws)node);
+      return;
+    }
+    if(node instanceof ShortCom)
+    { 
+      endVisit((ShortCom)node);
+      return;
+    }
+    if(node instanceof LongCom)
+    { 
+      endVisit((LongCom)node);
+      return;
+    }
+    if(node instanceof Eof)
+    { 
+      endVisit((Eof)node);
+      return;
+    }
+    if(node instanceof CommChar)
+    { 
+      endVisit((CommChar)node);
+      return;
+    }
+    if(node instanceof Asterisk)
+    { 
+      endVisit((Asterisk)node);
+      return;
+    }
+    if(node instanceof ModName_StrategoHost)
+    { 
+      endVisit((ModName_StrategoHost)node);
+      return;
+    }
+    if(node instanceof ModNamePart_StrategoHost)
+    { 
+      endVisit((ModNamePart_StrategoHost)node);
+      return;
+    }
+    if(node instanceof Id_StrategoHost)
+    { 
+      endVisit((Id_StrategoHost)node);
+      return;
+    }
+    if(node instanceof LId_StrategoHost)
+    { 
+      endVisit((LId_StrategoHost)node);
+      return;
+    }
+    if(node instanceof LCID_StrategoHost)
+    { 
+      endVisit((LCID_StrategoHost)node);
+      return;
+    }
+    if(node instanceof UCID_StrategoHost)
+    { 
+      endVisit((UCID_StrategoHost)node);
+      return;
+    }
+    if(node instanceof Keyword_StrategoHost)
+    { 
+      endVisit((Keyword_StrategoHost)node);
+      return;
+    }
+    if(node instanceof Int_StrategoHost)
+    { 
+      endVisit((Int_StrategoHost)node);
+      return;
+    }
+    if(node instanceof Real_StrategoHost)
+    { 
+      endVisit((Real_StrategoHost)node);
+      return;
+    }
+    if(node instanceof String_StrategoHost)
+    { 
+      endVisit((String_StrategoHost)node);
+      return;
+    }
+    if(node instanceof StrChar_StrategoHost)
+    { 
+      endVisit((StrChar_StrategoHost)node);
+      return;
+    }
+    if(node instanceof Char_StrategoHost)
+    { 
+      endVisit((Char_StrategoHost)node);
+      return;
+    }
+    if(node instanceof CharChar_StrategoHost)
+    { 
+      endVisit((CharChar_StrategoHost)node);
+      return;
+    }
+    if(node instanceof Var0)
+    { 
+      endVisit((Var0)node);
+      return;
+    }
+    if(node instanceof ID_StrategoHost0)
+    { 
+      endVisit((ID_StrategoHost0)node);
+      return;
+    }
+    if(node instanceof PreTerm_StrategoHost)
+    { 
+      endVisit((PreTerm_StrategoHost)node);
+      return;
+    }
+    if(node instanceof Term_StrategoHost)
+    { 
+      endVisit((Term_StrategoHost)node);
+      return;
+    }
+    if(node instanceof Wld0)
+    { 
+      endVisit((Wld0)node);
+      return;
+    }
+    if(node instanceof Wld)
+    { 
+      endVisit((Wld)node);
+      return;
+    }
+    if(node instanceof Int0)
+    { 
+      endVisit((Int0)node);
+      return;
+    }
+    if(node instanceof Real)
+    { 
+      endVisit((Real)node);
+      return;
+    }
+    if(node instanceof Str)
+    { 
+      endVisit((Str)node);
+      return;
+    }
+    if(node instanceof Op)
+    { 
+      endVisit((Op)node);
+      return;
+    }
+    if(node instanceof OpQ)
+    { 
+      endVisit((OpQ)node);
+      return;
+    }
+    if(node instanceof Explode)
+    { 
+      endVisit((Explode)node);
+      return;
+    }
+    if(node instanceof Anno0)
+    { 
+      endVisit((Anno0)node);
+      return;
+    }
+    if(node instanceof As0)
+    { 
+      endVisit((As0)node);
+      return;
+    }
+    if(node instanceof As)
+    { 
+      endVisit((As)node);
+      return;
+    }
+    if(node instanceof Sorts)
+    { 
+      endVisit((Sorts)node);
+      return;
+    }
+    if(node instanceof Constructors)
+    { 
+      endVisit((Constructors)node);
+      return;
+    }
+    if(node instanceof SortVar)
+    { 
+      endVisit((SortVar)node);
+      return;
+    }
+    if(node instanceof SortNoArgs)
+    { 
+      endVisit((SortNoArgs)node);
+      return;
+    }
+    if(node instanceof Sort)
+    { 
+      endVisit((Sort)node);
+      return;
+    }
+    if(node instanceof OpDecl)
+    { 
+      endVisit((OpDecl)node);
+      return;
+    }
+    if(node instanceof OpDeclQ)
+    { 
+      endVisit((OpDeclQ)node);
+      return;
+    }
+    if(node instanceof OpDeclInj)
+    { 
+      endVisit((OpDeclInj)node);
+      return;
+    }
+    if(node instanceof ConstType)
+    { 
+      endVisit((ConstType)node);
+      return;
+    }
+    if(node instanceof FunType)
+    { 
+      endVisit((FunType)node);
+      return;
+    }
+    if(node instanceof ArgType)
+    { 
+      endVisit((ArgType)node);
+      return;
+    }
+    if(node instanceof ArgType_StrategoHost)
+    { 
+      endVisit((ArgType_StrategoHost)node);
+      return;
+    }
+    if(node instanceof RetType_StrategoHost)
+    { 
+      endVisit((RetType_StrategoHost)node);
+      return;
+    }
+    if(node instanceof Type_StrategoHost0)
+    { 
+      endVisit((Type_StrategoHost0)node);
+      return;
+    }
+    if(node instanceof Type_StrategoHost)
+    { 
+      endVisit((Type_StrategoHost)node);
+      return;
+    }
+    if(node instanceof Def_StrategoHost0)
+    { 
+      endVisit((Def_StrategoHost0)node);
+      return;
+    }
+    if(node instanceof SVar)
+    { 
+      endVisit((SVar)node);
+      return;
+    }
+    if(node instanceof Let)
+    { 
+      endVisit((Let)node);
+      return;
+    }
+    if(node instanceof CallT)
+    { 
+      endVisit((CallT)node);
+      return;
+    }
+    if(node instanceof CallDynamic)
+    { 
+      endVisit((CallDynamic)node);
+      return;
+    }
+    if(node instanceof SDefT)
+    { 
+      endVisit((SDefT)node);
+      return;
+    }
+    if(node instanceof ExtSDefInl)
+    { 
+      endVisit((ExtSDefInl)node);
+      return;
+    }
+    if(node instanceof ExtSDef)
+    { 
+      endVisit((ExtSDef)node);
+      return;
+    }
+    if(node instanceof VarDec1)
+    { 
+      endVisit((VarDec1)node);
+      return;
+    }
+    if(node instanceof ParenStrat)
+    { 
+      endVisit((ParenStrat)node);
+      return;
+    }
+    if(node instanceof Fail)
+    { 
+      endVisit((Fail)node);
+      return;
+    }
+    if(node instanceof Id0)
+    { 
+      endVisit((Id0)node);
+      return;
+    }
+    if(node instanceof Match)
+    { 
+      endVisit((Match)node);
+      return;
+    }
+    if(node instanceof Build)
+    { 
+      endVisit((Build)node);
+      return;
+    }
+    if(node instanceof Scope)
+    { 
+      endVisit((Scope)node);
+      return;
+    }
+    if(node instanceof Seq)
+    { 
+      endVisit((Seq)node);
+      return;
+    }
+    if(node instanceof GuardedLChoice)
+    { 
+      endVisit((GuardedLChoice)node);
+      return;
+    }
+    if(node instanceof StrategyMid_StrategoHost)
+    { 
+      endVisit((StrategyMid_StrategoHost)node);
+      return;
+    }
+    if(node instanceof PrimT)
+    { 
+      endVisit((PrimT)node);
+      return;
+    }
+    if(node instanceof Some)
+    { 
+      endVisit((Some)node);
+      return;
+    }
+    if(node instanceof One)
+    { 
+      endVisit((One)node);
+      return;
+    }
+    if(node instanceof All)
+    { 
+      endVisit((All)node);
+      return;
+    }
+    if(node instanceof ImportTerm)
+    { 
+      endVisit((ImportTerm)node);
+      return;
+    }
+    if(node instanceof Module)
+    { 
+      endVisit((Module)node);
+      return;
+    }
+    if(node instanceof Specification)
+    { 
+      endVisit((Specification)node);
+      return;
+    }
+    if(node instanceof Imports)
+    { 
+      endVisit((Imports)node);
+      return;
+    }
+    if(node instanceof Strategies)
+    { 
+      endVisit((Strategies)node);
+      return;
+    }
+    if(node instanceof Signature)
+    { 
+      endVisit((Signature)node);
+      return;
+    }
+    if(node instanceof Import)
+    { 
+      endVisit((Import)node);
+      return;
+    }
+    if(node instanceof ImportWildcard)
+    { 
+      endVisit((ImportWildcard)node);
+      return;
+    }
+    if(node instanceof ListVar)
+    { 
+      endVisit((ListVar)node);
+      return;
+    }
+    if(node instanceof Var)
+    { 
+      endVisit((Var)node);
+      return;
+    }
+    if(node instanceof ID_StrategoHost)
+    { 
+      endVisit((ID_StrategoHost)node);
+      return;
+    }
+    if(node instanceof BuildDefaultPT)
+    { 
+      endVisit((BuildDefaultPT)node);
+      return;
+    }
+    if(node instanceof BuildDefault)
+    { 
+      endVisit((BuildDefault)node);
+      return;
+    }
+    if(node instanceof Char1)
+    { 
+      endVisit((Char1)node);
+      return;
+    }
+    if(node instanceof AnnoList)
+    { 
+      endVisit((AnnoList)node);
+      return;
+    }
+    if(node instanceof NoAnnoList)
+    { 
+      endVisit((NoAnnoList)node);
+      return;
+    }
+    if(node instanceof App0)
+    { 
+      endVisit((App0)node);
+      return;
+    }
+    if(node instanceof App)
+    { 
+      endVisit((App)node);
+      return;
+    }
+    if(node instanceof RootApp0)
+    { 
+      endVisit((RootApp0)node);
+      return;
+    }
+    if(node instanceof RootApp)
+    { 
+      endVisit((RootApp)node);
+      return;
+    }
+    if(node instanceof Tuple)
+    { 
+      endVisit((Tuple)node);
+      return;
+    }
+    if(node instanceof List0)
+    { 
+      endVisit((List0)node);
+      return;
+    }
+    if(node instanceof ListTail)
+    { 
+      endVisit((ListTail)node);
+      return;
+    }
+    if(node instanceof SortList)
+    { 
+      endVisit((SortList)node);
+      return;
+    }
+    if(node instanceof SortListTl)
+    { 
+      endVisit((SortListTl)node);
+      return;
+    }
+    if(node instanceof SortTuple)
+    { 
+      endVisit((SortTuple)node);
+      return;
+    }
+    if(node instanceof Star)
+    { 
+      endVisit((Star)node);
+      return;
+    }
+    if(node instanceof StarStar)
+    { 
+      endVisit((StarStar)node);
+      return;
+    }
+    if(node instanceof SDefNoArgs)
+    { 
+      endVisit((SDefNoArgs)node);
+      return;
+    }
+    if(node instanceof SDef)
+    { 
+      endVisit((SDef)node);
+      return;
+    }
+    if(node instanceof DefaultVarDec)
+    { 
+      endVisit((DefaultVarDec)node);
+      return;
+    }
+    if(node instanceof Call)
+    { 
+      endVisit((Call)node);
+      return;
+    }
+    if(node instanceof ScopeDefault)
+    { 
+      endVisit((ScopeDefault)node);
+      return;
+    }
+    if(node instanceof BA)
+    { 
+      endVisit((BA)node);
+      return;
+    }
+    if(node instanceof StrategyAngle)
+    { 
+      endVisit((StrategyAngle)node);
+      return;
+    }
+    if(node instanceof LChoice)
+    { 
+      endVisit((LChoice)node);
+      return;
+    }
+    if(node instanceof Rec)
+    { 
+      endVisit((Rec)node);
+      return;
+    }
+    if(node instanceof Not0)
+    { 
+      endVisit((Not0)node);
+      return;
+    }
+    if(node instanceof Where)
+    { 
+      endVisit((Where)node);
+      return;
+    }
+    if(node instanceof Test)
+    { 
+      endVisit((Test)node);
+      return;
+    }
+    if(node instanceof PrimNoArgs)
+    { 
+      endVisit((PrimNoArgs)node);
+      return;
+    }
+    if(node instanceof Prim)
+    { 
+      endVisit((Prim)node);
+      return;
+    }
+    if(node instanceof StrCong)
+    { 
+      endVisit((StrCong)node);
+      return;
+    }
+    if(node instanceof IntCong)
+    { 
+      endVisit((IntCong)node);
+      return;
+    }
+    if(node instanceof RealCong)
+    { 
+      endVisit((RealCong)node);
+      return;
+    }
+    if(node instanceof CharCong)
+    { 
+      endVisit((CharCong)node);
+      return;
+    }
+    if(node instanceof CongQ)
+    { 
+      endVisit((CongQ)node);
+      return;
+    }
+    if(node instanceof AnnoCong)
+    { 
+      endVisit((AnnoCong)node);
+      return;
+    }
+    if(node instanceof StrategyCurly)
+    { 
+      endVisit((StrategyCurly)node);
+      return;
+    }
+    if(node instanceof EmptyTupleCong)
+    { 
+      endVisit((EmptyTupleCong)node);
+      return;
+    }
+    if(node instanceof Strategy)
+    { 
+      endVisit((Strategy)node);
+      return;
+    }
+    if(node instanceof TupleCong)
+    { 
+      endVisit((TupleCong)node);
+      return;
+    }
+    if(node instanceof ListCongNoTail)
+    { 
+      endVisit((ListCongNoTail)node);
+      return;
+    }
+    if(node instanceof ListCong)
+    { 
+      endVisit((ListCong)node);
+      return;
+    }
+    if(node instanceof ExplodeCong)
+    { 
+      endVisit((ExplodeCong)node);
+      return;
+    }
+    if(node instanceof CallNoArgs)
+    { 
+      endVisit((CallNoArgs)node);
+      return;
+    }
+    if(node instanceof LRule)
+    { 
+      endVisit((LRule)node);
+      return;
+    }
+    if(node instanceof SRule)
+    { 
+      endVisit((SRule)node);
+      return;
+    }
+    if(node instanceof Choice)
+    { 
+      endVisit((Choice)node);
+      return;
+    }
+    if(node instanceof RChoice)
+    { 
+      endVisit((RChoice)node);
+      return;
+    }
+    if(node instanceof CondChoice)
+    { 
+      endVisit((CondChoice)node);
+      return;
+    }
+    if(node instanceof IfThen)
+    { 
+      endVisit((IfThen)node);
+      return;
+    }
+    if(node instanceof SwitchChoiceNoOtherwise)
+    { 
+      endVisit((SwitchChoiceNoOtherwise)node);
+      return;
+    }
+    if(node instanceof SwitchChoice)
+    { 
+      endVisit((SwitchChoice)node);
+      return;
+    }
+    if(node instanceof SwitchCase)
+    { 
+      endVisit((SwitchCase)node);
+      return;
+    }
+    if(node instanceof AM)
+    { 
+      endVisit((AM)node);
+      return;
+    }
+    if(node instanceof Assign0)
+    { 
+      endVisit((Assign0)node);
+      return;
+    }
+    if(node instanceof OverlayNoArgs)
+    { 
+      endVisit((OverlayNoArgs)node);
+      return;
+    }
+    if(node instanceof Overlay)
+    { 
+      endVisit((Overlay)node);
+      return;
+    }
+    if(node instanceof RDefNoArgs)
+    { 
+      endVisit((RDefNoArgs)node);
+      return;
+    }
+    if(node instanceof RDef)
+    { 
+      endVisit((RDef)node);
+      return;
+    }
+    if(node instanceof RDefT)
+    { 
+      endVisit((RDefT)node);
+      return;
+    }
+    if(node instanceof RuleNoCond)
+    { 
+      endVisit((RuleNoCond)node);
+      return;
+    }
+    if(node instanceof Rule)
+    { 
+      endVisit((Rule)node);
+      return;
+    }
+    if(node instanceof Rules)
+    { 
+      endVisit((Rules)node);
+      return;
+    }
+    if(node instanceof Overlays)
+    { 
+      endVisit((Overlays)node);
+      return;
+    }
+    if(node instanceof Def_StrategoHost)
+    { 
+      endVisit((Def_StrategoHost)node);
+      return;
+    }
+    if(node instanceof DynRuleScope)
+    { 
+      endVisit((DynRuleScope)node);
+      return;
+    }
+    if(node instanceof ScopeLabels_StrategoHost)
+    { 
+      endVisit((ScopeLabels_StrategoHost)node);
+      return;
+    }
+    if(node instanceof ScopeLabels)
+    { 
+      endVisit((ScopeLabels)node);
+      return;
+    }
+    if(node instanceof GenDynRules)
+    { 
+      endVisit((GenDynRules)node);
+      return;
+    }
+    if(node instanceof AddScopeLabel)
+    { 
+      endVisit((AddScopeLabel)node);
+      return;
+    }
+    if(node instanceof UndefineDynRule)
+    { 
+      endVisit((UndefineDynRule)node);
+      return;
+    }
+    if(node instanceof SetDynRule)
+    { 
+      endVisit((SetDynRule)node);
+      return;
+    }
+    if(node instanceof AddDynRule)
+    { 
+      endVisit((AddDynRule)node);
+      return;
+    }
+    if(node instanceof SetDynRuleMatch)
+    { 
+      endVisit((SetDynRuleMatch)node);
+      return;
+    }
+    if(node instanceof DynRuleAssign)
+    { 
+      endVisit((DynRuleAssign)node);
+      return;
+    }
+    if(node instanceof DynRuleAssignAdd)
+    { 
+      endVisit((DynRuleAssignAdd)node);
+      return;
+    }
+    if(node instanceof SetDynRuleDepends)
+    { 
+      endVisit((SetDynRuleDepends)node);
+      return;
+    }
+    if(node instanceof LabeledDynRuleId)
+    { 
+      endVisit((LabeledDynRuleId)node);
+      return;
+    }
+    if(node instanceof AddLabelDynRuleId)
+    { 
+      endVisit((AddLabelDynRuleId)node);
+      return;
+    }
+    if(node instanceof DynRuleId)
+    { 
+      endVisit((DynRuleId)node);
+      return;
+    }
+    if(node instanceof LabeledDynRuleScopeId)
+    { 
+      endVisit((LabeledDynRuleScopeId)node);
+      return;
+    }
+    if(node instanceof DynRuleScopeId)
+    { 
+      endVisit((DynRuleScopeId)node);
+      return;
+    }
+    if(node instanceof RDecNoArgs)
+    { 
+      endVisit((RDecNoArgs)node);
+      return;
+    }
+    if(node instanceof RDec)
+    { 
+      endVisit((RDec)node);
+      return;
+    }
+    if(node instanceof RDecT)
+    { 
+      endVisit((RDecT)node);
+      return;
+    }
+    if(node instanceof RuleNames_StrategoHost)
+    { 
+      endVisit((RuleNames_StrategoHost)node);
+      return;
+    }
+    if(node instanceof RuleNames)
+    { 
+      endVisit((RuleNames)node);
+      return;
+    }
+    if(node instanceof DynRuleIntersectFix)
+    { 
+      endVisit((DynRuleIntersectFix)node);
+      return;
+    }
+    if(node instanceof DynRuleUnionFix0)
+    { 
+      endVisit((DynRuleUnionFix0)node);
+      return;
+    }
+    if(node instanceof DynRuleUnionFix)
+    { 
+      endVisit((DynRuleUnionFix)node);
+      return;
+    }
+    if(node instanceof DynRuleIntersectUnionFix0)
+    { 
+      endVisit((DynRuleIntersectUnionFix0)node);
+      return;
+    }
+    if(node instanceof DynRuleIntersectUnionFix)
+    { 
+      endVisit((DynRuleIntersectUnionFix)node);
+      return;
+    }
+    if(node instanceof DynRuleIntersect)
+    { 
+      endVisit((DynRuleIntersect)node);
+      return;
+    }
+    if(node instanceof DynRuleUnion)
+    { 
+      endVisit((DynRuleUnion)node);
+      return;
+    }
+    if(node instanceof DynRuleIntersectUnion)
+    { 
+      endVisit((DynRuleIntersectUnion)node);
+      return;
+    }
+    if(node instanceof UnicodeEscape0)
+    { 
+      endVisit((UnicodeEscape0)node);
+      return;
+    }
+    if(node instanceof LineTerminator)
+    { 
+      endVisit((LineTerminator)node);
+      return;
+    }
+    if(node instanceof CarriageReturn)
+    { 
+      endVisit((CarriageReturn)node);
+      return;
+    }
+    if(node instanceof EndOfFile)
+    { 
+      endVisit((EndOfFile)node);
+      return;
+    }
+    if(node instanceof Comment)
+    { 
+      endVisit((Comment)node);
+      return;
+    }
+    if(node instanceof EOLCommentChars)
+    { 
+      endVisit((EOLCommentChars)node);
+      return;
+    }
+    if(node instanceof CommentPart)
+    { 
+      endVisit((CommentPart)node);
+      return;
+    }
+    if(node instanceof BlockCommentChars)
+    { 
+      endVisit((BlockCommentChars)node);
+      return;
+    }
+    if(node instanceof EscEscChar)
+    { 
+      endVisit((EscEscChar)node);
+      return;
+    }
+    if(node instanceof EscChar)
+    { 
+      endVisit((EscChar)node);
+      return;
+    }
+    if(node instanceof UnicodeEscape)
+    { 
+      endVisit((UnicodeEscape)node);
+      return;
+    }
+    if(node instanceof Keyword_JavaObject)
+    { 
+      endVisit((Keyword_JavaObject)node);
+      return;
+    }
+    if(node instanceof ID_JavaObject)
+    { 
+      endVisit((ID_JavaObject)node);
+      return;
+    }
+    if(node instanceof Id)
+    { 
+      endVisit((Id)node);
+      return;
+    }
+    if(node instanceof Public)
+    { 
+      endVisit((Public)node);
+      return;
+    }
+    if(node instanceof Private)
+    { 
+      endVisit((Private)node);
+      return;
+    }
+    if(node instanceof Protected)
+    { 
+      endVisit((Protected)node);
+      return;
+    }
+    if(node instanceof Abstract)
+    { 
+      endVisit((Abstract)node);
+      return;
+    }
+    if(node instanceof Final)
+    { 
+      endVisit((Final)node);
+      return;
+    }
+    if(node instanceof Static)
+    { 
+      endVisit((Static)node);
+      return;
+    }
+    if(node instanceof Native)
+    { 
+      endVisit((Native)node);
+      return;
+    }
+    if(node instanceof Transient)
+    { 
+      endVisit((Transient)node);
+      return;
+    }
+    if(node instanceof Volatile)
+    { 
+      endVisit((Volatile)node);
+      return;
+    }
+    if(node instanceof Synchronized0)
+    { 
+      endVisit((Synchronized0)node);
+      return;
+    }
+    if(node instanceof StrictFP)
+    { 
+      endVisit((StrictFP)node);
+      return;
+    }
+    if(node instanceof Modifier_JavaObject9)
+    { 
+      endVisit((Modifier_JavaObject9)node);
+      return;
+    }
+    if(node instanceof Modifier_JavaObject8)
+    { 
+      endVisit((Modifier_JavaObject8)node);
+      return;
+    }
+    if(node instanceof Modifier_JavaObject7)
+    { 
+      endVisit((Modifier_JavaObject7)node);
+      return;
+    }
+    if(node instanceof Modifier_JavaObject6)
+    { 
+      endVisit((Modifier_JavaObject6)node);
+      return;
+    }
+    if(node instanceof Modifier_JavaObject5)
+    { 
+      endVisit((Modifier_JavaObject5)node);
+      return;
+    }
+    if(node instanceof Modifier_JavaObject4)
+    { 
+      endVisit((Modifier_JavaObject4)node);
+      return;
+    }
+    if(node instanceof Modifier_JavaObject3)
+    { 
+      endVisit((Modifier_JavaObject3)node);
+      return;
+    }
+    if(node instanceof Modifier_JavaObject2)
+    { 
+      endVisit((Modifier_JavaObject2)node);
+      return;
+    }
+    if(node instanceof Modifier_JavaObject1)
+    { 
+      endVisit((Modifier_JavaObject1)node);
+      return;
+    }
+    if(node instanceof Modifier_JavaObject0)
+    { 
+      endVisit((Modifier_JavaObject0)node);
+      return;
+    }
+    if(node instanceof Modifier_JavaObject)
+    { 
+      endVisit((Modifier_JavaObject)node);
+      return;
+    }
+    if(node instanceof DeciLiteral_JavaObject)
+    { 
+      endVisit((DeciLiteral_JavaObject)node);
+      return;
+    }
+    if(node instanceof HexaLiteral_JavaObject)
+    { 
+      endVisit((HexaLiteral_JavaObject)node);
+      return;
+    }
+    if(node instanceof OctaLiteral_JavaObject)
+    { 
+      endVisit((OctaLiteral_JavaObject)node);
+      return;
+    }
+    if(node instanceof DeciNumeral_JavaObject)
+    { 
+      endVisit((DeciNumeral_JavaObject)node);
+      return;
+    }
+    if(node instanceof HexaNumeral_JavaObject)
+    { 
+      endVisit((HexaNumeral_JavaObject)node);
+      return;
+    }
+    if(node instanceof OctaNumeral_JavaObject)
+    { 
+      endVisit((OctaNumeral_JavaObject)node);
+      return;
+    }
+    if(node instanceof Deci)
+    { 
+      endVisit((Deci)node);
+      return;
+    }
+    if(node instanceof Hexa)
+    { 
+      endVisit((Hexa)node);
+      return;
+    }
+    if(node instanceof Octa)
+    { 
+      endVisit((Octa)node);
+      return;
+    }
+    if(node instanceof DeciFloatLiteral_JavaObject)
+    { 
+      endVisit((DeciFloatLiteral_JavaObject)node);
+      return;
+    }
+    if(node instanceof HexaFloatLiteral_JavaObject)
+    { 
+      endVisit((HexaFloatLiteral_JavaObject)node);
+      return;
+    }
+    if(node instanceof Float1)
+    { 
+      endVisit((Float1)node);
+      return;
+    }
+    if(node instanceof Float0)
+    { 
+      endVisit((Float0)node);
+      return;
+    }
+    if(node instanceof DeciFloatNumeral_JavaObject)
+    { 
+      endVisit((DeciFloatNumeral_JavaObject)node);
+      return;
+    }
+    if(node instanceof DeciFloatDigits_JavaObject)
+    { 
+      endVisit((DeciFloatDigits_JavaObject)node);
+      return;
+    }
+    if(node instanceof DeciFloatExponentPart_JavaObject)
+    { 
+      endVisit((DeciFloatExponentPart_JavaObject)node);
+      return;
+    }
+    if(node instanceof SignedInteger_JavaObject)
+    { 
+      endVisit((SignedInteger_JavaObject)node);
+      return;
+    }
+    if(node instanceof HexaFloatNumeral_JavaObject)
+    { 
+      endVisit((HexaFloatNumeral_JavaObject)node);
+      return;
+    }
+    if(node instanceof HexaSignificand_JavaObject)
+    { 
+      endVisit((HexaSignificand_JavaObject)node);
+      return;
+    }
+    if(node instanceof BinaryExponent_JavaObject)
+    { 
+      endVisit((BinaryExponent_JavaObject)node);
+      return;
+    }
+    if(node instanceof Bool)
+    { 
+      endVisit((Bool)node);
+      return;
+    }
+    if(node instanceof True)
+    { 
+      endVisit((True)node);
+      return;
+    }
+    if(node instanceof False)
+    { 
+      endVisit((False)node);
+      return;
+    }
+    if(node instanceof EscapeSeq_JavaObject0)
+    { 
+      endVisit((EscapeSeq_JavaObject0)node);
+      return;
+    }
+    if(node instanceof EscapeSeq_JavaObject)
+    { 
+      endVisit((EscapeSeq_JavaObject)node);
+      return;
+    }
+    if(node instanceof NamedEscape)
+    { 
+      endVisit((NamedEscape)node);
+      return;
+    }
+    if(node instanceof OctaEscape1)
+    { 
+      endVisit((OctaEscape1)node);
+      return;
+    }
+    if(node instanceof OctaEscape20)
+    { 
+      endVisit((OctaEscape20)node);
+      return;
+    }
+    if(node instanceof OctaEscape2)
+    { 
+      endVisit((OctaEscape2)node);
+      return;
+    }
+    if(node instanceof OctaEscape3)
+    { 
+      endVisit((OctaEscape3)node);
+      return;
+    }
+    if(node instanceof LastOcta_JavaObject)
+    { 
+      endVisit((LastOcta_JavaObject)node);
+      return;
+    }
+    if(node instanceof Char0)
+    { 
+      endVisit((Char0)node);
+      return;
+    }
+    if(node instanceof Single)
+    { 
+      endVisit((Single)node);
+      return;
+    }
+    if(node instanceof CharContent_JavaObject0)
+    { 
+      endVisit((CharContent_JavaObject0)node);
+      return;
+    }
+    if(node instanceof CharContent_JavaObject)
+    { 
+      endVisit((CharContent_JavaObject)node);
+      return;
+    }
+    if(node instanceof SingleChar_JavaObject)
+    { 
+      endVisit((SingleChar_JavaObject)node);
+      return;
+    }
+    if(node instanceof String)
+    { 
+      endVisit((String)node);
+      return;
+    }
+    if(node instanceof Chars)
+    { 
+      endVisit((Chars)node);
+      return;
+    }
+    if(node instanceof StringPart_JavaObject0)
+    { 
+      endVisit((StringPart_JavaObject0)node);
+      return;
+    }
+    if(node instanceof StringPart_JavaObject)
+    { 
+      endVisit((StringPart_JavaObject)node);
+      return;
+    }
+    if(node instanceof StringChars_JavaObject)
+    { 
+      endVisit((StringChars_JavaObject)node);
+      return;
+    }
+    if(node instanceof Null)
+    { 
+      endVisit((Null)node);
+      return;
+    }
+    if(node instanceof PrimType_JavaObject)
+    { 
+      endVisit((PrimType_JavaObject)node);
+      return;
+    }
+    if(node instanceof Boolean)
+    { 
+      endVisit((Boolean)node);
+      return;
+    }
+    if(node instanceof NumType_JavaObject0)
+    { 
+      endVisit((NumType_JavaObject0)node);
+      return;
+    }
+    if(node instanceof NumType_JavaObject)
+    { 
+      endVisit((NumType_JavaObject)node);
+      return;
+    }
+    if(node instanceof Byte)
+    { 
+      endVisit((Byte)node);
+      return;
+    }
+    if(node instanceof Short)
+    { 
+      endVisit((Short)node);
+      return;
+    }
+    if(node instanceof Int)
+    { 
+      endVisit((Int)node);
+      return;
+    }
+    if(node instanceof Long)
+    { 
+      endVisit((Long)node);
+      return;
+    }
+    if(node instanceof Char)
+    { 
+      endVisit((Char)node);
+      return;
+    }
+    if(node instanceof Float)
+    { 
+      endVisit((Float)node);
+      return;
+    }
+    if(node instanceof Double)
+    { 
+      endVisit((Double)node);
+      return;
+    }
+    if(node instanceof PackageName)
+    { 
+      endVisit((PackageName)node);
+      return;
+    }
+    if(node instanceof AmbName0)
+    { 
+      endVisit((AmbName0)node);
+      return;
+    }
+    if(node instanceof AmbName)
+    { 
+      endVisit((AmbName)node);
+      return;
+    }
+    if(node instanceof TypeName0)
+    { 
+      endVisit((TypeName0)node);
+      return;
+    }
+    if(node instanceof TypeName)
+    { 
+      endVisit((TypeName)node);
+      return;
+    }
+    if(node instanceof ExprName0)
+    { 
+      endVisit((ExprName0)node);
+      return;
+    }
+    if(node instanceof ExprName)
+    { 
+      endVisit((ExprName)node);
+      return;
+    }
+    if(node instanceof MethodName0)
+    { 
+      endVisit((MethodName0)node);
+      return;
+    }
+    if(node instanceof MethodName)
+    { 
+      endVisit((MethodName)node);
+      return;
+    }
+    if(node instanceof PackageOrTypeName0)
+    { 
+      endVisit((PackageOrTypeName0)node);
+      return;
+    }
+    if(node instanceof PackageOrTypeName)
+    { 
+      endVisit((PackageOrTypeName)node);
+      return;
+    }
+    if(node instanceof TypeArgs)
+    { 
+      endVisit((TypeArgs)node);
+      return;
+    }
+    if(node instanceof ActualTypeArg_JavaObject)
+    { 
+      endVisit((ActualTypeArg_JavaObject)node);
+      return;
+    }
+    if(node instanceof Wildcard)
+    { 
+      endVisit((Wildcard)node);
+      return;
+    }
+    if(node instanceof WildcardUpperBound)
+    { 
+      endVisit((WildcardUpperBound)node);
+      return;
+    }
+    if(node instanceof WildcardLowerBound)
+    { 
+      endVisit((WildcardLowerBound)node);
+      return;
+    }
+    if(node instanceof TypeParam)
+    { 
+      endVisit((TypeParam)node);
+      return;
+    }
+    if(node instanceof TypeBound)
+    { 
+      endVisit((TypeBound)node);
+      return;
+    }
+    if(node instanceof TypeParams)
+    { 
+      endVisit((TypeParams)node);
+      return;
+    }
+    if(node instanceof TypeVarId_JavaObject)
+    { 
+      endVisit((TypeVarId_JavaObject)node);
+      return;
+    }
+    if(node instanceof RefType_JavaObject0)
+    { 
+      endVisit((RefType_JavaObject0)node);
+      return;
+    }
+    if(node instanceof RefType_JavaObject)
+    { 
+      endVisit((RefType_JavaObject)node);
+      return;
+    }
+    if(node instanceof ClassOrInterfaceType)
+    { 
+      endVisit((ClassOrInterfaceType)node);
+      return;
+    }
+    if(node instanceof ClassType)
+    { 
+      endVisit((ClassType)node);
+      return;
+    }
+    if(node instanceof InterfaceType)
+    { 
+      endVisit((InterfaceType)node);
+      return;
+    }
+    if(node instanceof TypeDecSpec_JavaObject)
+    { 
+      endVisit((TypeDecSpec_JavaObject)node);
+      return;
+    }
+    if(node instanceof Member)
+    { 
+      endVisit((Member)node);
+      return;
+    }
+    if(node instanceof TypeVar)
+    { 
+      endVisit((TypeVar)node);
+      return;
+    }
+    if(node instanceof ArrayType)
+    { 
+      endVisit((ArrayType)node);
+      return;
+    }
+    if(node instanceof Type_JavaObject0)
+    { 
+      endVisit((Type_JavaObject0)node);
+      return;
+    }
+    if(node instanceof Type_JavaObject)
+    { 
+      endVisit((Type_JavaObject)node);
+      return;
+    }
+    if(node instanceof Lit)
+    { 
+      endVisit((Lit)node);
+      return;
+    }
+    if(node instanceof Literal_JavaObject5)
+    { 
+      endVisit((Literal_JavaObject5)node);
+      return;
+    }
+    if(node instanceof Literal_JavaObject4)
+    { 
+      endVisit((Literal_JavaObject4)node);
+      return;
+    }
+    if(node instanceof Literal_JavaObject3)
+    { 
+      endVisit((Literal_JavaObject3)node);
+      return;
+    }
+    if(node instanceof Literal_JavaObject2)
+    { 
+      endVisit((Literal_JavaObject2)node);
+      return;
+    }
+    if(node instanceof Literal_JavaObject1)
+    { 
+      endVisit((Literal_JavaObject1)node);
+      return;
+    }
+    if(node instanceof Literal_JavaObject0)
+    { 
+      endVisit((Literal_JavaObject0)node);
+      return;
+    }
+    if(node instanceof Literal_JavaObject)
+    { 
+      endVisit((Literal_JavaObject)node);
+      return;
+    }
+    if(node instanceof Class)
+    { 
+      endVisit((Class)node);
+      return;
+    }
+    if(node instanceof VoidClass)
+    { 
+      endVisit((VoidClass)node);
+      return;
+    }
+    if(node instanceof This)
+    { 
+      endVisit((This)node);
+      return;
+    }
+    if(node instanceof QThis)
+    { 
+      endVisit((QThis)node);
+      return;
+    }
+    if(node instanceof Expr)
+    { 
+      endVisit((Expr)node);
+      return;
+    }
+    if(node instanceof ArrayInit0)
+    { 
+      endVisit((ArrayInit0)node);
+      return;
+    }
+    if(node instanceof ArrayInit)
+    { 
+      endVisit((ArrayInit)node);
+      return;
+    }
+    if(node instanceof FieldDec)
+    { 
+      endVisit((FieldDec)node);
+      return;
+    }
+    if(node instanceof VarDec0)
+    { 
+      endVisit((VarDec0)node);
+      return;
+    }
+    if(node instanceof VarDec)
+    { 
+      endVisit((VarDec)node);
+      return;
+    }
+    if(node instanceof VarDecId_JavaObject)
+    { 
+      endVisit((VarDecId_JavaObject)node);
+      return;
+    }
+    if(node instanceof ArrayVarDecId)
+    { 
+      endVisit((ArrayVarDecId)node);
+      return;
+    }
+    if(node instanceof Dim0)
+    { 
+      endVisit((Dim0)node);
+      return;
+    }
+    if(node instanceof VarInit_JavaObject0)
+    { 
+      endVisit((VarInit_JavaObject0)node);
+      return;
+    }
+    if(node instanceof VarInit_JavaObject)
+    { 
+      endVisit((VarInit_JavaObject)node);
+      return;
+    }
+    if(node instanceof FieldMod_JavaObject5)
+    { 
+      endVisit((FieldMod_JavaObject5)node);
+      return;
+    }
+    if(node instanceof FieldMod_JavaObject4)
+    { 
+      endVisit((FieldMod_JavaObject4)node);
+      return;
+    }
+    if(node instanceof FieldMod_JavaObject3)
+    { 
+      endVisit((FieldMod_JavaObject3)node);
+      return;
+    }
+    if(node instanceof FieldMod_JavaObject2)
+    { 
+      endVisit((FieldMod_JavaObject2)node);
+      return;
+    }
+    if(node instanceof FieldMod_JavaObject1)
+    { 
+      endVisit((FieldMod_JavaObject1)node);
+      return;
+    }
+    if(node instanceof FieldMod_JavaObject0)
+    { 
+      endVisit((FieldMod_JavaObject0)node);
+      return;
+    }
+    if(node instanceof FieldMod_JavaObject)
+    { 
+      endVisit((FieldMod_JavaObject)node);
+      return;
+    }
+    if(node instanceof LocalVarDecStm)
+    { 
+      endVisit((LocalVarDecStm)node);
+      return;
+    }
+    if(node instanceof LocalVarDec)
+    { 
+      endVisit((LocalVarDec)node);
+      return;
+    }
+    if(node instanceof Stm_JavaObject)
+    { 
+      endVisit((Stm_JavaObject)node);
+      return;
+    }
+    if(node instanceof Empty)
+    { 
+      endVisit((Empty)node);
+      return;
+    }
+    if(node instanceof Labeled)
+    { 
+      endVisit((Labeled)node);
+      return;
+    }
+    if(node instanceof ExprStm)
+    { 
+      endVisit((ExprStm)node);
+      return;
+    }
+    if(node instanceof If0)
+    { 
+      endVisit((If0)node);
+      return;
+    }
+    if(node instanceof If)
+    { 
+      endVisit((If)node);
+      return;
+    }
+    if(node instanceof AssertStm0)
+    { 
+      endVisit((AssertStm0)node);
+      return;
+    }
+    if(node instanceof AssertStm)
+    { 
+      endVisit((AssertStm)node);
+      return;
+    }
+    if(node instanceof Switch)
+    { 
+      endVisit((Switch)node);
+      return;
+    }
+    if(node instanceof SwitchBlock)
+    { 
+      endVisit((SwitchBlock)node);
+      return;
+    }
+    if(node instanceof SwitchGroup)
+    { 
+      endVisit((SwitchGroup)node);
+      return;
+    }
+    if(node instanceof Case)
+    { 
+      endVisit((Case)node);
+      return;
+    }
+    if(node instanceof Default)
+    { 
+      endVisit((Default)node);
+      return;
+    }
+    if(node instanceof While)
+    { 
+      endVisit((While)node);
+      return;
+    }
+    if(node instanceof DoWhile)
+    { 
+      endVisit((DoWhile)node);
+      return;
+    }
+    if(node instanceof For0)
+    { 
+      endVisit((For0)node);
+      return;
+    }
+    if(node instanceof For)
+    { 
+      endVisit((For)node);
+      return;
+    }
+    if(node instanceof ForEach)
+    { 
+      endVisit((ForEach)node);
+      return;
+    }
+    if(node instanceof Break)
+    { 
+      endVisit((Break)node);
+      return;
+    }
+    if(node instanceof Continue)
+    { 
+      endVisit((Continue)node);
+      return;
+    }
+    if(node instanceof Return)
+    { 
+      endVisit((Return)node);
+      return;
+    }
+    if(node instanceof Throw)
+    { 
+      endVisit((Throw)node);
+      return;
+    }
+    if(node instanceof Synchronized)
+    { 
+      endVisit((Synchronized)node);
+      return;
+    }
+    if(node instanceof Try0)
+    { 
+      endVisit((Try0)node);
+      return;
+    }
+    if(node instanceof Try)
+    { 
+      endVisit((Try)node);
+      return;
+    }
+    if(node instanceof Catch)
+    { 
+      endVisit((Catch)node);
+      return;
+    }
+    if(node instanceof Block)
+    { 
+      endVisit((Block)node);
+      return;
+    }
+    if(node instanceof BlockStm_JavaObject0)
+    { 
+      endVisit((BlockStm_JavaObject0)node);
+      return;
+    }
+    if(node instanceof ClassDecStm)
+    { 
+      endVisit((ClassDecStm)node);
+      return;
+    }
+    if(node instanceof BlockStm_JavaObject)
+    { 
+      endVisit((BlockStm_JavaObject)node);
+      return;
+    }
+    if(node instanceof MethodDec)
+    { 
+      endVisit((MethodDec)node);
+      return;
+    }
+    if(node instanceof MethodDecHead)
+    { 
+      endVisit((MethodDecHead)node);
+      return;
+    }
+    if(node instanceof DeprMethodDecHead)
+    { 
+      endVisit((DeprMethodDecHead)node);
+      return;
+    }
+    if(node instanceof ResultType_JavaObject)
+    { 
+      endVisit((ResultType_JavaObject)node);
+      return;
+    }
+    if(node instanceof Void)
+    { 
+      endVisit((Void)node);
+      return;
+    }
+    if(node instanceof Param)
+    { 
+      endVisit((Param)node);
+      return;
+    }
+    if(node instanceof VarArityParam)
+    { 
+      endVisit((VarArityParam)node);
+      return;
+    }
+    if(node instanceof VarMod_JavaObject)
+    { 
+      endVisit((VarMod_JavaObject)node);
+      return;
+    }
+    if(node instanceof MethodMod_JavaObject7)
+    { 
+      endVisit((MethodMod_JavaObject7)node);
+      return;
+    }
+    if(node instanceof MethodMod_JavaObject6)
+    { 
+      endVisit((MethodMod_JavaObject6)node);
+      return;
+    }
+    if(node instanceof MethodMod_JavaObject5)
+    { 
+      endVisit((MethodMod_JavaObject5)node);
+      return;
+    }
+    if(node instanceof MethodMod_JavaObject4)
+    { 
+      endVisit((MethodMod_JavaObject4)node);
+      return;
+    }
+    if(node instanceof MethodMod_JavaObject3)
+    { 
+      endVisit((MethodMod_JavaObject3)node);
+      return;
+    }
+    if(node instanceof MethodMod_JavaObject2)
+    { 
+      endVisit((MethodMod_JavaObject2)node);
+      return;
+    }
+    if(node instanceof MethodMod_JavaObject1)
+    { 
+      endVisit((MethodMod_JavaObject1)node);
+      return;
+    }
+    if(node instanceof MethodMod_JavaObject0)
+    { 
+      endVisit((MethodMod_JavaObject0)node);
+      return;
+    }
+    if(node instanceof MethodMod_JavaObject)
+    { 
+      endVisit((MethodMod_JavaObject)node);
+      return;
+    }
+    if(node instanceof ThrowsDec)
+    { 
+      endVisit((ThrowsDec)node);
+      return;
+    }
+    if(node instanceof ExceptionType_JavaObject)
+    { 
+      endVisit((ExceptionType_JavaObject)node);
+      return;
+    }
+    if(node instanceof MethodBody_JavaObject)
+    { 
+      endVisit((MethodBody_JavaObject)node);
+      return;
+    }
+    if(node instanceof NoMethodBody)
+    { 
+      endVisit((NoMethodBody)node);
+      return;
+    }
+    if(node instanceof InstanceInit)
+    { 
+      endVisit((InstanceInit)node);
+      return;
+    }
+    if(node instanceof StaticInit)
+    { 
+      endVisit((StaticInit)node);
+      return;
+    }
+    if(node instanceof ConstrDec)
+    { 
+      endVisit((ConstrDec)node);
+      return;
+    }
+    if(node instanceof ConstrDecHead)
+    { 
+      endVisit((ConstrDecHead)node);
+      return;
+    }
+    if(node instanceof ConstrBody)
+    { 
+      endVisit((ConstrBody)node);
+      return;
+    }
+    if(node instanceof AltConstrInv)
+    { 
+      endVisit((AltConstrInv)node);
+      return;
+    }
+    if(node instanceof SuperConstrInv)
+    { 
+      endVisit((SuperConstrInv)node);
+      return;
+    }
+    if(node instanceof QSuperConstrInv)
+    { 
+      endVisit((QSuperConstrInv)node);
+      return;
+    }
+    if(node instanceof ConstrMod_JavaObject1)
+    { 
+      endVisit((ConstrMod_JavaObject1)node);
+      return;
+    }
+    if(node instanceof ConstrMod_JavaObject0)
+    { 
+      endVisit((ConstrMod_JavaObject0)node);
+      return;
+    }
+    if(node instanceof ConstrMod_JavaObject)
+    { 
+      endVisit((ConstrMod_JavaObject)node);
+      return;
+    }
+    if(node instanceof EnumDec)
+    { 
+      endVisit((EnumDec)node);
+      return;
+    }
+    if(node instanceof EnumDecHead)
+    { 
+      endVisit((EnumDecHead)node);
+      return;
+    }
+    if(node instanceof EnumBody0)
+    { 
+      endVisit((EnumBody0)node);
+      return;
+    }
+    if(node instanceof EnumBody)
+    { 
+      endVisit((EnumBody)node);
+      return;
+    }
+    if(node instanceof EnumConst)
+    { 
+      endVisit((EnumConst)node);
+      return;
+    }
+    if(node instanceof EnumConstArgs)
+    { 
+      endVisit((EnumConstArgs)node);
+      return;
+    }
+    if(node instanceof EnumBodyDecs)
+    { 
+      endVisit((EnumBodyDecs)node);
+      return;
+    }
+    if(node instanceof ConstantDec)
+    { 
+      endVisit((ConstantDec)node);
+      return;
+    }
+    if(node instanceof ConstantMod_JavaObject1)
+    { 
+      endVisit((ConstantMod_JavaObject1)node);
+      return;
+    }
+    if(node instanceof ConstantMod_JavaObject0)
+    { 
+      endVisit((ConstantMod_JavaObject0)node);
+      return;
+    }
+    if(node instanceof ConstantMod_JavaObject)
+    { 
+      endVisit((ConstantMod_JavaObject)node);
+      return;
+    }
+    if(node instanceof AbstractMethodDec)
+    { 
+      endVisit((AbstractMethodDec)node);
+      return;
+    }
+    if(node instanceof DeprAbstractMethodDec)
+    { 
+      endVisit((DeprAbstractMethodDec)node);
+      return;
+    }
+    if(node instanceof AbstractMethodMod_JavaObject0)
+    { 
+      endVisit((AbstractMethodMod_JavaObject0)node);
+      return;
+    }
+    if(node instanceof AbstractMethodMod_JavaObject)
+    { 
+      endVisit((AbstractMethodMod_JavaObject)node);
+      return;
+    }
+    if(node instanceof AnnoDec)
+    { 
+      endVisit((AnnoDec)node);
+      return;
+    }
+    if(node instanceof AnnoDecHead)
+    { 
+      endVisit((AnnoDecHead)node);
+      return;
+    }
+    if(node instanceof AnnoMethodDec)
+    { 
+      endVisit((AnnoMethodDec)node);
+      return;
+    }
+    if(node instanceof AnnoElemDec_JavaObject3)
+    { 
+      endVisit((AnnoElemDec_JavaObject3)node);
+      return;
+    }
+    if(node instanceof AnnoElemDec_JavaObject2)
+    { 
+      endVisit((AnnoElemDec_JavaObject2)node);
+      return;
+    }
+    if(node instanceof AnnoElemDec_JavaObject1)
+    { 
+      endVisit((AnnoElemDec_JavaObject1)node);
+      return;
+    }
+    if(node instanceof AnnoElemDec_JavaObject0)
+    { 
+      endVisit((AnnoElemDec_JavaObject0)node);
+      return;
+    }
+    if(node instanceof AnnoElemDec_JavaObject)
+    { 
+      endVisit((AnnoElemDec_JavaObject)node);
+      return;
+    }
+    if(node instanceof Semicolon2)
+    { 
+      endVisit((Semicolon2)node);
+      return;
+    }
+    if(node instanceof DefaultVal)
+    { 
+      endVisit((DefaultVal)node);
+      return;
+    }
+    if(node instanceof InterfaceDec_JavaObject)
+    { 
+      endVisit((InterfaceDec_JavaObject)node);
+      return;
+    }
+    if(node instanceof InterfaceDec)
+    { 
+      endVisit((InterfaceDec)node);
+      return;
+    }
+    if(node instanceof InterfaceDecHead)
+    { 
+      endVisit((InterfaceDecHead)node);
+      return;
+    }
+    if(node instanceof ExtendsInterfaces)
+    { 
+      endVisit((ExtendsInterfaces)node);
+      return;
+    }
+    if(node instanceof InterfaceMemberDec_JavaObject2)
+    { 
+      endVisit((InterfaceMemberDec_JavaObject2)node);
+      return;
+    }
+    if(node instanceof InterfaceMemberDec_JavaObject1)
+    { 
+      endVisit((InterfaceMemberDec_JavaObject1)node);
+      return;
+    }
+    if(node instanceof InterfaceMemberDec_JavaObject0)
+    { 
+      endVisit((InterfaceMemberDec_JavaObject0)node);
+      return;
+    }
+    if(node instanceof InterfaceMemberDec_JavaObject)
+    { 
+      endVisit((InterfaceMemberDec_JavaObject)node);
+      return;
+    }
+    if(node instanceof Semicolon1)
+    { 
+      endVisit((Semicolon1)node);
+      return;
+    }
+    if(node instanceof InterfaceMod_JavaObject4)
+    { 
+      endVisit((InterfaceMod_JavaObject4)node);
+      return;
+    }
+    if(node instanceof InterfaceMod_JavaObject3)
+    { 
+      endVisit((InterfaceMod_JavaObject3)node);
+      return;
+    }
+    if(node instanceof InterfaceMod_JavaObject2)
+    { 
+      endVisit((InterfaceMod_JavaObject2)node);
+      return;
+    }
+    if(node instanceof InterfaceMod_JavaObject1)
+    { 
+      endVisit((InterfaceMod_JavaObject1)node);
+      return;
+    }
+    if(node instanceof InterfaceMod_JavaObject0)
+    { 
+      endVisit((InterfaceMod_JavaObject0)node);
+      return;
+    }
+    if(node instanceof InterfaceMod_JavaObject)
+    { 
+      endVisit((InterfaceMod_JavaObject)node);
+      return;
+    }
+    if(node instanceof ClassDec_JavaObject)
+    { 
+      endVisit((ClassDec_JavaObject)node);
+      return;
+    }
+    if(node instanceof ClassDec)
+    { 
+      endVisit((ClassDec)node);
+      return;
+    }
+    if(node instanceof ClassBody)
+    { 
+      endVisit((ClassBody)node);
+      return;
+    }
+    if(node instanceof ClassDecHead)
+    { 
+      endVisit((ClassDecHead)node);
+      return;
+    }
+    if(node instanceof ClassMod_JavaObject5)
+    { 
+      endVisit((ClassMod_JavaObject5)node);
+      return;
+    }
+    if(node instanceof ClassMod_JavaObject4)
+    { 
+      endVisit((ClassMod_JavaObject4)node);
+      return;
+    }
+    if(node instanceof ClassMod_JavaObject3)
+    { 
+      endVisit((ClassMod_JavaObject3)node);
+      return;
+    }
+    if(node instanceof ClassMod_JavaObject2)
+    { 
+      endVisit((ClassMod_JavaObject2)node);
+      return;
+    }
+    if(node instanceof ClassMod_JavaObject1)
+    { 
+      endVisit((ClassMod_JavaObject1)node);
+      return;
+    }
+    if(node instanceof ClassMod_JavaObject0)
+    { 
+      endVisit((ClassMod_JavaObject0)node);
+      return;
+    }
+    if(node instanceof ClassMod_JavaObject)
+    { 
+      endVisit((ClassMod_JavaObject)node);
+      return;
+    }
+    if(node instanceof SuperDec)
+    { 
+      endVisit((SuperDec)node);
+      return;
+    }
+    if(node instanceof ImplementsDec)
+    { 
+      endVisit((ImplementsDec)node);
+      return;
+    }
+    if(node instanceof ClassBodyDec_JavaObject2)
+    { 
+      endVisit((ClassBodyDec_JavaObject2)node);
+      return;
+    }
+    if(node instanceof ClassBodyDec_JavaObject1)
+    { 
+      endVisit((ClassBodyDec_JavaObject1)node);
+      return;
+    }
+    if(node instanceof ClassBodyDec_JavaObject0)
+    { 
+      endVisit((ClassBodyDec_JavaObject0)node);
+      return;
+    }
+    if(node instanceof ClassBodyDec_JavaObject)
+    { 
+      endVisit((ClassBodyDec_JavaObject)node);
+      return;
+    }
+    if(node instanceof ClassMemberDec_JavaObject2)
+    { 
+      endVisit((ClassMemberDec_JavaObject2)node);
+      return;
+    }
+    if(node instanceof ClassMemberDec_JavaObject1)
+    { 
+      endVisit((ClassMemberDec_JavaObject1)node);
+      return;
+    }
+    if(node instanceof ClassMemberDec_JavaObject0)
+    { 
+      endVisit((ClassMemberDec_JavaObject0)node);
+      return;
+    }
+    if(node instanceof ClassMemberDec_JavaObject)
+    { 
+      endVisit((ClassMemberDec_JavaObject)node);
+      return;
+    }
+    if(node instanceof Semicolon0)
+    { 
+      endVisit((Semicolon0)node);
+      return;
+    }
+    if(node instanceof NewInstance)
+    { 
+      endVisit((NewInstance)node);
+      return;
+    }
+    if(node instanceof QNewInstance)
+    { 
+      endVisit((QNewInstance)node);
+      return;
+    }
+    if(node instanceof Expr_JavaObject3)
+    { 
+      endVisit((Expr_JavaObject3)node);
+      return;
+    }
+    if(node instanceof NewArray0)
+    { 
+      endVisit((NewArray0)node);
+      return;
+    }
+    if(node instanceof NewArray)
+    { 
+      endVisit((NewArray)node);
+      return;
+    }
+    if(node instanceof ArrayBaseType_JavaObject0)
+    { 
+      endVisit((ArrayBaseType_JavaObject0)node);
+      return;
+    }
+    if(node instanceof ArrayBaseType_JavaObject)
+    { 
+      endVisit((ArrayBaseType_JavaObject)node);
+      return;
+    }
+    if(node instanceof UnboundWld)
+    { 
+      endVisit((UnboundWld)node);
+      return;
+    }
+    if(node instanceof Dim)
+    { 
+      endVisit((Dim)node);
+      return;
+    }
+    if(node instanceof Expr_JavaObject2)
+    { 
+      endVisit((Expr_JavaObject2)node);
+      return;
+    }
+    if(node instanceof Field)
+    { 
+      endVisit((Field)node);
+      return;
+    }
+    if(node instanceof SuperField)
+    { 
+      endVisit((SuperField)node);
+      return;
+    }
+    if(node instanceof QSuperField)
+    { 
+      endVisit((QSuperField)node);
+      return;
+    }
+    if(node instanceof Expr_JavaObject1)
+    { 
+      endVisit((Expr_JavaObject1)node);
+      return;
+    }
+    if(node instanceof ArrayAccess)
+    { 
+      endVisit((ArrayAccess)node);
+      return;
+    }
+    if(node instanceof ArraySubscript)
+    { 
+      endVisit((ArraySubscript)node);
+      return;
+    }
+    if(node instanceof Invoke)
+    { 
+      endVisit((Invoke)node);
+      return;
+    }
+    if(node instanceof Method0)
+    { 
+      endVisit((Method0)node);
+      return;
+    }
+    if(node instanceof Method)
+    { 
+      endVisit((Method)node);
+      return;
+    }
+    if(node instanceof SuperMethod)
+    { 
+      endVisit((SuperMethod)node);
+      return;
+    }
+    if(node instanceof QSuperMethod)
+    { 
+      endVisit((QSuperMethod)node);
+      return;
+    }
+    if(node instanceof GenericMethod)
+    { 
+      endVisit((GenericMethod)node);
+      return;
+    }
+    if(node instanceof Expr_JavaObject0)
+    { 
+      endVisit((Expr_JavaObject0)node);
+      return;
+    }
+    if(node instanceof PostIncr)
+    { 
+      endVisit((PostIncr)node);
+      return;
+    }
+    if(node instanceof PostDecr)
+    { 
+      endVisit((PostDecr)node);
+      return;
+    }
+    if(node instanceof Plus0)
+    { 
+      endVisit((Plus0)node);
+      return;
+    }
+    if(node instanceof Minus0)
+    { 
+      endVisit((Minus0)node);
+      return;
+    }
+    if(node instanceof PreIncr)
+    { 
+      endVisit((PreIncr)node);
+      return;
+    }
+    if(node instanceof PreDecr)
+    { 
+      endVisit((PreDecr)node);
+      return;
+    }
+    if(node instanceof Complement)
+    { 
+      endVisit((Complement)node);
+      return;
+    }
+    if(node instanceof Not)
+    { 
+      endVisit((Not)node);
+      return;
+    }
+    if(node instanceof CastPrim)
+    { 
+      endVisit((CastPrim)node);
+      return;
+    }
+    if(node instanceof CastRef)
+    { 
+      endVisit((CastRef)node);
+      return;
+    }
+    if(node instanceof Expr_JavaObject)
+    { 
+      endVisit((Expr_JavaObject)node);
+      return;
+    }
+    if(node instanceof InstanceOf)
+    { 
+      endVisit((InstanceOf)node);
+      return;
+    }
+    if(node instanceof Mul)
+    { 
+      endVisit((Mul)node);
+      return;
+    }
+    if(node instanceof Div)
+    { 
+      endVisit((Div)node);
+      return;
+    }
+    if(node instanceof Remain)
+    { 
+      endVisit((Remain)node);
+      return;
+    }
+    if(node instanceof Plus)
+    { 
+      endVisit((Plus)node);
+      return;
+    }
+    if(node instanceof Minus)
+    { 
+      endVisit((Minus)node);
+      return;
+    }
+    if(node instanceof LeftShift)
+    { 
+      endVisit((LeftShift)node);
+      return;
+    }
+    if(node instanceof RightShift)
+    { 
+      endVisit((RightShift)node);
+      return;
+    }
+    if(node instanceof URightShift)
+    { 
+      endVisit((URightShift)node);
+      return;
+    }
+    if(node instanceof Lt)
+    { 
+      endVisit((Lt)node);
+      return;
+    }
+    if(node instanceof Gt)
+    { 
+      endVisit((Gt)node);
+      return;
+    }
+    if(node instanceof LtEq)
+    { 
+      endVisit((LtEq)node);
+      return;
+    }
+    if(node instanceof GtEq)
+    { 
+      endVisit((GtEq)node);
+      return;
+    }
+    if(node instanceof Eq)
+    { 
+      endVisit((Eq)node);
+      return;
+    }
+    if(node instanceof NotEq)
+    { 
+      endVisit((NotEq)node);
+      return;
+    }
+    if(node instanceof LazyAnd)
+    { 
+      endVisit((LazyAnd)node);
+      return;
+    }
+    if(node instanceof LazyOr)
+    { 
+      endVisit((LazyOr)node);
+      return;
+    }
+    if(node instanceof And)
+    { 
+      endVisit((And)node);
+      return;
+    }
+    if(node instanceof ExcOr)
+    { 
+      endVisit((ExcOr)node);
+      return;
+    }
+    if(node instanceof Or)
+    { 
+      endVisit((Or)node);
+      return;
+    }
+    if(node instanceof Cond)
+    { 
+      endVisit((Cond)node);
+      return;
+    }
+    if(node instanceof CondMid)
+    { 
+      endVisit((CondMid)node);
+      return;
+    }
+    if(node instanceof Assign)
+    { 
+      endVisit((Assign)node);
+      return;
+    }
+    if(node instanceof AssignMul)
+    { 
+      endVisit((AssignMul)node);
+      return;
+    }
+    if(node instanceof AssignDiv)
+    { 
+      endVisit((AssignDiv)node);
+      return;
+    }
+    if(node instanceof AssignRemain)
+    { 
+      endVisit((AssignRemain)node);
+      return;
+    }
+    if(node instanceof AssignPlus)
+    { 
+      endVisit((AssignPlus)node);
+      return;
+    }
+    if(node instanceof AssignMinus)
+    { 
+      endVisit((AssignMinus)node);
+      return;
+    }
+    if(node instanceof AssignLeftShift)
+    { 
+      endVisit((AssignLeftShift)node);
+      return;
+    }
+    if(node instanceof AssignRightShift)
+    { 
+      endVisit((AssignRightShift)node);
+      return;
+    }
+    if(node instanceof AssignURightShift)
+    { 
+      endVisit((AssignURightShift)node);
+      return;
+    }
+    if(node instanceof AssignAnd)
+    { 
+      endVisit((AssignAnd)node);
+      return;
+    }
+    if(node instanceof AssignExcOr)
+    { 
+      endVisit((AssignExcOr)node);
+      return;
+    }
+    if(node instanceof AssignOr)
+    { 
+      endVisit((AssignOr)node);
+      return;
+    }
+    if(node instanceof LHS_JavaObject1)
+    { 
+      endVisit((LHS_JavaObject1)node);
+      return;
+    }
+    if(node instanceof LHS_JavaObject0)
+    { 
+      endVisit((LHS_JavaObject0)node);
+      return;
+    }
+    if(node instanceof LHS_JavaObject)
+    { 
+      endVisit((LHS_JavaObject)node);
+      return;
+    }
+    if(node instanceof Anno)
+    { 
+      endVisit((Anno)node);
+      return;
+    }
+    if(node instanceof SingleElemAnno)
+    { 
+      endVisit((SingleElemAnno)node);
+      return;
+    }
+    if(node instanceof MarkerAnno)
+    { 
+      endVisit((MarkerAnno)node);
+      return;
+    }
+    if(node instanceof ElemValPair)
+    { 
+      endVisit((ElemValPair)node);
+      return;
+    }
+    if(node instanceof ElemVal_JavaObject0)
+    { 
+      endVisit((ElemVal_JavaObject0)node);
+      return;
+    }
+    if(node instanceof ElemVal_JavaObject)
+    { 
+      endVisit((ElemVal_JavaObject)node);
+      return;
+    }
+    if(node instanceof ElemValArrayInit0)
+    { 
+      endVisit((ElemValArrayInit0)node);
+      return;
+    }
+    if(node instanceof ElemValArrayInit)
+    { 
+      endVisit((ElemValArrayInit)node);
+      return;
+    }
+    if(node instanceof PackageDec)
+    { 
+      endVisit((PackageDec)node);
+      return;
+    }
+    if(node instanceof TypeImportDec)
+    { 
+      endVisit((TypeImportDec)node);
+      return;
+    }
+    if(node instanceof TypeImportOnDemandDec)
+    { 
+      endVisit((TypeImportOnDemandDec)node);
+      return;
+    }
+    if(node instanceof StaticImportDec)
+    { 
+      endVisit((StaticImportDec)node);
+      return;
+    }
+    if(node instanceof StaticImportOnDemandDec)
+    { 
+      endVisit((StaticImportOnDemandDec)node);
+      return;
+    }
+    if(node instanceof TypeDec_JavaObject0)
+    { 
+      endVisit((TypeDec_JavaObject0)node);
+      return;
+    }
+    if(node instanceof TypeDec_JavaObject)
+    { 
+      endVisit((TypeDec_JavaObject)node);
+      return;
+    }
+    if(node instanceof Semicolon)
+    { 
+      endVisit((Semicolon)node);
+      return;
+    }
+    if(node instanceof CompilationUnit)
+    { 
+      endVisit((CompilationUnit)node);
+      return;
+    }
+    if(node instanceof Metavar41)
+    { 
+      endVisit((Metavar41)node);
+      return;
+    }
+    if(node instanceof Metavar40)
+    { 
+      endVisit((Metavar40)node);
+      return;
+    }
+    if(node instanceof Metavar39)
+    { 
+      endVisit((Metavar39)node);
+      return;
+    }
+    if(node instanceof Metavar38)
+    { 
+      endVisit((Metavar38)node);
+      return;
+    }
+    if(node instanceof Metavar37)
+    { 
+      endVisit((Metavar37)node);
+      return;
+    }
+    if(node instanceof Metavar36)
+    { 
+      endVisit((Metavar36)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr80)
+    { 
+      endVisit((ToMetaExpr80)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr79)
+    { 
+      endVisit((ToMetaExpr79)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr78)
+    { 
+      endVisit((ToMetaExpr78)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr77)
+    { 
+      endVisit((ToMetaExpr77)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr76)
+    { 
+      endVisit((ToMetaExpr76)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr75)
+    { 
+      endVisit((ToMetaExpr75)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr74)
+    { 
+      endVisit((ToMetaExpr74)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr73)
+    { 
+      endVisit((ToMetaExpr73)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr72)
+    { 
+      endVisit((ToMetaExpr72)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr71)
+    { 
+      endVisit((ToMetaExpr71)node);
+      return;
+    }
+    if(node instanceof ToMetaListExpr7)
+    { 
+      endVisit((ToMetaListExpr7)node);
+      return;
+    }
+    if(node instanceof ToMetaListExpr6)
+    { 
+      endVisit((ToMetaListExpr6)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr70)
+    { 
+      endVisit((ToMetaExpr70)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr69)
+    { 
+      endVisit((ToMetaExpr69)node);
+      return;
+    }
+    if(node instanceof ToMetaListExpr5)
+    { 
+      endVisit((ToMetaListExpr5)node);
+      return;
+    }
+    if(node instanceof ToMetaListExpr4)
+    { 
+      endVisit((ToMetaListExpr4)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr68)
+    { 
+      endVisit((ToMetaExpr68)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr67)
+    { 
+      endVisit((ToMetaExpr67)node);
+      return;
+    }
+    if(node instanceof ToMetaListExpr3)
+    { 
+      endVisit((ToMetaListExpr3)node);
+      return;
+    }
+    if(node instanceof ToMetaListExpr2)
+    { 
+      endVisit((ToMetaListExpr2)node);
+      return;
+    }
+    if(node instanceof FromMetaExpr33)
+    { 
+      endVisit((FromMetaExpr33)node);
+      return;
+    }
+    if(node instanceof FromMetaExpr32)
+    { 
+      endVisit((FromMetaExpr32)node);
+      return;
+    }
+    if(node instanceof FromMetaExpr31)
+    { 
+      endVisit((FromMetaExpr31)node);
+      return;
+    }
+    if(node instanceof FromMetaExpr30)
+    { 
+      endVisit((FromMetaExpr30)node);
+      return;
+    }
+    if(node instanceof FromMetaExpr29)
+    { 
+      endVisit((FromMetaExpr29)node);
+      return;
+    }
+    if(node instanceof FromMetaExpr28)
+    { 
+      endVisit((FromMetaExpr28)node);
+      return;
+    }
+    if(node instanceof Metavar35)
+    { 
+      endVisit((Metavar35)node);
+      return;
+    }
+    if(node instanceof Metavar34)
+    { 
+      endVisit((Metavar34)node);
+      return;
+    }
+    if(node instanceof Metavar33)
+    { 
+      endVisit((Metavar33)node);
+      return;
+    }
+    if(node instanceof Metavar32)
+    { 
+      endVisit((Metavar32)node);
+      return;
+    }
+    if(node instanceof Metavar31)
+    { 
+      endVisit((Metavar31)node);
+      return;
+    }
+    if(node instanceof Metavar30)
+    { 
+      endVisit((Metavar30)node);
+      return;
+    }
+    if(node instanceof Metavar29)
+    { 
+      endVisit((Metavar29)node);
+      return;
+    }
+    if(node instanceof Metavar28)
+    { 
+      endVisit((Metavar28)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr66)
+    { 
+      endVisit((ToMetaExpr66)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr65)
+    { 
+      endVisit((ToMetaExpr65)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr64)
+    { 
+      endVisit((ToMetaExpr64)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr63)
+    { 
+      endVisit((ToMetaExpr63)node);
+      return;
+    }
+    if(node instanceof Metavar27)
+    { 
+      endVisit((Metavar27)node);
+      return;
+    }
+    if(node instanceof Metavar26)
+    { 
+      endVisit((Metavar26)node);
+      return;
+    }
+    if(node instanceof Metavar25)
+    { 
+      endVisit((Metavar25)node);
+      return;
+    }
+    if(node instanceof Metavar24)
+    { 
+      endVisit((Metavar24)node);
+      return;
+    }
+    if(node instanceof Metavar23)
+    { 
+      endVisit((Metavar23)node);
+      return;
+    }
+    if(node instanceof MetaTypeVar_JavaObject)
+    { 
+      endVisit((MetaTypeVar_JavaObject)node);
+      return;
+    }
+    if(node instanceof MetaPrimTypeVar_JavaObject)
+    { 
+      endVisit((MetaPrimTypeVar_JavaObject)node);
+      return;
+    }
+    if(node instanceof MetaRefTypeVar_JavaObject)
+    { 
+      endVisit((MetaRefTypeVar_JavaObject)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr62)
+    { 
+      endVisit((ToMetaExpr62)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr61)
+    { 
+      endVisit((ToMetaExpr61)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr60)
+    { 
+      endVisit((ToMetaExpr60)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr59)
+    { 
+      endVisit((ToMetaExpr59)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr58)
+    { 
+      endVisit((ToMetaExpr58)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr57)
+    { 
+      endVisit((ToMetaExpr57)node);
+      return;
+    }
+    if(node instanceof FromMetaExpr27)
+    { 
+      endVisit((FromMetaExpr27)node);
+      return;
+    }
+    if(node instanceof FromMetaExpr26)
+    { 
+      endVisit((FromMetaExpr26)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr56)
+    { 
+      endVisit((ToMetaExpr56)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr55)
+    { 
+      endVisit((ToMetaExpr55)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr54)
+    { 
+      endVisit((ToMetaExpr54)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr53)
+    { 
+      endVisit((ToMetaExpr53)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr52)
+    { 
+      endVisit((ToMetaExpr52)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr51)
+    { 
+      endVisit((ToMetaExpr51)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr50)
+    { 
+      endVisit((ToMetaExpr50)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr49)
+    { 
+      endVisit((ToMetaExpr49)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr48)
+    { 
+      endVisit((ToMetaExpr48)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr47)
+    { 
+      endVisit((ToMetaExpr47)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr46)
+    { 
+      endVisit((ToMetaExpr46)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr45)
+    { 
+      endVisit((ToMetaExpr45)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr44)
+    { 
+      endVisit((ToMetaExpr44)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr43)
+    { 
+      endVisit((ToMetaExpr43)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr42)
+    { 
+      endVisit((ToMetaExpr42)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr41)
+    { 
+      endVisit((ToMetaExpr41)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr40)
+    { 
+      endVisit((ToMetaExpr40)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr39)
+    { 
+      endVisit((ToMetaExpr39)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr38)
+    { 
+      endVisit((ToMetaExpr38)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr37)
+    { 
+      endVisit((ToMetaExpr37)node);
+      return;
+    }
+    if(node instanceof FromMetaExpr25)
+    { 
+      endVisit((FromMetaExpr25)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr36)
+    { 
+      endVisit((ToMetaExpr36)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr35)
+    { 
+      endVisit((ToMetaExpr35)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr34)
+    { 
+      endVisit((ToMetaExpr34)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr33)
+    { 
+      endVisit((ToMetaExpr33)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr32)
+    { 
+      endVisit((ToMetaExpr32)node);
+      return;
+    }
+    if(node instanceof FromMetaExpr24)
+    { 
+      endVisit((FromMetaExpr24)node);
+      return;
+    }
+    if(node instanceof FromMetaExpr23)
+    { 
+      endVisit((FromMetaExpr23)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr31)
+    { 
+      endVisit((ToMetaExpr31)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr30)
+    { 
+      endVisit((ToMetaExpr30)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr29)
+    { 
+      endVisit((ToMetaExpr29)node);
+      return;
+    }
+    if(node instanceof ToMetaListExpr1)
+    { 
+      endVisit((ToMetaListExpr1)node);
+      return;
+    }
+    if(node instanceof ToMetaListExpr0)
+    { 
+      endVisit((ToMetaListExpr0)node);
+      return;
+    }
+    if(node instanceof FromMetaExpr22)
+    { 
+      endVisit((FromMetaExpr22)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr28)
+    { 
+      endVisit((ToMetaExpr28)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr27)
+    { 
+      endVisit((ToMetaExpr27)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr26)
+    { 
+      endVisit((ToMetaExpr26)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr25)
+    { 
+      endVisit((ToMetaExpr25)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr24)
+    { 
+      endVisit((ToMetaExpr24)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr23)
+    { 
+      endVisit((ToMetaExpr23)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr22)
+    { 
+      endVisit((ToMetaExpr22)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr21)
+    { 
+      endVisit((ToMetaExpr21)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr20)
+    { 
+      endVisit((ToMetaExpr20)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr19)
+    { 
+      endVisit((ToMetaExpr19)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr18)
+    { 
+      endVisit((ToMetaExpr18)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr17)
+    { 
+      endVisit((ToMetaExpr17)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr16)
+    { 
+      endVisit((ToMetaExpr16)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr15)
+    { 
+      endVisit((ToMetaExpr15)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr14)
+    { 
+      endVisit((ToMetaExpr14)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr13)
+    { 
+      endVisit((ToMetaExpr13)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr12)
+    { 
+      endVisit((ToMetaExpr12)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr11)
+    { 
+      endVisit((ToMetaExpr11)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr10)
+    { 
+      endVisit((ToMetaExpr10)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr9)
+    { 
+      endVisit((ToMetaExpr9)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr8)
+    { 
+      endVisit((ToMetaExpr8)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr7)
+    { 
+      endVisit((ToMetaExpr7)node);
+      return;
+    }
+    if(node instanceof ToMetaListExpr)
+    { 
+      endVisit((ToMetaListExpr)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr6)
+    { 
+      endVisit((ToMetaExpr6)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr5)
+    { 
+      endVisit((ToMetaExpr5)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr4)
+    { 
+      endVisit((ToMetaExpr4)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr3)
+    { 
+      endVisit((ToMetaExpr3)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr2)
+    { 
+      endVisit((ToMetaExpr2)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr1)
+    { 
+      endVisit((ToMetaExpr1)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr0)
+    { 
+      endVisit((ToMetaExpr0)node);
+      return;
+    }
+    if(node instanceof ToMetaExpr)
+    { 
+      endVisit((ToMetaExpr)node);
+      return;
+    }
+    if(node instanceof FromMetaExpr21)
+    { 
+      endVisit((FromMetaExpr21)node);
+      return;
+    }
+    if(node instanceof FromMetaExpr20)
+    { 
+      endVisit((FromMetaExpr20)node);
+      return;
+    }
+    if(node instanceof FromMetaExpr19)
+    { 
+      endVisit((FromMetaExpr19)node);
+      return;
+    }
+    if(node instanceof FromMetaExpr18)
+    { 
+      endVisit((FromMetaExpr18)node);
+      return;
+    }
+    if(node instanceof FromMetaExpr17)
+    { 
+      endVisit((FromMetaExpr17)node);
+      return;
+    }
+    if(node instanceof FromMetaExpr16)
+    { 
+      endVisit((FromMetaExpr16)node);
+      return;
+    }
+    if(node instanceof FromMetaExpr15)
+    { 
+      endVisit((FromMetaExpr15)node);
+      return;
+    }
+    if(node instanceof FromMetaExpr14)
+    { 
+      endVisit((FromMetaExpr14)node);
+      return;
+    }
+    if(node instanceof FromMetaExpr13)
+    { 
+      endVisit((FromMetaExpr13)node);
+      return;
+    }
+    if(node instanceof FromMetaExpr12)
+    { 
+      endVisit((FromMetaExpr12)node);
+      return;
+    }
+    if(node instanceof FromMetaExpr11)
+    { 
+      endVisit((FromMetaExpr11)node);
+      return;
+    }
+    if(node instanceof FromMetaExpr10)
+    { 
+      endVisit((FromMetaExpr10)node);
+      return;
+    }
+    if(node instanceof FromMetaExpr9)
+    { 
+      endVisit((FromMetaExpr9)node);
+      return;
+    }
+    if(node instanceof FromMetaExpr8)
+    { 
+      endVisit((FromMetaExpr8)node);
+      return;
+    }
+    if(node instanceof FromMetaExpr7)
+    { 
+      endVisit((FromMetaExpr7)node);
+      return;
+    }
+    if(node instanceof FromMetaExpr6)
+    { 
+      endVisit((FromMetaExpr6)node);
+      return;
+    }
+    if(node instanceof FromMetaExpr5)
+    { 
+      endVisit((FromMetaExpr5)node);
+      return;
+    }
+    if(node instanceof FromMetaExpr4)
+    { 
+      endVisit((FromMetaExpr4)node);
+      return;
+    }
+    if(node instanceof FromMetaExpr3)
+    { 
+      endVisit((FromMetaExpr3)node);
+      return;
+    }
+    if(node instanceof FromMetaExpr2)
+    { 
+      endVisit((FromMetaExpr2)node);
+      return;
+    }
+    if(node instanceof FromMetaExpr1)
+    { 
+      endVisit((FromMetaExpr1)node);
+      return;
+    }
+    if(node instanceof Metavar22)
+    { 
+      endVisit((Metavar22)node);
+      return;
+    }
+    if(node instanceof Metavar21)
+    { 
+      endVisit((Metavar21)node);
+      return;
+    }
+    if(node instanceof Metavar20)
+    { 
+      endVisit((Metavar20)node);
+      return;
+    }
+    if(node instanceof Metavar19)
+    { 
+      endVisit((Metavar19)node);
+      return;
+    }
+    if(node instanceof Metavar18)
+    { 
+      endVisit((Metavar18)node);
+      return;
+    }
+    if(node instanceof Metavar17)
+    { 
+      endVisit((Metavar17)node);
+      return;
+    }
+    if(node instanceof Metavar16)
+    { 
+      endVisit((Metavar16)node);
+      return;
+    }
+    if(node instanceof Metavar15)
+    { 
+      endVisit((Metavar15)node);
+      return;
+    }
+    if(node instanceof Metavar14)
+    { 
+      endVisit((Metavar14)node);
+      return;
+    }
+    if(node instanceof Metavar13)
+    { 
+      endVisit((Metavar13)node);
+      return;
+    }
+    if(node instanceof Metavar12)
+    { 
+      endVisit((Metavar12)node);
+      return;
+    }
+    if(node instanceof Metavar11)
+    { 
+      endVisit((Metavar11)node);
+      return;
+    }
+    if(node instanceof Metavar10)
+    { 
+      endVisit((Metavar10)node);
+      return;
+    }
+    if(node instanceof Metavar9)
+    { 
+      endVisit((Metavar9)node);
+      return;
+    }
+    if(node instanceof Metavar8)
+    { 
+      endVisit((Metavar8)node);
+      return;
+    }
+    if(node instanceof Metavar7)
+    { 
+      endVisit((Metavar7)node);
+      return;
+    }
+    if(node instanceof Metavar6)
+    { 
+      endVisit((Metavar6)node);
+      return;
+    }
+    if(node instanceof Metavar5)
+    { 
+      endVisit((Metavar5)node);
+      return;
+    }
+    if(node instanceof Metavar4)
+    { 
+      endVisit((Metavar4)node);
+      return;
+    }
+    if(node instanceof Metavar3)
+    { 
+      endVisit((Metavar3)node);
+      return;
+    }
+    if(node instanceof Metavar2)
+    { 
+      endVisit((Metavar2)node);
+      return;
+    }
+    if(node instanceof Metavar1)
+    { 
+      endVisit((Metavar1)node);
+      return;
+    }
+    if(node instanceof Metavar0)
+    { 
+      endVisit((Metavar0)node);
+      return;
+    }
+    if(node instanceof Metavar)
+    { 
+      endVisit((Metavar)node);
+      return;
+    }
+    if(node instanceof FromMetaExpr0)
+    { 
+      endVisit((FromMetaExpr0)node);
+      return;
+    }
+    if(node instanceof FromMetaExpr)
+    { 
+      endVisit((FromMetaExpr)node);
+      return;
+    }
+    if(node instanceof ListPlusOfCommChar0)
+    { 
+      endVisit((ListPlusOfCommChar0)node);
+      return;
+    }
+    if(node instanceof ListStarOfCommChar0)
+    { 
+      endVisit((ListStarOfCommChar0)node);
+      return;
+    }
+    if(node instanceof ListPlusOfModNamePart_StrategoHost0)
+    { 
+      endVisit((ListPlusOfModNamePart_StrategoHost0)node);
+      return;
+    }
+    if(node instanceof ListStarOfModNamePart_StrategoHost0)
+    { 
+      endVisit((ListStarOfModNamePart_StrategoHost0)node);
+      return;
+    }
+    if(node instanceof ListPlusOfStrChar_StrategoHost0)
+    { 
+      endVisit((ListPlusOfStrChar_StrategoHost0)node);
+      return;
+    }
+    if(node instanceof ListStarOfStrChar_StrategoHost0)
+    { 
+      endVisit((ListStarOfStrChar_StrategoHost0)node);
+      return;
+    }
+    if(node instanceof ListPlusOfCommentPart0)
+    { 
+      endVisit((ListPlusOfCommentPart0)node);
+      return;
+    }
+    if(node instanceof ListStarOfCommentPart0)
+    { 
+      endVisit((ListStarOfCommentPart0)node);
+      return;
+    }
+    if(node instanceof OptDeciFloatExponentPart_JavaObject0)
+    { 
+      endVisit((OptDeciFloatExponentPart_JavaObject0)node);
+      return;
+    }
+    if(node instanceof OptWildcardBound_JavaObject0)
+    { 
+      endVisit((OptWildcardBound_JavaObject0)node);
+      return;
+    }
+    if(node instanceof OptTypeBound_JavaObject0)
+    { 
+      endVisit((OptTypeBound_JavaObject0)node);
+      return;
+    }
+    if(node instanceof OptId_JavaObject0)
+    { 
+      endVisit((OptId_JavaObject0)node);
+      return;
+    }
+    if(node instanceof OptExpr_JavaObject0)
+    { 
+      endVisit((OptExpr_JavaObject0)node);
+      return;
+    }
+    if(node instanceof OptConstrInv_JavaObject0)
+    { 
+      endVisit((OptConstrInv_JavaObject0)node);
+      return;
+    }
+    if(node instanceof OptEnumBodyDecs_JavaObject0)
+    { 
+      endVisit((OptEnumBodyDecs_JavaObject0)node);
+      return;
+    }
+    if(node instanceof OptEnumConstArgs_JavaObject0)
+    { 
+      endVisit((OptEnumConstArgs_JavaObject0)node);
+      return;
+    }
+    if(node instanceof Anno_JavaObject_ConstantMod_JavaObject00)
+    { 
+      endVisit((Anno_JavaObject_ConstantMod_JavaObject00)node);
+      return;
+    }
+    if(node instanceof Anno_JavaObject_ConstantMod_JavaObject0)
+    { 
+      endVisit((Anno_JavaObject_ConstantMod_JavaObject0)node);
+      return;
+    }
+    if(node instanceof Anno_JavaObject_AbstractMethodMod_JavaObject00)
+    { 
+      endVisit((Anno_JavaObject_AbstractMethodMod_JavaObject00)node);
+      return;
+    }
+    if(node instanceof Anno_JavaObject_AbstractMethodMod_JavaObject0)
+    { 
+      endVisit((Anno_JavaObject_AbstractMethodMod_JavaObject0)node);
+      return;
+    }
+    if(node instanceof OptThrows_JavaObject0)
+    { 
+      endVisit((OptThrows_JavaObject0)node);
+      return;
+    }
+    if(node instanceof OptDefaultVal_JavaObject0)
+    { 
+      endVisit((OptDefaultVal_JavaObject0)node);
+      return;
+    }
+    if(node instanceof Anno_JavaObject_InterfaceMod_JavaObject00)
+    { 
+      endVisit((Anno_JavaObject_InterfaceMod_JavaObject00)node);
+      return;
+    }
+    if(node instanceof Anno_JavaObject_InterfaceMod_JavaObject0)
+    { 
+      endVisit((Anno_JavaObject_InterfaceMod_JavaObject0)node);
+      return;
+    }
+    if(node instanceof OptExtendsInterfaces_JavaObject0)
+    { 
+      endVisit((OptExtendsInterfaces_JavaObject0)node);
+      return;
+    }
+    if(node instanceof OptTypeParams_JavaObject0)
+    { 
+      endVisit((OptTypeParams_JavaObject0)node);
+      return;
+    }
+    if(node instanceof OptSuper_JavaObject0)
+    { 
+      endVisit((OptSuper_JavaObject0)node);
+      return;
+    }
+    if(node instanceof OptInterfaces_JavaObject0)
+    { 
+      endVisit((OptInterfaces_JavaObject0)node);
+      return;
+    }
+    if(node instanceof OptTypeArgs_JavaObject00)
+    { 
+      endVisit((OptTypeArgs_JavaObject00)node);
+      return;
+    }
+    if(node instanceof OptPackageDec_JavaObject0)
+    { 
+      endVisit((OptPackageDec_JavaObject0)node);
+      return;
+    }
+    if(node instanceof Anno_JavaObject_MethodMod_JavaObject00)
+    { 
+      endVisit((Anno_JavaObject_MethodMod_JavaObject00)node);
+      return;
+    }
+    if(node instanceof Anno_JavaObject_MethodMod_JavaObject0)
+    { 
+      endVisit((Anno_JavaObject_MethodMod_JavaObject0)node);
+      return;
+    }
+    if(node instanceof Anno_JavaObject_ClassMod_JavaObject00)
+    { 
+      endVisit((Anno_JavaObject_ClassMod_JavaObject00)node);
+      return;
+    }
+    if(node instanceof Anno_JavaObject_ClassMod_JavaObject0)
+    { 
+      endVisit((Anno_JavaObject_ClassMod_JavaObject0)node);
+      return;
+    }
+    if(node instanceof Anno_JavaObject_ConstrMod_JavaObject00)
+    { 
+      endVisit((Anno_JavaObject_ConstrMod_JavaObject00)node);
+      return;
+    }
+    if(node instanceof Anno_JavaObject_ConstrMod_JavaObject0)
+    { 
+      endVisit((Anno_JavaObject_ConstrMod_JavaObject0)node);
+      return;
+    }
+    if(node instanceof Anno_JavaObject_VarMod_JavaObject00)
+    { 
+      endVisit((Anno_JavaObject_VarMod_JavaObject00)node);
+      return;
+    }
+    if(node instanceof Anno_JavaObject_VarMod_JavaObject0)
+    { 
+      endVisit((Anno_JavaObject_VarMod_JavaObject0)node);
+      return;
+    }
+    if(node instanceof Anno_JavaObject_FieldMod_JavaObject00)
+    { 
+      endVisit((Anno_JavaObject_FieldMod_JavaObject00)node);
+      return;
+    }
+    if(node instanceof Anno_JavaObject_FieldMod_JavaObject0)
+    { 
+      endVisit((Anno_JavaObject_FieldMod_JavaObject0)node);
+      return;
+    }
+    if(node instanceof OptClassBody_JavaObject0)
+    { 
+      endVisit((OptClassBody_JavaObject0)node);
+      return;
+    }
+    if(node instanceof OptTypeArgs_JavaObject0)
+    { 
+      endVisit((OptTypeArgs_JavaObject0)node);
+      return;
+    }
+    if(node instanceof WsSort)
+    { 
+      endVisit((WsSort)node);
+      return;
+    }
+    if(node instanceof ShortComSort)
+    { 
+      endVisit((ShortComSort)node);
+      return;
+    }
+    if(node instanceof LongComSort)
+    { 
+      endVisit((LongComSort)node);
+      return;
+    }
+    if(node instanceof EofSort)
+    { 
+      endVisit((EofSort)node);
+      return;
+    }
+    if(node instanceof CommCharSort)
+    { 
+      endVisit((CommCharSort)node);
+      return;
+    }
+    if(node instanceof AsteriskSort)
+    { 
+      endVisit((AsteriskSort)node);
+      return;
+    }
+    if(node instanceof ModName_StrategoHostSort)
+    { 
+      endVisit((ModName_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof ModNamePart_StrategoHostSort)
+    { 
+      endVisit((ModNamePart_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof Id_StrategoHostSort)
+    { 
+      endVisit((Id_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof LId_StrategoHostSort)
+    { 
+      endVisit((LId_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof LCID_StrategoHostSort)
+    { 
+      endVisit((LCID_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof UCID_StrategoHostSort)
+    { 
+      endVisit((UCID_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof Keyword_StrategoHostSort)
+    { 
+      endVisit((Keyword_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof Int_StrategoHostSort)
+    { 
+      endVisit((Int_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof Real_StrategoHostSort)
+    { 
+      endVisit((Real_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof String_StrategoHostSort)
+    { 
+      endVisit((String_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof StrChar_StrategoHostSort)
+    { 
+      endVisit((StrChar_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof Char_StrategoHostSort)
+    { 
+      endVisit((Char_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof CharChar_StrategoHostSort)
+    { 
+      endVisit((CharChar_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof Sdecl_StrategoHostSort)
+    { 
+      endVisit((Sdecl_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof Opdecl_StrategoHostSort)
+    { 
+      endVisit((Opdecl_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof ConstType_StrategoHostSort)
+    { 
+      endVisit((ConstType_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof FunType_StrategoHostSort)
+    { 
+      endVisit((FunType_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof ArgTypeSort)
+    { 
+      endVisit((ArgTypeSort)node);
+      return;
+    }
+    if(node instanceof ArgType_StrategoHostSort)
+    { 
+      endVisit((ArgType_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof RetType_StrategoHostSort)
+    { 
+      endVisit((RetType_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof Type_StrategoHostSort)
+    { 
+      endVisit((Type_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof SVar_StrategoHostSort)
+    { 
+      endVisit((SVar_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof StrategyParen_StrategoHostSort)
+    { 
+      endVisit((StrategyParen_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof StrategyMid_StrategoHostSort)
+    { 
+      endVisit((StrategyMid_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof Module_StrategoHostSort)
+    { 
+      endVisit((Module_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof ImportModName_StrategoHostSort)
+    { 
+      endVisit((ImportModName_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof LID_StrategoHostSort)
+    { 
+      endVisit((LID_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof Var_StrategoHostSort)
+    { 
+      endVisit((Var_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof ID_StrategoHostSort)
+    { 
+      endVisit((ID_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof PreTerm_StrategoHostSort)
+    { 
+      endVisit((PreTerm_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof Sort_StrategoHostSort)
+    { 
+      endVisit((Sort_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof Kind_StrategoHostSort)
+    { 
+      endVisit((Kind_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof StrategyDef_StrategoHostSort)
+    { 
+      endVisit((StrategyDef_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof Typedid_StrategoHostSort)
+    { 
+      endVisit((Typedid_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof StrategyAngleSort)
+    { 
+      endVisit((StrategyAngleSort)node);
+      return;
+    }
+    if(node instanceof StrategyCurly_StrategoHostSort)
+    { 
+      endVisit((StrategyCurly_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof StrategySort)
+    { 
+      endVisit((StrategySort)node);
+      return;
+    }
+    if(node instanceof SwitchCase_StrategoHostSort)
+    { 
+      endVisit((SwitchCase_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof Overlay_StrategoHostSort)
+    { 
+      endVisit((Overlay_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof RuleDef_StrategoHostSort)
+    { 
+      endVisit((RuleDef_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof Rule_StrategoHostSort)
+    { 
+      endVisit((Rule_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof Decl_StrategoHostSort)
+    { 
+      endVisit((Decl_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof Def_StrategoHostSort)
+    { 
+      endVisit((Def_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof ScopeLabels_StrategoHostSort)
+    { 
+      endVisit((ScopeLabels_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof DynRuleDef_StrategoHostSort)
+    { 
+      endVisit((DynRuleDef_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof DynRuleId_StrategoHostSort)
+    { 
+      endVisit((DynRuleId_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof DynRuleScopeId_StrategoHostSort)
+    { 
+      endVisit((DynRuleScopeId_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof RuleDec_StrategoHostSort)
+    { 
+      endVisit((RuleDec_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof RuleNames_StrategoHostSort)
+    { 
+      endVisit((RuleNames_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof Strategy_StrategoHostSort)
+    { 
+      endVisit((Strategy_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof LineTerminatorSort)
+    { 
+      endVisit((LineTerminatorSort)node);
+      return;
+    }
+    if(node instanceof CarriageReturnSort)
+    { 
+      endVisit((CarriageReturnSort)node);
+      return;
+    }
+    if(node instanceof EndOfFileSort)
+    { 
+      endVisit((EndOfFileSort)node);
+      return;
+    }
+    if(node instanceof CommentSort)
+    { 
+      endVisit((CommentSort)node);
+      return;
+    }
+    if(node instanceof EOLCommentCharsSort)
+    { 
+      endVisit((EOLCommentCharsSort)node);
+      return;
+    }
+    if(node instanceof CommentPartSort)
+    { 
+      endVisit((CommentPartSort)node);
+      return;
+    }
+    if(node instanceof BlockCommentCharsSort)
+    { 
+      endVisit((BlockCommentCharsSort)node);
+      return;
+    }
+    if(node instanceof EscEscCharSort)
+    { 
+      endVisit((EscEscCharSort)node);
+      return;
+    }
+    if(node instanceof EscCharSort)
+    { 
+      endVisit((EscCharSort)node);
+      return;
+    }
+    if(node instanceof UnicodeEscapeSort)
+    { 
+      endVisit((UnicodeEscapeSort)node);
+      return;
+    }
+    if(node instanceof Keyword_JavaObjectSort)
+    { 
+      endVisit((Keyword_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof Public_JavaObjectSort)
+    { 
+      endVisit((Public_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof Private_JavaObjectSort)
+    { 
+      endVisit((Private_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof Protected_JavaObjectSort)
+    { 
+      endVisit((Protected_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof Abstract_JavaObjectSort)
+    { 
+      endVisit((Abstract_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof Final_JavaObjectSort)
+    { 
+      endVisit((Final_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof Static_JavaObjectSort)
+    { 
+      endVisit((Static_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof Native_JavaObjectSort)
+    { 
+      endVisit((Native_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof Transient_JavaObjectSort)
+    { 
+      endVisit((Transient_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof Volatile_JavaObjectSort)
+    { 
+      endVisit((Volatile_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof Synchronized_JavaObjectSort)
+    { 
+      endVisit((Synchronized_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof StrictFP_JavaObjectSort)
+    { 
+      endVisit((StrictFP_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof Modifier_JavaObjectSort)
+    { 
+      endVisit((Modifier_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof DeciNumeral_JavaObjectSort)
+    { 
+      endVisit((DeciNumeral_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof HexaNumeral_JavaObjectSort)
+    { 
+      endVisit((HexaNumeral_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof OctaNumeral_JavaObjectSort)
+    { 
+      endVisit((OctaNumeral_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof IntLiteral_JavaObjectSort)
+    { 
+      endVisit((IntLiteral_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof DeciFloatLiteral_JavaObjectSort)
+    { 
+      endVisit((DeciFloatLiteral_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof HexaFloatLiteral_JavaObjectSort)
+    { 
+      endVisit((HexaFloatLiteral_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof DeciFloatNumeral_JavaObjectSort)
+    { 
+      endVisit((DeciFloatNumeral_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof DeciFloatDigits_JavaObjectSort)
+    { 
+      endVisit((DeciFloatDigits_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof DeciFloatExponentPart_JavaObjectSort)
+    { 
+      endVisit((DeciFloatExponentPart_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof SignedInteger_JavaObjectSort)
+    { 
+      endVisit((SignedInteger_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof HexaFloatNumeral_JavaObjectSort)
+    { 
+      endVisit((HexaFloatNumeral_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof HexaSignificand_JavaObjectSort)
+    { 
+      endVisit((HexaSignificand_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof BinaryExponent_JavaObjectSort)
+    { 
+      endVisit((BinaryExponent_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof BoolLiteral_JavaObjectSort)
+    { 
+      endVisit((BoolLiteral_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof Bool_JavaObjectSort)
+    { 
+      endVisit((Bool_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof EscapeSeq_JavaObjectSort)
+    { 
+      endVisit((EscapeSeq_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof NamedEscape_JavaObjectSort)
+    { 
+      endVisit((NamedEscape_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof OctaEscape_JavaObjectSort)
+    { 
+      endVisit((OctaEscape_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof LastOcta_JavaObjectSort)
+    { 
+      endVisit((LastOcta_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof CharContent_JavaObjectSort)
+    { 
+      endVisit((CharContent_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof StringPart_JavaObjectSort)
+    { 
+      endVisit((StringPart_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof NullLiteral_JavaObjectSort)
+    { 
+      endVisit((NullLiteral_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof NumType_JavaObjectSort)
+    { 
+      endVisit((NumType_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof IntType_JavaObjectSort)
+    { 
+      endVisit((IntType_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof FloatType_JavaObjectSort)
+    { 
+      endVisit((FloatType_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof TypeArgs_JavaObjectSort)
+    { 
+      endVisit((TypeArgs_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof ActualTypeArg_JavaObjectSort)
+    { 
+      endVisit((ActualTypeArg_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof WildcardBound_JavaObjectSort)
+    { 
+      endVisit((WildcardBound_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof TypeBound_JavaObjectSort)
+    { 
+      endVisit((TypeBound_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof TypeParams_JavaObjectSort)
+    { 
+      endVisit((TypeParams_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof TypeVarId_JavaObjectSort)
+    { 
+      endVisit((TypeVarId_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof ClassOrInterfaceType_JavaObjectSort)
+    { 
+      endVisit((ClassOrInterfaceType_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof ClassType_JavaObjectSort)
+    { 
+      endVisit((ClassType_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof InterfaceType_JavaObjectSort)
+    { 
+      endVisit((InterfaceType_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof TypeDecSpec_JavaObjectSort)
+    { 
+      endVisit((TypeDecSpec_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof TypeVar_JavaObjectSort)
+    { 
+      endVisit((TypeVar_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof ArrayType_JavaObjectSort)
+    { 
+      endVisit((ArrayType_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof Literal_JavaObjectSort)
+    { 
+      endVisit((Literal_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof ClassLiteral_JavaObjectSort)
+    { 
+      endVisit((ClassLiteral_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof ExprSort)
+    { 
+      endVisit((ExprSort)node);
+      return;
+    }
+    if(node instanceof ArrayInit_JavaObjectSort)
+    { 
+      endVisit((ArrayInit_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof FieldDec_JavaObjectSort)
+    { 
+      endVisit((FieldDec_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof VarDecId_JavaObjectSort)
+    { 
+      endVisit((VarDecId_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof Dim_JavaObjectSort)
+    { 
+      endVisit((Dim_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof VarInit_JavaObjectSort)
+    { 
+      endVisit((VarInit_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof LocalVarDecStm_JavaObjectSort)
+    { 
+      endVisit((LocalVarDecStm_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof SwitchBlock_JavaObjectSort)
+    { 
+      endVisit((SwitchBlock_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof SwitchLabel_JavaObjectSort)
+    { 
+      endVisit((SwitchLabel_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof CatchClause_JavaObjectSort)
+    { 
+      endVisit((CatchClause_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof Block_JavaObjectSort)
+    { 
+      endVisit((Block_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof MethodDec_JavaObjectSort)
+    { 
+      endVisit((MethodDec_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof MethodDecHead_JavaObjectSort)
+    { 
+      endVisit((MethodDecHead_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof ResultType_JavaObjectSort)
+    { 
+      endVisit((ResultType_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof Throws_JavaObjectSort)
+    { 
+      endVisit((Throws_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof ExceptionType_JavaObjectSort)
+    { 
+      endVisit((ExceptionType_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof MethodBody_JavaObjectSort)
+    { 
+      endVisit((MethodBody_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof InstanceInit_JavaObjectSort)
+    { 
+      endVisit((InstanceInit_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof StaticInit_JavaObjectSort)
+    { 
+      endVisit((StaticInit_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof ConstrDec_JavaObjectSort)
+    { 
+      endVisit((ConstrDec_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof ConstrHead_JavaObjectSort)
+    { 
+      endVisit((ConstrHead_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof ConstrBody_JavaObjectSort)
+    { 
+      endVisit((ConstrBody_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof ConstrInv_JavaObjectSort)
+    { 
+      endVisit((ConstrInv_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof EnumDec_JavaObjectSort)
+    { 
+      endVisit((EnumDec_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof EnumDecHead_JavaObjectSort)
+    { 
+      endVisit((EnumDecHead_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof EnumBody_JavaObjectSort)
+    { 
+      endVisit((EnumBody_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof EnumConst_JavaObjectSort)
+    { 
+      endVisit((EnumConst_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof EnumConstArgsSort)
+    { 
+      endVisit((EnumConstArgsSort)node);
+      return;
+    }
+    if(node instanceof EnumBodyDecs_JavaObjectSort)
+    { 
+      endVisit((EnumBodyDecs_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof ConstantDec_JavaObjectSort)
+    { 
+      endVisit((ConstantDec_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof ConstantMod_JavaObjectSort)
+    { 
+      endVisit((ConstantMod_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof AbstractMethodDec_JavaObjectSort)
+    { 
+      endVisit((AbstractMethodDec_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof AbstractMethodMod_JavaObjectSort)
+    { 
+      endVisit((AbstractMethodMod_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof AnnoDec_JavaObjectSort)
+    { 
+      endVisit((AnnoDec_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof AnnoDecHead_JavaObjectSort)
+    { 
+      endVisit((AnnoDecHead_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof AnnoElemDec_JavaObjectSort)
+    { 
+      endVisit((AnnoElemDec_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof DefaultVal_JavaObjectSort)
+    { 
+      endVisit((DefaultVal_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof InterfaceDec_JavaObjectSort)
+    { 
+      endVisit((InterfaceDec_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof InterfaceDecHead_JavaObjectSort)
+    { 
+      endVisit((InterfaceDecHead_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof ExtendsInterfaces_JavaObjectSort)
+    { 
+      endVisit((ExtendsInterfaces_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof InterfaceMod_JavaObjectSort)
+    { 
+      endVisit((InterfaceMod_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof ClassDec_JavaObjectSort)
+    { 
+      endVisit((ClassDec_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof ClassBody_JavaObjectSort)
+    { 
+      endVisit((ClassBody_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof ClassDecHead_JavaObjectSort)
+    { 
+      endVisit((ClassDecHead_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof Super_JavaObjectSort)
+    { 
+      endVisit((Super_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof Interfaces_JavaObjectSort)
+    { 
+      endVisit((Interfaces_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof ClassMemberDec_JavaObjectSort)
+    { 
+      endVisit((ClassMemberDec_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof ArrayCreationExpr_JavaObjectSort)
+    { 
+      endVisit((ArrayCreationExpr_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof ArrayBaseType_JavaObjectSort)
+    { 
+      endVisit((ArrayBaseType_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof DimExpr_JavaObjectSort)
+    { 
+      endVisit((DimExpr_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof FieldAccess_JavaObjectSort)
+    { 
+      endVisit((FieldAccess_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof ArrayAccess_JavaObjectSort)
+    { 
+      endVisit((ArrayAccess_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof ArraySubscriptSort)
+    { 
+      endVisit((ArraySubscriptSort)node);
+      return;
+    }
+    if(node instanceof MethodSpec_JavaObjectSort)
+    { 
+      endVisit((MethodSpec_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof CondMidSort)
+    { 
+      endVisit((CondMidSort)node);
+      return;
+    }
+    if(node instanceof Anno_JavaObjectSort)
+    { 
+      endVisit((Anno_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof ElemValPair_JavaObjectSort)
+    { 
+      endVisit((ElemValPair_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof ElemVal_JavaObjectSort)
+    { 
+      endVisit((ElemVal_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof CompilationUnit_JavaObjectSort)
+    { 
+      endVisit((CompilationUnit_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof SwitchGroup_JavaObjectSort)
+    { 
+      endVisit((SwitchGroup_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof Stm_JavaObjectSort)
+    { 
+      endVisit((Stm_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof BlockStm_JavaObjectSort)
+    { 
+      endVisit((BlockStm_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof LocalVarDec_JavaObjectSort)
+    { 
+      endVisit((LocalVarDec_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof VarDec_JavaObjectSort)
+    { 
+      endVisit((VarDec_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof LHS_JavaObjectSort)
+    { 
+      endVisit((LHS_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof PrimType_JavaObjectSort)
+    { 
+      endVisit((PrimType_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof RefType_JavaObjectSort)
+    { 
+      endVisit((RefType_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof MetaTypeVar_JavaObjectSort)
+    { 
+      endVisit((MetaTypeVar_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof MetaPrimTypeVar_JavaObjectSort)
+    { 
+      endVisit((MetaPrimTypeVar_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof MetaRefTypeVar_JavaObjectSort)
+    { 
+      endVisit((MetaRefTypeVar_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof Type_JavaObjectSort)
+    { 
+      endVisit((Type_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof PackageDec_JavaObjectSort)
+    { 
+      endVisit((PackageDec_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof OptPackageDec_JavaObject0Sort)
+    { 
+      endVisit((OptPackageDec_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof ImportDec_JavaObjectSort)
+    { 
+      endVisit((ImportDec_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof Term_StrategoHostSort)
+    { 
+      endVisit((Term_StrategoHostSort)node);
+      return;
+    }
+    if(node instanceof Name_JavaObjectSort)
+    { 
+      endVisit((Name_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof Id_JavaObjectSort)
+    { 
+      endVisit((Id_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof ID_JavaObjectSort)
+    { 
+      endVisit((ID_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof TypeParam_JavaObjectSort)
+    { 
+      endVisit((TypeParam_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof Expr_JavaObjectSort)
+    { 
+      endVisit((Expr_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof TypeDec_JavaObjectSort)
+    { 
+      endVisit((TypeDec_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof ClassBodyDec_JavaObjectSort)
+    { 
+      endVisit((ClassBodyDec_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof InterfaceMemberDec_JavaObjectSort)
+    { 
+      endVisit((InterfaceMemberDec_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof DeciLiteral_JavaObjectSort)
+    { 
+      endVisit((DeciLiteral_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof HexaLiteral_JavaObjectSort)
+    { 
+      endVisit((HexaLiteral_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof OctaLiteral_JavaObjectSort)
+    { 
+      endVisit((OctaLiteral_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof FloatLiteral_JavaObjectSort)
+    { 
+      endVisit((FloatLiteral_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof StringLiteral_JavaObjectSort)
+    { 
+      endVisit((StringLiteral_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof CharLiteral_JavaObjectSort)
+    { 
+      endVisit((CharLiteral_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof AmbName_JavaObjectSort)
+    { 
+      endVisit((AmbName_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof ExprName_JavaObjectSort)
+    { 
+      endVisit((ExprName_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof MethodName_JavaObjectSort)
+    { 
+      endVisit((MethodName_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof TypeName_JavaObjectSort)
+    { 
+      endVisit((TypeName_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof PackageOrTypeName_JavaObjectSort)
+    { 
+      endVisit((PackageOrTypeName_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof PackageName_JavaObjectSort)
+    { 
+      endVisit((PackageName_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof MethodMod_JavaObjectSort)
+    { 
+      endVisit((MethodMod_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof ClassMod_JavaObjectSort)
+    { 
+      endVisit((ClassMod_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof ConstrMod_JavaObjectSort)
+    { 
+      endVisit((ConstrMod_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof VarMod_JavaObjectSort)
+    { 
+      endVisit((VarMod_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof FieldMod_JavaObjectSort)
+    { 
+      endVisit((FieldMod_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof FormalParam_JavaObjectSort)
+    { 
+      endVisit((FormalParam_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof StringChars_JavaObjectSort)
+    { 
+      endVisit((StringChars_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof SingleChar_JavaObjectSort)
+    { 
+      endVisit((SingleChar_JavaObjectSort)node);
+      return;
+    }
+    if(node instanceof ListPlusOfCommChar0Sort)
+    { 
+      endVisit((ListPlusOfCommChar0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfCommChar0Sort)
+    { 
+      endVisit((ListStarOfCommChar0Sort)node);
+      return;
+    }
+    if(node instanceof ListPlusOfModNamePart_StrategoHost0Sort)
+    { 
+      endVisit((ListPlusOfModNamePart_StrategoHost0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfModNamePart_StrategoHost0Sort)
+    { 
+      endVisit((ListStarOfModNamePart_StrategoHost0Sort)node);
+      return;
+    }
+    if(node instanceof ListPlusOfStrChar_StrategoHost0Sort)
+    { 
+      endVisit((ListPlusOfStrChar_StrategoHost0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfStrChar_StrategoHost0Sort)
+    { 
+      endVisit((ListStarOfStrChar_StrategoHost0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfSort_StrategoHost1Sort)
+    { 
+      endVisit((ListStarOfSort_StrategoHost1Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfOpdecl_StrategoHost0Sort)
+    { 
+      endVisit((ListStarOfOpdecl_StrategoHost0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfArgType_StrategoHost0Sort)
+    { 
+      endVisit((ListStarOfArgType_StrategoHost0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfID_StrategoHost0Sort)
+    { 
+      endVisit((ListStarOfID_StrategoHost0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfDecl_StrategoHost0Sort)
+    { 
+      endVisit((ListStarOfDecl_StrategoHost0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfImportModName_StrategoHost0Sort)
+    { 
+      endVisit((ListStarOfImportModName_StrategoHost0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfSdecl_StrategoHost0Sort)
+    { 
+      endVisit((ListStarOfSdecl_StrategoHost0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfSort_StrategoHost0Sort)
+    { 
+      endVisit((ListStarOfSort_StrategoHost0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfStrategy_StrategoHost0Sort)
+    { 
+      endVisit((ListStarOfStrategy_StrategoHost0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfSwitchCase_StrategoHost0Sort)
+    { 
+      endVisit((ListStarOfSwitchCase_StrategoHost0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfDef_StrategoHost0Sort)
+    { 
+      endVisit((ListStarOfDef_StrategoHost0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfOverlay_StrategoHost0Sort)
+    { 
+      endVisit((ListStarOfOverlay_StrategoHost0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfDynRuleScopeId_StrategoHost0Sort)
+    { 
+      endVisit((ListStarOfDynRuleScopeId_StrategoHost0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfDynRuleDef_StrategoHost0Sort)
+    { 
+      endVisit((ListStarOfDynRuleDef_StrategoHost0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfTypedid_StrategoHost0Sort)
+    { 
+      endVisit((ListStarOfTypedid_StrategoHost0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfId_StrategoHost0Sort)
+    { 
+      endVisit((ListStarOfId_StrategoHost0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfCharClass1Sort)
+    { 
+      endVisit((ListStarOfCharClass1Sort)node);
+      return;
+    }
+    if(node instanceof ListPlusOfCommentPart0Sort)
+    { 
+      endVisit((ListPlusOfCommentPart0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfCommentPart0Sort)
+    { 
+      endVisit((ListStarOfCommentPart0Sort)node);
+      return;
+    }
+    if(node instanceof OptDeciFloatExponentPart_JavaObject0Sort)
+    { 
+      endVisit((OptDeciFloatExponentPart_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfStringPart_JavaObject0Sort)
+    { 
+      endVisit((ListStarOfStringPart_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfCharClass0Sort)
+    { 
+      endVisit((ListStarOfCharClass0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfId_JavaObject0Sort)
+    { 
+      endVisit((ListStarOfId_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfActualTypeArg_JavaObject0Sort)
+    { 
+      endVisit((ListStarOfActualTypeArg_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfClassOrInterfaceType_JavaObject0Sort)
+    { 
+      endVisit((ListStarOfClassOrInterfaceType_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfSwitchLabel_JavaObject0Sort)
+    { 
+      endVisit((ListStarOfSwitchLabel_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfBlockStm_JavaObject0Sort)
+    { 
+      endVisit((ListStarOfBlockStm_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfCatchClause_JavaObject0Sort)
+    { 
+      endVisit((ListStarOfCatchClause_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfExceptionType_JavaObject0Sort)
+    { 
+      endVisit((ListStarOfExceptionType_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfEnumConst_JavaObject0Sort)
+    { 
+      endVisit((ListStarOfEnumConst_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfAnno_JavaObject_ConstantMod_JavaObject0Sort)
+    { 
+      endVisit((ListStarOfAnno_JavaObject_ConstantMod_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof Anno_JavaObject_ConstantMod_JavaObject0Sort)
+    { 
+      endVisit((Anno_JavaObject_ConstantMod_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfAnno_JavaObject_AbstractMethodMod_JavaObject0Sort)
+    { 
+      endVisit((ListStarOfAnno_JavaObject_AbstractMethodMod_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof Anno_JavaObject_AbstractMethodMod_JavaObject0Sort)
+    { 
+      endVisit((Anno_JavaObject_AbstractMethodMod_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfAnnoElemDec_JavaObject0Sort)
+    { 
+      endVisit((ListStarOfAnnoElemDec_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfAbstractMethodMod_JavaObject0Sort)
+    { 
+      endVisit((ListStarOfAbstractMethodMod_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfAnno_JavaObject_InterfaceMod_JavaObject0Sort)
+    { 
+      endVisit((ListStarOfAnno_JavaObject_InterfaceMod_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof Anno_JavaObject_InterfaceMod_JavaObject0Sort)
+    { 
+      endVisit((Anno_JavaObject_InterfaceMod_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfInterfaceType_JavaObject0Sort)
+    { 
+      endVisit((ListStarOfInterfaceType_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfDimExpr_JavaObject0Sort)
+    { 
+      endVisit((ListStarOfDimExpr_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfDim_JavaObject0Sort)
+    { 
+      endVisit((ListStarOfDim_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof OptTypeArgs_JavaObject0Sort)
+    { 
+      endVisit((OptTypeArgs_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfElemValPair_JavaObject0Sort)
+    { 
+      endVisit((ListStarOfElemValPair_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfElemVal_JavaObject0Sort)
+    { 
+      endVisit((ListStarOfElemVal_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfAnno_JavaObject0Sort)
+    { 
+      endVisit((ListStarOfAnno_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfTypeDec_JavaObject0Sort)
+    { 
+      endVisit((ListStarOfTypeDec_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfVarInit_JavaObject0Sort)
+    { 
+      endVisit((ListStarOfVarInit_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfExpr_JavaObject0Sort)
+    { 
+      endVisit((ListStarOfExpr_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfSwitchGroup_JavaObject0Sort)
+    { 
+      endVisit((ListStarOfSwitchGroup_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfVarDec_JavaObject0Sort)
+    { 
+      endVisit((ListStarOfVarDec_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfImportDec_JavaObject0Sort)
+    { 
+      endVisit((ListStarOfImportDec_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfAbstractMethodDec_JavaObject0Sort)
+    { 
+      endVisit((ListStarOfAbstractMethodDec_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfTypeParam_JavaObject0Sort)
+    { 
+      endVisit((ListStarOfTypeParam_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfClassBodyDec_JavaObject0Sort)
+    { 
+      endVisit((ListStarOfClassBodyDec_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfInterfaceMemberDec_JavaObject0Sort)
+    { 
+      endVisit((ListStarOfInterfaceMemberDec_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfAnno_JavaObject_MethodMod_JavaObject0Sort)
+    { 
+      endVisit((ListStarOfAnno_JavaObject_MethodMod_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof Anno_JavaObject_MethodMod_JavaObject0Sort)
+    { 
+      endVisit((Anno_JavaObject_MethodMod_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfAnno_JavaObject_ClassMod_JavaObject0Sort)
+    { 
+      endVisit((ListStarOfAnno_JavaObject_ClassMod_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof Anno_JavaObject_ClassMod_JavaObject0Sort)
+    { 
+      endVisit((Anno_JavaObject_ClassMod_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfAnno_JavaObject_ConstrMod_JavaObject0Sort)
+    { 
+      endVisit((ListStarOfAnno_JavaObject_ConstrMod_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof Anno_JavaObject_ConstrMod_JavaObject0Sort)
+    { 
+      endVisit((Anno_JavaObject_ConstrMod_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfAnno_JavaObject_VarMod_JavaObject0Sort)
+    { 
+      endVisit((ListStarOfAnno_JavaObject_VarMod_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof Anno_JavaObject_VarMod_JavaObject0Sort)
+    { 
+      endVisit((Anno_JavaObject_VarMod_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfAnno_JavaObject_FieldMod_JavaObject0Sort)
+    { 
+      endVisit((ListStarOfAnno_JavaObject_FieldMod_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof Anno_JavaObject_FieldMod_JavaObject0Sort)
+    { 
+      endVisit((Anno_JavaObject_FieldMod_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfFormalParam_JavaObject0Sort)
+    { 
+      endVisit((ListStarOfFormalParam_JavaObject0Sort)node);
+      return;
+    }
+    if(node instanceof ListStarOfTerm_StrategoHost0Sort)
+    { 
+      endVisit((ListStarOfTerm_StrategoHost0Sort)node);
+      return;
+    }
+    if(node instanceof ASTString)
+    { 
+      endVisit((ASTString)node);
+      return;
+    }
+    if(node instanceof List)
+    { 
+      endVisit((List)node);
+      return;
+    }
+    throw new java.lang.IllegalArgumentException("Node of type " + node.getClass().getSimpleName() + "not expected.");
+  }
+}
\ No newline at end of file

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java2.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java2.java	Thu Dec 16 15:02:04 2010	(r21518)
@@ -0,0 +1,673 @@
+/*
+ * Created on 07.aug.2005
+ *
+ * Copyright (c) 2004, Karl Trygve Kalleberg <karltk near strategoxt.org>
+ * 
+ * Licensed under the GNU General Public License, v2
+ */
+package org.spoofax.interpreter.stratego;
+
+import java.util.ArrayList;
+
+import org.spoofax.DebugUtil;
+import org.spoofax.NotImplementedException;
+import org.spoofax.interpreter.core.IConstruct;
+import org.spoofax.interpreter.core.IContext;
+import org.spoofax.interpreter.core.InterpreterException;
+import org.spoofax.interpreter.core.Pair;
+import org.spoofax.interpreter.core.Tools;
+import org.spoofax.interpreter.terms.IStrategoAppl;
+import org.spoofax.interpreter.terms.IStrategoInt;
+import org.spoofax.interpreter.terms.IStrategoReal;
+import org.spoofax.interpreter.terms.IStrategoRef;
+import org.spoofax.interpreter.terms.IStrategoString;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.IStrategoList;
+import org.spoofax.interpreter.terms.IStrategoTuple;
+import static org.spoofax.interpreter.core.Tools.*;
+
+public class Match extends Strategy {
+
+    // FIXME pre-process to avoid String.equals() for Op cases
+    protected IStrategoAppl pattern;
+
+    public Match(IStrategoAppl pattern) {
+        this.pattern = pattern;
+    }
+
+    public IConstruct eval(IContext env) throws InterpreterException {
+        
+        if (DebugUtil.isDebugging()) {
+            debug("Match.eval() - ", " !", env.current(), " ; ?", pattern);
+        }
+
+        IStrategoTerm current = env.current();
+
+        Results r = match(env, current, pattern);
+
+        if (r == null) {
+            return getHook().pop().onFailure(env);
+        }
+        else {
+            boolean b = env.bindVars(r);
+            if (b)
+            	return getHook().pop().onSuccess(env);
+            else
+            	return getHook().pop().onFailure(env);
+        }
+    }
+
+    public Results matchAppl(IContext env, IStrategoAppl t,
+            IStrategoAppl p) throws InterpreterException {
+
+        if (Tools.isAnno(p, env)) {
+            return matchAnyAnno(env, t, p);
+        }
+        else if (Tools.isOp(p, env)) {
+            return matchApplOp(env, t, p);
+        }
+        else if (Tools.isInt(p, env)) {
+            return matchApplInt(env, t, p);
+        }
+        else if (Tools.isStr(p, env)) {
+            return null;
+        }
+        else if (Tools.isVar(p, env)) {
+            return matchAnyVar(t, p);
+        }
+        else if (Tools.isExplode(p, env)) {
+            return matchAnyExplode(env, t, p);
+        }
+        else if (Tools.isAs(p, env)) {
+            return matchCompoundAs(env, t, p);
+        }
+        else if (Tools.isWld(p, env)) {
+            return matchAnyWld(p);
+        }
+
+        throw new InterpreterException("Unknown Appl case '" + p + "'");
+    }
+
+    protected Results matchApplInt(IContext env, IStrategoTerm t,
+            IStrategoAppl p) throws InterpreterException {
+        if (Tools.isTermInt(t))
+            return match(env, Tools.intAt(t, 0), Tools.applAt(p, 0));
+        return null;
+    }
+
+    protected Results matchApplStr(IStrategoTerm t, IStrategoTerm p) {
+
+        throw new NotImplementedException();
+
+        //if (t.equals(p))
+        //    return emptyList();
+        //return null;
+    }
+
+    protected Results matchApplOp(IContext env, IStrategoAppl t,
+            IStrategoAppl p) throws InterpreterException {
+
+
+        String c = Tools.javaStringAt(p, 0);
+        if(c.equals("Cons")) {
+            return null; //matchApplCons(env, t, p);
+        } else if(c.equals("Nil")) {
+            return null; //matchApplNil(env, t);
+        } else if(c.equals("")) {
+            return matchApplTuple(env, t, p);
+        } 
+
+        IStrategoList ctorArgs = Tools.listAt(p, 1);
+
+        // Check if arity of the pattern matches that
+        // of the term
+        if (ctorArgs.getSubtermCount() != t.getSubtermCount())
+            return null;
+
+        // Check if the constructor name in the pattern
+        // matches that of the term
+        if (!t.getConstructor().getName().equals(c))
+            return null;
+
+        // Recursively match all arguments to term
+        Results r = emptyList();
+        for (int i = 0; i < ctorArgs.size(); i++) {
+            Results m = match(env, t.getSubterm(i),
+                              (IStrategoAppl) ctorArgs
+                              .getSubterm(i));
+            if (m != null)
+                r.addAll(m);
+            else
+                return null;
+        }
+
+        return r;
+    }
+
+//    private Results matchApplCons(IContext env, IStrategoAppl t, IStrategoAppl p) {
+//        throw new NotImplementedException();
+//    }
+//
+//    private Results matchApplNil(IContext env, IStrategoAppl t) {
+//        throw new NotImplementedException();
+//    }
+
+    private Results matchApplTuple(IContext env, IStrategoAppl t, IStrategoAppl p) throws InterpreterException {
+        String c = Tools.javaStringAt(p, 0);
+
+        // Check that the pattern p is really against a tuple 
+        if(!c.equals(""))
+            return null;
+
+        IStrategoList ctorArgs = Tools.listAt(p, 1);
+        
+        IStrategoTerm[] args = t.getArguments();
+        
+        // Check that arity of pattern equals arity of tuple
+        if(ctorArgs.size() != args.length)
+            return null;
+        
+        // Match subterms of tuple against subpatterns of pattern 
+        Results r = emptyList();
+        for (int i = 0; i < ctorArgs.size(); i++) {
+            Results m = match(env, args[i],
+                              (IStrategoAppl) ctorArgs
+                              .getSubterm(i));
+            if (m != null)
+                r.addAll(m);
+            else
+                return null;
+        }
+
+        return r;
+    }
+
+    private Results emptyList() {
+        return new Results();
+    }
+
+
+    protected Results matchInt(IContext env, IStrategoInt t,
+            IStrategoAppl p) throws InterpreterException {
+
+        if (DebugUtil.isDebugging()) {
+            debug("term is Int");
+        }
+
+        if (Tools.isAnno(p, env)) {
+            return matchAnyAnno(env, t, p);
+        }
+        else if (Tools.isInt(p, env)) {
+            return matchIntInt(t, p);
+        }
+        else if (Tools.isReal(p, env)) {
+            return null;
+        }
+        else if (Tools.isVar(p, env)) {
+            return matchAnyVar(t, p);
+        }
+        else if (Tools.isOp(p, env)) {
+            return null;
+        }
+        else if (Tools.isExplode(p, env)) {
+            return matchAnyExplode(env, t, p);
+        }
+        else if (Tools.isWld(p, env)) {
+            return matchAnyWld(p);
+        }
+        else if (Tools.isAs(p, env)) {
+            return matchCompoundAs(env, t, p);
+        } else if(Tools.isStr(p, env)) {
+            return null;
+        }
+
+        throw new InterpreterException("Unknown Int case '" + p + "'");
+    }
+
+    protected Results matchReal(IContext env, IStrategoReal t,
+            IStrategoAppl p) throws InterpreterException {
+
+        if (DebugUtil.isDebugging()) {
+            debug("term is Real");
+        }
+
+        if (Tools.isAnno(p, env)) {
+            return matchAnyAnno(env, t, p);
+        }
+        else if (Tools.isInt(p, env)) {
+            return null;
+        }
+        else if (Tools.isReal(p, env)) {
+            return matchRealReal(t, p);
+        }
+        else if (Tools.isVar(p, env)) {
+            return matchAnyVar(t, p);
+        }
+        else if (Tools.isOp(p, env)) {
+            return null;
+        }
+        else if (Tools.isExplode(p, env)) {
+            return matchAnyExplode(env, t, p);
+        }
+        else if (Tools.isWld(p, env)) {
+            return matchAnyWld(p);
+        }
+        else if (Tools.isAs(p, env)) {
+            return matchCompoundAs(env, t, p);
+        } else if (Tools.isStr(p, env)) {
+            return null;
+        }
+
+        throw new InterpreterException("Unknown Real case '" + p + "'");
+    }
+
+    private Results matchRealReal(IStrategoReal t, IStrategoAppl p) {
+
+        Double realVal = new Double(Tools.javaStringAt(p, 0));
+
+        if (realVal == t.realValue())
+            return emptyList();
+
+        return null;
+    }
+
+    private Results matchAnyWld(IStrategoAppl p) {
+        return emptyList();
+    }
+
+    protected Results matchAnyAnno(IContext env, IStrategoTerm t,
+            IStrategoAppl p) throws InterpreterException {
+        
+        Results r1 = matchList(env, t.getAnnotations(), applAt(p, 1));
+        if (r1 == null) return null;
+        
+        Results r2 = match(env, t, applAt(p, 0));
+        if (r2 == null) return null;
+        
+        r2.addAll(r1);
+        return r2;
+    }
+
+    protected Results matchIntInt(IStrategoInt t, IStrategoAppl p) {
+        Integer intVal = new Integer(Tools.javaStringAt(p, 0));
+        if (intVal == t.intValue())
+            return emptyList();
+
+        return null;
+    }
+
+    /*
+    protected Results matchAnyAs(IStrategoTerm t, IStrategoAppl p) {
+        String varName = Tools.javaStringAt(Tools.applAt(p, 0), 0);
+        return newResult(new Binding(varName, t));
+    }*/
+
+    @SuppressWarnings("serial")
+    public static final class Results extends ArrayList<Binding> {
+    }
+
+    public static final class Binding extends Pair<String, IStrategoTerm> {
+        public Binding(String first, IStrategoTerm second) {
+            super(first, second);
+        }
+    }
+
+    private Results newResult(Binding initial) {
+        Results r = new Results();
+        r.add(initial);
+        return r;
+    }
+
+    private Results matchAnyExplode(IContext env, IStrategoTerm t,
+            IStrategoAppl p) throws InterpreterException {
+
+        if(DebugUtil.isDebugging()) {
+            DebugUtil.debug("  pattern is Explode");
+        }
+        IStrategoAppl opPattern = Tools.applAt(p, 0);
+        IStrategoAppl argsPattern = Tools.applAt(p, 1);
+
+        IStrategoTerm op = getTermConstructor(env, t);
+        IStrategoTerm args = getTermArguments(env, t);
+
+        Results opResult = match(env, op, opPattern);
+        Results argsResult = match(env, args, argsPattern);
+
+        if (opResult == null || argsResult == null)
+            return null;
+
+        opResult.addAll(argsResult);
+
+        return opResult;
+    }
+
+    private IStrategoTerm getTermArguments(IContext env, IStrategoTerm t) throws InterpreterException {
+
+        switch(t.getTermType()) {
+        case IStrategoTerm.INT:
+        case IStrategoTerm.REAL:
+            return env.getFactory().makeList();
+        case IStrategoTerm.APPL:
+            IStrategoAppl a = (IStrategoAppl)t;
+            if (Tools.isNil(a, env) || Tools.isCons(a, env))
+                return t;
+            else
+                return env.getFactory().makeList(a.getArguments());
+        case IStrategoTerm.LIST: 
+            return t;
+        case IStrategoTerm.STRING:
+            return env.getFactory().makeList();
+        case IStrategoTerm.TUPLE:
+            IStrategoTuple tup = (IStrategoTuple) t;
+            IStrategoTerm[] args = new IStrategoTerm[tup.getSubtermCount()];
+            for(int i = 0; i < args.length; i++) 
+                args[i] = tup.get(i);
+            return env.getFactory().makeList(args); 
+        }
+            
+        throw new InterpreterException("Unknown term '" + t + "'");
+    }
+
+    private IStrategoTerm getTermConstructor(IContext env, IStrategoTerm t) throws InterpreterException {
+
+        if (Tools.isTermInt(t) || Tools.isTermReal(t)) {
+            return t;
+        } else if (Tools.isTermString(t)) {
+            return env.getFactory().makeString("\"" + ((IStrategoString)t).stringValue() + "\"");
+        } else if (Tools.isTermAppl(t)) {
+            IStrategoAppl a = (IStrategoAppl)t;
+            if (Tools.isCons(a, env) || Tools.isNil(a, env))
+                return env.getFactory().makeAppl(env.getStrategoSignature().getNil());
+            else
+                return env.getFactory().makeString(((IStrategoAppl)t).getConstructor().getName());
+        } else if (Tools.isTermList(t)) {
+            return env.getFactory().makeList();
+        } else if (Tools.isTermTuple(t)) {
+            return env.getFactory().makeString("");
+        }
+
+        throw new InterpreterException("Unknown term '" + t + "'");
+    }
+
+    public Results match(IContext env, IStrategoTerm t, IStrategoAppl p)
+    throws InterpreterException {
+
+    	if (t == null) {
+    	    throw new InterpreterException("Null term while matching: term library is defective");
+    	}
+        switch (t.getTermType()) {
+        case IStrategoTerm.APPL:
+            return matchAppl(env, (IStrategoAppl) t, p);
+        case IStrategoTerm.INT:
+            return matchInt(env, (IStrategoInt) t, p);
+        case IStrategoTerm.REAL:
+            return matchReal(env, (IStrategoReal) t, p);
+        case IStrategoTerm.STRING:
+            return matchString(env, (IStrategoString) t, p);
+        case IStrategoTerm.LIST:
+            return matchList(env, (IStrategoList) t, p);
+        case IStrategoTerm.TUPLE:
+            return matchTuple(env, (IStrategoTuple) t, p);
+        case IStrategoTerm.REF:
+            return matchRef(env, (IStrategoRef)t, p);
+        case IStrategoTerm.BLOB:
+            return matchBlob(env, t, p);
+        default:
+            throw new InterpreterException("Unsupported term type : "
+                                           + t.getClass().toString() + " [" + t.getTermType() + "]");
+        }
+    }
+
+    private Results matchBlob(IContext env, IStrategoTerm t, IStrategoAppl p) throws InterpreterException {
+        if (DebugUtil.isDebugging()) {
+            debug("term is Blob");
+        }
+        if (Tools.isAnno(p, env)) {
+            return matchAnyAnno(env, t, p);
+        }
+        else if (Tools.isWld(p, env)) {
+            return matchAnyWld(p);
+        }
+        else if (Tools.isAs(p, env)) {
+            return matchCompoundAs(env, t, p);
+        }
+        else if (Tools.isVar(p, env)) {
+            return matchAnyVar(t, p);
+        }
+        else if (Tools.isExplode(p, env)) {
+            return null; // FIXME: explode blobs?
+        } 
+        else if (Tools.isStr(p, env)) {
+            return null;
+        }
+        else if (Tools.isInt(p, env)) {
+            return null;
+        }
+        else if (Tools.isReal(p, env)) {
+            return null;
+        }
+        else if (Tools.isOp(p, env)) {
+            return null;
+        }
+
+        throw new InterpreterException("Unknown Tuple case '" + p + "'");
+    }
+
+    private Results matchRef(IContext env, IStrategoRef ref, IStrategoAppl p) {
+        throw new NotImplementedException();
+    }
+
+    private Results matchTuple(IContext env, IStrategoTuple t, IStrategoAppl p) throws InterpreterException {
+        if (DebugUtil.isDebugging()) {
+            debug("term is Tuple");
+        }
+        if (Tools.isAnno(p, env)) {
+            return matchAnyAnno(env, t, p);
+        }
+        else if (Tools.isInt(p, env)) {
+            return null;
+        }
+        else if (Tools.isReal(p, env)) {
+            return null;
+        }
+        else if (Tools.isVar(p, env)) {
+            return matchAnyVar(t, p);
+        }
+        else if (Tools.isOp(p, env)) {
+            return matchTupleOp(env, t, p);
+        }
+        else if (Tools.isWld(p, env)) {
+            return matchAnyWld(p);
+        }
+        else if (Tools.isAs(p, env)) {
+            return matchCompoundAs(env, t, p);
+        }
+        else if (Tools.isExplode(p, env)) {
+            return matchAnyExplode(env, t, p);
+        } 
+        else if (Tools.isStr(p, env)) {
+            return null;
+        }
+
+        throw new InterpreterException("Unknown Tuple case '" + p + "'");
+    }
+
+    private Results matchTupleOp(IContext env, IStrategoTuple t, IStrategoAppl p) throws InterpreterException {
+        
+        String c = Tools.javaStringAt(p, 0);
+
+        // Check that the pattern p is really against a tuple 
+        if(!c.equals(""))
+            return null;
+
+        IStrategoList ctorArgs = Tools.listAt(p, 1);
+        
+        // Check that arity of pattern equals arity of tuple
+        if(ctorArgs.size() != t.size())
+            return null;
+        
+        // Match subterms of tuple against subpatterns of pattern 
+        Results r = emptyList();
+        for (int i = 0; i < ctorArgs.size(); i++) {
+            Results m = match(env, t.get(i),
+                              (IStrategoAppl) ctorArgs
+                              .getSubterm(i));
+            if (m != null)
+                r.addAll(m);
+            else
+                return null;
+        }
+
+        return r;
+    }
+
+    protected Results matchList(IContext env, IStrategoList t,
+            IStrategoAppl p) throws InterpreterException {
+
+        if (DebugUtil.isDebugging()) {
+            debug("term is List");
+        }
+
+        if (Tools.isAnno(p, env)) {
+            return matchAnyAnno(env, t, p);
+        }
+        else if (Tools.isInt(p, env)) {
+            return null;
+        }
+        else if (Tools.isReal(p, env)) {
+            return null;
+        }
+        else if (Tools.isVar(p, env)) {
+            return matchAnyVar(t, p);
+        }
+        else if (Tools.isOp(p, env)) {
+            return matchListOp(env, t, p);
+        }
+        else if (Tools.isWld(p, env)) {
+            return matchAnyWld(p);
+        }
+        else if (Tools.isAs(p, env)) {
+            return matchCompoundAs(env, t, p);
+        }
+        else if (Tools.isExplode(p, env)) {
+            return matchAnyExplode(env, t, p);
+        }
+        else if (Tools.isStr(p, env)) {
+            return null;
+        }
+
+        throw new InterpreterException("Unknown List case '" + p + "'");
+    }
+
+    private Results matchCompoundAs(IContext env, IStrategoTerm t, IStrategoAppl p) throws InterpreterException {
+        
+        Results r = match(env, t, Tools.applAt(p, 1));
+
+        if (r == null)
+            return null;
+
+        if (DebugUtil.isDebugging()) {
+            debug("matching CompoundAs", p);
+        }
+
+        String varName = Tools.javaStringAt(Tools.applAt(p, 0), 0);
+        r.add(new Binding(varName, t));
+
+        return r;
+    }
+
+    private Results matchListOp(IContext env, IStrategoList t, IStrategoAppl p) throws InterpreterException {
+        
+        String c = Tools.javaStringAt(p, 0);
+
+        if(c.equals("Nil")) {
+            if(t.size() == 0)
+                return emptyList();
+        } 
+        else if(c.equals("Cons")) {
+            
+            if(t.size() < 1) {
+                return null;
+            }
+                
+            IStrategoTerm head = t.head();
+            IStrategoList tail = t.tail();
+            
+            IStrategoList pattern = Tools.listAt(p, 1);
+            
+            Results r = match(env, head, (IStrategoAppl)pattern.get(0));
+            if(r == null)
+                return null;
+            
+            Results r2 = match(env, tail, (IStrategoAppl)pattern.get(1));
+            if(r2 == null)
+                return null;
+            
+            r.addAll(r2);
+            return r;
+        }
+        
+        return null;
+    }
+
+    private Results matchAnyVar(IStrategoTerm t, IStrategoAppl p) {
+        String varName = Tools.javaStringAt(p, 0);
+        return newResult(new Binding(varName, t));
+    }
+
+    private Results matchString(IContext env, IStrategoString t, IStrategoAppl p) throws InterpreterException {
+        if (DebugUtil.isDebugging()) {
+            debug("term is String");
+        }
+        
+        if (Tools.isAnno(p, env)) {
+            return matchAnyAnno(env, t, p);
+        }
+        else if(Tools.isStr(p, env)) {
+            return matchStrStr(env, t, p);
+        }
+        else if (Tools.isInt(p, env)) {
+            return null;
+        }
+        else if (Tools.isReal(p, env)) {
+            return null;
+        }
+        else if (Tools.isVar(p, env)) {
+            return matchAnyVar(t, p);
+        }
+        else if (Tools.isOp(p, env)) {
+            return null;
+        }
+        else if (Tools.isExplode(p, env)) {
+            return matchAnyExplode(env, t, p);
+        }
+        else if (Tools.isWld(p, env)) {
+            return matchAnyWld(p);
+        }
+        else if (Tools.isAs(p, env)) {
+            return matchCompoundAs(env, t, p);
+        } 
+
+        throw new InterpreterException("Unknown String case '" + p + "'");
+    }
+
+    private Results matchStrStr(IContext env, IStrategoString t, IStrategoAppl p) {
+        if(DebugUtil.isDebugging()) {
+            DebugUtil.debug("  pattern is Str");
+        }
+        IStrategoString s = Tools.stringAt(p, 0);
+        if(s.stringValue().equals(t.stringValue())) {
+            return emptyList();
+        }
+        return null;
+    }
+
+    public void prettyPrint(StupidFormatter sf) {
+        sf.first("Match(" + pattern.toString() + ")");
+    }
+
+    @Override
+    protected String getTraceName() {
+        return super.getTraceName() + "(" + pattern + ")";
+    }
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java3.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java3.java	Thu Dec 16 15:02:04 2010	(r21518)
@@ -0,0 +1,3107 @@
+/*
+ * Created on 27. sep.. 2006
+ *
+ * Copyright (c) 2005, Karl Trygve Kalleberg <karltk at ii.uib.no>
+ * 
+ * Licensed under the GNU General Public License, v2
+ */
+package org.spoofax.interpreter.adapter.ecj;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.Writer;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.eclipse.core.resources.IFile;
+import org.eclipse.core.resources.IProject;
+import org.eclipse.jdt.core.ICompilationUnit;
+import org.eclipse.jdt.core.IField;
+import org.eclipse.jdt.core.IJavaElement;
+import org.eclipse.jdt.core.IJavaProject;
+import org.eclipse.jdt.core.IType;
+import org.eclipse.jdt.core.ITypeHierarchy;
+import org.eclipse.jdt.core.ITypeParameter;
+import org.eclipse.jdt.core.dom.*;
+import org.eclipse.jdt.core.dom.InfixExpression.Operator;
+import org.eclipse.jdt.core.dom.Modifier.ModifierKeyword;
+import org.eclipse.jdt.core.dom.PrimitiveType.Code;
+import org.spoofax.DebugUtil;
+import org.spoofax.NotImplementedException;
+import org.spoofax.interpreter.terms.BasicStrategoArrayList;
+import org.spoofax.interpreter.terms.IStrategoAppl;
+import org.spoofax.interpreter.terms.IStrategoConstructor;
+import org.spoofax.interpreter.terms.IStrategoInt;
+import org.spoofax.interpreter.terms.IStrategoList;
+import org.spoofax.interpreter.terms.IStrategoPlaceholder;
+import org.spoofax.interpreter.terms.IStrategoReal;
+import org.spoofax.interpreter.terms.IStrategoString;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.IStrategoTuple;
+import org.spoofax.interpreter.terms.ITermFactory;
+import org.spoofax.interpreter.terms.ITermPrinter;
+import org.spoofax.interpreter.terms.InlinePrinter;
+
+public class ECJFactory implements ITermFactory {
+
+    private static final int ARRAY_ACCESS = 1;
+    private static final int PACKAGE_DECLARATION = 2;
+    private static final int NONE = 3;
+    private static final int BOOLEAN_LITERAL = 4;
+    private static final int BOOLEAN_TYPE = 5;
+    private static final int BREAK_STATEMENT = 6;
+    private static final int CATCH_CLAUSE = 7;
+    private static final int CHARACTER_LITERAL = 8;
+    private static final int CLASS_INSTANCE_CREATION = 9;
+    private static final int ANNOTATION_TYPE_DECLARATION = 10;
+    private static final int ENUM_DECLARATION = 11;
+    private static final int TYPE_DECLARATION = 12;
+    private static final int ANNOTATION_TYPE_MEMBER_DECLARATION = 13;
+    private static final int ENUM_CONSTANT_DECLARATION = 14;
+    private static final int FIELD_DECLARATION = 15;
+    private static final int INITIALIZER = 16;
+    private static final int METHOD_DECLARATION = 17;
+    private static final int BLOCK_COMMENT = 18;
+    private static final int JAVADOC = 19;
+    private static final int LINE_COMMENT = 20;
+    private static final int COMPILATION_UNIT = 21;
+    private static final int MARKER_ANNOTATION = 22;
+    private static final int NORMAL_ANNOTATION = 23;
+    private static final int SINGLE_MEMBER_ANNOTATION = 24;
+    private static final int ARRAY_CREATION = 25;
+    private static final int ARRAY_INITIALIZER = 26;
+    private static final int ASSIGNMENT = 27;
+    private static final int CAST_EXPRESSION = 28;
+    private static final int CONDITIONAL_EXPRESSION = 29;
+    private static final int FIELD_ACCESS = 30;
+    private static final int INFIX_EXPRESSION = 31;
+    private static final int INSTANCEOF_EXPRESSION = 32;
+    private static final int METHOD_INVOCATION = 33;
+    private static final int QUALIFIED_NAME = 34;
+    private static final int SIMPLE_NAME = 35;
+    private static final int NULL_LITERAL = 36;
+    private static final int NUMBER_LITERAL = 37;
+    private static final int PARENTHESIZED_EXPRESSION = 38;
+    private static final int POSTFIX_EXPRESSION = 39;
+    private static final int PREFIX_EXPRESSION = 40;
+    private static final int STRING_LITERAL = 41;
+    private static final int SUPER_FIELD_ACCESS = 42;
+    private static final int THIS_EXPRESSION = 43;
+    private static final int VARIABLE_DECLARATION_EXPRESSION = 44;
+    private static final int IMPORT_DECLARATION = 45;
+    private static final int MEMBER_REF = 46;
+    private static final int MEMBER_VALUE_PAIR = 47;
+    private static final int METHOD_REF = 48;
+    private static final int METHOD_REF_PARAMETER = 49;
+    private static final int MODIFIER = 50;
+    private static final int MODIFIER_KEYWORD = 51;
+    private static final int POSTFIX_EXPRESSION_OPERATOR = 52;
+    private static final int PREFIX_EXPRESSION_OPERATOR = 53;
+    private static final int ASSERT_STATEMENT = 54;
+    private static final int BLOCK = 55;
+    private static final int CONSTRUCTOR_INVOCATION = 56;
+    private static final int CONTINUE_STATEMENT = 57;
+    private static final int DO_STATEMENT = 58;
+    private static final int EMPTY_STATEMENT = 59;
+    private static final int ENHANCED_FOR_STATEMENT = 60;
+    private static final int EXPRESSION_STATEMENT = 61;
+    private static final int FOR_STATEMENT = 62;
+    private static final int IF_STATEMENT = 63;
+    private static final int LABELED_STATEMENT = 64;
+    private static final int RETURN_STATEMENT = 65;
+    private static final int SUPER_CONSTRUCTOR_INVOCATION = 66;
+    private static final int SWITCH_CASE = 67;
+    private static final int SWITCH_STATEMENT = 68;
+    private static final int SYNCHRONIZED_STATEMENT = 69;
+    private static final int THROW_STATEMENT = 70;
+    private static final int TRY_STATEMENT = 71;
+    private static final int TYPE_DECLARATION_STATEMENT = 72;
+    private static final int TYPE_LITERAL = 73;
+    private static final int VARIABLE_DECLARATION_STATEMENT = 74;
+    private static final int WHILE_STATEMENT = 75;
+    private static final int SUPER_METHOD_INVOCATION = 76;
+    private static final int TAG_ELEMENT = 77;
+    private static final int TEXT_ELEMENT = 78;
+    private static final int ARRAY_TYPE = 79;
+    private static final int DOUBLE_TYPE = 80;
+    private static final int FLOAT_TYPE = 81;
+    private static final int INT_TYPE = 82;
+    private static final int LONG_TYPE = 83;
+    private static final int PARAMETERIZED_TYPE = 84;
+    private static final int PRIMITIVE_TYPE = 85;
+    private static final int QUALIFIED_TYPE = 86;
+    private static final int SIMPLE_TYPE = 87;
+    private static final int WILDCARD_TYPE = 88;
+    private static final int TYPE_PARAMETER = 89;
+    private static final int SINGLE_VARIABLE_DECLARATION = 90;
+    private static final int VARIABLE_DECLARATION_FRAGMENT = 91;
+    private static final int BYTE_TYPE = 92;
+    private static final int IMPORT_REFERENCE = 93;
+    private static final int ANONYMOUS_CLASS_DECLARATION = 94;
+    private static final int ASSIGNMENT_OPERATOR = 95;
+	private static ASTMatcher astMatcher;
+        
+    private Map<String,Integer> ctorNameToIndexMap;
+    private AST ast;
+    
+    public ECJFactory(AST ast) {
+        this.ast = ast;
+        initCtorMap();
+    }
+    
+    public ECJFactory() {
+        initCtorMap();
+    }
+    
+    private void initCtorMap() {
+        ctorNameToIndexMap = new HashMap<String,Integer>();
+        ctorNameToIndexMap.put("ArrayAccess", ARRAY_ACCESS);
+        ctorNameToIndexMap.put("PackageDeclaration", PACKAGE_DECLARATION);
+        ctorNameToIndexMap.put("BooleanLiteral", BOOLEAN_LITERAL);
+        ctorNameToIndexMap.put("BooleanType", BOOLEAN_TYPE);
+        ctorNameToIndexMap.put("ByteType", BYTE_TYPE);
+        ctorNameToIndexMap.put("BreakStatement", BREAK_STATEMENT);
+        ctorNameToIndexMap.put("CatchClause", CATCH_CLAUSE);
+        ctorNameToIndexMap.put("CharacterLiteral", CHARACTER_LITERAL);
+        ctorNameToIndexMap.put("ClassInstanceCreation", CLASS_INSTANCE_CREATION);
+        ctorNameToIndexMap.put("AnnotationTypeDeclaration", ANNOTATION_TYPE_DECLARATION);
+        ctorNameToIndexMap.put("EnumDeclaration", ENUM_DECLARATION);
+        ctorNameToIndexMap.put("TypeDeclaration", TYPE_DECLARATION);
+        ctorNameToIndexMap.put("AnnotationTypeMemberDeclaration", ANNOTATION_TYPE_MEMBER_DECLARATION);
+        ctorNameToIndexMap.put("EnumConstantDeclaration", ENUM_CONSTANT_DECLARATION);
+        ctorNameToIndexMap.put("FieldDeclaration", FIELD_DECLARATION);
+        ctorNameToIndexMap.put("Initializer", INITIALIZER);
+        ctorNameToIndexMap.put("MethodDeclaration", METHOD_DECLARATION);
+        ctorNameToIndexMap.put("BlockComment", BLOCK_COMMENT);
+        ctorNameToIndexMap.put("Javadoc", JAVADOC);
+        ctorNameToIndexMap.put("LineComment", LINE_COMMENT);
+        ctorNameToIndexMap.put("CompilationUnit", COMPILATION_UNIT);
+        ctorNameToIndexMap.put("MarkerAnnotation", MARKER_ANNOTATION);
+        ctorNameToIndexMap.put("NormalAnnotation", NORMAL_ANNOTATION);
+        ctorNameToIndexMap.put("SingleMemberAnnotation", SINGLE_MEMBER_ANNOTATION);
+        ctorNameToIndexMap.put("ArrayCreation", ARRAY_CREATION);
+        ctorNameToIndexMap.put("ArrayInitializer", ARRAY_INITIALIZER);
+        ctorNameToIndexMap.put("Assignment", ASSIGNMENT);
+        ctorNameToIndexMap.put("CastExpression", CAST_EXPRESSION);
+        ctorNameToIndexMap.put("ConditionalExpression", CONDITIONAL_EXPRESSION);
+        ctorNameToIndexMap.put("FieldAccess", FIELD_ACCESS);
+        ctorNameToIndexMap.put("InfixExpression", INFIX_EXPRESSION);
+        ctorNameToIndexMap.put("InstanceofExpression", INSTANCEOF_EXPRESSION);
+        ctorNameToIndexMap.put("MethodInvocation", METHOD_INVOCATION);
+        ctorNameToIndexMap.put("QualifiedName", QUALIFIED_NAME);
+        ctorNameToIndexMap.put("SimpleName", SIMPLE_NAME);
+        ctorNameToIndexMap.put("NullLiteral", NULL_LITERAL);
+        ctorNameToIndexMap.put("NumberLiteral", NUMBER_LITERAL);
+        ctorNameToIndexMap.put("ParenthesizedExpression", PARENTHESIZED_EXPRESSION);
+        ctorNameToIndexMap.put("PostfixExpression", POSTFIX_EXPRESSION);
+        ctorNameToIndexMap.put("PrefixExpression", PREFIX_EXPRESSION);
+        ctorNameToIndexMap.put("StringLiteral", STRING_LITERAL);
+        ctorNameToIndexMap.put("SuperFieldAccess", SUPER_FIELD_ACCESS);
+        ctorNameToIndexMap.put("ThisExpression", THIS_EXPRESSION);
+        ctorNameToIndexMap.put("VariableDeclarationExpression", VARIABLE_DECLARATION_EXPRESSION);
+        ctorNameToIndexMap.put("ImportDeclaration", IMPORT_DECLARATION);
+        ctorNameToIndexMap.put("MemberRef", MEMBER_REF);
+        ctorNameToIndexMap.put("MemberValuePair", MEMBER_VALUE_PAIR);
+        ctorNameToIndexMap.put("MethodRef", METHOD_REF);
+        ctorNameToIndexMap.put("MethodRefParameter", METHOD_REF_PARAMETER);
+        ctorNameToIndexMap.put("Modifier", MODIFIER);
+        ctorNameToIndexMap.put("ModifierKeyword", MODIFIER_KEYWORD);
+        ctorNameToIndexMap.put("PackageDeclaration", PACKAGE_DECLARATION);
+        ctorNameToIndexMap.put("PostfixExpressionOperator", POSTFIX_EXPRESSION_OPERATOR);
+        ctorNameToIndexMap.put("PrefixExpressionOperator", PREFIX_EXPRESSION_OPERATOR);
+        ctorNameToIndexMap.put("AssertStatement", ASSERT_STATEMENT);
+        ctorNameToIndexMap.put("Block", BLOCK);
+        ctorNameToIndexMap.put("ConstructorInvocation", CONSTRUCTOR_INVOCATION);
+        ctorNameToIndexMap.put("ContinueStatement", CONTINUE_STATEMENT);
+        ctorNameToIndexMap.put("DoStatement", DO_STATEMENT);
+        ctorNameToIndexMap.put("EmptyStatement", EMPTY_STATEMENT);
+        ctorNameToIndexMap.put("EnhancedForStatement", ENHANCED_FOR_STATEMENT);
+        ctorNameToIndexMap.put("ExpressionStatement", EXPRESSION_STATEMENT);
+        ctorNameToIndexMap.put("ForStatement", FOR_STATEMENT);
+        ctorNameToIndexMap.put("IfStatement", IF_STATEMENT);
+        ctorNameToIndexMap.put("LabeledStatement", LABELED_STATEMENT);
+        ctorNameToIndexMap.put("ReturnStatement", RETURN_STATEMENT);
+        ctorNameToIndexMap.put("SuperConstructorInvocation", SUPER_CONSTRUCTOR_INVOCATION);
+        ctorNameToIndexMap.put("SwitchCase", SWITCH_CASE);
+        ctorNameToIndexMap.put("SwitchStatement", SWITCH_STATEMENT);
+        ctorNameToIndexMap.put("SynchronizedStatement", SYNCHRONIZED_STATEMENT);
+        ctorNameToIndexMap.put("ThrowStatement", THROW_STATEMENT);
+        ctorNameToIndexMap.put("TryStatement", TRY_STATEMENT);
+        ctorNameToIndexMap.put("TypeDeclarationStatement", TYPE_DECLARATION_STATEMENT);
+        ctorNameToIndexMap.put("TypeLiteral", TYPE_LITERAL);
+        ctorNameToIndexMap.put("VariableDeclarationStatement", VARIABLE_DECLARATION_STATEMENT);
+        ctorNameToIndexMap.put("WhileStatement", WHILE_STATEMENT);
+        ctorNameToIndexMap.put("SuperMethodInvocation", SUPER_METHOD_INVOCATION);
+        ctorNameToIndexMap.put("TagElement", TAG_ELEMENT);
+        ctorNameToIndexMap.put("TextElement", TEXT_ELEMENT);
+        ctorNameToIndexMap.put("ArrayType", ARRAY_TYPE);
+        ctorNameToIndexMap.put("DoubleType", DOUBLE_TYPE);
+        ctorNameToIndexMap.put("FloatType", FLOAT_TYPE);
+        ctorNameToIndexMap.put("IntType", INT_TYPE);
+        ctorNameToIndexMap.put("LongType", LONG_TYPE);
+        ctorNameToIndexMap.put("ParameterizedType", PARAMETERIZED_TYPE);
+        ctorNameToIndexMap.put("PrimitiveType", PRIMITIVE_TYPE);
+        ctorNameToIndexMap.put("QualifiedType", QUALIFIED_TYPE);
+        ctorNameToIndexMap.put("SimpleType", SIMPLE_TYPE);
+        ctorNameToIndexMap.put("WildcardType", WILDCARD_TYPE);
+        ctorNameToIndexMap.put("TypeParameter", TYPE_PARAMETER);
+        ctorNameToIndexMap.put("SingleVariableDeclaration", SINGLE_VARIABLE_DECLARATION);
+        ctorNameToIndexMap.put("VariableDeclarationFragment", VARIABLE_DECLARATION_FRAGMENT);
+        ctorNameToIndexMap.put("None", NONE);
+        ctorNameToIndexMap.put("ImportReference", IMPORT_REFERENCE);
+        ctorNameToIndexMap.put("AnonymousClassDeclaration", ANONYMOUS_CLASS_DECLARATION);
+        ctorNameToIndexMap.put("AssignmentOperator", ASSIGNMENT_OPERATOR);
+    }
+    
+    public IStrategoTerm parseFromFile(String path) throws IOException {
+        throw new NotImplementedException();
+    }
+
+    public IStrategoTerm parseFromStream(InputStream inputStream) throws IOException {
+        throw new NotImplementedException();
+    }
+
+    public IStrategoTerm parseFromString(String text) {
+        if(text.equals("()")) {
+            return makeTuple();
+        } else if(text.charAt(0) == '"') {
+            return makeString(text.substring(1).substring(0, text.length() - 2));
+        }
+        throw new NotImplementedException();
+    }
+
+    public void unparseToFile(IStrategoTerm t, OutputStream ous) throws IOException {
+        InlinePrinter pp = new InlinePrinter();
+        t.prettyPrint(pp);
+        ous.write(pp.getString().getBytes());
+    }
+
+    public void unparseToFile(IStrategoTerm t, Writer out) throws IOException {
+        ITermPrinter tp = new InlinePrinter();
+        t.prettyPrint(tp);
+        out.write(tp.getString());
+    }
+
+    public boolean hasConstructor(String s, int i) {
+    	// FIXME also check generic factory
+    	return ctorNameToIndexMap.containsKey(s);
+    }
+
+    private List<ASTNode> getAnnotations(IStrategoTerm term) {
+        return ((WrappedASTNodeList)term).getWrappee();
+    }
+
+    private Javadoc getJavadoc(IStrategoTerm term) {
+        return ((WrappedJavadoc)term).getWrappee();
+    }
+    
+    public IStrategoPlaceholder makePlaceholder(IStrategoTerm template) {
+        throw new NotImplementedException();
+    }
+
+    @Deprecated
+    public IStrategoAppl makeAppl(IStrategoConstructor ctr, IStrategoList terms) {
+        return makeAppl(ctr, terms.getAllSubterms());
+    }
+    
+    public IStrategoTerm annotateTerm(IStrategoTerm term, IStrategoList annotations) {
+    	if(term instanceof ECJAnnoWrapper) {
+    		return new ECJAnnoWrapper(((ECJAnnoWrapper)term).getWrappee(), annotations);
+    	} else {
+    		return new ECJAnnoWrapper(term, annotations);
+    	}
+    }
+
+    public IStrategoAppl makeAppl(IStrategoConstructor ctr, IStrategoTerm... kids) {
+        IStrategoAppl t = constructASTNode(ctr, kids);
+        if(t == null) {
+            if(DebugUtil.isDebugging()) {
+                System.err.println("Generic fallback for:");
+                System.err.println("Construct: " + ctr.getName() + "/" + ctr.getArity() + " with " + kids.length + " kids");
+                for(int i = 0; i < kids.length; i++) {
+                    if(kids[i] instanceof WrappedASTNodeList) {
+                        WrappedASTNodeList l = (WrappedASTNodeList)kids[i];
+                        if(!l.isEmpty()) 
+                            System.err.println("  [" + l.get(0) + "]");
+                        else
+                            System.err.println("  " + l + " - empty");
+                    } else
+                        System.err.println("  " + kids[i]);
+                }
+            }
+            return ctr.instantiate(this, kids);
+        }
+        return t;
+    }
+
+    @SuppressWarnings("unchecked")
+    private IStrategoAppl constructASTNode(IStrategoConstructor ctr, IStrategoTerm[] kids) {
+        int index = ctorNameToIndex(ctr);
+        switch(index) {
+        case ANNOTATION_TYPE_DECLARATION: {
+            if((!isJavadoc(kids[0]) && !isNone(kids[0]))
+                    || !isExtendedModifierList(kids[1]) 
+                    || !isSimpleName(kids[2]) 
+                    || !isBodyDeclarationList(kids[3]))
+                return null;
+            AnnotationTypeDeclaration x = ast.newAnnotationTypeDeclaration();
+            if(isNone(kids[0]))
+                x.setJavadoc(null);
+            else
+                x.setJavadoc(asJavadoc(kids[0]));
+            x.modifiers().addAll(asExtendedModifierList(kids[1]));
+            x.setName(asSimpleName(kids[2]));
+            x.bodyDeclarations().addAll(asBodyDeclarationList(kids[3]));
+            return wrap(x);
+        }
+        case ANNOTATION_TYPE_MEMBER_DECLARATION: {
+            if((!isJavadoc(kids[0]) && !isNone(kids[0]))
+                    || !isModifierList(kids[1]) 
+                    || !isType(kids[2]) 
+                    || !isSimpleName(kids[3]) 
+                    || (!isExpression(kids[4]) && !isNone(kids[4])))
+                return null;
+            AnnotationTypeMemberDeclaration x = ast.newAnnotationTypeMemberDeclaration();
+            x.setJavadoc(asJavadoc(kids[0]));
+            x.modifiers().addAll(asModifierList(kids[1]));
+            x.setType(asType(kids[2]));
+            x.setName(asSimpleName(kids[3]));
+            if(isNone(kids[4]))
+                x.setDefault(null);
+            else
+                x.setDefault(asExpression(kids[4]));
+            return wrap(x);
+        }
+        case ANONYMOUS_CLASS_DECLARATION: {
+            if(!isBodyDeclarationList(kids[0]))
+                return null;
+            AnonymousClassDeclaration x = ast.newAnonymousClassDeclaration();
+            x.bodyDeclarations().addAll(asBodyDeclarationList(kids[0]));
+            return wrap(x);
+        }
+        case ARRAY_ACCESS: { 
+            if(!isExpression(kids[0]) || !isExpression(kids[1]))
+                return null;
+            ArrayAccess x = ast.newArrayAccess();
+            x.setArray(asExpression(kids[0]));
+            x.setIndex(asExpression(kids[1]));
+            return wrap(x);
+        }
+        case ARRAY_CREATION: {
+            if(!isArrayType(kids[0]) 
+                    || !isExpressionList(kids[1]) 
+                    || (!isArrayInitializer(kids[2]) && !isNone(kids[2])))
+                return null;
+            ArrayCreation x = ast.newArrayCreation();
+            x.setType(asArrayType(kids[0]));
+            x.dimensions().addAll(asExpressionList(kids[1]));
+            if(isNone(kids[2]))
+                x.setInitializer(null);
+            else
+                x.setInitializer(asArrayInitializer(kids[2]));
+            return wrap(x);
+        }
+        case ARRAY_INITIALIZER: {
+            if(!isExpressionList(kids[0]))
+                return null;
+            ArrayInitializer x = ast.newArrayInitializer();
+            x.expressions().addAll(asExpressionList(kids[0]));
+            return wrap(x);
+        }
+        case ARRAY_TYPE: {
+            if(!isType(kids[0]) 
+                    || !isInt(kids[1]) 
+                    || !isType(kids[2]))
+                return null;
+            ArrayType x = ast.newArrayType(asType(kids[2]), asInt(kids[1]));
+            x.setComponentType(asType(kids[0]));
+            return wrap(x);
+        }
+        case ASSERT_STATEMENT: {
+            if(!isExpression(kids[0]) || !(isExpression(kids[1]) || isNone(kids[1])))
+                return null;
+            AssertStatement x = ast.newAssertStatement();
+            x.setExpression(asExpression(kids[0]));
+            if(isNone(kids[1]))
+            	x.setMessage(null);
+            else 
+            	x.setMessage(asExpression(kids[1]));
+            return wrap(x);
+        }
+        case ASSIGNMENT: {
+            if(!isAssignmentOperator(kids[0])
+            		|| !isExpression(kids[1]) 
+            		|| !isExpression(kids[2]))
+                return null;
+            Assignment x = ast.newAssignment();
+            x.setOperator(asAssignmentOperator(kids[0]));
+            x.setLeftHandSide(asExpression(kids[1]));
+            x.setRightHandSide(asExpression(kids[2]));
+            return wrap(x);
+        }
+        case ASSIGNMENT_OPERATOR: {
+            if(!isString(kids[0]))
+                return null;
+            return wrap(Assignment.Operator.toOperator(asString(kids[0])));
+        }
+        case BLOCK: {
+            if(!isStatementList(kids[0]))
+                return null;
+            Block x = ast.newBlock();
+            x.statements().addAll(asStatementList(kids[0]));
+            return wrap(x);
+        }
+        case BLOCK_COMMENT: {
+            BlockComment x = ast.newBlockComment();
+            return wrap(x);
+        }
+        case BOOLEAN_LITERAL: {
+            if(!isInt(kids[0]))
+                return null;
+            return wrap(ast.newBooleanLiteral(asInt(kids[0]) == 1));
+        }
+        case BOOLEAN_TYPE: {
+            return wrap(ast.newPrimitiveType(PrimitiveType.BOOLEAN));
+        }
+        case BREAK_STATEMENT: {
+            if(!isSimpleName(kids[0]) && !isNone(kids[0]))
+                return null;
+            BreakStatement x = ast.newBreakStatement();
+            if(isNone(kids[0]))
+                x.setLabel(null);
+            else
+                x.setLabel(asSimpleName(kids[0]));
+            return wrap(x);
+        }
+        case BYTE_TYPE: {
+            return wrap(ast.newPrimitiveType(PrimitiveType.BYTE));
+        }
+        case CAST_EXPRESSION: {
+            if(!isType(kids[0]) || !isExpression(kids[1]))
+                return null;
+            CastExpression x = ast.newCastExpression();
+            x.setType(asType(kids[0]));
+            x.setExpression(asExpression(kids[1]));
+            return wrap(x);
+        }
+        case CATCH_CLAUSE: {
+            if(!isSingleVariableDeclaration(kids[0]) || !isBlock(kids[1]))
+                return null;
+            CatchClause x = ast.newCatchClause();
+            x.setException(asSingleVariableDeclaration(kids[0]));
+            x.setBody(asBlock(kids[1]));
+            return wrap(x);
+        }
+        case CHARACTER_LITERAL: {
+            if(!isInt(kids[0]))
+                return null;
+            CharacterLiteral x = ast.newCharacterLiteral();
+            x.setCharValue((char)asInt(kids[0]));
+            return wrap(x);
+        }
+        case CLASS_INSTANCE_CREATION: {
+            if((!isExpression(kids[0]) && !isNone(kids[0])) 
+                    || !isType(kids[1]) 
+                    || (!isAnonymousClassDeclaration(kids[2]) && !isNone(kids[2]))  
+                    || !isExpressionList(kids[3]))
+                return null;
+            ClassInstanceCreation x = ast.newClassInstanceCreation();
+            if(isNone(kids[0])) 
+                x.setExpression(null);
+            else 
+                x.setExpression(asExpression(kids[0]));
+            x.setType(asType(kids[1]));
+            if(isNone(kids[2]))
+                x.setAnonymousClassDeclaration(null);
+            else
+                x.setAnonymousClassDeclaration(asAnonymousClassDeclaration(kids[2]));
+            x.arguments().addAll(asExpressionList(kids[3]));
+            return wrap(x);
+        }
+        case COMPILATION_UNIT: {
+            if((!isPackageDeclaration(kids[0]) && !isNone(kids[0])) 
+                    || !isImportDeclarationList(kids[1]) 
+                    || !isAbstractTypeDeclarationList(kids[2]))
+                return null;
+            CompilationUnit x = ast.newCompilationUnit();
+            if(isNone(kids[0]))
+                x.setPackage(null);
+            else 
+                x.setPackage(asPackageDeclaration(kids[0]));
+            x.imports().addAll(asImportDeclarationList(kids[1]));
+            x.types().addAll(asAbstractTypeDeclarationList(kids[2]));
+            return wrap(x);
+        }
+        case CONDITIONAL_EXPRESSION: {
+            if(!isExpression(kids[0]) 
+                    || !isExpression(kids[1]) 
+                    || !isExpression(kids[2]))
+                return null;
+            ConditionalExpression x = ast.newConditionalExpression();
+            x.setExpression(asExpression(kids[0]));
+            x.setThenExpression(asExpression(kids[1]));
+            x.setElseExpression(asExpression(kids[2]));
+            return wrap(x);
+        }
+        case CONSTRUCTOR_INVOCATION: {
+            if(!isExpressionList(kids[0]))
+                return null;
+            ConstructorInvocation x = ast.newConstructorInvocation();
+            x.arguments().addAll(asExpressionList(kids[0]));
+            return wrap(x);
+        }
+        case CONTINUE_STATEMENT: {
+            if(!isSimpleName(kids[0]) && !isNone(kids[0]))
+                return null;
+            ContinueStatement x = ast.newContinueStatement();
+            if(isNone(kids[0]))
+                x.setLabel(null);
+            else
+                x.setLabel(asSimpleName(kids[0]));
+            return wrap(x);
+        }
+        case DO_STATEMENT: {
+            DoStatement x = ast.newDoStatement();
+            x.setExpression(asExpression(kids[0]));
+            x.setBody(asStatement(kids[1]));
+            return wrap(x);
+        }
+        case DOUBLE_TYPE: {
+            return wrap(ast.newPrimitiveType(PrimitiveType.DOUBLE));
+        }
+        case EMPTY_STATEMENT: {
+            return wrap(ast.newEmptyStatement());
+        }
+        case ENHANCED_FOR_STATEMENT: {
+            if(!isSingleVariableDeclaration(kids[0]) 
+                    || !isExpression(kids[1])
+                    || !isStatement(kids[2]))
+                return null;
+            EnhancedForStatement x = ast.newEnhancedForStatement();
+            x.setParameter(asSingleVariableDeclaration(kids[0]));
+            x.setExpression(asExpression(kids[1]));
+            x.setBody(asStatement(kids[2]));
+            return wrap(x);
+        }
+        case ENUM_CONSTANT_DECLARATION: {
+            if((!isJavadoc(kids[0]) && !isNone(kids[0]))
+                    || !isModifierList(kids[1]) 
+                    || !isSimpleName(kids[2]) 
+                    || !isExpressionList(kids[3]) 
+                    || !isAnonymousClassDeclaration(kids[4]))
+                return null;
+            EnumConstantDeclaration x = ast.newEnumConstantDeclaration();
+            if(isNone(kids[0]))
+                x.setJavadoc(null);
+            else
+                x.setJavadoc(asJavadoc(kids[0]));
+            x.modifiers().addAll(asModifierList(kids[1]));
+            x.setName(asSimpleName(kids[2]));
+            x.arguments().addAll(asExpressionList(kids[3]));
+            x.setAnonymousClassDeclaration(asAnonymousClassDeclaration(kids[4]));
+            return wrap(x);
+        }
+        case ENUM_DECLARATION: {
+            if((!isJavadoc(kids[0]) && !isNone(kids[0]))
+                    || !isModifierList(kids[1])
+                    || !isSimpleName(kids[2])
+                    || !isTypeList(kids[3])
+                    || !isEnumConstantDeclarationList(kids[4])
+                    || !isBodyDeclarationList(kids[5]))
+                return null;
+            EnumDeclaration x = ast.newEnumDeclaration();
+            if(isNone(kids[0]))
+                x.setJavadoc(null);
+            else
+                x.setJavadoc(asJavadoc(kids[0]));
+            x.modifiers().addAll(asModifierList(kids[1]));
+            x.setName(asSimpleName(kids[2]));
+            x.superInterfaceTypes().addAll(asTypeList(kids[3]));
+            x.enumConstants().addAll(asEnumConstantDeclarationList(kids[4]));
+            x.bodyDeclarations().addAll(asBodyDeclarationList(kids[5]));
+            return wrap(x);
+        }
+        case EXPRESSION_STATEMENT: {
+            if(!isExpression(kids[0]))
+                return null;
+            return wrap(ast.newExpressionStatement(asExpression(kids[0])));
+        }
+        case FIELD_ACCESS: {
+            if(!isExpression(kids[0]) || !isSimpleName(kids[1]))
+                return null;
+            FieldAccess x = ast.newFieldAccess();
+            x.setExpression(asExpression(kids[0]));
+            x.setName(asSimpleName(kids[1]));
+            return wrap(x);
+        }
+        case FIELD_DECLARATION: {
+            if((!isJavadoc(kids[0]) && !isNone(kids[0]))
+                    || !isModifierList(kids[1])
+                    || !isType(kids[2])
+                    || !isNonEmptyVariableDeclarationFragmentList(kids[3]))
+                return null;
+            List y = asFragmentList(kids[3]);
+            FieldDeclaration x = ast.newFieldDeclaration((VariableDeclarationFragment)y.remove(0));
+            if(isNone(kids[0]))
+                x.setJavadoc(null);
+            else
+                x.setJavadoc(asJavadoc(kids[0]));
+            x.modifiers().addAll(asModifierList(kids[1]));
+            x.setType(asType(kids[2]));
+            x.fragments().addAll(y);
+            return wrap(x);
+        }
+        case FLOAT_TYPE: {
+            return wrap(ast.newPrimitiveType(PrimitiveType.FLOAT));
+        }
+        case FOR_STATEMENT: {
+            if(!isExpressionList(kids[0]) 
+                    || (!isExpression(kids[1]) && !isNone(kids[1]))
+                    || !isExpressionList(kids[2])
+                    || !isStatement(kids[3]))
+                return null;
+            ForStatement x = ast.newForStatement();
+            x.initializers().addAll(asExpressionList(kids[0]));
+            if(isNone(kids[1]))
+                x.setExpression(null);
+            else
+                x.setExpression(asExpression(kids[1]));
+            x.updaters().addAll(asExpressionList(kids[2]));
+            x.setBody(asStatement(kids[3]));
+            return wrap(x);
+        }
+        case IF_STATEMENT: {
+            if(!isExpression(kids[0])
+                    || !isStatement(kids[1])
+                    || (!isStatement(kids[2]) && !isNone(kids[2])))
+                return null;
+            IfStatement x = ast.newIfStatement();
+            x.setExpression(asExpression(kids[0]));
+            x.setThenStatement(asStatement(kids[1]));
+            if(isNone(kids[2]))
+                x.setElseStatement(null);
+            else
+                x.setElseStatement(asStatement(kids[2]));
+            return wrap(x);
+        }
+        case IMPORT_DECLARATION: {
+            if(!isName(kids[0]) && !isInt(kids[1]) && !isInt(kids[2]))
+                return null;
+            ImportDeclaration x = ast.newImportDeclaration();
+            x.setName(asName(kids[0]));
+            x.setStatic(((IStrategoInt)kids[1]).intValue() > 0);
+            x.setOnDemand(((IStrategoInt)kids[2]).intValue() > 0);
+            return wrap(x);
+        }
+        case INFIX_EXPRESSION: {
+            if(!isOperator(kids[0])
+                    || !isExpression(kids[1])
+                    || !isExpression(kids[2])
+                    || !isExpressionList(kids[3]))
+                return null;
+            InfixExpression x = ast.newInfixExpression();
+            x.setOperator(asOperator(kids[0]));
+            x.setLeftOperand(asExpression(kids[1]));
+            x.setRightOperand(asExpression(kids[2]));
+            x.extendedOperands().addAll(asExpressionList(kids[3]));
+            return wrap(x);
+        }
+        case INITIALIZER: {
+            if(!isBlock(kids[0]))
+                return null;
+            Initializer x = ast.newInitializer();
+            x.setBody(asBlock(kids[0]));
+            return wrap(x);
+            
+        }
+        case INSTANCEOF_EXPRESSION: {
+            if(!isExpression(kids[0])
+                    || !isType(kids[1]))
+                return null;
+            InstanceofExpression x = ast.newInstanceofExpression();
+            x.setLeftOperand(asExpression(kids[0]));
+            x.setRightOperand(asType(kids[1]));
+            return wrap(x);
+        }
+        case INT_TYPE: {
+            return wrap(ast.newPrimitiveType(PrimitiveType.INT));
+        }
+        case JAVADOC: {
+            if(!isTagElementList(kids[0]))
+                return null;
+            Javadoc x = ast.newJavadoc();
+            x.tags().addAll(asTagElementList(kids[0]));
+            return wrap(x);
+        }
+        case LABELED_STATEMENT: {
+            if(!isSimpleName(kids[0]) 
+                    || !isStatement(kids[1]))
+                return null;
+            LabeledStatement x = ast.newLabeledStatement();
+            x.setLabel(asSimpleName(kids[0]));
+            x.setBody(asStatement(kids[1]));
+            return wrap(x);
+        }
+        case LINE_COMMENT: {
+            LineComment x = ast.newLineComment();
+            return wrap(x);
+        }
+        case LONG_TYPE: {
+            return wrap(ast.newPrimitiveType(PrimitiveType.INT));
+        }
+        case MARKER_ANNOTATION: {
+            if(!isName(kids[0]))
+                return null;
+            MarkerAnnotation x = ast.newMarkerAnnotation();
+            x.setTypeName(asName(kids[0]));
+            return wrap(x);
+            
+        }
+        case MEMBER_REF: {
+            if(!isSimpleName(kids[0]) || !isName(kids[1]))
+                return null;
+            MemberRef x = ast.newMemberRef();
+            x.setName(asSimpleName(kids[0]));
+            x.setQualifier(asName(kids[1]));
+            return wrap(x);
+        }
+        case MEMBER_VALUE_PAIR: {
+            if(!isSimpleName(kids[0]) || !isExpression(kids[1]))
+                return null;
+            MemberValuePair x = ast.newMemberValuePair();
+            x.setName(asSimpleName(kids[0]));
+            x.setValue(asExpression(kids[1]));
+            return wrap(x);
+        }
+        case METHOD_DECLARATION: {
+            if((!isJavadoc(kids[0]) && !isNone(kids[0]))
+                    || !isExtendedModifierList(kids[1])
+                    || (!isType(kids[2]) && !isNone(kids[2]))
+                    || !isTypeParameterList(kids[3])
+                    || !isSimpleName(kids[4])
+                    || !isSingleVariableDeclarationList(kids[5])
+                    || !isNameList(kids[6])
+                    || (!isBlock(kids[7]) && !isNone(kids[7])))
+                return null;
+            MethodDeclaration x = ast.newMethodDeclaration();
+            if(isNone(kids[0]))
+                x.setJavadoc(null);
+            else
+                x.setJavadoc(asJavadoc(kids[0]));
+            x.modifiers().addAll(asExtendedModifierList(kids[1]));
+            if(isNone(kids[2])) {
+                x.setReturnType2(null);
+                x.setConstructor(true);
+            } else
+                x.setReturnType2(asType(kids[2]));
+            x.typeParameters().addAll(asTypeParameterList(kids[3]));
+            x.setName(asSimpleName(kids[4]));
+            x.parameters().addAll(asSingleVariableDeclarationList(kids[5]));
+            x.thrownExceptions().addAll(asNameList(kids[6]));
+            if(isNone(kids[7]))
+                x.setBody(null);
+            else
+                x.setBody(asBlock(kids[7]));
+            return wrap(x);
+        }
+        case METHOD_INVOCATION: {
+            if((!isExpression(kids[0]) && !isNone(kids[0]))
+                    || !isSimpleName(kids[1])
+                    || !isTypeList(kids[2])
+                    || !isExpressionList(kids[3]))
+                return null;
+            MethodInvocation x = ast.newMethodInvocation();
+            if(isNone(kids[0]))
+                x.setExpression(null);
+            else 
+                x.setExpression(asExpression(kids[0]));
+            x.setName(asSimpleName(kids[1]));
+            x.typeArguments().addAll(asTypeList(kids[2]));
+            x.arguments().addAll(asExpressionList(kids[3]));
+            return wrap(x);
+        }
+        case METHOD_REF: {
+            if(!isSimpleName(kids[0])
+                    || !isName(kids[1])
+                    || !isMethodRefParameterList(kids[2]))
+                return null;
+            MethodRef x = ast.newMethodRef();
+            x.setName(asSimpleName(kids[0]));
+            x.setQualifier(asName(kids[1]));
+            x.parameters().addAll(asMethodRefParameterList(kids[2]));
+            return wrap(x);
+        }
+        case METHOD_REF_PARAMETER: {
+            if(!isType(kids[0])
+                    || !(isSimpleName(kids[1]) || isNone(kids[1])))
+                return null;
+            MethodRefParameter x = ast.newMethodRefParameter();
+            x.setType(asType(kids[0]));
+            if(isNone(kids[1]))
+            	x.setName(null);
+            else
+            	x.setName(asSimpleName(kids[1]));
+            return wrap(x);
+        }
+        case MODIFIER: {
+            if(!isModifierKeyword(kids[0]))
+                return null;
+            return wrap(ast.newModifier(asModifierKeyword(kids[0])));
+        }
+        case MODIFIER_KEYWORD: {
+            if(!isInt(kids[0]))
+                return null;
+            return wrap(Modifier.ModifierKeyword.fromFlagValue(asInt(kids[0])));
+        }
+        case NONE:
+            return None.INSTANCE;
+        case NORMAL_ANNOTATION: {
+            if(!isName(kids[0]) || !isMemberValuePairList(kids[1]))
+                return null;
+            NormalAnnotation x = ast.newNormalAnnotation();
+            x.setTypeName(asName(kids[0]));
+            x.values().addAll(asMemberValuePairList(kids[1]));
+            return wrap(x);
+        }
+        case NULL_LITERAL: {
+            return wrap(ast.newNullLiteral());
+        }
+        case NUMBER_LITERAL: {
+            if(!isString(kids[0]))
+                return null;
+            return wrap(ast.newNumberLiteral(asString(kids[0])));
+        }
+        case PACKAGE_DECLARATION: {
+            if((!isJavadoc(kids[0]) && !isNone(kids[0]))
+                    || !isAnnotations(kids[1])
+                    || !isName(kids[2]))
+                return null;
+            
+            PackageDeclaration pd = ast.newPackageDeclaration();
+            if(isNone(kids[0]))
+                pd.setJavadoc(null);
+            else
+                pd.setJavadoc(getJavadoc(kids[0]));
+            pd.annotations().addAll(getAnnotations(kids[1]));
+            pd.setName(asName(kids[2]));
+            return wrap(pd);
+        }
+        case PARAMETERIZED_TYPE: {
+            if(!isType(kids[0]) || !isTypeList(kids[1]))
+                return null;
+            ParameterizedType x = ast.newParameterizedType(asType(kids[0]));
+            x.typeArguments().addAll(asTypeList(kids[1]));
+            return wrap(x);
+        }
+        case PARENTHESIZED_EXPRESSION: {
+            if(!isExpression(kids[0]))
+                return null;
+            ParenthesizedExpression x = ast.newParenthesizedExpression();
+            x.setExpression(asExpression(kids[0]));
+            return wrap(x);
+        }
+        case POSTFIX_EXPRESSION: {
+            if(!isPostfixOperator(kids[0]) || !isExpression(kids[1]))
+                return null;
+            PostfixExpression x = ast.newPostfixExpression();
+            x.setOperator(asPostfixOperator(kids[0]));
+            x.setOperand(asExpression(kids[1]));
+            return wrap(x);
+        }
+        case POSTFIX_EXPRESSION_OPERATOR: {
+            if(!isString(kids[0]))
+                return null;
+            return wrap(PostfixExpression.Operator.toOperator(asString(kids[0])));
+        }
+        case PREFIX_EXPRESSION: {
+            if(!isPrefixOperator(kids[0]) || !isExpression(kids[1]))
+                return null;
+            PrefixExpression x = ast.newPrefixExpression();
+            x.setOperator(asPrefixOperator(kids[0]));
+            x.setOperand(asExpression(kids[1]));
+            return wrap(x);
+        }
+        case PREFIX_EXPRESSION_OPERATOR: {
+            if(!isString(kids[0]))
+                return null;
+            return wrap(PrefixExpression.Operator.toOperator(asString(kids[0])));
+        }
+        case PRIMITIVE_TYPE: {
+            if(!isString(kids[0]))
+                return null;
+            return wrap(ast.newPrimitiveType(asTypeCode(kids[0])));
+        }
+        case QUALIFIED_NAME: {
+            if(!isName(kids[0]) || !isSimpleName(kids[1]))
+                return null;
+            return wrap(ast.newQualifiedName(asName(kids[0]), asSimpleName(kids[1])));
+        }
+        case QUALIFIED_TYPE: {
+            if(!isType(kids[0]) || !isSimpleName(kids[1]))
+                return null;
+            return wrap(ast.newQualifiedType(asType(kids[0]), asSimpleName(kids[1])));
+        }
+        case RETURN_STATEMENT: {
+            if(!(isExpression(kids[0]) || isNone(kids[0])))
+                return null;
+            ReturnStatement x = ast.newReturnStatement();
+            if(isNone(kids[0]))
+            	x.setExpression(null);
+            else 
+            	x.setExpression(asExpression(kids[0]));
+            return wrap(x);
+        }
+        case SIMPLE_NAME: {
+            if(!isString(kids[0]))
+                return null;
+            return wrap(ast.newSimpleName(asString(kids[0])));
+        }
+        case SIMPLE_TYPE: {
+            if(!isName(kids[0]))
+                return null;
+            return wrap(ast.newSimpleType(asName(kids[0])));
+        }
+        case SINGLE_MEMBER_ANNOTATION: {
+            if(!isName(kids[0]) || !isExpression(kids[1]))
+                return null;
+            SingleMemberAnnotation x = ast.newSingleMemberAnnotation();
+            x.setTypeName(asName(kids[0]));
+            x.setValue(asExpression(kids[1]));
+            return wrap(x);
+        }
+        case SINGLE_VARIABLE_DECLARATION: {
+            if(!isModifierList(kids[0])
+                    || !isType(kids[1])
+                    || !isName(kids[2])
+                    || !isInt(kids[3])
+                    || (!isExpression(kids[4]) && !isNone(kids[4])))
+                return null;
+            SingleVariableDeclaration x = ast.newSingleVariableDeclaration();
+            x.modifiers().addAll(asModifierList(kids[0]));
+            x.setType(asType(kids[1]));
+            x.setName(asSimpleName(kids[2]));
+            x.setExtraDimensions(asInt(kids[3]));
+            if(isNone(kids[4])) 
+                x.setInitializer(null);
+            else
+                x.setInitializer(asExpression(kids[4]));
+            return wrap(x);
+        }
+        case STRING_LITERAL: {
+            if(!isString(kids[0]))
+                return null;
+            StringLiteral x = ast.newStringLiteral();
+            x.setLiteralValue(asString(kids[0]));
+            return wrap(x);
+        }
+        case SUPER_CONSTRUCTOR_INVOCATION: {
+            if((!isExpression(kids[0]) && !isNone(kids[0])) 
+                    || !isTypeList(kids[1]) 
+                    || !isExpressionList(kids[2]))
+                return null;
+            SuperConstructorInvocation x = ast.newSuperConstructorInvocation();
+            if(isNone(kids[0]))
+                x.setExpression(null);
+            else
+                x.setExpression(asExpression(kids[0]));
+            x.typeArguments().addAll(asTypeList(kids[1]));
+            x.arguments().addAll(asExpressionList(kids[2]));
+            return wrap(x);
+        }
+        case SUPER_FIELD_ACCESS: {
+            if((!isName(kids[0]) && !isNone(kids[0])) 
+                    || !isSimpleName(kids[1]))
+                return null;
+            SuperFieldAccess x = ast.newSuperFieldAccess();
+            if(isNone(kids[0]))
+                x.setQualifier(null);
+            else
+                x.setQualifier(asName(kids[0]));
+            x.setName(asSimpleName(kids[1]));
+            return wrap(x);
+        }
+        case SUPER_METHOD_INVOCATION: {
+            if((!isName(kids[0]) && !isNone(kids[0])) 
+                    || !isTypeList(kids[1])
+                    || !isSimpleName(kids[2])
+                    || !isExpressionList(kids[3]))
+                return null;
+            SuperMethodInvocation x = ast.newSuperMethodInvocation();
+            if(isNone(kids[0]))
+                x.setQualifier(null);
+            else
+                x.setQualifier(asName(kids[0]));
+            x.typeArguments().addAll(asTypeList(kids[1]));
+            x.setName(asSimpleName(kids[2]));
+            x.arguments().addAll(asExpressionList(kids[3]));
+            return wrap(x);
+        }
+        case SWITCH_CASE: {
+            if(!isExpression(kids[0]) && !isNone(kids[0]))
+                return null;
+            SwitchCase x = ast.newSwitchCase();
+            if(isNone(kids[0]))
+                x.setExpression(null);
+            else
+                x.setExpression(asExpression(kids[0]));
+            return wrap(x);
+        }
+        case SWITCH_STATEMENT: {
+            if(!isExpression(kids[0])
+                    || !isStatementList(kids[1]))
+                return null;
+            SwitchStatement x = ast.newSwitchStatement();
+            x.setExpression(asExpression(kids[0]));
+            x.statements().addAll(asStatementList(kids[1]));
+            return wrap(x);
+        }
+        case SYNCHRONIZED_STATEMENT: {
+            if(!isExpression(kids[0])
+                    || !isBlock(kids[1]))
+                return null;
+            SynchronizedStatement x = ast.newSynchronizedStatement();
+            x.setExpression(asExpression(kids[0]));
+            x.setBody(asBlock(kids[1]));
+            return wrap(x);
+        }
+        case TAG_ELEMENT: {
+            if((!isString(kids[0]) && !isNone(kids[0])) 
+                    || !isASTNodeList(kids[1]))
+                return null;
+            TagElement x = ast.newTagElement();
+            if(isNone(kids[0]))
+                x.setTagName(null);
+            else 
+                x.setTagName(asString(kids[0]));
+            x.fragments().addAll(asASTNodeList(kids[1]));
+            return wrap(x);
+        }
+        case TEXT_ELEMENT: {
+            if(!isString(kids[0]))
+                return null;
+            TextElement x = ast.newTextElement();
+            x.setText(asString(kids[0]));
+            return wrap(x);
+        }
+        case THIS_EXPRESSION: {
+            if(!isName(kids[0]) && !isNone(kids[0]))
+                return null;
+            ThisExpression x = ast.newThisExpression();
+            if(isNone(kids[0]))
+                x.setQualifier(null);
+            else 
+                x.setQualifier(asName(kids[0]));
+            return wrap(x);
+        }
+        case THROW_STATEMENT: {
+            if(!isExpression(kids[0]))
+                return null;
+            ThrowStatement x = ast.newThrowStatement();
+            x.setExpression(asExpression(kids[0]));
+            return wrap(x);
+        }
+        case TRY_STATEMENT: {
+            if(!isBlock(kids[0]) 
+                    || !isCatchClauseList(kids[1]) 
+                    || (!isBlock(kids[2]) && !isNone(kids[2])))
+                return null;
+            TryStatement x = ast.newTryStatement();
+            x.setBody(asBlock(kids[0]));
+            x.catchClauses().addAll(asCatchClauseList(kids[1]));
+            if(isNone(kids[2]))
+                x.setFinally(null);
+            else 
+                x.setFinally(asBlock(kids[2]));
+            return wrap(x);
+        }
+        case TYPE_DECLARATION: {
+            if((!isJavadoc(kids[0]) && !isNone(kids[0]))
+                    || !isModifierList(kids[1])
+                    || !isSimpleName(kids[2])
+                    || !isTypeParameterList(kids[3])
+                    || (!isType(kids[4]) && !isNone(kids[4]))
+                    || !isTypeList(kids[5])
+                    || !isBodyDeclarationList(kids[6])
+                    || !isInt(kids[7]))
+                return null;
+            TypeDeclaration x = ast.newTypeDeclaration();
+            if(isNone(kids[0]))
+                x.setJavadoc(null);
+            else
+                x.setJavadoc(asJavadoc(kids[0]));
+            x.modifiers().addAll(asModifierList(kids[1]));
+            x.setName(asSimpleName(kids[2]));
+            x.typeParameters().addAll(asTypeParameterList(kids[3]));
+            if(isNone(kids[4])) 
+                x.setSuperclassType(null);
+            else 
+                x.setSuperclassType(asType(kids[4]));
+            x.superInterfaceTypes().addAll(asTypeList(kids[5]));
+            x.bodyDeclarations().addAll(asBodyDeclarationList(kids[6]));
+            x.setInterface(asInt(kids[7]) == 1);
+            return wrap(x);
+        }
+        case TYPE_DECLARATION_STATEMENT: {
+            if(!isTypeDecl(kids[0]))
+                return null;
+            return wrap(ast.newTypeDeclarationStatement(asTypeDecl(kids[0])));
+        }
+        case TYPE_LITERAL: {
+            if(!isType(kids[0]))
+                return null;
+            TypeLiteral x = ast.newTypeLiteral();
+            x.setType(asType(kids[0]));
+            return wrap(x);
+        }
+        case TYPE_PARAMETER: {
+            if(!isSimpleName(kids[0]) || !isTypeList(kids[1]))
+                return null;
+            TypeParameter x = ast.newTypeParameter();
+            x.setName(asSimpleName(kids[0]));
+            x.typeBounds().addAll(asTypeList(kids[1]));
+            return wrap(x);
+        }
+        case VARIABLE_DECLARATION_EXPRESSION: {
+            if(!isModifierList(kids[0]) 
+                    || !isType(kids[1]) 
+                    || !isNonEmptyVariableDeclarationFragmentList(kids[2]))
+                return null;
+            List y = asFragmentList(kids[2]);
+            VariableDeclarationExpression x = ast.newVariableDeclarationExpression((VariableDeclarationFragment)y.remove(0));
+            x.modifiers().addAll(asModifierList(kids[0]));
+            x.setType(asType(kids[1]));
+            x.fragments().addAll(y);
+            return wrap(x);
+        }
+        case VARIABLE_DECLARATION_FRAGMENT: {
+            if(!isSimpleName(kids[0]) 
+                    || !isInt(kids[1]) 
+                    || (!isExpression(kids[2]) && !isNone(kids[2])))
+                return null;
+            VariableDeclarationFragment x = ast.newVariableDeclarationFragment();
+            x.setName(asSimpleName(kids[0]));
+            x.setExtraDimensions(asInt(kids[1]));
+            if(isNone(kids[2]))
+                x.setInitializer(null);
+            else
+                x.setInitializer(asExpression(kids[2]));
+            return wrap(x);
+        }
+        case VARIABLE_DECLARATION_STATEMENT: {
+            if(!isModifierList(kids[0]) 
+                    || !isType(kids[1]) 
+                    || !isNonEmptyVariableDeclarationFragmentList(kids[2]))
+                return null;
+            List y = asFragmentList(kids[2]);
+            VariableDeclarationStatement x = ast.newVariableDeclarationStatement((VariableDeclarationFragment)y.remove(0));
+            x.modifiers().addAll(asModifierList(kids[0]));
+            x.setType(asType(kids[1]));
+            x.fragments().addAll(y);
+            return wrap(x);
+        }
+        case WHILE_STATEMENT: {
+            if(!isExpression(kids[0]) || !isStatement(kids[1]))
+                return null;
+            WhileStatement x = ast.newWhileStatement();
+            x.setExpression(asExpression(kids[0]));
+            x.setBody(asStatement(kids[1]));
+            return wrap(x);
+        }
+        case WILDCARD_TYPE: {
+            if(!isType(kids[0]) && !isNone(kids[0]))
+                return null;
+            WildcardType x = ast.newWildcardType();
+            if(isNone(kids[0]))
+                x.setBound(null);
+            else
+                x.setBound(asType(kids[0]));
+            return wrap(x);
+        }
+        default:
+            return null;
+        }
+    }
+
+    private Javadoc asJavadoc(IStrategoTerm term) {
+        Javadoc x = ((WrappedJavadoc)term).getWrappee();
+        return x.getParent() == null && x.getAST() == ast ? x : (Javadoc)ASTNode.copySubtree(ast, x);
+    }
+
+    @SuppressWarnings("unchecked")
+    private Collection asExtendedModifierList(IStrategoTerm term) {
+        IStrategoTerm[] kids = term.getAllSubterms();
+        List r = new ArrayList(kids.length);
+        for(IStrategoTerm k : kids) {
+            r.add(asExtendedModifier(k));
+        }
+        return r;    
+    }
+
+    private IExtendedModifier asExtendedModifier(IStrategoTerm term) {
+    	final IExtendedModifier x = ((IWrappedExtendedModifier)term).getModifierWrappee();
+    	final ASTNode an = ((ASTNode)x);
+    	if(an.getParent() == null && an.getAST() == ast)
+    		return x;
+    	else 
+    		return (IExtendedModifier)ASTNode.copySubtree(ast, an);
+    }
+
+    private boolean isExtendedModifierList(IStrategoTerm term) {
+        if(term instanceof IStrategoList) {
+            IStrategoList list = (IStrategoList)term;
+            if(list.size() > 0) 
+                return isExtendedModifier(list.head());
+            return true;
+        }
+        return false;
+    }
+
+    private boolean isExtendedModifier(IStrategoTerm term) {
+        return term instanceof IWrappedExtendedModifier;
+    }
+
+    @SuppressWarnings("unchecked")
+    private Collection asTypeParameterList(IStrategoTerm term) {
+        IStrategoTerm[] kids = term.getAllSubterms();
+        List r = new ArrayList(kids.length);
+        for(IStrategoTerm k : kids) {
+            r.add(asTypeParameter(k));
+        }
+        return r;    
+    }
+
+    private TypeParameter asTypeParameter(IStrategoTerm term) {
+        TypeParameter x = ((WrappedTypeParameter)term).getWrappee();
+        return x.getParent() == null && x.getAST() == ast ? x : (TypeParameter)ASTNode.copySubtree(ast, x);
+    }
+
+    @SuppressWarnings("unchecked")
+    private Collection asTagElementList(IStrategoTerm term) {
+        IStrategoTerm[] kids = term.getAllSubterms();
+        List r = new ArrayList(kids.length);
+        for(IStrategoTerm k : kids) {
+            r.add(asTagElement(k));
+        }
+        return r;    
+    }
+
+
+    private TagElement asTagElement(IStrategoTerm term) {
+    	TagElement x = ((WrappedTagElement)term).getWrappee(); 
+        return x.getParent() == null && x.getAST() == ast ? x : (TagElement)ASTNode.copySubtree(ast, x);
+    }
+
+    @SuppressWarnings("unchecked")
+    private Collection asAbstractTypeDeclarationList(IStrategoTerm term) {
+        IStrategoTerm[] kids = term.getAllSubterms();
+        List r = new ArrayList(kids.length);
+        for(IStrategoTerm k : kids) {
+            r.add(asAbstractTypeDeclaration(k));
+        }
+        return r;    
+        
+    }
+
+    private Operator asOperator(IStrategoTerm term) {
+        String s = ((IStrategoString)term).stringValue();
+        return InfixExpression.Operator.toOperator(s);
+    }
+
+
+    @SuppressWarnings("unchecked")
+    private Collection asNameList(IStrategoTerm term) {
+        IStrategoTerm[] kids = term.getAllSubterms();
+        List r = new ArrayList(kids.length);
+        for(IStrategoTerm k : kids) {
+            r.add(asName(k));
+        }
+        return r;    
+    }
+
+    @SuppressWarnings("unchecked")
+    private Collection asSingleVariableDeclarationList(IStrategoTerm term) {
+        IStrategoTerm[] kids = term.getAllSubterms();
+        List r = new ArrayList(kids.length);
+        for(IStrategoTerm k : kids) {
+            r.add(asSingleVariableDeclaration(k));
+        }
+        return r;    
+    }
+
+    private AbstractTypeDeclaration asAbstractTypeDeclaration(IStrategoTerm term) {
+        AbstractTypeDeclaration x = ((WrappedAbstractTypeDeclaration)term).getWrappee();
+        return x.getParent() == null && x.getAST() == ast ? x : (AbstractTypeDeclaration)ASTNode.copySubtree(ast, x);
+    }
+
+    @SuppressWarnings("unchecked")
+    private Collection asMethodRefParameterList(IStrategoTerm term) {
+        IStrategoTerm[] kids = term.getAllSubterms();
+        List r = new ArrayList(kids.length);
+        for(IStrategoTerm k : kids) {
+            r.add(asMethodRefParameter(k));
+        }
+        return r;    
+    }
+
+    @SuppressWarnings("unchecked")
+    private Collection asImportDeclarationList(IStrategoTerm term) {
+        IStrategoTerm[] kids = term.getAllSubterms();
+        List r = new ArrayList(kids.length);
+        for(IStrategoTerm k : kids) {
+            r.add(asImportDeclaration(k));
+        }
+        return r;    
+    }
+
+    private ImportDeclaration asImportDeclaration(IStrategoTerm term) {
+        ImportDeclaration x = ((WrappedImportDeclaration)term).getWrappee();
+        return x.getParent() == null && x.getAST() == ast ? x : (ImportDeclaration)ASTNode.copySubtree(ast, x);
+    }
+
+    private PackageDeclaration asPackageDeclaration(IStrategoTerm term) {
+        PackageDeclaration x = ((WrappedPackageDeclaration)term).getWrappee();
+        return x.getParent() == null && x.getAST() == ast ? x : (PackageDeclaration)ASTNode.copySubtree(ast, x);
+    }
+
+
+    @SuppressWarnings("unchecked")
+    private Collection asEnumConstantDeclarationList(IStrategoTerm term) {
+        IStrategoTerm[] kids = term.getAllSubterms();
+        List r = new ArrayList(kids.length);
+        for(IStrategoTerm k : kids) {
+            r.add(asEnumConstantDeclaration(k));
+        }
+        return r;    
+    }
+
+    private EnumConstantDeclaration asEnumConstantDeclaration(IStrategoTerm term) {
+        EnumConstantDeclaration x = ((WrappedEnumConstantDeclaration)term).getWrappee();
+        return x.getParent() == null && x.getAST() == ast ? x : (EnumConstantDeclaration)ASTNode.copySubtree(ast, x);
+    }
+
+
+    @SuppressWarnings("unchecked")
+    private Collection asASTNodeList(IStrategoTerm term) {
+        IStrategoTerm[] kids = term.getAllSubterms();
+        List r = new ArrayList(kids.length);
+        for(IStrategoTerm k : kids) {
+            r.add(asASTNode(k));
+        }
+        return r;    
+    }
+
+    private ASTNode asASTNode(IStrategoTerm term) {
+        ASTNode x = ((WrappedASTNode)term).getWrappee();
+        return x.getParent() == null && x.getAST() == ast ? x : ASTNode.copySubtree(ast, x);
+    }
+
+    private MethodRefParameter asMethodRefParameter(IStrategoTerm term) {
+        MethodRefParameter x = ((WrappedMethodRefParameter)term).getWrappee();
+        return x.getParent() == null && x.getAST() == ast ? x : (MethodRefParameter)ASTNode.copySubtree(ast, x);
+    }
+
+    @SuppressWarnings("unchecked")
+    private Collection asMemberValuePairList(IStrategoTerm term) {
+        IStrategoTerm[] kids = term.getAllSubterms();
+        List r = new ArrayList(kids.length);
+        for(IStrategoTerm k : kids) {
+            r.add(asMemberValuePair(k));
+        }
+        return r;    
+    }
+
+    private MemberValuePair asMemberValuePair(IStrategoTerm term) {
+        MemberValuePair x = ((WrappedMemberValuePair)term).getWrappee();
+        return x.getParent() == null && x.getAST() == ast ? x : (MemberValuePair)ASTNode.copySubtree(ast, x);
+    }
+
+    private Code asTypeCode(IStrategoTerm term) {
+        return PrimitiveType.toCode(((IStrategoString)term).stringValue());
+    }
+
+    private ModifierKeyword asModifierKeyword(IStrategoTerm term) {
+        return ((WrappedModifierKeyword)term).getWrappee();
+    }
+
+    private Name asName(IStrategoTerm term) {
+        Name x = ((WrappedName)term).getWrappee();
+        return x.getParent() == null && x.getAST() == ast ? x : (Name)ASTNode.copySubtree(ast, x);
+    }
+
+    @SuppressWarnings("unchecked")
+    private Collection asCatchClauseList(IStrategoTerm term) {
+        IStrategoTerm[] kids = term.getAllSubterms();
+        List r = new ArrayList(kids.length);
+        for(IStrategoTerm k : kids) {
+            r.add(asCatchClause(k));
+        }
+        return r;    
+    }
+
+    private AbstractTypeDeclaration asTypeDecl(IStrategoTerm term) {
+        AbstractTypeDeclaration x = ((WrappedAbstractTypeDeclaration)term).getWrappee();
+        return x.getParent() == null && x.getAST() == ast ? x : (AbstractTypeDeclaration)ASTNode.copySubtree(ast, x);
+    }
+
+    @SuppressWarnings("unchecked")
+    private List asFragmentList(IStrategoTerm term) {
+        IStrategoTerm[] kids = term.getAllSubterms();
+        List r = new ArrayList(kids.length);
+        for(IStrategoTerm k : kids) {
+            r.add(asVariableDeclarationFragment(k));
+        }
+        return r;    
+    }
+
+    private ArrayInitializer asArrayInitializer(IStrategoTerm term) {
+        ArrayInitializer x = ((WrappedArrayInitializer)term).getWrappee();
+        return x.getParent() == null && x.getAST() == ast ? x : (ArrayInitializer)ASTNode.copySubtree(ast, x);
+    }
+
+    private ArrayType asArrayType(IStrategoTerm term) {
+        ArrayType x = ((WrappedArrayType)term).getWrappee();
+        return x.getParent() == null && x.getAST() == ast ? x : (ArrayType)ASTNode.copySubtree(ast, x);
+    }
+
+    private Type asType(IStrategoTerm term) {
+        Type x = ((WrappedType)term).getWrappee();
+        return x.getParent() == null && x.getAST() == ast ? x : (Type)ASTNode.copySubtree(ast, x);
+    }
+
+    private SingleVariableDeclaration asSingleVariableDeclaration(IStrategoTerm term) {
+        SingleVariableDeclaration x = ((WrappedSingleVariableDeclaration)term).getWrappee();
+        return x.getParent() == null && x.getAST() == ast ? x : (SingleVariableDeclaration)ASTNode.copySubtree(ast, x);
+    }
+
+    private Block asBlock(IStrategoTerm term) {
+        Block x = ((WrappedBlock)term).getWrappee();
+        return x.getParent() == null && x.getAST() == ast ? x : (Block)ASTNode.copySubtree(ast, x);
+    }
+
+    private PrefixExpression.Operator asPrefixOperator(IStrategoTerm term) {
+        return ((WrappedPrefixExpressionOperator)term).getWrappee();
+    }
+
+    @SuppressWarnings("unchecked")
+    private Collection asTypeList(IStrategoTerm term) {
+        IStrategoTerm[] kids = term.getAllSubterms();
+        List r = new ArrayList(kids.length);
+        for(IStrategoTerm k : kids) {
+            r.add(asType(k));
+        }
+        return r;    
+    }
+
+    @SuppressWarnings("unchecked")
+    private Collection asBodyDeclarationList(IStrategoTerm term) {
+        IStrategoTerm[] kids = term.getAllSubterms();
+        List r = new ArrayList(kids.length);
+        for(IStrategoTerm k : kids) {
+            r.add(asBodyDeclaration(k));
+        }
+        return r;
+    }
+
+    private Expression asExpression(IStrategoTerm term) {
+        Expression x = ((WrappedExpression) term).getWrappee();
+        return x.getParent() == null && x.getAST() == ast ? x : (Expression)ASTNode.copySubtree(ast, x);
+    }
+
+    private int asInt(IStrategoTerm term) {
+        return ((IStrategoInt)term).intValue();
+    }
+
+    @SuppressWarnings("unchecked")
+    private Collection asExpressionList(IStrategoTerm term) {
+        IStrategoTerm[] kids = term.getAllSubterms();
+        List r = new ArrayList(kids.length);
+        for(IStrategoTerm k : kids) {
+            r.add(asExpression(k));
+        }
+        return r;
+    }
+
+    private PostfixExpression.Operator asPostfixOperator(IStrategoTerm term) {
+        return ((WrappedPostfixExpressionOperator)term).getWrappee();
+    }
+
+    private Assignment.Operator asAssignmentOperator(IStrategoTerm term) {
+        return ((WrappedAssignmentOperator)term).getWrappee();
+    }
+
+    private BodyDeclaration asBodyDeclaration(IStrategoTerm k) {
+        BodyDeclaration x = ((WrappedBodyDeclaration)k).getWrappee();
+        return x.getParent() == null && x.getAST() == ast ? x : (BodyDeclaration)ASTNode.copySubtree(ast, x);
+    }
+
+    private SimpleName asSimpleName(IStrategoTerm term) {
+        SimpleName x = ((WrappedSimpleName)term).getWrappee();
+        return x.getParent() == null && x.getAST() == ast ? x : (SimpleName)ASTNode.copySubtree(ast, x);
+    }
+
+    private Modifier asModifier(IStrategoTerm term) {
+        Modifier x = ((WrappedModifier)term).getWrappee();
+        return x.getParent() == null && x.getAST() == ast ? x : (Modifier)ASTNode.copySubtree(ast, x);
+    }
+
+    private VariableDeclarationFragment asVariableDeclarationFragment(IStrategoTerm term) {
+    	VariableDeclarationFragment x = ((WrappedVariableDeclarationFragment)term).getWrappee();
+    	return x.getParent() == null && x.getAST() == ast ? x : (VariableDeclarationFragment) ASTNode.copySubtree(ast, x);
+    }
+
+    private AnonymousClassDeclaration asAnonymousClassDeclaration(IStrategoTerm term) {
+        AnonymousClassDeclaration x = ((WrappedAnonymousClassDeclaration)term).getWrappee();
+        return x.getParent() == null && x.getAST() == ast ? x : (AnonymousClassDeclaration) ASTNode.copySubtree(ast, x);
+    }
+
+    private CatchClause asCatchClause(IStrategoTerm term) {
+    	CatchClause x = ((WrappedCatchClause)term).getWrappee();
+    	return x.getParent() == null && x.getAST() == ast ? x : (CatchClause) ASTNode.copySubtree(ast, x);
+    }
+
+    private String asString(IStrategoTerm term) {
+        return ((IStrategoString)term).stringValue();
+    }
+
+    @SuppressWarnings("unchecked")
+    private Collection asStatementList(IStrategoTerm term) {
+        IStrategoTerm[] kids = term.getAllSubterms();
+        List r = new ArrayList(kids.length);
+        for(IStrategoTerm k : kids) {
+            r.add(asStatement(k));
+        }
+        return r;
+    }
+
+    private Statement asStatement(IStrategoTerm term) {
+        Statement x = ((WrappedStatement)term).getWrappee();
+        return x.getParent() == null && x.getAST() == ast ? x : (Statement)ASTNode.copySubtree(ast, x); 
+    }
+
+    private boolean isAbstractTypeDeclarationList(IStrategoTerm term) {
+        if(term instanceof IStrategoList) {
+            IStrategoTerm[] kids = ((IStrategoList)term).getAllSubterms();
+            for(IStrategoTerm k : kids) {
+                if(!isAbstractTypeDeclaration(k))
+                    return false;
+            }
+            return true;
+        }
+        return false;
+    }
+
+    private boolean isAbstractTypeDeclaration(IStrategoTerm term) {
+        return term instanceof WrappedAbstractTypeDeclaration;
+    }
+
+    private boolean isNone(IStrategoTerm term) {
+        return term instanceof None;
+    }
+
+    private boolean isName(IStrategoTerm term) {
+        return term instanceof WrappedName;
+    }
+
+    private boolean isAnnotations(IStrategoTerm term) {
+        return term instanceof WrappedASTNodeList;
+    }
+
+    private boolean isJavadoc(IStrategoTerm term) {
+        return term instanceof WrappedJavadoc;
+    }
+
+    private boolean isMethodRefParameterList(IStrategoTerm term) {
+        if(term instanceof IStrategoList) {
+            IStrategoTerm[] kids = ((IStrategoList)term).getAllSubterms();
+            for(IStrategoTerm k : kids) { 
+                if(!isMethodRefParameter(k))
+                    return false;
+            }
+            return true;
+        }
+        return false;
+    }
+
+    private boolean isMethodRefParameter(IStrategoTerm term) {
+        return term instanceof WrappedMethodRefParameter;
+    }
+
+    private boolean isNameList(IStrategoTerm term) {
+        if(term instanceof IStrategoList) {
+            IStrategoList list = (IStrategoList)term;
+            if(list.size() > 0) 
+                return isName(list.head());
+            return true;
+        }
+        return false;
+    }
+
+    private boolean isSingleVariableDeclarationList(IStrategoTerm term) {
+        if(term instanceof IStrategoList) {
+            IStrategoList list = (IStrategoList)term;
+            if(list.size() > 0) 
+                return isSingleVariableDeclaration(list.head());
+            return true;
+        }
+        return false;
+    }
+
+    private boolean isTypeParameterList(IStrategoTerm term) {
+        if(term instanceof IStrategoList) {
+            IStrategoList list = (IStrategoList)term;
+            if(list.size() > 0) 
+                return isTypeParameter(list.head());
+            return true;
+        }
+        return false;
+    }
+
+    private boolean isTypeParameter(IStrategoTerm term) {
+        return term instanceof WrappedTypeParameter;
+    }
+
+    private boolean isTagElementList(IStrategoTerm term) {
+        if(term instanceof IStrategoList) {
+            IStrategoTerm[] kids = term.getAllSubterms();
+            for(int i = 0; i < kids.length; i++)
+                if(!isTagElement(kids[i]))
+                    return false;
+        }
+        return true;
+    }
+
+    private boolean isTagElement(IStrategoTerm term) {
+        return term instanceof WrappedTagElement;
+    }
+
+    private boolean isOperator(IStrategoTerm term) {
+        return term instanceof IStrategoString 
+        && InfixExpression.Operator.toOperator(((IStrategoString)term).stringValue()) != null;
+    }
+
+    private boolean isEnumConstantDeclarationList(IStrategoTerm term) {
+        if(term instanceof IStrategoList) {
+            IStrategoList list = (IStrategoList)term;
+            if(list.size() > 0) 
+                return isEnumConstantDeclaration(list.head());
+            return true;
+        }
+        return false;
+    }
+
+    private boolean isEnumConstantDeclaration(IStrategoTerm term) {
+        return term instanceof WrappedEnumConstantDeclaration;
+    }
+
+    private boolean isImportDeclarationList(IStrategoTerm term) {
+        if(term instanceof IStrategoList) {
+            IStrategoList list = (IStrategoList)term;
+            if(list.size() > 0) 
+                return isImportDeclaration(list.head());
+            return true;
+        }
+        return false;
+    }
+
+    private boolean isImportDeclaration(IStrategoTerm term) {
+        return term instanceof WrappedImportDeclaration;
+    }
+
+    private boolean isPackageDeclaration(IStrategoTerm term) {
+        return term instanceof WrappedPackageDeclaration;
+    }
+
+    private boolean isMemberValuePairList(IStrategoTerm term) {
+        if(term instanceof IStrategoList) {
+            IStrategoList list = (IStrategoList)term;
+            if(list.size() > 0) 
+                return isMemberValuePair(list.head());
+            return true;
+        }
+        return false;
+    }
+
+    private boolean isMemberValuePair(IStrategoTerm term) {
+        return term instanceof WrappedMemberValuePair;
+    }
+   
+    private boolean isModifierKeyword(IStrategoTerm term) {
+        return term instanceof WrappedModifierKeyword;
+    }
+
+    private boolean isASTNodeList(IStrategoTerm term) {
+        return term instanceof WrappedASTNodeList;
+    }
+
+    private boolean isString(IStrategoTerm term) {
+        return term instanceof IStrategoString;
+    }
+
+    private boolean isCatchClauseList(IStrategoTerm term) {
+        if(term instanceof IStrategoList) {
+            IStrategoList list = (IStrategoList)term;
+            if(list.size() > 0) 
+                return isCatchClause(list.head());
+            return true;
+        }
+        return false;
+    }
+
+    private boolean isCatchClause(IStrategoTerm term) {
+        return term instanceof WrappedCatchClause;
+    }
+
+    private boolean isBodyDeclarationList(IStrategoTerm term) {
+        if(term instanceof IStrategoList) {
+            IStrategoTerm[] kids = ((IStrategoList)term).getAllSubterms();
+            for(int i = 0; i < kids.length; i++)
+                if(!isBodyDeclaration(kids[i]))
+                    return false;
+            return true;
+        }
+        return false;
+    }
+
+    private boolean isTypeDecl(IStrategoTerm term) {
+        return term instanceof WrappedAbstractTypeDeclaration;
+    }
+
+    private boolean isNonEmptyVariableDeclarationFragmentList(IStrategoTerm term) {
+        // Must contain at least one element
+        if(term instanceof IStrategoList) {
+            IStrategoList list = (IStrategoList)term;
+            if(list.size() < 0)
+                return false;
+            return isVariableDeclarationFragment(list.head());
+            
+        }
+        return false;
+    }
+
+    private boolean isVariableDeclarationFragment(IStrategoTerm term) {
+        return term instanceof WrappedVariableDeclarationFragment;
+    }
+
+    private boolean isAnonymousClassDeclaration(IStrategoTerm term) {
+        return term instanceof WrappedAnonymousClassDeclaration;
+    }
+
+    private boolean isBlock(IStrategoTerm term) {
+        return term instanceof WrappedBlock;
+    }
+
+    private boolean isSingleVariableDeclaration(IStrategoTerm term) {
+        return term instanceof WrappedSingleVariableDeclaration;
+    }
+
+    private boolean isPrefixOperator(IStrategoTerm term) {
+        return term instanceof WrappedPrefixExpressionOperator;
+    }
+
+    private boolean isPostfixOperator(IStrategoTerm term) {
+        return term instanceof WrappedPostfixExpressionOperator;
+    }
+
+    private boolean isAssignmentOperator(IStrategoTerm term) {
+        return term instanceof WrappedAssignmentOperator;
+    }
+
+    private boolean isTypeList(IStrategoTerm term) {
+        if(term instanceof IStrategoList) {
+        	for(IStrategoTerm t : ((IStrategoList)term).getAllSubterms()) {
+        		if(!isType(t))
+        			return false;
+        	}
+        	return true;
+        }
+        return false;
+    }
+
+    private boolean isStatementList(IStrategoTerm term) {
+        if(term instanceof IStrategoList) {
+            IStrategoList list = (IStrategoList)term;
+            for(IStrategoTerm t : list.getAllSubterms()) { 
+                if(!isStatement(t))
+                    return false;
+            }
+            return true;
+        }
+        return false;
+    }
+
+    private boolean isStatement(IStrategoTerm term) {
+        return term instanceof WrappedStatement;
+    }
+
+    private boolean isInt(IStrategoTerm term) {
+        return term instanceof IStrategoInt;
+    }
+
+
+    private boolean isExpressionList(IStrategoTerm term) {
+        if(term instanceof IStrategoList) {
+            IStrategoTerm[] kids = ((IStrategoList)term).getAllSubterms();
+            for(IStrategoTerm k : kids) {
+                if(!isExpression(k))
+                    return false;
+            }
+            return true;
+        }
+        return false;
+    }
+
+    private boolean isArrayInitializer(IStrategoTerm term) {
+        return term instanceof WrappedArrayInitializer;
+    }
+
+
+    private boolean isArrayType(IStrategoTerm term) {
+        return term instanceof WrappedArrayType;
+    }
+
+    private boolean isSimpleName(IStrategoTerm term) {
+        return term instanceof WrappedSimpleName;
+    }
+
+    private boolean isType(IStrategoTerm term) {
+        return term instanceof WrappedType;
+    }
+
+    @SuppressWarnings("unchecked")
+    private Collection asModifierList(IStrategoTerm term) {
+        IStrategoTerm[] kids = term.getAllSubterms();
+        List r = new ArrayList(kids.length);
+        for(IStrategoTerm k : kids) {
+            r.add(asModifier(k));
+        }
+        return r;
+    }
+
+    private boolean isModifierList(IStrategoTerm term) {
+        if(term instanceof IStrategoList) {
+            IStrategoTerm[] kids = ((IStrategoList)term).getAllSubterms();
+            for(IStrategoTerm k : kids) {
+                if(!isModifier(k))
+                    return false;
+            }
+            return true;
+        }
+        return false;
+    }
+
+    private boolean isModifier(IStrategoTerm term) {
+        return term instanceof WrappedModifier;
+    }
+
+    private boolean isBodyDeclaration(IStrategoTerm term) {
+        return term instanceof WrappedBodyDeclaration;
+    }
+
+    private boolean isExpression(IStrategoTerm term) {
+        return term instanceof WrappedExpression;
+    }
+
+    private int ctorNameToIndex(IStrategoConstructor ctr) {
+        Integer x = ctorNameToIndexMap.get(ctr.getName());
+        return x == null ? -1 : x.intValue();
+    }
+
+    public IStrategoConstructor makeConstructor(String string, int arity) {
+        return new ASTCtor(string, arity);
+    }
+
+    public IStrategoInt makeInt(int i) {
+        return new WrappedInt(i);
+    }
+
+    @SuppressWarnings("unchecked")
+    public IStrategoList makeList(IStrategoTerm... terms) {
+        
+        boolean mustUseGeneric = false;
+        for(IStrategoTerm t : terms)
+            if(!(t instanceof WrappedASTNode))
+                mustUseGeneric = true;
+        
+        if(mustUseGeneric) {
+            return new WrappedGenericList(terms);
+        }
+        
+        List<ASTNode> r = new ArrayList();
+        for(IStrategoTerm t : terms)
+            r.add(((WrappedASTNode)t).getWrappee());
+        return new WrappedASTNodeList(r);
+    }
+
+    public IStrategoList makeList(Collection<IStrategoTerm> terms) {
+    	return makeList(terms.toArray(new IStrategoTerm[0]));
+    }
+    
+    @Deprecated
+    public final IStrategoList makeList(IStrategoTerm head, IStrategoList tail) {
+        return makeListCons(head, tail);
+    }
+    
+    public IStrategoList makeListCons(IStrategoTerm head, IStrategoList tail) {
+        // TODO: handle list prepending in ECJFactory
+        return tail.prepend(head);
+    }
+
+    public IStrategoReal makeReal(double d) {
+        return new WrappedReal(d);
+    }
+
+    public IStrategoString makeString(String s) {
+        return new WrappedString(s);
+    }
+
+    public IStrategoTuple makeTuple(IStrategoTerm... terms) {
+        return new WrappedTuple(terms);
+    }
+
+    public static IStrategoAppl wrap(Javadoc javadoc) {
+        if(javadoc == null)
+            return None.INSTANCE;
+        else
+            return new WrappedJavadoc(javadoc);
+    }
+
+    @SuppressWarnings("unchecked")
+    public static IStrategoTerm wrap(List list) {
+        if(list == null)
+            return None.INSTANCE;
+        else
+            return new WrappedASTNodeList(list);
+    }
+
+    static IStrategoTerm wrapName(Name name) {
+        
+        if(name == null)
+            return None.INSTANCE;
+        
+        if(name instanceof QualifiedName)
+            return wrap((QualifiedName) name);
+        if(name instanceof SimpleName)
+            return wrap((SimpleName) name);
+        
+        throw new NotImplementedException("Unknown Name type: " + name.getClass());
+    }
+
+    static IStrategoAppl wrap(SimpleName name) {
+        if(name == null)
+            return None.INSTANCE;
+        else
+            return new WrappedSimpleName(name);
+    }
+
+    private static IStrategoAppl wrap(QualifiedName name) {
+        if(name == null)
+            return None.INSTANCE;
+        else
+            return new WrappedQualifiedName(name);
+    }
+
+    @SuppressWarnings("unchecked")
+	public static IStrategoTerm genericWrap(ASTNode node) {
+        
+        if(node instanceof ImportDeclaration)
+            return wrap((ImportDeclaration) node);
+        if(node instanceof Name)
+            return wrapName((Name) node);
+        if(node instanceof List)
+            return wrap((List) node);
+        if(node instanceof Javadoc)
+            return wrap((Javadoc) node);
+        if(node instanceof CompilationUnit)
+            return wrap((CompilationUnit) node);
+        if(node instanceof PackageDeclaration)
+            return wrap((PackageDeclaration) node);
+        if(node instanceof TypeDeclaration)
+            return wrap((TypeDeclaration) node);
+        if(node instanceof MethodDeclaration)
+            return wrap((MethodDeclaration) node);
+        if(node instanceof SingleVariableDeclaration)
+            return wrap((SingleVariableDeclaration) node);
+        if(node instanceof Expression)
+            return wrapExpression((Expression) node);
+        if(node instanceof VariableDeclarationFragment)
+            return wrap((VariableDeclarationFragment) node);
+        if(node instanceof AnonymousClassDeclaration)
+            return wrap((AnonymousClassDeclaration) node);
+        if(node instanceof BodyDeclaration)
+            return wrapBody((BodyDeclaration) node);
+        if(node instanceof CatchClause)
+            return wrap((CatchClause) node);
+        if(node instanceof Comment) 
+            return wrapComment((Comment) node);
+        if(node instanceof MemberRef)
+            return wrap((MemberRef) node);
+        if(node instanceof MemberValuePair)
+            return wrap((MemberValuePair) node);
+        if(node instanceof MethodRef)
+            return wrap((MethodRef) node);
+        if(node instanceof MethodRefParameter)
+            return wrap((MethodRefParameter) node);
+        if(node instanceof Modifier)
+            return wrap((Modifier) node);
+        if(node instanceof PackageDeclaration)
+            return wrap((PackageDeclaration) node);
+        if(node instanceof Statement)
+            return wrapStatement((Statement) node);
+        if(node instanceof TagElement)
+            return wrap((TagElement) node);
+        if(node instanceof TextElement)
+            return wrap((TextElement) node);
+        if(node instanceof Type)
+            return wrapType((Type) node);
+        if(node instanceof TypeParameter)
+            return wrap((TypeParameter) node);
+        if(node instanceof VariableDeclaration)
+            return wrapVarDecl((VariableDeclaration) node);
+        
+        if(node == null)
+            return None.INSTANCE;
+        
+        throw new NotImplementedException("Unknown ASTNode type" + node.getClass());
+    }
+
+    private static IStrategoTerm wrapVarDecl(VariableDeclaration decl) {
+        if(decl instanceof SingleVariableDeclaration)
+            return wrap((SingleVariableDeclaration) decl);
+        if(decl instanceof VariableDeclarationFragment)
+            return wrap((VariableDeclarationFragment) decl);
+        
+        throw new NotImplementedException();
+    }
+
+    private static IStrategoTerm wrapComment(Comment comment) {
+        if(comment instanceof BlockComment)
+            return wrap((BlockComment) comment);
+        if(comment instanceof Javadoc)
+            return wrap((Javadoc) comment);
+        if(comment instanceof LineComment)
+            return wrap((LineComment) comment);
+        
+        throw new NotImplementedException();
+    }
+
+    private static IStrategoAppl wrap(LineComment comment) {
+        if(comment == null)
+            return None.INSTANCE;
+        else
+            return new WrappedLineComment(comment);
+    }
+
+    private static IStrategoAppl wrap(BlockComment comment) {
+        if(comment == null)
+            return None.INSTANCE;
+        else
+            return new WrappedBlockComment(comment);
+    }
+
+    private static IStrategoTerm wrapBody(BodyDeclaration decl) {
+       
+        if(decl instanceof AbstractTypeDeclaration)
+            return wrapTypeDecl((AbstractTypeDeclaration) decl);
+        if(decl instanceof AnnotationTypeMemberDeclaration)
+            return wrap((AnnotationTypeMemberDeclaration) decl);
+        if(decl instanceof EnumConstantDeclaration)
+            return wrap((EnumConstantDeclaration) decl);
+        if(decl instanceof FieldDeclaration)
+            return wrap((FieldDeclaration) decl);
+        if(decl instanceof Initializer)
+            return wrap((Initializer) decl);
+        if(decl instanceof MethodDeclaration)
+            return wrap((MethodDeclaration) decl);
+        
+        throw new NotImplementedException();
+    }
+
+    private static IStrategoAppl wrap(AnnotationTypeMemberDeclaration declaration) {
+        if(declaration == null)
+            return None.INSTANCE;
+        else
+            return new WrappedAnnotationTypeMemberDeclaration(declaration);
+    }
+
+    private static IStrategoAppl wrap(EnumConstantDeclaration declaration) {
+        if(declaration == null)
+            return None.INSTANCE;
+        else
+            return new WrappedEnumConstantDeclaration(declaration);
+    }
+
+    private static IStrategoAppl wrap(FieldDeclaration declaration) {
+        if(declaration == null)
+            return None.INSTANCE;
+        else
+            return new WrappedFieldDeclaration(declaration);
+    }
+
+    private static IStrategoAppl wrap(Initializer initializer) {
+        if(initializer == null)
+                return None.INSTANCE;
+        else
+            return new WrappedInitializer(initializer);
+    }
+
+    private static IStrategoAppl wrap(TypeParameter parameter) {
+        if(parameter == null)
+            return None.INSTANCE;
+        else
+            return new WrappedTypeParameter(parameter);
+    }
+
+    private static IStrategoAppl wrap(TextElement element) {
+        if(element == null)
+            return None.INSTANCE;
+        else
+            return new WrappedTextElement(element);
+    }
+
+    private static IStrategoAppl wrap(TagElement element) {
+        if(element == null)
+            return None.INSTANCE;
+        else
+            return new WrappedTagElement(element);
+    }
+
+    static IStrategoTerm wrapStatement(Statement stat) {
+        
+        if(stat == null)
+            return None.INSTANCE;
+        
+        if(stat instanceof ExpressionStatement)
+            return wrap((ExpressionStatement) stat);
+        if(stat instanceof VariableDeclarationStatement)
+            return wrap((VariableDeclarationStatement) stat);
+        if(stat instanceof AssertStatement)
+            return wrap((AssertStatement) stat);
+        if(stat instanceof Block)
+            return wrap((Block) stat);
+        if(stat instanceof BreakStatement)
+            return wrap((BreakStatement) stat);
+        if(stat instanceof ConstructorInvocation)
+            return wrap((ConstructorInvocation) stat);
+        if(stat instanceof ContinueStatement)
+            return wrap((ContinueStatement) stat);
+        if(stat instanceof DoStatement)
+            return wrap((DoStatement) stat);
+        if(stat instanceof EmptyStatement)
+            return wrap((EmptyStatement) stat);
+        if(stat instanceof EnhancedForStatement)
+            return wrap((EnhancedForStatement) stat);
+        if(stat instanceof ForStatement)
+            return wrap((ForStatement) stat);
+        if(stat instanceof IfStatement)
+            return wrap((IfStatement) stat);
+        if(stat instanceof LabeledStatement)
+            return wrap((LabeledStatement) stat);
+        if(stat instanceof ReturnStatement)
+            return wrap((ReturnStatement) stat);
+        if(stat instanceof SuperConstructorInvocation)
+            return wrap((SuperConstructorInvocation) stat);
+        if(stat instanceof SwitchCase)
+            return wrap((SwitchCase) stat);
+        if(stat instanceof SwitchStatement)
+            return wrap((SwitchStatement) stat);
+        if(stat instanceof SynchronizedStatement)
+            return wrap((SynchronizedStatement) stat);
+        if(stat instanceof ThrowStatement)
+            return wrap((ThrowStatement) stat);
+        if(stat instanceof TryStatement)
+            return wrap((TryStatement) stat);
+        if(stat instanceof TypeDeclarationStatement)
+            return wrap((TypeDeclarationStatement) stat);
+        if(stat instanceof WhileStatement)
+            return wrap((WhileStatement) stat);
+
+        throw new NotImplementedException();
+    }
+
+    private static IStrategoAppl wrap(IfStatement statement) {
+        if(statement == null)
+            return None.INSTANCE;
+        else
+            return new WrappedIfStatement(statement);
+    }
+
+    private static IStrategoAppl wrap(SuperConstructorInvocation invocation) {
+        if(invocation == null)
+            return None.INSTANCE; 
+        else
+            return new WrappedSuperConstructorInvocation(invocation);
+    }
+
+    private static IStrategoAppl wrap(SwitchCase switchcase) {
+        if(switchcase == null)
+            return None.INSTANCE; 
+        else
+            return new WrappedSwitchCase(switchcase);
+    }
+
+    private static IStrategoAppl wrap(SwitchStatement statement) {
+        if(statement == null)
+            return None.INSTANCE;
+        else
+            return new WrappedSwitchStatement(statement);
+    }
+
+    private static IStrategoAppl wrap(SynchronizedStatement statement) {
+        if(statement == null)
+            return None.INSTANCE;
+        else
+            return new WrappedSynchronizedStatement(statement);
+    }
+
+    private static IStrategoAppl wrap(ThrowStatement statement) {
+        if(statement == null)
+            return None.INSTANCE;
+        else
+            return new WrappedThrowStatement(statement);
+    }
+
+    private static IStrategoAppl wrap(TryStatement statement) {
+        if(statement == null)
+            return None.INSTANCE;
+        else
+            return new WrappedTryStatement(statement);
+    }
+
+    private static IStrategoAppl wrap(TypeDeclarationStatement statement) {
+        if(statement == null)
+            return None.INSTANCE;
+        else
+            return new WrappedTypeDeclarationStatement(statement);
+    }
+
+    private static IStrategoAppl wrap(WhileStatement statement) {
+        if(statement == null)
+            return None.INSTANCE;
+        else
+            return new WrappedWhileStatement(statement);
+    }
+
+    private static IStrategoAppl wrap(ReturnStatement statement) {
+        if(statement == null)
+            return None.INSTANCE;
+        else
+            return new WrappedReturnStatement(statement);
+    }
+
+    private static IStrategoAppl wrap(LabeledStatement statement) {
+        if(statement == null)
+            return None.INSTANCE;
+        else
+            return new WrappedLabeledStatement(statement);
+    }
+
+    private static IStrategoAppl wrap(ForStatement statement) {
+        if(statement == null)
+            return None.INSTANCE;
+        else
+            return new WrappedForStatement(statement);
+    }
+
+    private static IStrategoAppl wrap(EnhancedForStatement statement) {
+        if(statement == null)
+            return None.INSTANCE;
+        else
+            return new WrappedEnhancedForStatement(statement);
+    }
+
+    private static IStrategoAppl wrap(EmptyStatement statement) {   
+        if(statement == null)
+            return None.INSTANCE;
+        else
+            return new WrappedEmptyStatement(statement);
+    }
+
+    private static IStrategoAppl wrap(DoStatement statement) {
+        if(statement == null)
+            return None.INSTANCE;
+        else
+            return new WrappedDoStatement(statement);
+    }
+
+    private static IStrategoAppl wrap(ContinueStatement statement) {
+        if(statement == null)
+            return None.INSTANCE;
+        else
+            return new WrappedContinueStatement(statement);
+    }
+
+    private static IStrategoAppl wrap(ConstructorInvocation invocation) {
+        if(invocation == null)
+            return None.INSTANCE;
+        else
+            return new WrappedConstructorInvocation(invocation);
+
+    }
+
+    private static IStrategoAppl wrap(BreakStatement statement) {
+        if(statement == null)
+            return None.INSTANCE;
+        else
+            return new WrappedBreakStatement(statement);
+    }
+
+    static IStrategoAppl wrap(Block block) {
+        if(block == null)
+            return None.INSTANCE;
+        else
+            return new WrappedBlock(block);
+    }
+
+    private static IStrategoAppl wrap(AssertStatement statement) {
+        if(statement == null)
+            return None.INSTANCE;
+        else
+            return new WrappedAssertStatement(statement);
+    }
+
+    private static IStrategoAppl wrap(Modifier modifier) {
+        if(modifier == null)
+            return None.INSTANCE;
+        else
+            return new WrappedModifier(modifier);
+    }
+
+    private static IStrategoAppl wrap(MethodRefParameter parameter) {
+        if(parameter == null)
+            return None.INSTANCE;
+        else
+            return new WrappedMethodRefParameter(parameter);
+    }
+
+    private static IStrategoAppl wrap(MethodRef ref) {
+        if(ref == null)
+            return None.INSTANCE;
+        else
+            return new WrappedMethodRef(ref);
+    }
+
+    private static IStrategoAppl wrap(MemberValuePair pair) {
+        if(pair == null)
+            return None.INSTANCE;
+        else
+            return new WrappedMemberValuePair(pair);
+    }
+
+    private static IStrategoAppl wrap(MemberRef ref) {
+        if(ref == null)
+            return None.INSTANCE;
+        else
+            return new WrappedMemberRef(ref);
+    }
+
+    private static IStrategoAppl wrap(CatchClause clause) {
+        if(clause == null)
+            return None.INSTANCE;
+        else
+            return new WrappedCatchClause(clause);
+    }
+
+    static IStrategoAppl wrap(AnonymousClassDeclaration declaration) {
+        if(declaration == null)
+            return None.INSTANCE;
+        else
+            return new WrappedAnonymousClassDeclaration(declaration);
+    }
+
+    private static IStrategoAppl wrap(VariableDeclarationFragment fragment) {
+        if(fragment == null)
+            return None.INSTANCE;
+        else
+            return new WrappedVariableDeclarationFragment(fragment);
+    }
+
+    private static IStrategoAppl wrap(VariableDeclarationStatement statement) {
+        if(statement == null)
+            return None.INSTANCE;
+        else
+            return new WrappedVariableDeclarationStatement(statement);
+    }
+
+    static IStrategoAppl wrap(ExpressionStatement statement) {
+        if(statement == null)
+            return None.INSTANCE;
+        else
+            return new WrappedExpressionStatement(statement);
+    }
+
+    static IStrategoAppl wrap(SingleVariableDeclaration declaration) {
+        if(declaration == null)
+            return None.INSTANCE;
+        else
+            return new WrappedSingleVariableDeclaration(declaration);
+    }
+
+    private static IStrategoAppl wrap(MethodDeclaration declaration) {
+        if(declaration == null)
+            return None.INSTANCE;
+        else
+            return new WrappedMethodDeclaration(declaration);
+    }
+
+    public static IStrategoAppl wrap(TypeDeclaration declaration) {
+        if(declaration == null)
+            return None.INSTANCE;
+        else
+            return new WrappedTypeDeclaration(declaration);
+    }
+
+    public static IStrategoAppl wrap(CompilationUnit unit) {
+        if(unit == null)
+            return None.INSTANCE;
+        else
+            return new WrappedCompilationUnit(unit);
+    }
+
+    public static IStrategoAppl wrap(PackageDeclaration declaration) {
+        if(declaration == null)
+            return None.INSTANCE;
+        else
+            return new WrappedPackageDeclaration(declaration);
+    }
+
+    static IStrategoAppl wrap(ImportDeclaration declaration) {
+        if(declaration == null)
+            return None.INSTANCE;
+        else
+            return new WrappedImportDeclaration(declaration);
+    }
+
+    public IStrategoTerm parseFromTree(ASTNode n) {
+        return genericWrap(n);
+    }
+
+    public static IStrategoTerm wrap(int val) {
+        return new WrappedInt(val);
+    }
+
+    public static IStrategoAppl wrap(ArrayType type) {
+        if(type == null)
+            return None.INSTANCE;
+        else
+            return new WrappedArrayType(type);
+    }
+
+    public static IStrategoTerm wrap(String identifier) {
+        if(identifier == null)
+            return None.INSTANCE;
+        else
+            return new WrappedString(identifier);
+    }
+
+    static IStrategoTerm wrapExpression(Expression expr) {
+
+        if(expr == null)
+            return None.INSTANCE;
+
+        if(expr instanceof Annotation)
+            return wrapAnnotation((Annotation) expr);
+        if(expr instanceof ArrayAccess)
+            return wrap((ArrayAccess) expr);
+        if(expr instanceof ArrayCreation)
+            return wrap((ArrayCreation) expr);
+        if(expr instanceof ArrayInitializer)
+            return wrap((ArrayInitializer) expr);
+        if(expr instanceof Assignment)
+            return wrap((Assignment) expr);
+        if(expr instanceof BooleanLiteral)
+            return wrap((BooleanLiteral) expr);
+        if(expr instanceof CastExpression)
+            return wrap((CastExpression) expr);
+        if(expr instanceof CharacterLiteral)
+            return wrap((CharacterLiteral) expr);
+        if(expr instanceof ClassInstanceCreation)
+            return wrap((ClassInstanceCreation) expr);
+        if(expr instanceof ConditionalExpression)
+            return wrap((ConditionalExpression) expr);
+        if(expr instanceof FieldAccess)
+            return wrap((FieldAccess) expr);
+        if(expr instanceof InfixExpression)
+            return wrap((InfixExpression) expr);
+        if(expr instanceof InstanceofExpression)
+            return wrap((InstanceofExpression) expr);
+        if(expr instanceof MethodInvocation)
+            return wrap((MethodInvocation) expr);
+        if(expr instanceof Name)
+            return wrapName((Name) expr);
+        if(expr instanceof NullLiteral)
+            return wrap((NullLiteral) expr);
+        if(expr instanceof NumberLiteral)
+            return wrap((NumberLiteral) expr);
+        if(expr instanceof ParenthesizedExpression)
+            return wrap((ParenthesizedExpression) expr);
+        if(expr instanceof PostfixExpression)
+            return wrap((PostfixExpression) expr);
+        if(expr instanceof PrefixExpression)
+            return wrap((PrefixExpression) expr);
+        if(expr instanceof StringLiteral)
+            return wrap((StringLiteral) expr);
+        if(expr instanceof SuperFieldAccess)
+            return wrap((SuperFieldAccess) expr);
+        if(expr instanceof SuperMethodInvocation)
+            return wrap((SuperMethodInvocation) expr);
+        if(expr instanceof ThisExpression)
+            return wrap((ThisExpression) expr);
+        if(expr instanceof TypeLiteral)
+            return wrap((TypeLiteral) expr);
+        if(expr instanceof VariableDeclarationExpression)
+            return wrap((VariableDeclarationExpression) expr);
+        
+        throw new NotImplementedException("Unknown Expression Type:" + expr.getClass());
+    }
+
+    private static IStrategoTerm wrapAnnotation(Annotation anno) {
+        
+        if(anno instanceof MarkerAnnotation)
+            return wrap((MarkerAnnotation) anno);
+        if(anno instanceof NormalAnnotation)
+            return wrap((NormalAnnotation) anno);
+        if(anno instanceof SingleMemberAnnotation)
+            return wrap((SingleMemberAnnotation) anno);
+
+        throw new NotImplementedException();
+    }
+
+    private static IStrategoAppl wrap(SingleMemberAnnotation annotation) {
+        if(annotation == null)
+            return None.INSTANCE;
+        else
+            return new WrappedSingleMemberAnnotation(annotation);
+    }
+
+    private static IStrategoAppl wrap(NormalAnnotation annotation) {
+        if(annotation == null)
+            return None.INSTANCE;
+        else
+            return new WrappedNormalAnnotation(annotation);
+    }
+
+    private static IStrategoAppl wrap(MarkerAnnotation annotation) {
+        if(annotation == null) 
+            return None.INSTANCE;
+        else
+            return new WrappedMarkerAnnotation(annotation);
+    }
+
+    private static IStrategoAppl wrap(VariableDeclarationExpression expression) {
+        if(expression == null)
+            return None.INSTANCE;
+        else
+            return new WrappedVariableDeclarationExpression(expression);
+    }
+
+    private static IStrategoAppl wrap(TypeLiteral literal) {
+        if(literal == null)
+            return None.INSTANCE;
+        else
+            return new WrappedTypeLiteral(literal);
+    }
+
+    private static IStrategoAppl wrap(ThisExpression expression) {
+        if(expression == null)
+            return None.INSTANCE;
+        else
+            return new WrappedThisExpression(expression);
+    }
+
+    private static IStrategoAppl wrap(SuperMethodInvocation invocation) {
+        if(invocation == null)
+            return None.INSTANCE;
+        else
+            return new WrappedSuperMethodInvocation(invocation);
+    }
+
+    private static IStrategoAppl wrap(SuperFieldAccess access) {
+        if(access == null)
+            return None.INSTANCE;
+        else
+            return new WrappedSuperFieldAccess(access);
+    }
+
+    private static IStrategoAppl wrap(StringLiteral literal) {
+        if(literal == null) 
+            return None.INSTANCE;
+        else
+            return new WrappedStringLiteral(literal);
+    }
+
+    private static IStrategoAppl wrap(PrefixExpression expression) {
+        if(expression == null)
+            return None.INSTANCE;
+        else
+            return new WrappedPrefixExpression(expression);
+    }
+
+    private static IStrategoAppl wrap(PostfixExpression expression) {
+        if(expression == null)
+            return None.INSTANCE;
+        else
+            return new WrappedPostfixExpression(expression);
+    }
+
+    private static IStrategoAppl wrap(ParenthesizedExpression expression) {
+        if(expression == null)
+            return None.INSTANCE;
+        else
+            return new WrappedParenthesizedExpression(expression);
+    }
+
+    private static IStrategoAppl wrap(NumberLiteral literal) {
+        if(literal == null)
+            return None.INSTANCE;
+        else
+            return new WrappedNumberLiteral(literal);
+    }
+
+    private static IStrategoAppl wrap(NullLiteral literal) {
+        if(literal == null)
+            return None.INSTANCE;
+        else
+            return new WrappedNullLiteral(literal);
+    }
+
+    private static IStrategoAppl wrap(MethodInvocation invocation) {
+        if(invocation == null)
+            return None.INSTANCE;
+        else
+            return new WrappedMethodInvocation(invocation);
+    }
+
+    private static IStrategoAppl wrap(InstanceofExpression expression) {
+        if(expression == null)
+            return None.INSTANCE;
+        else
+            return new WrappedInstanceofExpression(expression);
+    }
+
+    private static IStrategoAppl wrap(InfixExpression expression) {
+        
+        if(expression == null)
+            return None.INSTANCE;
+        else
+            return new WrappedInfixExpression(expression);
+
+/*
+        InfixExpression.Operator op = expression.getOperator();
+        
+        if(op == InfixExpression.Operator.PLUS)
+            return new WrappedPlus(expression); 
+        if(op == InfixExpression.Operator.MINUS)
+            return new WrappedMinus(expression); 
+        if(op == InfixExpression.Operator.TIMES)
+            return new WrappedTimes(expression); 
+        if(op == InfixExpression.Operator.DIVIDE)
+            return new WrappedDivide(expression); 
+
+        throw new NotImplementedException("Unknown InfixExpression Operator " + expression.getO);
+*/  
+    }
+
+    private static IStrategoAppl wrap(FieldAccess access) {
+        if(access == null)
+            return None.INSTANCE;
+        else
+            return new WrappedFieldAccess(access);
+    }
+
+    private static IStrategoAppl wrap(ConditionalExpression expression) {
+        if(expression == null)
+            return None.INSTANCE;
+        else
+            return new WrappedConditionalExpression(expression);
+    }
+
+    private static IStrategoAppl wrap(ClassInstanceCreation creation) {
+        if(creation == null)
+            return None.INSTANCE;
+        else
+            return new WrappedClassInstanceCreation(creation);
+    }
+
+    private static IStrategoAppl wrap(CharacterLiteral literal) {
+        if(literal == null)
+            return None.INSTANCE;
+        else
+            return new WrappedCharacterLiteral(literal);
+    }
+
+    private static IStrategoAppl wrap(CastExpression expression) {
+        if(expression == null)
+            return None.INSTANCE;
+        else
+            return new WrappedCastExpression(expression);
+    }
+
+    private static IStrategoAppl wrap(BooleanLiteral literal) {
+        if(literal == null)
+            return None.INSTANCE;
+        else
+            return new WrappedBooleanLiteral(literal);
+    }
+
+    private static IStrategoAppl wrap(Assignment assignment) {
+        if(assignment == null)
+            return None.INSTANCE;
+        else
+            return new WrappedAssignment(assignment);
+    }
+
+    private static IStrategoAppl wrap(ArrayInitializer initializer) {
+        if(initializer == null)
+            return None.INSTANCE;
+        else 
+            return new WrappedArrayInitializer(initializer);
+    }
+
+    private static IStrategoAppl wrap(ArrayCreation creation) {
+        if(creation == null)
+            return None.INSTANCE;
+        else
+            return new WrappedArrayCreation(creation);
+    }
+
+    private static IStrategoAppl wrap(ArrayAccess access) {
+        if(access == null)
+            return None.INSTANCE;
+        else
+            return new WrappedArrayAccess(access);
+    }
+
+    public static IStrategoTerm wrapType(Type type) {
+        
+        if(type instanceof ArrayType)
+            return wrap((ArrayType) type);
+        if(type instanceof ParameterizedType)
+            return wrap((ParameterizedType) type);
+        if(type instanceof PrimitiveType)
+            return wrap((PrimitiveType) type);
+        if(type instanceof QualifiedType)
+            return wrap((QualifiedType) type);
+        if(type instanceof SimpleType)
+            return wrap((SimpleType) type);
+        if(type instanceof WildcardType)
+            return wrap((WildcardType) type);
+        
+        if(type == null)
+            return None.INSTANCE;
+        
+        throw new NotImplementedException(" " + type.getClass());
+    }
+
+    private static IStrategoAppl wrap(WildcardType type) {
+        if(type == null)
+            return None.INSTANCE;
+        else
+            return new WrappedWildcardType(type);
+    }
+
+    private static IStrategoAppl wrap(SimpleType type) {
+        if(type == null)
+            return None.INSTANCE;
+        else
+            return new WrappedSimpleType(type);
+    }
+
+    private static IStrategoAppl wrap(QualifiedType type) {
+        if(type == null)
+            return None.INSTANCE;
+        else
+            return new WrappedQualifiedType(type);
+    }
+
+    private static IStrategoAppl wrap(PrimitiveType type) {
+        
+        if(type == null)
+            return None.INSTANCE;
+        else
+            return new WrappedPrimitiveType(type);
+        /*
+        if(type.getPrimitiveTypeCode() == PrimitiveType.INT)
+            return new WrappedIntType(type);
+        if(type.getPrimitiveTypeCode() == PrimitiveType.BOOLEAN)
+            return new WrappedBooleanType(type);
+        if(type.getPrimitiveTypeCode() == PrimitiveType.DOUBLE)
+            return new WrappedDoubleType(type);
+        if(type.getPrimitiveTypeCode() == PrimitiveType.FLOAT)
+            return new WrappedFloatType(type);
+        if(type.getPrimitiveTypeCode() == PrimitiveType.BYTE)
+            return new WrappedByteType(type);
+        if(type.getPrimitiveTypeCode() == PrimitiveType.LONG)
+            return new WrappedLongType(type);
+        
+        throw new NotImplementedException();
+        */
+    }
+
+    private static IStrategoAppl wrap(ParameterizedType type) {
+        if(type == null)
+            return None.INSTANCE;
+        else
+            return new WrappedParameterizedType(type); 
+    }
+
+    public static IStrategoAppl wrap(ModifierKeyword keyword) {
+        if(keyword == null)
+            return None.INSTANCE;
+        else 
+            return new WrappedModifierKeyword(keyword);
+    }
+
+    public static IStrategoAppl wrap(PostfixExpression.Operator operator) {
+        if(operator == null)
+            return None.INSTANCE;
+        else
+            return new WrappedPostfixExpressionOperator(operator);
+    }
+
+    public static IStrategoAppl wrap(PrefixExpression.Operator operator) {
+        if(operator == null)
+            return None.INSTANCE;
+        else
+            return new WrappedPrefixExpressionOperator(operator);
+    }
+
+    public static IStrategoTerm wrapTypeDecl(AbstractTypeDeclaration decl) {
+        if(decl instanceof AnnotationTypeDeclaration)
+            return wrap((AnnotationTypeDeclaration) decl);
+        if(decl instanceof EnumDeclaration)
+            return wrap((EnumDeclaration) decl);
+        if(decl instanceof TypeDeclaration)
+            return wrap((TypeDeclaration) decl);
+        
+        throw new NotImplementedException();
+    }
+
+    private static IStrategoAppl wrap(EnumDeclaration declaration) {
+        if(declaration == null)
+            return None.INSTANCE;
+        else
+            return new WrappedEnumDeclaration(declaration);
+    }
+
+    private static IStrategoAppl wrap(AnnotationTypeDeclaration declaration) {
+        if(declaration == null)
+            return None.INSTANCE;
+        else
+            return new WrappedAnnotationTypeDeclaration(declaration);
+    }
+
+    public static IStrategoTerm wrap(ITypeBinding binding) {
+        if(binding == null)
+            return None.INSTANCE;
+        else
+            return new WrappedITypeBinding(binding);
+    }
+
+    public static IStrategoTerm wrap(ITypeBinding[] bindings) {
+        IStrategoTerm[] terms = new IStrategoTerm[bindings.length];
+        for(int i = 0, sz = bindings.length; i < sz; i++)
+            terms[i] = ECJFactory.wrap(bindings[i]);
+        return new WrappedGenericList(terms);
+    }
+
+    public static IStrategoTerm wrap(ITypeParameter[] parameters) {
+        final IStrategoTerm[] terms = new IStrategoTerm[parameters.length];
+        for(int i = 0, sz = parameters.length; i < sz; i++)
+            terms[i] = ECJFactory.wrap(parameters[i]);
+        return new WrappedGenericList(terms);
+    }
+    
+    public static IStrategoTerm wrap(IField[] fields) {
+        IStrategoTerm[] terms = new IStrategoTerm[fields.length];
+        for(int i = 0, sz = fields.length; i < sz; i++)
+            terms[i] = ECJFactory.wrap(fields[i]);
+        return new WrappedGenericList(terms);
+    }
+
+
+    private static IStrategoTerm wrap(IField field) {
+    	if(field == null)
+    		return None.INSTANCE;
+    	else
+    		return new WrappedIField(field);
+	}
+
+	public static IStrategoTerm wrap(ITypeParameter binding) {
+        if(binding == null)
+            return None.INSTANCE;
+        else
+            return new WrappedITypeParameter(binding);
+    }
+
+    public static IStrategoTerm wrap(IProject proj) {
+        if(proj == null)
+            return None.INSTANCE;
+        else
+            return new WrappedIProject(proj);
+    }
+
+    public static IStrategoTerm wrap(String[] strs) {
+        IStrategoTerm[] r = new IStrategoTerm[strs.length];
+        for(int i = 0; i < r.length; i++)
+            r[i] = wrap(strs[i]);
+        return new WrappedGenericList(r);
+    }
+
+    public static IStrategoTerm wrap(IMethodBinding mb) {
+        if(mb == null)
+            return None.INSTANCE;
+        else
+            return new WrappedIMethodBinding(mb);
+    }
+
+    public void setAST(AST ast) {
+        this.ast = ast;
+    }
+
+    @Deprecated
+    public IStrategoAppl replaceAppl(IStrategoConstructor constructor, IStrategoTerm[] kids, IStrategoTerm old) {
+        return replaceAppl(constructor, kids, (IStrategoAppl)old);
+    }
+    
+    public IStrategoAppl replaceAppl(IStrategoConstructor constructor, IStrategoTerm[] kids, IStrategoAppl old) {
+        final IStrategoAppl r = makeAppl(constructor, kids);
+        // FIXME None should be in a different hierarchy than other WrappedASTNodes
+        if(r instanceof WrappedASTNode && old instanceof WrappedASTNode) {
+            final WrappedASTNode n = (WrappedASTNode)r;
+            final WrappedASTNode o = (WrappedASTNode)old;
+            final ASTNode nn = n.getWrappee();
+            final ASTNode on = o.getWrappee();
+            if(nn != null && on != null)
+                nn.setSourceRange(on.getStartPosition(), on.getLength());
+        }
+        return r;
+    }
+    
+    public IStrategoTuple replaceTuple(IStrategoTerm[] kids, IStrategoTuple old) {
+        return makeTuple(kids);
+    }
+    
+    public IStrategoList replaceList(IStrategoTerm[] kids, IStrategoList old) {
+        return makeList(kids);
+    }
+
+    public static IStrategoTerm wrap(IType t) {
+        if(t == null)
+            return None.INSTANCE;
+        else
+            return new WrappedIType(t);
+    }
+
+    public static IStrategoTerm wrap(IJavaProject jp) {
+        if(jp == null)
+            return None.INSTANCE;
+        else
+            return new WrappedIJavaProject(jp);
+    }
+
+    public static IStrategoTerm wrap(ICompilationUnit cu) {
+        if(cu == null)
+            return None.INSTANCE;
+        else
+            return new WrappedICompilationUnit(cu);
+    }
+
+    public static IStrategoTerm wrap(IFile file) {
+        if(file == null)
+            return None.INSTANCE;
+        else
+            return new WrappedIFile(file);
+    }
+
+    public static IStrategoTerm wrap(IBinding binding) {
+        if(binding == null)
+            return None.INSTANCE;
+        else
+            return new WrappedIBinding(binding);
+    }
+
+	public static IStrategoAppl wrap(Assignment.Operator operator) {
+		if(operator == null)
+			return None.INSTANCE;
+		else
+			return new WrappedAssignmentOperator(operator);
+	}
+
+	public static IStrategoTerm wrap(ITypeHierarchy th) {
+		if(th == null)
+			return None.INSTANCE;
+		else
+			return new WrappedITypeHierarchy(th);
+	}
+
+	public static IStrategoTerm wrapAmbName(String name) {
+		if(name == null)
+			return None.INSTANCE;
+		else 
+			return new AmbName(name);
+	}
+
+	public static IStrategoTerm wrapDottedName(String name) {
+		if(name == null)
+			return None.INSTANCE;
+		else 
+			return new DottedName(name);
+	}
+
+	public static IStrategoTerm fullyGenericWrap(Object o) {
+		if(o instanceof String)
+			return wrap((String)o);
+		if(o instanceof Integer)
+			return wrap((Integer)o);
+		if(o instanceof Boolean)
+			return wrap(((Boolean)o) ? 1 : 0);
+		if(o instanceof ASTNode)
+			return genericWrap((ASTNode)o);
+		if(o instanceof IType)
+			return wrap((IType)o);
+		
+		throw new NotImplementedException(" " + o.getClass());
+	}
+
+	public AST getAST() {
+		return ast;
+	}
+
+	public static IStrategoTerm wrap(IJavaElement el) {
+		if(el == null)
+			return None.INSTANCE;
+		else
+			return new WrappedIJavaElement(el);
+	}
+
+	public static IStrategoAppl wrapSignature(String s) {
+		if(s == null)
+			return None.INSTANCE;
+		else
+			return new WrappedActualTypeSignature(s);
+		
+	}
+
+	public static IStrategoTerm wrapSignatures(String[] signatures) {
+		if(signatures == null)
+			return None.INSTANCE;
+		else {
+			IStrategoAppl[] ws = new WrappedActualTypeSignature[signatures.length];
+			for(int i = 0; i < signatures.length; i++)
+				ws[i] = wrapSignature(signatures[i]);
+			return new BasicStrategoArrayList(ws);
+		}
+
+	}
+
+	public static ASTMatcher getMatcher() {
+		if(astMatcher == null)
+			astMatcher = new ASTMatcher();
+		return astMatcher;
+	}
+
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java4.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java4.java	Thu Dec 16 15:02:04 2010	(r21518)
@@ -0,0 +1,1333 @@
+ /*
+ * Created on 03.des.2005
+ *
+ * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
+ * 
+ * Licensed under the GNU Lesser General Public License, v2.1
+ */
+package org.spoofax.jsglr;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.PushbackInputStream;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Queue;
+import java.util.Set;
+import java.util.Timer;
+import java.util.TimerTask;
+import java.util.concurrent.CancellationException;
+
+import org.spoofax.ArrayDeque;
+
+import aterm.ATerm;
+import aterm.ATermFactory;
+import aterm.pure.PureFactory;
+
+public class SGLR {             
+   
+    private final Set<BadTokenException> collectedErrors = new LinkedHashSet<BadTokenException>();
+    
+    static final int EOF = ParseTable.NUM_CHARS;
+    
+    static final int TAB_SIZE = 4;//8;
+    
+    private static final Timer abortTimer = new Timer(true);
+    
+    private int abortTimerJobId;
+
+    protected static boolean WORK_AROUND_MULTIPLE_LOOKAHEAD;
+    
+    //Performance testing
+    private static long parseTime=0;
+    private static int parseCount=0;
+    
+    private int timeout;
+        
+    public Frame startFrame; 
+    
+    private long startTime;
+    
+    private volatile boolean asyncAborted;
+    
+    private ATermFactory factory;
+
+    public Frame acceptingStack;
+
+    public ArrayDeque<Frame> activeStacks;
+
+    private ParseTable parseTable;
+
+    public int currentToken;
+
+    public int tokensSeen;
+
+    protected int lineNumber;
+
+    protected int columnNumber;
+
+    private ArrayDeque<ActionState> forShifter;
+
+    private ArrayDeque<Frame> forActor;
+
+    private ArrayDeque<Frame> forActorDelayed;
+
+    private int maxBranches;
+
+    private int maxToken;
+
+    private int maxLine;
+
+    private int maxColumn;
+
+    private int maxTokenNumber;
+
+    private AmbiguityManager ambiguityManager;
+
+    public Disambiguator disambiguator;
+
+    private int rejectCount;
+
+    private int reductionCount;
+
+    private PushbackInputStream currentInputStream;
+   
+    //Creates indent- and dedent- tokens
+    //Meant for parsing of indentation based languages
+    //TODO: still under construction
+    private IndentTokenizer indentTokenHandler;
+    
+    // ------------------------------------- Integrated recovery  ------------------------
+  //Keeps track of the indentation for each line
+   // private IndentationHandler indentHandler;
+    
+    private ParserHistory history;
+    
+    private RecoveryConnector recoverIntegrator;
+    
+    protected boolean useIntegratedRecovery;
+    
+    public ParserHistory getHistory() {
+        return history;
+    }    
+     
+    
+    /* START: FINE GRAINED ON REGION */
+    private boolean fineGrainedOnRegion;
+    protected void setFineGrainedOnRegion(boolean fineGrainedMode) {
+        fineGrainedOnRegion=fineGrainedMode;
+        recoverStacks=new ArrayDeque<Frame>();
+    }
+
+    public void clearRecoverStacks(){
+        recoverStacks.clear(false);
+    }
+    
+    private ArrayDeque<Frame> recoverStacks;
+    public ArrayDeque<Frame> getRecoverStacks() {
+        return recoverStacks;
+    }
+
+    protected void setUseFineGrained(boolean useFG) {
+        recoverIntegrator.setUseFineGrained(useFG);        
+    }
+    /* END: FINE GRAINED ON REGION */
+    
+    public Set<BadTokenException> getCollectedErrors() {
+        return collectedErrors;
+    }
+    
+    //-------------------------- fine-grained recovery ----------------------------------
+    private RecoverDisambiguator recoverDisambiguator;
+       
+    SGLR() {
+        basicInit(null);
+    }
+
+    public SGLR(final ATermFactory pf, ParseTable parseTable) {
+        assert pf != null;
+        assert parseTable != null;
+        // Init with a new factory for both serialized or BAF instances.
+        this.parseTable = parseTable;
+        basicInit(pf);        
+    }
+
+    public void setUseStructureRecovery(boolean useRecovery, IRecoveryParser parser) {
+        useIntegratedRecovery = useRecovery;
+        recoverIntegrator = new RecoveryConnector(this, parser);
+    }
+    
+    /**
+     * Structure-based recovery without bridge parsing.
+     * 
+    */
+    public final void setUseStructureRecovery(boolean useRecovery) throws NoRecoveryRulesException {        
+        setUseStructureRecovery(useRecovery, null);
+    }
+    
+    /**
+     * @deprecated Use {@link #asyncCancel()} instead.
+     */
+    @Deprecated
+    public void asyncAbort() {
+        asyncCancel();
+    }
+    
+    /**
+     * Aborts an asynchronously running parse job, causing it to throw an exception.
+     *  
+     * (Provides no guarantee that the parser is actually cancelled.)
+     */
+    public void asyncCancel() {
+        asyncAborted = true;
+    }
+    
+    public void asyncCancelReset() {
+        asyncAborted = false;
+    }
+
+    private void basicInit(ATermFactory factory) {
+        this.factory = factory;
+        if (factory == null)
+            factory = new PureFactory();
+        activeStacks = new ArrayDeque<Frame>();     
+        forActor = new ArrayDeque<Frame>();
+        forActorDelayed = new ArrayDeque<Frame>();
+        forShifter = new ArrayDeque<ActionState>();
+
+        // FIXME This is *wrong*: need to set the input string size instead
+        ambiguityManager = new AmbiguityManager(10000);
+
+        disambiguator = new Disambiguator();
+        //indentHandler = new IndentationHandler();
+       // indentTokenHandler = new IndentTokenizer(indentHandler, false);  
+        useIntegratedRecovery = false;
+        recoverIntegrator = null;
+        history=new ParserHistory();
+        recoverDisambiguator=new RecoverDisambiguator(this.parseTable);
+    }
+
+    public static boolean isDebugging() {
+        return Tools.debugging;
+    }
+
+    public static boolean isLogging() {
+        return Tools.logging;
+    }
+
+    /**
+     * Initializes the active stacks. At the start of parsing there is only one
+     * active stack, and this stack contains the start symbol obtained from the
+     * parse table.
+     * 
+     * @return the initial stack
+     */
+    private Frame initActiveStacks() {
+        activeStacks.clear();
+        Frame st0 = newStack(parseTable.getInitialState());
+        addStack(st0);
+        return st0;
+    }
+    
+    public final ATerm parse(InputStream fis)  throws IOException, SGLRException {        
+        return parse(fis, null);
+    }   
+    
+    public ATerm parse(InputStream fis, String startSymbol) throws IOException,
+            BadTokenException, TokenExpectedException, ParseException,
+            SGLRException {
+        logBeforeParsing();        
+        initParseVariables(fis);        
+        startTime = System.currentTimeMillis();
+        initParseTimer();
+        return sglrParse(startSymbol);
+    }
+    
+    public final ATerm parse(String input) throws IOException, BadTokenException,
+            TokenExpectedException, ParseException, SGLRException {
+        
+        return parse(input, null);
+    }
+    
+    public ATerm parse(String input, String startSymbol) throws IOException, BadTokenException, TokenExpectedException, ParseException,
+        SGLRException {
+        
+        return parse(new ByteArrayInputStream(input.getBytes("ISO-8859-1")), startSymbol);
+    }
+    
+    private void initParseTimer() {
+        if (timeout > 0) {
+            // We use a single shared timer to conserve native threads
+            // and a jobId to recognize stale abort events
+            synchronized (abortTimer) {
+                asyncAborted = false;
+                ++abortTimerJobId;
+            }
+            final int jobId = abortTimerJobId;
+            abortTimer.schedule(new TimerTask() {
+                @Override
+                public void run() {
+                    synchronized (abortTimer) {
+                        if (abortTimerJobId == jobId)
+                            asyncAbort();
+                    }
+                }
+            }, timeout
+            );
+        } else {
+            asyncAborted = false;
+        }
+    }
+    
+    /**
+     * Sets the maximum amount of time to try and parse a file,
+     * before a {@link ParseTimeoutException} is thrown.
+     * 
+     * @param timeout  The maximum time to parse, in milliseconds.
+     */
+    public void setTimeout(int timeout) {
+        this.timeout = timeout;
+    }
+
+    private ATerm sglrParse(String startSymbol)
+            throws IOException, BadTokenException, TokenExpectedException,
+            ParseException, SGLRException {       
+        
+        try {
+            do {
+                readNextToken();                
+                //indentHandler.updateIndentation(currentToken);
+                //indentTokenHandler.handleIndentShifts(this);                
+                //recoverHandler.afterStreamRead(currentToken);
+                history.keepTokenAndState(this);
+                doParseStep(); 
+                //recoverHandler.afterParseStep();
+               // System.out.print((char)currentToken);             
+            } while (currentToken != SGLR.EOF && activeStacks.size() > 0);
+            
+            if (acceptingStack == null) {
+                collectedErrors.add(createBadTokenException()); 
+            }
+            
+            if(useIntegratedRecovery && acceptingStack==null){                
+                recoverIntegrator.recover();                              
+                if(acceptingStack==null && activeStacks.size()>0)
+                    return sglrParse(startSymbol);
+            } /*else if(recoverHandler.meetsRecoverCriteria()){
+                recoverHandler.recover();
+                if(acceptingStack==null)
+                    return sglrParse(startSymbol);
+            }*/
+           
+        } catch (CancellationException e) {
+            throw new ParseTimeoutException(this, currentToken, tokensSeen - 1, lineNumber,
+                    columnNumber, collectedErrors);
+        }           
+                
+        logAfterParsing();    
+        
+        Link s = acceptingStack.findDirectLink(startFrame);
+                
+        if (s == null)
+            throw new ParseException(this, "Accepting stack has no link");
+     
+        logParseResult(s);
+        Tools.debug("avoids: ", s.recoverCount);
+        //Tools.debug(s.label.toParseTree(parseTable));
+        
+        return disambiguator.applyFilters(this, s.label, startSymbol, tokensSeen);
+    }
+
+    void readNextToken() throws IOException {
+        logCurrentToken();            
+        currentToken = getNextToken();    
+    }
+
+    public void doParseStep() throws IOException {               
+        parseCharacter(); //applies reductions on active stack structure and fills forshifter                      
+        shifter(); //renewes active stacks with states in forshifter
+    }    
+
+    private void initParseVariables(InputStream fis) {        
+        startFrame = initActiveStacks();
+        tokensSeen = 0;
+        columnNumber = 0;
+        lineNumber = 1;        
+        currentInputStream = new PushbackInputStream(fis, 1024);
+        acceptingStack = null; 
+        //history.keepInitialState(this);
+        collectedErrors.clear();
+    }    
+
+     private BadTokenException createBadTokenException() {
+        Frame singlePreviousStack = activeStacks.size() == 1
+                ? activeStacks.get(0)
+                : null;
+        if (singlePreviousStack != null) {
+            Action action = singlePreviousStack.peek().getSingularAction();
+            
+            if (action != null && action.getActionItems().length == 1) {
+                StringBuilder expected = new StringBuilder();
+                
+                do {
+                    int token = action.getSingularRange();
+                    if (token == -1) break;
+                    expected.append((char) token);
+                    
+                    ActionItem[] items = action.getActionItems();
+                    
+                    if (!(items.length == 1 && items[0].type == ActionItem.SHIFT))
+                        break;
+                    
+                    Shift shift = (Shift) items[0];
+                    action = parseTable.getState(shift.nextState).getSingularAction();
+                                        
+                } while (action != null);
+
+                if (expected.length() > 0)
+                    return new TokenExpectedException(this, expected.toString(), currentToken,
+                                                     tokensSeen - 1, lineNumber, columnNumber);
+            }
+        }
+        
+        return new BadTokenException(this, currentToken, tokensSeen - 1, lineNumber,
+                                           columnNumber);
+    }
+
+    private void shifter() {
+        logBeforeShifter();
+        clearActiveStacks(false);
+
+        IParseNode prod = parseTable.lookupProduction(currentToken);
+
+        while (forShifter.size() > 0) {
+            ActionState as = forShifter.remove();
+            if (!parseTable.hasRejects() || !as.st.allLinksRejected()) {
+                Frame st1 = findStack(activeStacks, as.s);
+                if (st1 == null) {
+                    st1 = newStack(as.s);
+                    addStack(st1);
+                }
+                st1.addLink(as.st, prod, 1);
+            } else {
+                if (Tools.logging) {
+                    Tools.logger("Shifter: skipping rejected stack with state ",
+                                 as.st.state.stateNumber);
+                }
+            }
+        }
+        logAfterShifter();
+    }    
+
+    public void addStack(Frame st1) {
+        if(Tools.tracing) {
+            TRACE("SG_AddStack() - " + st1.state.stateNumber);
+        }
+        activeStacks.addFirst(st1);
+    }    
+
+    private void parseCharacter() throws IOException {
+        logBeforeParseCharacter();
+
+        ArrayDeque<Frame> actives = new ArrayDeque<Frame>(activeStacks); // FIXME avoid garbage        
+        clearForActorDelayed(false);
+        clearForShifter(false);
+        while (actives.size() > 0 || forActor.size() > 0) {
+            Frame st;
+            st = pickStackNodeFromActivesOrForActor(actives);
+            if (!st.allLinksRejected()) {
+                actor(st);
+            }
+            
+            if(actives.size() == 0 && forActor.size() == 0) {
+                fillForActorWithDelayedFrames(); //Fills foractor, clears foractor delayed
+            }
+        }
+        return;
+    }
+
+    private void fillForActorWithDelayedFrames() {
+        if(Tools.tracing) {
+            TRACE("SG_ - both empty");
+        }
+        forActor = forActorDelayed;
+        forActorDelayed = new ArrayDeque<Frame>(); // FIXME: avoid garbage
+    }
+
+    private Frame pickStackNodeFromActivesOrForActor(ArrayDeque<Frame> actives) {
+        Frame st;
+        if(actives.size() > 0) {
+            if(Tools.tracing) {
+                TRACE("SG_ - took active");
+            }
+            st = actives.remove();
+        } else {
+            if(Tools.tracing) {
+                TRACE("SG_ - took foractor");
+            }
+            st = forActor.remove();
+        }
+        return st;
+    }    
+
+    private void actor(Frame st) throws IOException {
+        State s = st.peek();
+        logBeforeActor(st, s);        
+        for (Action action : s.getActions()) {
+            if (action.accepts(currentToken)) {
+                for (ActionItem ai : action.getActionItems()) {                    
+                    switch (ai.type) {
+                        case ActionItem.SHIFT: {
+                            Shift sh = (Shift) ai;
+                            ActionState actState = new ActionState(st, parseTable.getState(sh.nextState));
+                            actState.currentToken = currentToken;                            
+                            addShiftPair(actState); //Adds StackNode to forshifter
+                            statsRecordParsers(); //sets some values un current parse state
+                            break;
+                        }
+                        case ActionItem.REDUCE: {
+                            Reduce red = (Reduce) ai;
+                            doReductions(st, red.production);
+                            break;
+                        }
+                        case ActionItem.REDUCE_LOOKAHEAD: {
+                            ReduceLookahead red = (ReduceLookahead) ai;
+                            if(checkLookahead(red)) {
+                                if(Tools.tracing) {
+                                    TRACE("SG_ - ok");
+                                }
+                                doReductions(st, red.production);
+                            }
+                            break;
+                        }
+                        case ActionItem.ACCEPT: {                            
+                            if (!st.allLinksRejected()) {
+                                acceptingStack = st;
+                                if (Tools.logging) {
+                                    Tools.logger("Reached the accept state");
+                                }
+                            }
+                            break;
+                        }
+                        default:
+                            throw new NotImplementedException();
+                     }
+                }
+            }            
+        }
+        
+        if(Tools.tracing) {
+            TRACE("SG_ - actor done");
+        }
+    }    
+
+    private boolean checkLookahead(ReduceLookahead red) throws IOException {
+        return doCheckLookahead(red, red.getCharRanges(), 0);
+    }
+    
+    private boolean doCheckLookahead(ReduceLookahead red, RangeList[] charClass, int pos) throws IOException {
+        if(Tools.tracing) {
+            TRACE("SG_CheckLookAhead() - ");
+        }
+        
+        int c = currentInputStream.read();
+        
+        // EOF
+        if(c == -1) 
+            return true;
+        
+        boolean permit = true;
+        
+        if(pos < charClass.length)
+            permit = charClass[pos].within(c) ? false : doCheckLookahead(red, charClass, pos + 1);
+
+        currentInputStream.unread(c);
+        return permit;
+    }
+
+    private void addShiftPair(ActionState state) {
+        if(Tools.tracing) {
+            TRACE("SG_AddShiftPair() - " + state.s.stateNumber);
+        }
+        forShifter.add(state);
+    }
+
+    private void statsRecordParsers() {
+        if (forShifter.size() > maxBranches) {
+            maxBranches = forShifter.size();
+            maxToken = currentToken;
+            maxColumn = columnNumber;
+            maxLine = lineNumber;
+            maxTokenNumber = tokensSeen;
+        }
+    }
+
+    private void doReductions(Frame st, Production prod) throws IOException {
+        if(recoverModeOk(st, prod)){
+            List<Path> paths = st.findAllPaths(prod.arity);         
+            logBeforeDoReductions(st, prod, paths.size());
+            reduceAllPaths(prod, paths);
+            logAfterDoReductions();
+        }
+    }
+    
+    private boolean recoverModeOk(Frame st, Production prod) {
+        return !prod.isRecoverProduction() || fineGrainedOnRegion;
+        
+    }
+    /*
+    private boolean recoverModeOk(Frame st, Production prod) {
+        if(useIntegratedRecovery && prod.isRecoverProduction() && !reduceRecoverOnly && recoverTolerance>0){
+           //if(findStack(recoveryActor, st.state)==null)
+            if(!recoveryActor.contains(st))
+                recoveryActor.addFirst(st);
+        }
+        // TODO: is this condition right??
+        return !useIntegratedRecovery || prod.isRecoverProduction() == reduceRecoverOnly;
+    }*/
+    
+    private void doLimitedReductions(Frame st, Production prod, Link l) throws IOException { //Todo: Look add sharing code with doReductions
+        if(recoverModeOk(st, prod)){
+            List<Path> paths = st.findLimitedPaths(prod.arity, l); //find paths containing the link         
+            logBeforeLimitedReductions(st, prod, l, paths);        
+            reduceAllPaths(prod, paths);
+        }
+    }
+
+    private void reduceAllPaths(Production prod, List<Path> paths)
+            throws IOException {
+        
+        for (int i = paths.size() - 1; i >= 0; i--) {
+            Path path = paths.get(i);
+            List<IParseNode> kids = path.getATerms();
+            Frame st0 = path.getEnd();
+            State next = parseTable.go(st0.peek(), prod.label);
+            logReductionPath(prod, path, kids, st0, next);
+            reducer(st0, next, prod, kids, path);
+        }
+        clearPath(paths);
+        
+        if (asyncAborted) {
+            // Rethrown as ParseTimeoutException in SGLR.sglrParse()
+            throw new CancellationException("Long-running parse job aborted");
+        }
+    }
+
+    
+    private void clearPath(List<Path> paths) {
+        if(Tools.tracing) {
+            SGLR.TRACE("SG_ClearPath() - " + paths.size());
+        }
+        paths.clear();
+    }
+
+    private void reducer(Frame st0, State s, Production prod, List<IParseNode> kids, Path path) throws IOException {
+        int length = path.getLength();        
+        int numberOfRecoveries = calcRecoverCount(prod, path); 
+        IParseNode t = prod.apply(kids);
+        Frame st1; 
+        Link nl;                   
+        logBeforeReducer(s, prod, length);
+        increaseReductionCount();        
+        st1 = findStack(activeStacks, s);
+        if (st1 == null) {             
+            if(prod.isRecoverProduction()){           
+                addNewRecoverStack(st0, s, prod, length, numberOfRecoveries, t); 
+                return;
+            } 
+            addNewStack(st0, s, prod, length, numberOfRecoveries, t); 
+        } else {
+            /* A stack with state s exists; check for ambiguities */
+            nl = st1.findDirectLink(st0);
+
+            if (nl != null) {
+                if(prod.isRecoverProduction()){           
+                    return;               
+                }   
+                logAmbiguity(st0, prod, st1, nl);
+                if (prod.isRejectProduction())
+                    nl.reject();               
+                if(numberOfRecoveries==0 && nl.recoverCount==0 || nl.isRejected())
+                    createAmbNode(t, nl);
+                else if (numberOfRecoveries < nl.recoverCount){                    
+                    nl.label=t;
+                    nl.recoverCount=numberOfRecoveries;
+                    actorOnActiveStacksOverNewLink(nl);                   
+                }
+                else if (numberOfRecoveries == nl.recoverCount){                    
+                    nl.label=t;                                      
+                }
+            } else {
+                if(prod.isRecoverProduction()){           
+                    addNewRecoverStack(st0, s, prod, length, numberOfRecoveries, t);
+                    return;
+                }    
+                nl = st1.addLink(st0, t, length);
+                nl.recoverCount = numberOfRecoveries;
+                if (prod.isRejectProduction()){
+                    nl.reject();    
+                    increaseRejectCount();
+                } 
+                logAddedLink(st0, st1, nl);              
+                actorOnActiveStacksOverNewLink(nl);
+            }
+        }
+        if(Tools.tracing) {
+            TRACE_ActiveStacks();
+            TRACE("SG_ - reducer done");
+        }
+    }
+    
+    /*private void handleAmbiguity(int numberOfRecoveries, IParseNode t, Link nl) throws IOException {        
+        //if both branches contain no recover productions and not in recover mode, create an Amb node.
+        //if(numberOfRecoveries == 0 && nl.recoverCount==0){            
+            if(recoverIntegrator==null)
+                createAmbNode(t, nl);
+            else if (!recoverIntegrator.isActive())
+                createAmbNode(t, nl);
+            return;
+        //}
+        //if (!nl.isRejected()) {            
+          //  int nlOld = nl.recoverCount;
+           // recoverDisambiguator.handleAmbiguity(numberOfRecoveries, t, nl);
+           // if (nl.recoverCount < nlOld)
+             //   actorOnActiveStacksOverNewLink(nl);
+        //}
+                        
+    }*/
+
+    void createAmbNode(IParseNode t, Link nl) {
+        nl.addAmbiguity(t, tokensSeen);
+        ambiguityManager.increaseAmbiguityCalls();
+    }
+    
+    private void addNewStack(Frame st0, State s, Production prod, int length,
+            int numberOfRecoveries, IParseNode t) {
+        Frame st1;
+        Link nl;
+        /* Found no existing stack with for state s; make new stack */
+        st1 = newStack(s);            
+        nl = st1.addLink(st0, t, length);
+        nl.recoverCount = numberOfRecoveries;   
+        addStack(st1);            
+        forActorDelayed.addFirst(st1);
+        if(Tools.tracing) {
+            TRACE("SG_AddStack() - " + st1.state.stateNumber);
+        }
+        if (prod.isRejectProduction()) {
+            if (Tools.logging) {
+                Tools.logger("Reject [new]");
+            }
+            nl.reject();
+            increaseRejectCount();
+        }
+    }  
+    
+    private void addNewRecoverStack(Frame st0, State s, Production prod, int length,
+            int numberOfRecoveries, IParseNode t) {
+        if (fineGrainedOnRegion && !prod.isRejectProduction()) {
+            Frame st1;
+            Link nl;
+            /* Found no existing stack with for state s; make new stack */
+            st1 = newStack(s);
+            nl = st1.addLink(st0, t, length);
+            nl.recoverCount = numberOfRecoveries;
+            recoverStacks.addFirst(st1);            
+        }
+    }  
+
+    private void actorOnActiveStacksOverNewLink(Link nl) throws IOException {
+        // Note: ActiveStacks can be modified inside doLimitedReductions
+        // new elements may be inserted at the beginning
+        final int sz = activeStacks.size();
+        for (int i = 0; i < sz; i++) {
+//                for(Frame st2 : activeStacks) {
+            if(Tools.tracing) {
+                TRACE("SG_ activeStack - ");
+            }
+            int pos = activeStacks.size() - sz + i;
+            Frame st2 = activeStacks.get(pos);
+            if (st2.allLinksRejected() || inReduceStacks(forActor, st2) || inReduceStacks(forActorDelayed, st2))
+                continue; //stacknode will find reduction in regular process
+
+            for (Action action : st2.peek().getActions()) {
+                if (action.accepts(currentToken)) {
+                    for (ActionItem ai : action.getActionItems()) {                  
+                        switch(ai.type) {
+                            case ActionItem.REDUCE:
+                                Reduce red = (Reduce) ai;
+                                doLimitedReductions(st2, red.production, nl);                           
+                                break;
+                            case ActionItem.REDUCE_LOOKAHEAD:
+                                ReduceLookahead red2 = (ReduceLookahead) ai;                         
+                                if(checkLookahead(red2)) {
+                                    doLimitedReductions(st2, red2.production, nl);                               
+                                }
+                                break;
+                        }
+                    }
+                }
+            }
+        }
+    }    
+
+    private int calcRecoverCount(Production prod, Path path) {
+        int numberOfRecoveries = path.getRecoverCount();
+        if(prod.isRecoverProduction())
+        {
+            numberOfRecoveries+=1;
+        }
+        return numberOfRecoveries;
+    }
+    
+    private boolean inReduceStacks(Queue<Frame> q, Frame frame) {
+        if(Tools.tracing) {
+            TRACE("SG_InReduceStacks() - " + frame.state.stateNumber);
+        }
+        return q.contains(frame);
+    }
+
+    protected Frame newStack(State s) {
+        if(Tools.tracing) {
+            TRACE("SG_NewStack() - " + s.stateNumber);
+        }
+        return new Frame(s);
+    }
+
+    private void increaseReductionCount() {
+        reductionCount++;
+    }
+
+    protected void increaseRejectCount() {
+        rejectCount++;
+    }
+
+    protected int getRejectCount() {
+        return rejectCount;
+    }
+
+    Frame findStack(ArrayDeque<Frame> stacks, State s) {
+        if(Tools.tracing) {
+            TRACE("SG_FindStack() - " + s.stateNumber);
+        }
+
+        // We need only check the top frames of the active stacks.
+        if (Tools.debugging) {
+            Tools.debug("findStack() - ", dumpActiveStacks());
+            Tools.debug(" looking for ", s.stateNumber);
+        }
+
+        final int size = stacks.size();
+        for (int i = 0; i < size; i++) {
+            if (stacks.get(i).state.stateNumber == s.stateNumber) {
+                if(Tools.tracing) {
+                    TRACE("SG_ - found stack");
+                }
+                return stacks.get(i);
+            }
+        }
+        if(Tools.tracing) {
+            TRACE("SG_ - stack not found");
+        }
+        return null;
+    }     
+   
+
+    private int getNextToken() throws IOException {
+        if(Tools.tracing) {
+            TRACE("SG_NextToken() - ");
+        }
+
+        int t = currentInputStream.read();
+        updateParserFields(t);
+        if(t==-1)
+            return SGLR.EOF;
+        return t;
+    }
+
+    protected void updateParserFields(int t) {
+        tokensSeen++;
+
+        if (Tools.debugging) {
+            Tools.debug("getNextToken() - ", t, "(", (char) t, ")");
+        }
+
+        switch (t) {
+        case '\n':
+            lineNumber++;
+            columnNumber = 0;
+            break;
+        case '\t':
+            columnNumber = (columnNumber / TAB_SIZE + 1) * TAB_SIZE;
+            break;
+        case -1:
+            break;
+        default:
+            columnNumber++;
+        }
+    }
+
+    static int num = 0;
+
+    @Deprecated
+    public void setFilter(boolean filter) {
+        getDisambiguator().setFilterAny(filter);
+    }
+
+    public void clear() {
+        if (this.acceptingStack != null) {
+            this.acceptingStack.clear();
+        }
+
+        clearActiveStacks(true);
+        clearForActorDelayed(true);
+        clearForActor(true);
+        clearForShifter(true);
+
+        this.parseTable = null;
+        this.factory = null;
+        this.ambiguityManager = null; // todo clear
+    }
+
+    private void clearForShifter(boolean all) {
+        if (all) {
+            for (ActionState as : forShifter) {
+                as.clear(all);
+            }
+        }
+        this.forShifter.clear();
+    }
+
+    private void clearForActor(boolean all) {
+        if (all) {
+            for (Frame frame : forActor) {
+                frame.clear();
+            }
+        }
+        forActor.clear();
+    }
+
+    private void clearForActorDelayed(boolean all) {
+        if (all) {
+            for (Frame frame : forActorDelayed) {
+                frame.clear();
+            }
+        }
+        forActorDelayed.clear(true);
+    }
+
+    private void clearActiveStacks(boolean all) {
+        if (all) {
+            for (Frame frame : activeStacks) {
+                frame.clear();
+            }
+        }
+        activeStacks.clear(true);
+    }
+
+    ParseTable getParseTable() {
+        return parseTable;
+    }
+
+    AmbiguityManager getAmbiguityManager() {
+        return ambiguityManager;
+    }
+    
+    public Disambiguator getDisambiguator() {
+        return disambiguator;
+    }
+    
+    public void setDisambiguator(Disambiguator disambiguator) {
+        this.disambiguator = disambiguator;
+    }
+
+    public ATermFactory getFactory() {
+        return factory;
+    }
+
+    public int getReductionCount() {
+        return reductionCount;
+    }
+
+    public int getRejectionCount() {
+        return rejectCount;
+    }
+    
+    @Deprecated
+    public static void setWorkAroundMultipleLookahead(boolean value) {
+        WORK_AROUND_MULTIPLE_LOOKAHEAD = value;
+    }   
+       
+
+      
+      
+    
+    ////////////////////////////////////////////////////// Log functions ///////////////////////////////////////////////////////////////////////////////
+    
+    static void TRACE(String string) {
+        System.err.println("[" + num + "] " + string);
+        num++;
+    }
+
+    private String dumpActiveStacks() {
+        StringBuffer sb = new StringBuffer();
+        boolean first = true;
+        if (activeStacks == null) {
+            sb.append(" GSS unitialized");
+        } else {
+            sb.append("{").append(activeStacks.size()).append("} ");
+            for (Frame f : activeStacks) {
+                if (!first)
+                    sb.append(", ");
+                sb.append(f.dumpStack());
+                first = false;
+            }
+        }
+        return sb.toString();
+    }
+
+    
+    private void logParseResult(Link s) {
+        if (isDebugging()) {
+            Tools.debug("internal parse tree:\n", s.label);
+        }
+
+        if(Tools.tracing) {
+            TRACE("SG_ - internal tree: " + s.label);
+        }       
+                
+        if (Tools.measuring) {
+            Measures m = new Measures();
+            //Tools.debug("Time (ms): " + (System.currentTimeMillis()-startTime));
+            m.setTime(System.currentTimeMillis() - startTime);
+            //Tools.debug("Red.: " + reductionCount);
+            m.setReductionCount(reductionCount);
+            //Tools.debug("Nodes: " + Frame.framesCreated);
+            m.setFramesCreated(Frame.framesCreated);
+            //Tools.debug("Links: " + Link.linksCreated);
+            m.setLinkedCreated(Link.linksCreated);
+            //Tools.debug("avoids: " + s.avoidCount);
+            m.setAvoidCount(s.recoverCount);
+            //Tools.debug("Total Time: " + parseTime);
+            m.setParseTime(parseTime);
+            //Tools.debug("Total Count: " + parseCount);
+            Measures.setParseCount(++parseCount);
+            //Tools.debug("Average Time: " + (int)parseTime / parseCount);
+            m.setAverageParseTime((int)parseTime / parseCount);
+            m.setRecoverTime(-1);
+            Tools.setMeasures(m);
+        }
+    }
+    
+
+    private void logBeforeParsing() {
+        if(Tools.tracing) {
+            TRACE("SG_Parse() - ");
+        }
+
+        if (Tools.debugging) {
+            Tools.debug("parse() - ", dumpActiveStacks());
+        }
+    }
+    
+    private void logAfterParsing()
+            throws BadTokenException, TokenExpectedException {
+        if (isLogging()) {
+            Tools.logger("Number of lines: ", lineNumber);
+            Tools.logger("Maximum ", maxBranches, " parse branches reached at token ",
+                         logCharify(maxToken), ", line ", maxLine, ", column ", maxColumn,
+                         " (token #", maxTokenNumber, ")");
+
+            long elapsed = System.currentTimeMillis() - startTime;
+            Tools.logger("Parse time: " + elapsed / 1000.0f + "s");
+        }
+
+        if (isDebugging()) {
+            Tools.debug("Parsing complete: all tokens read");
+        }
+
+        if (acceptingStack == null) {
+            BadTokenException bad = createBadTokenException();
+            if (collectedErrors.isEmpty()) {
+                throw bad;
+            } else {
+                collectedErrors.add(bad);
+                throw new MultiBadTokenException(this, collectedErrors);
+            }
+        }
+
+
+        if (isDebugging()) {
+            Tools.debug("Accepting stack exists");
+        }
+    }
+
+    private void logCurrentToken() {
+        if (isLogging()) {
+            Tools.logger("Current token (#", tokensSeen, "): ", logCharify(currentToken));
+        }
+    }
+    
+    private void logAfterShifter() {
+        if(Tools.tracing) {
+            TRACE("SG_DiscardShiftPairs() - ");
+            TRACE_ActiveStacks();
+        }
+    }
+
+    private void logBeforeShifter() {
+        if(Tools.tracing) {
+            TRACE("SG_Shifter() - ");
+            TRACE_ActiveStacks();
+        }
+        
+        if (Tools.logging) {
+            Tools.logger("#", tokensSeen, ": shifting ", forShifter.size(), " parser(s) -- token ",
+                         logCharify(currentToken), ", line ", lineNumber, ", column ", columnNumber);
+        }
+
+        if (Tools.debugging) {
+            Tools.debug("shifter() - " + dumpActiveStacks());
+
+            Tools.debug(" token   : " + currentToken);
+            Tools.debug(" parsers : " + forShifter.size());
+        }
+    }
+    
+    private void logBeforeParseCharacter() {
+        if(Tools.tracing) {
+            TRACE("SG_ParseToken() - ");
+        }
+
+        if (Tools.debugging) {
+            Tools.debug("parseCharacter() - " + dumpActiveStacks());
+            Tools.debug(" # active stacks : " + activeStacks.size());
+        }
+
+        /* forActor = *///computeStackOfStacks(activeStacks);
+
+        if (Tools.debugging) {
+            Tools.debug(" # for actor     : " + forActor.size());
+        }
+    }
+    
+    private String logCharify(int currentToken) {
+        switch (currentToken) {
+        case 32:
+            return "\\32";
+        case SGLR.EOF:
+            return "EOF";
+        case '\n':
+            return "\\n";
+        case 0:
+            return "\\0";
+        default:
+            return "" + (char) currentToken;
+        }
+    }
+    
+    private void logBeforeActor(Frame st, State s) {
+        List<ActionItem> actionItems = null;
+        
+        if (Tools.debugging || Tools.tracing) {
+            actionItems = s.getActionItems(currentToken);
+        }
+        
+        if(Tools.tracing) {
+            TRACE("SG_Actor() - " + st.state.stateNumber);
+            TRACE_ActiveStacks();
+        }
+        
+        if (Tools.debugging) {
+            Tools.debug("actor() - ", dumpActiveStacks());
+        }       
+
+        if (Tools.debugging) {
+            Tools.debug(" state   : ", s.stateNumber);
+            Tools.debug(" token   : ", currentToken);
+        }        
+
+        if (Tools.debugging) {
+            Tools.debug(" actions : ", actionItems);
+        }
+        
+        if(Tools.tracing) {
+            TRACE("SG_ - actions: " + actionItems.size());
+        }
+    }
+    
+    private void logAfterDoReductions() {
+        if (Tools.debugging) {
+            Tools.debug("<doReductions() - " + dumpActiveStacks());
+        }
+        
+        if(Tools.tracing) {
+            TRACE("SG_ - doreductions done");
+        }
+    }
+
+    private void logReductionPath(Production prod, Path path,
+            List<IParseNode> kids, Frame st0, State next) {
+        if (Tools.debugging) {
+            Tools.debug(" path: ", path);
+            Tools.debug(" kids: ", kids);        
+            Tools.debug(st0.state);
+        }            
+
+        if (Tools.logging) {
+            Tools.logger("Goto(", st0.peek().stateNumber, ",", prod.label + ") == ",
+                         next.stateNumber);
+        }
+    }   
+    
+
+    private void logBeforeDoReductions(Frame st, Production prod,
+            final int pathsCount) {
+        if(Tools.tracing) {
+            TRACE("SG_DoReductions() - " + st.state.stateNumber);
+        }
+
+        if (Tools.debugging) {
+            Tools.debug("doReductions() - " + dumpActiveStacks());
+            logReductionInfo(st, prod);       
+            Tools.debug(" paths : " + pathsCount);
+        }
+    }
+    
+    private void logBeforeLimitedReductions(Frame st, Production prod, Link l,
+            List<Path> paths) {
+        if(Tools.tracing) {
+            TRACE("SG_ - back in reducer ");
+            TRACE_ActiveStacks();
+            TRACE("SG_DoLimitedReductions() - " + st.state.stateNumber + ", " + l.parent.state.stateNumber);
+        }
+
+        if (Tools.debugging) {
+            Tools.debug("doLimitedReductions() - ", dumpActiveStacks());
+            logReductionInfo(st, prod);
+            List<?> reversePaths = (List<?>) ((ArrayList<?>) paths).clone();
+            Collections.reverse(reversePaths);
+            Tools.debug(reversePaths);
+        }
+    }
+
+    private void logReductionInfo(Frame st, Production prod) {
+        Tools.debug(" state : ", st.peek().stateNumber);
+        Tools.debug(" token : ", currentToken);
+        Tools.debug(" label : ", prod.label);
+        Tools.debug(" arity : ", prod.arity);
+        Tools.debug(" stack : ", st.dumpStack());
+    }
+
+    private void logAddedLink(Frame st0, Frame st1, Link nl) {
+        if (Tools.debugging) {
+            Tools.debug(" added link ", nl, " from ", st1.state.stateNumber, " to ",
+                        st0.state.stateNumber);
+        }               
+
+        if(Tools.tracing) {
+            TRACE_ActiveStacks();
+        }
+    }
+    
+    private void logBeforeReducer(State s, Production prod, int length) {
+        if(Tools.tracing) {
+            TRACE("SG_Reducer() - " + s.stateNumber + ", " + length + ", " + prod.label);
+            TRACE_ActiveStacks();
+        }
+
+        if (Tools.logging) {
+            Tools.logger("Reducing; state ", s.stateNumber, ", token: ", logCharify(currentToken),
+                         ", production: ", prod.label);
+        }
+
+        if (Tools.debugging) {
+            Tools.debug("reducer() - ", dumpActiveStacks());
+
+            Tools.debug(" state      : ", s.stateNumber);
+            Tools.debug(" token      : ", logCharify(currentToken) + " (" + currentToken + ")");
+            Tools.debug(" production : ", prod.label);
+        }
+    }
+
+    private void TRACE_ActiveStacks() {
+        TRACE("SG_ - active stacks: " + activeStacks.size());
+        TRACE("SG_ - for_actor stacks: " + forActor.size());
+        TRACE("SG_ - for_actor_delayed stacks: " + forActorDelayed.size());
+    }
+
+   
+    private void logAmbiguity(Frame st0, Production prod, Frame st1, Link nl) {
+        if (Tools.logging) {
+            Tools.logger("Ambiguity: direct link ", st0.state.stateNumber, " -> ",
+                         st1.state.stateNumber, " ", (prod.isRejectProduction() ? "{reject}" : ""));
+            if (nl.label instanceof ParseNode) {
+                Tools.logger("nl is ", nl.isRejected() ? "{reject}" : "", " for ",
+                             ((ParseNode) nl.label).label);
+            }
+        }
+
+        if (Tools.debugging) {
+            Tools.debug("createAmbiguityCluster - ", tokensSeen - nl.getLength() - 1, "/",
+                        nl.getLength());
+        }
+    }    
+    //-------------------------------------------------- mj: debug and recovery ------------------------
+        
+    //Used for debugging
+    private String mjInfo() {
+        String result = "";
+        result += "CURR TOKEN: " + (char)currentToken;
+        result += " ACTIVESTACKS: ";
+        for (Frame f : activeStacks) {
+            result += f.state.stateNumber;
+            if(f.minAvoidValue() > 0)
+                result += "$"+f.minAvoidValue() + "$";
+            result += "; ";            
+        }
+        result += " FORACTOR: ";
+        for (Frame f : forActor) {
+            result += f.state.stateNumber;
+            result += "; ";
+        }
+        result += " FORACTOR_DELAYED: ";
+        for (Frame f : forActorDelayed) {
+            result += f.state.stateNumber;
+            result += "; ";
+        }
+        result += " FORSHIFTER: ";
+        for (ActionState as : forShifter) {
+            result += "{ ";
+            result += as.st.state.stateNumber;
+            result+=",";
+            result += as.s.stateNumber;            
+            result += "} ; ";
+        }
+        return result;        
+    } 
+    
+    private String[] viewStackObject(boolean avoidFiltered){
+        List<String> stackPaths = new ArrayList<String>();
+        for (Frame actNode : activeStacks) {
+            List<String> testMJ = actNode.getStackPaths("", avoidFiltered);
+            stackPaths.addAll(testMJ);
+        }
+        return stackPaths.toArray(new String[stackPaths.size()]);
+    }  
+    
+    private String[] viewStackObject()
+    {
+        return viewStackObject(false);
+    }
+    
+    private String[] viewFilteredStackObject()
+    {
+        return viewStackObject(true);
+    }
+    
+    private void mjTesting() {        
+        Tools.debug((char)currentToken); 
+    }   
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/webdsl0.app
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/webdsl0.app	Thu Dec 16 15:02:04 2010	(r21518)
@@ -0,0 +1,191 @@
+module built-in
+
+  section methods for built-in types
+
+  type String { //includes other String-based types such as Secret, Patch, Email, URL, etc.
+    length():Int
+    toLowerCase():String
+    toUpperCase():String
+    replace(String,String):String
+    utils.StringType.parseUUID                   as parseUUID():UUID
+    org.webdsl.tools.Utils.containsDigit         as containsDigit():Bool
+    org.webdsl.tools.Utils.containsLowerCase     as containsLowerCase():Bool
+    org.webdsl.tools.Utils.containsUpperCase     as containsUpperCase():Bool
+    org.webdsl.tools.Utils.isCleanUrl            as isCleanUrl():Bool
+    org.apache.commons.lang.StringUtils.contains as contains(String):Bool // this 'contains' function handles null, null as either arg will produce false 
+    utils.StringType.parseInt                    as parseInt():Int
+    utils.StringType.split                       as split():List<String>
+    utils.StringType.splitWithSeparator          as split(String):List<String> //TODO Regex as argument
+  }
+  
+  type Secret {
+    org.webdsl.tools.Utils.secretDigest  as digest():Secret
+    org.webdsl.tools.Utils.secretCheck   as check(Secret):Bool
+  }
+  
+  type Patch {
+    name.fraser.neil.plaintext.patch_factory.patchApply  as applyPatch(String):String
+  }
+  type String {
+    name.fraser.neil.plaintext.patch_factory.patchMake   as makePatch(String):Patch
+    name.fraser.neil.plaintext.patch_factory.diff        as diff(String):List<String>
+  }
+  
+  type DateTime { // includes Date and Time types
+    utils.DateType.format as format(String):String
+    before(DateTime):Bool
+    after(DateTime):Bool
+    getTime():Long
+    setTime(Long)
+  }
+
+//  section JSON for services
+      
+  native class org.json.JSONObject as JSONObject {
+    constructor()
+    constructor(String)
+    get(String) : Object
+    getBoolean(String) : Bool
+    getDouble(String) : Double
+    getInt(String) : Int
+    getJSONArray(String) : JSONArray
+    getJSONObject(String) : JSONObject
+    getString(String) : String
+    has(String) : Bool
+    names() : JSONArray
+    put(String, Object)
+    toString() : String
+    toString(Int) : String
+  }
+  
+  native class org.json.JSONArray as JSONArray {
+    constructor()
+    constructor(String)
+    get(Int) : Object
+    getBoolean(Int) : Bool
+    getDouble(Int) : Double
+    getInt(Int) : Int
+    getJSONArray(Int) : JSONArray
+    getJSONObject(Int) : JSONObject
+    getString(Int) : String
+    length() : Int
+    join(String) : String
+    put(Object)
+    remove(Int)
+    toString() : String
+    toString(Int) : String
+  } 
+  
+//  section WebDriver for testing
+  
+  native class org.openqa.selenium.WebDriver as WebDriver {
+    get(String)
+    getTitle():String
+    getPageSource():String
+    findElement(SelectBy):WebElement
+    findElements(SelectBy):List<WebElement>
+    close()
+  }
+  
+  native class org.openqa.selenium.By as SelectBy {
+    static id(String):SelectBy
+    static linkText(String):SelectBy
+    static name(String):SelectBy
+    static partialLinkText(String):SelectBy
+    static tagName(String):SelectBy
+    static xpath(String):SelectBy
+  } 
+  
+  native class org.openqa.selenium.WebElement as WebElement {
+    getText():String
+    getValue():String
+    getElementName():String
+    isEnabled():Bool
+    sendKeys(String)
+    submit()
+    clear()
+    click()
+    getAttribute(String):String
+    isEnabled():Bool
+    isSelected():Bool
+    //void 	sendKeys(java.lang.CharSequence... keysToSend)
+    setSelected()
+    toggle():Bool
+  }
+  
+  native class org.openqa.selenium.htmlunit.HtmlUnitDriver as HtmlUnitDriver : WebDriver {
+    constructor()
+  }
+  
+  native class org.openqa.selenium.firefox.FirefoxDriver as FirefoxDriver : WebDriver {
+    constructor()
+  }
+  
+//email
+
+  entity QueuedEmail {
+    body :: String (length=1000000) //Note: default length for string is currently 255
+    to :: String (length=1000000)
+    cc :: String (length=1000000)
+    bcc :: String (length=1000000)
+    replyTo :: String (length=1000000)
+    from :: String (length=1000000)
+    subject :: String (length=1000000)
+  }
+  
+  invoke internalHandleEmailQueue() every 30 seconds
+
+  function internalHandleEmailQueue(){
+    var queuedEmails := from QueuedEmail limit 5;
+    
+    for(queuedEmail:QueuedEmail in queuedEmails){
+      queuedEmail.delete();
+      flush();
+      sendemail(sendQueuedEmail(queuedEmail));
+      //normally you would use email(sendQueuedEmail(queuedEmail)) to send email, however, 
+      //that is desugared to renderemail(queuedEmail).save() to make it asynchronous.
+      //In this function the email is actually send, using the synchronous sendemail function.
+    }
+  }
+  
+  define email sendQueuedEmail(q:QueuedEmail){
+    to(q.to)
+    from(q.from)
+    subject(q.subject)
+    cc(q.cc)
+    bcc(q.bcc)
+    replyTo(q.replyTo)
+    rawoutput{ //don't escape the html from internal email rendering
+      output(q.body)
+    }
+  }
+  
+// radio buttons input
+
+  define ignore-access-control validate radio(ent1:Ref<Entity>,ent2:List<Entity>){
+    var rname := getUniqueTemplateId()
+    var tmp : String:= getRequestParameter(rname);
+    var subme : Entity := null;
+    init{
+      if(tmp != null){
+        subme := loadEntity(ent1.getTypeString(),UUIDFromString(tmp));
+      }
+    }
+    for(e:Entity in ent2){
+      <input type="radio"
+        //either it was submitted or it was not submitted but the value was already p
+        if(tmp != null && subme == e || tmp == null && ent1 == e){
+           checked="checked"
+        }
+        name=rname
+        value=e.id
+        all attributes
+      />
+      output(e.name)
+    }
+    databind{
+      if(tmp != null && subme in ent2){
+        ent1 := subme;
+      }
+    }
+  }
\ No newline at end of file

From karltk at strategoxt.org  Thu Dec 16 16:02:22 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:02:22 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21519 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt: src/org/spoofax/jsglr
	src/org/spoofax/jsglr/client test/org/spoofax/jsglr/tests
Message-ID: <201012161502.oBGF2MRw026963@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:02:21 2010
New Revision: 21519
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21519&sc=1

Log:
* Starting to throw away collection classes wherever we can.

Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/FileTools.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Frame.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentInfo.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Path.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIParseNode.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/FileTools.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/FileTools.java	Thu Dec 16 15:02:04 2010	(r21518)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/FileTools.java	Thu Dec 16 15:02:21 2010	(r21519)
@@ -7,8 +7,8 @@
 public class FileTools {
 
 	public static String loadFileAsString(String fn) {
-		// FIXME (KTK) static allocation of 7MB must be replaced with something dynamic  
-		char[] cbuf = new char[1024*1024*7];
+		// FIXME (KTK) static allocation of 15MB must be replaced with something dynamic  
+		char[] cbuf = new char[1024*1024*15];
 		try {
 			BufferedReader br = new BufferedReader(new FileReader(fn));
 			int len = br.read(cbuf);

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Frame.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Frame.java	Thu Dec 16 15:02:04 2010	(r21518)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Frame.java	Thu Dec 16 15:02:21 2010	(r21519)
@@ -77,7 +77,7 @@
         if (arity == 0) {
             Path n = Path.valueOf(node, null, this, length);
             if(Tools.tracing) {
-                SGLR.TRACE("SG_NewPath() - " + state.stateNumber + ", " + n.length);
+                SGLR.TRACE("SG_NewPath() - " + state.stateNumber + ", " + length);
             }
             collect.add(n);
         } else { 
@@ -259,7 +259,7 @@
         if (arity == 0 && seen) {
             Path n = Path.valueOf(node, null, this, length);
             if(Tools.tracing) {
-                SGLR.TRACE("SG_NewPath() - " + state.stateNumber + ", " + n.length);
+                SGLR.TRACE("SG_NewPath() - " + state.stateNumber + ", " + length);
             }
             collect.add(n);
         } else if(arity > 0) {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentInfo.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentInfo.java	Thu Dec 16 15:02:04 2010	(r21518)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentInfo.java	Thu Dec 16 15:02:21 2010	(r21519)
@@ -87,8 +87,8 @@
                 int length = p.getLength(); //length => total_length, p => reduce_length, p.p => layout_length (-shift), p.p.p => shift_length (=1)                 
                 if(length > maxPathLength){
                     maxPathLength = length;
-                    if(p.parent.label!=null)
-                        result =p.parent.link;
+                    if(p.getParent().getLabel()!=null)
+                        result =p.getParent().getLink();
                 }
             }
         }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Path.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Path.java	Thu Dec 16 15:02:04 2010	(r21518)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Path.java	Thu Dec 16 15:02:21 2010	(r21519)
@@ -8,97 +8,116 @@
 package org.spoofax.jsglr.client;
 
 import java.util.ArrayList;
-import java.util.Iterator;
 import java.util.List;
 
-public class Path /*implements Iterable<IParseNode>*/ {
 
-    public final Path parent;
+public class Path {
 
-    public final IParseNode label;
-
-    public final Frame frame;
-
-    protected final int length;
-    
-    public final Link link;
-
-    Path(Path parent, Link link, Frame frame, int length) {
-    	this.parent = parent;
-        this.link = link;
-        if(link != null){
-            this.label = link.label;
+	private Path parent;
+	private IParseNode label;
+	private Frame frame;
+	private int length;
+	private int parentCount;
+	private Link link;
+
+	public int getRecoverCount()
+	{
+		int result = 0;
+		if(link != null) {
+			result += link.recoverCount;           
+		}
+		if(parent != null) {
+			// TODO find out relation linktoparent/parent
+			result += parent.getRecoverCount();
+		}
+		return result;        
+	}
+
+	public int getRecoverCount(int maxCharLength)
+	{
+		if(parent == null || this.length <= maxCharLength)
+			return getRecoverCount();
+		return parent.getRecoverCount(maxCharLength);
+	}
+
+	public static boolean logNewInstanceCreation = false;
+
+	public Path reuse(Path parent, Link link, Frame frame, int length, int parentCount) {
+		this.parent = parent;
+		this.link = link;
+		this.frame = frame;
+		this.length = length;
+		this.parentCount = parentCount;
+		if(link != null){
+			this.label = link.label;
         } else {
             this.label = null;
         }
-        this.frame = frame;
-        this.length = length;
-    }
-
-    public int getRecoverCount()
-    {
-        int result = 0;
-        if(link != null) {
-            result += link.recoverCount;           
-        }
-        if(parent != null) {
-        	// TODO find out relation linktoparent/parent
-            result += parent.getRecoverCount();
-        }
-        return result;        
-    }
-    
-    public int getRecoverCount(int maxCharLength)
-    {
-        if(parent == null || this.length <= maxCharLength)
-            return getRecoverCount();
-        return parent.getRecoverCount(maxCharLength);
-    }
-
-    public static boolean logNewInstanceCreation = false;
-
-    public static Path valueOf(Path parent, Link ln, Frame frame, int length) {
-        return new Path(parent, ln, frame, length);
-    }
-
-
-    public Frame getEnd() {
-        return frame;
-    }
-
-    public final List<IParseNode> getATerms() {
-        ArrayList<IParseNode> ret = new ArrayList<IParseNode>();
-        for (Path n = parent; n != null; n = n.parent) {
-            ret.add(n.label);
-        }
-        return ret;
-    }
-
-    public String toString() {
-        StringBuilder sb = new StringBuilder();
-        boolean first = true;
-        sb.append("<");
-        for (Path p = this; p != null; p = p.parent) {
-            if (!first) {
-                sb.append(", ");
-            }
-            sb.append(p.frame.state.stateNumber);
-            first = false;
+		assert length >= 0;
+		assert parentCount >= 0;
+		return this;
+	}
+
+	public Frame getEnd() {
+		return frame;
+	}
+
+	public final List<IParseNode> getParseNodes() {
+		List<IParseNode> ret = new ArrayList<IParseNode>();
+
+		int pos = 0;
+		for (Path n = parent; n != null; n = n.parent) {
+			ret.add(n.label);
+		}
+
+		return ret;
+	}
+
+	public String toString() {
+		StringBuilder sb = new StringBuilder();
+		boolean first = true;
+		sb.append("<");
+		for (Path p = this; p != null; p = p.parent) {
+			if (!first) {
+				sb.append(", ");
+			}
+			sb.append(p.frame.state.stateNumber);
+			first = false;
+		}
+		sb.append(">");
+		return sb.toString();
+	}
+
+	public int getLength() {
+		return length;
+	}
+
+	public Path getParent() {
+		return parent;
+	}
+
+	public IParseNode getLabel() {
+		return label;
+	}
+
+	public Link getLink() {
+		return link;
+	}
+
+	public static Path valueOf(Path parent, Link link, Frame frame, int length/*, int parentCount*/) {
+		Path r = new Path();
+		r.parent = parent;
+		r.link = link;
+		if(link != null){
+            r.label = link.label;
+        } else {
+            r.label = null;
         }
-        sb.append(">");
-        return sb.toString();
-    }
-
-    public int getLength() {
-    	return length;
-    }
-
-//    private class 
-//	@Override
-//	public Iterator<IParseNode> iterator() {
-//		// TODO Auto-generated method stub
-//		return null;
-//	}
-
+		r.frame = frame;
+		r.length = length;
+		r.parentCount = -1; //parentCount;
+		return r;
+	}
 }
 
+

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 15:02:04 2010	(r21518)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 15:02:21 2010	(r21519)
@@ -547,7 +547,9 @@
 
         for (int i = paths.size() - 1; i >= 0; i--) {
             Path path = paths.get(i);
-            List<IParseNode> kids = path.getATerms();
+            List<IParseNode> kids = new ArrayList<IParseNode>();
+            for(IParseNode p : path.getParseNodes())
+            	kids.add(p);
             Frame st0 = path.getEnd();
             State next = parseTable.go(st0.peek(), prod.label);
             logReductionPath(prod, path, kids, st0, next);

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:02:04 2010	(r21518)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:02:21 2010	(r21519)
@@ -7,13 +7,12 @@
  */
 package org.spoofax.jsglr.tests;
 
-import java.io.BufferedReader;
-import java.io.FileReader;
-import java.io.IOException;
+import java.util.Arrays;
 
 import junit.framework.TestCase;
 
 import org.spoofax.jsglr.FileTools;
+import org.spoofax.jsglr.client.Frame;
 import org.spoofax.jsglr.client.InvalidParseTableException;
 import org.spoofax.jsglr.client.ParseTable;
 import org.spoofax.jsglr.client.ParserException;

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIParseNode.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIParseNode.java	Thu Dec 16 15:02:04 2010	(r21518)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIParseNode.java	Thu Dec 16 15:02:21 2010	(r21519)
@@ -10,12 +10,12 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import junit.framework.TestCase;
+
 import org.spoofax.jsglr.client.IParseNode;
 import org.spoofax.jsglr.client.ParseNode;
 import org.spoofax.jsglr.client.ParseProductionNode;
 
-import junit.framework.TestCase;
-
 public class TestIParseNode extends TestCase {
 
     private IParseNode pn0; 

From karltk at strategoxt.org  Thu Dec 16 16:02:29 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:02:29 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21520 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt: src/org/spoofax/jsglr
	src/org/spoofax/jsglr/client test/org/spoofax/jsglr/tests
Message-ID: <201012161502.oBGF2TiF026968@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:02:29 2010
New Revision: 21520
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21520&sc=1

Log:
* First bash at pooling the path objects.

Added:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/PathPool.java
Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Frame.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IParseNode.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentInfo.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseAvoid.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParsePrefer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseProductionNode.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseReject.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Path.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Production.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java	Thu Dec 16 15:02:21 2010	(r21519)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java	Thu Dec 16 15:02:29 2010	(r21520)
@@ -43,6 +43,7 @@
         boolean waitForProfiler = false;
         boolean timing = false;
         boolean heuristicFilters = false;
+        boolean buildParseTree = true;
         int profilingRuns = 0;
         
         for(int i=0;i<args.length;i++) {
@@ -70,6 +71,8 @@
             	profilingRuns = Integer.parseInt(args[++i]);
             } else if(args[i].equals("--timing")) {
             	timing = true;
+            } else if(args[i].equals("--recognize")) {
+            	buildParseTree = false;
             } else {
                 System.err.println("Unknown option: " + args[i]);
                 System.exit(1);
@@ -91,6 +94,7 @@
         sglr.getDisambiguator().setFilterCycles(detectCycles);
         sglr.getDisambiguator().setFilterAny(filter);
         sglr.getDisambiguator().setHeuristicFilters(heuristicFilters);
+        sglr.setBuildParseTree(buildParseTree);
         
         if(waitForProfiler) {
         	System.err.println("Hit enter to start profiling...");
@@ -125,7 +129,7 @@
         ATerm t=null;
         try {
         	parsingTime = System.currentTimeMillis();
-            t=sglr.parse(FileTools.loadFileAsString(input), startSymbol);            
+            t = sglr.parse(FileTools.loadFileAsString(input), startSymbol);            
             parsingTime = System.currentTimeMillis() - parsingTime;            
         } catch(BadTokenException e) {
             System.err.println("Parsing failed : " + e.getMessage());

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java	Thu Dec 16 15:02:21 2010	(r21519)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java	Thu Dec 16 15:02:29 2010	(r21520)
@@ -55,16 +55,6 @@
     }
 
     @Override
-	@Deprecated
-    void clear() {
-        for (int i = 0; i < alternatives.size(); i++) {
-            alternatives.get(i).clear();
-        }
-        alternatives.clear();
-        cachedHashCode = NO_HASH_CODE;
-    }
-
-    @Override
     public String toString() {
         return "amb(" + alternatives + ")";
     }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java	Thu Dec 16 15:02:21 2010	(r21519)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java	Thu Dec 16 15:02:29 2010	(r21520)
@@ -480,7 +480,7 @@
         if(firstKid instanceof Amb) {
 
             List<IParseNode> ambs = ((Amb)firstKid).getAlternatives();
-            List<IParseNode> restKids = kids.subList(1, t.kids.size() - 1);
+            List<IParseNode> restKids = kids.subList(1, t.kids.length - 1);
 
             for (int i = 0, max = ambs.size(); i < max; i++) {
                 IParseNode amb = ambs.get(i);
@@ -814,8 +814,8 @@
         // Work-around for http://bugs.strategoxt.org/browse/SPI-5 (Permissive grammars introduce ambiguities for literals)
 
         if (left instanceof ParseNode && right instanceof ParseNode) {
-            List<IParseNode> leftKids = ((ParseNode) left).kids;
-            List<IParseNode> rightKids = ((ParseNode) right).kids;
+            List<IParseNode> leftKids = ((ParseNode) left).getKids();
+            List<IParseNode> rightKids = ((ParseNode) right).getKids();
             if (leftKids.size() > 0 && rightKids.size() == 1) {
                 if (leftKids.get(0) instanceof ParseProductionNode && rightKids.get(0).equals(left)) {
                     return FILTER_LEFT_WINS;
@@ -1046,7 +1046,7 @@
             Label prod = getLabel(t);
 
             while (prod.isInjection()) {
-                t = ((ParseNode) t).getKids().get(0);
+                t = ((ParseNode) t).kids[0];
 
 
                 if (t instanceof ParseNode) {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Frame.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Frame.java	Thu Dec 16 15:02:21 2010	(r21519)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Frame.java	Thu Dec 16 15:02:29 2010	(r21520)
@@ -9,7 +9,6 @@
 
 import java.io.Serializable;
 import java.util.ArrayList;
-import java.util.LinkedList;
 import java.util.List;
 
 import org.spoofax.jsglr.shared.Tools;
@@ -63,29 +62,27 @@
         return state;
     }
 
-    public List<Path> findAllPaths(int arity) {
-        ArrayList<Path> ret = new ArrayList<Path>(arity);
-        doComputePathsToRoot(ret, null, arity, 0);
-        return ret;
+    public void findAllPaths(PathPool pool, int arity) {
+    	doComputePathsToRoot(pool, null, arity, 0, 0);
     }
 
-    private void doComputePathsToRoot(List<Path> collect, Path node, int arity, int length) {
-        if(Tools.tracing) {
+    private void doComputePathsToRoot(PathPool pool, Path node, int arity, int parentCount, int length) {
+        
+    	if(Tools.tracing) {
             SGLR.TRACE("SG_FindAllPaths() - " + arity + ", " + length);
         }
 
         if (arity == 0) {
-            Path n = Path.valueOf(node, null, this, length);
+            pool.rememberPath(node, null, this, length, parentCount);
             if(Tools.tracing) {
                 SGLR.TRACE("SG_NewPath() - " + state.stateNumber + ", " + length);
             }
-            collect.add(n);
         } else { 
             for (int i = 1; i <= stepsCount; i++) {
-                Link ln = steps[stepsCount - i];
+                Link link = steps[stepsCount - i];
                 
-                Path n = Path.valueOf(node, ln, this, ln.getLength());
-                ln.parent.doComputePathsToRoot(collect, n, arity - 1, length + ln.getLength());
+                Path n = pool.makePath(node, link, this, link.getLength(), parentCount);
+                link.parent.doComputePathsToRoot(pool, n, arity - 1, parentCount + 1, length + link.getLength());
             }
         }
     }
@@ -120,6 +117,8 @@
     }   
     
 
+    static public int[] counter = new int[1000];
+    
     public Link addLink(Frame st0, IParseNode n, int length) {
         if(Tools.tracing) {
             SGLR.TRACE("SG_AddLink() - " + state.stateNumber + ", " + st0.state.stateNumber + ", " + length);
@@ -127,7 +126,7 @@
         if(stepsCount >= steps.length) {
             resizeSteps();
         }
-        
+        counter[stepsCount]++;
         return steps[stepsCount++] = new Link(st0, n, length); 
     }
 
@@ -204,16 +203,14 @@
         return sb.toString();
     }
 
-    public List<Path> findLimitedPaths(int arity, Link l) {
+    public void findLimitedPaths(PathPool pool, int arity, Link l) {
         if(Tools.tracing) {
             SGLR.TRACE("SG_FindLimitedPaths() - " + arity + ", " + l.getLength() + ", " + l.parent.state.stateNumber);
             TRACE_DumpLinks(steps);
         }
-        List<Path> ret = new ArrayList<Path>(arity);
         if(findLink(arity, l)) { 
-            doComputePathsToRoot(ret, null, l, false, arity, 0);
+            doComputePathsToRoot(pool, null, l, false, arity, 0, 0);
         } 
-        return ret;
     }
 
     private void TRACE_DumpLinks(Link[] st) {
@@ -250,24 +247,23 @@
         return false;
     }
 
-    private void doComputePathsToRoot(List<Path> collect, Path node, Link l,
-      boolean seen, int arity, int length) {
+    private void doComputePathsToRoot(PathPool pool, Path node, Link l,
+      boolean seen, int arity, int parentCount, int length) {
         if(Tools.tracing) {
             SGLR.TRACE("SG_FindPaths() - " + arity);
         }
 
         if (arity == 0 && seen) {
-            Path n = Path.valueOf(node, null, this, length);
+            pool.rememberPath(node, null, this, length, parentCount);
             if(Tools.tracing) {
                 SGLR.TRACE("SG_NewPath() - " + state.stateNumber + ", " + length);
             }
-            collect.add(n);
         } else if(arity > 0) {
             for (int i = 0; i < stepsCount; i++) {
                 Link ln = steps[stepsCount - i - 1];
                 boolean seenIt = seen || (ln == l);
-                Path n = Path.valueOf(node, ln, this, ln.getLength());
-                ln.parent.doComputePathsToRoot(collect, n, l, seenIt, arity - 1, length + ln.getLength());
+                Path n = pool.makePath(node, ln, this, ln.getLength(), arity - length);
+                ln.parent.doComputePathsToRoot(pool, n, l, seenIt, arity - 1, parentCount + 1, length + ln.getLength());
             }
         }
     }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IParseNode.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IParseNode.java	Thu Dec 16 15:02:21 2010	(r21519)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IParseNode.java	Thu Dec 16 15:02:29 2010	(r21520)
@@ -15,8 +15,6 @@
 
     public abstract ATerm toParseTree(ParseTable pt);
 
-    @Deprecated
-    abstract void clear();
     @Override
 	abstract public boolean equals(Object obj);
     @Override

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentInfo.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentInfo.java	Thu Dec 16 15:02:21 2010	(r21519)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentInfo.java	Thu Dec 16 15:02:29 2010	(r21520)
@@ -60,15 +60,20 @@
     /*
      * Calculates the biggest reduce belonging to this backtrack point.
      */
+    private PathPool staticPathPool = new PathPool(64);
     public int maxReduceLength() {
         int maxPathLength = 0;
         for (Frame activeStack : stackNodes) {
-            for (Path p : activeStack.findAllPaths(2)) {//3=> shifted_LO, reduced_LO, ReducedCodeFragment
-                int length = p.getLength(); //length => total_length, p => reduce_length, p.p => layout_length (-shift), p.p.p => shift_length (=1)                 
+        	staticPathPool.start();
+        	activeStack.findAllPaths(staticPathPool, 2);
+        	for(int i = 0; i < staticPathPool.size(); i++) {
+        		// 3=> shifted_LO, reduced_LO, ReducedCodeFragment
+                int length = staticPathPool.get(i).getLength(); //length => total_length, p => reduce_length, p.p => layout_length (-shift), p.p.p => shift_length (=1)                 
                 if(length > maxPathLength){
                     maxPathLength = length;                   
                 }
             }
+        	staticPathPool.end();
         }
         return maxPathLength;
     }    
@@ -83,12 +88,14 @@
         int maxPathLength = -1;
         Link result=null;
         for (Frame activeStack : stackNodes) {
-            for (Path p : activeStack.findAllPaths(3)) {//3=> shifted_LO, reduced_LO, ReducedCodeFragment
+        	activeStack.findAllPaths(staticPathPool, 3);
+            for(int i = 0; i < staticPathPool.size(); i++ ) {//3=> shifted_LO, reduced_LO, ReducedCodeFragment
+            	Path p = staticPathPool.get(i);
                 int length = p.getLength(); //length => total_length, p => reduce_length, p.p => layout_length (-shift), p.p.p => shift_length (=1)                 
                 if(length > maxPathLength){
                     maxPathLength = length;
-                    if(p.getParent().getLabel()!=null)
-                        result =p.getParent().getLink();
+                    if(p.getParent().getLabel() != null)
+                        result = p.getParent().getLink();
                 }
             }
         }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseAvoid.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseAvoid.java	Thu Dec 16 15:02:21 2010	(r21519)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseAvoid.java	Thu Dec 16 15:02:29 2010	(r21520)
@@ -7,13 +7,11 @@
  */
 package org.spoofax.jsglr.client;
 
-import java.util.List;
-
 import org.spoofax.jsglr.shared.terms.ATerm;
 
 public class ParseAvoid extends ParseNode {
 
-    public ParseAvoid(int label, List<IParseNode> kids) {
+    public ParseAvoid(int label, IParseNode[] kids) {
         super(label, kids);
     }
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java	Thu Dec 16 15:02:21 2010	(r21519)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java	Thu Dec 16 15:02:29 2010	(r21520)
@@ -7,6 +7,7 @@
  */
 package org.spoofax.jsglr.client;
 
+import java.util.Arrays;
 import java.util.List;
 
 import org.spoofax.jsglr.shared.terms.ATerm;
@@ -17,22 +18,27 @@
 
     public final int label;
 
-    protected final List<IParseNode> kids;
+    protected final IParseNode[] kids;
 
     private int cachedHashCode;
 
-    public ParseNode(int label, List<IParseNode> kids) {
+    public ParseNode(int label, IParseNode[] kids) {
         this.label = label;
         this.kids = kids;
     }
 
+    public ParseNode(int label, List<IParseNode> kids) {
+        this.label = label;
+        this.kids = kids.toArray(new IParseNode[kids.size()]);
+    }
+
     @Override
 	public ATerm toParseTree(ParseTable pt) {
         ATermFactory factory = pt.getFactory();
 
         ATermList l1 = factory.makeList();
-        for (int i = kids.size() - 1; i >= 0; i--) {
-            l1 = l1.prepend(kids.get(i).toParseTree(pt));
+        for (int i = kids.length - 1; i >= 0; i--) {
+            l1 = l1.prepend(kids[i].toParseTree(pt));
         }
 
         return factory.makeAppl(pt.applAFun, pt.getProduction(label), l1);
@@ -56,16 +62,10 @@
 
     public int getLabel() { return label; }
 
-    public List<IParseNode> getKids() { return kids; }
-
-    @Override
-	@Deprecated
-    void clear() {
-        for (int i = 0; i < kids.size(); i++) {
-            kids.get(i).clear();
-        }
-        kids.clear();
-        cachedHashCode = NO_HASH_CODE;
+    @Deprecated
+    public List<IParseNode> getKids() {
+    	// FIXME remove this method; should return the kids directly
+    	return Arrays.asList(kids);
     }
 
     @Override
@@ -75,11 +75,11 @@
         if (obj == this)
             return true;
         ParseNode o = (ParseNode)obj;
-        if(label != o.label || kids.size() != o.kids.size()
+        if(label != o.label || kids.length != o.kids.length
                 || hashCode() != o.hashCode())
             return false;
-        for(int i=0;i<kids.size();i++) {
-            if(!kids.get(i).equals(o.kids.get(i)))
+        for(int i = 0; i < kids.length; i++) {
+            if(!kids[i].equals(o.kids[i]))
                 return false;
         }
         return true;
@@ -99,6 +99,6 @@
 
     @Override
     public String toStringShallow() {
-        return "regular*(" + label + ", {" +  kids.size() + "})";
+        return "regular*(" + label + ", {" +  kids.length + "})";
     }
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParsePrefer.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParsePrefer.java	Thu Dec 16 15:02:21 2010	(r21519)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParsePrefer.java	Thu Dec 16 15:02:29 2010	(r21520)
@@ -7,13 +7,11 @@
  */
 package org.spoofax.jsglr.client;
 
-import java.util.List;
-
 import org.spoofax.jsglr.shared.terms.ATerm;
 
 public class ParsePrefer extends ParseNode {
 
-    public ParsePrefer(int label, List<IParseNode> kids) {
+    public ParsePrefer(int label, IParseNode[] kids) {
         super(label, kids);
     }
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseProductionNode.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseProductionNode.java	Thu Dec 16 15:02:21 2010	(r21519)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseProductionNode.java	Thu Dec 16 15:02:29 2010	(r21520)
@@ -35,8 +35,6 @@
         return prod == ((ParseProductionNode)obj).prod;
     }
 
-    @Override
-    void clear() {}
 
     @Override
     public int hashCode() {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseReject.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseReject.java	Thu Dec 16 15:02:21 2010	(r21519)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseReject.java	Thu Dec 16 15:02:29 2010	(r21520)
@@ -7,13 +7,11 @@
  */
 package org.spoofax.jsglr.client;
 
-import java.util.List;
-
 import org.spoofax.jsglr.shared.terms.ATerm;
 
 public class ParseReject extends ParseNode {
 
-    public ParseReject(int label, List<IParseNode> kids) {
+    public ParseReject(int label, IParseNode[] kids) {
         super(label, kids);
     }
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Path.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Path.java	Thu Dec 16 15:02:21 2010	(r21519)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Path.java	Thu Dec 16 15:02:29 2010	(r21520)
@@ -62,12 +62,12 @@
 		return frame;
 	}
 
-	public final List<IParseNode> getParseNodes() {
-		List<IParseNode> ret = new ArrayList<IParseNode>();
+	public final IParseNode[] getParseNodes() {
+		IParseNode[] ret = new IParseNode[parentCount];
 
 		int pos = 0;
 		for (Path n = parent; n != null; n = n.parent) {
-			ret.add(n.label);
+			ret[pos++] = n.label;
 		}
 
 		return ret;
@@ -104,20 +104,20 @@
 		return link;
 	}
 
-	public static Path valueOf(Path parent, Link link, Frame frame, int length/*, int parentCount*/) {
-		Path r = new Path();
-		r.parent = parent;
-		r.link = link;
-		if(link != null){
-            r.label = link.label;
-        } else {
-            r.label = null;
-        }
-		r.frame = frame;
-		r.length = length;
-		r.parentCount = -1; //parentCount;
-		return r;
-	}
+//	public static Path valueOf(Path parent, Link link, Frame frame, int length/*, int parentCount*/) {
+//		Path r = new Path();
+//		r.parent = parent;
+//		r.link = link;
+//		if(link != null){
+//            r.label = link.label;
+//        } else {
+//            r.label = null;
+//        }
+//		r.frame = frame;
+//		r.length = length;
+//		r.parentCount = -1; //parentCount;
+//		return r;
+//	}
 }
 
 

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/PathPool.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/PathPool.java	Thu Dec 16 15:02:29 2010	(r21520)
@@ -0,0 +1,83 @@
+package org.spoofax.jsglr.client;
+
+
+public class PathPool {
+
+	int rememberIndex;
+	int allocIndex;
+	Path[] pool;
+	int usage;
+	
+	public static int maxRemembered;
+	public static int maxAllocated;
+	
+	public PathPool(int capacity) {
+		allocIndex = 1;
+		rememberIndex = 0;
+		usage = 0;
+		pool = new Path[capacity];
+	}
+	
+	public Path rememberPath(Path parent, Link link, Frame frame, int length, int parentCount) {
+		Path p;
+		if(pool[rememberIndex] == null) {
+			p = new Path();
+			pool[rememberIndex] = p;
+		} else {
+			p = pool[rememberIndex];
+		}
+		rememberIndex++;
+		return p.reuse(parent, link, frame, length, parentCount);
+    }
+	
+	public Path makePath(Path parent, Link link, Frame frame, int length, int parentCount) {
+		Path p;
+		int index = pool.length - allocIndex; 
+		if(pool[index] == null) {
+			p = new Path();
+			pool[index] = p;
+		} else {
+			p = pool[index];
+		}
+		allocIndex++;
+		return p.reuse(parent, link, frame, length, parentCount);
+    }
+
+	public int size() {
+		return rememberIndex;
+	}
+	
+	public Path get(int index) {
+		return pool[index];
+	}
+
+	public void end() {
+		usage--;
+		if(usage != 0)
+			throw new IllegalStateException("Must always end() the PathPool after use");
+		maxRemembered = Math.max(maxRemembered, rememberIndex);
+		maxAllocated = Math.max(maxAllocated, allocIndex);
+	}
+	
+	public static int poolMisses = 0;
+	
+	private static PathPool level2 = null;
+	
+	public PathPool start() {
+		if(usage == 0) {
+			usage++;
+			rememberIndex = 0;
+			allocIndex = 1;
+			return this;
+		} else if (level2 != null && level2.usage == 0) {
+			return level2.start();
+		} else {
+			// FIXME (KTK) count misses
+			poolMisses++;
+			
+			PathPool n = new PathPool(pool.length);
+			level2 = n;
+			return n.start();
+		}
+	}
+}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Production.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Production.java	Thu Dec 16 15:02:21 2010	(r21519)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Production.java	Thu Dec 16 15:02:29 2010	(r21520)
@@ -7,10 +7,12 @@
  */
 package org.spoofax.jsglr.client;
 
-import static org.spoofax.jsglr.client.ProductionType.*;
+import static org.spoofax.jsglr.client.ProductionType.AVOID;
+import static org.spoofax.jsglr.client.ProductionType.NO_TYPE;
+import static org.spoofax.jsglr.client.ProductionType.PREFER;
+import static org.spoofax.jsglr.client.ProductionType.REJECT;
 
 import java.io.Serializable;
-import java.util.List;
 
 public class Production implements Serializable {
 
@@ -31,7 +33,7 @@
         this.isRecover = isRecover;
     }
 
-    public IParseNode apply(List<IParseNode> kids) {
+    public IParseNode apply(IParseNode[] kids) {
         switch(status) {
         case REJECT:
             return new ParseReject(label, kids);

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 15:02:21 2010	(r21519)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 15:02:29 2010	(r21520)
@@ -7,8 +7,7 @@
  */
 package org.spoofax.jsglr.client;
 
-import java.util.ArrayList;
-import java.util.Collections;
+import java.util.Arrays;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Queue;
@@ -84,6 +83,8 @@
 
     private PushbackStringIterator currentInputStream;
 
+    private boolean buildParseTree = true;
+    
     //Creates indent- and dedent- tokens
     //Meant for parsing of indentation based languages
     //TODO: still under construction
@@ -107,8 +108,8 @@
     /* START: FINE GRAINED ON REGION */
     private boolean fineGrainedOnRegion;
     protected void setFineGrainedOnRegion(boolean fineGrainedMode) {
-        fineGrainedOnRegion=fineGrainedMode;
-        recoverStacks=new ArrayDeque<Frame>();
+        fineGrainedOnRegion = fineGrainedMode;
+        recoverStacks = new ArrayDeque<Frame>();
     }
 
     public void clearRecoverStacks(){
@@ -281,7 +282,10 @@
         Tools.debug("avoids: ", s.recoverCount);
         //Tools.debug(s.label.toParseTree(parseTable));
 
-        return disambiguator.applyFilters(this, s.label, startSymbol, tokensSeen);
+        if(buildParseTree)
+        	return disambiguator.applyFilters(this, s.label, startSymbol, tokensSeen);
+        else
+        	return null;
     }
 
     void readNextToken() {
@@ -511,12 +515,16 @@
         }
     }
 
+    private PathPool staticPathPool = new PathPool(1024);
+    
     private void doReductions(Frame st, Production prod) {
-        if(recoverModeOk(st, prod)){
-            List<Path> paths = st.findAllPaths(prod.arity);
-            logBeforeDoReductions(st, prod, paths.size());
-            reduceAllPaths(prod, paths);
+        if(recoverModeOk(st, prod)) {
+        	staticPathPool.start();
+            st.findAllPaths(staticPathPool, prod.arity);
+            logBeforeDoReductions(st, prod, staticPathPool.size());
+            reduceAllPaths(prod, staticPathPool);
             logAfterDoReductions();
+            staticPathPool.end();
         }
     }
 
@@ -535,27 +543,28 @@
         return !useIntegratedRecovery || prod.isRecoverProduction() == reduceRecoverOnly;
     }*/
 
+    PathPool defaultPool = new PathPool(512);
+	
     private void doLimitedReductions(Frame st, Production prod, Link l) { //Todo: Look add sharing code with doReductions
-        if(recoverModeOk(st, prod)){
-            List<Path> paths = st.findLimitedPaths(prod.arity, l); //find paths containing the link
-            logBeforeLimitedReductions(st, prod, l, paths);
-            reduceAllPaths(prod, paths);
+        if(recoverModeOk(st, prod)) {
+        	PathPool limitedPool = defaultPool.start();
+        	st.findLimitedPaths(limitedPool, prod.arity, l); //find paths containing the link
+            logBeforeLimitedReductions(st, prod, l, limitedPool);
+            reduceAllPaths(prod, limitedPool);
+            limitedPool.end();
         }
     }
 
-    private void reduceAllPaths(Production prod, List<Path> paths) {
+    private void reduceAllPaths(Production prod, PathPool paths) {
 
-        for (int i = paths.size() - 1; i >= 0; i--) {
-            Path path = paths.get(i);
-            List<IParseNode> kids = new ArrayList<IParseNode>();
-            for(IParseNode p : path.getParseNodes())
-            	kids.add(p);
+        for(int i = 0; i < paths.size(); i++) {
+        	Path path = paths.get(i);
+            IParseNode[] kids = path.getParseNodes();
             Frame st0 = path.getEnd();
             State next = parseTable.go(st0.peek(), prod.label);
-            logReductionPath(prod, path, kids, st0, next);
+            logReductionPath(prod, path, st0, next);
             reducer(st0, next, prod, kids, path);
         }
-        clearPath(paths);
 
         if (asyncAborted) {
             // Rethrown as ParseTimeoutException in SGLR.sglrParse()
@@ -564,14 +573,7 @@
     }
 
 
-    private void clearPath(List<Path> paths) {
-        if(Tools.tracing) {
-            SGLR.TRACE("SG_ClearPath() - " + paths.size());
-        }
-        paths.clear();
-    }
-
-    private void reducer(Frame st0, State s, Production prod, List<IParseNode> kids, Path path) {
+    private void reducer(Frame st0, State s, Production prod, IParseNode[] kids, Path path) {
         int length = path.getLength();
         int numberOfRecoveries = calcRecoverCount(prod, path);
         IParseNode t = prod.apply(kids);
@@ -1125,11 +1127,9 @@
         }
     }
 
-    private void logReductionPath(Production prod, Path path,
-            List<IParseNode> kids, Frame st0, State next) {
+    private void logReductionPath(Production prod, Path path, Frame st0, State next) {
         if (Tools.debugging) {
             Tools.debug(" path: ", path);
-            Tools.debug(" kids: ", kids);
             Tools.debug(st0.state);
         }
 
@@ -1154,7 +1154,7 @@
     }
 
     private void logBeforeLimitedReductions(Frame st, Production prod, Link l,
-            List<Path> paths) {
+            PathPool paths) {
         if(Tools.tracing) {
             TRACE("SG_ - back in reducer ");
             TRACE_ActiveStacks();
@@ -1164,9 +1164,7 @@
         if (Tools.debugging) {
             Tools.debug("doLimitedReductions() - ", dumpActiveStacks());
             logReductionInfo(st, prod);
-            List<?> reversePaths = (List<?>) ((ArrayList<?>) paths).clone();
-            Collections.reverse(reversePaths);
-            Tools.debug(reversePaths);
+            Tools.debug(Arrays.asList(paths));
         }
     }
 
@@ -1231,4 +1229,8 @@
                         nl.getLength());
         }
     }
+
+	public void setBuildParseTree(boolean buildParseTree) {
+		this.buildParseTree = buildParseTree;
+	}
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:02:21 2010	(r21519)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:02:29 2010	(r21520)
@@ -16,6 +16,7 @@
 import org.spoofax.jsglr.client.InvalidParseTableException;
 import org.spoofax.jsglr.client.ParseTable;
 import org.spoofax.jsglr.client.ParserException;
+import org.spoofax.jsglr.client.PathPool;
 import org.spoofax.jsglr.client.SGLR;
 import org.spoofax.jsglr.shared.Tools;
 import org.spoofax.jsglr.shared.terms.ATerm;
@@ -105,7 +106,10 @@
 		//			}
 		//
 		//		});
-
+		
+		System.out.println(PathPool.poolMisses);
+		System.out.println(PathPool.maxRemembered);
+		System.out.println(PathPool.maxAllocated);
 	}
 
 	private void doCompare(String s, final ATerm parsed) {

From karltk at strategoxt.org  Thu Dec 16 16:02:36 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:02:36 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21521 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt: src/org/spoofax/jsglr
	src/org/spoofax/jsglr/client test/org/spoofax/jsglr/tests
Message-ID: <201012161502.oBGF2a4E026971@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:02:35 2010
New Revision: 21521
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21521&sc=1

Log:
* Added --no-tree-build option for only running the parser, with no subsequent tree construction.
 * Added cleanup of performance counters between each parse.
 * Separate doReductions() from doLimitedReductions() cases -- the later may be recursive.
 * Added an extra cache layer to PathListPool, but this probably has no effect.

Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Frame.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentInfo.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java	Thu Dec 16 15:02:29 2010	(r21520)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java	Thu Dec 16 15:02:35 2010	(r21521)
@@ -71,7 +71,7 @@
             	profilingRuns = Integer.parseInt(args[++i]);
             } else if(args[i].equals("--timing")) {
             	timing = true;
-            } else if(args[i].equals("--recognize")) {
+            } else if(args[i].equals("--no-tree-build")) {
             	buildParseTree = false;
             } else {
                 System.err.println("Unknown option: " + args[i]);

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Frame.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Frame.java	Thu Dec 16 15:02:29 2010	(r21520)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Frame.java	Thu Dec 16 15:02:35 2010	(r21521)
@@ -62,11 +62,11 @@
         return state;
     }
 
-    public void findAllPaths(PathPool pool, int arity) {
+    public void findAllPaths(PooledPathList pool, int arity) {
     	doComputePathsToRoot(pool, null, arity, 0, 0);
     }
 
-    private void doComputePathsToRoot(PathPool pool, Path node, int arity, int parentCount, int length) {
+    private void doComputePathsToRoot(PooledPathList pool, Path node, int arity, int parentCount, int length) {
         
     	if(Tools.tracing) {
             SGLR.TRACE("SG_FindAllPaths() - " + arity + ", " + length);
@@ -203,7 +203,7 @@
         return sb.toString();
     }
 
-    public void findLimitedPaths(PathPool pool, int arity, Link l) {
+    public void findLimitedPaths(PooledPathList pool, int arity, Link l) {
         if(Tools.tracing) {
             SGLR.TRACE("SG_FindLimitedPaths() - " + arity + ", " + l.getLength() + ", " + l.parent.state.stateNumber);
             TRACE_DumpLinks(steps);
@@ -247,7 +247,7 @@
         return false;
     }
 
-    private void doComputePathsToRoot(PathPool pool, Path node, Link l,
+    private void doComputePathsToRoot(PooledPathList pool, Path node, Link l,
       boolean seen, int arity, int parentCount, int length) {
         if(Tools.tracing) {
             SGLR.TRACE("SG_FindPaths() - " + arity);

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentInfo.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentInfo.java	Thu Dec 16 15:02:29 2010	(r21520)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentInfo.java	Thu Dec 16 15:02:35 2010	(r21521)
@@ -60,20 +60,21 @@
     /*
      * Calculates the biggest reduce belonging to this backtrack point.
      */
-    private PathPool staticPathPool = new PathPool(64);
+    private PooledPathList indentPathCache = new PooledPathList(64, true);
+    
     public int maxReduceLength() {
         int maxPathLength = 0;
         for (Frame activeStack : stackNodes) {
-        	staticPathPool.start();
-        	activeStack.findAllPaths(staticPathPool, 2);
-        	for(int i = 0; i < staticPathPool.size(); i++) {
+        	indentPathCache.start();
+        	activeStack.findAllPaths(indentPathCache, 2);
+        	for(int i = 0; i < indentPathCache.size(); i++) {
         		// 3=> shifted_LO, reduced_LO, ReducedCodeFragment
-                int length = staticPathPool.get(i).getLength(); //length => total_length, p => reduce_length, p.p => layout_length (-shift), p.p.p => shift_length (=1)                 
+                int length = indentPathCache.get(i).getLength(); //length => total_length, p => reduce_length, p.p => layout_length (-shift), p.p.p => shift_length (=1)                 
                 if(length > maxPathLength){
                     maxPathLength = length;                   
                 }
             }
-        	staticPathPool.end();
+        	indentPathCache.end();
         }
         return maxPathLength;
     }    
@@ -88,9 +89,9 @@
         int maxPathLength = -1;
         Link result=null;
         for (Frame activeStack : stackNodes) {
-        	activeStack.findAllPaths(staticPathPool, 3);
-            for(int i = 0; i < staticPathPool.size(); i++ ) {//3=> shifted_LO, reduced_LO, ReducedCodeFragment
-            	Path p = staticPathPool.get(i);
+        	activeStack.findAllPaths(indentPathCache, 3);
+            for(int i = 0; i < indentPathCache.size(); i++ ) {//3=> shifted_LO, reduced_LO, ReducedCodeFragment
+            	Path p = indentPathCache.get(i);
                 int length = p.getLength(); //length => total_length, p => reduce_length, p.p => layout_length (-shift), p.p.p => shift_length (=1)                 
                 if(length > maxPathLength){
                     maxPathLength = length;

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 15:02:29 2010	(r21520)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 15:02:35 2010	(r21521)
@@ -85,6 +85,8 @@
 
     private boolean buildParseTree = true;
     
+    PathListPool pathCache = new PathListPool();
+    
     //Creates indent- and dedent- tokens
     //Meant for parsing of indentation based languages
     //TODO: still under construction
@@ -307,6 +309,9 @@
         acceptingStack = null;
         //history.keepInitialState(this);
         collectedErrors.clear();
+        
+        PooledPathList.resetPerformanceCounters();
+        PathListPool.resetPerformanceCounters();
     }
 
      private BadTokenException createBadTokenException() {
@@ -515,16 +520,16 @@
         }
     }
 
-    private PathPool staticPathPool = new PathPool(1024);
+    private PooledPathList reductionsPathCache = new PooledPathList(512, true);
     
     private void doReductions(Frame st, Production prod) {
         if(recoverModeOk(st, prod)) {
-        	staticPathPool.start();
-            st.findAllPaths(staticPathPool, prod.arity);
-            logBeforeDoReductions(st, prod, staticPathPool.size());
-            reduceAllPaths(prod, staticPathPool);
+        	PooledPathList paths = reductionsPathCache.start();
+            st.findAllPaths(paths, prod.arity);
+            logBeforeDoReductions(st, prod, paths.size());
+            reduceAllPaths(prod, paths);
             logAfterDoReductions();
-            staticPathPool.end();
+            paths.end();
         }
     }
 
@@ -543,11 +548,11 @@
         return !useIntegratedRecovery || prod.isRecoverProduction() == reduceRecoverOnly;
     }*/
 
-    PathPool defaultPool = new PathPool(512);
+    
 	
     private void doLimitedReductions(Frame st, Production prod, Link l) { //Todo: Look add sharing code with doReductions
         if(recoverModeOk(st, prod)) {
-        	PathPool limitedPool = defaultPool.start();
+        	PooledPathList limitedPool = pathCache.create();
         	st.findLimitedPaths(limitedPool, prod.arity, l); //find paths containing the link
             logBeforeLimitedReductions(st, prod, l, limitedPool);
             reduceAllPaths(prod, limitedPool);
@@ -555,7 +560,7 @@
         }
     }
 
-    private void reduceAllPaths(Production prod, PathPool paths) {
+    private void reduceAllPaths(Production prod, PooledPathList paths) {
 
         for(int i = 0; i < paths.size(); i++) {
         	Path path = paths.get(i);
@@ -1154,7 +1159,7 @@
     }
 
     private void logBeforeLimitedReductions(Frame st, Production prod, Link l,
-            PathPool paths) {
+            PooledPathList paths) {
         if(Tools.tracing) {
             TRACE("SG_ - back in reducer ");
             TRACE_ActiveStacks();

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:02:29 2010	(r21520)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:02:35 2010	(r21521)
@@ -16,7 +16,8 @@
 import org.spoofax.jsglr.client.InvalidParseTableException;
 import org.spoofax.jsglr.client.ParseTable;
 import org.spoofax.jsglr.client.ParserException;
-import org.spoofax.jsglr.client.PathPool;
+import org.spoofax.jsglr.client.PathListPool;
+import org.spoofax.jsglr.client.PooledPathList;
 import org.spoofax.jsglr.client.SGLR;
 import org.spoofax.jsglr.shared.Tools;
 import org.spoofax.jsglr.shared.terms.ATerm;
@@ -107,9 +108,9 @@
 		//
 		//		});
 		
-		System.out.println(PathPool.poolMisses);
-		System.out.println(PathPool.maxRemembered);
-		System.out.println(PathPool.maxAllocated);
+		System.out.println(PathListPool.cacheMisses);
+		System.out.println(PooledPathList.maxRemembered);
+		System.out.println(PooledPathList.maxAllocated);
 	}
 
 	private void doCompare(String s, final ATerm parsed) {

From karltk at strategoxt.org  Thu Dec 16 16:02:41 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:02:41 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21522 -
	spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client
Message-ID: <201012161502.oBGF2fTW026974@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:02:41 2010
New Revision: 21522
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21522&sc=1

Log:
* Renamed

Deleted:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/PathPool.java

From karltk at strategoxt.org  Thu Dec 16 16:02:46 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:02:46 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21523 -
	spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client
Message-ID: <201012161502.oBGF2kRX026978@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:02:46 2010
New Revision: 21523
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21523&sc=1

Log:
* Oops.

Added:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/PathListPool.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/PooledPathList.java

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/PathListPool.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/PathListPool.java	Thu Dec 16 15:02:46 2010	(r21523)
@@ -0,0 +1,34 @@
+package org.spoofax.jsglr.client;
+
+
+public class PathListPool {
+
+	private PooledPathList p0 = new PooledPathList(512, false);
+	private PooledPathList p1 = new PooledPathList(512, false);
+	private PooledPathList p2 = new PooledPathList(512, false);
+	private PooledPathList p3 = new PooledPathList(512, false);
+	
+	public static int cacheMisses = 0;
+	
+	public PooledPathList create() {
+		if(p0.usage == 0)
+			return p0.start();
+		if(p1.usage == 0)
+			return p1.start();
+		if(p2.usage == 0)
+			return p2.start();
+		if(p3.usage == 0)
+			return p3.start();
+	
+		cacheMisses++;
+		p3 = p2;
+		p2 = p1;
+		p1 = p0;
+		p0 = new PooledPathList(512, false);
+		return p0.start();
+	}
+	
+	public static void resetPerformanceCounters() {
+		cacheMisses = 0;
+	}
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/PooledPathList.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/PooledPathList.java	Thu Dec 16 15:02:46 2010	(r21523)
@@ -0,0 +1,80 @@
+package org.spoofax.jsglr.client;
+
+
+public class PooledPathList {
+
+	int rememberIndex;
+	int allocIndex;
+	Path[] pool;
+	int usage;
+	
+	public static int maxRemembered;
+	public static int maxAllocated;
+	
+	public PooledPathList(int capacity, boolean deepInit) {
+		allocIndex = 1;
+		rememberIndex = 0;
+		usage = 0;
+		pool = new Path[capacity];
+		for(int i = 0; i < capacity; i++) {
+			pool[i] = new Path();
+		}
+	}
+	
+	public Path rememberPath(Path parent, Link link, Frame frame, int length, int parentCount) {
+		Path p;
+		if(pool[rememberIndex] == null) {
+			p = new Path();
+			pool[rememberIndex] = p;
+		} else {
+			p = pool[rememberIndex];
+		}
+		rememberIndex++;
+		return p.reuse(parent, link, frame, length, parentCount);
+    }
+	
+	public Path makePath(Path parent, Link link, Frame frame, int length, int parentCount) {
+		Path p;
+		int index = pool.length - allocIndex; 
+		if(pool[index] == null) {
+			p = new Path();
+			pool[index] = p;
+		} else {
+			p = pool[index];
+		}
+		allocIndex++;
+		return p.reuse(parent, link, frame, length, parentCount);
+    }
+
+	public int size() {
+		return rememberIndex;
+	}
+	
+	public Path get(int index) {
+		return pool[index];
+	}
+
+	public void end() {
+		usage--;
+		if(usage != 0)
+			throw new IllegalStateException("Must always end() the PooledPathList after use");
+		maxRemembered = Math.max(maxRemembered, rememberIndex);
+		maxAllocated = Math.max(maxAllocated, allocIndex);
+	}
+	
+	
+	public PooledPathList start() {
+		if(usage == 0) {
+			usage++;
+			rememberIndex = 0;
+			allocIndex = 1;
+			return this;
+		} 
+		throw new IllegalStateException("PooledPathList may not be used recursively");
+	}
+	
+	public static void resetPerformanceCounters() {
+		maxRemembered = 0;
+		maxAllocated = 0;
+	}
+}

From karltk at strategoxt.org  Thu Dec 16 16:02:53 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:02:53 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21524 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt: src/org/spoofax/jsglr/client
	src/org/spoofax/jsglr/shared/terms test/org/spoofax/jsglr/tests
Message-ID: <201012161502.oBGF2rOG026986@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:02:52 2010
New Revision: 21524
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21524&sc=1

Log:
* Renamed IParseNode to AbstractParseNode.

Added:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/AbstractParseNode.java
Deleted:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IParseNode.java
Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/AmbKey.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/AmbiguityManager.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Frame.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Link.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseAvoid.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParsePrefer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseProductionNode.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseReject.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Path.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Production.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/RecoverDisambiguator.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermFactory.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIParseNode.java

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/AbstractParseNode.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/AbstractParseNode.java	Thu Dec 16 15:02:52 2010	(r21524)
@@ -0,0 +1,26 @@
+/*
+ * Created on 30.mar.2006
+ *
+ * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
+ *
+ * Licensed under the GNU General Public License, v2
+ */
+package org.spoofax.jsglr.client;
+
+import org.spoofax.jsglr.shared.terms.ATerm;
+
+public abstract class AbstractParseNode {
+
+    protected static final int NO_HASH_CODE = 0;
+
+    public abstract ATerm toParseTree(ParseTable pt);
+
+    @Override
+	abstract public boolean equals(Object obj);
+    @Override
+	abstract public int hashCode();
+
+    abstract public String toStringShallow();
+    @Override
+	abstract public String toString();
+}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java	Thu Dec 16 15:02:46 2010	(r21523)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java	Thu Dec 16 15:02:52 2010	(r21524)
@@ -15,19 +15,19 @@
 import org.spoofax.jsglr.shared.terms.ATermList;
 
 
-public class Amb extends IParseNode {
+public class Amb extends AbstractParseNode {
 
-    private final List<IParseNode> alternatives;
+    private final List<AbstractParseNode> alternatives;
 
     private int cachedHashCode = NO_HASH_CODE;
 
-    Amb(IParseNode left, IParseNode right) {
-        alternatives = new ArrayList<IParseNode>(2);
+    Amb(AbstractParseNode left, AbstractParseNode right) {
+        alternatives = new ArrayList<AbstractParseNode>(2);
         alternatives.add(left);
         alternatives.add(right);
     }
 
-    public Amb(List<IParseNode> alternatives) {
+    public Amb(List<AbstractParseNode> alternatives) {
         this.alternatives = alternatives;
     }
 
@@ -44,7 +44,7 @@
             ATermList list) {
 
         for (int i = alternatives.size() - 1; i >= 0; i--) {
-            IParseNode alt = alternatives.get(i);
+            AbstractParseNode alt = alternatives.get(i);
             if (alt instanceof Amb) {
                 list = ((Amb) alt).addToParseTree(pt, factory, list);
             } else {
@@ -59,11 +59,11 @@
         return "amb(" + alternatives + ")";
     }
 
-    public boolean hasAmbiguity(IParseNode newNode) {
+    public boolean hasAmbiguity(AbstractParseNode newNode) {
         throw new NotImplementedException();
     }
 
-    public List<IParseNode> getAlternatives() {
+    public List<AbstractParseNode> getAlternatives() {
         return alternatives;
     }
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/AmbKey.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/AmbKey.java	Thu Dec 16 15:02:46 2010	(r21523)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/AmbKey.java	Thu Dec 16 15:02:52 2010	(r21524)
@@ -10,10 +10,10 @@
 
 public class AmbKey {
 
-    private IParseNode key;
+    private AbstractParseNode key;
     private int pos;
     
-    AmbKey(IParseNode key, int pos) {
+    AmbKey(AbstractParseNode key, int pos) {
         this.key = key;
         this.pos = pos;
     }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/AmbiguityManager.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/AmbiguityManager.java	Thu Dec 16 15:02:46 2010	(r21523)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/AmbiguityManager.java	Thu Dec 16 15:02:52 2010	(r21524)
@@ -58,7 +58,7 @@
         ambiguitiesCount++;
     }
 
-    public int getClusterIndex(IParseNode t, int pos) {
+    public int getClusterIndex(AbstractParseNode t, int pos) {
         if(SGLR.isDebugging()) {
             Tools.debug("getClusterIndex()");
             Tools.debug(" t - " + t);

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java	Thu Dec 16 15:02:46 2010	(r21523)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java	Thu Dec 16 15:02:52 2010	(r21524)
@@ -181,7 +181,7 @@
         setDefaultFilters();
     }
 
-    public ATerm applyFilters(SGLR parser, IParseNode root, String sort, int inputLength) throws SGLRException, FilterException {
+    public ATerm applyFilters(SGLR parser, AbstractParseNode root, String sort, int inputLength) throws SGLRException, FilterException {
         try {
             if(SGLR.isDebugging()) {
                 Tools.debug("applyFilters()");
@@ -189,7 +189,7 @@
 
             initializeFromParser(parser);
 
-            IParseNode t = root;
+            AbstractParseNode t = root;
 
             t = applyTopSortFilter(sort, t);
 
@@ -233,11 +233,11 @@
         Tools.logger("Number of Injection Counts: ", ambiguityManager.getInjectionCount());
     }
 
-    private ATerm yieldTree(IParseNode t) {
+    private ATerm yieldTree(AbstractParseNode t) {
         return t.toParseTree(parser.getParseTable());
     }
 
-    private ATerm convertToATerm(IParseNode t) {
+    private ATerm convertToATerm(AbstractParseNode t) {
 
         if (SGLR.isDebugging()) {
             Tools.debug("convertToATerm: ", t);
@@ -257,7 +257,7 @@
                                                 parseTable.getFactory().makeInt(ambCount));
     }
 
-    private IParseNode applyCycleDetectFilter(IParseNode t) throws FilterException {
+    private AbstractParseNode applyCycleDetectFilter(AbstractParseNode t) throws FilterException {
 
         if (SGLR.isDebugging()) {
             Tools.debug("applyCycleDetectFilter() - ", t);
@@ -274,7 +274,7 @@
         return t;
     }
 
-    private ATerm getProduction(IParseNode t) {
+    private ATerm getProduction(AbstractParseNode t) {
         if (t instanceof ParseNode) {
             return parseTable.getProduction(((ParseNode) t).getLabel());
         } else {
@@ -282,7 +282,7 @@
         }
     }
 
-    private IParseNode applyTopSortFilter(String sort, IParseNode t) throws SGLRException {
+    private AbstractParseNode applyTopSortFilter(String sort, AbstractParseNode t) throws SGLRException {
 
         if (SGLR.isDebugging()) {
             Tools.debug("applyTopSortFilter() - ", t);
@@ -309,8 +309,8 @@
         }
     }
 
-    private IParseNode selectOnTopSort(IParseNode t, String sort) throws FilterException {
-        List<IParseNode> results = new ArrayList<IParseNode>();
+    private AbstractParseNode selectOnTopSort(AbstractParseNode t, String sort) throws FilterException {
+        List<AbstractParseNode> results = new ArrayList<AbstractParseNode>();
 
         if (t instanceof Amb) {
             addTopSortAlternatives(t, sort, results);
@@ -326,10 +326,10 @@
         }
       }
 
-    private void addTopSortAlternatives(IParseNode t, String sort, List<IParseNode> results) throws FilterException {
-        List<IParseNode> alternatives = ((Amb) t).getAlternatives();
+    private void addTopSortAlternatives(AbstractParseNode t, String sort, List<AbstractParseNode> results) throws FilterException {
+        List<AbstractParseNode> alternatives = ((Amb) t).getAlternatives();
         for (int i = 0, max = alternatives.size(); i < max; i++) {
-            IParseNode amb = alternatives.get(i);
+            AbstractParseNode amb = alternatives.get(i);
             if (amb instanceof Amb) {
                 addTopSortAlternatives(amb, sort, results);
             } else {
@@ -340,7 +340,7 @@
         }
     }
 
-    private IParseNode filterTree(IParseNode t, boolean inAmbiguityCluster) throws FilterException {
+    private AbstractParseNode filterTree(AbstractParseNode t, boolean inAmbiguityCluster) throws FilterException {
         // SG_FilterTreeRecursive
         if (SGLR.isDebugging()) {
             Tools.debug("filterTree(node)    - ", t);
@@ -349,21 +349,21 @@
         if (t instanceof Amb) {
             if (!inAmbiguityCluster) {
                 // (some cycle stuff should be done here)
-                List<IParseNode> ambs = ((Amb)t).getAlternatives();
+                List<AbstractParseNode> ambs = ((Amb)t).getAlternatives();
                 t = filterAmbiguities(ambs);
             } else {
             	// FIXME: hasRejectProd(Amb) can never succeed?
                 if (filterReject && parseTable.hasRejects() && hasRejectProd(t)) {
                     return null;
                 }
-                List<IParseNode> ambs = ((Amb) t).getAlternatives();
+                List<AbstractParseNode> ambs = ((Amb) t).getAlternatives();
                 return filterAmbiguities(ambs);
 
             }
         } else if(t instanceof ParseNode) {
             ParseNode node = (ParseNode) t;
-            List<IParseNode> args = node.getKids();
-            List<IParseNode> newArgs = filterTree(args, false);
+            List<AbstractParseNode> args = node.getKids();
+            List<AbstractParseNode> newArgs = filterTree(args, false);
 
             if (filterReject && parseTable.hasRejects()) {
                 if (hasRejectProd(t) && !parser.useIntegratedRecovery)
@@ -385,18 +385,18 @@
         }
     }
 
-    private List<IParseNode> filterTree(List<IParseNode> args, boolean inAmbiguityCluster) throws FilterException {
+    private List<AbstractParseNode> filterTree(List<AbstractParseNode> args, boolean inAmbiguityCluster) throws FilterException {
 
         if(SGLR.isDebugging()) {
             Tools.debug("filterTree(<nodes>) - ", args);
         }
 
-        List<IParseNode> newArgs = new ArrayList<IParseNode>();
+        List<AbstractParseNode> newArgs = new ArrayList<AbstractParseNode>();
         // boolean changed = false;
 
         for (int i = 0, max = args.size(); i < max; i++) {
-            IParseNode n = args.get(i);
-            IParseNode filtered = filterTree(n, false);
+            AbstractParseNode n = args.get(i);
+            AbstractParseNode filtered = filterTree(n, false);
 
             // changed = !filtered.equals(n) || changed;
             newArgs.add(filtered);
@@ -409,9 +409,9 @@
         // }
 
         if (filterAny) {
-            List<IParseNode> filtered = new ArrayList<IParseNode>();
+            List<AbstractParseNode> filtered = new ArrayList<AbstractParseNode>();
             for (int i = 0, max = newArgs.size(); i < max; i++) {
-                IParseNode n = newArgs.get(i);
+                AbstractParseNode n = newArgs.get(i);
                 filtered.add(applyAssociativityPriorityFilter(n));
             }
             return filtered;
@@ -420,7 +420,7 @@
         }
     }
 
-    private IParseNode applyAssociativityPriorityFilter(IParseNode t) throws FilterException {
+    private AbstractParseNode applyAssociativityPriorityFilter(AbstractParseNode t) throws FilterException {
         // SG_Associativity_Priority_Filter(pt, t)
         // - ok
 
@@ -428,7 +428,7 @@
             Tools.debug("applyAssociativityPriorityFilter() - ", t);
         }
 
-        IParseNode r = t;
+        AbstractParseNode r = t;
 
         if (t instanceof ParseNode) {
             Label prodLabel = getProductionLabel(t);
@@ -465,7 +465,7 @@
         return r;
     }
 
-    private IParseNode applyRightAssociativeFilter(ParseNode t, Label prodLabel) throws FilterException {
+    private AbstractParseNode applyRightAssociativeFilter(ParseNode t, Label prodLabel) throws FilterException {
         // SG_Right_Associativity_Filter(t, prodl)
         // - almost ok
 
@@ -473,17 +473,17 @@
             Tools.debug("applyRightAssociativeFilter() - ", t);
         }
 
-        List<IParseNode> newAmbiguities = new ArrayList<IParseNode>();
-        List<IParseNode> kids = t.getKids();
-        IParseNode firstKid = kids.get(0);
+        List<AbstractParseNode> newAmbiguities = new ArrayList<AbstractParseNode>();
+        List<AbstractParseNode> kids = t.getKids();
+        AbstractParseNode firstKid = kids.get(0);
 
         if(firstKid instanceof Amb) {
 
-            List<IParseNode> ambs = ((Amb)firstKid).getAlternatives();
-            List<IParseNode> restKids = kids.subList(1, t.kids.length - 1);
+            List<AbstractParseNode> ambs = ((Amb)firstKid).getAlternatives();
+            List<AbstractParseNode> restKids = kids.subList(1, t.kids.length - 1);
 
             for (int i = 0, max = ambs.size(); i < max; i++) {
-                IParseNode amb = ambs.get(i);
+                AbstractParseNode amb = ambs.get(i);
                 if(((ParseNode)amb).getLabel() != prodLabel.labelNumber) {
                     newAmbiguities.add(amb);
                 }
@@ -510,32 +510,32 @@
         return t;
     }
 
-    private IParseNode applyPriorityFilter(ParseNode t, Label prodLabel) throws FilterException {
+    private AbstractParseNode applyPriorityFilter(ParseNode t, Label prodLabel) throws FilterException {
         // SG_Priority_Filter
 
         if(SGLR.isDebugging()) {
             Tools.debug("applyPriorityFilter() - ", t);
         }
 
-        List<IParseNode> newAmbiguities = new ArrayList<IParseNode>();
-        List<IParseNode> kids = t.getKids();
-        List<IParseNode> newKids = new ArrayList<IParseNode>();
+        List<AbstractParseNode> newAmbiguities = new ArrayList<AbstractParseNode>();
+        List<AbstractParseNode> kids = t.getKids();
+        List<AbstractParseNode> newKids = new ArrayList<AbstractParseNode>();
 
         int l0 = prodLabel.labelNumber;
         int kidnumber = 0;
 
         for (int i = 0, max = kids.size(); i < max; i++) {
-            final IParseNode kid = kids.get(i);
-            IParseNode newKid = kid;
-            final IParseNode injection = jumpOverInjections(kid);
+            final AbstractParseNode kid = kids.get(i);
+            AbstractParseNode newKid = kid;
+            final AbstractParseNode injection = jumpOverInjections(kid);
 
             if (injection instanceof Amb) {
-                List<IParseNode> ambs = ((Amb) injection).getAlternatives();
+                List<AbstractParseNode> ambs = ((Amb) injection).getAlternatives();
 
                 newAmbiguities.clear();
                 for (int j = 0, jmax = ambs.size(); j < jmax; j++) {
-                    IParseNode amb = ambs.get(j);
-                    IParseNode injAmb = jumpOverInjections(amb);
+                    AbstractParseNode amb = ambs.get(j);
+                    AbstractParseNode injAmb = jumpOverInjections(amb);
 
                     if (injAmb instanceof ParseNode) {
                         Label label = getProductionLabel(t);
@@ -546,7 +546,7 @@
                 }
 
                 if(!newAmbiguities.isEmpty()) {
-                    IParseNode n = null;
+                    AbstractParseNode n = null;
                     if(newAmbiguities.size() > 1) {
                         n = new Amb(newAmbiguities);
                     } else {
@@ -576,7 +576,7 @@
         return new ParseNode(t.label, newKids);
     }
 
-    private IParseNode replaceUnderInjections(IParseNode alt, IParseNode injection, IParseNode n) {
+    private AbstractParseNode replaceUnderInjections(AbstractParseNode alt, AbstractParseNode injection, AbstractParseNode n) {
         // SG_Replace_Under_Injections
         // - not ok
 
@@ -593,7 +593,7 @@
         */
     }
 
-    private IParseNode jumpOverInjections(IParseNode t) {
+    private AbstractParseNode jumpOverInjections(AbstractParseNode t) {
 
         if(SGLR.isDebugging()) {
             Tools.debug("jumpOverInjections() - ", t);
@@ -603,8 +603,8 @@
             int prod = ((ParseNode) t).label;
             ParseNode n = (ParseNode)t;
             while (isUserDefinedLabel(prod)) {
-                List<IParseNode> kids = n.getKids();
-                IParseNode x = kids.get(0);
+                List<AbstractParseNode> kids = n.getKids();
+                AbstractParseNode x = kids.get(0);
                 if(x instanceof ParseNode) {
                     n = (ParseNode)x;
                     prod = n.label;
@@ -643,26 +643,26 @@
         return parseTable.getPriorities(prodLabel);
     }
 
-    private IParseNode applyLeftAssociativeFilter(ParseNode t, Label prodLabel) throws FilterException {
+    private AbstractParseNode applyLeftAssociativeFilter(ParseNode t, Label prodLabel) throws FilterException {
         // SG_Right_Associativity_Filter()
 
         if(SGLR.isDebugging()) {
             Tools.debug("applyLeftAssociativeFilter() - ", t);
         }
 
-        List<IParseNode> newAmbiguities = new ArrayList<IParseNode>();
-        List<IParseNode> kids = t.getKids();
-        IParseNode last = kids.get(kids.size() - 1);
+        List<AbstractParseNode> newAmbiguities = new ArrayList<AbstractParseNode>();
+        List<AbstractParseNode> kids = t.getKids();
+        AbstractParseNode last = kids.get(kids.size() - 1);
 
         if (last instanceof Amb) {
-            List<IParseNode> rest = new ArrayList<IParseNode>();
+            List<AbstractParseNode> rest = new ArrayList<AbstractParseNode>();
             rest.addAll(kids);
             rest.remove(rest.size() - 1);
 
-            List<IParseNode> ambs = ((Amb) last).getAlternatives();
+            List<AbstractParseNode> ambs = ((Amb) last).getAlternatives();
 
             for (int i = 0, max = ambs.size(); i < max; i++) {
-                IParseNode amb = ambs.get(i);
+                AbstractParseNode amb = ambs.get(i);
                 if (amb instanceof Amb
                         || !parseTable.getLabel(((ParseNode) amb).getLabel()).equals(prodLabel)) {
                     newAmbiguities.add(amb);
@@ -690,7 +690,7 @@
         return t;
     }
 
-    private Label getProductionLabel(IParseNode t) {
+    private Label getProductionLabel(AbstractParseNode t) {
         if (t instanceof ParseNode) {
             return parseTable.getLabel(((ParseNode) t).getLabel());
         } else if (t instanceof ParseProductionNode) {
@@ -699,31 +699,31 @@
         return null;
     }
 
-    private boolean hasRejectProd(IParseNode t) {
+    private boolean hasRejectProd(AbstractParseNode t) {
         return t instanceof ParseReject;
     }
 
-    private IParseNode filterAmbiguities(List<IParseNode> ambs) throws FilterException {
+    private AbstractParseNode filterAmbiguities(List<AbstractParseNode> ambs) throws FilterException {
         // SG_FilterAmb
 
         if(SGLR.isDebugging()) {
             Tools.debug("filterAmbiguities() - [", ambs.size(), "]");
         }
 
-        List<IParseNode> newAmbiguities = new ArrayList<IParseNode>();
+        List<AbstractParseNode> newAmbiguities = new ArrayList<AbstractParseNode>();
 
         for (int i = 0, max = ambs.size(); i < max; i++) {
-            IParseNode amb = ambs.get(i);
-            IParseNode newAmb = filterTree(amb, true);
+            AbstractParseNode amb = ambs.get(i);
+            AbstractParseNode newAmb = filterTree(amb, true);
             if (newAmb != null) newAmbiguities.add(newAmb);
         }
 
         if (newAmbiguities.size() > 1) {
             /* Handle ambiguities inside this ambiguity cluster */
-            List<IParseNode> oldAmbiguities = new LinkedList<IParseNode>();
+            List<AbstractParseNode> oldAmbiguities = new LinkedList<AbstractParseNode>();
             oldAmbiguities.addAll(newAmbiguities);
             for (int i = 0, max = oldAmbiguities.size(); i < max; i++) {
-                IParseNode amb = oldAmbiguities.get(i);
+                AbstractParseNode amb = oldAmbiguities.get(i);
                 if (newAmbiguities.remove(amb)) {
                     newAmbiguities = filterAmbiguityList(newAmbiguities, amb);
                 }
@@ -739,11 +739,11 @@
         return new Amb(newAmbiguities);
     }
 
-    private List<IParseNode> filterAmbiguityList(List<IParseNode> ambs, IParseNode t) {
+    private List<AbstractParseNode> filterAmbiguityList(List<AbstractParseNode> ambs, AbstractParseNode t) {
         // SG_FilterAmbList
 
         boolean keepT = true;
-        List<IParseNode> r = new ArrayList<IParseNode>();
+        List<AbstractParseNode> r = new ArrayList<AbstractParseNode>();
 
         if (ambs.isEmpty()) {
             r.add(t);
@@ -751,7 +751,7 @@
         }
 
         for (int i = 0, max = ambs.size(); i < max; i++) {
-            IParseNode amb = ambs.get(i);
+            AbstractParseNode amb = ambs.get(i);
             switch (filter(t, amb)) {
             case FILTER_DRAW:
                 r.add(amb);
@@ -769,7 +769,7 @@
         return r;
     }
 
-    private int filter(IParseNode left, IParseNode right) {
+    private int filter(AbstractParseNode left, AbstractParseNode right) {
         // SG_Filter(t0, t1)
 
         if(SGLR.isDebugging()) {
@@ -810,12 +810,12 @@
         return filterPermissiveLiterals(left, right);
     }
 
-    private int filterPermissiveLiterals(IParseNode left, IParseNode right) {
+    private int filterPermissiveLiterals(AbstractParseNode left, AbstractParseNode right) {
         // Work-around for http://bugs.strategoxt.org/browse/SPI-5 (Permissive grammars introduce ambiguities for literals)
 
         if (left instanceof ParseNode && right instanceof ParseNode) {
-            List<IParseNode> leftKids = ((ParseNode) left).getKids();
-            List<IParseNode> rightKids = ((ParseNode) right).getKids();
+            List<AbstractParseNode> leftKids = ((ParseNode) left).getKids();
+            List<AbstractParseNode> rightKids = ((ParseNode) right).getKids();
             if (leftKids.size() > 0 && rightKids.size() == 1) {
                 if (leftKids.get(0) instanceof ParseProductionNode && rightKids.get(0).equals(left)) {
                     return FILTER_LEFT_WINS;
@@ -825,7 +825,7 @@
         return FILTER_DRAW;
     }
 
-    private int filterOnInjectionCount(IParseNode left, IParseNode right) {
+    private int filterOnInjectionCount(AbstractParseNode left, AbstractParseNode right) {
 
         if(SGLR.isDebugging()) {
             Tools.debug("filterOnInjectionCount()");
@@ -849,7 +849,7 @@
         return FILTER_DRAW;
     }
 
-    private int countAllInjections(IParseNode t) {
+    private int countAllInjections(AbstractParseNode t) {
         // SG_CountAllInjectionsInTree
         // - ok
         if (t instanceof Amb) {
@@ -862,18 +862,18 @@
         return 0;
     }
 
-    private int countAllInjections(List<IParseNode> ls) {
+    private int countAllInjections(List<AbstractParseNode> ls) {
         // SG_CountAllInjectionsInTree
         // - ok
         int r = 0;
         for (int i = 0, max = ls.size(); i < max; i++) {
-            IParseNode n = ls.get(i);
+            AbstractParseNode n = ls.get(i);
             r += countAllInjections(n);
         }
         return r;
     }
 
-    private int filterOnPreferCount(IParseNode left, IParseNode right) {
+    private int filterOnPreferCount(AbstractParseNode left, AbstractParseNode right) {
 
         if(SGLR.isDebugging()) {
             Tools.debug("filterOnPreferCount()");
@@ -913,7 +913,7 @@
         return r;
     }
 
-    private int countPrefers(IParseNode t) {
+    private int countPrefers(AbstractParseNode t) {
         // SG_CountPrefersInTree
         // - ok
         if (t instanceof Amb) {
@@ -929,18 +929,18 @@
         return 0;
     }
 
-    private int countPrefers(List<IParseNode> ls) {
+    private int countPrefers(List<AbstractParseNode> ls) {
         // SG_CountPrefersInTree
         // - ok
         int r = 0;
         for (int i = 0, max = ls.size(); i < max; i++) {
-            IParseNode n = ls.get(i);
+            AbstractParseNode n = ls.get(i);
             r += countPrefers(n);
         }
         return r;
     }
 
-    private int countAvoids(IParseNode t) {
+    private int countAvoids(AbstractParseNode t) {
         // SG_CountAvoidsInTree
         // - ok
         if (t instanceof Amb) {
@@ -956,18 +956,18 @@
         return 0;
     }
 
-    private int countAvoids(List<IParseNode> ls) {
+    private int countAvoids(List<AbstractParseNode> ls) {
         // SG_CountAvoidsInTree
         // - ok
         int r = 0;
         for (int i = 0, max = ls.size(); i < max; i++) {
-            IParseNode n = ls.get(i);
+            AbstractParseNode n = ls.get(i);
             r += countAvoids(n);
         }
         return r;
     }
 
-    private int filterOnIndirectPrefers(IParseNode left, IParseNode right) {
+    private int filterOnIndirectPrefers(AbstractParseNode left, AbstractParseNode right) {
         // SG_Indirect_Eagerness_Filter
 
         if(SGLR.isDebugging()) {
@@ -983,15 +983,15 @@
         ParseNode l = (ParseNode) left;
         ParseNode r = (ParseNode) right;
 
-        List<IParseNode> leftArgs = l.getKids();
-        List<IParseNode> rightArgs = r.getKids();
+        List<AbstractParseNode> leftArgs = l.getKids();
+        List<AbstractParseNode> rightArgs = r.getKids();
 
         int diffs = computeDistinctArguments(leftArgs, rightArgs);
 
         if (diffs == 1) {
             for (int i = 0; i < leftArgs.size(); i++) {
-                IParseNode leftArg = leftArgs.get(i);
-                IParseNode rightArg = rightArgs.get(i);
+                AbstractParseNode leftArg = leftArgs.get(i);
+                AbstractParseNode rightArg = rightArgs.get(i);
 
                 if (!leftArg.equals(rightArg)) {
                     return filterOnIndirectPrefers(leftArg, rightArg);
@@ -1002,7 +1002,7 @@
         return FILTER_DRAW;
     }
 
-    private int filterOnDirectPrefers(IParseNode left, IParseNode right) {
+    private int filterOnDirectPrefers(AbstractParseNode left, AbstractParseNode right) {
         // SG_Direct_Eagerness_Filter
 
         if(SGLR.isDebugging()) {
@@ -1018,13 +1018,13 @@
         return FILTER_DRAW;
     }
 
-    private boolean isLeftMoreEager(IParseNode left, IParseNode right) {
+    private boolean isLeftMoreEager(AbstractParseNode left, AbstractParseNode right) {
         assert !(left instanceof Amb || right instanceof Amb);
         if (isMoreEager(left, right))
             return true;
 
-        IParseNode newLeft = jumpOverInjectionsModuloEagerness(left);
-        IParseNode newRight = jumpOverInjectionsModuloEagerness(right);
+        AbstractParseNode newLeft = jumpOverInjectionsModuloEagerness(left);
+        AbstractParseNode newRight = jumpOverInjectionsModuloEagerness(right);
 
         if (newLeft instanceof ParseNode && newRight instanceof ParseNode)
             return isMoreEager(newLeft, newRight);
@@ -1032,7 +1032,7 @@
         return false;
     }
 
-    private IParseNode jumpOverInjectionsModuloEagerness(IParseNode t) {
+    private AbstractParseNode jumpOverInjectionsModuloEagerness(AbstractParseNode t) {
 
         if(SGLR.isDebugging()) {
             Tools.debug("jumpOverInjectionsModuloEagerness()");
@@ -1064,7 +1064,7 @@
         return t;
     }
 
-    private Label getLabel(IParseNode t) {
+    private Label getLabel(AbstractParseNode t) {
         if (t instanceof ParseNode) {
             ParseNode n = (ParseNode) t;
             return parseTable.getLabel(n.label);
@@ -1075,11 +1075,11 @@
         return null;
     }
 
-    private int getProductionType(IParseNode t) {
+    private int getProductionType(AbstractParseNode t) {
         return getLabel(t).getAttributes().getType();
     }
 
-    private boolean isMoreEager(IParseNode left, IParseNode right) {
+    private boolean isMoreEager(AbstractParseNode left, AbstractParseNode right) {
         int leftLabel = ((ParseNode) left).getLabel();
         int rightLabel = ((ParseNode) right).getLabel();
 
@@ -1092,7 +1092,7 @@
         return false;
     }
 
-    private int computeDistinctArguments(List<IParseNode> leftArgs, List<IParseNode> rightArgs) {
+    private int computeDistinctArguments(List<AbstractParseNode> leftArgs, List<AbstractParseNode> rightArgs) {
         // countDistinctArguments
         int r = 0;
         for (int i = 0; i < leftArgs.size(); i++) {
@@ -1102,16 +1102,16 @@
         return r;
     }
 
-    private boolean isCyclicTerm(IParseNode t) {
+    private boolean isCyclicTerm(AbstractParseNode t) {
 
         ambiguityManager.dumpIndexTable();
 
-        List<IParseNode> cycles = computeCyclicTerm(t);
+        List<AbstractParseNode> cycles = computeCyclicTerm(t);
 
         return cycles != null && cycles.size() > 0;
     }
 
-    private List<IParseNode> computeCyclicTerm(IParseNode t) {
+    private List<AbstractParseNode> computeCyclicTerm(AbstractParseNode t) {
         // FIXME rewrite to use HashMap and object id
         PositionMap visited = new PositionMap(ambiguityManager.getMaxNumberOfAmbiguities());
 
@@ -1120,7 +1120,7 @@
         return computeCyclicTerm(t, false, visited);
     }
 
-    private List<IParseNode> computeCyclicTerm(IParseNode t, boolean inAmbiguityCluster,
+    private List<AbstractParseNode> computeCyclicTerm(AbstractParseNode t, boolean inAmbiguityCluster,
             PositionMap visited) {
 
         if (SGLR.isDebugging()) {
@@ -1134,7 +1134,7 @@
             return null;
         } else if (t instanceof ParseNode) {
             //Amb ambiguities = null;
-            List<IParseNode> cycle = null;
+            List<AbstractParseNode> cycle = null;
             //int clusterIndex;
             ParseNode n = (ParseNode) t;
 
@@ -1197,12 +1197,12 @@
     }
      */
 
-    private List<IParseNode> computeCyclicTerm(List<IParseNode> kids, boolean b, PositionMap visited) {
+    private List<AbstractParseNode> computeCyclicTerm(List<AbstractParseNode> kids, boolean b, PositionMap visited) {
 
 
         for (int i = 0, max = kids.size(); i < max; i++) {
-            IParseNode kid = kids.get(i);
-            List<IParseNode> cycle = computeCyclicTerm(kid, false, visited);
+            AbstractParseNode kid = kids.get(i);
+            List<AbstractParseNode> cycle = computeCyclicTerm(kid, false, visited);
             if (cycle != null)
                 return cycle;
         }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Frame.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Frame.java	Thu Dec 16 15:02:46 2010	(r21523)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Frame.java	Thu Dec 16 15:02:52 2010	(r21524)
@@ -119,7 +119,7 @@
 
     static public int[] counter = new int[1000];
     
-    public Link addLink(Frame st0, IParseNode n, int length) {
+    public Link addLink(Frame st0, AbstractParseNode n, int length) {
         if(Tools.tracing) {
             SGLR.TRACE("SG_AddLink() - " + state.stateNumber + ", " + st0.state.stateNumber + ", " + length);
         }
@@ -262,7 +262,7 @@
             for (int i = 0; i < stepsCount; i++) {
                 Link ln = steps[stepsCount - i - 1];
                 boolean seenIt = seen || (ln == l);
-                Path n = pool.makePath(node, ln, this, ln.getLength(), arity - length);
+                Path n = pool.makePath(node, ln, this, ln.getLength(), parentCount);
                 ln.parent.doComputePathsToRoot(pool, n, l, seenIt, arity - 1, parentCount + 1, length + ln.getLength());
             }
         }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Link.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Link.java	Thu Dec 16 15:02:46 2010	(r21523)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Link.java	Thu Dec 16 15:02:52 2010	(r21524)
@@ -16,7 +16,7 @@
     
     protected Frame parent;
 
-    protected IParseNode label;
+    protected AbstractParseNode label;
 
     private boolean rejected;
     
@@ -24,7 +24,7 @@
     
     public int recoverCount;
 
-    public Link(Frame destination, IParseNode t, int length) {
+    public Link(Frame destination, AbstractParseNode t, int length) {
         this.parent = destination;
         label = t;
         rejected = false;
@@ -59,7 +59,7 @@
         this.label = null;
     }
 
-    public void addAmbiguity(IParseNode t, int tokensSeen) {
+    public void addAmbiguity(AbstractParseNode t, int tokensSeen) {
         if(Tools.tracing) {
             SGLR.TRACE("SG_CreateAmbCluster() - " + tokensSeen);
         }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseAvoid.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseAvoid.java	Thu Dec 16 15:02:46 2010	(r21523)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseAvoid.java	Thu Dec 16 15:02:52 2010	(r21524)
@@ -11,7 +11,7 @@
 
 public class ParseAvoid extends ParseNode {
 
-    public ParseAvoid(int label, IParseNode[] kids) {
+    public ParseAvoid(int label, AbstractParseNode[] kids) {
         super(label, kids);
     }
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java	Thu Dec 16 15:02:46 2010	(r21523)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java	Thu Dec 16 15:02:52 2010	(r21524)
@@ -14,22 +14,22 @@
 import org.spoofax.jsglr.shared.terms.ATermFactory;
 import org.spoofax.jsglr.shared.terms.ATermList;
 
-public class ParseNode extends IParseNode {
+public class ParseNode extends AbstractParseNode {
 
     public final int label;
 
-    protected final IParseNode[] kids;
+    protected final AbstractParseNode[] kids;
 
     private int cachedHashCode;
 
-    public ParseNode(int label, IParseNode[] kids) {
+    public ParseNode(int label, AbstractParseNode[] kids) {
         this.label = label;
         this.kids = kids;
     }
 
-    public ParseNode(int label, List<IParseNode> kids) {
+    public ParseNode(int label, List<AbstractParseNode> kids) {
         this.label = label;
-        this.kids = kids.toArray(new IParseNode[kids.size()]);
+        this.kids = kids.toArray(new AbstractParseNode[kids.size()]);
     }
 
     @Override
@@ -38,7 +38,7 @@
 
         ATermList l1 = factory.makeList();
         for (int i = kids.length - 1; i >= 0; i--) {
-            l1 = l1.prepend(kids[i].toParseTree(pt));
+        	l1 = l1.prepend(kids[i].toParseTree(pt));
         }
 
         return factory.makeAppl(pt.applAFun, pt.getProduction(label), l1);
@@ -63,7 +63,7 @@
     public int getLabel() { return label; }
 
     @Deprecated
-    public List<IParseNode> getKids() {
+    public List<AbstractParseNode> getKids() {
     	// FIXME remove this method; should return the kids directly
     	return Arrays.asList(kids);
     }
@@ -91,7 +91,7 @@
             return cachedHashCode;
         final int prime = 31;
         int result = prime * label;
-        for(IParseNode n : kids)
+        for(AbstractParseNode n : kids)
             result += (prime * n.hashCode());
         cachedHashCode = result;
         return result;

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParsePrefer.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParsePrefer.java	Thu Dec 16 15:02:46 2010	(r21523)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParsePrefer.java	Thu Dec 16 15:02:52 2010	(r21524)
@@ -11,7 +11,7 @@
 
 public class ParsePrefer extends ParseNode {
 
-    public ParsePrefer(int label, IParseNode[] kids) {
+    public ParsePrefer(int label, AbstractParseNode[] kids) {
         super(label, kids);
     }
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseProductionNode.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseProductionNode.java	Thu Dec 16 15:02:46 2010	(r21523)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseProductionNode.java	Thu Dec 16 15:02:52 2010	(r21524)
@@ -9,7 +9,7 @@
 
 import org.spoofax.jsglr.shared.terms.ATerm;
 
-public class ParseProductionNode extends IParseNode {
+public class ParseProductionNode extends AbstractParseNode {
 
     public final int prod;
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseReject.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseReject.java	Thu Dec 16 15:02:46 2010	(r21523)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseReject.java	Thu Dec 16 15:02:52 2010	(r21524)
@@ -11,7 +11,7 @@
 
 public class ParseReject extends ParseNode {
 
-    public ParseReject(int label, IParseNode[] kids) {
+    public ParseReject(int label, AbstractParseNode[] kids) {
         super(label, kids);
     }
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java	Thu Dec 16 15:02:46 2010	(r21523)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java	Thu Dec 16 15:02:52 2010	(r21524)
@@ -57,12 +57,6 @@
 
     transient public AFun ambAFun;
 
-    transient private ATerm injection1Appl;
-
-    transient private ATerm injection2Appl;
-
-    transient private ATerm litStringAppl;
-
     private Label[] injections;
 
     // TODO: allocate prototypes to avoid measurable GC overhead in ParseTable construction
@@ -88,9 +82,6 @@
         this.factory = factory;
         applAFun = factory.makeAFun("appl", 2, false);
         ambAFun = factory.makeAFun("amb", 1, false);
-        injection1Appl = factory.parse("prod([<term>],cf(<term>),<term>)");
-        injection2Appl = factory.parse("prod([<term>],lex(sort(<str>)),<term>)");
-        litStringAppl = factory.parse("lit(<str>)");
     }
 
     public ATermFactory getFactory() {
@@ -591,7 +582,7 @@
         return hasAvoids() || hasPrefers();
     }
 
-    public IParseNode lookupProduction(int currentToken) {
+    public AbstractParseNode lookupProduction(int currentToken) {
         return new ParseProductionNode(currentToken);
     }
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Path.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Path.java	Thu Dec 16 15:02:46 2010	(r21523)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Path.java	Thu Dec 16 15:02:52 2010	(r21524)
@@ -7,14 +7,12 @@
  */
 package org.spoofax.jsglr.client;
 
-import java.util.ArrayList;
-import java.util.List;
 
 
 public class Path {
 
 	private Path parent;
-	private IParseNode label;
+	private AbstractParseNode label;
 	private Frame frame;
 	private int length;
 	private int parentCount;
@@ -40,19 +38,20 @@
 		return parent.getRecoverCount(maxCharLength);
 	}
 
-	public static boolean logNewInstanceCreation = false;
-
+	public static int[] counter = new int[1024];
+	
 	public Path reuse(Path parent, Link link, Frame frame, int length, int parentCount) {
 		this.parent = parent;
 		this.link = link;
 		this.frame = frame;
 		this.length = length;
 		this.parentCount = parentCount;
-		if(link != null){
+		if(link != null) {
 			this.label = link.label;
         } else {
             this.label = null;
         }
+		counter[parentCount]++;
 		assert length >= 0;
 		assert parentCount >= 0;
 		return this;
@@ -62,8 +61,8 @@
 		return frame;
 	}
 
-	public final IParseNode[] getParseNodes() {
-		IParseNode[] ret = new IParseNode[parentCount];
+	public final AbstractParseNode[] getParseNodes() {
+		AbstractParseNode[] ret = new AbstractParseNode[parentCount];
 
 		int pos = 0;
 		for (Path n = parent; n != null; n = n.parent) {
@@ -96,7 +95,7 @@
 		return parent;
 	}
 
-	public IParseNode getLabel() {
+	public AbstractParseNode getLabel() {
 		return label;
 	}
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Production.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Production.java	Thu Dec 16 15:02:46 2010	(r21523)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Production.java	Thu Dec 16 15:02:52 2010	(r21524)
@@ -33,7 +33,7 @@
         this.isRecover = isRecover;
     }
 
-    public IParseNode apply(IParseNode[] kids) {
+    public AbstractParseNode apply(AbstractParseNode[] kids) {
         switch(status) {
         case REJECT:
             return new ParseReject(label, kids);

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/RecoverDisambiguator.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/RecoverDisambiguator.java	Thu Dec 16 15:02:46 2010	(r21523)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/RecoverDisambiguator.java	Thu Dec 16 15:02:52 2010	(r21524)
@@ -10,7 +10,7 @@
         parseTable=pt;        
     }
     
-    public void handleAmbiguity(int recoverCount_t, IParseNode t, Link nl){  
+    public void handleAmbiguity(int recoverCount_t, AbstractParseNode t, Link nl){  
         //System.out.println("RECOVERCOUNT: "+recoverCount_t);
         //System.out.println("LNK_RECOVERCOUNT: "+nl.recoverCount);
         testCount++;
@@ -24,7 +24,7 @@
           //  trySelectByIndentation(recoverCount_t, t, nl);
     }
     
-    private boolean trySelectOnRecoverCount(int recoverCount_t, IParseNode t, Link nl) {
+    private boolean trySelectOnRecoverCount(int recoverCount_t, AbstractParseNode t, Link nl) {
         if(recoverCount_t == nl.recoverCount){
             setLabel(recoverCount_t, t, nl);
             return false;
@@ -34,7 +34,7 @@
         return true;
     }
     
-    private boolean trySelectNoRecoveries(int avoidCount_t, IParseNode t, Link nl){     
+    private boolean trySelectNoRecoveries(int avoidCount_t, AbstractParseNode t, Link nl){     
         if(nl.recoverCount==0)
             return true;
         if(avoidCount_t==0){
@@ -44,7 +44,7 @@
         return false;
     }
     
-    private void setLabel(int recoverCount_t, IParseNode t, Link nl) {
+    private void setLabel(int recoverCount_t, AbstractParseNode t, Link nl) {
         nl.label=t;
         nl.recoverCount=recoverCount_t;
     }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 15:02:46 2010	(r21523)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 15:02:52 2010	(r21524)
@@ -353,7 +353,7 @@
         logBeforeShifter();
         clearActiveStacks();
 
-        IParseNode prod = parseTable.lookupProduction(currentToken);
+        AbstractParseNode prod = parseTable.lookupProduction(currentToken);
 
         while (forShifter.size() > 0) {
             ActionState as = forShifter.remove();
@@ -564,7 +564,7 @@
 
         for(int i = 0; i < paths.size(); i++) {
         	Path path = paths.get(i);
-            IParseNode[] kids = path.getParseNodes();
+            AbstractParseNode[] kids = path.getParseNodes();
             Frame st0 = path.getEnd();
             State next = parseTable.go(st0.peek(), prod.label);
             logReductionPath(prod, path, st0, next);
@@ -578,10 +578,10 @@
     }
 
 
-    private void reducer(Frame st0, State s, Production prod, IParseNode[] kids, Path path) {
+    private void reducer(Frame st0, State s, Production prod, AbstractParseNode[] kids, Path path) {
         int length = path.getLength();
         int numberOfRecoveries = calcRecoverCount(prod, path);
-        IParseNode t = prod.apply(kids);
+        AbstractParseNode t = prod.apply(kids);
         Frame st1;
         Link nl;
         logBeforeReducer(s, prod, length);
@@ -653,13 +653,13 @@
 
     }*/
 
-    void createAmbNode(IParseNode t, Link nl) {
+    void createAmbNode(AbstractParseNode t, Link nl) {
         nl.addAmbiguity(t, tokensSeen);
         ambiguityManager.increaseAmbiguityCalls();
     }
 
     private void addNewStack(Frame st0, State s, Production prod, int length,
-            int numberOfRecoveries, IParseNode t) {
+            int numberOfRecoveries, AbstractParseNode t) {
         Frame st1;
         Link nl;
         /* Found no existing stack with for state s; make new stack */
@@ -681,7 +681,7 @@
     }
 
     private void addNewRecoverStack(Frame st0, State s, Production prod, int length,
-            int numberOfRecoveries, IParseNode t) {
+            int numberOfRecoveries, AbstractParseNode t) {
         if (fineGrainedOnRegion && !prod.isRejectProduction()) {
             Frame st1;
             Link nl;

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermFactory.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermFactory.java	Thu Dec 16 15:02:46 2010	(r21523)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermFactory.java	Thu Dec 16 15:02:52 2010	(r21524)
@@ -45,6 +45,10 @@
 		return new ATermAppl(this, afun, kids);
 	}
 
+	public ATerm makeAppl(AFun afun, ATerm[] kids, boolean m) {
+		return new ATermAppl(this, afun, kids);
+	}
+
 	public ATerm makeInt(int i) {
 		return new ATermInt(this, i);
 	}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:02:46 2010	(r21523)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:02:52 2010	(r21524)
@@ -16,6 +16,7 @@
 import org.spoofax.jsglr.client.InvalidParseTableException;
 import org.spoofax.jsglr.client.ParseTable;
 import org.spoofax.jsglr.client.ParserException;
+import org.spoofax.jsglr.client.Path;
 import org.spoofax.jsglr.client.PathListPool;
 import org.spoofax.jsglr.client.PooledPathList;
 import org.spoofax.jsglr.client.SGLR;
@@ -111,6 +112,7 @@
 		System.out.println(PathListPool.cacheMisses);
 		System.out.println(PooledPathList.maxRemembered);
 		System.out.println(PooledPathList.maxAllocated);
+		System.out.println(Arrays.toString(Path.counter));
 	}
 
 	private void doCompare(String s, final ATerm parsed) {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIParseNode.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIParseNode.java	Thu Dec 16 15:02:46 2010	(r21523)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIParseNode.java	Thu Dec 16 15:02:52 2010	(r21524)
@@ -12,22 +12,22 @@
 
 import junit.framework.TestCase;
 
-import org.spoofax.jsglr.client.IParseNode;
+import org.spoofax.jsglr.client.AbstractParseNode;
 import org.spoofax.jsglr.client.ParseNode;
 import org.spoofax.jsglr.client.ParseProductionNode;
 
 public class TestIParseNode extends TestCase {
 
-    private IParseNode pn0; 
-    private IParseNode pn1;
+    private AbstractParseNode pn0; 
+    private AbstractParseNode pn1;
     
     @Override
     protected void setUp() throws Exception {
-        List<IParseNode> r0 = new ArrayList<IParseNode>();
+        List<AbstractParseNode> r0 = new ArrayList<AbstractParseNode>();
         r0.add(new ParseProductionNode(123));
         pn0 = new ParseNode(233, r0);
 
-        List<IParseNode> r1 = new ArrayList<IParseNode>();
+        List<AbstractParseNode> r1 = new ArrayList<AbstractParseNode>();
         r1.add(new ParseProductionNode(123));
         pn1 = new ParseNode(233, r1);
     }

From karltk at strategoxt.org  Thu Dec 16 16:02:59 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:02:59 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21525 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt:
	src/org/spoofax/jsglr/shared/terms test/org/spoofax/jsglr/tests
Message-ID: <201012161502.oBGF2xRx026990@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:02:58 2010
New Revision: 21525
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21525&sc=1

Log:
* ATermLists are now immutable linked lists instead of array-based.

Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermFactory.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestG_ambi.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermFactory.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermFactory.java	Thu Dec 16 15:02:52 2010	(r21524)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermFactory.java	Thu Dec 16 15:02:58 2010	(r21525)
@@ -22,16 +22,19 @@
 	}
 	
 	public ATermList makeList() {
-		return new ATermList(this);
+		return new ATermList(this, null, null);
 	}
 
 	public ATermList makeList(ATerm... elements) {
-		return new ATermList(this, elements);
+		ATermList l = new ATermList(this, null, null);
+		for(int i = elements.length - 1; i >= 0; i--)
+			l = l.prepend(elements[i]);
+		return l;
 	}
 
-	public ATermList makeList(List<ATerm> elements) {
-		return new ATermList(this, elements.toArray(new ATerm[0]));
-	}
+//	public ATermList makeList(List<ATerm> elements) {
+//		return new ATermList(this, elements.toArray(new ATerm[0]));
+//	}
 
 	public ATerm parse(String text) {
 		return parseFromString(text);
@@ -78,7 +81,7 @@
         final int ch = bis.read();
         if (ch == '{') {
             List<ATerm> annos = parseTermSequence(bis, '}');
-            return annotateTerm(term, makeList(annos));
+            return annotateTerm(term, makeList(annos.toArray(new ATerm[annos.size()])));
         } else {
             bis.unread(ch);
             return term;
@@ -233,7 +236,7 @@
 
     private ATerm parseList(PushbackStringIterator bis) {
         //System.err.println("list");
-        return makeList(parseTermSequence(bis, ']'));
+        return makeList(parseTermSequence(bis, ']').toArray(new ATerm[0]));
     }
 
     private ATerm parseNumber(PushbackStringIterator bis) {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java	Thu Dec 16 15:02:52 2010	(r21524)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java	Thu Dec 16 15:02:58 2010	(r21525)
@@ -6,56 +6,50 @@
 
 	private static final long serialVersionUID = 1L;
 
-	private ATerm[] elements;
+	private ATerm element;
+	private ATermList next;
 
 	ATermList() {}
 
-	ATermList(ATermFactory factory) {
+	ATermList(ATermFactory factory, ATerm element, ATermList next) {
 		super(factory);
-		elements = new ATerm[0];
-	}
-
-	ATermList(ATermFactory factory, ATerm... terms) {
-		super(factory);
-		elements = terms;
+		this.element = element;
+		this.next = next;
 	}
 
 	public ATermList prepend(ATerm t) {
-		ATerm[] newList = new ATerm[elements.length+1];
-		System.arraycopy(elements, 0, newList, 1, elements.length);
-		newList[0] = t;
-		return new ATermList(factory, newList);
-	}
-	//
-	//	public ATermList append(ATerm t) {
-	//		ATerm[] newList = new ATerm[elements.length+1];
-	//		System.arraycopy(elements, 0, newList, 0, elements.length);
-	//		newList[elements.length] = t;
-	//		return new ATermList(factory, newList);
-	//	}
+		return new ATermList(factory, t, this);
+	}
 
 	public boolean isEmpty() {
-		return elements.length == 0;
+		return element == null;
 	}
 
 	public ATerm getFirst() {
-		return elements[0];
+		return element;
 	}
 
 	public ATermList getNext() {
-		ATerm[] newList = new ATerm[elements.length-1];
-		System.arraycopy(elements, 1, newList, 0, elements.length-1);
-		return new ATermList(factory, newList);
+		return next;
 	}
 
 	@Override
-	public ATerm getChildAt(int i) {
-		return elements[i];
+	public ATerm getChildAt(int index) {
+		ATermList l = this;
+		for(int i = 0; i < index; i++) 
+			l = l.next;
+		return l.element;
 	}
 
 	@Override
 	public int getChildCount() {
-		return elements.length;
+		int pos = 0;
+		ATermList l = this;
+		while(l.element != null) {
+			pos++;
+			l = l.next;
+		}
+		return pos;
 	}
 
 	@Override
@@ -64,22 +58,22 @@
 	}
 
 	private static class ATermListIterator implements Iterator<ATerm> {
-		private final ATermList underlying;
-		private int position;
+		private ATermList underlying;
 
 		ATermListIterator(ATermList underlying) {
 			this.underlying = underlying;
-			position = 0;
 		}
 
 		@Override
 		public boolean hasNext() {
-			return position < underlying.elements.length;
+			return underlying.element != null;
 		}
 
 		@Override
 		public ATerm next() {
-			return underlying.elements[position++];
+			ATerm e = underlying.element;
+			underlying = underlying.next;
+			return e;
 		}
 
 		@Override
@@ -89,7 +83,7 @@
 	}
 
 	@Override
-	public Iterator iterator() {
+	public Iterator<ATerm> iterator() {
 		return new ATermListIterator(this);
 	}
 
@@ -99,10 +93,12 @@
 			sb.append("...");
 		} else { 
 			sb.append('[');
-			for(int i = 0 ; i < elements.length; i++) {
-				if(i > 0)
+			ATermList l = this;
+			while(l.element != null) {
+				l.element.toString(depth - 1, sb);
+				l = l.next;
+				if(l.element != null)
 					sb.append(",");
-				elements[i].toString(depth - 1, sb);
 			}
 			sb.append(']');
 		}
@@ -112,12 +108,17 @@
 	public boolean simpleMatch(ATerm t) {
 		if(!(t instanceof ATermList))
 			return false;
-		ATermList o = (ATermList)t;
-		if(elements.length != o.elements.length)
-			return false;
-		for(int i = 0; i < elements.length; i++)
-			if(!o.elements[i].simpleMatch(elements[i]))
+		ATermList a = (ATermList)t;
+		ATermList b = (ATermList)t;		
+		do {
+			if(a.element == null && b.element == null)
+				return true;
+			if(a.element == null)
+				return false;
+			if(!a.element.equals(b.element))
 				return false;
-		return true;
+			a = a.next;
+			b = b.next;
+		} while(true);
 	}
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestG_ambi.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestG_ambi.java	Thu Dec 16 15:02:52 2010	(r21524)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestG_ambi.java	Thu Dec 16 15:02:58 2010	(r21525)
@@ -19,7 +19,7 @@
 
 
     public void testG_ambi_1() {
-        doParseTest("g-ambi-1");
+    	doParseTest("g-ambi-1");
     }
 
     public void testG_ambi_2() {

From karltk at strategoxt.org  Thu Dec 16 16:03:04 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:03:04 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21526 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt:
	src/org/spoofax/jsglr/client test/org/spoofax/jsglr/tests
Message-ID: <201012161503.oBGF34pn027022@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:03:04 2010
New Revision: 21526
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21526&sc=1

Log:
Use a pre-inited flyweight for the ParseProductionNodes.

Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java	Thu Dec 16 15:02:58 2010	(r21525)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java	Thu Dec 16 15:03:04 2010	(r21526)
@@ -27,6 +27,7 @@
         this.kids = kids;
     }
 
+    @Deprecated
     public ParseNode(int label, List<AbstractParseNode> kids) {
         this.label = label;
         this.kids = kids.toArray(new AbstractParseNode[kids.size()]);

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java	Thu Dec 16 15:02:58 2010	(r21525)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java	Thu Dec 16 15:03:04 2010	(r21526)
@@ -73,6 +73,14 @@
 
     private transient Map<Label, List<Priority>> priorityCache;
 
+    private static final ParseProductionNode[] productionNodes = new ParseProductionNode[256 + 1];
+    
+    static {
+    	for(int i = 0; i < productionNodes.length; i++) {
+    		productionNodes[i] = new ParseProductionNode(i);
+    	}
+    }
+                                             
     public ParseTable(ATerm pt) throws InvalidParseTableException {
         initAFuns(pt.getFactory());
         parse(pt);
@@ -583,7 +591,7 @@
     }
 
     public AbstractParseNode lookupProduction(int currentToken) {
-        return new ParseProductionNode(currentToken);
+    	return productionNodes[currentToken];
     }
 
     public ATerm getProduction(int prod) {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 15:02:58 2010	(r21525)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 15:03:04 2010	(r21526)
@@ -385,7 +385,7 @@
     private void parseCharacter() {
         logBeforeParseCharacter();
 
-        ArrayDeque<Frame> actives = new ArrayDeque<Frame>(activeStacks); // FIXME avoid garbage
+        ArrayDeque<Frame> actives = new ArrayDeque<Frame>(activeStacks); // FIXME avoid garbage -- singleton 'actives', since parseCharacter isn't recursive
         clearForActorDelayed();
         clearForShifter();
         while (actives.size() > 0 || forActor.size() > 0) {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:02:58 2010	(r21525)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:03:04 2010	(r21526)
@@ -14,6 +14,8 @@
 import org.spoofax.jsglr.FileTools;
 import org.spoofax.jsglr.client.Frame;
 import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParsePrefer;
+import org.spoofax.jsglr.client.ParseProductionNode;
 import org.spoofax.jsglr.client.ParseTable;
 import org.spoofax.jsglr.client.ParserException;
 import org.spoofax.jsglr.client.Path;

From karltk at strategoxt.org  Thu Dec 16 16:03:09 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:03:09 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21527 -
	spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client
Message-ID: <201012161503.oBGF39gD027025@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:03:09 2010
New Revision: 21527
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21527&sc=1

Log:
* Removed main source for new ArrayDeque$DeqIterator objects.

Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 15:03:04 2010	(r21526)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 15:03:09 2010	(r21527)
@@ -86,6 +86,7 @@
     private boolean buildParseTree = true;
     
     PathListPool pathCache = new PathListPool();
+    ArrayDeque<Frame> activeStacksWorkQueue = new ArrayDeque<Frame>();
     
     //Creates indent- and dedent- tokens
     //Meant for parsing of indentation based languages
@@ -380,22 +381,23 @@
         }
         activeStacks.addFirst(st1);
     }
-
-    int x = 0;
+    
     private void parseCharacter() {
         logBeforeParseCharacter();
 
-        ArrayDeque<Frame> actives = new ArrayDeque<Frame>(activeStacks); // FIXME avoid garbage -- singleton 'actives', since parseCharacter isn't recursive
+        activeStacksWorkQueue.clear();
+        for(int i = 0; i < activeStacks.size(); i++)
+        	activeStacksWorkQueue.add(activeStacks.get(i));
         clearForActorDelayed();
         clearForShifter();
-        while (actives.size() > 0 || forActor.size() > 0) {
+        while (activeStacksWorkQueue.size() > 0 || forActor.size() > 0) {
             Frame st;
-            st = pickStackNodeFromActivesOrForActor(actives);
+            st = pickStackNodeFromActivesOrForActor(activeStacksWorkQueue);
             if (!st.allLinksRejected()) {
                 actor(st);
             }
 
-            if(actives.size() == 0 && forActor.size() == 0) {
+            if(activeStacksWorkQueue.size() == 0 && forActor.size() == 0) {
                 fillForActorWithDelayedFrames(); //Fills foractor, clears foractor delayed
             }
         }

From karltk at strategoxt.org  Thu Dec 16 16:03:14 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:03:14 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21528 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt:
	src/org/spoofax/jsglr/client test/org/spoofax/jsglr/tests
Message-ID: <201012161503.oBGF3EFH027028@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:03:14 2010
New Revision: 21528
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21528&sc=1

Log:
* Removed ParseNode constructor with List<AbstractParseNode> argument.

Added:
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestAbstractParseNode.java
Deleted:
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIParseNode.java
Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java	Thu Dec 16 15:03:09 2010	(r21527)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java	Thu Dec 16 15:03:14 2010	(r21528)
@@ -362,8 +362,8 @@
             }
         } else if(t instanceof ParseNode) {
             ParseNode node = (ParseNode) t;
-            List<AbstractParseNode> args = node.getKids();
-            List<AbstractParseNode> newArgs = filterTree(args, false);
+            AbstractParseNode[] args = node.kids;
+            AbstractParseNode[] newArgs = filterTree(args, false);
 
             if (filterReject && parseTable.hasRejects()) {
                 if (hasRejectProd(t) && !parser.useIntegratedRecovery)
@@ -385,21 +385,21 @@
         }
     }
 
-    private List<AbstractParseNode> filterTree(List<AbstractParseNode> args, boolean inAmbiguityCluster) throws FilterException {
+    private AbstractParseNode[] filterTree(AbstractParseNode[] args, boolean inAmbiguityCluster) throws FilterException {
 
         if(SGLR.isDebugging()) {
             Tools.debug("filterTree(<nodes>) - ", args);
         }
 
-        List<AbstractParseNode> newArgs = new ArrayList<AbstractParseNode>();
+        AbstractParseNode[] newArgs = new AbstractParseNode[args.length];
         // boolean changed = false;
 
-        for (int i = 0, max = args.size(); i < max; i++) {
-            AbstractParseNode n = args.get(i);
+        for (int i = 0, max = args.length; i < max; i++) {
+            AbstractParseNode n = args[i];
             AbstractParseNode filtered = filterTree(n, false);
 
             // changed = !filtered.equals(n) || changed;
-            newArgs.add(filtered);
+            newArgs[i] = filtered;
         }
 
         // FIXME Shouldn't we do some filtering here?
@@ -409,10 +409,9 @@
         // }
 
         if (filterAny) {
-            List<AbstractParseNode> filtered = new ArrayList<AbstractParseNode>();
-            for (int i = 0, max = newArgs.size(); i < max; i++) {
-                AbstractParseNode n = newArgs.get(i);
-                filtered.add(applyAssociativityPriorityFilter(n));
+            AbstractParseNode[] filtered = new AbstractParseNode[newArgs.length];
+            for (int i = 0, max = newArgs.length; i < max; i++) {
+                filtered[i] = applyAssociativityPriorityFilter(newArgs[i]);
             }
             return filtered;
         } else {
@@ -474,13 +473,12 @@
         }
 
         List<AbstractParseNode> newAmbiguities = new ArrayList<AbstractParseNode>();
-        List<AbstractParseNode> kids = t.getKids();
-        AbstractParseNode firstKid = kids.get(0);
+        AbstractParseNode[] kids = t.kids;
+        AbstractParseNode firstKid = kids[0];
 
         if(firstKid instanceof Amb) {
 
             List<AbstractParseNode> ambs = ((Amb)firstKid).getAlternatives();
-            List<AbstractParseNode> restKids = kids.subList(1, t.kids.length - 1);
 
             for (int i = 0, max = ambs.size(); i < max; i++) {
                 AbstractParseNode amb = ambs.get(i);
@@ -489,13 +487,19 @@
                 }
             }
 
+            int additionalAmbNodes = newAmbiguities.isEmpty() ? 0 : 1;
+            AbstractParseNode[] restKids = new AbstractParseNode[t.kids.length - 1 + additionalAmbNodes]; 
+            for(int i = 0; i < restKids.length; i++) 
+            	restKids[i] = kids[i + 1];
+
             // FIXME is this correct?
             if(!newAmbiguities.isEmpty()) {
+            	AbstractParseNode extraAmb;
                 if(newAmbiguities.size() > 1)
-                    firstKid = new Amb(newAmbiguities);
+                    extraAmb = new Amb(newAmbiguities);
                 else
-                    firstKid = newAmbiguities.get(0);
-                restKids.add(firstKid);
+                    extraAmb = newAmbiguities.get(0);
+                restKids[restKids.length - 1] = extraAmb;
             } else {
                 throw new FilterException(parser);
             }
@@ -573,7 +577,8 @@
             kidnumber++;
         }
 
-        return new ParseNode(t.label, newKids);
+        // FIXME (KTK) get rid of toArray by precomputing the necessary size of newKids earlier in the method
+        return new ParseNode(t.label, newKids.toArray(new AbstractParseNode[newKids.size()]));
     }
 
     private AbstractParseNode replaceUnderInjections(AbstractParseNode alt, AbstractParseNode injection, AbstractParseNode n) {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java	Thu Dec 16 15:03:09 2010	(r21527)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java	Thu Dec 16 15:03:14 2010	(r21528)
@@ -27,12 +27,6 @@
         this.kids = kids;
     }
 
-    @Deprecated
-    public ParseNode(int label, List<AbstractParseNode> kids) {
-        this.label = label;
-        this.kids = kids.toArray(new AbstractParseNode[kids.size()]);
-    }
-
     @Override
 	public ATerm toParseTree(ParseTable pt) {
         ATermFactory factory = pt.getFactory();

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestAbstractParseNode.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestAbstractParseNode.java	Thu Dec 16 15:03:14 2010	(r21528)
@@ -0,0 +1,39 @@
+/*
+ * Created on 21.apr.2006
+ *
+ * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
+ * 
+ * Licensed under the GNU General Public License, v2
+ */
+package org.spoofax.jsglr.tests;
+
+import junit.framework.TestCase;
+
+import org.spoofax.jsglr.client.AbstractParseNode;
+import org.spoofax.jsglr.client.ParseNode;
+import org.spoofax.jsglr.client.ParseProductionNode;
+
+public class TestAbstractParseNode extends TestCase {
+
+    private AbstractParseNode pn0; 
+    private AbstractParseNode pn1;
+    
+    @Override
+    protected void setUp() throws Exception {
+        AbstractParseNode[]  r0 = { new ParseProductionNode(123) };
+        pn0 = new ParseNode(233, r0);
+
+        AbstractParseNode[] r1 = { new ParseProductionNode(123) };
+        pn1 = new ParseNode(233, r1);
+    }
+
+    public void testHashCode() {
+        assertTrue(pn0.hashCode() == pn1.hashCode());
+    }
+
+    public void testEquals() {
+        assertTrue(pn0.equals(pn1));
+    }
+
+
+}

From karltk at strategoxt.org  Thu Dec 16 16:03:19 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:03:19 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21529 -
	spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client
Message-ID: <201012161503.oBGF3Jg0027031@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:03:19 2010
New Revision: 21529
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21529&sc=1

Log:
* Removed List<> for kids in ParseNode and getAlternatives in Amb.

Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java	Thu Dec 16 15:03:14 2010	(r21528)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java	Thu Dec 16 15:03:19 2010	(r21529)
@@ -17,17 +17,17 @@
 
 public class Amb extends AbstractParseNode {
 
-    private final List<AbstractParseNode> alternatives;
+    private final AbstractParseNode[] alternatives;
 
     private int cachedHashCode = NO_HASH_CODE;
 
     Amb(AbstractParseNode left, AbstractParseNode right) {
-        alternatives = new ArrayList<AbstractParseNode>(2);
-        alternatives.add(left);
-        alternatives.add(right);
+        alternatives = new AbstractParseNode[2];
+        alternatives[0] = left;
+        alternatives[1] = right;
     }
 
-    public Amb(List<AbstractParseNode> alternatives) {
+    public Amb(AbstractParseNode[] alternatives) {
         this.alternatives = alternatives;
     }
 
@@ -43,8 +43,8 @@
     private ATermList addToParseTree(ParseTable pt, ATermFactory factory,
             ATermList list) {
 
-        for (int i = alternatives.size() - 1; i >= 0; i--) {
-            AbstractParseNode alt = alternatives.get(i);
+        for (int i = alternatives.length - 1; i >= 0; i--) {
+            AbstractParseNode alt = alternatives[i];
             if (alt instanceof Amb) {
                 list = ((Amb) alt).addToParseTree(pt, factory, list);
             } else {
@@ -63,7 +63,7 @@
         throw new NotImplementedException();
     }
 
-    public List<AbstractParseNode> getAlternatives() {
+    public AbstractParseNode[] getAlternatives() {
         return alternatives;
     }
 
@@ -74,11 +74,11 @@
         if (obj == this)
             return true;
         Amb o = (Amb)obj;
-        if(o.alternatives.size() != alternatives.size()
+        if(o.alternatives.length != alternatives.length
                 || o.hashCode() != hashCode())
             return false;
-        for(int i=0;i<alternatives.size();i++)
-            if(!alternatives.get(i).equals(o.alternatives.get(i)))
+        for(int i = 0; i < alternatives.length; i++)
+            if(!alternatives[i].equals(o.alternatives[i]))
                 return false;
         return true;
     }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java	Thu Dec 16 15:03:14 2010	(r21528)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java	Thu Dec 16 15:03:19 2010	(r21529)
@@ -318,7 +318,7 @@
             switch (results.size()) {
                 case 0: return null;
                 case 1: return results.get(0);
-                default: return new Amb(results);
+                default: return new Amb(results.toArray(new AbstractParseNode[results.size()]));
             }
         } else {
             ATerm prod = getProduction(t);
@@ -327,9 +327,7 @@
       }
 
     private void addTopSortAlternatives(AbstractParseNode t, String sort, List<AbstractParseNode> results) throws FilterException {
-        List<AbstractParseNode> alternatives = ((Amb) t).getAlternatives();
-        for (int i = 0, max = alternatives.size(); i < max; i++) {
-            AbstractParseNode amb = alternatives.get(i);
+        for(AbstractParseNode amb : ((Amb) t).getAlternatives()) {
             if (amb instanceof Amb) {
                 addTopSortAlternatives(amb, sort, results);
             } else {
@@ -349,14 +347,14 @@
         if (t instanceof Amb) {
             if (!inAmbiguityCluster) {
                 // (some cycle stuff should be done here)
-                List<AbstractParseNode> ambs = ((Amb)t).getAlternatives();
+                AbstractParseNode[] ambs = ((Amb)t).getAlternatives();
                 t = filterAmbiguities(ambs);
             } else {
             	// FIXME: hasRejectProd(Amb) can never succeed?
                 if (filterReject && parseTable.hasRejects() && hasRejectProd(t)) {
                     return null;
                 }
-                List<AbstractParseNode> ambs = ((Amb) t).getAlternatives();
+                AbstractParseNode[] ambs = ((Amb) t).getAlternatives();
                 return filterAmbiguities(ambs);
 
             }
@@ -478,10 +476,7 @@
 
         if(firstKid instanceof Amb) {
 
-            List<AbstractParseNode> ambs = ((Amb)firstKid).getAlternatives();
-
-            for (int i = 0, max = ambs.size(); i < max; i++) {
-                AbstractParseNode amb = ambs.get(i);
+            for (AbstractParseNode amb : ((Amb)firstKid).getAlternatives()) {
                 if(((ParseNode)amb).getLabel() != prodLabel.labelNumber) {
                     newAmbiguities.add(amb);
                 }
@@ -496,7 +491,7 @@
             if(!newAmbiguities.isEmpty()) {
             	AbstractParseNode extraAmb;
                 if(newAmbiguities.size() > 1)
-                    extraAmb = new Amb(newAmbiguities);
+                    extraAmb = new Amb(newAmbiguities.toArray(new AbstractParseNode[newAmbiguities.size()]));
                 else
                     extraAmb = newAmbiguities.get(0);
                 restKids[restKids.length - 1] = extraAmb;
@@ -522,23 +517,18 @@
         }
 
         List<AbstractParseNode> newAmbiguities = new ArrayList<AbstractParseNode>();
-        List<AbstractParseNode> kids = t.getKids();
         List<AbstractParseNode> newKids = new ArrayList<AbstractParseNode>();
 
         int l0 = prodLabel.labelNumber;
         int kidnumber = 0;
 
-        for (int i = 0, max = kids.size(); i < max; i++) {
-            final AbstractParseNode kid = kids.get(i);
+        for (final AbstractParseNode kid : t.kids) {
             AbstractParseNode newKid = kid;
             final AbstractParseNode injection = jumpOverInjections(kid);
 
             if (injection instanceof Amb) {
-                List<AbstractParseNode> ambs = ((Amb) injection).getAlternatives();
-
                 newAmbiguities.clear();
-                for (int j = 0, jmax = ambs.size(); j < jmax; j++) {
-                    AbstractParseNode amb = ambs.get(j);
+                for (AbstractParseNode amb : ((Amb) injection).getAlternatives()) {
                     AbstractParseNode injAmb = jumpOverInjections(amb);
 
                     if (injAmb instanceof ParseNode) {
@@ -552,7 +542,7 @@
                 if(!newAmbiguities.isEmpty()) {
                     AbstractParseNode n = null;
                     if(newAmbiguities.size() > 1) {
-                        n = new Amb(newAmbiguities);
+                        n = new Amb(newAmbiguities.toArray(new AbstractParseNode[newAmbiguities.size()]));
                     } else {
                         n = newAmbiguities.get(0);
                     }
@@ -608,8 +598,7 @@
             int prod = ((ParseNode) t).label;
             ParseNode n = (ParseNode)t;
             while (isUserDefinedLabel(prod)) {
-                List<AbstractParseNode> kids = n.getKids();
-                AbstractParseNode x = kids.get(0);
+                AbstractParseNode x = n.kids[0];
                 if(x instanceof ParseNode) {
                     n = (ParseNode)x;
                     prod = n.label;
@@ -656,18 +645,12 @@
         }
 
         List<AbstractParseNode> newAmbiguities = new ArrayList<AbstractParseNode>();
-        List<AbstractParseNode> kids = t.getKids();
-        AbstractParseNode last = kids.get(kids.size() - 1);
+        AbstractParseNode[] kids = t.kids;
+        AbstractParseNode last = kids[kids.length - 1];
 
         if (last instanceof Amb) {
-            List<AbstractParseNode> rest = new ArrayList<AbstractParseNode>();
-            rest.addAll(kids);
-            rest.remove(rest.size() - 1);
-
-            List<AbstractParseNode> ambs = ((Amb) last).getAlternatives();
 
-            for (int i = 0, max = ambs.size(); i < max; i++) {
-                AbstractParseNode amb = ambs.get(i);
+            for (AbstractParseNode amb : ((Amb) last).getAlternatives()) {
                 if (amb instanceof Amb
                         || !parseTable.getLabel(((ParseNode) amb).getLabel()).equals(prodLabel)) {
                     newAmbiguities.add(amb);
@@ -675,12 +658,16 @@
             }
 
             if (!newAmbiguities.isEmpty()) {
+            	AbstractParseNode[] rest = new AbstractParseNode[kids.length];
+                for(int i = 0; i < kids.length - 1; i++)
+                	rest[i] = kids[i];
+                
                 if (newAmbiguities.size() > 1) {
-                    last = new Amb(newAmbiguities);
+                    last = new Amb(newAmbiguities.toArray(new AbstractParseNode[newAmbiguities.size()]));
                 } else {
                     last = newAmbiguities.get(0);
                 }
-                rest.add(last);
+                rest[rest.length - 1] = last;
                 return new Amb(rest);
             } else {
                 throw new FilterException(parser);
@@ -708,27 +695,25 @@
         return t instanceof ParseReject;
     }
 
-    private AbstractParseNode filterAmbiguities(List<AbstractParseNode> ambs) throws FilterException {
+    private AbstractParseNode filterAmbiguities(AbstractParseNode[] ambs) throws FilterException {
         // SG_FilterAmb
 
         if(SGLR.isDebugging()) {
-            Tools.debug("filterAmbiguities() - [", ambs.size(), "]");
+            Tools.debug("filterAmbiguities() - [", ambs.length, "]");
         }
 
         List<AbstractParseNode> newAmbiguities = new ArrayList<AbstractParseNode>();
 
-        for (int i = 0, max = ambs.size(); i < max; i++) {
-            AbstractParseNode amb = ambs.get(i);
+        for (AbstractParseNode amb : ambs) {
             AbstractParseNode newAmb = filterTree(amb, true);
-            if (newAmb != null) newAmbiguities.add(newAmb);
+            if (newAmb != null) 
+            	newAmbiguities.add(newAmb);
         }
 
         if (newAmbiguities.size() > 1) {
             /* Handle ambiguities inside this ambiguity cluster */
-            List<AbstractParseNode> oldAmbiguities = new LinkedList<AbstractParseNode>();
-            oldAmbiguities.addAll(newAmbiguities);
-            for (int i = 0, max = oldAmbiguities.size(); i < max; i++) {
-                AbstractParseNode amb = oldAmbiguities.get(i);
+            List<AbstractParseNode> oldAmbiguities = new ArrayList<AbstractParseNode>(newAmbiguities);
+            for (AbstractParseNode amb : oldAmbiguities) {
                 if (newAmbiguities.remove(amb)) {
                     newAmbiguities = filterAmbiguityList(newAmbiguities, amb);
                 }
@@ -741,7 +726,7 @@
         if (newAmbiguities.size() == 1)
             return newAmbiguities.get(0);
 
-        return new Amb(newAmbiguities);
+        return new Amb(newAmbiguities.toArray(new AbstractParseNode[newAmbiguities.size()]));
     }
 
     private List<AbstractParseNode> filterAmbiguityList(List<AbstractParseNode> ambs, AbstractParseNode t) {
@@ -819,10 +804,10 @@
         // Work-around for http://bugs.strategoxt.org/browse/SPI-5 (Permissive grammars introduce ambiguities for literals)
 
         if (left instanceof ParseNode && right instanceof ParseNode) {
-            List<AbstractParseNode> leftKids = ((ParseNode) left).getKids();
-            List<AbstractParseNode> rightKids = ((ParseNode) right).getKids();
-            if (leftKids.size() > 0 && rightKids.size() == 1) {
-                if (leftKids.get(0) instanceof ParseProductionNode && rightKids.get(0).equals(left)) {
+            AbstractParseNode[] leftKids = ((ParseNode) left).kids;
+            AbstractParseNode[] rightKids = ((ParseNode) right).kids;
+            if (leftKids.length > 0 && rightKids.length == 1) {
+                if (leftKids[0] instanceof ParseProductionNode && rightKids[0].equals(left)) {
                     return FILTER_LEFT_WINS;
                 }
             }
@@ -859,21 +844,20 @@
         // - ok
         if (t instanceof Amb) {
             // Trick from forest.c
-            return countAllInjections(((Amb) t).getAlternatives().get(0));
+            return countAllInjections(((Amb) t).getAlternatives()[0]);
         } else if (t instanceof ParseNode) {
             int c = getProductionLabel(t).isInjection() ? 1 : 0;
-            return c + countAllInjections(((ParseNode) t).getKids());
+            return c + countAllInjections(((ParseNode) t).kids);
         }
         return 0;
     }
 
-    private int countAllInjections(List<AbstractParseNode> ls) {
+    private int countAllInjections(AbstractParseNode[] ls) {
         // SG_CountAllInjectionsInTree
         // - ok
         int r = 0;
-        for (int i = 0, max = ls.size(); i < max; i++) {
-            AbstractParseNode n = ls.get(i);
-            r += countAllInjections(n);
+        for (int i = 0, max = ls.length; i < max; i++) {
+            r += countAllInjections(ls[i]);
         }
         return r;
     }
@@ -929,17 +913,16 @@
                 return 1;
             else if (type == ProductionType.AVOID)
                 return 0;
-            return countPrefers(((ParseNode) t).getKids());
+            return countPrefers(((ParseNode) t).kids);
         }
         return 0;
     }
 
-    private int countPrefers(List<AbstractParseNode> ls) {
+    private int countPrefers(AbstractParseNode[] ls) {
         // SG_CountPrefersInTree
         // - ok
         int r = 0;
-        for (int i = 0, max = ls.size(); i < max; i++) {
-            AbstractParseNode n = ls.get(i);
+        for (AbstractParseNode n : ls) {
             r += countPrefers(n);
         }
         return r;
@@ -956,17 +939,16 @@
                 return 0;
             else if (type == ProductionType.AVOID)
                 return 1;
-            return countAvoids(((ParseNode) t).getKids());
+            return countAvoids(((ParseNode) t).kids);
         }
         return 0;
     }
 
-    private int countAvoids(List<AbstractParseNode> ls) {
+    private int countAvoids(AbstractParseNode[] ls) {
         // SG_CountAvoidsInTree
         // - ok
         int r = 0;
-        for (int i = 0, max = ls.size(); i < max; i++) {
-            AbstractParseNode n = ls.get(i);
+        for (AbstractParseNode n : ls) {
             r += countAvoids(n);
         }
         return r;
@@ -988,15 +970,15 @@
         ParseNode l = (ParseNode) left;
         ParseNode r = (ParseNode) right;
 
-        List<AbstractParseNode> leftArgs = l.getKids();
-        List<AbstractParseNode> rightArgs = r.getKids();
+        AbstractParseNode[] leftArgs = l.kids;
+        AbstractParseNode[] rightArgs = r.kids;
 
         int diffs = computeDistinctArguments(leftArgs, rightArgs);
 
         if (diffs == 1) {
-            for (int i = 0; i < leftArgs.size(); i++) {
-                AbstractParseNode leftArg = leftArgs.get(i);
-                AbstractParseNode rightArg = rightArgs.get(i);
+            for (int i = 0; i < leftArgs.length; i++) {
+                AbstractParseNode leftArg = leftArgs[i];
+                AbstractParseNode rightArg = rightArgs[i];
 
                 if (!leftArg.equals(rightArg)) {
                     return filterOnIndirectPrefers(leftArg, rightArg);
@@ -1097,11 +1079,11 @@
         return false;
     }
 
-    private int computeDistinctArguments(List<AbstractParseNode> leftArgs, List<AbstractParseNode> rightArgs) {
+    private int computeDistinctArguments(AbstractParseNode[] leftArgs, AbstractParseNode[] rightArgs) {
         // countDistinctArguments
         int r = 0;
-        for (int i = 0; i < leftArgs.size(); i++) {
-            if (!leftArgs.get(i).equals(rightArgs.get(i)))
+        for (int i = 0; i < leftArgs.length; i++) {
+            if (!leftArgs[i].equals(rightArgs[i]))
                 r++;
         }
         return r;
@@ -1144,7 +1126,7 @@
             ParseNode n = (ParseNode) t;
 
             if (inAmbiguityCluster) {
-                cycle = computeCyclicTerm(n.getKids(), false, visited);
+                cycle = computeCyclicTerm(n.kids, false, visited);
             } else {
                 /*
                 if (ambiguityManager.isInputAmbiguousAt(parseTreePosition)) {
@@ -1202,12 +1184,10 @@
     }
      */
 
-    private List<AbstractParseNode> computeCyclicTerm(List<AbstractParseNode> kids, boolean b, PositionMap visited) {
-
+    private List<AbstractParseNode> computeCyclicTerm(AbstractParseNode[] kids, boolean b, PositionMap visited) {
 
-        for (int i = 0, max = kids.size(); i < max; i++) {
-            AbstractParseNode kid = kids.get(i);
-            List<AbstractParseNode> cycle = computeCyclicTerm(kid, false, visited);
+        for (int i = 0, max = kids.length; i < max; i++) {
+            List<AbstractParseNode> cycle = computeCyclicTerm(kids[i], false, visited);
             if (cycle != null)
                 return cycle;
         }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java	Thu Dec 16 15:03:14 2010	(r21528)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java	Thu Dec 16 15:03:19 2010	(r21529)
@@ -7,7 +7,6 @@
  */
 package org.spoofax.jsglr.client;
 
-import java.util.Arrays;
 import java.util.List;
 
 import org.spoofax.jsglr.shared.terms.ATerm;
@@ -57,12 +56,6 @@
 
     public int getLabel() { return label; }
 
-    @Deprecated
-    public List<AbstractParseNode> getKids() {
-    	// FIXME remove this method; should return the kids directly
-    	return Arrays.asList(kids);
-    }
-
     @Override
     public boolean equals(Object obj) {
         if(!(obj instanceof ParseNode))

From karltk at strategoxt.org  Thu Dec 16 16:03:25 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:03:25 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21530 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt: src/org/spoofax/jsglr/client
	src/org/spoofax/jsglr/shared/terms test/org/spoofax/jsglr/tests
Message-ID: <201012161503.oBGF3PgA027034@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:03:25 2010
New Revision: 21530
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21530&sc=1

Log:
* Code gardening.

Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTreeTools.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Term.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermAppl.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java	Thu Dec 16 15:03:19 2010	(r21529)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java	Thu Dec 16 15:03:25 2010	(r21530)
@@ -7,9 +7,6 @@
  */
 package org.spoofax.jsglr.client;
 
-import java.util.ArrayList;
-import java.util.List;
-
 import org.spoofax.jsglr.shared.terms.ATerm;
 import org.spoofax.jsglr.shared.terms.ATermFactory;
 import org.spoofax.jsglr.shared.terms.ATermList;

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java	Thu Dec 16 15:03:19 2010	(r21529)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java	Thu Dec 16 15:03:25 2010	(r21530)
@@ -8,7 +8,6 @@
 package org.spoofax.jsglr.client;
 
 import java.util.ArrayList;
-import java.util.LinkedList;
 import java.util.List;
 
 import org.spoofax.jsglr.shared.SGLRException;

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java	Thu Dec 16 15:03:19 2010	(r21529)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java	Thu Dec 16 15:03:25 2010	(r21530)
@@ -204,12 +204,12 @@
         return ret;
     }
 
-    @SuppressWarnings("rawtypes")
     private boolean isInjection(ATermAppl prod) {
 
-//        injection1Appl = factory.parse("prod([<term>],cf(<term>),<term>)");
-//        injection2Appl = factory.parse("prod([<term>],lex(sort(<str>)),<term>)");
-//        litStringAppl = factory.parse("lit(<str>)");
+    	// Injections are terms on the following form:
+    	//  . prod([<term>],cf(<term>),<term>)
+    	//  . prod([<term>],lex(sort(<str>)),<term>)
+    	//  . lit(<str>)
 
         if(!prod.getAFun().getName().equals("prod"))
         	return false;

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTreeTools.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTreeTools.java	Thu Dec 16 15:03:19 2010	(r21529)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTreeTools.java	Thu Dec 16 15:03:25 2010	(r21530)
@@ -17,13 +17,12 @@
 	private final static int TERM_CONS = 0;
 	private final static int CONS_NAME = 0;
 
-	private AFun parsetreeFun;
-	private AFun applFun;
-	private AFun termFun;
-	private AFun prodFun;
-	private AFun noattrsFun;
-	private AFun attrsFun;
-	private AFun consFun;
+	private final AFun parsetreeFun;
+	private final AFun applFun;
+	private final AFun termFun;
+	private final AFun prodFun;
+	private final AFun noattrsFun;
+	private final AFun consFun;
 
 	public ParseTreeTools(ATermFactory factory) {
 		super();
@@ -31,7 +30,6 @@
 		applFun = factory.makeAFun("appl", 2, false);
 		prodFun = factory.makeAFun("prod", 3, false);
 		noattrsFun = factory.makeAFun("no-attrs", 0, false);
-		attrsFun = factory.makeAFun("attrs", 1, false);
 		termFun = factory.makeAFun("term", 1, false);
 		consFun = factory.makeAFun("cons", 1, false);
 	}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 15:03:19 2010	(r21529)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 15:03:25 2010	(r21530)
@@ -85,8 +85,10 @@
 
     private boolean buildParseTree = true;
     
-    PathListPool pathCache = new PathListPool();
-    ArrayDeque<Frame> activeStacksWorkQueue = new ArrayDeque<Frame>();
+    private PooledPathList reductionsPathCache = new PooledPathList(512, true);
+    private PathListPool pathCache = new PathListPool();
+    private ArrayDeque<Frame> activeStacksWorkQueue = new ArrayDeque<Frame>();
+    private ArrayDeque<Frame> recoverStacks;
     
     //Creates indent- and dedent- tokens
     //Meant for parsing of indentation based languages
@@ -107,7 +109,6 @@
         return history;
     }
 
-
     /* START: FINE GRAINED ON REGION */
     private boolean fineGrainedOnRegion;
     protected void setFineGrainedOnRegion(boolean fineGrainedMode) {
@@ -119,7 +120,7 @@
         recoverStacks.clear(false);
     }
 
-    private ArrayDeque<Frame> recoverStacks;
+    
     public ArrayDeque<Frame> getRecoverStacks() {
         return recoverStacks;
     }
@@ -216,7 +217,7 @@
      * active stack, and this stack contains the start symbol obtained from the
      * parse table.
      *
-     * @return the initial stack
+     * @return top-level frame of the initial stack
      */
     private Frame initActiveStacks() {
         activeStacks.clear();
@@ -315,49 +316,51 @@
         PathListPool.resetPerformanceCounters();
     }
 
-     private BadTokenException createBadTokenException() {
-        Frame singlePreviousStack = activeStacks.size() == 1
-                ? activeStacks.get(0)
-                : null;
-        if (singlePreviousStack != null) {
-            Action action = singlePreviousStack.peek().getSingularAction();
-
-            if (action != null && action.getActionItems().length == 1) {
-                StringBuilder expected = new StringBuilder();
-
-                do {
-                    int token = action.getSingularRange();
-                    if (token == -1) break;
-                    expected.append((char) token);
-
-                    ActionItem[] items = action.getActionItems();
-
-                    if (!(items.length == 1 && items[0].type == ActionItem.SHIFT))
-                        break;
-
-                    Shift shift = (Shift) items[0];
-                    action = parseTable.getState(shift.nextState).getSingularAction();
-
-                } while (action != null);
-
-                if (expected.length() > 0)
-                    return new TokenExpectedException(this, expected.toString(), currentToken,
-                                                     tokensSeen - 1, lineNumber, columnNumber);
-            }
-        }
+    private BadTokenException createBadTokenException() {
+
+    	final Frame singlePreviousStack = activeStacks.size() == 1 ? activeStacks.get(0) : null;
+
+    	if (singlePreviousStack != null) {
+    		Action action = singlePreviousStack.peek().getSingularAction();
+
+    		if (action != null && action.getActionItems().length == 1) {
+    			final StringBuilder expected = new StringBuilder();
+
+    			do {
+    				int token = action.getSingularRange();
+    				if (token == -1) break;
+    				expected.append((char) token);
+
+    				ActionItem[] items = action.getActionItems();
+
+    				if (!(items.length == 1 && items[0].type == ActionItem.SHIFT))
+    					break;
 
-        return new BadTokenException(this, currentToken, tokensSeen - 1, lineNumber,
-                                           columnNumber);
+    				Shift shift = (Shift) items[0];
+    				action = parseTable.getState(shift.nextState).getSingularAction();
+
+    			} while (action != null);
+
+    			if (expected.length() > 0)
+    				return new TokenExpectedException(this, expected.toString(), currentToken,
+    						tokensSeen - 1, lineNumber, columnNumber);
+    		}
+    	}
+
+    	return new BadTokenException(this, currentToken, tokensSeen - 1, lineNumber,
+    			columnNumber);
     }
 
     private void shifter() {
         logBeforeShifter();
         clearActiveStacks();
 
-        AbstractParseNode prod = parseTable.lookupProduction(currentToken);
+        final AbstractParseNode prod = parseTable.lookupProduction(currentToken);
 
         while (forShifter.size() > 0) {
-            ActionState as = forShifter.remove();
+            
+        	final ActionState as = forShifter.remove();
+            
             if (!parseTable.hasRejects() || !as.st.allLinksRejected()) {
                 Frame st1 = findStack(activeStacks, as.s);
                 if (st1 == null) {
@@ -388,11 +391,12 @@
         activeStacksWorkQueue.clear();
         for(int i = 0; i < activeStacks.size(); i++)
         	activeStacksWorkQueue.add(activeStacks.get(i));
+        
         clearForActorDelayed();
         clearForShifter();
+        
         while (activeStacksWorkQueue.size() > 0 || forActor.size() > 0) {
-            Frame st;
-            st = pickStackNodeFromActivesOrForActor(activeStacksWorkQueue);
+            final Frame st = pickStackNodeFromActivesOrForActor(activeStacksWorkQueue);
             if (!st.allLinksRejected()) {
                 actor(st);
             }
@@ -401,7 +405,6 @@
                 fillForActorWithDelayedFrames(); //Fills foractor, clears foractor delayed
             }
         }
-        return;
     }
 
     private void fillForActorWithDelayedFrames() {
@@ -431,27 +434,29 @@
     }
 
     private void actor(Frame st) {
-        State s = st.peek();
+        
+    	final State s = st.peek();
         logBeforeActor(st, s);
+        
         for (Action action : s.getActions()) {
             if (action.accepts(currentToken)) {
                 for (ActionItem ai : action.getActionItems()) {
                     switch (ai.type) {
                         case ActionItem.SHIFT: {
-                            Shift sh = (Shift) ai;
-                            ActionState actState = new ActionState(st, parseTable.getState(sh.nextState));
+                        	final Shift sh = (Shift) ai;
+                            final ActionState actState = new ActionState(st, parseTable.getState(sh.nextState));
                             actState.currentToken = currentToken;
                             addShiftPair(actState); //Adds StackNode to forshifter
                             statsRecordParsers(); //sets some values un current parse state
                             break;
                         }
                         case ActionItem.REDUCE: {
-                            Reduce red = (Reduce) ai;
+                        	final Reduce red = (Reduce) ai;
                             doReductions(st, red.production);
                             break;
                         }
                         case ActionItem.REDUCE_LOOKAHEAD: {
-                            ReduceLookahead red = (ReduceLookahead) ai;
+                            final ReduceLookahead red = (ReduceLookahead) ai;
                             if(checkLookahead(red)) {
                                 if(Tools.tracing) {
                                     TRACE("SG_ - ok");
@@ -490,7 +495,7 @@
             TRACE("SG_CheckLookAhead() - ");
         }
 
-        int c = currentInputStream.read();
+        final int c = currentInputStream.read();
 
         // EOF
         if(c == -1)
@@ -502,6 +507,7 @@
             permit = charClass[pos].within(c) ? false : doCheckLookahead(red, charClass, pos + 1);
 
         currentInputStream.unread(c);
+        
         return permit;
     }
 
@@ -522,53 +528,42 @@
         }
     }
 
-    private PooledPathList reductionsPathCache = new PooledPathList(512, true);
     
     private void doReductions(Frame st, Production prod) {
-        if(recoverModeOk(st, prod)) {
-        	PooledPathList paths = reductionsPathCache.start();
-            st.findAllPaths(paths, prod.arity);
-            logBeforeDoReductions(st, prod, paths.size());
-            reduceAllPaths(prod, paths);
-            logAfterDoReductions();
-            paths.end();
-        }
+
+    	if(!recoverModeOk(st, prod))
+        	return;
+        	
+    	final PooledPathList paths = reductionsPathCache.start();
+    	st.findAllPaths(paths, prod.arity);
+    	logBeforeDoReductions(st, prod, paths.size());
+    	reduceAllPaths(prod, paths);
+    	logAfterDoReductions();
+    	paths.end();
     }
 
     private boolean recoverModeOk(Frame st, Production prod) {
         return !prod.isRecoverProduction() || fineGrainedOnRegion;
-
     }
-    /*
-    private boolean recoverModeOk(Frame st, Production prod) {
-        if(useIntegratedRecovery && prod.isRecoverProduction() && !reduceRecoverOnly && recoverTolerance>0){
-           //if(findStack(recoveryActor, st.state)==null)
-            if(!recoveryActor.contains(st))
-                recoveryActor.addFirst(st);
-        }
-        // TODO: is this condition right??
-        return !useIntegratedRecovery || prod.isRecoverProduction() == reduceRecoverOnly;
-    }*/
-
-    
 	
     private void doLimitedReductions(Frame st, Production prod, Link l) { //Todo: Look add sharing code with doReductions
-        if(recoverModeOk(st, prod)) {
-        	PooledPathList limitedPool = pathCache.create();
-        	st.findLimitedPaths(limitedPool, prod.arity, l); //find paths containing the link
-            logBeforeLimitedReductions(st, prod, l, limitedPool);
-            reduceAllPaths(prod, limitedPool);
-            limitedPool.end();
-        }
+        if(!recoverModeOk(st, prod))
+        	return;
+        
+        final PooledPathList limitedPool = pathCache.create();
+        st.findLimitedPaths(limitedPool, prod.arity, l); //find paths containing the link
+        logBeforeLimitedReductions(st, prod, l, limitedPool);
+        reduceAllPaths(prod, limitedPool);
+        limitedPool.end();
     }
 
     private void reduceAllPaths(Production prod, PooledPathList paths) {
 
         for(int i = 0; i < paths.size(); i++) {
-        	Path path = paths.get(i);
-            AbstractParseNode[] kids = path.getParseNodes();
-            Frame st0 = path.getEnd();
-            State next = parseTable.go(st0.peek(), prod.label);
+        	final Path path = paths.get(i);
+            final AbstractParseNode[] kids = path.getParseNodes();
+            final Frame st0 = path.getEnd();
+            final State next = parseTable.go(st0.peek(), prod.label);
             logReductionPath(prod, path, st0, next);
             reducer(st0, next, prod, kids, path);
         }
@@ -581,14 +576,15 @@
 
 
     private void reducer(Frame st0, State s, Production prod, AbstractParseNode[] kids, Path path) {
-        int length = path.getLength();
-        int numberOfRecoveries = calcRecoverCount(prod, path);
-        AbstractParseNode t = prod.apply(kids);
-        Frame st1;
-        Link nl;
-        logBeforeReducer(s, prod, length);
+        
+    	logBeforeReducer(s, prod, path.getLength());
         increaseReductionCount();
-        st1 = findStack(activeStacks, s);
+
+        final int length = path.getLength();
+        final int numberOfRecoveries = calcRecoverCount(prod, path);
+        final AbstractParseNode t = prod.apply(kids);
+        final Frame st1 = findStack(activeStacks, s);
+
         if (st1 == null) {
             if(prod.isRecoverProduction()){
                 addNewRecoverStack(st0, s, prod, length, numberOfRecoveries, t);
@@ -597,7 +593,7 @@
             addNewStack(st0, s, prod, length, numberOfRecoveries, t);
         } else {
             /* A stack with state s exists; check for ambiguities */
-            nl = st1.findDirectLink(st0);
+        	Link nl = st1.findDirectLink(st0);
 
             if (nl != null) {
                 if(prod.isRecoverProduction()){
@@ -606,24 +602,23 @@
                 logAmbiguity(st0, prod, st1, nl);
                 if (prod.isRejectProduction())
                     nl.reject();
-                if(numberOfRecoveries==0 && nl.recoverCount==0 || nl.isRejected())
+                if(numberOfRecoveries == 0 && nl.recoverCount == 0 || nl.isRejected()) {
                     createAmbNode(t, nl);
-                else if (numberOfRecoveries < nl.recoverCount){
-                    nl.label=t;
-                    nl.recoverCount=numberOfRecoveries;
+                } else if (numberOfRecoveries < nl.recoverCount) {
+                    nl.label = t;
+                    nl.recoverCount = numberOfRecoveries;
                     actorOnActiveStacksOverNewLink(nl);
-                }
-                else if (numberOfRecoveries == nl.recoverCount){
-                    nl.label=t;
+                } else if (numberOfRecoveries == nl.recoverCount) {
+                    nl.label = t;
                 }
             } else {
-                if(prod.isRecoverProduction()){
+                if(prod.isRecoverProduction()) {
                     addNewRecoverStack(st0, s, prod, length, numberOfRecoveries, t);
                     return;
                 }
                 nl = st1.addLink(st0, t, length);
                 nl.recoverCount = numberOfRecoveries;
-                if (prod.isRejectProduction()){
+                if (prod.isRejectProduction()) {
                     nl.reject();
                     increaseRejectCount();
                 }
@@ -636,43 +631,29 @@
             TRACE("SG_ - reducer done");
         }
     }
-
-    /*private void handleAmbiguity(int numberOfRecoveries, IParseNode t, Link nl) throws IOException {
-        //if both branches contain no recover productions and not in recover mode, create an Amb node.
-        //if(numberOfRecoveries == 0 && nl.recoverCount==0){
-            if(recoverIntegrator==null)
-                createAmbNode(t, nl);
-            else if (!recoverIntegrator.isActive())
-                createAmbNode(t, nl);
-            return;
-        //}
-        //if (!nl.isRejected()) {
-          //  int nlOld = nl.recoverCount;
-           // recoverDisambiguator.handleAmbiguity(numberOfRecoveries, t, nl);
-           // if (nl.recoverCount < nlOld)
-             //   actorOnActiveStacksOverNewLink(nl);
-        //}
-
-    }*/
-
-    void createAmbNode(AbstractParseNode t, Link nl) {
+    
+    private void createAmbNode(AbstractParseNode t, Link nl) {
         nl.addAmbiguity(t, tokensSeen);
         ambiguityManager.increaseAmbiguityCalls();
     }
 
+    /** 
+     * Found no existing stack with for state s; make new stack 
+     */
     private void addNewStack(Frame st0, State s, Production prod, int length,
             int numberOfRecoveries, AbstractParseNode t) {
-        Frame st1;
-        Link nl;
-        /* Found no existing stack with for state s; make new stack */
-        st1 = newStack(s);
-        nl = st1.addLink(st0, t, length);
+
+    	final Frame st1 = newStack(s);
+        final Link nl = st1.addLink(st0, t, length);
+        
         nl.recoverCount = numberOfRecoveries;
         addStack(st1);
         forActorDelayed.addFirst(st1);
+        
         if(Tools.tracing) {
             TRACE("SG_AddStack() - " + st1.state.stateNumber);
         }
+        
         if (prod.isRejectProduction()) {
             if (Tools.logging) {
                 Tools.logger("Reject [new]");
@@ -682,17 +663,17 @@
         }
     }
 
+    /**
+     *  Found no existing stack with for state s; make new stack 
+     */
     private void addNewRecoverStack(Frame st0, State s, Production prod, int length,
             int numberOfRecoveries, AbstractParseNode t) {
-        if (fineGrainedOnRegion && !prod.isRejectProduction()) {
-            Frame st1;
-            Link nl;
-            /* Found no existing stack with for state s; make new stack */
-            st1 = newStack(s);
-            nl = st1.addLink(st0, t, length);
-            nl.recoverCount = numberOfRecoveries;
-            recoverStacks.addFirst(st1);
-        }
+        if (!(fineGrainedOnRegion && !prod.isRejectProduction()))
+        	return;
+        final Frame st1 = newStack(s);
+        final Link nl = st1.addLink(st0, t, length);
+        nl.recoverCount = numberOfRecoveries;
+        recoverStacks.addFirst(st1);
     }
 
     private void actorOnActiveStacksOverNewLink(Link nl) {
@@ -704,8 +685,8 @@
             if(Tools.tracing) {
                 TRACE("SG_ activeStack - ");
             }
-            int pos = activeStacks.size() - sz + i;
-            Frame st2 = activeStacks.get(pos);
+            final int pos = activeStacks.size() - sz + i;
+            final Frame st2 = activeStacks.get(pos);
             if (st2.allLinksRejected() || inReduceStacks(forActor, st2) || inReduceStacks(forActorDelayed, st2))
                 continue; //stacknode will find reduction in regular process
 
@@ -714,11 +695,11 @@
                     for (ActionItem ai : action.getActionItems()) {
                         switch(ai.type) {
                             case ActionItem.REDUCE:
-                                Reduce red = (Reduce) ai;
+                            	final Reduce red = (Reduce) ai;
                                 doLimitedReductions(st2, red.production, nl);
                                 break;
                             case ActionItem.REDUCE_LOOKAHEAD:
-                                ReduceLookahead red2 = (ReduceLookahead) ai;
+                                final ReduceLookahead red2 = (ReduceLookahead) ai;
                                 if(checkLookahead(red2)) {
                                     doLimitedReductions(st2, red2.production, nl);
                                 }
@@ -731,12 +712,7 @@
     }
 
     private int calcRecoverCount(Production prod, Path path) {
-        int numberOfRecoveries = path.getRecoverCount();
-        if(prod.isRecoverProduction())
-        {
-            numberOfRecoveries+=1;
-        }
-        return numberOfRecoveries;
+        return path.getRecoverCount() + (prod.isRecoverProduction() ? 1 : 0);
     }
 
     private boolean inReduceStacks(Queue<Frame> q, Frame frame) {
@@ -765,7 +741,7 @@
         return rejectCount;
     }
 
-    Frame findStack(ArrayDeque<Frame> stacks, State s) {
+    private Frame findStack(ArrayDeque<Frame> stacks, State s) {
         if(Tools.tracing) {
             TRACE("SG_FindStack() - " + s.stateNumber);
         }
@@ -797,21 +773,21 @@
             TRACE("SG_NextToken() - ");
         }
 
-        int t = currentInputStream.read();
-        updateParserFields(t);
-        if(t==-1)
+        final int ch = currentInputStream.read();
+        updateLineAndColumnInfo(ch);
+        if(ch == -1)
             return SGLR.EOF;
-        return t;
+        return ch;
     }
 
-    protected void updateParserFields(int t) {
+    protected void updateLineAndColumnInfo(int ch) {
         tokensSeen++;
 
         if (Tools.debugging) {
-            Tools.debug("getNextToken() - ", t, "(", (char) t, ")");
+            Tools.debug("getNextToken() - ", ch, "(", (char) ch, ")");
         }
 
-        switch (t) {
+        switch (ch) {
         case '\n':
             lineNumber++;
             columnNumber = 0;
@@ -826,8 +802,6 @@
         }
     }
 
-    static int num = 0;
-
     @Deprecated
     public void setFilter(boolean filter) {
         getDisambiguator().setFilterAny(filter);
@@ -932,9 +906,11 @@
 
     ////////////////////////////////////////////////////// Log functions ///////////////////////////////////////////////////////////////////////////////
 
+    static int traceCallCount = 0;
+
     static void TRACE(String string) {
-        System.err.println("[" + num + "] " + string);
-        num++;
+        System.err.println("[" + traceCallCount + "] " + string);
+        traceCallCount++;
     }
 
     private String dumpActiveStacks() {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Term.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Term.java	Thu Dec 16 15:03:19 2010	(r21529)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Term.java	Thu Dec 16 15:03:25 2010	(r21530)
@@ -7,11 +7,8 @@
  */
 package org.spoofax.jsglr.client;
 
-import java.util.List;
-
 import org.spoofax.jsglr.shared.terms.ATerm;
 import org.spoofax.jsglr.shared.terms.ATermAppl;
-import org.spoofax.jsglr.shared.terms.ATermFactory;
 import org.spoofax.jsglr.shared.terms.ATermInt;
 import org.spoofax.jsglr.shared.terms.ATermList;
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermAppl.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermAppl.java	Thu Dec 16 15:03:19 2010	(r21529)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermAppl.java	Thu Dec 16 15:03:25 2010	(r21530)
@@ -1,7 +1,5 @@
 package org.spoofax.jsglr.shared.terms;
 
-import java.util.List;
-
 import org.spoofax.jsglr.client.NotImplementedException;
 
 public class ATermAppl extends ATerm {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:03:19 2010	(r21529)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:03:25 2010	(r21530)
@@ -12,10 +12,7 @@
 import junit.framework.TestCase;
 
 import org.spoofax.jsglr.FileTools;
-import org.spoofax.jsglr.client.Frame;
 import org.spoofax.jsglr.client.InvalidParseTableException;
-import org.spoofax.jsglr.client.ParsePrefer;
-import org.spoofax.jsglr.client.ParseProductionNode;
 import org.spoofax.jsglr.client.ParseTable;
 import org.spoofax.jsglr.client.ParserException;
 import org.spoofax.jsglr.client.Path;

From karltk at strategoxt.org  Thu Dec 16 16:03:31 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:03:31 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21531 -
	spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client
Message-ID: <201012161503.oBGF3Vpl027038@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:03:31 2010
New Revision: 21531
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21531&sc=1

Log:
* Code gardening.

Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Label.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Label.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Label.java	Thu Dec 16 15:03:25 2010	(r21530)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Label.java	Thu Dec 16 15:03:31 2010	(r21531)
@@ -67,4 +67,5 @@
     public int hashCode() {
         return labelNumber;
     }
+    
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java	Thu Dec 16 15:03:25 2010	(r21530)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java	Thu Dec 16 15:03:31 2010	(r21531)
@@ -115,7 +115,7 @@
         associativities = parseAssociativities(prioritiesTerm);
 
         injections = new Label[labels.length];
-        for(int i=0;i<labels.length;i++)
+        for(int i = 0; i < labels.length; i++)
             if(labels[i] != null && labels[i].isInjection())
                 injections[i] = labels[i];
 
@@ -189,16 +189,19 @@
 
     private Label[] parseLabels(ATermList labelsTerm) throws InvalidParseTableException {
 
-        Label[] ret = new Label[labelsTerm.getChildCount() + NUM_CHARS + 1];
+        final Label[] ret = new Label[labelsTerm.getChildCount() + NUM_CHARS + 1];
 
         while (!labelsTerm.isEmpty()) {
-            ATermAppl a = Term.applAt(labelsTerm, 0);
-            labelsTerm = labelsTerm.getNext();
-            ATermAppl prod = Term.applAt(a, 0);
-            int labelNumber = Term.intAt(a, 1);
-            boolean injection = isInjection(prod);
-            ProductionAttributes pa = parseProductionAttributes(Term.applAt(prod, 2));
+            
+        	final ATermAppl a = Term.applAt(labelsTerm, 0);
+            final ATermAppl prod = Term.applAt(a, 0);
+            final int labelNumber = Term.intAt(a, 1);
+            final boolean injection = isInjection(prod);
+            final ProductionAttributes pa = parseProductionAttributes(Term.applAt(prod, 2));
+            
             ret[labelNumber] = new Label(labelNumber, prod, pa, injection);
+
+            labelsTerm = labelsTerm.getNext();
         }
 
         return ret;

From karltk at strategoxt.org  Thu Dec 16 16:03:37 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:03:37 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21532 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt: src/org/spoofax/client
	src/org/spoofax/jsglr src/org/spoofax/jsglr/client
	test/org/spoofax/jsglr/client test/org/spoofax/j...
Message-ID: <201012161503.oBGF3buS027041@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:03:37 2010
New Revision: 21532
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21532&sc=1

Log:
* Tree construction is now done via the TreeBuilder interface.
 * Default tree builder is the Asfix2 builder, producing terms identical to before.

Added:
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/Asfix2TreeBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/TreeBuilder.java
Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/client/JSGLREntryPoint.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/AbstractParseNode.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Label.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseAvoid.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParsePrefer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseProductionNode.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseReject.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Path.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/client/JSGLREntryPoint.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/client/JSGLREntryPoint.java	Thu Dec 16 15:03:31 2010	(r21531)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/client/JSGLREntryPoint.java	Thu Dec 16 15:03:37 2010	(r21532)
@@ -66,7 +66,7 @@
 			System.out.println(pt.toString().length());
 			SGLR sglr = new SGLR(af, new ParseTable(pt));
 			long now = System.currentTimeMillis();
-			ATerm r = sglr.parse(strategoSampleCode());
+			ATerm r = (ATerm) sglr.parse(strategoSampleCode());
 			now = System.currentTimeMillis() - now;
 			if(r != null) {
 				RootPanel.get().add(new Label(r.toString()));

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java	Thu Dec 16 15:03:31 2010	(r21531)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java	Thu Dec 16 15:03:37 2010	(r21532)
@@ -126,7 +126,7 @@
             ous = System.out;
 
         long parsingTime = 0;
-        ATerm t=null;
+        Object t = null;
         try {
         	parsingTime = System.currentTimeMillis();
             t = sglr.parse(FileTools.loadFileAsString(input), startSymbol);            
@@ -138,7 +138,7 @@
             System.err.println("Parsing failed : " + e);
         }
         if(t != null && !"-".equals(output)){            
-            String outputString=t.toString();
+            String outputString = t.toString();
             ous.write(outputString.getBytes());
         }
         return parsingTime;

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/AbstractParseNode.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/AbstractParseNode.java	Thu Dec 16 15:03:31 2010	(r21531)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/AbstractParseNode.java	Thu Dec 16 15:03:37 2010	(r21532)
@@ -7,13 +7,12 @@
  */
 package org.spoofax.jsglr.client;
 
-import org.spoofax.jsglr.shared.terms.ATerm;
 
 public abstract class AbstractParseNode {
 
     protected static final int NO_HASH_CODE = 0;
 
-    public abstract ATerm toParseTree(ParseTable pt);
+    public abstract Object toParseTree(ParseTable pt);
 
     @Override
 	abstract public boolean equals(Object obj);

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java	Thu Dec 16 15:03:31 2010	(r21531)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java	Thu Dec 16 15:03:37 2010	(r21532)
@@ -7,6 +7,9 @@
  */
 package org.spoofax.jsglr.client;
 
+import java.util.ArrayList;
+import java.util.List;
+
 import org.spoofax.jsglr.shared.terms.ATerm;
 import org.spoofax.jsglr.shared.terms.ATermFactory;
 import org.spoofax.jsglr.shared.terms.ATermList;
@@ -29,28 +32,24 @@
     }
 
     @Override
-	public ATerm toParseTree(ParseTable pt) {
-
-        ATermFactory factory = pt.getFactory();
-        ATermList list = factory.makeList();
-        list = addToParseTree(pt, factory, list);
-        return pt.getFactory().makeAppl(pt.ambAFun, list);
-    }
-
-    private ATermList addToParseTree(ParseTable pt, ATermFactory factory,
-            ATermList list) {
-
-        for (int i = alternatives.length - 1; i >= 0; i--) {
-            AbstractParseNode alt = alternatives[i];
-            if (alt instanceof Amb) {
-                list = ((Amb) alt).addToParseTree(pt, factory, list);
-            } else {
-                list = list.prepend(alt.toParseTree(pt));
-            }
-        }
-        return list;
+	public Object toParseTree(ParseTable pt) {
+    	ArrayList<Object> collect = new ArrayList<Object>();
+    	addToParseTree(pt, collect);
+    	return pt.getTreeBuilder().buildAmb(collect.toArray(new Object[collect.size()]));
+    }
+    
+    private void addToParseTree(ParseTable pt, List<Object> collect) {
+    	for (int i = alternatives.length - 1; i >= 0; i--) {
+    		AbstractParseNode alt = alternatives[i];
+    		if (alt instanceof Amb) {
+    			((Amb) alt).addToParseTree(pt, collect);
+    		} else {
+    			collect.add(alt.toParseTree(pt));
+    		}
+    	}
     }
 
+
     @Override
     public String toString() {
         return "amb(" + alternatives + ")";

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java	Thu Dec 16 15:03:31 2010	(r21531)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java	Thu Dec 16 15:03:37 2010	(r21532)
@@ -180,7 +180,7 @@
         setDefaultFilters();
     }
 
-    public ATerm applyFilters(SGLR parser, AbstractParseNode root, String sort, int inputLength) throws SGLRException, FilterException {
+    public Object applyFilters(SGLR parser, AbstractParseNode root, String sort, int inputLength) throws SGLRException, FilterException {
         try {
             if(SGLR.isDebugging()) {
                 Tools.debug("applyFilters()");
@@ -200,7 +200,7 @@
                 t = filterTree(t, false);
             }
 
-            // TODO: Move convertToATerm to SGLR.java and support IStrategoTerms
+//            // TODO: Move convertToATerm to SGLR.java and support IStrategoTerms
             ATerm result = convertToATerm(t);
             assert Term.asAppl(result).getAFun().getName().equals("parsetree");
             return result;
@@ -232,7 +232,7 @@
         Tools.logger("Number of Injection Counts: ", ambiguityManager.getInjectionCount());
     }
 
-    private ATerm yieldTree(AbstractParseNode t) {
+    private Object yieldTree(AbstractParseNode t) {
         return t.toParseTree(parser.getParseTable());
     }
 
@@ -243,7 +243,7 @@
         }
 
         ambiguityManager.resetAmbiguityCount();
-        ATerm r = yieldTree(t);
+        Object r = yieldTree(t);
 
         logStatus();
 
@@ -251,9 +251,8 @@
         if (SGLR.isDebugging()) {
             Tools.debug("yield: ", r);
         }
-        final AFun parseTreeAfun = parseTable.getFactory().makeAFun("parsetree", 2, false);
-        return parseTable.getFactory().makeAppl(parseTreeAfun, r,
-                                                parseTable.getFactory().makeInt(ambCount));
+        
+        return (ATerm)parser.getParseTable().getTreeBuilder().buildToplevel(r, ambCount);
     }
 
     private AbstractParseNode applyCycleDetectFilter(AbstractParseNode t) throws FilterException {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Label.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Label.java	Thu Dec 16 15:03:31 2010	(r21531)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Label.java	Thu Dec 16 15:03:37 2010	(r21532)
@@ -15,10 +15,11 @@
 
     private static final long serialVersionUID = -4080621639747161438L;
 
-    final int labelNumber;
-    final ATermAppl prod;
+    /*package*/ final int labelNumber;
+    /*package*/ final ATermAppl prod;
     private final ProductionAttributes productionAttributes;
     private final boolean injection;
+    private Object tree;
 
     public Label(int labelNumber, ATermAppl prod, ProductionAttributes productionAttributes, boolean injection) {
         this.labelNumber = labelNumber;
@@ -67,5 +68,13 @@
     public int hashCode() {
         return labelNumber;
     }
+
+	public void setTree(Object tree) {
+		this.tree = tree;
+	}
+
+	public Object getTree() {
+		return tree;
+	}
     
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseAvoid.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseAvoid.java	Thu Dec 16 15:03:31 2010	(r21531)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseAvoid.java	Thu Dec 16 15:03:37 2010	(r21532)
@@ -7,7 +7,6 @@
  */
 package org.spoofax.jsglr.client;
 
-import org.spoofax.jsglr.shared.terms.ATerm;
 
 public class ParseAvoid extends ParseNode {
 
@@ -16,9 +15,8 @@
     }
 
     @Override
-    public ATerm toParseTree(ParseTable pt) {
+    public Object toParseTree(ParseTable pt) {
         return super.toParseTree(pt);
-        //throw new NotImplementedException();
     }
 
     @Override

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java	Thu Dec 16 15:03:31 2010	(r21531)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java	Thu Dec 16 15:03:37 2010	(r21532)
@@ -27,15 +27,16 @@
     }
 
     @Override
-	public ATerm toParseTree(ParseTable pt) {
-        ATermFactory factory = pt.getFactory();
+	public Object toParseTree(ParseTable pt) {
+        TreeBuilder tb = pt.getTreeBuilder();
 
-        ATermList l1 = factory.makeList();
-        for (int i = kids.length - 1; i >= 0; i--) {
-        	l1 = l1.prepend(kids[i].toParseTree(pt));
+        Object[] subtrees = new Object[kids.length];
+        for (int i = 0; i < kids.length; i++) {
+        	subtrees[i] = kids[i].toParseTree(pt);
         }
 
-        return factory.makeAppl(pt.applAFun, pt.getProduction(label), l1);
+        return tb.buildNode(label, pt.getLabel(label).getTree(), subtrees);
+        //return factory.makeAppl(pt.applAFun, pt.getProduction(label), l1);
     }
 
     /**

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParsePrefer.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParsePrefer.java	Thu Dec 16 15:03:31 2010	(r21531)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParsePrefer.java	Thu Dec 16 15:03:37 2010	(r21532)
@@ -7,7 +7,6 @@
  */
 package org.spoofax.jsglr.client;
 
-import org.spoofax.jsglr.shared.terms.ATerm;
 
 public class ParsePrefer extends ParseNode {
 
@@ -16,9 +15,8 @@
     }
 
     @Override
-    public ATerm toParseTree(ParseTable pt) {
+    public Object toParseTree(ParseTable pt) {
         return super.toParseTree(pt);
-        //throw new NotImplementedException();
     }
 
     @Override

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseProductionNode.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseProductionNode.java	Thu Dec 16 15:03:31 2010	(r21531)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseProductionNode.java	Thu Dec 16 15:03:37 2010	(r21532)
@@ -7,7 +7,6 @@
  */
 package org.spoofax.jsglr.client;
 
-import org.spoofax.jsglr.shared.terms.ATerm;
 
 public class ParseProductionNode extends AbstractParseNode {
 
@@ -18,9 +17,10 @@
     }
 
     @Override
-	public ATerm toParseTree(ParseTable pt) {
-    	return pt.getProduction(prod);
+	public Object toParseTree(ParseTable pt) {
+    	return pt.getTreeBuilder().buildProduction(prod);
     }
+
     @Override
     public String toString() {
         return "" + prod;

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseReject.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseReject.java	Thu Dec 16 15:03:31 2010	(r21531)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseReject.java	Thu Dec 16 15:03:37 2010	(r21532)
@@ -7,7 +7,6 @@
  */
 package org.spoofax.jsglr.client;
 
-import org.spoofax.jsglr.shared.terms.ATerm;
 
 public class ParseReject extends ParseNode {
 
@@ -16,8 +15,8 @@
     }
 
     @Override
-    public ATerm toParseTree(ParseTable pt) {
-        // Reject nodes shouldn't normally be outputted to a tree,
+    public Object toParseTree(ParseTable pt) {
+        // Reject nodes shouldn't normally be output to a tree,
         // but in error recovery mode they can be
         return super.toParseTree(pt);
     }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java	Thu Dec 16 15:03:31 2010	(r21531)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java	Thu Dec 16 15:03:37 2010	(r21532)
@@ -73,6 +73,8 @@
 
     private transient Map<Label, List<Priority>> priorityCache;
 
+	private transient TreeBuilder treeBuilder = new Asfix2TreeBuilder();
+
     private static final ParseProductionNode[] productionNodes = new ParseProductionNode[256 + 1];
     
     static {
@@ -633,4 +635,24 @@
 	public List<Label> getLabels() {
 	    return Collections.unmodifiableList(asList(labels));
 	}
+
+	public void setTreeConstructionParticipant(TreeBuilder treeBuilder) {
+		this.treeBuilder = treeBuilder;
+	}
+
+	private boolean prepared = false;
+	public void prepare() {
+		if(prepared)
+			return;
+		for(int i = 0; i < labels.length; i++) {
+			if(labels[i] == null)
+				continue;
+			labels[i].setTree(treeBuilder.mapProduction(i, labels[i].getProduction()));
+		}
+		prepared = true;		
+	}
+
+	public TreeBuilder getTreeBuilder() {
+		return treeBuilder;
+	}
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Path.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Path.java	Thu Dec 16 15:03:31 2010	(r21531)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Path.java	Thu Dec 16 15:03:37 2010	(r21532)
@@ -38,8 +38,6 @@
 		return parent.getRecoverCount(maxCharLength);
 	}
 
-	public static int[] counter = new int[1024];
-	
 	public Path reuse(Path parent, Link link, Frame frame, int length, int parentCount) {
 		this.parent = parent;
 		this.link = link;
@@ -51,7 +49,6 @@
         } else {
             this.label = null;
         }
-		counter[parentCount]++;
 		assert length >= 0;
 		assert parentCount >= 0;
 		return this;

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 15:03:31 2010	(r21531)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 15:03:37 2010	(r21532)
@@ -146,6 +146,7 @@
         assert parseTable != null;
         // Init with a new factory for both serialized or BAF instances.
         this.parseTable = parseTable;
+        parseTable.prepare();
         basicInit(pf);
     }
 
@@ -226,7 +227,7 @@
         return st0;
     }
 
-    public ATerm parse(String fis, String startSymbol) throws BadTokenException, TokenExpectedException, ParseException,
+    public Object parse(String fis, String startSymbol) throws BadTokenException, TokenExpectedException, ParseException,
             SGLRException {
         logBeforeParsing();
         initParseVariables(fis);
@@ -234,13 +235,13 @@
         return sglrParse(startSymbol);
     }
 
-    public final ATerm parse(String input) throws BadTokenException,
+    public final Object parse(String input) throws BadTokenException,
             TokenExpectedException, ParseException, SGLRException {
 
         return parse(input, null);
     }
 
-    private ATerm sglrParse(String startSymbol)
+    private Object sglrParse(String startSymbol)
             throws BadTokenException, TokenExpectedException,
             ParseException, SGLRException {
 

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/Asfix2TreeBuilder.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/Asfix2TreeBuilder.java	Thu Dec 16 15:03:37 2010	(r21532)
@@ -0,0 +1,50 @@
+package org.spoofax.jsglr.client;
+
+import org.spoofax.jsglr.shared.terms.AFun;
+import org.spoofax.jsglr.shared.terms.ATerm;
+import org.spoofax.jsglr.shared.terms.ATermAppl;
+import org.spoofax.jsglr.shared.terms.ATermFactory;
+import org.spoofax.jsglr.shared.terms.ATermList;
+
+public class Asfix2TreeBuilder implements TreeBuilder {
+
+	private final ATermFactory factory = new ATermFactory();
+	private final AFun applAFun;
+	private final AFun ambAFun;
+	private final AFun parseTreeAFun;
+	
+	public Asfix2TreeBuilder() {
+	    applAFun = factory.makeAFun("appl", 2, false);
+	    ambAFun = factory.makeAFun("amb", 1, false);
+	    parseTreeAFun = factory.makeAFun("parsetree", 2, false);
+	}
+
+	@Override
+	public Object mapProduction(int labelNumber, ATermAppl parseTreeProduction) {
+		return parseTreeProduction;
+	}
+
+	@Override
+	public Object buildNode(int label, Object node, Object[] subtrees) {
+		ATerm parent = (ATerm)node;
+		ATermList ls = factory.makeList();
+		for(int i = subtrees.length - 1; i >= 0; i--)
+			ls = ls.prepend((ATerm)subtrees[i]);
+		return factory.makeAppl(applAFun, parent, ls);
+	}
+
+	@Override
+	public Object buildAmb(Object[] alternatives) {
+		return factory.makeAppl(ambAFun, (ATerm[])alternatives);
+	}
+
+	@Override
+	public Object buildProduction(int label) {
+		return factory.makeInt(label);
+	}
+
+	@Override
+	public Object buildToplevel(Object node, int ambCount) {
+		return factory.makeAppl(parseTreeAFun, (ATerm)node, factory.makeInt(ambCount));	}
+
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/TreeBuilder.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/TreeBuilder.java	Thu Dec 16 15:03:37 2010	(r21532)
@@ -0,0 +1,14 @@
+package org.spoofax.jsglr.client;
+
+import org.spoofax.jsglr.shared.terms.ATermAppl;
+
+public interface TreeBuilder {
+
+	public Object mapProduction(int labelNumber, ATermAppl parseTreeProduction);
+
+	public Object buildNode(int label, Object node, Object[] subtrees);
+	public Object buildProduction(int productionNumber);
+	public Object buildToplevel(Object node, int ambiguityCount);
+	public Object buildAmb(Object[] alternatives);
+	
+}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:03:31 2010	(r21531)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:03:37 2010	(r21532)
@@ -12,7 +12,9 @@
 import junit.framework.TestCase;
 
 import org.spoofax.jsglr.FileTools;
+import org.spoofax.jsglr.client.Asfix2TreeBuilder;
 import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.Label;
 import org.spoofax.jsglr.client.ParseTable;
 import org.spoofax.jsglr.client.ParserException;
 import org.spoofax.jsglr.client.Path;
@@ -46,7 +48,8 @@
 		String fn = "tests/grammars/" + grammar + ".tbl";
 
 		ATerm result = pf.parseFromString(FileTools.loadFileAsString(fn));
-		sglr = new SGLR(pf, new ParseTable(result));
+		ParseTable pt = new ParseTable(result);
+		sglr = new SGLR(pf, pt);
 		//        parseTableService.fetchParseTable("tests/grammars/" + grammar + ".tbl",
 		//        		new AsyncCallback<ATerm>() {
 		//
@@ -94,7 +97,7 @@
 		long parseTime = System.nanoTime();
 		ATerm parsed = null;
 		try {
-			parsed = sglr.parse(result);
+			parsed = (ATerm) sglr.parse(result);
 		} catch (Exception e) {
 			e.printStackTrace();
 			fail(e.toString());
@@ -111,7 +114,6 @@
 		System.out.println(PathListPool.cacheMisses);
 		System.out.println(PooledPathList.maxRemembered);
 		System.out.println(PooledPathList.maxAllocated);
-		System.out.println(Arrays.toString(Path.counter));
 	}
 
 	private void doCompare(String s, final ATerm parsed) {

From karltk at strategoxt.org  Thu Dec 16 16:03:43 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:03:43 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21533 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt:
	src/org/spoofax/jsglr/client test/org/spoofax/jsglr/client
	test/org/spoofax/jsglr/tests
Message-ID: <201012161503.oBGF3hht027053@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:03:43 2010
New Revision: 21533
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21533&sc=1

Log:
* TreeBuilder is now reponsible for mapping label numbers to trees.
 * TreeBuilder is told the number of productions and labels before being informed about the labels.

Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Label.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/Asfix2TreeBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/TreeBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Label.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Label.java	Thu Dec 16 15:03:37 2010	(r21532)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Label.java	Thu Dec 16 15:03:43 2010	(r21533)
@@ -19,7 +19,6 @@
     /*package*/ final ATermAppl prod;
     private final ProductionAttributes productionAttributes;
     private final boolean injection;
-    private Object tree;
 
     public Label(int labelNumber, ATermAppl prod, ProductionAttributes productionAttributes, boolean injection) {
         this.labelNumber = labelNumber;
@@ -68,13 +67,4 @@
     public int hashCode() {
         return labelNumber;
     }
-
-	public void setTree(Object tree) {
-		this.tree = tree;
-	}
-
-	public Object getTree() {
-		return tree;
-	}
-    
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java	Thu Dec 16 15:03:37 2010	(r21532)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java	Thu Dec 16 15:03:43 2010	(r21533)
@@ -35,8 +35,7 @@
         	subtrees[i] = kids[i].toParseTree(pt);
         }
 
-        return tb.buildNode(label, pt.getLabel(label).getTree(), subtrees);
-        //return factory.makeAppl(pt.applAFun, pt.getProduction(label), l1);
+        return tb.buildNode(label - ParseTable.LABEL_BASE, subtrees);
     }
 
     /**

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java	Thu Dec 16 15:03:37 2010	(r21532)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java	Thu Dec 16 15:03:43 2010	(r21533)
@@ -30,7 +30,8 @@
      *  supported by the parse table format.)
      */
     protected static final int NUM_CHARS = 256;
-
+    protected static final int LABEL_BASE = NUM_CHARS + 1;
+    
     private static final long serialVersionUID = -3372429249660900093L;
 
     private State[] states;
@@ -73,7 +74,7 @@
 
     private transient Map<Label, List<Priority>> priorityCache;
 
-	private transient TreeBuilder treeBuilder = new Asfix2TreeBuilder();
+	private transient TreeBuilder treeBuilder;
 
     private static final ParseProductionNode[] productionNodes = new ParseProductionNode[256 + 1];
     
@@ -86,6 +87,7 @@
     public ParseTable(ATerm pt) throws InvalidParseTableException {
         initAFuns(pt.getFactory());
         parse(pt);
+        setTreeConstructionParticipant(new Asfix2TreeBuilder());
     }
 
     public void initAFuns(ATermFactory factory) {
@@ -191,7 +193,7 @@
 
     private Label[] parseLabels(ATermList labelsTerm) throws InvalidParseTableException {
 
-        final Label[] ret = new Label[labelsTerm.getChildCount() + NUM_CHARS + 1];
+        final Label[] ret = new Label[labelsTerm.getChildCount() + LABEL_BASE];
 
         while (!labelsTerm.isEmpty()) {
             
@@ -638,18 +640,12 @@
 
 	public void setTreeConstructionParticipant(TreeBuilder treeBuilder) {
 		this.treeBuilder = treeBuilder;
-	}
-
-	private boolean prepared = false;
-	public void prepare() {
-		if(prepared)
-			return;
+		treeBuilder.initialize(NUM_CHARS, labels.length - LABEL_BASE);
 		for(int i = 0; i < labels.length; i++) {
 			if(labels[i] == null)
 				continue;
-			labels[i].setTree(treeBuilder.mapProduction(i, labels[i].getProduction()));
+			treeBuilder.addLabel(i - LABEL_BASE, labels[i].getProduction());
 		}
-		prepared = true;		
 	}
 
 	public TreeBuilder getTreeBuilder() {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 15:03:37 2010	(r21532)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 15:03:43 2010	(r21533)
@@ -146,7 +146,6 @@
         assert parseTable != null;
         // Init with a new factory for both serialized or BAF instances.
         this.parseTable = parseTable;
-        parseTable.prepare();
         basicInit(pf);
     }
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/Asfix2TreeBuilder.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/Asfix2TreeBuilder.java	Thu Dec 16 15:03:37 2010	(r21532)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/Asfix2TreeBuilder.java	Thu Dec 16 15:03:43 2010	(r21533)
@@ -12,6 +12,7 @@
 	private final AFun applAFun;
 	private final AFun ambAFun;
 	private final AFun parseTreeAFun;
+	private ATermAppl[] labels;
 	
 	public Asfix2TreeBuilder() {
 	    applAFun = factory.makeAFun("appl", 2, false);
@@ -19,18 +20,21 @@
 	    parseTreeAFun = factory.makeAFun("parsetree", 2, false);
 	}
 
+	public void initialize(int productionCount, int labelCount) {
+		labels = new ATermAppl[labelCount];
+	}
+	
 	@Override
-	public Object mapProduction(int labelNumber, ATermAppl parseTreeProduction) {
-		return parseTreeProduction;
+	public void addLabel(int labelNumber, ATermAppl parseTreeProduction) {
+		labels[labelNumber] = parseTreeProduction;
 	}
 
 	@Override
-	public Object buildNode(int label, Object node, Object[] subtrees) {
-		ATerm parent = (ATerm)node;
+	public Object buildNode(int labelNumber, Object[] subtrees) {
 		ATermList ls = factory.makeList();
 		for(int i = subtrees.length - 1; i >= 0; i--)
 			ls = ls.prepend((ATerm)subtrees[i]);
-		return factory.makeAppl(applAFun, parent, ls);
+		return factory.makeAppl(applAFun, labels[labelNumber], ls);
 	}
 
 	@Override
@@ -39,8 +43,8 @@
 	}
 
 	@Override
-	public Object buildProduction(int label) {
-		return factory.makeInt(label);
+	public Object buildProduction(int productionNumber) {
+		return factory.makeInt(productionNumber);
 	}
 
 	@Override

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/TreeBuilder.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/TreeBuilder.java	Thu Dec 16 15:03:37 2010	(r21532)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/TreeBuilder.java	Thu Dec 16 15:03:43 2010	(r21533)
@@ -4,11 +4,13 @@
 
 public interface TreeBuilder {
 
-	public Object mapProduction(int labelNumber, ATermAppl parseTreeProduction);
+	public void addLabel(int labelNumber, ATermAppl parseTreeProduction);
 
-	public Object buildNode(int label, Object node, Object[] subtrees);
+	public Object buildNode(int labelNumber, Object[] subtrees);
 	public Object buildProduction(int productionNumber);
-	public Object buildToplevel(Object node, int ambiguityCount);
+	public Object buildToplevel(Object subtree, int ambiguityCount);
 	public Object buildAmb(Object[] alternatives);
+
+	public void initialize(int productionCount, int labelCount);
 	
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:03:37 2010	(r21532)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:03:43 2010	(r21533)
@@ -7,17 +7,12 @@
  */
 package org.spoofax.jsglr.tests;
 
-import java.util.Arrays;
-
 import junit.framework.TestCase;
 
 import org.spoofax.jsglr.FileTools;
-import org.spoofax.jsglr.client.Asfix2TreeBuilder;
 import org.spoofax.jsglr.client.InvalidParseTableException;
-import org.spoofax.jsglr.client.Label;
 import org.spoofax.jsglr.client.ParseTable;
 import org.spoofax.jsglr.client.ParserException;
-import org.spoofax.jsglr.client.Path;
 import org.spoofax.jsglr.client.PathListPool;
 import org.spoofax.jsglr.client.PooledPathList;
 import org.spoofax.jsglr.client.SGLR;
@@ -45,10 +40,10 @@
 		this.suffix = suffix;
 		Tools.setDebug(false);
 		Tools.setLogging(false);
-		String fn = "tests/grammars/" + grammar + ".tbl";
+		final String fn = "tests/grammars/" + grammar + ".tbl";
 
-		ATerm result = pf.parseFromString(FileTools.loadFileAsString(fn));
-		ParseTable pt = new ParseTable(result);
+		final ATerm result = pf.parseFromString(FileTools.loadFileAsString(fn));
+		final ParseTable pt = new ParseTable(result);
 		sglr = new SGLR(pf, pt);
 		//        parseTableService.fetchParseTable("tests/grammars/" + grammar + ".tbl",
 		//        		new AsyncCallback<ATerm>() {
@@ -92,13 +87,13 @@
 		//
 		//			@Override
 		//			public void onSuccess(String result) {
-		String result = FileTools.loadFileAsString("tests/data/" + s + "." + suffix);
+		final String result = FileTools.loadFileAsString("tests/data/" + s + "." + suffix);
 		assertNotNull("Data file is missing", result);
 		long parseTime = System.nanoTime();
 		ATerm parsed = null;
 		try {
 			parsed = (ATerm) sglr.parse(result);
-		} catch (Exception e) {
+		} catch (final Exception e) {
 			e.printStackTrace();
 			fail(e.toString());
 		}
@@ -106,11 +101,13 @@
 		System.out.println("Parsing " + s + " took " + parseTime/1000/1000 + " millis.");
 		assertNotNull(parsed);
 		if(doCompare)
+		{
 			doCompare(s, parsed);
-		//			}
-		//
-		//		});
-		
+			//			}
+			//
+			//		});
+		}
+
 		System.out.println(PathListPool.cacheMisses);
 		System.out.println(PooledPathList.maxRemembered);
 		System.out.println(PooledPathList.maxAllocated);
@@ -118,8 +115,8 @@
 
 	private void doCompare(String s, final ATerm parsed) {
 		//parseTableService.readTermFromFile("tests/data/" + s + ".trm", new AsyncCallback<ATerm>() {
-		String x = FileTools.loadFileAsString("tests/data/" + s + ".trm");
-		ATerm wanted = parsed.getFactory().parse(x);
+		final String x = FileTools.loadFileAsString("tests/data/" + s + ".trm");
+		final ATerm wanted = parsed.getFactory().parse(x);
 		//			@Override
 		//			public void onFailure(Throwable caught) {
 		//				fail();

From karltk at strategoxt.org  Thu Dec 16 16:03:49 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:03:49 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21534 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt: src/org/spoofax/client
	src/org/spoofax/jsglr/client src/org/spoofax/jsglr/server
	src/org/spoofax/jsglr/shared/terms test/o...
Message-ID: <201012161503.oBGF3nbc027075@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:03:49 2010
New Revision: 21534
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21534&sc=1

Log:
* Compile with 1.5.

Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/client/JSGLREntryPoint.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/server/RemoteParseTableServiceImpl.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/Asfix2TreeBuilder.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/client/JSGLREntryPoint.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/client/JSGLREntryPoint.java	Thu Dec 16 15:03:43 2010	(r21533)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/client/JSGLREntryPoint.java	Thu Dec 16 15:03:49 2010	(r21534)
@@ -23,50 +23,49 @@
 public class JSGLREntryPoint implements EntryPoint {
 
 	private void fetchParseTable(String parseTable) {
-		RequestBuilder builder = new RequestBuilder(RequestBuilder.GET, parseTable);
+		final RequestBuilder builder = new RequestBuilder(RequestBuilder.GET, parseTable);
 		try {
 			builder.sendRequest( null,  new RequestCallback() {
 				public void onError(Request request, Throwable exception)
-				{ 
-					GWT.log( "error", exception ); 
+				{
+					GWT.log( "error", exception );
 				}
-				@Override
 				public void onResponseReceived(Request request, Response response) {
 					parseAndGo(response.getText());
 				}
 			});
-		} catch (RequestException e) { 
-			GWT.log( "error", e); 
+		} catch (final RequestException e) {
+			GWT.log( "error", e);
 		}
 	}
-	@Override
+
 	public void onModuleLoad() {
 		RootPanel.get().add(new Label("Loading parse table from server"));
 		fetchParseTable("/Stratego.tbl");
-//		RemoteParseTableServiceAsync rpts = GWT.create(RemoteParseTableService.class);
-//		rpts.fetchParseTable("Stratego2.tbl", new AsyncCallback<ATerm>() {
-//
-//			@Override
-//			public void onSuccess(ATerm result) {
-//				parseAndGo(result);
-//			}
-//
-//			@Override
-//			public void onFailure(Throwable caught) {
-//				RootPanel.get().add(new Label("Failed to fetch parse table"));
-//			}
-//		});
+		//		RemoteParseTableServiceAsync rpts = GWT.create(RemoteParseTableService.class);
+		//		rpts.fetchParseTable("Stratego2.tbl", new AsyncCallback<ATerm>() {
+		//
+		//			@Override
+		//			public void onSuccess(ATerm result) {
+		//				parseAndGo(result);
+		//			}
+		//
+		//			@Override
+		//			public void onFailure(Throwable caught) {
+		//				RootPanel.get().add(new Label("Failed to fetch parse table"));
+		//			}
+		//		});
 	}
 
 	private void parseAndGo(String table) {
 		try {
 			System.out.println(table.length());
-			ATermFactory af = new ATermFactory();
-			ATerm pt = af.parse(table);
+			final ATermFactory af = new ATermFactory();
+			final ATerm pt = af.parse(table);
 			System.out.println(pt.toString().length());
-			SGLR sglr = new SGLR(af, new ParseTable(pt));
+			final SGLR sglr = new SGLR(af, new ParseTable(pt));
 			long now = System.currentTimeMillis();
-			ATerm r = (ATerm) sglr.parse(strategoSampleCode());
+			final ATerm r = (ATerm) sglr.parse(strategoSampleCode());
 			now = System.currentTimeMillis() - now;
 			if(r != null) {
 				RootPanel.get().add(new Label(r.toString()));
@@ -74,15 +73,15 @@
 			} else {
 				RootPanel.get().add(new Label("Parsing failed"));
 			}
-		} catch (InvalidParseTableException e) {
+		} catch (final InvalidParseTableException e) {
 			wrap(e);
-		} catch (TokenExpectedException e) {
+		} catch (final TokenExpectedException e) {
 			wrap(e);
-		} catch (BadTokenException e) {
+		} catch (final BadTokenException e) {
 			wrap(e);
-		} catch (ParseException e) {
+		} catch (final ParseException e) {
 			wrap(e);
-		} catch (SGLRException e) {
+		} catch (final SGLRException e) {
 			wrap(e);
 		}
 
@@ -97,16 +96,16 @@
 		"imports\n" +
 		"  include/Stratify\n" +
 		"strategies\n" +
-		"collect-meta-prop =\n" + 
-		"         ?Prop(n, v)\n" + 
-		"       ; rules(meta-prop : n -> v)\n" + 
-		"       ; <debug> (\"registered\", n, \"->\", v)\n" + 
+		"collect-meta-prop =\n" +
+		"         ?Prop(n, v)\n" +
+		"       ; rules(meta-prop : n -> v)\n" +
+		"       ; <debug> (\"registered\", n, \"->\", v)\n" +
 		"       ; <meta-prop> n\n" +
-		"       ; <debug> (\"looked up\", n, \"->\", <id>)\n" + 
-		" apply-with-props(s | props) =\n" + 
+		"       ; <debug> (\"looked up\", n, \"->\", <id>)\n" +
+		" apply-with-props(s | props) =\n" +
 		"        {meta-props:\n" +
-		"              where(<map(collect-meta-prop)> props)\n" + 
-		"          ; s\n" + 
+		"              where(<map(collect-meta-prop)> props)\n" +
+		"          ; s\n" +
 		"        }\n" +
 		" string-join(|c) =\n" +
 		"          <foldl(\\(x,y) -> <concat-strings> [y, c, x]\\)> (<id>, \"\")\n" +

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 15:03:43 2010	(r21533)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 15:03:49 2010	(r21534)
@@ -1,4 +1,4 @@
- /*
+/*
  * Created on 03.des.2005
  *
  * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
@@ -18,1200 +18,1192 @@
 import org.spoofax.jsglr.shared.SGLRException;
 import org.spoofax.jsglr.shared.TokenExpectedException;
 import org.spoofax.jsglr.shared.Tools;
-import org.spoofax.jsglr.shared.terms.ATerm;
 import org.spoofax.jsglr.shared.terms.ATermFactory;
 
 public class SGLR {
 
-    private final Set<BadTokenException> collectedErrors = new LinkedHashSet<BadTokenException>();
+	private final Set<BadTokenException> collectedErrors = new LinkedHashSet<BadTokenException>();
 
-    public static final int EOF = ParseTable.NUM_CHARS;
+	public static final int EOF = ParseTable.NUM_CHARS;
 
-    static final int TAB_SIZE = 4;//8;
+	static final int TAB_SIZE = 4;//8;
 
-    protected static boolean WORK_AROUND_MULTIPLE_LOOKAHEAD;
+	protected static boolean WORK_AROUND_MULTIPLE_LOOKAHEAD;
 
-    //Performance testing
-    private static long parseTime=0;
-    private static int parseCount=0;
-
-    public Frame startFrame;
-
-    private long startTime;
-
-    private volatile boolean asyncAborted;
-
-    private ATermFactory factory;
-
-    public Frame acceptingStack;
-
-    public ArrayDeque<Frame> activeStacks;
-
-    private ParseTable parseTable;
-
-    public int currentToken;
-
-    public int tokensSeen;
-
-    protected int lineNumber;
-
-    protected int columnNumber;
-
-    private ArrayDeque<ActionState> forShifter;
-
-    private ArrayDeque<Frame> forActor;
-
-    private ArrayDeque<Frame> forActorDelayed;
-
-    private int maxBranches;
-
-    private int maxToken;
-
-    private int maxLine;
-
-    private int maxColumn;
-
-    private int maxTokenNumber;
-
-    private AmbiguityManager ambiguityManager;
-
-    public Disambiguator disambiguator;
-
-    private int rejectCount;
-
-    private int reductionCount;
-
-    private PushbackStringIterator currentInputStream;
-
-    private boolean buildParseTree = true;
-    
-    private PooledPathList reductionsPathCache = new PooledPathList(512, true);
-    private PathListPool pathCache = new PathListPool();
-    private ArrayDeque<Frame> activeStacksWorkQueue = new ArrayDeque<Frame>();
-    private ArrayDeque<Frame> recoverStacks;
-    
-    //Creates indent- and dedent- tokens
-    //Meant for parsing of indentation based languages
-    //TODO: still under construction
-//    private IndentTokenizer indentTokenHandler;
-
-    // ------------------------------------- Integrated recovery  ------------------------
-  //Keeps track of the indentation for each line
-   // private IndentationHandler indentHandler;
-
-    private ParserHistory history;
-
-    private RecoveryConnector recoverIntegrator;
-
-    protected boolean useIntegratedRecovery;
-
-    public ParserHistory getHistory() {
-        return history;
-    }
-
-    /* START: FINE GRAINED ON REGION */
-    private boolean fineGrainedOnRegion;
-    protected void setFineGrainedOnRegion(boolean fineGrainedMode) {
-        fineGrainedOnRegion = fineGrainedMode;
-        recoverStacks = new ArrayDeque<Frame>();
-    }
-
-    public void clearRecoverStacks(){
-        recoverStacks.clear(false);
-    }
-
-    
-    public ArrayDeque<Frame> getRecoverStacks() {
-        return recoverStacks;
-    }
-
-    protected void setUseFineGrained(boolean useFG) {
-        recoverIntegrator.setUseFineGrained(useFG);
-    }
-    /* END: FINE GRAINED ON REGION */
-
-    public Set<BadTokenException> getCollectedErrors() {
-        return collectedErrors;
-    }
-
-    //-------------------------- fine-grained recovery ----------------------------------
-    //private RecoverDisambiguator recoverDisambiguator;
-
-    SGLR() {
-        basicInit(null);
-    }
-
-    public SGLR(final ATermFactory pf, ParseTable parseTable) {
-        assert pf != null;
-        assert parseTable != null;
-        // Init with a new factory for both serialized or BAF instances.
-        this.parseTable = parseTable;
-        basicInit(pf);
-    }
-
-    public void setUseStructureRecovery(boolean useRecovery, IRecoveryParser parser) {
-        useIntegratedRecovery = useRecovery;
-        recoverIntegrator = new RecoveryConnector(this, parser);
-    }
-
-    /**
-     * Structure-based recovery without bridge parsing.
-     *
-    */
-    public final void setUseStructureRecovery(boolean useRecovery) throws NoRecoveryRulesException {
-        setUseStructureRecovery(useRecovery, null);
-    }
-
-    /**
-     * @deprecated Use {@link #asyncCancel()} instead.
-     */
-    @Deprecated
-    public void asyncAbort() {
-        asyncCancel();
-    }
-
-    /**
-     * Aborts an asynchronously running parse job, causing it to throw an exception.
-     *
-     * (Provides no guarantee that the parser is actually cancelled.)
-     */
-    public void asyncCancel() {
-        asyncAborted = true;
-    }
-
-    public void asyncCancelReset() {
-        asyncAborted = false;
-    }
-
-    private void basicInit(ATermFactory factory) {
-        this.factory = factory;
-        if (factory == null)
-            factory = new ATermFactory();
-        activeStacks = new ArrayDeque<Frame>();
-        forActor = new ArrayDeque<Frame>();
-        forActorDelayed = new ArrayDeque<Frame>();
-        forShifter = new ArrayDeque<ActionState>();
-
-        // FIXME This is *wrong*: need to set the input string size instead
-        ambiguityManager = new AmbiguityManager(10000);
-
-        disambiguator = new Disambiguator();
-        //indentHandler = new IndentationHandler();
-       // indentTokenHandler = new IndentTokenizer(indentHandler, false);
-        useIntegratedRecovery = false;
-        recoverIntegrator = null;
-        history=new ParserHistory();
-        //recoverDisambiguator=new RecoverDisambiguator(this.parseTable);
-    }
-
-    public static boolean isDebugging() {
-        return Tools.debugging;
-    }
-
-    public static boolean isLogging() {
-        return Tools.logging;
-    }
-
-    /**
-     * Initializes the active stacks. At the start of parsing there is only one
-     * active stack, and this stack contains the start symbol obtained from the
-     * parse table.
-     *
-     * @return top-level frame of the initial stack
-     */
-    private Frame initActiveStacks() {
-        activeStacks.clear();
-        Frame st0 = newStack(parseTable.getInitialState());
-        addStack(st0);
-        return st0;
-    }
-
-    public Object parse(String fis, String startSymbol) throws BadTokenException, TokenExpectedException, ParseException,
-            SGLRException {
-        logBeforeParsing();
-        initParseVariables(fis);
-        startTime = System.currentTimeMillis();
-        return sglrParse(startSymbol);
-    }
-
-    public final Object parse(String input) throws BadTokenException,
-            TokenExpectedException, ParseException, SGLRException {
-
-        return parse(input, null);
-    }
-
-    private Object sglrParse(String startSymbol)
-            throws BadTokenException, TokenExpectedException,
-            ParseException, SGLRException {
-
-        try {
-            do {
-                readNextToken();
-                //indentHandler.updateIndentation(currentToken);
-                //indentTokenHandler.handleIndentShifts(this);
-                //recoverHandler.afterStreamRead(currentToken);
-                history.keepTokenAndState(this);
-                doParseStep();
-                //recoverHandler.afterParseStep();
-               // System.out.print((char)currentToken);
-            } while (currentToken != SGLR.EOF && activeStacks.size() > 0);
-
-            if (acceptingStack == null) {
-                collectedErrors.add(createBadTokenException());
-            }
-
-            if(useIntegratedRecovery && acceptingStack==null){
-                recoverIntegrator.recover();
-                if(acceptingStack==null && activeStacks.size()>0)
-                    return sglrParse(startSymbol);
-            } /*else if(recoverHandler.meetsRecoverCriteria()){
-                recoverHandler.recover();
-                if(acceptingStack==null)
-                    return sglrParse(startSymbol);
-            }*/
-
-        } catch (TaskCancellationException e) {
-            throw new ParseTimeoutException(this, currentToken, tokensSeen - 1, lineNumber,
-                    columnNumber, collectedErrors);
-        }
-
-        logAfterParsing();
-
-        Link s = acceptingStack.findDirectLink(startFrame);
-
-        if (s == null)
-            throw new ParseException(this, "Accepting stack has no link");
-
-        logParseResult(s);
-        Tools.debug("avoids: ", s.recoverCount);
-        //Tools.debug(s.label.toParseTree(parseTable));
-
-        if(buildParseTree)
-        	return disambiguator.applyFilters(this, s.label, startSymbol, tokensSeen);
-        else
-        	return null;
-    }
-
-    void readNextToken() {
-        logCurrentToken();
-        currentToken = getNextToken();
-    }
-
-    public void doParseStep() {
-        parseCharacter(); //applies reductions on active stack structure and fills forshifter
-        shifter(); //renewes active stacks with states in forshifter
-    }
-
-    private void initParseVariables(String input) {
-        startFrame = initActiveStacks();
-        tokensSeen = 0;
-        columnNumber = 0;
-        lineNumber = 1;
-        currentInputStream = new PushbackStringIterator(input);
-        acceptingStack = null;
-        //history.keepInitialState(this);
-        collectedErrors.clear();
-        
-        PooledPathList.resetPerformanceCounters();
-        PathListPool.resetPerformanceCounters();
-    }
-
-    private BadTokenException createBadTokenException() {
-
-    	final Frame singlePreviousStack = activeStacks.size() == 1 ? activeStacks.get(0) : null;
-
-    	if (singlePreviousStack != null) {
-    		Action action = singlePreviousStack.peek().getSingularAction();
-
-    		if (action != null && action.getActionItems().length == 1) {
-    			final StringBuilder expected = new StringBuilder();
-
-    			do {
-    				int token = action.getSingularRange();
-    				if (token == -1) break;
-    				expected.append((char) token);
-
-    				ActionItem[] items = action.getActionItems();
-
-    				if (!(items.length == 1 && items[0].type == ActionItem.SHIFT))
-    					break;
-
-    				Shift shift = (Shift) items[0];
-    				action = parseTable.getState(shift.nextState).getSingularAction();
-
-    			} while (action != null);
-
-    			if (expected.length() > 0)
-    				return new TokenExpectedException(this, expected.toString(), currentToken,
-    						tokensSeen - 1, lineNumber, columnNumber);
-    		}
-    	}
-
-    	return new BadTokenException(this, currentToken, tokensSeen - 1, lineNumber,
-    			columnNumber);
-    }
-
-    private void shifter() {
-        logBeforeShifter();
-        clearActiveStacks();
-
-        final AbstractParseNode prod = parseTable.lookupProduction(currentToken);
-
-        while (forShifter.size() > 0) {
-            
-        	final ActionState as = forShifter.remove();
-            
-            if (!parseTable.hasRejects() || !as.st.allLinksRejected()) {
-                Frame st1 = findStack(activeStacks, as.s);
-                if (st1 == null) {
-                    st1 = newStack(as.s);
-                    addStack(st1);
-                }
-                st1.addLink(as.st, prod, 1);
-            } else {
-                if (Tools.logging) {
-                    Tools.logger("Shifter: skipping rejected stack with state ",
-                                 as.st.state.stateNumber);
-                }
-            }
-        }
-        logAfterShifter();
-    }
-
-    public void addStack(Frame st1) {
-        if(Tools.tracing) {
-            TRACE("SG_AddStack() - " + st1.state.stateNumber);
-        }
-        activeStacks.addFirst(st1);
-    }
-    
-    private void parseCharacter() {
-        logBeforeParseCharacter();
-
-        activeStacksWorkQueue.clear();
-        for(int i = 0; i < activeStacks.size(); i++)
-        	activeStacksWorkQueue.add(activeStacks.get(i));
-        
-        clearForActorDelayed();
-        clearForShifter();
-        
-        while (activeStacksWorkQueue.size() > 0 || forActor.size() > 0) {
-            final Frame st = pickStackNodeFromActivesOrForActor(activeStacksWorkQueue);
-            if (!st.allLinksRejected()) {
-                actor(st);
-            }
-
-            if(activeStacksWorkQueue.size() == 0 && forActor.size() == 0) {
-                fillForActorWithDelayedFrames(); //Fills foractor, clears foractor delayed
-            }
-        }
-    }
-
-    private void fillForActorWithDelayedFrames() {
-        if(Tools.tracing) {
-            TRACE("SG_ - both empty");
-        }
-        ArrayDeque<Frame> tmp = forActor;
-        forActor = forActorDelayed;
-        tmp.clear();
-        forActorDelayed = tmp;
-    }
-
-    private Frame pickStackNodeFromActivesOrForActor(ArrayDeque<Frame> actives) {
-        Frame st;
-        if(actives.size() > 0) {
-            if(Tools.tracing) {
-                TRACE("SG_ - took active");
-            }
-            st = actives.remove();
-        } else {
-            if(Tools.tracing) {
-                TRACE("SG_ - took foractor");
-            }
-            st = forActor.remove();
-        }
-        return st;
-    }
-
-    private void actor(Frame st) {
-        
-    	final State s = st.peek();
-        logBeforeActor(st, s);
-        
-        for (Action action : s.getActions()) {
-            if (action.accepts(currentToken)) {
-                for (ActionItem ai : action.getActionItems()) {
-                    switch (ai.type) {
-                        case ActionItem.SHIFT: {
-                        	final Shift sh = (Shift) ai;
-                            final ActionState actState = new ActionState(st, parseTable.getState(sh.nextState));
-                            actState.currentToken = currentToken;
-                            addShiftPair(actState); //Adds StackNode to forshifter
-                            statsRecordParsers(); //sets some values un current parse state
-                            break;
-                        }
-                        case ActionItem.REDUCE: {
-                        	final Reduce red = (Reduce) ai;
-                            doReductions(st, red.production);
-                            break;
-                        }
-                        case ActionItem.REDUCE_LOOKAHEAD: {
-                            final ReduceLookahead red = (ReduceLookahead) ai;
-                            if(checkLookahead(red)) {
-                                if(Tools.tracing) {
-                                    TRACE("SG_ - ok");
-                                }
-                                doReductions(st, red.production);
-                            }
-                            break;
-                        }
-                        case ActionItem.ACCEPT: {
-                            if (!st.allLinksRejected()) {
-                                acceptingStack = st;
-                                if (Tools.logging) {
-                                    Tools.logger("Reached the accept state");
-                                }
-                            }
-                            break;
-                        }
-                        default:
-                            throw new NotImplementedException();
-                     }
-                }
-            }
-        }
-
-        if(Tools.tracing) {
-            TRACE("SG_ - actor done");
-        }
-    }
-
-    private boolean checkLookahead(ReduceLookahead red) {
-        return doCheckLookahead(red, red.getCharRanges(), 0);
-    }
-
-    private boolean doCheckLookahead(ReduceLookahead red, RangeList[] charClass, int pos) {
-        if(Tools.tracing) {
-            TRACE("SG_CheckLookAhead() - ");
-        }
-
-        final int c = currentInputStream.read();
-
-        // EOF
-        if(c == -1)
-            return true;
-
-        boolean permit = true;
-
-        if(pos < charClass.length)
-            permit = charClass[pos].within(c) ? false : doCheckLookahead(red, charClass, pos + 1);
-
-        currentInputStream.unread(c);
-        
-        return permit;
-    }
-
-    private void addShiftPair(ActionState state) {
-        if(Tools.tracing) {
-            TRACE("SG_AddShiftPair() - " + state.s.stateNumber);
-        }
-        forShifter.add(state);
-    }
-
-    private void statsRecordParsers() {
-        if (forShifter.size() > maxBranches) {
-            maxBranches = forShifter.size();
-            maxToken = currentToken;
-            maxColumn = columnNumber;
-            maxLine = lineNumber;
-            maxTokenNumber = tokensSeen;
-        }
-    }
-
-    
-    private void doReductions(Frame st, Production prod) {
-
-    	if(!recoverModeOk(st, prod))
-        	return;
-        	
-    	final PooledPathList paths = reductionsPathCache.start();
-    	st.findAllPaths(paths, prod.arity);
-    	logBeforeDoReductions(st, prod, paths.size());
-    	reduceAllPaths(prod, paths);
-    	logAfterDoReductions();
-    	paths.end();
-    }
-
-    private boolean recoverModeOk(Frame st, Production prod) {
-        return !prod.isRecoverProduction() || fineGrainedOnRegion;
-    }
-	
-    private void doLimitedReductions(Frame st, Production prod, Link l) { //Todo: Look add sharing code with doReductions
-        if(!recoverModeOk(st, prod))
-        	return;
-        
-        final PooledPathList limitedPool = pathCache.create();
-        st.findLimitedPaths(limitedPool, prod.arity, l); //find paths containing the link
-        logBeforeLimitedReductions(st, prod, l, limitedPool);
-        reduceAllPaths(prod, limitedPool);
-        limitedPool.end();
-    }
-
-    private void reduceAllPaths(Production prod, PooledPathList paths) {
-
-        for(int i = 0; i < paths.size(); i++) {
-        	final Path path = paths.get(i);
-            final AbstractParseNode[] kids = path.getParseNodes();
-            final Frame st0 = path.getEnd();
-            final State next = parseTable.go(st0.peek(), prod.label);
-            logReductionPath(prod, path, st0, next);
-            reducer(st0, next, prod, kids, path);
-        }
-
-        if (asyncAborted) {
-            // Rethrown as ParseTimeoutException in SGLR.sglrParse()
-            throw new TaskCancellationException("Long-running parse job aborted");
-        }
-    }
-
-
-    private void reducer(Frame st0, State s, Production prod, AbstractParseNode[] kids, Path path) {
-        
-    	logBeforeReducer(s, prod, path.getLength());
-        increaseReductionCount();
-
-        final int length = path.getLength();
-        final int numberOfRecoveries = calcRecoverCount(prod, path);
-        final AbstractParseNode t = prod.apply(kids);
-        final Frame st1 = findStack(activeStacks, s);
-
-        if (st1 == null) {
-            if(prod.isRecoverProduction()){
-                addNewRecoverStack(st0, s, prod, length, numberOfRecoveries, t);
-                return;
-            }
-            addNewStack(st0, s, prod, length, numberOfRecoveries, t);
-        } else {
-            /* A stack with state s exists; check for ambiguities */
-        	Link nl = st1.findDirectLink(st0);
-
-            if (nl != null) {
-                if(prod.isRecoverProduction()){
-                    return;
-                }
-                logAmbiguity(st0, prod, st1, nl);
-                if (prod.isRejectProduction())
-                    nl.reject();
-                if(numberOfRecoveries == 0 && nl.recoverCount == 0 || nl.isRejected()) {
-                    createAmbNode(t, nl);
-                } else if (numberOfRecoveries < nl.recoverCount) {
-                    nl.label = t;
-                    nl.recoverCount = numberOfRecoveries;
-                    actorOnActiveStacksOverNewLink(nl);
-                } else if (numberOfRecoveries == nl.recoverCount) {
-                    nl.label = t;
-                }
-            } else {
-                if(prod.isRecoverProduction()) {
-                    addNewRecoverStack(st0, s, prod, length, numberOfRecoveries, t);
-                    return;
-                }
-                nl = st1.addLink(st0, t, length);
-                nl.recoverCount = numberOfRecoveries;
-                if (prod.isRejectProduction()) {
-                    nl.reject();
-                    increaseRejectCount();
-                }
-                logAddedLink(st0, st1, nl);
-                actorOnActiveStacksOverNewLink(nl);
-            }
-        }
-        if(Tools.tracing) {
-            TRACE_ActiveStacks();
-            TRACE("SG_ - reducer done");
-        }
-    }
-    
-    private void createAmbNode(AbstractParseNode t, Link nl) {
-        nl.addAmbiguity(t, tokensSeen);
-        ambiguityManager.increaseAmbiguityCalls();
-    }
-
-    /** 
-     * Found no existing stack with for state s; make new stack 
-     */
-    private void addNewStack(Frame st0, State s, Production prod, int length,
-            int numberOfRecoveries, AbstractParseNode t) {
-
-    	final Frame st1 = newStack(s);
-        final Link nl = st1.addLink(st0, t, length);
-        
-        nl.recoverCount = numberOfRecoveries;
-        addStack(st1);
-        forActorDelayed.addFirst(st1);
-        
-        if(Tools.tracing) {
-            TRACE("SG_AddStack() - " + st1.state.stateNumber);
-        }
-        
-        if (prod.isRejectProduction()) {
-            if (Tools.logging) {
-                Tools.logger("Reject [new]");
-            }
-            nl.reject();
-            increaseRejectCount();
-        }
-    }
-
-    /**
-     *  Found no existing stack with for state s; make new stack 
-     */
-    private void addNewRecoverStack(Frame st0, State s, Production prod, int length,
-            int numberOfRecoveries, AbstractParseNode t) {
-        if (!(fineGrainedOnRegion && !prod.isRejectProduction()))
-        	return;
-        final Frame st1 = newStack(s);
-        final Link nl = st1.addLink(st0, t, length);
-        nl.recoverCount = numberOfRecoveries;
-        recoverStacks.addFirst(st1);
-    }
-
-    private void actorOnActiveStacksOverNewLink(Link nl) {
-        // Note: ActiveStacks can be modified inside doLimitedReductions
-        // new elements may be inserted at the beginning
-        final int sz = activeStacks.size();
-        for (int i = 0; i < sz; i++) {
-//                for(Frame st2 : activeStacks) {
-            if(Tools.tracing) {
-                TRACE("SG_ activeStack - ");
-            }
-            final int pos = activeStacks.size() - sz + i;
-            final Frame st2 = activeStacks.get(pos);
-            if (st2.allLinksRejected() || inReduceStacks(forActor, st2) || inReduceStacks(forActorDelayed, st2))
-                continue; //stacknode will find reduction in regular process
-
-            for (Action action : st2.peek().getActions()) {
-                if (action.accepts(currentToken)) {
-                    for (ActionItem ai : action.getActionItems()) {
-                        switch(ai.type) {
-                            case ActionItem.REDUCE:
-                            	final Reduce red = (Reduce) ai;
-                                doLimitedReductions(st2, red.production, nl);
-                                break;
-                            case ActionItem.REDUCE_LOOKAHEAD:
-                                final ReduceLookahead red2 = (ReduceLookahead) ai;
-                                if(checkLookahead(red2)) {
-                                    doLimitedReductions(st2, red2.production, nl);
-                                }
-                                break;
-                        }
-                    }
-                }
-            }
-        }
-    }
-
-    private int calcRecoverCount(Production prod, Path path) {
-        return path.getRecoverCount() + (prod.isRecoverProduction() ? 1 : 0);
-    }
-
-    private boolean inReduceStacks(Queue<Frame> q, Frame frame) {
-        if(Tools.tracing) {
-            TRACE("SG_InReduceStacks() - " + frame.state.stateNumber);
-        }
-        return q.contains(frame);
-    }
-
-    protected Frame newStack(State s) {
-        if(Tools.tracing) {
-            TRACE("SG_NewStack() - " + s.stateNumber);
-        }
-        return new Frame(s);
-    }
-
-    private void increaseReductionCount() {
-        reductionCount++;
-    }
-
-    protected void increaseRejectCount() {
-        rejectCount++;
-    }
-
-    protected int getRejectCount() {
-        return rejectCount;
-    }
-
-    private Frame findStack(ArrayDeque<Frame> stacks, State s) {
-        if(Tools.tracing) {
-            TRACE("SG_FindStack() - " + s.stateNumber);
-        }
-
-        // We need only check the top frames of the active stacks.
-        if (Tools.debugging) {
-            Tools.debug("findStack() - ", dumpActiveStacks());
-            Tools.debug(" looking for ", s.stateNumber);
-        }
-
-        final int size = stacks.size();
-        for (int i = 0; i < size; i++) {
-            if (stacks.get(i).state.stateNumber == s.stateNumber) {
-                if(Tools.tracing) {
-                    TRACE("SG_ - found stack");
-                }
-                return stacks.get(i);
-            }
-        }
-        if(Tools.tracing) {
-            TRACE("SG_ - stack not found");
-        }
-        return null;
-    }
-
-
-    private int getNextToken() {
-        if(Tools.tracing) {
-            TRACE("SG_NextToken() - ");
-        }
-
-        final int ch = currentInputStream.read();
-        updateLineAndColumnInfo(ch);
-        if(ch == -1)
-            return SGLR.EOF;
-        return ch;
-    }
-
-    protected void updateLineAndColumnInfo(int ch) {
-        tokensSeen++;
-
-        if (Tools.debugging) {
-            Tools.debug("getNextToken() - ", ch, "(", (char) ch, ")");
-        }
-
-        switch (ch) {
-        case '\n':
-            lineNumber++;
-            columnNumber = 0;
-            break;
-        case '\t':
-            columnNumber = (columnNumber / TAB_SIZE + 1) * TAB_SIZE;
-            break;
-        case -1:
-            break;
-        default:
-            columnNumber++;
-        }
-    }
-
-    @Deprecated
-    public void setFilter(boolean filter) {
-        getDisambiguator().setFilterAny(filter);
-    }
-
-    public void clear() {
-        if (this.acceptingStack != null) {
-            this.acceptingStack.clear();
-        }
-
-        clearActiveStacksDeep();
-        clearForActorDelayedDeep();
-        clearForActorDeep();
-        clearForShifterDeep();
-
-        this.parseTable = null;
-        this.factory = null;
-        this.ambiguityManager = null;
-    }
-
-    private void clearForShifterDeep() {
-    	for (ActionState as : forShifter) {
-    		as.clear(true);
-    	}
-    	clearForShifter();
-    }
-
-    private void clearForShifter() {
-        forShifter.clear();
-    }
-
-    private void clearForActor() {
-        forActor.clear();
-    }
-
-    private void clearForActorDeep() {
-    	for (Frame frame : forActor) {
-    		frame.clear();
-    	}
-    	clearForActor();
-    }
-
-    private void clearForActorDelayedDeep() {
-    	for (Frame frame : forActorDelayed) {
-    		frame.clear();
-            	
-        }
-    	clearForActorDelayed();
-    }
-
-    private void clearForActorDelayed() {
-        forActorDelayed.clear(true);
-    }
-
-    private void clearActiveStacksDeep() {
-    	for (Frame frame : activeStacks) {
-    		frame.clear();
-    	}
-    	clearActiveStacks();
-    }
-
-    private void clearActiveStacks() {
-        activeStacks.clear(true);
-    }
-
-    ParseTable getParseTable() {
-        return parseTable;
-    }
-
-    AmbiguityManager getAmbiguityManager() {
-        return ambiguityManager;
-    }
-
-    public Disambiguator getDisambiguator() {
-        return disambiguator;
-    }
-
-    public void setDisambiguator(Disambiguator disambiguator) {
-        this.disambiguator = disambiguator;
-    }
-
-    public ATermFactory getFactory() {
-        return factory;
-    }
-
-    public int getReductionCount() {
-        return reductionCount;
-    }
-
-    public int getRejectionCount() {
-        return rejectCount;
-    }
-
-    @Deprecated
-    public static void setWorkAroundMultipleLookahead(boolean value) {
-        WORK_AROUND_MULTIPLE_LOOKAHEAD = value;
-    }
-
-
-
-
-
-    ////////////////////////////////////////////////////// Log functions ///////////////////////////////////////////////////////////////////////////////
-
-    static int traceCallCount = 0;
-
-    static void TRACE(String string) {
-        System.err.println("[" + traceCallCount + "] " + string);
-        traceCallCount++;
-    }
-
-    private String dumpActiveStacks() {
-        StringBuffer sb = new StringBuffer();
-        boolean first = true;
-        if (activeStacks == null) {
-            sb.append(" GSS unitialized");
-        } else {
-            sb.append("{").append(activeStacks.size()).append("} ");
-            for (Frame f : activeStacks) {
-                if (!first)
-                    sb.append(", ");
-                sb.append(f.dumpStack());
-                first = false;
-            }
-        }
-        return sb.toString();
-    }
-
-
-    private void logParseResult(Link s) {
-        if (isDebugging()) {
-            Tools.debug("internal parse tree:\n", s.label);
-        }
-
-        if(Tools.tracing) {
-            TRACE("SG_ - internal tree: " + s.label);
-        }
-
-        if (Tools.measuring) {
-            Measures m = new Measures();
-            //Tools.debug("Time (ms): " + (System.currentTimeMillis()-startTime));
-            m.setTime(System.currentTimeMillis() - startTime);
-            //Tools.debug("Red.: " + reductionCount);
-            m.setReductionCount(reductionCount);
-            //Tools.debug("Nodes: " + Frame.framesCreated);
-            m.setFramesCreated(Frame.framesCreated);
-            //Tools.debug("Links: " + Link.linksCreated);
-            m.setLinkedCreated(Link.linksCreated);
-            //Tools.debug("avoids: " + s.avoidCount);
-            m.setAvoidCount(s.recoverCount);
-            //Tools.debug("Total Time: " + parseTime);
-            m.setParseTime(parseTime);
-            //Tools.debug("Total Count: " + parseCount);
-            Measures.setParseCount(++parseCount);
-            //Tools.debug("Average Time: " + (int)parseTime / parseCount);
-            m.setAverageParseTime((int)parseTime / parseCount);
-            m.setRecoverTime(-1);
-            Tools.setMeasures(m);
-        }
-    }
-
-
-    private void logBeforeParsing() {
-        if(Tools.tracing) {
-            TRACE("SG_Parse() - ");
-        }
-
-        if (Tools.debugging) {
-            Tools.debug("parse() - ", dumpActiveStacks());
-        }
-    }
-
-    private void logAfterParsing()
-            throws BadTokenException, TokenExpectedException {
-        if (isLogging()) {
-            Tools.logger("Number of lines: ", lineNumber);
-            Tools.logger("Maximum ", maxBranches, " parse branches reached at token ",
-                         logCharify(maxToken), ", line ", maxLine, ", column ", maxColumn,
-                         " (token #", maxTokenNumber, ")");
-
-            long elapsed = System.currentTimeMillis() - startTime;
-            Tools.logger("Parse time: " + elapsed / 1000.0f + "s");
-        }
-
-        if (isDebugging()) {
-            Tools.debug("Parsing complete: all tokens read");
-        }
-
-        if (acceptingStack == null) {
-            BadTokenException bad = createBadTokenException();
-            if (collectedErrors.isEmpty()) {
-                throw bad;
-            } else {
-                collectedErrors.add(bad);
-                throw new MultiBadTokenException(this, collectedErrors);
-            }
-        }
-
-
-        if (isDebugging()) {
-            Tools.debug("Accepting stack exists");
-        }
-    }
-
-    private void logCurrentToken() {
-        if (isLogging()) {
-            Tools.logger("Current token (#", tokensSeen, "): ", logCharify(currentToken));
-        }
-    }
-
-    private void logAfterShifter() {
-        if(Tools.tracing) {
-            TRACE("SG_DiscardShiftPairs() - ");
-            TRACE_ActiveStacks();
-        }
-    }
-
-    private void logBeforeShifter() {
-        if(Tools.tracing) {
-            TRACE("SG_Shifter() - ");
-            TRACE_ActiveStacks();
-        }
-
-        if (Tools.logging) {
-            Tools.logger("#", tokensSeen, ": shifting ", forShifter.size(), " parser(s) -- token ",
-                         logCharify(currentToken), ", line ", lineNumber, ", column ", columnNumber);
-        }
-
-        if (Tools.debugging) {
-            Tools.debug("shifter() - " + dumpActiveStacks());
-
-            Tools.debug(" token   : " + currentToken);
-            Tools.debug(" parsers : " + forShifter.size());
-        }
-    }
-
-    private void logBeforeParseCharacter() {
-        if(Tools.tracing) {
-            TRACE("SG_ParseToken() - ");
-        }
-
-        if (Tools.debugging) {
-            Tools.debug("parseCharacter() - " + dumpActiveStacks());
-            Tools.debug(" # active stacks : " + activeStacks.size());
-        }
-
-        /* forActor = *///computeStackOfStacks(activeStacks);
-
-        if (Tools.debugging) {
-            Tools.debug(" # for actor     : " + forActor.size());
-        }
-    }
-
-    private String logCharify(int currentToken) {
-        switch (currentToken) {
-        case 32:
-            return "\\32";
-        case SGLR.EOF:
-            return "EOF";
-        case '\n':
-            return "\\n";
-        case 0:
-            return "\\0";
-        default:
-            return "" + (char) currentToken;
-        }
-    }
-
-    private void logBeforeActor(Frame st, State s) {
-        List<ActionItem> actionItems = null;
-
-        if (Tools.debugging || Tools.tracing) {
-            actionItems = s.getActionItems(currentToken);
-        }
-
-        if(Tools.tracing) {
-            TRACE("SG_Actor() - " + st.state.stateNumber);
-            TRACE_ActiveStacks();
-        }
-
-        if (Tools.debugging) {
-            Tools.debug("actor() - ", dumpActiveStacks());
-        }
-
-        if (Tools.debugging) {
-            Tools.debug(" state   : ", s.stateNumber);
-            Tools.debug(" token   : ", currentToken);
-        }
-
-        if (Tools.debugging) {
-            Tools.debug(" actions : ", actionItems);
-        }
-
-        if(Tools.tracing) {
-            TRACE("SG_ - actions: " + actionItems.size());
-        }
-    }
-
-    private void logAfterDoReductions() {
-        if (Tools.debugging) {
-            Tools.debug("<doReductions() - " + dumpActiveStacks());
-        }
-
-        if(Tools.tracing) {
-            TRACE("SG_ - doreductions done");
-        }
-    }
-
-    private void logReductionPath(Production prod, Path path, Frame st0, State next) {
-        if (Tools.debugging) {
-            Tools.debug(" path: ", path);
-            Tools.debug(st0.state);
-        }
-
-        if (Tools.logging) {
-            Tools.logger("Goto(", st0.peek().stateNumber, ",", prod.label + ") == ",
-                         next.stateNumber);
-        }
-    }
-
-
-    private void logBeforeDoReductions(Frame st, Production prod,
-            final int pathsCount) {
-        if(Tools.tracing) {
-            TRACE("SG_DoReductions() - " + st.state.stateNumber);
-        }
-
-        if (Tools.debugging) {
-            Tools.debug("doReductions() - " + dumpActiveStacks());
-            logReductionInfo(st, prod);
-            Tools.debug(" paths : " + pathsCount);
-        }
-    }
-
-    private void logBeforeLimitedReductions(Frame st, Production prod, Link l,
-            PooledPathList paths) {
-        if(Tools.tracing) {
-            TRACE("SG_ - back in reducer ");
-            TRACE_ActiveStacks();
-            TRACE("SG_DoLimitedReductions() - " + st.state.stateNumber + ", " + l.parent.state.stateNumber);
-        }
-
-        if (Tools.debugging) {
-            Tools.debug("doLimitedReductions() - ", dumpActiveStacks());
-            logReductionInfo(st, prod);
-            Tools.debug(Arrays.asList(paths));
-        }
-    }
-
-    private void logReductionInfo(Frame st, Production prod) {
-        Tools.debug(" state : ", st.peek().stateNumber);
-        Tools.debug(" token : ", currentToken);
-        Tools.debug(" label : ", prod.label);
-        Tools.debug(" arity : ", prod.arity);
-        Tools.debug(" stack : ", st.dumpStack());
-    }
-
-    private void logAddedLink(Frame st0, Frame st1, Link nl) {
-        if (Tools.debugging) {
-            Tools.debug(" added link ", nl, " from ", st1.state.stateNumber, " to ",
-                        st0.state.stateNumber);
-        }
-
-        if(Tools.tracing) {
-            TRACE_ActiveStacks();
-        }
-    }
-
-    private void logBeforeReducer(State s, Production prod, int length) {
-        if(Tools.tracing) {
-            TRACE("SG_Reducer() - " + s.stateNumber + ", " + length + ", " + prod.label);
-            TRACE_ActiveStacks();
-        }
-
-        if (Tools.logging) {
-            Tools.logger("Reducing; state ", s.stateNumber, ", token: ", logCharify(currentToken),
-                         ", production: ", prod.label);
-        }
-
-        if (Tools.debugging) {
-            Tools.debug("reducer() - ", dumpActiveStacks());
-
-            Tools.debug(" state      : ", s.stateNumber);
-            Tools.debug(" token      : ", logCharify(currentToken) + " (" + currentToken + ")");
-            Tools.debug(" production : ", prod.label);
-        }
-    }
-
-    private void TRACE_ActiveStacks() {
-        TRACE("SG_ - active stacks: " + activeStacks.size());
-        TRACE("SG_ - for_actor stacks: " + forActor.size());
-        TRACE("SG_ - for_actor_delayed stacks: " + forActorDelayed.size());
-    }
-
-
-    private void logAmbiguity(Frame st0, Production prod, Frame st1, Link nl) {
-        if (Tools.logging) {
-            Tools.logger("Ambiguity: direct link ", st0.state.stateNumber, " -> ",
-                         st1.state.stateNumber, " ", (prod.isRejectProduction() ? "{reject}" : ""));
-            if (nl.label instanceof ParseNode) {
-                Tools.logger("nl is ", nl.isRejected() ? "{reject}" : "", " for ",
-                             ((ParseNode) nl.label).label);
-            }
-        }
-
-        if (Tools.debugging) {
-            Tools.debug("createAmbiguityCluster - ", tokensSeen - nl.getLength() - 1, "/",
-                        nl.getLength());
-        }
-    }
+	//Performance testing
+	private static long parseTime=0;
+	private static int parseCount=0;
+
+	public Frame startFrame;
+
+	private long startTime;
+
+	private volatile boolean asyncAborted;
+
+	private ATermFactory factory;
+
+	public Frame acceptingStack;
+
+	public ArrayDeque<Frame> activeStacks;
+
+	private ParseTable parseTable;
+
+	public int currentToken;
+
+	public int tokensSeen;
+
+	protected int lineNumber;
+
+	protected int columnNumber;
+
+	private ArrayDeque<ActionState> forShifter;
+
+	private ArrayDeque<Frame> forActor;
+
+	private ArrayDeque<Frame> forActorDelayed;
+
+	private int maxBranches;
+
+	private int maxToken;
+
+	private int maxLine;
+
+	private int maxColumn;
+
+	private int maxTokenNumber;
+
+	private AmbiguityManager ambiguityManager;
+
+	public Disambiguator disambiguator;
+
+	private int rejectCount;
+
+	private int reductionCount;
+
+	private PushbackStringIterator currentInputStream;
+
+	private boolean buildParseTree = true;
+
+	private PooledPathList reductionsPathCache = new PooledPathList(512, true);
+	private PathListPool pathCache = new PathListPool();
+	private ArrayDeque<Frame> activeStacksWorkQueue = new ArrayDeque<Frame>();
+	private ArrayDeque<Frame> recoverStacks;
+
+	private ParserHistory history;
+
+	private RecoveryConnector recoverIntegrator;
+
+	protected boolean useIntegratedRecovery;
+
+	public ParserHistory getHistory() {
+		return history;
+	}
+
+	/* START: FINE GRAINED ON REGION */
+	private boolean fineGrainedOnRegion;
+	protected void setFineGrainedOnRegion(boolean fineGrainedMode) {
+		fineGrainedOnRegion = fineGrainedMode;
+		recoverStacks = new ArrayDeque<Frame>();
+	}
+
+	public void clearRecoverStacks(){
+		recoverStacks.clear(false);
+	}
+
+
+	public ArrayDeque<Frame> getRecoverStacks() {
+		return recoverStacks;
+	}
+
+	protected void setUseFineGrained(boolean useFG) {
+		recoverIntegrator.setUseFineGrained(useFG);
+	}
+	/* END: FINE GRAINED ON REGION */
+
+	public Set<BadTokenException> getCollectedErrors() {
+		return collectedErrors;
+	}
+
+	SGLR() {
+		basicInit(null);
+	}
+
+	public SGLR(final ATermFactory pf, ParseTable parseTable) {
+		assert pf != null;
+		assert parseTable != null;
+		// Init with a new factory for both serialized or BAF instances.
+		this.parseTable = parseTable;
+		basicInit(pf);
+	}
+
+	public void setUseStructureRecovery(boolean useRecovery, IRecoveryParser parser) {
+		useIntegratedRecovery = useRecovery;
+		recoverIntegrator = new RecoveryConnector(this, parser);
+	}
+
+	/**
+	 * Structure-based recovery without bridge parsing.
+	 *
+	 */
+	public final void setUseStructureRecovery(boolean useRecovery) throws NoRecoveryRulesException {
+		setUseStructureRecovery(useRecovery, null);
+	}
+
+	/**
+	 * @deprecated Use {@link #asyncCancel()} instead.
+	 */
+	@Deprecated
+	public void asyncAbort() {
+		asyncCancel();
+	}
+
+	/**
+	 * Aborts an asynchronously running parse job, causing it to throw an exception.
+	 *
+	 * (Provides no guarantee that the parser is actually cancelled.)
+	 */
+	public void asyncCancel() {
+		asyncAborted = true;
+	}
+
+	public void asyncCancelReset() {
+		asyncAborted = false;
+	}
+
+	private void basicInit(ATermFactory factory) {
+		this.factory = factory;
+		if (factory == null) {
+			factory = new ATermFactory();
+		}
+		activeStacks = new ArrayDeque<Frame>();
+		forActor = new ArrayDeque<Frame>();
+		forActorDelayed = new ArrayDeque<Frame>();
+		forShifter = new ArrayDeque<ActionState>();
+
+		// FIXME This is *wrong*: need to set the input string size instead
+		ambiguityManager = new AmbiguityManager(10000);
+
+		disambiguator = new Disambiguator();
+		useIntegratedRecovery = false;
+		recoverIntegrator = null;
+		history = new ParserHistory();
+	}
+
+	public static boolean isDebugging() {
+		return Tools.debugging;
+	}
+
+	public static boolean isLogging() {
+		return Tools.logging;
+	}
+
+	/**
+	 * Initializes the active stacks. At the start of parsing there is only one
+	 * active stack, and this stack contains the start symbol obtained from the
+	 * parse table.
+	 *
+	 * @return top-level frame of the initial stack
+	 */
+	private Frame initActiveStacks() {
+		activeStacks.clear();
+		final Frame st0 = newStack(parseTable.getInitialState());
+		addStack(st0);
+		return st0;
+	}
+
+	public Object parse(String fis, String startSymbol) throws BadTokenException, TokenExpectedException, ParseException,
+	SGLRException {
+		logBeforeParsing();
+		initParseVariables(fis);
+		startTime = System.currentTimeMillis();
+		return sglrParse(startSymbol);
+	}
+
+	public final Object parse(String input) throws BadTokenException,
+	TokenExpectedException, ParseException, SGLRException {
+
+		return parse(input, null);
+	}
+
+	private Object sglrParse(String startSymbol)
+	throws BadTokenException, TokenExpectedException,
+	ParseException, SGLRException {
+
+		try {
+			do {
+				readNextToken();
+				history.keepTokenAndState(this);
+				doParseStep();
+			} while (currentToken != SGLR.EOF && activeStacks.size() > 0);
+
+			if (acceptingStack == null) {
+				collectedErrors.add(createBadTokenException());
+			}
+
+			if(useIntegratedRecovery && acceptingStack==null){
+				recoverIntegrator.recover();
+				if(acceptingStack==null && activeStacks.size()>0) {
+					return sglrParse(startSymbol);
+				}
+			}
+		} catch (final TaskCancellationException e) {
+			throw new ParseTimeoutException(this, currentToken, tokensSeen - 1, lineNumber,
+					columnNumber, collectedErrors);
+		}
+
+		logAfterParsing();
+
+		final Link s = acceptingStack.findDirectLink(startFrame);
+
+		if (s == null) {
+			throw new ParseException(this, "Accepting stack has no link");
+		}
+
+		logParseResult(s);
+		Tools.debug("avoids: ", s.recoverCount);
+		//Tools.debug(s.label.toParseTree(parseTable));
+
+		if(buildParseTree) {
+			return disambiguator.applyFilters(this, s.label, startSymbol, tokensSeen);
+		} else {
+			return null;
+		}
+	}
+
+	void readNextToken() {
+		logCurrentToken();
+		currentToken = getNextToken();
+	}
+
+	public void doParseStep() {
+		parseCharacter(); //applies reductions on active stack structure and fills forshifter
+		shifter(); //renewes active stacks with states in forshifter
+	}
+
+	private void initParseVariables(String input) {
+		startFrame = initActiveStacks();
+		tokensSeen = 0;
+		columnNumber = 0;
+		lineNumber = 1;
+		currentInputStream = new PushbackStringIterator(input);
+		acceptingStack = null;
+		collectedErrors.clear();
+
+		PooledPathList.resetPerformanceCounters();
+		PathListPool.resetPerformanceCounters();
+	}
+
+	private BadTokenException createBadTokenException() {
+
+		final Frame singlePreviousStack = activeStacks.size() == 1 ? activeStacks.get(0) : null;
+
+		if (singlePreviousStack != null) {
+			Action action = singlePreviousStack.peek().getSingularAction();
+
+			if (action != null && action.getActionItems().length == 1) {
+				final StringBuilder expected = new StringBuilder();
+
+				do {
+					final int token = action.getSingularRange();
+					if (token == -1) {
+						break;
+					}
+					expected.append((char) token);
+
+					final ActionItem[] items = action.getActionItems();
+
+					if (!(items.length == 1 && items[0].type == ActionItem.SHIFT)) {
+						break;
+					}
+
+					final Shift shift = (Shift) items[0];
+					action = parseTable.getState(shift.nextState).getSingularAction();
+
+				} while (action != null);
+
+				if (expected.length() > 0) {
+					return new TokenExpectedException(this, expected.toString(), currentToken,
+							tokensSeen - 1, lineNumber, columnNumber);
+				}
+			}
+		}
+
+		return new BadTokenException(this, currentToken, tokensSeen - 1, lineNumber,
+				columnNumber);
+	}
+
+	private void shifter() {
+		logBeforeShifter();
+		clearActiveStacks();
+
+		final AbstractParseNode prod = parseTable.lookupProduction(currentToken);
+
+		while (forShifter.size() > 0) {
+
+			final ActionState as = forShifter.remove();
+
+			if (!parseTable.hasRejects() || !as.st.allLinksRejected()) {
+				Frame st1 = findStack(activeStacks, as.s);
+				if (st1 == null) {
+					st1 = newStack(as.s);
+					addStack(st1);
+				}
+				st1.addLink(as.st, prod, 1);
+			} else {
+				if (Tools.logging) {
+					Tools.logger("Shifter: skipping rejected stack with state ",
+							as.st.state.stateNumber);
+				}
+			}
+		}
+		logAfterShifter();
+	}
+
+	public void addStack(Frame st1) {
+		if(Tools.tracing) {
+			TRACE("SG_AddStack() - " + st1.state.stateNumber);
+		}
+		activeStacks.addFirst(st1);
+	}
+
+	private void parseCharacter() {
+		logBeforeParseCharacter();
+
+		activeStacksWorkQueue.clear();
+		for(int i = 0; i < activeStacks.size(); i++) {
+			activeStacksWorkQueue.add(activeStacks.get(i));
+		}
+
+		clearForActorDelayed();
+		clearForShifter();
+
+		while (activeStacksWorkQueue.size() > 0 || forActor.size() > 0) {
+			final Frame st = pickStackNodeFromActivesOrForActor(activeStacksWorkQueue);
+			if (!st.allLinksRejected()) {
+				actor(st);
+			}
+
+			if(activeStacksWorkQueue.size() == 0 && forActor.size() == 0) {
+				fillForActorWithDelayedFrames(); //Fills foractor, clears foractor delayed
+			}
+		}
+	}
+
+	private void fillForActorWithDelayedFrames() {
+		if(Tools.tracing) {
+			TRACE("SG_ - both empty");
+		}
+		final ArrayDeque<Frame> tmp = forActor;
+		forActor = forActorDelayed;
+		tmp.clear();
+		forActorDelayed = tmp;
+	}
+
+	private Frame pickStackNodeFromActivesOrForActor(ArrayDeque<Frame> actives) {
+		Frame st;
+		if(actives.size() > 0) {
+			if(Tools.tracing) {
+				TRACE("SG_ - took active");
+			}
+			st = actives.remove();
+		} else {
+			if(Tools.tracing) {
+				TRACE("SG_ - took foractor");
+			}
+			st = forActor.remove();
+		}
+		return st;
+	}
+
+	private void actor(Frame st) {
+
+		final State s = st.peek();
+		logBeforeActor(st, s);
+
+		for (final Action action : s.getActions()) {
+			if (action.accepts(currentToken)) {
+				for (final ActionItem ai : action.getActionItems()) {
+					switch (ai.type) {
+					case ActionItem.SHIFT: {
+						final Shift sh = (Shift) ai;
+						final ActionState actState = new ActionState(st, parseTable.getState(sh.nextState));
+						actState.currentToken = currentToken;
+						addShiftPair(actState); //Adds StackNode to forshifter
+						statsRecordParsers(); //sets some values un current parse state
+						break;
+					}
+					case ActionItem.REDUCE: {
+						final Reduce red = (Reduce) ai;
+						doReductions(st, red.production);
+						break;
+					}
+					case ActionItem.REDUCE_LOOKAHEAD: {
+						final ReduceLookahead red = (ReduceLookahead) ai;
+						if(checkLookahead(red)) {
+							if(Tools.tracing) {
+								TRACE("SG_ - ok");
+							}
+							doReductions(st, red.production);
+						}
+						break;
+					}
+					case ActionItem.ACCEPT: {
+						if (!st.allLinksRejected()) {
+							acceptingStack = st;
+							if (Tools.logging) {
+								Tools.logger("Reached the accept state");
+							}
+						}
+						break;
+					}
+					default:
+						throw new NotImplementedException();
+					}
+				}
+			}
+		}
+
+		if(Tools.tracing) {
+			TRACE("SG_ - actor done");
+		}
+	}
+
+	private boolean checkLookahead(ReduceLookahead red) {
+		return doCheckLookahead(red, red.getCharRanges(), 0);
+	}
+
+	private boolean doCheckLookahead(ReduceLookahead red, RangeList[] charClass, int pos) {
+		if(Tools.tracing) {
+			TRACE("SG_CheckLookAhead() - ");
+		}
+
+		final int c = currentInputStream.read();
+
+		// EOF
+		if(c == -1) {
+			return true;
+		}
+
+		boolean permit = true;
+
+		if(pos < charClass.length) {
+			permit = charClass[pos].within(c) ? false : doCheckLookahead(red, charClass, pos + 1);
+		}
+
+		currentInputStream.unread(c);
+
+		return permit;
+	}
+
+	private void addShiftPair(ActionState state) {
+		if(Tools.tracing) {
+			TRACE("SG_AddShiftPair() - " + state.s.stateNumber);
+		}
+		forShifter.add(state);
+	}
+
+	private void statsRecordParsers() {
+		if (forShifter.size() > maxBranches) {
+			maxBranches = forShifter.size();
+			maxToken = currentToken;
+			maxColumn = columnNumber;
+			maxLine = lineNumber;
+			maxTokenNumber = tokensSeen;
+		}
+	}
+
+
+	private void doReductions(Frame st, Production prod) {
+
+		if(!recoverModeOk(st, prod)) {
+			return;
+		}
+
+		final PooledPathList paths = reductionsPathCache.start();
+		st.findAllPaths(paths, prod.arity);
+		logBeforeDoReductions(st, prod, paths.size());
+		reduceAllPaths(prod, paths);
+		logAfterDoReductions();
+		paths.end();
+	}
+
+	private boolean recoverModeOk(Frame st, Production prod) {
+		return !prod.isRecoverProduction() || fineGrainedOnRegion;
+	}
+
+	private void doLimitedReductions(Frame st, Production prod, Link l) { //Todo: Look add sharing code with doReductions
+		if(!recoverModeOk(st, prod)) {
+			return;
+		}
+
+		final PooledPathList limitedPool = pathCache.create();
+		st.findLimitedPaths(limitedPool, prod.arity, l); //find paths containing the link
+		logBeforeLimitedReductions(st, prod, l, limitedPool);
+		reduceAllPaths(prod, limitedPool);
+		limitedPool.end();
+	}
+
+	private void reduceAllPaths(Production prod, PooledPathList paths) {
+
+		for(int i = 0; i < paths.size(); i++) {
+			final Path path = paths.get(i);
+			final AbstractParseNode[] kids = path.getParseNodes();
+			final Frame st0 = path.getEnd();
+			final State next = parseTable.go(st0.peek(), prod.label);
+			logReductionPath(prod, path, st0, next);
+			reducer(st0, next, prod, kids, path);
+		}
+
+		if (asyncAborted) {
+			// Rethrown as ParseTimeoutException in SGLR.sglrParse()
+			throw new TaskCancellationException("Long-running parse job aborted");
+		}
+	}
+
+
+	private void reducer(Frame st0, State s, Production prod, AbstractParseNode[] kids, Path path) {
+
+		logBeforeReducer(s, prod, path.getLength());
+		increaseReductionCount();
+
+		final int length = path.getLength();
+		final int numberOfRecoveries = calcRecoverCount(prod, path);
+		final AbstractParseNode t = prod.apply(kids);
+		final Frame st1 = findStack(activeStacks, s);
+
+		if (st1 == null) {
+			if(prod.isRecoverProduction()){
+				addNewRecoverStack(st0, s, prod, length, numberOfRecoveries, t);
+				return;
+			}
+			addNewStack(st0, s, prod, length, numberOfRecoveries, t);
+		} else {
+			/* A stack with state s exists; check for ambiguities */
+			Link nl = st1.findDirectLink(st0);
+
+			if (nl != null) {
+				if(prod.isRecoverProduction()){
+					return;
+				}
+				logAmbiguity(st0, prod, st1, nl);
+				if (prod.isRejectProduction()) {
+					nl.reject();
+				}
+				if(numberOfRecoveries == 0 && nl.recoverCount == 0 || nl.isRejected()) {
+					createAmbNode(t, nl);
+				} else if (numberOfRecoveries < nl.recoverCount) {
+					nl.label = t;
+					nl.recoverCount = numberOfRecoveries;
+					actorOnActiveStacksOverNewLink(nl);
+				} else if (numberOfRecoveries == nl.recoverCount) {
+					nl.label = t;
+				}
+			} else {
+				if(prod.isRecoverProduction()) {
+					addNewRecoverStack(st0, s, prod, length, numberOfRecoveries, t);
+					return;
+				}
+				nl = st1.addLink(st0, t, length);
+				nl.recoverCount = numberOfRecoveries;
+				if (prod.isRejectProduction()) {
+					nl.reject();
+					increaseRejectCount();
+				}
+				logAddedLink(st0, st1, nl);
+				actorOnActiveStacksOverNewLink(nl);
+			}
+		}
+		if(Tools.tracing) {
+			TRACE_ActiveStacks();
+			TRACE("SG_ - reducer done");
+		}
+	}
+
+	private void createAmbNode(AbstractParseNode t, Link nl) {
+		nl.addAmbiguity(t, tokensSeen);
+		ambiguityManager.increaseAmbiguityCalls();
+	}
+
+	/**
+	 * Found no existing stack with for state s; make new stack
+	 */
+	private void addNewStack(Frame st0, State s, Production prod, int length,
+			int numberOfRecoveries, AbstractParseNode t) {
+
+		final Frame st1 = newStack(s);
+		final Link nl = st1.addLink(st0, t, length);
+
+		nl.recoverCount = numberOfRecoveries;
+		addStack(st1);
+		forActorDelayed.addFirst(st1);
+
+		if(Tools.tracing) {
+			TRACE("SG_AddStack() - " + st1.state.stateNumber);
+		}
+
+		if (prod.isRejectProduction()) {
+			if (Tools.logging) {
+				Tools.logger("Reject [new]");
+			}
+			nl.reject();
+			increaseRejectCount();
+		}
+	}
+
+	/**
+	 *  Found no existing stack with for state s; make new stack
+	 */
+	private void addNewRecoverStack(Frame st0, State s, Production prod, int length,
+			int numberOfRecoveries, AbstractParseNode t) {
+		if (!(fineGrainedOnRegion && !prod.isRejectProduction())) {
+			return;
+		}
+		final Frame st1 = newStack(s);
+		final Link nl = st1.addLink(st0, t, length);
+		nl.recoverCount = numberOfRecoveries;
+		recoverStacks.addFirst(st1);
+	}
+
+	private void actorOnActiveStacksOverNewLink(Link nl) {
+		// Note: ActiveStacks can be modified inside doLimitedReductions
+		// new elements may be inserted at the beginning
+		final int sz = activeStacks.size();
+		for (int i = 0; i < sz; i++) {
+			//                for(Frame st2 : activeStacks) {
+			if(Tools.tracing) {
+				TRACE("SG_ activeStack - ");
+			}
+			final int pos = activeStacks.size() - sz + i;
+			final Frame st2 = activeStacks.get(pos);
+			if (st2.allLinksRejected() || inReduceStacks(forActor, st2) || inReduceStacks(forActorDelayed, st2))
+			{
+				continue; //stacknode will find reduction in regular process
+			}
+
+			for (final Action action : st2.peek().getActions()) {
+				if (action.accepts(currentToken)) {
+					for (final ActionItem ai : action.getActionItems()) {
+						switch(ai.type) {
+						case ActionItem.REDUCE:
+							final Reduce red = (Reduce) ai;
+							doLimitedReductions(st2, red.production, nl);
+							break;
+						case ActionItem.REDUCE_LOOKAHEAD:
+							final ReduceLookahead red2 = (ReduceLookahead) ai;
+							if(checkLookahead(red2)) {
+								doLimitedReductions(st2, red2.production, nl);
+							}
+							break;
+						}
+					}
+				}
+			}
+		}
+	}
+
+	private int calcRecoverCount(Production prod, Path path) {
+		return path.getRecoverCount() + (prod.isRecoverProduction() ? 1 : 0);
+	}
+
+	private boolean inReduceStacks(Queue<Frame> q, Frame frame) {
+		if(Tools.tracing) {
+			TRACE("SG_InReduceStacks() - " + frame.state.stateNumber);
+		}
+		return q.contains(frame);
+	}
+
+	protected Frame newStack(State s) {
+		if(Tools.tracing) {
+			TRACE("SG_NewStack() - " + s.stateNumber);
+		}
+		return new Frame(s);
+	}
+
+	private void increaseReductionCount() {
+		reductionCount++;
+	}
+
+	protected void increaseRejectCount() {
+		rejectCount++;
+	}
+
+	protected int getRejectCount() {
+		return rejectCount;
+	}
+
+	private Frame findStack(ArrayDeque<Frame> stacks, State s) {
+		if(Tools.tracing) {
+			TRACE("SG_FindStack() - " + s.stateNumber);
+		}
+
+		// We need only check the top frames of the active stacks.
+		if (Tools.debugging) {
+			Tools.debug("findStack() - ", dumpActiveStacks());
+			Tools.debug(" looking for ", s.stateNumber);
+		}
+
+		final int size = stacks.size();
+		for (int i = 0; i < size; i++) {
+			if (stacks.get(i).state.stateNumber == s.stateNumber) {
+				if(Tools.tracing) {
+					TRACE("SG_ - found stack");
+				}
+				return stacks.get(i);
+			}
+		}
+		if(Tools.tracing) {
+			TRACE("SG_ - stack not found");
+		}
+		return null;
+	}
+
+
+	private int getNextToken() {
+		if(Tools.tracing) {
+			TRACE("SG_NextToken() - ");
+		}
+
+		final int ch = currentInputStream.read();
+		updateLineAndColumnInfo(ch);
+		if(ch == -1) {
+			return SGLR.EOF;
+		}
+		return ch;
+	}
+
+	protected void updateLineAndColumnInfo(int ch) {
+		tokensSeen++;
+
+		if (Tools.debugging) {
+			Tools.debug("getNextToken() - ", ch, "(", (char) ch, ")");
+		}
+
+		switch (ch) {
+		case '\n':
+			lineNumber++;
+			columnNumber = 0;
+			break;
+		case '\t':
+			columnNumber = (columnNumber / TAB_SIZE + 1) * TAB_SIZE;
+			break;
+		case -1:
+			break;
+		default:
+			columnNumber++;
+		}
+	}
+
+	@Deprecated
+	public void setFilter(boolean filter) {
+		getDisambiguator().setFilterAny(filter);
+	}
+
+	public void clear() {
+		if (this.acceptingStack != null) {
+			this.acceptingStack.clear();
+		}
+
+		clearActiveStacksDeep();
+		clearForActorDelayedDeep();
+		clearForActorDeep();
+		clearForShifterDeep();
+
+		this.parseTable = null;
+		this.factory = null;
+		this.ambiguityManager = null;
+	}
+
+	private void clearForShifterDeep() {
+		for (final ActionState as : forShifter) {
+			as.clear(true);
+		}
+		clearForShifter();
+	}
+
+	private void clearForShifter() {
+		forShifter.clear();
+	}
+
+	private void clearForActor() {
+		forActor.clear();
+	}
+
+	private void clearForActorDeep() {
+		for (final Frame frame : forActor) {
+			frame.clear();
+		}
+		clearForActor();
+	}
+
+	private void clearForActorDelayedDeep() {
+		for (final Frame frame : forActorDelayed) {
+			frame.clear();
+
+		}
+		clearForActorDelayed();
+	}
+
+	private void clearForActorDelayed() {
+		forActorDelayed.clear(true);
+	}
+
+	private void clearActiveStacksDeep() {
+		for (final Frame frame : activeStacks) {
+			frame.clear();
+		}
+		clearActiveStacks();
+	}
+
+	private void clearActiveStacks() {
+		activeStacks.clear(true);
+	}
+
+	ParseTable getParseTable() {
+		return parseTable;
+	}
+
+	AmbiguityManager getAmbiguityManager() {
+		return ambiguityManager;
+	}
+
+	public Disambiguator getDisambiguator() {
+		return disambiguator;
+	}
+
+	public void setDisambiguator(Disambiguator disambiguator) {
+		this.disambiguator = disambiguator;
+	}
+
+	public ATermFactory getFactory() {
+		return factory;
+	}
+
+	public int getReductionCount() {
+		return reductionCount;
+	}
+
+	public int getRejectionCount() {
+		return rejectCount;
+	}
+
+	@Deprecated
+	public static void setWorkAroundMultipleLookahead(boolean value) {
+		WORK_AROUND_MULTIPLE_LOOKAHEAD = value;
+	}
+
+
+
+
+
+	////////////////////////////////////////////////////// Log functions ///////////////////////////////////////////////////////////////////////////////
+
+	private static int traceCallCount = 0;
+
+	static void TRACE(String string) {
+		System.err.println("[" + traceCallCount + "] " + string);
+		traceCallCount++;
+	}
+
+	private String dumpActiveStacks() {
+		final StringBuffer sb = new StringBuffer();
+		boolean first = true;
+		if (activeStacks == null) {
+			sb.append(" GSS unitialized");
+		} else {
+			sb.append("{").append(activeStacks.size()).append("} ");
+			for (final Frame f : activeStacks) {
+				if (!first) {
+					sb.append(", ");
+				}
+				sb.append(f.dumpStack());
+				first = false;
+			}
+		}
+		return sb.toString();
+	}
+
+
+	private void logParseResult(Link s) {
+		if (isDebugging()) {
+			Tools.debug("internal parse tree:\n", s.label);
+		}
+
+		if(Tools.tracing) {
+			TRACE("SG_ - internal tree: " + s.label);
+		}
+
+		if (Tools.measuring) {
+			final Measures m = new Measures();
+			//Tools.debug("Time (ms): " + (System.currentTimeMillis()-startTime));
+			m.setTime(System.currentTimeMillis() - startTime);
+			//Tools.debug("Red.: " + reductionCount);
+			m.setReductionCount(reductionCount);
+			//Tools.debug("Nodes: " + Frame.framesCreated);
+			m.setFramesCreated(Frame.framesCreated);
+			//Tools.debug("Links: " + Link.linksCreated);
+			m.setLinkedCreated(Link.linksCreated);
+			//Tools.debug("avoids: " + s.avoidCount);
+			m.setAvoidCount(s.recoverCount);
+			//Tools.debug("Total Time: " + parseTime);
+			m.setParseTime(parseTime);
+			//Tools.debug("Total Count: " + parseCount);
+			Measures.setParseCount(++parseCount);
+			//Tools.debug("Average Time: " + (int)parseTime / parseCount);
+			m.setAverageParseTime((int)parseTime / parseCount);
+			m.setRecoverTime(-1);
+			Tools.setMeasures(m);
+		}
+	}
+
+
+	private void logBeforeParsing() {
+		if(Tools.tracing) {
+			TRACE("SG_Parse() - ");
+		}
+
+		if (Tools.debugging) {
+			Tools.debug("parse() - ", dumpActiveStacks());
+		}
+	}
+
+	private void logAfterParsing()
+	throws BadTokenException, TokenExpectedException {
+		if (isLogging()) {
+			Tools.logger("Number of lines: ", lineNumber);
+			Tools.logger("Maximum ", maxBranches, " parse branches reached at token ",
+					logCharify(maxToken), ", line ", maxLine, ", column ", maxColumn,
+					" (token #", maxTokenNumber, ")");
+
+			final long elapsed = System.currentTimeMillis() - startTime;
+			Tools.logger("Parse time: " + elapsed / 1000.0f + "s");
+		}
+
+		if (isDebugging()) {
+			Tools.debug("Parsing complete: all tokens read");
+		}
+
+		if (acceptingStack == null) {
+			final BadTokenException bad = createBadTokenException();
+			if (collectedErrors.isEmpty()) {
+				throw bad;
+			} else {
+				collectedErrors.add(bad);
+				throw new MultiBadTokenException(this, collectedErrors);
+			}
+		}
+
+
+		if (isDebugging()) {
+			Tools.debug("Accepting stack exists");
+		}
+	}
+
+	private void logCurrentToken() {
+		if (isLogging()) {
+			Tools.logger("Current token (#", tokensSeen, "): ", logCharify(currentToken));
+		}
+	}
+
+	private void logAfterShifter() {
+		if(Tools.tracing) {
+			TRACE("SG_DiscardShiftPairs() - ");
+			TRACE_ActiveStacks();
+		}
+	}
+
+	private void logBeforeShifter() {
+		if(Tools.tracing) {
+			TRACE("SG_Shifter() - ");
+			TRACE_ActiveStacks();
+		}
+
+		if (Tools.logging) {
+			Tools.logger("#", tokensSeen, ": shifting ", forShifter.size(), " parser(s) -- token ",
+					logCharify(currentToken), ", line ", lineNumber, ", column ", columnNumber);
+		}
+
+		if (Tools.debugging) {
+			Tools.debug("shifter() - " + dumpActiveStacks());
+
+			Tools.debug(" token   : " + currentToken);
+			Tools.debug(" parsers : " + forShifter.size());
+		}
+	}
+
+	private void logBeforeParseCharacter() {
+		if(Tools.tracing) {
+			TRACE("SG_ParseToken() - ");
+		}
+
+		if (Tools.debugging) {
+			Tools.debug("parseCharacter() - " + dumpActiveStacks());
+			Tools.debug(" # active stacks : " + activeStacks.size());
+		}
+
+		/* forActor = *///computeStackOfStacks(activeStacks);
+
+		if (Tools.debugging) {
+			Tools.debug(" # for actor     : " + forActor.size());
+		}
+	}
+
+	private String logCharify(int currentToken) {
+		switch (currentToken) {
+		case 32:
+			return "\\32";
+		case SGLR.EOF:
+			return "EOF";
+		case '\n':
+			return "\\n";
+		case 0:
+			return "\\0";
+		default:
+			return "" + (char) currentToken;
+		}
+	}
+
+	private void logBeforeActor(Frame st, State s) {
+		List<ActionItem> actionItems = null;
+
+		if (Tools.debugging || Tools.tracing) {
+			actionItems = s.getActionItems(currentToken);
+		}
+
+		if(Tools.tracing) {
+			TRACE("SG_Actor() - " + st.state.stateNumber);
+			TRACE_ActiveStacks();
+		}
+
+		if (Tools.debugging) {
+			Tools.debug("actor() - ", dumpActiveStacks());
+		}
+
+		if (Tools.debugging) {
+			Tools.debug(" state   : ", s.stateNumber);
+			Tools.debug(" token   : ", currentToken);
+		}
+
+		if (Tools.debugging) {
+			Tools.debug(" actions : ", actionItems);
+		}
+
+		if(Tools.tracing) {
+			TRACE("SG_ - actions: " + actionItems.size());
+		}
+	}
+
+	private void logAfterDoReductions() {
+		if (Tools.debugging) {
+			Tools.debug("<doReductions() - " + dumpActiveStacks());
+		}
+
+		if(Tools.tracing) {
+			TRACE("SG_ - doreductions done");
+		}
+	}
+
+	private void logReductionPath(Production prod, Path path, Frame st0, State next) {
+		if (Tools.debugging) {
+			Tools.debug(" path: ", path);
+			Tools.debug(st0.state);
+		}
+
+		if (Tools.logging) {
+			Tools.logger("Goto(", st0.peek().stateNumber, ",", prod.label + ") == ",
+					next.stateNumber);
+		}
+	}
+
+
+	private void logBeforeDoReductions(Frame st, Production prod,
+			final int pathsCount) {
+		if(Tools.tracing) {
+			TRACE("SG_DoReductions() - " + st.state.stateNumber);
+		}
+
+		if (Tools.debugging) {
+			Tools.debug("doReductions() - " + dumpActiveStacks());
+			logReductionInfo(st, prod);
+			Tools.debug(" paths : " + pathsCount);
+		}
+	}
+
+	private void logBeforeLimitedReductions(Frame st, Production prod, Link l,
+			PooledPathList paths) {
+		if(Tools.tracing) {
+			TRACE("SG_ - back in reducer ");
+			TRACE_ActiveStacks();
+			TRACE("SG_DoLimitedReductions() - " + st.state.stateNumber + ", " + l.parent.state.stateNumber);
+		}
+
+		if (Tools.debugging) {
+			Tools.debug("doLimitedReductions() - ", dumpActiveStacks());
+			logReductionInfo(st, prod);
+			Tools.debug(Arrays.asList(paths));
+		}
+	}
+
+	private void logReductionInfo(Frame st, Production prod) {
+		Tools.debug(" state : ", st.peek().stateNumber);
+		Tools.debug(" token : ", currentToken);
+		Tools.debug(" label : ", prod.label);
+		Tools.debug(" arity : ", prod.arity);
+		Tools.debug(" stack : ", st.dumpStack());
+	}
+
+	private void logAddedLink(Frame st0, Frame st1, Link nl) {
+		if (Tools.debugging) {
+			Tools.debug(" added link ", nl, " from ", st1.state.stateNumber, " to ",
+					st0.state.stateNumber);
+		}
+
+		if(Tools.tracing) {
+			TRACE_ActiveStacks();
+		}
+	}
+
+	private void logBeforeReducer(State s, Production prod, int length) {
+		if(Tools.tracing) {
+			TRACE("SG_Reducer() - " + s.stateNumber + ", " + length + ", " + prod.label);
+			TRACE_ActiveStacks();
+		}
+
+		if (Tools.logging) {
+			Tools.logger("Reducing; state ", s.stateNumber, ", token: ", logCharify(currentToken),
+					", production: ", prod.label);
+		}
+
+		if (Tools.debugging) {
+			Tools.debug("reducer() - ", dumpActiveStacks());
+
+			Tools.debug(" state      : ", s.stateNumber);
+			Tools.debug(" token      : ", logCharify(currentToken) + " (" + currentToken + ")");
+			Tools.debug(" production : ", prod.label);
+		}
+	}
+
+	private void TRACE_ActiveStacks() {
+		TRACE("SG_ - active stacks: " + activeStacks.size());
+		TRACE("SG_ - for_actor stacks: " + forActor.size());
+		TRACE("SG_ - for_actor_delayed stacks: " + forActorDelayed.size());
+	}
+
+
+	private void logAmbiguity(Frame st0, Production prod, Frame st1, Link nl) {
+		if (Tools.logging) {
+			Tools.logger("Ambiguity: direct link ", st0.state.stateNumber, " -> ",
+					st1.state.stateNumber, " ", (prod.isRejectProduction() ? "{reject}" : ""));
+			if (nl.label instanceof ParseNode) {
+				Tools.logger("nl is ", nl.isRejected() ? "{reject}" : "", " for ",
+						((ParseNode) nl.label).label);
+			}
+		}
+
+		if (Tools.debugging) {
+			Tools.debug("createAmbiguityCluster - ", tokensSeen - nl.getLength() - 1, "/",
+					nl.getLength());
+		}
+	}
 
 	public void setBuildParseTree(boolean buildParseTree) {
 		this.buildParseTree = buildParseTree;

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/server/RemoteParseTableServiceImpl.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/server/RemoteParseTableServiceImpl.java	Thu Dec 16 15:03:43 2010	(r21533)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/server/RemoteParseTableServiceImpl.java	Thu Dec 16 15:03:49 2010	(r21534)
@@ -15,34 +15,33 @@
 public class RemoteParseTableServiceImpl extends RemoteServiceServlet implements RemoteParseTableService {
 
 	public ATerm fetchParseTable(String resourceName) {
-		ATermFactory f = new ATermFactory();
+		final ATermFactory f = new ATermFactory();
 		try {
-			InputStream is = new FileInputStream(resourceName);
+			final InputStream is = new FileInputStream(resourceName);
 			System.out.println("Loading into buffer");
-			char[] buffer = new char[12*1024*1024]; // FIXME 12 MBs should be enough for everyone
+			final char[] buffer = new char[12*1024*1024]; // FIXME 12 MBs should be enough for everyone
 			for(int i = 0; i < buffer.length; i++) {
-				int ch = is.read();
-				if(ch == -1)
+				final int ch = is.read();
+				if(ch == -1) {
 					break;
+				}
 				buffer[i] = (char)ch;
 			}
 			System.out.println("Loading from buffer");
-			ATerm e = f.parse(new String(buffer));
+			final ATerm e = f.parse(new String(buffer));
 			System.out.println("Loaded term, serializing");
 			return e;
-		} catch(FileNotFoundException e) {
-		} catch(IOException e) {
+		} catch(final FileNotFoundException e) {
+		} catch(final IOException e) {
 		}
 		System.err.println("Failed to load parse table " + resourceName);
 		return null;
 	}
 
-	@Override
 	public ATerm readTermFromFile(String string) {
 		return new ATermFactory().makeInt(0);
 	}
 
-	@Override
 	public String fetchText(String string) {
 		return "abc";
 	}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java	Thu Dec 16 15:03:43 2010	(r21533)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java	Thu Dec 16 15:03:49 2010	(r21534)
@@ -36,8 +36,9 @@
 	@Override
 	public ATerm getChildAt(int index) {
 		ATermList l = this;
-		for(int i = 0; i < index; i++) 
+		for(int i = 0; i < index; i++) {
 			l = l.next;
+		}
 		return l.element;
 	}
 
@@ -64,25 +65,21 @@
 			this.underlying = underlying;
 		}
 
-		@Override
 		public boolean hasNext() {
 			return underlying.element != null;
 		}
 
-		@Override
 		public ATerm next() {
-			ATerm e = underlying.element;
+			final ATerm e = underlying.element;
 			underlying = underlying.next;
 			return e;
 		}
 
-		@Override
 		public void remove() {
 			throw new RuntimeException("Not supported");
 		}
 	}
 
-	@Override
 	public Iterator<ATerm> iterator() {
 		return new ATermListIterator(this);
 	}
@@ -91,14 +88,15 @@
 	protected void toString(int depth, StringBuilder sb) {
 		if(depth == 0) {
 			sb.append("...");
-		} else { 
+		} else {
 			sb.append('[');
 			ATermList l = this;
 			while(l.element != null) {
 				l.element.toString(depth - 1, sb);
 				l = l.next;
-				if(l.element != null)
+				if(l.element != null) {
 					sb.append(",");
+				}
 			}
 			sb.append(']');
 		}
@@ -106,17 +104,21 @@
 
 	@Override
 	public boolean simpleMatch(ATerm t) {
-		if(!(t instanceof ATermList))
+		if(!(t instanceof ATermList)) {
 			return false;
+		}
 		ATermList a = (ATermList)t;
-		ATermList b = (ATermList)t;		
+		ATermList b = (ATermList)t;
 		do {
-			if(a.element == null && b.element == null)
+			if(a.element == null && b.element == null) {
 				return true;
-			if(a.element == null)
+			}
+			if(a.element == null) {
 				return false;
-			if(!a.element.equals(b.element))
+			}
+			if(!a.element.equals(b.element)) {
 				return false;
+			}
 			a = a.next;
 			b = b.next;
 		} while(true);

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/Asfix2TreeBuilder.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/Asfix2TreeBuilder.java	Thu Dec 16 15:03:43 2010	(r21533)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/Asfix2TreeBuilder.java	Thu Dec 16 15:03:49 2010	(r21534)
@@ -13,41 +13,37 @@
 	private final AFun ambAFun;
 	private final AFun parseTreeAFun;
 	private ATermAppl[] labels;
-	
+
 	public Asfix2TreeBuilder() {
-	    applAFun = factory.makeAFun("appl", 2, false);
-	    ambAFun = factory.makeAFun("amb", 1, false);
-	    parseTreeAFun = factory.makeAFun("parsetree", 2, false);
+		applAFun = factory.makeAFun("appl", 2, false);
+		ambAFun = factory.makeAFun("amb", 1, false);
+		parseTreeAFun = factory.makeAFun("parsetree", 2, false);
 	}
 
 	public void initialize(int productionCount, int labelCount) {
 		labels = new ATermAppl[labelCount];
 	}
-	
-	@Override
+
 	public void addLabel(int labelNumber, ATermAppl parseTreeProduction) {
 		labels[labelNumber] = parseTreeProduction;
 	}
 
-	@Override
 	public Object buildNode(int labelNumber, Object[] subtrees) {
 		ATermList ls = factory.makeList();
-		for(int i = subtrees.length - 1; i >= 0; i--)
+		for(int i = subtrees.length - 1; i >= 0; i--) {
 			ls = ls.prepend((ATerm)subtrees[i]);
+		}
 		return factory.makeAppl(applAFun, labels[labelNumber], ls);
 	}
 
-	@Override
 	public Object buildAmb(Object[] alternatives) {
 		return factory.makeAppl(ambAFun, (ATerm[])alternatives);
 	}
 
-	@Override
 	public Object buildProduction(int productionNumber) {
 		return factory.makeInt(productionNumber);
 	}
 
-	@Override
 	public Object buildToplevel(Object node, int ambCount) {
 		return factory.makeAppl(parseTreeAFun, (ATerm)node, factory.makeInt(ambCount));	}
 

From karltk at strategoxt.org  Thu Dec 16 16:03:59 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:03:59 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21535 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt: src/org/spoofax
	src/org/spoofax/jsglr src/org/spoofax/jsglr/client
	src/org/spoofax/jsglr/shared src/org/spoofax/jsglr/shar...
Message-ID: <201012161503.oBGF3xcp027378@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:03:58 2010
New Revision: 21535
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21535&sc=1

Log:
Added imploder and tree builder.

Added:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Asfix2TreeBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/TreeBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/ATermImplodedTreeFactory.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/AstAnnoImploder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/BottomupTreeBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/DummyTokenizer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/IImplodedTreeFactory.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/IToken.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/ITokenStream.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/ITokenizer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/ITreeBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/ImplodedTreeBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/LabelInfo.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/ProductionAttributeReader.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/Token.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/TokenKindManager.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/Tokenizer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/TopdownTreeBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestImplode.java
Deleted:
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/Asfix2TreeBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/TreeBuilder.java
Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/JsglrGWT.gwt.xml
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/AbstractParseNode.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/NotImplementedException.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseAvoid.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParsePrefer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseProductionNode.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseReject.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/Tools.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/AFun.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermAppl.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermFactory.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermInt.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermPlaceholder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermString.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermTuple.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/JsglrGWT.gwt.xml
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/JsglrGWT.gwt.xml	Thu Dec 16 15:03:49 2010	(r21534)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/JsglrGWT.gwt.xml	Thu Dec 16 15:03:58 2010	(r21535)
@@ -8,7 +8,7 @@
   <source path='jsglr/shared'/>
   <source path='client'/>
   <source path='jsglr/tests'/>
-
+<!-- 
   <entry-point class='org.spoofax.client.JSGLREntryPoint'/>
-
+ -->
 </module>

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java	Thu Dec 16 15:03:49 2010	(r21534)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -21,131 +21,134 @@
 import org.spoofax.jsglr.shared.BadTokenException;
 import org.spoofax.jsglr.shared.SGLRException;
 import org.spoofax.jsglr.shared.Tools;
-import org.spoofax.jsglr.shared.terms.ATerm;
 import org.spoofax.jsglr.shared.terms.ATermFactory;
 
 public class Main {
 
-    public static void main(String[] args) throws FileNotFoundException, IOException, InvalidParseTableException {
+	public static void main(String[] args) throws FileNotFoundException, IOException, InvalidParseTableException {
 
-        if(args.length < 2) {
-            usage();
-        }
-
-        String parseTableFile = null;
-        String input = null;
-        String output = null;
-        String startSymbol = null;
-        boolean debugging = false;
-        boolean logging = false;
-        boolean detectCycles = true;
-        boolean filter = true;
-        boolean waitForProfiler = false;
-        boolean timing = false;
-        boolean heuristicFilters = false;
-        boolean buildParseTree = true;
-        int profilingRuns = 0;
-        
-        for(int i=0;i<args.length;i++) {
-            if(args[i].equals("-p")) {
-                parseTableFile = args[++i];
-            } else if(args[i].equals("-i")) {
-                input = args[++i];
-            } else if(args[i].equals("-o")) {
-                output = args[++i];
-            } else if(args[i].equals("-d")) {
-                debugging = true;
-            } else if(args[i].equals("-v")) {
-                logging = true;
-            } else if(args[i].equals("-f")) {
-                filter = false;
-            } else if(args[i].equals("-c")) {
-                detectCycles = false;
-            } else if(args[i].equals("-s")) {
-                startSymbol = args[++i];
-            } else if(args[i].equals("--heuristic-filters")) {
-                heuristicFilters = args[++i].equals("on");
-            } else if(args[i].equals("--wait-for-profiler")) {
-                waitForProfiler = true;
-            } else if(args[i].equals("--profiler-runs")) {
-            	profilingRuns = Integer.parseInt(args[++i]);
-            } else if(args[i].equals("--timing")) {
-            	timing = true;
-            } else if(args[i].equals("--no-tree-build")) {
-            	buildParseTree = false;
-            } else {
-                System.err.println("Unknown option: " + args[i]);
-                System.exit(1);
-            }
-        }
-
-        if(parseTableFile == null)
-            usage();
-        
-        ATermFactory factory = new ATermFactory();
-        long tableLoadingTime = System.currentTimeMillis(); 
-        ParseTable pt = new ParseTable(factory.parseFromString(FileTools.loadFileAsString(parseTableFile)));
-        SGLR sglr = new SGLR(factory, pt);        
-
-        tableLoadingTime = System.currentTimeMillis() - tableLoadingTime;
-
-        Tools.setDebug(debugging);
-        Tools.setLogging(logging);
-        sglr.getDisambiguator().setFilterCycles(detectCycles);
-        sglr.getDisambiguator().setFilterAny(filter);
-        sglr.getDisambiguator().setHeuristicFilters(heuristicFilters);
-        sglr.setBuildParseTree(buildParseTree);
-        
-        if(waitForProfiler) {
-        	System.err.println("Hit enter to start profiling...");
-            System.in.read();
-        }
-
-        for(int i = 0; i < profilingRuns - 1; i++)
-        	parseFile(input, null, sglr, startSymbol);
-        
-        long parsingTime = parseFile(input, output, sglr, startSymbol);
-
-        if(timing) {
-        	System.err.println("Parse table loading time : " + tableLoadingTime + "ms");
-        	System.err.println("Parsing time             : " + parsingTime + "ms");
-        }
-    }
-
-    public static long parseFile(String input, String output, SGLR sglr, String startSymbol)
-            throws FileNotFoundException, IOException {
-        InputStream fis = null;
-        if(input == null)
-            fis = System.in;
-        else
-            fis = new BufferedInputStream(new FileInputStream(input));
-        OutputStream ous = null;
-        if(output != null && !"-".equals(output))
-            ous = new FileOutputStream(output);
-        else 
-            ous = System.out;
-
-        long parsingTime = 0;
-        Object t = null;
-        try {
-        	parsingTime = System.currentTimeMillis();
-            t = sglr.parse(FileTools.loadFileAsString(input), startSymbol);            
-            parsingTime = System.currentTimeMillis() - parsingTime;            
-        } catch(BadTokenException e) {
-            System.err.println("Parsing failed : " + e.getMessage());
-        } catch(SGLRException e) {
-            // Detailed message for other exceptions
-            System.err.println("Parsing failed : " + e);
-        }
-        if(t != null && !"-".equals(output)){            
-            String outputString = t.toString();
-            ous.write(outputString.getBytes());
-        }
-        return parsingTime;
-    }
-
-    private static void usage() {
-        System.out.println("Usage: org.spoofax.jsglr.Main [-f -d -v] -p <parsetable.tbl> -i <inputfile>");
-        System.exit(-1);
-    }
+		if(args.length < 2) {
+			usage();
+		}
+
+		String parseTableFile = null;
+		String input = null;
+		String output = null;
+		String startSymbol = null;
+		boolean debugging = false;
+		boolean logging = false;
+		boolean detectCycles = true;
+		boolean filter = true;
+		boolean waitForProfiler = false;
+		boolean timing = false;
+		boolean heuristicFilters = false;
+		boolean buildParseTree = true;
+		int profilingRuns = 0;
+
+		for(int i=0;i<args.length;i++) {
+			if(args[i].equals("-p")) {
+				parseTableFile = args[++i];
+			} else if(args[i].equals("-i")) {
+				input = args[++i];
+			} else if(args[i].equals("-o")) {
+				output = args[++i];
+			} else if(args[i].equals("-d")) {
+				debugging = true;
+			} else if(args[i].equals("-v")) {
+				logging = true;
+			} else if(args[i].equals("-f")) {
+				filter = false;
+			} else if(args[i].equals("-c")) {
+				detectCycles = false;
+			} else if(args[i].equals("-s")) {
+				startSymbol = args[++i];
+			} else if(args[i].equals("--heuristic-filters")) {
+				heuristicFilters = args[++i].equals("on");
+			} else if(args[i].equals("--wait-for-profiler")) {
+				waitForProfiler = true;
+			} else if(args[i].equals("--profiler-runs")) {
+				profilingRuns = Integer.parseInt(args[++i]);
+			} else if(args[i].equals("--timing")) {
+				timing = true;
+			} else if(args[i].equals("--no-tree-build")) {
+				buildParseTree = false;
+			} else {
+				System.err.println("Unknown option: " + args[i]);
+				System.exit(1);
+			}
+		}
+
+		if(parseTableFile == null) {
+			usage();
+		}
+
+		final ATermFactory factory = new ATermFactory();
+		long tableLoadingTime = System.currentTimeMillis();
+		final ParseTable pt = new ParseTable(factory.parseFromString(FileTools.loadFileAsString(parseTableFile)));
+		final SGLR sglr = new SGLR(factory, pt);
+
+		tableLoadingTime = System.currentTimeMillis() - tableLoadingTime;
+
+		Tools.setDebug(debugging);
+		Tools.setLogging(logging);
+		sglr.getDisambiguator().setFilterCycles(detectCycles);
+		sglr.getDisambiguator().setFilterAny(filter);
+		sglr.getDisambiguator().setHeuristicFilters(heuristicFilters);
+		sglr.setBuildParseTree(buildParseTree);
+
+		if(waitForProfiler) {
+			System.err.println("Hit enter to start profiling...");
+			System.in.read();
+		}
+
+		for(int i = 0; i < profilingRuns - 1; i++) {
+			parseFile(input, null, sglr, startSymbol);
+		}
+
+		final long parsingTime = parseFile(input, output, sglr, startSymbol);
+
+		if(timing) {
+			System.err.println("Parse table loading time : " + tableLoadingTime + "ms");
+			System.err.println("Parsing time             : " + parsingTime + "ms");
+		}
+	}
+
+	public static long parseFile(String input, String output, SGLR sglr, String startSymbol)
+	throws FileNotFoundException, IOException {
+		InputStream fis = null;
+		if(input == null) {
+			fis = System.in;
+		} else {
+			fis = new BufferedInputStream(new FileInputStream(input));
+		}
+		OutputStream ous = null;
+		if(output != null && !"-".equals(output)) {
+			ous = new FileOutputStream(output);
+		} else {
+			ous = System.out;
+		}
+
+		long parsingTime = 0;
+		Object t = null;
+		try {
+			parsingTime = System.currentTimeMillis();
+			t = sglr.parse(FileTools.loadFileAsString(input), startSymbol);
+			parsingTime = System.currentTimeMillis() - parsingTime;
+		} catch(final BadTokenException e) {
+			System.err.println("Parsing failed : " + e.getMessage());
+		} catch(final SGLRException e) {
+			// Detailed message for other exceptions
+			System.err.println("Parsing failed : " + e);
+		}
+		if(t != null && !"-".equals(output)){
+			final String outputString = t.toString();
+			ous.write(outputString.getBytes());
+		}
+		return parsingTime;
+	}
+
+	private static void usage() {
+		System.out.println("Usage: org.spoofax.jsglr.Main [-f -d -v] -p <parsetable.tbl> -i <inputfile>");
+		System.exit(-1);
+	}
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/AbstractParseNode.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/AbstractParseNode.java	Thu Dec 16 15:03:49 2010	(r21534)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/AbstractParseNode.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -12,7 +12,9 @@
 
     protected static final int NO_HASH_CODE = 0;
 
-    public abstract Object toParseTree(ParseTable pt);
+    public abstract Object toTreeBottomup(BottomupTreeBuilder builder);
+    
+    public abstract Object toTreeTopdown(TopdownTreeBuilder builder);
 
     @Override
 	abstract public boolean equals(Object obj);

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java	Thu Dec 16 15:03:49 2010	(r21534)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -10,87 +10,92 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import org.spoofax.jsglr.shared.terms.ATerm;
-import org.spoofax.jsglr.shared.terms.ATermFactory;
-import org.spoofax.jsglr.shared.terms.ATermList;
-
 
 public class Amb extends AbstractParseNode {
 
-    private final AbstractParseNode[] alternatives;
+	private final AbstractParseNode[] alternatives;
 
-    private int cachedHashCode = NO_HASH_CODE;
+	private int cachedHashCode = NO_HASH_CODE;
 
-    Amb(AbstractParseNode left, AbstractParseNode right) {
-        alternatives = new AbstractParseNode[2];
-        alternatives[0] = left;
-        alternatives[1] = right;
-    }
+	Amb(AbstractParseNode left, AbstractParseNode right) {
+		alternatives = new AbstractParseNode[2];
+		alternatives[0] = left;
+		alternatives[1] = right;
+	}
+
+	public Amb(AbstractParseNode[] alternatives) {
+		this.alternatives = alternatives;
+	}
 
-    public Amb(AbstractParseNode[] alternatives) {
-        this.alternatives = alternatives;
+	@Override
+	public Object toTreeBottomup(BottomupTreeBuilder builder) {
+    	ArrayList<Object> collect = new ArrayList<Object>();
+    	addToTree(builder, collect);
+    	return builder.buildAmb(collect.toArray(new Object[collect.size()]));
     }
-
+    
     @Override
-	public Object toParseTree(ParseTable pt) {
-    	ArrayList<Object> collect = new ArrayList<Object>();
-    	addToParseTree(pt, collect);
-    	return pt.getTreeBuilder().buildAmb(collect.toArray(new Object[collect.size()]));
+    public Object toTreeTopdown(TopdownTreeBuilder builder) {
+    	return builder.buildTreeAmb(this);
     }
     
-    private void addToParseTree(ParseTable pt, List<Object> collect) {
+    private void addToTree(BottomupTreeBuilder builder, List<Object> collect) {
     	for (int i = alternatives.length - 1; i >= 0; i--) {
     		AbstractParseNode alt = alternatives[i];
     		if (alt instanceof Amb) {
-    			((Amb) alt).addToParseTree(pt, collect);
+    			((Amb) alt).addToTree(builder, collect);
     		} else {
-    			collect.add(alt.toParseTree(pt));
+    			collect.add(alt.toTreeBottomup(builder));
     		}
     	}
     }
 
-
-    @Override
-    public String toString() {
-        return "amb(" + alternatives + ")";
-    }
-
-    public boolean hasAmbiguity(AbstractParseNode newNode) {
-        throw new NotImplementedException();
-    }
-
-    public AbstractParseNode[] getAlternatives() {
-        return alternatives;
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-        if(!(obj instanceof Amb))
-            return false;
-        if (obj == this)
-            return true;
-        Amb o = (Amb)obj;
-        if(o.alternatives.length != alternatives.length
-                || o.hashCode() != hashCode())
-            return false;
-        for(int i = 0; i < alternatives.length; i++)
-            if(!alternatives[i].equals(o.alternatives[i]))
-                return false;
-        return true;
-    }
-
-    @Override
-    public int hashCode() {
-        if (cachedHashCode != NO_HASH_CODE) {
-            assert cachedHashCode == alternatives.hashCode();
-            return cachedHashCode;
-        }
-        int result = cachedHashCode = alternatives.hashCode();
-        return result;
-    }
-
-    @Override
-    public String toStringShallow() {
-        return "Amb";
-    }
+	@Override
+	public String toString() {
+		return "amb(" + alternatives + ")";
+	}
+
+	public boolean hasAmbiguity(AbstractParseNode newNode) {
+		throw new NotImplementedException();
+	}
+
+	public AbstractParseNode[] getAlternatives() {
+		return alternatives;
+	}
+
+	@Override
+	public boolean equals(Object obj) {
+		if(!(obj instanceof Amb)) {
+			return false;
+		}
+		if (obj == this) {
+			return true;
+		}
+		final Amb o = (Amb)obj;
+		if(o.alternatives.length != alternatives.length
+				|| o.hashCode() != hashCode()) {
+			return false;
+		}
+		for(int i = 0; i < alternatives.length; i++) {
+			if(!alternatives[i].equals(o.alternatives[i])) {
+				return false;
+			}
+		}
+		return true;
+	}
+
+	@Override
+	public int hashCode() {
+		if (cachedHashCode != NO_HASH_CODE) {
+			assert cachedHashCode == alternatives.hashCode();
+			return cachedHashCode;
+		}
+		final int result = cachedHashCode = alternatives.hashCode();
+		return result;
+	}
+
+	@Override
+	public String toStringShallow() {
+		return "Amb";
+	}
 }

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Asfix2TreeBuilder.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Asfix2TreeBuilder.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -0,0 +1,56 @@
+package org.spoofax.jsglr.client;
+
+import org.spoofax.jsglr.shared.terms.AFun;
+import org.spoofax.jsglr.shared.terms.ATerm;
+import org.spoofax.jsglr.shared.terms.ATermAppl;
+import org.spoofax.jsglr.shared.terms.ATermFactory;
+import org.spoofax.jsglr.shared.terms.ATermList;
+
+public class Asfix2TreeBuilder extends BottomupTreeBuilder {
+
+	private final ATermFactory factory = new ATermFactory();
+	private final AFun applAFun;
+	private final AFun ambAFun;
+	private final AFun parseTreeAFun;
+	private ATermAppl[] labels;
+	private int labelStart;
+
+	public Asfix2TreeBuilder() {
+		applAFun = factory.makeAFun("appl", 2, false);
+		ambAFun = factory.makeAFun("amb", 1, false);
+		parseTreeAFun = factory.makeAFun("parsetree", 2, false);
+	}
+
+	public void initialize(ParseTable table, int productionCount, int labelStart, int labelCount) {
+		labels = new ATermAppl[labelCount - labelStart];
+		this.labelStart = labelStart;
+	}
+
+	public void initializeLabel(int labelNumber, ATermAppl parseTreeProduction) {
+		labels[labelNumber - labelStart] = parseTreeProduction;
+	}
+
+	public ATerm buildNode(int labelNumber, Object[] subtrees) {
+		ATermList ls = factory.makeList();
+		for(int i = subtrees.length - 1; i >= 0; i--) {
+			ls = ls.prepend((ATerm)subtrees[i]);
+		}
+		return factory.makeAppl(applAFun, labels[labelNumber - labelStart], ls);
+	}
+
+	public ATerm buildAmb(Object[] alternatives) {
+		return factory.makeAppl(ambAFun, (ATerm[])alternatives);
+	}
+
+	public ATerm buildProduction(int productionNumber) {
+		return factory.makeInt(productionNumber);
+	}
+
+	public ATerm buildTreeTop(Object node, int ambCount) {
+		return factory.makeAppl(parseTreeAFun, (ATerm)node, factory.makeInt(ambCount));
+	}
+
+	public ITokenizer getTokenizer() {
+		return null;
+	}
+}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java	Thu Dec 16 15:03:49 2010	(r21534)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -12,7 +12,6 @@
 
 import org.spoofax.jsglr.shared.SGLRException;
 import org.spoofax.jsglr.shared.Tools;
-import org.spoofax.jsglr.shared.terms.AFun;
 import org.spoofax.jsglr.shared.terms.ATerm;
 import org.spoofax.jsglr.shared.terms.ParseError;
 
@@ -22,559 +21,568 @@
  */
 public class Disambiguator {
 
-    private static final int FILTER_DRAW = 1;
+	private static final int FILTER_DRAW = 1;
 
-    private static final int FILTER_LEFT_WINS = 2;
+	private static final int FILTER_LEFT_WINS = 2;
 
-    private static final int FILTER_RIGHT_WINS = 3;
+	private static final int FILTER_RIGHT_WINS = 3;
 
-    private boolean filterAny;
+	private boolean filterAny;
 
-    private boolean filterCycles;
+	private boolean filterCycles;
 
-    private boolean filterDirectPreference;
+	private boolean filterDirectPreference;
 
-    private boolean filterPreferenceCount;
+	private boolean filterPreferenceCount;
 
-    private boolean filterInjectionCount;
+	private boolean filterInjectionCount;
 
-    private boolean filterTopSort;
+	private boolean filterTopSort;
 
-    private boolean filterReject;
+	private boolean filterReject;
 
-    private boolean filterAssociativity;
+	private boolean filterAssociativity;
 
-    private boolean filterPriorities;
+	private boolean filterPriorities;
 
-    private boolean filterStrict;
+	private boolean filterStrict;
 
-    // Current parser state
+	// Current parser state
 
-    private AmbiguityManager ambiguityManager;
+	private AmbiguityManager ambiguityManager;
 
-    private SGLR parser;
+	private SGLR parser;
 
-    private ParseTable parseTable;
+	private ParseTable parseTable;
 
-    // private Map<AmbKey, IParseNode> resolvedTable = new HashMap<AmbKey, IParseNode>();
+	// private Map<AmbKey, IParseNode> resolvedTable = new HashMap<AmbKey, IParseNode>();
 
-    /**
-     * Sets whether any filter should be applied at all (excluding the top sort filter).
-     */
-    public final void setFilterAny(boolean filterAny) {
-        this.filterAny = filterAny;
-    }
+	/**
+	 * Sets whether any filter should be applied at all (excluding the top sort filter).
+	 */
+	public final void setFilterAny(boolean filterAny) {
+		this.filterAny = filterAny;
+	}
 
-    public final void setFilterDirectPreference(boolean filterDirectPreference) {
-        this.filterDirectPreference = filterDirectPreference;
-    }
+	public final void setFilterDirectPreference(boolean filterDirectPreference) {
+		this.filterDirectPreference = filterDirectPreference;
+	}
 
-    public boolean getFilterDirectPreference() {
-        return filterDirectPreference;
-    }
+	public boolean getFilterDirectPreference() {
+		return filterDirectPreference;
+	}
 
-    /**
-     * For preference count filtering, see {@link #setFilterPreferenceCount(boolean)}.
-     */
-    @Deprecated
-    public final void setFilterIndirectPreference(boolean filterIndirectPreference) {
-        throw new UnsupportedOperationException();
-    }
+	/**
+	 * For preference count filtering, see {@link #setFilterPreferenceCount(boolean)}.
+	 */
+	@Deprecated
+	public final void setFilterIndirectPreference(boolean filterIndirectPreference) {
+		throw new UnsupportedOperationException();
+	}
 
-    /**
-     * For preference count filtering, see {@link #getFilterPreferenceCount()}.
-     */
-    @Deprecated
-    public boolean getFilterIndirectPreference() {
-        throw new UnsupportedOperationException();
-    }
+	/**
+	 * For preference count filtering, see {@link #getFilterPreferenceCount()}.
+	 */
+	@Deprecated
+	public boolean getFilterIndirectPreference() {
+		throw new UnsupportedOperationException();
+	}
 
-    public final void setFilterInjectionCount(boolean filterInjectionCount) {
-        this.filterInjectionCount = filterInjectionCount;
-    }
+	public final void setFilterInjectionCount(boolean filterInjectionCount) {
+		this.filterInjectionCount = filterInjectionCount;
+	}
 
-    public boolean getFilterInjectionCount() {
-        return filterInjectionCount;
-    }
+	public boolean getFilterInjectionCount() {
+		return filterInjectionCount;
+	}
 
-    public final void setFilterPreferenceCount(boolean filterPreferenceCount) {
-        this.filterPreferenceCount = filterPreferenceCount;
-    }
+	public final void setFilterPreferenceCount(boolean filterPreferenceCount) {
+		this.filterPreferenceCount = filterPreferenceCount;
+	}
 
-    public boolean getFilterPreferenceCount() {
-        return filterPreferenceCount;
-    }
+	public boolean getFilterPreferenceCount() {
+		return filterPreferenceCount;
+	}
 
-    public final void setFilterTopSort(boolean filterTopSort) {
-        this.filterTopSort = filterTopSort;
-    }
+	public final void setFilterTopSort(boolean filterTopSort) {
+		this.filterTopSort = filterTopSort;
+	}
 
-    public boolean getFilterTopSort() {
-        return filterTopSort;
-    }
+	public boolean getFilterTopSort() {
+		return filterTopSort;
+	}
 
-    public void setFilterCycles(boolean filterCycles) {
-        this.filterCycles = filterCycles;
-    }
+	public void setFilterCycles(boolean filterCycles) {
+		this.filterCycles = filterCycles;
+	}
 
-    public boolean isFilterCycles() {
-        return filterCycles;
-    }
+	public boolean isFilterCycles() {
+		return filterCycles;
+	}
 
-    public void setFilterAssociativity(boolean filterAssociativity) {
-        this.filterAssociativity = filterAssociativity;
-    }
+	public void setFilterAssociativity(boolean filterAssociativity) {
+		this.filterAssociativity = filterAssociativity;
+	}
 
-    public boolean getFilterAssociativity() {
-        return filterAssociativity;
-    }
+	public boolean getFilterAssociativity() {
+		return filterAssociativity;
+	}
 
-    public void setFilterPriorities(boolean filterPriorities) {
-        this.filterPriorities = filterPriorities;
-    }
+	public void setFilterPriorities(boolean filterPriorities) {
+		this.filterPriorities = filterPriorities;
+	}
 
-    public boolean getFilterPriorities() {
-        return filterPriorities;
-    }
+	public boolean getFilterPriorities() {
+		return filterPriorities;
+	}
 
-    /**
-     * Sets whether to enable strict filtering, triggering a
-     * FilterException when the priorities filter encounters
-     * an unfiltered ambiguity.
-     */
-    public void setFilterStrict(boolean filterStrict) {
-        this.filterStrict = filterStrict;
-    }
+	/**
+	 * Sets whether to enable strict filtering, triggering a
+	 * FilterException when the priorities filter encounters
+	 * an unfiltered ambiguity.
+	 */
+	public void setFilterStrict(boolean filterStrict) {
+		this.filterStrict = filterStrict;
+	}
 
-    public boolean getFilterStrict() {
-        return filterStrict;
-    }
+	public boolean getFilterStrict() {
+		return filterStrict;
+	}
 
-    public final void setHeuristicFilters(boolean heuristicFilters) {
-        setFilterPreferenceCount(heuristicFilters);
-        setFilterInjectionCount(heuristicFilters);
-    }
+	public final void setHeuristicFilters(boolean heuristicFilters) {
+		setFilterPreferenceCount(heuristicFilters);
+		setFilterInjectionCount(heuristicFilters);
+	}
 
-    public void setFilterReject(boolean filterReject) {
-        this.filterReject = filterReject;
-    }
+	public void setFilterReject(boolean filterReject) {
+		this.filterReject = filterReject;
+	}
 
-    public boolean getFilterReject() {
-        return filterReject;
-    }
+	public boolean getFilterReject() {
+		return filterReject;
+	}
 
-    public final void setDefaultFilters() {
-        filterAny = true;
-        filterCycles = false; // TODO: filterCycles; enable by default
-        filterDirectPreference = true;
-        filterPreferenceCount = false;
-        filterInjectionCount = false;
-        filterTopSort = true;
-        filterReject = true;
-        filterAssociativity = true;
-        filterPriorities = true;
-        filterStrict = false; // TODO: disable filterStrict hack
-    }
+	public final void setDefaultFilters() {
+		filterAny = true;
+		filterCycles = false; // TODO: filterCycles; enable by default
+		filterDirectPreference = true;
+		filterPreferenceCount = false;
+		filterInjectionCount = false;
+		filterTopSort = true;
+		filterReject = true;
+		filterAssociativity = true;
+		filterPriorities = true;
+		filterStrict = false; // TODO: disable filterStrict hack
+	}
 
-    public Disambiguator() {
-        setDefaultFilters();
-    }
+	public Disambiguator() {
+		setDefaultFilters();
+	}
 
     public Object applyFilters(SGLR parser, AbstractParseNode root, String sort, int inputLength) throws SGLRException, FilterException {
-        try {
-            if(SGLR.isDebugging()) {
-                Tools.debug("applyFilters()");
-            }
-
-            initializeFromParser(parser);
-
-            AbstractParseNode t = root;
-
-            t = applyTopSortFilter(sort, t);
-
-            if (filterAny) {
-                t = applyCycleDetectFilter(t);
-
-                // SG_FilterTree
-                ambiguityManager.resetClustersVisitedCount();
-                t = filterTree(t, false);
-            }
-
-//            // TODO: Move convertToATerm to SGLR.java and support IStrategoTerms
-            ATerm result = convertToATerm(t);
-            assert Term.asAppl(result).getAFun().getName().equals("parsetree");
-            return result;
-        } catch (RuntimeException e) {
-            throw new FilterException(parser, "Runtime exception when applying filters", e);
+    	AbstractParseNode t = root;
+		if(SGLR.isDebugging()) {
+			Tools.debug("applyFilters()");
+		}
+
+    	try {
+    		try {
+	            if(SGLR.isDebugging()) {
+	                Tools.debug("applyFilters()");
+	            }
+	
+	            initializeFromParser(parser);
+	            t = applyTopSortFilter(sort, t);
+	
+	            if (filterAny) {
+	                t = applyCycleDetectFilter(t);
+	
+	                // SG_FilterTree
+	                ambiguityManager.resetClustersVisitedCount();
+	                t = filterTree(t, false);
+	            }
+	        } catch (RuntimeException e) {
+	            throw new FilterException(parser, "Runtime exception when applying filters", e);
+	        }
+
+	        return yieldTreeTop(t);
+        
         } finally {
             initializeFromParser(null);
         }
     }
 
-    private void initializeFromParser(SGLR parser) {
-        if (parser == null) {
-            this.parser = null;
-            parseTable = null;
-            ambiguityManager = null;
-        } else {
-            this.parser = parser;
-            parseTable = parser.getParseTable();
-            ambiguityManager = parser.getAmbiguityManager();
-        }
-    }
-
-    private void logStatus() {
-        Tools.logger("Number of rejects: ", parser.getRejectCount());
-        Tools.logger("Number of reductions: ", parser.getReductionCount());
-        Tools.logger("Number of ambiguities: ", ambiguityManager.getMaxNumberOfAmbiguities());
-        Tools.logger("Number of calls to Amb: ", ambiguityManager.getAmbiguityCallsCount());
-        Tools.logger("Count Eagerness Comparisons: ", ambiguityManager.getEagernessComparisonCount(), " / ", ambiguityManager.getEagernessSucceededCount());
-        Tools.logger("Number of Injection Counts: ", ambiguityManager.getInjectionCount());
-    }
+	private void initializeFromParser(SGLR parser) {
+		if (parser == null) {
+			this.parser = null;
+			parseTable = null;
+			ambiguityManager = null;
+		} else {
+			this.parser = parser;
+			parseTable = parser.getParseTable();
+			ambiguityManager = parser.getAmbiguityManager();
+		}
+	}
+
+	private void logStatus() {
+		Tools.logger("Number of rejects: ", parser.getRejectCount());
+		Tools.logger("Number of reductions: ", parser.getReductionCount());
+		Tools.logger("Number of ambiguities: ", ambiguityManager.getMaxNumberOfAmbiguities());
+		Tools.logger("Number of calls to Amb: ", ambiguityManager.getAmbiguityCallsCount());
+		Tools.logger("Count Eagerness Comparisons: ", ambiguityManager.getEagernessComparisonCount(), " / ", ambiguityManager.getEagernessSucceededCount());
+		Tools.logger("Number of Injection Counts: ", ambiguityManager.getInjectionCount());
+	}
 
     private Object yieldTree(AbstractParseNode t) {
-        return t.toParseTree(parser.getParseTable());
+        return parseTable.getTreeBuilder().buildTree(t);
     }
 
-    private ATerm convertToATerm(AbstractParseNode t) {
+    private Object yieldTreeTop(AbstractParseNode t) {
 
-        if (SGLR.isDebugging()) {
-            Tools.debug("convertToATerm: ", t);
-        }
+		if (SGLR.isDebugging()) {
+			Tools.debug("convertToATerm: ", t);
+		}
 
-        ambiguityManager.resetAmbiguityCount();
-        Object r = yieldTree(t);
+		ambiguityManager.resetAmbiguityCount();
+		final Object r = yieldTree(t);
 
-        logStatus();
+		logStatus();
 
         int ambCount = ambiguityManager.getAmbiguitiesCount();
         if (SGLR.isDebugging()) {
             Tools.debug("yield: ", r);
         }
         
-        return (ATerm)parser.getParseTable().getTreeBuilder().buildToplevel(r, ambCount);
-    }
-
-    private AbstractParseNode applyCycleDetectFilter(AbstractParseNode t) throws FilterException {
-
-        if (SGLR.isDebugging()) {
-            Tools.debug("applyCycleDetectFilter() - ", t);
-        }
-
-        if (filterCycles) {
-            if (ambiguityManager.getMaxNumberOfAmbiguities() > 0) {
-                if (isCyclicTerm(t)) {
-                    throw new FilterException(parser, "Term is cyclic");
-                }
-            }
-        }
-
-        return t;
-    }
-
-    private ATerm getProduction(AbstractParseNode t) {
-        if (t instanceof ParseNode) {
-            return parseTable.getProduction(((ParseNode) t).getLabel());
-        } else {
-            return parseTable.getProduction(((ParseProductionNode) t).getProduction());
-        }
-    }
-
-    private AbstractParseNode applyTopSortFilter(String sort, AbstractParseNode t) throws SGLRException {
-
-        if (SGLR.isDebugging()) {
-            Tools.debug("applyTopSortFilter() - ", t);
-        }
-
-        if (sort != null && filterTopSort) {
-            t = selectOnTopSort(t, sort);
-            if (t == null)
-                throw new StartSymbolException(parser, "Desired start symbol not found: " + sort);
-        }
-
-        return t;
-    }
-
-    private boolean matchProdOnTopSort(ATerm prod, String sort) throws FilterException {
-        try {
-            sort = sort.replaceAll("\"", "");
-            return prod.match("prod([cf(opt(layout)),cf(sort(\"" + sort + "\")),cf(opt(layout))], sort(\"<START>\"),no-attrs)") != null
-                || prod.match("prod([cf(sort(\"" + sort + "\"))], sort(\"<START>\"),no-attrs)") != null
-                || prod.match("prod([lex(sort(\"" + sort + "\"))], sort(\"<START>\"),no-attrs)") != null
-                || prod.match("prod([sort(\"" + sort + "\")], sort(\"<START>\"),no-attrs)") != null;
-        } catch (ParseError e) {
-            throw new FilterException(parser, "Could not select desired top sort: " + sort, e);
-        }
-    }
-
-    private AbstractParseNode selectOnTopSort(AbstractParseNode t, String sort) throws FilterException {
-        List<AbstractParseNode> results = new ArrayList<AbstractParseNode>();
-
-        if (t instanceof Amb) {
-            addTopSortAlternatives(t, sort, results);
-
-            switch (results.size()) {
-                case 0: return null;
-                case 1: return results.get(0);
-                default: return new Amb(results.toArray(new AbstractParseNode[results.size()]));
-            }
-        } else {
-            ATerm prod = getProduction(t);
-            return matchProdOnTopSort(prod, sort) ? t : null;
-        }
-      }
-
-    private void addTopSortAlternatives(AbstractParseNode t, String sort, List<AbstractParseNode> results) throws FilterException {
-        for(AbstractParseNode amb : ((Amb) t).getAlternatives()) {
-            if (amb instanceof Amb) {
-                addTopSortAlternatives(amb, sort, results);
-            } else {
-                ATerm prod = getProduction(amb);
-                if (matchProdOnTopSort(prod, sort))
-                    results.add(amb);
-            }
-        }
-    }
-
-    private AbstractParseNode filterTree(AbstractParseNode t, boolean inAmbiguityCluster) throws FilterException {
-        // SG_FilterTreeRecursive
-        if (SGLR.isDebugging()) {
-            Tools.debug("filterTree(node)    - ", t);
-        }
-
-        if (t instanceof Amb) {
-            if (!inAmbiguityCluster) {
-                // (some cycle stuff should be done here)
-                AbstractParseNode[] ambs = ((Amb)t).getAlternatives();
-                t = filterAmbiguities(ambs);
-            } else {
-            	// FIXME: hasRejectProd(Amb) can never succeed?
-                if (filterReject && parseTable.hasRejects() && hasRejectProd(t)) {
-                    return null;
-                }
-                AbstractParseNode[] ambs = ((Amb) t).getAlternatives();
-                return filterAmbiguities(ambs);
-
-            }
-        } else if(t instanceof ParseNode) {
-            ParseNode node = (ParseNode) t;
-            AbstractParseNode[] args = node.kids;
-            AbstractParseNode[] newArgs = filterTree(args, false);
-
-            if (filterReject && parseTable.hasRejects()) {
-                if (hasRejectProd(t) && !parser.useIntegratedRecovery)
-                    throw new FilterException(parser, "Unexpected reject annotation in " + yieldTree(t));
-            }
-
-            t = new ParseNode(node.label, newArgs);
-        } else if(t instanceof ParseProductionNode) {
-            // leaf node -- do thing (cannot be any ambiguities here)
-            return t;
-        } else {
-            throw new FatalException();
-        }
-
-        if (filterAssociativity) {
-            return applyAssociativityPriorityFilter(t);
-        } else {
-            return t;
-        }
-    }
-
-    private AbstractParseNode[] filterTree(AbstractParseNode[] args, boolean inAmbiguityCluster) throws FilterException {
-
-        if(SGLR.isDebugging()) {
-            Tools.debug("filterTree(<nodes>) - ", args);
-        }
-
-        AbstractParseNode[] newArgs = new AbstractParseNode[args.length];
-        // boolean changed = false;
-
-        for (int i = 0, max = args.length; i < max; i++) {
-            AbstractParseNode n = args[i];
-            AbstractParseNode filtered = filterTree(n, false);
-
-            // changed = !filtered.equals(n) || changed;
-            newArgs[i] = filtered;
-        }
-
-        // FIXME Shouldn't we do some filtering here?
-        // if (!changed) {
-        //     Tools.debug("Dropping: ", args);
-        //     newArgs = getEmptyList();
-        // }
-
-        if (filterAny) {
-            AbstractParseNode[] filtered = new AbstractParseNode[newArgs.length];
-            for (int i = 0, max = newArgs.length; i < max; i++) {
-                filtered[i] = applyAssociativityPriorityFilter(newArgs[i]);
-            }
-            return filtered;
-        } else {
-            return newArgs;
-        }
-    }
-
-    private AbstractParseNode applyAssociativityPriorityFilter(AbstractParseNode t) throws FilterException {
-        // SG_Associativity_Priority_Filter(pt, t)
-        // - ok
-
-        if(SGLR.isDebugging()) {
-            Tools.debug("applyAssociativityPriorityFilter() - ", t);
-        }
-
-        AbstractParseNode r = t;
-
-        if (t instanceof ParseNode) {
-            Label prodLabel = getProductionLabel(t);
-            ParseNode n = (ParseNode) t;
-
-            if (filterAssociativity) {
-                if (prodLabel.isLeftAssociative()) {
-                    r = applyLeftAssociativeFilter(n, prodLabel);
-                } else if (prodLabel.isRightAssociative()) {
-                    r = applyRightAssociativeFilter(n, prodLabel);
-                }
-
-            }
-
-            if (filterPriorities && parseTable.hasPriorities()) {
-                if(Tools.debugging) {
-                    Tools.debug(" - about to look up : ",  prodLabel.labelNumber);
-                }
-
-                if (!lookupGtrPriority(prodLabel).isEmpty()) {
-                    if(Tools.debugging) {
-                        Tools.debug(" - found");
-                    }
-                    if (r instanceof Amb) // FIXME is this correct?
-                        return r;
-                    return applyPriorityFilter((ParseNode) r, prodLabel);
-                }
-                if(Tools.debugging) {
-                    Tools.debug(" - not found");
-                }
-            }
-        }
-
-        return r;
+        return parser.getParseTable().getTreeBuilder().buildTreeTop(r, ambCount);
     }
 
-    private AbstractParseNode applyRightAssociativeFilter(ParseNode t, Label prodLabel) throws FilterException {
-        // SG_Right_Associativity_Filter(t, prodl)
-        // - almost ok
+	private AbstractParseNode applyCycleDetectFilter(AbstractParseNode t) throws FilterException {
 
-        if(SGLR.isDebugging()) {
-            Tools.debug("applyRightAssociativeFilter() - ", t);
-        }
-
-        List<AbstractParseNode> newAmbiguities = new ArrayList<AbstractParseNode>();
-        AbstractParseNode[] kids = t.kids;
-        AbstractParseNode firstKid = kids[0];
-
-        if(firstKid instanceof Amb) {
-
-            for (AbstractParseNode amb : ((Amb)firstKid).getAlternatives()) {
-                if(((ParseNode)amb).getLabel() != prodLabel.labelNumber) {
-                    newAmbiguities.add(amb);
-                }
-            }
-
-            int additionalAmbNodes = newAmbiguities.isEmpty() ? 0 : 1;
-            AbstractParseNode[] restKids = new AbstractParseNode[t.kids.length - 1 + additionalAmbNodes]; 
-            for(int i = 0; i < restKids.length; i++) 
-            	restKids[i] = kids[i + 1];
-
-            // FIXME is this correct?
-            if(!newAmbiguities.isEmpty()) {
-            	AbstractParseNode extraAmb;
-                if(newAmbiguities.size() > 1)
-                    extraAmb = new Amb(newAmbiguities.toArray(new AbstractParseNode[newAmbiguities.size()]));
-                else
-                    extraAmb = newAmbiguities.get(0);
-                restKids[restKids.length - 1] = extraAmb;
-            } else {
-                throw new FilterException(parser);
-            }
-
-            // FIXME is this correct?
-            return new ParseNode(t.label, restKids);
-
-        } else if(firstKid instanceof ParseNode) {
-            if(((ParseNode)firstKid).getLabel() == prodLabel.labelNumber)
-                throw new FilterException(parser);
-        }
-        return t;
-    }
-
-    private AbstractParseNode applyPriorityFilter(ParseNode t, Label prodLabel) throws FilterException {
-        // SG_Priority_Filter
-
-        if(SGLR.isDebugging()) {
-            Tools.debug("applyPriorityFilter() - ", t);
-        }
-
-        List<AbstractParseNode> newAmbiguities = new ArrayList<AbstractParseNode>();
-        List<AbstractParseNode> newKids = new ArrayList<AbstractParseNode>();
-
-        int l0 = prodLabel.labelNumber;
-        int kidnumber = 0;
+		if (SGLR.isDebugging()) {
+			Tools.debug("applyCycleDetectFilter() - ", t);
+		}
+
+		if (filterCycles) {
+			if (ambiguityManager.getMaxNumberOfAmbiguities() > 0) {
+				if (isCyclicTerm(t)) {
+					throw new FilterException(parser, "Term is cyclic");
+				}
+			}
+		}
+
+		return t;
+	}
+
+	private ATerm getProduction(AbstractParseNode t) {
+		if (t instanceof ParseNode) {
+			return parseTable.getProduction(((ParseNode) t).getLabel());
+		} else {
+			return parseTable.getProduction(((ParseProductionNode) t).getProduction());
+		}
+	}
+
+	private AbstractParseNode applyTopSortFilter(String sort, AbstractParseNode t) throws SGLRException {
+
+		if (SGLR.isDebugging()) {
+			Tools.debug("applyTopSortFilter() - ", t);
+		}
+
+		if (sort != null && filterTopSort) {
+			t = selectOnTopSort(t, sort);
+			if (t == null) {
+				throw new StartSymbolException(parser, "Desired start symbol not found: " + sort);
+			}
+		}
+
+		return t;
+	}
+
+	private boolean matchProdOnTopSort(ATerm prod, String sort) throws FilterException {
+		try {
+			sort = sort.replaceAll("\"", "");
+			return prod.match("prod([cf(opt(layout)),cf(sort(\"" + sort + "\")),cf(opt(layout))], sort(\"<START>\"),no-attrs)") != null
+			|| prod.match("prod([cf(sort(\"" + sort + "\"))], sort(\"<START>\"),no-attrs)") != null
+			|| prod.match("prod([lex(sort(\"" + sort + "\"))], sort(\"<START>\"),no-attrs)") != null
+			|| prod.match("prod([sort(\"" + sort + "\")], sort(\"<START>\"),no-attrs)") != null;
+		} catch (final ParseError e) {
+			throw new FilterException(parser, "Could not select desired top sort: " + sort, e);
+		}
+	}
+
+	private AbstractParseNode selectOnTopSort(AbstractParseNode t, String sort) throws FilterException {
+		final List<AbstractParseNode> results = new ArrayList<AbstractParseNode>();
+
+		if (t instanceof Amb) {
+			addTopSortAlternatives(t, sort, results);
+
+			switch (results.size()) {
+			case 0: return null;
+			case 1: return results.get(0);
+			default: return new Amb(results.toArray(new AbstractParseNode[results.size()]));
+			}
+		} else {
+			final ATerm prod = getProduction(t);
+			return matchProdOnTopSort(prod, sort) ? t : null;
+		}
+	}
+
+	private void addTopSortAlternatives(AbstractParseNode t, String sort, List<AbstractParseNode> results) throws FilterException {
+		for(final AbstractParseNode amb : ((Amb) t).getAlternatives()) {
+			if (amb instanceof Amb) {
+				addTopSortAlternatives(amb, sort, results);
+			} else {
+				final ATerm prod = getProduction(amb);
+				if (matchProdOnTopSort(prod, sort)) {
+					results.add(amb);
+				}
+			}
+		}
+	}
+
+	private AbstractParseNode filterTree(AbstractParseNode t, boolean inAmbiguityCluster) throws FilterException {
+		// SG_FilterTreeRecursive
+		if (SGLR.isDebugging()) {
+			Tools.debug("filterTree(node)    - ", t);
+		}
+
+		if (t instanceof Amb) {
+			if (!inAmbiguityCluster) {
+				// (some cycle stuff should be done here)
+				final AbstractParseNode[] ambs = ((Amb)t).getAlternatives();
+				t = filterAmbiguities(ambs);
+			} else {
+				// FIXME: hasRejectProd(Amb) can never succeed?
+				if (filterReject && parseTable.hasRejects() && hasRejectProd(t)) {
+					return null;
+				}
+				final AbstractParseNode[] ambs = ((Amb) t).getAlternatives();
+				return filterAmbiguities(ambs);
+
+			}
+		} else if(t instanceof ParseNode) {
+			final ParseNode node = (ParseNode) t;
+			final AbstractParseNode[] args = node.kids;
+			final AbstractParseNode[] newArgs = filterTree(args, false);
+
+			if (filterReject && parseTable.hasRejects()) {
+				if (hasRejectProd(t) && !parser.useIntegratedRecovery) {
+					throw new FilterException(parser, "Unexpected reject annotation in " + yieldTree(t));
+				}
+			}
+
+			t = new ParseNode(node.label, newArgs);
+		} else if(t instanceof ParseProductionNode) {
+			// leaf node -- do thing (cannot be any ambiguities here)
+			return t;
+		} else {
+			throw new FatalException();
+		}
+
+		if (filterAssociativity) {
+			return applyAssociativityPriorityFilter(t);
+		} else {
+			return t;
+		}
+	}
+
+	private AbstractParseNode[] filterTree(AbstractParseNode[] args, boolean inAmbiguityCluster) throws FilterException {
+
+		if(SGLR.isDebugging()) {
+			Tools.debug("filterTree(<nodes>) - ", args);
+		}
+
+		final AbstractParseNode[] newArgs = new AbstractParseNode[args.length];
+		// boolean changed = false;
+
+		for (int i = 0, max = args.length; i < max; i++) {
+			final AbstractParseNode n = args[i];
+			final AbstractParseNode filtered = filterTree(n, false);
+
+			// changed = !filtered.equals(n) || changed;
+			newArgs[i] = filtered;
+		}
+
+		// FIXME Shouldn't we do some filtering here?
+		// if (!changed) {
+		//     Tools.debug("Dropping: ", args);
+		//     newArgs = getEmptyList();
+		// }
+
+		if (filterAny) {
+			final AbstractParseNode[] filtered = new AbstractParseNode[newArgs.length];
+			for (int i = 0, max = newArgs.length; i < max; i++) {
+				filtered[i] = applyAssociativityPriorityFilter(newArgs[i]);
+			}
+			return filtered;
+		} else {
+			return newArgs;
+		}
+	}
+
+	private AbstractParseNode applyAssociativityPriorityFilter(AbstractParseNode t) throws FilterException {
+		// SG_Associativity_Priority_Filter(pt, t)
+		// - ok
+
+		if(SGLR.isDebugging()) {
+			Tools.debug("applyAssociativityPriorityFilter() - ", t);
+		}
+
+		AbstractParseNode r = t;
+
+		if (t instanceof ParseNode) {
+			final Label prodLabel = getProductionLabel(t);
+			final ParseNode n = (ParseNode) t;
+
+			if (filterAssociativity) {
+				if (prodLabel.isLeftAssociative()) {
+					r = applyLeftAssociativeFilter(n, prodLabel);
+				} else if (prodLabel.isRightAssociative()) {
+					r = applyRightAssociativeFilter(n, prodLabel);
+				}
+
+			}
+
+			if (filterPriorities && parseTable.hasPriorities()) {
+				if(Tools.debugging) {
+					Tools.debug(" - about to look up : ",  prodLabel.labelNumber);
+				}
+
+				if (!lookupGtrPriority(prodLabel).isEmpty()) {
+					if(Tools.debugging) {
+						Tools.debug(" - found");
+					}
+					if (r instanceof Amb) {
+						return r;
+					}
+					return applyPriorityFilter((ParseNode) r, prodLabel);
+				}
+				if(Tools.debugging) {
+					Tools.debug(" - not found");
+				}
+			}
+		}
+
+		return r;
+	}
+
+	private AbstractParseNode applyRightAssociativeFilter(ParseNode t, Label prodLabel) throws FilterException {
+		// SG_Right_Associativity_Filter(t, prodl)
+		// - almost ok
+
+		if(SGLR.isDebugging()) {
+			Tools.debug("applyRightAssociativeFilter() - ", t);
+		}
+
+		final List<AbstractParseNode> newAmbiguities = new ArrayList<AbstractParseNode>();
+		final AbstractParseNode[] kids = t.kids;
+		final AbstractParseNode firstKid = kids[0];
+
+		if(firstKid instanceof Amb) {
+
+			for (final AbstractParseNode amb : ((Amb)firstKid).getAlternatives()) {
+				if(((ParseNode)amb).getLabel() != prodLabel.labelNumber) {
+					newAmbiguities.add(amb);
+				}
+			}
+
+			final int additionalAmbNodes = newAmbiguities.isEmpty() ? 0 : 1;
+			final AbstractParseNode[] restKids = new AbstractParseNode[t.kids.length - 1 + additionalAmbNodes];
+			for(int i = 0; i < restKids.length; i++) {
+				restKids[i] = kids[i + 1];
+			}
+
+			// FIXME is this correct?
+					if(!newAmbiguities.isEmpty()) {
+						AbstractParseNode extraAmb;
+						if(newAmbiguities.size() > 1) {
+							extraAmb = new Amb(newAmbiguities.toArray(new AbstractParseNode[newAmbiguities.size()]));
+						} else {
+							extraAmb = newAmbiguities.get(0);
+						}
+						restKids[restKids.length - 1] = extraAmb;
+					} else {
+						throw new FilterException(parser);
+					}
+
+					// FIXME is this correct?
+					return new ParseNode(t.label, restKids);
+
+		} else if(firstKid instanceof ParseNode) {
+			if(((ParseNode)firstKid).getLabel() == prodLabel.labelNumber) {
+				throw new FilterException(parser);
+			}
+		}
+		return t;
+	}
+
+	private AbstractParseNode applyPriorityFilter(ParseNode t, Label prodLabel) throws FilterException {
+		// SG_Priority_Filter
+
+		if(SGLR.isDebugging()) {
+			Tools.debug("applyPriorityFilter() - ", t);
+		}
+
+		final List<AbstractParseNode> newAmbiguities = new ArrayList<AbstractParseNode>();
+		final List<AbstractParseNode> newKids = new ArrayList<AbstractParseNode>();
+
+		final int l0 = prodLabel.labelNumber;
+		int kidnumber = 0;
+
+		for (final AbstractParseNode kid : t.kids) {
+			AbstractParseNode newKid = kid;
+			final AbstractParseNode injection = jumpOverInjections(kid);
+
+			if (injection instanceof Amb) {
+				newAmbiguities.clear();
+				for (final AbstractParseNode amb : ((Amb) injection).getAlternatives()) {
+					final AbstractParseNode injAmb = jumpOverInjections(amb);
+
+					if (injAmb instanceof ParseNode) {
+						final Label label = getProductionLabel(t);
+						if(hasGreaterPriority(l0, label.labelNumber, kidnumber)) {
+							newAmbiguities.add(amb);
+						}
+					}
+				}
+
+				if(!newAmbiguities.isEmpty()) {
+					AbstractParseNode n = null;
+					if(newAmbiguities.size() > 1) {
+						n = new Amb(newAmbiguities.toArray(new AbstractParseNode[newAmbiguities.size()]));
+					} else {
+						n = newAmbiguities.get(0);
+					}
+					newKid = replaceUnderInjections(kid, injection, n);
+				} else {
+					// fishy: another filter might be borked
+					if (filterStrict) {
+						throw new FilterException(parser);
+					} else {
+						// TODO: log or whatever?
+								return t;
+					}
+				}
+			} else if (injection instanceof ParseNode) {
+				final int l1 = ((ParseNode) injection).label;
+				if (hasGreaterPriority(l0, l1, kidnumber)) {
+					throw new FilterException(parser);
+				}
+			}
+
+			newKids.add(newKid);
+			kidnumber++;
+		}
+
+		// FIXME (KTK) get rid of toArray by precomputing the necessary size of newKids earlier in the method
+		return new ParseNode(t.label, newKids.toArray(new AbstractParseNode[newKids.size()]));
+	}
+
+	private AbstractParseNode replaceUnderInjections(AbstractParseNode alt, AbstractParseNode injection, AbstractParseNode n) {
+		// SG_Replace_Under_Injections
+		// - not ok
 
-        for (final AbstractParseNode kid : t.kids) {
-            AbstractParseNode newKid = kid;
-            final AbstractParseNode injection = jumpOverInjections(kid);
-
-            if (injection instanceof Amb) {
-                newAmbiguities.clear();
-                for (AbstractParseNode amb : ((Amb) injection).getAlternatives()) {
-                    AbstractParseNode injAmb = jumpOverInjections(amb);
-
-                    if (injAmb instanceof ParseNode) {
-                        Label label = getProductionLabel(t);
-                        if(hasGreaterPriority(l0, label.labelNumber, kidnumber)) {
-                            newAmbiguities.add(amb);
-                        }
-                    }
-                }
-
-                if(!newAmbiguities.isEmpty()) {
-                    AbstractParseNode n = null;
-                    if(newAmbiguities.size() > 1) {
-                        n = new Amb(newAmbiguities.toArray(new AbstractParseNode[newAmbiguities.size()]));
-                    } else {
-                        n = newAmbiguities.get(0);
-                    }
-                    newKid = replaceUnderInjections(kid, injection, n);
-                } else {
-                    // fishy: another filter might be borked
-                    if (filterStrict) {
-                        throw new FilterException(parser);
-                    } else {
-                        // TODO: log or whatever?
-                        return t;
-                    }
-                }
-            } else if (injection instanceof ParseNode) {
-                int l1 = ((ParseNode) injection).label;
-                if (hasGreaterPriority(l0, l1, kidnumber)) {
-                    throw new FilterException(parser);
-                }
-            }
-
-            newKids.add(newKid);
-            kidnumber++;
-        }
-
-        // FIXME (KTK) get rid of toArray by precomputing the necessary size of newKids earlier in the method
-        return new ParseNode(t.label, newKids.toArray(new AbstractParseNode[newKids.size()]));
-    }
-
-    private AbstractParseNode replaceUnderInjections(AbstractParseNode alt, AbstractParseNode injection, AbstractParseNode n) {
-        // SG_Replace_Under_Injections
-        // - not ok
-
-        throw new NotImplementedException();
-        /*
+		throw new NotImplementedException();
+		/*
         if (ATisEqual(t, injT)) {
            return newTree;
         } else {
@@ -583,550 +591,569 @@
                                                     injT, newTree);
           return ATsetArgument((ATermAppl)t, (ATerm)ATmakeList1((ATerm)newSon), 1);
         }
-        */
-    }
-
-    private AbstractParseNode jumpOverInjections(AbstractParseNode t) {
+		 */
+	}
 
-        if(SGLR.isDebugging()) {
-            Tools.debug("jumpOverInjections() - ", t);
-        }
-
-        if (t instanceof ParseNode) {
-            int prod = ((ParseNode) t).label;
-            ParseNode n = (ParseNode)t;
-            while (isUserDefinedLabel(prod)) {
-                AbstractParseNode x = n.kids[0];
-                if(x instanceof ParseNode) {
-                    n = (ParseNode)x;
-                    prod = n.label;
-                } else {
-                    return x;
-                }
-            }
-        }
-
-        return t;
-    }
-
-    // TODO: shouldn't this be called isInjection?
-
-    private boolean isUserDefinedLabel(int prod) {
-        Label l = parseTable.lookupInjection(prod);
-        if(l == null)
-            return false;
-        return l.isInjection();
-    }
-
-    private boolean hasGreaterPriority(int l0, int l1, int arg) {
-        List<Priority> prios = lookupGtrPriority(parseTable.getLabel(l0));
-
-        for (int i = 0, size = prios.size(); i < size; i++) {
-            Priority p = prios.get(i);
-        	if (l1 == p.right)
-        		if (p.arg == -1 || p.arg == arg) {
-        			return true;
-        	}
-        }
-        return false;
-    }
-
-    private List<Priority> lookupGtrPriority(Label prodLabel) {
-        return parseTable.getPriorities(prodLabel);
-    }
-
-    private AbstractParseNode applyLeftAssociativeFilter(ParseNode t, Label prodLabel) throws FilterException {
-        // SG_Right_Associativity_Filter()
-
-        if(SGLR.isDebugging()) {
-            Tools.debug("applyLeftAssociativeFilter() - ", t);
-        }
-
-        List<AbstractParseNode> newAmbiguities = new ArrayList<AbstractParseNode>();
-        AbstractParseNode[] kids = t.kids;
-        AbstractParseNode last = kids[kids.length - 1];
-
-        if (last instanceof Amb) {
-
-            for (AbstractParseNode amb : ((Amb) last).getAlternatives()) {
-                if (amb instanceof Amb
-                        || !parseTable.getLabel(((ParseNode) amb).getLabel()).equals(prodLabel)) {
-                    newAmbiguities.add(amb);
-                }
-            }
-
-            if (!newAmbiguities.isEmpty()) {
-            	AbstractParseNode[] rest = new AbstractParseNode[kids.length];
-                for(int i = 0; i < kids.length - 1; i++)
-                	rest[i] = kids[i];
-                
-                if (newAmbiguities.size() > 1) {
-                    last = new Amb(newAmbiguities.toArray(new AbstractParseNode[newAmbiguities.size()]));
-                } else {
-                    last = newAmbiguities.get(0);
-                }
-                rest[rest.length - 1] = last;
-                return new Amb(rest);
-            } else {
-                throw new FilterException(parser);
-            }
-        } else if (last instanceof ParseNode) {
-            Label other = parseTable.getLabel(((ParseNode) last).getLabel());
-            if (prodLabel.equals(other)) {
-                throw new FilterException(parser);
-            }
-        }
-
-        return t;
-    }
-
-    private Label getProductionLabel(AbstractParseNode t) {
-        if (t instanceof ParseNode) {
-            return parseTable.getLabel(((ParseNode) t).getLabel());
-        } else if (t instanceof ParseProductionNode) {
-            return parseTable.getLabel(((ParseProductionNode) t).getProduction());
-        }
-        return null;
-    }
-
-    private boolean hasRejectProd(AbstractParseNode t) {
-        return t instanceof ParseReject;
-    }
+	private AbstractParseNode jumpOverInjections(AbstractParseNode t) {
 
-    private AbstractParseNode filterAmbiguities(AbstractParseNode[] ambs) throws FilterException {
-        // SG_FilterAmb
+		if(SGLR.isDebugging()) {
+			Tools.debug("jumpOverInjections() - ", t);
+		}
+
+		if (t instanceof ParseNode) {
+			int prod = ((ParseNode) t).label;
+			ParseNode n = (ParseNode)t;
+			while (isUserDefinedLabel(prod)) {
+				final AbstractParseNode x = n.kids[0];
+				if(x instanceof ParseNode) {
+					n = (ParseNode)x;
+					prod = n.label;
+				} else {
+					return x;
+				}
+			}
+		}
+
+		return t;
+	}
+
+	// TODO: shouldn't this be called isInjection?
+
+	private boolean isUserDefinedLabel(int prod) {
+		final Label l = parseTable.lookupInjection(prod);
+		if(l == null) {
+			return false;
+		}
+		return l.isInjection();
+	}
+
+	private boolean hasGreaterPriority(int l0, int l1, int arg) {
+		final List<Priority> prios = lookupGtrPriority(parseTable.getLabel(l0));
+
+		for (int i = 0, size = prios.size(); i < size; i++) {
+			final Priority p = prios.get(i);
+			if (l1 == p.right) {
+				if (p.arg == -1 || p.arg == arg) {
+					return true;
+				}
+			}
+		}
+		return false;
+	}
+
+	private List<Priority> lookupGtrPriority(Label prodLabel) {
+		return parseTable.getPriorities(prodLabel);
+	}
+
+	private AbstractParseNode applyLeftAssociativeFilter(ParseNode t, Label prodLabel) throws FilterException {
+		// SG_Right_Associativity_Filter()
+
+		if(SGLR.isDebugging()) {
+			Tools.debug("applyLeftAssociativeFilter() - ", t);
+		}
+
+		final List<AbstractParseNode> newAmbiguities = new ArrayList<AbstractParseNode>();
+		final AbstractParseNode[] kids = t.kids;
+		AbstractParseNode last = kids[kids.length - 1];
+
+		if (last instanceof Amb) {
+
+			for (final AbstractParseNode amb : ((Amb) last).getAlternatives()) {
+				if (amb instanceof Amb
+						|| !parseTable.getLabel(((ParseNode) amb).getLabel()).equals(prodLabel)) {
+					newAmbiguities.add(amb);
+				}
+			}
+
+			if (!newAmbiguities.isEmpty()) {
+				final AbstractParseNode[] rest = new AbstractParseNode[kids.length];
+				for(int i = 0; i < kids.length - 1; i++) {
+					rest[i] = kids[i];
+				}
+
+				if (newAmbiguities.size() > 1) {
+					last = new Amb(newAmbiguities.toArray(new AbstractParseNode[newAmbiguities.size()]));
+				} else {
+					last = newAmbiguities.get(0);
+				}
+				rest[rest.length - 1] = last;
+				return new Amb(rest);
+			} else {
+				throw new FilterException(parser);
+			}
+		} else if (last instanceof ParseNode) {
+			final Label other = parseTable.getLabel(((ParseNode) last).getLabel());
+			if (prodLabel.equals(other)) {
+				throw new FilterException(parser);
+			}
+		}
+
+		return t;
+	}
+
+	private Label getProductionLabel(AbstractParseNode t) {
+		if (t instanceof ParseNode) {
+			return parseTable.getLabel(((ParseNode) t).getLabel());
+		} else if (t instanceof ParseProductionNode) {
+			return parseTable.getLabel(((ParseProductionNode) t).getProduction());
+		}
+		return null;
+	}
+
+	private boolean hasRejectProd(AbstractParseNode t) {
+		return t instanceof ParseReject;
+	}
+
+	private AbstractParseNode filterAmbiguities(AbstractParseNode[] ambs) throws FilterException {
+		// SG_FilterAmb
+
+		if(SGLR.isDebugging()) {
+			Tools.debug("filterAmbiguities() - [", ambs.length, "]");
+		}
+
+		List<AbstractParseNode> newAmbiguities = new ArrayList<AbstractParseNode>();
+
+		for (final AbstractParseNode amb : ambs) {
+			final AbstractParseNode newAmb = filterTree(amb, true);
+			if (newAmb != null) {
+				newAmbiguities.add(newAmb);
+			}
+		}
+
+		if (newAmbiguities.size() > 1) {
+			/* Handle ambiguities inside this ambiguity cluster */
+			final List<AbstractParseNode> oldAmbiguities = new ArrayList<AbstractParseNode>(newAmbiguities);
+			for (final AbstractParseNode amb : oldAmbiguities) {
+				if (newAmbiguities.remove(amb)) {
+					newAmbiguities = filterAmbiguityList(newAmbiguities, amb);
+				}
+			}
+		}
+
+		if (newAmbiguities.isEmpty()) {
+			throw new FilterException(parser);
+		}
+
+		if (newAmbiguities.size() == 1) {
+			return newAmbiguities.get(0);
+		}
+
+		return new Amb(newAmbiguities.toArray(new AbstractParseNode[newAmbiguities.size()]));
+	}
+
+	private List<AbstractParseNode> filterAmbiguityList(List<AbstractParseNode> ambs, AbstractParseNode t) {
+		// SG_FilterAmbList
+
+		boolean keepT = true;
+		final List<AbstractParseNode> r = new ArrayList<AbstractParseNode>();
+
+		if (ambs.isEmpty()) {
+			r.add(t);
+			return r;
+		}
+
+		for (int i = 0, max = ambs.size(); i < max; i++) {
+			final AbstractParseNode amb = ambs.get(i);
+			switch (filter(t, amb)) {
+			case FILTER_DRAW:
+				r.add(amb);
+				break;
+			case FILTER_RIGHT_WINS:
+				r.add(amb);
+				keepT = false;
+			}
+		}
+
+		if (keepT) {
+			r.add(t);
+		}
+
+		return r;
+	}
+
+	private int filter(AbstractParseNode left, AbstractParseNode right) {
+		// SG_Filter(t0, t1)
+
+		if(SGLR.isDebugging()) {
+			Tools.debug("filter()");
+		}
+
+		if (left.equals(right)) {
+			return FILTER_LEFT_WINS;
+		}
 
-        if(SGLR.isDebugging()) {
-            Tools.debug("filterAmbiguities() - [", ambs.length, "]");
-        }
-
-        List<AbstractParseNode> newAmbiguities = new ArrayList<AbstractParseNode>();
-
-        for (AbstractParseNode amb : ambs) {
-            AbstractParseNode newAmb = filterTree(amb, true);
-            if (newAmb != null) 
-            	newAmbiguities.add(newAmb);
-        }
-
-        if (newAmbiguities.size() > 1) {
-            /* Handle ambiguities inside this ambiguity cluster */
-            List<AbstractParseNode> oldAmbiguities = new ArrayList<AbstractParseNode>(newAmbiguities);
-            for (AbstractParseNode amb : oldAmbiguities) {
-                if (newAmbiguities.remove(amb)) {
-                    newAmbiguities = filterAmbiguityList(newAmbiguities, amb);
-                }
-            }
-        }
-
-        if (newAmbiguities.isEmpty())
-            throw new FilterException(parser);
-
-        if (newAmbiguities.size() == 1)
-            return newAmbiguities.get(0);
-
-        return new Amb(newAmbiguities.toArray(new AbstractParseNode[newAmbiguities.size()]));
-    }
-
-    private List<AbstractParseNode> filterAmbiguityList(List<AbstractParseNode> ambs, AbstractParseNode t) {
-        // SG_FilterAmbList
-
-        boolean keepT = true;
-        List<AbstractParseNode> r = new ArrayList<AbstractParseNode>();
-
-        if (ambs.isEmpty()) {
-            r.add(t);
-            return r;
-        }
-
-        for (int i = 0, max = ambs.size(); i < max; i++) {
-            AbstractParseNode amb = ambs.get(i);
-            switch (filter(t, amb)) {
-            case FILTER_DRAW:
-                r.add(amb);
-                break;
-            case FILTER_RIGHT_WINS:
-                r.add(amb);
-                keepT = false;
-            }
-        }
-
-        if (keepT) {
-            r.add(t);
-        }
-
-        return r;
-    }
-
-    private int filter(AbstractParseNode left, AbstractParseNode right) {
-        // SG_Filter(t0, t1)
-
-        if(SGLR.isDebugging()) {
-            Tools.debug("filter()");
-        }
-
-        if (left.equals(right)) {
-            return FILTER_LEFT_WINS;
-        }
-
-        /* UNDONE: direct eagerness filter seems to be disabled in reference SGLR
+		/* UNDONE: direct eagerness filter seems to be disabled in reference SGLR
         if (filterDirectPreference && parseTable.hasPrefersOrAvoids()) {
             int r = filterOnDirectPrefers(left, right);
             if (r != FILTER_DRAW)
                 return r;
         }
-        */
-
-        // like C-SGLR, we use indirect preference filtering if the direct one is enabled
-        if (filterDirectPreference && parseTable.hasPrefersOrAvoids()) {
-            int r = filterOnIndirectPrefers(left, right);
-            if (r != FILTER_DRAW)
-                return r;
-        }
-
-        if (filterPreferenceCount && parseTable.hasPrefersOrAvoids()) {
-            int r = filterOnPreferCount(left, right);
-            if (r != FILTER_DRAW)
-                return r;
-        }
-
-        if (filterInjectionCount) {
-            int r = filterOnInjectionCount(left, right);
-            if (r != FILTER_DRAW)
-                return r;
-        }
-
-        return filterPermissiveLiterals(left, right);
-    }
-
-    private int filterPermissiveLiterals(AbstractParseNode left, AbstractParseNode right) {
-        // Work-around for http://bugs.strategoxt.org/browse/SPI-5 (Permissive grammars introduce ambiguities for literals)
-
-        if (left instanceof ParseNode && right instanceof ParseNode) {
-            AbstractParseNode[] leftKids = ((ParseNode) left).kids;
-            AbstractParseNode[] rightKids = ((ParseNode) right).kids;
-            if (leftKids.length > 0 && rightKids.length == 1) {
-                if (leftKids[0] instanceof ParseProductionNode && rightKids[0].equals(left)) {
-                    return FILTER_LEFT_WINS;
-                }
-            }
-        }
-        return FILTER_DRAW;
-    }
-
-    private int filterOnInjectionCount(AbstractParseNode left, AbstractParseNode right) {
-
-        if(SGLR.isDebugging()) {
-            Tools.debug("filterOnInjectionCount()");
-        }
-
-        ambiguityManager.increaseInjectionCount();
-
-        int leftInjectionCount = countAllInjections(left);
-        int rightInjectionCount = countAllInjections(right);
-
-        if (leftInjectionCount != rightInjectionCount) {
-            ambiguityManager.increaseInjectionFilterSucceededCount();
-        }
-
-        if (leftInjectionCount > rightInjectionCount) {
-            return FILTER_RIGHT_WINS;
-        } else if (rightInjectionCount > leftInjectionCount) {
-            return FILTER_LEFT_WINS;
-        }
-
-        return FILTER_DRAW;
-    }
-
-    private int countAllInjections(AbstractParseNode t) {
-        // SG_CountAllInjectionsInTree
-        // - ok
-        if (t instanceof Amb) {
-            // Trick from forest.c
-            return countAllInjections(((Amb) t).getAlternatives()[0]);
-        } else if (t instanceof ParseNode) {
-            int c = getProductionLabel(t).isInjection() ? 1 : 0;
-            return c + countAllInjections(((ParseNode) t).kids);
-        }
-        return 0;
-    }
-
-    private int countAllInjections(AbstractParseNode[] ls) {
-        // SG_CountAllInjectionsInTree
-        // - ok
-        int r = 0;
-        for (int i = 0, max = ls.length; i < max; i++) {
-            r += countAllInjections(ls[i]);
-        }
-        return r;
-    }
-
-    private int filterOnPreferCount(AbstractParseNode left, AbstractParseNode right) {
-
-        if(SGLR.isDebugging()) {
-            Tools.debug("filterOnPreferCount()");
-        }
-
-        ambiguityManager.increaseEagernessFilterCalledCount();
-
-        int r = FILTER_DRAW;
-        if (parseTable.hasPrefers() || parseTable.hasAvoids()) {
-            int leftPreferCount = countPrefers(left);
-            int rightPreferCount = countPrefers(right);
-            int leftAvoidCount = countAvoids(left);
-            int rightAvoidCount = countAvoids(right);
-
-            if ((leftPreferCount > rightPreferCount && leftAvoidCount <= rightAvoidCount)
-                    || (leftPreferCount == rightPreferCount && leftAvoidCount < rightAvoidCount)) {
-                Tools.logger("Eagerness priority: ", left, " > ", right);
-                r = FILTER_LEFT_WINS;
-            }
-
-            if ((rightPreferCount > leftPreferCount && rightAvoidCount <= leftAvoidCount)
-                    || (rightPreferCount == leftPreferCount && rightAvoidCount < leftAvoidCount)) {
-                if (r != FILTER_DRAW) {
-                    Tools.logger("Symmetric eagerness priority: ", left, " == ", right);
-                    r = FILTER_DRAW;
-                } else {
-                    Tools.logger("Eagerness priority: ", right, " > ", left);
-                    r = FILTER_RIGHT_WINS;
-                }
-            }
-        }
-
-        if (r != FILTER_DRAW) {
-            ambiguityManager.increaseEagernessFilterSucceededCount();
-        }
-
-        return r;
-    }
-
-    private int countPrefers(AbstractParseNode t) {
-        // SG_CountPrefersInTree
-        // - ok
-        if (t instanceof Amb) {
-            return countPrefers(((Amb) t).getAlternatives());
-        } else if (t instanceof ParseNode) {
-            int type = getProductionType(t);
-            if (type == ProductionType.PREFER)
-                return 1;
-            else if (type == ProductionType.AVOID)
-                return 0;
-            return countPrefers(((ParseNode) t).kids);
-        }
-        return 0;
-    }
-
-    private int countPrefers(AbstractParseNode[] ls) {
-        // SG_CountPrefersInTree
-        // - ok
-        int r = 0;
-        for (AbstractParseNode n : ls) {
-            r += countPrefers(n);
-        }
-        return r;
-    }
+		 */
 
-    private int countAvoids(AbstractParseNode t) {
-        // SG_CountAvoidsInTree
-        // - ok
-        if (t instanceof Amb) {
-            return countAvoids(((Amb) t).getAlternatives());
-        } else if (t instanceof ParseNode) {
-            int type = getProductionType(t);
-            if (type == ProductionType.PREFER)
-                return 0;
-            else if (type == ProductionType.AVOID)
-                return 1;
-            return countAvoids(((ParseNode) t).kids);
-        }
-        return 0;
-    }
-
-    private int countAvoids(AbstractParseNode[] ls) {
-        // SG_CountAvoidsInTree
-        // - ok
-        int r = 0;
-        for (AbstractParseNode n : ls) {
-            r += countAvoids(n);
-        }
-        return r;
-    }
-
-    private int filterOnIndirectPrefers(AbstractParseNode left, AbstractParseNode right) {
-        // SG_Indirect_Eagerness_Filter
-
-        if(SGLR.isDebugging()) {
-            Tools.debug("filterOnIndirectPrefers()");
-        }
-
-        if (left instanceof Amb || right instanceof Amb)
-            return FILTER_DRAW;
-
-        if (!getLabel(left).equals(getLabel(right)))
-            return filterOnDirectPrefers(left, right);
-
-        ParseNode l = (ParseNode) left;
-        ParseNode r = (ParseNode) right;
-
-        AbstractParseNode[] leftArgs = l.kids;
-        AbstractParseNode[] rightArgs = r.kids;
-
-        int diffs = computeDistinctArguments(leftArgs, rightArgs);
-
-        if (diffs == 1) {
-            for (int i = 0; i < leftArgs.length; i++) {
-                AbstractParseNode leftArg = leftArgs[i];
-                AbstractParseNode rightArg = rightArgs[i];
-
-                if (!leftArg.equals(rightArg)) {
-                    return filterOnIndirectPrefers(leftArg, rightArg);
-                }
-            }
-
-        }
-        return FILTER_DRAW;
-    }
-
-    private int filterOnDirectPrefers(AbstractParseNode left, AbstractParseNode right) {
-        // SG_Direct_Eagerness_Filter
-
-        if(SGLR.isDebugging()) {
-            Tools.debug("filterOnDirectPrefers()");
-        }
-
-        // TODO: optimize - move up the jumpOverInjectionsModuloEagerness calls
-        if (isLeftMoreEager(left, right))
-            return FILTER_LEFT_WINS;
-        if (isLeftMoreEager(right, left))
-            return FILTER_RIGHT_WINS;
-
-        return FILTER_DRAW;
-    }
-
-    private boolean isLeftMoreEager(AbstractParseNode left, AbstractParseNode right) {
-        assert !(left instanceof Amb || right instanceof Amb);
-        if (isMoreEager(left, right))
-            return true;
-
-        AbstractParseNode newLeft = jumpOverInjectionsModuloEagerness(left);
-        AbstractParseNode newRight = jumpOverInjectionsModuloEagerness(right);
-
-        if (newLeft instanceof ParseNode && newRight instanceof ParseNode)
-            return isMoreEager(newLeft, newRight);
-
-        return false;
-    }
-
-    private AbstractParseNode jumpOverInjectionsModuloEagerness(AbstractParseNode t) {
-
-        if(SGLR.isDebugging()) {
-            Tools.debug("jumpOverInjectionsModuloEagerness()");
-        }
-
-        int prodType = getProductionType(t);
-
-        if (t instanceof ParseNode && prodType != ProductionType.PREFER
-                && prodType != ProductionType.AVOID) {
-
-            Label prod = getLabel(t);
-
-            while (prod.isInjection()) {
-                t = ((ParseNode) t).kids[0];
-
-
-                if (t instanceof ParseNode) {
-                    int prodTypeX = getProductionType(t);
-
-                    if (prodTypeX != ProductionType.PREFER
-                        && prodTypeX != ProductionType.AVOID) {
-                        prod = getLabel(t);
-                        continue;
-                    }
-                }
-                return t;
-            }
-        }
-        return t;
-    }
-
-    private Label getLabel(AbstractParseNode t) {
-        if (t instanceof ParseNode) {
-            ParseNode n = (ParseNode) t;
-            return parseTable.getLabel(n.label);
-        } else if (t instanceof ParseProductionNode) {
-            ParseProductionNode n = (ParseProductionNode) t;
-            return parseTable.getLabel(n.prod);
-        }
-        return null;
-    }
-
-    private int getProductionType(AbstractParseNode t) {
-        return getLabel(t).getAttributes().getType();
-    }
-
-    private boolean isMoreEager(AbstractParseNode left, AbstractParseNode right) {
-        int leftLabel = ((ParseNode) left).getLabel();
-        int rightLabel = ((ParseNode) right).getLabel();
-
-        Label leftProd = parseTable.getLabel(leftLabel);
-        Label rightProd = parseTable.getLabel(rightLabel);
-
-        if (leftProd.isMoreEager(rightProd))
-            return true;
-
-        return false;
-    }
-
-    private int computeDistinctArguments(AbstractParseNode[] leftArgs, AbstractParseNode[] rightArgs) {
-        // countDistinctArguments
-        int r = 0;
-        for (int i = 0; i < leftArgs.length; i++) {
-            if (!leftArgs[i].equals(rightArgs[i]))
-                r++;
-        }
-        return r;
-    }
-
-    private boolean isCyclicTerm(AbstractParseNode t) {
-
-        ambiguityManager.dumpIndexTable();
-
-        List<AbstractParseNode> cycles = computeCyclicTerm(t);
-
-        return cycles != null && cycles.size() > 0;
-    }
-
-    private List<AbstractParseNode> computeCyclicTerm(AbstractParseNode t) {
-        // FIXME rewrite to use HashMap and object id
-        PositionMap visited = new PositionMap(ambiguityManager.getMaxNumberOfAmbiguities());
-
-        ambiguityManager.resetAmbiguityCount();
-
-        return computeCyclicTerm(t, false, visited);
-    }
-
-    private List<AbstractParseNode> computeCyclicTerm(AbstractParseNode t, boolean inAmbiguityCluster,
-            PositionMap visited) {
-
-        if (SGLR.isDebugging()) {
-            Tools.debug("computeCyclicTerm() - ", t);
-        }
-
-        if (t instanceof ParseProductionNode) {
-            if (SGLR.isDebugging()) {
-                Tools.debug(" bumping");
-            }
-            return null;
-        } else if (t instanceof ParseNode) {
-            //Amb ambiguities = null;
-            List<AbstractParseNode> cycle = null;
-            //int clusterIndex;
-            ParseNode n = (ParseNode) t;
-
-            if (inAmbiguityCluster) {
-                cycle = computeCyclicTerm(n.kids, false, visited);
-            } else {
-                /*
+		// like C-SGLR, we use indirect preference filtering if the direct one is enabled
+		if (filterDirectPreference && parseTable.hasPrefersOrAvoids()) {
+			final int r = filterOnIndirectPrefers(left, right);
+			if (r != FILTER_DRAW) {
+				return r;
+			}
+		}
+
+		if (filterPreferenceCount && parseTable.hasPrefersOrAvoids()) {
+			final int r = filterOnPreferCount(left, right);
+			if (r != FILTER_DRAW) {
+				return r;
+			}
+		}
+
+		if (filterInjectionCount) {
+			final int r = filterOnInjectionCount(left, right);
+			if (r != FILTER_DRAW) {
+				return r;
+			}
+		}
+
+		return filterPermissiveLiterals(left, right);
+	}
+
+	private int filterPermissiveLiterals(AbstractParseNode left, AbstractParseNode right) {
+		// Work-around for http://bugs.strategoxt.org/browse/SPI-5 (Permissive grammars introduce ambiguities for literals)
+
+		if (left instanceof ParseNode && right instanceof ParseNode) {
+			final AbstractParseNode[] leftKids = ((ParseNode) left).kids;
+			final AbstractParseNode[] rightKids = ((ParseNode) right).kids;
+			if (leftKids.length > 0 && rightKids.length == 1) {
+				if (leftKids[0] instanceof ParseProductionNode && rightKids[0].equals(left)) {
+					return FILTER_LEFT_WINS;
+				}
+			}
+		}
+		return FILTER_DRAW;
+	}
+
+	private int filterOnInjectionCount(AbstractParseNode left, AbstractParseNode right) {
+
+		if(SGLR.isDebugging()) {
+			Tools.debug("filterOnInjectionCount()");
+		}
+
+		ambiguityManager.increaseInjectionCount();
+
+		final int leftInjectionCount = countAllInjections(left);
+		final int rightInjectionCount = countAllInjections(right);
+
+		if (leftInjectionCount != rightInjectionCount) {
+			ambiguityManager.increaseInjectionFilterSucceededCount();
+		}
+
+		if (leftInjectionCount > rightInjectionCount) {
+			return FILTER_RIGHT_WINS;
+		} else if (rightInjectionCount > leftInjectionCount) {
+			return FILTER_LEFT_WINS;
+		}
+
+		return FILTER_DRAW;
+	}
+
+	private int countAllInjections(AbstractParseNode t) {
+		// SG_CountAllInjectionsInTree
+		// - ok
+		if (t instanceof Amb) {
+			// Trick from forest.c
+			return countAllInjections(((Amb) t).getAlternatives()[0]);
+		} else if (t instanceof ParseNode) {
+			final int c = getProductionLabel(t).isInjection() ? 1 : 0;
+			return c + countAllInjections(((ParseNode) t).kids);
+		}
+		return 0;
+	}
+
+	private int countAllInjections(AbstractParseNode[] ls) {
+		// SG_CountAllInjectionsInTree
+		// - ok
+		int r = 0;
+		for (int i = 0, max = ls.length; i < max; i++) {
+			r += countAllInjections(ls[i]);
+		}
+		return r;
+	}
+
+	private int filterOnPreferCount(AbstractParseNode left, AbstractParseNode right) {
+
+		if(SGLR.isDebugging()) {
+			Tools.debug("filterOnPreferCount()");
+		}
+
+		ambiguityManager.increaseEagernessFilterCalledCount();
+
+		int r = FILTER_DRAW;
+		if (parseTable.hasPrefers() || parseTable.hasAvoids()) {
+			final int leftPreferCount = countPrefers(left);
+			final int rightPreferCount = countPrefers(right);
+			final int leftAvoidCount = countAvoids(left);
+			final int rightAvoidCount = countAvoids(right);
+
+			if ((leftPreferCount > rightPreferCount && leftAvoidCount <= rightAvoidCount)
+					|| (leftPreferCount == rightPreferCount && leftAvoidCount < rightAvoidCount)) {
+				Tools.logger("Eagerness priority: ", left, " > ", right);
+				r = FILTER_LEFT_WINS;
+			}
+
+			if ((rightPreferCount > leftPreferCount && rightAvoidCount <= leftAvoidCount)
+					|| (rightPreferCount == leftPreferCount && rightAvoidCount < leftAvoidCount)) {
+				if (r != FILTER_DRAW) {
+					Tools.logger("Symmetric eagerness priority: ", left, " == ", right);
+					r = FILTER_DRAW;
+				} else {
+					Tools.logger("Eagerness priority: ", right, " > ", left);
+					r = FILTER_RIGHT_WINS;
+				}
+			}
+		}
+
+		if (r != FILTER_DRAW) {
+			ambiguityManager.increaseEagernessFilterSucceededCount();
+		}
+
+		return r;
+	}
+
+	private int countPrefers(AbstractParseNode t) {
+		// SG_CountPrefersInTree
+		// - ok
+		if (t instanceof Amb) {
+			return countPrefers(((Amb) t).getAlternatives());
+		} else if (t instanceof ParseNode) {
+			final int type = getProductionType(t);
+			if (type == ProductionType.PREFER) {
+				return 1;
+			} else if (type == ProductionType.AVOID) {
+				return 0;
+			}
+			return countPrefers(((ParseNode) t).kids);
+		}
+		return 0;
+	}
+
+	private int countPrefers(AbstractParseNode[] ls) {
+		// SG_CountPrefersInTree
+		// - ok
+		int r = 0;
+		for (final AbstractParseNode n : ls) {
+			r += countPrefers(n);
+		}
+		return r;
+	}
+
+	private int countAvoids(AbstractParseNode t) {
+		// SG_CountAvoidsInTree
+		// - ok
+		if (t instanceof Amb) {
+			return countAvoids(((Amb) t).getAlternatives());
+		} else if (t instanceof ParseNode) {
+			final int type = getProductionType(t);
+			if (type == ProductionType.PREFER) {
+				return 0;
+			} else if (type == ProductionType.AVOID) {
+				return 1;
+			}
+			return countAvoids(((ParseNode) t).kids);
+		}
+		return 0;
+	}
+
+	private int countAvoids(AbstractParseNode[] ls) {
+		// SG_CountAvoidsInTree
+		// - ok
+		int r = 0;
+		for (final AbstractParseNode n : ls) {
+			r += countAvoids(n);
+		}
+		return r;
+	}
+
+	private int filterOnIndirectPrefers(AbstractParseNode left, AbstractParseNode right) {
+		// SG_Indirect_Eagerness_Filter
+
+		if(SGLR.isDebugging()) {
+			Tools.debug("filterOnIndirectPrefers()");
+		}
+
+		if (left instanceof Amb || right instanceof Amb) {
+			return FILTER_DRAW;
+		}
+
+		if (!getLabel(left).equals(getLabel(right))) {
+			return filterOnDirectPrefers(left, right);
+		}
+
+		final ParseNode l = (ParseNode) left;
+		final ParseNode r = (ParseNode) right;
+
+		final AbstractParseNode[] leftArgs = l.kids;
+		final AbstractParseNode[] rightArgs = r.kids;
+
+		final int diffs = computeDistinctArguments(leftArgs, rightArgs);
+
+		if (diffs == 1) {
+			for (int i = 0; i < leftArgs.length; i++) {
+				final AbstractParseNode leftArg = leftArgs[i];
+				final AbstractParseNode rightArg = rightArgs[i];
+
+				if (!leftArg.equals(rightArg)) {
+					return filterOnIndirectPrefers(leftArg, rightArg);
+				}
+			}
+
+		}
+		return FILTER_DRAW;
+	}
+
+	private int filterOnDirectPrefers(AbstractParseNode left, AbstractParseNode right) {
+		// SG_Direct_Eagerness_Filter
+
+		if(SGLR.isDebugging()) {
+			Tools.debug("filterOnDirectPrefers()");
+		}
+
+		// TODO: optimize - move up the jumpOverInjectionsModuloEagerness calls
+		if (isLeftMoreEager(left, right)) {
+			return FILTER_LEFT_WINS;
+		}
+		if (isLeftMoreEager(right, left)) {
+			return FILTER_RIGHT_WINS;
+		}
+
+		return FILTER_DRAW;
+	}
+
+	private boolean isLeftMoreEager(AbstractParseNode left, AbstractParseNode right) {
+		assert !(left instanceof Amb || right instanceof Amb);
+		if (isMoreEager(left, right)) {
+			return true;
+		}
+
+		final AbstractParseNode newLeft = jumpOverInjectionsModuloEagerness(left);
+		final AbstractParseNode newRight = jumpOverInjectionsModuloEagerness(right);
+
+		if (newLeft instanceof ParseNode && newRight instanceof ParseNode) {
+			return isMoreEager(newLeft, newRight);
+		}
+
+		return false;
+	}
+
+	private AbstractParseNode jumpOverInjectionsModuloEagerness(AbstractParseNode t) {
+
+		if(SGLR.isDebugging()) {
+			Tools.debug("jumpOverInjectionsModuloEagerness()");
+		}
+
+		final int prodType = getProductionType(t);
+
+		if (t instanceof ParseNode && prodType != ProductionType.PREFER
+				&& prodType != ProductionType.AVOID) {
+
+			Label prod = getLabel(t);
+
+			while (prod.isInjection()) {
+				t = ((ParseNode) t).kids[0];
+
+
+				if (t instanceof ParseNode) {
+					final int prodTypeX = getProductionType(t);
+
+					if (prodTypeX != ProductionType.PREFER
+							&& prodTypeX != ProductionType.AVOID) {
+						prod = getLabel(t);
+						continue;
+					}
+				}
+				return t;
+			}
+		}
+		return t;
+	}
+
+	private Label getLabel(AbstractParseNode t) {
+		if (t instanceof ParseNode) {
+			final ParseNode n = (ParseNode) t;
+			return parseTable.getLabel(n.label);
+		} else if (t instanceof ParseProductionNode) {
+			final ParseProductionNode n = (ParseProductionNode) t;
+			return parseTable.getLabel(n.prod);
+		}
+		return null;
+	}
+
+	private int getProductionType(AbstractParseNode t) {
+		return getLabel(t).getAttributes().getType();
+	}
+
+	private boolean isMoreEager(AbstractParseNode left, AbstractParseNode right) {
+		final int leftLabel = ((ParseNode) left).getLabel();
+		final int rightLabel = ((ParseNode) right).getLabel();
+
+		final Label leftProd = parseTable.getLabel(leftLabel);
+		final Label rightProd = parseTable.getLabel(rightLabel);
+
+		if (leftProd.isMoreEager(rightProd)) {
+			return true;
+		}
+
+		return false;
+	}
+
+	private int computeDistinctArguments(AbstractParseNode[] leftArgs, AbstractParseNode[] rightArgs) {
+		// countDistinctArguments
+		int r = 0;
+		for (int i = 0; i < leftArgs.length; i++) {
+			if (!leftArgs[i].equals(rightArgs[i])) {
+				r++;
+			}
+		}
+		return r;
+	}
+
+	private boolean isCyclicTerm(AbstractParseNode t) {
+
+		ambiguityManager.dumpIndexTable();
+
+		final List<AbstractParseNode> cycles = computeCyclicTerm(t);
+
+		return cycles != null && cycles.size() > 0;
+	}
+
+	private List<AbstractParseNode> computeCyclicTerm(AbstractParseNode t) {
+		// FIXME rewrite to use HashMap and object id
+		final PositionMap visited = new PositionMap(ambiguityManager.getMaxNumberOfAmbiguities());
+
+		ambiguityManager.resetAmbiguityCount();
+
+		return computeCyclicTerm(t, false, visited);
+	}
+
+	private List<AbstractParseNode> computeCyclicTerm(AbstractParseNode t, boolean inAmbiguityCluster,
+			PositionMap visited) {
+
+		if (SGLR.isDebugging()) {
+			Tools.debug("computeCyclicTerm() - ", t);
+		}
+
+		if (t instanceof ParseProductionNode) {
+			if (SGLR.isDebugging()) {
+				Tools.debug(" bumping");
+			}
+			return null;
+		} else if (t instanceof ParseNode) {
+			//Amb ambiguities = null;
+			List<AbstractParseNode> cycle = null;
+			//int clusterIndex;
+			final ParseNode n = (ParseNode) t;
+
+			if (inAmbiguityCluster) {
+				cycle = computeCyclicTerm(n.kids, false, visited);
+			} else {
+				/*
                 if (ambiguityManager.isInputAmbiguousAt(parseTreePosition)) {
                     ambiguityManager.increaseAmbiguityCount();
                     clusterIndex = ambiguityManager.getClusterIndex(t, parseTreePosition);
@@ -1141,8 +1168,8 @@
                     clusterIndex = -1;
                 }*/
 
-                throw new NotImplementedException();
-/*
+				throw new NotImplementedException();
+				/*
                 if (ambiguities == null) {
                     cycle = computeCyclicTerm(((ParseNode) t).getKids(), false, visited);
                 } else {
@@ -1158,15 +1185,15 @@
                         parseTreePosition += length;
                     }
                 }
- */
-            }
-            return cycle;
-        } else {
-            throw new FatalException();
-        }
-    }
+				 */
+			}
+			return cycle;
+		} else {
+			throw new FatalException();
+		}
+	}
 
-    /*
+	/*
     private List<IParseNode> computeCyclicTermInAmbiguityCluster(Amb ambiguities,
             PositionMap visited) {
 
@@ -1180,16 +1207,17 @@
         }
         return null;
     }
-     */
+	 */
 
-    private List<AbstractParseNode> computeCyclicTerm(AbstractParseNode[] kids, boolean b, PositionMap visited) {
+	private List<AbstractParseNode> computeCyclicTerm(AbstractParseNode[] kids, boolean b, PositionMap visited) {
 
-        for (int i = 0, max = kids.length; i < max; i++) {
-            List<AbstractParseNode> cycle = computeCyclicTerm(kids[i], false, visited);
-            if (cycle != null)
-                return cycle;
-        }
-        return null;
-    }
+		for (int i = 0, max = kids.length; i < max; i++) {
+			final List<AbstractParseNode> cycle = computeCyclicTerm(kids[i], false, visited);
+			if (cycle != null) {
+				return cycle;
+			}
+		}
+		return null;
+	}
 
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/NotImplementedException.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/NotImplementedException.java	Thu Dec 16 15:03:49 2010	(r21534)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/NotImplementedException.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -11,4 +11,11 @@
 
     private static final long serialVersionUID = 1758191718483879246L;
 
+    public NotImplementedException(String message) {
+		super(message);
+	}
+    
+    public NotImplementedException() {
+		// Default constructor
+	}
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseAvoid.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseAvoid.java	Thu Dec 16 15:03:49 2010	(r21534)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseAvoid.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -15,11 +15,6 @@
     }
 
     @Override
-    public Object toParseTree(ParseTable pt) {
-        return super.toParseTree(pt);
-    }
-
-    @Override
     public String toString() {
         return "avoid(aprod(" + label + "), " + kids + ")";
     }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java	Thu Dec 16 15:03:49 2010	(r21534)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -15,9 +15,9 @@
 
 public class ParseNode extends AbstractParseNode {
 
-    public final int label;
+    final int label;
 
-    protected final AbstractParseNode[] kids;
+    final AbstractParseNode[] kids;
 
     private int cachedHashCode;
 
@@ -25,17 +25,24 @@
         this.label = label;
         this.kids = kids;
     }
+    
+    @Override
+    public Object toTreeTopdown(TopdownTreeBuilder builder) {
+    	return builder.buildTreeNode(this);
+    }
 
     @Override
-	public Object toParseTree(ParseTable pt) {
-        TreeBuilder tb = pt.getTreeBuilder();
+	public Object toTreeBottomup(BottomupTreeBuilder builder) {
+    	builder.visitLabel(label);
 
         Object[] subtrees = new Object[kids.length];
         for (int i = 0; i < kids.length; i++) {
-        	subtrees[i] = kids[i].toParseTree(pt);
+        	subtrees[i] = kids[i].toTreeBottomup(builder);
         }
 
-        return tb.buildNode(label - ParseTable.LABEL_BASE, subtrees);
+        Object result = builder.buildNode(label, subtrees);
+        builder.endVisitLabel(label);
+		return result;
     }
 
     /**
@@ -54,7 +61,13 @@
         return "regular(aprod(" + label + ")," + kids + ")";
     }
 
-    public int getLabel() { return label; }
+    public int getLabel() {
+    	return label;
+    }
+    
+    public AbstractParseNode[] getChildren() {
+		return kids;
+	}
 
     @Override
     public boolean equals(Object obj) {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParsePrefer.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParsePrefer.java	Thu Dec 16 15:03:49 2010	(r21534)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParsePrefer.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -15,11 +15,6 @@
     }
 
     @Override
-    public Object toParseTree(ParseTable pt) {
-        return super.toParseTree(pt);
-    }
-
-    @Override
     public String toString() {
         return "prefer(aprod(" + label + "), " + kids + ")";
     }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseProductionNode.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseProductionNode.java	Thu Dec 16 15:03:49 2010	(r21534)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseProductionNode.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -17,8 +17,13 @@
     }
 
     @Override
-	public Object toParseTree(ParseTable pt) {
-    	return pt.getTreeBuilder().buildProduction(prod);
+	public Object toTreeBottomup(BottomupTreeBuilder builder) {
+    	return builder.buildProduction(prod);
+    }
+    
+    @Override
+    public Object toTreeTopdown(TopdownTreeBuilder builder) {
+    	return builder.buildTreeProduction(this);
     }
 
     @Override

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseReject.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseReject.java	Thu Dec 16 15:03:49 2010	(r21534)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseReject.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -15,10 +15,10 @@
     }
 
     @Override
-    public Object toParseTree(ParseTable pt) {
+    public Object toTreeBottomup(BottomupTreeBuilder builder) {
         // Reject nodes shouldn't normally be output to a tree,
         // but in error recovery mode they can be
-        return super.toParseTree(pt);
+        return super.toTreeBottomup(builder);
     }
 
     @Override

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java	Thu Dec 16 15:03:49 2010	(r21534)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -74,7 +74,7 @@
 
     private transient Map<Label, List<Priority>> priorityCache;
 
-	private transient TreeBuilder treeBuilder;
+	private transient ITreeBuilder treeBuilder;
 
     private static final ParseProductionNode[] productionNodes = new ParseProductionNode[256 + 1];
     
@@ -87,7 +87,6 @@
     public ParseTable(ATerm pt) throws InvalidParseTableException {
         initAFuns(pt.getFactory());
         parse(pt);
-        setTreeConstructionParticipant(new Asfix2TreeBuilder());
     }
 
     public void initAFuns(ATermFactory factory) {
@@ -638,17 +637,19 @@
 	    return Collections.unmodifiableList(asList(labels));
 	}
 
-	public void setTreeConstructionParticipant(TreeBuilder treeBuilder) {
+	public void setTreeBuilder(ITreeBuilder treeBuilder) {
 		this.treeBuilder = treeBuilder;
-		treeBuilder.initialize(NUM_CHARS, labels.length - LABEL_BASE);
+		treeBuilder.initialize(this, NUM_CHARS, LABEL_BASE, labels.length);
 		for(int i = 0; i < labels.length; i++) {
 			if(labels[i] == null)
 				continue;
-			treeBuilder.addLabel(i - LABEL_BASE, labels[i].getProduction());
+			treeBuilder.initializeLabel(i, labels[i].getProduction());
 		}
 	}
 
-	public TreeBuilder getTreeBuilder() {
+	public ITreeBuilder getTreeBuilder() {
+        if (treeBuilder == null)
+        	setTreeBuilder(new Asfix2TreeBuilder());
 		return treeBuilder;
 	}
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 15:03:49 2010	(r21534)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -288,6 +288,10 @@
 		currentInputStream = new PushbackStringIterator(input);
 		acceptingStack = null;
 		collectedErrors.clear();
+		ITokenizer tokenizer = parseTable.getTreeBuilder().getTokenizer();
+		// TODO: optimize?
+		if (tokenizer != null)
+			tokenizer.initialize(input.toCharArray());
 
 		PooledPathList.resetPerformanceCounters();
 		PathListPool.resetPerformanceCounters();
@@ -862,6 +866,10 @@
 		return parseTable;
 	}
 
+	public void setTreeBuilder(ImplodedTreeBuilder implodedTreeBuilder) {
+		parseTable.setTreeBuilder(new ImplodedTreeBuilder());
+	}
+
 	AmbiguityManager getAmbiguityManager() {
 		return ambiguityManager;
 	}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/TreeBuilder.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/TreeBuilder.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -0,0 +1,16 @@
+package org.spoofax.jsglr.client;
+
+import org.spoofax.jsglr.shared.terms.ATermAppl;
+
+public interface TreeBuilder {
+
+	public void addLabel(int labelNumber, ATermAppl parseTreeProduction);
+
+	public Object buildNode(int labelNumber, Object[] subtrees);
+	public Object buildProduction(int productionNumber);
+	public Object buildToplevel(Object subtree, int ambiguityCount);
+	public Object buildAmb(Object[] alternatives);
+
+	public void initialize(int productionCount, int labelCount);
+	
+}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/Tools.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/Tools.java	Thu Dec 16 15:03:49 2010	(r21534)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/Tools.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -8,6 +8,10 @@
 package org.spoofax.jsglr.shared;
 
 import org.spoofax.jsglr.client.Measures;
+import org.spoofax.jsglr.shared.terms.ATerm;
+import org.spoofax.jsglr.shared.terms.ATermAppl;
+import org.spoofax.jsglr.shared.terms.ATermInt;
+import org.spoofax.jsglr.shared.terms.ATermString;
 
 
 public class Tools {
@@ -54,5 +58,33 @@
     public static Measures getMeasures() {
         return measures;
     }
+    
+    // Terms
+
+    public static ATermAppl applAt(ATerm pt, int i) {
+        return termAt(pt, i);
+    }
+    
+    public static String asJavaString(ATerm s) {
+    	return ((ATermString) s).getString();
+    }
+
+    @SuppressWarnings("unchecked") // casting is inherently unsafe, but doesn't warrant a warning here
+    public static<T extends ATerm> T termAt(ATerm t, int i) {
+        return (T) t.getChildAt(i);
+    }
+    
+    public static ATermAppl asAppl(ATerm t) {
+        return (ATermAppl) t;
+    }
+
+    public static boolean isAppl(ATerm t) {
+        return t.getType() == ATerm.APPL;
+    }
+    
+    public static int intAt(ATerm pt, int i) {
+        return ((ATermInt) pt.getChildAt(i)).getInt();
+    }
+
 
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/AFun.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/AFun.java	Thu Dec 16 15:03:49 2010	(r21534)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/AFun.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -11,7 +11,7 @@
 
 	AFun() {}
 	
-	public AFun(String name, int arity, boolean quoted) {
+	AFun(String name, int arity, boolean quoted) {
 		this.name = name;
 		this.arity = arity;
 	}
@@ -31,4 +31,13 @@
 		AFun o = (AFun)obj;
 		return o.arity == arity && o.name.equals(name);
 	}
+
+	@Override
+	public int hashCode() {
+		final int prime = 31;
+		int result = 1;
+		result = prime * result + arity;
+		result = prime * result + ((name == null) ? 0 : name.hashCode());
+		return result;
+	}
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java	Thu Dec 16 15:03:49 2010	(r21534)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -4,6 +4,7 @@
 import java.util.LinkedList;
 import java.util.List;
 
+import org.spoofax.jsglr.client.IToken;
 import org.spoofax.jsglr.client.NotImplementedException;
 
 public abstract class ATerm implements Serializable {
@@ -18,6 +19,8 @@
 	public static final int PLACEHOLDER = 6;
 
 	protected ATermFactory factory;
+	
+	private IToken leftToken, rightToken;
 
 	ATerm() {}
 	
@@ -30,6 +33,19 @@
 	public abstract ATerm getChildAt(int i);
 
 	public abstract int getType();
+	
+	public void internalSetTokens(IToken leftToken, IToken rightToken) {
+		this.leftToken = leftToken;
+		this.rightToken = rightToken;
+	}
+	
+	public IToken getLeftToken() {
+		return leftToken;
+	}
+	
+	public IToken getRightToken() {
+		return rightToken;
+	}
 
 	public ATermFactory getFactory() {
 		return factory;
@@ -43,8 +59,14 @@
 			return null;
 		}
 	}
+	
+	public boolean equals(Object o) {
+		return simpleMatch((ATerm) o);
+	}
 
 	public abstract boolean simpleMatch(ATerm t);
+	
+	public abstract int hashCode();
 
 	public boolean match(ATerm litStringAppl) {
 		throw new NotImplementedException();

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermAppl.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermAppl.java	Thu Dec 16 15:03:49 2010	(r21534)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermAppl.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -39,6 +39,11 @@
 	public boolean match(ATerm term) {
 		throw new NotImplementedException();
 	}
+	
+	@Override
+	public int hashCode() {
+		throw new NotImplementedException();
+	}
 
 	public AFun getAFun() {
 		return ctor;

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermFactory.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermFactory.java	Thu Dec 16 15:03:49 2010	(r21534)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermFactory.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -4,6 +4,7 @@
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
+import java.util.concurrent.ConcurrentHashMap;
 
 import org.spoofax.jsglr.client.NotImplementedException;
 import org.spoofax.jsglr.client.PushbackStringIterator;
@@ -11,14 +12,25 @@
 public class ATermFactory implements Serializable {
 
 	private static final long serialVersionUID = 1L;
-	private static final ATerm[] EMPTY = new ATerm[0];
+	
+	protected static final ATerm[] EMPTY = new ATerm[0];
+
+    private final ConcurrentHashMap<AFun, AFun> afunCache =
+        new ConcurrentHashMap<AFun, AFun>();
 
 	public AFun makeAFun(String ctorName, int arity, boolean quoted) {
-		return new AFun(ctorName, arity, quoted);
+		AFun candidate = new AFun(ctorName, arity, quoted);
+		AFun cached = afunCache.get(candidate);
+		if (cached == null) {
+			cached = afunCache.putIfAbsent(candidate, candidate);
+			return cached == null ? candidate : cached;
+		} else {
+			return cached;
+		}
 	}
 
 	public ATermPlaceholder makePlaceholder(ATerm template) {
-		return new ATermPlaceholder(this, makeConstructor("<>", 1), template);
+		return new ATermPlaceholder(this, makeAFun("<>", 1), template);
 	}
 	
 	public ATermList makeList() {
@@ -40,19 +52,20 @@
 		return parseFromString(text);
 	}
 
-	public ATerm makeAppl(AFun afun, ATermList kids) {
+	public ATermAppl makeAppl(AFun afun, ATermList kids) {
 		return new ATermAppl(this, afun, kids);
 	}
 
-	public ATerm makeAppl(AFun afun, ATerm... kids) {
+	public ATermAppl makeAppl(AFun afun, ATerm... kids) {
 		return new ATermAppl(this, afun, kids);
 	}
 
-	public ATerm makeAppl(AFun afun, ATerm[] kids, boolean m) {
+	public ATermAppl makeAppl(AFun afun, ATerm[] kids, boolean m) {
+		if (m) throw new UnsupportedOperationException("Use makeString() to make strings");
 		return new ATermAppl(this, afun, kids);
 	}
 
-	public ATerm makeInt(int i) {
+	public ATermInt makeInt(int i) {
 		return new ATermInt(this, i);
 	}
 
@@ -151,7 +164,7 @@
         return makeString(sb.toString());
     }
 
-    private ATermString makeString(String string) {
+    public ATermString makeString(String string) {
     	return new ATermString(this, string);
 	}
 
@@ -175,17 +188,17 @@
 
         if(ch == '(') {
             List<ATerm> l = parseTermSequence(bis, ')');
-            AFun c = makeConstructor(sb.toString(), l.size());
+            AFun c = makeAFun(sb.toString(), l.size());
             return makeAppl(c, l.toArray(EMPTY));
         } else {
             bis.unread(ch);
-            AFun c = makeConstructor(sb.toString(), 0);
+            AFun c = makeAFun(sb.toString(), 0);
             return makeAppl(c, EMPTY);
         }
     }
 
 	
-	private AFun makeConstructor(String ctorName, int arity) {
+	private AFun makeAFun(String ctorName, int arity) {
 		return makeAFun(ctorName, arity, false);
 	}
 
@@ -202,7 +215,7 @@
         return makeTuple(parseTermSequence(bis, ')').toArray(EMPTY));
     }
 
-    private ATermTuple makeTuple(ATerm[] elements) {
+    public ATermTuple makeTuple(ATerm[] elements) {
     	return new ATermTuple(this, elements);
 	}
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermInt.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermInt.java	Thu Dec 16 15:03:49 2010	(r21534)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermInt.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -1,5 +1,7 @@
 package org.spoofax.jsglr.shared.terms;
 
+import org.spoofax.jsglr.client.NotImplementedException;
+
 public class ATermInt extends ATerm {
 
 	private static final long serialVersionUID = 1L;
@@ -49,4 +51,9 @@
 		ATermInt a = (ATermInt)t;
 		return a.value == value;
 	}
+
+	@Override
+	public int hashCode() {
+		return value;
+	}
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java	Thu Dec 16 15:03:49 2010	(r21534)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -2,6 +2,8 @@
 
 import java.util.Iterator;
 
+import org.spoofax.jsglr.client.NotImplementedException;
+
 public class ATermList extends ATerm implements Iterable<ATerm> {
 
 	private static final long serialVersionUID = 1L;
@@ -123,4 +125,18 @@
 			b = b.next;
 		} while(true);
 	}
+	
+	@Override
+	public boolean equals(Object o) {
+		if (o == this)
+			return true;
+		if (o instanceof ATermAppl)
+			throw new NotImplementedException();
+		return false;
+	}
+	
+	@Override
+	public int hashCode() {
+		throw new NotImplementedException();
+	}
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermPlaceholder.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermPlaceholder.java	Thu Dec 16 15:03:49 2010	(r21534)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermPlaceholder.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -14,5 +14,9 @@
 	public int getType() {
 		return ATerm.PLACEHOLDER;
 	}
+	
+	public ATerm getPlaceholder() {
+		return getChildAt(0);
+	}
 
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermString.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermString.java	Thu Dec 16 15:03:49 2010	(r21534)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermString.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -1,6 +1,14 @@
 package org.spoofax.jsglr.shared.terms;
 
-public class ATermString extends ATerm {
+/**
+ * A String term.
+ * 
+ * For compatibility with the traditional ATerm library,
+ * this class extends ATermAppl.
+ * 
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class ATermString extends ATermAppl {
 
 	private static final long serialVersionUID = 1L;
 	
@@ -9,7 +17,7 @@
 	ATermString() {}
 	
 	ATermString(ATermFactory factory, String value) {
-		super(factory);
+		super(factory, null, ATermFactory.EMPTY);
 		this.value = value;
 	}
 	
@@ -17,6 +25,21 @@
 	public int getChildCount() {
 		return 0;
 	}
+	
+	public String getString() {
+		return value;
+	}
+	
+	@Deprecated
+	@Override
+	public String getName() {
+		return value;
+	}
+	
+	@Override
+	public AFun getAFun() {
+		throw new UnsupportedOperationException();
+	}
 
 	@Override
 	public ATerm getChildAt(int i) {
@@ -46,4 +69,9 @@
 		ATermString o = (ATermString)t;
 		return o.value.equals(value);
 	}
+	
+	@Override
+	public int hashCode() {
+		return value.hashCode();
+	}
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermTuple.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermTuple.java	Thu Dec 16 15:03:49 2010	(r21534)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermTuple.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -44,6 +44,21 @@
 
 	@Override
 	protected void toString(int depth, StringBuilder sb) {
+		if(depth == 0) {
+			sb.append("...");
+		} else {
+			sb.append('(');
+			for(int i = 0; i < elements.length; i++) {
+				if(i > 0)
+					sb.append(",");
+				elements[i].toString(depth - 1, sb);
+			}
+			sb.append(')');
+		}
+	}
+	
+	@Override
+	public int hashCode() {
 		throw new NotImplementedException();
 	}
 }

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/ATermImplodedTreeFactory.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/ATermImplodedTreeFactory.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -0,0 +1,107 @@
+package org.spoofax.jsglr.client;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.spoofax.jsglr.shared.terms.AFun;
+import org.spoofax.jsglr.shared.terms.ATerm;
+import org.spoofax.jsglr.shared.terms.ATermAppl;
+import org.spoofax.jsglr.shared.terms.ATermFactory;
+import org.spoofax.jsglr.shared.terms.ATermInt;
+import org.spoofax.jsglr.shared.terms.ATermList;
+import org.spoofax.jsglr.shared.terms.ATermString;
+import org.spoofax.jsglr.shared.terms.ATermTuple;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class ATermImplodedTreeFactory implements IImplodedTreeFactory<ATerm> {
+	
+	private final ATermFactory factory;
+	
+	public ATermImplodedTreeFactory() {
+		this(new ATermFactory());
+	}
+	
+	public ATermImplodedTreeFactory(ATermFactory factory) {
+		this.factory = factory;
+	}
+	
+	public AFun createConstructor(String name, int childCount) {
+		return factory.makeAFun(name, childCount, false);
+	}
+
+	public ATermAppl createNonTerminal(String sort, String constructor,
+			IToken leftToken, IToken rightToken, List<ATerm> children) {
+		
+		// TODO: Optimize - cache afuns? hard to do up front, messy to do now in the LabelInfo objects 
+		AFun afun = factory.makeAFun(constructor, children.size(), false);
+		ATermAppl result = factory.makeAppl(afun, toArray(children));
+		result.internalSetTokens(leftToken, rightToken);
+		return result;
+	}
+
+	public ATermInt createIntTerminal(String sort, IToken token, int value) {
+		ATermInt result = factory.makeInt(value);
+		result.internalSetTokens(token, token);
+		return result;
+	}
+
+	public ATerm createRealTerminal(String sort, IToken token, double value) {
+		throw new UnsupportedOperationException("ATermReal not supported");
+	}
+
+	public ATermString createStringTerminal(String sort, String value, IToken token) {
+		ATermString result = factory.makeString(value);
+		result.internalSetTokens(token, token);
+		return result;
+	}
+
+	public ATermTuple createTuple(String elementSort, IToken leftToken,
+			IToken rightToken, List<ATerm> children) {
+		
+		ATermTuple result = factory.makeTuple(toArray(children));
+		result.internalSetTokens(leftToken, rightToken);
+		return result;
+	}
+
+	public ATermAppl createAmb(List<ATerm> alternatives) {
+		IToken leftToken = alternatives.get(0).getLeftToken();
+		IToken rightToken = alternatives.get(alternatives.size() - 1).getRightToken();
+		return createNonTerminal(null, "amb", leftToken, rightToken, alternatives);
+	}
+
+	public ATermList createList(String elementSort, IToken leftToken,
+			IToken rightToken, List<ATerm> children) {
+		
+		ATermList result = factory.makeList(toArray(children));
+		result.internalSetTokens(leftToken, rightToken);
+		return result;
+	}
+
+	public boolean isStringTerminal(ATerm node) {
+		return node.getType() == ATerm.STRING;
+	}
+
+	public ATerm createInjection(String sort, List<ATerm> children) {
+		return children.get(0);
+	}
+
+	public Iterable<ATerm> getChildren(ATerm node) {
+		if (node instanceof Iterable<?>) {
+			@SuppressWarnings("unchecked")
+			Iterable<ATerm> result = (Iterable<ATerm>) node;
+			return result;
+		} else {
+			ArrayList<ATerm> children = new ArrayList<ATerm>(node.getChildCount());
+			for (int i = 0, max = node.getChildCount(); i < max; i++) {
+				children.add(node.getChildAt(i));
+			}
+			return children;
+		}
+	}
+
+	private static ATerm[] toArray(List<ATerm> children) {
+		return children.toArray(new ATerm[children.size()]);
+	}
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/AstAnnoImploder.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/AstAnnoImploder.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -0,0 +1,128 @@
+package org.spoofax.jsglr.client;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.spoofax.jsglr.shared.terms.ATerm;
+import org.spoofax.jsglr.shared.terms.ATermAppl;
+import org.spoofax.jsglr.shared.terms.ATermFactory;
+import org.spoofax.jsglr.shared.terms.ATermInt;
+import org.spoofax.jsglr.shared.terms.ATermList;
+import org.spoofax.jsglr.shared.terms.ATermPlaceholder;
+
+import static org.spoofax.jsglr.shared.Tools.*;
+
+
+/**
+ * Implodes {ast} annotations in asfix trees.
+ * 
+ * Note that this class assigns a null sort to all children
+ * of the constructed TNode.
+ * 
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class AstAnnoImploder<TNode> {
+
+	private final IImplodedTreeFactory<TNode> factory;
+	
+	private final List<TNode> placeholderValues;
+	
+	private final IToken leftToken, rightToken;
+	
+	private final ATermFactory termFactory;
+	
+	public AstAnnoImploder(IImplodedTreeFactory<TNode> factory, ATermFactory termFactory, List<TNode> placeholderValues, IToken leftToken, IToken rightToken) {
+		this.factory = factory;
+		this.termFactory = termFactory;
+		this.placeholderValues = placeholderValues;
+		this.leftToken = leftToken;
+		this.rightToken = rightToken;
+	}
+	
+	public TNode implode(ATerm ast, String sort) {
+		// Placeholder terms are represented as strings; must parse them and fill in their arguments
+		String astString = ast.toString();
+		if (astString.startsWith("\"") && astString.endsWith("\"")) {
+			astString = astString.substring(1, astString.length() - 1);
+			astString = astString.replace("\\\\", "\\").replace("\\\"", "\"");
+			ast = termFactory.parse(astString);
+		}
+		
+		return toNode(ast, sort);
+	}
+	
+	private TNode toNode(ATerm term, String sort) {
+		switch (term.getType()) {
+			case ATerm.PLACEHOLDER:
+				return placeholderToNode(term, sort);
+				
+			case ATerm.APPL:
+				return applToNode(term, sort);
+				
+			case ATerm.LIST:
+				return listToNode(term, sort);
+				
+			case ATerm.INT:
+				ATermInt i = (ATermInt) term;
+				return factory.createIntTerminal(sort, leftToken, i.getInt());
+				
+			/*
+			case ATerm.REAL:
+				ATermInt i = (ATermReal) term;
+				return factory.createRealTerminal(sort, leftToken, i.getReal());
+			*/
+				
+			default:
+				throw new IllegalStateException("Unexpected term type encountered in {ast} attribute");
+		}
+	}
+	
+	private TNode placeholderToNode(ATerm placeholder, String sort) {
+		ATerm term = ((ATermPlaceholder) placeholder).getPlaceholder();
+		if (term.getType() == ATerm.INT) {
+			int id = ((ATermInt) term).getInt();
+			if (1 <= id && id <= placeholderValues.size()) {
+				return placeholderValues.get(id - 1);
+			}
+		} else if (term.getType() == ATerm.APPL) {
+			String type = ((ATermAppl) term).getName();
+			if ("conc".equals(type) && term.getChildCount() == 2) {
+				TNode left = toNode(termAt(term, 0), null);
+				TNode right = toNode(termAt(term, 1), null);
+				List<TNode> children = new ArrayList<TNode>();
+				for (TNode node : factory.getChildren(left))
+					children.add(node);
+				for (TNode node : factory.getChildren(right))
+					children.add(node);
+				return factory.createList(sort, leftToken, rightToken, children);
+			} else if ("yield".equals(type) && term.getChildCount() == 1) {
+				throw new NotImplementedException("not implemented: yield in {ast} attribute");
+			}
+		}
+			
+		throw new IllegalStateException("Error in syntax definition: illegal placeholder in {ast} attribute: " + placeholder);
+	}
+	
+	private TNode applToNode(ATerm term, String sort) {
+		ATermAppl appl = (ATermAppl) term;
+		ArrayList<TNode> children = new ArrayList<TNode>(appl.getChildCount());
+		for (int i = 0; i < appl.getChildCount(); i++) {
+			children.add(toNode(termAt(appl, i), null));
+		}
+		if (appl.getType() == ATerm.STRING) {
+			return factory.createStringTerminal(sort, appl.getName(), leftToken);
+		} else {
+			return factory.createNonTerminal(sort, appl.getName(), leftToken, rightToken, children);
+		}
+	}
+	
+	private TNode listToNode(ATerm term, String sort) {
+		// TODO: Fishy (Spoofax/49)
+		ATermList list = (ATermList) term;
+		ArrayList<TNode> children = new ArrayList<TNode>(list.getChildCount());
+		for (int i = 0; i < term.getChildCount(); i++) {
+			children.add(toNode(termAt(term, i), null));
+		}
+		return factory.createList(sort, leftToken, rightToken, children);
+	}
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/BottomupTreeBuilder.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/BottomupTreeBuilder.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -0,0 +1,35 @@
+package org.spoofax.jsglr.client;
+
+
+/**
+ * An abstract bottom-up tree builder implementation.
+ *
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public abstract class BottomupTreeBuilder implements ITreeBuilder {
+
+	public void initialize(int productionCount, int labelCount) {
+		
+	}
+	
+	public Object buildTree(AbstractParseNode node) {
+		return node.toTreeBottomup(this);
+	}
+	
+	public void visitLabel(int labelNumber) {
+		
+	}
+	
+	public void endVisitLabel(int labelNumber) {
+		
+	}
+
+	public Object buildTreeTop(Object subtree, int ambiguityCount) {
+		return subtree;
+	}
+
+	public abstract Object buildNode(int labelNumber, Object[] subtrees);
+	public abstract Object buildProduction(int productionNumber);
+	public abstract Object buildAmb(Object[] alternatives);
+
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/DummyTokenizer.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/DummyTokenizer.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -0,0 +1,65 @@
+package org.spoofax.jsglr.client;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class DummyTokenizer implements ITokenizer {
+	
+	private final IToken onlyToken = new Token(this, 0, 0, 0, IToken.TK_UNKNOWN);
+	
+	private char[] inputChars;
+	
+	/**
+	 * @param inputChars
+	 *           The input characters (used for {indentpadding} productions
+	 *           and error recovery)
+	 */
+	public void initialize(char[] inputChars) {
+		this.inputChars = inputChars;
+	}
+
+	public char[] getInputChars() {
+		return inputChars;
+	}
+
+	public int getStartOffset() {
+		return 0;
+	}
+
+	public void setStartOffset(int startOffset) {
+		// Do nothing		
+	}
+
+	public IToken currentToken() {
+		return onlyToken;
+	}
+
+	public int getTokenCount() {
+		return 0;
+	}
+
+	public IToken getTokenAt(int i) {
+		return onlyToken;
+	}
+
+	public IToken makeToken(int offset, LabelInfo label) {
+		return onlyToken;
+	}
+
+	public IToken makeToken(int offset, LabelInfo label, boolean allowEmptyToken) {
+		return onlyToken;
+	}
+
+	public IToken makeToken(int offset, int kind, boolean allowEmptyToken) {
+		return onlyToken;
+	}
+
+	public IToken createSkippedToken(int offset, char inputChar, char prevChar) {
+		return onlyToken;
+	}
+
+	public void createLayoutToken(int offset, int lastOffset, LabelInfo label) {
+		// Do nothing
+	}
+
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/IImplodedTreeFactory.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/IImplodedTreeFactory.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -0,0 +1,50 @@
+package org.spoofax.jsglr.client;
+
+import java.util.List;
+
+
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public interface IImplodedTreeFactory<TNode> {
+
+	/**
+	 * Create a new non-terminal node (or a terminal with only a constructor).
+	 */
+	public TNode createNonTerminal(String sort, String constructor, IToken leftToken, IToken rightToken,
+			List<TNode> children);
+	
+	/**
+	 * Create a new terminal node for an int value.
+	 */
+	public TNode createIntTerminal(String sort, IToken token, int value);
+	
+	/**
+	 * Create a new terminal node for an real value.
+	 */
+	public TNode createRealTerminal(String sort, IToken token, double value);
+	
+	/**
+	 * Create a new terminal node for a string token.
+	 */
+	public TNode createStringTerminal(String sort, String value, IToken token);
+	
+	public TNode createTuple(String elementSort, IToken leftToken, IToken rightToken, List<TNode> children);
+	
+	/**
+	 * Create a new node list. 
+	 */
+	public TNode createList(String elementSort, IToken leftToken, IToken rightToken, List<TNode> children);
+
+	public TNode createAmb(List<TNode> alternatives);
+
+	/**
+	 * Create an injection node.
+	 */
+	public TNode createInjection(String sort, List<TNode> children);
+	
+	public boolean isStringTerminal(TNode node);
+	
+	public Iterable<TNode> getChildren(TNode node);
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/IToken.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/IToken.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -0,0 +1,50 @@
+package org.spoofax.jsglr.client;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public interface IToken {
+	/** Unknown token kind. */
+	public static final int TK_UNKNOWN = 0;
+	
+	/** Token kind for a generic identifier. */
+	public static final int TK_IDENTIFIER = 1;
+	
+	/** Token kind for a generic numeric value. */
+	public static final int TK_NUMBER = 2;
+	
+	/** Token kind for a generic string literal. */
+	public static final int TK_STRING = 3;
+	
+	/** Token kind for a generic keyword token. */
+	public static final int TK_KEYWORD = 4;
+	
+	/** Token kind for a generic keyword token. */
+	public static final int TK_OPERATOR = 5;
+	
+	/** Token kind for a meta-variable. */
+	public static final int TK_VAR = 6;
+	
+	/** Token kind for a layout (or comment) token. */
+	public static final int TK_LAYOUT = 7;
+	
+	/** Token kind for an EOF token. */
+	public static final int TK_EOF = 8;
+	
+	/** Token kind for an erroneous token. */
+	public static final int TK_ERROR = 9;
+	
+	public static final int TK_RESERVED = 10;
+	
+	int getKind();
+	
+	int getIndex();
+
+	int getStartOffset();
+
+	int getEndOffset();
+
+	int getLine();
+	
+	int getColumn();
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/ITokenStream.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/ITokenStream.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -0,0 +1,8 @@
+package org.spoofax.jsglr.client;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class ITokenStream {
+
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/ITokenizer.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/ITokenizer.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -0,0 +1,41 @@
+package org.spoofax.jsglr.client;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public interface ITokenizer {
+	
+	void initialize(char[] inputChars);
+
+	char[] getInputChars();
+
+	int getStartOffset();
+
+	void setStartOffset(int startOffset);
+
+	IToken currentToken();
+
+	int getTokenCount();
+
+	IToken getTokenAt(int i);
+
+	IToken makeToken(int offset, LabelInfo label);
+
+	IToken makeToken(int offset, LabelInfo label, boolean allowEmptyToken);
+
+	IToken makeToken(int offset, int kind, boolean allowEmptyToken);
+
+	/**
+	 * Creates an artificial token at keyword boundaries
+	 * inside skipped regions of code.
+	 * Required for keyword highlighting with {@link KeywordRecognizer}.
+	 */
+	IToken createSkippedToken(int offset, char inputChar, char prevChar);
+
+	/**
+	 * Creates an artificial token for every water-based recovery
+	 * and for comments within layout.
+	 */
+	void createLayoutToken(int offset, int lastOffset, LabelInfo label);
+
+}
\ No newline at end of file

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/ITreeBuilder.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/ITreeBuilder.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -0,0 +1,17 @@
+package org.spoofax.jsglr.client;
+
+import org.spoofax.jsglr.shared.terms.ATermAppl;
+
+public interface ITreeBuilder {
+
+	void initialize(ParseTable table, int productionCount, int labelStart, int labelCount);
+	void initializeLabel(int labelNumber, ATermAppl parseTreeProduction);
+	
+	Object buildTree(AbstractParseNode node);
+	Object buildTreeTop(Object subtree, int ambiguityCount);
+	
+	/**
+	 * Gets the tokenizer, if applicable, or null.
+	 */
+	ITokenizer getTokenizer();
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/ImplodedTreeBuilder.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/ImplodedTreeBuilder.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -0,0 +1,367 @@
+package org.spoofax.jsglr.client;
+
+import static java.lang.Math.max;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.spoofax.jsglr.shared.terms.ATermAppl;
+import org.spoofax.jsglr.shared.terms.ATermFactory;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+ at SuppressWarnings({"rawtypes", "unchecked"})
+public class ImplodedTreeBuilder extends TopdownTreeBuilder {
+	
+	public static final char SKIPPED_CHAR = (char) -1; // TODO: sync with ParseErorHandler
+	
+	public static final char UNEXPECTED_EOF_CHAR = (char) -2; // TODO: sync with ParseErorHandler
+	
+	private static final int NONE = -1;
+
+	private static final int EXPECTED_NODE_CHILDREN = 5;
+	
+	private static final String LIST_CONSTRUCTOR = new String("[]");
+	
+	private static final String TUPLE_CONSTRUCTOR = new String("");
+	
+	private final ITokenizer tokenizer;
+	
+	private IImplodedTreeFactory factory;
+	
+	private boolean useDefaultFactory;
+	
+	private ProductionAttributeReader prodReader;
+
+	private ATermFactory termFactory;
+	
+	private LabelInfo[] labels;
+	
+	private int labelStart;
+	
+	/** Character offset for the current implosion. */ 
+	private int offset;
+	
+	private int nonMatchingOffset = NONE;
+	
+	private char nonMatchingChar, nonMatchingCharExpected, prevChar;
+	
+	private boolean inLexicalContext;
+	
+	public ImplodedTreeBuilder() {
+		this(null, new Tokenizer());
+		this.useDefaultFactory = true;
+	}
+	
+	public ImplodedTreeBuilder(IImplodedTreeFactory treeFactory, ITokenizer tokenizer) {
+		this.factory = treeFactory;
+		this.tokenizer = tokenizer;
+	}
+
+	public void initialize(ParseTable table, int productionCount, int labelStart, int labelCount) {
+		this.termFactory = table.getFactory();
+		if (useDefaultFactory)
+			factory = new ATermImplodedTreeFactory(termFactory);
+		this.prodReader = new ProductionAttributeReader(termFactory);
+		this.labels = new LabelInfo[labelCount - labelStart];
+		this.labelStart = labelStart;
+	}
+
+	public void initializeLabel(int labelNumber, ATermAppl parseTreeProduction) {
+		labels[labelNumber - labelStart] = new LabelInfo(prodReader, parseTreeProduction);
+	}
+	
+	public ITokenizer getTokenizer() {
+		return tokenizer;
+	}
+	
+	/*
+	public void visitLabel(int labelNumber) {
+		LabelInfo label = labels[labelNumber - labelStart];
+		if (label.isLexical() || label.isVar())
+			lexicalContextDepth++;
+	}
+	
+	public void endVisitLabel(int labelNumber) {
+		LabelInfo label = labels[labelNumber - labelStart];
+		if (label.isLexical() || label.isVar())
+			lexicalContextDepth--;
+	}
+	*/
+	
+	@Override
+	protected Object buildTreeNode(ParseNode node) {
+		LabelInfo label = labels[node.label - labelStart];
+		IToken prevToken = tokenizer.currentToken();
+		int lastOffset = offset;
+		AbstractParseNode[] subnodes = node.getChildren();
+		
+		boolean lexicalStart = !inLexicalContext && label.isLexicalLiteralOrLayout();
+		if (lexicalStart) inLexicalContext = true;
+		
+		if (!inLexicalContext
+				&& subnodes.length > 0 && subnodes[0] instanceof ParseProductionNode
+				&& label.isSortProduction()
+				&& label.getLHS().getChildCount() == 1) {
+			return createIntTerminal(label, subnodes);
+		}
+		
+		boolean isVar  = !inLexicalContext && label.isVar();
+		if (isVar) inLexicalContext = true;
+		
+		// TODO: Optimize - one particularly gnarly optimization would be to reuse the subnodes array here
+		//                  and in buildTreeAmb
+		ArrayList<Object> children = null;
+		if (!inLexicalContext)
+			children = new ArrayList<Object>(max(EXPECTED_NODE_CHILDREN, subnodes.length));
+
+		// Recurse
+		for (AbstractParseNode subnode : subnodes) {
+			Object child = subnode.toTreeTopdown(this);
+			if (child != null) children.add(child);
+		}
+		
+		if (lexicalStart || isVar) {
+			return createStringTerminal(label);
+		} else if (inLexicalContext) {
+			tokenizer.createLayoutToken(offset, lastOffset, label);
+			return null; // don't create tokens inside lexical context; just create one big token at the top
+		} else {
+			return createNodeOrInjection(label, prevToken, children);
+		}
+	}
+
+	public Object buildTreeAmb(Amb a) {
+		final int oldOffset = offset;
+		final int oldBeginOffset = tokenizer.getStartOffset();
+		final boolean oldLexicalContext = inLexicalContext;
+		final AbstractParseNode[] subnodes = a.getAlternatives();
+		final ArrayList<Object> children =
+			new ArrayList<Object>(max(EXPECTED_NODE_CHILDREN, subnodes.length));
+
+		// Recurse
+		for (AbstractParseNode subnode : subnodes) {
+			// Restore lexical state for each branch
+			offset = oldOffset;
+			tokenizer.setStartOffset(oldBeginOffset);
+			inLexicalContext = oldLexicalContext;
+			
+			Object child = subnode.toTreeTopdown(this);
+			if (child != null) children.add(child);
+		}
+		return factory.createAmb(children);
+	}
+
+	public Object buildTreeProduction(ParseProductionNode node) {
+		int character = node.prod;
+		consumeLexicalChar(character);
+		return null;
+	}
+
+
+	private Object createStringTerminal(LabelInfo label) {
+		inLexicalContext = false;
+		String sort = label.getSort();
+		IToken token = tokenizer.makeToken(offset, label, sort != null);
+		
+		if (sort == null) return null;
+		
+		// Debug.log("Creating node ", sort, " from ", SGLRTokenizer.dumpToString(token));
+		
+		Object result = factory.createStringTerminal(sort, getPaddedLexicalValue(label, token), token);
+		String constructor = label.getMetaVarConstructor();
+		if (constructor != null) {
+			ArrayList<Object> children = new ArrayList<Object>(1);
+			children.add(result);
+			result = factory.createNonTerminal(sort, constructor, token, token, children);
+		}
+		return result;
+	}
+	
+	private Object createIntTerminal(LabelInfo label, AbstractParseNode[] contents) {
+		IToken token = tokenizer.makeToken(offset, label, true);
+		int value = contents.length == 1 && contents[0] instanceof ParseProductionNode
+			? ((ParseProductionNode) contents[0]).prod : -1;
+		assert value != -1;
+		return factory.createIntTerminal(label.getSort(), token, value);
+	}
+
+	private Object createNodeOrInjection(LabelInfo label, IToken prevToken, List<Object> children) {
+		
+		String constructor = label.getConstructor();
+		
+		if (label.isList()) {
+			return createNode(label, LIST_CONSTRUCTOR, prevToken, children);
+		} else if (constructor != null) {
+			tokenizer.makeToken(offset, label); // TODO: why makeToken here??
+			return createNode(label, constructor, prevToken, children);
+		} else if (label.getAstAttribute() != null) {
+			return createAstNonTerminal(label, prevToken, children);
+		} else if (label.isOptional()) {
+			// TODO: Spoofax/295: JSGLR does not output correct AST for optional literals
+			if (children.size() == 0) {
+				return createNode(label, "None", prevToken, children);
+			} else {
+				assert children.size() == 1;
+				return createNode(label, "Some", prevToken, children);
+			}
+		} else if (children.size() == 1) {
+			// Injection
+			// TODO: efficiently store injection sort for use by content completion?
+			//       would be needed to distinguish FoldingRules and Sorts in "folding" sections...
+			//       maybe only if the content proposer demands it?
+			// TODO: also, avoid semantics for deprecated?
+			return factory.createInjection(label.getSort(), children);
+		} else {
+			// Constructor-less application (tuple)
+			return createNode(label, TUPLE_CONSTRUCTOR, prevToken, children);
+		}
+	}
+
+	/**
+	 * Create a context-free tree node.
+	 * 
+	 * @param constructor
+	 *          The constructor to use, or {@link #LIST_CONSTRUCTOR} to construct a list,
+	 *          or {@link #TUPLE_CONSTRUCTOR} to construct a tuple.
+	 */
+	private Object createNode(LabelInfo label, String constructor, IToken prevToken,
+			List<Object> children) {
+		
+		IToken left = getStartToken(prevToken);
+		IToken right = getEndToken(left, tokenizer.currentToken());
+		
+		if (constructor == LIST_CONSTRUCTOR) {
+			return factory.createList(label.getSort(), left, right, children);
+		} else if (constructor == TUPLE_CONSTRUCTOR) {
+			return factory.createTuple(label.getSort(), left, right, children);
+		} else if (constructor == null && children.size() == 1 && factory.isStringTerminal(children.get(0))) {
+			// Child node was a <string> node (rare case); unpack it and create a new terminal
+			assert left == right;
+			return factory.createStringTerminal(label.getSort(), getPaddedLexicalValue(label, left), left);
+		} else {
+			return factory.createNonTerminal(label.getSort(), constructor, left, right, children);
+		}
+	}
+	
+	/**
+	 * Gets the padded lexical value for {indentpadding} lexicals, or returns null.
+	 */
+	private String getPaddedLexicalValue(LabelInfo label, IToken startToken) {
+		if (label.isIndentPaddingLexical()) {
+			char[] inputChars = tokenizer.getInputChars();
+			int lineStart = startToken.getStartOffset() - 1;
+			if (lineStart < 0) return null;
+			while (lineStart >= 0) {
+				char c = inputChars[lineStart--];
+				if (c == '\n' || c == '\r') {
+					lineStart++;
+					break;
+				}
+			}
+			StringBuilder result = new StringBuilder();
+			result.append(inputChars, lineStart, startToken.getStartOffset() - lineStart - 1);
+			for (int i = 0; i < result.length(); i++) {
+				char c = result.charAt(i);
+				if (c != ' ' && c != '\t') result.setCharAt(i, ' ');
+			}
+			result.append(startToken.toString());
+			return result.toString();
+		} else {
+			return null; // lazily load token string value
+		}
+	}
+
+	/** Implode a context-free node with an {ast} annotation. */
+	private Object createAstNonTerminal(LabelInfo label, IToken prevToken, List<Object> children) {
+		IToken left = getStartToken(prevToken);
+		IToken right = getEndToken(left, tokenizer.currentToken());
+		AstAnnoImploder imploder = new AstAnnoImploder<Object>(factory, termFactory, children, left, right);
+		return imploder.implode(label.getAstAttribute(), label.getSort());
+	}
+	
+	/** Get the token after the previous node's ending token, or null if N/A. */
+	private IToken getStartToken(IToken prevToken) {
+		if (prevToken == null) {
+			return tokenizer.getTokenCount() == 0
+				? null
+			    : tokenizer.getTokenAt(0);
+		} else {
+			int index = prevToken.getIndex();
+			
+			if (tokenizer.getTokenCount() - index <= 1) {
+				// Create new empty token
+				// HACK: Assume TK_LAYOUT kind for empty tokens in AST nodes
+				return tokenizer.makeToken(offset, IToken.TK_LAYOUT, true);
+			} else {
+				return tokenizer.getTokenAt(index + 1); 
+			}
+		}
+	}
+	
+	/** Get the last no-layout token for an AST node. */
+	private IToken getEndToken(IToken startToken, IToken lastToken) {
+		int begin = startToken.getIndex();
+		
+		for (int i = lastToken.getIndex(); i > begin; i--) {
+			lastToken = tokenizer.getTokenAt(i);
+			if (lastToken.getKind() != IToken.TK_LAYOUT
+					|| lastToken.getStartOffset() == lastToken.getEndOffset()-1)
+				break;
+		}
+		
+		return lastToken;
+	}
+	
+	/** Consume a character of a lexical terminal. */
+	protected final void consumeLexicalChar(int character) {
+		char[] inputChars = tokenizer.getInputChars();
+		if (offset >= inputChars.length) {
+			if (nonMatchingOffset != NONE) {
+				assert false : "Character in parse tree after end of input stream: "
+						+ (char) character
+						+ " - may be caused by unexcepted character in parse tree at position "
+						+ nonMatchingChar 	+ ": " + nonMatchingChar + " instead of "
+						+ nonMatchingCharExpected;
+			}
+		    // UNDONE: Strict lexical stream checking
+			// throw new ImploderException("Character in parse tree after end of input stream: " + (char) character.getInt());
+			// a forced reduction may have added some extra characters to the tree;
+			inputChars[inputChars.length - 1] = UNEXPECTED_EOF_CHAR;
+			return;
+		}
+		
+		char parsedChar = (char) character;
+		char inputChar = inputChars[offset];
+		
+		if (parsedChar != inputChar) {
+			if (RecoveryConnector.isLayoutCharacter(parsedChar)) {
+				// Remember that the parser skipped the current character
+				// for later error reporting. (Cannot modify the immutable
+				// parse tree here; changing the original stream instead.)
+				inputChars[offset] = SKIPPED_CHAR;
+				tokenizer.createSkippedToken(offset, inputChar, prevChar);
+				offset++;
+			} else {
+				// UNDONE: Strict lexical stream checking
+				// throw new IllegalStateException("Character from asfix stream (" + parsedChar
+				//	 	+ ") must be in lex stream (" + inputChar + ")");
+			    // instead, we allow the non-matching character for now, and hope
+			    // we can pick up the right track later
+				// TODO: better way to report skipped fragments in the parser
+				//       this isn't 100% reliable
+				if (nonMatchingOffset == NONE) {
+					nonMatchingOffset = offset;
+					nonMatchingChar = parsedChar;
+					nonMatchingCharExpected = inputChar;
+				}
+				inputChars[offset] = SKIPPED_CHAR;
+			}
+		} else {
+			offset++;
+		}
+		prevChar = inputChar;
+	}
+
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/LabelInfo.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/LabelInfo.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -0,0 +1,131 @@
+package org.spoofax.jsglr.client;
+
+import static org.spoofax.jsglr.shared.Tools.termAt;
+
+import org.spoofax.jsglr.shared.terms.ATerm;
+import org.spoofax.jsglr.shared.terms.ATermAppl;
+import org.spoofax.jsglr.shared.terms.ATermList;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class LabelInfo {
+	
+	private final ProductionAttributeReader reader;
+
+	private final ATermAppl production;
+	
+	private final String sort;
+	
+	private final String constructor;
+	
+	private final ATerm astAttribute;
+	
+	private final boolean isLexicalLiteralOrLayout;
+	
+	private final boolean isLexical;
+
+	private final boolean isVar;
+
+	private final boolean isList;
+
+	private final boolean isIndentPaddingLexical;
+	
+	private final boolean isLexLayout;
+	
+	private final boolean isSortProduction;
+
+	private final boolean isLayout;
+	
+	private final boolean isLiteral;
+	
+	private final String metaVarConstructor;
+	
+	public LabelInfo(ProductionAttributeReader reader, ATermAppl production) {
+		this.production = production;
+		this.reader = reader;
+		ATermAppl rhs = getRHS();
+		ATermAppl attrs = getAttrs();
+		sort = reader.getSort(rhs);
+		constructor = reader.getConsAttribute(attrs);
+		astAttribute = reader.getAstAttribute(attrs);
+		isLexicalLiteralOrLayout = reader.isLexicalLiteralOrLayout(rhs);
+		isList = reader.isList(rhs);
+		isVar = reader.isVariableNode(rhs);
+		isIndentPaddingLexical = reader.isIndentPaddingLexical(attrs);
+		isLexLayout = reader.isLexLayout(rhs);
+		isLexical = reader.isLexical(rhs);
+		isLayout = reader.isLayout(rhs);
+		isLiteral = reader.isLiteral(rhs);
+		isSortProduction = reader.sortFun == rhs.getAFun() || reader.parameterizedSortFun == rhs.getAFun();
+		metaVarConstructor = reader.getMetaVarConstructor(rhs);
+	}
+    
+	protected ATermList getLHS() {
+    	return termAt(production, 0);
+    }
+    
+	protected ATermAppl getRHS() {
+    	return termAt(production, 1);
+    }
+    
+	protected ATermAppl getAttrs() {
+    	return termAt(production, 2);
+    }
+	
+	public String getSort() {
+		return sort;
+	}
+	
+	public String getConstructor() {
+		return constructor;
+	}
+	
+	public ATerm getAstAttribute() {
+		return astAttribute;
+	}
+	
+	public boolean isLexicalLiteralOrLayout() {
+		return isLexicalLiteralOrLayout;
+	}
+	
+	public boolean isLexical() {
+		return isLexical;
+	}
+	
+	public boolean isList() {
+		return isList;
+	}
+	
+	public boolean isVar() {
+		return isVar;
+	}
+	
+	public boolean isIndentPaddingLexical() {
+		return isIndentPaddingLexical;
+	}
+	
+	public boolean isLexLayout() {
+		return isLexLayout;
+	}
+	
+	public boolean isLayout() {
+		return isLayout;
+	}
+	
+	public boolean isLiteral() {
+		return isLiteral;
+	}
+	
+	public boolean isSortProduction() {
+		return isSortProduction;
+	}
+	
+	public String getMetaVarConstructor() {
+		return metaVarConstructor;
+	}
+
+	public boolean isOptional() {
+		return reader.isOptional(getRHS());
+	}
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/ProductionAttributeReader.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/ProductionAttributeReader.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -0,0 +1,265 @@
+package org.spoofax.jsglr.client;
+
+import static org.spoofax.jsglr.shared.Tools.applAt;
+import static org.spoofax.jsglr.shared.Tools.asAppl;
+import static org.spoofax.jsglr.shared.Tools.asJavaString;
+import static org.spoofax.jsglr.shared.Tools.isAppl;
+import static org.spoofax.jsglr.shared.Tools.termAt;
+
+import org.spoofax.jsglr.shared.terms.AFun;
+import org.spoofax.jsglr.shared.terms.ATerm;
+import org.spoofax.jsglr.shared.terms.ATermAppl;
+import org.spoofax.jsglr.shared.terms.ATermFactory;
+import org.spoofax.jsglr.shared.terms.ATermList;
+
+
+/**
+ * Extracts attributes from parse table productions.
+ * 
+ * @author Lennart Kats <L.C.L.Kats add tudelft.nl>
+ */
+public class ProductionAttributeReader {
+	
+	private final int PARAMETRIZED_SORT_NAME = 0;
+	
+	private final int PARAMETRIZED_SORT_ARGS = 1;
+	
+	private final int ALT_SORT_LEFT = 0;
+	
+	private final int ALT_SORT_RIGHT = 1;
+	
+	protected final AFun sortFun;
+	
+	protected final AFun parameterizedSortFun;
+	
+	protected final AFun attrsFun;
+	
+	protected final AFun noAttrsFun;
+	
+	protected final AFun preferFun;
+	
+	protected final AFun avoidFun;
+	
+	private final AFun varSymFun;
+	
+	private final AFun altFun;
+	
+	private final AFun charClassFun;
+	
+	private final AFun litFun;
+	
+	private final AFun cilitFun;
+	
+	private final AFun lexFun;
+	
+	private final AFun optFun;
+	
+	private final AFun layoutFun;
+	
+	private final AFun cfFun;
+	
+	private final AFun varsymFun;
+	
+	private final AFun seqFun;
+	
+	private final AFun iterFun;
+	
+	private final AFun iterStarFun;
+	
+	private final AFun iterPlusFun;
+	
+	private final AFun iterSepFun;
+	
+	private final AFun iterStarSepFun;
+	
+	private final AFun iterPlusSepFun;
+	
+	public ProductionAttributeReader(ATermFactory factory) {
+		sortFun = factory.makeAFun("sort", 1, false);
+		parameterizedSortFun =
+			factory.makeAFun("parameterized-sort", 2, false);
+		attrsFun = factory.makeAFun("attrs", 1, false);
+		noAttrsFun = factory.makeAFun("no-attrs", 0, false);
+		preferFun = factory.makeAFun("prefer", 0, false);
+		avoidFun = factory.makeAFun("avoid", 0, false);
+		varSymFun = factory.makeAFun("varsym", 1, false);
+		altFun = factory.makeAFun("alt", 2, false);
+		charClassFun = factory.makeAFun("char-class", 1, false);
+		litFun = factory.makeAFun("lit", 1, false);
+		cilitFun = factory.makeAFun("cilit", 1, false);
+		lexFun = factory.makeAFun("lex", 1, false);
+		optFun = factory.makeAFun("opt", 1, false);
+		layoutFun = factory.makeAFun("layout", 0, false);
+		cfFun = factory.makeAFun("cf", 1, false);
+		varsymFun = factory.makeAFun("varsym", 1, false);
+		seqFun = factory.makeAFun("seq", 2, false);
+		iterFun = factory.makeAFun("iter", 1, false);
+		iterStarFun = factory.makeAFun("iter-star", 1, false);
+		iterPlusFun = factory.makeAFun("iter-plus", 1, false);
+		iterSepFun = factory.makeAFun("iter-sep", 2, false);
+		iterStarSepFun = factory.makeAFun("iter-star-sep", 2, false);
+		iterPlusSepFun = factory.makeAFun("iter-plus-sep", 2, false);
+	}
+
+	public String getConsAttribute(ATermAppl attrs) {
+		ATerm consAttr = getAttribute(attrs, "cons");
+		return consAttr == null ? null : ((ATermAppl) consAttr).getName();
+	}
+	
+	// FIXME: support meta-var constructors
+	public String getMetaVarConstructor(ATermAppl rhs) {
+		if (rhs.getChildCount() == 1 && varSymFun == rhs.getAFun()) {
+			return isIterFun(((ATermAppl) rhs.getChildAt(0)).getAFun())
+					? "meta-listvar"
+					: "meta-var";
+		}
+		return null;
+	}
+	
+	public ATerm getAstAttribute(ATermAppl attrs) {
+		return getAttribute(attrs, "ast");
+	}
+	
+	public boolean isIndentPaddingLexical(ATermAppl attrs) {
+		return getAttribute(attrs, "indentpadding") != null;
+	}
+
+	/** Return the contents of a term attribute (e.g., "cons"), or null if not found. */
+	public ATerm getAttribute(ATermAppl attrs, String attrName) {
+		if (attrs.getAFun() == noAttrsFun)
+			return null;
+		
+		ATermList list = termAt(attrs, 0);
+		
+		for (ATerm attr : list) {			
+			if (attr instanceof ATermAppl) {
+				ATermAppl namedAttr = (ATermAppl) attr;
+				if (namedAttr.getName().equals("term")) {
+					namedAttr = termAt(namedAttr, 0);
+					
+					if (namedAttr.getName().equals(attrName))
+						return namedAttr.getChildCount() == 1 ? termAt(namedAttr, 0) : namedAttr;
+				}				
+			}
+		}
+		
+		return null; // no cons found
+	}
+	
+	/** 
+	 * Get the RTG sort name of a production RHS, or for lists, the RTG element sort name.
+	 */
+    public String getSort(ATermAppl rhs) {
+    	for (ATerm current = rhs; current.getChildCount() > 0 && isAppl(current); current = termAt(current, 0)) {
+    		AFun cons = asAppl(current).getAFun();
+			if (cons == sortFun)
+    			return asJavaString(termAt(current, 0));
+    		if (cons == parameterizedSortFun)
+    			return getParameterizedSortName(current);
+    		if (cons == charClassFun)
+    			return null;
+    		if (cons == altFun)
+    			return getAltSortName(current);
+    	}
+    	
+    	return null;
+    }
+    
+    private String getParameterizedSortName(ATerm node) {
+    	StringBuilder result = new StringBuilder();
+    	
+    	result.append(applAt(node, PARAMETRIZED_SORT_NAME).getName());
+    	result.append('_');
+    	
+		ATermList args = termAt(node, PARAMETRIZED_SORT_ARGS);
+		
+        for (ATermAppl arg = (ATermAppl) args.getFirst(); !args.getNext().isEmpty(); args = args.getNext()) {
+			result.append(arg.getName());
+		}
+		
+		return result.toString();
+    }
+    
+    private String getAltSortName(ATerm node) {
+		String left = getSort(applAt(node, ALT_SORT_LEFT));
+		String right = getSort(applAt(node, ALT_SORT_RIGHT));
+		
+		// HACK: In the RTG, alt sorts appear with a number at the end
+		return left + "_" + right + "0";
+    }
+
+	/**
+	 * Identifies lexical parse tree nodes.
+	 * 
+	 * @see AsfixAnalyzer#isVariableNode(ATermAppl)
+	 *      Identifies variables, which are usually treated similarly to
+	 *      lexical nodes.
+	 * 
+	 * @return true if the current node is lexical.
+	 */
+	public boolean isLexicalLiteralOrLayout(ATermAppl rhs) {
+		return (lexFun == rhs.getAFun() || isLiteral(rhs)
+		    || isLayout(rhs));
+	}
+	
+	public boolean isLexical(ATermAppl rhs) {
+		return lexFun == rhs.getAFun();
+	}
+
+	public boolean isLayout(ATermAppl rhs) {
+		ATerm details = termAt(rhs, 0);
+		if (!isAppl(details))
+			return false;
+		
+		if (optFun == asAppl(details).getAFun())
+			details = applAt(details, 0);
+		
+		return layoutFun == asAppl(details).getAFun();
+	}
+
+	public boolean isLiteral(ATermAppl rhs) {
+		AFun fun = rhs.getAFun();
+		return litFun == fun || cilitFun == fun;
+	}
+	
+	public boolean isList(ATermAppl rhs) {
+		ATermAppl details = cfFun == rhs.getAFun()
+		                  ? applAt(rhs, 0)
+		                  : rhs;
+		              	
+	  	if (details.getAFun() == optFun)
+	  		details = applAt(details, 0);
+	  	
+		AFun fun = details.getAFun();
+		
+		 // FIXME: Spoofax/159: AsfixImploder creates tuples instead of lists for seqs
+		return isIterFun(fun) || seqFun == fun;
+	}
+
+	public boolean isIterFun(AFun fun) {
+		return iterFun == fun || iterStarFun == fun || iterPlusFun == fun
+				|| iterSepFun == fun || iterStarSepFun == fun || iterPlusSepFun == fun;
+	}
+
+	/**
+	 * Identifies parse tree nodes that begin variables.
+	 * 
+	 * @see #isVariableNode(ATermAppl) 
+	 * @return true if the current node is lexical.
+	 */
+	public boolean isVariableNode(ATermAppl rhs) {
+		return varsymFun == rhs.getAFun();
+	}
+
+	public boolean isLexLayout(ATermAppl rhs) {
+		if (rhs.getChildCount() != 1) return false;
+		ATerm child = rhs.getChildAt(0);
+		return isAppl(child) && layoutFun == ((ATermAppl) child).getAFun()
+			&& lexFun == rhs.getAFun();
+	}
+
+	public boolean isOptional(ATermAppl rhs) {
+		return rhs.getAFun() == optFun;
+	}
+
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/Token.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/Token.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -0,0 +1,46 @@
+package org.spoofax.jsglr.client;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class Token implements IToken {
+
+	private final ITokenizer tokenizer;
+	
+	private final int index, startOffset, endOffset, kind;
+
+	public Token(ITokenizer tokenizer, int index, int startOffset, int endOffset, int kind) {
+		this.tokenizer = tokenizer;
+		this.index = index;
+		this.startOffset = startOffset;
+		this.endOffset = endOffset;
+		this.kind = kind;
+	}
+	
+	public int getKind() {
+		return kind;
+	}
+
+	public int getIndex() {
+		return index;
+	}
+
+	public int getStartOffset() {
+		return startOffset;
+	}
+
+	public int getEndOffset() {
+		return endOffset;
+	}
+
+	public int getLine() {
+		// TODO
+		throw new NotImplementedException();
+	}
+	
+	public int getColumn() {
+		// TODO
+		throw new NotImplementedException();
+	}
+
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/TokenKindManager.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/TokenKindManager.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -0,0 +1,135 @@
+package org.spoofax.jsglr.client;
+
+import static org.spoofax.jsglr.client.IToken.TK_IDENTIFIER;
+import static org.spoofax.jsglr.client.IToken.TK_KEYWORD;
+import static org.spoofax.jsglr.client.IToken.TK_LAYOUT;
+import static org.spoofax.jsglr.client.IToken.TK_NUMBER;
+import static org.spoofax.jsglr.client.IToken.TK_OPERATOR;
+import static org.spoofax.jsglr.client.IToken.TK_STRING;
+import static org.spoofax.jsglr.client.IToken.TK_VAR;
+import static org.spoofax.jsglr.shared.Tools.applAt;
+import static org.spoofax.jsglr.shared.Tools.asAppl;
+import static org.spoofax.jsglr.shared.Tools.intAt;
+import static org.spoofax.jsglr.shared.Tools.isAppl;
+import static org.spoofax.jsglr.shared.Tools.termAt;
+
+import org.spoofax.jsglr.shared.terms.ATerm;
+import org.spoofax.jsglr.shared.terms.ATermAppl;
+
+/**
+ * Class that handles producing and printing token kinds.
+ * 
+ * @note May be overridden for specific grammars.
+ * 
+ * @see TokenKind
+ * 
+ * @author Lennart Kats <L.C.L.Kats add tudelft.nl>
+ */
+public class TokenKindManager {
+	private static final int RANGE_START = 0;
+	
+	private static final int RANGE_END = 1;
+	
+	// General token kind information
+	
+	/**
+	 * Get the token kind for a given sort.
+	 */
+	public int getTokenKind(LabelInfo label) {
+		// TODO: Optimization - cache token kind info in LabelInfo
+		
+		if (label.isLayout()) {
+			return TK_LAYOUT;
+		} else if (label.isLexical()) {
+			if (isStringLiteral(label)) {
+				return TK_STRING;
+			} else if (isNumberLiteral(label)) {
+				return TK_NUMBER;
+			} else {
+				return TK_IDENTIFIER;
+			}
+		} else if (label.isVar()) {
+			return TK_VAR;
+		} else if (isOperator(label)) {
+			return TK_OPERATOR;
+		} else {
+			return TK_KEYWORD;
+		}
+	}
+
+	protected static boolean isOperator(LabelInfo label) {
+		if (!label.isLiteral()) return false;
+		
+		ATermAppl lit = applAt(label.getRHS(), 0);
+		String contents = lit.getName();
+		
+		for (int i = 0; i < contents.length(); i++) {
+			char c = contents.charAt(i);
+			if (Character.isLetter(c)) return false;
+		}
+		
+		return true;
+	}
+	
+	/**
+	 * Determines whether the given string could possibly 
+	 * be a keyword (as opposed to an operator).
+	 */
+	protected static boolean isKeyword(String literal) {
+		for (int i = 0, end = literal.length(); i < end; i++) {
+			char c = literal.charAt(i);
+			if (!isKeywordChar(c))
+				return false;
+		}
+		return true;
+	}
+	
+	/**
+	 * Determines whether the given character could possibly 
+	 * be part of a keyword (as opposed to an operator).
+	 */
+	protected static boolean isKeywordChar(char c) {
+		return Character.isLetterOrDigit(c) || c == '_';
+	}
+	
+	protected static boolean isStringLiteral(LabelInfo label) {
+		return topdownHasSpaces(label.getRHS());
+	}
+	
+	private static boolean topdownHasSpaces(ATerm term) {
+		// Return true if any character range of this contains spaces
+		for (int i = 0; i < term.getChildCount(); i++) {
+			ATerm child = termAt(term, i);
+			if (isAppl(child) && asAppl(child).getName().equals("range")) {
+				int start = intAt(child, RANGE_START);
+				int end = intAt(child, RANGE_END);
+				if (start <= ' ' && ' ' <= end) return true;
+			} else {
+				if (topdownHasSpaces(child)) return true;
+			}
+		}
+		
+		return false;
+	}
+	
+	protected static boolean isNumberLiteral(LabelInfo label) {
+		ATerm range = getFirstRange(label.getLHS());
+		
+		return range != null && intAt(range, RANGE_START) == '0' && intAt(range, RANGE_END) == '9';
+	}
+	
+	private static ATerm getFirstRange(ATerm term) {
+		// Get very first character range in this term
+		for (int i = 0; i < term.getChildCount(); i++) {
+			ATerm child = termAt(term, i);
+			if (isAppl(child) && asAppl(child).getName().equals("range")) {
+				return child;
+			} else {
+				child = getFirstRange(child);
+				if (child != null) return child;
+			}
+		}
+		
+		return null;
+	}
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/Tokenizer.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/Tokenizer.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -0,0 +1,125 @@
+package org.spoofax.jsglr.client;
+
+import static org.spoofax.jsglr.client.IToken.*;
+
+import java.util.ArrayList;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class Tokenizer implements ITokenizer {
+	
+	private static final int EXPECTED_TOKENS_DIVIDER = 5;
+	
+	private final TokenKindManager manager =
+		new TokenKindManager();
+	
+	private char[] inputChars;
+	
+	/** Start of the next token. */
+	private int startOffset;
+
+	private ArrayList<IToken> tokens;
+	
+	public void initialize(char[] inputChars) {
+		this.inputChars = inputChars;
+		this.tokens = new ArrayList<IToken>(inputChars.length / EXPECTED_TOKENS_DIVIDER);
+		startOffset = 0;
+	}
+	
+	public final char[] getInputChars() {
+		return inputChars;
+	}
+	
+	public final int getStartOffset() {
+		return startOffset;
+	}
+
+	public void setStartOffset(int startOffset) {
+		this.startOffset = startOffset;
+	}
+
+	public IToken currentToken() {
+		return tokens.size() == 0
+			? null
+			:tokens.get(tokens.size() - 1);
+	}
+	
+	public int getTokenCount() {
+		return tokens.size();
+	}
+	
+	public IToken getTokenAt(int i) {
+		return tokens.get(i);
+	}
+
+	public IToken makeToken(int offset, LabelInfo label) {
+		return makeToken(offset, label, false);
+	}
+
+	public IToken makeToken(int endOffset, LabelInfo label, boolean allowEmptyToken) {
+		return makeToken(endOffset, manager.getTokenKind(label), allowEmptyToken);
+	}
+	
+	public IToken makeToken(int endOffset, int kind, boolean allowEmptyToken) {
+		if (!allowEmptyToken && startOffset >= endOffset) // empty token
+			return null;
+		
+		assert endOffset >= startOffset || (kind == TK_RESERVED && startOffset == 0);
+		IToken result = new Token(this, tokens.size() - 1, endOffset, endOffset, kind);
+		tokens.add(result);
+		return result;
+	}
+
+	/**
+	 * Creates an artificial token at keyword boundaries
+	 * inside skipped regions of code.
+	 * Required for keyword highlighting with {@link KeywordRecognizer}.
+	 */
+	public IToken createSkippedToken(int offset, char inputChar, char prevChar) {
+		boolean isInputKeywordChar = isKeywordChar(inputChar);
+		if (offset > 0 && offset - 1 > getStartOffset()) {
+			if ((isInputKeywordChar && !isKeywordChar(prevChar))
+					|| (!isInputKeywordChar && isKeywordChar(prevChar))) {
+				return makeToken(offset - 1, TK_ERROR, false);
+			}
+		}
+		if (offset + 1 < inputChars.length) {
+			char nextChar = inputChars[offset + 1];
+			if ((isInputKeywordChar && !isKeywordChar(nextChar))
+					|| (!isInputKeywordChar && isKeywordChar(nextChar))) {
+				return makeToken(offset + 1, TK_ERROR, false);
+			}
+		}
+		return null;
+	}
+	
+	/**
+	 * Determines whether the given character could possibly 
+	 * be part of a keyword (as opposed to an operator).
+	 */
+	private boolean isKeywordChar(char c) {
+		return Character.isLetterOrDigit(c) || c == '_';
+	}
+
+	/**
+	 * Creates an artificial token for every water-based recovery
+	 * and for comments within layout.
+	 */
+	public void createLayoutToken(int offset, int lastOffset, LabelInfo label) {
+		// Create separate tokens for >1 char layout lexicals (e.g., comments)
+		if (offset > lastOffset + 1 && label.isLexLayout()) {
+			if (startOffset <= lastOffset)
+				makeToken(lastOffset, TK_LAYOUT, false);
+			makeToken(offset, TK_LAYOUT, false);
+		} else {
+			String sort = label.getSort();
+			if ("WATERTOKEN".equals(sort) || "WATERTOKENSEPARATOR".equals(sort)) {
+				if (getStartOffset() <= lastOffset)
+					makeToken(lastOffset, TK_LAYOUT, false);
+				makeToken(offset, TK_ERROR, false);
+			}
+		}
+	}
+
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/TopdownTreeBuilder.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/TopdownTreeBuilder.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -0,0 +1,40 @@
+package org.spoofax.jsglr.client;
+
+/**
+ * An abstract top-down tree builder implementation.
+ * For most uses, the bottom-up one should be more suitable.
+ * 
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public abstract class TopdownTreeBuilder implements ITreeBuilder {
+
+	public void initialize(int productionCount, int labelCount) {
+		
+	}
+
+	/**
+	 * @deprecated
+	 *   For a best balance of performance and stack consumption, directly call
+	 *   {@link ParseNode#buildTreeBottomup} instead.
+	 */
+	public final Object buildTree(AbstractParseNode node) {
+		if (node instanceof ParseNode) {
+			return buildTreeNode((ParseNode) node);
+		} else if (node instanceof ParseProductionNode) {
+			return buildTreeProduction((ParseProductionNode) node);
+		} else {
+			assert node instanceof Amb;
+			return buildTreeAmb((Amb) node);
+		}
+	}
+
+	public Object buildTreeTop(Object subtree, int ambiguityCount) {
+		return subtree;
+	}
+
+	protected abstract Object buildTreeNode(ParseNode node);
+
+	protected abstract Object buildTreeProduction(ParseProductionNode node);
+
+	protected abstract Object buildTreeAmb(Amb node);
+}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:03:49 2010	(r21534)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -16,6 +16,7 @@
 import org.spoofax.jsglr.client.PathListPool;
 import org.spoofax.jsglr.client.PooledPathList;
 import org.spoofax.jsglr.client.SGLR;
+import org.spoofax.jsglr.shared.SGLRException;
 import org.spoofax.jsglr.shared.Tools;
 import org.spoofax.jsglr.shared.terms.ATerm;
 import org.spoofax.jsglr.shared.terms.ATermFactory;
@@ -74,7 +75,7 @@
 		sglr.clear();
 	}
 
-	final static boolean doCompare = true;
+	boolean doCompare = true;
 	public void doParseTest(final String s) {
 
 		//		parseTableService.fetchText("tests/data/" + s + "." + suffix,
@@ -93,19 +94,17 @@
 		ATerm parsed = null;
 		try {
 			parsed = (ATerm) sglr.parse(result);
-		} catch (final Exception e) {
+		} catch (SGLRException e) {
 			e.printStackTrace();
-			fail(e.toString());
+			throw new RuntimeException(e);
 		}
 		parseTime = System.nanoTime() - parseTime;
 		System.out.println("Parsing " + s + " took " + parseTime/1000/1000 + " millis.");
 		assertNotNull(parsed);
-		if(doCompare)
-		{
+		if (doCompare) {
 			doCompare(s, parsed);
-			//			}
-			//
-			//		});
+		} else {
+			System.out.println(parsed);
 		}
 
 		System.out.println(PathListPool.cacheMisses);

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestImplode.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestImplode.java	Thu Dec 16 15:03:58 2010	(r21535)
@@ -0,0 +1,35 @@
+package org.spoofax.jsglr.tests;
+
+import java.io.FileNotFoundException;
+import java.io.IOException;
+
+import org.spoofax.jsglr.client.ImplodedTreeBuilder;
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParserException;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class TestImplode extends ParseTestCase {
+
+    @Override
+	public void gwtSetUp() throws ParserException, InvalidParseTableException {
+        super.gwtSetUp("Java-15", "java");
+        sglr.setTreeBuilder(new ImplodedTreeBuilder());
+        // TODO: compare results
+        doCompare = false;
+    }
+
+    public void testJava0() throws FileNotFoundException, IOException {
+    	doParseTest("java0");
+    }
+    
+    public void testJava2() throws FileNotFoundException, IOException {
+    	doParseTest("java2");
+    }
+
+    public void testJava4() throws FileNotFoundException, IOException {
+    	doParseTest("java4");
+    }
+    
+}

From karltk at strategoxt.org  Thu Dec 16 16:04:08 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:04:08 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21536 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt: src/org/spoofax/jsglr/client
	src/org/spoofax/jsglr/client/imploder
	src/org/spoofax/jsglr/shared/terms test/org/spoofax/jsg...
Message-ID: <201012161504.oBGF48vj027388@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:04:08 2010
New Revision: 21536
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21536&sc=1

Log:
Relocated source files.

Added:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/BottomupTreeBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ITreeBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ATermImplodedTreeFactory.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/AstAnnoImploder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/DummyTokenizer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/IImplodedTreeFactory.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/IToken.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITokenizer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ImplodedTreeBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/LabelInfo.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ProductionAttributeReader.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Token.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TokenKindManager.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Tokenizer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TopdownTreeBuilder.java
Deleted:
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/client/
Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/AbstractParseNode.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Asfix2TreeBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseProductionNode.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestImplode.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/AbstractParseNode.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/AbstractParseNode.java	Thu Dec 16 15:03:58 2010	(r21535)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/AbstractParseNode.java	Thu Dec 16 15:04:08 2010	(r21536)
@@ -7,6 +7,8 @@
  */
 package org.spoofax.jsglr.client;
 
+import org.spoofax.jsglr.client.imploder.TopdownTreeBuilder;
+
 
 public abstract class AbstractParseNode {
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java	Thu Dec 16 15:03:58 2010	(r21535)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java	Thu Dec 16 15:04:08 2010	(r21536)
@@ -10,6 +10,8 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import org.spoofax.jsglr.client.imploder.TopdownTreeBuilder;
+
 
 public class Amb extends AbstractParseNode {
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Asfix2TreeBuilder.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Asfix2TreeBuilder.java	Thu Dec 16 15:03:58 2010	(r21535)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Asfix2TreeBuilder.java	Thu Dec 16 15:04:08 2010	(r21536)
@@ -1,5 +1,6 @@
 package org.spoofax.jsglr.client;
 
+import org.spoofax.jsglr.client.imploder.ITokenizer;
 import org.spoofax.jsglr.shared.terms.AFun;
 import org.spoofax.jsglr.shared.terms.ATerm;
 import org.spoofax.jsglr.shared.terms.ATermAppl;

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/BottomupTreeBuilder.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/BottomupTreeBuilder.java	Thu Dec 16 15:04:08 2010	(r21536)
@@ -0,0 +1,35 @@
+package org.spoofax.jsglr.client;
+
+
+/**
+ * An abstract bottom-up tree builder implementation.
+ *
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public abstract class BottomupTreeBuilder implements ITreeBuilder {
+
+	public void initialize(int productionCount, int labelCount) {
+		
+	}
+	
+	public Object buildTree(AbstractParseNode node) {
+		return node.toTreeBottomup(this);
+	}
+	
+	public void visitLabel(int labelNumber) {
+		
+	}
+	
+	public void endVisitLabel(int labelNumber) {
+		
+	}
+
+	public Object buildTreeTop(Object subtree, int ambiguityCount) {
+		return subtree;
+	}
+
+	public abstract Object buildNode(int labelNumber, Object[] subtrees);
+	public abstract Object buildProduction(int productionNumber);
+	public abstract Object buildAmb(Object[] alternatives);
+
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ITreeBuilder.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ITreeBuilder.java	Thu Dec 16 15:04:08 2010	(r21536)
@@ -0,0 +1,18 @@
+package org.spoofax.jsglr.client;
+
+import org.spoofax.jsglr.client.imploder.ITokenizer;
+import org.spoofax.jsglr.shared.terms.ATermAppl;
+
+public interface ITreeBuilder {
+
+	void initialize(ParseTable table, int productionCount, int labelStart, int labelCount);
+	void initializeLabel(int labelNumber, ATermAppl parseTreeProduction);
+	
+	Object buildTree(AbstractParseNode node);
+	Object buildTreeTop(Object subtree, int ambiguityCount);
+	
+	/**
+	 * Gets the tokenizer, if applicable, or null.
+	 */
+	ITokenizer getTokenizer();
+}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java	Thu Dec 16 15:03:58 2010	(r21535)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java	Thu Dec 16 15:04:08 2010	(r21536)
@@ -9,6 +9,7 @@
 
 import java.util.List;
 
+import org.spoofax.jsglr.client.imploder.TopdownTreeBuilder;
 import org.spoofax.jsglr.shared.terms.ATerm;
 import org.spoofax.jsglr.shared.terms.ATermFactory;
 import org.spoofax.jsglr.shared.terms.ATermList;

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseProductionNode.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseProductionNode.java	Thu Dec 16 15:03:58 2010	(r21535)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseProductionNode.java	Thu Dec 16 15:04:08 2010	(r21536)
@@ -7,6 +7,8 @@
  */
 package org.spoofax.jsglr.client;
 
+import org.spoofax.jsglr.client.imploder.TopdownTreeBuilder;
+
 
 public class ParseProductionNode extends AbstractParseNode {
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 15:03:58 2010	(r21535)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 15:04:08 2010	(r21536)
@@ -13,6 +13,8 @@
 import java.util.Queue;
 import java.util.Set;
 
+import org.spoofax.jsglr.client.imploder.ITokenizer;
+import org.spoofax.jsglr.client.imploder.ImplodedTreeBuilder;
 import org.spoofax.jsglr.shared.ArrayDeque;
 import org.spoofax.jsglr.shared.BadTokenException;
 import org.spoofax.jsglr.shared.SGLRException;

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ATermImplodedTreeFactory.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ATermImplodedTreeFactory.java	Thu Dec 16 15:04:08 2010	(r21536)
@@ -0,0 +1,107 @@
+package org.spoofax.jsglr.client.imploder;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.spoofax.jsglr.shared.terms.AFun;
+import org.spoofax.jsglr.shared.terms.ATerm;
+import org.spoofax.jsglr.shared.terms.ATermAppl;
+import org.spoofax.jsglr.shared.terms.ATermFactory;
+import org.spoofax.jsglr.shared.terms.ATermInt;
+import org.spoofax.jsglr.shared.terms.ATermList;
+import org.spoofax.jsglr.shared.terms.ATermString;
+import org.spoofax.jsglr.shared.terms.ATermTuple;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class ATermImplodedTreeFactory implements IImplodedTreeFactory<ATerm> {
+	
+	private final ATermFactory factory;
+	
+	public ATermImplodedTreeFactory() {
+		this(new ATermFactory());
+	}
+	
+	public ATermImplodedTreeFactory(ATermFactory factory) {
+		this.factory = factory;
+	}
+	
+	public AFun createConstructor(String name, int childCount) {
+		return factory.makeAFun(name, childCount, false);
+	}
+
+	public ATermAppl createNonTerminal(String sort, String constructor,
+			IToken leftToken, IToken rightToken, List<ATerm> children) {
+		
+		// TODO: Optimize - cache afuns? hard to do up front, messy to do now in the LabelInfo objects 
+		AFun afun = factory.makeAFun(constructor, children.size(), false);
+		ATermAppl result = factory.makeAppl(afun, toArray(children));
+		result.internalSetTokens(leftToken, rightToken);
+		return result;
+	}
+
+	public ATermInt createIntTerminal(String sort, IToken token, int value) {
+		ATermInt result = factory.makeInt(value);
+		result.internalSetTokens(token, token);
+		return result;
+	}
+
+	public ATerm createRealTerminal(String sort, IToken token, double value) {
+		throw new UnsupportedOperationException("ATermReal not supported");
+	}
+
+	public ATermString createStringTerminal(String sort, String value, IToken token) {
+		ATermString result = factory.makeString(value);
+		result.internalSetTokens(token, token);
+		return result;
+	}
+
+	public ATermTuple createTuple(String elementSort, IToken leftToken,
+			IToken rightToken, List<ATerm> children) {
+		
+		ATermTuple result = factory.makeTuple(toArray(children));
+		result.internalSetTokens(leftToken, rightToken);
+		return result;
+	}
+
+	public ATermAppl createAmb(List<ATerm> alternatives) {
+		IToken leftToken = alternatives.get(0).getLeftToken();
+		IToken rightToken = alternatives.get(alternatives.size() - 1).getRightToken();
+		return createNonTerminal(null, "amb", leftToken, rightToken, alternatives);
+	}
+
+	public ATermList createList(String elementSort, IToken leftToken,
+			IToken rightToken, List<ATerm> children) {
+		
+		ATermList result = factory.makeList(toArray(children));
+		result.internalSetTokens(leftToken, rightToken);
+		return result;
+	}
+
+	public boolean isStringTerminal(ATerm node) {
+		return node.getType() == ATerm.STRING;
+	}
+
+	public ATerm createInjection(String sort, List<ATerm> children) {
+		return children.get(0);
+	}
+
+	public Iterable<ATerm> getChildren(ATerm node) {
+		if (node instanceof Iterable<?>) {
+			@SuppressWarnings("unchecked")
+			Iterable<ATerm> result = (Iterable<ATerm>) node;
+			return result;
+		} else {
+			ArrayList<ATerm> children = new ArrayList<ATerm>(node.getChildCount());
+			for (int i = 0, max = node.getChildCount(); i < max; i++) {
+				children.add(node.getChildAt(i));
+			}
+			return children;
+		}
+	}
+
+	private static ATerm[] toArray(List<ATerm> children) {
+		return children.toArray(new ATerm[children.size()]);
+	}
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/AstAnnoImploder.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/AstAnnoImploder.java	Thu Dec 16 15:04:08 2010	(r21536)
@@ -0,0 +1,129 @@
+package org.spoofax.jsglr.client.imploder;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.spoofax.jsglr.client.NotImplementedException;
+import org.spoofax.jsglr.shared.terms.ATerm;
+import org.spoofax.jsglr.shared.terms.ATermAppl;
+import org.spoofax.jsglr.shared.terms.ATermFactory;
+import org.spoofax.jsglr.shared.terms.ATermInt;
+import org.spoofax.jsglr.shared.terms.ATermList;
+import org.spoofax.jsglr.shared.terms.ATermPlaceholder;
+
+import static org.spoofax.jsglr.shared.Tools.*;
+
+
+/**
+ * Implodes {ast} annotations in asfix trees.
+ * 
+ * Note that this class assigns a null sort to all children
+ * of the constructed TNode.
+ * 
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class AstAnnoImploder<TNode> {
+
+	private final IImplodedTreeFactory<TNode> factory;
+	
+	private final List<TNode> placeholderValues;
+	
+	private final IToken leftToken, rightToken;
+	
+	private final ATermFactory termFactory;
+	
+	public AstAnnoImploder(IImplodedTreeFactory<TNode> factory, ATermFactory termFactory, List<TNode> placeholderValues, IToken leftToken, IToken rightToken) {
+		this.factory = factory;
+		this.termFactory = termFactory;
+		this.placeholderValues = placeholderValues;
+		this.leftToken = leftToken;
+		this.rightToken = rightToken;
+	}
+	
+	public TNode implode(ATerm ast, String sort) {
+		// Placeholder terms are represented as strings; must parse them and fill in their arguments
+		String astString = ast.toString();
+		if (astString.startsWith("\"") && astString.endsWith("\"")) {
+			astString = astString.substring(1, astString.length() - 1);
+			astString = astString.replace("\\\\", "\\").replace("\\\"", "\"");
+			ast = termFactory.parse(astString);
+		}
+		
+		return toNode(ast, sort);
+	}
+	
+	private TNode toNode(ATerm term, String sort) {
+		switch (term.getType()) {
+			case ATerm.PLACEHOLDER:
+				return placeholderToNode(term, sort);
+				
+			case ATerm.APPL:
+				return applToNode(term, sort);
+				
+			case ATerm.LIST:
+				return listToNode(term, sort);
+				
+			case ATerm.INT:
+				ATermInt i = (ATermInt) term;
+				return factory.createIntTerminal(sort, leftToken, i.getInt());
+				
+			/*
+			case ATerm.REAL:
+				ATermInt i = (ATermReal) term;
+				return factory.createRealTerminal(sort, leftToken, i.getReal());
+			*/
+				
+			default:
+				throw new IllegalStateException("Unexpected term type encountered in {ast} attribute");
+		}
+	}
+	
+	private TNode placeholderToNode(ATerm placeholder, String sort) {
+		ATerm term = ((ATermPlaceholder) placeholder).getPlaceholder();
+		if (term.getType() == ATerm.INT) {
+			int id = ((ATermInt) term).getInt();
+			if (1 <= id && id <= placeholderValues.size()) {
+				return placeholderValues.get(id - 1);
+			}
+		} else if (term.getType() == ATerm.APPL) {
+			String type = ((ATermAppl) term).getName();
+			if ("conc".equals(type) && term.getChildCount() == 2) {
+				TNode left = toNode(termAt(term, 0), null);
+				TNode right = toNode(termAt(term, 1), null);
+				List<TNode> children = new ArrayList<TNode>();
+				for (TNode node : factory.getChildren(left))
+					children.add(node);
+				for (TNode node : factory.getChildren(right))
+					children.add(node);
+				return factory.createList(sort, leftToken, rightToken, children);
+			} else if ("yield".equals(type) && term.getChildCount() == 1) {
+				throw new NotImplementedException("not implemented: yield in {ast} attribute");
+			}
+		}
+			
+		throw new IllegalStateException("Error in syntax definition: illegal placeholder in {ast} attribute: " + placeholder);
+	}
+	
+	private TNode applToNode(ATerm term, String sort) {
+		ATermAppl appl = (ATermAppl) term;
+		ArrayList<TNode> children = new ArrayList<TNode>(appl.getChildCount());
+		for (int i = 0; i < appl.getChildCount(); i++) {
+			children.add(toNode(termAt(appl, i), null));
+		}
+		if (appl.getType() == ATerm.STRING) {
+			return factory.createStringTerminal(sort, appl.getName(), leftToken);
+		} else {
+			return factory.createNonTerminal(sort, appl.getName(), leftToken, rightToken, children);
+		}
+	}
+	
+	private TNode listToNode(ATerm term, String sort) {
+		// TODO: Fishy (Spoofax/49)
+		ATermList list = (ATermList) term;
+		ArrayList<TNode> children = new ArrayList<TNode>(list.getChildCount());
+		for (int i = 0; i < term.getChildCount(); i++) {
+			children.add(toNode(termAt(term, i), null));
+		}
+		return factory.createList(sort, leftToken, rightToken, children);
+	}
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/DummyTokenizer.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/DummyTokenizer.java	Thu Dec 16 15:04:08 2010	(r21536)
@@ -0,0 +1,65 @@
+package org.spoofax.jsglr.client.imploder;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class DummyTokenizer implements ITokenizer {
+	
+	private final IToken onlyToken = new Token(this, 0, 0, 0, IToken.TK_UNKNOWN);
+	
+	private char[] inputChars;
+	
+	/**
+	 * @param inputChars
+	 *           The input characters (used for {indentpadding} productions
+	 *           and error recovery)
+	 */
+	public void initialize(char[] inputChars) {
+		this.inputChars = inputChars;
+	}
+
+	public char[] getInputChars() {
+		return inputChars;
+	}
+
+	public int getStartOffset() {
+		return 0;
+	}
+
+	public void setStartOffset(int startOffset) {
+		// Do nothing		
+	}
+
+	public IToken currentToken() {
+		return onlyToken;
+	}
+
+	public int getTokenCount() {
+		return 0;
+	}
+
+	public IToken getTokenAt(int i) {
+		return onlyToken;
+	}
+
+	public IToken makeToken(int offset, LabelInfo label) {
+		return onlyToken;
+	}
+
+	public IToken makeToken(int offset, LabelInfo label, boolean allowEmptyToken) {
+		return onlyToken;
+	}
+
+	public IToken makeToken(int offset, int kind, boolean allowEmptyToken) {
+		return onlyToken;
+	}
+
+	public IToken createSkippedToken(int offset, char inputChar, char prevChar) {
+		return onlyToken;
+	}
+
+	public void createLayoutToken(int offset, int lastOffset, LabelInfo label) {
+		// Do nothing
+	}
+
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/IImplodedTreeFactory.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/IImplodedTreeFactory.java	Thu Dec 16 15:04:08 2010	(r21536)
@@ -0,0 +1,50 @@
+package org.spoofax.jsglr.client.imploder;
+
+import java.util.List;
+
+
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public interface IImplodedTreeFactory<TNode> {
+
+	/**
+	 * Create a new non-terminal node (or a terminal with only a constructor).
+	 */
+	public TNode createNonTerminal(String sort, String constructor, IToken leftToken, IToken rightToken,
+			List<TNode> children);
+	
+	/**
+	 * Create a new terminal node for an int value.
+	 */
+	public TNode createIntTerminal(String sort, IToken token, int value);
+	
+	/**
+	 * Create a new terminal node for an real value.
+	 */
+	public TNode createRealTerminal(String sort, IToken token, double value);
+	
+	/**
+	 * Create a new terminal node for a string token.
+	 */
+	public TNode createStringTerminal(String sort, String value, IToken token);
+	
+	public TNode createTuple(String elementSort, IToken leftToken, IToken rightToken, List<TNode> children);
+	
+	/**
+	 * Create a new node list. 
+	 */
+	public TNode createList(String elementSort, IToken leftToken, IToken rightToken, List<TNode> children);
+
+	public TNode createAmb(List<TNode> alternatives);
+
+	/**
+	 * Create an injection node.
+	 */
+	public TNode createInjection(String sort, List<TNode> children);
+	
+	public boolean isStringTerminal(TNode node);
+	
+	public Iterable<TNode> getChildren(TNode node);
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/IToken.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/IToken.java	Thu Dec 16 15:04:08 2010	(r21536)
@@ -0,0 +1,50 @@
+package org.spoofax.jsglr.client.imploder;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public interface IToken {
+	/** Unknown token kind. */
+	public static final int TK_UNKNOWN = 0;
+	
+	/** Token kind for a generic identifier. */
+	public static final int TK_IDENTIFIER = 1;
+	
+	/** Token kind for a generic numeric value. */
+	public static final int TK_NUMBER = 2;
+	
+	/** Token kind for a generic string literal. */
+	public static final int TK_STRING = 3;
+	
+	/** Token kind for a generic keyword token. */
+	public static final int TK_KEYWORD = 4;
+	
+	/** Token kind for a generic keyword token. */
+	public static final int TK_OPERATOR = 5;
+	
+	/** Token kind for a meta-variable. */
+	public static final int TK_VAR = 6;
+	
+	/** Token kind for a layout (or comment) token. */
+	public static final int TK_LAYOUT = 7;
+	
+	/** Token kind for an EOF token. */
+	public static final int TK_EOF = 8;
+	
+	/** Token kind for an erroneous token. */
+	public static final int TK_ERROR = 9;
+	
+	public static final int TK_RESERVED = 10;
+	
+	int getKind();
+	
+	int getIndex();
+
+	int getStartOffset();
+
+	int getEndOffset();
+
+	int getLine();
+	
+	int getColumn();
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITokenizer.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITokenizer.java	Thu Dec 16 15:04:08 2010	(r21536)
@@ -0,0 +1,41 @@
+package org.spoofax.jsglr.client.imploder;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public interface ITokenizer {
+	
+	void initialize(char[] inputChars);
+
+	char[] getInputChars();
+
+	int getStartOffset();
+
+	void setStartOffset(int startOffset);
+
+	IToken currentToken();
+
+	int getTokenCount();
+
+	IToken getTokenAt(int i);
+
+	IToken makeToken(int offset, LabelInfo label);
+
+	IToken makeToken(int offset, LabelInfo label, boolean allowEmptyToken);
+
+	IToken makeToken(int offset, int kind, boolean allowEmptyToken);
+
+	/**
+	 * Creates an artificial token at keyword boundaries
+	 * inside skipped regions of code.
+	 * Required for keyword highlighting with {@link KeywordRecognizer}.
+	 */
+	IToken createSkippedToken(int offset, char inputChar, char prevChar);
+
+	/**
+	 * Creates an artificial token for every water-based recovery
+	 * and for comments within layout.
+	 */
+	void createLayoutToken(int offset, int lastOffset, LabelInfo label);
+
+}
\ No newline at end of file

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ImplodedTreeBuilder.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ImplodedTreeBuilder.java	Thu Dec 16 15:04:08 2010	(r21536)
@@ -0,0 +1,373 @@
+package org.spoofax.jsglr.client.imploder;
+
+import static java.lang.Math.max;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.spoofax.jsglr.client.AbstractParseNode;
+import org.spoofax.jsglr.client.Amb;
+import org.spoofax.jsglr.client.ParseNode;
+import org.spoofax.jsglr.client.ParseProductionNode;
+import org.spoofax.jsglr.client.ParseTable;
+import org.spoofax.jsglr.client.RecoveryConnector;
+import org.spoofax.jsglr.shared.terms.ATermAppl;
+import org.spoofax.jsglr.shared.terms.ATermFactory;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+ at SuppressWarnings({"rawtypes", "unchecked"})
+public class ImplodedTreeBuilder extends TopdownTreeBuilder {
+	
+	public static final char SKIPPED_CHAR = (char) -1; // TODO: sync with ParseErorHandler
+	
+	public static final char UNEXPECTED_EOF_CHAR = (char) -2; // TODO: sync with ParseErorHandler
+	
+	private static final int NONE = -1;
+
+	private static final int EXPECTED_NODE_CHILDREN = 5;
+	
+	private static final String LIST_CONSTRUCTOR = new String("[]");
+	
+	private static final String TUPLE_CONSTRUCTOR = new String("");
+	
+	private final ITokenizer tokenizer;
+	
+	private IImplodedTreeFactory factory;
+	
+	private boolean useDefaultFactory;
+	
+	private ProductionAttributeReader prodReader;
+
+	private ATermFactory termFactory;
+	
+	private LabelInfo[] labels;
+	
+	private int labelStart;
+	
+	/** Character offset for the current implosion. */ 
+	private int offset;
+	
+	private int nonMatchingOffset = NONE;
+	
+	private char nonMatchingChar, nonMatchingCharExpected, prevChar;
+	
+	private boolean inLexicalContext;
+	
+	public ImplodedTreeBuilder() {
+		this(null, new Tokenizer());
+		this.useDefaultFactory = true;
+	}
+	
+	public ImplodedTreeBuilder(IImplodedTreeFactory treeFactory, ITokenizer tokenizer) {
+		this.factory = treeFactory;
+		this.tokenizer = tokenizer;
+	}
+
+	public void initialize(ParseTable table, int productionCount, int labelStart, int labelCount) {
+		this.termFactory = table.getFactory();
+		if (useDefaultFactory)
+			factory = new ATermImplodedTreeFactory(termFactory);
+		this.prodReader = new ProductionAttributeReader(termFactory);
+		this.labels = new LabelInfo[labelCount - labelStart];
+		this.labelStart = labelStart;
+	}
+
+	public void initializeLabel(int labelNumber, ATermAppl parseTreeProduction) {
+		labels[labelNumber - labelStart] = new LabelInfo(prodReader, parseTreeProduction);
+	}
+	
+	public ITokenizer getTokenizer() {
+		return tokenizer;
+	}
+	
+	/*
+	public void visitLabel(int labelNumber) {
+		LabelInfo label = labels[labelNumber - labelStart];
+		if (label.isLexical() || label.isVar())
+			lexicalContextDepth++;
+	}
+	
+	public void endVisitLabel(int labelNumber) {
+		LabelInfo label = labels[labelNumber - labelStart];
+		if (label.isLexical() || label.isVar())
+			lexicalContextDepth--;
+	}
+	*/
+	
+	@Override
+	public Object buildTreeNode(ParseNode node) {
+		LabelInfo label = labels[node.getLabel() - labelStart];
+		IToken prevToken = tokenizer.currentToken();
+		int lastOffset = offset;
+		AbstractParseNode[] subnodes = node.getChildren();
+		
+		boolean lexicalStart = !inLexicalContext && label.isLexicalLiteralOrLayout();
+		if (lexicalStart) inLexicalContext = true;
+		
+		if (!inLexicalContext
+				&& subnodes.length > 0 && subnodes[0] instanceof ParseProductionNode
+				&& label.isSortProduction()
+				&& label.getLHS().getChildCount() == 1) {
+			return createIntTerminal(label, subnodes);
+		}
+		
+		boolean isVar  = !inLexicalContext && label.isVar();
+		if (isVar) inLexicalContext = true;
+		
+		// TODO: Optimize - one particularly gnarly optimization would be to reuse the subnodes array here
+		//                  and in buildTreeAmb
+		ArrayList<Object> children = null;
+		if (!inLexicalContext)
+			children = new ArrayList<Object>(max(EXPECTED_NODE_CHILDREN, subnodes.length));
+
+		// Recurse
+		for (AbstractParseNode subnode : subnodes) {
+			Object child = subnode.toTreeTopdown(this);
+			if (child != null) children.add(child);
+		}
+		
+		if (lexicalStart || isVar) {
+			return createStringTerminal(label);
+		} else if (inLexicalContext) {
+			tokenizer.createLayoutToken(offset, lastOffset, label);
+			return null; // don't create tokens inside lexical context; just create one big token at the top
+		} else {
+			return createNodeOrInjection(label, prevToken, children);
+		}
+	}
+
+	public Object buildTreeAmb(Amb a) {
+		final int oldOffset = offset;
+		final int oldBeginOffset = tokenizer.getStartOffset();
+		final boolean oldLexicalContext = inLexicalContext;
+		final AbstractParseNode[] subnodes = a.getAlternatives();
+		final ArrayList<Object> children =
+			new ArrayList<Object>(max(EXPECTED_NODE_CHILDREN, subnodes.length));
+
+		// Recurse
+		for (AbstractParseNode subnode : subnodes) {
+			// Restore lexical state for each branch
+			offset = oldOffset;
+			tokenizer.setStartOffset(oldBeginOffset);
+			inLexicalContext = oldLexicalContext;
+			
+			Object child = subnode.toTreeTopdown(this);
+			if (child != null) children.add(child);
+		}
+		return factory.createAmb(children);
+	}
+
+	public Object buildTreeProduction(ParseProductionNode node) {
+		int character = node.prod;
+		consumeLexicalChar(character);
+		return null;
+	}
+
+
+	private Object createStringTerminal(LabelInfo label) {
+		inLexicalContext = false;
+		String sort = label.getSort();
+		IToken token = tokenizer.makeToken(offset, label, sort != null);
+		
+		if (sort == null) return null;
+		
+		// Debug.log("Creating node ", sort, " from ", SGLRTokenizer.dumpToString(token));
+		
+		Object result = factory.createStringTerminal(sort, getPaddedLexicalValue(label, token), token);
+		String constructor = label.getMetaVarConstructor();
+		if (constructor != null) {
+			ArrayList<Object> children = new ArrayList<Object>(1);
+			children.add(result);
+			result = factory.createNonTerminal(sort, constructor, token, token, children);
+		}
+		return result;
+	}
+	
+	private Object createIntTerminal(LabelInfo label, AbstractParseNode[] contents) {
+		IToken token = tokenizer.makeToken(offset, label, true);
+		int value = contents.length == 1 && contents[0] instanceof ParseProductionNode
+			? ((ParseProductionNode) contents[0]).prod : -1;
+		assert value != -1;
+		return factory.createIntTerminal(label.getSort(), token, value);
+	}
+
+	private Object createNodeOrInjection(LabelInfo label, IToken prevToken, List<Object> children) {
+		
+		String constructor = label.getConstructor();
+		
+		if (label.isList()) {
+			return createNode(label, LIST_CONSTRUCTOR, prevToken, children);
+		} else if (constructor != null) {
+			tokenizer.makeToken(offset, label); // TODO: why makeToken here??
+			return createNode(label, constructor, prevToken, children);
+		} else if (label.getAstAttribute() != null) {
+			return createAstNonTerminal(label, prevToken, children);
+		} else if (label.isOptional()) {
+			// TODO: Spoofax/295: JSGLR does not output correct AST for optional literals
+			if (children.size() == 0) {
+				return createNode(label, "None", prevToken, children);
+			} else {
+				assert children.size() == 1;
+				return createNode(label, "Some", prevToken, children);
+			}
+		} else if (children.size() == 1) {
+			// Injection
+			// TODO: efficiently store injection sort for use by content completion?
+			//       would be needed to distinguish FoldingRules and Sorts in "folding" sections...
+			//       maybe only if the content proposer demands it?
+			// TODO: also, avoid semantics for deprecated?
+			return factory.createInjection(label.getSort(), children);
+		} else {
+			// Constructor-less application (tuple)
+			return createNode(label, TUPLE_CONSTRUCTOR, prevToken, children);
+		}
+	}
+
+	/**
+	 * Create a context-free tree node.
+	 * 
+	 * @param constructor
+	 *          The constructor to use, or {@link #LIST_CONSTRUCTOR} to construct a list,
+	 *          or {@link #TUPLE_CONSTRUCTOR} to construct a tuple.
+	 */
+	private Object createNode(LabelInfo label, String constructor, IToken prevToken,
+			List<Object> children) {
+		
+		IToken left = getStartToken(prevToken);
+		IToken right = getEndToken(left, tokenizer.currentToken());
+		
+		if (constructor == LIST_CONSTRUCTOR) {
+			return factory.createList(label.getSort(), left, right, children);
+		} else if (constructor == TUPLE_CONSTRUCTOR) {
+			return factory.createTuple(label.getSort(), left, right, children);
+		} else if (constructor == null && children.size() == 1 && factory.isStringTerminal(children.get(0))) {
+			// Child node was a <string> node (rare case); unpack it and create a new terminal
+			assert left == right;
+			return factory.createStringTerminal(label.getSort(), getPaddedLexicalValue(label, left), left);
+		} else {
+			return factory.createNonTerminal(label.getSort(), constructor, left, right, children);
+		}
+	}
+	
+	/**
+	 * Gets the padded lexical value for {indentpadding} lexicals, or returns null.
+	 */
+	private String getPaddedLexicalValue(LabelInfo label, IToken startToken) {
+		if (label.isIndentPaddingLexical()) {
+			char[] inputChars = tokenizer.getInputChars();
+			int lineStart = startToken.getStartOffset() - 1;
+			if (lineStart < 0) return null;
+			while (lineStart >= 0) {
+				char c = inputChars[lineStart--];
+				if (c == '\n' || c == '\r') {
+					lineStart++;
+					break;
+				}
+			}
+			StringBuilder result = new StringBuilder();
+			result.append(inputChars, lineStart, startToken.getStartOffset() - lineStart - 1);
+			for (int i = 0; i < result.length(); i++) {
+				char c = result.charAt(i);
+				if (c != ' ' && c != '\t') result.setCharAt(i, ' ');
+			}
+			result.append(startToken.toString());
+			return result.toString();
+		} else {
+			return null; // lazily load token string value
+		}
+	}
+
+	/** Implode a context-free node with an {ast} annotation. */
+	private Object createAstNonTerminal(LabelInfo label, IToken prevToken, List<Object> children) {
+		IToken left = getStartToken(prevToken);
+		IToken right = getEndToken(left, tokenizer.currentToken());
+		AstAnnoImploder imploder = new AstAnnoImploder<Object>(factory, termFactory, children, left, right);
+		return imploder.implode(label.getAstAttribute(), label.getSort());
+	}
+	
+	/** Get the token after the previous node's ending token, or null if N/A. */
+	private IToken getStartToken(IToken prevToken) {
+		if (prevToken == null) {
+			return tokenizer.getTokenCount() == 0
+				? null
+			    : tokenizer.getTokenAt(0);
+		} else {
+			int index = prevToken.getIndex();
+			
+			if (tokenizer.getTokenCount() - index <= 1) {
+				// Create new empty token
+				// HACK: Assume TK_LAYOUT kind for empty tokens in AST nodes
+				return tokenizer.makeToken(offset, IToken.TK_LAYOUT, true);
+			} else {
+				return tokenizer.getTokenAt(index + 1); 
+			}
+		}
+	}
+	
+	/** Get the last no-layout token for an AST node. */
+	private IToken getEndToken(IToken startToken, IToken lastToken) {
+		int begin = startToken.getIndex();
+		
+		for (int i = lastToken.getIndex(); i > begin; i--) {
+			lastToken = tokenizer.getTokenAt(i);
+			if (lastToken.getKind() != IToken.TK_LAYOUT
+					|| lastToken.getStartOffset() == lastToken.getEndOffset()-1)
+				break;
+		}
+		
+		return lastToken;
+	}
+	
+	/** Consume a character of a lexical terminal. */
+	protected final void consumeLexicalChar(int character) {
+		char[] inputChars = tokenizer.getInputChars();
+		if (offset >= inputChars.length) {
+			if (nonMatchingOffset != NONE) {
+				assert false : "Character in parse tree after end of input stream: "
+						+ (char) character
+						+ " - may be caused by unexcepted character in parse tree at position "
+						+ nonMatchingChar 	+ ": " + nonMatchingChar + " instead of "
+						+ nonMatchingCharExpected;
+			}
+		    // UNDONE: Strict lexical stream checking
+			// throw new ImploderException("Character in parse tree after end of input stream: " + (char) character.getInt());
+			// a forced reduction may have added some extra characters to the tree;
+			inputChars[inputChars.length - 1] = UNEXPECTED_EOF_CHAR;
+			return;
+		}
+		
+		char parsedChar = (char) character;
+		char inputChar = inputChars[offset];
+		
+		if (parsedChar != inputChar) {
+			if (RecoveryConnector.isLayoutCharacter(parsedChar)) {
+				// Remember that the parser skipped the current character
+				// for later error reporting. (Cannot modify the immutable
+				// parse tree here; changing the original stream instead.)
+				inputChars[offset] = SKIPPED_CHAR;
+				tokenizer.createSkippedToken(offset, inputChar, prevChar);
+				offset++;
+			} else {
+				// UNDONE: Strict lexical stream checking
+				// throw new IllegalStateException("Character from asfix stream (" + parsedChar
+				//	 	+ ") must be in lex stream (" + inputChar + ")");
+			    // instead, we allow the non-matching character for now, and hope
+			    // we can pick up the right track later
+				// TODO: better way to report skipped fragments in the parser
+				//       this isn't 100% reliable
+				if (nonMatchingOffset == NONE) {
+					nonMatchingOffset = offset;
+					nonMatchingChar = parsedChar;
+					nonMatchingCharExpected = inputChar;
+				}
+				inputChars[offset] = SKIPPED_CHAR;
+			}
+		} else {
+			offset++;
+		}
+		prevChar = inputChar;
+	}
+
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/LabelInfo.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/LabelInfo.java	Thu Dec 16 15:04:08 2010	(r21536)
@@ -0,0 +1,131 @@
+package org.spoofax.jsglr.client.imploder;
+
+import static org.spoofax.jsglr.shared.Tools.termAt;
+
+import org.spoofax.jsglr.shared.terms.ATerm;
+import org.spoofax.jsglr.shared.terms.ATermAppl;
+import org.spoofax.jsglr.shared.terms.ATermList;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class LabelInfo {
+	
+	private final ProductionAttributeReader reader;
+
+	private final ATermAppl production;
+	
+	private final String sort;
+	
+	private final String constructor;
+	
+	private final ATerm astAttribute;
+	
+	private final boolean isLexicalLiteralOrLayout;
+	
+	private final boolean isLexical;
+
+	private final boolean isVar;
+
+	private final boolean isList;
+
+	private final boolean isIndentPaddingLexical;
+	
+	private final boolean isLexLayout;
+	
+	private final boolean isSortProduction;
+
+	private final boolean isLayout;
+	
+	private final boolean isLiteral;
+	
+	private final String metaVarConstructor;
+	
+	public LabelInfo(ProductionAttributeReader reader, ATermAppl production) {
+		this.production = production;
+		this.reader = reader;
+		ATermAppl rhs = getRHS();
+		ATermAppl attrs = getAttrs();
+		sort = reader.getSort(rhs);
+		constructor = reader.getConsAttribute(attrs);
+		astAttribute = reader.getAstAttribute(attrs);
+		isLexicalLiteralOrLayout = reader.isLexicalLiteralOrLayout(rhs);
+		isList = reader.isList(rhs);
+		isVar = reader.isVariableNode(rhs);
+		isIndentPaddingLexical = reader.isIndentPaddingLexical(attrs);
+		isLexLayout = reader.isLexLayout(rhs);
+		isLexical = reader.isLexical(rhs);
+		isLayout = reader.isLayout(rhs);
+		isLiteral = reader.isLiteral(rhs);
+		isSortProduction = reader.sortFun == rhs.getAFun() || reader.parameterizedSortFun == rhs.getAFun();
+		metaVarConstructor = reader.getMetaVarConstructor(rhs);
+	}
+    
+	protected ATermList getLHS() {
+    	return termAt(production, 0);
+    }
+    
+	protected ATermAppl getRHS() {
+    	return termAt(production, 1);
+    }
+    
+	protected ATermAppl getAttrs() {
+    	return termAt(production, 2);
+    }
+	
+	public String getSort() {
+		return sort;
+	}
+	
+	public String getConstructor() {
+		return constructor;
+	}
+	
+	public ATerm getAstAttribute() {
+		return astAttribute;
+	}
+	
+	public boolean isLexicalLiteralOrLayout() {
+		return isLexicalLiteralOrLayout;
+	}
+	
+	public boolean isLexical() {
+		return isLexical;
+	}
+	
+	public boolean isList() {
+		return isList;
+	}
+	
+	public boolean isVar() {
+		return isVar;
+	}
+	
+	public boolean isIndentPaddingLexical() {
+		return isIndentPaddingLexical;
+	}
+	
+	public boolean isLexLayout() {
+		return isLexLayout;
+	}
+	
+	public boolean isLayout() {
+		return isLayout;
+	}
+	
+	public boolean isLiteral() {
+		return isLiteral;
+	}
+	
+	public boolean isSortProduction() {
+		return isSortProduction;
+	}
+	
+	public String getMetaVarConstructor() {
+		return metaVarConstructor;
+	}
+
+	public boolean isOptional() {
+		return reader.isOptional(getRHS());
+	}
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ProductionAttributeReader.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ProductionAttributeReader.java	Thu Dec 16 15:04:08 2010	(r21536)
@@ -0,0 +1,265 @@
+package org.spoofax.jsglr.client.imploder;
+
+import static org.spoofax.jsglr.shared.Tools.applAt;
+import static org.spoofax.jsglr.shared.Tools.asAppl;
+import static org.spoofax.jsglr.shared.Tools.asJavaString;
+import static org.spoofax.jsglr.shared.Tools.isAppl;
+import static org.spoofax.jsglr.shared.Tools.termAt;
+
+import org.spoofax.jsglr.shared.terms.AFun;
+import org.spoofax.jsglr.shared.terms.ATerm;
+import org.spoofax.jsglr.shared.terms.ATermAppl;
+import org.spoofax.jsglr.shared.terms.ATermFactory;
+import org.spoofax.jsglr.shared.terms.ATermList;
+
+
+/**
+ * Extracts attributes from parse table productions.
+ * 
+ * @author Lennart Kats <L.C.L.Kats add tudelft.nl>
+ */
+public class ProductionAttributeReader {
+	
+	private final int PARAMETRIZED_SORT_NAME = 0;
+	
+	private final int PARAMETRIZED_SORT_ARGS = 1;
+	
+	private final int ALT_SORT_LEFT = 0;
+	
+	private final int ALT_SORT_RIGHT = 1;
+	
+	protected final AFun sortFun;
+	
+	protected final AFun parameterizedSortFun;
+	
+	protected final AFun attrsFun;
+	
+	protected final AFun noAttrsFun;
+	
+	protected final AFun preferFun;
+	
+	protected final AFun avoidFun;
+	
+	private final AFun varSymFun;
+	
+	private final AFun altFun;
+	
+	private final AFun charClassFun;
+	
+	private final AFun litFun;
+	
+	private final AFun cilitFun;
+	
+	private final AFun lexFun;
+	
+	private final AFun optFun;
+	
+	private final AFun layoutFun;
+	
+	private final AFun cfFun;
+	
+	private final AFun varsymFun;
+	
+	private final AFun seqFun;
+	
+	private final AFun iterFun;
+	
+	private final AFun iterStarFun;
+	
+	private final AFun iterPlusFun;
+	
+	private final AFun iterSepFun;
+	
+	private final AFun iterStarSepFun;
+	
+	private final AFun iterPlusSepFun;
+	
+	public ProductionAttributeReader(ATermFactory factory) {
+		sortFun = factory.makeAFun("sort", 1, false);
+		parameterizedSortFun =
+			factory.makeAFun("parameterized-sort", 2, false);
+		attrsFun = factory.makeAFun("attrs", 1, false);
+		noAttrsFun = factory.makeAFun("no-attrs", 0, false);
+		preferFun = factory.makeAFun("prefer", 0, false);
+		avoidFun = factory.makeAFun("avoid", 0, false);
+		varSymFun = factory.makeAFun("varsym", 1, false);
+		altFun = factory.makeAFun("alt", 2, false);
+		charClassFun = factory.makeAFun("char-class", 1, false);
+		litFun = factory.makeAFun("lit", 1, false);
+		cilitFun = factory.makeAFun("cilit", 1, false);
+		lexFun = factory.makeAFun("lex", 1, false);
+		optFun = factory.makeAFun("opt", 1, false);
+		layoutFun = factory.makeAFun("layout", 0, false);
+		cfFun = factory.makeAFun("cf", 1, false);
+		varsymFun = factory.makeAFun("varsym", 1, false);
+		seqFun = factory.makeAFun("seq", 2, false);
+		iterFun = factory.makeAFun("iter", 1, false);
+		iterStarFun = factory.makeAFun("iter-star", 1, false);
+		iterPlusFun = factory.makeAFun("iter-plus", 1, false);
+		iterSepFun = factory.makeAFun("iter-sep", 2, false);
+		iterStarSepFun = factory.makeAFun("iter-star-sep", 2, false);
+		iterPlusSepFun = factory.makeAFun("iter-plus-sep", 2, false);
+	}
+
+	public String getConsAttribute(ATermAppl attrs) {
+		ATerm consAttr = getAttribute(attrs, "cons");
+		return consAttr == null ? null : ((ATermAppl) consAttr).getName();
+	}
+	
+	// FIXME: support meta-var constructors
+	public String getMetaVarConstructor(ATermAppl rhs) {
+		if (rhs.getChildCount() == 1 && varSymFun == rhs.getAFun()) {
+			return isIterFun(((ATermAppl) rhs.getChildAt(0)).getAFun())
+					? "meta-listvar"
+					: "meta-var";
+		}
+		return null;
+	}
+	
+	public ATerm getAstAttribute(ATermAppl attrs) {
+		return getAttribute(attrs, "ast");
+	}
+	
+	public boolean isIndentPaddingLexical(ATermAppl attrs) {
+		return getAttribute(attrs, "indentpadding") != null;
+	}
+
+	/** Return the contents of a term attribute (e.g., "cons"), or null if not found. */
+	public ATerm getAttribute(ATermAppl attrs, String attrName) {
+		if (attrs.getAFun() == noAttrsFun)
+			return null;
+		
+		ATermList list = termAt(attrs, 0);
+		
+		for (ATerm attr : list) {			
+			if (attr instanceof ATermAppl) {
+				ATermAppl namedAttr = (ATermAppl) attr;
+				if (namedAttr.getName().equals("term")) {
+					namedAttr = termAt(namedAttr, 0);
+					
+					if (namedAttr.getName().equals(attrName))
+						return namedAttr.getChildCount() == 1 ? termAt(namedAttr, 0) : namedAttr;
+				}				
+			}
+		}
+		
+		return null; // no cons found
+	}
+	
+	/** 
+	 * Get the RTG sort name of a production RHS, or for lists, the RTG element sort name.
+	 */
+    public String getSort(ATermAppl rhs) {
+    	for (ATerm current = rhs; current.getChildCount() > 0 && isAppl(current); current = termAt(current, 0)) {
+    		AFun cons = asAppl(current).getAFun();
+			if (cons == sortFun)
+    			return asJavaString(termAt(current, 0));
+    		if (cons == parameterizedSortFun)
+    			return getParameterizedSortName(current);
+    		if (cons == charClassFun)
+    			return null;
+    		if (cons == altFun)
+    			return getAltSortName(current);
+    	}
+    	
+    	return null;
+    }
+    
+    private String getParameterizedSortName(ATerm node) {
+    	StringBuilder result = new StringBuilder();
+    	
+    	result.append(applAt(node, PARAMETRIZED_SORT_NAME).getName());
+    	result.append('_');
+    	
+		ATermList args = termAt(node, PARAMETRIZED_SORT_ARGS);
+		
+        for (ATermAppl arg = (ATermAppl) args.getFirst(); !args.getNext().isEmpty(); args = args.getNext()) {
+			result.append(arg.getName());
+		}
+		
+		return result.toString();
+    }
+    
+    private String getAltSortName(ATerm node) {
+		String left = getSort(applAt(node, ALT_SORT_LEFT));
+		String right = getSort(applAt(node, ALT_SORT_RIGHT));
+		
+		// HACK: In the RTG, alt sorts appear with a number at the end
+		return left + "_" + right + "0";
+    }
+
+	/**
+	 * Identifies lexical parse tree nodes.
+	 * 
+	 * @see AsfixAnalyzer#isVariableNode(ATermAppl)
+	 *      Identifies variables, which are usually treated similarly to
+	 *      lexical nodes.
+	 * 
+	 * @return true if the current node is lexical.
+	 */
+	public boolean isLexicalLiteralOrLayout(ATermAppl rhs) {
+		return (lexFun == rhs.getAFun() || isLiteral(rhs)
+		    || isLayout(rhs));
+	}
+	
+	public boolean isLexical(ATermAppl rhs) {
+		return lexFun == rhs.getAFun();
+	}
+
+	public boolean isLayout(ATermAppl rhs) {
+		ATerm details = termAt(rhs, 0);
+		if (!isAppl(details))
+			return false;
+		
+		if (optFun == asAppl(details).getAFun())
+			details = applAt(details, 0);
+		
+		return layoutFun == asAppl(details).getAFun();
+	}
+
+	public boolean isLiteral(ATermAppl rhs) {
+		AFun fun = rhs.getAFun();
+		return litFun == fun || cilitFun == fun;
+	}
+	
+	public boolean isList(ATermAppl rhs) {
+		ATermAppl details = cfFun == rhs.getAFun()
+		                  ? applAt(rhs, 0)
+		                  : rhs;
+		              	
+	  	if (details.getAFun() == optFun)
+	  		details = applAt(details, 0);
+	  	
+		AFun fun = details.getAFun();
+		
+		 // FIXME: Spoofax/159: AsfixImploder creates tuples instead of lists for seqs
+		return isIterFun(fun) || seqFun == fun;
+	}
+
+	public boolean isIterFun(AFun fun) {
+		return iterFun == fun || iterStarFun == fun || iterPlusFun == fun
+				|| iterSepFun == fun || iterStarSepFun == fun || iterPlusSepFun == fun;
+	}
+
+	/**
+	 * Identifies parse tree nodes that begin variables.
+	 * 
+	 * @see #isVariableNode(ATermAppl) 
+	 * @return true if the current node is lexical.
+	 */
+	public boolean isVariableNode(ATermAppl rhs) {
+		return varsymFun == rhs.getAFun();
+	}
+
+	public boolean isLexLayout(ATermAppl rhs) {
+		if (rhs.getChildCount() != 1) return false;
+		ATerm child = rhs.getChildAt(0);
+		return isAppl(child) && layoutFun == ((ATermAppl) child).getAFun()
+			&& lexFun == rhs.getAFun();
+	}
+
+	public boolean isOptional(ATermAppl rhs) {
+		return rhs.getAFun() == optFun;
+	}
+
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Token.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Token.java	Thu Dec 16 15:04:08 2010	(r21536)
@@ -0,0 +1,48 @@
+package org.spoofax.jsglr.client.imploder;
+
+import org.spoofax.jsglr.client.NotImplementedException;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class Token implements IToken {
+
+	private final ITokenizer tokenizer;
+	
+	private final int index, startOffset, endOffset, kind;
+
+	public Token(ITokenizer tokenizer, int index, int startOffset, int endOffset, int kind) {
+		this.tokenizer = tokenizer;
+		this.index = index;
+		this.startOffset = startOffset;
+		this.endOffset = endOffset;
+		this.kind = kind;
+	}
+	
+	public int getKind() {
+		return kind;
+	}
+
+	public int getIndex() {
+		return index;
+	}
+
+	public int getStartOffset() {
+		return startOffset;
+	}
+
+	public int getEndOffset() {
+		return endOffset;
+	}
+
+	public int getLine() {
+		// TODO
+		throw new NotImplementedException();
+	}
+	
+	public int getColumn() {
+		// TODO
+		throw new NotImplementedException();
+	}
+
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TokenKindManager.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TokenKindManager.java	Thu Dec 16 15:04:08 2010	(r21536)
@@ -0,0 +1,135 @@
+package org.spoofax.jsglr.client.imploder;
+
+import static org.spoofax.jsglr.client.imploder.IToken.TK_IDENTIFIER;
+import static org.spoofax.jsglr.client.imploder.IToken.TK_KEYWORD;
+import static org.spoofax.jsglr.client.imploder.IToken.TK_LAYOUT;
+import static org.spoofax.jsglr.client.imploder.IToken.TK_NUMBER;
+import static org.spoofax.jsglr.client.imploder.IToken.TK_OPERATOR;
+import static org.spoofax.jsglr.client.imploder.IToken.TK_STRING;
+import static org.spoofax.jsglr.client.imploder.IToken.TK_VAR;
+import static org.spoofax.jsglr.shared.Tools.applAt;
+import static org.spoofax.jsglr.shared.Tools.asAppl;
+import static org.spoofax.jsglr.shared.Tools.intAt;
+import static org.spoofax.jsglr.shared.Tools.isAppl;
+import static org.spoofax.jsglr.shared.Tools.termAt;
+
+import org.spoofax.jsglr.shared.terms.ATerm;
+import org.spoofax.jsglr.shared.terms.ATermAppl;
+
+/**
+ * Class that handles producing and printing token kinds.
+ * 
+ * @note May be overridden for specific grammars.
+ * 
+ * @see TokenKind
+ * 
+ * @author Lennart Kats <L.C.L.Kats add tudelft.nl>
+ */
+public class TokenKindManager {
+	private static final int RANGE_START = 0;
+	
+	private static final int RANGE_END = 1;
+	
+	// General token kind information
+	
+	/**
+	 * Get the token kind for a given sort.
+	 */
+	public int getTokenKind(LabelInfo label) {
+		// TODO: Optimization - cache token kind info in LabelInfo
+		
+		if (label.isLayout()) {
+			return TK_LAYOUT;
+		} else if (label.isLexical()) {
+			if (isStringLiteral(label)) {
+				return TK_STRING;
+			} else if (isNumberLiteral(label)) {
+				return TK_NUMBER;
+			} else {
+				return TK_IDENTIFIER;
+			}
+		} else if (label.isVar()) {
+			return TK_VAR;
+		} else if (isOperator(label)) {
+			return TK_OPERATOR;
+		} else {
+			return TK_KEYWORD;
+		}
+	}
+
+	protected static boolean isOperator(LabelInfo label) {
+		if (!label.isLiteral()) return false;
+		
+		ATermAppl lit = applAt(label.getRHS(), 0);
+		String contents = lit.getName();
+		
+		for (int i = 0; i < contents.length(); i++) {
+			char c = contents.charAt(i);
+			if (Character.isLetter(c)) return false;
+		}
+		
+		return true;
+	}
+	
+	/**
+	 * Determines whether the given string could possibly 
+	 * be a keyword (as opposed to an operator).
+	 */
+	protected static boolean isKeyword(String literal) {
+		for (int i = 0, end = literal.length(); i < end; i++) {
+			char c = literal.charAt(i);
+			if (!isKeywordChar(c))
+				return false;
+		}
+		return true;
+	}
+	
+	/**
+	 * Determines whether the given character could possibly 
+	 * be part of a keyword (as opposed to an operator).
+	 */
+	protected static boolean isKeywordChar(char c) {
+		return Character.isLetterOrDigit(c) || c == '_';
+	}
+	
+	protected static boolean isStringLiteral(LabelInfo label) {
+		return topdownHasSpaces(label.getRHS());
+	}
+	
+	private static boolean topdownHasSpaces(ATerm term) {
+		// Return true if any character range of this contains spaces
+		for (int i = 0; i < term.getChildCount(); i++) {
+			ATerm child = termAt(term, i);
+			if (isAppl(child) && asAppl(child).getName().equals("range")) {
+				int start = intAt(child, RANGE_START);
+				int end = intAt(child, RANGE_END);
+				if (start <= ' ' && ' ' <= end) return true;
+			} else {
+				if (topdownHasSpaces(child)) return true;
+			}
+		}
+		
+		return false;
+	}
+	
+	protected static boolean isNumberLiteral(LabelInfo label) {
+		ATerm range = getFirstRange(label.getLHS());
+		
+		return range != null && intAt(range, RANGE_START) == '0' && intAt(range, RANGE_END) == '9';
+	}
+	
+	private static ATerm getFirstRange(ATerm term) {
+		// Get very first character range in this term
+		for (int i = 0; i < term.getChildCount(); i++) {
+			ATerm child = termAt(term, i);
+			if (isAppl(child) && asAppl(child).getName().equals("range")) {
+				return child;
+			} else {
+				child = getFirstRange(child);
+				if (child != null) return child;
+			}
+		}
+		
+		return null;
+	}
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Tokenizer.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Tokenizer.java	Thu Dec 16 15:04:08 2010	(r21536)
@@ -0,0 +1,125 @@
+package org.spoofax.jsglr.client.imploder;
+
+import static org.spoofax.jsglr.client.imploder.IToken.*;
+
+import java.util.ArrayList;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class Tokenizer implements ITokenizer {
+	
+	private static final int EXPECTED_TOKENS_DIVIDER = 5;
+	
+	private final TokenKindManager manager =
+		new TokenKindManager();
+	
+	private char[] inputChars;
+	
+	/** Start of the next token. */
+	private int startOffset;
+
+	private ArrayList<IToken> tokens;
+	
+	public void initialize(char[] inputChars) {
+		this.inputChars = inputChars;
+		this.tokens = new ArrayList<IToken>(inputChars.length / EXPECTED_TOKENS_DIVIDER);
+		startOffset = 0;
+	}
+	
+	public final char[] getInputChars() {
+		return inputChars;
+	}
+	
+	public final int getStartOffset() {
+		return startOffset;
+	}
+
+	public void setStartOffset(int startOffset) {
+		this.startOffset = startOffset;
+	}
+
+	public IToken currentToken() {
+		return tokens.size() == 0
+			? null
+			:tokens.get(tokens.size() - 1);
+	}
+	
+	public int getTokenCount() {
+		return tokens.size();
+	}
+	
+	public IToken getTokenAt(int i) {
+		return tokens.get(i);
+	}
+
+	public IToken makeToken(int offset, LabelInfo label) {
+		return makeToken(offset, label, false);
+	}
+
+	public IToken makeToken(int endOffset, LabelInfo label, boolean allowEmptyToken) {
+		return makeToken(endOffset, manager.getTokenKind(label), allowEmptyToken);
+	}
+	
+	public IToken makeToken(int endOffset, int kind, boolean allowEmptyToken) {
+		if (!allowEmptyToken && startOffset >= endOffset) // empty token
+			return null;
+		
+		assert endOffset >= startOffset || (kind == TK_RESERVED && startOffset == 0);
+		IToken result = new Token(this, tokens.size() - 1, endOffset, endOffset, kind);
+		tokens.add(result);
+		return result;
+	}
+
+	/**
+	 * Creates an artificial token at keyword boundaries
+	 * inside skipped regions of code.
+	 * Required for keyword highlighting with {@link KeywordRecognizer}.
+	 */
+	public IToken createSkippedToken(int offset, char inputChar, char prevChar) {
+		boolean isInputKeywordChar = isKeywordChar(inputChar);
+		if (offset > 0 && offset - 1 > getStartOffset()) {
+			if ((isInputKeywordChar && !isKeywordChar(prevChar))
+					|| (!isInputKeywordChar && isKeywordChar(prevChar))) {
+				return makeToken(offset - 1, TK_ERROR, false);
+			}
+		}
+		if (offset + 1 < inputChars.length) {
+			char nextChar = inputChars[offset + 1];
+			if ((isInputKeywordChar && !isKeywordChar(nextChar))
+					|| (!isInputKeywordChar && isKeywordChar(nextChar))) {
+				return makeToken(offset + 1, TK_ERROR, false);
+			}
+		}
+		return null;
+	}
+	
+	/**
+	 * Determines whether the given character could possibly 
+	 * be part of a keyword (as opposed to an operator).
+	 */
+	private boolean isKeywordChar(char c) {
+		return Character.isLetterOrDigit(c) || c == '_';
+	}
+
+	/**
+	 * Creates an artificial token for every water-based recovery
+	 * and for comments within layout.
+	 */
+	public void createLayoutToken(int offset, int lastOffset, LabelInfo label) {
+		// Create separate tokens for >1 char layout lexicals (e.g., comments)
+		if (offset > lastOffset + 1 && label.isLexLayout()) {
+			if (startOffset <= lastOffset)
+				makeToken(lastOffset, TK_LAYOUT, false);
+			makeToken(offset, TK_LAYOUT, false);
+		} else {
+			String sort = label.getSort();
+			if ("WATERTOKEN".equals(sort) || "WATERTOKENSEPARATOR".equals(sort)) {
+				if (getStartOffset() <= lastOffset)
+					makeToken(lastOffset, TK_LAYOUT, false);
+				makeToken(offset, TK_ERROR, false);
+			}
+		}
+	}
+
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TopdownTreeBuilder.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TopdownTreeBuilder.java	Thu Dec 16 15:04:08 2010	(r21536)
@@ -0,0 +1,46 @@
+package org.spoofax.jsglr.client.imploder;
+
+import org.spoofax.jsglr.client.AbstractParseNode;
+import org.spoofax.jsglr.client.Amb;
+import org.spoofax.jsglr.client.ITreeBuilder;
+import org.spoofax.jsglr.client.ParseNode;
+import org.spoofax.jsglr.client.ParseProductionNode;
+
+/**
+ * An abstract top-down tree builder implementation.
+ * For most uses, the bottom-up one should be more suitable.
+ * 
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public abstract class TopdownTreeBuilder implements ITreeBuilder {
+
+	public void initialize(int productionCount, int labelCount) {
+		
+	}
+
+	/**
+	 * @deprecated
+	 *   For a best balance of performance and stack consumption, directly call
+	 *   {@link ParseNode#buildTreeBottomup} instead.
+	 */
+	public final Object buildTree(AbstractParseNode node) {
+		if (node instanceof ParseNode) {
+			return buildTreeNode((ParseNode) node);
+		} else if (node instanceof ParseProductionNode) {
+			return buildTreeProduction((ParseProductionNode) node);
+		} else {
+			assert node instanceof Amb;
+			return buildTreeAmb((Amb) node);
+		}
+	}
+
+	public Object buildTreeTop(Object subtree, int ambiguityCount) {
+		return subtree;
+	}
+
+	public abstract Object buildTreeNode(ParseNode node);
+
+	public abstract Object buildTreeProduction(ParseProductionNode node);
+
+	public abstract Object buildTreeAmb(Amb node);
+}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java	Thu Dec 16 15:03:58 2010	(r21535)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java	Thu Dec 16 15:04:08 2010	(r21536)
@@ -4,8 +4,8 @@
 import java.util.LinkedList;
 import java.util.List;
 
-import org.spoofax.jsglr.client.IToken;
 import org.spoofax.jsglr.client.NotImplementedException;
+import org.spoofax.jsglr.client.imploder.IToken;
 
 public abstract class ATerm implements Serializable {
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestImplode.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestImplode.java	Thu Dec 16 15:03:58 2010	(r21535)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestImplode.java	Thu Dec 16 15:04:08 2010	(r21536)
@@ -3,9 +3,9 @@
 import java.io.FileNotFoundException;
 import java.io.IOException;
 
-import org.spoofax.jsglr.client.ImplodedTreeBuilder;
 import org.spoofax.jsglr.client.InvalidParseTableException;
 import org.spoofax.jsglr.client.ParserException;
+import org.spoofax.jsglr.client.imploder.ImplodedTreeBuilder;
 
 /**
  * @author Lennart Kats <lennart add lclnet.nl>

From karltk at strategoxt.org  Thu Dec 16 16:04:15 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:04:15 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21537 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt: src/org/spoofax/jsglr/client
	src/org/spoofax/jsglr/client/imploder test/org/spoofax/jsglr/tests
Message-ID: <201012161504.oBGF4F6S027391@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:04:14 2010
New Revision: 21537
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21537&sc=1

Log:
Renamed some classes (removing "Imploded" everywhere in the imploder package).

Added:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ATermTreeFactory.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITreeFactory.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java
Deleted:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ATermImplodedTreeFactory.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/IImplodedTreeFactory.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ImplodedTreeBuilder.java
Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/AstAnnoImploder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITokenizer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestImplode.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 15:04:08 2010	(r21536)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 15:04:14 2010	(r21537)
@@ -14,7 +14,7 @@
 import java.util.Set;
 
 import org.spoofax.jsglr.client.imploder.ITokenizer;
-import org.spoofax.jsglr.client.imploder.ImplodedTreeBuilder;
+import org.spoofax.jsglr.client.imploder.TreeBuilder;
 import org.spoofax.jsglr.shared.ArrayDeque;
 import org.spoofax.jsglr.shared.BadTokenException;
 import org.spoofax.jsglr.shared.SGLRException;
@@ -868,8 +868,8 @@
 		return parseTable;
 	}
 
-	public void setTreeBuilder(ImplodedTreeBuilder implodedTreeBuilder) {
-		parseTable.setTreeBuilder(new ImplodedTreeBuilder());
+	public void setTreeBuilder(TreeBuilder treeBuilder) {
+		parseTable.setTreeBuilder(new TreeBuilder());
 	}
 
 	AmbiguityManager getAmbiguityManager() {

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ATermTreeFactory.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ATermTreeFactory.java	Thu Dec 16 15:04:14 2010	(r21537)
@@ -0,0 +1,107 @@
+package org.spoofax.jsglr.client.imploder;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.spoofax.jsglr.shared.terms.AFun;
+import org.spoofax.jsglr.shared.terms.ATerm;
+import org.spoofax.jsglr.shared.terms.ATermAppl;
+import org.spoofax.jsglr.shared.terms.ATermFactory;
+import org.spoofax.jsglr.shared.terms.ATermInt;
+import org.spoofax.jsglr.shared.terms.ATermList;
+import org.spoofax.jsglr.shared.terms.ATermString;
+import org.spoofax.jsglr.shared.terms.ATermTuple;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class ATermTreeFactory implements ITreeFactory<ATerm> {
+	
+	private final ATermFactory factory;
+	
+	public ATermTreeFactory() {
+		this(new ATermFactory());
+	}
+	
+	public ATermTreeFactory(ATermFactory factory) {
+		this.factory = factory;
+	}
+	
+	public AFun createConstructor(String name, int childCount) {
+		return factory.makeAFun(name, childCount, false);
+	}
+
+	public ATermAppl createNonTerminal(String sort, String constructor,
+			IToken leftToken, IToken rightToken, List<ATerm> children) {
+		
+		// TODO: Optimize - cache afuns? hard to do up front, messy to do now in the LabelInfo objects 
+		AFun afun = factory.makeAFun(constructor, children.size(), false);
+		ATermAppl result = factory.makeAppl(afun, toArray(children));
+		result.internalSetTokens(leftToken, rightToken);
+		return result;
+	}
+
+	public ATermInt createIntTerminal(String sort, IToken token, int value) {
+		ATermInt result = factory.makeInt(value);
+		result.internalSetTokens(token, token);
+		return result;
+	}
+
+	public ATerm createRealTerminal(String sort, IToken token, double value) {
+		throw new UnsupportedOperationException("ATermReal not supported");
+	}
+
+	public ATermString createStringTerminal(String sort, String value, IToken token) {
+		ATermString result = factory.makeString(value);
+		result.internalSetTokens(token, token);
+		return result;
+	}
+
+	public ATermTuple createTuple(String elementSort, IToken leftToken,
+			IToken rightToken, List<ATerm> children) {
+		
+		ATermTuple result = factory.makeTuple(toArray(children));
+		result.internalSetTokens(leftToken, rightToken);
+		return result;
+	}
+
+	public ATermAppl createAmb(List<ATerm> alternatives) {
+		IToken leftToken = alternatives.get(0).getLeftToken();
+		IToken rightToken = alternatives.get(alternatives.size() - 1).getRightToken();
+		return createNonTerminal(null, "amb", leftToken, rightToken, alternatives);
+	}
+
+	public ATermList createList(String elementSort, IToken leftToken,
+			IToken rightToken, List<ATerm> children) {
+		
+		ATermList result = factory.makeList(toArray(children));
+		result.internalSetTokens(leftToken, rightToken);
+		return result;
+	}
+
+	public boolean isStringTerminal(ATerm node) {
+		return node.getType() == ATerm.STRING;
+	}
+
+	public ATerm createInjection(String sort, List<ATerm> children) {
+		return children.get(0);
+	}
+
+	public Iterable<ATerm> getChildren(ATerm node) {
+		if (node instanceof Iterable<?>) {
+			@SuppressWarnings("unchecked")
+			Iterable<ATerm> result = (Iterable<ATerm>) node;
+			return result;
+		} else {
+			ArrayList<ATerm> children = new ArrayList<ATerm>(node.getChildCount());
+			for (int i = 0, max = node.getChildCount(); i < max; i++) {
+				children.add(node.getChildAt(i));
+			}
+			return children;
+		}
+	}
+
+	private static ATerm[] toArray(List<ATerm> children) {
+		return children.toArray(new ATerm[children.size()]);
+	}
+}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/AstAnnoImploder.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/AstAnnoImploder.java	Thu Dec 16 15:04:08 2010	(r21536)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/AstAnnoImploder.java	Thu Dec 16 15:04:14 2010	(r21537)
@@ -24,7 +24,7 @@
  */
 public class AstAnnoImploder<TNode> {
 
-	private final IImplodedTreeFactory<TNode> factory;
+	private final ITreeFactory<TNode> factory;
 	
 	private final List<TNode> placeholderValues;
 	
@@ -32,7 +32,7 @@
 	
 	private final ATermFactory termFactory;
 	
-	public AstAnnoImploder(IImplodedTreeFactory<TNode> factory, ATermFactory termFactory, List<TNode> placeholderValues, IToken leftToken, IToken rightToken) {
+	public AstAnnoImploder(ITreeFactory<TNode> factory, ATermFactory termFactory, List<TNode> placeholderValues, IToken leftToken, IToken rightToken) {
 		this.factory = factory;
 		this.termFactory = termFactory;
 		this.placeholderValues = placeholderValues;

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITokenizer.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITokenizer.java	Thu Dec 16 15:04:08 2010	(r21536)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITokenizer.java	Thu Dec 16 15:04:14 2010	(r21537)
@@ -5,6 +5,7 @@
  */
 public interface ITokenizer {
 	
+	// TODO: Optimize - use String in tokenizer?
 	void initialize(char[] inputChars);
 
 	char[] getInputChars();

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITreeFactory.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITreeFactory.java	Thu Dec 16 15:04:14 2010	(r21537)
@@ -0,0 +1,50 @@
+package org.spoofax.jsglr.client.imploder;
+
+import java.util.List;
+
+
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public interface ITreeFactory<TNode> {
+
+	/**
+	 * Create a new non-terminal node (or a terminal with only a constructor).
+	 */
+	public TNode createNonTerminal(String sort, String constructor, IToken leftToken, IToken rightToken,
+			List<TNode> children);
+	
+	/**
+	 * Create a new terminal node for an int value.
+	 */
+	public TNode createIntTerminal(String sort, IToken token, int value);
+	
+	/**
+	 * Create a new terminal node for an real value.
+	 */
+	public TNode createRealTerminal(String sort, IToken token, double value);
+	
+	/**
+	 * Create a new terminal node for a string token.
+	 */
+	public TNode createStringTerminal(String sort, String value, IToken token);
+	
+	public TNode createTuple(String elementSort, IToken leftToken, IToken rightToken, List<TNode> children);
+	
+	/**
+	 * Create a new node list. 
+	 */
+	public TNode createList(String elementSort, IToken leftToken, IToken rightToken, List<TNode> children);
+
+	public TNode createAmb(List<TNode> alternatives);
+
+	/**
+	 * Create an injection node.
+	 */
+	public TNode createInjection(String sort, List<TNode> children);
+	
+	public boolean isStringTerminal(TNode node);
+	
+	public Iterable<TNode> getChildren(TNode node);
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java	Thu Dec 16 15:04:14 2010	(r21537)
@@ -0,0 +1,359 @@
+package org.spoofax.jsglr.client.imploder;
+
+import static java.lang.Math.max;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.spoofax.jsglr.client.AbstractParseNode;
+import org.spoofax.jsglr.client.Amb;
+import org.spoofax.jsglr.client.ParseNode;
+import org.spoofax.jsglr.client.ParseProductionNode;
+import org.spoofax.jsglr.client.ParseTable;
+import org.spoofax.jsglr.client.RecoveryConnector;
+import org.spoofax.jsglr.shared.terms.ATermAppl;
+import org.spoofax.jsglr.shared.terms.ATermFactory;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+ at SuppressWarnings({"rawtypes", "unchecked"})
+public class TreeBuilder extends TopdownTreeBuilder {
+	
+	public static final char SKIPPED_CHAR = (char) -1; // TODO: sync with ParseErorHandler
+	
+	public static final char UNEXPECTED_EOF_CHAR = (char) -2; // TODO: sync with ParseErorHandler
+	
+	private static final int NONE = -1;
+
+	private static final int EXPECTED_NODE_CHILDREN = 5;
+	
+	private static final String LIST_CONSTRUCTOR = new String("[]");
+	
+	private static final String TUPLE_CONSTRUCTOR = new String("");
+	
+	private final ITokenizer tokenizer;
+	
+	private ITreeFactory factory;
+	
+	private boolean useDefaultFactory;
+	
+	private ProductionAttributeReader prodReader;
+
+	private ATermFactory termFactory;
+	
+	private LabelInfo[] labels;
+	
+	private int labelStart;
+	
+	/** Character offset for the current implosion. */ 
+	private int offset;
+	
+	private int nonMatchingOffset = NONE;
+	
+	private char nonMatchingChar, nonMatchingCharExpected, prevChar;
+	
+	private boolean inLexicalContext;
+	
+	public TreeBuilder() {
+		this(null, new Tokenizer());
+		this.useDefaultFactory = true;
+	}
+	
+	public TreeBuilder(ITreeFactory treeFactory, ITokenizer tokenizer) {
+		this.factory = treeFactory;
+		this.tokenizer = tokenizer;
+	}
+
+	public void initialize(ParseTable table, int productionCount, int labelStart, int labelCount) {
+		this.termFactory = table.getFactory();
+		if (useDefaultFactory)
+			factory = new ATermTreeFactory(termFactory);
+		this.prodReader = new ProductionAttributeReader(termFactory);
+		this.labels = new LabelInfo[labelCount - labelStart];
+		this.labelStart = labelStart;
+	}
+
+	public void initializeLabel(int labelNumber, ATermAppl parseTreeProduction) {
+		labels[labelNumber - labelStart] = new LabelInfo(prodReader, parseTreeProduction);
+	}
+	
+	public ITokenizer getTokenizer() {
+		return tokenizer;
+	}
+	
+	@Override
+	public Object buildTreeNode(ParseNode node) {
+		LabelInfo label = labels[node.getLabel() - labelStart];
+		IToken prevToken = tokenizer.currentToken();
+		int lastOffset = offset;
+		AbstractParseNode[] subnodes = node.getChildren();
+		
+		boolean lexicalStart = !inLexicalContext && label.isLexicalLiteralOrLayout();
+		if (lexicalStart) inLexicalContext = true;
+		
+		if (!inLexicalContext
+				&& subnodes.length > 0 && subnodes[0] instanceof ParseProductionNode
+				&& label.isSortProduction()
+				&& label.getLHS().getChildCount() == 1) {
+			return createIntTerminal(label, subnodes);
+		}
+		
+		boolean isVar  = !inLexicalContext && label.isVar();
+		if (isVar) inLexicalContext = true;
+		
+		// TODO: Optimize - one particularly gnarly optimization would be to reuse the subnodes array here
+		//                  and in buildTreeAmb
+		ArrayList<Object> children = null;
+		if (!inLexicalContext)
+			children = new ArrayList<Object>(max(EXPECTED_NODE_CHILDREN, subnodes.length));
+
+		// Recurse
+		for (AbstractParseNode subnode : subnodes) {
+			Object child = subnode.toTreeTopdown(this);
+			if (child != null) children.add(child);
+		}
+		
+		if (lexicalStart || isVar) {
+			return createStringTerminal(label);
+		} else if (inLexicalContext) {
+			tokenizer.createLayoutToken(offset, lastOffset, label);
+			return null; // don't create tokens inside lexical context; just create one big token at the top
+		} else {
+			return createNodeOrInjection(label, prevToken, children);
+		}
+	}
+
+	public Object buildTreeAmb(Amb a) {
+		final int oldOffset = offset;
+		final int oldBeginOffset = tokenizer.getStartOffset();
+		final boolean oldLexicalContext = inLexicalContext;
+		final AbstractParseNode[] subnodes = a.getAlternatives();
+		final ArrayList<Object> children =
+			new ArrayList<Object>(max(EXPECTED_NODE_CHILDREN, subnodes.length));
+
+		// Recurse
+		for (AbstractParseNode subnode : subnodes) {
+			// Restore lexical state for each branch
+			offset = oldOffset;
+			tokenizer.setStartOffset(oldBeginOffset);
+			inLexicalContext = oldLexicalContext;
+			
+			Object child = subnode.toTreeTopdown(this);
+			if (child != null) children.add(child);
+		}
+		return factory.createAmb(children);
+	}
+
+	public Object buildTreeProduction(ParseProductionNode node) {
+		int character = node.prod;
+		consumeLexicalChar(character);
+		return null;
+	}
+
+
+	private Object createStringTerminal(LabelInfo label) {
+		inLexicalContext = false;
+		String sort = label.getSort();
+		IToken token = tokenizer.makeToken(offset, label, sort != null);
+		
+		if (sort == null) return null;
+		
+		// Debug.log("Creating node ", sort, " from ", SGLRTokenizer.dumpToString(token));
+		
+		Object result = factory.createStringTerminal(sort, getPaddedLexicalValue(label, token), token);
+		String constructor = label.getMetaVarConstructor();
+		if (constructor != null) {
+			ArrayList<Object> children = new ArrayList<Object>(1);
+			children.add(result);
+			result = factory.createNonTerminal(sort, constructor, token, token, children);
+		}
+		return result;
+	}
+	
+	private Object createIntTerminal(LabelInfo label, AbstractParseNode[] contents) {
+		IToken token = tokenizer.makeToken(offset, label, true);
+		int value = contents.length == 1 && contents[0] instanceof ParseProductionNode
+			? ((ParseProductionNode) contents[0]).prod : -1;
+		assert value != -1;
+		return factory.createIntTerminal(label.getSort(), token, value);
+	}
+
+	private Object createNodeOrInjection(LabelInfo label, IToken prevToken, List<Object> children) {
+		
+		String constructor = label.getConstructor();
+		
+		if (label.isList()) {
+			return createNode(label, LIST_CONSTRUCTOR, prevToken, children);
+		} else if (constructor != null) {
+			tokenizer.makeToken(offset, label); // TODO: why makeToken here??
+			return createNode(label, constructor, prevToken, children);
+		} else if (label.getAstAttribute() != null) {
+			return createAstNonTerminal(label, prevToken, children);
+		} else if (label.isOptional()) {
+			// TODO: Spoofax/295: JSGLR does not output correct AST for optional literals
+			if (children.size() == 0) {
+				return createNode(label, "None", prevToken, children);
+			} else {
+				assert children.size() == 1;
+				return createNode(label, "Some", prevToken, children);
+			}
+		} else if (children.size() == 1) {
+			// Injection
+			// TODO: efficiently store injection sort for use by content completion?
+			//       would be needed to distinguish FoldingRules and Sorts in "folding" sections...
+			//       maybe only if the content proposer demands it?
+			// TODO: also, avoid semantics for deprecated?
+			return factory.createInjection(label.getSort(), children);
+		} else {
+			// Constructor-less application (tuple)
+			return createNode(label, TUPLE_CONSTRUCTOR, prevToken, children);
+		}
+	}
+
+	/**
+	 * Create a context-free tree node.
+	 * 
+	 * @param constructor
+	 *          The constructor to use, or {@link #LIST_CONSTRUCTOR} to construct a list,
+	 *          or {@link #TUPLE_CONSTRUCTOR} to construct a tuple.
+	 */
+	private Object createNode(LabelInfo label, String constructor, IToken prevToken,
+			List<Object> children) {
+		
+		IToken left = getStartToken(prevToken);
+		IToken right = getEndToken(left, tokenizer.currentToken());
+		
+		if (constructor == LIST_CONSTRUCTOR) {
+			return factory.createList(label.getSort(), left, right, children);
+		} else if (constructor == TUPLE_CONSTRUCTOR) {
+			return factory.createTuple(label.getSort(), left, right, children);
+		} else if (constructor == null && children.size() == 1 && factory.isStringTerminal(children.get(0))) {
+			// Child node was a <string> node (rare case); unpack it and create a new terminal
+			assert left == right;
+			return factory.createStringTerminal(label.getSort(), getPaddedLexicalValue(label, left), left);
+		} else {
+			return factory.createNonTerminal(label.getSort(), constructor, left, right, children);
+		}
+	}
+	
+	/**
+	 * Gets the padded lexical value for {indentpadding} lexicals, or returns null.
+	 */
+	private String getPaddedLexicalValue(LabelInfo label, IToken startToken) {
+		if (label.isIndentPaddingLexical()) {
+			char[] inputChars = tokenizer.getInputChars();
+			int lineStart = startToken.getStartOffset() - 1;
+			if (lineStart < 0) return null;
+			while (lineStart >= 0) {
+				char c = inputChars[lineStart--];
+				if (c == '\n' || c == '\r') {
+					lineStart++;
+					break;
+				}
+			}
+			StringBuilder result = new StringBuilder();
+			result.append(inputChars, lineStart, startToken.getStartOffset() - lineStart - 1);
+			for (int i = 0; i < result.length(); i++) {
+				char c = result.charAt(i);
+				if (c != ' ' && c != '\t') result.setCharAt(i, ' ');
+			}
+			result.append(startToken.toString());
+			return result.toString();
+		} else {
+			return null; // lazily load token string value
+		}
+	}
+
+	/** Implode a context-free node with an {ast} annotation. */
+	private Object createAstNonTerminal(LabelInfo label, IToken prevToken, List<Object> children) {
+		IToken left = getStartToken(prevToken);
+		IToken right = getEndToken(left, tokenizer.currentToken());
+		AstAnnoImploder imploder = new AstAnnoImploder<Object>(factory, termFactory, children, left, right);
+		return imploder.implode(label.getAstAttribute(), label.getSort());
+	}
+	
+	/** Get the token after the previous node's ending token, or null if N/A. */
+	private IToken getStartToken(IToken prevToken) {
+		if (prevToken == null) {
+			return tokenizer.getTokenCount() == 0
+				? null
+			    : tokenizer.getTokenAt(0);
+		} else {
+			int index = prevToken.getIndex();
+			
+			if (tokenizer.getTokenCount() - index <= 1) {
+				// Create new empty token
+				// HACK: Assume TK_LAYOUT kind for empty tokens in AST nodes
+				return tokenizer.makeToken(offset, IToken.TK_LAYOUT, true);
+			} else {
+				return tokenizer.getTokenAt(index + 1); 
+			}
+		}
+	}
+	
+	/** Get the last no-layout token for an AST node. */
+	private IToken getEndToken(IToken startToken, IToken lastToken) {
+		int begin = startToken.getIndex();
+		
+		for (int i = lastToken.getIndex(); i > begin; i--) {
+			lastToken = tokenizer.getTokenAt(i);
+			if (lastToken.getKind() != IToken.TK_LAYOUT
+					|| lastToken.getStartOffset() == lastToken.getEndOffset()-1)
+				break;
+		}
+		
+		return lastToken;
+	}
+	
+	/** Consume a character of a lexical terminal. */
+	protected final void consumeLexicalChar(int character) {
+		char[] inputChars = tokenizer.getInputChars();
+		if (offset >= inputChars.length) {
+			if (nonMatchingOffset != NONE) {
+				assert false : "Character in parse tree after end of input stream: "
+						+ (char) character
+						+ " - may be caused by unexcepted character in parse tree at position "
+						+ nonMatchingChar 	+ ": " + nonMatchingChar + " instead of "
+						+ nonMatchingCharExpected;
+			}
+		    // UNDONE: Strict lexical stream checking
+			// throw new ImploderException("Character in parse tree after end of input stream: " + (char) character.getInt());
+			// a forced reduction may have added some extra characters to the tree;
+			inputChars[inputChars.length - 1] = UNEXPECTED_EOF_CHAR;
+			return;
+		}
+		
+		char parsedChar = (char) character;
+		char inputChar = inputChars[offset];
+		
+		if (parsedChar != inputChar) {
+			if (RecoveryConnector.isLayoutCharacter(parsedChar)) {
+				// Remember that the parser skipped the current character
+				// for later error reporting. (Cannot modify the immutable
+				// parse tree here; changing the original stream instead.)
+				inputChars[offset] = SKIPPED_CHAR;
+				tokenizer.createSkippedToken(offset, inputChar, prevChar);
+				offset++;
+			} else {
+				// UNDONE: Strict lexical stream checking
+				// throw new IllegalStateException("Character from asfix stream (" + parsedChar
+				//	 	+ ") must be in lex stream (" + inputChar + ")");
+			    // instead, we allow the non-matching character for now, and hope
+			    // we can pick up the right track later
+				// TODO: better way to report skipped fragments in the parser
+				//       this isn't 100% reliable
+				if (nonMatchingOffset == NONE) {
+					nonMatchingOffset = offset;
+					nonMatchingChar = parsedChar;
+					nonMatchingCharExpected = inputChar;
+				}
+				inputChars[offset] = SKIPPED_CHAR;
+			}
+		} else {
+			offset++;
+		}
+		prevChar = inputChar;
+	}
+
+}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestImplode.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestImplode.java	Thu Dec 16 15:04:08 2010	(r21536)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestImplode.java	Thu Dec 16 15:04:14 2010	(r21537)
@@ -5,7 +5,7 @@
 
 import org.spoofax.jsglr.client.InvalidParseTableException;
 import org.spoofax.jsglr.client.ParserException;
-import org.spoofax.jsglr.client.imploder.ImplodedTreeBuilder;
+import org.spoofax.jsglr.client.imploder.TreeBuilder;
 
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
@@ -15,7 +15,7 @@
     @Override
 	public void gwtSetUp() throws ParserException, InvalidParseTableException {
         super.gwtSetUp("Java-15", "java");
-        sglr.setTreeBuilder(new ImplodedTreeBuilder());
+        sglr.setTreeBuilder(new TreeBuilder());
         // TODO: compare results
         doCompare = false;
     }

From karltk at strategoxt.org  Thu Dec 16 16:04:21 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:04:21 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21538 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt: src/org/spoofax/jsglr/client
	src/org/spoofax/jsglr/client/imploder test/org/spoofax/jsglr/tests
Message-ID: <201012161504.oBGF4Lp6027399@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:04:20 2010
New Revision: 21538
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21538&sc=1

Log:
Tokenizer fixes; added line numbers; multi-line tokens are now split up.

Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/DummyTokenizer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITokenizer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/LabelInfo.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Token.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Tokenizer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java	Thu Dec 16 15:04:14 2010	(r21537)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java	Thu Dec 16 15:04:20 2010	(r21538)
@@ -7,6 +7,7 @@
  */
 package org.spoofax.jsglr.client;
 
+import java.util.Arrays;
 import java.util.List;
 
 import org.spoofax.jsglr.client.imploder.TopdownTreeBuilder;
@@ -59,7 +60,7 @@
 
     @Override
     public String toString() {
-        return "regular(aprod(" + label + ")," + kids + ")";
+        return "regular(aprod(" + label + ")," + Arrays.toString(kids) + ")";
     }
 
     public int getLabel() {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/DummyTokenizer.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/DummyTokenizer.java	Thu Dec 16 15:04:14 2010	(r21537)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/DummyTokenizer.java	Thu Dec 16 15:04:20 2010	(r21538)
@@ -5,7 +5,7 @@
  */
 public class DummyTokenizer implements ITokenizer {
 	
-	private final IToken onlyToken = new Token(this, 0, 0, 0, IToken.TK_UNKNOWN);
+	private final IToken onlyToken = new Token(this, 0, 0, 0, 0, IToken.TK_UNKNOWN);
 	
 	private char[] inputChars;
 	
@@ -61,5 +61,9 @@
 	public void createLayoutToken(int offset, int lastOffset, LabelInfo label) {
 		// Do nothing
 	}
+	
+	public String toString(IToken left, IToken right) {
+		return "";
+	}
 
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITokenizer.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITokenizer.java	Thu Dec 16 15:04:14 2010	(r21537)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITokenizer.java	Thu Dec 16 15:04:20 2010	(r21538)
@@ -39,4 +39,6 @@
 	 */
 	void createLayoutToken(int offset, int lastOffset, LabelInfo label);
 
+	String toString(IToken left, IToken right);
+
 }
\ No newline at end of file

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/LabelInfo.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/LabelInfo.java	Thu Dec 16 15:04:14 2010	(r21537)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/LabelInfo.java	Thu Dec 16 15:04:20 2010	(r21538)
@@ -128,4 +128,9 @@
 	public boolean isOptional() {
 		return reader.isOptional(getRHS());
 	}
+	
+	@Override
+	public String toString() {
+		return production.toString();
+	}
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Token.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Token.java	Thu Dec 16 15:04:14 2010	(r21537)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Token.java	Thu Dec 16 15:04:20 2010	(r21538)
@@ -9,16 +9,21 @@
 
 	private final ITokenizer tokenizer;
 	
-	private final int index, startOffset, endOffset, kind;
+	private final int index, startOffset, endOffset, line, kind;
 
-	public Token(ITokenizer tokenizer, int index, int startOffset, int endOffset, int kind) {
+	public Token(ITokenizer tokenizer, int index, int line, int startOffset, int endOffset, int kind) {
 		this.tokenizer = tokenizer;
 		this.index = index;
+		this.line = line;
 		this.startOffset = startOffset;
 		this.endOffset = endOffset;
 		this.kind = kind;
 	}
 	
+	public ITokenizer getTokenizer() {
+		return tokenizer;
+	}
+	
 	public int getKind() {
 		return kind;
 	}
@@ -36,13 +41,17 @@
 	}
 
 	public int getLine() {
-		// TODO
-		throw new NotImplementedException();
+		return line;
 	}
 	
 	public int getColumn() {
 		// TODO
 		throw new NotImplementedException();
 	}
+	
+	@Override
+	public String toString() {
+		return tokenizer.toString(this, this);
+	}
 
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Tokenizer.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Tokenizer.java	Thu Dec 16 15:04:14 2010	(r21537)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Tokenizer.java	Thu Dec 16 15:04:20 2010	(r21538)
@@ -1,5 +1,6 @@
 package org.spoofax.jsglr.client.imploder;
 
+import static java.lang.Math.min;
 import static org.spoofax.jsglr.client.imploder.IToken.*;
 
 import java.util.ArrayList;
@@ -15,16 +16,21 @@
 		new TokenKindManager();
 	
 	private char[] inputChars;
+
+	private ArrayList<IToken> tokens;
 	
 	/** Start of the next token. */
 	private int startOffset;
-
-	private ArrayList<IToken> tokens;
+	
+	/** Line number of the next token. */
+	private int line; // TODO: first line zero or one??
 	
 	public void initialize(char[] inputChars) {
 		this.inputChars = inputChars;
 		this.tokens = new ArrayList<IToken>(inputChars.length / EXPECTED_TOKENS_DIVIDER);
 		startOffset = 0;
+		// Ensure there's at least one token
+		tokens.add(new Token(this, 0, line, 0, -1, TK_RESERVED));
 	}
 	
 	public final char[] getInputChars() {
@@ -42,7 +48,7 @@
 	public IToken currentToken() {
 		return tokens.size() == 0
 			? null
-			:tokens.get(tokens.size() - 1);
+			: tokens.get(tokens.size() - 1);
 	}
 	
 	public int getTokenCount() {
@@ -53,8 +59,8 @@
 		return tokens.get(i);
 	}
 
-	public IToken makeToken(int offset, LabelInfo label) {
-		return makeToken(offset, label, false);
+	public IToken makeToken(int endOffset, LabelInfo label) {
+		return makeToken(endOffset, label, false);
 	}
 
 	public IToken makeToken(int endOffset, LabelInfo label, boolean allowEmptyToken) {
@@ -62,12 +68,34 @@
 	}
 	
 	public IToken makeToken(int endOffset, int kind, boolean allowEmptyToken) {
-		if (!allowEmptyToken && startOffset >= endOffset) // empty token
+		if (!allowEmptyToken && startOffset > endOffset) // empty token
 			return null;
 		
 		assert endOffset >= startOffset || (kind == TK_RESERVED && startOffset == 0);
-		IToken result = new Token(this, tokens.size() - 1, endOffset, endOffset, kind);
+		
+		char[] chars = inputChars;
+		int offset;
+		IToken token = null;
+		for (offset = min(startOffset, endOffset); offset < endOffset; offset++) {
+			if (chars[offset] == '\n') {
+				if (offset - 1 > startOffset)
+					token = internalMakeToken(kind, offset - 1);
+				internalMakeToken(kind, offset); // newline
+			}
+		}
+		
+		if (token == null || offset <= endOffset) {
+			return internalMakeToken(kind, offset);
+		} else {
+			return token;
+		}
+	}
+
+	private IToken internalMakeToken(int kind, int offset) {
+		IToken result = new Token(this, tokens.size() - 1, line, startOffset, offset, kind);
 		tokens.add(result);
+		startOffset = offset + 1;
+		line++;
 		return result;
 	}
 
@@ -77,18 +105,19 @@
 	 * Required for keyword highlighting with {@link KeywordRecognizer}.
 	 */
 	public IToken createSkippedToken(int offset, char inputChar, char prevChar) {
+		// FIXME: off-by-one errors?? offset passed is now offset - 1 c.f. old SGLRTokenizer
 		boolean isInputKeywordChar = isKeywordChar(inputChar);
-		if (offset > 0 && offset - 1 > getStartOffset()) {
+		if (offset > 0 && offset > getStartOffset()) {
 			if ((isInputKeywordChar && !isKeywordChar(prevChar))
 					|| (!isInputKeywordChar && isKeywordChar(prevChar))) {
-				return makeToken(offset - 1, TK_ERROR, false);
+				return makeToken(offset, TK_ERROR, false);
 			}
 		}
-		if (offset + 1 < inputChars.length) {
-			char nextChar = inputChars[offset + 1];
+		if (offset + 2 < inputChars.length) {
+			char nextChar = inputChars[offset + 2];
 			if ((isInputKeywordChar && !isKeywordChar(nextChar))
 					|| (!isInputKeywordChar && isKeywordChar(nextChar))) {
-				return makeToken(offset + 1, TK_ERROR, false);
+				return makeToken(offset + 2, TK_ERROR, false);
 			}
 		}
 		return null;
@@ -121,5 +150,25 @@
 			}
 		}
 	}
+	
+	public String toString(IToken left, IToken right) {
+		int offset = left.getStartOffset();
+		return new String(inputChars, offset, right.getEndOffset() - offset + 1);
+	}
+	
+	@Override
+	public String toString() {
+		StringBuilder result = new StringBuilder();
+		result.append('[');
+		for (IToken token : tokens) {
+			int offset = token.getStartOffset();
+			result.append(inputChars, offset, token.getEndOffset() - offset + 1);
+			result.append(',');
+		}
+		if (tokens.size() > 0)
+			result.deleteCharAt(result.length() - 1);
+		result.append(']');
+		return result.toString();
+	}
 
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java	Thu Dec 16 15:04:14 2010	(r21537)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java	Thu Dec 16 15:04:20 2010	(r21538)
@@ -90,7 +90,8 @@
 		AbstractParseNode[] subnodes = node.getChildren();
 		
 		boolean lexicalStart = !inLexicalContext && label.isLexicalLiteralOrLayout();
-		if (lexicalStart) inLexicalContext = true;
+		if (lexicalStart)
+			inLexicalContext = true;
 		
 		if (!inLexicalContext
 				&& subnodes.length > 0 && subnodes[0] instanceof ParseProductionNode
@@ -110,14 +111,15 @@
 
 		// Recurse
 		for (AbstractParseNode subnode : subnodes) {
+			// TODO: Optimize stack - inline toTreeTopdown case selection?
 			Object child = subnode.toTreeTopdown(this);
 			if (child != null) children.add(child);
 		}
 		
 		if (lexicalStart || isVar) {
-			return createStringTerminal(label);
+			return tryCreateStringTerminal(label);
 		} else if (inLexicalContext) {
-			tokenizer.createLayoutToken(offset, lastOffset, label);
+			tokenizer.createLayoutToken(offset - 1, lastOffset - 1, label);
 			return null; // don't create tokens inside lexical context; just create one big token at the top
 		} else {
 			return createNodeOrInjection(label, prevToken, children);
@@ -152,10 +154,10 @@
 	}
 
 
-	private Object createStringTerminal(LabelInfo label) {
+	private Object tryCreateStringTerminal(LabelInfo label) {
 		inLexicalContext = false;
 		String sort = label.getSort();
-		IToken token = tokenizer.makeToken(offset, label, sort != null);
+		IToken token = tokenizer.makeToken(offset - 1, label, sort != null);
 		
 		if (sort == null) return null;
 		
@@ -172,7 +174,7 @@
 	}
 	
 	private Object createIntTerminal(LabelInfo label, AbstractParseNode[] contents) {
-		IToken token = tokenizer.makeToken(offset, label, true);
+		IToken token = tokenizer.makeToken(offset - 1, label, true);
 		int value = contents.length == 1 && contents[0] instanceof ParseProductionNode
 			? ((ParseProductionNode) contents[0]).prod : -1;
 		assert value != -1;
@@ -186,7 +188,7 @@
 		if (label.isList()) {
 			return createNode(label, LIST_CONSTRUCTOR, prevToken, children);
 		} else if (constructor != null) {
-			tokenizer.makeToken(offset, label); // TODO: why makeToken here??
+			// UNDONE: tokenizer.makeToken(offset, label); // TODO: why makeToken here??
 			return createNode(label, constructor, prevToken, children);
 		} else if (label.getAstAttribute() != null) {
 			return createAstNonTerminal(label, prevToken, children);
@@ -285,7 +287,7 @@
 			if (tokenizer.getTokenCount() - index <= 1) {
 				// Create new empty token
 				// HACK: Assume TK_LAYOUT kind for empty tokens in AST nodes
-				return tokenizer.makeToken(offset, IToken.TK_LAYOUT, true);
+				return tokenizer.makeToken(offset - 1, IToken.TK_LAYOUT, true);
 			} else {
 				return tokenizer.getTokenAt(index + 1); 
 			}
@@ -333,7 +335,7 @@
 				// for later error reporting. (Cannot modify the immutable
 				// parse tree here; changing the original stream instead.)
 				inputChars[offset] = SKIPPED_CHAR;
-				tokenizer.createSkippedToken(offset, inputChar, prevChar);
+				tokenizer.createSkippedToken(offset - 1, inputChar, prevChar);
 				offset++;
 			} else {
 				// UNDONE: Strict lexical stream checking

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:04:14 2010	(r21537)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:04:20 2010	(r21538)
@@ -16,6 +16,7 @@
 import org.spoofax.jsglr.client.PathListPool;
 import org.spoofax.jsglr.client.PooledPathList;
 import org.spoofax.jsglr.client.SGLR;
+import org.spoofax.jsglr.client.imploder.Token;
 import org.spoofax.jsglr.shared.SGLRException;
 import org.spoofax.jsglr.shared.Tools;
 import org.spoofax.jsglr.shared.terms.ATerm;
@@ -105,6 +106,9 @@
 			doCompare(s, parsed);
 		} else {
 			System.out.println(parsed);
+			if (parsed.getLeftToken() != null) {
+				System.out.println(((Token) parsed.getLeftToken()).getTokenizer());
+			}
 		}
 
 		System.out.println(PathListPool.cacheMisses);

From karltk at strategoxt.org  Thu Dec 16 16:04:26 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:04:26 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21539 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt:
	src/org/spoofax/jsglr/client/imploder test/org/spoofax/jsglr/tests
Message-ID: <201012161504.oBGF4QrV027402@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:04:26 2010
New Revision: 21539
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21539&sc=1

Log:
Cleanup; fixed Some/None imploding.

Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/LabelInfo.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ProductionAttributeReader.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/LabelInfo.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/LabelInfo.java	Thu Dec 16 15:04:20 2010	(r21538)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/LabelInfo.java	Thu Dec 16 15:04:26 2010	(r21539)
@@ -21,7 +21,7 @@
 	
 	private final ATerm astAttribute;
 	
-	private final boolean isLexicalLiteralOrLayout;
+	private final boolean isNonContextFree;
 	
 	private final boolean isLexical;
 
@@ -39,6 +39,8 @@
 	
 	private final boolean isLiteral;
 	
+	private final boolean isOptional;
+	
 	private final String metaVarConstructor;
 	
 	public LabelInfo(ProductionAttributeReader reader, ATermAppl production) {
@@ -49,7 +51,7 @@
 		sort = reader.getSort(rhs);
 		constructor = reader.getConsAttribute(attrs);
 		astAttribute = reader.getAstAttribute(attrs);
-		isLexicalLiteralOrLayout = reader.isLexicalLiteralOrLayout(rhs);
+		isNonContextFree = reader.isNonContextFree(rhs);
 		isList = reader.isList(rhs);
 		isVar = reader.isVariableNode(rhs);
 		isIndentPaddingLexical = reader.isIndentPaddingLexical(attrs);
@@ -57,6 +59,7 @@
 		isLexical = reader.isLexical(rhs);
 		isLayout = reader.isLayout(rhs);
 		isLiteral = reader.isLiteral(rhs);
+		isOptional = reader.isOptional(rhs);
 		isSortProduction = reader.sortFun == rhs.getAFun() || reader.parameterizedSortFun == rhs.getAFun();
 		metaVarConstructor = reader.getMetaVarConstructor(rhs);
 	}
@@ -85,8 +88,8 @@
 		return astAttribute;
 	}
 	
-	public boolean isLexicalLiteralOrLayout() {
-		return isLexicalLiteralOrLayout;
+	public boolean isNonContextFree() {
+		return isNonContextFree;
 	}
 	
 	public boolean isLexical() {
@@ -126,7 +129,7 @@
 	}
 
 	public boolean isOptional() {
-		return reader.isOptional(getRHS());
+		return isOptional;
 	}
 	
 	@Override

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ProductionAttributeReader.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ProductionAttributeReader.java	Thu Dec 16 15:04:20 2010	(r21538)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ProductionAttributeReader.java	Thu Dec 16 15:04:26 2010	(r21539)
@@ -197,9 +197,9 @@
 	 * 
 	 * @return true if the current node is lexical.
 	 */
-	public boolean isLexicalLiteralOrLayout(ATermAppl rhs) {
+	public boolean isNonContextFree(ATermAppl rhs) {
 		return (lexFun == rhs.getAFun() || isLiteral(rhs)
-		    || isLayout(rhs));
+		    || isLayout(rhs)) || isVariableNode(rhs);
 	}
 	
 	public boolean isLexical(ATermAppl rhs) {
@@ -259,7 +259,12 @@
 	}
 
 	public boolean isOptional(ATermAppl rhs) {
-		return rhs.getAFun() == optFun;
+		if (rhs.getAFun() == optFun)
+			return true;
+		rhs = termAt(rhs, 0);
+		if (rhs.getChildCount() == 1 && rhs.getAFun() == optFun)
+			return true;
+		return false;
 	}
 
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java	Thu Dec 16 15:04:20 2010	(r21538)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java	Thu Dec 16 15:04:26 2010	(r21539)
@@ -89,19 +89,17 @@
 		int lastOffset = offset;
 		AbstractParseNode[] subnodes = node.getChildren();
 		
-		boolean lexicalStart = !inLexicalContext && label.isLexicalLiteralOrLayout();
-		if (lexicalStart)
-			inLexicalContext = true;
-		
-		if (!inLexicalContext
-				&& subnodes.length > 0 && subnodes[0] instanceof ParseProductionNode
-				&& label.isSortProduction()
-				&& label.getLHS().getChildCount() == 1) {
-			return createIntTerminal(label, subnodes);
-		}
+		boolean lexicalStart = false;
 		
-		boolean isVar  = !inLexicalContext && label.isVar();
-		if (isVar) inLexicalContext = true;
+		if (!inLexicalContext) {
+			if (label.isNonContextFree()) {
+				inLexicalContext = lexicalStart = true;
+			} else if (subnodes.length > 0 && subnodes[0] instanceof ParseProductionNode
+					&& label.isSortProduction()
+					&& label.getLHS().getChildCount() == 1) {
+				return createIntTerminal(label, subnodes);
+			}
+		}
 		
 		// TODO: Optimize - one particularly gnarly optimization would be to reuse the subnodes array here
 		//                  and in buildTreeAmb
@@ -116,7 +114,7 @@
 			if (child != null) children.add(child);
 		}
 		
-		if (lexicalStart || isVar) {
+		if (lexicalStart) {
 			return tryCreateStringTerminal(label);
 		} else if (inLexicalContext) {
 			tokenizer.createLayoutToken(offset - 1, lastOffset - 1, label);

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:04:20 2010	(r21538)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:04:26 2010	(r21539)
@@ -105,10 +105,9 @@
 		if (doCompare) {
 			doCompare(s, parsed);
 		} else {
-			System.out.println(parsed);
-			if (parsed.getLeftToken() != null) {
+			if (parsed.getLeftToken() != null)
 				System.out.println(((Token) parsed.getLeftToken()).getTokenizer());
-			}
+			System.out.println(parsed);
 		}
 
 		System.out.println(PathListPool.cacheMisses);

From karltk at strategoxt.org  Thu Dec 16 16:04:32 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:04:32 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21540 - in
	spoofax/branches/jsglr-gwt: . jsglr-gwt/.settings
	jsglr-gwt/src/org/spoofax/jsglr/client
	jsglr-gwt/src/org/spoofax/jsglr/client/imploder
	jsglr-gwt/src/org/spoof...
Message-ID: <201012161504.oBGF4WXo027405@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:04:32 2010
New Revision: 21540
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21540&sc=1

Log:
Collapsed revision history:
 * Added list flattening support to the imploder using an intermediate data structure; fixed string terminal implosion.
 * Tokenizer now works on strings. Added KeywordRecognizer.
 * Some proper imploder tests.
 * Made Tokenizer iterable.
 * Tokenization tests and line numbering fix.
 * Added project specific prefs.
 * Fix bug in setter method.
 * Mostly formatting.
 * Added line and column number support.
 * Added prefs.
 * Merge.
 * Remove debugging prints.
 * Support TK_ERROR_KEYWORD for keywords in bad regions.
 * merge

Added:
   spoofax/branches/jsglr-gwt/jsglr-gwt/.settings/org.eclipse.jdt.ui.prefs
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/KeywordRecognizer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/AutoConcatList.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestTokenize.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java6.java.recover
Deleted:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/TreeBuilder.java
Modified:
   spoofax/branches/jsglr-gwt/.hgignore
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ATermTreeFactory.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/DummyTokenizer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/IToken.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITokenizer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITreeFactory.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/LabelInfo.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ProductionAttributeReader.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Token.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TokenKindManager.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Tokenizer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TopdownTreeBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermFactory.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermString.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestImplode.java

Modified: spoofax/branches/jsglr-gwt/.hgignore
==============================================================================
--- spoofax/branches/jsglr-gwt/.hgignore	Thu Dec 16 15:04:26 2010	(r21539)
+++ spoofax/branches/jsglr-gwt/.hgignore	Thu Dec 16 15:04:32 2010	(r21540)
@@ -5,6 +5,7 @@
 *.jar
 *.tbl
 *.trm
+*.itrm
 .sglr-log
 jsglr-gwt/war/jsglrgwt
 jsglr-gwt/war/*.tbl

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/.settings/org.eclipse.jdt.ui.prefs
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/.settings/org.eclipse.jdt.ui.prefs	Thu Dec 16 15:04:32 2010	(r21540)
@@ -0,0 +1,65 @@
+#Mon Nov 15 11:15:46 CET 2010
+cleanup.add_default_serial_version_id=true
+cleanup.add_generated_serial_version_id=false
+cleanup.add_missing_annotations=true
+cleanup.add_missing_deprecated_annotations=true
+cleanup.add_missing_methods=false
+cleanup.add_missing_nls_tags=false
+cleanup.add_missing_override_annotations=true
+cleanup.add_missing_override_annotations_interface_methods=true
+cleanup.add_serial_version_id=false
+cleanup.always_use_blocks=true
+cleanup.always_use_parentheses_in_expressions=false
+cleanup.always_use_this_for_non_static_field_access=false
+cleanup.always_use_this_for_non_static_method_access=false
+cleanup.convert_to_enhanced_for_loop=false
+cleanup.correct_indentation=false
+cleanup.format_source_code=false
+cleanup.format_source_code_changes_only=false
+cleanup.make_local_variable_final=true
+cleanup.make_parameters_final=false
+cleanup.make_private_fields_final=true
+cleanup.make_type_abstract_if_missing_method=false
+cleanup.make_variable_declarations_final=false
+cleanup.never_use_blocks=false
+cleanup.never_use_parentheses_in_expressions=true
+cleanup.organize_imports=false
+cleanup.qualify_static_field_accesses_with_declaring_class=false
+cleanup.qualify_static_member_accesses_through_instances_with_declaring_class=true
+cleanup.qualify_static_member_accesses_through_subtypes_with_declaring_class=true
+cleanup.qualify_static_member_accesses_with_declaring_class=true
+cleanup.qualify_static_method_accesses_with_declaring_class=false
+cleanup.remove_private_constructors=true
+cleanup.remove_trailing_whitespaces=false
+cleanup.remove_trailing_whitespaces_all=true
+cleanup.remove_trailing_whitespaces_ignore_empty=false
+cleanup.remove_unnecessary_casts=true
+cleanup.remove_unnecessary_nls_tags=true
+cleanup.remove_unused_imports=true
+cleanup.remove_unused_local_variables=false
+cleanup.remove_unused_private_fields=true
+cleanup.remove_unused_private_members=false
+cleanup.remove_unused_private_methods=true
+cleanup.remove_unused_private_types=true
+cleanup.sort_members=false
+cleanup.sort_members_all=false
+cleanup.use_blocks=false
+cleanup.use_blocks_only_for_return_and_throw=false
+cleanup.use_parentheses_in_expressions=false
+cleanup.use_this_for_non_static_field_access=false
+cleanup.use_this_for_non_static_field_access_only_if_necessary=true
+cleanup.use_this_for_non_static_method_access=false
+cleanup.use_this_for_non_static_method_access_only_if_necessary=true
+cleanup_profile=org.eclipse.jdt.ui.default.eclipse_clean_up_profile
+cleanup_settings_version=2
+eclipse.preferences.version=1
+formatter_profile=org.eclipse.jdt.ui.default.eclipse_profile
+formatter_settings_version=11
+org.eclipse.jdt.ui.exception.name=e
+org.eclipse.jdt.ui.gettersetter.use.is=true
+org.eclipse.jdt.ui.ignorelowercasenames=true
+org.eclipse.jdt.ui.importorder=java;javax;org;com;
+org.eclipse.jdt.ui.keywordthis=false
+org.eclipse.jdt.ui.ondemandthreshold=99
+org.eclipse.jdt.ui.overrideannotation=true
+org.eclipse.jdt.ui.staticondemandthreshold=99

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/KeywordRecognizer.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/KeywordRecognizer.java	Thu Dec 16 15:04:32 2010	(r21540)
@@ -0,0 +1,68 @@
+package org.spoofax.jsglr.client;
+
+import static org.spoofax.jsglr.shared.Tools.termAt;
+
+import java.util.HashSet;
+import java.util.Set;
+
+import org.spoofax.jsglr.shared.terms.AFun;
+import org.spoofax.jsglr.shared.terms.ATerm;
+import org.spoofax.jsglr.shared.terms.ATermAppl;
+
+/**
+ * Recognizes keywords in a language without considering their context.
+ * 
+ * @see ParseTable#getKeywordRecognizer()
+ * 
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class KeywordRecognizer {
+	
+	private final AFun litFun;
+	
+	private final Set<String> keywords = new HashSet<String>();
+	
+	protected KeywordRecognizer(ParseTable table) {
+		litFun = table.getFactory().makeAFun("lit", 1, false);
+		if (table != null) {
+			for (Label l : table.getLabels()) {
+				if (l != null) {
+					ATerm rhs = termAt(l.getProduction(), 1);
+					if (rhs instanceof ATermAppl && ((ATermAppl) rhs).getAFun() == litFun) {
+						ATermAppl lit = termAt(rhs, 0);
+						String litString = lit.getName();
+						if (isPotentialKeyword(litString))
+							keywords.add(litString);
+					}
+				}
+			}
+		}
+	}
+	
+	public boolean isKeyword(String literal) {
+		return keywords.contains(literal);
+	}
+	
+	/**
+	 * Determines whether the given string could possibly 
+	 * be a keyword (as opposed to an operator).
+	 * 
+	 * @see #isKeyword(String)
+	 */
+	public static boolean isPotentialKeyword(String literal) {
+		for (int i = 0, end = literal.length(); i < end; i++) {
+			char c = literal.charAt(i);
+			if (!isPotentialKeywordChar(c))
+				return false;
+		}
+		return true;
+	}
+	
+	/**
+	 * Determines whether the given character could possibly 
+	 * be part of a keyword (as opposed to an operator).
+	 */
+	public static boolean isPotentialKeywordChar(char c) {
+		return Character.isLetterOrDigit(c) || c == '_';
+	}
+}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java	Thu Dec 16 15:04:26 2010	(r21539)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java	Thu Dec 16 15:04:32 2010	(r21540)
@@ -75,6 +75,8 @@
     private transient Map<Label, List<Priority>> priorityCache;
 
 	private transient ITreeBuilder treeBuilder;
+	
+	private transient KeywordRecognizer keywords;
 
     private static final ParseProductionNode[] productionNodes = new ParseProductionNode[256 + 1];
     
@@ -652,4 +654,9 @@
         	setTreeBuilder(new Asfix2TreeBuilder());
 		return treeBuilder;
 	}
+	
+	public KeywordRecognizer getKeywordRecognizer() {
+		if (keywords == null) keywords = new KeywordRecognizer(this);
+		return keywords;
+	}
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 15:04:26 2010	(r21539)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 15:04:32 2010	(r21540)
@@ -216,7 +216,8 @@
 	public Object parse(String fis, String startSymbol) throws BadTokenException, TokenExpectedException, ParseException,
 	SGLRException {
 		logBeforeParsing();
-		initParseVariables(fis);
+		String filename = null; // TODO: get filename from some place; useful for errors
+		initParseVariables(filename, fis);
 		startTime = System.currentTimeMillis();
 		return sglrParse(startSymbol);
 	}
@@ -282,7 +283,7 @@
 		shifter(); //renewes active stacks with states in forshifter
 	}
 
-	private void initParseVariables(String input) {
+	private void initParseVariables(String filename, String input) {
 		startFrame = initActiveStacks();
 		tokensSeen = 0;
 		columnNumber = 0;
@@ -291,10 +292,8 @@
 		acceptingStack = null;
 		collectedErrors.clear();
 		ITokenizer tokenizer = parseTable.getTreeBuilder().getTokenizer();
-		// TODO: optimize?
 		if (tokenizer != null)
-			tokenizer.initialize(input.toCharArray());
-
+			tokenizer.initialize(filename, input);
 		PooledPathList.resetPerformanceCounters();
 		PathListPool.resetPerformanceCounters();
 	}
@@ -869,7 +868,7 @@
 	}
 
 	public void setTreeBuilder(TreeBuilder treeBuilder) {
-		parseTable.setTreeBuilder(new TreeBuilder());
+		parseTable.setTreeBuilder(treeBuilder);
 	}
 
 	AmbiguityManager getAmbiguityManager() {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ATermTreeFactory.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ATermTreeFactory.java	Thu Dec 16 15:04:26 2010	(r21539)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ATermTreeFactory.java	Thu Dec 16 15:04:32 2010	(r21540)
@@ -27,6 +27,10 @@
 		this.factory = factory;
 	}
 	
+	public ATermFactory getTermFactory() {
+		return factory;
+	}
+	
 	public AFun createConstructor(String name, int childCount) {
 		return factory.makeAFun(name, childCount, false);
 	}
@@ -104,4 +108,12 @@
 	private static ATerm[] toArray(List<ATerm> children) {
 		return children.toArray(new ATerm[children.size()]);
 	}
+
+	public IToken getLeftToken(ATerm node) {
+		return node.getLeftToken();
+	}
+
+	public IToken getRightToken(ATerm node) {
+		return node.getRightToken();
+	}
 }

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/AutoConcatList.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/AutoConcatList.java	Thu Dec 16 15:04:32 2010	(r21540)
@@ -0,0 +1,201 @@
+package org.spoofax.jsglr.client.imploder;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.ListIterator;
+
+import org.spoofax.jsglr.client.NotImplementedException;
+
+/**
+ * A list implementation that will automatically 
+ * concatenate itself with any added lists
+ * with nodes of the same Sort.
+ * 
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class AutoConcatList<E> implements List<E> {
+	
+	private static final long serialVersionUID = 349960310822051373L;
+	
+	private static final int INITIAL_LIST_SIZE = 10;
+	
+	private final String sort;
+	
+	/** The inner list value, if there is only one value. */
+	private E node;
+	
+	/** The inner list values, if there is more than one value. */
+	private ArrayList<E> nodes;
+	
+	public AutoConcatList(String sort) {
+		this.sort = sort;
+	}
+	
+	public String getSort() {
+		return sort;
+	}
+	
+	private ArrayList<E> asList() {
+		if (node != null) {
+			nodes = new ArrayList<E>(INITIAL_LIST_SIZE);
+			nodes.add(node);
+			node = null;
+		} else if (nodes == null) {
+			nodes = new ArrayList<E>(INITIAL_LIST_SIZE);
+		}
+		return nodes;
+	}
+
+	@SuppressWarnings("unchecked")
+	public boolean add(E e) {
+		if (e == null) {
+			throw new IllegalArgumentException();
+		} else if (node == null && nodes == null) {
+			if (e instanceof AutoConcatList) {
+				AutoConcatList<E> eList = (AutoConcatList<E>) e;
+				if (eList.getSort().equals(sort)) {
+					node = eList.node;
+					nodes = eList.nodes;
+					return true;
+				}
+			}
+			node = e;
+		} else {
+			asList();
+			if (e instanceof AutoConcatList) {
+				AutoConcatList<E> eList = (AutoConcatList<E>) e;
+				if (eList.getSort().equals(sort)) {
+					if (eList.node != null) {
+						nodes.add(eList.node);
+					} else if (eList.nodes != null) {
+						nodes.addAll(eList.nodes);
+					}
+					return true;
+				}
+			}
+			nodes.add(e);
+		}
+		return true;
+	}
+
+	public void add(int index, E element) {
+		// asList().add(index, element);
+		throw new NotImplementedException();
+	}
+
+	public boolean addAll(Collection<? extends E> c) {
+		// return asList().addAll(c);
+		throw new NotImplementedException();
+	}
+
+	public boolean addAll(int index, Collection<? extends E> c) {
+		// throw new UnsupportedOperationException();
+		throw new NotImplementedException();
+	}
+
+	public void clear() {
+		throw new UnsupportedOperationException();
+	}
+
+	public boolean contains(Object o) {
+		if (node != null) return node == o;
+		else return nodes != null && nodes.contains(o);
+	}
+
+	public boolean containsAll(Collection<?> c) {
+		return asList().containsAll(c);
+	}
+
+	public E get(int index) {
+		if (index == 0 && node != null) {
+			return node;
+		} else {
+			return asList().get(index);
+		}
+	}
+
+	public int indexOf(Object o) {
+		return asList().indexOf(o);
+	}
+
+	public boolean isEmpty() {
+		if (node != null) {
+			return false;
+		} else {
+			return nodes == null || nodes.isEmpty();
+		}
+	}
+
+	public Iterator<E> iterator() {
+		return asList().iterator();
+	}
+
+	public int lastIndexOf(Object o) {
+		return asList().lastIndexOf(o);
+	}
+
+	public ListIterator<E> listIterator() {
+		return asList().listIterator();
+	}
+
+	public ListIterator<E> listIterator(int index) {
+		return asList().listIterator(index);
+	}
+
+	public boolean remove(Object o) {
+		return asList().remove(o);
+	}
+
+	public E remove(int index) {
+		return asList().remove(index);
+	}
+
+	public boolean removeAll(Collection<?> c) {
+		return asList().removeAll(c);
+	}
+
+	public boolean retainAll(Collection<?> c) {
+		return asList().retainAll(c);
+	}
+
+	public E set(int index, E element) {
+		return asList().set(index, element);
+	}
+
+	public int size() {
+		if (node != null) {
+			return 1;
+		} else {
+			return nodes == null ? 0 : nodes.size();
+		}
+	}
+
+	public List<E> subList(int fromIndex, int toIndex) {
+		return asList().subList(fromIndex, toIndex);
+	}
+
+	public Object[] toArray() {
+		return asList().toArray();
+	}
+
+	public <T> T[] toArray(T[] a) {
+		return asList().toArray(a);
+	}
+	
+	@Override
+	public boolean equals(Object arg0) {
+		return arg0 == this || asList().equals(arg0);
+	}
+	
+	@Override
+	public int hashCode() {
+		return asList().hashCode();
+	}
+	
+	@Override
+	public String toString() {
+		return asList().toString();
+	}
+}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/DummyTokenizer.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/DummyTokenizer.java	Thu Dec 16 15:04:26 2010	(r21539)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/DummyTokenizer.java	Thu Dec 16 15:04:32 2010	(r21540)
@@ -1,25 +1,36 @@
 package org.spoofax.jsglr.client.imploder;
 
+import java.util.ArrayList;
+import java.util.Iterator;
+
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
+ * @author Karl Trygve Kalleberg <karltk near strategoxt dot org>
  */
 public class DummyTokenizer implements ITokenizer {
 	
-	private final IToken onlyToken = new Token(this, 0, 0, 0, 0, IToken.TK_UNKNOWN);
+	private final IToken onlyToken = new Token(this, 0, 0, 0, 0, 0, IToken.TK_UNKNOWN);
+
+	private String filename;
 	
-	private char[] inputChars;
+	private String input;
 	
 	/**
 	 * @param inputChars
 	 *           The input characters (used for {indentpadding} productions
 	 *           and error recovery)
 	 */
-	public void initialize(char[] inputChars) {
-		this.inputChars = inputChars;
+	public void initialize(String filename, String input) {
+		this.filename = filename;
+		this.input = input;
+	}
+	
+	public String getFilename() {
+		return filename;
 	}
 
-	public char[] getInputChars() {
-		return inputChars;
+	public String getInput() {
+		return input;
 	}
 
 	public int getStartOffset() {
@@ -54,11 +65,11 @@
 		return onlyToken;
 	}
 
-	public IToken createSkippedToken(int offset, char inputChar, char prevChar) {
-		return onlyToken;
+	public void makeErrorToken(int offset) {
+		// Do nothing
 	}
 
-	public void createLayoutToken(int offset, int lastOffset, LabelInfo label) {
+	public void makeLayoutToken(int offset, int lastOffset, LabelInfo label) {
 		// Do nothing
 	}
 	
@@ -66,4 +77,9 @@
 		return "";
 	}
 
+	public Iterator<IToken> iterator() {
+		ArrayList<IToken> result = new ArrayList<IToken>(1);
+		result.add(onlyToken);
+		return result.iterator();
+	}
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/IToken.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/IToken.java	Thu Dec 16 15:04:26 2010	(r21539)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/IToken.java	Thu Dec 16 15:04:32 2010	(r21540)
@@ -31,13 +31,21 @@
 	/** Token kind for an EOF token. */
 	public static final int TK_EOF = 8;
 	
-	/** Token kind for an erroneous token. */
+	/** Token kind for an erroneous non-keyword token. */
 	public static final int TK_ERROR = 9;
 	
-	public static final int TK_RESERVED = 10;
+	/** Token kind for an erroneous keyword token. */
+	public static final int TK_ERROR_KEYWORD = 10;
+	
+	/** Token kind for an erroneous token. */
+	public static final int TK_ERROR_EOF_UNEXPECTED = 11;
+	
+	public static final int TK_RESERVED = 12;
 	
 	int getKind();
 	
+	void setKind(int kind);
+	
 	int getIndex();
 
 	int getStartOffset();
@@ -47,4 +55,6 @@
 	int getLine();
 	
 	int getColumn();
+	
+	ITokenizer getTokenizer();
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITokenizer.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITokenizer.java	Thu Dec 16 15:04:26 2010	(r21539)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITokenizer.java	Thu Dec 16 15:04:32 2010	(r21540)
@@ -1,14 +1,19 @@
 package org.spoofax.jsglr.client.imploder;
 
+import org.spoofax.jsglr.client.KeywordRecognizer;
+
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
  */
-public interface ITokenizer {
+public interface ITokenizer extends Iterable<IToken> {
 	
-	// TODO: Optimize - use String in tokenizer?
-	void initialize(char[] inputChars);
+	/**
+	 * Initializes the tokenizer for the given
+	 * file name (if applicable) and contents.
+	 */
+	void initialize(String filename, String input);
 
-	char[] getInputChars();
+	String getInput();
 
 	int getStartOffset();
 
@@ -20,25 +25,29 @@
 
 	IToken getTokenAt(int i);
 
-	IToken makeToken(int offset, LabelInfo label);
-
 	IToken makeToken(int offset, LabelInfo label, boolean allowEmptyToken);
 
 	IToken makeToken(int offset, int kind, boolean allowEmptyToken);
 
 	/**
-	 * Creates an artificial token at keyword boundaries
-	 * inside skipped regions of code.
+	 * Creates artificial token at keyword boundaries
+	 * inside skipped regions of code when
+	 * invoked for each character in a skipped/erroneous region of code.
 	 * Required for keyword highlighting with {@link KeywordRecognizer}.
+	 * 
+	 * @param offset
+	 *           The offset of the 
 	 */
-	IToken createSkippedToken(int offset, char inputChar, char prevChar);
+	void makeErrorToken(int offset);
 
 	/**
 	 * Creates an artificial token for every water-based recovery
 	 * and for comments within layout.
 	 */
-	void createLayoutToken(int offset, int lastOffset, LabelInfo label);
+	void makeLayoutToken(int offset, int lastOffset, LabelInfo label);
 
 	String toString(IToken left, IToken right);
 
+	String getFilename();
+
 }
\ No newline at end of file

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITreeFactory.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITreeFactory.java	Thu Dec 16 15:04:26 2010	(r21539)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITreeFactory.java	Thu Dec 16 15:04:32 2010	(r21540)
@@ -46,5 +46,18 @@
 	
 	public boolean isStringTerminal(TNode node);
 	
+	/**
+	 * Gets the children of a node.
+	 */
 	public Iterable<TNode> getChildren(TNode node);
+	
+	/**
+	 * Gets the left token of a node, or null if not supported/applicable.
+	 */
+	public IToken getLeftToken(TNode node);
+	
+	/**
+	 * Gets the right token of a node, or null if not supported/applicable.
+	 */
+	public IToken getRightToken(TNode node);
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/LabelInfo.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/LabelInfo.java	Thu Dec 16 15:04:26 2010	(r21539)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/LabelInfo.java	Thu Dec 16 15:04:32 2010	(r21540)
@@ -10,8 +10,6 @@
  * @author Lennart Kats <lennart add lclnet.nl>
  */
 public class LabelInfo {
-	
-	private final ProductionAttributeReader reader;
 
 	private final ATermAppl production;
 	
@@ -45,7 +43,6 @@
 	
 	public LabelInfo(ProductionAttributeReader reader, ATermAppl production) {
 		this.production = production;
-		this.reader = reader;
 		ATermAppl rhs = getRHS();
 		ATermAppl attrs = getAttrs();
 		sort = reader.getSort(rhs);

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ProductionAttributeReader.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ProductionAttributeReader.java	Thu Dec 16 15:04:26 2010	(r21539)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ProductionAttributeReader.java	Thu Dec 16 15:04:32 2010	(r21540)
@@ -262,9 +262,7 @@
 		if (rhs.getAFun() == optFun)
 			return true;
 		rhs = termAt(rhs, 0);
-		if (rhs.getChildCount() == 1 && rhs.getAFun() == optFun)
-			return true;
-		return false;
+		return rhs.getChildCount() == 1 && rhs.getAFun() == optFun;
 	}
 
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Token.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Token.java	Thu Dec 16 15:04:26 2010	(r21539)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Token.java	Thu Dec 16 15:04:32 2010	(r21540)
@@ -1,20 +1,22 @@
 package org.spoofax.jsglr.client.imploder;
 
-import org.spoofax.jsglr.client.NotImplementedException;
 
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
+ * @author Karl Trygve Kalleberg <karltk near strategoxt dot org>
  */
 public class Token implements IToken {
 
 	private final ITokenizer tokenizer;
 	
-	private final int index, startOffset, endOffset, line, kind;
+	private final int index, startOffset, endOffset, line, column;
+	private int kind;
 
-	public Token(ITokenizer tokenizer, int index, int line, int startOffset, int endOffset, int kind) {
+	public Token(ITokenizer tokenizer, int index, int line, int column, int startOffset, int endOffset, int kind) {
 		this.tokenizer = tokenizer;
 		this.index = index;
 		this.line = line;
+		this.column = column;
 		this.startOffset = startOffset;
 		this.endOffset = endOffset;
 		this.kind = kind;
@@ -27,6 +29,10 @@
 	public int getKind() {
 		return kind;
 	}
+	
+	public void setKind(int kind) {
+		this.kind = kind;
+	}
 
 	public int getIndex() {
 		return index;
@@ -45,8 +51,7 @@
 	}
 	
 	public int getColumn() {
-		// TODO
-		throw new NotImplementedException();
+		return column;
 	}
 	
 	@Override

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TokenKindManager.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TokenKindManager.java	Thu Dec 16 15:04:26 2010	(r21539)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TokenKindManager.java	Thu Dec 16 15:04:32 2010	(r21540)
@@ -71,27 +71,6 @@
 		return true;
 	}
 	
-	/**
-	 * Determines whether the given string could possibly 
-	 * be a keyword (as opposed to an operator).
-	 */
-	protected static boolean isKeyword(String literal) {
-		for (int i = 0, end = literal.length(); i < end; i++) {
-			char c = literal.charAt(i);
-			if (!isKeywordChar(c))
-				return false;
-		}
-		return true;
-	}
-	
-	/**
-	 * Determines whether the given character could possibly 
-	 * be part of a keyword (as opposed to an operator).
-	 */
-	protected static boolean isKeywordChar(char c) {
-		return Character.isLetterOrDigit(c) || c == '_';
-	}
-	
 	protected static boolean isStringLiteral(LabelInfo label) {
 		return topdownHasSpaces(label.getRHS());
 	}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Tokenizer.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Tokenizer.java	Thu Dec 16 15:04:26 2010	(r21539)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Tokenizer.java	Thu Dec 16 15:04:32 2010	(r21540)
@@ -1,21 +1,31 @@
 package org.spoofax.jsglr.client.imploder;
 
 import static java.lang.Math.min;
-import static org.spoofax.jsglr.client.imploder.IToken.*;
+import static org.spoofax.jsglr.client.imploder.IToken.TK_ERROR;
+import static org.spoofax.jsglr.client.imploder.IToken.TK_LAYOUT;
+import static org.spoofax.jsglr.client.imploder.IToken.TK_RESERVED;
 
 import java.util.ArrayList;
+import java.util.Iterator;
+
+import org.spoofax.jsglr.client.KeywordRecognizer;
 
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
+ * @author Karl Trygve Kalleberg <karltk near strategoxt dot org>
  */
 public class Tokenizer implements ITokenizer {
 	
 	private static final int EXPECTED_TOKENS_DIVIDER = 5;
 	
+	private final KeywordRecognizer keywords;
+	
 	private final TokenKindManager manager =
 		new TokenKindManager();
 	
-	private char[] inputChars;
+	private String filename;
+	
+	private String input;
 
 	private ArrayList<IToken> tokens;
 	
@@ -23,18 +33,31 @@
 	private int startOffset;
 	
 	/** Line number of the next token. */
-	private int line; // TODO: first line zero or one??
+	private int line;
+
+	private int offsetAtLineStart;
 	
-	public void initialize(char[] inputChars) {
-		this.inputChars = inputChars;
-		this.tokens = new ArrayList<IToken>(inputChars.length / EXPECTED_TOKENS_DIVIDER);
+	public Tokenizer(KeywordRecognizer keywords) {
+		this.keywords = keywords;
+	}
+	
+	public void initialize(String filename, String input) {
+		this.filename = filename;
+		this.input = input;
+		this.tokens = new ArrayList<IToken>(input.length() / EXPECTED_TOKENS_DIVIDER);
 		startOffset = 0;
+		line = 0;
+		offsetAtLineStart = 0;
 		// Ensure there's at least one token
-		tokens.add(new Token(this, 0, line, 0, -1, TK_RESERVED));
+		tokens.add(new Token(this, 0, line, 0, 0, -1, TK_RESERVED));
+	}
+	
+	public final String getInput() {
+		return input;
 	}
 	
-	public final char[] getInputChars() {
-		return inputChars;
+	public String getFilename() {
+		return filename;
 	}
 	
 	public final int getStartOffset() {
@@ -59,10 +82,6 @@
 		return tokens.get(i);
 	}
 
-	public IToken makeToken(int endOffset, LabelInfo label) {
-		return makeToken(endOffset, label, false);
-	}
-
 	public IToken makeToken(int endOffset, LabelInfo label, boolean allowEmptyToken) {
 		return makeToken(endOffset, manager.getTokenKind(label), allowEmptyToken);
 	}
@@ -73,54 +92,75 @@
 		
 		assert endOffset >= startOffset || (kind == TK_RESERVED && startOffset == 0);
 		
-		char[] chars = inputChars;
 		int offset;
 		IToken token = null;
 		for (offset = min(startOffset, endOffset); offset < endOffset; offset++) {
-			if (chars[offset] == '\n') {
+			if (input.charAt(offset) == '\n') {
 				if (offset - 1 > startOffset)
 					token = internalMakeToken(kind, offset - 1);
-				internalMakeToken(kind, offset); // newline
+				internalMakeToken(TK_LAYOUT, offset); // newline
+				line++;
+				offsetAtLineStart = startOffset;
 			}
 		}
 		
 		if (token == null || offset <= endOffset) {
-			return internalMakeToken(kind, offset);
+			token = internalMakeToken(kind, offset);
+			if (input.charAt(offset) == '\n') {
+				line++;
+				offsetAtLineStart = startOffset;
+			}
+			return token;
 		} else {
 			return token;
 		}
 	}
 
-	private IToken internalMakeToken(int kind, int offset) {
-		IToken result = new Token(this, tokens.size() - 1, line, startOffset, offset, kind);
+	private IToken internalMakeToken(int kind, int endOffset) {
+		IToken result = new Token(this, tokens.size() - 1, line, startOffset - offsetAtLineStart, startOffset, endOffset, kind);
 		tokens.add(result);
-		startOffset = offset + 1;
-		line++;
+		startOffset = endOffset + 1;
 		return result;
 	}
 
-	/**
-	 * Creates an artificial token at keyword boundaries
-	 * inside skipped regions of code.
-	 * Required for keyword highlighting with {@link KeywordRecognizer}.
-	 */
-	public IToken createSkippedToken(int offset, char inputChar, char prevChar) {
-		// FIXME: off-by-one errors?? offset passed is now offset - 1 c.f. old SGLRTokenizer
-		boolean isInputKeywordChar = isKeywordChar(inputChar);
-		if (offset > 0 && offset > getStartOffset()) {
-			if ((isInputKeywordChar && !isKeywordChar(prevChar))
-					|| (!isInputKeywordChar && isKeywordChar(prevChar))) {
-				return makeToken(offset, TK_ERROR, false);
+	public void makeErrorToken(int offset) {
+		char inputChar = input.charAt(offset);
+		
+		boolean isInputKeywordChar = KeywordRecognizer.isPotentialKeywordChar(inputChar);
+		if (isAtPotentialKeywordEnd(offset, isInputKeywordChar)) {
+			if (keywords.isKeyword(toString(startOffset, offset - 1))) {
+				makeToken(offset - 1, TK_ERROR_KEYWORD, false);
+			} else {
+				makeToken(offset - 1, TK_ERROR, false);
+			}
+		}
+		if (isAtPotentialKeywordStart(offset, isInputKeywordChar)) {
+			if (keywords.isKeyword(toString(startOffset, offset))) {
+				makeToken(offset, TK_ERROR_KEYWORD, false);
+			} else {
+				makeToken(offset, TK_ERROR, false);
 			}
 		}
-		if (offset + 2 < inputChars.length) {
-			char nextChar = inputChars[offset + 2];
+	}
+
+	private boolean isAtPotentialKeywordEnd(int offset, boolean isInputKeywordChar) {
+		if (offset >= 1 && offset > startOffset) {
+			char prevChar = input.charAt(offset - 1);
+			return 	(isInputKeywordChar && !isKeywordChar(prevChar))
+					|| (!isInputKeywordChar && isKeywordChar(prevChar));
+		}
+		return false;
+	}
+
+	private boolean isAtPotentialKeywordStart(int offset, boolean isInputKeywordChar) {
+		if (offset + 1 < input.length()) {
+			char nextChar = input.charAt(offset + 1);
 			if ((isInputKeywordChar && !isKeywordChar(nextChar))
 					|| (!isInputKeywordChar && isKeywordChar(nextChar))) {
-				return makeToken(offset + 2, TK_ERROR, false);
+				return true;
 			}
 		}
-		return null;
+		return false;
 	}
 	
 	/**
@@ -135,7 +175,7 @@
 	 * Creates an artificial token for every water-based recovery
 	 * and for comments within layout.
 	 */
-	public void createLayoutToken(int offset, int lastOffset, LabelInfo label) {
+	public void makeLayoutToken(int offset, int lastOffset, LabelInfo label) {
 		// Create separate tokens for >1 char layout lexicals (e.g., comments)
 		if (offset > lastOffset + 1 && label.isLexLayout()) {
 			if (startOffset <= lastOffset)
@@ -152,8 +192,13 @@
 	}
 	
 	public String toString(IToken left, IToken right) {
-		int offset = left.getStartOffset();
-		return new String(inputChars, offset, right.getEndOffset() - offset + 1);
+		int startOffset = left.getStartOffset();
+		int endOffset = right.getEndOffset();
+		return toString(startOffset, endOffset);
+	}
+
+	private String toString(int startOffset, int endOffset) {
+		return new StringBuilder(endOffset - startOffset + 1).append(input, startOffset, endOffset + 1).toString();
 	}
 	
 	@Override
@@ -162,7 +207,7 @@
 		result.append('[');
 		for (IToken token : tokens) {
 			int offset = token.getStartOffset();
-			result.append(inputChars, offset, token.getEndOffset() - offset + 1);
+			result.append(input, offset, token.getEndOffset() + 1);
 			result.append(',');
 		}
 		if (tokens.size() > 0)
@@ -171,4 +216,12 @@
 		return result.toString();
 	}
 
+	protected KeywordRecognizer getKeywordRecognizer() {
+		return keywords;
+	}
+
+	public Iterator<IToken> iterator() {
+		return tokens.iterator();
+	}
+
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TopdownTreeBuilder.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TopdownTreeBuilder.java	Thu Dec 16 15:04:26 2010	(r21539)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TopdownTreeBuilder.java	Thu Dec 16 15:04:32 2010	(r21540)
@@ -23,7 +23,7 @@
 	 *   For a best balance of performance and stack consumption, directly call
 	 *   {@link ParseNode#buildTreeBottomup} instead.
 	 */
-	public final Object buildTree(AbstractParseNode node) {
+	public Object buildTree(AbstractParseNode node) {
 		if (node instanceof ParseNode) {
 			return buildTreeNode((ParseNode) node);
 		} else if (node instanceof ParseProductionNode) {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java	Thu Dec 16 15:04:26 2010	(r21539)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java	Thu Dec 16 15:04:32 2010	(r21540)
@@ -1,6 +1,7 @@
 package org.spoofax.jsglr.client.imploder;
 
 import static java.lang.Math.max;
+import static org.spoofax.jsglr.client.imploder.IToken.TK_ERROR_EOF_UNEXPECTED;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -16,6 +17,7 @@
 
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
+ * @author Karl Trygve Kalleberg <karltk near strategoxt dot org>
  */
 @SuppressWarnings({"rawtypes", "unchecked"})
 public class TreeBuilder extends TopdownTreeBuilder {
@@ -32,11 +34,11 @@
 	
 	private static final String TUPLE_CONSTRUCTOR = new String("");
 	
-	private final ITokenizer tokenizer;
+	private ITokenizer tokenizer;
 	
 	private ITreeFactory factory;
 	
-	private boolean useDefaultFactory;
+	private boolean initializeFactories;
 	
 	private ProductionAttributeReader prodReader;
 
@@ -51,13 +53,12 @@
 	
 	private int nonMatchingOffset = NONE;
 	
-	private char nonMatchingChar, nonMatchingCharExpected, prevChar;
+	private char nonMatchingChar, nonMatchingCharExpected;
 	
 	private boolean inLexicalContext;
 	
 	public TreeBuilder() {
-		this(null, new Tokenizer());
-		this.useDefaultFactory = true;
+		this.initializeFactories = true;
 	}
 	
 	public TreeBuilder(ITreeFactory treeFactory, ITokenizer tokenizer) {
@@ -67,8 +68,12 @@
 
 	public void initialize(ParseTable table, int productionCount, int labelStart, int labelCount) {
 		this.termFactory = table.getFactory();
-		if (useDefaultFactory)
+		if (initializeFactories) {
 			factory = new ATermTreeFactory(termFactory);
+			tokenizer = new Tokenizer(table.getKeywordRecognizer());
+		}
+		assert !(factory instanceof ATermTreeFactory) || ((ATermTreeFactory) factory).getTermFactory() == table.getFactory(); 
+		assert !(tokenizer instanceof Tokenizer) || ((Tokenizer) factory).getKeywordRecognizer() == table.getKeywordRecognizer(); 
 		this.prodReader = new ProductionAttributeReader(termFactory);
 		this.labels = new LabelInfo[labelCount - labelStart];
 		this.labelStart = labelStart;
@@ -83,12 +88,33 @@
 	}
 	
 	@Override
+	@Deprecated
+	public Object buildTree(AbstractParseNode node) {
+		return tryBuildAutoConcatListNode(super.buildTree(node));
+	}
+	
+	@Override
+	public Object buildTreeTop(Object subtree, int ambiguityCount) {
+		try {
+			return tryBuildAutoConcatListNode(subtree);
+		} finally {
+			offset = 0;
+			inLexicalContext = false;
+		}
+	}
+	
+	/**
+	 * Given a {@link ParseNode}, builds a tree node using the
+	 * {@link ITreeFactory}, or an intermediate {@link AutoConcatList}
+	 * object.
+	 */
+	@Override
 	public Object buildTreeNode(ParseNode node) {
 		LabelInfo label = labels[node.getLabel() - labelStart];
 		IToken prevToken = tokenizer.currentToken();
 		int lastOffset = offset;
 		AbstractParseNode[] subnodes = node.getChildren();
-		
+		boolean isList = label.isList();
 		boolean lexicalStart = false;
 		
 		if (!inLexicalContext) {
@@ -103,27 +129,35 @@
 		
 		// TODO: Optimize - one particularly gnarly optimization would be to reuse the subnodes array here
 		//                  and in buildTreeAmb
-		ArrayList<Object> children = null;
-		if (!inLexicalContext)
-			children = new ArrayList<Object>(max(EXPECTED_NODE_CHILDREN, subnodes.length));
+		List<Object> children = null;
+		if (!inLexicalContext) {
+			if (isList) {
+				children = new AutoConcatList<Object>(label.getSort());
+			} else {
+				children = new ArrayList<Object>(max(EXPECTED_NODE_CHILDREN, subnodes.length));
+			}
+		}
 
 		// Recurse
 		for (AbstractParseNode subnode : subnodes) {
 			// TODO: Optimize stack - inline toTreeTopdown case selection?
 			Object child = subnode.toTreeTopdown(this);
-			if (child != null) children.add(child);
+			if (child != null) children.add(isList ? child : tryBuildAutoConcatListNode(child));
 		}
 		
 		if (lexicalStart) {
 			return tryCreateStringTerminal(label);
 		} else if (inLexicalContext) {
-			tokenizer.createLayoutToken(offset - 1, lastOffset - 1, label);
+			tokenizer.makeLayoutToken(offset - 1, lastOffset - 1, label);
 			return null; // don't create tokens inside lexical context; just create one big token at the top
+		} else if (isList) {
+			return children;
 		} else {
 			return createNodeOrInjection(label, prevToken, children);
 		}
 	}
 
+	@Override
 	public Object buildTreeAmb(Amb a) {
 		final int oldOffset = offset;
 		final int oldBeginOffset = tokenizer.getStartOffset();
@@ -145,6 +179,26 @@
 		return factory.createAmb(children);
 	}
 
+	private Object tryBuildAutoConcatListNode(Object node) {
+		if (node instanceof AutoConcatList) {
+			return buildAutoConcatListNode((AutoConcatList) node);
+		} else {
+			return node;
+		}
+	}
+	
+	/**
+	 * Converts an {@link AutoConcatList} intermediate list
+	 * representation to a proper tree node using the
+	 * {@link ITreeFactory}.
+	 */
+	public Object buildAutoConcatListNode(AutoConcatList list) {
+		IToken left = list.isEmpty() ? null : factory.getLeftToken(list.get(0));
+		IToken right = list.isEmpty() ? null : factory.getRightToken(list.get(list.size() - 1));
+		return factory.createList(list.getSort(), left, right, list);
+	}
+
+	@Override
 	public Object buildTreeProduction(ParseProductionNode node) {
 		int character = node.prod;
 		consumeLexicalChar(character);
@@ -184,7 +238,8 @@
 		String constructor = label.getConstructor();
 		
 		if (label.isList()) {
-			return createNode(label, LIST_CONSTRUCTOR, prevToken, children);
+			throw new IllegalStateException("Illegal state: now handled by tryCreateAutoConcatListNode()");
+			// return createNode(label, LIST_CONSTRUCTOR, prevToken, children);
 		} else if (constructor != null) {
 			// UNDONE: tokenizer.makeToken(offset, label); // TODO: why makeToken here??
 			return createNode(label, constructor, prevToken, children);
@@ -242,18 +297,18 @@
 	 */
 	private String getPaddedLexicalValue(LabelInfo label, IToken startToken) {
 		if (label.isIndentPaddingLexical()) {
-			char[] inputChars = tokenizer.getInputChars();
+			String input = tokenizer.getInput();
 			int lineStart = startToken.getStartOffset() - 1;
 			if (lineStart < 0) return null;
 			while (lineStart >= 0) {
-				char c = inputChars[lineStart--];
+				char c = input.charAt(lineStart--);
 				if (c == '\n' || c == '\r') {
 					lineStart++;
 					break;
 				}
 			}
 			StringBuilder result = new StringBuilder();
-			result.append(inputChars, lineStart, startToken.getStartOffset() - lineStart - 1);
+			result.append(input, lineStart, startToken.getStartOffset() - lineStart - 1);
 			for (int i = 0; i < result.length(); i++) {
 				char c = result.charAt(i);
 				if (c != ' ' && c != '\t') result.setCharAt(i, ' ');
@@ -261,7 +316,7 @@
 			result.append(startToken.toString());
 			return result.toString();
 		} else {
-			return null; // lazily load token string value
+			return startToken.toString(); // lazily load token string value
 		}
 	}
 
@@ -308,52 +363,52 @@
 	
 	/** Consume a character of a lexical terminal. */
 	protected final void consumeLexicalChar(int character) {
-		char[] inputChars = tokenizer.getInputChars();
-		if (offset >= inputChars.length) {
-			if (nonMatchingOffset != NONE) {
-				assert false : "Character in parse tree after end of input stream: "
-						+ (char) character
-						+ " - may be caused by unexcepted character in parse tree at position "
-						+ nonMatchingChar 	+ ": " + nonMatchingChar + " instead of "
-						+ nonMatchingCharExpected;
-			}
-		    // UNDONE: Strict lexical stream checking
-			// throw new ImploderException("Character in parse tree after end of input stream: " + (char) character.getInt());
-			// a forced reduction may have added some extra characters to the tree;
-			inputChars[inputChars.length - 1] = UNEXPECTED_EOF_CHAR;
-			return;
-		}
-		
-		char parsedChar = (char) character;
-		char inputChar = inputChars[offset];
-		
-		if (parsedChar != inputChar) {
-			if (RecoveryConnector.isLayoutCharacter(parsedChar)) {
-				// Remember that the parser skipped the current character
-				// for later error reporting. (Cannot modify the immutable
-				// parse tree here; changing the original stream instead.)
-				inputChars[offset] = SKIPPED_CHAR;
-				tokenizer.createSkippedToken(offset - 1, inputChar, prevChar);
-				offset++;
-			} else {
-				// UNDONE: Strict lexical stream checking
-				// throw new IllegalStateException("Character from asfix stream (" + parsedChar
-				//	 	+ ") must be in lex stream (" + inputChar + ")");
-			    // instead, we allow the non-matching character for now, and hope
-			    // we can pick up the right track later
-				// TODO: better way to report skipped fragments in the parser
-				//       this isn't 100% reliable
-				if (nonMatchingOffset == NONE) {
-					nonMatchingOffset = offset;
-					nonMatchingChar = parsedChar;
-					nonMatchingCharExpected = inputChar;
+		String input = tokenizer.getInput();
+		if (offset >= input.length()) {
+			markUnexpectedEOF(character);
+		} else {
+			char parsedChar = (char) character;
+			char inputChar = input.charAt(offset);
+			
+			if (parsedChar != inputChar) {
+				if (RecoveryConnector.isLayoutCharacter(parsedChar)) {
+					tokenizer.makeErrorToken(offset);
+					offset++;
+				} else {
+					// UNDONE: Strict lexical stream checking
+					// throw new IllegalStateException("Character from asfix stream (" + parsedChar
+					//	 	+ ") must be in lex stream (" + inputChar + ")");
+				    // instead, we allow the non-matching character for now, and hope
+				    // we can pick up the right track later
+					// TODO: better way to report skipped fragments in the parser
+					//       this isn't 100% reliable
+					if (nonMatchingOffset == NONE) {
+						nonMatchingOffset = offset;
+						nonMatchingChar = parsedChar;
+						nonMatchingCharExpected = inputChar;
+					}
 				}
-				inputChars[offset] = SKIPPED_CHAR;
+			} else {
+				offset++;
 			}
-		} else {
-			offset++;
 		}
-		prevChar = inputChar;
+	}
+
+	private void markUnexpectedEOF(int character) {
+		String input = tokenizer.getInput();
+		assert nonMatchingOffset == NONE :
+				"Character in parse tree after end of input stream: " + (char) character
+				+ " - may be caused by unexpected character in parse tree at position "
+				+ nonMatchingChar 	+ ": " + nonMatchingChar + " instead of "
+				+ nonMatchingCharExpected;
+		// UNDONE: Strict lexical stream checking
+		// throw new ImploderException("Character in parse tree after end of input stream: " + (char) character.getInt());
+		// a forced reduction may have added some extra characters to the tree;
+		if (tokenizer.currentToken().getKind() != TK_ERROR_EOF_UNEXPECTED) {
+			if (tokenizer.getStartOffset() >= input.length())
+				tokenizer.setStartOffset(max(input.length() - 1, 0));
+			tokenizer.makeToken(input.length(), TK_ERROR_EOF_UNEXPECTED, true);
+		}
 	}
 
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermFactory.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermFactory.java	Thu Dec 16 15:04:26 2010	(r21539)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermFactory.java	Thu Dec 16 15:04:32 2010	(r21540)
@@ -3,8 +3,8 @@
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
-import java.util.concurrent.ConcurrentHashMap;
 
 import org.spoofax.jsglr.client.NotImplementedException;
 import org.spoofax.jsglr.client.PushbackStringIterator;
@@ -12,17 +12,16 @@
 public class ATermFactory implements Serializable {
 
 	private static final long serialVersionUID = 1L;
-	
+
 	protected static final ATerm[] EMPTY = new ATerm[0];
 
-    private final ConcurrentHashMap<AFun, AFun> afunCache =
-        new ConcurrentHashMap<AFun, AFun>();
+	private final HashMap<AFun, AFun> afunCache = new HashMap<AFun, AFun>();
 
 	public AFun makeAFun(String ctorName, int arity, boolean quoted) {
-		AFun candidate = new AFun(ctorName, arity, quoted);
+		final AFun candidate = new AFun(ctorName, arity, quoted);
 		AFun cached = afunCache.get(candidate);
 		if (cached == null) {
-			cached = afunCache.putIfAbsent(candidate, candidate);
+			cached = afunCache.put/*IfAbsent*/(candidate, candidate);
 			return cached == null ? candidate : cached;
 		} else {
 			return cached;
@@ -32,21 +31,22 @@
 	public ATermPlaceholder makePlaceholder(ATerm template) {
 		return new ATermPlaceholder(this, makeAFun("<>", 1), template);
 	}
-	
+
 	public ATermList makeList() {
 		return new ATermList(this, null, null);
 	}
 
 	public ATermList makeList(ATerm... elements) {
 		ATermList l = new ATermList(this, null, null);
-		for(int i = elements.length - 1; i >= 0; i--)
+		for(int i = elements.length - 1; i >= 0; i--) {
 			l = l.prepend(elements[i]);
+		}
 		return l;
 	}
 
-//	public ATermList makeList(List<ATerm> elements) {
-//		return new ATermList(this, elements.toArray(new ATerm[0]));
-//	}
+	//	public ATermList makeList(List<ATerm> elements) {
+	//		return new ATermList(this, elements.toArray(new ATerm[0]));
+	//	}
 
 	public ATerm parse(String text) {
 		return parseFromString(text);
@@ -61,7 +61,9 @@
 	}
 
 	public ATermAppl makeAppl(AFun afun, ATerm[] kids, boolean m) {
-		if (m) throw new UnsupportedOperationException("Use makeString() to make strings");
+		if (m) {
+			throw new UnsupportedOperationException("Use makeString() to make strings");
+		}
 		return new ATermAppl(this, afun, kids);
 	}
 
@@ -69,244 +71,250 @@
 		return new ATermInt(this, i);
 	}
 
-	
+
 	protected ATerm parseFromStream(PushbackStringIterator bis) {
-        parseSkip(bis);
-        final int ch = bis.read();
-        switch(ch) {
-        case '[': return parseAnno(bis, parseList(bis));
-        case '(': return parseAnno(bis, parseTuple(bis));
-        case '"': return parseAnno(bis, parseString(bis));
-        case '<': return parsePlaceholder(bis);
-        default:
-            bis.unread(ch);
-            if (Character.isLetter((char)ch)) {
-                return parseAnno(bis, parseAppl(bis));
-            }
-            else if(Character.isDigit((char)ch))
-                return parseAnno(bis, parseNumber(bis));
-        }
-        throw new ParseError("Invalid term: '" + (char)ch + "'");
-    }
-    
-    private ATerm parseAnno(PushbackStringIterator bis, ATerm term) {
-        parseSkip(bis);
-        final int ch = bis.read();
-        if (ch == '{') {
-            List<ATerm> annos = parseTermSequence(bis, '}');
-            return annotateTerm(term, makeList(annos.toArray(new ATerm[annos.size()])));
-        } else {
-            bis.unread(ch);
-            return term;
-        }
-    }
-
-    private ATerm parseString(PushbackStringIterator bis) {
-        int ch = bis.read();
-        if(ch == '"')
-            return makeString("");
-        StringBuilder sb = new StringBuilder();
-        boolean escaped = false;
-        do {
-            escaped = false;
-            if(ch == '\\') {
-                escaped = true;
-                ch = bis.read();
-            }
-            if(escaped) {
-                switch(ch) {
-                case 'n':
-                    sb.append('\n');
-                    break;
-                case 't':
-                    sb.append('\t');
-                    break;
-                case 'b':
-                    sb.append('\b');
-                    break;
-                case 'f':
-                    sb.append('\f');
-                    break;
-                case 'r':
-                    sb.append('\r');
-                    break;
-                case '\\':
-                    sb.append('\\');
-                    break;
-                case '\'':
-                    sb.append('\'');
-                    break;
-                case '\"':
-                    sb.append('\"');
-                    break;
-                case '0':
-                case '1':
-                case '2':
-                case '3':
-                case '4':
-                case '5':
-                case '6':
-                case '7':
-                case '8':
-                case '9':
-                    throw new NotImplementedException();
-                default:
-                    sb.append("\\" + (char)ch); 
-                }
-                ch = bis.read();
-            } else if(ch != '\"') {
-                if (ch == -1)
-                    throw new ParseError("Unterminated string: " + sb);
-                sb.append((char)ch);
-                ch = bis.read();
-            }
-        } while(escaped || ch != '\"');
-        return makeString(sb.toString());
-    }
+		parseSkip(bis);
+		final int ch = bis.read();
+		switch(ch) {
+		case '[': return parseAnno(bis, parseList(bis));
+		case '(': return parseAnno(bis, parseTuple(bis));
+		case '"': return parseAnno(bis, parseString(bis));
+		case '<': return parsePlaceholder(bis);
+		default:
+			bis.unread(ch);
+			if (Character.isLetter((char)ch)) {
+				return parseAnno(bis, parseAppl(bis));
+			}
+			else if(Character.isDigit((char)ch)) {
+				return parseAnno(bis, parseNumber(bis));
+			}
+		}
+		throw new ParseError("Invalid term: '" + (char)ch + "'");
+	}
+
+	private ATerm parseAnno(PushbackStringIterator bis, ATerm term) {
+		parseSkip(bis);
+		final int ch = bis.read();
+		if (ch == '{') {
+			final List<ATerm> annos = parseTermSequence(bis, '}');
+			return annotateTerm(term, makeList(annos.toArray(new ATerm[annos.size()])));
+		} else {
+			bis.unread(ch);
+			return term;
+		}
+	}
+
+	private ATerm parseString(PushbackStringIterator bis) {
+		int ch = bis.read();
+		if(ch == '"') {
+			return makeString("");
+		}
+		final StringBuilder sb = new StringBuilder();
+		boolean escaped = false;
+		do {
+			escaped = false;
+			if(ch == '\\') {
+				escaped = true;
+				ch = bis.read();
+			}
+			if(escaped) {
+				switch(ch) {
+				case 'n':
+					sb.append('\n');
+					break;
+				case 't':
+					sb.append('\t');
+					break;
+				case 'b':
+					sb.append('\b');
+					break;
+				case 'f':
+					sb.append('\f');
+					break;
+				case 'r':
+					sb.append('\r');
+					break;
+				case '\\':
+					sb.append('\\');
+					break;
+				case '\'':
+					sb.append('\'');
+					break;
+				case '\"':
+					sb.append('\"');
+					break;
+				case '0':
+				case '1':
+				case '2':
+				case '3':
+				case '4':
+				case '5':
+				case '6':
+				case '7':
+				case '8':
+				case '9':
+					throw new NotImplementedException();
+				default:
+					sb.append("\\" + (char)ch);
+				}
+				ch = bis.read();
+			} else if(ch != '\"') {
+				if (ch == -1) {
+					throw new ParseError("Unterminated string: " + sb);
+				}
+				sb.append((char)ch);
+				ch = bis.read();
+			}
+		} while(escaped || ch != '\"');
+		return makeString(sb.toString());
+	}
 
-    public ATermString makeString(String string) {
-    	return new ATermString(this, string);
+	public ATermString makeString(String string) {
+		return new ATermString(this, string);
 	}
 
 	private ATerm parseAppl(PushbackStringIterator bis) {
-        //System.err.println("appl");
-        // TODO: share stringbuilder instances?
-        StringBuilder sb = new StringBuilder();
-        int ch = bis.read();
-        do {
-            sb.append((char)ch);
-            ch = bis.read();
-        } // TODO: use a switch for this
-          while(Character.isLetterOrDigit((char)ch) || ch == '_' || ch == '-'
-            || ch == '+' || ch == '*' || ch == '$');
-        
-        //System.err.println(" - " + sb.toString());
-        
-        bis.unread(ch);
-        parseSkip(bis);
-        ch = bis.read();
-
-        if(ch == '(') {
-            List<ATerm> l = parseTermSequence(bis, ')');
-            AFun c = makeAFun(sb.toString(), l.size());
-            return makeAppl(c, l.toArray(EMPTY));
-        } else {
-            bis.unread(ch);
-            AFun c = makeAFun(sb.toString(), 0);
-            return makeAppl(c, EMPTY);
-        }
-    }
+		//System.err.println("appl");
+		// TODO: share stringbuilder instances?
+		final StringBuilder sb = new StringBuilder();
+		int ch = bis.read();
+		do {
+			sb.append((char)ch);
+			ch = bis.read();
+		} // TODO: use a switch for this
+		while(Character.isLetterOrDigit((char)ch) || ch == '_' || ch == '-'
+			|| ch == '+' || ch == '*' || ch == '$');
+
+		//System.err.println(" - " + sb.toString());
+
+		bis.unread(ch);
+		parseSkip(bis);
+		ch = bis.read();
+
+		if(ch == '(') {
+			final List<ATerm> l = parseTermSequence(bis, ')');
+			final AFun c = makeAFun(sb.toString(), l.size());
+			return makeAppl(c, l.toArray(EMPTY));
+		} else {
+			bis.unread(ch);
+			final AFun c = makeAFun(sb.toString(), 0);
+			return makeAppl(c, EMPTY);
+		}
+	}
+
 
-	
 	private AFun makeAFun(String ctorName, int arity) {
 		return makeAFun(ctorName, arity, false);
 	}
 
 	private ATerm parsePlaceholder(PushbackStringIterator bis) {
-        ATerm template = parseFromStream(bis);
-        parseSkip(bis);
-        if (bis.read() != '>')
-            throw new ParseError("Expected: '>'");
-        return makePlaceholder(template);
-    }
-
-    private ATerm parseTuple(PushbackStringIterator bis) {
-        //System.err.println("tuple");
-        return makeTuple(parseTermSequence(bis, ')').toArray(EMPTY));
-    }
+		final ATerm template = parseFromStream(bis);
+		parseSkip(bis);
+		if (bis.read() != '>') {
+			throw new ParseError("Expected: '>'");
+		}
+		return makePlaceholder(template);
+	}
 
-    public ATermTuple makeTuple(ATerm[] elements) {
-    	return new ATermTuple(this, elements);
+	private ATerm parseTuple(PushbackStringIterator bis) {
+		//System.err.println("tuple");
+		return makeTuple(parseTermSequence(bis, ')').toArray(EMPTY));
+	}
+
+	public ATermTuple makeTuple(ATerm[] elements) {
+		return new ATermTuple(this, elements);
 	}
 
 	private List<ATerm> parseTermSequence(PushbackStringIterator bis, char endChar) {
-        //System.err.println("sequence");
-		int pos = bis.getOffset();
-        List<ATerm> els = Collections.emptyList();
-        parseSkip(bis);
-        int ch = bis.read();
-        if(ch == endChar)
-            return els;
-        els = new ArrayList<ATerm>();
-        bis.unread(ch);
-        do {
-            els.add(parseFromStream(bis));
-            parseSkip(bis);
-            ch = bis.read();
-        } while(ch == ',');
-        
-        if (ch != endChar) {
-            bis.unread(ch);
-            parseSkip(bis);
-            ch = bis.read();
-        }
-
-        if(ch != endChar)
-            throw new ParseError("Sequence starting at offset " + pos + " must end with '" + endChar + "', saw '" + (char)ch + "'");
-        
-        return els;
-    }
-
-    private ATerm parseList(PushbackStringIterator bis) {
-        //System.err.println("list");
-        return makeList(parseTermSequence(bis, ']').toArray(new ATerm[0]));
-    }
-
-    private ATerm parseNumber(PushbackStringIterator bis) {
-        //System.err.println("number");
-        String whole = parseDigitSequence(bis);
-        
-        int ch = bis.read();
-        if(ch == '.') {
-            String frac = parseDigitSequence(bis);
-            ch = bis.read();
-            if(ch == 'e' || ch == 'E') {
-                String exp = parseDigitSequence(bis);
-                double d = Double.parseDouble(whole + "." + frac + "e" + exp);
-                return makeReal(d);
-            }
-            bis.unread(ch);
-            double d = Double.parseDouble(whole + "." + frac);
-            return makeReal(d);
-        }
-        bis.unread(ch);
-        return makeInt(Integer.parseInt(whole));
-    }
+		//System.err.println("sequence");
+		final int pos = bis.getOffset();
+		List<ATerm> els = Collections.emptyList();
+		parseSkip(bis);
+		int ch = bis.read();
+		if(ch == endChar) {
+			return els;
+		}
+		els = new ArrayList<ATerm>();
+		bis.unread(ch);
+		do {
+			els.add(parseFromStream(bis));
+			parseSkip(bis);
+			ch = bis.read();
+		} while(ch == ',');
+
+		if (ch != endChar) {
+			bis.unread(ch);
+			parseSkip(bis);
+			ch = bis.read();
+		}
+
+		if(ch != endChar) {
+			throw new ParseError("Sequence starting at offset " + pos + " must end with '" + endChar + "', saw '" + (char)ch + "'");
+		}
 
-    public ATerm makeReal(double d) {
-    	throw new NotImplementedException();
+		return els;
+	}
+
+	private ATerm parseList(PushbackStringIterator bis) {
+		//System.err.println("list");
+		return makeList(parseTermSequence(bis, ']').toArray(new ATerm[0]));
+	}
+
+	private ATerm parseNumber(PushbackStringIterator bis) {
+		//System.err.println("number");
+		final String whole = parseDigitSequence(bis);
+
+		int ch = bis.read();
+		if(ch == '.') {
+			final String frac = parseDigitSequence(bis);
+			ch = bis.read();
+			if(ch == 'e' || ch == 'E') {
+				final String exp = parseDigitSequence(bis);
+				final double d = Double.parseDouble(whole + "." + frac + "e" + exp);
+				return makeReal(d);
+			}
+			bis.unread(ch);
+			final double d = Double.parseDouble(whole + "." + frac);
+			return makeReal(d);
+		}
+		bis.unread(ch);
+		return makeInt(Integer.parseInt(whole));
+	}
+
+	public ATerm makeReal(double d) {
+		throw new NotImplementedException();
 	}
 
 	private String parseDigitSequence(PushbackStringIterator bis) {
-        StringBuilder sb = new StringBuilder();
-        int ch = bis.read();
-        do {
-            sb.append((char)ch);
-            ch = bis.read();
-        } while(Character.isDigit((char)ch));
-        bis.unread(ch);
-        return sb.toString(); 
-    }
-
-    public ATerm parseFromString(String text) {
-    	return parseFromStream(new PushbackStringIterator(text));
-    }
-    
-    private void parseSkip(PushbackStringIterator input){
-        for (;;) {
-            int b = input.read();
-            switch (b) {
-                case ' ': case '\t': case '\n':
-                    continue;
-                default:
-                    input.unread(b);
-                    return;
-            }
-        }
-    }
-    
-    public ATerm annotateTerm(ATerm term, ATerm annotations) {
-    	throw new NotImplementedException();
-    }
+		final StringBuilder sb = new StringBuilder();
+		int ch = bis.read();
+		do {
+			sb.append((char)ch);
+			ch = bis.read();
+		} while(Character.isDigit((char)ch));
+		bis.unread(ch);
+		return sb.toString();
+	}
+
+	public ATerm parseFromString(String text) {
+		return parseFromStream(new PushbackStringIterator(text));
+	}
+
+	private void parseSkip(PushbackStringIterator input){
+		for (;;) {
+			final int b = input.read();
+			switch (b) {
+			case ' ': case '\t': case '\n':
+				continue;
+			default:
+				input.unread(b);
+				return;
+			}
+		}
+	}
+
+	public ATerm annotateTerm(ATerm term, ATerm annotations) {
+		throw new NotImplementedException();
+	}
 
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermString.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermString.java	Thu Dec 16 15:04:26 2010	(r21539)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermString.java	Thu Dec 16 15:04:32 2010	(r21540)
@@ -19,6 +19,7 @@
 	ATermString(ATermFactory factory, String value) {
 		super(factory, null, ATermFactory.EMPTY);
 		this.value = value;
+		assert value != null;
 	}
 	
 	@Override

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:04:26 2010	(r21539)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:04:32 2010	(r21540)
@@ -16,7 +16,7 @@
 import org.spoofax.jsglr.client.PathListPool;
 import org.spoofax.jsglr.client.PooledPathList;
 import org.spoofax.jsglr.client.SGLR;
-import org.spoofax.jsglr.client.imploder.Token;
+import org.spoofax.jsglr.client.imploder.TreeBuilder;
 import org.spoofax.jsglr.shared.SGLRException;
 import org.spoofax.jsglr.shared.Tools;
 import org.spoofax.jsglr.shared.terms.ATerm;
@@ -25,7 +25,10 @@
 public abstract class ParseTestCase extends TestCase {
 
 	protected SGLR sglr;
+	
 	protected String suffix;
+	
+	protected ParseTable table;
 
 	// shared by all tests
 	static final ATermFactory pf = new ATermFactory();
@@ -45,8 +48,8 @@
 		final String fn = "tests/grammars/" + grammar + ".tbl";
 
 		final ATerm result = pf.parseFromString(FileTools.loadFileAsString(fn));
-		final ParseTable pt = new ParseTable(result);
-		sglr = new SGLR(pf, pt);
+		table = new ParseTable(result);
+		sglr = new SGLR(pf, table);
 		//        parseTableService.fetchParseTable("tests/grammars/" + grammar + ".tbl",
 		//        		new AsyncCallback<ATerm>() {
 		//
@@ -77,7 +80,7 @@
 	}
 
 	boolean doCompare = true;
-	public void doParseTest(final String s) {
+	public ATerm doParseTest(final String s) {
 
 		//		parseTableService.fetchText("tests/data/" + s + "." + suffix,
 		//				new AsyncCallback<String>() {
@@ -106,18 +109,21 @@
 			doCompare(s, parsed);
 		} else {
 			if (parsed.getLeftToken() != null)
-				System.out.println(((Token) parsed.getLeftToken()).getTokenizer());
+				System.out.println(parsed.getLeftToken().getTokenizer());
 			System.out.println(parsed);
 		}
 
 		System.out.println(PathListPool.cacheMisses);
 		System.out.println(PooledPathList.maxRemembered);
 		System.out.println(PooledPathList.maxAllocated);
+		return parsed;
 	}
 
 	private void doCompare(String s, final ATerm parsed) {
 		//parseTableService.readTermFromFile("tests/data/" + s + ".trm", new AsyncCallback<ATerm>() {
-		final String x = FileTools.loadFileAsString("tests/data/" + s + ".trm");
+		String extension =
+			table.getTreeBuilder() instanceof TreeBuilder ? ".itrm" : ".trm";
+		final String x = FileTools.loadFileAsString("tests/data/" + s + extension);
 		final ATerm wanted = parsed.getFactory().parse(x);
 		//			@Override
 		//			public void onFailure(Throwable caught) {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestImplode.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestImplode.java	Thu Dec 16 15:04:26 2010	(r21539)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestImplode.java	Thu Dec 16 15:04:32 2010	(r21540)
@@ -16,9 +16,8 @@
 	public void gwtSetUp() throws ParserException, InvalidParseTableException {
         super.gwtSetUp("Java-15", "java");
         sglr.setTreeBuilder(new TreeBuilder());
-        // TODO: compare results
-        doCompare = false;
     }
+    
 
     public void testJava0() throws FileNotFoundException, IOException {
     	doParseTest("java0");

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestTokenize.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestTokenize.java	Thu Dec 16 15:04:32 2010	(r21540)
@@ -0,0 +1,73 @@
+package org.spoofax.jsglr.tests;
+
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.util.Iterator;
+
+import org.spoofax.jsglr.client.imploder.IToken;
+import org.spoofax.jsglr.client.imploder.ITokenizer;
+import org.spoofax.jsglr.client.imploder.TreeBuilder;
+import org.spoofax.jsglr.shared.terms.ATerm;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class TestTokenize extends ParseTestCase {
+
+	@Override
+	protected void gwtSetUp() throws Exception {
+        super.gwtSetUp("Java-15", "java");
+        sglr.setTreeBuilder(new TreeBuilder());
+        sglr.setUseStructureRecovery(true);
+        doCompare = false;
+	}
+
+    public void testJava5() throws FileNotFoundException, IOException {
+    	ATerm parsed = doParseTest("java5");
+    	ITokenizer tokenizer = parsed.getLeftToken().getTokenizer();
+    	Iterator<IToken> tokens = tokenizer.iterator();
+    	System.out.println(tokenizer);
+    	
+    	assertEquals(0, tokens.next().getLine());
+    	IToken packageToken = tokens.next();
+    	assertEquals("package", packageToken.toString());
+    	assertEquals(0, packageToken.getLine());
+    	assertEquals(" ", tokens.next().toString());
+    	assertEquals("java", tokens.next().toString());
+    	assertEquals(".", tokens.next().toString());
+    	assertEquals("java5", tokens.next().toString());
+    	assertEquals(";", tokens.next().toString());
+    	assertEquals("\n", tokens.next().toString());
+    	assertEquals("\n", tokens.next().toString());
+    	IToken classToken = tokens.next();
+    	IToken classToken2 = tokens.next();
+    	System.out.println(classToken2.getLine());
+    	assertEquals("class", classToken.toString());
+    	assertEquals(IToken.TK_KEYWORD, classToken.getKind());
+    	assertEquals(2, classToken.getLine());
+    }
+    
+    public void testJava6() throws FileNotFoundException, IOException {
+    	suffix = "java.recover";
+    	ATerm parsed = doParseTest("java6");
+    	ITokenizer tokenizer = parsed.getLeftToken().getTokenizer();
+    	Iterator<IToken> tokens = tokenizer.iterator();
+    	System.out.println(tokenizer);
+    	
+    	while (!tokens.next().toString().equals("the"));
+    	
+    	IToken token = tokens.next();
+    	assertEquals(" ", token.toString());
+    	assertEquals(IToken.TK_ERROR, token.getKind());
+    	token = tokens.next();
+    	assertEquals("int", token.toString());
+    	assertEquals(IToken.TK_ERROR_KEYWORD, token.getKind());
+    	token = tokens.next();
+    	assertEquals(" ", token.toString());
+    	assertEquals(IToken.TK_ERROR, token.getKind());
+    	token = tokens.next();
+    	assertEquals("bar", token.toString());
+    	assertEquals(IToken.TK_ERROR, token.getKind());
+    }
+
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5.java	Thu Dec 16 15:04:32 2010	(r21540)
@@ -0,0 +1,6 @@
+package java.java5;
+
+class X {
+  ;
+  ;
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java6.java.recover
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java6.java.recover	Thu Dec 16 15:04:32 2010	(r21540)
@@ -0,0 +1,5 @@
+package java.java6;
+
+class Foo {
+  the int bar makes no sense
+}

From karltk at strategoxt.org  Thu Dec 16 16:04:40 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:04:40 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21541 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt: src/org/spoofax/jsglr/client
	src/org/spoofax/jsglr/client/imploder
	src/org/spoofax/jsglr/shared/terms test/org/spoofax/jsg...
Message-ID: <201012161504.oBGF4eif027408@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:04:39 2010
New Revision: 21541
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21541&sc=1

Log:
Collapsed revision history:
 * Added missing import
 * Fixed casting bug.
 * Reallocate a new Tokenizer for each input.
 * Started working on incremental parsing.
 * merge

Added:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IncrementalSGLR.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/IAstNode.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalParsing.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java4-increment.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5-increment.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/s7.str.recover
Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Asfix2TreeBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ITreeBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ATermTreeFactory.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/DummyTokenizer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITokenizer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Tokenizer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestStratego.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Asfix2TreeBuilder.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Asfix2TreeBuilder.java	Thu Dec 16 15:04:32 2010	(r21540)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Asfix2TreeBuilder.java	Thu Dec 16 15:04:39 2010	(r21541)
@@ -22,7 +22,7 @@
 		parseTreeAFun = factory.makeAFun("parsetree", 2, false);
 	}
 
-	public void initialize(ParseTable table, int productionCount, int labelStart, int labelCount) {
+	public void initializeTable(ParseTable table, int productionCount, int labelStart, int labelCount) {
 		labels = new ATermAppl[labelCount - labelStart];
 		this.labelStart = labelStart;
 	}
@@ -31,6 +31,10 @@
 		labels[labelNumber - labelStart] = parseTreeProduction;
 	}
 
+	public void initializeInput(String filename, String input) {
+		// Not used here
+	}
+
 	public ATerm buildNode(int labelNumber, Object[] subtrees) {
 		ATermList ls = factory.makeList();
 		for(int i = subtrees.length - 1; i >= 0; i--) {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ITreeBuilder.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ITreeBuilder.java	Thu Dec 16 15:04:32 2010	(r21540)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ITreeBuilder.java	Thu Dec 16 15:04:39 2010	(r21541)
@@ -5,8 +5,9 @@
 
 public interface ITreeBuilder {
 
-	void initialize(ParseTable table, int productionCount, int labelStart, int labelCount);
+	void initializeTable(ParseTable table, int productionCount, int labelStart, int labelCount);
 	void initializeLabel(int labelNumber, ATermAppl parseTreeProduction);
+	void initializeInput(String filename, String input);
 	
 	Object buildTree(AbstractParseNode node);
 	Object buildTreeTop(Object subtree, int ambiguityCount);

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IncrementalSGLR.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IncrementalSGLR.java	Thu Dec 16 15:04:39 2010	(r21541)
@@ -0,0 +1,112 @@
+package org.spoofax.jsglr.client;
+
+import static java.lang.Math.max;
+
+import java.util.Set;
+
+import org.spoofax.jsglr.client.imploder.IAstNode;
+import org.spoofax.jsglr.client.imploder.IToken;
+import org.spoofax.jsglr.client.imploder.ITreeFactory;
+import org.spoofax.jsglr.client.imploder.TreeBuilder;
+import org.spoofax.jsglr.shared.BadTokenException;
+import org.spoofax.jsglr.shared.SGLRException;
+import org.spoofax.jsglr.shared.TokenExpectedException;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class IncrementalSGLR<TNode extends IAstNode> {
+	
+	private final SGLR parser;
+
+	private final ITreeFactory<TNode> factory;
+	
+	private final Set<String> incrementalSorts;
+
+	public IncrementalSGLR(SGLR parser, ITreeBuilder builder, ITreeFactory<TNode> factory, Set<String> incrementalSorts) {
+		this.parser = parser;
+		this.factory = factory;
+		this.incrementalSorts = incrementalSorts;
+		parser.setTreeBuilder(builder);
+		assert !(builder instanceof TreeBuilder)
+			|| ((TreeBuilder) builder).getFactory().getClass() == factory.getClass();
+	}
+	
+	public IAstNode parseIncremental(String input, String filename, String startSymbol, TNode oldTree)
+			throws TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		
+		String oldInput = oldTree.getLeftToken().getTokenizer().getInput();
+		int damageStart = getDamageStart(input, oldInput);
+		int damageEndOffset = oldInput.length() - input.length();
+		int damageEnd = getDamageEnd(input, oldInput, damageEndOffset);
+		if (damageEnd == 0) return oldTree;
+		
+		StringBuilder partialInput = new StringBuilder(input.length());
+		buildPartialInput(input, partialInput, damageStart, damageEnd, damageEndOffset, oldTree, 0);
+		System.out.println(partialInput);
+		
+		IAstNode partialTree = (IAstNode) parser.parse(partialInput.toString(), startSymbol);
+		// TODO: some sanity check
+		
+		return buildOutputTree(partialTree, oldTree, damageStart, damageEnd);
+	}
+
+	private int buildPartialInput(String input, StringBuilder partialInput, int damageStart, 
+			int damageEnd, int damageEndOffset, IAstNode oldTree, int offset) {
+		
+		IToken left = oldTree.getLeftToken();
+		IToken right = oldTree.getRightToken();
+		int startOffset = 0;
+		int endOffset = 0;
+		
+		if (left != null && right != null) {
+			startOffset = left.getStartOffset();
+			endOffset = right.getEndOffset();
+			if (incrementalSorts.contains(oldTree.getSort())
+					&& !isRangeOverlap(damageStart, damageEnd, startOffset, endOffset)) {
+				for (int i = offset; i < endOffset; i++) {
+					partialInput.append(input.charAt(i) == '\n' ? '\n' : ' ');
+				}
+				return endOffset;
+			}
+		}
+		for (int i = 0, max = oldTree.getChildCount(); i < max; i++) {
+			IAstNode child = oldTree.getChildAt(i);
+			offset = buildPartialInput(input, partialInput, damageStart, damageEnd, damageEndOffset, child, offset);
+		}
+
+		if (left != null && right != null) {
+			int extraOffset = offset >= damageStart ? damageEndOffset : 0;
+			partialInput.append(input, offset + extraOffset, endOffset + extraOffset); 
+			return endOffset;
+		} else {
+			return offset;
+		}
+	}
+
+	private static boolean isRangeOverlap(int start1, int end1, int start2, int end2) {
+		return ((start2 >= start1 && start2 <= end1)
+				|| (end2 >= start1 && end2 <= end1));
+	}
+
+
+	private int getDamageStart(String input, String oldInput) {
+		for (int i = 0; i < input.length(); i++) {
+			if (input.charAt(i) != oldInput.charAt(i)) return i;
+		}
+		return input.length() - 1;
+	}
+
+	private int getDamageEnd(String input, String oldInput, int offset) {
+		int boundOffset = max(offset, 0);
+		for (int i = input.length() - 1; i + boundOffset >= 0; i--) {
+			if (input.charAt(i) != oldInput.charAt(i + offset)) return i;
+		}
+		return 0;
+	}
+	
+	private IAstNode buildOutputTree(IAstNode partialTree, TNode oldTree, int damageStart, int damageEnd) {
+		// TODO
+		throw new NotImplementedException();
+	}
+}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java	Thu Dec 16 15:04:32 2010	(r21540)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java	Thu Dec 16 15:04:39 2010	(r21541)
@@ -641,7 +641,7 @@
 
 	public void setTreeBuilder(ITreeBuilder treeBuilder) {
 		this.treeBuilder = treeBuilder;
-		treeBuilder.initialize(this, NUM_CHARS, LABEL_BASE, labels.length);
+		treeBuilder.initializeTable(this, NUM_CHARS, LABEL_BASE, labels.length);
 		for(int i = 0; i < labels.length; i++) {
 			if(labels[i] == null)
 				continue;

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 15:04:32 2010	(r21540)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 15:04:39 2010	(r21541)
@@ -13,8 +13,6 @@
 import java.util.Queue;
 import java.util.Set;
 
-import org.spoofax.jsglr.client.imploder.ITokenizer;
-import org.spoofax.jsglr.client.imploder.TreeBuilder;
 import org.spoofax.jsglr.shared.ArrayDeque;
 import org.spoofax.jsglr.shared.BadTokenException;
 import org.spoofax.jsglr.shared.SGLRException;
@@ -291,9 +289,7 @@
 		currentInputStream = new PushbackStringIterator(input);
 		acceptingStack = null;
 		collectedErrors.clear();
-		ITokenizer tokenizer = parseTable.getTreeBuilder().getTokenizer();
-		if (tokenizer != null)
-			tokenizer.initialize(filename, input);
+		parseTable.getTreeBuilder().initializeInput(filename, input);
 		PooledPathList.resetPerformanceCounters();
 		PathListPool.resetPerformanceCounters();
 	}
@@ -867,10 +863,14 @@
 		return parseTable;
 	}
 
-	public void setTreeBuilder(TreeBuilder treeBuilder) {
+	public void setTreeBuilder(ITreeBuilder treeBuilder) {
 		parseTable.setTreeBuilder(treeBuilder);
 	}
 
+	public ITreeBuilder getTreeBuilder() {
+		return parseTable.getTreeBuilder();
+	}
+
 	AmbiguityManager getAmbiguityManager() {
 		return ambiguityManager;
 	}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ATermTreeFactory.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ATermTreeFactory.java	Thu Dec 16 15:04:32 2010	(r21540)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ATermTreeFactory.java	Thu Dec 16 15:04:39 2010	(r21541)
@@ -42,12 +42,14 @@
 		AFun afun = factory.makeAFun(constructor, children.size(), false);
 		ATermAppl result = factory.makeAppl(afun, toArray(children));
 		result.internalSetTokens(leftToken, rightToken);
+		result.internalSetSort(sort);
 		return result;
 	}
 
 	public ATermInt createIntTerminal(String sort, IToken token, int value) {
 		ATermInt result = factory.makeInt(value);
 		result.internalSetTokens(token, token);
+		result.internalSetSort(sort);
 		return result;
 	}
 
@@ -58,6 +60,7 @@
 	public ATermString createStringTerminal(String sort, String value, IToken token) {
 		ATermString result = factory.makeString(value);
 		result.internalSetTokens(token, token);
+		result.internalSetSort(sort);
 		return result;
 	}
 
@@ -66,6 +69,7 @@
 		
 		ATermTuple result = factory.makeTuple(toArray(children));
 		result.internalSetTokens(leftToken, rightToken);
+		result.internalSetSort(elementSort);
 		return result;
 	}
 
@@ -80,6 +84,7 @@
 		
 		ATermList result = factory.makeList(toArray(children));
 		result.internalSetTokens(leftToken, rightToken);
+		result.internalSetSort(elementSort);
 		return result;
 	}
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/DummyTokenizer.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/DummyTokenizer.java	Thu Dec 16 15:04:32 2010	(r21540)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/DummyTokenizer.java	Thu Dec 16 15:04:39 2010	(r21541)
@@ -11,16 +11,11 @@
 	
 	private final IToken onlyToken = new Token(this, 0, 0, 0, 0, 0, IToken.TK_UNKNOWN);
 
-	private String filename;
+	private final String filename;
 	
-	private String input;
+	private final String input;
 	
-	/**
-	 * @param inputChars
-	 *           The input characters (used for {indentpadding} productions
-	 *           and error recovery)
-	 */
-	public void initialize(String filename, String input) {
+	public DummyTokenizer(String filename, String input) {
 		this.filename = filename;
 		this.input = input;
 	}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/IAstNode.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/IAstNode.java	Thu Dec 16 15:04:39 2010	(r21541)
@@ -0,0 +1,17 @@
+package org.spoofax.jsglr.client.imploder;
+
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public interface IAstNode {
+	IToken getLeftToken();
+	
+	IToken getRightToken();
+	
+	int getChildCount();
+	
+	IAstNode getChildAt(int i);
+	
+	String getSort();
+}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITokenizer.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITokenizer.java	Thu Dec 16 15:04:32 2010	(r21540)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITokenizer.java	Thu Dec 16 15:04:39 2010	(r21541)
@@ -6,12 +6,6 @@
  * @author Lennart Kats <lennart add lclnet.nl>
  */
 public interface ITokenizer extends Iterable<IToken> {
-	
-	/**
-	 * Initializes the tokenizer for the given
-	 * file name (if applicable) and contents.
-	 */
-	void initialize(String filename, String input);
 
 	String getInput();
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Tokenizer.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Tokenizer.java	Thu Dec 16 15:04:32 2010	(r21540)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Tokenizer.java	Thu Dec 16 15:04:39 2010	(r21541)
@@ -2,6 +2,7 @@
 
 import static java.lang.Math.min;
 import static org.spoofax.jsglr.client.imploder.IToken.TK_ERROR;
+import static org.spoofax.jsglr.client.imploder.IToken.TK_ERROR_KEYWORD;
 import static org.spoofax.jsglr.client.imploder.IToken.TK_LAYOUT;
 import static org.spoofax.jsglr.client.imploder.IToken.TK_RESERVED;
 
@@ -23,11 +24,11 @@
 	private final TokenKindManager manager =
 		new TokenKindManager();
 	
-	private String filename;
+	private final String filename;
 	
-	private String input;
+	private final String input;
 
-	private ArrayList<IToken> tokens;
+	private final ArrayList<IToken> tokens;
 	
 	/** Start of the next token. */
 	private int startOffset;
@@ -37,11 +38,12 @@
 
 	private int offsetAtLineStart;
 	
-	public Tokenizer(KeywordRecognizer keywords) {
+	/**
+	 * Creates a new tokenizer for the given
+	 * file name (if applicable) and contents.
+	 */
+	public Tokenizer(KeywordRecognizer keywords, String filename, String input) {
 		this.keywords = keywords;
-	}
-	
-	public void initialize(String filename, String input) {
 		this.filename = filename;
 		this.input = input;
 		this.tokens = new ArrayList<IToken>(input.length() / EXPECTED_TOKENS_DIVIDER);

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java	Thu Dec 16 15:04:32 2010	(r21540)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java	Thu Dec 16 15:04:39 2010	(r21541)
@@ -34,6 +34,8 @@
 	
 	private static final String TUPLE_CONSTRUCTOR = new String("");
 	
+	private ParseTable table;
+	
 	private ITokenizer tokenizer;
 	
 	private ITreeFactory factory;
@@ -61,19 +63,18 @@
 		this.initializeFactories = true;
 	}
 	
-	public TreeBuilder(ITreeFactory treeFactory, ITokenizer tokenizer) {
+	public TreeBuilder(ITreeFactory treeFactory) {
 		this.factory = treeFactory;
-		this.tokenizer = tokenizer;
 	}
 
-	public void initialize(ParseTable table, int productionCount, int labelStart, int labelCount) {
+	public void initializeTable(ParseTable table, int productionCount, int labelStart, int labelCount) {
+		this.table = table;
 		this.termFactory = table.getFactory();
 		if (initializeFactories) {
 			factory = new ATermTreeFactory(termFactory);
-			tokenizer = new Tokenizer(table.getKeywordRecognizer());
 		}
 		assert !(factory instanceof ATermTreeFactory) || ((ATermTreeFactory) factory).getTermFactory() == table.getFactory(); 
-		assert !(tokenizer instanceof Tokenizer) || ((Tokenizer) factory).getKeywordRecognizer() == table.getKeywordRecognizer(); 
+		assert !(tokenizer instanceof Tokenizer) || ((Tokenizer) tokenizer).getKeywordRecognizer() == table.getKeywordRecognizer(); 
 		this.prodReader = new ProductionAttributeReader(termFactory);
 		this.labels = new LabelInfo[labelCount - labelStart];
 		this.labelStart = labelStart;
@@ -83,9 +84,20 @@
 		labels[labelNumber - labelStart] = new LabelInfo(prodReader, parseTreeProduction);
 	}
 	
+	public void initializeInput(String filename, String input) {
+		assert offset == 0;
+		tokenizer = new Tokenizer(table.getKeywordRecognizer(), filename, input);
+	}
+	
 	public ITokenizer getTokenizer() {
 		return tokenizer;
 	}
+
+	public ITreeFactory getFactory() {
+		if (factory == null && initializeFactories)
+			throw new IllegalStateException("Not initialized yet");
+		return factory;
+	}
 	
 	@Override
 	@Deprecated
@@ -277,7 +289,8 @@
 			List<Object> children) {
 		
 		IToken left = getStartToken(prevToken);
-		IToken right = getEndToken(left, tokenizer.currentToken());
+		// IToken right = getEndToken(left, tokenizer.currentToken());
+		IToken right = tokenizer.currentToken();
 		
 		if (constructor == LIST_CONSTRUCTOR) {
 			return factory.createList(label.getSort(), left, right, children);
@@ -348,8 +361,8 @@
 	}
 	
 	/** Get the last no-layout token for an AST node. */
-	private IToken getEndToken(IToken startToken, IToken lastToken) {
-		int begin = startToken.getIndex();
+	private IToken getEndToken(IToken currentToken, IToken lastToken) {
+		int begin = currentToken.getIndex();
 		
 		for (int i = lastToken.getIndex(); i > begin; i--) {
 			lastToken = tokenizer.getTokenAt(i);

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java	Thu Dec 16 15:04:32 2010	(r21540)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java	Thu Dec 16 15:04:39 2010	(r21541)
@@ -6,8 +6,9 @@
 
 import org.spoofax.jsglr.client.NotImplementedException;
 import org.spoofax.jsglr.client.imploder.IToken;
+import org.spoofax.jsglr.client.imploder.IAstNode;
 
-public abstract class ATerm implements Serializable {
+public abstract class ATerm implements IAstNode, Serializable {
 
 	private static final long serialVersionUID = 1L;
 	
@@ -22,6 +23,8 @@
 	
 	private IToken leftToken, rightToken;
 
+	private String sort;
+
 	ATerm() {}
 	
 	protected ATerm(ATermFactory factory) {
@@ -37,6 +40,9 @@
 	public void internalSetTokens(IToken leftToken, IToken rightToken) {
 		this.leftToken = leftToken;
 		this.rightToken = rightToken;
+		assert getChildCount() == 0
+			|| getChildAt(getChildCount() - 1).getRightToken() == null
+			|| rightToken.getEndOffset() >= getChildAt(getChildCount() - 1).getRightToken().getEndOffset(); 
 	}
 	
 	public IToken getLeftToken() {
@@ -46,6 +52,14 @@
 	public IToken getRightToken() {
 		return rightToken;
 	}
+	
+	public void internalSetSort(String sort) {
+		this.sort = sort;
+	}
+	
+	public String getSort() {
+		return sort;
+	}
 
 	public ATermFactory getFactory() {
 		return factory;

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java	Thu Dec 16 15:04:32 2010	(r21540)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java	Thu Dec 16 15:04:39 2010	(r21541)
@@ -22,6 +22,15 @@
 	public ATermList prepend(ATerm t) {
 		return new ATermList(factory, t, this);
 	}
+	
+	@Override
+	public String getSort() {
+		return super.getSort() + "*";
+	}
+	
+	public String getElementSort() {
+		return super.getSort();
+	}
 
 	public boolean isEmpty() {
 		return element == null;

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:04:32 2010	(r21540)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:04:39 2010	(r21541)
@@ -92,7 +92,7 @@
 		//
 		//			@Override
 		//			public void onSuccess(String result) {
-		final String result = FileTools.loadFileAsString("tests/data/" + s + "." + suffix);
+		final String result = loadAsString(s);
 		assertNotNull("Data file is missing", result);
 		long parseTime = System.nanoTime();
 		ATerm parsed = null;
@@ -119,6 +119,10 @@
 		return parsed;
 	}
 
+	protected String loadAsString(final String testFile) {
+		return FileTools.loadFileAsString("tests/data/" + testFile + "." + suffix);
+	}
+
 	private void doCompare(String s, final ATerm parsed) {
 		//parseTableService.readTermFromFile("tests/data/" + s + ".trm", new AsyncCallback<ATerm>() {
 		String extension =

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalParsing.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalParsing.java	Thu Dec 16 15:04:39 2010	(r21541)
@@ -0,0 +1,43 @@
+package org.spoofax.jsglr.tests;
+
+import java.util.HashSet;
+import java.util.Set;
+
+import org.spoofax.jsglr.client.IncrementalSGLR;
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParserException;
+import org.spoofax.jsglr.client.imploder.TreeBuilder;
+import org.spoofax.jsglr.shared.terms.ATerm;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class TestIncrementalParsing extends ParseTestCase {
+
+    @Override
+	public void gwtSetUp() throws ParserException, InvalidParseTableException {
+        super.gwtSetUp("Java-15", "java");
+        sglr.setTreeBuilder(new TreeBuilder());
+    }
+
+    public void testJava5() throws Exception {
+    	ATerm tree1 = doParseTest("java5");
+    	TreeBuilder builder = (TreeBuilder) sglr.getTreeBuilder();
+    	Set<String> sorts = new HashSet<String>();
+    	sorts.add("MethodDec");
+    	IncrementalSGLR<ATerm> parser = new IncrementalSGLR<ATerm>(sglr, builder, builder.getFactory(), sorts);
+    	ATerm tree2 = (ATerm) parser.parseIncremental(loadAsString("java5-increment"), null, null, tree1);
+    	assertEquals(tree1, tree2);
+    }
+
+    public void testJava4() throws Exception {
+    	ATerm tree1 = doParseTest("java4");
+    	TreeBuilder builder = (TreeBuilder) sglr.getTreeBuilder();
+    	Set<String> sorts = new HashSet<String>();
+    	sorts.add("MethodDec");
+    	IncrementalSGLR<ATerm> parser = new IncrementalSGLR<ATerm>(sglr, builder, builder.getFactory(), sorts);
+    	ATerm tree2 = (ATerm) parser.parseIncremental(loadAsString("java4-increment"), null, null, tree1);
+    	assertEquals(tree1, tree2);
+    }
+
+}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestStratego.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestStratego.java	Thu Dec 16 15:04:32 2010	(r21540)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestStratego.java	Thu Dec 16 15:04:39 2010	(r21541)
@@ -12,6 +12,7 @@
 
 import org.spoofax.jsglr.client.InvalidParseTableException;
 import org.spoofax.jsglr.client.ParserException;
+import org.spoofax.jsglr.client.imploder.TreeBuilder;
 
 public class TestStratego extends ParseTestCase {
 
@@ -49,4 +50,12 @@
         doParseTest("s6");
     }
 
+    public void testS7() throws Exception {
+        sglr.setUseStructureRecovery(true);
+        sglr.setTreeBuilder(new TreeBuilder());
+        doCompare = false;
+    	suffix = "str.recover";
+        doParseTest("s7");
+    }
+
 }

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java4-increment.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java4-increment.java	Thu Dec 16 15:04:39 2010	(r21541)
@@ -0,0 +1,1337 @@
+ /*
+ * Created on 03.des.2005
+ *
+ * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
+ * 
+ * Licensed under the GNU Lesser General Public License, v2.1
+ */
+package org.spoofax.jsglr;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.PushbackInputStream;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Queue;
+import java.util.Set;
+import java.util.Timer;
+import java.util.TimerTask;
+import java.util.concurrent.CancellationException;
+
+import org.spoofax.ArrayDeque;
+
+import aterm.ATerm;
+import aterm.ATermFactory;
+import aterm.pure.PureFactory;
+
+public class SGLR {             
+   
+    private final Set<BadTokenException> collectedErrors = new LinkedHashSet<BadTokenException>();
+    
+    static final int EOF = ParseTable.NUM_CHARS;
+    
+    static final int TAB_SIZE = 4;//8;
+    
+    private static final Timer abortTimer = new Timer(true);
+    
+    private int abortTimerJobId;
+
+    protected static boolean WORK_AROUND_MULTIPLE_LOOKAHEAD;
+    
+    //Performance testing
+    private static long parseTime=0;
+    private static int parseCount=0;
+    
+    private int timeout;
+        
+    public Frame startFrame; 
+    
+    private long startTime;
+    
+    private volatile boolean asyncAborted;
+    
+    private ATermFactory factory;
+
+    public Frame acceptingStack;
+
+    public ArrayDeque<Frame> activeStacks;
+
+    private ParseTable parseTable;
+
+    public int currentToken;
+
+    public int tokensSeen;
+
+    protected int lineNumber;
+
+    protected int columnNumber;
+
+    private ArrayDeque<ActionState> forShifter;
+
+    private ArrayDeque<Frame> forActor;
+
+    private ArrayDeque<Frame> forActorDelayed;
+
+    private int maxBranches;
+
+    private int maxToken;
+
+    private int maxLine;
+
+    private int maxColumn;
+
+    private int maxTokenNumber;
+
+    private AmbiguityManager ambiguityManager;
+
+    public Disambiguator disambiguator;
+
+    private int rejectCount;
+
+    private int reductionCount;
+
+    private PushbackInputStream currentInputStream;
+   
+    //Creates indent- and dedent- tokens
+    //Meant for parsing of indentation based languages
+    //TODO: still under construction
+    private IndentTokenizer indentTokenHandler;
+    
+    // ------------------------------------- Integrated recovery  ------------------------
+  //Keeps track of the indentation for each line
+   // private IndentationHandler indentHandler;
+    
+    private ParserHistory history;
+    
+    private RecoveryConnector recoverIntegrator;
+    
+    protected boolean useIntegratedRecovery;
+    
+    public ParserHistory getHistory() {
+        return history;
+    }    
+     
+    
+    /* START: FINE GRAINED ON REGION */
+    private boolean fineGrainedOnRegion;
+    protected void setFineGrainedOnRegion(boolean fineGrainedMode) {
+        fineGrainedOnRegion=fineGrainedMode;
+        recoverStacks=new ArrayDeque<Frame>();
+    }
+
+    public void clearRecoverStacks(){
+        recoverStacks.clear(false);
+    }
+    
+    private ArrayDeque<Frame> recoverStacks;
+    public ArrayDeque<Frame> getRecoverStacks() {
+        return recoverStacks;
+    }
+
+    protected void setUseFineGrained(boolean useFG) {
+        recoverIntegrator.setUseFineGrained(useFG);        
+    }
+    /* END: FINE GRAINED ON REGION */
+    
+    public Set<BadTokenException> getCollectedErrors() {
+        return collectedErrors;
+    }
+    
+    //-------------------------- fine-grained recovery ----------------------------------
+    private RecoverDisambiguator recoverDisambiguator;
+       
+    SGLR() {
+        basicInit(null);
+    }
+
+    public SGLR(final ATermFactory pf, ParseTable parseTable) {
+        assert pf != null;
+        assert parseTable != null;
+        // Init with a new factory for both serialized or BAF instances.
+        this.parseTable = parseTable;
+        basicInit(pf);        
+    }
+
+    public void setUseStructureRecovery(boolean useRecovery, IRecoveryParser parser) {
+        useIntegratedRecovery = useRecovery;
+        recoverIntegrator = new RecoveryConnector(this, parser);
+    }
+    
+    /**
+     * Structure-based recovery without bridge parsing.
+     * 
+    */
+    public final void setUseStructureRecovery(boolean useRecovery) throws NoRecoveryRulesException {        
+        setUseStructureRecovery(useRecovery, null);
+    }
+    
+    /**
+     * @deprecated Use {@link #asyncCancel()} instead.
+     */
+    @Deprecated
+    public void asyncAbort() {
+        asyncCancel();
+    }
+    
+    /**
+     * Aborts an asynchronously running parse job, causing it to throw an exception.
+     *  
+     * (Provides no guarantee that the parser is actually cancelled.)
+     */
+    public void asyncCancel() {
+        asyncAborted = true;
+    }
+    
+    public void asyncCancelReset() {
+        asyncAborted = false;
+    }
+
+    private void basicInit(ATermFactory factory) {
+        this.factory = factory;
+        if (factory == null)
+            factory = new PureFactory();
+        activeStacks = new ArrayDeque<Frame>();     
+        forActor = new ArrayDeque<Frame>();
+        forActorDelayed = new ArrayDeque<Frame>();
+        forShifter = new ArrayDeque<ActionState>();
+
+        // FIXME This is *wrong*: need to set the input string size instead
+        ambiguityManager = new AmbiguityManager(10000);
+
+        disambiguator = new Disambiguator();
+        //indentHandler = new IndentationHandler();
+       // indentTokenHandler = new IndentTokenizer(indentHandler, false);  
+        useIntegratedRecovery = false;
+        recoverIntegrator = null;
+        history=new ParserHistory();
+        recoverDisambiguator=new RecoverDisambiguator(this.parseTable);
+    }
+
+    public static boolean isDebugging() {
+        return Tools.debugging;
+    }
+
+    public static boolean isLogging() {
+        return Tools.logging;
+    }
+
+    /**
+     * Initializes the active stacks. At the start of parsing there is only one
+     * active stack, and this stack contains the start symbol obtained from the
+     * parse table.
+     * 
+     * @return the initial stack
+     */
+    private Frame initActiveStacks() {
+        activeStacks.clear();
+        Frame st0 = newStack(parseTable.getInitialState());
+        addStack(st0);
+        return st0;
+    }
+    
+    public final ATerm parse(InputStream fis)  throws IOException, SGLRException {        
+        return parse(fis, null);
+    }   
+    
+    public ATerm parse(InputStream fis, String startSymbol) throws IOException,
+            BadTokenException, TokenExpectedException, ParseException,
+            SGLRException {
+        logBeforeParsing();        
+        initParseVariables(fis);        
+        startTime = System.currentTimeMillis();
+        initParseTimer();
+        return sglrParse(startSymbol);
+    }
+    
+    public final ATerm parse(String input) throws IOException, BadTokenException,
+            TokenExpectedException, ParseException, SGLRException {
+        
+        return parse(input, null);
+    }
+    
+    public ATerm parse(String input, String startSymbol) throws IOException, BadTokenException, TokenExpectedException, ParseException,
+        SGLRException {
+        
+        return parse(new ByteArrayInputStream(input.getBytes("ISO-8859-1")), startSymbol);
+    }
+    
+    private void initParseTimer() {
+        if (timeout > 0) {
+            // We use a single shared timer to conserve native threads
+            // and a jobId to recognize stale abort events
+            synchronized (abortTimer) {
+                asyncAborted = false;
+                ++abortTimerJobId;
+            }
+            final int jobId = abortTimerJobId;
+            abortTimer.schedule(new TimerTask() {
+                @Override
+                public void run() {
+                    synchronized (abortTimer) {
+                        if (abortTimerJobId == jobId)
+                            asyncAbort();
+                    }
+                }
+            }, timeout
+            );
+        } else {
+            asyncAborted = false;
+        }
+    }
+    
+    /**
+     * Sets the maximum amount of time to try and parse a file,
+     * before a {@link ParseTimeoutException} is thrown.
+     * 
+     * @param timeout  The maximum time to parse, in milliseconds.
+     */
+    public void setTimeout(int timeout) {
+        this.timeout = timeout;
+    }
+
+    private ATerm sglrParse(String startSymbol)
+            throws IOException, BadTokenException, TokenExpectedException,
+            ParseException, SGLRException {       
+        
+        try {
+            do {
+                readNextToken();                
+                //indentHandler.updateIndentation(currentToken);
+                //indentTokenHandler.handleIndentShifts(this);                
+                //recoverHandler.afterStreamRead(currentToken);
+                history.keepTokenAndState(this);
+                doParseStep(); 
+                //recoverHandler.afterParseStep();
+               // System.out.print((char)currentToken);             
+            } while (currentToken != SGLR.EOF && activeStacks.size() > 0);
+            
+            if (acceptingStack == null) {
+                collectedErrors.add(createBadTokenException()); 
+            }
+            
+            if(useIntegratedRecovery && acceptingStack==null){                
+                recoverIntegrator.recover();                              
+                if(acceptingStack==null && activeStacks.size()>0)
+                    return sglrParse(startSymbol);
+            } /*else if(recoverHandler.meetsRecoverCriteria()){
+                recoverHandler.recover();
+                if(acceptingStack==null)
+                    return sglrParse(startSymbol);
+            }*/
+           
+        } catch (CancellationException e) {
+            throw new ParseTimeoutException(this, currentToken, tokensSeen - 1, lineNumber,
+                    columnNumber, collectedErrors);
+        }           
+                
+        logAfterParsing();    
+        
+        Link s = acceptingStack.findDirectLink(startFrame);
+                
+        if (s == null)
+            throw new ParseException(this, "Accepting stack has no link");
+     
+        logParseResult(s);
+        Tools.debug("avoids: ", s.recoverCount);
+        //Tools.debug(s.label.toParseTree(parseTable));
+        
+        return disambiguator.applyFilters(this, s.label, startSymbol, tokensSeen);
+    }
+
+    void readNextToken() throws IOException {
+        logCurrentToken();            
+        currentToken = getNextToken();    
+    }
+
+    public void doParseStep() throws IOException {               
+        parseCharacter(); //applies reductions on active stack structure and fills forshifter                      
+        shifter(); //renewes active stacks with states in forshifter
+    }    
+
+    private void initParseVariables(InputStream fis) {        
+        startFrame = initActiveStacks();
+        tokensSeen = 0;
+        columnNumber = 0;
+        lineNumber = 1;        
+        currentInputStream = new PushbackInputStream(fis, 1024);
+        acceptingStack = null; 
+        //history.keepInitialState(this);
+        collectedErrors.clear();
+    }    
+
+     private BadTokenException createBadTokenException() {
+        Frame singlePreviousStack = activeStacks.size() == 1
+                ? activeStacks.get(0)
+                : null;
+        if (singlePreviousStack != null) {
+            Action action = singlePreviousStack.peek().getSingularAction();
+            
+            if (action != null && action.getActionItems().length == 1) {
+                StringBuilder expected = new StringBuilder();
+                
+                do {
+                    int token = action.getSingularRange();
+                    if (token == -1) break;
+                    expected.append((char) token);
+                    
+                    ActionItem[] items = action.getActionItems();
+                    
+                    if (!(items.length == 1 && items[0].type == ActionItem.SHIFT))
+                        break;
+                    
+                    Shift shift = (Shift) items[0];
+                    action = parseTable.getState(shift.nextState).getSingularAction();
+                                        
+                } while (action != null);
+
+                if (expected.length() > 0)
+                    return new TokenExpectedException(this, expected.toString(), currentToken,
+                                                     tokensSeen - 1, lineNumber, columnNumber);
+            }
+        }
+        
+        return new BadTokenException(this, currentToken, tokensSeen - 1, lineNumber,
+                                           columnNumber);
+    }
+
+    private void shifter() {
+        logBeforeShifter();
+        clearActiveStacks(false);
+
+        IParseNode prod = parseTable.lookupProduction(currentToken);
+
+        while (forShifter.size() > 0) {
+            ActionState as = forShifter.remove();
+            if (!parseTable.hasRejects() || !as.st.allLinksRejected()) {
+                Frame st1 = findStack(activeStacks, as.s);
+                if (st1 == null) {
+                    st1 = newStack(as.s);
+                    addStack(st1);
+                }
+                st1.addLink(as.st, prod, 1);
+            } else {
+                if (Tools.logging) {
+                    Tools.logger("Shifter: skipping rejected stack with state ",
+                                 as.st.state.stateNumber);
+                }
+            }
+        }
+        logAfterShifter();
+    }
+    
+    private void foo() {
+    	// and then there was a foo
+    }
+
+    public void addStack(Frame st1) {
+        if(Tools.tracing) {
+            TRACE("SG_AddStack() - " + st1.state.stateNumber);
+        }
+        activeStacks.addFirst(st1);
+    }    
+
+    private void parseCharacter() throws IOException {
+        logBeforeParseCharacter();
+
+        ArrayDeque<Frame> actives = new ArrayDeque<Frame>(activeStacks); // FIXME avoid garbage        
+        clearForActorDelayed(false);
+        clearForShifter(false);
+        while (actives.size() > 0 || forActor.size() > 0) {
+            Frame st;
+            st = pickStackNodeFromActivesOrForActor(actives);
+            if (!st.allLinksRejected()) {
+                actor(st);
+            }
+            
+            if(actives.size() == 0 && forActor.size() == 0) {
+                fillForActorWithDelayedFrames(); //Fills foractor, clears foractor delayed
+            }
+        }
+        return;
+    }
+
+    private void fillForActorWithDelayedFrames() {
+        if(Tools.tracing) {
+            TRACE("SG_ - both empty");
+        }
+        forActor = forActorDelayed;
+        forActorDelayed = new ArrayDeque<Frame>(); // FIXME: avoid garbage
+    }
+
+    private Frame pickStackNodeFromActivesOrForActor(ArrayDeque<Frame> actives) {
+        Frame st;
+        if(actives.size() > 0) {
+            if(Tools.tracing) {
+                TRACE("SG_ - took active");
+            }
+            st = actives.remove();
+        } else {
+            if(Tools.tracing) {
+                TRACE("SG_ - took foractor");
+            }
+            st = forActor.remove();
+        }
+        return st;
+    }    
+
+    private void actor(Frame st) throws IOException {
+        State s = st.peek();
+        logBeforeActor(st, s);        
+        for (Action action : s.getActions()) {
+            if (action.accepts(currentToken)) {
+                for (ActionItem ai : action.getActionItems()) {                    
+                    switch (ai.type) {
+                        case ActionItem.SHIFT: {
+                            Shift sh = (Shift) ai;
+                            ActionState actState = new ActionState(st, parseTable.getState(sh.nextState));
+                            actState.currentToken = currentToken;                            
+                            addShiftPair(actState); //Adds StackNode to forshifter
+                            statsRecordParsers(); //sets some values un current parse state
+                            break;
+                        }
+                        case ActionItem.REDUCE: {
+                            Reduce red = (Reduce) ai;
+                            doReductions(st, red.production);
+                            break;
+                        }
+                        case ActionItem.REDUCE_LOOKAHEAD: {
+                            ReduceLookahead red = (ReduceLookahead) ai;
+                            if(checkLookahead(red)) {
+                                if(Tools.tracing) {
+                                    TRACE("SG_ - ok");
+                                }
+                                doReductions(st, red.production);
+                            }
+                            break;
+                        }
+                        case ActionItem.ACCEPT: {                            
+                            if (!st.allLinksRejected()) {
+                                acceptingStack = st;
+                                if (Tools.logging) {
+                                    Tools.logger("Reached the accept state");
+                                }
+                            }
+                            break;
+                        }
+                        default:
+                            throw new NotImplementedException();
+                     }
+                }
+            }            
+        }
+        
+        if(Tools.tracing) {
+            TRACE("SG_ - actor done");
+        }
+    }    
+
+    private boolean checkLookahead(ReduceLookahead red) throws IOException {
+        return doCheckLookahead(red, red.getCharRanges(), 0);
+    }
+    
+    private boolean doCheckLookahead(ReduceLookahead red, RangeList[] charClass, int pos) throws IOException {
+        if(Tools.tracing) {
+            TRACE("SG_CheckLookAhead() - ");
+        }
+        
+        int c = currentInputStream.read();
+        
+        // EOF
+        if(c == -1) 
+            return true;
+        
+        boolean permit = true;
+        
+        if(pos < charClass.length)
+            permit = charClass[pos].within(c) ? false : doCheckLookahead(red, charClass, pos + 1);
+
+        currentInputStream.unread(c);
+        return permit;
+    }
+
+    private void addShiftPair(ActionState state) {
+        if(Tools.tracing) {
+            TRACE("SG_AddShiftPair() - " + state.s.stateNumber);
+        }
+        forShifter.add(state);
+    }
+
+    private void statsRecordParsers() {
+        if (forShifter.size() > maxBranches) {
+            maxBranches = forShifter.size();
+            maxToken = currentToken;
+            maxColumn = columnNumber;
+            maxLine = lineNumber;
+            maxTokenNumber = tokensSeen;
+        }
+    }
+
+    private void doReductions(Frame st, Production prod) throws IOException {
+        if(recoverModeOk(st, prod)){
+            List<Path> paths = st.findAllPaths(prod.arity);         
+            logBeforeDoReductions(st, prod, paths.size());
+            reduceAllPaths(prod, paths);
+            logAfterDoReductions();
+        }
+    }
+    
+    private boolean recoverModeOk(Frame st, Production prod) {
+        return !prod.isRecoverProduction() || fineGrainedOnRegion;
+        
+    }
+    /*
+    private boolean recoverModeOk(Frame st, Production prod) {
+        if(useIntegratedRecovery && prod.isRecoverProduction() && !reduceRecoverOnly && recoverTolerance>0){
+           //if(findStack(recoveryActor, st.state)==null)
+            if(!recoveryActor.contains(st))
+                recoveryActor.addFirst(st);
+        }
+        // TODO: is this condition right??
+        return !useIntegratedRecovery || prod.isRecoverProduction() == reduceRecoverOnly;
+    }*/
+    
+    private void doLimitedReductions(Frame st, Production prod, Link l) throws IOException { //Todo: Look add sharing code with doReductions
+        if(recoverModeOk(st, prod)){
+            List<Path> paths = st.findLimitedPaths(prod.arity, l); //find paths containing the link         
+            logBeforeLimitedReductions(st, prod, l, paths);        
+            reduceAllPaths(prod, paths);
+        }
+    }
+
+    private void reduceAllPaths(Production prod, List<Path> paths)
+            throws IOException {
+        
+        for (int i = paths.size() - 1; i >= 0; i--) {
+            Path path = paths.get(i);
+            List<IParseNode> kids = path.getATerms();
+            Frame st0 = path.getEnd();
+            State next = parseTable.go(st0.peek(), prod.label);
+            logReductionPath(prod, path, kids, st0, next);
+            reducer(st0, next, prod, kids, path);
+        }
+        clearPath(paths);
+        
+        if (asyncAborted) {
+            // Rethrown as ParseTimeoutException in SGLR.sglrParse()
+            throw new CancellationException("Long-running parse job aborted");
+        }
+    }
+
+    
+    private void clearPath(List<Path> paths) {
+        if(Tools.tracing) {
+            SGLR.TRACE("SG_ClearPath() - " + paths.size());
+        }
+        paths.clear();
+    }
+
+    private void reducer(Frame st0, State s, Production prod, List<IParseNode> kids, Path path) throws IOException {
+        int length = path.getLength();        
+        int numberOfRecoveries = calcRecoverCount(prod, path); 
+        IParseNode t = prod.apply(kids);
+        Frame st1; 
+        Link nl;                   
+        logBeforeReducer(s, prod, length);
+        increaseReductionCount();        
+        st1 = findStack(activeStacks, s);
+        if (st1 == null) {             
+            if(prod.isRecoverProduction()){           
+                addNewRecoverStack(st0, s, prod, length, numberOfRecoveries, t); 
+                return;
+            } 
+            addNewStack(st0, s, prod, length, numberOfRecoveries, t); 
+        } else {
+            /* A stack with state s exists; check for ambiguities */
+            nl = st1.findDirectLink(st0);
+
+            if (nl != null) {
+                if(prod.isRecoverProduction()){           
+                    return;               
+                }   
+                logAmbiguity(st0, prod, st1, nl);
+                if (prod.isRejectProduction())
+                    nl.reject();               
+                if(numberOfRecoveries==0 && nl.recoverCount==0 || nl.isRejected())
+                    createAmbNode(t, nl);
+                else if (numberOfRecoveries < nl.recoverCount){                    
+                    nl.label=t;
+                    nl.recoverCount=numberOfRecoveries;
+                    actorOnActiveStacksOverNewLink(nl);                   
+                }
+                else if (numberOfRecoveries == nl.recoverCount){                    
+                    nl.label=t;                                      
+                }
+            } else {
+                if(prod.isRecoverProduction()){           
+                    addNewRecoverStack(st0, s, prod, length, numberOfRecoveries, t);
+                    return;
+                }    
+                nl = st1.addLink(st0, t, length);
+                nl.recoverCount = numberOfRecoveries;
+                if (prod.isRejectProduction()){
+                    nl.reject();    
+                    increaseRejectCount();
+                } 
+                logAddedLink(st0, st1, nl);              
+                actorOnActiveStacksOverNewLink(nl);
+            }
+        }
+        if(Tools.tracing) {
+            TRACE_ActiveStacks();
+            TRACE("SG_ - reducer done");
+        }
+    }
+    
+    /*private void handleAmbiguity(int numberOfRecoveries, IParseNode t, Link nl) throws IOException {        
+        //if both branches contain no recover productions and not in recover mode, create an Amb node.
+        //if(numberOfRecoveries == 0 && nl.recoverCount==0){            
+            if(recoverIntegrator==null)
+                createAmbNode(t, nl);
+            else if (!recoverIntegrator.isActive())
+                createAmbNode(t, nl);
+            return;
+        //}
+        //if (!nl.isRejected()) {            
+          //  int nlOld = nl.recoverCount;
+           // recoverDisambiguator.handleAmbiguity(numberOfRecoveries, t, nl);
+           // if (nl.recoverCount < nlOld)
+             //   actorOnActiveStacksOverNewLink(nl);
+        //}
+                        
+    }*/
+
+    void createAmbNode(IParseNode t, Link nl) {
+        nl.addAmbiguity(t, tokensSeen);
+        ambiguityManager.increaseAmbiguityCalls();
+    }
+    
+    private void addNewStack(Frame st0, State s, Production prod, int length,
+            int numberOfRecoveries, IParseNode t) {
+        Frame st1;
+        Link nl;
+        /* Found no existing stack with for state s; make new stack */
+        st1 = newStack(s);            
+        nl = st1.addLink(st0, t, length);
+        nl.recoverCount = numberOfRecoveries;   
+        addStack(st1);            
+        forActorDelayed.addFirst(st1);
+        if(Tools.tracing) {
+            TRACE("SG_AddStack() - " + st1.state.stateNumber);
+        }
+        if (prod.isRejectProduction()) {
+            if (Tools.logging) {
+                Tools.logger("Reject [new]");
+            }
+            nl.reject();
+            increaseRejectCount();
+        }
+    }  
+    
+    private void addNewRecoverStack(Frame st0, State s, Production prod, int length,
+            int numberOfRecoveries, IParseNode t) {
+        if (fineGrainedOnRegion && !prod.isRejectProduction()) {
+            Frame st1;
+            Link nl;
+            /* Found no existing stack with for state s; make new stack */
+            st1 = newStack(s);
+            nl = st1.addLink(st0, t, length);
+            nl.recoverCount = numberOfRecoveries;
+            recoverStacks.addFirst(st1);            
+        }
+    }  
+
+    private void actorOnActiveStacksOverNewLink(Link nl) throws IOException {
+        // Note: ActiveStacks can be modified inside doLimitedReductions
+        // new elements may be inserted at the beginning
+        final int sz = activeStacks.size();
+        for (int i = 0; i < sz; i++) {
+//                for(Frame st2 : activeStacks) {
+            if(Tools.tracing) {
+                TRACE("SG_ activeStack - ");
+            }
+            int pos = activeStacks.size() - sz + i;
+            Frame st2 = activeStacks.get(pos);
+            if (st2.allLinksRejected() || inReduceStacks(forActor, st2) || inReduceStacks(forActorDelayed, st2))
+                continue; //stacknode will find reduction in regular process
+
+            for (Action action : st2.peek().getActions()) {
+                if (action.accepts(currentToken)) {
+                    for (ActionItem ai : action.getActionItems()) {                  
+                        switch(ai.type) {
+                            case ActionItem.REDUCE:
+                                Reduce red = (Reduce) ai;
+                                doLimitedReductions(st2, red.production, nl);                           
+                                break;
+                            case ActionItem.REDUCE_LOOKAHEAD:
+                                ReduceLookahead red2 = (ReduceLookahead) ai;                         
+                                if(checkLookahead(red2)) {
+                                    doLimitedReductions(st2, red2.production, nl);                               
+                                }
+                                break;
+                        }
+                    }
+                }
+            }
+        }
+    }    
+
+    private int calcRecoverCount(Production prod, Path path) {
+        int numberOfRecoveries = path.getRecoverCount();
+        if(prod.isRecoverProduction())
+        {
+            numberOfRecoveries+=1;
+        }
+        return numberOfRecoveries;
+    }
+    
+    private boolean inReduceStacks(Queue<Frame> q, Frame frame) {
+        if(Tools.tracing) {
+            TRACE("SG_InReduceStacks() - " + frame.state.stateNumber);
+        }
+        return q.contains(frame);
+    }
+
+    protected Frame newStack(State s) {
+        if(Tools.tracing) {
+            TRACE("SG_NewStack() - " + s.stateNumber);
+        }
+        return new Frame(s);
+    }
+
+    private void increaseReductionCount() {
+        reductionCount++;
+    }
+
+    protected void increaseRejectCount() {
+        rejectCount++;
+    }
+
+    protected int getRejectCount() {
+        return rejectCount;
+    }
+
+    Frame findStack(ArrayDeque<Frame> stacks, State s) {
+        if(Tools.tracing) {
+            TRACE("SG_FindStack() - " + s.stateNumber);
+        }
+
+        // We need only check the top frames of the active stacks.
+        if (Tools.debugging) {
+            Tools.debug("findStack() - ", dumpActiveStacks());
+            Tools.debug(" looking for ", s.stateNumber);
+        }
+
+        final int size = stacks.size();
+        for (int i = 0; i < size; i++) {
+            if (stacks.get(i).state.stateNumber == s.stateNumber) {
+                if(Tools.tracing) {
+                    TRACE("SG_ - found stack");
+                }
+                return stacks.get(i);
+            }
+        }
+        if(Tools.tracing) {
+            TRACE("SG_ - stack not found");
+        }
+        return null;
+    }     
+   
+
+    private int getNextToken() throws IOException {
+        if(Tools.tracing) {
+            TRACE("SG_NextToken() - ");
+        }
+
+        int t = currentInputStream.read();
+        updateParserFields(t);
+        if(t==-1)
+            return SGLR.EOF;
+        return t;
+    }
+
+    protected void updateParserFields(int t) {
+        tokensSeen++;
+
+        if (Tools.debugging) {
+            Tools.debug("getNextToken() - ", t, "(", (char) t, ")");
+        }
+
+        switch (t) {
+        case '\n':
+            lineNumber++;
+            columnNumber = 0;
+            break;
+        case '\t':
+            columnNumber = (columnNumber / TAB_SIZE + 1) * TAB_SIZE;
+            break;
+        case -1:
+            break;
+        default:
+            columnNumber++;
+        }
+    }
+
+    static int num = 0;
+
+    @Deprecated
+    public void setFilter(boolean filter) {
+        getDisambiguator().setFilterAny(filter);
+    }
+
+    public void clear() {
+        if (this.acceptingStack != null) {
+            this.acceptingStack.clear();
+        }
+
+        clearActiveStacks(true);
+        clearForActorDelayed(true);
+        clearForActor(true);
+        clearForShifter(true);
+
+        this.parseTable = null;
+        this.factory = null;
+        this.ambiguityManager = null; // todo clear
+    }
+
+    private void clearForShifter(boolean all) {
+        if (all) {
+            for (ActionState as : forShifter) {
+                as.clear(all);
+            }
+        }
+        this.forShifter.clear();
+    }
+
+    private void clearForActor(boolean all) {
+        if (all) {
+            for (Frame frame : forActor) {
+                frame.clear();
+            }
+        }
+        forActor.clear();
+    }
+
+    private void clearForActorDelayed(boolean all) {
+        if (all) {
+            for (Frame frame : forActorDelayed) {
+                frame.clear();
+            }
+        }
+        forActorDelayed.clear(true);
+    }
+
+    private void clearActiveStacks(boolean all) {
+        if (all) {
+            for (Frame frame : activeStacks) {
+                frame.clear();
+            }
+        }
+        activeStacks.clear(true);
+    }
+
+    ParseTable getParseTable() {
+        return parseTable;
+    }
+
+    AmbiguityManager getAmbiguityManager() {
+        return ambiguityManager;
+    }
+    
+    public Disambiguator getDisambiguator() {
+        return disambiguator;
+    }
+    
+    public void setDisambiguator(Disambiguator disambiguator) {
+        this.disambiguator = disambiguator;
+    }
+
+    public ATermFactory getFactory() {
+        return factory;
+    }
+
+    public int getReductionCount() {
+        return reductionCount;
+    }
+
+    public int getRejectionCount() {
+        return rejectCount;
+    }
+    
+    @Deprecated
+    public static void setWorkAroundMultipleLookahead(boolean value) {
+        WORK_AROUND_MULTIPLE_LOOKAHEAD = value;
+    }   
+       
+
+      
+      
+    
+    ////////////////////////////////////////////////////// Log functions ///////////////////////////////////////////////////////////////////////////////
+    
+    static void TRACE(String string) {
+        System.err.println("[" + num + "] " + string);
+        num++;
+    }
+
+    private String dumpActiveStacks() {
+        StringBuffer sb = new StringBuffer();
+        boolean first = true;
+        if (activeStacks == null) {
+            sb.append(" GSS unitialized");
+        } else {
+            sb.append("{").append(activeStacks.size()).append("} ");
+            for (Frame f : activeStacks) {
+                if (!first)
+                    sb.append(", ");
+                sb.append(f.dumpStack());
+                first = false;
+            }
+        }
+        return sb.toString();
+    }
+
+    
+    private void logParseResult(Link s) {
+        if (isDebugging()) {
+            Tools.debug("internal parse tree:\n", s.label);
+        }
+
+        if(Tools.tracing) {
+            TRACE("SG_ - internal tree: " + s.label);
+        }       
+                
+        if (Tools.measuring) {
+            Measures m = new Measures();
+            //Tools.debug("Time (ms): " + (System.currentTimeMillis()-startTime));
+            m.setTime(System.currentTimeMillis() - startTime);
+            //Tools.debug("Red.: " + reductionCount);
+            m.setReductionCount(reductionCount);
+            //Tools.debug("Nodes: " + Frame.framesCreated);
+            m.setFramesCreated(Frame.framesCreated);
+            //Tools.debug("Links: " + Link.linksCreated);
+            m.setLinkedCreated(Link.linksCreated);
+            //Tools.debug("avoids: " + s.avoidCount);
+            m.setAvoidCount(s.recoverCount);
+            //Tools.debug("Total Time: " + parseTime);
+            m.setParseTime(parseTime);
+            //Tools.debug("Total Count: " + parseCount);
+            Measures.setParseCount(++parseCount);
+            //Tools.debug("Average Time: " + (int)parseTime / parseCount);
+            m.setAverageParseTime((int)parseTime / parseCount);
+            m.setRecoverTime(-1);
+            Tools.setMeasures(m);
+        }
+    }
+    
+
+    private void logBeforeParsing() {
+        if(Tools.tracing) {
+            TRACE("SG_Parse() - ");
+        }
+
+        if (Tools.debugging) {
+            Tools.debug("parse() - ", dumpActiveStacks());
+        }
+    }
+    
+    private void logAfterParsing()
+            throws BadTokenException, TokenExpectedException {
+        if (isLogging()) {
+            Tools.logger("Number of lines: ", lineNumber);
+            Tools.logger("Maximum ", maxBranches, " parse branches reached at token ",
+                         logCharify(maxToken), ", line ", maxLine, ", column ", maxColumn,
+                         " (token #", maxTokenNumber, ")");
+
+            long elapsed = System.currentTimeMillis() - startTime;
+            Tools.logger("Parse time: " + elapsed / 1000.0f + "s");
+        }
+
+        if (isDebugging()) {
+            Tools.debug("Parsing complete: all tokens read");
+        }
+
+        if (acceptingStack == null) {
+            BadTokenException bad = createBadTokenException();
+            if (collectedErrors.isEmpty()) {
+                throw bad;
+            } else {
+                collectedErrors.add(bad);
+                throw new MultiBadTokenException(this, collectedErrors);
+            }
+        }
+
+
+        if (isDebugging()) {
+            Tools.debug("Accepting stack exists");
+        }
+    }
+
+    private void logCurrentToken() {
+        if (isLogging()) {
+            Tools.logger("Current token (#", tokensSeen, "): ", logCharify(currentToken));
+        }
+    }
+    
+    private void logAfterShifter() {
+        if(Tools.tracing) {
+            TRACE("SG_DiscardShiftPairs() - ");
+            TRACE_ActiveStacks();
+        }
+    }
+
+    private void logBeforeShifter() {
+        if(Tools.tracing) {
+            TRACE("SG_Shifter() - ");
+            TRACE_ActiveStacks();
+        }
+        
+        if (Tools.logging) {
+            Tools.logger("#", tokensSeen, ": shifting ", forShifter.size(), " parser(s) -- token ",
+                         logCharify(currentToken), ", line ", lineNumber, ", column ", columnNumber);
+        }
+
+        if (Tools.debugging) {
+            Tools.debug("shifter() - " + dumpActiveStacks());
+
+            Tools.debug(" token   : " + currentToken);
+            Tools.debug(" parsers : " + forShifter.size());
+        }
+    }
+    
+    private void logBeforeParseCharacter() {
+        if(Tools.tracing) {
+            TRACE("SG_ParseToken() - ");
+        }
+
+        if (Tools.debugging) {
+            Tools.debug("parseCharacter() - " + dumpActiveStacks());
+            Tools.debug(" # active stacks : " + activeStacks.size());
+        }
+
+        /* forActor = *///computeStackOfStacks(activeStacks);
+
+        if (Tools.debugging) {
+            Tools.debug(" # for actor     : " + forActor.size());
+        }
+    }
+    
+    private String logCharify(int currentToken) {
+        switch (currentToken) {
+        case 32:
+            return "\\32";
+        case SGLR.EOF:
+            return "EOF";
+        case '\n':
+            return "\\n";
+        case 0:
+            return "\\0";
+        default:
+            return "" + (char) currentToken;
+        }
+    }
+    
+    private void logBeforeActor(Frame st, State s) {
+        List<ActionItem> actionItems = null;
+        
+        if (Tools.debugging || Tools.tracing) {
+            actionItems = s.getActionItems(currentToken);
+        }
+        
+        if(Tools.tracing) {
+            TRACE("SG_Actor() - " + st.state.stateNumber);
+            TRACE_ActiveStacks();
+        }
+        
+        if (Tools.debugging) {
+            Tools.debug("actor() - ", dumpActiveStacks());
+        }       
+
+        if (Tools.debugging) {
+            Tools.debug(" state   : ", s.stateNumber);
+            Tools.debug(" token   : ", currentToken);
+        }        
+
+        if (Tools.debugging) {
+            Tools.debug(" actions : ", actionItems);
+        }
+        
+        if(Tools.tracing) {
+            TRACE("SG_ - actions: " + actionItems.size());
+        }
+    }
+    
+    private void logAfterDoReductions() {
+        if (Tools.debugging) {
+            Tools.debug("<doReductions() - " + dumpActiveStacks());
+        }
+        
+        if(Tools.tracing) {
+            TRACE("SG_ - doreductions done");
+        }
+    }
+
+    private void logReductionPath(Production prod, Path path,
+            List<IParseNode> kids, Frame st0, State next) {
+        if (Tools.debugging) {
+            Tools.debug(" path: ", path);
+            Tools.debug(" kids: ", kids);        
+            Tools.debug(st0.state);
+        }            
+
+        if (Tools.logging) {
+            Tools.logger("Goto(", st0.peek().stateNumber, ",", prod.label + ") == ",
+                         next.stateNumber);
+        }
+    }   
+    
+
+    private void logBeforeDoReductions(Frame st, Production prod,
+            final int pathsCount) {
+        if(Tools.tracing) {
+            TRACE("SG_DoReductions() - " + st.state.stateNumber);
+        }
+
+        if (Tools.debugging) {
+            Tools.debug("doReductions() - " + dumpActiveStacks());
+            logReductionInfo(st, prod);       
+            Tools.debug(" paths : " + pathsCount);
+        }
+    }
+    
+    private void logBeforeLimitedReductions(Frame st, Production prod, Link l,
+            List<Path> paths) {
+        if(Tools.tracing) {
+            TRACE("SG_ - back in reducer ");
+            TRACE_ActiveStacks();
+            TRACE("SG_DoLimitedReductions() - " + st.state.stateNumber + ", " + l.parent.state.stateNumber);
+        }
+
+        if (Tools.debugging) {
+            Tools.debug("doLimitedReductions() - ", dumpActiveStacks());
+            logReductionInfo(st, prod);
+            List<?> reversePaths = (List<?>) ((ArrayList<?>) paths).clone();
+            Collections.reverse(reversePaths);
+            Tools.debug(reversePaths);
+        }
+    }
+
+    private void logReductionInfo(Frame st, Production prod) {
+        Tools.debug(" state : ", st.peek().stateNumber);
+        Tools.debug(" token : ", currentToken);
+        Tools.debug(" label : ", prod.label);
+        Tools.debug(" arity : ", prod.arity);
+        Tools.debug(" stack : ", st.dumpStack());
+    }
+
+    private void logAddedLink(Frame st0, Frame st1, Link nl) {
+        if (Tools.debugging) {
+            Tools.debug(" added link ", nl, " from ", st1.state.stateNumber, " to ",
+                        st0.state.stateNumber);
+        }               
+
+        if(Tools.tracing) {
+            TRACE_ActiveStacks();
+        }
+    }
+    
+    private void logBeforeReducer(State s, Production prod, int length) {
+        if(Tools.tracing) {
+            TRACE("SG_Reducer() - " + s.stateNumber + ", " + length + ", " + prod.label);
+            TRACE_ActiveStacks();
+        }
+
+        if (Tools.logging) {
+            Tools.logger("Reducing; state ", s.stateNumber, ", token: ", logCharify(currentToken),
+                         ", production: ", prod.label);
+        }
+
+        if (Tools.debugging) {
+            Tools.debug("reducer() - ", dumpActiveStacks());
+
+            Tools.debug(" state      : ", s.stateNumber);
+            Tools.debug(" token      : ", logCharify(currentToken) + " (" + currentToken + ")");
+            Tools.debug(" production : ", prod.label);
+        }
+    }
+
+    private void TRACE_ActiveStacks() {
+        TRACE("SG_ - active stacks: " + activeStacks.size());
+        TRACE("SG_ - for_actor stacks: " + forActor.size());
+        TRACE("SG_ - for_actor_delayed stacks: " + forActorDelayed.size());
+    }
+
+   
+    private void logAmbiguity(Frame st0, Production prod, Frame st1, Link nl) {
+        if (Tools.logging) {
+            Tools.logger("Ambiguity: direct link ", st0.state.stateNumber, " -> ",
+                         st1.state.stateNumber, " ", (prod.isRejectProduction() ? "{reject}" : ""));
+            if (nl.label instanceof ParseNode) {
+                Tools.logger("nl is ", nl.isRejected() ? "{reject}" : "", " for ",
+                             ((ParseNode) nl.label).label);
+            }
+        }
+
+        if (Tools.debugging) {
+            Tools.debug("createAmbiguityCluster - ", tokensSeen - nl.getLength() - 1, "/",
+                        nl.getLength());
+        }
+    }    
+    //-------------------------------------------------- mj: debug and recovery ------------------------
+        
+    //Used for debugging
+    private String mjInfo() {
+        String result = "";
+        result += "CURR TOKEN: " + (char)currentToken;
+        result += " ACTIVESTACKS: ";
+        for (Frame f : activeStacks) {
+            result += f.state.stateNumber;
+            if(f.minAvoidValue() > 0)
+                result += "$"+f.minAvoidValue() + "$";
+            result += "; ";            
+        }
+        result += " FORACTOR: ";
+        for (Frame f : forActor) {
+            result += f.state.stateNumber;
+            result += "; ";
+        }
+        result += " FORACTOR_DELAYED: ";
+        for (Frame f : forActorDelayed) {
+            result += f.state.stateNumber;
+            result += "; ";
+        }
+        result += " FORSHIFTER: ";
+        for (ActionState as : forShifter) {
+            result += "{ ";
+            result += as.st.state.stateNumber;
+            result+=",";
+            result += as.s.stateNumber;            
+            result += "} ; ";
+        }
+        return result;        
+    } 
+    
+    private String[] viewStackObject(boolean avoidFiltered){
+        List<String> stackPaths = new ArrayList<String>();
+        for (Frame actNode : activeStacks) {
+            List<String> testMJ = actNode.getStackPaths("", avoidFiltered);
+            stackPaths.addAll(testMJ);
+        }
+        return stackPaths.toArray(new String[stackPaths.size()]);
+    }  
+    
+    private String[] viewStackObject()
+    {
+        return viewStackObject(false);
+    }
+    
+    private String[] viewFilteredStackObject()
+    {
+        return viewStackObject(true);
+    }
+    
+    private void mjTesting() {        
+        Tools.debug((char)currentToken); 
+    }   
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5-increment.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5-increment.java	Thu Dec 16 15:04:39 2010	(r21541)
@@ -0,0 +1,6 @@
+package java.java5;
+
+class X {
+  ;
+  void foo() {}void bar() {}
+}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5.java	Thu Dec 16 15:04:32 2010	(r21540)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5.java	Thu Dec 16 15:04:39 2010	(r21541)
@@ -2,5 +2,5 @@
 
 class X {
   ;
-  ;
+  void foo() {}
 }

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/s7.str.recover
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/s7.str.recover	Thu Dec 16 15:04:39 2010	(r21541)
@@ -0,0 +1,3 @@
+module foo
+rules
+  foo : 0 -> 1 wher i
\ No newline at end of file

From karltk at strategoxt.org  Thu Dec 16 16:04:46 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:04:46 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21542 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt: src/org/spoofax/jsglr/client
	src/org/spoofax/jsglr/client/imploder
	src/org/spoofax/jsglr/shared src/org/spoofax/jsglr/shar...
Message-ID: <201012161504.oBGF4kDD027412@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:04:46 2010
New Revision: 21542
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21542&sc=1

Log:
Incremental parsing basics working.

Added:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IncrementalSGLRException.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java
Deleted:
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalParsing.java
Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IncrementalSGLR.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ATermTreeFactory.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/IAstNode.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITreeFactory.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/BadTokenException.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermTuple.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5-increment.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java	Thu Dec 16 15:04:39 2010	(r21541)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java	Thu Dec 16 15:04:46 2010	(r21542)
@@ -344,6 +344,9 @@
 		if (SGLR.isDebugging()) {
 			Tools.debug("filterTree(node)    - ", t);
 		}
+		
+		// parseTable.setTreeBuilder(new Asfix2TreeBuilder());
+		// System.out.println(yieldTree(t));
 
 		if (t instanceof Amb) {
 			if (!inAmbiguityCluster) {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IncrementalSGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IncrementalSGLR.java	Thu Dec 16 15:04:39 2010	(r21541)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IncrementalSGLR.java	Thu Dec 16 15:04:46 2010	(r21542)
@@ -1,12 +1,16 @@
 package org.spoofax.jsglr.client;
 
 import static java.lang.Math.max;
+import static java.lang.Math.min;
 
+import java.util.ArrayList;
+import java.util.List;
 import java.util.Set;
 
 import org.spoofax.jsglr.client.imploder.IAstNode;
 import org.spoofax.jsglr.client.imploder.IToken;
 import org.spoofax.jsglr.client.imploder.ITreeFactory;
+import org.spoofax.jsglr.client.imploder.Tokenizer;
 import org.spoofax.jsglr.client.imploder.TreeBuilder;
 import org.spoofax.jsglr.shared.BadTokenException;
 import org.spoofax.jsglr.shared.SGLRException;
@@ -17,12 +21,30 @@
  */
 public class IncrementalSGLR<TNode extends IAstNode> {
 	
+	/**
+	 * Allows for one character of extra slack based on the assumption
+	 * that grammars will not have two consecutive IncrementalSort*
+	 * lists.
+	 */
+	private static final int NEXT_CHAR = 1;
+	
+	private static final boolean ASSUME_MINIMAL_DIFF = true;
+	
+	private static final boolean DEBUG = true;
+	
 	private final SGLR parser;
 
 	private final ITreeFactory<TNode> factory;
 	
 	private final Set<String> incrementalSorts;
+	
+	private boolean isDamageIncluded;
 
+	/**
+	 * @param incrementalSorts
+	 *            Sorts that can be incrementally parsed (e.g., MethodDec, ImportDec).
+	 *            *Must* be sorts that only occur in lists (such as MethodDec*).
+	 */
 	public IncrementalSGLR(SGLR parser, ITreeBuilder builder, ITreeFactory<TNode> factory, Set<String> incrementalSorts) {
 		this.parser = parser;
 		this.factory = factory;
@@ -30,63 +52,167 @@
 		parser.setTreeBuilder(builder);
 		assert !(builder instanceof TreeBuilder)
 			|| ((TreeBuilder) builder).getFactory().getClass() == factory.getClass();
+		
+		// TODO: support injection sorts in incrementalSorts
+		//       (using injection prods in parse table; build some class like KeywordRecognizer)
 	}
 	
 	public IAstNode parseIncremental(String input, String filename, String startSymbol, TNode oldTree)
-			throws TokenExpectedException, BadTokenException, ParseException, SGLRException {
+			throws TokenExpectedException, BadTokenException, ParseException, SGLRException, IncrementalSGLRException {
 		
 		String oldInput = oldTree.getLeftToken().getTokenizer().getInput();
 		int damageStart = getDamageStart(input, oldInput);
-		int damageEndOffset = oldInput.length() - input.length();
-		int damageEnd = getDamageEnd(input, oldInput, damageEndOffset);
-		if (damageEnd == 0) return oldTree;
+		int afterDamageOffset = input.length() - oldInput.length();
+		int damageEnd = getDamageEnd(input, oldInput, afterDamageOffset,
+				ASSUME_MINIMAL_DIFF ? max(afterDamageOffset, 0) : damageStart);
+		if (damageEnd == damageStart - 1) return oldTree;
 		
-		StringBuilder partialInput = new StringBuilder(input.length());
-		buildPartialInput(input, partialInput, damageStart, damageEnd, damageEndOffset, oldTree, 0);
-		System.out.println(partialInput);
+		sanityCheckOldTree(oldTree, damageStart, damageEnd);
 		
-		IAstNode partialTree = (IAstNode) parser.parse(partialInput.toString(), startSymbol);
-		// TODO: some sanity check
+		String partialInput = buildPartialInput(input, damageStart, afterDamageOffset, damageEnd, oldTree);
+		
+		IAstNode partialTree = (IAstNode) parser.parse(partialInput, startSymbol);
+		
+		List<IAstNode> repairedTreeNodes =
+			getDamageTreeNodes(partialTree, damageStart, damageEnd, new ArrayList<IAstNode>());
+		if (DEBUG) System.out.println("\nRepaired: " + repairedTreeNodes);
+		sanityCheckRepairedTree(repairedTreeNodes);
+
+		Tokenizer tokenizer = new Tokenizer(parser.getParseTable().getKeywordRecognizer(), filename, oldInput);
+		return buildOutput(oldTree, repairedTreeNodes, damageStart, damageEnd, tokenizer);
+	}
+	
+	private void sanityCheckOldTree(IAstNode oldTree, int damageStart, int damageEnd)
+			throws IncrementalSGLRException {
+		
+		List<IAstNode> damagedNodes =
+			getDamageTreeNodes(oldTree, damageStart, damageEnd, new ArrayList<IAstNode>());
+		for (IAstNode node : damagedNodes) {
+			if (!incrementalSorts.contains(node.getSort()))
+				throw new IncrementalSGLRException("Unsafe change to tree node of type "
+						+ node.getSort() + " at line " + node.getLeftToken().getLine());
+		}
+	}
+
+	private void sanityCheckRepairedTree(List<IAstNode> repairedTreeNodes)
+			throws IncrementalSGLRException {
+		
+		for (IAstNode node : repairedTreeNodes) {
+			if (!incrementalSorts.contains(node.getSort()))
+				throw new IncrementalSGLRException("Unsafe tree parsed at "
+						+ node.getSort()  + " at line " + node.getLeftToken().getLine());
+		}
+	}
+
+	private String buildPartialInput(String input, int damageStart,
+			int afterDamageOffset, int damageEnd, TNode oldTree)
+			throws IncrementalSGLRException {
 		
-		return buildOutputTree(partialTree, oldTree, damageStart, damageEnd);
+		StringBuilder result = new StringBuilder(input.length());
+		isDamageIncluded = false;
+		buildPartialInput(input, damageStart, damageEnd, afterDamageOffset, oldTree, 0, result);
+		return result.toString();
 	}
 
-	private int buildPartialInput(String input, StringBuilder partialInput, int damageStart, 
-			int damageEnd, int damageEndOffset, IAstNode oldTree, int offset) {
+	private int buildPartialInput(String input, int damageStart, int damageEnd, 
+			int afterDamageOffset, IAstNode oldTree, int offset, StringBuilder result)
+			throws IncrementalSGLRException {
 		
 		IToken left = oldTree.getLeftToken();
 		IToken right = oldTree.getRightToken();
 		int startOffset = 0;
 		int endOffset = 0;
 		
+		// Print incrementalSorts nodes
 		if (left != null && right != null) {
 			startOffset = left.getStartOffset();
 			endOffset = right.getEndOffset();
-			if (incrementalSorts.contains(oldTree.getSort())
-					&& !isRangeOverlap(damageStart, damageEnd, startOffset, endOffset)) {
-				for (int i = offset; i < endOffset; i++) {
-					partialInput.append(input.charAt(i) == '\n' ? '\n' : ' ');
+			if (!oldTree.isList() && incrementalSorts.contains(oldTree.getSort())) {
+				if (isRangeOverlap(damageStart, damageEnd, startOffset, endOffset)) {
+					if (!isDamageIncluded) {
+						isDamageIncluded = true;
+						// append(input, offset, offset + afterDamageOffset + 1, result);
+						append(input, offset, damageStart, result);
+						if (DEBUG) System.out.print('|');
+						append(input, damageStart, damageEnd + 1, result);
+						// if (DEBUG) System.out.print('|');
+						// append(input, damageEnd + 1, offset + afterDamageOffset + 1, result);
+						// so maybe: offset + afterDamageOffset + 1 - (offset + afterDamageOffset - damageEnd)
+						//         = damageEnd + 1
+						if (DEBUG) System.out.print('|');
+						// append(input, offset + afterDamageOffset + 1, endOffset + afterDamageOffset + 1, result);
+						append(input, damageEnd + 1, endOffset + afterDamageOffset + 1, result);
+						if (DEBUG) System.out.print('|');
+					}
+					// possible: appendWhitespace(input, startOffset, endOffset, result);
+				} else {
+					appendWhitespace(input, offset, endOffset, result);
 				}
-				return endOffset;
+				return endOffset + 1;
 			}
 		}
-		for (int i = 0, max = oldTree.getChildCount(); i < max; i++) {
+		
+		// Recurse
+		if (oldTree.isList() && oldTree instanceof Iterable) { // likely a linked list
+			for (Object o : (Iterable<?>) oldTree) {
+				IAstNode child = (IAstNode) o;
+				offset = buildPartialInput(input, damageStart, damageEnd, afterDamageOffset, child, offset, result);
+			}
+		} else {
+			for (int i = 0, count = oldTree.getChildCount(); i < count; i++) {
+				IAstNode child = oldTree.getChildAt(i);
+				offset = buildPartialInput(input, damageStart, damageEnd, afterDamageOffset, child, offset, result);
+			}
+		}
+		
+		/*
+		for (int i = 0, count = oldTree.getChildCount(); i < count; i++) {
 			IAstNode child = oldTree.getChildAt(i);
-			offset = buildPartialInput(input, partialInput, damageStart, damageEnd, damageEndOffset, child, offset);
+			IToken childLeft = child.getLeftToken();
+			IToken childRight = child.getRightToken();
+			if (childLeft != null && childRight != null) {
+				
+				startOffset = childRight.getEndOffset() + 1;
+			}
 		}
+		*/
 
+		// Print original text
 		if (left != null && right != null) {
-			int extraOffset = offset >= damageStart ? damageEndOffset : 0;
-			partialInput.append(input, offset + extraOffset, endOffset + extraOffset); 
-			return endOffset;
+			return appendPartialInput(input, damageStart, damageEnd, afterDamageOffset, oldTree, offset, endOffset, result);
 		} else {
 			return offset;
 		}
 	}
 
+	private void appendWhitespace(String input, int offset, int endOffset, StringBuilder result) {
+		for (int i = offset; i <= endOffset; i++) {
+			// if (DEBUG) System.out.print(input.charAt(i) == '\n' ? "\n" : "-" + input.charAt(i));
+			result.append(input.charAt(i) == '\n' ? '\n' : ' ');
+		}
+	}
+
+	private int appendPartialInput(String input, int damageStart, int damageEnd,
+			int afterDamageOffset, IAstNode oldTree, int offset, int endOffset, StringBuilder result) {
+		if (offset >= damageStart) {
+			if (!isDamageIncluded) {
+				append(input, damageStart, damageEnd + 1, result);
+				isDamageIncluded = true;
+			}
+			append(input, offset + afterDamageOffset, endOffset + afterDamageOffset + 1, result);
+		} else {
+			append(input, offset, min(endOffset + 1, damageStart), result);
+		}
+		return endOffset + 1;
+	}
+	
+	private static void append(String input, int offset, int endOffset, StringBuilder result) {
+		if (DEBUG) System.out.print(input.substring(offset, endOffset));
+		result.append(input, offset, endOffset);
+ 	}
+
 	private static boolean isRangeOverlap(int start1, int end1, int start2, int end2) {
-		return ((start2 >= start1 && start2 <= end1)
-				|| (end2 >= start1 && end2 <= end1));
+		return start1 <= end2 && start2 <= end1;
 	}
 
 
@@ -97,16 +223,128 @@
 		return input.length() - 1;
 	}
 
-	private int getDamageEnd(String input, String oldInput, int offset) {
-		int boundOffset = max(offset, 0);
-		for (int i = input.length() - 1; i + boundOffset >= 0; i--) {
-			if (input.charAt(i) != oldInput.charAt(i + offset)) return i;
+	private int getDamageEnd(String input, String oldInput, int offset, int damageStart) {
+		for (int i = input.length() - 1; i > damageStart + offset; i--) {
+			if (input.charAt(i) != oldInput.charAt(i - offset)) return i;
 		}
-		return 0;
+		return damageStart - 1;
 	}
 	
-	private IAstNode buildOutputTree(IAstNode partialTree, TNode oldTree, int damageStart, int damageEnd) {
-		// TODO
-		throw new NotImplementedException();
+	/**
+	 * Gets all non-list tree nodes that are in the damaged region
+	 * according to {@link #isDamageTreeNode}.
+	 */
+	private List<IAstNode> getDamageTreeNodes(IAstNode tree, int damageStart, int damageEnd,
+			List<IAstNode> results) {
+		
+		if (tree.isList()) { // ignored for getDamageTreeNodes
+			getDamageTreeNodesRecurse(tree, damageStart, damageEnd, results);
+		} else {
+			if (isDamageTreeNode(tree, damageStart, damageEnd)) {
+				results.add(tree);
+			} else {
+				getDamageTreeNodesRecurse(tree, damageStart, damageEnd, results);
+			}
+		}
+		return results;
+	}
+
+	private void getDamageTreeNodesRecurse(IAstNode tree, int damageStart, int damageEnd,
+			List<IAstNode> results) {
+		
+		if (tree instanceof Iterable) { // likely a linked list
+			for (Object o : (Iterable<?>) tree) {
+				getDamageTreeNodes((IAstNode) o, damageStart, damageEnd, results);
+			}
+		} else {
+			for (int i = 0, count = tree.getChildCount(); i < count; i++) {
+				getDamageTreeNodes(tree.getChildAt(i), damageStart, damageEnd, results);
+			}
+		}
+	}
+
+	/**
+	 * Determines if the damaged region affects a particular tree node,
+	 * looking only at those tokens that actually belong to the node
+	 * and not to its children. Also returns true for nodes with a sort 
+	 * in {@link #incrementalSorts} regardless of whether they own the tokens
+	 * or not.
+	 */
+	private boolean isDamageTreeNode(IAstNode tree, int damageStart, int damageEnd) {
+		IToken left = tree.getLeftToken();
+		IToken right = tree.getRightToken();
+		if (left != null && right != null) {
+			int startOffset = left.getStartOffset();
+			int endOffset = right.getEndOffset();
+			
+			if (!isRangeOverlap(damageStart, damageEnd, startOffset, endOffset))
+				return false;
+			if (incrementalSorts.contains(tree.getSort()))
+				return true;
+			for (int i = 0, count = tree.getChildCount(); i < count; i++) {
+				IAstNode child = tree.getChildAt(i);
+				IToken childLeft = child.getLeftToken();
+				IToken childRight = child.getRightToken();
+				if (childLeft != null && childRight != null) {
+					if (isRangeOverlap(damageStart, damageEnd, startOffset, childLeft.getStartOffset() - 1)) {
+						return true;
+					}
+					startOffset = childRight.getEndOffset() + 1;
+				}
+			}
+			return isRangeOverlap(damageStart, damageEnd, startOffset, endOffset);
+		} else {
+			return false;
+		}
+	}
+	
+	@SuppressWarnings("unchecked")
+	private IAstNode buildOutput(IAstNode oldTreeNode, List<IAstNode> repairedTreeNodes,
+			int damageStart, int damageEnd,Tokenizer tokenizer) {
+		// TODO: recreate tokens
+		IToken leftToken = null;
+		IToken rightToken = null;
+		List<IAstNode> children;
+		if (oldTreeNode.isList() && incrementalSorts.contains(oldTreeNode.getElementSort())) {
+			List<IAstNode> oldChildren = copyChildrenToList(oldTreeNode);
+			children = new ArrayList<IAstNode>(oldTreeNode.getChildCount() + repairedTreeNodes.size());
+			boolean addedNewChildren = false;
+			for (IAstNode oldChild : oldChildren) {
+				if (!addedNewChildren && oldChild.getRightToken().getEndOffset() >= damageStart) {
+					addedNewChildren = true;
+					insertDamagedNodes(oldTreeNode, repairedTreeNodes, damageStart, damageEnd, tokenizer, children);
+				}
+				children.add(oldChild);
+			}
+			if (!addedNewChildren && oldTreeNode.getRightToken().getEndOffset() + NEXT_CHAR >= damageStart)
+				insertDamagedNodes(oldTreeNode, repairedTreeNodes, damageStart, damageEnd, tokenizer, children);
+		} else {
+			children = copyChildrenToList(oldTreeNode);
+			for (int i = 0; i < children.size(); i++) {
+				children.set(i, buildOutput(children.get(i), repairedTreeNodes, damageStart, damageEnd, tokenizer));
+			}
+		}
+		return factory.recreateNode((TNode) oldTreeNode, leftToken, rightToken, (List<TNode>) children);
+	}
+
+	private void insertDamagedNodes(IAstNode oldTreeNode, List<IAstNode> repairedTreeNodes,
+			int damageStart, int damageEnd, Tokenizer tokenizer, List<IAstNode> children) {
+		
+		// TODO: recreate tokens
+		children.addAll(repairedTreeNodes);
+	}
+
+	private static List<IAstNode> copyChildrenToList(IAstNode node) {
+		List<IAstNode> results = new ArrayList<IAstNode>(node.getChildCount());
+		if (node.isList() && node instanceof Iterable) { // likely a linked list
+			for (Object o : ((Iterable<?>) node)) {
+				results.add((IAstNode) o);
+			}
+		} else {
+			for (int i = 0, count = node.getChildCount(); i < count; i++) {
+				results.add(node.getChildAt(i));
+			}
+		}
+		return results;
 	}
 }

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IncrementalSGLRException.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IncrementalSGLRException.java	Thu Dec 16 15:04:46 2010	(r21542)
@@ -0,0 +1,31 @@
+package org.spoofax.jsglr.client;
+
+/**
+ * An exception thrown if some input cannot be incrementally parsed.
+ * Likely, it can be parsed non-incrementally instead.
+ * 
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class IncrementalSGLRException extends Exception {
+
+	private static final long serialVersionUID = 3965028076577690983L;
+
+	private static final String DEFAULT_MESSAGE = "Incremental parsing failed";
+	
+	public IncrementalSGLRException() {
+		super(DEFAULT_MESSAGE);
+	}
+
+	public IncrementalSGLRException(String message) {
+		super(message);
+	}
+
+	public IncrementalSGLRException(Throwable cause) {
+		super(DEFAULT_MESSAGE, cause);
+	}
+
+	public IncrementalSGLRException(String message, Throwable cause) {
+		super(message, cause);
+	}
+
+}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java	Thu Dec 16 15:04:39 2010	(r21541)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTable.java	Thu Dec 16 15:04:46 2010	(r21542)
@@ -198,7 +198,7 @@
 
         while (!labelsTerm.isEmpty()) {
             
-        	final ATermAppl a = Term.applAt(labelsTerm, 0);
+        	final ATermAppl a = (ATermAppl) labelsTerm.getFirst();
             final ATermAppl prod = Term.applAt(a, 0);
             final int labelNumber = Term.intAt(a, 1);
             final boolean injection = isInjection(prod);
@@ -239,10 +239,10 @@
         if(ls.getChildCount() < 1)
         	return false;
         
-        if(ls.getChildAt(0).getType() != ATerm.APPL)
+        if(ls.getFirst().getType() != ATerm.APPL)
         	return false;
         
-        final AFun fun = ((ATermAppl)ls.getChildAt(0)).getAFun();
+        final AFun fun = ((ATermAppl)ls.getFirst()).getAFun();
         return !(fun.getName().equals("lit") && fun.getArity() == 1);
     }
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ATermTreeFactory.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ATermTreeFactory.java	Thu Dec 16 15:04:39 2010	(r21541)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ATermTreeFactory.java	Thu Dec 16 15:04:46 2010	(r21542)
@@ -1,8 +1,15 @@
 package org.spoofax.jsglr.client.imploder;
 
+import static org.spoofax.jsglr.shared.terms.ATerm.APPL;
+import static org.spoofax.jsglr.shared.terms.ATerm.INT;
+import static org.spoofax.jsglr.shared.terms.ATerm.LIST;
+import static org.spoofax.jsglr.shared.terms.ATerm.STRING;
+import static org.spoofax.jsglr.shared.terms.ATerm.TUPLE;
+
 import java.util.ArrayList;
 import java.util.List;
 
+import org.spoofax.jsglr.client.NotImplementedException;
 import org.spoofax.jsglr.shared.terms.AFun;
 import org.spoofax.jsglr.shared.terms.ATerm;
 import org.spoofax.jsglr.shared.terms.ATermAppl;
@@ -87,6 +94,22 @@
 		result.internalSetSort(elementSort);
 		return result;
 	}
+	
+	public ATerm recreateNode(ATerm oldNode, IToken leftToken, IToken rightToken, List<ATerm> children) {
+		switch (oldNode.getType()) {
+			case INT:
+				return createIntTerminal(null, leftToken, ((ATermInt) oldNode).getInt());
+			case APPL:
+				return createNonTerminal(null, ((ATermAppl) oldNode).getName(), leftToken, rightToken, children);
+			case LIST:
+				return createList(null, leftToken, rightToken, children);
+			case STRING:
+				return createStringTerminal(null, ((ATermString) oldNode).getString(), leftToken);
+			case TUPLE:
+			default:
+				throw new NotImplementedException("Recreating term of type " + oldNode.getType() + ": " + oldNode); 
+		}
+	}
 
 	public boolean isStringTerminal(ATerm node) {
 		return node.getType() == ATerm.STRING;

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/IAstNode.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/IAstNode.java	Thu Dec 16 15:04:39 2010	(r21541)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/IAstNode.java	Thu Dec 16 15:04:46 2010	(r21542)
@@ -14,4 +14,14 @@
 	IAstNode getChildAt(int i);
 	
 	String getSort();
-}
+
+	/**
+	 * The element sort for lists and tuples.
+	 * 
+	 * @throws UnsupportedOperationException
+	 *             If the node is not a list or tuple.
+	 */
+	String getElementSort();
+	
+	boolean isList();
+}
\ No newline at end of file

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITreeFactory.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITreeFactory.java	Thu Dec 16 15:04:39 2010	(r21541)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITreeFactory.java	Thu Dec 16 15:04:46 2010	(r21542)
@@ -38,6 +38,12 @@
 	public TNode createList(String elementSort, IToken leftToken, IToken rightToken, List<TNode> children);
 
 	public TNode createAmb(List<TNode> alternatives);
+	
+	/**
+	 * Creates a new node similar to an existing node,
+	 * used for incremental tree construction.
+	 */
+	public TNode recreateNode(TNode oldNode, IToken leftToken, IToken rightToken, List<TNode> children);
 
 	/**
 	 * Create an injection node.

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/BadTokenException.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/BadTokenException.java	Thu Dec 16 15:04:39 2010	(r21541)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/BadTokenException.java	Thu Dec 16 15:04:46 2010	(r21542)
@@ -50,7 +50,9 @@
     private String escape(int ch) {
     	switch(ch) {
     	case 0: return "\\0";
-    	default: return ""+ch;
+    	case '\n': return "\\n";
+    	case '\r': return "\\r";
+    	default: return ""+ (char) ch;
     	}
 	}
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java	Thu Dec 16 15:04:39 2010	(r21541)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java	Thu Dec 16 15:04:46 2010	(r21542)
@@ -18,6 +18,7 @@
 	public static final int STRING = 4;
 	public static final int TUPLE = 5;
 	public static final int PLACEHOLDER = 6;
+	private static final int DEFAULT_PRINT_DEPTH = Integer.MAX_VALUE;
 
 	protected ATermFactory factory;
 	
@@ -42,6 +43,7 @@
 		this.rightToken = rightToken;
 		assert getChildCount() == 0
 			|| getChildAt(getChildCount() - 1).getRightToken() == null
+			|| rightToken == null
 			|| rightToken.getEndOffset() >= getChildAt(getChildCount() - 1).getRightToken().getEndOffset(); 
 	}
 	
@@ -60,6 +62,14 @@
 	public String getSort() {
 		return sort;
 	}
+	
+	public String getElementSort() {
+		throw new UnsupportedOperationException();
+	}
+	
+	public boolean isList() {
+		return false;
+	}
 
 	public ATermFactory getFactory() {
 		return factory;
@@ -89,7 +99,7 @@
 	@Override
 	public final String toString() {
 		StringBuilder sb = new StringBuilder();
-		toString(8, sb);
+		toString(DEFAULT_PRINT_DEPTH, sb);
 		return sb.toString();
 	}
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java	Thu Dec 16 15:04:39 2010	(r21541)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java	Thu Dec 16 15:04:46 2010	(r21542)
@@ -28,6 +28,7 @@
 		return super.getSort() + "*";
 	}
 	
+	@Override
 	public String getElementSort() {
 		return super.getSort();
 	}
@@ -43,6 +44,11 @@
 	public ATermList getNext() {
 		return next;
 	}
+	
+	@Override
+	public boolean isList() {
+		return true;
+	}
 
 	@Override
 	public ATerm getChildAt(int index) {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermTuple.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermTuple.java	Thu Dec 16 15:04:39 2010	(r21541)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermTuple.java	Thu Dec 16 15:04:46 2010	(r21542)
@@ -28,6 +28,16 @@
 	public int getType() {
 		return ATerm.TUPLE;
 	}
+	
+	@Override
+	public String getSort() {
+		return super.getSort() + "*";
+	}
+	
+	@Override
+	public String getElementSort() {
+		return super.getSort();
+	}
 
 	@Override
 	public boolean simpleMatch(ATerm t) {

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java	Thu Dec 16 15:04:46 2010	(r21542)
@@ -0,0 +1,51 @@
+package org.spoofax.jsglr.tests;
+
+import java.util.HashSet;
+import java.util.Set;
+
+import org.spoofax.jsglr.client.IncrementalSGLR;
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParserException;
+import org.spoofax.jsglr.client.imploder.TreeBuilder;
+import org.spoofax.jsglr.shared.terms.ATerm;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class TestIncrementalSGLR extends ParseTestCase {
+
+    @Override
+	public void gwtSetUp() throws ParserException, InvalidParseTableException {
+        super.gwtSetUp("Java-15", "java");
+        sglr.setTreeBuilder(new TreeBuilder());
+    }
+
+    public void testJava5() throws Exception {
+    	ATerm tree1 = doParseTest("java5");
+    	TreeBuilder builder = (TreeBuilder) sglr.getTreeBuilder();
+    	Set<String> sorts = new HashSet<String>();
+    	sorts.add("MethodDec");
+    	sorts.add("ClassBodyDec");
+    	IncrementalSGLR<ATerm> parser = new IncrementalSGLR<ATerm>(sglr, builder, builder.getFactory(), sorts);
+    	ATerm tree2 = (ATerm) parser.parseIncremental(loadAsString("java5-increment"), null, null, tree1);
+    	ATerm tree3 = (ATerm) sglr.parse(loadAsString("java5-increment"));
+    	System.out.println(tree2);
+    	System.out.println(tree3);
+    	assertEquals(tree3.toString(), tree2.toString());
+    }
+
+    public void testJava4() throws Exception {
+    	ATerm tree1 = doParseTest("java4");
+    	TreeBuilder builder = (TreeBuilder) sglr.getTreeBuilder();
+    	Set<String> sorts = new HashSet<String>();
+    	sorts.add("MethodDec");
+    	sorts.add("ClassBodyDec");
+    	IncrementalSGLR<ATerm> parser = new IncrementalSGLR<ATerm>(sglr, builder, builder.getFactory(), sorts);
+    	ATerm tree2 = (ATerm) parser.parseIncremental(loadAsString("java4-increment"), null, null, tree1);
+    	ATerm tree3 = (ATerm) sglr.parse(loadAsString("java4-increment"));
+    	System.out.println(tree2);
+    	System.out.println(tree3);
+    	assertEquals(tree3.toString(), tree2.toString());
+    }
+
+}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5-increment.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5-increment.java	Thu Dec 16 15:04:39 2010	(r21541)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5-increment.java	Thu Dec 16 15:04:46 2010	(r21542)
@@ -2,5 +2,7 @@
 
 class X {
   ;
-  void foo() {}void bar() {}
+  void foo() {}
+  void bar() {}
+  void baz() {}
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5.java	Thu Dec 16 15:04:39 2010	(r21541)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5.java	Thu Dec 16 15:04:46 2010	(r21542)
@@ -3,4 +3,5 @@
 class X {
   ;
   void foo() {}
+  void baz() {}
 }

From karltk at strategoxt.org  Thu Dec 16 16:04:51 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:04:51 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21543 -
	spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client
Message-ID: <201012161504.oBGF4pmd027415@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:04:51 2010
New Revision: 21543
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21543&sc=1

Log:
Don't reallocate ParseNodes and ParseNode arrays all the time in the Disambiguator.

Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java	Thu Dec 16 15:04:46 2010	(r21542)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java	Thu Dec 16 15:04:51 2010	(r21543)
@@ -373,7 +373,8 @@
 				}
 			}
 
-			t = new ParseNode(node.label, newArgs);
+			if (newArgs != null)
+				t = new ParseNode(node.label, newArgs);
 		} else if(t instanceof ParseProductionNode) {
 			// leaf node -- do thing (cannot be any ambiguities here)
 			return t;
@@ -388,21 +389,31 @@
 		}
 	}
 
+	/**
+	 * Filters child parse nodes.
+	 * 
+	 * @return An array of filtered child nodes, or null if no changes were made.
+	 */
 	private AbstractParseNode[] filterTree(AbstractParseNode[] args, boolean inAmbiguityCluster) throws FilterException {
 
 		if(SGLR.isDebugging()) {
 			Tools.debug("filterTree(<nodes>) - ", args);
 		}
 
-		final AbstractParseNode[] newArgs = new AbstractParseNode[args.length];
-		// boolean changed = false;
+		AbstractParseNode[] newArgs = null;
 
 		for (int i = 0, max = args.length; i < max; i++) {
 			final AbstractParseNode n = args[i];
 			final AbstractParseNode filtered = filterTree(n, false);
 
-			// changed = !filtered.equals(n) || changed;
-			newArgs[i] = filtered;
+			if (newArgs == null) {
+				if (filtered != n) {
+					newArgs = cloneArrayUpToIndex(args, i);
+					newArgs[i] = filtered;
+				}
+			} else {
+				newArgs[i] = filtered;
+			}
 		}
 
 		// FIXME Shouldn't we do some filtering here?
@@ -412,14 +423,30 @@
 		// }
 
 		if (filterAny) {
-			final AbstractParseNode[] filtered = new AbstractParseNode[newArgs.length];
-			for (int i = 0, max = newArgs.length; i < max; i++) {
-				filtered[i] = applyAssociativityPriorityFilter(newArgs[i]);
+			if (newArgs != null) args = newArgs;
+			newArgs = null;
+			for (int i = 0, max = args.length; i < max; i++) {
+				AbstractParseNode n = args[i];
+				AbstractParseNode filtered = applyAssociativityPriorityFilter(n);
+
+				if (newArgs == null) {
+					if (filtered != n) {
+						newArgs = cloneArrayUpToIndex(args, i);
+						newArgs[i] = filtered;
+					}
+				} else {
+					newArgs[i] = filtered;
+				}
 			}
-			return filtered;
-		} else {
-			return newArgs;
 		}
+		return newArgs;
+	}
+
+	private static AbstractParseNode[] cloneArrayUpToIndex(AbstractParseNode[] args, int index) {
+		AbstractParseNode[] newArgs;
+		newArgs = new AbstractParseNode[args.length];
+		System.arraycopy(args, 0, newArgs, 0, index);
+		return newArgs;
 	}
 
 	private AbstractParseNode applyAssociativityPriorityFilter(AbstractParseNode t) throws FilterException {

From karltk at strategoxt.org  Thu Dec 16 16:04:56 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:04:56 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21544 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt: src/org/spoofax/jsglr/client
	src/org/spoofax/jsglr/shared/terms test/org/spoofax/jsglr/tests
Message-ID: <201012161504.oBGF4use027418@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:04:56 2010
New Revision: 21544
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21544&sc=1

Log:
Changed the BottomupTreeBuilder interface a bit and fixed a class cast exception.

Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Asfix2TreeBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/BottomupTreeBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermAppl.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermInt.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermString.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermTuple.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java	Thu Dec 16 15:04:51 2010	(r21543)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java	Thu Dec 16 15:04:56 2010	(r21544)
@@ -33,7 +33,7 @@
 	public Object toTreeBottomup(BottomupTreeBuilder builder) {
     	ArrayList<Object> collect = new ArrayList<Object>();
     	addToTree(builder, collect);
-    	return builder.buildAmb(collect.toArray(new Object[collect.size()]));
+    	return builder.buildAmb(collect);
     }
     
     @Override

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Asfix2TreeBuilder.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Asfix2TreeBuilder.java	Thu Dec 16 15:04:51 2010	(r21543)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Asfix2TreeBuilder.java	Thu Dec 16 15:04:56 2010	(r21544)
@@ -1,5 +1,7 @@
 package org.spoofax.jsglr.client;
 
+import java.util.List;
+
 import org.spoofax.jsglr.client.imploder.ITokenizer;
 import org.spoofax.jsglr.shared.terms.AFun;
 import org.spoofax.jsglr.shared.terms.ATerm;
@@ -35,16 +37,16 @@
 		// Not used here
 	}
 
-	public ATerm buildNode(int labelNumber, Object[] subtrees) {
+	public ATerm buildNode(int labelNumber, List<Object> subtrees) {
 		ATermList ls = factory.makeList();
-		for(int i = subtrees.length - 1; i >= 0; i--) {
-			ls = ls.prepend((ATerm)subtrees[i]);
+		for(int i = subtrees.size() - 1; i >= 0; i--) {
+			ls = ls.prepend((ATerm)subtrees.get(i));
 		}
 		return factory.makeAppl(applAFun, labels[labelNumber - labelStart], ls);
 	}
 
-	public ATerm buildAmb(Object[] alternatives) {
-		return factory.makeAppl(ambAFun, (ATerm[])alternatives);
+	public ATerm buildAmb(List<Object> alternatives) {
+		return factory.makeAppl(ambAFun, alternatives.toArray(new ATerm[alternatives.size()]));
 	}
 
 	public ATerm buildProduction(int productionNumber) {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/BottomupTreeBuilder.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/BottomupTreeBuilder.java	Thu Dec 16 15:04:51 2010	(r21543)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/BottomupTreeBuilder.java	Thu Dec 16 15:04:56 2010	(r21544)
@@ -1,5 +1,7 @@
 package org.spoofax.jsglr.client;
 
+import java.util.List;
+
 
 /**
  * An abstract bottom-up tree builder implementation.
@@ -28,8 +30,8 @@
 		return subtree;
 	}
 
-	public abstract Object buildNode(int labelNumber, Object[] subtrees);
+	public abstract Object buildNode(int labelNumber, List<Object> subtrees);
 	public abstract Object buildProduction(int productionNumber);
-	public abstract Object buildAmb(Object[] alternatives);
+	public abstract Object buildAmb(List<Object> alternatives);
 
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java	Thu Dec 16 15:04:51 2010	(r21543)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java	Thu Dec 16 15:04:56 2010	(r21544)
@@ -7,6 +7,7 @@
  */
 package org.spoofax.jsglr.client;
 
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 
@@ -37,9 +38,9 @@
 	public Object toTreeBottomup(BottomupTreeBuilder builder) {
     	builder.visitLabel(label);
 
-        Object[] subtrees = new Object[kids.length];
+        ArrayList<Object> subtrees = new ArrayList<Object>(kids.length);
         for (int i = 0; i < kids.length; i++) {
-        	subtrees[i] = kids[i].toTreeBottomup(builder);
+        	subtrees.add(kids[i].toTreeBottomup(builder));
         }
 
         Object result = builder.buildNode(label, subtrees);

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java	Thu Dec 16 15:04:51 2010	(r21543)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java	Thu Dec 16 15:04:56 2010	(r21544)
@@ -98,10 +98,12 @@
 
 	@Override
 	public final String toString() {
-		StringBuilder sb = new StringBuilder();
-		toString(DEFAULT_PRINT_DEPTH, sb);
-		return sb.toString();
+		return toString(DEFAULT_PRINT_DEPTH);
+	}
+	
+	public final String toString(int depth) {
+		return toString(new StringBuilder(), depth).toString();
 	}
 
-	protected abstract void toString(int depth, StringBuilder sb);
+	protected abstract StringBuilder toString(StringBuilder sb, int depth);
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermAppl.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermAppl.java	Thu Dec 16 15:04:51 2010	(r21543)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermAppl.java	Thu Dec 16 15:04:56 2010	(r21544)
@@ -50,7 +50,7 @@
 	}
 
 	@Override
-	protected void toString(int depth, StringBuilder sb) {
+	protected StringBuilder toString(StringBuilder sb, int depth) {
 		if(depth == 0) {
 			sb.append("...");
 		} else {
@@ -59,10 +59,11 @@
 			for(int i = 0; i < kids.length; i++) {
 				if(i > 0)
 					sb.append(",");
-				kids[i].toString(depth - 1, sb);
+				kids[i].toString(sb, depth - 1);
 			}
 			sb.append(')');
 		}
+		return sb;
 	}
 
 	@Override

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermInt.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermInt.java	Thu Dec 16 15:04:51 2010	(r21543)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermInt.java	Thu Dec 16 15:04:56 2010	(r21544)
@@ -35,13 +35,14 @@
 	}
 
 	@Override
-	protected void toString(int depth, StringBuilder sb) {
+	protected StringBuilder toString(StringBuilder sb, int depth) {
 		if(depth == 0) {
 			sb.append("...");
 		}
 		else {
 			sb.append(Integer.toString(value));
 		}
+		return sb;
 	}
 
 	@Override

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java	Thu Dec 16 15:04:51 2010	(r21543)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java	Thu Dec 16 15:04:56 2010	(r21544)
@@ -102,14 +102,14 @@
 	}
 
 	@Override
-	protected void toString(int depth, StringBuilder sb) {
+	protected StringBuilder toString(StringBuilder sb, int depth) {
 		if(depth == 0) {
 			sb.append("...");
 		} else {
 			sb.append('[');
 			ATermList l = this;
 			while(l.element != null) {
-				l.element.toString(depth - 1, sb);
+				l.element.toString(sb, depth - 1);
 				l = l.next;
 				if(l.element != null) {
 					sb.append(",");
@@ -117,6 +117,7 @@
 			}
 			sb.append(']');
 		}
+		return sb;
 	}
 
 	@Override

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermString.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermString.java	Thu Dec 16 15:04:51 2010	(r21543)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermString.java	Thu Dec 16 15:04:56 2010	(r21544)
@@ -53,7 +53,7 @@
 	} 
 	
 	@Override
-	public void toString(int depth, StringBuilder sb) {
+	protected StringBuilder toString(StringBuilder sb, int depth) {
 		if(depth == 0) {
 			sb.append("...");
 		} else {
@@ -61,6 +61,7 @@
 			sb.append(value);
 			sb.append('\"');
 		}
+		return sb;
 	}
 
 	@Override

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermTuple.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermTuple.java	Thu Dec 16 15:04:51 2010	(r21543)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermTuple.java	Thu Dec 16 15:04:56 2010	(r21544)
@@ -53,7 +53,7 @@
 	}
 
 	@Override
-	protected void toString(int depth, StringBuilder sb) {
+	protected StringBuilder toString(StringBuilder sb, int depth) {
 		if(depth == 0) {
 			sb.append("...");
 		} else {
@@ -61,10 +61,11 @@
 			for(int i = 0; i < elements.length; i++) {
 				if(i > 0)
 					sb.append(",");
-				elements[i].toString(depth - 1, sb);
+				elements[i].toString(sb, depth - 1);
 			}
 			sb.append(')');
 		}
+		return sb;
 	}
 	
 	@Override

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:04:51 2010	(r21543)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:04:56 2010	(r21544)
@@ -110,7 +110,7 @@
 		} else {
 			if (parsed.getLeftToken() != null)
 				System.out.println(parsed.getLeftToken().getTokenizer());
-			System.out.println(parsed);
+			System.out.println(parsed.toString(8));
 		}
 
 		System.out.println(PathListPool.cacheMisses);
@@ -138,8 +138,8 @@
 		//			public void onSuccess(ATerm loaded) {
 		assertNotNull(x);
 
-		System.out.println(parsed);
-		System.out.println(wanted);
+		System.out.println(parsed.toString(8));
+		System.out.println(parsed.toString(8));
 		if(!parsed.simpleMatch(wanted)) {
 			fail();
 		}

From karltk at strategoxt.org  Thu Dec 16 16:05:01 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:05:01 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21545 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client:
	. imploder
Message-ID: <201012161505.oBGF51Eq027424@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:05:01 2010
New Revision: 21545
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21545&sc=1

Log:
Avoid recursion over large lists of parse production nodes in the Disambiguator and TreeBuilder.

Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/AbstractParseNode.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseProductionNode.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/AbstractParseNode.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/AbstractParseNode.java	Thu Dec 16 15:04:56 2010	(r21544)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/AbstractParseNode.java	Thu Dec 16 15:05:01 2010	(r21545)
@@ -26,4 +26,14 @@
     abstract public String toStringShallow();
     @Override
 	abstract public String toString();
+    
+    /**
+     * Returns true if this is either:
+     * - a {@link ParseProductionNode}.
+     * - a ParseNode with a {@link ParseProductionNode} child
+     *   and an {@link #isParseProductionChain()} child.
+     * - a ParseNode with a single {@link #isParseProductionChain()}
+     *   child.
+     */
+    public abstract boolean isParseProductionChain();
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java	Thu Dec 16 15:04:56 2010	(r21544)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java	Thu Dec 16 15:05:01 2010	(r21545)
@@ -28,6 +28,11 @@
 	public Amb(AbstractParseNode[] alternatives) {
 		this.alternatives = alternatives;
 	}
+	
+	@Override
+	public boolean isParseProductionChain() {
+		return false;
+	}
 
 	@Override
 	public Object toTreeBottomup(BottomupTreeBuilder builder) {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java	Thu Dec 16 15:04:56 2010	(r21544)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java	Thu Dec 16 15:05:01 2010	(r21545)
@@ -365,7 +365,9 @@
 		} else if(t instanceof ParseNode) {
 			final ParseNode node = (ParseNode) t;
 			final AbstractParseNode[] args = node.kids;
-			final AbstractParseNode[] newArgs = filterTree(args, false);
+			final AbstractParseNode[] newArgs =
+				t.isParseProductionChain() ? null : filterTree(args, false);
+			// TODO: assert that parse production chains do not have reject nodes?
 
 			if (filterReject && parseTable.hasRejects()) {
 				if (hasRejectProd(t) && !parser.useIntegratedRecovery) {
@@ -399,6 +401,8 @@
 		if(SGLR.isDebugging()) {
 			Tools.debug("filterTree(<nodes>) - ", args);
 		}
+		
+		// TODO: Optimize - combine these two loops
 
 		AbstractParseNode[] newArgs = null;
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java	Thu Dec 16 15:04:56 2010	(r21544)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java	Thu Dec 16 15:05:01 2010	(r21545)
@@ -21,15 +21,35 @@
     final int label;
 
     final AbstractParseNode[] kids;
+    
+    private final boolean isParseProductionChain;
 
     private int cachedHashCode;
 
     public ParseNode(int label, AbstractParseNode[] kids) {
         this.label = label;
         this.kids = kids;
+        switch (kids.length) {
+        	case 2:
+        		isParseProductionChain =
+        			kids[0] instanceof ParseProductionNode /*kids[0].isParseProductionChain()*/
+        			&& kids[1].isParseProductionChain();
+        		break;
+        	case 1:
+        		isParseProductionChain = kids[0].isParseProductionChain();
+        		break;
+        	default:
+        		isParseProductionChain = false;
+        }
+        // TODO: Optimize - create compact representation for parse production chains
     }
     
     @Override
+    public boolean isParseProductionChain() {
+		return isParseProductionChain;
+	}
+    
+    @Override
     public Object toTreeTopdown(TopdownTreeBuilder builder) {
     	return builder.buildTreeNode(this);
     }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseProductionNode.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseProductionNode.java	Thu Dec 16 15:04:56 2010	(r21544)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseProductionNode.java	Thu Dec 16 15:05:01 2010	(r21545)
@@ -17,6 +17,10 @@
     public ParseProductionNode(int prod) {
         this.prod = prod;
     }
+    
+    public boolean isParseProductionChain() {
+    	return true;
+    }
 
     @Override
 	public Object toTreeBottomup(BottomupTreeBuilder builder) {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java	Thu Dec 16 15:04:56 2010	(r21544)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java	Thu Dec 16 15:05:01 2010	(r21545)
@@ -152,9 +152,13 @@
 
 		// Recurse
 		for (AbstractParseNode subnode : subnodes) {
-			// TODO: Optimize stack - inline toTreeTopdown case selection?
-			Object child = subnode.toTreeTopdown(this);
-			if (child != null) children.add(isList ? child : tryBuildAutoConcatListNode(child));
+			if (inLexicalContext && subnode.isParseProductionChain()) {
+				chainToTreeTopdown(subnode);
+			} else {
+				// TODO: Optimize stack - inline toTreeTopdown case selection?
+				Object child = subnode.toTreeTopdown(this);
+				if (child != null) children.add(isList ? child : tryBuildAutoConcatListNode(child));
+			}
 		}
 		
 		if (lexicalStart) {
@@ -169,6 +173,26 @@
 		}
 	}
 
+	/**
+	 * Efficiently consume lexical chars in parse production chains.
+	 * @see AbstractParseNode#isParseProductionChain()
+	 */
+	private void chainToTreeTopdown(AbstractParseNode node) {
+		assert node.isParseProductionChain();
+		while (node instanceof ParseNode) {
+			AbstractParseNode[] kids = ((ParseNode) node).getChildren();
+			if (kids.length == 2) {
+				buildTreeProduction((ParseProductionNode) kids[0]);
+				node = kids[1];
+			} else if (kids.length == 1) {
+				node = kids[0];
+			} else {
+				throw new IllegalStateException("Unexpected node in parse production chain: " + node);
+			}
+		}
+		buildTreeProduction((ParseProductionNode) node);
+	}
+
 	@Override
 	public Object buildTreeAmb(Amb a) {
 		final int oldOffset = offset;
@@ -420,7 +444,7 @@
 		if (tokenizer.currentToken().getKind() != TK_ERROR_EOF_UNEXPECTED) {
 			if (tokenizer.getStartOffset() >= input.length())
 				tokenizer.setStartOffset(max(input.length() - 1, 0));
-			tokenizer.makeToken(input.length(), TK_ERROR_EOF_UNEXPECTED, true);
+			tokenizer.makeToken(input.length() - 1, TK_ERROR_EOF_UNEXPECTED, true);
 		}
 	}
 

From karltk at strategoxt.org  Thu Dec 16 16:05:06 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:05:06 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21546 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt: src/org/spoofax/jsglr/client
	src/org/spoofax/jsglr/client/incremental
	test/org/spoofax/jsglr/tests
Message-ID: <201012161505.oBGF56oF027427@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:05:06 2010
New Revision: 21546
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21546&sc=1

Log:
Refactoring the incremental parser implementation into separate classes.

Added:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalInputBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLRException.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java
Deleted:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IncrementalSGLRException.java
Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 15:05:01 2010	(r21545)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 15:05:06 2010	(r21546)
@@ -859,7 +859,7 @@
 		activeStacks.clear(true);
 	}
 
-	ParseTable getParseTable() {
+	public ParseTable getParseTable() {
 		return parseTable;
 	}
 

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalInputBuilder.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalInputBuilder.java	Thu Dec 16 15:05:06 2010	(r21546)
@@ -0,0 +1,131 @@
+package org.spoofax.jsglr.client.incremental;
+
+import static java.lang.Math.min;
+import static org.spoofax.jsglr.client.incremental.IncrementalSGLR.DEBUG;
+import static org.spoofax.jsglr.client.incremental.IncrementalSGLR.isRangeOverlap;
+
+import java.util.Set;
+
+import org.spoofax.jsglr.client.imploder.IAstNode;
+import org.spoofax.jsglr.client.imploder.IToken;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class IncrementalInputBuilder {
+	
+	private final StringBuilder result = new StringBuilder();
+	
+	private final Set<String> incrementalSorts;
+	
+	private final String input;
+	
+	private final int damageStart;
+	
+	private final int damageEnd;
+
+	private final int afterDamageOffset;
+	
+	private boolean isDamagePrinted;
+
+	/**
+	 * @param incrementalSorts
+	 *            Sorts that can be incrementally parsed (e.g., MethodDec, ImportDec).
+	 *            *Must* be sorts that only occur in lists (such as MethodDec*).
+	 */
+	public IncrementalInputBuilder(Set<String> incrementalSorts, String input,
+			int damageStart, int damageEnd, int afterDamageOffset) {
+		this.incrementalSorts = incrementalSorts;
+		this.input = input;
+		this.damageEnd = damageEnd;
+		this.damageStart = damageStart;
+		this.afterDamageOffset = afterDamageOffset;
+	}
+
+	public String buildPartialInput(IAstNode oldTree) throws IncrementalSGLRException {
+		buildPartialInput(oldTree, 0);
+		return result.toString();
+	}
+
+	private int buildPartialInput(IAstNode oldTree, int offset) throws IncrementalSGLRException {
+		IToken left = oldTree.getLeftToken();
+		IToken right = oldTree.getRightToken();
+		int startOffset = 0;
+		int endOffset = 0;
+		
+		// Print incrementalSorts nodes
+		if (left != null && right != null) {
+			startOffset = left.getStartOffset();
+			endOffset = right.getEndOffset();
+			if (!oldTree.isList() && incrementalSorts.contains(oldTree.getSort())) {
+				if (isRangeOverlap(damageStart, damageEnd, startOffset, endOffset)) {
+					if (!isDamagePrinted) {
+						isDamagePrinted = true;
+						// append(input, offset, offset + afterDamageOffset + 1);
+						if (DEBUG) System.out.print('|');
+						append(input, offset, damageStart);
+						if (DEBUG) System.out.print('|');
+						append(input, damageStart, damageEnd + 1);
+						// if (DEBUG) System.out.print('|');
+						// append(input, damageEnd + 1, offset + afterDamageOffset + 1);
+						// so maybe: offset + afterDamageOffset + 1 - (offset + afterDamageOffset - damageEnd)
+						//         = damageEnd + 1
+						if (DEBUG) System.out.print('|');
+						// append(input, offset + afterDamageOffset + 1, endOffset + afterDamageOffset + 1);
+						append(input, damageEnd + 1, endOffset + afterDamageOffset + 1);
+						if (DEBUG) System.out.print('|');
+					}
+					// possible: appendWhitespace(input, startOffset, endOffset);
+				} else {
+					appendWhitespace(input, offset, endOffset);
+				}
+				return endOffset + 1;
+			}
+		}
+		
+		// Recurse
+		if (oldTree.isList() && oldTree instanceof Iterable) { // likely a linked list
+			for (Object o : (Iterable<?>) oldTree) {
+				IAstNode child = (IAstNode) o;
+				offset = buildPartialInput(child, offset);
+			}
+		} else {
+			for (int i = 0, count = oldTree.getChildCount(); i < count; i++) {
+				IAstNode child = oldTree.getChildAt(i);
+				offset = buildPartialInput(child, offset);
+			}
+		}
+
+		// Print original text
+		if (left != null && right != null) {
+			return appendPartialInput(oldTree, offset, endOffset);
+		} else {
+			return offset;
+		}
+	}
+
+	private void appendWhitespace(String input, int offset, int endOffset) {
+		for (int i = offset; i <= endOffset; i++) {
+			// if (DEBUG) System.out.print(input.charAt(i) == '\n' ? "\n" : "-" + input.charAt(i));
+			result.append(input.charAt(i) == '\n' ? '\n' : ' ');
+		}
+	}
+
+	private int appendPartialInput(IAstNode oldTree, int offset, int endOffset) {
+		if (offset >= damageStart) {
+			if (!isDamagePrinted) {
+				append(input, damageStart, damageEnd + 1);
+				isDamagePrinted = true;
+			}
+			append(input, offset + afterDamageOffset, endOffset + afterDamageOffset + 1);
+		} else {
+			append(input, offset, min(endOffset + 1, damageStart));
+		}
+		return endOffset + 1;
+	}
+	
+	private void append(String input, int offset, int endOffset) {
+		if (DEBUG) System.out.print(input.substring(offset, endOffset));
+		result.append(input, offset, endOffset);
+ 	}
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java	Thu Dec 16 15:05:06 2010	(r21546)
@@ -0,0 +1,120 @@
+package org.spoofax.jsglr.client.incremental;
+
+import static java.lang.Math.max;
+
+import java.util.List;
+import java.util.Set;
+
+import org.spoofax.jsglr.client.ITreeBuilder;
+import org.spoofax.jsglr.client.ParseException;
+import org.spoofax.jsglr.client.SGLR;
+import org.spoofax.jsglr.client.imploder.IAstNode;
+import org.spoofax.jsglr.client.imploder.ITreeFactory;
+import org.spoofax.jsglr.client.imploder.TreeBuilder;
+import org.spoofax.jsglr.shared.BadTokenException;
+import org.spoofax.jsglr.shared.SGLRException;
+import org.spoofax.jsglr.shared.TokenExpectedException;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class IncrementalSGLR<TNode extends IAstNode> {
+	
+	private static final boolean ASSUME_MINIMAL_DIFF = true;
+	
+	static final boolean DEBUG = true;
+	
+	final SGLR parser;
+
+	final ITreeFactory<TNode> factory;
+	
+	final Set<String> incrementalSorts;
+
+	/**
+	 * @param incrementalSorts
+	 *            Sorts that can be incrementally parsed (e.g., MethodDec, ImportDec).
+	 *            *Must* be sorts that only occur in lists (such as MethodDec*).
+	 */
+	public IncrementalSGLR(SGLR parser, ITreeBuilder builder, ITreeFactory<TNode> factory, Set<String> incrementalSorts) {
+		this.parser = parser;
+		this.factory = factory;
+		this.incrementalSorts = incrementalSorts;
+		parser.setTreeBuilder(builder);
+		assert !(builder instanceof TreeBuilder)
+			|| ((TreeBuilder) builder).getFactory().getClass() == factory.getClass();
+		
+		// TODO: support injection sorts in incrementalSorts
+		//       (using injection prods in parse table; build some class like KeywordRecognizer)
+	}
+	
+	public IAstNode parseIncremental(String input, String filename, String startSymbol, TNode oldTree)
+			throws TokenExpectedException, BadTokenException, ParseException, SGLRException, IncrementalSGLRException {
+		
+		String oldInput = oldTree.getLeftToken().getTokenizer().getInput();
+		int damageStart = getDamageStart(input, oldInput);
+		int afterDamageOffset = input.length() - oldInput.length();
+		int damageEnd = getDamageEnd(input, oldInput, afterDamageOffset,
+				ASSUME_MINIMAL_DIFF ? max(afterDamageOffset, 0) : damageStart);
+		if (damageEnd == damageStart - 1) return oldTree;
+		
+		IncrementalInputBuilder inputBuilder =
+			new IncrementalInputBuilder(incrementalSorts, input, damageStart, damageEnd, afterDamageOffset);
+		
+		IncrementalTreeBuilder<TNode> treeBuilder =
+			new IncrementalTreeBuilder<TNode>(this, input, filename, damageStart, damageEnd);
+		
+		sanityCheckOldTree(treeBuilder, oldTree);
+
+		String partialInput = inputBuilder.buildPartialInput(oldTree);
+		
+		IAstNode partialTree = (IAstNode) parser.parse(partialInput, startSymbol);
+		
+		List<IAstNode> repairedTreeNodes = treeBuilder.getDamageTreeNodes(partialTree);
+		
+		sanityCheckRepairedTree(repairedTreeNodes);
+
+		return treeBuilder.buildOutput(oldTree, repairedTreeNodes);
+	}
+	
+	private void sanityCheckOldTree(IncrementalTreeBuilder<TNode> builder, IAstNode oldTree)
+			throws IncrementalSGLRException {
+		
+		List<IAstNode> damagedNodes = builder.getDamageTreeNodes(oldTree);
+		for (IAstNode node : damagedNodes) {
+			if (!incrementalSorts.contains(node.getSort()))
+				throw new IncrementalSGLRException("Unsafe change to tree node of type "
+						+ node.getSort() + " at line " + node.getLeftToken().getLine());
+		}
+	}
+
+	private void sanityCheckRepairedTree(List<IAstNode> repairedTreeNodes)
+			throws IncrementalSGLRException {
+		
+		if (DEBUG) System.out.println("\nRepaired: " + repairedTreeNodes);
+		
+		for (IAstNode node : repairedTreeNodes) {
+			if (!incrementalSorts.contains(node.getSort()))
+				throw new IncrementalSGLRException("Unsafe tree parsed at "
+						+ node.getSort()  + " at line " + node.getLeftToken().getLine());
+		}
+	}
+
+	protected static boolean isRangeOverlap(int start1, int end1, int start2, int end2) {
+		return start1 <= end2 && start2 <= end1;
+	}
+
+
+	private int getDamageStart(String input, String oldInput) {
+		for (int i = 0; i < input.length(); i++) {
+			if (input.charAt(i) != oldInput.charAt(i)) return i;
+		}
+		return input.length() - 1;
+	}
+
+	private int getDamageEnd(String input, String oldInput, int offset, int damageStart) {
+		for (int i = input.length() - 1; i > damageStart + offset; i--) {
+			if (input.charAt(i) != oldInput.charAt(i - offset)) return i;
+		}
+		return damageStart - 1;
+	}
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLRException.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLRException.java	Thu Dec 16 15:05:06 2010	(r21546)
@@ -0,0 +1,31 @@
+package org.spoofax.jsglr.client.incremental;
+
+/**
+ * An exception thrown if some input cannot be incrementally parsed.
+ * Likely, it can be parsed non-incrementally instead.
+ * 
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class IncrementalSGLRException extends Exception {
+
+	private static final long serialVersionUID = 3965028076577690983L;
+
+	private static final String DEFAULT_MESSAGE = "Incremental parsing failed";
+	
+	public IncrementalSGLRException() {
+		super(DEFAULT_MESSAGE);
+	}
+
+	public IncrementalSGLRException(String message) {
+		super(message);
+	}
+
+	public IncrementalSGLRException(Throwable cause) {
+		super(DEFAULT_MESSAGE, cause);
+	}
+
+	public IncrementalSGLRException(String message, Throwable cause) {
+		super(message, cause);
+	}
+
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java	Thu Dec 16 15:05:06 2010	(r21546)
@@ -0,0 +1,180 @@
+package org.spoofax.jsglr.client.incremental;
+
+import static org.spoofax.jsglr.client.incremental.IncrementalSGLR.isRangeOverlap;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+
+import org.spoofax.jsglr.client.SGLR;
+import org.spoofax.jsglr.client.imploder.IAstNode;
+import org.spoofax.jsglr.client.imploder.IToken;
+import org.spoofax.jsglr.client.imploder.ITreeFactory;
+import org.spoofax.jsglr.client.imploder.Tokenizer;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class IncrementalTreeBuilder<TNode extends IAstNode> {
+	
+	/**
+	 * Allows for one character of extra slack based on the assumption
+	 * that grammars will not have two consecutive IncrementalSort*
+	 * lists.
+	 */
+	private static final int NEXT_CHAR = 1;
+	
+	private final SGLR parser;
+
+	private final String input;
+
+	private final String filename;
+
+	private final ITreeFactory<TNode> factory;
+	
+	private final Set<String> incrementalSorts;
+
+	private final int damageStart;
+
+	private final int damageEnd;
+
+	/**
+	 * @param incrementalSorts
+	 *            Sorts that can be incrementally parsed (e.g., MethodDec, ImportDec).
+	 *            *Must* be sorts that only occur in lists (such as MethodDec*).
+	 */
+	public IncrementalTreeBuilder(IncrementalSGLR<TNode> parser, String input, String filename,
+			int damageStart, int damageEnd) {
+		this.parser = parser.parser;
+		this.input = input;
+		this.filename = filename;
+		this.factory = parser.factory;
+		this.incrementalSorts = parser.incrementalSorts;
+		this.damageStart = damageStart;
+		this.damageEnd = damageEnd;
+	}
+	
+	/**
+	 * Gets all non-list tree nodes that are in the damaged region
+	 * according to {@link #isDamageTreeNode}.
+	 */
+	public List<IAstNode> getDamageTreeNodes(IAstNode tree) {
+		return getDamageTreeNodes(tree, new ArrayList<IAstNode>());
+	}
+
+	private List<IAstNode> getDamageTreeNodes(IAstNode tree, List<IAstNode> results) {
+		if (tree.isList()) { // ignored for getDamageTreeNodes
+			getDamageTreeNodesRecurse(tree, results);
+		} else {
+			if (isDamageTreeNode(tree)) {
+				results.add(tree);
+			} else {
+				getDamageTreeNodesRecurse(tree, results);
+			}
+		}
+		return results;
+	}
+
+	private void getDamageTreeNodesRecurse(IAstNode tree, List<IAstNode> results) {
+		
+		if (tree instanceof Iterable) { // likely a linked list
+			for (Object o : (Iterable<?>) tree) {
+				getDamageTreeNodes((IAstNode) o, results);
+			}
+		} else {
+			for (int i = 0, count = tree.getChildCount(); i < count; i++) {
+				getDamageTreeNodes(tree.getChildAt(i), results);
+			}
+		}
+	}
+
+	/**
+	 * Determines if the damaged region affects a particular tree node,
+	 * looking only at those tokens that actually belong to the node
+	 * and not to its children. Also returns true for nodes with a sort 
+	 * in {@link #incrementalSorts} regardless of whether they own the tokens
+	 * or not.
+	 */
+	private boolean isDamageTreeNode(IAstNode tree) {
+		IToken left = tree.getLeftToken();
+		IToken right = tree.getRightToken();
+		if (left != null && right != null) {
+			int startOffset = left.getStartOffset();
+			int endOffset = right.getEndOffset();
+			
+			if (!isRangeOverlap(damageStart, damageEnd, startOffset, endOffset))
+				return false;
+			if (incrementalSorts.contains(tree.getSort()))
+				return true;
+			for (int i = 0, count = tree.getChildCount(); i < count; i++) {
+				IAstNode child = tree.getChildAt(i);
+				IToken childLeft = child.getLeftToken();
+				IToken childRight = child.getRightToken();
+				if (childLeft != null && childRight != null) {
+					if (isRangeOverlap(damageStart, damageEnd, startOffset, childLeft.getStartOffset() - 1)) {
+						return true;
+					}
+					startOffset = childRight.getEndOffset() + 1;
+				}
+			}
+			return isRangeOverlap(damageStart, damageEnd, startOffset, endOffset);
+		} else {
+			return false;
+		}
+	}
+	public TNode buildOutput(IAstNode oldTreeNode, List<IAstNode> repairedTreeNodes) {
+		Tokenizer tokenizer =
+			new Tokenizer(parser.getParseTable().getKeywordRecognizer(), filename, input);
+		return buildOutput(oldTreeNode, repairedTreeNodes, tokenizer);
+	}
+	
+	@SuppressWarnings("unchecked")
+	private TNode buildOutput(IAstNode oldTreeNode, List<IAstNode> repairedTreeNodes,
+			Tokenizer tokenizer) {
+		// TODO: recreate tokens
+		IToken leftToken = null;
+		IToken rightToken = null;
+		List<IAstNode> children;
+		if (oldTreeNode.isList() && incrementalSorts.contains(oldTreeNode.getElementSort())) {
+			List<IAstNode> oldChildren = copyChildrenToList(oldTreeNode);
+			children = new ArrayList<IAstNode>(oldTreeNode.getChildCount() + repairedTreeNodes.size());
+			boolean addedNewChildren = false;
+			for (IAstNode oldChild : oldChildren) {
+				if (!addedNewChildren && oldChild.getRightToken().getEndOffset() >= damageStart) {
+					addedNewChildren = true;
+					insertDamagedNodes(oldTreeNode, repairedTreeNodes, tokenizer, children);
+				}
+				children.add(oldChild);
+			}
+			if (!addedNewChildren && oldTreeNode.getRightToken().getEndOffset() + NEXT_CHAR >= damageStart)
+				insertDamagedNodes(oldTreeNode, repairedTreeNodes, tokenizer, children);
+		} else {
+			children = copyChildrenToList(oldTreeNode);
+			for (int i = 0; i < children.size(); i++) {
+				children.set(i, buildOutput(children.get(i), repairedTreeNodes, tokenizer));
+			}
+		}
+		return factory.recreateNode((TNode) oldTreeNode, leftToken, rightToken, (List<TNode>) children);
+	}
+
+	private void insertDamagedNodes(IAstNode oldTreeNode, List<IAstNode> repairedTreeNodes,
+			Tokenizer tokenizer, List<IAstNode> children) {
+		
+		// TODO: recreate tokens
+		children.addAll(repairedTreeNodes);
+	}
+
+	private static List<IAstNode> copyChildrenToList(IAstNode node) {
+		List<IAstNode> results = new ArrayList<IAstNode>(node.getChildCount());
+		if (node.isList() && node instanceof Iterable) { // likely a linked list
+			for (Object o : ((Iterable<?>) node)) {
+				results.add((IAstNode) o);
+			}
+		} else {
+			for (int i = 0, count = node.getChildCount(); i < count; i++) {
+				results.add(node.getChildAt(i));
+			}
+		}
+		return results;
+	}
+}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java	Thu Dec 16 15:05:01 2010	(r21545)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java	Thu Dec 16 15:05:06 2010	(r21546)
@@ -3,10 +3,10 @@
 import java.util.HashSet;
 import java.util.Set;
 
-import org.spoofax.jsglr.client.IncrementalSGLR;
 import org.spoofax.jsglr.client.InvalidParseTableException;
 import org.spoofax.jsglr.client.ParserException;
 import org.spoofax.jsglr.client.imploder.TreeBuilder;
+import org.spoofax.jsglr.client.incremental.IncrementalSGLR;
 import org.spoofax.jsglr.shared.terms.ATerm;
 
 /**

From karltk at strategoxt.org  Thu Dec 16 16:05:11 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:05:11 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21547 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt:
	src/org/spoofax/jsglr/client/incremental
	test/org/spoofax/jsglr/tests tests/data
Message-ID: <201012161505.oBGF5Bxe027430@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:05:11 2010
New Revision: 21547
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21547&sc=1

Log:


Added:
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5-increment2.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5-increment3.java
Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalInputBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalInputBuilder.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalInputBuilder.java	Thu Dec 16 15:05:06 2010	(r21546)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalInputBuilder.java	Thu Dec 16 15:05:11 2010	(r21547)
@@ -59,22 +59,7 @@
 			endOffset = right.getEndOffset();
 			if (!oldTree.isList() && incrementalSorts.contains(oldTree.getSort())) {
 				if (isRangeOverlap(damageStart, damageEnd, startOffset, endOffset)) {
-					if (!isDamagePrinted) {
-						isDamagePrinted = true;
-						// append(input, offset, offset + afterDamageOffset + 1);
-						if (DEBUG) System.out.print('|');
-						append(input, offset, damageStart);
-						if (DEBUG) System.out.print('|');
-						append(input, damageStart, damageEnd + 1);
-						// if (DEBUG) System.out.print('|');
-						// append(input, damageEnd + 1, offset + afterDamageOffset + 1);
-						// so maybe: offset + afterDamageOffset + 1 - (offset + afterDamageOffset - damageEnd)
-						//         = damageEnd + 1
-						if (DEBUG) System.out.print('|');
-						// append(input, offset + afterDamageOffset + 1, endOffset + afterDamageOffset + 1);
-						append(input, damageEnd + 1, endOffset + afterDamageOffset + 1);
-						if (DEBUG) System.out.print('|');
-					}
+					printDamagedNode(offset, endOffset);
 					// possible: appendWhitespace(input, startOffset, endOffset);
 				} else {
 					appendWhitespace(input, offset, endOffset);
@@ -83,7 +68,17 @@
 			}
 		}
 		
-		// Recurse
+		offset = buildPartialInputRecurse(oldTree, offset);
+
+		// Print original text
+		if (left != null && right != null) {
+			return appendPartialInput(oldTree, offset, endOffset);
+		} else {
+			return offset;
+		}
+	}
+
+	private int buildPartialInputRecurse(IAstNode oldTree, int offset) throws IncrementalSGLRException {
 		if (oldTree.isList() && oldTree instanceof Iterable) { // likely a linked list
 			for (Object o : (Iterable<?>) oldTree) {
 				IAstNode child = (IAstNode) o;
@@ -95,12 +90,20 @@
 				offset = buildPartialInput(child, offset);
 			}
 		}
+		return offset;
+	}
 
-		// Print original text
-		if (left != null && right != null) {
-			return appendPartialInput(oldTree, offset, endOffset);
-		} else {
-			return offset;
+	private void printDamagedNode(int offset, int endOffset) {
+		if (!isDamagePrinted) {
+			isDamagePrinted = true;
+			if (DEBUG) System.out.print('|');
+			append(input, offset, damageStart);
+			if (DEBUG) System.out.print('|');
+			append(input, damageStart, damageEnd + 1);
+			if (DEBUG) System.out.print('|');
+			// TODO: don't use endOffset here but use the last token's end offset
+			append(input, damageEnd + 1, endOffset + afterDamageOffset + 1);
+			if (DEBUG) System.out.print('|');
 		}
 	}
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:05:06 2010	(r21546)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:05:11 2010	(r21547)
@@ -7,16 +7,22 @@
  */
 package org.spoofax.jsglr.tests;
 
+import java.util.HashSet;
+import java.util.Set;
+
 import junit.framework.TestCase;
 
 import org.spoofax.jsglr.FileTools;
+import org.spoofax.jsglr.client.ITreeBuilder;
 import org.spoofax.jsglr.client.InvalidParseTableException;
 import org.spoofax.jsglr.client.ParseTable;
 import org.spoofax.jsglr.client.ParserException;
 import org.spoofax.jsglr.client.PathListPool;
 import org.spoofax.jsglr.client.PooledPathList;
 import org.spoofax.jsglr.client.SGLR;
+import org.spoofax.jsglr.client.imploder.ATermTreeFactory;
 import org.spoofax.jsglr.client.imploder.TreeBuilder;
+import org.spoofax.jsglr.client.incremental.IncrementalSGLR;
 import org.spoofax.jsglr.shared.SGLRException;
 import org.spoofax.jsglr.shared.Tools;
 import org.spoofax.jsglr.shared.terms.ATerm;
@@ -30,6 +36,8 @@
 	
 	protected ParseTable table;
 
+	private IncrementalSGLR<ATerm> incrementalSGLR;
+
 	// shared by all tests
 	static final ATermFactory pf = new ATermFactory();
 	//RemoteParseTableServiceAsync parseTableService = GWT.create(RemoteParseTableService.class);
@@ -40,8 +48,8 @@
 	}
 
 	protected abstract void gwtSetUp() throws Exception;
-
-	public void gwtSetUp(String grammar, String suffix) throws ParserException, InvalidParseTableException {
+	
+	public void gwtSetUp(String grammar, String suffix, String... incrementalSorts) throws ParserException, InvalidParseTableException {
 		this.suffix = suffix;
 		Tools.setDebug(false);
 		Tools.setLogging(false);
@@ -69,6 +77,15 @@
 		//					}
 		//				});
 
+		if (incrementalSorts.length > 0) {
+			ATermTreeFactory factory = new ATermTreeFactory(sglr.getFactory());
+			TreeBuilder builder = new TreeBuilder(factory);
+			sglr.setTreeBuilder(builder);
+			Set<String> sorts = new HashSet<String>();
+	    	for (String sort : incrementalSorts)
+	    		sorts.add(sort);
+	    	incrementalSGLR = new IncrementalSGLR<ATerm>(sglr, builder, factory, sorts);
+		}
 	}
 
 
@@ -118,6 +135,21 @@
 		System.out.println(PooledPathList.maxAllocated);
 		return parsed;
 	}
+	
+	public ATerm doParseIncrementalTest(ATerm oldTree, String newFile) throws Exception {
+		String contents = loadAsString(newFile);
+    	ATerm newTree = (ATerm) incrementalSGLR.parseIncremental(contents, newFile, null, oldTree);
+		String extension =
+			table.getTreeBuilder() instanceof TreeBuilder ? ".itrm" : ".trm";
+		final String x = FileTools.loadFileAsString("tests/data/" + newFile + extension);
+		final ATerm wanted = newTree.getFactory().parse(x);
+		System.out.println(newTree.toString(8));
+		System.out.println(wanted.toString(8));
+    	if (!newTree.simpleMatch(wanted)) {
+    		fail();
+    	}
+    	return newTree;
+	}
 
 	protected String loadAsString(final String testFile) {
 		return FileTools.loadFileAsString("tests/data/" + testFile + "." + suffix);
@@ -139,7 +171,7 @@
 		assertNotNull(x);
 
 		System.out.println(parsed.toString(8));
-		System.out.println(parsed.toString(8));
+		System.out.println(wanted.toString(8));
 		if(!parsed.simpleMatch(wanted)) {
 			fail();
 		}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java	Thu Dec 16 15:05:06 2010	(r21546)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java	Thu Dec 16 15:05:11 2010	(r21547)
@@ -1,12 +1,7 @@
 package org.spoofax.jsglr.tests;
 
-import java.util.HashSet;
-import java.util.Set;
-
 import org.spoofax.jsglr.client.InvalidParseTableException;
 import org.spoofax.jsglr.client.ParserException;
-import org.spoofax.jsglr.client.imploder.TreeBuilder;
-import org.spoofax.jsglr.client.incremental.IncrementalSGLR;
 import org.spoofax.jsglr.shared.terms.ATerm;
 
 /**
@@ -16,36 +11,20 @@
 
     @Override
 	public void gwtSetUp() throws ParserException, InvalidParseTableException {
-        super.gwtSetUp("Java-15", "java");
-        sglr.setTreeBuilder(new TreeBuilder());
+        super.gwtSetUp("Java-15", "java", "MethodDec", "ClassBodyDec");
     }
 
     public void testJava5() throws Exception {
     	ATerm tree1 = doParseTest("java5");
-    	TreeBuilder builder = (TreeBuilder) sglr.getTreeBuilder();
-    	Set<String> sorts = new HashSet<String>();
-    	sorts.add("MethodDec");
-    	sorts.add("ClassBodyDec");
-    	IncrementalSGLR<ATerm> parser = new IncrementalSGLR<ATerm>(sglr, builder, builder.getFactory(), sorts);
-    	ATerm tree2 = (ATerm) parser.parseIncremental(loadAsString("java5-increment"), null, null, tree1);
-    	ATerm tree3 = (ATerm) sglr.parse(loadAsString("java5-increment"));
-    	System.out.println(tree2);
-    	System.out.println(tree3);
-    	assertEquals(tree3.toString(), tree2.toString());
+    	doParseIncrementalTest(tree1, "java5-increment");
+    	// doParseIncrementalTest(tree1, "java5-increment2");
+    	// doParseIncrementalTest(tree1, "java5-increment3");
     }
 
     public void testJava4() throws Exception {
     	ATerm tree1 = doParseTest("java4");
-    	TreeBuilder builder = (TreeBuilder) sglr.getTreeBuilder();
-    	Set<String> sorts = new HashSet<String>();
-    	sorts.add("MethodDec");
-    	sorts.add("ClassBodyDec");
-    	IncrementalSGLR<ATerm> parser = new IncrementalSGLR<ATerm>(sglr, builder, builder.getFactory(), sorts);
-    	ATerm tree2 = (ATerm) parser.parseIncremental(loadAsString("java4-increment"), null, null, tree1);
-    	ATerm tree3 = (ATerm) sglr.parse(loadAsString("java4-increment"));
-    	System.out.println(tree2);
-    	System.out.println(tree3);
-    	assertEquals(tree3.toString(), tree2.toString());
+    	doParseIncrementalTest(tree1, "java4-increment");
+    	// TODO: test doParseIncrementalTest(tree1, "java5-increment");
     }
 
 }

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5-increment2.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5-increment2.java	Thu Dec 16 15:05:11 2010	(r21547)
@@ -0,0 +1,8 @@
+package java.java5;
+
+class X {
+  ;
+  void foo() {}
+  void baz() {}
+  void qux() {}
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5-increment3.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5-increment3.java	Thu Dec 16 15:05:11 2010	(r21547)
@@ -0,0 +1,6 @@
+package java.java5;
+
+class X {
+  ;
+  void foo() {}
+}

From karltk at strategoxt.org  Thu Dec 16 16:05:16 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:05:16 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21548 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt: src/org/spoofax/jsglr/client
	src/org/spoofax/jsglr/client/incremental
	src/org/spoofax/jsglr/shared/terms test/org/spoofax/...
Message-ID: <201012161505.oBGF5GRs027433@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:05:15 2010
New Revision: 21548
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21548&sc=1

Log:
Fixed some IncrementalInputBuilder problems.

Added:
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5-increment4.java
Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/PushbackStringIterator.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalInputBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLRException.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermFactory.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/PushbackStringIterator.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/PushbackStringIterator.java	Thu Dec 16 15:05:11 2010	(r21547)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/PushbackStringIterator.java	Thu Dec 16 15:05:15 2010	(r21548)
@@ -8,6 +8,7 @@
 	public PushbackStringIterator(String data) {
 		this.data = data;
 		position = 0;
+		assert data != null;
 	}
 	
 	public int read() {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalInputBuilder.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalInputBuilder.java	Thu Dec 16 15:05:11 2010	(r21547)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalInputBuilder.java	Thu Dec 16 15:05:15 2010	(r21548)
@@ -2,7 +2,6 @@
 
 import static java.lang.Math.min;
 import static org.spoofax.jsglr.client.incremental.IncrementalSGLR.DEBUG;
-import static org.spoofax.jsglr.client.incremental.IncrementalSGLR.isRangeOverlap;
 
 import java.util.Set;
 
@@ -14,6 +13,8 @@
  */
 public class IncrementalInputBuilder {
 	
+	private static final boolean INSERT_WHITESPACE = true;
+
 	private final StringBuilder result = new StringBuilder();
 	
 	private final Set<String> incrementalSorts;
@@ -22,9 +23,10 @@
 	
 	private final int damageStart;
 	
+	@SuppressWarnings("unused")
 	private final int damageEnd;
 
-	private final int afterDamageOffset;
+	private final int damageSizeChange;
 	
 	private boolean isDamagePrinted;
 
@@ -34,12 +36,12 @@
 	 *            *Must* be sorts that only occur in lists (such as MethodDec*).
 	 */
 	public IncrementalInputBuilder(Set<String> incrementalSorts, String input,
-			int damageStart, int damageEnd, int afterDamageOffset) {
+			int damageStart, int damageEnd, int damageSizeChange) {
 		this.incrementalSorts = incrementalSorts;
 		this.input = input;
 		this.damageEnd = damageEnd;
 		this.damageStart = damageStart;
-		this.afterDamageOffset = afterDamageOffset;
+		this.damageSizeChange = damageSizeChange;
 	}
 
 	public String buildPartialInput(IAstNode oldTree) throws IncrementalSGLRException {
@@ -48,17 +50,14 @@
 	}
 
 	private int buildPartialInput(IAstNode oldTree, int offset) throws IncrementalSGLRException {
-		IToken left = oldTree.getLeftToken();
 		IToken right = oldTree.getRightToken();
-		int startOffset = 0;
 		int endOffset = 0;
 		
 		// Print incrementalSorts nodes
-		if (left != null && right != null) {
-			startOffset = left.getStartOffset();
+		if (right != null) {
 			endOffset = right.getEndOffset();
 			if (!oldTree.isList() && incrementalSorts.contains(oldTree.getSort())) {
-				if (isRangeOverlap(damageStart, damageEnd, startOffset, endOffset)) {
+				if (endOffset >= damageStart /*isRangeOverlap(damageStart, damageEnd, startOffset, endOffset)*/) {
 					printDamagedNode(offset, endOffset);
 					// possible: appendWhitespace(input, startOffset, endOffset);
 				} else {
@@ -71,7 +70,7 @@
 		offset = buildPartialInputRecurse(oldTree, offset);
 
 		// Print original text
-		if (left != null && right != null) {
+		if (right != null) {
 			return appendPartialInput(oldTree, offset, endOffset);
 		} else {
 			return offset;
@@ -95,32 +94,39 @@
 
 	private void printDamagedNode(int offset, int endOffset) {
 		if (!isDamagePrinted) {
+			append(input, offset, endOffset + damageSizeChange + 1);
 			isDamagePrinted = true;
-			if (DEBUG) System.out.print('|');
+			/*
+			if (DEBUG) System.err.print('|');
 			append(input, offset, damageStart);
-			if (DEBUG) System.out.print('|');
+			if (DEBUG) System.err.print('|');
 			append(input, damageStart, damageEnd + 1);
-			if (DEBUG) System.out.print('|');
+			if (DEBUG) System.err.print('|');
 			// TODO: don't use endOffset here but use the last token's end offset
-			append(input, damageEnd + 1, endOffset + afterDamageOffset + 1);
-			if (DEBUG) System.out.print('|');
+			append(input, damageEnd + 1, endOffset + damageSizeChange + 1);
+			if (DEBUG) System.err.print('|');
+			*/
 		}
 	}
 
 	private void appendWhitespace(String input, int offset, int endOffset) {
-		for (int i = offset; i <= endOffset; i++) {
-			// if (DEBUG) System.out.print(input.charAt(i) == '\n' ? "\n" : "-" + input.charAt(i));
-			result.append(input.charAt(i) == '\n' ? '\n' : ' ');
+		if (INSERT_WHITESPACE) {
+			for (int i = offset; i <= endOffset; i++) {
+				// if (DEBUG) System.err.print(input.charAt(i) == '\n' ? "\n" : "-" + input.charAt(i));
+				result.append(input.charAt(i) == '\n' ? '\n' : ' ');
+			}
 		}
 	}
 
 	private int appendPartialInput(IAstNode oldTree, int offset, int endOffset) {
 		if (offset >= damageStart) {
 			if (!isDamagePrinted) {
-				append(input, damageStart, damageEnd + 1);
+				// append(input, damageStart, damageEnd + 1);
+				append(input, damageStart, damageStart + damageSizeChange + 1);
+				// append(input, damageStart + damageSizeChange, damageEnd + damageSizeChange + 1);
 				isDamagePrinted = true;
 			}
-			append(input, offset + afterDamageOffset, endOffset + afterDamageOffset + 1);
+			append(input, offset + damageSizeChange, endOffset + damageSizeChange + 1);
 		} else {
 			append(input, offset, min(endOffset + 1, damageStart));
 		}
@@ -128,7 +134,7 @@
 	}
 	
 	private void append(String input, int offset, int endOffset) {
-		if (DEBUG) System.out.print(input.substring(offset, endOffset));
+		if (DEBUG) System.err.print(input.substring(offset, endOffset));
 		result.append(input, offset, endOffset);
  	}
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java	Thu Dec 16 15:05:11 2010	(r21547)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java	Thu Dec 16 15:05:15 2010	(r21548)
@@ -22,7 +22,7 @@
 	
 	private static final boolean ASSUME_MINIMAL_DIFF = true;
 	
-	static final boolean DEBUG = true;
+	static final boolean DEBUG = false;
 	
 	final SGLR parser;
 
@@ -52,13 +52,13 @@
 		
 		String oldInput = oldTree.getLeftToken().getTokenizer().getInput();
 		int damageStart = getDamageStart(input, oldInput);
-		int afterDamageOffset = input.length() - oldInput.length();
-		int damageEnd = getDamageEnd(input, oldInput, afterDamageOffset,
-				ASSUME_MINIMAL_DIFF ? max(afterDamageOffset, 0) : damageStart);
+		int damageSizeChange = input.length() - oldInput.length();
+		int damageEnd = getDamageEnd(input, oldInput, damageSizeChange,
+				ASSUME_MINIMAL_DIFF ? max(damageSizeChange, 0) : damageStart);
 		if (damageEnd == damageStart - 1) return oldTree;
 		
 		IncrementalInputBuilder inputBuilder =
-			new IncrementalInputBuilder(incrementalSorts, input, damageStart, damageEnd, afterDamageOffset);
+			new IncrementalInputBuilder(incrementalSorts, input, damageStart, damageEnd, damageSizeChange);
 		
 		IncrementalTreeBuilder<TNode> treeBuilder =
 			new IncrementalTreeBuilder<TNode>(this, input, filename, damageStart, damageEnd);
@@ -80,9 +80,11 @@
 			throws IncrementalSGLRException {
 		
 		List<IAstNode> damagedNodes = builder.getDamageTreeNodes(oldTree);
+		if (DEBUG) System.err.println("Damaged: " + damagedNodes);
+		
 		for (IAstNode node : damagedNodes) {
 			if (!incrementalSorts.contains(node.getSort()))
-				throw new IncrementalSGLRException("Unsafe change to tree node of type "
+				throw new IncrementalSGLRException("Precondition failed: unsafe change to tree node of type "
 						+ node.getSort() + " at line " + node.getLeftToken().getLine());
 		}
 	}
@@ -90,17 +92,17 @@
 	private void sanityCheckRepairedTree(List<IAstNode> repairedTreeNodes)
 			throws IncrementalSGLRException {
 		
-		if (DEBUG) System.out.println("\nRepaired: " + repairedTreeNodes);
+		if (DEBUG) System.err.println("\nRepaired: " + repairedTreeNodes);
 		
 		for (IAstNode node : repairedTreeNodes) {
 			if (!incrementalSorts.contains(node.getSort()))
-				throw new IncrementalSGLRException("Unsafe tree parsed at "
+				throw new IncrementalSGLRException("Postcondition failed: unsafe tree parsed at "
 						+ node.getSort()  + " at line " + node.getLeftToken().getLine());
 		}
 	}
 
 	protected static boolean isRangeOverlap(int start1, int end1, int start2, int end2) {
-		return start1 <= end2 && start2 <= end1;
+		return start1 < end2 && start2 < end1;
 	}
 
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLRException.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLRException.java	Thu Dec 16 15:05:11 2010	(r21547)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLRException.java	Thu Dec 16 15:05:15 2010	(r21548)
@@ -1,5 +1,7 @@
 package org.spoofax.jsglr.client.incremental;
 
+import static org.spoofax.jsglr.client.incremental.IncrementalSGLR.DEBUG;
+
 /**
  * An exception thrown if some input cannot be incrementally parsed.
  * Likely, it can be parsed non-incrementally instead.
@@ -13,19 +15,20 @@
 	private static final String DEFAULT_MESSAGE = "Incremental parsing failed";
 	
 	public IncrementalSGLRException() {
-		super(DEFAULT_MESSAGE);
+		this(DEFAULT_MESSAGE);
 	}
 
 	public IncrementalSGLRException(String message) {
-		super(message);
+		this(message, null);
 	}
 
 	public IncrementalSGLRException(Throwable cause) {
-		super(DEFAULT_MESSAGE, cause);
+		this(DEFAULT_MESSAGE, cause);
 	}
 
 	public IncrementalSGLRException(String message, Throwable cause) {
 		super(message, cause);
+		if (DEBUG) System.err.println(message);
 	}
 
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java	Thu Dec 16 15:05:11 2010	(r21547)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java	Thu Dec 16 15:05:15 2010	(r21548)
@@ -9,6 +9,7 @@
 import org.spoofax.jsglr.client.SGLR;
 import org.spoofax.jsglr.client.imploder.IAstNode;
 import org.spoofax.jsglr.client.imploder.IToken;
+import org.spoofax.jsglr.client.imploder.ITokenizer;
 import org.spoofax.jsglr.client.imploder.ITreeFactory;
 import org.spoofax.jsglr.client.imploder.Tokenizer;
 
@@ -102,7 +103,7 @@
 			int startOffset = left.getStartOffset();
 			int endOffset = right.getEndOffset();
 			
-			if (!isRangeOverlap(damageStart, damageEnd, startOffset, endOffset))
+			if (!isDamagedNonEmptyRange(startOffset, endOffset))
 				return false;
 			if (incrementalSorts.contains(tree.getSort()))
 				return true;
@@ -111,17 +112,31 @@
 				IToken childLeft = child.getLeftToken();
 				IToken childRight = child.getRightToken();
 				if (childLeft != null && childRight != null) {
-					if (isRangeOverlap(damageStart, damageEnd, startOffset, childLeft.getStartOffset() - 1)) {
+					if (isDamagedNonEmptyRange(startOffset, childLeft.getStartOffset() - 1)) {
 						return true;
 					}
 					startOffset = childRight.getEndOffset() + 1;
 				}
 			}
-			return isRangeOverlap(damageStart, damageEnd, startOffset, endOffset);
+			return isDamagedNonEmptyRange(startOffset, getLastNonLayoutOffset(tree));
 		} else {
 			return false;
 		}
 	}
+	
+	private static int getLastNonLayoutOffset(IAstNode tree) {
+		IToken token = tree.getRightToken();
+		ITokenizer tokens = token.getTokenizer();
+		while (token.getKind() == IToken.TK_LAYOUT && token.getIndex() > 0) {
+			token = tokens.getTokenAt(token.getIndex() - 1);
+		}
+		return token.getEndOffset();
+	}
+	
+	private boolean isDamagedNonEmptyRange(int startOffset, int endOffset) {
+		return endOffset >= startOffset && isRangeOverlap(damageStart, damageEnd, startOffset, endOffset);
+	}
+	
 	public TNode buildOutput(IAstNode oldTreeNode, List<IAstNode> repairedTreeNodes) {
 		Tokenizer tokenizer =
 			new Tokenizer(parser.getParseTable().getKeywordRecognizer(), filename, input);

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermFactory.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermFactory.java	Thu Dec 16 15:05:11 2010	(r21547)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermFactory.java	Thu Dec 16 15:05:15 2010	(r21548)
@@ -6,6 +6,7 @@
 import java.util.HashMap;
 import java.util.List;
 
+import org.apache.commons.lang.NullArgumentException;
 import org.spoofax.jsglr.client.NotImplementedException;
 import org.spoofax.jsglr.client.PushbackStringIterator;
 
@@ -297,6 +298,8 @@
 	}
 
 	public ATerm parseFromString(String text) {
+		if (text == null)
+			throw new NullArgumentException("text");
 		return parseFromStream(new PushbackStringIterator(text));
 	}
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:05:11 2010	(r21547)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:05:15 2010	(r21548)
@@ -138,7 +138,10 @@
 	
 	public ATerm doParseIncrementalTest(ATerm oldTree, String newFile) throws Exception {
 		String contents = loadAsString(newFile);
+		long parseTime = System.nanoTime();
     	ATerm newTree = (ATerm) incrementalSGLR.parseIncremental(contents, newFile, null, oldTree);
+		parseTime = System.nanoTime() - parseTime;
+		System.out.println("Incremental parsing " + newFile + " took " + parseTime/1000/1000 + " millis.");
 		String extension =
 			table.getTreeBuilder() instanceof TreeBuilder ? ".itrm" : ".trm";
 		final String x = FileTools.loadFileAsString("tests/data/" + newFile + extension);

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java	Thu Dec 16 15:05:11 2010	(r21547)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java	Thu Dec 16 15:05:15 2010	(r21548)
@@ -9,16 +9,28 @@
  */
 public class TestIncrementalSGLR extends ParseTestCase {
 
+	ATerm java5;
+	
     @Override
 	public void gwtSetUp() throws ParserException, InvalidParseTableException {
         super.gwtSetUp("Java-15", "java", "MethodDec", "ClassBodyDec");
+    	java5 = doParseTest("java5");
     }
 
-    public void testJava5() throws Exception {
-    	ATerm tree1 = doParseTest("java5");
-    	doParseIncrementalTest(tree1, "java5-increment");
-    	// doParseIncrementalTest(tree1, "java5-increment2");
-    	// doParseIncrementalTest(tree1, "java5-increment3");
+    public void testJava51() throws Exception {
+    	doParseIncrementalTest(java5, "java5-increment");
+    }
+    
+    public void testJava52() throws Exception {
+    	doParseIncrementalTest(java5, "java5-increment2");
+    }
+    
+    public void testJava53() throws Exception {
+    	doParseIncrementalTest(java5, "java5-increment3");
+    }
+    
+    public void testJava54() throws Exception {
+    	doParseIncrementalTest(java5, "java5-increment4");
     }
 
     public void testJava4() throws Exception {

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5-increment4.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5-increment4.java	Thu Dec 16 15:05:15 2010	(r21548)
@@ -0,0 +1,6 @@
+package java.java5;
+
+class X {
+  ;
+  void foobaz() {}
+}

From karltk at strategoxt.org  Thu Dec 16 16:05:21 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:05:21 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21549 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt: src/org/spoofax/jsglr/client
	src/org/spoofax/jsglr/client/imploder
	src/org/spoofax/jsglr/client/incremental test/org/spoof...
Message-ID: <201012161505.oBGF5LID027436@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:05:21 2010
New Revision: 21549
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21549&sc=1

Log:
Rewrote IncrementalInputBuilder; current tests succeed.

Added:
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5-increment5.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5-increment6.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5-increment7.java
Deleted:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IncrementalSGLR.java
Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Tokenizer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalInputBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Tokenizer.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Tokenizer.java	Thu Dec 16 15:05:15 2010	(r21548)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Tokenizer.java	Thu Dec 16 15:05:21 2010	(r21549)
@@ -92,7 +92,7 @@
 		if (!allowEmptyToken && startOffset > endOffset) // empty token
 			return null;
 		
-		assert endOffset >= startOffset || (kind == TK_RESERVED && startOffset == 0);
+		assert endOffset + 1 >= startOffset || (kind == TK_RESERVED && startOffset == 0);
 		
 		int offset;
 		IToken token = null;
@@ -119,7 +119,7 @@
 	}
 
 	private IToken internalMakeToken(int kind, int endOffset) {
-		IToken result = new Token(this, tokens.size() - 1, line, startOffset - offsetAtLineStart, startOffset, endOffset, kind);
+		IToken result = new Token(this, tokens.size(), line, startOffset - offsetAtLineStart, startOffset, endOffset, kind);
 		tokens.add(result);
 		startOffset = endOffset + 1;
 		return result;
@@ -193,6 +193,70 @@
 		}
 	}
 	
+	/**
+	 * Searches towards the left of the given token for the
+	 * leftmost layout token, returning the current token if
+	 * no layout token is found.
+	 */
+	public static IToken findLeftMostLayoutToken(IToken token) {
+		if (token == null) return null;
+		ITokenizer tokens = token.getTokenizer();
+		for (int i = token.getIndex() - 1; i >= 0; i++) {
+			if (token.getKind() == IToken.TK_LAYOUT)
+				break;
+			token = tokens.getTokenAt(i);
+		}
+		return token;
+	}
+	
+	/**
+	 * Searches towards the left of the given token for the
+	 * leftmost non-layout token, returning the current token if
+	 * no non-layout token is found.
+	 */
+	public static IToken findLeftMostNonLayoutToken(IToken token) {
+		if (token == null) return null;
+		ITokenizer tokens = token.getTokenizer();
+		for (int i = token.getIndex() - 1; i >= 0; i++) {
+			if (token.getKind() != IToken.TK_LAYOUT)
+				break;
+			token = tokens.getTokenAt(i);
+		}
+		return token;
+	}
+	
+	/**
+	 * Searches towards the right of the given token for the
+	 * rightmost layout token, returning the current token if
+	 * no layout token is found.
+	 */
+	public static IToken findRightMostLayoutToken(IToken token) {
+		if (token == null) return null;
+		ITokenizer tokens = token.getTokenizer();
+		for (int i = token.getIndex() + 1, count = tokens.getTokenCount(); i < count; i++) {
+			if (token.getKind() == IToken.TK_LAYOUT)
+				break;
+			token = tokens.getTokenAt(i);
+		}
+		return token;
+	}
+	
+	/**
+	 * Searches towards the right of the given token for the
+	 * rightmost non-layout token, returning the current token if
+	 * no non-layout token is found.
+	 */
+	public static IToken findRightMostNonLayoutToken(IToken token) {
+		if (token == null) return null;
+		ITokenizer tokens = token.getTokenizer();
+		for (int i = token.getIndex() + 1, count = tokens.getTokenCount(); i < count; i++) {
+			if (token.getKind() != IToken.TK_LAYOUT)
+				break;
+			token = tokens.getTokenAt(i);
+		}
+		return token;
+	}
+	
 	public String toString(IToken left, IToken right) {
 		int startOffset = left.getStartOffset();
 		int endOffset = right.getEndOffset();

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalInputBuilder.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalInputBuilder.java	Thu Dec 16 15:05:15 2010	(r21548)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalInputBuilder.java	Thu Dec 16 15:05:21 2010	(r21549)
@@ -1,8 +1,12 @@
 package org.spoofax.jsglr.client.incremental;
 
+import static java.lang.Math.max;
 import static java.lang.Math.min;
 import static org.spoofax.jsglr.client.incremental.IncrementalSGLR.DEBUG;
+import static org.spoofax.jsglr.client.incremental.IncrementalSGLR.isRangeOverlap;
+import static org.spoofax.jsglr.client.incremental.IncrementalSGLR.tryGetListIterator;
 
+import java.util.Iterator;
 import java.util.Set;
 
 import org.spoofax.jsglr.client.imploder.IAstNode;
@@ -13,128 +17,162 @@
  */
 public class IncrementalInputBuilder {
 	
-	private static final boolean INSERT_WHITESPACE = true;
+	private static final boolean INSERT_WHITESPACE = false;
 
 	private final StringBuilder result = new StringBuilder();
 	
 	private final Set<String> incrementalSorts;
 	
 	private final String input;
+
+	@SuppressWarnings("unused") // for debugging
+	private final String oldInput;
 	
 	private final int damageStart;
 	
-	@SuppressWarnings("unused")
+	/**
+	 * The (inclusive) end offset of the damage region.
+	 */
 	private final int damageEnd;
 
 	private final int damageSizeChange;
 	
+	private boolean isSkipping;
+	
 	private boolean isDamagePrinted;
+	
+	private int skippedChars;
 
 	/**
 	 * @param incrementalSorts
 	 *            Sorts that can be incrementally parsed (e.g., MethodDec, ImportDec).
 	 *            *Must* be sorts that only occur in lists (such as MethodDec*).
 	 */
-	public IncrementalInputBuilder(Set<String> incrementalSorts, String input,
+	public IncrementalInputBuilder(Set<String> incrementalSorts, String input, String oldInput,
 			int damageStart, int damageEnd, int damageSizeChange) {
 		this.incrementalSorts = incrementalSorts;
 		this.input = input;
+		this.oldInput = oldInput;
 		this.damageEnd = damageEnd;
 		this.damageStart = damageStart;
 		this.damageSizeChange = damageSizeChange;
 	}
 
 	public String buildPartialInput(IAstNode oldTree) throws IncrementalSGLRException {
-		buildPartialInput(oldTree, 0);
-		return result.toString();
+		isSkipping = isDamagePrinted = false;
+		skippedChars = 0;
+		appendTree(oldTree);
+		try {
+			return result.toString();
+		} finally {
+			if (DEBUG) System.out.println();
+		}
+	}
+	
+	/**
+	 * Gets the number of characters *before* the damaged region
+	 * that were in the original input string but not in 
+	 * the last incremental input string built by this instance.
+	 */
+	public int getLastSkippedChars() {
+		return skippedChars;
 	}
 
-	private int buildPartialInput(IAstNode oldTree, int offset) throws IncrementalSGLRException {
+	private void appendTree(IAstNode oldTree) throws IncrementalSGLRException {
+		IToken left = oldTree.getLeftToken();
 		IToken right = oldTree.getRightToken();
+		int startOffset = 0;
 		int endOffset = 0;
+		boolean isSkippingStart = false;
 		
-		// Print incrementalSorts nodes
-		if (right != null) {
+		if (left != null && right != null) {
+			startOffset = left.getStartOffset();
 			endOffset = right.getEndOffset();
-			if (!oldTree.isList() && incrementalSorts.contains(oldTree.getSort())) {
-				if (endOffset >= damageStart /*isRangeOverlap(damageStart, damageEnd, startOffset, endOffset)*/) {
-					printDamagedNode(offset, endOffset);
-					// possible: appendWhitespace(input, startOffset, endOffset);
-				} else {
-					appendWhitespace(input, offset, endOffset);
-				}
-				return endOffset + 1;
+			
+			if (!isSkipping && !oldTree.isList() && incrementalSorts.contains(oldTree.getSort())
+					&& !isRangeOverlap(damageStart, damageEnd /*- damageSizeChange*/, startOffset, endOffset)) {
+				isSkipping = isSkippingStart = true;
 			}
-		}
-		
-		offset = buildPartialInputRecurse(oldTree, offset);
 
-		// Print original text
-		if (right != null) {
-			return appendPartialInput(oldTree, offset, endOffset);
+			Iterator<IAstNode> iterator = tryGetListIterator(oldTree); 
+			for (int i = 0, max = oldTree.getChildCount(); i < max; i++) {
+				IAstNode child = iterator == null ? oldTree.getChildAt(i) : iterator.next();
+				IToken childLeft = child.getLeftToken();
+				IToken childRight = child.getRightToken();
+				if (childLeft != null)
+					appendToken(startOffset, childLeft.getStartOffset() - 1);
+				appendTree(child);
+				if (childRight != null)
+					startOffset = childRight.getEndOffset() + 1;
+			}
+			appendToken(startOffset, endOffset);
 		} else {
-			return offset;
+			assert oldTree.getChildCount() == 0 :
+				"No tokens for tree with children??";
 		}
+		
+		if (isSkippingStart) isSkipping = false;
 	}
-
-	private int buildPartialInputRecurse(IAstNode oldTree, int offset) throws IncrementalSGLRException {
-		if (oldTree.isList() && oldTree instanceof Iterable) { // likely a linked list
-			for (Object o : (Iterable<?>) oldTree) {
-				IAstNode child = (IAstNode) o;
-				offset = buildPartialInput(child, offset);
+	
+	/**
+	 * Appends a token with the given startOffset
+	 * and endOffset (inclusive). If the token overlaps
+	 * with the damaged region, it is discarded
+	 * or merged with the damaged region as necessary.
+	 */
+	private void appendToken(int startOffset, int endOffset) {
+		if (isDamagePrinted /* startOffset >= damageStart */) {
+			assert startOffset >= damageStart;
+			if (endOffset > damageEnd) {
+				int newStartOffset = max(damageEnd + damageSizeChange + 1, startOffset + damageSizeChange);
+				internalAppendSubstring(newStartOffset, endOffset + damageSizeChange + 1);
 			}
+			
 		} else {
-			for (int i = 0, count = oldTree.getChildCount(); i < count; i++) {
-				IAstNode child = oldTree.getChildAt(i);
-				offset = buildPartialInput(child, offset);
-			}
-		}
-		return offset;
-	}
-
-	private void printDamagedNode(int offset, int endOffset) {
-		if (!isDamagePrinted) {
-			append(input, offset, endOffset + damageSizeChange + 1);
-			isDamagePrinted = true;
-			/*
-			if (DEBUG) System.err.print('|');
-			append(input, offset, damageStart);
-			if (DEBUG) System.err.print('|');
-			append(input, damageStart, damageEnd + 1);
-			if (DEBUG) System.err.print('|');
-			// TODO: don't use endOffset here but use the last token's end offset
-			append(input, damageEnd + 1, endOffset + damageSizeChange + 1);
-			if (DEBUG) System.err.print('|');
-			*/
-		}
-	}
-
-	private void appendWhitespace(String input, int offset, int endOffset) {
-		if (INSERT_WHITESPACE) {
-			for (int i = offset; i <= endOffset; i++) {
-				// if (DEBUG) System.err.print(input.charAt(i) == '\n' ? "\n" : "-" + input.charAt(i));
-				result.append(input.charAt(i) == '\n' ? '\n' : ' ');
+			if (endOffset >= damageStart) {
+				int tokenLength = endOffset - startOffset + 1;
+				int charsBeforeDamage = damageStart - startOffset;
+				int charsAfterDamage = max(0, endOffset - damageEnd);
+				assert charsBeforeDamage + charsAfterDamage <= tokenLength
+					&& min(charsBeforeDamage, charsAfterDamage) >= 0;
+				if (DEBUG) System.out.print('|');
+				internalAppendSubstring(startOffset, startOffset + charsBeforeDamage);
+				if (DEBUG) System.out.print('$');
+				internalAppendSubstring(damageStart, damageEnd + damageSizeChange + 1);
+				if (DEBUG) System.out.print('$');
+				internalAppendSubstring(damageEnd + damageSizeChange + 1,
+							damageEnd + damageSizeChange + 1 + charsAfterDamage);
+				if (DEBUG) System.out.print('|');
+				isDamagePrinted = true;
+			} else {
+				internalAppendSubstring(startOffset, endOffset + 1);
 			}
 		}
-	}
-
-	private int appendPartialInput(IAstNode oldTree, int offset, int endOffset) {
-		if (offset >= damageStart) {
-			if (!isDamagePrinted) {
-				// append(input, damageStart, damageEnd + 1);
-				append(input, damageStart, damageStart + damageSizeChange + 1);
-				// append(input, damageStart + damageSizeChange, damageEnd + damageSizeChange + 1);
-				isDamagePrinted = true;
+ 	}
+	
+	/**
+	 * Directly appends a substring with a given 
+	 * startIndex and endIndex (exclusive).
+	 * 
+	 * @param startIndex  The start index or offset of the string.
+	 * @param endIndex    The endIndex of the string (exclusive),
+	 *                    equal to endOffset + 1.
+	 */
+	private void internalAppendSubstring(int startIndex, int endIndex) {
+		if (isSkipping) {
+			for (int i = startIndex; i < endIndex; i++) {
+				// if (DEBUG) System.out.print(input.charAt(i) == '\n' ? "\n" : "-" + input.charAt(i));
+				if (input.charAt(i) == '\n') {
+					result.append('\n');
+				} else if (INSERT_WHITESPACE) {
+					result.append(' ');
+				} else if (i < damageStart) {
+					skippedChars++;
+				}
 			}
-			append(input, offset + damageSizeChange, endOffset + damageSizeChange + 1);
 		} else {
-			append(input, offset, min(endOffset + 1, damageStart));
+			if (DEBUG) System.out.print(input.substring(startIndex, endIndex));
+			result.append(input, startIndex, endIndex);
 		}
-		return endOffset + 1;
 	}
-	
-	private void append(String input, int offset, int endOffset) {
-		if (DEBUG) System.err.print(input.substring(offset, endOffset));
-		result.append(input, offset, endOffset);
- 	}
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java	Thu Dec 16 15:05:15 2010	(r21548)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java	Thu Dec 16 15:05:21 2010	(r21549)
@@ -1,7 +1,9 @@
 package org.spoofax.jsglr.client.incremental;
 
 import static java.lang.Math.max;
+import static java.lang.Math.min;
 
+import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
 
@@ -16,19 +18,21 @@
 import org.spoofax.jsglr.shared.TokenExpectedException;
 
 /**
+ * An incremental parsing extension of SGLR.
+ * 
  * @author Lennart Kats <lennart add lclnet.nl>
  */
 public class IncrementalSGLR<TNode extends IAstNode> {
 	
-	private static final boolean ASSUME_MINIMAL_DIFF = true;
-	
-	static final boolean DEBUG = false;
+	static final boolean DEBUG = true;
 	
 	final SGLR parser;
 
 	final ITreeFactory<TNode> factory;
 	
 	final Set<String> incrementalSorts;
+	
+	int lastRepairedTreeNodesCount;
 
 	/**
 	 * @param incrementalSorts
@@ -47,40 +51,86 @@
 		//       (using injection prods in parse table; build some class like KeywordRecognizer)
 	}
 	
-	public IAstNode parseIncremental(String input, String filename, String startSymbol, TNode oldTree)
+	/**
+	 * Attempts to incrementally parse an input,
+	 * or falls back to normal parsing if incremental parsing fails.
+	 */
+	public IAstNode tryParseIncremental(String input, String filename, String startSymbol, TNode oldTree)
+			throws TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		
+		try {
+			return parseIncremental(input, filename, startSymbol, oldTree);
+		} catch (IncrementalSGLRException e) {
+			lastRepairedTreeNodesCount = -1;
+			return (IAstNode) parser.parse(input, startSymbol);
+		}
+	}
+	
+	/**
+	 * Incrementally parse an input.
+	 * 
+	 * @throws IncrementalSGLRException
+	 *             If the input could not be incrementally parsed.
+	 *             It may still be possible to parse it non-incrementally.
+	 */
+	public IAstNode parseIncremental(String newInput, String filename, String startSymbol, TNode oldTree)
 			throws TokenExpectedException, BadTokenException, ParseException, SGLRException, IncrementalSGLRException {
 		
 		String oldInput = oldTree.getLeftToken().getTokenizer().getInput();
-		int damageStart = getDamageStart(input, oldInput);
-		int damageSizeChange = input.length() - oldInput.length();
-		int damageEnd = getDamageEnd(input, oldInput, damageSizeChange,
-				ASSUME_MINIMAL_DIFF ? max(damageSizeChange, 0) : damageStart);
-		if (damageEnd == damageStart - 1) return oldTree;
+		//oldInput = "{old}{old}";
+		//newInput = "{old}{old}{NEW}}";
+		int damageStart = getDamageStart(newInput, oldInput);
+		int damageSizeChange = newInput.length() - oldInput.length();
+		int damageEnd = getDamageEnd(newInput, oldInput, damageStart, damageSizeChange);
+		sanityCheckDiff(oldInput, newInput, damageStart, damageEnd, damageSizeChange);
+		
+		if (damageSizeChange == 0 && damageEnd == damageStart - 1) {
+			assert newInput.equals(oldInput);
+			lastRepairedTreeNodesCount = 0;
+			return oldTree;
+		}
 		
 		IncrementalInputBuilder inputBuilder =
-			new IncrementalInputBuilder(incrementalSorts, input, damageStart, damageEnd, damageSizeChange);
+			new IncrementalInputBuilder(incrementalSorts, newInput, oldInput, damageStart, damageEnd, damageSizeChange);
 		
 		IncrementalTreeBuilder<TNode> treeBuilder =
-			new IncrementalTreeBuilder<TNode>(this, input, filename, damageStart, damageEnd);
+			new IncrementalTreeBuilder<TNode>(this, newInput, filename, damageStart, damageEnd, damageSizeChange);
 		
-		sanityCheckOldTree(treeBuilder, oldTree);
+		sanityCheckOldTree(oldTree, treeBuilder.getDamagedTreeNodes(oldTree));
 
 		String partialInput = inputBuilder.buildPartialInput(oldTree);
-		
 		IAstNode partialTree = (IAstNode) parser.parse(partialInput, startSymbol);
 		
-		List<IAstNode> repairedTreeNodes = treeBuilder.getDamageTreeNodes(partialTree);
-		
+		List<IAstNode> repairedTreeNodes = treeBuilder.getRepairedTreeNodes(partialTree, inputBuilder.getLastSkippedChars());
+		lastRepairedTreeNodesCount = repairedTreeNodes.size();
 		sanityCheckRepairedTree(repairedTreeNodes);
 
 		return treeBuilder.buildOutput(oldTree, repairedTreeNodes);
 	}
 	
-	private void sanityCheckOldTree(IncrementalTreeBuilder<TNode> builder, IAstNode oldTree)
+	/**
+	 * Returns the number of tree nodes that had to be
+	 * repaired for the last incremental parse task.
+	 */
+	public int getLastRepairedTreeNodesCount() {
+		return lastRepairedTreeNodesCount;
+	}
+
+	private void sanityCheckDiff(String oldInput, String newInput,
+			int damageStart, int damageEnd, int damageSizeChange) throws IncrementalSGLRException {
+		if (!(damageStart <= damageEnd + 1
+			&& damageStart <= damageEnd + damageSizeChange + 1)) {
+			throw new IncrementalSGLRException("Precondition failed: unable to determine valid diff");
+		}
+		assert (oldInput.substring(0, damageStart)
+			+ newInput.substring(damageStart, damageEnd + damageSizeChange + 1)
+			+ oldInput.substring(damageEnd + 1)).equals(newInput);
+	}
+
+	private void sanityCheckOldTree(IAstNode oldTree, List<IAstNode> damagedNodes)
 			throws IncrementalSGLRException {
 		
-		List<IAstNode> damagedNodes = builder.getDamageTreeNodes(oldTree);
-		if (DEBUG) System.err.println("Damaged: " + damagedNodes);
+		if (DEBUG) System.out.println("Damaged: " + damagedNodes);
 		
 		for (IAstNode node : damagedNodes) {
 			if (!incrementalSorts.contains(node.getSort()))
@@ -88,15 +138,15 @@
 						+ node.getSort() + " at line " + node.getLeftToken().getLine());
 		}
 	}
-
+	
 	private void sanityCheckRepairedTree(List<IAstNode> repairedTreeNodes)
 			throws IncrementalSGLRException {
 		
-		if (DEBUG) System.err.println("\nRepaired: " + repairedTreeNodes);
+		if (DEBUG) System.out.println("\nRepaired: " + repairedTreeNodes);
 		
 		for (IAstNode node : repairedTreeNodes) {
 			if (!incrementalSorts.contains(node.getSort()))
-				throw new IncrementalSGLRException("Postcondition failed: unsafe tree parsed at "
+				throw new IncrementalSGLRException("Postcondition failed: unsafe tree parsed of type "
 						+ node.getSort()  + " at line " + node.getLeftToken().getLine());
 		}
 	}
@@ -105,18 +155,29 @@
 		return start1 < end2 && start2 < end1;
 	}
 
+	@SuppressWarnings("unchecked")
+	protected static Iterator<IAstNode> tryGetListIterator(IAstNode oldTree) {
+		if (oldTree.isList() && oldTree instanceof Iterable)
+			return ((Iterable<IAstNode>) oldTree).iterator();
+		else
+			return null;
+	}
+
 
 	private int getDamageStart(String input, String oldInput) {
-		for (int i = 0; i < input.length(); i++) {
+		int limit = min(input.length(), oldInput.length());
+		for (int i = 0; i < limit; i++) {
 			if (input.charAt(i) != oldInput.charAt(i)) return i;
 		}
-		return input.length() - 1;
+		return limit - 1;
 	}
 
-	private int getDamageEnd(String input, String oldInput, int offset, int damageStart) {
-		for (int i = input.length() - 1; i > damageStart + offset; i--) {
-			if (input.charAt(i) != oldInput.charAt(i - offset)) return i;
+	private int getDamageEnd(String input, String oldInput, int damageStart, int damageSizeChange) {
+		int limit = max(damageStart, damageStart - damageSizeChange) -1;
+		for (int i = oldInput.length() - 1; i > limit; i--) {
+			if (oldInput.charAt(i) != input.charAt(i + damageSizeChange))
+				return i;
 		}
-		return damageStart - 1;
+		return limit;
 	}
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java	Thu Dec 16 15:05:15 2010	(r21548)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java	Thu Dec 16 15:05:21 2010	(r21549)
@@ -1,15 +1,18 @@
 package org.spoofax.jsglr.client.incremental;
 
+import static org.spoofax.jsglr.client.imploder.Tokenizer.findLeftMostLayoutToken;
+import static org.spoofax.jsglr.client.imploder.Tokenizer.findRightMostLayoutToken;
 import static org.spoofax.jsglr.client.incremental.IncrementalSGLR.isRangeOverlap;
+import static org.spoofax.jsglr.client.incremental.IncrementalSGLR.tryGetListIterator;
 
 import java.util.ArrayList;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
 
 import org.spoofax.jsglr.client.SGLR;
 import org.spoofax.jsglr.client.imploder.IAstNode;
 import org.spoofax.jsglr.client.imploder.IToken;
-import org.spoofax.jsglr.client.imploder.ITokenizer;
 import org.spoofax.jsglr.client.imploder.ITreeFactory;
 import org.spoofax.jsglr.client.imploder.Tokenizer;
 
@@ -38,6 +41,8 @@
 	private final int damageStart;
 
 	private final int damageEnd;
+	
+	private final int damageSizeChange;
 
 	/**
 	 * @param incrementalSorts
@@ -45,7 +50,7 @@
 	 *            *Must* be sorts that only occur in lists (such as MethodDec*).
 	 */
 	public IncrementalTreeBuilder(IncrementalSGLR<TNode> parser, String input, String filename,
-			int damageStart, int damageEnd) {
+			int damageStart, int damageEnd, int damageSizeChange) {
 		this.parser = parser.parser;
 		this.input = input;
 		this.filename = filename;
@@ -53,40 +58,37 @@
 		this.incrementalSorts = parser.incrementalSorts;
 		this.damageStart = damageStart;
 		this.damageEnd = damageEnd;
+		this.damageSizeChange = damageSizeChange;
 	}
 	
 	/**
-	 * Gets all non-list tree nodes that are in the damaged region
-	 * according to {@link #isDamageTreeNode}.
+	 * Gets all non-list tree nodes from the original tree
+	 * that are in the damaged region according to {@link #isDamageTreeNode}.
 	 */
-	public List<IAstNode> getDamageTreeNodes(IAstNode tree) {
-		return getDamageTreeNodes(tree, new ArrayList<IAstNode>());
+	public List<IAstNode> getDamagedTreeNodes(IAstNode tree) {
+		return getDamagedRegionTreeNodes(tree, new ArrayList<IAstNode>(), true, 0);
 	}
-
-	private List<IAstNode> getDamageTreeNodes(IAstNode tree, List<IAstNode> results) {
-		if (tree.isList()) { // ignored for getDamageTreeNodes
-			getDamageTreeNodesRecurse(tree, results);
-		} else {
-			if (isDamageTreeNode(tree)) {
-				results.add(tree);
-			} else {
-				getDamageTreeNodesRecurse(tree, results);
-			}
-		}
-		return results;
+	
+	/**
+	 * Gets all non-list tree nodes from the partial result tree
+	 * that are in the damaged region according to {@link #isDamageTreeNode}.
+	 */
+	public List<IAstNode> getRepairedTreeNodes(IAstNode tree, int skippedChars) {
+		return getDamagedRegionTreeNodes(tree, new ArrayList<IAstNode>(), false, skippedChars);
 	}
 
-	private void getDamageTreeNodesRecurse(IAstNode tree, List<IAstNode> results) {
-		
-		if (tree instanceof Iterable) { // likely a linked list
-			for (Object o : (Iterable<?>) tree) {
-				getDamageTreeNodes((IAstNode) o, results);
-			}
+	private List<IAstNode> getDamagedRegionTreeNodes(IAstNode tree, List<IAstNode> results, boolean isOriginalTree, int skippedChars) {
+		if (!tree.isList() && isDamageTreeNode(tree, isOriginalTree, skippedChars)) {
+			results.add(tree);
 		} else {
-			for (int i = 0, count = tree.getChildCount(); i < count; i++) {
-				getDamageTreeNodes(tree.getChildAt(i), results);
+			// Recurse
+			Iterator<IAstNode> iterator = tryGetListIterator(tree); 
+			for (int i = 0, max = tree.getChildCount(); i < max; i++) {
+				IAstNode child = iterator == null ? tree.getChildAt(i) : iterator.next();
+				getDamagedRegionTreeNodes(child, results, isOriginalTree, skippedChars);
 			}
 		}
+		return results;
 	}
 
 	/**
@@ -96,45 +98,48 @@
 	 * in {@link #incrementalSorts} regardless of whether they own the tokens
 	 * or not.
 	 */
-	private boolean isDamageTreeNode(IAstNode tree) {
-		IToken left = tree.getLeftToken();
-		IToken right = tree.getRightToken();
-		if (left != null && right != null) {
-			int startOffset = left.getStartOffset();
-			int endOffset = right.getEndOffset();
-			
-			if (!isDamagedNonEmptyRange(startOffset, endOffset))
+	protected boolean isDamageTreeNode(IAstNode tree, boolean isOriginalTree, int skippedChars) {
+		IToken current = findLeftMostLayoutToken(tree.getLeftToken());
+		IToken last = findRightMostLayoutToken(tree.getRightToken());
+		if (current != null && last != null) {
+			if (!isDamagedNonEmptyRange(
+					current.getStartOffset(), last.getEndOffset(), isOriginalTree, skippedChars))
 				return false;
 			if (incrementalSorts.contains(tree.getSort()))
 				return true;
-			for (int i = 0, count = tree.getChildCount(); i < count; i++) {
-				IAstNode child = tree.getChildAt(i);
+			Iterator<IAstNode> iterator = tryGetListIterator(tree); 
+			for (int i = 0, max = tree.getChildCount(); i < max; i++) {
+				IAstNode child = iterator == null ? tree.getChildAt(i) : iterator.next();
 				IToken childLeft = child.getLeftToken();
-				IToken childRight = child.getRightToken();
+				IToken childRight = findRightMostLayoutToken(child.getRightToken());
 				if (childLeft != null && childRight != null) {
-					if (isDamagedNonEmptyRange(startOffset, childLeft.getStartOffset() - 1)) {
+					if (childLeft.getIndex() > current.getIndex()
+							&& isDamagedNonEmptyRange(
+									current.getStartOffset(), childLeft.getStartOffset() - 1,
+									isOriginalTree, skippedChars)) {
 						return true;
 					}
-					startOffset = childRight.getEndOffset() + 1;
+					current = childRight;
 				}
 			}
-			return isDamagedNonEmptyRange(startOffset, getLastNonLayoutOffset(tree));
+			return isDamagedNonEmptyRange(
+					current.getEndOffset() + 1, last.getEndOffset(), isOriginalTree, skippedChars);
 		} else {
 			return false;
 		}
 	}
 	
-	private static int getLastNonLayoutOffset(IAstNode tree) {
-		IToken token = tree.getRightToken();
-		ITokenizer tokens = token.getTokenizer();
-		while (token.getKind() == IToken.TK_LAYOUT && token.getIndex() > 0) {
-			token = tokens.getTokenAt(token.getIndex() - 1);
+	private boolean isDamagedNonEmptyRange(int startOffset, int endOffset,
+			boolean isOriginalTree, int skippedChars) {
+		// TODO: get rid of non-empty criterion?? at the very least for empty damage regions...
+		if (isOriginalTree) {
+			return /*endOffset >= startOffset
+				&&*/ isRangeOverlap(damageStart, damageEnd, startOffset, endOffset);
+		} else {
+			return /*endOffset >= startOffset
+				&&*/ isRangeOverlap(damageStart - skippedChars, damageEnd - skippedChars + damageSizeChange,
+						startOffset, endOffset);
 		}
-		return token.getEndOffset();
-	}
-	
-	private boolean isDamagedNonEmptyRange(int startOffset, int endOffset) {
-		return endOffset >= startOffset && isRangeOverlap(damageStart, damageEnd, startOffset, endOffset);
 	}
 	
 	public TNode buildOutput(IAstNode oldTreeNode, List<IAstNode> repairedTreeNodes) {
@@ -147,6 +152,7 @@
 	private TNode buildOutput(IAstNode oldTreeNode, List<IAstNode> repairedTreeNodes,
 			Tokenizer tokenizer) {
 		// TODO: recreate tokens
+
 		IToken leftToken = null;
 		IToken rightToken = null;
 		List<IAstNode> children;
@@ -179,16 +185,12 @@
 		children.addAll(repairedTreeNodes);
 	}
 
-	private static List<IAstNode> copyChildrenToList(IAstNode node) {
-		List<IAstNode> results = new ArrayList<IAstNode>(node.getChildCount());
-		if (node.isList() && node instanceof Iterable) { // likely a linked list
-			for (Object o : ((Iterable<?>) node)) {
-				results.add((IAstNode) o);
-			}
-		} else {
-			for (int i = 0, count = node.getChildCount(); i < count; i++) {
-				results.add(node.getChildAt(i));
-			}
+	private static List<IAstNode> copyChildrenToList(IAstNode tree) {
+		List<IAstNode> results = new ArrayList<IAstNode>(tree.getChildCount());
+		Iterator<IAstNode> iterator = tryGetListIterator(tree); 
+		for (int i = 0, max = tree.getChildCount(); i < max; i++) {
+			IAstNode child = iterator == null ? tree.getChildAt(i) : iterator.next();
+			results.add(child);
 		}
 		return results;
 	}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:05:15 2010	(r21548)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:05:21 2010	(r21549)
@@ -139,6 +139,8 @@
 	public ATerm doParseIncrementalTest(ATerm oldTree, String newFile) throws Exception {
 		String contents = loadAsString(newFile);
 		long parseTime = System.nanoTime();
+		System.out.println("------------------------");
+		System.out.println("Parsing " + newFile);
     	ATerm newTree = (ATerm) incrementalSGLR.parseIncremental(contents, newFile, null, oldTree);
 		parseTime = System.nanoTime() - parseTime;
 		System.out.println("Incremental parsing " + newFile + " took " + parseTime/1000/1000 + " millis.");

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java	Thu Dec 16 15:05:15 2010	(r21548)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java	Thu Dec 16 15:05:21 2010	(r21549)
@@ -2,6 +2,7 @@
 
 import org.spoofax.jsglr.client.InvalidParseTableException;
 import org.spoofax.jsglr.client.ParserException;
+import org.spoofax.jsglr.client.incremental.IncrementalSGLRException;
 import org.spoofax.jsglr.shared.terms.ATerm;
 
 /**
@@ -9,34 +10,70 @@
  */
 public class TestIncrementalSGLR extends ParseTestCase {
 
-	ATerm java5;
+	private static ATerm java4Result, java5Result;
 	
     @Override
 	public void gwtSetUp() throws ParserException, InvalidParseTableException {
-        super.gwtSetUp("Java-15", "java", "MethodDec", "ClassBodyDec");
-    	java5 = doParseTest("java5");
+        super.gwtSetUp("Java-15", "java", "MethodDec", "ClassBodyDec"
+        		// TODO:, "ClassMemberDec"
+        		);
+    }
+    
+    private ATerm getJava4Result() {
+    	if (java4Result == null) java4Result = doParseTest("java4");
+    	return java4Result;
+    }
+    
+    private ATerm getJava5Result() {
+    	if (java5Result == null) java5Result = doParseTest("java5");
+    	return java5Result;
     }
 
     public void testJava51() throws Exception {
-    	doParseIncrementalTest(java5, "java5-increment");
+    	doParseIncrementalTest(getJava5Result(), "java5-increment");
     }
     
     public void testJava52() throws Exception {
-    	doParseIncrementalTest(java5, "java5-increment2");
+    	doParseIncrementalTest(getJava5Result(), "java5-increment2");
     }
     
     public void testJava53() throws Exception {
-    	doParseIncrementalTest(java5, "java5-increment3");
+    	doParseIncrementalTest(getJava5Result(), "java5-increment3");
     }
     
     public void testJava54() throws Exception {
-    	doParseIncrementalTest(java5, "java5-increment4");
+    	doParseIncrementalTest(getJava5Result(), "java5-increment4");
+    }
+    
+    public void testJava55() throws Exception {
+    	doParseIncrementalTest(getJava5Result(), "java5-increment5");
+    }
+    
+    public void testJava56() throws Exception {
+    	try {
+    		doParseIncrementalTest(getJava5Result(), "java5-increment6");
+    	} catch (IncrementalSGLRException e) {
+    		return;
+    	}
+    	fail("Exception expected");
+    }
+    
+    public void testJava57() throws Exception {
+    	doParseIncrementalTest(getJava5Result(), "java5-increment7");
     }
 
     public void testJava4() throws Exception {
-    	ATerm tree1 = doParseTest("java4");
-    	doParseIncrementalTest(tree1, "java4-increment");
-    	// TODO: test doParseIncrementalTest(tree1, "java5-increment");
+    	doParseIncrementalTest(getJava4Result(), "java4-increment");
+    	// TODO: test doParseIncrementalTest(java4, "java5-increment");
+    }
+
+    public void testJava4vs5() throws Exception {
+    	try {
+    		doParseIncrementalTest(getJava4Result(), "java5-increment");
+    	} catch (IncrementalSGLRException e) {
+    		return;
+    	}
+    	fail("Exception expected");
     }
 
 }

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5-increment5.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5-increment5.java	Thu Dec 16 15:05:21 2010	(r21549)
@@ -0,0 +1,6 @@
+package java.java5;
+
+class X {
+  ;
+  void foobaz() {};
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5-increment6.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5-increment6.java	Thu Dec 16 15:05:21 2010	(r21549)
@@ -0,0 +1,7 @@
+package java.java5;
+
+class XY {
+  ;
+  void foo() {}
+  void baz() {}
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5-increment7.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5-increment7.java	Thu Dec 16 15:05:21 2010	(r21549)
@@ -0,0 +1,7 @@
+package java.java5;
+
+class X {void a();
+  ;
+  void foo() {}
+  void baz() {}
+}

From karltk at strategoxt.org  Thu Dec 16 16:05:28 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:05:28 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21550 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt: src/org/spoofax/jsglr/client
	src/org/spoofax/jsglr/client/imploder
	src/org/spoofax/jsglr/client/incremental test/org/spoof...
Message-ID: <201012161505.oBGF5SSn027440@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:05:27 2010
New Revision: 21550
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21550&sc=1

Log:
All incremental parsing tree tests succeeding; now for tokens and perhaps more corner cases.

Added:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParserHistory.java.orig
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5-increment8.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java6-increment.java.recover
Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParserHistory.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/AutoConcatList.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/DummyTokenizer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITokenizer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Tokenizer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalInputBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLRException.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestTokenize.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java6.java.recover

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParserHistory.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParserHistory.java	Thu Dec 16 15:05:21 2010	(r21549)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParserHistory.java	Thu Dec 16 15:05:27 2010	(r21550)
@@ -28,10 +28,10 @@
     
     public ParserHistory(){    
         newLinePoints=new ArrayList<IndentInfo>();        
-        reset();
+        clear();
     }
      
-    private void reset(){
+    public void clear(){
         newLinePoints.clear();
         recoverTokenStream = new char[5000];
         recoverTokenCount = 0;

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParserHistory.java.orig
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParserHistory.java.orig	Thu Dec 16 15:05:27 2010	(r21550)
@@ -0,0 +1,250 @@
+package org.spoofax.jsglr.client;
+
+import java.util.ArrayList;
+
+public class ParserHistory {
+    
+    private final static int MAX_SIZE_NEW_LINE_POINTS = 150;
+    private final static int MIN_SIZE_NEW_LINE_POINTS = 50;
+    private final IndentationHandler indentHandler;
+    private IndentationHandler recoveryIndentHandler;
+    
+    private ArrayList<IndentInfo> newLinePoints;      
+    public char[] recoverTokenStream;
+    private int recoverTokenCount;
+    private int tokenIndex;
+    
+    public int getTokenIndex() {
+        return tokenIndex;
+    }
+    
+    public int getIndexLastToken() {
+        return recoverTokenCount-1;
+    }
+
+    public void setTokenIndex(int tokenIndex) {
+        this.tokenIndex = tokenIndex;
+    }
+    
+    public ParserHistory(){    
+        newLinePoints=new ArrayList<IndentInfo>();  
+        indentHandler = new IndentationHandler();
+        recoveryIndentHandler=new IndentationHandler();      
+        clear();
+    }
+     
+    public void clear(){
+        newLinePoints.clear();
+        recoverTokenStream = new char[5000];
+        recoverTokenCount = 0;
+        tokenIndex=0;
+        //indentHandler.clear();
+        //resetRecoveryIndentHandler(0);
+    }
+    
+    public void resetRecoveryIndentHandler(int indentValue){
+        recoveryIndentHandler=new IndentationHandler();
+        recoveryIndentHandler.setInLeftMargin(true);
+        recoveryIndentHandler.setIndentValue(indentValue);
+    }
+    /*
+     * Set current token of parser based on recover tokens or read from new tokens
+     */
+    public void readRecoverToken(SGLR myParser, boolean keepRecoveredLines) {  
+        if (hasFinishedRecoverTokens() /*) {             
+            if(*/
+        		&& myParser.currentToken!=SGLR.EOF /*){                
+                if(*/ && getIndexLastToken()>=0 && recoverTokenStream[getIndexLastToken()]!=SGLR.EOF){
+                    myParser.readNextToken();
+                    indentHandler.updateIndentation(myParser.currentToken);
+                    keepToken((char)myParser.currentToken);   
+                    if(indentHandler.lineMarginEnded() || myParser.currentToken==SGLR.EOF)
+                        keepNewLinePoint(myParser, myParser.tokensSeen-1, true, indentHandler);
+                /*}
+            }*/
+        }
+        else if(tokenIndex<0 || tokenIndex>recoverTokenCount){
+            myParser.currentToken =SGLR.EOF;
+            System.err.println("Unexpected token index"+tokenIndex);
+        }
+        else{
+            myParser.currentToken = recoverTokenStream[tokenIndex];
+            if(keepRecoveredLines){
+                recoveryIndentHandler.updateIndentation(myParser.currentToken);
+                if(recoveryIndentHandler.lineMarginEnded() || myParser.currentToken==SGLR.EOF)
+                    keepNewLinePoint(myParser, tokenIndex, false, recoveryIndentHandler);
+            }    
+        }
+        tokenIndex++;
+        
+    }
+    
+    public boolean hasFinishedRecoverTokens() {
+        return tokenIndex >= recoverTokenCount;
+    }
+    
+    public int getTokensSeenStartLine(int tokPosition){
+        int tokIndexLine=tokPosition;
+        while (recoverTokenStream[tokIndexLine] != '\n' && tokIndexLine>0) {
+            tokIndexLine-=1;
+        }
+        return tokIndexLine;
+    }
+
+    public void keepTokenAndState(SGLR myParser) {
+        indentHandler.updateIndentation(myParser.currentToken);
+        keepToken((char)myParser.currentToken);
+        tokenIndex++;
+        if(indentHandler.lineMarginEnded() || myParser.currentToken==SGLR.EOF)
+            keepNewLinePoint(myParser, myParser.tokensSeen-1, false, indentHandler);
+    }
+    
+    public void keepInitialState(SGLR myParser) {        
+        IndentInfo newLinePoint= new IndentInfo(0, 0, 0);
+        newLinePoint.fillStackNodes(myParser.activeStacks);
+        newLinePoints.add(newLinePoint);
+    }
+
+    private void keepToken(char currentToken) {
+        if(getIndexLastToken()>0 && recoverTokenStream[getIndexLastToken()]==SGLR.EOF)
+            return;
+        recoverTokenStream[recoverTokenCount++] = currentToken;         
+        if (recoverTokenCount == recoverTokenStream.length) {
+            char[] copy = recoverTokenStream;
+            recoverTokenStream = new char[recoverTokenStream.length * 2];
+            System.arraycopy(copy, 0, recoverTokenStream, 0, copy.length);
+        }
+    }
+    
+    private void keepNewLinePoint(SGLR myParser, int tokSeen ,boolean inRecoverMode, IndentationHandler anIndentHandler) {
+        int indent = anIndentHandler.getIndentValue();
+        IndentInfo newLinePoint= new IndentInfo(myParser.lineNumber, tokSeen, indent);
+        newLinePoints.add(newLinePoint);
+        //System.out.println(newLinePoints.size()-1+" NEWLINE ("+newLinePoint.getIndentValue()+")"+newLinePoint.getTokensSeen());
+        if(!inRecoverMode){
+            newLinePoint.fillStackNodes(myParser.activeStacks);           
+            if(newLinePoints.size()> MAX_SIZE_NEW_LINE_POINTS)
+                removeOldPoints();
+        }
+    }
+    
+    private void removeOldPoints() {        
+        int firstPointIndex = nrOfLines()-MIN_SIZE_NEW_LINE_POINTS;
+        ArrayList<IndentInfo> shrinkedList = new ArrayList<IndentInfo>();
+        shrinkedList.ensureCapacity(newLinePoints.size());
+        shrinkedList.addAll(newLinePoints.subList(firstPointIndex, newLinePoints.size()-1));
+        newLinePoints = shrinkedList;
+    }
+
+    public String getFragment(int startTok, int endTok) {
+        String fragment="";
+        for (int i = startTok; i <= endTok; i++) {
+            if(i >= recoverTokenCount)
+                break;
+            fragment+= recoverTokenStream[i];
+        }        
+        return fragment;
+    }
+    
+    public String getFragment(StructureSkipSuggestion skip) {
+        if(skip.getEndSkip().getTokensSeen() < skip.getStartSkip().getTokensSeen()){
+            System.err.println("Startskip > endskip");
+            //System.err.println(getFragment(skip.getEndSkip().getTokensSeen(), skip.getEndSkip().getTokensSeen()));
+            return "--Wrong Fragment --";
+        }
+        String fragment="";
+        for (int i = skip.getStartSkip().getTokensSeen(); i <= skip.getEndSkip().getTokensSeen()-1; i++) {
+            if(i >= recoverTokenCount)
+                break;
+            fragment+= recoverTokenStream[i];
+        }  
+        String correctedFragment=fragment.substring(skip.getAdditionalTokens().length);
+        return correctedFragment;
+    }
+    
+    public String readLine(int StartTok) {
+        String fragment="";
+        int pos=StartTok;
+        char currentTok=' ';
+        while(currentTok!='\n' && currentTok!=SGLR.EOF && pos<recoverTokenCount) {            
+            currentTok=recoverTokenStream[pos];
+            fragment+= currentTok;
+            pos++;
+        }        
+        return fragment;
+    }
+    
+    private int nrOfLines(){
+        return newLinePoints.size();
+    }
+    
+    public IndentInfo getLine(int index){
+        // FIXME: throw an IndexOutOfBoundsException: this is indicates a programmer error
+        if(index < 0 || index > getIndexLastLine())
+            return null;
+        return newLinePoints.get(index);
+    }
+    
+    public IndentInfo getLastLine(){
+        return newLinePoints.get(newLinePoints.size()-1);
+    }
+    
+    public int getIndexLastLine(){
+        return newLinePoints.size()-1;
+    }
+    
+    public ArrayList<IndentInfo> getLinesFromTo(int startIndex, int endLocation) {
+        int indexLine = startIndex;
+        ArrayList<IndentInfo> result=new ArrayList<IndentInfo>();
+        IndentInfo firstLine = newLinePoints.get(indexLine);
+        while(indexLine < newLinePoints.size()){
+             firstLine = newLinePoints.get(indexLine);
+             if(firstLine.getTokensSeen() < endLocation){
+                 result.add(firstLine);
+                 indexLine++;
+             }
+             else{
+                 indexLine=newLinePoints.size();
+             }
+        }
+        return result;
+    }
+
+    public void deleteLinesFrom(int startIndexErrorFragment) {
+        if(startIndexErrorFragment>=0 && startIndexErrorFragment<newLinePoints.size()-1){
+            ArrayList<IndentInfo> shrinkedList=new ArrayList<IndentInfo>();
+            shrinkedList.addAll(newLinePoints.subList(0, startIndexErrorFragment));
+            newLinePoints=shrinkedList;
+        }
+        else if (startIndexErrorFragment > newLinePoints.size()-1){
+            System.err.println("StartIndex Error Fragment: "+startIndexErrorFragment);
+            System.err.println("Numeber Of Lines in History: : "+newLinePoints.size());
+            System.err.println("Unexpected index of history new-line-points");            
+        }
+    }
+    
+    public void logHistory(){       
+       for (int i = 0; i < newLinePoints.size()-1; i++) {
+           IndentInfo currLine=newLinePoints.get(i);
+           IndentInfo nextLine=newLinePoints.get(i+1);
+           String stackDescription="";
+           for (Frame node : currLine.getStackNodes()) {
+               stackDescription+=node.state.stateNumber+";";
+           }
+           System.out.print("("+i+")"+"["+currLine.getIndentValue()+"]"+"{"+stackDescription+"}"+getFragment(currLine.getTokensSeen(), nextLine.getTokensSeen()-1));
+       }
+       IndentInfo currLine=newLinePoints.get(newLinePoints.size()-1);
+       System.out.print("("+(newLinePoints.size()-1)+")"+"["+currLine.getIndentValue()+"]"+getFragment(currLine.getTokensSeen(), getIndexLastToken()-1));
+
+    }
+
+    public int getLineOfTokenPosition(int tokPos) {        
+        for (int i = 1; i < newLinePoints.size(); i++) {
+            IndentInfo line=newLinePoints.get(i);
+            if(line.getTokensSeen()>tokPos)
+                return i-1;
+        }
+        return newLinePoints.size()-1;
+    }
+    
+}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 15:05:21 2010	(r21549)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Thu Dec 16 15:05:27 2010	(r21550)
@@ -180,9 +180,6 @@
 		forActorDelayed = new ArrayDeque<Frame>();
 		forShifter = new ArrayDeque<ActionState>();
 
-		// FIXME This is *wrong*: need to set the input string size instead
-		ambiguityManager = new AmbiguityManager(10000);
-
 		disambiguator = new Disambiguator();
 		useIntegratedRecovery = false;
 		recoverIntegrator = null;
@@ -282,6 +279,10 @@
 	}
 
 	private void initParseVariables(String filename, String input) {
+		forActor.clear();
+		forActorDelayed.clear();
+		forShifter.clear();
+		history.clear();
 		startFrame = initActiveStacks();
 		tokensSeen = 0;
 		columnNumber = 0;
@@ -292,6 +293,8 @@
 		parseTable.getTreeBuilder().initializeInput(filename, input);
 		PooledPathList.resetPerformanceCounters();
 		PathListPool.resetPerformanceCounters();
+		ambiguityManager = new AmbiguityManager(input.length());
+		
 	}
 
 	private BadTokenException createBadTokenException() {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/AutoConcatList.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/AutoConcatList.java	Thu Dec 16 15:05:21 2010	(r21549)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/AutoConcatList.java	Thu Dec 16 15:05:27 2010	(r21550)
@@ -22,6 +22,8 @@
 	private static final int INITIAL_LIST_SIZE = 10;
 	
 	private final String sort;
+
+	private IToken emptyListToken;
 	
 	/** The inner list value, if there is only one value. */
 	private E node;
@@ -31,12 +33,21 @@
 	
 	public AutoConcatList(String sort) {
 		this.sort = sort;
+		this.emptyListToken = emptyListToken;
 	}
 	
 	public String getSort() {
 		return sort;
 	}
 	
+	public IToken getEmptyListToken() {
+		return emptyListToken;
+	}
+	
+	public void setEmptyListToken(IToken emptyListToken) {
+		this.emptyListToken = emptyListToken;
+	}
+	
 	private ArrayList<E> asList() {
 		if (node != null) {
 			nodes = new ArrayList<E>(INITIAL_LIST_SIZE);

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/DummyTokenizer.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/DummyTokenizer.java	Thu Dec 16 15:05:21 2010	(r21549)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/DummyTokenizer.java	Thu Dec 16 15:05:27 2010	(r21550)
@@ -48,23 +48,23 @@
 		return onlyToken;
 	}
 
-	public IToken makeToken(int offset, LabelInfo label) {
+	public IToken makeToken(int endOffset, LabelInfo label) {
 		return onlyToken;
 	}
 
-	public IToken makeToken(int offset, LabelInfo label, boolean allowEmptyToken) {
+	public IToken makeToken(int endOffset, LabelInfo label, boolean allowEmptyToken) {
 		return onlyToken;
 	}
 
-	public IToken makeToken(int offset, int kind, boolean allowEmptyToken) {
+	public IToken makeToken(int endOffset, int kind, boolean allowEmptyToken) {
 		return onlyToken;
 	}
 
-	public void makeErrorToken(int offset) {
+	public void makeErrorToken(int endOffset) {
 		// Do nothing
 	}
 
-	public void makeLayoutToken(int offset, int lastOffset, LabelInfo label) {
+	public void makeLayoutToken(int endOffset, int lastOffset, LabelInfo label) {
 		// Do nothing
 	}
 	

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITokenizer.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITokenizer.java	Thu Dec 16 15:05:21 2010	(r21549)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITokenizer.java	Thu Dec 16 15:05:27 2010	(r21550)
@@ -19,9 +19,9 @@
 
 	IToken getTokenAt(int i);
 
-	IToken makeToken(int offset, LabelInfo label, boolean allowEmptyToken);
+	IToken makeToken(int endOffset, LabelInfo label, boolean allowEmptyToken);
 
-	IToken makeToken(int offset, int kind, boolean allowEmptyToken);
+	IToken makeToken(int endOffset, int kind, boolean allowEmptyToken);
 
 	/**
 	 * Creates artificial token at keyword boundaries
@@ -32,13 +32,13 @@
 	 * @param offset
 	 *           The offset of the 
 	 */
-	void makeErrorToken(int offset);
+	void makeErrorToken(int endOffset);
 
 	/**
 	 * Creates an artificial token for every water-based recovery
 	 * and for comments within layout.
 	 */
-	void makeLayoutToken(int offset, int lastOffset, LabelInfo label);
+	void makeLayoutToken(int endOffset, int lastOffset, LabelInfo label);
 
 	String toString(IToken left, IToken right);
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Tokenizer.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Tokenizer.java	Thu Dec 16 15:05:21 2010	(r21549)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Tokenizer.java	Thu Dec 16 15:05:27 2010	(r21550)
@@ -4,7 +4,7 @@
 import static org.spoofax.jsglr.client.imploder.IToken.TK_ERROR;
 import static org.spoofax.jsglr.client.imploder.IToken.TK_ERROR_KEYWORD;
 import static org.spoofax.jsglr.client.imploder.IToken.TK_LAYOUT;
-import static org.spoofax.jsglr.client.imploder.IToken.TK_RESERVED;
+import static org.spoofax.jsglr.client.imploder.IToken.*;
 
 import java.util.ArrayList;
 import java.util.Iterator;
@@ -17,7 +17,7 @@
  */
 public class Tokenizer implements ITokenizer {
 	
-	private static final int EXPECTED_TOKENS_DIVIDER = 5;
+	private static final double EXPECTED_TOKENS_DIVIDER = 1.3;
 	
 	private final KeywordRecognizer keywords;
 	
@@ -46,7 +46,7 @@
 		this.keywords = keywords;
 		this.filename = filename;
 		this.input = input;
-		this.tokens = new ArrayList<IToken>(input.length() / EXPECTED_TOKENS_DIVIDER);
+		this.tokens = new ArrayList<IToken>((int) (input.length() / EXPECTED_TOKENS_DIVIDER));
 		startOffset = 0;
 		line = 0;
 		offsetAtLineStart = 0;
@@ -107,8 +107,9 @@
 		}
 		
 		if (token == null || offset <= endOffset) {
+			int oldStartOffset = startOffset;
 			token = internalMakeToken(kind, offset);
-			if (input.charAt(offset) == '\n') {
+			if (offset >= oldStartOffset && input.charAt(offset) == '\n') {
 				line++;
 				offsetAtLineStart = startOffset;
 			}
@@ -177,82 +178,58 @@
 	 * Creates an artificial token for every water-based recovery
 	 * and for comments within layout.
 	 */
-	public void makeLayoutToken(int offset, int lastOffset, LabelInfo label) {
+	public void makeLayoutToken(int endOffset, int lastOffset, LabelInfo label) {
 		// Create separate tokens for >1 char layout lexicals (e.g., comments)
-		if (offset > lastOffset + 1 && label.isLexLayout()) {
+		if (endOffset > lastOffset + 1 && label.isLexLayout()) {
 			if (startOffset <= lastOffset)
 				makeToken(lastOffset, TK_LAYOUT, false);
-			makeToken(offset, TK_LAYOUT, false);
+			makeToken(endOffset, TK_LAYOUT, false);
 		} else {
 			String sort = label.getSort();
 			if ("WATERTOKEN".equals(sort) || "WATERTOKENSEPARATOR".equals(sort)) {
 				if (getStartOffset() <= lastOffset)
 					makeToken(lastOffset, TK_LAYOUT, false);
-				makeToken(offset, TK_ERROR, false);
+				makeToken(endOffset, TK_ERROR, false);
 			}
 		}
 	}
 	
 	/**
 	 * Searches towards the left of the given token for the
-	 * leftmost layout token, returning the current token if
+	 * leftmost layout or error token, returning the current token if
 	 * no layout token is found.
 	 */
 	public static IToken findLeftMostLayoutToken(IToken token) {
 		if (token == null) return null;
 		ITokenizer tokens = token.getTokenizer();
-		for (int i = token.getIndex() - 1; i >= 0; i++) {
-			if (token.getKind() == IToken.TK_LAYOUT)
-				break;
-			token = tokens.getTokenAt(i);
-		}
-		return token;
-	}
-	
-	/**
-	 * Searches towards the left of the given token for the
-	 * leftmost non-layout token, returning the current token if
-	 * no non-layout token is found.
-	 */
-	public static IToken findLeftMostNonLayoutToken(IToken token) {
-		if (token == null) return null;
-		ITokenizer tokens = token.getTokenizer();
-		for (int i = token.getIndex() - 1; i >= 0; i++) {
-			if (token.getKind() != IToken.TK_LAYOUT)
-				break;
-			token = tokens.getTokenAt(i);
+	loop:
+		for (int i = token.getIndex() - 1; i >= 0; i--) {
+			IToken neighbour = tokens.getTokenAt(i);
+			switch (neighbour.getKind()) {
+				case TK_LAYOUT: case TK_ERROR: case TK_ERROR_KEYWORD: break;
+				default: break loop;
+			}
+			token = neighbour;
 		}
 		return token;
 	}
 	
 	/**
 	 * Searches towards the right of the given token for the
-	 * rightmost layout token, returning the current token if
+	 * rightmost layout or error token, returning the current token if
 	 * no layout token is found.
 	 */
 	public static IToken findRightMostLayoutToken(IToken token) {
 		if (token == null) return null;
 		ITokenizer tokens = token.getTokenizer();
+	loop:
 		for (int i = token.getIndex() + 1, count = tokens.getTokenCount(); i < count; i++) {
-			if (token.getKind() == IToken.TK_LAYOUT)
-				break;
-			token = tokens.getTokenAt(i);
-		}
-		return token;
-	}
-	
-	/**
-	 * Searches towards the right of the given token for the
-	 * rightmost non-layout token, returning the current token if
-	 * no non-layout token is found.
-	 */
-	public static IToken findRightMostNonLayoutToken(IToken token) {
-		if (token == null) return null;
-		ITokenizer tokens = token.getTokenizer();
-		for (int i = token.getIndex() + 1, count = tokens.getTokenCount(); i < count; i++) {
-			if (token.getKind() != IToken.TK_LAYOUT)
-				break;
-			token = tokens.getTokenAt(i);
+			IToken neighbour = tokens.getTokenAt(i);
+			switch (neighbour.getKind()) {
+				case TK_LAYOUT: case TK_ERROR: case TK_ERROR_KEYWORD: break;
+				default: break loop;
+			}
+			token = neighbour;
 		}
 		return token;
 	}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java	Thu Dec 16 15:05:21 2010	(r21549)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java	Thu Dec 16 15:05:27 2010	(r21550)
@@ -1,6 +1,7 @@
 package org.spoofax.jsglr.client.imploder;
 
 import static java.lang.Math.max;
+import static org.spoofax.jsglr.client.imploder.IToken.TK_EOF;
 import static org.spoofax.jsglr.client.imploder.IToken.TK_ERROR_EOF_UNEXPECTED;
 
 import java.util.ArrayList;
@@ -108,12 +109,28 @@
 	@Override
 	public Object buildTreeTop(Object subtree, int ambiguityCount) {
 		try {
-			return tryBuildAutoConcatListNode(subtree);
+			Object tree = tryBuildAutoConcatListNode(subtree);
+			tree = recreateWithAllTokens(tree);
+			tokenizer.makeToken(tokenizer.getStartOffset() - 1, TK_EOF, true);
+			return tree;
 		} finally {
 			offset = 0;
 			inLexicalContext = false;
 		}
 	}
+
+	/**
+	 * Recreates a tree node, changing its begin and end token
+	 * to the begin and end token of the entire token stream.
+	 */
+	private Object recreateWithAllTokens(Object tree) {
+		List<Object> children = new ArrayList<Object>();
+		for (Object child : factory.getChildren(tree))
+			children.add(child);
+		tree = factory.recreateNode(tree, tokenizer.getTokenAt(0),
+				tokenizer.currentToken(), children);
+		return tree;
+	}
 	
 	/**
 	 * Given a {@link ParseNode}, builds a tree node using the
@@ -139,8 +156,6 @@
 			}
 		}
 		
-		// TODO: Optimize - one particularly gnarly optimization would be to reuse the subnodes array here
-		//                  and in buildTreeAmb
 		List<Object> children = null;
 		if (!inLexicalContext) {
 			if (isList) {
@@ -161,6 +176,11 @@
 			}
 		}
 		
+		if (!inLexicalContext && isList && children.isEmpty()) {
+			IToken token = tokenizer.makeToken(tokenizer.getStartOffset() - 1, IToken.TK_LAYOUT, true);
+			((AutoConcatList) children).setEmptyListToken(token);
+		}
+		
 		if (lexicalStart) {
 			return tryCreateStringTerminal(label);
 		} else if (inLexicalContext) {
@@ -229,8 +249,8 @@
 	 * {@link ITreeFactory}.
 	 */
 	public Object buildAutoConcatListNode(AutoConcatList list) {
-		IToken left = list.isEmpty() ? null : factory.getLeftToken(list.get(0));
-		IToken right = list.isEmpty() ? null : factory.getRightToken(list.get(list.size() - 1));
+		IToken left = list.isEmpty() ? list.getEmptyListToken() : factory.getLeftToken(list.get(0));
+		IToken right = list.isEmpty() ? list.getEmptyListToken() : factory.getRightToken(list.get(list.size() - 1));
 		return factory.createList(list.getSort(), left, right, list);
 	}
 
@@ -328,6 +348,15 @@
 			return factory.createNonTerminal(label.getSort(), constructor, left, right, children);
 		}
 	}
+
+	/** Implode a context-free node with an {ast} annotation. */
+	private Object createAstNonTerminal(LabelInfo label, IToken prevToken, List<Object> children) {
+		IToken left = getStartToken(prevToken);
+		// IToken right = getEndToken(left, tokenizer.currentToken());
+		IToken right = tokenizer.currentToken();
+		AstAnnoImploder imploder = new AstAnnoImploder<Object>(factory, termFactory, children, left, right);
+		return imploder.implode(label.getAstAttribute(), label.getSort());
+	}
 	
 	/**
 	 * Gets the padded lexical value for {indentpadding} lexicals, or returns null.
@@ -356,14 +385,6 @@
 			return startToken.toString(); // lazily load token string value
 		}
 	}
-
-	/** Implode a context-free node with an {ast} annotation. */
-	private Object createAstNonTerminal(LabelInfo label, IToken prevToken, List<Object> children) {
-		IToken left = getStartToken(prevToken);
-		IToken right = getEndToken(left, tokenizer.currentToken());
-		AstAnnoImploder imploder = new AstAnnoImploder<Object>(factory, termFactory, children, left, right);
-		return imploder.implode(label.getAstAttribute(), label.getSort());
-	}
 	
 	/** Get the token after the previous node's ending token, or null if N/A. */
 	private IToken getStartToken(IToken prevToken) {
@@ -384,8 +405,11 @@
 		}
 	}
 	
-	/** Get the last no-layout token for an AST node. */
+	/* Get the last no-layout token for an AST node.
 	private IToken getEndToken(IToken currentToken, IToken lastToken) {
+		if (lastToken.getEndOffset() == tokenizer.getInput().length() - 1)
+			return lastToken;
+
 		int begin = currentToken.getIndex();
 		
 		for (int i = lastToken.getIndex(); i > begin; i--) {
@@ -397,6 +421,7 @@
 		
 		return lastToken;
 	}
+	*/
 	
 	/** Consume a character of a lexical terminal. */
 	protected final void consumeLexicalChar(int character) {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalInputBuilder.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalInputBuilder.java	Thu Dec 16 15:05:21 2010	(r21549)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalInputBuilder.java	Thu Dec 16 15:05:27 2010	(r21550)
@@ -23,7 +23,7 @@
 	
 	private final Set<String> incrementalSorts;
 	
-	private final String input;
+	private final String newInput;
 
 	@SuppressWarnings("unused") // for debugging
 	private final String oldInput;
@@ -41,7 +41,9 @@
 	
 	private boolean isDamagePrinted;
 	
-	private int skippedChars;
+	private int skippedCharsBeforeDamage;
+	
+	private int skippedCharsAfterDamage;
 
 	/**
 	 * @param incrementalSorts
@@ -51,7 +53,7 @@
 	public IncrementalInputBuilder(Set<String> incrementalSorts, String input, String oldInput,
 			int damageStart, int damageEnd, int damageSizeChange) {
 		this.incrementalSorts = incrementalSorts;
-		this.input = input;
+		this.newInput = input;
 		this.oldInput = oldInput;
 		this.damageEnd = damageEnd;
 		this.damageStart = damageStart;
@@ -60,9 +62,11 @@
 
 	public String buildPartialInput(IAstNode oldTree) throws IncrementalSGLRException {
 		isSkipping = isDamagePrinted = false;
-		skippedChars = 0;
-		appendTree(oldTree);
+		skippedCharsAfterDamage = skippedCharsBeforeDamage = 0;
+		StringBuilder result = appendTree(oldTree);
 		try {
+			assert result.length() ==
+				newInput.length() - skippedCharsBeforeDamage - skippedCharsAfterDamage; 
 			return result.toString();
 		} finally {
 			if (DEBUG) System.out.println();
@@ -74,11 +78,11 @@
 	 * that were in the original input string but not in 
 	 * the last incremental input string built by this instance.
 	 */
-	public int getLastSkippedChars() {
-		return skippedChars;
+	public int getLastSkippedCharsBeforeDamage() {
+		return skippedCharsBeforeDamage;
 	}
 
-	private void appendTree(IAstNode oldTree) throws IncrementalSGLRException {
+	private StringBuilder appendTree(IAstNode oldTree) throws IncrementalSGLRException {
 		IToken left = oldTree.getLeftToken();
 		IToken right = oldTree.getRightToken();
 		int startOffset = 0;
@@ -112,6 +116,7 @@
 		}
 		
 		if (isSkippingStart) isSkipping = false;
+		return result;
 	}
 	
 	/**
@@ -121,6 +126,7 @@
 	 * or merged with the damaged region as necessary.
 	 */
 	private void appendToken(int startOffset, int endOffset) {
+		// TODO: optimize - skip TK_LAYOUT tokens
 		if (isDamagePrinted /* startOffset >= damageStart */) {
 			assert startOffset >= damageStart;
 			if (endOffset > damageEnd) {
@@ -161,18 +167,20 @@
 	private void internalAppendSubstring(int startIndex, int endIndex) {
 		if (isSkipping) {
 			for (int i = startIndex; i < endIndex; i++) {
-				// if (DEBUG) System.out.print(input.charAt(i) == '\n' ? "\n" : "-" + input.charAt(i));
-				if (input.charAt(i) == '\n') {
+				// if (DEBUG) System.out.print(newInput.charAt(i) == '\n' ? "\n" : "-" + newInput.charAt(i));
+				if (newInput.charAt(i) == '\n') {
 					result.append('\n');
 				} else if (INSERT_WHITESPACE) {
 					result.append(' ');
 				} else if (i < damageStart) {
-					skippedChars++;
+					skippedCharsBeforeDamage++;
+				} else {
+					skippedCharsAfterDamage++;
 				}
 			}
 		} else {
-			if (DEBUG) System.out.print(input.substring(startIndex, endIndex));
-			result.append(input, startIndex, endIndex);
+			if (DEBUG) System.out.print(newInput.substring(startIndex, endIndex));
+			result.append(newInput, startIndex, endIndex);
 		}
 	}
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java	Thu Dec 16 15:05:21 2010	(r21549)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java	Thu Dec 16 15:05:27 2010	(r21550)
@@ -7,12 +7,11 @@
 import java.util.List;
 import java.util.Set;
 
-import org.spoofax.jsglr.client.ITreeBuilder;
+import org.spoofax.jsglr.client.NotImplementedException;
 import org.spoofax.jsglr.client.ParseException;
 import org.spoofax.jsglr.client.SGLR;
 import org.spoofax.jsglr.client.imploder.IAstNode;
 import org.spoofax.jsglr.client.imploder.ITreeFactory;
-import org.spoofax.jsglr.client.imploder.TreeBuilder;
 import org.spoofax.jsglr.shared.BadTokenException;
 import org.spoofax.jsglr.shared.SGLRException;
 import org.spoofax.jsglr.shared.TokenExpectedException;
@@ -39,16 +38,15 @@
 	 *            Sorts that can be incrementally parsed (e.g., MethodDec, ImportDec).
 	 *            *Must* be sorts that only occur in lists (such as MethodDec*).
 	 */
-	public IncrementalSGLR(SGLR parser, ITreeBuilder builder, ITreeFactory<TNode> factory, Set<String> incrementalSorts) {
+	public IncrementalSGLR(SGLR parser, ITreeFactory<TNode> factory, Set<String> incrementalSorts,
+			boolean includeInjections) {
 		this.parser = parser;
 		this.factory = factory;
 		this.incrementalSorts = incrementalSorts;
-		parser.setTreeBuilder(builder);
-		assert !(builder instanceof TreeBuilder)
-			|| ((TreeBuilder) builder).getFactory().getClass() == factory.getClass();
 		
 		// TODO: support injection sorts in incrementalSorts
 		//       (using injection prods in parse table; build some class like KeywordRecognizer)
+		if (includeInjections) throw new NotImplementedException("includeInjections"); 
 	}
 	
 	/**
@@ -77,8 +75,6 @@
 			throws TokenExpectedException, BadTokenException, ParseException, SGLRException, IncrementalSGLRException {
 		
 		String oldInput = oldTree.getLeftToken().getTokenizer().getInput();
-		//oldInput = "{old}{old}";
-		//newInput = "{old}{old}{NEW}}";
 		int damageStart = getDamageStart(newInput, oldInput);
 		int damageSizeChange = newInput.length() - oldInput.length();
 		int damageEnd = getDamageEnd(newInput, oldInput, damageStart, damageSizeChange);
@@ -99,13 +95,14 @@
 		sanityCheckOldTree(oldTree, treeBuilder.getDamagedTreeNodes(oldTree));
 
 		String partialInput = inputBuilder.buildPartialInput(oldTree);
+		int skippedChars = inputBuilder.getLastSkippedCharsBeforeDamage();
 		IAstNode partialTree = (IAstNode) parser.parse(partialInput, startSymbol);
 		
-		List<IAstNode> repairedTreeNodes = treeBuilder.getRepairedTreeNodes(partialTree, inputBuilder.getLastSkippedChars());
+		List<IAstNode> repairedTreeNodes = treeBuilder.getRepairedTreeNodes(partialTree, skippedChars);
 		lastRepairedTreeNodesCount = repairedTreeNodes.size();
 		sanityCheckRepairedTree(repairedTreeNodes);
 
-		return treeBuilder.buildOutput(oldTree, repairedTreeNodes);
+		return treeBuilder.buildOutput(oldTree, repairedTreeNodes, skippedChars);
 	}
 	
 	/**

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLRException.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLRException.java	Thu Dec 16 15:05:21 2010	(r21549)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLRException.java	Thu Dec 16 15:05:27 2010	(r21550)
@@ -28,7 +28,7 @@
 
 	public IncrementalSGLRException(String message, Throwable cause) {
 		super(message, cause);
-		if (DEBUG) System.err.println(message);
+		if (DEBUG) System.out.println(message);
 	}
 
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java	Thu Dec 16 15:05:21 2010	(r21549)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java	Thu Dec 16 15:05:27 2010	(r21550)
@@ -4,6 +4,7 @@
 import static org.spoofax.jsglr.client.imploder.Tokenizer.findRightMostLayoutToken;
 import static org.spoofax.jsglr.client.incremental.IncrementalSGLR.isRangeOverlap;
 import static org.spoofax.jsglr.client.incremental.IncrementalSGLR.tryGetListIterator;
+import static org.spoofax.jsglr.client.imploder.IToken.TK_EOF;
 
 import java.util.ArrayList;
 import java.util.Iterator;
@@ -43,6 +44,8 @@
 	private final int damageEnd;
 	
 	private final int damageSizeChange;
+	
+	private boolean isRepairedNodesInserted;
 
 	/**
 	 * @param incrementalSorts
@@ -110,7 +113,7 @@
 			Iterator<IAstNode> iterator = tryGetListIterator(tree); 
 			for (int i = 0, max = tree.getChildCount(); i < max; i++) {
 				IAstNode child = iterator == null ? tree.getChildAt(i) : iterator.next();
-				IToken childLeft = child.getLeftToken();
+				IToken childLeft = findLeftMostLayoutToken(child.getLeftToken());
 				IToken childRight = findRightMostLayoutToken(child.getRightToken());
 				if (childLeft != null && childRight != null) {
 					if (childLeft.getIndex() > current.getIndex()
@@ -142,47 +145,58 @@
 		}
 	}
 	
-	public TNode buildOutput(IAstNode oldTreeNode, List<IAstNode> repairedTreeNodes) {
+	public TNode buildOutput(IAstNode oldTreeNode, List<IAstNode> repairedTreeNodes, int skippedChars) 
+			throws IncrementalSGLRException {
+		isRepairedNodesInserted = false;
 		Tokenizer tokenizer =
 			new Tokenizer(parser.getParseTable().getKeywordRecognizer(), filename, input);
-		return buildOutput(oldTreeNode, repairedTreeNodes, tokenizer);
+		TNode result = buildOutputSubtree(oldTreeNode, repairedTreeNodes, skippedChars, tokenizer);
+		if (!isRepairedNodesInserted)
+			throw new IncrementalSGLRException("Postcondition failed: unable to insert repaired tree nodes in original tree: " + repairedTreeNodes);
+		tokenizer.makeToken(tokenizer.getStartOffset() - 1, TK_EOF, true);
+		return result;
 	}
 	
 	@SuppressWarnings("unchecked")
-	private TNode buildOutput(IAstNode oldTreeNode, List<IAstNode> repairedTreeNodes,
-			Tokenizer tokenizer) {
+	private TNode buildOutputSubtree(IAstNode oldTreeNode, List<IAstNode> repairedTreeNodes,
+			int skippedChars, Tokenizer tokenizer) {
 		// TODO: recreate tokens
 
-		IToken leftToken = null;
-		IToken rightToken = null;
+		IToken leftToken = tokenizer.currentToken();
 		List<IAstNode> children;
 		if (oldTreeNode.isList() && incrementalSorts.contains(oldTreeNode.getElementSort())) {
 			List<IAstNode> oldChildren = copyChildrenToList(oldTreeNode);
 			children = new ArrayList<IAstNode>(oldTreeNode.getChildCount() + repairedTreeNodes.size());
-			boolean addedNewChildren = false;
 			for (IAstNode oldChild : oldChildren) {
-				if (!addedNewChildren && oldChild.getRightToken().getEndOffset() >= damageStart) {
-					addedNewChildren = true;
-					insertDamagedNodes(oldTreeNode, repairedTreeNodes, tokenizer, children);
+				if (!isRepairedNodesInserted && oldChild.getRightToken().getEndOffset() >= damageStart) {
+					insertRepairedNodes(oldTreeNode, repairedTreeNodes, tokenizer, children);
 				}
-				children.add(oldChild);
+				children.add(buildOutputSubtree(oldChild, repairedTreeNodes, skippedChars, tokenizer));
+			}
+			IToken endToken = Tokenizer.findRightMostLayoutToken(oldTreeNode.getRightToken());
+			if (!isRepairedNodesInserted && endToken.getEndOffset() >= damageStart - skippedChars) {
+				insertRepairedNodes(oldTreeNode, repairedTreeNodes, tokenizer, children);
 			}
-			if (!addedNewChildren && oldTreeNode.getRightToken().getEndOffset() + NEXT_CHAR >= damageStart)
-				insertDamagedNodes(oldTreeNode, repairedTreeNodes, tokenizer, children);
 		} else {
 			children = copyChildrenToList(oldTreeNode);
 			for (int i = 0; i < children.size(); i++) {
-				children.set(i, buildOutput(children.get(i), repairedTreeNodes, tokenizer));
+				children.set(i, buildOutputSubtree(children.get(i), repairedTreeNodes, skippedChars, tokenizer));
 			}
 		}
-		return factory.recreateNode((TNode) oldTreeNode, leftToken, rightToken, (List<TNode>) children);
+		return factory.recreateNode((TNode) oldTreeNode, null, null, /*leftToken, tokenizer.currentToken()*/ (List<TNode>) children);
 	}
 
-	private void insertDamagedNodes(IAstNode oldTreeNode, List<IAstNode> repairedTreeNodes,
+	private void insertRepairedNodes(IAstNode oldTreeNode, List<IAstNode> repairedTreeNodes,
 			Tokenizer tokenizer, List<IAstNode> children) {
 		
+		isRepairedNodesInserted = true;
+
 		// TODO: recreate tokens
-		children.addAll(repairedTreeNodes);
+		for (IAstNode node : repairedTreeNodes) {
+			// List<IAstNode> children = copy
+			// factory.recreateNode((TNode) oldTreeNode, leftToken, tokenizer.currentToken(), children)
+			children.add(node);
+		}
 	}
 
 	private static List<IAstNode> copyChildrenToList(IAstNode tree) {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:05:21 2010	(r21549)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:05:27 2010	(r21550)
@@ -13,7 +13,6 @@
 import junit.framework.TestCase;
 
 import org.spoofax.jsglr.FileTools;
-import org.spoofax.jsglr.client.ITreeBuilder;
 import org.spoofax.jsglr.client.InvalidParseTableException;
 import org.spoofax.jsglr.client.ParseTable;
 import org.spoofax.jsglr.client.ParserException;
@@ -84,7 +83,7 @@
 			Set<String> sorts = new HashSet<String>();
 	    	for (String sort : incrementalSorts)
 	    		sorts.add(sort);
-	    	incrementalSGLR = new IncrementalSGLR<ATerm>(sglr, builder, factory, sorts);
+	    	incrementalSGLR = new IncrementalSGLR<ATerm>(sglr, factory, sorts, false);
 		}
 	}
 
@@ -110,7 +109,7 @@
 		//			@Override
 		//			public void onSuccess(String result) {
 		final String result = loadAsString(s);
-		assertNotNull("Data file is missing", result);
+		assertNotNull("Data file is missing: " + s, result);
 		long parseTime = System.nanoTime();
 		ATerm parsed = null;
 		try {
@@ -146,13 +145,17 @@
 		System.out.println("Incremental parsing " + newFile + " took " + parseTime/1000/1000 + " millis.");
 		String extension =
 			table.getTreeBuilder() instanceof TreeBuilder ? ".itrm" : ".trm";
-		final String x = FileTools.loadFileAsString("tests/data/" + newFile + extension);
-		final ATerm wanted = newTree.getFactory().parse(x);
-		System.out.println(newTree.toString(8));
-		System.out.println(wanted.toString(8));
-    	if (!newTree.simpleMatch(wanted)) {
-    		fail();
-    	}
+		if (doCompare) {
+			final String x = FileTools.loadFileAsString("tests/data/" + newFile + extension);
+			assertNotNull("Data file is missing: " + newFile + extension, x);
+			final ATerm wanted = newTree.getFactory().parse(x);
+			System.out.println(newTree.toString(8));
+			System.out.println(wanted.toString(8));
+	    	if (!newTree.simpleMatch(wanted))
+	    		fail();
+		} else {
+			System.out.println(newTree.toString(8));
+		}
     	return newTree;
 	}
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java	Thu Dec 16 15:05:21 2010	(r21549)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java	Thu Dec 16 15:05:27 2010	(r21550)
@@ -2,6 +2,7 @@
 
 import org.spoofax.jsglr.client.InvalidParseTableException;
 import org.spoofax.jsglr.client.ParserException;
+import org.spoofax.jsglr.client.incremental.IncrementalSGLR;
 import org.spoofax.jsglr.client.incremental.IncrementalSGLRException;
 import org.spoofax.jsglr.shared.terms.ATerm;
 
@@ -15,8 +16,10 @@
     @Override
 	public void gwtSetUp() throws ParserException, InvalidParseTableException {
         super.gwtSetUp("Java-15", "java", "MethodDec", "ClassBodyDec"
-        		// TODO:, "ClassMemberDec"
+        		, "ClassMemberDec", "ConstrDec", "FieldDec"
         		);
+        assertTrue("Java -ea assertions must be enabled for these tests",
+        		IncrementalSGLR.class.desiredAssertionStatus());
     }
     
     private ATerm getJava4Result() {
@@ -61,6 +64,15 @@
     public void testJava57() throws Exception {
     	doParseIncrementalTest(getJava5Result(), "java5-increment7");
     }
+    
+    public void testJava58() throws Exception {
+    	try {
+    		doParseIncrementalTest(getJava5Result(), "java5-increment8");
+    	} catch (IncrementalSGLRException e) {
+    		return;
+    	}
+    	fail("Exception expected");
+    }
 
     public void testJava4() throws Exception {
     	doParseIncrementalTest(getJava4Result(), "java4-increment");
@@ -75,5 +87,15 @@
     	}
     	fail("Exception expected");
     }
+    
+    public void testJava6Recovery() throws Exception {
+    	suffix = "java.recover";
+    	sglr.setUseStructureRecovery(true);
+    	doCompare = false;
+    	ATerm java6 = doParseTest("java6");
+    	ATerm java61 = doParseIncrementalTest(java6, "java6-increment");
+    	assertFalse(java6.toString().contains("baz"));
+    	assertTrue(java61.toString().contains("baz"));
+    }
 
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestTokenize.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestTokenize.java	Thu Dec 16 15:05:21 2010	(r21549)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestTokenize.java	Thu Dec 16 15:05:27 2010	(r21550)
@@ -29,23 +29,34 @@
     	System.out.println(tokenizer);
     	
     	assertEquals(0, tokens.next().getLine());
-    	IToken packageToken = tokens.next();
+    	IToken packageToken = getNonEmptyToken(tokens);
+    	assertEquals("package", packageToken.toString());
     	assertEquals("package", packageToken.toString());
     	assertEquals(0, packageToken.getLine());
-    	assertEquals(" ", tokens.next().toString());
-    	assertEquals("java", tokens.next().toString());
-    	assertEquals(".", tokens.next().toString());
-    	assertEquals("java5", tokens.next().toString());
-    	assertEquals(";", tokens.next().toString());
-    	assertEquals("\n", tokens.next().toString());
-    	assertEquals("\n", tokens.next().toString());
-    	IToken classToken = tokens.next();
-    	IToken classToken2 = tokens.next();
+    	assertEquals(" ", getNonEmptyToken(tokens).toString());
+    	assertEquals("java", getNonEmptyToken(tokens).toString());
+    	assertEquals(".", getNonEmptyToken(tokens).toString());
+    	assertEquals("java5", getNonEmptyToken(tokens).toString());
+    	assertEquals(";", getNonEmptyToken(tokens).toString());
+    	assertEquals("\n", getNonEmptyToken(tokens).toString());
+    	assertEquals("\n", getNonEmptyToken(tokens).toString());
+    	IToken classToken = getNonEmptyToken(tokens);
+    	IToken classToken2 = getNonEmptyToken(tokens);
     	System.out.println(classToken2.getLine());
     	assertEquals("class", classToken.toString());
     	assertEquals(IToken.TK_KEYWORD, classToken.getKind());
     	assertEquals(2, classToken.getLine());
+    	assertEquals(7, tokenizer.getTokenAt(tokenizer.getTokenCount() - 1).getLine());
     }
+
+	private static IToken getNonEmptyToken(Iterator<IToken> tokens) {
+		IToken token;
+		do {
+			token = tokens.next();
+		} while (token.getEndOffset() < token.getStartOffset());
+		return token;
+		
+	}
     
     public void testJava6() throws FileNotFoundException, IOException {
     	suffix = "java.recover";
@@ -54,18 +65,18 @@
     	Iterator<IToken> tokens = tokenizer.iterator();
     	System.out.println(tokenizer);
     	
-    	while (!tokens.next().toString().equals("the"));
+    	while (!getNonEmptyToken(tokens).toString().equals("the"));
     	
-    	IToken token = tokens.next();
+    	IToken token = getNonEmptyToken(tokens);
     	assertEquals(" ", token.toString());
     	assertEquals(IToken.TK_ERROR, token.getKind());
-    	token = tokens.next();
+    	token = getNonEmptyToken(tokens);
     	assertEquals("int", token.toString());
     	assertEquals(IToken.TK_ERROR_KEYWORD, token.getKind());
-    	token = tokens.next();
+    	token = getNonEmptyToken(tokens);
     	assertEquals(" ", token.toString());
     	assertEquals(IToken.TK_ERROR, token.getKind());
-    	token = tokens.next();
+    	token = getNonEmptyToken(tokens);
     	assertEquals("bar", token.toString());
     	assertEquals(IToken.TK_ERROR, token.getKind());
     }

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5-increment8.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java5-increment8.java	Thu Dec 16 15:05:27 2010	(r21550)
@@ -0,0 +1,7 @@
+package java.java5;
+
+class X  {
+  ;
+  void foo() {}
+  void baz() {}
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java6-increment.java.recover
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java6-increment.java.recover	Thu Dec 16 15:05:27 2010	(r21550)
@@ -0,0 +1,7 @@
+package java.java6;
+
+class Foo {
+  int foo();
+  the int bar makes no sense
+  int baz();
+}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java6.java.recover
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java6.java.recover	Thu Dec 16 15:05:21 2010	(r21549)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java6.java.recover	Thu Dec 16 15:05:27 2010	(r21550)
@@ -1,5 +1,6 @@
 package java.java6;
 
 class Foo {
+  int foo();
   the int bar makes no sense
 }

From karltk at strategoxt.org  Thu Dec 16 16:05:33 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:05:33 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21551 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr:
	client/incremental shared/terms
Message-ID: <201012161505.oBGF5XC9027443@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:05:32 2010
New Revision: 21551
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21551&sc=1

Log:
cleanup

Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermFactory.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java	Thu Dec 16 15:05:27 2010	(r21550)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java	Thu Dec 16 15:05:32 2010	(r21551)
@@ -22,13 +22,6 @@
  */
 public class IncrementalTreeBuilder<TNode extends IAstNode> {
 	
-	/**
-	 * Allows for one character of extra slack based on the assumption
-	 * that grammars will not have two consecutive IncrementalSort*
-	 * lists.
-	 */
-	private static final int NEXT_CHAR = 1;
-	
 	private final SGLR parser;
 
 	private final String input;

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermFactory.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermFactory.java	Thu Dec 16 15:05:27 2010	(r21550)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermFactory.java	Thu Dec 16 15:05:32 2010	(r21551)
@@ -6,7 +6,6 @@
 import java.util.HashMap;
 import java.util.List;
 
-import org.apache.commons.lang.NullArgumentException;
 import org.spoofax.jsglr.client.NotImplementedException;
 import org.spoofax.jsglr.client.PushbackStringIterator;
 
@@ -299,7 +298,7 @@
 
 	public ATerm parseFromString(String text) {
 		if (text == null)
-			throw new NullArgumentException("text");
+			throw new IllegalArgumentException("text is null");
 		return parseFromStream(new PushbackStringIterator(text));
 	}
 

From karltk at strategoxt.org  Thu Dec 16 16:05:37 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:05:37 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21552 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt:
	src/org/spoofax/jsglr/client/imploder
	src/org/spoofax/jsglr/client/incremental
	src/org/spoofax/jsglr/shared/terms test/org...
Message-ID: <201012161505.oBGF5b8J027447@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:05:37 2010
New Revision: 21552
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21552&sc=1

Log:
Working on tokenization for IncrementalSGLR and friends.

Added:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/DamageRegionAnalyzer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java7-increment.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java7.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java8-increment.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java8-increment2.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java8-increment3.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java8.java
Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Tokenizer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalInputBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Tokenizer.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Tokenizer.java	Thu Dec 16 15:05:32 2010	(r21551)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Tokenizer.java	Thu Dec 16 15:05:37 2010	(r21552)
@@ -89,10 +89,12 @@
 	}
 	
 	public IToken makeToken(int endOffset, int kind, boolean allowEmptyToken) {
+		assert endOffset <= input.length();
 		if (!allowEmptyToken && startOffset > endOffset) // empty token
 			return null;
 		
-		assert endOffset + 1 >= startOffset || (kind == TK_RESERVED && startOffset == 0);
+		assert endOffset + 1 >= startOffset || (kind == TK_RESERVED && startOffset == 0)
+			: "Creating token ending before current start offset";
 		
 		int offset;
 		IToken token = null;
@@ -234,6 +236,20 @@
 		return token;
 	}
 	
+	public static IToken getTokenAfter(IToken token) {
+		if (token == null) return null;
+		return token.getTokenizer().getTokenAt(token.getIndex() + 1);
+	}
+	
+	public static IToken getTokenBefore(IToken token) {
+		if (token == null) return null;
+		return token.getTokenizer().getTokenAt(token.getIndex() - 1);
+	}
+	
+	public static int getLength(IToken token) {
+		return token.getEndOffset() - token.getStartOffset() + 1;
+	}
+	
 	public String toString(IToken left, IToken right) {
 		int startOffset = left.getStartOffset();
 		int endOffset = right.getEndOffset();
@@ -241,7 +257,7 @@
 	}
 
 	private String toString(int startOffset, int endOffset) {
-		return new StringBuilder(endOffset - startOffset + 1).append(input, startOffset, endOffset + 1).toString();
+		return input.substring(startOffset, endOffset + 1);
 	}
 	
 	@Override

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/DamageRegionAnalyzer.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/DamageRegionAnalyzer.java	Thu Dec 16 15:05:37 2010	(r21552)
@@ -0,0 +1,119 @@
+package org.spoofax.jsglr.client.incremental;
+
+import static org.spoofax.jsglr.client.imploder.Tokenizer.findLeftMostLayoutToken;
+import static org.spoofax.jsglr.client.imploder.Tokenizer.findRightMostLayoutToken;
+import static org.spoofax.jsglr.client.incremental.IncrementalSGLR.isRangeOverlap;
+import static org.spoofax.jsglr.client.incremental.IncrementalSGLR.tryGetListIterator;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Set;
+
+import org.spoofax.jsglr.client.imploder.IAstNode;
+import org.spoofax.jsglr.client.imploder.IToken;
+
+/**
+ * Analyzes the trees before and after incremental parsing,
+ * determining the tree nodes that are in the damage region.
+ * 
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class DamageRegionAnalyzer {
+
+	final Set<String> incrementalSorts;
+	
+	final int damageStart;
+
+	final int damageEnd;
+	
+	final int damageSizeChange;
+
+	public DamageRegionAnalyzer(IncrementalSGLR<?> parser, int damageStart, int damageEnd, int damageSizeChange) {
+		this.incrementalSorts = parser.incrementalSorts;
+		this.damageStart = damageStart;
+		this.damageEnd = damageEnd;
+		this.damageSizeChange = damageSizeChange;
+	}
+	
+	/**
+	 * Gets all non-list tree nodes from the original tree
+	 * that are in the damage region according to {@link #isDamageTreeNode}.
+	 */
+	public List<IAstNode> getDamageTreeNodes(IAstNode tree) {
+		return getDamageRegionTreeNodes(tree, new ArrayList<IAstNode>(), true, 0);
+	}
+	
+	/**
+	 * Gets all non-list tree nodes from the partial result tree
+	 * that are in the damage region according to {@link #isDamageTreeNode}.
+	 */
+	public List<IAstNode> getRepairedTreeNodes(IAstNode tree, int skippedChars) {
+		return getDamageRegionTreeNodes(tree, new ArrayList<IAstNode>(), false, skippedChars);
+	}
+
+	private List<IAstNode> getDamageRegionTreeNodes(IAstNode tree, List<IAstNode> results, boolean isOriginalTree, int skippedChars) {
+		if (!tree.isList() && isDamageTreeNode(tree, isOriginalTree, skippedChars)) {
+			results.add(tree);
+		} else {
+			// Recurse
+			Iterator<IAstNode> iterator = tryGetListIterator(tree); 
+			for (int i = 0, max = tree.getChildCount(); i < max; i++) {
+				IAstNode child = iterator == null ? tree.getChildAt(i) : iterator.next();
+				getDamageRegionTreeNodes(child, results, isOriginalTree, skippedChars);
+			}
+		}
+		return results;
+	}
+
+	/**
+	 * Determines if the damage region affects a particular tree node,
+	 * looking only at those tokens that actually belong to the node
+	 * and not to its children. Also returns true for nodes in the region
+	 * with a sort in {@link #incrementalSorts} regardless of whether they own the tokens
+	 * or not.
+	 */
+	protected boolean isDamageTreeNode(IAstNode tree, boolean isOriginalTree, int skippedChars) {
+		IToken current = findLeftMostLayoutToken(tree.getLeftToken());
+		IToken last = findRightMostLayoutToken(tree.getRightToken());
+		if (current != null && last != null) {
+			if (!isDamagedNonEmptyRange(
+					current.getStartOffset(), last.getEndOffset(), isOriginalTree, skippedChars))
+				return false;
+			if (incrementalSorts.contains(tree.getSort()))
+				return true;
+			Iterator<IAstNode> iterator = tryGetListIterator(tree); 
+			for (int i = 0, max = tree.getChildCount(); i < max; i++) {
+				IAstNode child = iterator == null ? tree.getChildAt(i) : iterator.next();
+				IToken childLeft = findLeftMostLayoutToken(child.getLeftToken());
+				IToken childRight = findRightMostLayoutToken(child.getRightToken());
+				if (childLeft != null && childRight != null) {
+					if (childLeft.getIndex() > current.getIndex()
+							&& isDamagedNonEmptyRange(
+									current.getStartOffset(), childLeft.getStartOffset() - 1,
+									isOriginalTree, skippedChars)) {
+						return true;
+					}
+					current = childRight;
+				}
+			}
+			return isDamagedNonEmptyRange(
+					current.getEndOffset() + 1, last.getEndOffset(), isOriginalTree, skippedChars);
+		} else {
+			return false;
+		}
+	}
+	
+	private boolean isDamagedNonEmptyRange(int startOffset, int endOffset,
+			boolean isOriginalTree, int skippedChars) {
+		// TODO: get rid of non-empty criterion?? at the very least for empty damage regions...
+		if (isOriginalTree) {
+			return /*endOffset >= startOffset
+				&&*/ isRangeOverlap(damageStart, damageEnd, startOffset, endOffset);
+		} else {
+			return /*endOffset >= startOffset
+				&&*/ isRangeOverlap(damageStart - skippedChars, damageEnd - skippedChars + damageSizeChange,
+						startOffset, endOffset);
+		}
+	}
+}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalInputBuilder.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalInputBuilder.java	Thu Dec 16 15:05:32 2010	(r21551)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalInputBuilder.java	Thu Dec 16 15:05:37 2010	(r21552)
@@ -13,6 +13,8 @@
 import org.spoofax.jsglr.client.imploder.IToken;
 
 /**
+ * Constructs an input string for incremental parsing.
+ * 
  * @author Lennart Kats <lennart add lclnet.nl>
  */
 public class IncrementalInputBuilder {
@@ -46,18 +48,19 @@
 	private int skippedCharsAfterDamage;
 
 	/**
+	 * Constructs an input string for incremental parsing.
+	 * 
 	 * @param incrementalSorts
 	 *            Sorts that can be incrementally parsed (e.g., MethodDec, ImportDec).
 	 *            *Must* be sorts that only occur in lists (such as MethodDec*).
 	 */
-	public IncrementalInputBuilder(Set<String> incrementalSorts, String input, String oldInput,
-			int damageStart, int damageEnd, int damageSizeChange) {
-		this.incrementalSorts = incrementalSorts;
+	public IncrementalInputBuilder(DamageRegionAnalyzer damageAnalyzer, String input, String oldInput) {
+		this.incrementalSorts = damageAnalyzer.incrementalSorts;
 		this.newInput = input;
 		this.oldInput = oldInput;
-		this.damageEnd = damageEnd;
-		this.damageStart = damageStart;
-		this.damageSizeChange = damageSizeChange;
+		this.damageEnd = damageAnalyzer.damageEnd;
+		this.damageStart = damageAnalyzer.damageStart;
+		this.damageSizeChange = damageAnalyzer.damageSizeChange;
 	}
 
 	public String buildPartialInput(IAstNode oldTree) throws IncrementalSGLRException {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java	Thu Dec 16 15:05:32 2010	(r21551)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java	Thu Dec 16 15:05:37 2010	(r21552)
@@ -50,28 +50,13 @@
 	}
 	
 	/**
-	 * Attempts to incrementally parse an input,
-	 * or falls back to normal parsing if incremental parsing fails.
-	 */
-	public IAstNode tryParseIncremental(String input, String filename, String startSymbol, TNode oldTree)
-			throws TokenExpectedException, BadTokenException, ParseException, SGLRException {
-		
-		try {
-			return parseIncremental(input, filename, startSymbol, oldTree);
-		} catch (IncrementalSGLRException e) {
-			lastRepairedTreeNodesCount = -1;
-			return (IAstNode) parser.parse(input, startSymbol);
-		}
-	}
-	
-	/**
 	 * Incrementally parse an input.
 	 * 
 	 * @throws IncrementalSGLRException
 	 *             If the input could not be incrementally parsed.
 	 *             It may still be possible to parse it non-incrementally.
 	 */
-	public IAstNode parseIncremental(String newInput, String filename, String startSymbol, TNode oldTree)
+	public TNode parseIncremental(String newInput, String filename, String startSymbol, TNode oldTree)
 			throws TokenExpectedException, BadTokenException, ParseException, SGLRException, IncrementalSGLRException {
 		
 		String oldInput = oldTree.getLeftToken().getTokenizer().getInput();
@@ -86,23 +71,26 @@
 			return oldTree;
 		}
 		
-		IncrementalInputBuilder inputBuilder =
-			new IncrementalInputBuilder(incrementalSorts, newInput, oldInput, damageStart, damageEnd, damageSizeChange);
+		DamageRegionAnalyzer damageAnalyzer =
+			new DamageRegionAnalyzer(this, damageStart, damageEnd, damageSizeChange);
 		
-		IncrementalTreeBuilder<TNode> treeBuilder =
-			new IncrementalTreeBuilder<TNode>(this, newInput, filename, damageStart, damageEnd, damageSizeChange);
+		IncrementalInputBuilder inputBuilder =
+			new IncrementalInputBuilder(damageAnalyzer, newInput, oldInput);
 		
-		sanityCheckOldTree(oldTree, treeBuilder.getDamagedTreeNodes(oldTree));
+		sanityCheckOldTree(oldTree, damageAnalyzer.getDamageTreeNodes(oldTree));
 
 		String partialInput = inputBuilder.buildPartialInput(oldTree);
 		int skippedChars = inputBuilder.getLastSkippedCharsBeforeDamage();
 		IAstNode partialTree = (IAstNode) parser.parse(partialInput, startSymbol);
 		
-		List<IAstNode> repairedTreeNodes = treeBuilder.getRepairedTreeNodes(partialTree, skippedChars);
+		List<IAstNode> repairedTreeNodes = damageAnalyzer.getRepairedTreeNodes(partialTree, skippedChars);
 		lastRepairedTreeNodesCount = repairedTreeNodes.size();
 		sanityCheckRepairedTree(repairedTreeNodes);
+		
+		IncrementalTreeBuilder<TNode> treeBuilder =
+			new IncrementalTreeBuilder<TNode>(this, damageAnalyzer, newInput, filename, repairedTreeNodes, skippedChars);
 
-		return treeBuilder.buildOutput(oldTree, repairedTreeNodes, skippedChars);
+		return treeBuilder.buildOutput(oldTree);
 	}
 	
 	/**
@@ -149,7 +137,7 @@
 	}
 
 	protected static boolean isRangeOverlap(int start1, int end1, int start2, int end2) {
-		return start1 < end2 && start2 < end1;
+		return start1 <= end2 && start2 <= end1; // e.g. testJava55
 	}
 
 	@SuppressWarnings("unchecked")

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java	Thu Dec 16 15:05:32 2010	(r21551)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java	Thu Dec 16 15:05:37 2010	(r21552)
@@ -1,32 +1,36 @@
 package org.spoofax.jsglr.client.incremental;
 
+import static java.lang.Math.min;
+import static org.spoofax.jsglr.client.imploder.IToken.TK_EOF;
+import static org.spoofax.jsglr.client.imploder.IToken.TK_ERROR;
+import static org.spoofax.jsglr.client.imploder.IToken.TK_ERROR_EOF_UNEXPECTED;
+import static org.spoofax.jsglr.client.imploder.IToken.TK_ERROR_KEYWORD;
+import static org.spoofax.jsglr.client.imploder.IToken.TK_UNKNOWN;
 import static org.spoofax.jsglr.client.imploder.Tokenizer.findLeftMostLayoutToken;
 import static org.spoofax.jsglr.client.imploder.Tokenizer.findRightMostLayoutToken;
-import static org.spoofax.jsglr.client.incremental.IncrementalSGLR.isRangeOverlap;
+import static org.spoofax.jsglr.client.imploder.Tokenizer.getTokenAfter;
+import static org.spoofax.jsglr.client.imploder.Tokenizer.getTokenBefore;
 import static org.spoofax.jsglr.client.incremental.IncrementalSGLR.tryGetListIterator;
-import static org.spoofax.jsglr.client.imploder.IToken.TK_EOF;
 
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
 
-import org.spoofax.jsglr.client.SGLR;
 import org.spoofax.jsglr.client.imploder.IAstNode;
 import org.spoofax.jsglr.client.imploder.IToken;
+import org.spoofax.jsglr.client.imploder.ITokenizer;
 import org.spoofax.jsglr.client.imploder.ITreeFactory;
 import org.spoofax.jsglr.client.imploder.Tokenizer;
 
 /**
+ * Constructs the output tree based on the old tree and the list of repaired tree nodes.
+ * 
  * @author Lennart Kats <lennart add lclnet.nl>
  */
 public class IncrementalTreeBuilder<TNode extends IAstNode> {
 	
-	private final SGLR parser;
-
-	private final String input;
-
-	private final String filename;
+	private static final int NO_STOP_OFFSET = Integer.MAX_VALUE;
 
 	private final ITreeFactory<TNode> factory;
 	
@@ -35,160 +39,158 @@
 	private final int damageStart;
 
 	private final int damageEnd;
+
+	private final int skippedChars;
 	
 	private final int damageSizeChange;
+
+	private final List<IAstNode> repairedTreeNodes;
+
+	private final Tokenizer newTokenizer;
+
+	private final DamageRegionAnalyzer damageAnalyzer;
 	
 	private boolean isRepairedNodesInserted;
 
 	/**
-	 * @param incrementalSorts
-	 *            Sorts that can be incrementally parsed (e.g., MethodDec, ImportDec).
-	 *            *Must* be sorts that only occur in lists (such as MethodDec*).
+	 * @param skippedChars @see {@link IncrementalInputBuilder#getLastSkippedCharsBeforeDamage()}
 	 */
-	public IncrementalTreeBuilder(IncrementalSGLR<TNode> parser, String input, String filename,
-			int damageStart, int damageEnd, int damageSizeChange) {
-		this.parser = parser.parser;
-		this.input = input;
-		this.filename = filename;
+	public IncrementalTreeBuilder(IncrementalSGLR<TNode> parser, DamageRegionAnalyzer damageAnalyzer,
+			String input, String filename, List<IAstNode> repairedTreeNodes, int skippedChars) {
+		this.damageAnalyzer = damageAnalyzer;
 		this.factory = parser.factory;
-		this.incrementalSorts = parser.incrementalSorts;
-		this.damageStart = damageStart;
-		this.damageEnd = damageEnd;
-		this.damageSizeChange = damageSizeChange;
+		this.incrementalSorts = damageAnalyzer.incrementalSorts;
+		this.damageStart = damageAnalyzer.damageStart;
+		this.damageEnd = damageAnalyzer.damageEnd;
+		this.skippedChars = skippedChars;
+		this.damageSizeChange = damageAnalyzer.damageSizeChange;
+		this.repairedTreeNodes = repairedTreeNodes;
+		this.newTokenizer = new Tokenizer(parser.parser.getParseTable().getKeywordRecognizer(), filename, input);
 	}
 	
 	/**
-	 * Gets all non-list tree nodes from the original tree
-	 * that are in the damaged region according to {@link #isDamageTreeNode}.
+	 * Builds the output tree based on the old tree and the list of repaired tree nodes.
 	 */
-	public List<IAstNode> getDamagedTreeNodes(IAstNode tree) {
-		return getDamagedRegionTreeNodes(tree, new ArrayList<IAstNode>(), true, 0);
-	}
-	
-	/**
-	 * Gets all non-list tree nodes from the partial result tree
-	 * that are in the damaged region according to {@link #isDamageTreeNode}.
-	 */
-	public List<IAstNode> getRepairedTreeNodes(IAstNode tree, int skippedChars) {
-		return getDamagedRegionTreeNodes(tree, new ArrayList<IAstNode>(), false, skippedChars);
-	}
-
-	private List<IAstNode> getDamagedRegionTreeNodes(IAstNode tree, List<IAstNode> results, boolean isOriginalTree, int skippedChars) {
-		if (!tree.isList() && isDamageTreeNode(tree, isOriginalTree, skippedChars)) {
-			results.add(tree);
-		} else {
-			// Recurse
-			Iterator<IAstNode> iterator = tryGetListIterator(tree); 
-			for (int i = 0, max = tree.getChildCount(); i < max; i++) {
-				IAstNode child = iterator == null ? tree.getChildAt(i) : iterator.next();
-				getDamagedRegionTreeNodes(child, results, isOriginalTree, skippedChars);
-			}
-		}
-		return results;
-	}
-
-	/**
-	 * Determines if the damaged region affects a particular tree node,
-	 * looking only at those tokens that actually belong to the node
-	 * and not to its children. Also returns true for nodes with a sort 
-	 * in {@link #incrementalSorts} regardless of whether they own the tokens
-	 * or not.
-	 */
-	protected boolean isDamageTreeNode(IAstNode tree, boolean isOriginalTree, int skippedChars) {
-		IToken current = findLeftMostLayoutToken(tree.getLeftToken());
-		IToken last = findRightMostLayoutToken(tree.getRightToken());
-		if (current != null && last != null) {
-			if (!isDamagedNonEmptyRange(
-					current.getStartOffset(), last.getEndOffset(), isOriginalTree, skippedChars))
-				return false;
-			if (incrementalSorts.contains(tree.getSort()))
-				return true;
-			Iterator<IAstNode> iterator = tryGetListIterator(tree); 
-			for (int i = 0, max = tree.getChildCount(); i < max; i++) {
-				IAstNode child = iterator == null ? tree.getChildAt(i) : iterator.next();
-				IToken childLeft = findLeftMostLayoutToken(child.getLeftToken());
-				IToken childRight = findRightMostLayoutToken(child.getRightToken());
-				if (childLeft != null && childRight != null) {
-					if (childLeft.getIndex() > current.getIndex()
-							&& isDamagedNonEmptyRange(
-									current.getStartOffset(), childLeft.getStartOffset() - 1,
-									isOriginalTree, skippedChars)) {
-						return true;
-					}
-					current = childRight;
-				}
-			}
-			return isDamagedNonEmptyRange(
-					current.getEndOffset() + 1, last.getEndOffset(), isOriginalTree, skippedChars);
-		} else {
-			return false;
-		}
-	}
-	
-	private boolean isDamagedNonEmptyRange(int startOffset, int endOffset,
-			boolean isOriginalTree, int skippedChars) {
-		// TODO: get rid of non-empty criterion?? at the very least for empty damage regions...
-		if (isOriginalTree) {
-			return /*endOffset >= startOffset
-				&&*/ isRangeOverlap(damageStart, damageEnd, startOffset, endOffset);
-		} else {
-			return /*endOffset >= startOffset
-				&&*/ isRangeOverlap(damageStart - skippedChars, damageEnd - skippedChars + damageSizeChange,
-						startOffset, endOffset);
-		}
-	}
-	
-	public TNode buildOutput(IAstNode oldTreeNode, List<IAstNode> repairedTreeNodes, int skippedChars) 
-			throws IncrementalSGLRException {
+	public TNode buildOutput(IAstNode oldTreeNode) throws IncrementalSGLRException {
 		isRepairedNodesInserted = false;
-		Tokenizer tokenizer =
-			new Tokenizer(parser.getParseTable().getKeywordRecognizer(), filename, input);
-		TNode result = buildOutputSubtree(oldTreeNode, repairedTreeNodes, skippedChars, tokenizer);
+		TNode result = buildOutputSubtree(oldTreeNode, 0);
 		if (!isRepairedNodesInserted)
 			throw new IncrementalSGLRException("Postcondition failed: unable to insert repaired tree nodes in original tree: " + repairedTreeNodes);
-		tokenizer.makeToken(tokenizer.getStartOffset() - 1, TK_EOF, true);
+		newTokenizer.makeToken(newTokenizer.getStartOffset() - 1, TK_EOF, true);
 		return result;
 	}
 	
-	@SuppressWarnings("unchecked")
-	private TNode buildOutputSubtree(IAstNode oldTreeNode, List<IAstNode> repairedTreeNodes,
-			int skippedChars, Tokenizer tokenizer) {
-		// TODO: recreate tokens
+	private TNode buildOutputSubtree(IAstNode oldTreeNode, int offsetChange) {
 
-		IToken leftToken = tokenizer.currentToken();
-		List<IAstNode> children;
+		final List<IAstNode> children;
+		final IToken beforeStartToken = newTokenizer.currentToken();
+		IToken startToken = oldTreeNode.getLeftToken();
+		
+		// TODO: copy tokens before first child??
 		if (oldTreeNode.isList() && incrementalSorts.contains(oldTreeNode.getElementSort())) {
-			List<IAstNode> oldChildren = copyChildrenToList(oldTreeNode);
+			assert offsetChange == 0 : "Nested incrementalSorts lists?";
 			children = new ArrayList<IAstNode>(oldTreeNode.getChildCount() + repairedTreeNodes.size());
-			for (IAstNode oldChild : oldChildren) {
-				if (!isRepairedNodesInserted && oldChild.getRightToken().getEndOffset() >= damageStart) {
-					insertRepairedNodes(oldTreeNode, repairedTreeNodes, tokenizer, children);
+
+			Iterator<IAstNode> iterator = tryGetListIterator(oldTreeNode); 
+			for (int i = 0, max = oldTreeNode.getChildCount(); i < max; i++) {
+				IAstNode child = iterator == null ? oldTreeNode.getChildAt(i) : iterator.next();
+
+				copyTokensAndTryAddRepairedNodes(oldTreeNode, children, startToken, child.getLeftToken(), child.getRightToken());
+
+				if (!damageAnalyzer.isDamageTreeNode(child, true, skippedChars)) {
+					startToken = getTokenAfter(child.getRightToken());
+					children.add(buildOutputSubtree(child, offsetChange));
 				}
-				children.add(buildOutputSubtree(oldChild, repairedTreeNodes, skippedChars, tokenizer));
-			}
-			IToken endToken = Tokenizer.findRightMostLayoutToken(oldTreeNode.getRightToken());
-			if (!isRepairedNodesInserted && endToken.getEndOffset() >= damageStart - skippedChars) {
-				insertRepairedNodes(oldTreeNode, repairedTreeNodes, tokenizer, children);
 			}
+			IToken stopToken = getTokenAfter(findRightMostLayoutToken(oldTreeNode.getRightToken()));
+			copyTokensAndTryAddRepairedNodes(oldTreeNode, children, startToken, stopToken, stopToken);
 		} else {
 			children = copyChildrenToList(oldTreeNode);
 			for (int i = 0; i < children.size(); i++) {
-				children.set(i, buildOutputSubtree(children.get(i), repairedTreeNodes, skippedChars, tokenizer));
+				IAstNode child = children.get(i);
+				
+				int myOffsetChange = offsetChange + (isRepairedNodesInserted ? damageSizeChange : 0);
+				copyTokens(startToken, findLeftMostLayoutToken(child.getLeftToken()), NO_STOP_OFFSET/*child.getLeftToken().getEndOffset() + 1*/, myOffsetChange);
+				startToken = getTokenAfter(child.getRightToken());
+
+				children.set(i, buildOutputSubtree(child, offsetChange));
 			}
 		}
-		return factory.recreateNode((TNode) oldTreeNode, null, null, /*leftToken, tokenizer.currentToken()*/ (List<TNode>) children);
+		int myOffsetChange = offsetChange + (isRepairedNodesInserted ? damageSizeChange : 0);
+		IToken stopToken = getTokenAfter(oldTreeNode.getRightToken());
+		copyTokens(startToken, stopToken, NO_STOP_OFFSET/*stopToken.getEndOffset() + 1*/, myOffsetChange);
+		return buildOutputNode(oldTreeNode, children, beforeStartToken);
 	}
 
-	private void insertRepairedNodes(IAstNode oldTreeNode, List<IAstNode> repairedTreeNodes,
-			Tokenizer tokenizer, List<IAstNode> children) {
+	@SuppressWarnings("unchecked")
+	private TNode buildOutputNode(IAstNode oldTreeNode, List<IAstNode> children, IToken beforeStartToken) {
+		IToken startToken;
+		if (newTokenizer.currentToken() == beforeStartToken) {
+			startToken = newTokenizer.makeToken(newTokenizer.getStartOffset() - 1, TK_UNKNOWN, true);
+		} else {
+			startToken = getTokenAfter(beforeStartToken);
+		}
+		return factory.recreateNode((TNode) oldTreeNode, startToken, newTokenizer.currentToken(), (List<TNode>) children);
+	}
+
+	private void copyTokensAndTryAddRepairedNodes(IAstNode oldTreeNode, List<IAstNode> children,
+			IToken firstToken, IToken stopToken, IToken childEndToken) {
 		
-		isRepairedNodesInserted = true;
+		if (!isRepairedNodesInserted && childEndToken.getEndOffset() >= damageStart) {
+			//copyTokens(firstToken, stopToken, damageStart, -skippedChars);
+			copyTokens(firstToken, stopToken, damageStart, 0);
+			insertRepairedNodes(oldTreeNode, children);
+			copyTokens(firstToken, stopToken, damageEnd - skippedChars /*+ 1*/, damageSizeChange);
+		} else {
+			copyTokens(firstToken, stopToken, damageStart, 0);
+		}
+	}
 
-		// TODO: recreate tokens
-		for (IAstNode node : repairedTreeNodes) {
-			// List<IAstNode> children = copy
-			// factory.recreateNode((TNode) oldTreeNode, leftToken, tokenizer.currentToken(), children)
-			children.add(node);
+	private void insertRepairedNodes(IAstNode oldTreeNode, List<IAstNode> children) {
+		if (repairedTreeNodes.size() > 0) {
+			IToken firstToken = getTokenBefore(repairedTreeNodes.get(0).getLeftToken());
+	
+			for (IAstNode node : repairedTreeNodes) {
+				copyTokens(firstToken, node.getLeftToken(), NO_STOP_OFFSET/*node.getLeftToken().getEndOffset() + 1*/, skippedChars);
+				firstToken = getTokenAfter(node.getRightToken());
+				
+				children.add(buildOutputSubtree(node, skippedChars));
+			}
+		}
+		isRepairedNodesInserted = true;
+	}
+	
+	/**
+	 * Copies tokens to {@link #newTokenizer}.
+	 * 
+	 * @param startToken
+	 *           Start copying at this token.
+	 * @param stopToken
+	 *           Stop copying just before this token.
+	 * @param stopOffset
+	 *           Stop copying just before this offset in the original token stream.
+	 * @param offsetChange
+	 *           The change in offset between the given tokens and the copied tokens in the new tokenizer.
+	 */
+	private void copyTokens(IToken startToken, IToken stopToken, int stopOffset, int offsetChange) {
+		ITokenizer fromTokenizer = startToken.getTokenizer();
+		assert fromTokenizer == stopToken.getTokenizer();
+		for (int i = findLeftMostLayoutToken(startToken).getIndex(), last = stopToken.getIndex(); i < last; i++) {
+			IToken fromToken = fromTokenizer.getTokenAt(i);
+			int myEndOffset = min(stopOffset, fromToken.getEndOffset()) + offsetChange;
+			IToken toToken = newTokenizer.makeToken(myEndOffset, fromToken.getKind(), isEssentialToken(fromToken));
+			assert toToken == null || myEndOffset < fromToken.getEndOffset() + offsetChange
+				|| toToken.toString().equals(fromToken.toString())
+				: "Expected '" + fromToken + "' in copied tokenstream, not '" + toToken + "'";
+		}
+	}
+	
+	private static boolean isEssentialToken(IToken token) {
+		switch (token.getKind()) {
+			case TK_ERROR: case TK_ERROR_EOF_UNEXPECTED: case TK_ERROR_KEYWORD:
+				return true;
+			default:
+				return false;
 		}
 	}
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java	Thu Dec 16 15:05:32 2010	(r21551)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java	Thu Dec 16 15:05:37 2010	(r21552)
@@ -45,6 +45,8 @@
 			|| getChildAt(getChildCount() - 1).getRightToken() == null
 			|| rightToken == null
 			|| rightToken.getEndOffset() >= getChildAt(getChildCount() - 1).getRightToken().getEndOffset(); 
+		assert leftToken == null || rightToken == null
+			|| leftToken.getTokenizer() == rightToken.getTokenizer();
 	}
 	
 	public IToken getLeftToken() {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:05:32 2010	(r21551)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:05:37 2010	(r21552)
@@ -153,11 +153,16 @@
 			System.out.println(wanted.toString(8));
 	    	if (!newTree.simpleMatch(wanted))
 	    		fail();
+	    	doTokenStreamEqualityTest(oldTree, newTree);
 		} else {
 			System.out.println(newTree.toString(8));
 		}
     	return newTree;
 	}
+	
+	private void doTokenStreamEqualityTest(ATerm oldTree, ATerm newTree) {
+		System.out.println(newTree.getLeftToken().getTokenizer());
+	}
 
 	protected String loadAsString(final String testFile) {
 		return FileTools.loadFileAsString("tests/data/" + testFile + "." + suffix);

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java	Thu Dec 16 15:05:32 2010	(r21551)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java	Thu Dec 16 15:05:37 2010	(r21552)
@@ -11,7 +11,7 @@
  */
 public class TestIncrementalSGLR extends ParseTestCase {
 
-	private static ATerm java4Result, java5Result;
+	private static ATerm java4Result, java5Result, java8Result;
 	
     @Override
 	public void gwtSetUp() throws ParserException, InvalidParseTableException {
@@ -31,6 +31,11 @@
     	if (java5Result == null) java5Result = doParseTest("java5");
     	return java5Result;
     }
+    
+    private ATerm getJava8Result() {
+    	if (java8Result == null) java8Result = doParseTest("java8");
+    	return java8Result;
+    }
 
     public void testJava51() throws Exception {
     	doParseIncrementalTest(getJava5Result(), "java5-increment");
@@ -49,7 +54,10 @@
     }
     
     public void testJava55() throws Exception {
-    	doParseIncrementalTest(getJava5Result(), "java5-increment5");
+    	ATerm result = doParseIncrementalTest(getJava5Result(), "java5-increment5");
+    	assertFalse("There is no foo", result.toString().contains("\"foo\""));
+    	assertFalse("There is no baz", result.toString().contains("\"bar\""));
+    	assertTrue("There is only foobaz", result.toString().contains("\"foobaz\""));
     }
     
     public void testJava56() throws Exception {
@@ -73,6 +81,52 @@
     	}
     	fail("Exception expected");
     }
+    
+    public void testJava6Recovery() throws Exception {
+    	suffix = "java.recover";
+    	sglr.setUseStructureRecovery(true);
+    	doCompare = false;
+    	ATerm java6 = doParseTest("java6");
+    	ATerm java61 = doParseIncrementalTest(java6, "java6-increment");
+    	assertFalse(java6.toString().contains("baz"));
+    	assertTrue(java61.toString().contains("baz"));
+    	assertTrue(java61.getLeftToken().getTokenizer().toString().toString().contains("sense"));
+    }
+    
+    public void testJava7() throws Exception {
+    	ATerm java7 = doParseTest("java7");
+    	ATerm java7Increment = doParseIncrementalTest(java7, "java7-increment");
+    	assertTrue("Method bar should be outside of a comment", java7.toString().contains("\"bar\""));
+    	assertFalse("Method bar should be in a comment", java7Increment.toString().contains("\"bar\""));
+    }
+    
+    public void testJava8() throws Exception {
+    	ATerm java8 = getJava8Result();
+    	ATerm java8Increment = doParseIncrementalTest(java8, "java8-increment");
+    	assertTrue("Comment should be in input tokens", java8.getLeftToken().getTokenizer().toString().contains("comment"));
+    	assertFalse("Comment should be in output tokens", java8Increment.getLeftToken().getTokenizer().toString().contains("comment"));
+    }
+    
+    public void testJava82() throws Exception {
+    	ATerm java8 = getJava8Result();
+    	ATerm java8Increment = doParseIncrementalTest(java8, "java8-increment2");
+    	assertTrue("Comment should be in input tokens", java8.getLeftToken().getTokenizer().toString().contains("comment"));
+    	assertFalse("Comment should be in output tokens", java8Increment.getLeftToken().getTokenizer().toString().contains("comment"));
+    }
+    
+    public void testJava83() throws Exception {
+    	ATerm java8 = getJava8Result();
+    	ATerm java8Increment = doParseIncrementalTest(java8, "java8-increment3");
+    	assertTrue("Comment should be in input tokens", java8.getLeftToken().getTokenizer().toString().contains("comment"));
+    	assertFalse("Comment should be in output tokens", java8Increment.getLeftToken().getTokenizer().toString().contains("comment"));
+    }
+    
+    public void testJava84() throws Exception {
+    	ATerm java8 = getJava8Result();
+    	ATerm java8Increment = doParseIncrementalTest(java8, "java8-increment4");
+    	assertTrue("Comment should be in input tokens", java8.getLeftToken().getTokenizer().toString().contains("comment"));
+    	assertFalse("Comment should be in output tokens", java8Increment.getLeftToken().getTokenizer().toString().contains("comment"));
+    }
 
     public void testJava4() throws Exception {
     	doParseIncrementalTest(getJava4Result(), "java4-increment");
@@ -87,15 +141,5 @@
     	}
     	fail("Exception expected");
     }
-    
-    public void testJava6Recovery() throws Exception {
-    	suffix = "java.recover";
-    	sglr.setUseStructureRecovery(true);
-    	doCompare = false;
-    	ATerm java6 = doParseTest("java6");
-    	ATerm java61 = doParseIncrementalTest(java6, "java6-increment");
-    	assertFalse(java6.toString().contains("baz"));
-    	assertTrue(java61.toString().contains("baz"));
-    }
 
 }

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java7-increment.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java7-increment.java	Thu Dec 16 15:05:37 2010	(r21552)
@@ -0,0 +1,10 @@
+package java.java7;
+
+class Foo {
+  int foo() {
+    /*
+  int bar();
+  int baz() {
+    /* */
+  }
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java7.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java7.java	Thu Dec 16 15:05:37 2010	(r21552)
@@ -0,0 +1,8 @@
+package java.java7;
+
+class Foo {
+  int bar();
+  int baz() {
+    /* */
+  }
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java8-increment.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java8-increment.java	Thu Dec 16 15:05:37 2010	(r21552)
@@ -0,0 +1,8 @@
+package java.java8;
+
+class Foo {
+  int bar();
+  int foo();
+  /*comment*/
+  int baz();
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java8-increment2.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java8-increment2.java	Thu Dec 16 15:05:37 2010	(r21552)
@@ -0,0 +1,8 @@
+package java.java8;
+
+class Foo {
+  int bar();
+  int foo();
+  /*comment*/
+  int baz();
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java8-increment3.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java8-increment3.java	Thu Dec 16 15:05:37 2010	(r21552)
@@ -0,0 +1,7 @@
+package java.java8;
+
+class Foo {
+  int bad();
+  /*comment*/
+  int baz();
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java8.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java8.java	Thu Dec 16 15:05:37 2010	(r21552)
@@ -0,0 +1,7 @@
+package java.java8;
+
+class Foo {
+  int bar();
+  /*comment*/
+  int baz();
+}

From karltk at strategoxt.org  Thu Dec 16 16:05:42 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:05:42 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21553 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client:
	imploder incremental
Message-ID: <201012161505.oBGF5gwL027450@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:05:42 2010
New Revision: 21553
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21553&sc=1

Log:
Minor interface changes.

Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ATermTreeFactory.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITreeFactory.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ATermTreeFactory.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ATermTreeFactory.java	Thu Dec 16 15:05:37 2010	(r21552)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ATermTreeFactory.java	Thu Dec 16 15:05:42 2010	(r21553)
@@ -7,6 +7,7 @@
 import static org.spoofax.jsglr.shared.terms.ATerm.TUPLE;
 
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
 import org.spoofax.jsglr.client.NotImplementedException;
@@ -111,8 +112,8 @@
 		}
 	}
 
-	public boolean isStringTerminal(ATerm node) {
-		return node.getType() == ATerm.STRING;
+	public String getStringTerminalValue(ATerm node) {
+		return node.getType() == ATerm.STRING ? ((ATermString) node).getString() : null;
 	}
 
 	public ATerm createInjection(String sort, List<ATerm> children) {
@@ -125,6 +126,8 @@
 			Iterable<ATerm> result = (Iterable<ATerm>) node;
 			return result;
 		} else {
+			if (node.getChildCount() == 0)
+				return Collections.emptyList();
 			ArrayList<ATerm> children = new ArrayList<ATerm>(node.getChildCount());
 			for (int i = 0, max = node.getChildCount(); i < max; i++) {
 				children.add(node.getChildAt(i));

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITreeFactory.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITreeFactory.java	Thu Dec 16 15:05:37 2010	(r21552)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITreeFactory.java	Thu Dec 16 15:05:42 2010	(r21553)
@@ -2,8 +2,6 @@
 
 import java.util.List;
 
-
-
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
  */
@@ -12,58 +10,61 @@
 	/**
 	 * Create a new non-terminal node (or a terminal with only a constructor).
 	 */
-	public TNode createNonTerminal(String sort, String constructor, IToken leftToken, IToken rightToken,
+	TNode createNonTerminal(String sort, String constructor, IToken leftToken, IToken rightToken,
 			List<TNode> children);
 	
 	/**
 	 * Create a new terminal node for an int value.
 	 */
-	public TNode createIntTerminal(String sort, IToken token, int value);
+	TNode createIntTerminal(String sort, IToken token, int value);
 	
 	/**
 	 * Create a new terminal node for an real value.
 	 */
-	public TNode createRealTerminal(String sort, IToken token, double value);
+	TNode createRealTerminal(String sort, IToken token, double value);
 	
 	/**
 	 * Create a new terminal node for a string token.
 	 */
-	public TNode createStringTerminal(String sort, String value, IToken token);
+	TNode createStringTerminal(String sort, String value, IToken token);
 	
-	public TNode createTuple(String elementSort, IToken leftToken, IToken rightToken, List<TNode> children);
+	TNode createTuple(String elementSort, IToken leftToken, IToken rightToken, List<TNode> children);
 	
 	/**
 	 * Create a new node list. 
 	 */
-	public TNode createList(String elementSort, IToken leftToken, IToken rightToken, List<TNode> children);
+	TNode createList(String elementSort, IToken leftToken, IToken rightToken, List<TNode> children);
 
-	public TNode createAmb(List<TNode> alternatives);
+	TNode createAmb(List<TNode> alternatives);
 	
 	/**
 	 * Creates a new node similar to an existing node,
 	 * used for incremental tree construction.
 	 */
-	public TNode recreateNode(TNode oldNode, IToken leftToken, IToken rightToken, List<TNode> children);
+	TNode recreateNode(TNode oldNode, IToken leftToken, IToken rightToken, List<TNode> children);
 
 	/**
 	 * Create an injection node.
 	 */
-	public TNode createInjection(String sort, List<TNode> children);
+	TNode createInjection(String sort, List<TNode> children);
 	
-	public boolean isStringTerminal(TNode node);
+	/**
+	 * Gets the string value of a string terminal, or returns null.
+	 */
+	String getStringTerminalValue(TNode node);
 	
 	/**
 	 * Gets the children of a node.
 	 */
-	public Iterable<TNode> getChildren(TNode node);
+	Iterable<TNode> getChildren(TNode node);
 	
 	/**
 	 * Gets the left token of a node, or null if not supported/applicable.
 	 */
-	public IToken getLeftToken(TNode node);
+	IToken getLeftToken(TNode node);
 	
 	/**
 	 * Gets the right token of a node, or null if not supported/applicable.
 	 */
-	public IToken getRightToken(TNode node);
+	IToken getRightToken(TNode node);
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java	Thu Dec 16 15:05:37 2010	(r21552)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java	Thu Dec 16 15:05:42 2010	(r21553)
@@ -340,7 +340,7 @@
 			return factory.createList(label.getSort(), left, right, children);
 		} else if (constructor == TUPLE_CONSTRUCTOR) {
 			return factory.createTuple(label.getSort(), left, right, children);
-		} else if (constructor == null && children.size() == 1 && factory.isStringTerminal(children.get(0))) {
+		} else if (constructor == null && children.size() == 1 && factory.getStringTerminalValue(children.get(0)) != null) {
 			// Child node was a <string> node (rare case); unpack it and create a new terminal
 			assert left == right;
 			return factory.createStringTerminal(label.getSort(), getPaddedLexicalValue(label, left), left);

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java	Thu Dec 16 15:05:37 2010	(r21552)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java	Thu Dec 16 15:05:42 2010	(r21553)
@@ -140,7 +140,7 @@
 			//copyTokens(firstToken, stopToken, damageStart, -skippedChars);
 			copyTokens(firstToken, stopToken, damageStart, 0);
 			insertRepairedNodes(oldTreeNode, children);
-			copyTokens(firstToken, stopToken, damageEnd - skippedChars /*+ 1*/, damageSizeChange);
+			copyTokens(firstToken, stopToken, damageEnd - skippedChars + 1, damageSizeChange);
 		} else {
 			copyTokens(firstToken, stopToken, damageStart, 0);
 		}

From karltk at strategoxt.org  Thu Dec 16 16:05:46 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:05:46 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21554 -
	spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder
Message-ID: <201012161505.oBGF5kPY027453@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:05:46 2010
New Revision: 21554
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21554&sc=1

Log:
Added AstNodeVisitor helper class.

Added:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/AstNodeVisitor.java
Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/AutoConcatList.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/IAstNode.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITreeFactory.java

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/AstNodeVisitor.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/AstNodeVisitor.java	Thu Dec 16 15:05:46 2010	(r21554)
@@ -0,0 +1,41 @@
+package org.spoofax.jsglr.client.imploder;
+
+import java.util.Iterator;
+
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public abstract class AstNodeVisitor implements IAstNodeVisitor {
+	
+	public final void visit(IAstNode tree) {
+		Iterator<IAstNode> iterator = tryGetListIterator(tree); 
+		for (int i = 0, max = tree.getChildCount(); i < max; i++) {
+			IAstNode child = iterator == null ? tree.getChildAt(i) : iterator.next();
+			if (preVisit(child)) {
+				visit(child);
+				postVisit(child);
+			}
+		}
+	}
+
+	@SuppressWarnings("unchecked")
+	protected static Iterator<IAstNode> tryGetListIterator(IAstNode tree) {
+		if (tree instanceof Iterable) {
+			return ((Iterable<IAstNode>) tree).iterator();
+		} else {
+			return null;
+		}
+	}
+}
+
+//Local interface avoids abstract method and subsequent @Override annotation requirement
+
+interface IAstNodeVisitor {
+	/**
+	 * @return true if this node should be visited and post-visited.
+	 */
+	boolean preVisit(IAstNode node);
+
+	void postVisit(IAstNode node);
+}
\ No newline at end of file

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/AutoConcatList.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/AutoConcatList.java	Thu Dec 16 15:05:42 2010	(r21553)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/AutoConcatList.java	Thu Dec 16 15:05:46 2010	(r21554)
@@ -33,7 +33,6 @@
 	
 	public AutoConcatList(String sort) {
 		this.sort = sort;
-		this.emptyListToken = emptyListToken;
 	}
 	
 	public String getSort() {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/IAstNode.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/IAstNode.java	Thu Dec 16 15:05:42 2010	(r21553)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/IAstNode.java	Thu Dec 16 15:05:46 2010	(r21554)
@@ -1,7 +1,11 @@
 package org.spoofax.jsglr.client.imploder;
 
-
 /**
+ * An interface for tree nodes with tokens.
+ * 
+ * @see ITreeFactory
+ *      A factory interface that typically constructs nodes of this type.
+ * 
  * @author Lennart Kats <lennart add lclnet.nl>
  */
 public interface IAstNode {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITreeFactory.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITreeFactory.java	Thu Dec 16 15:05:42 2010	(r21553)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITreeFactory.java	Thu Dec 16 15:05:46 2010	(r21554)
@@ -2,7 +2,14 @@
 
 import java.util.List;
 
+import org.spoofax.jsglr.client.ITreeBuilder;
+
 /**
+ * Constructs tree nodes for imploded parse trees.
+ * 
+ * @see TreeBuilder  An {@link ITreeBuilder} that creates imploded trees.
+ * @see IAstNode     An interface for tree nodes with tokens.
+ * 
  * @author Lennart Kats <lennart add lclnet.nl>
  */
 public interface ITreeFactory<TNode> {

From karltk at strategoxt.org  Thu Dec 16 16:05:50 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:05:50 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21555 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr: .
	client/imploder
Message-ID: <201012161505.oBGF5oWZ027456@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:05:49 2010
New Revision: 21555
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21555&sc=1

Log:
Minor imploder fix and CLI tuning.

Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ATermTreeFactory.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java	Thu Dec 16 15:05:46 2010	(r21554)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java	Thu Dec 16 15:05:49 2010	(r21555)
@@ -18,12 +18,16 @@
 import org.spoofax.jsglr.client.InvalidParseTableException;
 import org.spoofax.jsglr.client.ParseTable;
 import org.spoofax.jsglr.client.SGLR;
+import org.spoofax.jsglr.client.imploder.TreeBuilder;
 import org.spoofax.jsglr.shared.BadTokenException;
 import org.spoofax.jsglr.shared.SGLRException;
 import org.spoofax.jsglr.shared.Tools;
+import org.spoofax.jsglr.shared.terms.ATerm;
 import org.spoofax.jsglr.shared.terms.ATermFactory;
 
 public class Main {
+	
+	private static final String NO_OUTPUT = "-";
 
 	public static void main(String[] args) throws FileNotFoundException, IOException, InvalidParseTableException {
 
@@ -43,6 +47,7 @@
 		boolean timing = false;
 		boolean heuristicFilters = false;
 		boolean buildParseTree = true;
+		boolean implode = false;
 		int profilingRuns = 0;
 
 		for(int i=0;i<args.length;i++) {
@@ -72,6 +77,8 @@
 				timing = true;
 			} else if(args[i].equals("--no-tree-build")) {
 				buildParseTree = false;
+			} else if(args[i].equals("--implode")) {
+				implode = true;
 			} else {
 				System.err.println("Unknown option: " + args[i]);
 				System.exit(1);
@@ -95,6 +102,8 @@
 		sglr.getDisambiguator().setFilterAny(filter);
 		sglr.getDisambiguator().setHeuristicFilters(heuristicFilters);
 		sglr.setBuildParseTree(buildParseTree);
+		if (implode)
+			sglr.setTreeBuilder(new TreeBuilder());
 
 		if(waitForProfiler) {
 			System.err.println("Hit enter to start profiling...");
@@ -102,7 +111,7 @@
 		}
 
 		for(int i = 0; i < profilingRuns - 1; i++) {
-			parseFile(input, null, sglr, startSymbol);
+			parseFile(input, NO_OUTPUT, sglr, startSymbol);
 		}
 
 		final long parsingTime = parseFile(input, output, sglr, startSymbol);
@@ -122,7 +131,7 @@
 			fis = new BufferedInputStream(new FileInputStream(input));
 		}
 		OutputStream ous = null;
-		if(output != null && !"-".equals(output)) {
+		if(output != null && !NO_OUTPUT.equals(output)) {
 			ous = new FileOutputStream(output);
 		} else {
 			ous = System.out;
@@ -140,7 +149,7 @@
 			// Detailed message for other exceptions
 			System.err.println("Parsing failed : " + e);
 		}
-		if(t != null && !"-".equals(output)){
+		if(t != null && !NO_OUTPUT.equals(output)){
 			final String outputString = t.toString();
 			ous.write(outputString.getBytes());
 		}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ATermTreeFactory.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ATermTreeFactory.java	Thu Dec 16 15:05:46 2010	(r21554)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ATermTreeFactory.java	Thu Dec 16 15:05:49 2010	(r21555)
@@ -82,9 +82,17 @@
 	}
 
 	public ATermAppl createAmb(List<ATerm> alternatives) {
-		IToken leftToken = alternatives.get(0).getLeftToken();
-		IToken rightToken = alternatives.get(alternatives.size() - 1).getRightToken();
-		return createNonTerminal(null, "amb", leftToken, rightToken, alternatives);
+		IToken leftToken = null; 
+		IToken rightToken = null;
+		if (alternatives.size() > 0) {
+			leftToken = alternatives.get(0).getLeftToken();
+			rightToken = alternatives.get(alternatives.size() - 1).getRightToken();
+		}
+		
+		List<ATerm> alternativesInList = new ArrayList<ATerm>();
+		alternativesInList.add(createList(null, leftToken, rightToken, alternatives));
+		
+		return createNonTerminal(null, "amb", leftToken, rightToken, alternativesInList);
 	}
 
 	public ATermList createList(String elementSort, IToken leftToken,

From karltk at strategoxt.org  Thu Dec 16 16:05:53 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:05:53 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21556 -
	spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client
Message-ID: <201012161505.oBGF5rCD027459@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:05:53 2010
New Revision: 21556
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21556&sc=1

Log:
Fixed Disambiguator regression.

Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java	Thu Dec 16 15:05:49 2010	(r21555)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java	Thu Dec 16 15:05:53 2010	(r21556)
@@ -443,7 +443,7 @@
 				}
 			}
 		}
-		return newArgs;
+		return newArgs == null ? args : newArgs;
 	}
 
 	private static AbstractParseNode[] cloneArrayUpToIndex(AbstractParseNode[] args, int index) {

From karltk at strategoxt.org  Thu Dec 16 16:05:57 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:05:57 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21557 -
	spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client
Message-ID: <201012161505.oBGF5vHN027463@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:05:57 2010
New Revision: 21557
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21557&sc=1

Log:
Avoid needless reallocation of ParseNode.

Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java	Thu Dec 16 15:05:53 2010	(r21556)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java	Thu Dec 16 15:05:57 2010	(r21557)
@@ -8,6 +8,7 @@
 package org.spoofax.jsglr.client;
 
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
 
 import org.spoofax.jsglr.shared.SGLRException;
@@ -375,7 +376,7 @@
 				}
 			}
 
-			if (newArgs != null)
+			if (newArgs != null && args != newArgs)
 				t = new ParseNode(node.label, newArgs);
 		} else if(t instanceof ParseProductionNode) {
 			// leaf node -- do thing (cannot be any ambiguities here)

From karltk at strategoxt.org  Thu Dec 16 16:06:01 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:06:01 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21558 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr: .
	client shared/terms
Message-ID: <201012161506.oBGF610f027466@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:06:00 2010
New Revision: 21558
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21558&sc=1

Log:
Efficient output to stream for Main.java.

Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermAppl.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermInt.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermString.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermTuple.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java	Thu Dec 16 15:05:57 2010	(r21557)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java	Thu Dec 16 15:06:00 2010	(r21558)
@@ -8,12 +8,14 @@
 package org.spoofax.jsglr;
 
 import java.io.BufferedInputStream;
+import java.io.BufferedWriter;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
+import java.io.FileWriter;
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.io.Writer;
 
 import org.spoofax.jsglr.client.InvalidParseTableException;
 import org.spoofax.jsglr.client.ParseTable;
@@ -124,17 +126,19 @@
 
 	public static long parseFile(String input, String output, SGLR sglr, String startSymbol)
 	throws FileNotFoundException, IOException {
+		/* TODO: support stdin input
 		InputStream fis = null;
 		if(input == null) {
-			fis = System.in;
+			fis = new BufferedInputStream(System.in);
 		} else {
 			fis = new BufferedInputStream(new FileInputStream(input));
 		}
-		OutputStream ous = null;
+		*/
+		Writer out = null;
 		if(output != null && !NO_OUTPUT.equals(output)) {
-			ous = new FileOutputStream(output);
+			out = new BufferedWriter(new FileWriter(output));
 		} else {
-			ous = System.out;
+			out = new BufferedWriter(new OutputStreamWriter(System.out));
 		}
 
 		long parsingTime = 0;
@@ -150,8 +154,8 @@
 			System.err.println("Parsing failed : " + e);
 		}
 		if(t != null && !NO_OUTPUT.equals(output)){
-			final String outputString = t.toString();
-			ous.write(outputString.getBytes());
+			((ATerm) t).writeTo(out);
+			out.close();
 		}
 		return parsingTime;
 	}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java	Thu Dec 16 15:05:57 2010	(r21557)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Amb.java	Thu Dec 16 15:06:00 2010	(r21558)
@@ -20,9 +20,7 @@
 	private int cachedHashCode = NO_HASH_CODE;
 
 	Amb(AbstractParseNode left, AbstractParseNode right) {
-		alternatives = new AbstractParseNode[2];
-		alternatives[0] = left;
-		alternatives[1] = right;
+		alternatives = new AbstractParseNode[] { left, right };
 	}
 
 	public Amb(AbstractParseNode[] alternatives) {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java	Thu Dec 16 15:05:57 2010	(r21557)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATerm.java	Thu Dec 16 15:06:00 2010	(r21558)
@@ -1,5 +1,6 @@
 package org.spoofax.jsglr.shared.terms;
 
+import java.io.IOException;
 import java.io.Serializable;
 import java.util.LinkedList;
 import java.util.List;
@@ -104,8 +105,18 @@
 	}
 	
 	public final String toString(int depth) {
-		return toString(new StringBuilder(), depth).toString();
+		try {
+			StringBuilder result = new StringBuilder();
+			writeTo(result, depth);
+			return result.toString();
+		} catch (IOException e) {
+			throw new RuntimeException(e); // shouldn't happen for stringbuilder
+		}
+	}
+
+	public final void writeTo(Appendable a) throws IOException {
+		writeTo(a, DEFAULT_PRINT_DEPTH);
 	}
 
-	protected abstract StringBuilder toString(StringBuilder sb, int depth);
+	public abstract void writeTo(Appendable a, int depth) throws IOException;
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermAppl.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermAppl.java	Thu Dec 16 15:05:57 2010	(r21557)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermAppl.java	Thu Dec 16 15:06:00 2010	(r21558)
@@ -1,5 +1,8 @@
 package org.spoofax.jsglr.shared.terms;
 
+import java.io.IOError;
+import java.io.IOException;
+
 import org.spoofax.jsglr.client.NotImplementedException;
 
 public class ATermAppl extends ATerm {
@@ -50,7 +53,7 @@
 	}
 
 	@Override
-	protected StringBuilder toString(StringBuilder sb, int depth) {
+	public void writeTo(Appendable sb, int depth) throws IOException {
 		if(depth == 0) {
 			sb.append("...");
 		} else {
@@ -59,11 +62,10 @@
 			for(int i = 0; i < kids.length; i++) {
 				if(i > 0)
 					sb.append(",");
-				kids[i].toString(sb, depth - 1);
+				kids[i].writeTo(sb, depth - 1);
 			}
 			sb.append(')');
 		}
-		return sb;
 	}
 
 	@Override

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermInt.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermInt.java	Thu Dec 16 15:05:57 2010	(r21557)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermInt.java	Thu Dec 16 15:06:00 2010	(r21558)
@@ -1,5 +1,7 @@
 package org.spoofax.jsglr.shared.terms;
 
+import java.io.IOException;
+
 import org.spoofax.jsglr.client.NotImplementedException;
 
 public class ATermInt extends ATerm {
@@ -35,14 +37,13 @@
 	}
 
 	@Override
-	protected StringBuilder toString(StringBuilder sb, int depth) {
+	public void writeTo(Appendable sb, int depth) throws IOException {
 		if(depth == 0) {
 			sb.append("...");
 		}
 		else {
 			sb.append(Integer.toString(value));
 		}
-		return sb;
 	}
 
 	@Override

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java	Thu Dec 16 15:05:57 2010	(r21557)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermList.java	Thu Dec 16 15:06:00 2010	(r21558)
@@ -1,5 +1,6 @@
 package org.spoofax.jsglr.shared.terms;
 
+import java.io.IOException;
 import java.util.Iterator;
 
 import org.spoofax.jsglr.client.NotImplementedException;
@@ -102,14 +103,14 @@
 	}
 
 	@Override
-	protected StringBuilder toString(StringBuilder sb, int depth) {
+	public void writeTo(Appendable sb, int depth) throws IOException {
 		if(depth == 0) {
 			sb.append("...");
 		} else {
 			sb.append('[');
 			ATermList l = this;
 			while(l.element != null) {
-				l.element.toString(sb, depth - 1);
+				l.element.writeTo(sb, depth - 1);
 				l = l.next;
 				if(l.element != null) {
 					sb.append(",");
@@ -117,7 +118,6 @@
 			}
 			sb.append(']');
 		}
-		return sb;
 	}
 
 	@Override

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermString.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermString.java	Thu Dec 16 15:05:57 2010	(r21557)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermString.java	Thu Dec 16 15:06:00 2010	(r21558)
@@ -1,5 +1,7 @@
 package org.spoofax.jsglr.shared.terms;
 
+import java.io.IOException;
+
 /**
  * A String term.
  * 
@@ -53,7 +55,7 @@
 	} 
 	
 	@Override
-	protected StringBuilder toString(StringBuilder sb, int depth) {
+	public void writeTo(Appendable sb, int depth) throws IOException {
 		if(depth == 0) {
 			sb.append("...");
 		} else {
@@ -61,7 +63,6 @@
 			sb.append(value);
 			sb.append('\"');
 		}
-		return sb;
 	}
 
 	@Override

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermTuple.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermTuple.java	Thu Dec 16 15:05:57 2010	(r21557)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermTuple.java	Thu Dec 16 15:06:00 2010	(r21558)
@@ -1,5 +1,7 @@
 package org.spoofax.jsglr.shared.terms;
 
+import java.io.IOException;
+
 import org.spoofax.jsglr.client.NotImplementedException;
 
 public class ATermTuple extends ATerm {
@@ -53,7 +55,7 @@
 	}
 
 	@Override
-	protected StringBuilder toString(StringBuilder sb, int depth) {
+	public void writeTo(Appendable sb, int depth) throws IOException {
 		if(depth == 0) {
 			sb.append("...");
 		} else {
@@ -61,11 +63,10 @@
 			for(int i = 0; i < elements.length; i++) {
 				if(i > 0)
 					sb.append(",");
-				elements[i].toString(sb, depth - 1);
+				elements[i].writeTo(sb, depth - 1);
 			}
 			sb.append(')');
 		}
-		return sb;
 	}
 	
 	@Override

From karltk at strategoxt.org  Thu Dec 16 16:06:05 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:06:05 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21559 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr: .
	client/imploder
Message-ID: <201012161506.oBGF65RU027469@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:06:05 2010
New Revision: 21559
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21559&sc=1

Log:
Disabled tokenization for CLI.

Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java	Thu Dec 16 15:06:00 2010	(r21558)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java	Thu Dec 16 15:06:05 2010	(r21559)
@@ -105,7 +105,7 @@
 		sglr.getDisambiguator().setHeuristicFilters(heuristicFilters);
 		sglr.setBuildParseTree(buildParseTree);
 		if (implode)
-			sglr.setTreeBuilder(new TreeBuilder());
+			sglr.setTreeBuilder(new TreeBuilder(true));
 
 		if(waitForProfiler) {
 			System.err.println("Hit enter to start profiling...");

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java	Thu Dec 16 15:06:00 2010	(r21558)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java	Thu Dec 16 15:06:05 2010	(r21559)
@@ -35,6 +35,8 @@
 	
 	private static final String TUPLE_CONSTRUCTOR = new String("");
 	
+	private final boolean disableTokens;
+	
 	private ParseTable table;
 	
 	private ITokenizer tokenizer;
@@ -61,11 +63,17 @@
 	private boolean inLexicalContext;
 	
 	public TreeBuilder() {
+		this(true);
+	}
+	
+	public TreeBuilder(boolean disableTokens) {
+		this.disableTokens = disableTokens;
 		this.initializeFactories = true;
 	}
 	
-	public TreeBuilder(ITreeFactory treeFactory) {
+	public TreeBuilder(ITreeFactory treeFactory, boolean disableTokens) {
 		this.factory = treeFactory;
+		this.disableTokens = disableTokens;
 	}
 
 	public void initializeTable(ParseTable table, int productionCount, int labelStart, int labelCount) {
@@ -87,7 +95,9 @@
 	
 	public void initializeInput(String filename, String input) {
 		assert offset == 0;
-		tokenizer = new Tokenizer(table.getKeywordRecognizer(), filename, input);
+		tokenizer = disableTokens
+			? new DummyTokenizer(filename, input)
+			: new Tokenizer(table.getKeywordRecognizer(), filename, input);
 	}
 	
 	public ITokenizer getTokenizer() {

From karltk at strategoxt.org  Thu Dec 16 16:06:09 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:06:09 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21560 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt:
	src/org/spoofax/jsglr/client/imploder
	src/org/spoofax/jsglr/client/incremental
	test/org/spoofax/jsglr/tests
Message-ID: <201012161506.oBGF69jG027472@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:06:09 2010
New Revision: 21560
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21560&sc=1

Log:
Added new CommentDamageHandler for IncrementalSGLR. Some fixes.

Added:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/CommentDamageHandler.java
Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java	Thu Dec 16 15:06:05 2010	(r21559)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java	Thu Dec 16 15:06:09 2010	(r21560)
@@ -63,7 +63,7 @@
 	private boolean inLexicalContext;
 	
 	public TreeBuilder() {
-		this(true);
+		this(false);
 	}
 	
 	public TreeBuilder(boolean disableTokens) {
@@ -71,6 +71,10 @@
 		this.initializeFactories = true;
 	}
 	
+	public TreeBuilder(ITreeFactory treeFactory) {
+		this(treeFactory, false);
+	}
+	
 	public TreeBuilder(ITreeFactory treeFactory, boolean disableTokens) {
 		this.factory = treeFactory;
 		this.disableTokens = disableTokens;

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/CommentDamageHandler.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/CommentDamageHandler.java	Thu Dec 16 15:06:09 2010	(r21560)
@@ -0,0 +1,44 @@
+package org.spoofax.jsglr.client.incremental;
+
+import static java.lang.Math.min;
+import static org.spoofax.jsglr.client.incremental.IncrementalSGLR.DEBUG;
+
+/**
+ * A helper class that expands the damage region
+ * for incremental parsing if block comments
+ * are involved.
+ * 
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class CommentDamageHandler {
+	
+	public static final CommentDamageHandler C_STYLE = new CommentDamageHandler("/*", "*/");
+
+	private final String commentStart;
+	
+	private final String commentEnd;
+
+	public CommentDamageHandler(String commentStart, String commentEnd) {
+		this.commentStart = commentStart;
+		this.commentEnd = commentEnd;
+	}
+	
+	public int getExpandedDamageRegionEnd(String input, int damageStart, int damageEnd) {
+		// Move back to '/' if user just entered '*'
+		damageStart = min(0, damageStart - commentStart.length() + 1);
+		
+		int commentStartOffset = input.lastIndexOf(commentStart, damageEnd);
+		if (commentStartOffset >= damageStart) {
+			int result = input.indexOf(commentEnd, commentStartOffset + commentStart.length() + 1);
+			if (result == -1) {
+				if (DEBUG) System.out.println("Unterminated comment ignored"); // try to recover locally
+				return damageEnd;
+			} else {
+				return result;
+			}
+		} else {
+			return damageEnd;
+		}
+			
+	}
+}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java	Thu Dec 16 15:06:05 2010	(r21559)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java	Thu Dec 16 15:06:09 2010	(r21560)
@@ -31,16 +31,19 @@
 	
 	final Set<String> incrementalSorts;
 	
-	int lastRepairedTreeNodesCount;
+	private final CommentDamageHandler comments;
+	
+	private int lastRepairedTreeNodesCount;
 
 	/**
 	 * @param incrementalSorts
 	 *            Sorts that can be incrementally parsed (e.g., MethodDec, ImportDec).
 	 *            *Must* be sorts that only occur in lists (such as MethodDec*).
 	 */
-	public IncrementalSGLR(SGLR parser, ITreeFactory<TNode> factory, Set<String> incrementalSorts,
-			boolean includeInjections) {
+	public IncrementalSGLR(SGLR parser, CommentDamageHandler comments, ITreeFactory<TNode> factory,
+			Set<String> incrementalSorts, boolean includeInjections) {
 		this.parser = parser;
+		this.comments = comments;
 		this.factory = factory;
 		this.incrementalSorts = incrementalSorts;
 		
@@ -64,6 +67,7 @@
 		int damageSizeChange = newInput.length() - oldInput.length();
 		int damageEnd = getDamageEnd(newInput, oldInput, damageStart, damageSizeChange);
 		sanityCheckDiff(oldInput, newInput, damageStart, damageEnd, damageSizeChange);
+		damageEnd = comments.getExpandedDamageRegionEnd(newInput, damageStart, damageEnd);
 		
 		if (damageSizeChange == 0 && damageEnd == damageStart - 1) {
 			assert newInput.equals(oldInput);
@@ -141,7 +145,7 @@
 	}
 
 	@SuppressWarnings("unchecked")
-	protected static Iterator<IAstNode> tryGetListIterator(IAstNode oldTree) {
+	static Iterator<IAstNode> tryGetListIterator(IAstNode oldTree) {
 		if (oldTree.isList() && oldTree instanceof Iterable)
 			return ((Iterable<IAstNode>) oldTree).iterator();
 		else

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:06:05 2010	(r21559)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:06:09 2010	(r21560)
@@ -7,6 +7,8 @@
  */
 package org.spoofax.jsglr.tests;
 
+import static org.spoofax.jsglr.client.incremental.CommentDamageHandler.C_STYLE;
+
 import java.util.HashSet;
 import java.util.Set;
 
@@ -83,7 +85,7 @@
 			Set<String> sorts = new HashSet<String>();
 	    	for (String sort : incrementalSorts)
 	    		sorts.add(sort);
-	    	incrementalSGLR = new IncrementalSGLR<ATerm>(sglr, factory, sorts, false);
+	    	incrementalSGLR = new IncrementalSGLR<ATerm>(sglr, C_STYLE, factory, sorts, false);
 		}
 	}
 

From karltk at strategoxt.org  Thu Dec 16 16:06:12 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:06:12 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21561 -
	spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental
Message-ID: <201012161506.oBGF6CSh027475@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:06:12 2010
New Revision: 21561
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21561&sc=1

Log:
Support line comments in CommentDamageHandler.

Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/CommentDamageHandler.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/CommentDamageHandler.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/CommentDamageHandler.java	Thu Dec 16 15:06:09 2010	(r21560)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/CommentDamageHandler.java	Thu Dec 16 15:06:12 2010	(r21561)
@@ -1,11 +1,11 @@
 package org.spoofax.jsglr.client.incremental;
 
-import static java.lang.Math.min;
+import static java.lang.Math.max;
 import static org.spoofax.jsglr.client.incremental.IncrementalSGLR.DEBUG;
 
 /**
  * A helper class that expands the damage region
- * for incremental parsing if block comments
+ * for incremental parsing if block or line comments
  * are involved.
  * 
  * @author Lennart Kats <lennart add lclnet.nl>
@@ -13,6 +13,8 @@
 public class CommentDamageHandler {
 	
 	public static final CommentDamageHandler C_STYLE = new CommentDamageHandler("/*", "*/");
+	
+	public static final CommentDamageHandler ONLY_LINE_COMMENTS = new CommentDamageHandler(null, null);
 
 	private final String commentStart;
 	
@@ -25,7 +27,11 @@
 	
 	public int getExpandedDamageRegionEnd(String input, int damageStart, int damageEnd) {
 		// Move back to '/' if user just entered '*'
-		damageStart = min(0, damageStart - commentStart.length() + 1);
+		damageStart = max(0, damageStart - commentStart.length() + 1);
+		// Move to following newline, in case line comments are involved
+		damageEnd = max(damageEnd, input.indexOf('\n', damageEnd));
+		
+		if (commentStart == null) return damageEnd; 
 		
 		int commentStartOffset = input.lastIndexOf(commentStart, damageEnd);
 		if (commentStartOffset >= damageStart) {

From karltk at strategoxt.org  Thu Dec 16 16:06:18 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:06:18 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21562 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt:
	src/org/spoofax/jsglr/client/imploder
	src/org/spoofax/jsglr/client/incremental
	test/org/spoofax/jsglr/tests tests/data
Message-ID: <201012161506.oBGF6IJH027478@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:06:17 2010
New Revision: 21562
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21562&sc=1

Log:
Incremental parsing tokenization tests and corner cases working.

Added:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITreeInspector.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/CommentDamageExpander.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/NeighbourDamageExpander.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java7-increment2.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java7-increment3.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java8-increment4.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java8-increment5.java
Deleted:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/CommentDamageHandler.java
Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ATermTreeFactory.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/AstNodeVisitor.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/DummyTokenizer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/IToken.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITokenizer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITreeFactory.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Token.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Tokenizer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/DamageRegionAnalyzer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalInputBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java7-increment.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java7.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java8-increment.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java8-increment2.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java8-increment3.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java8.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ATermTreeFactory.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ATermTreeFactory.java	Thu Dec 16 15:06:12 2010	(r21561)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ATermTreeFactory.java	Thu Dec 16 15:06:17 2010	(r21562)
@@ -120,7 +120,7 @@
 		}
 	}
 
-	public String getStringTerminalValue(ATerm node) {
+	public String tryGetStringValue(ATerm node) {
 		return node.getType() == ATerm.STRING ? ((ATermString) node).getString() : null;
 	}
 
@@ -155,4 +155,12 @@
 	public IToken getRightToken(ATerm node) {
 		return node.getRightToken();
 	}
+	
+	public Iterable<ATerm> tryGetAmbChildren(ATerm node) {
+		if (node.getType() == APPL && "amb".equals(((ATermAppl) node).getName())) {
+			return (ATermList) node.getChildAt(0);
+		} else {
+			return null;
+		}
+	}
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/AstNodeVisitor.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/AstNodeVisitor.java	Thu Dec 16 15:06:12 2010	(r21561)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/AstNodeVisitor.java	Thu Dec 16 15:06:17 2010	(r21562)
@@ -8,15 +8,16 @@
  */
 public abstract class AstNodeVisitor implements IAstNodeVisitor {
 	
-	public final void visit(IAstNode tree) {
+	public final boolean visit(IAstNode tree) {
 		Iterator<IAstNode> iterator = tryGetListIterator(tree); 
 		for (int i = 0, max = tree.getChildCount(); i < max; i++) {
 			IAstNode child = iterator == null ? tree.getChildAt(i) : iterator.next();
-			if (preVisit(child)) {
-				visit(child);
-				postVisit(child);
-			}
+			preVisit(child);
+			boolean isDone = visit(child);
+			postVisit(child);
+			if (isDone || isDone()) return true;
 		}
+		return false;
 	}
 
 	@SuppressWarnings("unchecked")
@@ -27,15 +28,24 @@
 			return null;
 		}
 	}
+	
+	public void preVisit(IAstNode node) {
+		// No default implementation
+	}
+	
+	public void postVisit(IAstNode node) {
+		// No default implementation
+	}
+	
+	public boolean isDone() {
+		return false;
+	}
 }
 
 //Local interface avoids abstract method and subsequent @Override annotation requirement
 
 interface IAstNodeVisitor {
-	/**
-	 * @return true if this node should be visited and post-visited.
-	 */
-	boolean preVisit(IAstNode node);
+	void preVisit(IAstNode node);
 
 	void postVisit(IAstNode node);
 }
\ No newline at end of file

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/DummyTokenizer.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/DummyTokenizer.java	Thu Dec 16 15:06:12 2010	(r21561)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/DummyTokenizer.java	Thu Dec 16 15:06:17 2010	(r21562)
@@ -9,15 +9,18 @@
  */
 public class DummyTokenizer implements ITokenizer {
 	
-	private final IToken onlyToken = new Token(this, 0, 0, 0, 0, 0, IToken.TK_UNKNOWN);
+	private final IToken onlyToken;
 
 	private final String filename;
 	
 	private final String input;
 	
+	private boolean isAmbiguous;
+	
 	public DummyTokenizer(String filename, String input) {
 		this.filename = filename;
 		this.input = input;
+		onlyToken = new Token(this, 0, 0, 0, 0, input.length() - 1, IToken.TK_UNKNOWN);
 	}
 	
 	public String getFilename() {
@@ -47,6 +50,10 @@
 	public IToken getTokenAt(int i) {
 		return onlyToken;
 	}
+	
+	public IToken getTokenAtOffset(int o) {
+		return onlyToken;
+	}
 
 	public IToken makeToken(int endOffset, LabelInfo label) {
 		return onlyToken;
@@ -77,4 +84,12 @@
 		result.add(onlyToken);
 		return result.iterator();
 	}
+
+	public boolean isAmbigous() {
+		return isAmbiguous;
+	}
+
+	public void setAmbiguous(boolean isAmbiguous) {
+		this.isAmbiguous = isAmbiguous;
+	}
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/IToken.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/IToken.java	Thu Dec 16 15:06:12 2010	(r21561)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/IToken.java	Thu Dec 16 15:06:17 2010	(r21562)
@@ -3,7 +3,7 @@
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
  */
-public interface IToken {
+public interface IToken extends Comparable<IToken> {
 	/** Unknown token kind. */
 	public static final int TK_UNKNOWN = 0;
 	

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITokenizer.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITokenizer.java	Thu Dec 16 15:06:12 2010	(r21561)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITokenizer.java	Thu Dec 16 15:06:17 2010	(r21562)
@@ -19,6 +19,8 @@
 
 	IToken getTokenAt(int i);
 
+	IToken getTokenAtOffset(int o);
+
 	IToken makeToken(int endOffset, LabelInfo label, boolean allowEmptyToken);
 
 	IToken makeToken(int endOffset, int kind, boolean allowEmptyToken);
@@ -43,5 +45,17 @@
 	String toString(IToken left, IToken right);
 
 	String getFilename();
+	
+	/**
+	 * Determines if the tokenizer is ambiguous.
+	 * If it is, tokens with subsequent indices may not
+	 * always have matching start/end offsets.
+	 * 
+	 * @see Tokenizer#getTokenAfter(IToken)   Gets the next token with a matching offset.
+	 * @see Tokenizer#getTokenBefore(IToken)  Gets the previous token with a matching offset.
+	 */
+	boolean isAmbigous();
+	
+	void setAmbiguous(boolean isAmbiguous);
 
 }
\ No newline at end of file

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITreeFactory.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITreeFactory.java	Thu Dec 16 15:06:12 2010	(r21561)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITreeFactory.java	Thu Dec 16 15:06:17 2010	(r21562)
@@ -12,7 +12,7 @@
  * 
  * @author Lennart Kats <lennart add lclnet.nl>
  */
-public interface ITreeFactory<TNode> {
+public interface ITreeFactory<TNode> extends ITreeInspector<TNode> {
 
 	/**
 	 * Create a new non-terminal node (or a terminal with only a constructor).
@@ -54,24 +54,4 @@
 	 * Create an injection node.
 	 */
 	TNode createInjection(String sort, List<TNode> children);
-	
-	/**
-	 * Gets the string value of a string terminal, or returns null.
-	 */
-	String getStringTerminalValue(TNode node);
-	
-	/**
-	 * Gets the children of a node.
-	 */
-	Iterable<TNode> getChildren(TNode node);
-	
-	/**
-	 * Gets the left token of a node, or null if not supported/applicable.
-	 */
-	IToken getLeftToken(TNode node);
-	
-	/**
-	 * Gets the right token of a node, or null if not supported/applicable.
-	 */
-	IToken getRightToken(TNode node);
 }

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITreeInspector.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/ITreeInspector.java	Thu Dec 16 15:06:17 2010	(r21562)
@@ -0,0 +1,38 @@
+package org.spoofax.jsglr.client.imploder;
+
+/**
+ * @see ITreeFactory  Constructs tree nodes.
+ * @see IAstNode      An interface for tree nodes with tokens.
+ *
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public interface ITreeInspector<TNode> {
+	
+	/**
+	 * Gets the string value of a string terminal,
+	 * or returns null for other node types.
+	 */
+	String tryGetStringValue(TNode node);
+	
+	/**
+	 * Gets the children of a node.
+	 */
+	Iterable<TNode> getChildren(TNode node);
+	
+	/**
+	 * Gets the left token of a node, or null if not supported/applicable.
+	 */
+	IToken getLeftToken(TNode node);
+	
+	/**
+	 * Gets the right token of a node, or null if not supported/applicable.
+	 */
+	IToken getRightToken(TNode node);
+	
+	/**
+	 * Gets the ambiguous branches of an 'amb' node,
+	 * or returns null if the given node is not an 'amb' node.
+	 */
+	Iterable<TNode> tryGetAmbChildren(TNode node);
+
+}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Token.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Token.java	Thu Dec 16 15:06:12 2010	(r21561)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Token.java	Thu Dec 16 15:06:17 2010	(r21562)
@@ -59,4 +59,9 @@
 		return tokenizer.toString(this, this);
 	}
 
+	public int compareTo(IToken arg0) {
+		// TODO Auto-generated method stub
+		return 0;
+	}
+
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Tokenizer.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Tokenizer.java	Thu Dec 16 15:06:12 2010	(r21561)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/Tokenizer.java	Thu Dec 16 15:06:17 2010	(r21562)
@@ -7,6 +7,7 @@
 import static org.spoofax.jsglr.client.imploder.IToken.*;
 
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.Iterator;
 
 import org.spoofax.jsglr.client.KeywordRecognizer;
@@ -28,7 +29,7 @@
 	
 	private final String input;
 
-	private final ArrayList<IToken> tokens;
+	private final ArrayList<Token> tokens;
 	
 	/** Start of the next token. */
 	private int startOffset;
@@ -38,6 +39,8 @@
 
 	private int offsetAtLineStart;
 	
+	private boolean isAmbiguous;
+	
 	/**
 	 * Creates a new tokenizer for the given
 	 * file name (if applicable) and contents.
@@ -46,7 +49,7 @@
 		this.keywords = keywords;
 		this.filename = filename;
 		this.input = input;
-		this.tokens = new ArrayList<IToken>((int) (input.length() / EXPECTED_TOKENS_DIVIDER));
+		this.tokens = new ArrayList<Token>((int) (input.length() / EXPECTED_TOKENS_DIVIDER));
 		startOffset = 0;
 		line = 0;
 		offsetAtLineStart = 0;
@@ -67,6 +70,7 @@
 	}
 
 	public void setStartOffset(int startOffset) {
+		assert isAmbiguous;
 		this.startOffset = startOffset;
 	}
 
@@ -83,6 +87,12 @@
 	public IToken getTokenAt(int i) {
 		return tokens.get(i);
 	}
+	
+	public IToken getTokenAtOffset(int offset) {
+		Token key = new Token(this, -1, -1, -1, offset, offset, TK_RESERVED);
+		int resultIndex = Collections.binarySearch(tokens, key);
+		return resultIndex == -1 ? null : getTokenAt(resultIndex);
+	}
 
 	public IToken makeToken(int endOffset, LabelInfo label, boolean allowEmptyToken) {
 		return makeToken(endOffset, manager.getTokenKind(label), allowEmptyToken);
@@ -122,7 +132,7 @@
 	}
 
 	private IToken internalMakeToken(int kind, int endOffset) {
-		IToken result = new Token(this, tokens.size(), line, startOffset - offsetAtLineStart, startOffset, endOffset, kind);
+		Token result = new Token(this, tokens.size(), line, startOffset - offsetAtLineStart, startOffset, endOffset, kind);
 		tokens.add(result);
 		startOffset = endOffset + 1;
 		return result;
@@ -236,14 +246,38 @@
 		return token;
 	}
 	
+	/**
+	 * Gets the token with an offset following the given token,
+	 * even in an ambiguous token stream.
+	 * 
+	 * @see #isAmbiguous()
+	 */
 	public static IToken getTokenAfter(IToken token) {
 		if (token == null) return null;
-		return token.getTokenizer().getTokenAt(token.getIndex() + 1);
+		int nextOffset = token.getEndOffset();
+		ITokenizer tokens = token.getTokenizer();
+		for (int i = token.getIndex() + 1, max = tokens.getTokenCount(); i < max; i++) {
+			IToken result = tokens.getTokenAt(i);
+			if (result.getStartOffset() >= nextOffset) return result;
+		}
+		return null;
 	}
 	
+	/**
+	 * Gets the token with an offset preceding the given token,
+	 * even in an ambiguous token stream.
+	 * 
+	 * @see #isAmbiguous()
+	 */
 	public static IToken getTokenBefore(IToken token) {
 		if (token == null) return null;
-		return token.getTokenizer().getTokenAt(token.getIndex() - 1);
+		int prevOffset = token.getStartOffset();
+		ITokenizer tokens = token.getTokenizer();
+		for (int i = token.getIndex() - 1; i >= 0; i--) {
+			IToken result = tokens.getTokenAt(i);
+			if (result.getEndOffset() <= prevOffset) return result;
+		}
+		return null;
 	}
 	
 	public static int getLength(IToken token) {
@@ -280,7 +314,17 @@
 	}
 
 	public Iterator<IToken> iterator() {
-		return tokens.iterator();
+		@SuppressWarnings("unchecked") // covariance
+		Iterator<IToken> result = (Iterator<IToken>) (Iterator<?>) tokens.iterator();
+		return result;
+	}
+
+	public boolean isAmbigous() {
+		return isAmbiguous;
+	}
+
+	public void setAmbiguous(boolean isAmbiguous) {
+		this.isAmbiguous = isAmbiguous;
 	}
 
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java	Thu Dec 16 15:06:12 2010	(r21561)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java	Thu Dec 16 15:06:17 2010	(r21562)
@@ -235,6 +235,7 @@
 		final AbstractParseNode[] subnodes = a.getAlternatives();
 		final ArrayList<Object> children =
 			new ArrayList<Object>(max(EXPECTED_NODE_CHILDREN, subnodes.length));
+		tokenizer.setAmbiguous(true);
 
 		// Recurse
 		for (AbstractParseNode subnode : subnodes) {
@@ -354,7 +355,7 @@
 			return factory.createList(label.getSort(), left, right, children);
 		} else if (constructor == TUPLE_CONSTRUCTOR) {
 			return factory.createTuple(label.getSort(), left, right, children);
-		} else if (constructor == null && children.size() == 1 && factory.getStringTerminalValue(children.get(0)) != null) {
+		} else if (constructor == null && children.size() == 1 && factory.tryGetStringValue(children.get(0)) != null) {
 			// Child node was a <string> node (rare case); unpack it and create a new terminal
 			assert left == right;
 			return factory.createStringTerminal(label.getSort(), getPaddedLexicalValue(label, left), left);

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/CommentDamageExpander.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/CommentDamageExpander.java	Thu Dec 16 15:06:17 2010	(r21562)
@@ -0,0 +1,60 @@
+package org.spoofax.jsglr.client.incremental;
+
+import static java.lang.Math.max;
+import static org.spoofax.jsglr.client.incremental.IncrementalSGLR.DEBUG;
+
+/**
+ * A helper class that expands the damage region
+ * for incremental parsing if block or line comments
+ * are involved.
+ * 
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class CommentDamageExpander {
+	
+	public static final CommentDamageExpander C_STYLE = new CommentDamageExpander("/*", "*/");
+	
+	public static final CommentDamageExpander ONLY_LINE_COMMENTS = new CommentDamageExpander(null, null);
+
+	private final String commentStart;
+	
+	private final String commentEnd;
+
+	public CommentDamageExpander(String commentStart, String commentEnd) {
+		this.commentStart = commentStart;
+		this.commentEnd = commentEnd;
+	}
+	
+	public int getExpandedDamageStart(String newInput, int damageStart, int damageEnd, int damageSizeChange) {
+		// Move to preceding newline, in case line comments are involved
+		return newInput.lastIndexOf('\n', damageStart - 1) + 1;
+	}
+	
+	/**
+	 * Expands the damage region end offset to accommodate
+	 * for unclosed comment blocks and line comments.
+	 */
+	public int getExpandedDamageEnd(String newInput, int damageStart, int damageEnd, int damageSizeChange) {
+		// Move back to '/' if user just entered '*'
+		damageStart = max(0, damageStart - commentStart.length() + 1);
+		// Move to following newline, in case line comments are involved
+		damageEnd = max(damageEnd, newInput.indexOf('\n', damageEnd + damageSizeChange) - damageSizeChange);
+		
+		if (commentStart == null) return damageEnd; 
+		
+		int commentStartOffset = newInput.lastIndexOf(commentStart, damageEnd + damageSizeChange);
+		int commentEndOffset = newInput.indexOf(commentEnd, commentStartOffset + commentStart.length() + 1);
+		if (commentEndOffset == -1) {
+			if (DEBUG && commentStartOffset != -1)
+				System.out.println("Unterminated comment ignored"); // try to recover locally
+			return damageEnd;
+		} else if (commentEndOffset + commentEnd.length() <= damageStart) {
+			// Comment found, but was closed before damage region
+			return damageEnd;
+		} else {
+			assert commentEndOffset - damageSizeChange + commentEnd.length() >= damageEnd;
+			return commentEndOffset - damageSizeChange + commentEnd.length();
+		}
+			
+	}
+}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/DamageRegionAnalyzer.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/DamageRegionAnalyzer.java	Thu Dec 16 15:06:12 2010	(r21561)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/DamageRegionAnalyzer.java	Thu Dec 16 15:06:17 2010	(r21562)
@@ -40,7 +40,7 @@
 	 * Gets all non-list tree nodes from the original tree
 	 * that are in the damage region according to {@link #isDamageTreeNode}.
 	 */
-	public List<IAstNode> getDamageTreeNodes(IAstNode tree) {
+	public List<IAstNode> getDamageNodes(IAstNode tree) {
 		return getDamageRegionTreeNodes(tree, new ArrayList<IAstNode>(), true, 0);
 	}
 	
@@ -48,7 +48,7 @@
 	 * Gets all non-list tree nodes from the partial result tree
 	 * that are in the damage region according to {@link #isDamageTreeNode}.
 	 */
-	public List<IAstNode> getRepairedTreeNodes(IAstNode tree, int skippedChars) {
+	public List<IAstNode> getDamageNodesForPartialTree(IAstNode tree, int skippedChars) {
 		return getDamageRegionTreeNodes(tree, new ArrayList<IAstNode>(), false, skippedChars);
 	}
 
@@ -77,7 +77,7 @@
 		IToken current = findLeftMostLayoutToken(tree.getLeftToken());
 		IToken last = findRightMostLayoutToken(tree.getRightToken());
 		if (current != null && last != null) {
-			if (!isDamagedNonEmptyRange(
+			if (!isDamagedRange(
 					current.getStartOffset(), last.getEndOffset(), isOriginalTree, skippedChars))
 				return false;
 			if (incrementalSorts.contains(tree.getSort()))
@@ -89,7 +89,7 @@
 				IToken childRight = findRightMostLayoutToken(child.getRightToken());
 				if (childLeft != null && childRight != null) {
 					if (childLeft.getIndex() > current.getIndex()
-							&& isDamagedNonEmptyRange(
+							&& isDamagedRange(
 									current.getStartOffset(), childLeft.getStartOffset() - 1,
 									isOriginalTree, skippedChars)) {
 						return true;
@@ -97,16 +97,15 @@
 					current = childRight;
 				}
 			}
-			return isDamagedNonEmptyRange(
+			return isDamagedRange(
 					current.getEndOffset() + 1, last.getEndOffset(), isOriginalTree, skippedChars);
 		} else {
 			return false;
 		}
 	}
 	
-	private boolean isDamagedNonEmptyRange(int startOffset, int endOffset,
+	private boolean isDamagedRange(int startOffset, int endOffset,
 			boolean isOriginalTree, int skippedChars) {
-		// TODO: get rid of non-empty criterion?? at the very least for empty damage regions...
 		if (isOriginalTree) {
 			return /*endOffset >= startOffset
 				&&*/ isRangeOverlap(damageStart, damageEnd, startOffset, endOffset);

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalInputBuilder.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalInputBuilder.java	Thu Dec 16 15:06:12 2010	(r21561)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalInputBuilder.java	Thu Dec 16 15:06:17 2010	(r21562)
@@ -97,7 +97,8 @@
 			endOffset = right.getEndOffset();
 			
 			if (!isSkipping && !oldTree.isList() && incrementalSorts.contains(oldTree.getSort())
-					&& !isRangeOverlap(damageStart, damageEnd /*- damageSizeChange*/, startOffset, endOffset)) {
+					&& !isRangeOverlap(damageStart, damageEnd, startOffset, endOffset)) {
+					   // !isDamagedNodeOrLayout(left, right)) {
 				isSkipping = isSkippingStart = true;
 			}
 
@@ -121,6 +122,14 @@
 		if (isSkippingStart) isSkipping = false;
 		return result;
 	}
+
+	/*
+	private boolean isDamagedNodeOrLayout(IToken left, IToken right) {
+		int startOffset = Tokenizer.findLeftMostLayoutToken(left).getStartOffset();
+		int endOffset = Tokenizer.findRightMostLayoutToken(right).getEndOffset();
+		return isRangeOverlap(damageStart, damageEnd, startOffset, endOffset);
+	}
+	*/
 	
 	/**
 	 * Appends a token with the given startOffset

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java	Thu Dec 16 15:06:12 2010	(r21561)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java	Thu Dec 16 15:06:17 2010	(r21562)
@@ -3,6 +3,7 @@
 import static java.lang.Math.max;
 import static java.lang.Math.min;
 
+import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
@@ -23,7 +24,7 @@
  */
 public class IncrementalSGLR<TNode extends IAstNode> {
 	
-	static final boolean DEBUG = true;
+	public static boolean DEBUG = false;
 	
 	final SGLR parser;
 
@@ -31,16 +32,16 @@
 	
 	final Set<String> incrementalSorts;
 	
-	private final CommentDamageHandler comments;
+	private final CommentDamageExpander comments;
 	
-	private int lastRepairedTreeNodesCount;
+	private List<TNode> lastReconstructedNodes;
 
 	/**
 	 * @param incrementalSorts
 	 *            Sorts that can be incrementally parsed (e.g., MethodDec, ImportDec).
 	 *            *Must* be sorts that only occur in lists (such as MethodDec*).
 	 */
-	public IncrementalSGLR(SGLR parser, CommentDamageHandler comments, ITreeFactory<TNode> factory,
+	public IncrementalSGLR(SGLR parser, CommentDamageExpander comments, ITreeFactory<TNode> factory,
 			Set<String> incrementalSorts, boolean includeInjections) {
 		this.parser = parser;
 		this.comments = comments;
@@ -55,54 +56,64 @@
 	/**
 	 * Incrementally parse an input.
 	 * 
+	 * @see #getLastReconstructedNodes()
+	 *             Gets the list of tree nodes that were reconstructed
+	 *             after running {@link #parseIncremental}.
+	 * 
 	 * @throws IncrementalSGLRException
 	 *             If the input could not be incrementally parsed.
 	 *             It may still be possible to parse it non-incrementally.
 	 */
 	public TNode parseIncremental(String newInput, String filename, String startSymbol, TNode oldTree)
 			throws TokenExpectedException, BadTokenException, ParseException, SGLRException, IncrementalSGLRException {
-		
+
+		// Determine damage size
+		lastReconstructedNodes = Collections.emptyList();
 		String oldInput = oldTree.getLeftToken().getTokenizer().getInput();
 		int damageStart = getDamageStart(newInput, oldInput);
 		int damageSizeChange = newInput.length() - oldInput.length();
 		int damageEnd = getDamageEnd(newInput, oldInput, damageStart, damageSizeChange);
 		sanityCheckDiff(oldInput, newInput, damageStart, damageEnd, damageSizeChange);
-		damageEnd = comments.getExpandedDamageRegionEnd(newInput, damageStart, damageEnd);
 		
 		if (damageSizeChange == 0 && damageEnd == damageStart - 1) {
 			assert newInput.equals(oldInput);
-			lastRepairedTreeNodesCount = 0;
 			return oldTree;
 		}
+
+		// Expand damage size as needed
+		damageStart = comments.getExpandedDamageStart(newInput, damageStart, damageEnd, damageSizeChange);
+		damageEnd = comments.getExpandedDamageEnd(newInput, damageStart, damageEnd, damageSizeChange);
+		NeighbourDamageExpander neighbours = new NeighbourDamageExpander(oldTree, incrementalSorts, damageStart, damageEnd);
+		damageStart = neighbours.getExpandedDamageStart();
+		damageEnd = neighbours.getExpandedDamageEnd();
+		sanityCheckDiff(oldInput, newInput, damageStart, damageEnd, damageSizeChange);
 		
-		DamageRegionAnalyzer damageAnalyzer =
-			new DamageRegionAnalyzer(this, damageStart, damageEnd, damageSizeChange);
-		
-		IncrementalInputBuilder inputBuilder =
-			new IncrementalInputBuilder(damageAnalyzer, newInput, oldInput);
-		
-		sanityCheckOldTree(oldTree, damageAnalyzer.getDamageTreeNodes(oldTree));
+		// Analyze damage
+		DamageRegionAnalyzer damageAnalyzer = new DamageRegionAnalyzer(this, damageStart, damageEnd, damageSizeChange);
+		IncrementalInputBuilder inputBuilder = new IncrementalInputBuilder(damageAnalyzer, newInput, oldInput);
+		sanityCheckOldTree(oldTree, damageAnalyzer.getDamageNodes(oldTree));
 
+		// Construct and parse partial input
 		String partialInput = inputBuilder.buildPartialInput(oldTree);
 		int skippedChars = inputBuilder.getLastSkippedCharsBeforeDamage();
 		IAstNode partialTree = (IAstNode) parser.parse(partialInput, startSymbol);
+		List<IAstNode> repairedNodes = damageAnalyzer.getDamageNodesForPartialTree(partialTree, skippedChars);
+		sanityCheckRepairedTree(repairedNodes);
 		
-		List<IAstNode> repairedTreeNodes = damageAnalyzer.getRepairedTreeNodes(partialTree, skippedChars);
-		lastRepairedTreeNodesCount = repairedTreeNodes.size();
-		sanityCheckRepairedTree(repairedTreeNodes);
-		
-		IncrementalTreeBuilder<TNode> treeBuilder =
-			new IncrementalTreeBuilder<TNode>(this, damageAnalyzer, newInput, filename, repairedTreeNodes, skippedChars);
-
-		return treeBuilder.buildOutput(oldTree);
+		// Combine old tree with new partial tree
+		IncrementalTreeBuilder<TNode> treeBuilder = 
+			new IncrementalTreeBuilder<TNode>(this, damageAnalyzer, newInput, filename, repairedNodes, skippedChars);
+		TNode result = treeBuilder.buildOutput(oldTree);
+		lastReconstructedNodes = treeBuilder.getLastReconstructedNodes();
+		return result;
 	}
 	
 	/**
-	 * Returns the number of tree nodes that had to be
-	 * repaired for the last incremental parse task.
+	 * Returns the list of tree nodes that was reconstructed
+	 * for the last incremental parse.
 	 */
-	public int getLastRepairedTreeNodesCount() {
-		return lastRepairedTreeNodesCount;
+	public List<TNode> getLastReconstructedNodes() {
+		return lastReconstructedNodes;
 	}
 
 	private void sanityCheckDiff(String oldInput, String newInput,
@@ -121,6 +132,11 @@
 		
 		if (DEBUG) System.out.println("Damaged: " + damagedNodes);
 		
+		if (isAmbiguous(oldTree)) {
+			// Not yet supported by IncrementalTreeBuilder
+			throw new IncrementalSGLRException("Postcondition failed: old tree is ambiguous");
+		}
+		
 		for (IAstNode node : damagedNodes) {
 			if (!incrementalSorts.contains(node.getSort()))
 				throw new IncrementalSGLRException("Precondition failed: unsafe change to tree node of type "
@@ -134,11 +150,19 @@
 		if (DEBUG) System.out.println("\nRepaired: " + repairedTreeNodes);
 		
 		for (IAstNode node : repairedTreeNodes) {
-			if (!incrementalSorts.contains(node.getSort()))
+			if (!incrementalSorts.contains(node.getSort())) {
 				throw new IncrementalSGLRException("Postcondition failed: unsafe tree parsed of type "
 						+ node.getSort()  + " at line " + node.getLeftToken().getLine());
+			} else if (isAmbiguous(node)) {
+				// Not yet supported by IncrementalTreeBuilder
+				throw new IncrementalSGLRException("Postcondition failed: updated tree is ambiguous");
+			}
 		}
 	}
+	
+	private static boolean isAmbiguous(IAstNode tree) {
+		return tree.getLeftToken().getTokenizer().isAmbigous();
+	}
 
 	protected static boolean isRangeOverlap(int start1, int end1, int start2, int end2) {
 		return start1 <= end2 && start2 <= end1; // e.g. testJava55

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java	Thu Dec 16 15:06:12 2010	(r21561)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java	Thu Dec 16 15:06:17 2010	(r21562)
@@ -44,12 +44,14 @@
 	
 	private final int damageSizeChange;
 
-	private final List<IAstNode> repairedTreeNodes;
+	private final List<IAstNode> repairedNodes;
 
 	private final Tokenizer newTokenizer;
 
 	private final DamageRegionAnalyzer damageAnalyzer;
 	
+	private final List<TNode> reconstructedNodes = new ArrayList<TNode>();
+	
 	private boolean isRepairedNodesInserted;
 
 	/**
@@ -64,7 +66,7 @@
 		this.damageEnd = damageAnalyzer.damageEnd;
 		this.skippedChars = skippedChars;
 		this.damageSizeChange = damageAnalyzer.damageSizeChange;
-		this.repairedTreeNodes = repairedTreeNodes;
+		this.repairedNodes = repairedTreeNodes;
 		this.newTokenizer = new Tokenizer(parser.parser.getParseTable().getKeywordRecognizer(), filename, input);
 	}
 	
@@ -75,21 +77,27 @@
 		isRepairedNodesInserted = false;
 		TNode result = buildOutputSubtree(oldTreeNode, 0);
 		if (!isRepairedNodesInserted)
-			throw new IncrementalSGLRException("Postcondition failed: unable to insert repaired tree nodes in original tree: " + repairedTreeNodes);
+			throw new IncrementalSGLRException("Postcondition failed: unable to insert repaired tree nodes in original tree: " + repairedNodes);
 		newTokenizer.makeToken(newTokenizer.getStartOffset() - 1, TK_EOF, true);
 		return result;
 	}
 	
+	public List<TNode> getLastReconstructedNodes() {
+		return reconstructedNodes;
+	}
+	
 	private TNode buildOutputSubtree(IAstNode oldTreeNode, int offsetChange) {
 
 		final List<IAstNode> children;
 		final IToken beforeStartToken = newTokenizer.currentToken();
 		IToken startToken = oldTreeNode.getLeftToken();
 		
+		sanityCheckOldTreeNode(oldTreeNode);
+		
 		// TODO: copy tokens before first child??
 		if (oldTreeNode.isList() && incrementalSorts.contains(oldTreeNode.getElementSort())) {
 			assert offsetChange == 0 : "Nested incrementalSorts lists?";
-			children = new ArrayList<IAstNode>(oldTreeNode.getChildCount() + repairedTreeNodes.size());
+			children = new ArrayList<IAstNode>(oldTreeNode.getChildCount() + repairedNodes.size());
 
 			Iterator<IAstNode> iterator = tryGetListIterator(oldTreeNode); 
 			for (int i = 0, max = oldTreeNode.getChildCount(); i < max; i++) {
@@ -122,6 +130,15 @@
 		return buildOutputNode(oldTreeNode, children, beforeStartToken);
 	}
 
+	private void sanityCheckOldTreeNode(IAstNode oldTreeNode) {
+		// (Also checked in IncrementalSGLR precondition.)
+		// TODO: incremental parsing with ambiguous trees
+		@SuppressWarnings("unchecked")
+		TNode tOldTreeNode = (TNode) oldTreeNode;
+		assert factory.tryGetAmbChildren(tOldTreeNode) == null :
+			"Incremental tree building with ambiguities not implemented";
+	}
+
 	@SuppressWarnings("unchecked")
 	private TNode buildOutputNode(IAstNode oldTreeNode, List<IAstNode> children, IToken beforeStartToken) {
 		IToken startToken;
@@ -140,21 +157,23 @@
 			//copyTokens(firstToken, stopToken, damageStart, -skippedChars);
 			copyTokens(firstToken, stopToken, damageStart, 0);
 			insertRepairedNodes(oldTreeNode, children);
-			copyTokens(firstToken, stopToken, damageEnd - skippedChars + 1, damageSizeChange);
+			copyTokens(firstToken, stopToken, damageEnd + damageSizeChange - skippedChars + 1, damageSizeChange);
 		} else {
 			copyTokens(firstToken, stopToken, damageStart, 0);
 		}
 	}
 
 	private void insertRepairedNodes(IAstNode oldTreeNode, List<IAstNode> children) {
-		if (repairedTreeNodes.size() > 0) {
-			IToken firstToken = getTokenBefore(repairedTreeNodes.get(0).getLeftToken());
+		if (repairedNodes.size() > 0) {
+			IToken firstToken = getTokenBefore(repairedNodes.get(0).getLeftToken());
 	
-			for (IAstNode node : repairedTreeNodes) {
+			for (IAstNode node : repairedNodes) {
 				copyTokens(firstToken, node.getLeftToken(), NO_STOP_OFFSET/*node.getLeftToken().getEndOffset() + 1*/, skippedChars);
 				firstToken = getTokenAfter(node.getRightToken());
 				
-				children.add(buildOutputSubtree(node, skippedChars));
+				TNode reconstructed = buildOutputSubtree(node, skippedChars);
+				reconstructedNodes.add(reconstructed);
+				children.add(reconstructed);
 			}
 		}
 		isRepairedNodesInserted = true;
@@ -175,12 +194,17 @@
 	private void copyTokens(IToken startToken, IToken stopToken, int stopOffset, int offsetChange) {
 		ITokenizer fromTokenizer = startToken.getTokenizer();
 		assert fromTokenizer == stopToken.getTokenizer();
+		int oldStartOffset = newTokenizer.getStartOffset();
 		for (int i = findLeftMostLayoutToken(startToken).getIndex(), last = stopToken.getIndex(); i < last; i++) {
 			IToken fromToken = fromTokenizer.getTokenAt(i);
 			int myEndOffset = min(stopOffset, fromToken.getEndOffset()) + offsetChange;
+			if (myEndOffset < oldStartOffset)
+				continue;
 			IToken toToken = newTokenizer.makeToken(myEndOffset, fromToken.getKind(), isEssentialToken(fromToken));
 			assert toToken == null || myEndOffset < fromToken.getEndOffset() + offsetChange
-				|| toToken.toString().equals(fromToken.toString())
+				|| // toToken.toString().equals(fromToken.toString())
+				fromToken.toString().equals(newTokenizer.getInput().substring(
+						fromToken.getStartOffset() + offsetChange, fromToken.getEndOffset() + offsetChange + 1))
 				: "Expected '" + fromToken + "' in copied tokenstream, not '" + toToken + "'";
 		}
 	}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/NeighbourDamageExpander.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/NeighbourDamageExpander.java	Thu Dec 16 15:06:17 2010	(r21562)
@@ -0,0 +1,128 @@
+package org.spoofax.jsglr.client.incremental;
+
+import static java.lang.Math.max;
+import static java.lang.Math.min;
+import static org.spoofax.jsglr.client.incremental.IncrementalSGLR.isRangeOverlap;
+
+import java.util.Iterator;
+import java.util.Set;
+
+import org.spoofax.jsglr.client.imploder.AstNodeVisitor;
+import org.spoofax.jsglr.client.imploder.IAstNode;
+import org.spoofax.jsglr.client.imploder.IToken;
+import org.spoofax.jsglr.client.imploder.Tokenizer;
+
+/**
+ * Expands the damage region to the two
+ * neighbouring tree nodes, if they 
+ * correspond to the set of incremental sorts.
+ * 
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class NeighbourDamageExpander {
+
+	private final IAstNode oldTree;
+
+	private final Set<String> incrementalSorts;
+	
+	private final int damageStart;
+
+	private final int damageEnd;
+	
+	private IAstNode leftNeighbour;
+	
+	private IAstNode rightNeighbour;
+
+	public NeighbourDamageExpander(IAstNode oldTree, Set<String> incrementalSorts,
+			int damageStart, int damageEnd) {
+		this.oldTree = oldTree;
+		this.incrementalSorts = incrementalSorts;
+		this.damageStart = damageStart;
+		this.damageEnd = damageEnd;
+		initNeighbours();
+	}
+	
+	public int getExpandedDamageStart() {
+		if (leftNeighbour == null) {
+			return damageStart;
+		} else {
+			return min(damageStart, leftNeighbour.getLeftToken().getStartOffset());
+		}
+	}
+	
+	public int getExpandedDamageEnd() {
+		if (rightNeighbour == null) {
+			return damageEnd;
+		} else {
+			return max(damageEnd, rightNeighbour.getRightToken().getEndOffset());
+		}
+	}
+	
+	private void initNeighbours() {
+		new AstNodeVisitor() {
+			boolean done;
+			
+			public void preVisit(IAstNode node) {
+				if (node.isList() && incrementalSorts.contains(node.getElementSort())
+						&& isDamagedNode(node, true, true)) {
+					visitIncrementalSortsList(node);
+				}
+			}
+			
+			private void visitIncrementalSortsList(IAstNode list) {
+				boolean foundDamagedNode = false;
+				
+				Iterator<IAstNode> iterator = tryGetListIterator(list);
+				IAstNode lastChild = null;
+				for (int i = 0, max = list.getChildCount(); i < max; i++) {
+					IAstNode child = iterator == null ? list.getChildAt(i) : iterator.next();
+					if (!foundDamagedNode) {
+						if (isDamagedNode(child, true, true)) {
+							if (leftNeighbour == null || isLeftCollateralDamage(child))
+								leftNeighbour = child;
+							foundDamagedNode = true;
+							rightNeighbour = child; // next node, if any, replaces this value
+						} else {
+							leftNeighbour = child;
+						}
+					} else if (isDamagedNode(child, true, true)) {
+						rightNeighbour = child;
+					} else {
+						rightNeighbour = isRightCollateralDamage(rightNeighbour) ? rightNeighbour : child;
+						done = true;
+						return;
+					}
+					lastChild = child;
+				}
+				if (rightNeighbour == null) rightNeighbour = lastChild;
+			}
+			
+			public boolean isDone() {
+				return done;
+			}
+		}.visit(oldTree);
+	}
+
+	private boolean isDamagedNode(IAstNode node, boolean considerLeftLayout, boolean considerRightLayout) {
+		IToken left = node.getLeftToken();
+		IToken right = node.getRightToken();
+		if (left == null || right == null) return false;
+		if (considerLeftLayout)
+			left = Tokenizer.findLeftMostLayoutToken(left);
+		if (considerRightLayout)
+			right = Tokenizer.findRightMostLayoutToken(right);
+		int startOffset = left.getStartOffset();
+		int endOffset = right.getEndOffset();
+		return isRangeOverlap(damageStart, damageEnd, startOffset, endOffset);
+	}
+
+	private boolean isLeftCollateralDamage(IAstNode child) {
+		assert isDamagedNode(child, true, true);
+		return !isDamagedNode(child, true, false);
+	}
+
+	private boolean isRightCollateralDamage(IAstNode child) {
+		assert isDamagedNode(child, true, true);
+		return !isDamagedNode(child, false, true);
+	}
+}
\ No newline at end of file

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:06:12 2010	(r21561)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:06:17 2010	(r21562)
@@ -7,7 +7,7 @@
  */
 package org.spoofax.jsglr.tests;
 
-import static org.spoofax.jsglr.client.incremental.CommentDamageHandler.C_STYLE;
+import static org.spoofax.jsglr.client.incremental.CommentDamageExpander.C_STYLE;
 
 import java.util.HashSet;
 import java.util.Set;
@@ -37,7 +37,7 @@
 	
 	protected ParseTable table;
 
-	private IncrementalSGLR<ATerm> incrementalSGLR;
+	protected IncrementalSGLR<ATerm> incrementalSGLR;
 
 	// shared by all tests
 	static final ATermFactory pf = new ATermFactory();
@@ -86,6 +86,7 @@
 	    	for (String sort : incrementalSorts)
 	    		sorts.add(sort);
 	    	incrementalSGLR = new IncrementalSGLR<ATerm>(sglr, C_STYLE, factory, sorts, false);
+	        IncrementalSGLR.DEBUG = true;
 		}
 	}
 
@@ -139,6 +140,7 @@
 	
 	public ATerm doParseIncrementalTest(ATerm oldTree, String newFile) throws Exception {
 		String contents = loadAsString(newFile);
+		assertNotNull(contents);
 		long parseTime = System.nanoTime();
 		System.out.println("------------------------");
 		System.out.println("Parsing " + newFile);
@@ -163,7 +165,12 @@
 	}
 	
 	private void doTokenStreamEqualityTest(ATerm oldTree, ATerm newTree) {
-		System.out.println(newTree.getLeftToken().getTokenizer());
+		// Actual token equality test is now performed
+		// using assertions in IncrementalTreeBuilder
+		String tokens = newTree.getLeftToken().getTokenizer().toString();
+		if (tokens.length() > 300)
+			tokens = tokens.substring(0, 300) + "...";
+		System.out.println(tokens);
 	}
 
 	protected String loadAsString(final String testFile) {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java	Thu Dec 16 15:06:12 2010	(r21561)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java	Thu Dec 16 15:06:17 2010	(r21562)
@@ -11,7 +11,7 @@
  */
 public class TestIncrementalSGLR extends ParseTestCase {
 
-	private static ATerm java4Result, java5Result, java8Result;
+	private static ATerm java4Result, java5Result, java7Result, java8Result;
 	
     @Override
 	public void gwtSetUp() throws ParserException, InvalidParseTableException {
@@ -32,6 +32,11 @@
     	return java5Result;
     }
     
+    private ATerm getJava7Result() {
+    	if (java7Result == null) java7Result = doParseTest("java7");
+    	return java7Result;
+    }
+    
     private ATerm getJava8Result() {
     	if (java8Result == null) java8Result = doParseTest("java8");
     	return java8Result;
@@ -70,7 +75,13 @@
     }
     
     public void testJava57() throws Exception {
-    	doParseIncrementalTest(getJava5Result(), "java5-increment7");
+    	try {
+    		doParseIncrementalTest(getJava5Result(), "java5-increment7");
+    		fail("Was really expecting a failure here; comment damage expander expands to previous newline?");
+    	} catch (IncrementalSGLRException e) {
+    		assertTrue("Only allowed to fail because of comment damage expander:" + e.getMessage(),
+    				e.getMessage().indexOf("Precondition") != -1);
+    	}
     }
     
     public void testJava58() throws Exception {
@@ -94,52 +105,89 @@
     }
     
     public void testJava7() throws Exception {
-    	ATerm java7 = doParseTest("java7");
-    	ATerm java7Increment = doParseIncrementalTest(java7, "java7-increment");
-    	assertTrue("Method bar should be outside of a comment", java7.toString().contains("\"bar\""));
-    	assertFalse("Method bar should be in a comment", java7Increment.toString().contains("\"bar\""));
+    	ATerm java7 = getJava7Result();
+    	doParseIncrementalTest(java7, "java7-increment");
+    }
+    
+    public void testJava72() throws Exception {
+    	ATerm java7 = getJava7Result();
+    	doParseIncrementalTest(java7, "java7-increment2");
+    	assertFalse(isReparsed("foo"));
+    }
+    
+    public void testJava73() throws Exception {
+    	ATerm java7 = getJava7Result();
+    	doParseIncrementalTest(java7, "java7-increment3");
+    	int reparsed = incrementalSGLR.getLastReconstructedNodes().size();
+    	assertTrue("Expected 1 reparsed node: " + reparsed, reparsed <= 4);
     }
     
     public void testJava8() throws Exception {
     	ATerm java8 = getJava8Result();
     	ATerm java8Increment = doParseIncrementalTest(java8, "java8-increment");
     	assertTrue("Comment should be in input tokens", java8.getLeftToken().getTokenizer().toString().contains("comment"));
-    	assertFalse("Comment should be in output tokens", java8Increment.getLeftToken().getTokenizer().toString().contains("comment"));
+    	assertTrue("Comment should be in output tokens", java8Increment.getLeftToken().getTokenizer().toString().contains("comment"));
+    	assertTrue(isReparsed("foo"));
+    	assertFalse(isReparsed("qux"));
     }
     
     public void testJava82() throws Exception {
     	ATerm java8 = getJava8Result();
     	ATerm java8Increment = doParseIncrementalTest(java8, "java8-increment2");
     	assertTrue("Comment should be in input tokens", java8.getLeftToken().getTokenizer().toString().contains("comment"));
-    	assertFalse("Comment should be in output tokens", java8Increment.getLeftToken().getTokenizer().toString().contains("comment"));
+    	assertTrue("Comment should be in output tokens", java8Increment.getLeftToken().getTokenizer().toString().contains("comment"));
+    	// Here, qux is reparsed because comment damage handler and then neighbour damage handler
+    	// epand the damage zone
+    	// assertFalse(isReparsed("qux"));
     }
     
     public void testJava83() throws Exception {
     	ATerm java8 = getJava8Result();
     	ATerm java8Increment = doParseIncrementalTest(java8, "java8-increment3");
     	assertTrue("Comment should be in input tokens", java8.getLeftToken().getTokenizer().toString().contains("comment"));
-    	assertFalse("Comment should be in output tokens", java8Increment.getLeftToken().getTokenizer().toString().contains("comment"));
+    	assertTrue("Comment should be in output tokens", java8Increment.getLeftToken().getTokenizer().toString().contains("comment"));
+    	assertFalse(isReparsed("qux"));
     }
     
     public void testJava84() throws Exception {
     	ATerm java8 = getJava8Result();
     	ATerm java8Increment = doParseIncrementalTest(java8, "java8-increment4");
     	assertTrue("Comment should be in input tokens", java8.getLeftToken().getTokenizer().toString().contains("comment"));
-    	assertFalse("Comment should be in output tokens", java8Increment.getLeftToken().getTokenizer().toString().contains("comment"));
+    	assertTrue("Comment should be in output tokens", java8Increment.getLeftToken().getTokenizer().toString().contains("comment"));
+    	assertFalse(isReparsed("qux"));
+    }
+    
+    public void testJava85() throws Exception {
+    	ATerm java8 = getJava8Result();
+    	ATerm java8Increment = doParseIncrementalTest(java8, "java8-increment5");
+    	assertTrue("Comment should be in input tokens", java8.getLeftToken().getTokenizer().toString().contains("comment"));
+    	assertTrue("Comment should be in output tokens", java8Increment.getLeftToken().getTokenizer().toString().contains("comment"));
+    	assertFalse(isReparsed("qux"));
     }
 
     public void testJava4() throws Exception {
     	doParseIncrementalTest(getJava4Result(), "java4-increment");
-    	// TODO: test doParseIncrementalTest(java4, "java5-increment");
+    	assertTrue(isReparsed("foo"));
+    	int reparsed = incrementalSGLR.getLastReconstructedNodes().size();
+    	assertTrue("Expected 4 or fewer reparsed nodes: " + reparsed, reparsed <= 4);
     }
 
     public void testJava4vs5() throws Exception {
     	try {
+            IncrementalSGLR.DEBUG = false;
     		doParseIncrementalTest(getJava4Result(), "java5-increment");
     	} catch (IncrementalSGLRException e) {
+    		System.out.println(e.getMessage());
+    		assertTrue("Must fail on precondition", e.getMessage().indexOf("Precondition") != -1);
     		return;
+    	} finally {
+            IncrementalSGLR.DEBUG = true;
     	}
     	fail("Exception expected");
     }
+    
+    private boolean isReparsed(String substring) {
+    	return incrementalSGLR.getLastReconstructedNodes().toString().indexOf(substring) != -1;
+    }
 
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java7-increment.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java7-increment.java	Thu Dec 16 15:06:12 2010	(r21561)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java7-increment.java	Thu Dec 16 15:06:17 2010	(r21562)
@@ -7,4 +7,7 @@
   int baz() {
     /* */
   }
+  int quz() {
+    /* */
+  }
 }

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java7-increment2.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java7-increment2.java	Thu Dec 16 15:06:17 2010	(r21562)
@@ -0,0 +1,12 @@
+package java.java7;
+
+class Foo {
+  int foo();
+  int bar();
+  int baz() {
+    /*
+  }
+  int quz() {
+    /* */
+  }
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java7-increment3.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java7-increment3.java	Thu Dec 16 15:06:17 2010	(r21562)
@@ -0,0 +1,13 @@
+package java.java7;
+
+class Foo {
+  int foo();
+  int bar();
+  int baz() {
+    /* */
+	quz();
+  }
+  int quz() {
+    /* */
+  }
+}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java7.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java7.java	Thu Dec 16 15:06:12 2010	(r21561)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java7.java	Thu Dec 16 15:06:17 2010	(r21562)
@@ -1,8 +1,12 @@
 package java.java7;
 
 class Foo {
+  int foo();
   int bar();
   int baz() {
     /* */
   }
+  int quz() {
+    /* */
+  }
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java8-increment.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java8-increment.java	Thu Dec 16 15:06:12 2010	(r21561)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java8-increment.java	Thu Dec 16 15:06:17 2010	(r21562)
@@ -5,4 +5,5 @@
   int foo();
   /*comment*/
   int baz();
+  int qux();
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java8-increment2.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java8-increment2.java	Thu Dec 16 15:06:12 2010	(r21561)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java8-increment2.java	Thu Dec 16 15:06:17 2010	(r21562)
@@ -2,7 +2,8 @@
 
 class Foo {
   int bar();
-  int foo();
   /*comment*/
+  int foo();
   int baz();
+  int qux();
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java8-increment3.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java8-increment3.java	Thu Dec 16 15:06:12 2010	(r21561)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java8-increment3.java	Thu Dec 16 15:06:17 2010	(r21562)
@@ -4,4 +4,5 @@
   int bad();
   /*comment*/
   int baz();
+  int qux();
 }

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java8-increment4.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java8-increment4.java	Thu Dec 16 15:06:17 2010	(r21562)
@@ -0,0 +1,9 @@
+package java.java8;
+
+class Foo {
+  int bar();
+  public
+  /*comment*/
+  int baz();
+  int qux();
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java8-increment5.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java8-increment5.java	Thu Dec 16 15:06:17 2010	(r21562)
@@ -0,0 +1,8 @@
+package java.java8;
+
+class Foo {
+  public    
+  /*comment*/
+  int baz();
+  int qux();
+}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java8.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java8.java	Thu Dec 16 15:06:12 2010	(r21561)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java8.java	Thu Dec 16 15:06:17 2010	(r21562)
@@ -4,4 +4,5 @@
   int bar();
   /*comment*/
   int baz();
+  int qux();
 }

From karltk at strategoxt.org  Thu Dec 16 16:06:22 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:06:22 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21563 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt:
	src/org/spoofax/jsglr/client/incremental
	test/org/spoofax/jsglr/tests
Message-ID: <201012161506.oBGF6Mfi027481@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:06:22 2010
New Revision: 21563
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21563&sc=1

Log:
Avoid spurious comments and layout in IncrementalInputBuilder.

Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalInputBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalInputBuilder.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalInputBuilder.java	Thu Dec 16 15:06:17 2010	(r21562)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalInputBuilder.java	Thu Dec 16 15:06:22 2010	(r21563)
@@ -66,7 +66,7 @@
 	public String buildPartialInput(IAstNode oldTree) throws IncrementalSGLRException {
 		isSkipping = isDamagePrinted = false;
 		skippedCharsAfterDamage = skippedCharsBeforeDamage = 0;
-		StringBuilder result = appendTree(oldTree);
+		appendTree(oldTree);
 		try {
 			assert result.length() ==
 				newInput.length() - skippedCharsBeforeDamage - skippedCharsAfterDamage; 
@@ -85,7 +85,10 @@
 		return skippedCharsBeforeDamage;
 	}
 
-	private StringBuilder appendTree(IAstNode oldTree) throws IncrementalSGLRException {
+	/**
+	 * @return true if the current node was printed to the {@link #result} string.
+	 */
+	private boolean appendTree(IAstNode oldTree) throws IncrementalSGLRException {
 		IToken left = oldTree.getLeftToken();
 		IToken right = oldTree.getRightToken();
 		int startOffset = 0;
@@ -98,10 +101,11 @@
 			
 			if (!isSkipping && !oldTree.isList() && incrementalSorts.contains(oldTree.getSort())
 					&& !isRangeOverlap(damageStart, damageEnd, startOffset, endOffset)) {
-					   // !isDamagedNodeOrLayout(left, right)) {
+					   //!isDamagedNodeOrLayout(left, right)) {
 				isSkipping = isSkippingStart = true;
 			}
 
+			boolean wasSkipped = false;
 			Iterator<IAstNode> iterator = tryGetListIterator(oldTree); 
 			for (int i = 0, max = oldTree.getChildCount(); i < max; i++) {
 				IAstNode child = iterator == null ? oldTree.getChildAt(i) : iterator.next();
@@ -109,24 +113,25 @@
 				IToken childRight = child.getRightToken();
 				if (childLeft != null)
 					appendToken(startOffset, childLeft.getStartOffset() - 1);
-				appendTree(child);
+				if (wasSkipped) isSkipping = false;
+				wasSkipped = !appendTree(child);
 				if (childRight != null)
 					startOffset = childRight.getEndOffset() + 1;
 			}
 			appendToken(startOffset, endOffset);
+			if (wasSkipped) isSkipping = false;
 		} else {
 			assert oldTree.getChildCount() == 0 :
 				"No tokens for tree with children??";
 		}
 		
-		if (isSkippingStart) isSkipping = false;
-		return result;
+		return !isSkippingStart;
 	}
 
 	/*
 	private boolean isDamagedNodeOrLayout(IToken left, IToken right) {
-		int startOffset = Tokenizer.findLeftMostLayoutToken(left).getStartOffset();
-		int endOffset = Tokenizer.findRightMostLayoutToken(right).getEndOffset();
+		int startOffset = findLeftMostLayoutToken(left).getStartOffset();
+		int endOffset = findRightMostLayoutToken(right).getEndOffset();
 		return isRangeOverlap(damageStart, damageEnd, startOffset, endOffset);
 	}
 	*/

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:06:17 2010	(r21562)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:06:22 2010	(r21563)
@@ -146,7 +146,7 @@
 		System.out.println("Parsing " + newFile);
     	ATerm newTree = (ATerm) incrementalSGLR.parseIncremental(contents, newFile, null, oldTree);
 		parseTime = System.nanoTime() - parseTime;
-		System.out.println("Incremental parsing " + newFile + " took " + parseTime/1000/1000 + " millis.");
+		System.out.println("Incremental parsing " + newFile + " took " + parseTime/1000/1000 + " millis" + (IncrementalSGLR.DEBUG ? " including debug printing" : ""));
 		String extension =
 			table.getTreeBuilder() instanceof TreeBuilder ? ".itrm" : ".trm";
 		if (doCompare) {

From karltk at strategoxt.org  Thu Dec 16 16:06:26 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:06:26 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21564 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt:
	src/org/spoofax/jsglr/client/incremental
	src/org/spoofax/jsglr/shared/terms test/org/spoofax/jsglr/tests
Message-ID: <201012161506.oBGF6QCc027484@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:06:26 2010
New Revision: 21564
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21564&sc=1

Log:
Working on easier IncrementalSGLR interface with SortAnalyzer.

Added:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/SortAnalyzer.java
Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/AFun.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermAppl.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java	Thu Dec 16 15:06:22 2010	(r21563)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java	Thu Dec 16 15:06:26 2010	(r21564)
@@ -8,7 +8,6 @@
 import java.util.List;
 import java.util.Set;
 
-import org.spoofax.jsglr.client.NotImplementedException;
 import org.spoofax.jsglr.client.ParseException;
 import org.spoofax.jsglr.client.SGLR;
 import org.spoofax.jsglr.client.imploder.IAstNode;
@@ -37,20 +36,21 @@
 	private List<TNode> lastReconstructedNodes;
 
 	/**
+	 * Creates a new, reusable IncrementalSGLR instance.
+	 * 
+	 * @see SortAnalyzer#getInjectionsTo()
+	 *            Can be used to determine the injections for incrementalSorts.
+	 * 
 	 * @param incrementalSorts
 	 *            Sorts that can be incrementally parsed (e.g., MethodDec, ImportDec).
 	 *            *Must* be sorts that only occur in lists (such as MethodDec*).
 	 */
 	public IncrementalSGLR(SGLR parser, CommentDamageExpander comments, ITreeFactory<TNode> factory,
-			Set<String> incrementalSorts, boolean includeInjections) {
+			Set<String> incrementalSorts) {
 		this.parser = parser;
 		this.comments = comments;
 		this.factory = factory;
 		this.incrementalSorts = incrementalSorts;
-		
-		// TODO: support injection sorts in incrementalSorts
-		//       (using injection prods in parse table; build some class like KeywordRecognizer)
-		if (includeInjections) throw new NotImplementedException("includeInjections"); 
 	}
 	
 	/**

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java	Thu Dec 16 15:06:22 2010	(r21563)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java	Thu Dec 16 15:06:26 2010	(r21564)
@@ -87,16 +87,14 @@
 	}
 	
 	private TNode buildOutputSubtree(IAstNode oldTreeNode, int offsetChange) {
-
 		final List<IAstNode> children;
 		final IToken beforeStartToken = newTokenizer.currentToken();
 		IToken startToken = oldTreeNode.getLeftToken();
 		
 		sanityCheckOldTreeNode(oldTreeNode);
 		
-		// TODO: copy tokens before first child??
 		if (oldTreeNode.isList() && incrementalSorts.contains(oldTreeNode.getElementSort())) {
-			assert offsetChange == 0 : "Nested incrementalSorts lists?";
+			// UNDONE: assert offsetChange == 0 : "Nested incrementalSorts lists?";
 			children = new ArrayList<IAstNode>(oldTreeNode.getChildCount() + repairedNodes.size());
 
 			Iterator<IAstNode> iterator = tryGetListIterator(oldTreeNode); 

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/SortAnalyzer.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/SortAnalyzer.java	Thu Dec 16 15:06:26 2010	(r21564)
@@ -0,0 +1,79 @@
+package org.spoofax.jsglr.client.incremental;
+
+import static org.spoofax.jsglr.shared.Tools.termAt;
+import static org.spoofax.jsglr.shared.terms.ATerm.APPL;
+
+import java.util.Set;
+
+import org.spoofax.jsglr.client.Label;
+import org.spoofax.jsglr.client.ParseTable;
+import org.spoofax.jsglr.shared.terms.AFun;
+import org.spoofax.jsglr.shared.terms.ATerm;
+import org.spoofax.jsglr.shared.terms.ATermAppl;
+import org.spoofax.jsglr.shared.terms.ATermFactory;
+import org.spoofax.jsglr.shared.terms.ATermList;
+import org.spoofax.jsglr.shared.terms.ATermString;
+
+import com.google.gwt.dev.util.collect.HashSet;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class SortAnalyzer {
+
+	private final ParseTable table;
+	
+	private final AFun sortFun;
+	
+	private final AFun cfFun;
+	
+	private final AFun lexFun;
+
+	public SortAnalyzer(ParseTable table) {
+		this.table = table;
+		sortFun = table.getFactory().makeAFun("sort", 1, false);
+		cfFun = table.getFactory().makeAFun("cf", 1, false);
+		lexFun = table.getFactory().makeAFun("lex", 1, false);
+	}
+	
+	public Set<String> getInjectionsTo(String... sorts) {
+		Set<String> results = new HashSet<String>();
+		for (String sort : sorts) {
+			addInjectionsTo(sort, results);
+		}
+		return results;
+	}
+	
+	private void addInjectionsTo(String sort, Set<String> results) {
+		ATermFactory factory = table.getFactory();
+		ATerm sortTerm = factory.makeAppl(sortFun, factory.makeString(sort));
+		for (Label l : table.getLabels()) {
+			if (l != null) {
+				ATermAppl production = l.getProduction();
+				ATermAppl toSort = termAt(production, 1);
+				toSort = stripFun(toSort, cfFun);
+				toSort = stripFun(toSort, lexFun);
+				if (toSort.equals(sortTerm)) {
+					ATermList lhs = termAt(production, 0);
+					if (lhs.getChildCount() != 1) continue;
+					if (lhs.getFirst().getType() != APPL) continue;
+					ATermAppl lhsFirst = (ATermAppl) lhs.getFirst();
+					lhsFirst = stripFun(lhsFirst, cfFun);
+					lhsFirst = stripFun(lhsFirst, lexFun);
+					if (lhsFirst.getAFun() != sortFun) continue;
+					ATermString fromSort = termAt(lhsFirst, 0);
+					results.add(fromSort.getString());
+				}
+			}
+		}
+		results.add(sort);
+	}
+	
+	public ATermAppl stripFun(ATermAppl appl, AFun fun) {
+		if (appl.getAFun() == fun) {
+			return (ATermAppl) termAt(appl, 0);
+		} else {
+			return appl;
+		}
+	}
+}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/AFun.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/AFun.java	Thu Dec 16 15:06:22 2010	(r21563)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/AFun.java	Thu Dec 16 15:06:26 2010	(r21564)
@@ -28,6 +28,8 @@
 	public boolean equals(Object obj) {
 		if(!(obj instanceof AFun))
 			return false;
+		if (obj == this)
+			return true;
 		AFun o = (AFun)obj;
 		return o.arity == arity && o.name.equals(name);
 	}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermAppl.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermAppl.java	Thu Dec 16 15:06:22 2010	(r21563)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermAppl.java	Thu Dec 16 15:06:26 2010	(r21564)
@@ -1,6 +1,5 @@
 package org.spoofax.jsglr.shared.terms;
 
-import java.io.IOError;
 import java.io.IOException;
 
 import org.spoofax.jsglr.client.NotImplementedException;
@@ -73,14 +72,20 @@
 		if(!(t instanceof ATermAppl))
 			return false;
 		ATermAppl o = (ATermAppl)t;
-		if(o.kids.length != kids.length)
+		if (o.kids.length != kids.length)
 			return false;
+		if (o.ctor != ctor) {
+			if (o.factory == factory || !ctor.equals(o.ctor)) {
+				assert !ctor.equals(o.ctor) : "Constructors must be maximally shared";
+				return false;
+			}
+		}
 		for(int i = 0; i < kids.length; i++)
 			if(!kids[i].simpleMatch(o.kids[i])) {
 				System.out.println(kids[i] + "\n  !=  \n"   + o.kids[i]);
 				return false;
 			}
-		return ctor.equals(o.ctor);
+		return true;
 	}
 
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:06:22 2010	(r21563)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:06:26 2010	(r21564)
@@ -24,6 +24,7 @@
 import org.spoofax.jsglr.client.imploder.ATermTreeFactory;
 import org.spoofax.jsglr.client.imploder.TreeBuilder;
 import org.spoofax.jsglr.client.incremental.IncrementalSGLR;
+import org.spoofax.jsglr.client.incremental.SortAnalyzer;
 import org.spoofax.jsglr.shared.SGLRException;
 import org.spoofax.jsglr.shared.Tools;
 import org.spoofax.jsglr.shared.terms.ATerm;
@@ -82,10 +83,11 @@
 			ATermTreeFactory factory = new ATermTreeFactory(sglr.getFactory());
 			TreeBuilder builder = new TreeBuilder(factory);
 			sglr.setTreeBuilder(builder);
+			//Set<String> sorts = new SortAnalyzer(table).getInjectionsTo(incrementalSorts);
 			Set<String> sorts = new HashSet<String>();
 	    	for (String sort : incrementalSorts)
 	    		sorts.add(sort);
-	    	incrementalSGLR = new IncrementalSGLR<ATerm>(sglr, C_STYLE, factory, sorts, false);
+			incrementalSGLR = new IncrementalSGLR<ATerm>(sglr, C_STYLE, factory, sorts);
 	        IncrementalSGLR.DEBUG = true;
 		}
 	}

From karltk at strategoxt.org  Thu Dec 16 16:06:30 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:06:30 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21565 - in
	spoofax/branches/jsglr-gwt: . jsglr-gwt/scripts
	jsglr-gwt/src/org/spoofax/jsglr/client/incremental
	jsglr-gwt/test/org/spoofax/jsglr/tests jsglr-gwt/tests/data
Message-ID: <201012161506.oBGF6Ugm027487@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:06:30 2010
New Revision: 21565
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21565&sc=1

Log:
Collapsed revision history:
 * Some more corner cases for incremental parsing; seem to work.
 * Added ignores.
 * Added tiny script to create a GWT jar file.
 * Minor interface tweaks.
 * merge

Added:
   spoofax/branches/jsglr-gwt/jsglr-gwt/scripts/
   spoofax/branches/jsglr-gwt/jsglr-gwt/scripts/bundle.sh   (contents, props changed)
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java9-increment.java.recover
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java9-increment2.java.recover
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java9-increment3.java.recover
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java9.java.recover
Modified:
   spoofax/branches/jsglr-gwt/.hgignore
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java

Modified: spoofax/branches/jsglr-gwt/.hgignore
==============================================================================
--- spoofax/branches/jsglr-gwt/.hgignore	Thu Dec 16 15:06:26 2010	(r21564)
+++ spoofax/branches/jsglr-gwt/.hgignore	Thu Dec 16 15:06:30 2010	(r21565)
@@ -1,14 +1,7 @@
 syntax: glob
-*.class
-*.cache.*
-.metadata
-*.jar
-*.tbl
-*.trm
-*.itrm
-.sglr-log
-jsglr-gwt/war/jsglrgwt
-jsglr-gwt/war/*.tbl
-jsglr-gwt/.settings
-jsglr-gwt/war/WEB-INF/classes
-jsglr-gwt/tomcat
+jsglr-gwt/scripts/staging/*
+jsglr-gwt/scripts/*.jar
+jsglr-gwt/war/*
+jsglr-gwt/test-classes/*
+jsglr-gwt/tests/*/*.{tbl,itrm,trm}
+jsglr-gwt/tests/.jsglr-log

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/scripts/bundle.sh
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/scripts/bundle.sh	Thu Dec 16 15:06:30 2010	(r21565)
@@ -0,0 +1,7 @@
+#! /bin/bash -x
+
+mkdir -p staging/
+rsync -r ../src/ staging/
+rsync -r ../war/WEB-INF/classes/ staging/
+jar cvf jsglr-gwt-$(date +"%Y-%m-%d").jar -C staging/ .
+  
\ No newline at end of file

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java	Thu Dec 16 15:06:26 2010	(r21564)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java	Thu Dec 16 15:06:30 2010	(r21565)
@@ -66,6 +66,9 @@
 	 */
 	public TNode parseIncremental(String newInput, String filename, String startSymbol, TNode oldTree)
 			throws TokenExpectedException, BadTokenException, ParseException, SGLRException, IncrementalSGLRException {
+		
+		if (oldTree == null)
+			throw new IncrementalSGLRException("Precondition failed: oldTree is null");
 
 		// Determine damage size
 		lastReconstructedNodes = Collections.emptyList();
@@ -115,6 +118,10 @@
 	public List<TNode> getLastReconstructedNodes() {
 		return lastReconstructedNodes;
 	}
+	
+	public SGLR getParser() {
+		return parser;
+	}
 
 	private void sanityCheckDiff(String oldInput, String newInput,
 			int damageStart, int damageEnd, int damageSizeChange) throws IncrementalSGLRException {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java	Thu Dec 16 15:06:26 2010	(r21564)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java	Thu Dec 16 15:06:30 2010	(r21565)
@@ -164,6 +164,35 @@
     	assertTrue("Comment should be in output tokens", java8Increment.getLeftToken().getTokenizer().toString().contains("comment"));
     	assertFalse(isReparsed("qux"));
     }
+    
+    public void testJava912Recovery() throws Exception {
+    	suffix = "java.recover";
+    	sglr.setUseStructureRecovery(true);
+    	doCompare = false;
+    	ATerm java9 = doParseTest("java9");
+    	ATerm java91 = doParseIncrementalTest(java9,  "java9-increment");
+    	try {
+    		doParseIncrementalTest(java91, "java9-increment2");
+    	} catch (IncrementalSGLRException e) {
+    		System.out.println(e.getMessage());
+    		return; // expected
+    	}
+    	fail("Exception expected");
+    }
+    
+    public void testJava93Recovery() throws Exception {
+    	suffix = "java.recover";
+    	sglr.setUseStructureRecovery(true);
+    	doCompare = false;
+    	ATerm java9 = doParseTest("java9");
+    	try {
+    		doParseIncrementalTest(java9, "java9-increment3");
+    	} catch (IncrementalSGLRException e) {
+    		System.out.println(e.getMessage());
+    		return; // expected
+    	}
+    	fail("Exception expected");
+    }
 
     public void testJava4() throws Exception {
     	doParseIncrementalTest(getJava4Result(), "java4-increment");

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java9-increment.java.recover
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java9-increment.java.recover	Thu Dec 16 15:06:30 2010	(r21565)
@@ -0,0 +1,7 @@
+package java.java9;
+
+class Foo {
+  {
+  int baz();
+  int qux();
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java9-increment2.java.recover
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java9-increment2.java.recover	Thu Dec 16 15:06:30 2010	(r21565)
@@ -0,0 +1,9 @@
+package java.java9;
+
+class Foo {
+  int foo();
+  {
+  int baz();
+  int qux();
+  }
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java9-increment3.java.recover
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java9-increment3.java.recover	Thu Dec 16 15:06:30 2010	(r21565)
@@ -0,0 +1,8 @@
+package java.java9;
+
+class Foo {
+  {
+  int baz();
+  int qux();
+  }
+}

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java9.java.recover
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/data/java9.java.recover	Thu Dec 16 15:06:30 2010	(r21565)
@@ -0,0 +1,8 @@
+package java.java9;
+
+class Foo {
+  int foo();
+  {
+  int baz();
+  int qux();
+}

From karltk at strategoxt.org  Thu Dec 16 16:06:33 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:06:33 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21566 - in
	spoofax/branches/jsglr-gwt: . jsglr-gwt/.settings
Message-ID: <201012161506.oBGF6X6R027490@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:06:33 2010
New Revision: 21566
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21566&sc=1

Log:
Project config.

Added:
   spoofax/branches/jsglr-gwt/jsglr-gwt/.settings/com.google.gwt.eclipse.core.prefs
Modified:
   spoofax/branches/jsglr-gwt/.hgignore

Modified: spoofax/branches/jsglr-gwt/.hgignore
==============================================================================
--- spoofax/branches/jsglr-gwt/.hgignore	Thu Dec 16 15:06:30 2010	(r21565)
+++ spoofax/branches/jsglr-gwt/.hgignore	Thu Dec 16 15:06:33 2010	(r21566)
@@ -4,4 +4,4 @@
 jsglr-gwt/war/*
 jsglr-gwt/test-classes/*
 jsglr-gwt/tests/*/*.{tbl,itrm,trm}
-jsglr-gwt/tests/.jsglr-log
+jsglr-gwt/tests/.sglr-log

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/.settings/com.google.gwt.eclipse.core.prefs
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/.settings/com.google.gwt.eclipse.core.prefs	Thu Dec 16 15:06:33 2010	(r21566)
@@ -0,0 +1,5 @@
+#Mon Nov 22 11:49:04 CET 2010
+eclipse.preferences.version=1
+entryPointModules=
+filesCopiedToWebInfLib=gwt-servlet.jar
+gwtCompileSettings=PGd3dC1jb21waWxlLXNldHRpbmdzPjxsb2ctbGV2ZWw+VFJBQ0U8L2xvZy1sZXZlbD48b3V0cHV0LXN0eWxlPk9CRlVTQ0FURUQ8L291dHB1dC1zdHlsZT48ZXh0cmEtYXJncz48IVtDREFUQVtdXT48L2V4dHJhLWFyZ3M+PHZtLWFyZ3M+PCFbQ0RBVEFbLVhteDUxMm1dXT48L3ZtLWFyZ3M+PC9nd3QtY29tcGlsZS1zZXR0aW5ncz4\=

From karltk at strategoxt.org  Thu Dec 16 16:06:37 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:06:37 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21567 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt: src/org/spoofax/jsglr
	src/org/spoofax/jsglr/client test/org/spoofax/jsglr/tests
Message-ID: <201012161506.oBGF6bAO027494@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:06:36 2010
New Revision: 21567
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21567&sc=1

Log:
cleanup

Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java	Thu Dec 16 15:06:33 2010	(r21566)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java	Thu Dec 16 15:06:36 2010	(r21567)
@@ -7,13 +7,10 @@
  */
 package org.spoofax.jsglr;
 
-import java.io.BufferedInputStream;
 import java.io.BufferedWriter;
-import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileWriter;
 import java.io.IOException;
-import java.io.InputStream;
 import java.io.OutputStreamWriter;
 import java.io.Writer;
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java	Thu Dec 16 15:06:33 2010	(r21566)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Disambiguator.java	Thu Dec 16 15:06:36 2010	(r21567)
@@ -8,7 +8,6 @@
 package org.spoofax.jsglr.client;
 
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.List;
 
 import org.spoofax.jsglr.shared.SGLRException;

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:06:33 2010	(r21566)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Thu Dec 16 15:06:36 2010	(r21567)
@@ -24,7 +24,6 @@
 import org.spoofax.jsglr.client.imploder.ATermTreeFactory;
 import org.spoofax.jsglr.client.imploder.TreeBuilder;
 import org.spoofax.jsglr.client.incremental.IncrementalSGLR;
-import org.spoofax.jsglr.client.incremental.SortAnalyzer;
 import org.spoofax.jsglr.shared.SGLRException;
 import org.spoofax.jsglr.shared.Tools;
 import org.spoofax.jsglr.shared.terms.ATerm;

From karltk at strategoxt.org  Thu Dec 16 16:06:40 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:06:40 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21568 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr:
	client/incremental shared/terms
Message-ID: <201012161506.oBGF6enG027498@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:06:39 2010
New Revision: 21568
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21568&sc=1

Log:
Dependency fix.

Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/SortAnalyzer.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermInt.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/SortAnalyzer.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/SortAnalyzer.java	Thu Dec 16 15:06:36 2010	(r21567)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/incremental/SortAnalyzer.java	Thu Dec 16 15:06:39 2010	(r21568)
@@ -3,6 +3,7 @@
 import static org.spoofax.jsglr.shared.Tools.termAt;
 import static org.spoofax.jsglr.shared.terms.ATerm.APPL;
 
+import java.util.HashSet;
 import java.util.Set;
 
 import org.spoofax.jsglr.client.Label;
@@ -14,8 +15,6 @@
 import org.spoofax.jsglr.shared.terms.ATermList;
 import org.spoofax.jsglr.shared.terms.ATermString;
 
-import com.google.gwt.dev.util.collect.HashSet;
-
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
  */

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermInt.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermInt.java	Thu Dec 16 15:06:36 2010	(r21567)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/shared/terms/ATermInt.java	Thu Dec 16 15:06:39 2010	(r21568)
@@ -2,8 +2,6 @@
 
 import java.io.IOException;
 
-import org.spoofax.jsglr.client.NotImplementedException;
-
 public class ATermInt extends ATerm {
 
 	private static final long serialVersionUID = 1L;

From karltk at strategoxt.org  Thu Dec 16 16:06:43 2010
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Thu, 16 Dec 2010 15:06:43 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21569 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt:
	src/org/spoofax/jsglr/client tests tests/grammars
Message-ID: <201012161506.oBGF6hvX027501@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: Thu Dec 16 15:06:43 2010
New Revision: 21569
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21569&sc=1

Log:
* Added back Makefiles that somehow got lost in the hg-to-svn merge process.
 * Removed a spurious orig file.

Deleted:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParserHistory.java.orig
Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/Makefile
   spoofax/branches/jsglr-gwt/jsglr-gwt/tests/grammars/Makefile

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/Makefile
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/tests/Makefile	Thu Dec 16 15:06:39 2010	(r21568)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/Makefile	Thu Dec 16 15:06:43 2010	(r21569)
@@ -1,18 +1,107 @@
 
-STR_FILES = $(wildcard data/s*.str)
+B_FILES = $(wildcard data/b*.txt)
+STR_FILES = $(wildcard data/*.str)
+JAVA_FILES = $(wildcard data/*.java)
+WEBDSL_FILES = $(wildcard data/*.app)
+TRM_FILES= \
+	$(patsubst %txt,%trm, $(B_FILES)) \
+	$(patsubst %str,%trm, $(STR_FILES)) \
+	$(patsubst %java,%trm, $(JAVA_FILES)) \
+	$(patsubst %app,%trm, $(WEBDSL_FILES)) \
+	data/g-ambi-1.trm \
+	data/g-ambi-2.trm \
+	data/g-avoid-1_1.trm \
+	data/g-avoid-2_1.trm \
+	data/g-left-assoc-1.trm \
+	data/g-prefer-1_1.trm \
+	data/g-prefer-2_1.trm \
+	data/g-prio-1_1.trm \
+	data/g-prio-2_1.trm \
+	data/g-reject-1_1.trm \
+	data/g-reject-2_1.trm \
+	data/g-right-assoc-1.trm \
+	data/g1_1.trm \
+	data/g2_1.trm
+
+ITRM_FILES = $(subst .trm,.itrm,$(TRM_FILES))
+SGLR_TRACES = $(patsubst data/%.str,sglr-trace-%.txt,$(STR_FILES))
 SGLR_TRACES = $(patsubst data/%.str,sglr-trace-%.txt,$(STR_FILES))
 JSGLR_TRACES = $(patsubst data/%.str,jsglr-trace-%.txt,$(STR_FILES))
 TESTS = $(patsubst data/%.str,trace-diff-%.txt,$(STR_FILES))
 
 SGLR=$(HOME)/.nix-profile/bin/sglr
+IMPLODE=$(HOME)/.nix-profile/bin/implode-asfix
+SGLROPTS=-2 -t #-fd -fe -fi -fp -fr -t -lvd
 #../../../sglr/sglr-2.1M1/sglr/sglr/sglr
 
-all: $(TESTS) $(SGLR_TRACES) $(JSGLR_TRACES)
+all: $(TRM_FILES) $(ITRM_FILES)
+	cd grammars && make 
+	echo .$(TRM_FILES).
+
+_all: $(TESTS) $(SGLR_TRACES) $(JSGLR_TRACES)
+
+%.itrm : %.trm
+	$(IMPLODE) -i $< -o $@
+
+data/g-ambi-1.trm : data/g-ambi-1.txt
+	$(SGLR) $(SGLROPTS) -p grammars/G-ambi.tbl -i $< -o $@
+
+data/g-ambi-2.trm : data/g-ambi-2.txt
+	$(SGLR) $(SGLROPTS) -p grammars/G-ambi.tbl -i $< -o $@
+
+data/g-avoid-1_1.trm : data/g-avoid-1_1.txt
+	$(SGLR) $(SGLROPTS) -p grammars/G-avoid-1.tbl -i $< -o $@
+
+data/g-avoid-2_1.trm : data/g-avoid-2_1.txt
+	$(SGLR) $(SGLROPTS) -p grammars/G-avoid-2.tbl -i $< -o $@
+
+data/g-left-assoc-1.trm : data/g-left-assoc-1.txt
+	$(SGLR) $(SGLROPTS) -p grammars/G-left-assoc.tbl -i $< -o $@
+
+data/g-right-assoc-1.trm : data/g-right-assoc-1.txt
+	$(SGLR) $(SGLROPTS) -p grammars/G-right-assoc.tbl -i $< -o $@
+
+data/g-prefer-1_1.trm : data/g-prefer-1_1.txt
+	$(SGLR) $(SGLROPTS) -p grammars/G-prefer-1.tbl -i $< -o $@
+
+data/g-prefer-2_1.trm : data/g-prefer-2_1.txt
+	$(SGLR) $(SGLROPTS) -p grammars/G-prefer-2.tbl -i $< -o $@
+
+data/g-prio-1_1.trm : data/g-prio-1_1.txt
+	$(SGLR) $(SGLROPTS) -p grammars/G-prio-1.tbl -i $< -o $@
+
+data/g-prio-2_1.trm : data/g-prio-2_1.txt
+	$(SGLR) $(SGLROPTS) -p grammars/G-prio-2.tbl -i $< -o $@
+
+data/g-reject-1_1.trm : data/g-reject-1_1.txt
+	$(SGLR) $(SGLROPTS) -p grammars/G-reject-1.tbl -i $< -o $@
+
+data/g-reject-2_1.trm : data/g-reject-2_1.txt
+	$(SGLR) $(SGLROPTS) -p grammars/G-reject-2.tbl -i $< -o $@
+
+data/g1_1.trm : data/g1_1.txt
+	$(SGLR) $(SGLROPTS) -p grammars/G1.tbl -i $< -o $@
+
+data/g2_1.trm : data/g2_1.txt
+	$(SGLR) $(SGLROPTS) -p grammars/G2.tbl -i $< -o $@
+
+
+data/b%.trm : data/b%.txt
+	$(SGLR) $(SGLROPTS) -p grammars/Booleans.tbl -i $< -o $@
+
+data/%.trm : data/%.java
+	$(SGLR) $(SGLROPTS) -p grammars/Java-15.tbl -i $< -o $@
+
+data/%.trm : data/%.str
+	$(SGLR) $(SGLROPTS) -p grammars/Stratego.tbl -i $< -o $@
+
+data/%.trm : data/%.app
+	$(SGLR) $(SGLROPTS) -p grammars/WebDSL.tbl -i $< -o $@
 
 sglr-only: $(SGLR_TRACES)
 
 sglr-trace-%.txt : data/%.str grammars/Stratego.tbl
-	$(SGLR) -2 -fd -fe -fi -fp -fr -t -lvd -p grammars/Stratego.tbl -i $< -o sglr.trm
+	$(SGLR) $(SGLROPTS) -p grammars/Stratego.tbl -i $< -o sglr.trm
 	cat .sglr-log | egrep "^(Goto|Reducing|\#|Current|nl|Amb)" > $@
 
 jsglr-trace-%.txt : data/%.str grammars/Stratego.tbl

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/tests/grammars/Makefile
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/tests/grammars/Makefile	Thu Dec 16 15:06:39 2010	(r21568)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/tests/grammars/Makefile	Thu Dec 16 15:06:43 2010	(r21569)
@@ -1,6 +1,8 @@
 GRAMMARS =							\
 	Booleans.tbl						\
 	Stratego.tbl						\
+	Java-15.tbl						\
+	WebDSL.tbl						\
 	$(patsubst basic/%.sdf,%.tbl,$(wildcard basic/*.sdf))
 
 all : $(GRAMMARS)
@@ -29,6 +31,13 @@
 	ln -sf $< $@
 
 Stratego.tbl:
-	cp $(HOME)/.nix-profile/share/sdf/stratego-front/Stratego.tbl Stratego.tbl
+	curl http://boblycat.org/~karltk/stuff/$@ | baffle -wt -o $@
+
+Java-15.tbl:
+	curl http://boblycat.org/~karltk/stuff/$@ | baffle -wt -o $@
+
+WebDSL.tbl:
+	curl http://boblycat.org/~karltk/stuff/$@ | baffle -wt -o $@
+
 clean:
 	rm -f *.def *.tbl

From n.bruning at student.tudelft.nl  Fri Dec 17 15:43:48 2010
From: n.bruning at student.tudelft.nl (Nathan Bruning)
Date: Fri, 17 Dec 2010 14:43:48 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21570 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans
Message-ID: <201012171443.oBHEhmYx015552@proliant.st.ewi.tudelft.nl>

Author: NathanBruning
Date: Fri Dec 17 14:43:47 2010
New Revision: 21570
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21570&sc=1

Log:
Fix parameters for generated dynamic rule strategies

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/analysis.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/analysis.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/analysis.str	Thu Dec 16 15:06:43 2010	(r21569)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/analysis.str	Fri Dec 17 14:43:47 2010	(r21570)
@@ -277,14 +277,23 @@
         Declaration: cookie -> dec
       );
       // See https://svn.strategoxt.org/repos/StrategoXT/strategoxt/trunk/strc-core/lib/stratego/strc/front/lift-dynamic-rules.str
-      ![ "new", "undefine", "aux", "once", "bagof", "reverse-bagof", "bigbagof", "all-keys"
-       , "innermost-scope", "break", "break-to-label", "break-bp", "continue", "continue-to-label"
-       , "throw", "chain", "bigchain", "fold", "bigfold" ];
-      list-loop({prefix, sig, cookie':
-        ?prefix;
-        sig := ($[[prefix]-[x]], s'*, t'*);
-        rules(DeclareCookie: sig -> cookie)
-      })
+      <declare-dr-rule(|x, cookie, 0, 2)> "new";
+      <declare-dr-rule(|x, cookie, 0, 1)> "undefine";
+      <declare-dr-rule(|x, cookie, s'*, <inc> t'*)> "aux";   // FIXME: dependent on number of free variables in lhs
+      <declare-dr-rule(|x, cookie, <inc> s'*, t'*)> "reverse-bagof";
+      <declare-dr-rule(|x, cookie, 1, 0)> "innermost-scope";
+      <map(declare-dr-rule(|x, cookie, s'*, <inc> t'*))>
+        ["break-to-label","continue-to-label"];
+      <declare-dr-rule(|x, cookie, <inc> s'*, <inc> t'*)> "throw";
+      <map(declare-dr-rule(|x, cookie, <inc> s'*, t'*))>
+        ["fold", "bigfold"];
+      <map(declare-dr-rule(|x, cookie, s'*, t'*))>
+        ["once", "bagof", "bigbagof", "all-keys", "innermost-scope", "break", "break-bp", "continue", "chain", "bigchain"]
+      
+  declare-dr-rule(|x,cookie,s,t) =
+    ?prefix;
+    sig := ($[[prefix]-[x]], s, t);
+    rules(DeclareCookie: sig -> cookie)
 
   dr-scope-declare-cookies(defs, s):
     t -> t'

From L.C.L.Kats at tudelft.nl  Mon Dec 20 12:07:32 2010
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Mon, 20 Dec 2010 11:07:32 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21575 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt/src: . org/spoofax/jsglr/client
Message-ID: <201012201107.oBKB7Wpg001295@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: Mon Dec 20 11:07:32 2010
New Revision: 21575
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21575&sc=1

Log:
Merged trunk into branch

Added:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/RecoveryPerformance.java
      - copied, changed from r21570, spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/RecoveryPerformance.java
Deleted:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/java.hprof.txt
Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/FineGrainedOnRegion.java   (contents, props changed)
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/RangeList.java   (contents, props changed)
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/RecoveryConnector.java   (contents, props changed)
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java   (contents, props changed)

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/FineGrainedOnRegion.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/FineGrainedOnRegion.java	Sat Dec 18 20:29:52 2010	(r21574)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/FineGrainedOnRegion.java	Mon Dec 20 11:07:32 2010	(r21575)
@@ -17,6 +17,21 @@
         return mySGLR.getHistory();
     }
    
+    public void setInfoFGOnly(){
+        regionEndPosition=mySGLR.tokensSeen;
+        acceptRecoveryPosition=regionEndPosition+10;
+        int lastIndex=getHistory().getIndexLastLine();       
+        for (int i = 0; i < lastIndex; i++) {
+            IndentInfo line= getHistory().getLine(i);
+            if(line.getStackNodes()!=null && line.getStackNodes().size()>0){
+                BacktrackPosition btPoint=new BacktrackPosition(line.getStackNodes(), line.getTokensSeen());
+                btPoint.setIndexHistory(i);
+                choicePoints.add(btPoint);
+            }            
+        } 
+        maxPerLine=MAX_RECOVERIES_PER_LINE;
+    }
+    
     public void setRegionInfo(StructureSkipSuggestion erroneousRegion, int acceptPosition){
         regionEndPosition=erroneousRegion.getEndSkip().getTokensSeen();
         acceptRecoveryPosition=acceptPosition;
@@ -100,6 +115,7 @@
             //if(logToken==SGLR.EOF){logToken='$';}
             //System.out.print(logToken);
             if(curTokIndex<=endRecoverSearchPos && !firstRound){
+                //int oldSize=newCandidates.size();
                 newCandidates.addAll(collectNewRecoverCandidates(curTokIndex));
                 //if(newCandidates.size()>oldSize)
                   //  System.out.println("CANDIDATES: " + (newCandidates.size()-oldSize));

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/RangeList.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/RangeList.java	Sat Dec 18 20:29:52 2010	(r21574)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/RangeList.java	Mon Dec 20 11:07:32 2010	(r21575)
@@ -1,5 +1,6 @@
 package org.spoofax.jsglr.client;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -9,7 +10,9 @@
  * 
  * @author Lennart Kats <lennart add lclnet.nl>
  */
-public class RangeList {
+public class RangeList implements Serializable {
+    
+    private static final long serialVersionUID = 16593569;
     
     public static final int NONE = -1;
     

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/RecoveryConnector.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/RecoveryConnector.java	Sat Dec 18 20:29:52 2010	(r21574)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/RecoveryConnector.java	Mon Dec 20 11:07:32 2010	(r21575)
@@ -4,28 +4,34 @@
 import org.spoofax.jsglr.shared.BadTokenException;
 import org.spoofax.jsglr.shared.SGLRException;
 import org.spoofax.jsglr.shared.TokenExpectedException;
-import org.spoofax.jsglr.shared.Tools;
 
 //TODO: keep recovered lines (Testcase: two separated errors)
 public class RecoveryConnector {
     private SGLR mySGLR;
     private IRecoveryParser recoveryParser;
     private RegionRecovery skipRecovery;
-    private boolean active;
     private boolean useBridgeParser;
-    private IRecoveryResult bpResult;
     private boolean useFineGrained;
+    private boolean onlyFineGrained;
     
     
+    public void setOnlyFineGrained(boolean onlyFG) {
+        onlyFineGrained=onlyFG;        
+    }
+    
+    public void setUseFineGrained(boolean useFG) {
+        useFineGrained=useFG;        
+    }
+    
     public void setUseBridgeParser(boolean useBridgeParser) {
         this.useBridgeParser = useBridgeParser;
     }
 
     public RecoveryConnector(SGLR parser, IRecoveryParser recoveryParser){
-        useFineGrained=true;
-        active=false;
         mySGLR=parser;        
         skipRecovery = new RegionRecovery(mySGLR); 
+        useFineGrained=true;
+        onlyFineGrained=false;
         if(recoveryParser!=null){
             this.recoveryParser = recoveryParser;
             useBridgeParser=true;
@@ -38,172 +44,95 @@
     private ParserHistory getHistory() {
         return mySGLR.getHistory();
     }
-    
     public void recover() {
-        //long startSkip=System.currentTimeMillis();
-        //System.err.print("***************** Recover");
-        doRecoverSteps();
-        //long durationSkip=System.currentTimeMillis()-startSkip;
-        //System.err.print(" Recovertime: "+durationSkip);
+        mySGLR.getPerformanceMeasuring().startRecovery();
+        combinedRecover();
+        mySGLR.getPerformanceMeasuring().endRecovery();
     }
 
-    private void doRecoverSteps() {
-        active=true;
+    private void combinedRecover() {
+        if(onlyFineGrained){
+            mySGLR.getPerformanceMeasuring().startFG();
+            tryFineGrainedRepair();
+            mySGLR.getPerformanceMeasuring().endFG();
+            return;
+        }
+        mySGLR.getPerformanceMeasuring().startCG();
         boolean skipSucceeded = skipRecovery.selectErroneousFragment(); //decides whether whitespace parse makes sense
+        mySGLR.getPerformanceMeasuring().endCG();
         mySGLR.acceptingStack=null;
-        long startSkip=System.currentTimeMillis();
-        String errorFragment = skipRecovery.getErrorFragmentWithLeftMargin();
-        long durationSkip=System.currentTimeMillis()-startSkip;
-        Tools.debug("Skip time: "+ durationSkip);
-        //System.err.print("Skip time: "+ durationSkip+ "  ");
-        Tools.debug(errorFragment);
-        //System.err.print(errorFragment);
         mySGLR.activeStacks.clear();
         //BRIDGE REPAIR
         if(useBridgeParser){            
+            String errorFragment = skipRecovery.getErrorFragmentWithLeftMargin();
+            mySGLR.getPerformanceMeasuring().startBP();
             boolean succeeded = tryBridgeRepair(errorFragment);
+            mySGLR.getPerformanceMeasuring().endBP();
             if(succeeded){
-                Tools.debug("Bridge Repair Succeeded");
-                //System.err.print("************** BP-Succeeded");
                 return;
             }
-            Tools.debug("Bridge Repair Failed");
         }
-        //System.out.println("USE FG? "+useFineGrained);
         //FINEGRAINED REPAIR 
-        if(useFineGrained){            
-            long startFineGrained=System.currentTimeMillis();        
-            tryFineGrainedRepair();       
-            long durationFG=System.currentTimeMillis()-startFineGrained;
-            Tools.debug("Fine-Grained time: "+ durationFG);
-        }
-        //System.out.println("HISTORY AFTER FINE-GRAINED");
-        //getHistory().logHistory();
-        //System.err.print("Fine-Grained time: "+ durationFG);
-        //Tools.debug("Disambiguations: " +  RecoverDisambiguator.testCount);
-        if(recoverySucceeded()){
-            Tools.debug("Fine-Grained Repair Succeeded");
-            //System.err.print("**************** FG-succeeded");
-            ArrayDeque<Frame> fgStacks=new ArrayDeque<Frame>();
-            fgStacks.addAll(mySGLR.activeStacks);
-            if (skipSucceeded) { 
-                
-                boolean whiteSpaceRecovery=parseErrorFragmentAsWhiteSpace(false);
-                if(whiteSpaceRecovery)
-                    whiteSpaceRecovery=parseRemainingTokens(false);
-                if(whiteSpaceRecovery){
-                    for (Frame frame : mySGLR.activeStacks) {
-                        for (Link l : frame.getAllLinks()) {
-                            l.recoverCount = 5;
-                        }
-                    }                    
-                }
-               // ArrayDeque<Frame> wsStacks=mySGLR.activeStacks;
-                
-                //mySGLR.activeStacks.clear();
-                //whiteSpaceParse();
-                //whiteSpaceParse(errorFragment); 
-                for (Frame frame : fgStacks) {
-                    mySGLR.addStack(frame);
-                } 
-                /*
-                for (Frame frame : wsStacks) {
-                    mySGLR.addStack(frame);
-                } */  
+        if(useFineGrained){
+            mySGLR.getPerformanceMeasuring().startFG();
+            boolean FGSucceeded=tryFineGrainedRepair();
+            mySGLR.getPerformanceMeasuring().endFG();
+            if(FGSucceeded){ //FG succeeded  
+                addSkipOption(skipSucceeded);
+                return;
             }
-            //System.out.println("HISTORY AFTER FG + COLLECTING WS-STACKS");
-            //getHistory().logHistory();
-            return;
         }
-        Tools.debug("FineGrained Repair Failed");
         //WHITESPACE REPAIR
         if (skipSucceeded) { 
             getHistory().deleteLinesFrom(skipRecovery.getStartIndexErrorFragment());//TODO: integrate with FG and BP
             getHistory().resetRecoveryIndentHandler(skipRecovery.getStartLineErrorFragment().getIndentValue());
-            boolean whiteSpaceRecovery=parseErrorFragmentAsWhiteSpace(false);//true
-            //System.err.println("MMM");
-            //getHistory().logHistory();
-            if(whiteSpaceRecovery){
-                parseRemainingTokens(true);
-                //System.err.println("MMM");
-                //getHistory().logHistory();
-            }
-            //whiteSpaceParse();
-            //whiteSpaceParse(errorFragment); 
-            if(recoverySucceeded()){
-                Tools.debug("WhiteSpace Repair Succeeded");
-                //System.err.print("************* WS-succeeded");
-            }
-            else{
-                Tools.debug("WhiteSpace Repair unexpectly fails");
-                recover();
-                //System.err.print("*************** WS-Fails unexpected");
-            }/*
-            if(!parseRemainingTokens())
-                recover();*/
-        }
-        //FORCE PREFIX ACCEPT
-        /*else {            
-            EofRecovery eofR = new EofRecovery(mySGLR);
-            eofR.enforceAccept(getHistory().getBigReducePoint().getStackNodes());
-            if(recoverySucceeded()){
-                Tools.debug("Enforcing Accepting Stack - Succeeded");
-                //System.err.print("******************* AS-succeeded");
-            }
-            else{
-                Tools.debug("Enforcing Accepting Stack - Failed"); 
-              //System.err.print("******************* AS-Failed");
-            }
-        }*/
-        active = false;
+            parseErrorFragmentAsWhiteSpace(false);
+            parseRemainingTokens(true);
+        }
+    }
+
+    private void addSkipOption(boolean skipSucceeded) {
+        ArrayDeque<Frame> fgStacks=new ArrayDeque<Frame>();
+        fgStacks.addAll(mySGLR.activeStacks);
+        if(skipSucceeded && parseErrorFragmentAsWhiteSpace(false) && parseRemainingTokens(false)){
+            for (Frame frame : mySGLR.activeStacks) {
+                for (Link l : frame.getAllLinks()) {
+                    l.recoverCount = 5;
+                }
+            }                        
+            for (Frame frame : fgStacks) {
+                mySGLR.addStack(frame);
+            } 
+        }
     }
     
     private boolean recoverySucceeded() {
-        boolean hasSucceeded = (mySGLR.activeStacks.size()>0 || mySGLR.acceptingStack!=null);
-        /*
-        if(hasSucceeded){           
-            ArrayList<IndentInfo> recoverNewLinePoints = new ArrayList<IndentInfo>();            
-            IndentInfo currentStatus = new IndentInfo(mySGLR.lineNumber, getHistory().getTokenIndex(), mySGLR.getIndentHandler().getIndentValue());
-            recoverNewLinePoints.add(currentStatus);
-            getHistory().addRecoverLines(recoverNewLinePoints);
-        }
-        */
-        return hasSucceeded;
-    }
-
-    private void whiteSpaceParse() {
-        String errorFragment=skipRecovery.getErrorFragment();
-        mySGLR.activeStacks.addAll(skipRecovery.getStartLineErrorFragment().getStackNodes());            
-        tryParsing(errorFragment, true);
-        parseRemainingTokens(true);
-    }
-
-    private void tryFineGrainedRepair() {
-        FineGrainedOnRegion fgRepair=new FineGrainedOnRegion(mySGLR);        
-        fgRepair.setRegionInfo(skipRecovery.getErroneousRegion(), skipRecovery.getAcceptPosition());
+        return (mySGLR.activeStacks.size()>0 || mySGLR.acceptingStack!=null);
+    }
+
+    private boolean tryFineGrainedRepair() {
+        FineGrainedOnRegion fgRepair=new FineGrainedOnRegion(mySGLR); 
+        if(!onlyFineGrained){
+            fgRepair.setRegionInfo(skipRecovery.getErroneousRegion(), skipRecovery.getAcceptPosition());
+        }
+        else{
+            fgRepair.setInfoFGOnly();
+        }
         fgRepair.recover();
         fgRepair.parseRemainingTokens();
-        /*if(!fgRepair.parseRemainingTokens())
-            recover();*/
+        return recoverySucceeded();
     }
-    /*
-    private void tryFineGrainedRepair() throws IOException {
-        FineGrainedRepair fineGrained=new FineGrainedRepair(mySGLR);   
-        fineGrained.setBpSuggestions(getBPSuggestions());
-        fineGrained.findRecoverBranch(skipRecovery.getSkippedLines(), skipRecovery.getEndPositionErrorFragment());        
-    }*/
 
     private boolean tryBridgeRepair(String errorFragment) {
         String repairedFragment = repairBridges(errorFragment);
         mySGLR.activeStacks.addAll(skipRecovery.getStartLineErrorFragment().getStackNodes());   
         tryParsing(repairedFragment, false);      
-        parseRemainingTokens(true);
-        return recoverySucceeded();
+        return parseRemainingTokens(true);
     }
 
-    private String repairBridges(String errorFragment) {
+    private String repairBridges(String errorFragment) {        
         try {            
-            bpResult = null;
+            IRecoveryResult bpResult = null;
             bpResult = recoveryParser.recover(errorFragment);
             return bpResult.getResult();
         } catch (TokenExpectedException e) {
@@ -215,19 +144,15 @@
         } catch (Exception e) {
             e.printStackTrace();
         }
-        return "/*" + errorFragment + "*/";
+        return  errorFragment;
     }
     
     private void tryParsing(String fragment, boolean asLayout) {
         // Skip any leading whitespace, since we already parsed up to that point
-        int indexFragment = findFirstNonLayoutToken(fragment);      
-        //System.out.println("&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&");
+        int indexFragment = findFirstNonLayoutToken(fragment);
         while(indexFragment<fragment.length() && mySGLR.activeStacks.size()>0) {                        
             mySGLR.currentToken=fragment.charAt(indexFragment);
-            //System.out.print((char)mySGLR.currentToken);
-            //Tools.debug((char)mySGLR.currentToken);
             indexFragment++;
-            
             if(!asLayout)
                 mySGLR.doParseStep();
             else
@@ -257,7 +182,7 @@
             //System.out.print((char)mySGLR.currentToken);
             mySGLR.doParseStep();            
         }  
-        return mySGLR.activeStacks.size()>0 || mySGLR.acceptingStack!=null;
+        return recoverySucceeded();
     }
 
     
@@ -282,13 +207,28 @@
             indexFragment++;
         return indexFragment;
     }
-
-    public boolean isActive() {        
-        return active;
+    
+    /*
+    private Map<Integer, char[]> getBPSuggestions(){
+        Map<Integer, char[]> bpSuggestions = getBridges();
+        int startPos = skipRecovery.getStartPositionErrorFragment_InclLeftMargin();
+        
+        Map<Integer, char[]> bpSuggestAbsolute = new HashMap<Integer, char[]>();
+        for (Integer aKey : bpSuggestions.keySet()) {
+            Integer newKey=new Integer(startPos+aKey.intValue());
+            char[] newValue=bpSuggestions.get(aKey);
+            bpSuggestAbsolute.put(newKey, newValue);
+        }
+        return bpSuggestAbsolute;
     }
 
-    public void setUseFineGrained(boolean useFG) {
-        useFineGrained=useFG;        
+    private Map<Integer, char[]> getBridges() {
+        IRecoveryResult bpResult;
+        if (bpResult != null) {
+            return bpResult.getSuggestions();
+        }
+        return new HashMap<Integer, char[]>();
     }
+    */
 
 }

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/RecoveryPerformance.java (from r21570, spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/RecoveryPerformance.java)
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/RecoveryPerformance.java	Fri Dec 17 14:43:47 2010	(r21570, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/RecoveryPerformance.java	Mon Dec 20 11:07:32 2010	(r21575)
@@ -1,4 +1,4 @@
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.client;
 
 import java.util.ArrayList;
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Sat Dec 18 20:29:52 2010	(r21574)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Mon Dec 20 11:07:32 2010	(r21575)
@@ -22,6 +22,8 @@
 
 public class SGLR {
 
+    private RecoveryPerformance performanceMeasuring;
+
 	private final Set<BadTokenException> collectedErrors = new LinkedHashSet<BadTokenException>();
 
 	public static final int EOF = ParseTable.NUM_CHARS;
@@ -38,7 +40,7 @@
 
 	private long startTime;
 
-	private volatile boolean asyncAborted;
+	protected volatile boolean asyncAborted;
 
 	private ATermFactory factory;
 
@@ -79,6 +81,8 @@
 	private int rejectCount;
 
 	private int reductionCount;
+	
+	protected int timeout;
 
 	private PushbackStringIterator currentInputStream;
 
@@ -99,12 +103,7 @@
 		return history;
 	}
 
-	/* START: FINE GRAINED ON REGION */
 	private boolean fineGrainedOnRegion;
-	protected void setFineGrainedOnRegion(boolean fineGrainedMode) {
-		fineGrainedOnRegion = fineGrainedMode;
-		recoverStacks = new ArrayDeque<Frame>();
-	}
 
 	public void clearRecoverStacks(){
 		recoverStacks.clear(false);
@@ -115,20 +114,29 @@
 		return recoverStacks;
 	}
 
-	protected void setUseFineGrained(boolean useFG) {
-		recoverIntegrator.setUseFineGrained(useFG);
-	}
-	/* END: FINE GRAINED ON REGION */
-
 	public Set<BadTokenException> getCollectedErrors() {
 		return collectedErrors;
 	}
+    
+    /**
+     * Attempts to set a timeout for parsing.
+     * Default implementation is a no-op.
+     * 
+     * @see org.spoofax.jsglr.SGLR#setTimeout(int)
+     */
+    public void setTimeout(int timeout) {
+        this.timeout = timeout;
+    }
+    
+    protected void initParseTimer() {
+        // Default does nothing (not supported by GWT)
+    }
 
 	SGLR() {
 		basicInit(null);
 	}
 
-	public SGLR(final ATermFactory pf, ParseTable parseTable) {
+	public SGLR(ATermFactory pf, ParseTable parseTable) {
 		assert pf != null;
 		assert parseTable != null;
 		// Init with a new factory for both serialized or BAF instances.
@@ -148,6 +156,36 @@
 	public final void setUseStructureRecovery(boolean useRecovery) throws NoRecoveryRulesException {
 		setUseStructureRecovery(useRecovery, null);
 	}
+	
+    protected void setFineGrainedOnRegion(boolean fineGrainedMode) {
+        fineGrainedOnRegion = fineGrainedMode;
+        recoverStacks = new ArrayDeque<Frame>();
+    }
+
+    @Deprecated
+    protected void setUseFineGrained(boolean useFG) {
+        recoverIntegrator.setUseFineGrained(useFG);
+    }
+
+    // FIXME: we have way to many of these accessors; does this have to be public?
+    //        if not for normal use, it should at least be 'internalSet....'
+    @Deprecated
+    public void setCombinedRecovery(boolean useBP, boolean useFG,
+            boolean useOnlyFG) {
+        recoverIntegrator.setOnlyFineGrained(useOnlyFG);
+        recoverIntegrator.setUseBridgeParser(useBP);
+        recoverIntegrator.setUseFineGrained(useFG);
+    }
+
+    // LK: this thing gets reset every time; why a setter?
+    @Deprecated
+    public void setPerformanceMeasuring(RecoveryPerformance performanceMeasuring) {
+        this.performanceMeasuring = performanceMeasuring;
+    }
+
+    public RecoveryPerformance getPerformanceMeasuring() {
+        return performanceMeasuring;
+    }
 
 	/**
 	 * @deprecated Use {@link #asyncCancel()} instead.
@@ -214,7 +252,11 @@
 		String filename = null; // TODO: get filename from some place; useful for errors
 		initParseVariables(filename, fis);
 		startTime = System.currentTimeMillis();
-		return sglrParse(startSymbol);
+		initParseTimer();
+        getPerformanceMeasuring().startParse();
+        Object result = sglrParse(startSymbol);
+        getPerformanceMeasuring().endParse();
+        return result;
 	}
 
 	public final Object parse(String input) throws BadTokenException,
@@ -290,6 +332,8 @@
 		currentInputStream = new PushbackStringIterator(input);
 		acceptingStack = null;
 		collectedErrors.clear();
+		history=new ParserHistory();
+		performanceMeasuring=new RecoveryPerformance();
 		parseTable.getTreeBuilder().initializeInput(filename, input);
 		PooledPathList.resetPerformanceCounters();
 		PathListPool.resetPerformanceCounters();

From L.C.L.Kats at tudelft.nl  Mon Dec 20 12:17:30 2010
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Mon, 20 Dec 2010 11:17:30 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21576 -
	spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr
Message-ID: <201012201117.oBKBHUh7001389@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: Mon Dec 20 11:17:30 2010
New Revision: 21576
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21576&sc=1

Log:
Added a new (stub) class for SGLR with streams and timers, and restored the ParseTableManager. The client SGLR class should probably be called ClientSGLR in the future.

Added:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseTableManager.java
      - copied, changed from r21570, spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/ParseTableManager.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/SGLR.java

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseTableManager.java (from r21570, spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/ParseTableManager.java)
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/ParseTableManager.java	Fri Dec 17 14:43:47 2010	(r21570, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseTableManager.java	Mon Dec 20 11:17:30 2010	(r21576)
@@ -19,9 +19,11 @@
 import java.util.HashMap;
 import java.util.Map;
 
-import aterm.ATerm;
-import aterm.ATermFactory;
-import aterm.pure.PureFactory;
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParseTable;
+import org.spoofax.jsglr.shared.Tools;
+import org.spoofax.jsglr.shared.terms.ATerm;
+import org.spoofax.jsglr.shared.terms.ATermFactory;
 
 public class ParseTableManager {
     
@@ -33,7 +35,7 @@
     private boolean useDiskCache;
     
     public ParseTableManager() {
-        this(new PureFactory());
+        this(new ATermFactory());
     }
     
     public ParseTableManager(ATermFactory factory) {

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/SGLR.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/SGLR.java	Mon Dec 20 11:17:30 2010	(r21576)
@@ -0,0 +1,58 @@
+package org.spoofax.jsglr;
+
+import java.util.Timer;
+import java.util.TimerTask;
+
+import org.spoofax.jsglr.client.ParseTable;
+import org.spoofax.jsglr.client.ParseTimeoutException;
+import org.spoofax.jsglr.shared.terms.ATermFactory;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class SGLR extends org.spoofax.jsglr.client.SGLR {
+
+    private static final Timer abortTimer = new Timer(true);
+
+    private int abortTimerJobId;
+
+    /**
+     * Sets the maximum amount of time to try and parse a file, before a
+     * {@link ParseTimeoutException} is thrown.
+     * 
+     * @param timeout
+     *            The maximum time to parse, in milliseconds.
+     */
+    @Override
+    public void setTimeout(int timeout) {
+        this.timeout = timeout;
+    }
+
+    @Override
+    protected void initParseTimer() {
+        if (timeout > 0) {
+            // We use a single shared timer to conserve native threads
+            // and a jobId to recognize stale abort events
+            synchronized (abortTimer) {
+                asyncAborted = false;
+                ++abortTimerJobId;
+            }
+            final int jobId = abortTimerJobId;
+            abortTimer.schedule(new TimerTask() {
+                @Override
+                public void run() {
+                    synchronized (abortTimer) {
+                        if (abortTimerJobId == jobId)
+                            asyncCancel();
+                    }
+                }
+            }, timeout);
+        } else {
+            asyncAborted = false;
+        }
+    }
+
+    public SGLR(ATermFactory pf, ParseTable parseTable) {
+        super(pf, parseTable);
+    }
+}

From L.C.L.Kats at tudelft.nl  Mon Dec 20 12:37:30 2010
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Mon, 20 Dec 2010 11:37:30 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21577 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr: . client
Message-ID: <201012201137.oBKBbUV4001761@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: Mon Dec 20 11:37:30 2010
New Revision: 21577
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21577&sc=1

Log:
Reintroduced stream-based public API.

Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/FileTools.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseTableManager.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/SGLR.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/FileTools.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/FileTools.java	Mon Dec 20 11:17:30 2010	(r21576)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/FileTools.java	Mon Dec 20 11:37:30 2010	(r21577)
@@ -3,20 +3,36 @@
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.IOException;
+import java.io.Reader;
 
 public class FileTools {
 
-	public static String loadFileAsString(String fn) {
-		// FIXME (KTK) static allocation of 15MB must be replaced with something dynamic  
-		char[] cbuf = new char[1024*1024*15];
-		try {
-			BufferedReader br = new BufferedReader(new FileReader(fn));
-			int len = br.read(cbuf);
-			return new String(cbuf, 0, len);
-		} catch (IOException e) {
-			e.printStackTrace();
-			return null;
-		}
-	}
+    private static char[] asyncBuffer = new char[4096];
+
+    @Deprecated
+    public static String loadFileAsString(String fn) {
+        return tryLoadFileAsString(fn);
+    }
+
+    public static String tryLoadFileAsString(String fn) {
+        try {
+            return loadFileAsString(new FileReader(fn));
+        } catch (IOException e) {
+            e.printStackTrace();
+            return null;
+        }
+    }
+    
+    public static String loadFileAsString(Reader reader) throws IOException {
+        StringBuilder result = new StringBuilder();
+        BufferedReader bufferedReader = new BufferedReader(reader);
+        synchronized (asyncBuffer) {
+            int read;
+            while ((read = bufferedReader.read(asyncBuffer)) > 0) {
+                result.append(asyncBuffer, 0, read);
+            }
+            return result.toString();
+        }
+    }
 
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseTableManager.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseTableManager.java	Mon Dec 20 11:17:30 2010	(r21576)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseTableManager.java	Mon Dec 20 11:37:30 2010	(r21577)
@@ -13,6 +13,7 @@
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.io.InputStreamReader;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.lang.ref.WeakReference;
@@ -114,7 +115,9 @@
             throw new InvalidParseTableException("stream is null");
         }
 
-        return initializeParseTable(factory.readFromFile(stream));
+        // TODO: optimize - load table directly from stream
+        String tableString = FileTools.loadFileAsString(new InputStreamReader(stream));
+        return initializeParseTable(factory.parseFromString(tableString));
     }
 
 	private ParseTable initializeParseTable(ATerm pt) throws InvalidParseTableException {

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/SGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/SGLR.java	Mon Dec 20 11:17:30 2010	(r21576)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/SGLR.java	Mon Dec 20 11:37:30 2010	(r21577)
@@ -1,12 +1,20 @@
 package org.spoofax.jsglr;
 
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
 import java.util.Timer;
 import java.util.TimerTask;
 
+import org.spoofax.jsglr.client.ParseException;
 import org.spoofax.jsglr.client.ParseTable;
 import org.spoofax.jsglr.client.ParseTimeoutException;
+import org.spoofax.jsglr.shared.BadTokenException;
+import org.spoofax.jsglr.shared.SGLRException;
+import org.spoofax.jsglr.shared.TokenExpectedException;
 import org.spoofax.jsglr.shared.terms.ATermFactory;
 
+
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
  */
@@ -55,4 +63,25 @@
     public SGLR(ATermFactory pf, ParseTable parseTable) {
         super(pf, parseTable);
     }
+    
+    /**
+     * @deprecated Call {@link #parse(InputStream, String)} instead.
+     */
+    public final Object parse(InputStream fis) {
+        return parse(fis);
+    }
+
+    public final Object parse(InputStream fis, String filename)
+            throws BadTokenException, TokenExpectedException, ParseException,
+            SGLRException, SGLRException {
+        return parse(fis, null);
+    }
+
+    public Object parse(InputStream fis, String filename, String startSymbol)
+            throws BadTokenException, TokenExpectedException, ParseException,
+            SGLRException, IOException {
+        String input = FileTools.loadFileAsString(new InputStreamReader(fis));
+        return parse(input, filename, startSymbol);
+    }
+
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Mon Dec 20 11:17:30 2010	(r21576)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Mon Dec 20 11:37:30 2010	(r21577)
@@ -245,11 +245,22 @@
 		addStack(st0);
 		return st0;
 	}
+	
+	@Deprecated
+	public Object parse(String fis) throws BadTokenException,
+    TokenExpectedException, ParseException, SGLRException {
+	    return parse(fis, null);
+	}
+
+    public final Object parse(String input, String filename) throws BadTokenException,
+    TokenExpectedException, ParseException, SGLRException {
+
+        return parse(input, filename, null);
+    }
 
-	public Object parse(String fis, String startSymbol) throws BadTokenException, TokenExpectedException, ParseException,
+	public Object parse(String fis, String filename, String startSymbol) throws BadTokenException, TokenExpectedException, ParseException,
 	SGLRException {
 		logBeforeParsing();
-		String filename = null; // TODO: get filename from some place; useful for errors
 		initParseVariables(filename, fis);
 		startTime = System.currentTimeMillis();
 		initParseTimer();
@@ -259,12 +270,6 @@
         return result;
 	}
 
-	public final Object parse(String input) throws BadTokenException,
-	TokenExpectedException, ParseException, SGLRException {
-
-		return parse(input, null);
-	}
-
 	private Object sglrParse(String startSymbol)
 	throws BadTokenException, TokenExpectedException,
 	ParseException, SGLRException {

From L.C.L.Kats at tudelft.nl  Mon Dec 20 20:34:19 2010
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Mon, 20 Dec 2010 19:34:19 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21578 - in
	spoofax/branches/jsglr-gwt/jsglr-gwt: . .settings META-INF
	_attic _attic/rnsglr _attic/src _attic/src/org
	_attic/src/org/spoofax src/org/spoofax src/org/spoofax...
Message-ID: <201012201934.oBKJYJjs008625@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: Mon Dec 20 19:34:18 2010
New Revision: 21578
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21578&sc=1

Log:
Reorganizing project a bit to allow for future merge back into trunk. Moved rnsglr to _attic.

Added:
   spoofax/branches/jsglr-gwt/jsglr-gwt/_attic/
   spoofax/branches/jsglr-gwt/jsglr-gwt/_attic/rnsglr/
      - copied from r21577, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/rnsglr/
   spoofax/branches/jsglr-gwt/jsglr-gwt/_attic/src/
   spoofax/branches/jsglr-gwt/jsglr-gwt/_attic/src/org/
   spoofax/branches/jsglr-gwt/jsglr-gwt/_attic/src/org/spoofax/
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/io/
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/io/FileTools.java
      - copied, changed from r21577, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/FileTools.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/io/ParseTableManager.java
      - copied, changed from r21577, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseTableManager.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/io/SGLR.java
      - copied, changed from r21577, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/SGLR.java
Replaced:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java
Deleted:
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/FileTools.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseTableManager.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/SGLR.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/rnsglr/
Modified:
   spoofax/branches/jsglr-gwt/jsglr-gwt/   (props changed)
   spoofax/branches/jsglr-gwt/jsglr-gwt/.project
   spoofax/branches/jsglr-gwt/jsglr-gwt/.settings/org.eclipse.jdt.core.prefs
   spoofax/branches/jsglr-gwt/jsglr-gwt/.settings/org.eclipse.jdt.ui.prefs
   spoofax/branches/jsglr-gwt/jsglr-gwt/META-INF/MANIFEST.MF
   spoofax/branches/jsglr-gwt/jsglr-gwt/_attic/rnsglr/Tree.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/JsglrGWT.gwt.xml
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Asfix2TreeBuilder.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentationFilter.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTreeTools.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Term.java
   spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/.project
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/.project	Mon Dec 20 11:37:30 2010	(r21577)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/.project	Mon Dec 20 19:34:18 2010	(r21578)
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <projectDescription>
-	<name>jsglr-gwt</name>
+	<name>org.spoofax.jsglr</name>
 	<comment></comment>
 	<projects>
 	</projects>
@@ -20,9 +20,26 @@
 			<arguments>
 			</arguments>
 		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.ajdt.core.ajbuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.pde.ManifestBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.pde.SchemaBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
 	</buildSpec>
 	<natures>
+		<nature>org.eclipse.ajdt.ui.ajnature</nature>
 		<nature>org.eclipse.jdt.core.javanature</nature>
 		<nature>com.google.gwt.eclipse.core.gwtNature</nature>
+		<nature>org.eclipse.pde.PluginNature</nature>
 	</natures>
 </projectDescription>

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/.settings/org.eclipse.jdt.core.prefs
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/.settings/org.eclipse.jdt.core.prefs	Mon Dec 20 11:37:30 2010	(r21577)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/.settings/org.eclipse.jdt.core.prefs	Mon Dec 20 19:34:18 2010	(r21578)
@@ -1,4 +1,4 @@
-#Mon Dec 08 12:59:50 CET 2008
+#Mon Dec 20 20:13:06 CET 2010
 eclipse.preferences.version=1
 org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
 org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.5
@@ -70,6 +70,7 @@
 org.eclipse.jdt.core.compiler.source=1.5
 org.eclipse.jdt.core.formatter.align_type_members_on_columns=false
 org.eclipse.jdt.core.formatter.alignment_for_arguments_in_allocation_expression=16
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_annotation=0
 org.eclipse.jdt.core.formatter.alignment_for_arguments_in_enum_constant=16
 org.eclipse.jdt.core.formatter.alignment_for_arguments_in_explicit_constructor_call=16
 org.eclipse.jdt.core.formatter.alignment_for_arguments_in_method_invocation=16
@@ -80,6 +81,7 @@
 org.eclipse.jdt.core.formatter.alignment_for_conditional_expression=80
 org.eclipse.jdt.core.formatter.alignment_for_enum_constants=0
 org.eclipse.jdt.core.formatter.alignment_for_expressions_in_array_initializer=16
+org.eclipse.jdt.core.formatter.alignment_for_method_declaration=0
 org.eclipse.jdt.core.formatter.alignment_for_multiple_fields=16
 org.eclipse.jdt.core.formatter.alignment_for_parameters_in_constructor_declaration=16
 org.eclipse.jdt.core.formatter.alignment_for_parameters_in_method_declaration=16
@@ -91,7 +93,7 @@
 org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_method_declaration=16
 org.eclipse.jdt.core.formatter.blank_lines_after_imports=1
 org.eclipse.jdt.core.formatter.blank_lines_after_package=1
-org.eclipse.jdt.core.formatter.blank_lines_before_field=1
+org.eclipse.jdt.core.formatter.blank_lines_before_field=0
 org.eclipse.jdt.core.formatter.blank_lines_before_first_class_body_declaration=0
 org.eclipse.jdt.core.formatter.blank_lines_before_imports=1
 org.eclipse.jdt.core.formatter.blank_lines_before_member_type=1
@@ -111,11 +113,9 @@
 org.eclipse.jdt.core.formatter.brace_position_for_method_declaration=end_of_line
 org.eclipse.jdt.core.formatter.brace_position_for_switch=end_of_line
 org.eclipse.jdt.core.formatter.brace_position_for_type_declaration=end_of_line
-org.eclipse.jdt.core.formatter.comment.clear_blank_lines=false
 org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_block_comment=false
 org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_javadoc_comment=false
 org.eclipse.jdt.core.formatter.comment.format_block_comments=true
-org.eclipse.jdt.core.formatter.comment.format_comments=true
 org.eclipse.jdt.core.formatter.comment.format_header=false
 org.eclipse.jdt.core.formatter.comment.format_html=true
 org.eclipse.jdt.core.formatter.comment.format_javadoc_comments=true
@@ -126,10 +126,15 @@
 org.eclipse.jdt.core.formatter.comment.insert_new_line_before_root_tags=insert
 org.eclipse.jdt.core.formatter.comment.insert_new_line_for_parameter=insert
 org.eclipse.jdt.core.formatter.comment.line_length=80
+org.eclipse.jdt.core.formatter.comment.new_lines_at_block_boundaries=true
+org.eclipse.jdt.core.formatter.comment.new_lines_at_javadoc_boundaries=true
 org.eclipse.jdt.core.formatter.compact_else_if=true
 org.eclipse.jdt.core.formatter.continuation_indentation=2
 org.eclipse.jdt.core.formatter.continuation_indentation_for_array_initializer=2
+org.eclipse.jdt.core.formatter.disabling_tag=@formatter\:off
+org.eclipse.jdt.core.formatter.enabling_tag=@formatter\:on
 org.eclipse.jdt.core.formatter.format_guardian_clause_on_one_line=false
+org.eclipse.jdt.core.formatter.format_line_comment_starting_on_first_column=true
 org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_annotation_declaration_header=true
 org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_constant_header=true
 org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_declaration_header=true
@@ -141,7 +146,10 @@
 org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_cases=true
 org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_switch=false
 org.eclipse.jdt.core.formatter.indentation.size=4
-org.eclipse.jdt.core.formatter.insert_new_line_after_annotation=insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_local_variable=insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_member=insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_parameter=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_label=do not insert
 org.eclipse.jdt.core.formatter.insert_new_line_after_opening_brace_in_array_initializer=do not insert
 org.eclipse.jdt.core.formatter.insert_new_line_at_end_of_file_if_missing=do not insert
 org.eclipse.jdt.core.formatter.insert_new_line_before_catch_in_try_statement=do not insert
@@ -310,6 +318,8 @@
 org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_enum_constant=do not insert
 org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_declaration=do not insert
 org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_invocation=do not insert
+org.eclipse.jdt.core.formatter.join_lines_in_comments=true
+org.eclipse.jdt.core.formatter.join_wrapped_lines=true
 org.eclipse.jdt.core.formatter.keep_else_statement_on_same_line=false
 org.eclipse.jdt.core.formatter.keep_empty_array_initializer_on_one_line=false
 org.eclipse.jdt.core.formatter.keep_imple_if_on_one_line=false
@@ -320,7 +330,9 @@
 org.eclipse.jdt.core.formatter.number_of_blank_lines_at_beginning_of_method_body=0
 org.eclipse.jdt.core.formatter.number_of_empty_lines_to_preserve=1
 org.eclipse.jdt.core.formatter.put_empty_statement_on_new_line=true
-org.eclipse.jdt.core.formatter.tabulation.char=space
+org.eclipse.jdt.core.formatter.tabulation.char=tab
 org.eclipse.jdt.core.formatter.tabulation.size=4
+org.eclipse.jdt.core.formatter.use_on_off_tags=false
 org.eclipse.jdt.core.formatter.use_tabs_only_for_leading_indentations=false
 org.eclipse.jdt.core.formatter.wrap_before_binary_operator=true
+org.eclipse.jdt.core.formatter.wrap_outer_expressions_when_nested=true

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/.settings/org.eclipse.jdt.ui.prefs
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/.settings/org.eclipse.jdt.ui.prefs	Mon Dec 20 11:37:30 2010	(r21577)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/.settings/org.eclipse.jdt.ui.prefs	Mon Dec 20 19:34:18 2010	(r21578)
@@ -1,4 +1,4 @@
-#Mon Nov 15 11:15:46 CET 2010
+#Mon Dec 20 19:29:19 CET 2010
 cleanup.add_default_serial_version_id=true
 cleanup.add_generated_serial_version_id=false
 cleanup.add_missing_annotations=true

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/META-INF/MANIFEST.MF
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/META-INF/MANIFEST.MF	Mon Dec 20 11:37:30 2010	(r21577)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/META-INF/MANIFEST.MF	Mon Dec 20 19:34:18 2010	(r21578)
@@ -2,9 +2,14 @@
 Bundle-ManifestVersion: 2
 Bundle-Name: Scannerless Generalized LR parser
 Bundle-SymbolicName: org.spoofax.jsglr
-Bundle-Version: 0.2.2.qualifier
+Bundle-Version: 0.3.0.qualifier
 Export-Package: org.spoofax,
- org.spoofax.jsglr
+ org.spoofax.jsglr.io,
+ org.spoofax.jsglr.client,
+ org.spoofax.jsglr.client.imploder,
+ org.spoofax.jsglr.client.incremental,
+ org.spoofax.jsglr.shared,
+ org.spoofax.jsglr.shared.terms
 Bundle-Vendor: Spoofax.org
 Require-Bundle: org.spoofax.aterm,
  org.junit,

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/_attic/rnsglr/Tree.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/rnsglr/Tree.java	Mon Dec 20 11:37:30 2010	(r21577)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/_attic/rnsglr/Tree.java	Mon Dec 20 19:34:18 2010	(r21578)
@@ -2,7 +2,7 @@
 
 import org.spoofax.jsglr.NotImplementedException;
 
-import aterm.ATerm;
+import org.spoofax.jsglr.shared.terms.ATerm;
 
 public class Tree {
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/JsglrGWT.gwt.xml
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/JsglrGWT.gwt.xml	Mon Dec 20 11:37:30 2010	(r21577)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/JsglrGWT.gwt.xml	Mon Dec 20 19:34:18 2010	(r21578)
@@ -8,6 +8,44 @@
   <source path='jsglr/shared'/>
   <source path='client'/>
   <source path='jsglr/tests'/>
+  
+  <!--
+  <replace-with class="org.spoofax.jsglr.shared.terms.PureFactory">
+    <when-type-is class="aterm.ATermFactory"/>
+  </replace-with>
+  
+  <replace-with class="org.spoofax.jsglr.shared.terms.ATermFactory">
+    <when-type-is class="aterm.ATermFactory"/>
+  </replace-with>
+  
+  <replace-with class="org.spoofax.jsglr.shared.terms.Visitable">
+    <when-type-is class="aterm.Visitable"/>
+  </replace-with>
+  
+  <replace-with class="org.spoofax.jsglr.shared.terms.ATerm">
+    <when-type-is class="aterm.ATerm"/>
+  </replace-with>
+  
+  <replace-with class="org.spoofax.jsglr.shared.terms.AFun">
+    <when-type-is class="aterm.AFun"/>
+  </replace-with>
+  
+  <replace-with class="org.spoofax.jsglr.shared.terms.ATermAppl">
+    <when-type-is class="aterm.ATermAppl"/>
+  </replace-with>
+  
+  <replace-with class="org.spoofax.jsglr.shared.terms.ATermInt">
+    <when-type-is class="aterm.ATermInt"/>
+  </replace-with>
+  
+  <replace-with class="org.spoofax.jsglr.shared.terms.ATermList">
+    <when-type-is class="aterm.ATermList"/>
+  </replace-with>
+  
+  <replace-with class="org.spoofax.jsglr.shared.terms.ATermTuple">
+    <when-type-is class="aterm.ATermTuple"/>
+  </replace-with>
+  -->
 <!-- 
   <entry-point class='org.spoofax.client.JSGLREntryPoint'/>
  -->

Added: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/Main.java	Mon Dec 20 19:34:18 2010	(r21578)
@@ -0,0 +1,165 @@
+/*
+ * Created on 03.des.2005
+ *
+ * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
+ * 
+ * Licensed under the GNU Lesser General Public License, v2.1
+ */
+package org.spoofax.jsglr;
+
+import java.io.BufferedWriter;
+import java.io.FileNotFoundException;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.OutputStreamWriter;
+import java.io.Writer;
+
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParseTable;
+import org.spoofax.jsglr.client.SGLR;
+import org.spoofax.jsglr.client.imploder.TreeBuilder;
+import org.spoofax.jsglr.io.FileTools;
+import org.spoofax.jsglr.shared.BadTokenException;
+import org.spoofax.jsglr.shared.SGLRException;
+import org.spoofax.jsglr.shared.Tools;
+import org.spoofax.jsglr.shared.terms.ATerm;
+import org.spoofax.jsglr.shared.terms.ATermFactory;
+
+public class Main {
+	
+	private static final String NO_OUTPUT = "-";
+
+	public static void main(String[] args) throws FileNotFoundException, IOException, InvalidParseTableException {
+
+		if(args.length < 2) {
+			usage();
+		}
+
+		String parseTableFile = null;
+		String input = null;
+		String output = null;
+		String startSymbol = null;
+		boolean debugging = false;
+		boolean logging = false;
+		boolean detectCycles = true;
+		boolean filter = true;
+		boolean waitForProfiler = false;
+		boolean timing = false;
+		boolean heuristicFilters = false;
+		boolean buildParseTree = true;
+		boolean implode = false;
+		int profilingRuns = 0;
+
+		for(int i=0;i<args.length;i++) {
+			if(args[i].equals("-p")) {
+				parseTableFile = args[++i];
+			} else if(args[i].equals("-i")) {
+				input = args[++i];
+			} else if(args[i].equals("-o")) {
+				output = args[++i];
+			} else if(args[i].equals("-d")) {
+				debugging = true;
+			} else if(args[i].equals("-v")) {
+				logging = true;
+			} else if(args[i].equals("-f")) {
+				filter = false;
+			} else if(args[i].equals("-c")) {
+				detectCycles = false;
+			} else if(args[i].equals("-s")) {
+				startSymbol = args[++i];
+			} else if(args[i].equals("--heuristic-filters")) {
+				heuristicFilters = args[++i].equals("on");
+			} else if(args[i].equals("--wait-for-profiler")) {
+				waitForProfiler = true;
+			} else if(args[i].equals("--profiler-runs")) {
+				profilingRuns = Integer.parseInt(args[++i]);
+			} else if(args[i].equals("--timing")) {
+				timing = true;
+			} else if(args[i].equals("--no-tree-build")) {
+				buildParseTree = false;
+			} else if(args[i].equals("--implode")) {
+				implode = true;
+			} else {
+				System.err.println("Unknown option: " + args[i]);
+				System.exit(1);
+			}
+		}
+
+		if(parseTableFile == null) {
+			usage();
+		}
+
+		final ATermFactory factory = new ATermFactory();
+		long tableLoadingTime = System.currentTimeMillis();
+		final ParseTable pt = new ParseTable(factory.parseFromString(FileTools.loadFileAsString(parseTableFile)));
+		final SGLR sglr = new SGLR(factory, pt);
+
+		tableLoadingTime = System.currentTimeMillis() - tableLoadingTime;
+
+		Tools.setDebug(debugging);
+		Tools.setLogging(logging);
+		sglr.getDisambiguator().setFilterCycles(detectCycles);
+		sglr.getDisambiguator().setFilterAny(filter);
+		sglr.getDisambiguator().setHeuristicFilters(heuristicFilters);
+		sglr.setBuildParseTree(buildParseTree);
+		if (implode)
+			sglr.setTreeBuilder(new TreeBuilder(true));
+
+		if(waitForProfiler) {
+			System.err.println("Hit enter to start profiling...");
+			System.in.read();
+		}
+
+		for(int i = 0; i < profilingRuns - 1; i++) {
+			parseFile(input, NO_OUTPUT, sglr, startSymbol);
+		}
+
+		final long parsingTime = parseFile(input, output, sglr, startSymbol);
+
+		if(timing) {
+			System.err.println("Parse table loading time : " + tableLoadingTime + "ms");
+			System.err.println("Parsing time             : " + parsingTime + "ms");
+		}
+	}
+
+	public static long parseFile(String input, String output, SGLR sglr, String startSymbol)
+	throws FileNotFoundException, IOException {
+		/* TODO: support stdin input
+		InputStream fis = null;
+		if(input == null) {
+			fis = new BufferedInputStream(System.in);
+		} else {
+			fis = new BufferedInputStream(new FileInputStream(input));
+		}
+		*/
+		Writer out = null;
+		if(output != null && !NO_OUTPUT.equals(output)) {
+			out = new BufferedWriter(new FileWriter(output));
+		} else {
+			out = new BufferedWriter(new OutputStreamWriter(System.out));
+		}
+
+		long parsingTime = 0;
+		Object t = null;
+		try {
+			parsingTime = System.currentTimeMillis();
+			t = sglr.parse(FileTools.loadFileAsString(input), startSymbol);
+			parsingTime = System.currentTimeMillis() - parsingTime;
+		} catch(final BadTokenException e) {
+			System.err.println("Parsing failed : " + e.getMessage());
+		} catch(final SGLRException e) {
+			// Detailed message for other exceptions
+			System.err.println("Parsing failed : " + e);
+		}
+		if(t != null && !NO_OUTPUT.equals(output)){
+			((ATerm) t).writeTo(out);
+			out.close();
+		}
+		return parsingTime;
+	}
+
+	private static void usage() {
+		System.out.println("Usage: org.spoofax.jsglr.Main [-f -d -v] -p <parsetable.tbl> -i <inputfile>");
+		System.exit(-1);
+	}
+}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Asfix2TreeBuilder.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Asfix2TreeBuilder.java	Mon Dec 20 11:37:30 2010	(r21577)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Asfix2TreeBuilder.java	Mon Dec 20 19:34:18 2010	(r21578)
@@ -40,7 +40,7 @@
 	public ATerm buildNode(int labelNumber, List<Object> subtrees) {
 		ATermList ls = factory.makeList();
 		for(int i = subtrees.size() - 1; i >= 0; i--) {
-			ls = ls.prepend((ATerm)subtrees.get(i));
+        	ls = factory.makeList((ATerm)subtrees.get(i), ls);
 		}
 		return factory.makeAppl(applAFun, labels[labelNumber - labelStart], ls);
 	}

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentationFilter.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentationFilter.java	Mon Dec 20 11:37:30 2010	(r21577)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/IndentationFilter.java	Mon Dec 20 19:34:18 2010	(r21578)
@@ -20,13 +20,13 @@
                 contents = termAt(node, 1);
             }
             for (int i = 0; i < contents.getChildCount(); i++) {
-                resolveAmbiguitiesByIndentation(contents.getChildAt(i));
+                resolveAmbiguitiesByIndentation((ATerm) contents.getChildAt(i));
             }
         }
 
         if ("amb".equals(((ATermAppl) node).getName())){
             ATermList ambs = termAt(node, 0);
-            node = ambs.getChildAt(0);
+            node = (ATerm) ambs.getChildAt(0);
         }
     }
 

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java	Mon Dec 20 11:37:30 2010	(r21577)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseNode.java	Mon Dec 20 19:34:18 2010	(r21578)
@@ -74,7 +74,7 @@
     public static ATermList makeList(ATermFactory factory, List<ATerm> terms) {
         ATermList result = factory.makeList();
         for (int i = terms.size() - 1; i >= 0; i--) {
-            result = result.prepend(terms.get(i));
+        	result = factory.makeList(terms.get(i), result);
         }
         return result;
     }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTreeTools.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTreeTools.java	Mon Dec 20 11:37:30 2010	(r21577)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/ParseTreeTools.java	Mon Dec 20 19:34:18 2010	(r21578)
@@ -67,13 +67,13 @@
 			prod = appl;
 		}
 		else if(appl.getAFun() == applFun) {
-			prod = assertAppl(appl.getChildAt(APPL_PROD), prodFun);
+			prod = assertAppl((ATerm) appl.getChildAt(APPL_PROD), prodFun);
 		}
 		else {
 			throw new IllegalArgumentException("Expected prod or appl: " + arg);
 		}
 
-		ATermAppl attrs = assertAppl(prod.getChildAt(PROD_ATTRS));
+		ATermAppl attrs = assertAppl((ATerm) prod.getChildAt(PROD_ATTRS));
 		if(attrs.getAFun() == noattrsFun) {
 			return null;
 		}
@@ -114,7 +114,7 @@
 	public void yield(ATerm parsetree, StringBuilder builder) {
 		ATermAppl appl = assertAppl(parsetree);
 		if(appl.getAFun() == parsetreeFun) {
-			appl = assertAppl(appl.getChildAt(PARSE_TREE));
+			appl = assertAppl((ATerm) appl.getChildAt(PARSE_TREE));
 		}
 
 		yieldAppl(appl, builder);

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Mon Dec 20 11:37:30 2010	(r21577)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/SGLR.java	Mon Dec 20 19:34:18 2010	(r21578)
@@ -122,7 +122,7 @@
      * Attempts to set a timeout for parsing.
      * Default implementation is a no-op.
      * 
-     * @see org.spoofax.jsglr.SGLR#setTimeout(int)
+     * @see org.spoofax.jsglr.io.SGLR#setTimeout(int)
      */
     public void setTimeout(int timeout) {
         this.timeout = timeout;

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Term.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Term.java	Mon Dec 20 11:37:30 2010	(r21577)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/client/Term.java	Mon Dec 20 19:34:18 2010	(r21578)
@@ -32,7 +32,7 @@
     }
 
     public static int intAt(ATerm pt, int i) {
-        return asInt(pt.getChildAt(i)).getInt();
+        return asInt((ATerm) pt.getChildAt(i)).getInt();
     }
 
     public static ATermList listAt(ATerm pt, int i) {

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/io/FileTools.java (from r21577, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/FileTools.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/FileTools.java	Mon Dec 20 11:37:30 2010	(r21577, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/io/FileTools.java	Mon Dec 20 19:34:18 2010	(r21578)
@@ -1,4 +1,4 @@
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.io;
 
 import java.io.BufferedReader;
 import java.io.FileReader;

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/io/ParseTableManager.java (from r21577, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseTableManager.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/ParseTableManager.java	Mon Dec 20 11:37:30 2010	(r21577, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/io/ParseTableManager.java	Mon Dec 20 19:34:18 2010	(r21578)
@@ -5,7 +5,7 @@
  * 
  * Licensed under the GNU General Public License, v2
  */
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.io;
 
 import java.io.File;
 import java.io.FileInputStream;

Copied and modified: spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/io/SGLR.java (from r21577, spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/SGLR.java)
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/SGLR.java	Mon Dec 20 11:37:30 2010	(r21577, copy source)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/src/org/spoofax/jsglr/io/SGLR.java	Mon Dec 20 19:34:18 2010	(r21578)
@@ -1,4 +1,4 @@
-package org.spoofax.jsglr;
+package org.spoofax.jsglr.io;
 
 import java.io.IOException;
 import java.io.InputStream;
@@ -14,74 +14,75 @@
 import org.spoofax.jsglr.shared.TokenExpectedException;
 import org.spoofax.jsglr.shared.terms.ATermFactory;
 
-
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
  */
 public class SGLR extends org.spoofax.jsglr.client.SGLR {
 
-    private static final Timer abortTimer = new Timer(true);
+	private static final Timer abortTimer = new Timer(true);
 
-    private int abortTimerJobId;
+	private int abortTimerJobId;
 
-    /**
-     * Sets the maximum amount of time to try and parse a file, before a
-     * {@link ParseTimeoutException} is thrown.
-     * 
-     * @param timeout
-     *            The maximum time to parse, in milliseconds.
-     */
-    @Override
-    public void setTimeout(int timeout) {
-        this.timeout = timeout;
-    }
-
-    @Override
-    protected void initParseTimer() {
-        if (timeout > 0) {
-            // We use a single shared timer to conserve native threads
-            // and a jobId to recognize stale abort events
-            synchronized (abortTimer) {
-                asyncAborted = false;
-                ++abortTimerJobId;
-            }
-            final int jobId = abortTimerJobId;
-            abortTimer.schedule(new TimerTask() {
-                @Override
-                public void run() {
-                    synchronized (abortTimer) {
-                        if (abortTimerJobId == jobId)
-                            asyncCancel();
-                    }
-                }
-            }, timeout);
-        } else {
-            asyncAborted = false;
-        }
-    }
-
-    public SGLR(ATermFactory pf, ParseTable parseTable) {
-        super(pf, parseTable);
-    }
-    
-    /**
-     * @deprecated Call {@link #parse(InputStream, String)} instead.
-     */
-    public final Object parse(InputStream fis) {
-        return parse(fis);
-    }
-
-    public final Object parse(InputStream fis, String filename)
-            throws BadTokenException, TokenExpectedException, ParseException,
-            SGLRException, SGLRException {
-        return parse(fis, null);
-    }
-
-    public Object parse(InputStream fis, String filename, String startSymbol)
-            throws BadTokenException, TokenExpectedException, ParseException,
-            SGLRException, IOException {
-        String input = FileTools.loadFileAsString(new InputStreamReader(fis));
-        return parse(input, filename, startSymbol);
-    }
+	/**
+	 * Sets the maximum amount of time to try and parse a file, before a
+	 * {@link ParseTimeoutException} is thrown.
+	 * 
+	 * @param timeout
+	 *            The maximum time to parse, in milliseconds.
+	 */
+	@Override
+	public void setTimeout(int timeout) {
+		this.timeout = timeout;
+	}
+
+	@Override
+	protected void initParseTimer() {
+		if (timeout > 0) {
+			// We use a single shared timer to conserve native threads
+			// and a jobId to recognize stale abort events
+			synchronized (abortTimer) {
+				asyncAborted = false;
+				++abortTimerJobId;
+			}
+			final int jobId = abortTimerJobId;
+			abortTimer.schedule(new TimerTask() {
+				@Override
+				public void run() {
+					synchronized (abortTimer) {
+						if (abortTimerJobId == jobId)
+							asyncCancel();
+					}
+				}
+			}, timeout);
+		} else {
+			asyncAborted = false;
+		}
+	}
+
+	public SGLR(ATermFactory pf, ParseTable parseTable) {
+		super(pf, parseTable);
+	}
+
+	/**
+	 * @deprecated Call {@link #parse(InputStream, String)} instead.
+	 */
+	public final Object parse(InputStream fis)
+			throws BadTokenException, TokenExpectedException, ParseException,
+			SGLRException, SGLRException, IOException {
+		return parse(fis, null);
+	}
+
+	public final Object parse(InputStream fis, String filename)
+			throws BadTokenException, TokenExpectedException, ParseException,
+			SGLRException, SGLRException, IOException {
+		return parse(fis, null);
+	}
+
+	public Object parse(InputStream fis, String filename, String startSymbol)
+			throws BadTokenException, TokenExpectedException, ParseException,
+			SGLRException, IOException {
+		String input = FileTools.loadFileAsString(new InputStreamReader(fis));
+		return parse(input, filename, startSymbol);
+	}
 
 }

Modified: spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java
==============================================================================
--- spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Mon Dec 20 11:37:30 2010	(r21577)
+++ spoofax/branches/jsglr-gwt/jsglr-gwt/test/org/spoofax/jsglr/tests/ParseTestCase.java	Mon Dec 20 19:34:18 2010	(r21578)
@@ -14,7 +14,6 @@
 
 import junit.framework.TestCase;
 
-import org.spoofax.jsglr.FileTools;
 import org.spoofax.jsglr.client.InvalidParseTableException;
 import org.spoofax.jsglr.client.ParseTable;
 import org.spoofax.jsglr.client.ParserException;
@@ -24,6 +23,7 @@
 import org.spoofax.jsglr.client.imploder.ATermTreeFactory;
 import org.spoofax.jsglr.client.imploder.TreeBuilder;
 import org.spoofax.jsglr.client.incremental.IncrementalSGLR;
+import org.spoofax.jsglr.io.FileTools;
 import org.spoofax.jsglr.shared.SGLRException;
 import org.spoofax.jsglr.shared.Tools;
 import org.spoofax.jsglr.shared.terms.ATerm;

From R.B.Vermaas at tudelft.nl  Wed Dec 22 12:32:38 2010
From: R.B.Vermaas at tudelft.nl (Rob Vermaas)
Date: Wed, 22 Dec 2010 11:32:38 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21579 - in
	spoofax-imp/trunk/org.strategoxt.imp.testing: . META-INF
	syntax test trans
Message-ID: <201012221132.oBMBWcfI008531@proliant.st.ewi.tudelft.nl>

Author: rob
Date: Wed Dec 22 11:32:38 2010
New Revision: 21579
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21579&sc=1

Log:
changed syntax, added some parse test online eval

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.testing/META-INF/MANIFEST.MF
   spoofax-imp/trunk/org.strategoxt.imp.testing/build.main.xml
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Common.sdf
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing.sdf
   spoofax-imp/trunk/org.strategoxt.imp.testing/test/asd.aterm
   spoofax-imp/trunk/org.strategoxt.imp.testing/test/asd3.aterm
   spoofax-imp/trunk/org.strategoxt.imp.testing/test/example2.spt
   spoofax-imp/trunk/org.strategoxt.imp.testing/test/test.aterm
   spoofax-imp/trunk/org.strategoxt.imp.testing/test/test.spt
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/aterm-eq.str
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check.str
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/generate.str
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/spoofax_testing.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/META-INF/MANIFEST.MF
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/META-INF/MANIFEST.MF	Mon Dec 20 19:34:18 2010	(r21578)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/META-INF/MANIFEST.MF	Wed Dec 22 11:32:38 2010	(r21579)
@@ -19,7 +19,8 @@
  org.spoofax.aterm,
  org.spoofax.jsglr,
  org.strategoxt.strj,
- org.eclipse.jdt.junit
+ org.eclipse.jdt.junit,
+ org.eclipse.jdt.core
 Bundle-RequiredExecutionEnvironment: J2SE-1.5
 Bundle-ActivationPolicy: lazy
 Export-Package: org.strategoxt.imp.testing

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/build.main.xml
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/build.main.xml	Mon Dec 20 19:34:18 2010	(r21578)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/build.main.xml	Wed Dec 22 11:32:38 2010	(r21579)
@@ -18,7 +18,7 @@
         <property name="dist" location="bin/dist"/>
         
         <!-- Imports -->
-        <property name="build.sdf.imports" value=""/>
+        <property name="build.sdf.imports" value="-Idef ${syntax}/Stratego-Sugar.def"/>
         <property name="build.stratego.args" value="
                         --library
                         -I &quot;${trans}&quot;

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Common.sdf
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Common.sdf	Mon Dec 20 19:34:18 2010	(r21578)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Common.sdf	Wed Dec 22 11:32:38 2010	(r21579)
@@ -4,7 +4,7 @@
 
   lexical syntax
   
-    [a-zA-Z][a-zA-Z0-9\_]* -> ID
+    [a-zA-Z][a-zA-Z0-9\_]* -> ID {prefer}
     "-"? [0-9]+            -> INT
     
     "\"" StringChar* "\"" -> STRING

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing.sdf
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing.sdf	Mon Dec 20 19:34:18 2010	(r21578)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing.sdf	Wed Dec 22 11:32:38 2010	(r21579)
@@ -6,6 +6,7 @@
 imports Spoofax-Testing-String-Quotation
 imports languages/aterm/syntax/ATerms
 imports RegExp
+imports Stratego-Sugar
 
 exports
   context-free start-symbols TestSuite
@@ -13,11 +14,18 @@
 exports
   sorts TestSuite TopSort Test Input Result
   context-free syntax
-    "testsuite" Name Options Test* -> TestSuite {cons("testsuite")}
+    "testsuite" Name Options TestSuitePart* -> TestSuite {cons("testsuite")}
     "topsort" Sort    -> Options {cons("topsort")}
     "options" Option+ -> Options {cons("options")}
     OptionValue OptionValue -> Option {cons("option")}
 
+    StrategoTests -> TestSuitePart
+    ParseTests    -> TestSuitePart
+    VarDecls      -> TestSuitePart
+    
+    "stratego" "tests" StrategoTest* -> StrategoTests {cons("stratego-tests")}
+    "parse" "tests" ParseTest*       -> ParseTests {cons("parse-tests")}
+    
   lexical syntax
     ~[\ \t\n\r]+ -> OptionValue
     "test"       -> OptionValue {reject}
@@ -27,8 +35,19 @@
 
   %% The description syntax is very ambiguous if comments are allowed around it. So, we forbid comments.
   syntax
-    "parse" <LAYOUT?-CF> "test" <Space-LEX> <Description-CF> <LAYOUT?-CF> <Input-CF> <LAYOUT?-CF> <Result-CF> -> <Test-CF> {cons("parse-test")}
-    "parse" <LAYOUT?-CF> "test" <LAYOUT?-CF> <Input-CF> <LAYOUT?-CF> <Result-CF> -> <Test-CF>  {cons("parse-test")}
+    "test" <Space-LEX> <Description-CF> <LAYOUT?-CF> <Input-CF> <LAYOUT?-CF> <Result-CF> -> <ParseTest-CF> {cons("parse-test")}
+
+  context-free syntax
+    "variables" TermDecl* -> VarDecls {cons("Variables")} 
+    ID "=" ATerm          -> TermDecl {cons("VarDecl")}
+    
+  syntax
+    "test" <Space-LEX> <Description-CF> <LAYOUT?-CF> <Strategy-CF> <LAYOUT?-CF> <StrategoResult-CF> -> <StrategoTest-CF> {cons("stratego-test")}
+    "test" <Space-LEX> <Description-CF> <LAYOUT?-CF> <Strategy-CF> -> <StrategoTest-CF> {cons("stratego-test")}
+
+  context-free syntax
+    "fails" -> StrategoResult {cons("failure")}
+    
 
   lexical syntax
     [\ ]+ -> Space

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/test/asd.aterm
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/test/asd.aterm	Mon Dec 20 19:34:18 2010	(r21578)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/test/asd.aterm	Wed Dec 22 11:32:38 2010	(r21579)
@@ -1,10 +1,13 @@
 testsuite(
   name("ASD")
 , topsort("TypeDec")
-, [parse-test(
-     " "
-   , description("rob is gek")
-   , string("\"", "asd", "\"")
-   , failure()
-   )]
-)
+, [ parse-tests(
+      [parse-test(
+         " "
+       , description("rob is gek")
+       , string("\"", "asd", "\"")
+       , failure()
+       )]
+    )
+  ]
+)
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/test/asd3.aterm
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/test/asd3.aterm	Mon Dec 20 19:34:18 2010	(r21578)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/test/asd3.aterm	Wed Dec 22 11:32:38 2010	(r21579)
@@ -1,10 +1,13 @@
 testsuite(
   name("ASD123")
 , topsort("TypeDec")
-, [parse-test(
-     " "
-   , description("rob is gek")
-   , string("\"", "asd", "\"")
-   , failure()
-   )]
+, [ parse-tests(
+      [parse-test(
+         " "
+       , description("rob is gek")
+       , string("\"", "asd", "\"")
+       , failure()
+       )]
+    )
+  ]
 )
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/test/example2.spt
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/test/example2.spt	Mon Dec 20 19:34:18 2010	(r21578)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/test/example2.spt	Wed Dec 22 11:32:38 2010	(r21579)
@@ -1,4 +1,5 @@
 testsuite ASD
     topsort TypeDec
-    parse test rob is gek
+    parse tests
+    test rob is gek
       "asd" fails
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/test/test.aterm
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/test/test.aterm	Mon Dec 20 19:34:18 2010	(r21578)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/test/test.aterm	Wed Dec 22 11:32:38 2010	(r21579)
@@ -1,6 +1 @@
-parse-test(
-  " "
-, description("missing topsort")
-, string("\"\"", "\n    testsuite ASD\n    parse test rob is gek\n      \"asd\" fails \n  ", "\"\"")
-, failure()
-)
\ No newline at end of file
+Var("input1", list([]))
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/test/test.spt
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/test/test.spt	Mon Dec 20 19:34:18 2010	(r21578)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/test/test.spt	Wed Dec 22 11:32:38 2010	(r21579)
@@ -1,48 +1,78 @@
 testsuite testsuites
 topsort TestSuite
 
-parse test testsuite (1)
-  ""
-    testsuite ASD
-    topsort TypeDec
-    parse test rob is gek
-       "asd" fails 
-  "" -> testsuite( name("ASD"), _, _)
-  
-parse test missing topsort
-  ""
-    testsuite ASD
-    parse test rob is gek
-      "asd" fails 
-  "" fails
-
-parse test file input test (self) (1)
-  file ./test.spt succeeds
-
-parse test file input test (2) 
-  file ./example2.spt succeeds
- 
-parse test test 1
-  ""
-    testsuite ASD
-    topsort TypeDec
-    parse test rob is gek
-      "asd" fails 
-  "" -> file ./asd.aterm
-
-parse test test 2
-  ""
-    testsuite ASD123
-    topsort TypeDec
-    parse test rob is gek
-      "asd" fails 
-  "" -> file ./asd3.aterm
+variables 
+	input1 = []
+	input2 = [1,2,3]
+	input3 = Int(1)
+
+parse tests 
+	test testsuite (1)
+	  ""
+	    testsuite ASD
+	    topsort TypeDec
+	    parse tests
+	      test rob is gek123
+	         "asd" fails 
+	  "" -> testsuite( name("ASD"), _, _)
+	  
+	test missing topsort
+	  ""
+	    testsuite ASD
+	    parse test rob is gek
+	      "asd" fails 
+	  "" fails
+	
+	test file input test (self) (1)
+	  file ./test.spt succeeds
+	
+	test file input test (2) 
+	  file ./example2.spt succeeds
+	 
+	test test 1
+	  ""
+	    testsuite ASD
+	    topsort TypeDec
+	    parse tests
+	    
+	    test rob is gek
+	      "asd" fails 
+	  "" -> file ./asd.aterm
+	
+	test test 2
+	  ""
+	    testsuite ASD123
+	    topsort TypeDec
+	 
+	    parse tests
+	    test rob is gek
+	    
+	      "asd" fails 
+	  "" -> file ./asd3.aterm
+	
+	test empty file should fail
+	    ""
+	    "" fails
+
+stratego tests
+
+	test Hd on list
+	  <Hd>[1,2,3,4] => 1
+	
+	test Hd on empty list should fail
+	  <Hd>[] fails
+	
+	test test-term-projection-in-anno
+	  <?_{<id>}>1{2} => 2
+	
+	test test-term-projection-in-anno
+	  <catch-annos> Plus(Var("a"), Var("b")){Int} => Anno(Plus(Var("a"), Var("b")), [Int])
 
 
 /*
 
 editor test simple testsuite editor test (1)
-
+  
   ""
     testsuite ASD
     topsort TypeDec
@@ -58,5 +88,4 @@
   no errors, 1 warning, /no tests in/
 
 */
-
  
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/aterm-eq.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/trans/aterm-eq.str	Mon Dec 20 19:34:18 2010	(r21578)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/aterm-eq.str	Wed Dec 22 11:32:38 2010	(r21579)
@@ -14,7 +14,7 @@
   aterm-eq(|p) =
     <aterm-eq>(<explode-aterm>,<read-from-string>p)
 
-  aterm-eq =
+  aterm-eq = 
     rec x(
         list-term-eq(x)
     +    int-term-eq(x)
@@ -22,8 +22,8 @@
     +   appl-term-eq(x)
     +        afun-eq(x)
     +    wildcard-eq(x)
-    + wildcardvar-eq(x)
-    )
+    + wildcardvar-eq(x) 
+    ) 
 
 rules
 

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check.str	Mon Dec 20 19:34:18 2010	(r21578)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check.str	Wed Dec 22 11:32:38 2010	(r21579)
@@ -2,50 +2,44 @@
 
 imports
   libstratego-lib
+  libstratego-aterm
   include/Spoofax-Testing
   lib/editor-common.generated
-
-rules
-
-  // Analysis: does a topdown traversal of the tree,
-  // and tries to apply the record-entity rule.
-  analyze:
-    t -> t
-    with
-      <topdown(try(record-entity))> t
-
-  // Records the definition of an entity in a dynamic rule GetEntity.
-  record-entity:
-    Entity(x, body) -> Entity(x, body)
-    with
-      // For a name 'x', GetEntity will return the original 'x' tree node
-      rules(
-        GetEntity :+ x -> x
-      )
+  aterm-eq
+  spoofax_testing
+  file-resolving
+  
 rules
-    
-  // Reports an error if a property type is undefined.
-  // This error is reported on the type name 'type'.
-  constraint-error:
-    Property(x, Type(type)) -> (type, $[Type [type] is not defined])
-    where
-      not(!type => "String"); // String and Int are built-in types
-      not(!type => "Int");
-      not(<GetEntity> type) // no entity for this type
+  constraint-note = fail
   
-  // Reports an error if an entity is defined more than once.
-  // This constraint is implemented by testing if the "bag" of
-  // all entities x is not a singleton list.
-  constraint-error:
-    Entity(x, _) -> (x, $[Duplicate entity name])
+  constraint-warning:
+    parse-test(_,description(d), i, e) -> (d, $[Test fails])
     where
-      not(<bagof-GetEntity> x => [_])
-  
+      input := <parse-test-get-input>i
+    ; expected := <parse-test-get-expected>e  
+    ; exploded := <explode-aterm>input
+    where
+      not(<aterm-eq>(exploded, expected))
+
   constraint-warning:
-    Entity(x, _) -> (x, $[Entity names must start with a capital])
+    parse-test(_,description(d), i, failure()) -> (d, $[Test fails])
     where
-      not(<string-starts-with-capital> x)
-  
-  constraint-note:
-    Module(x @ "example", _) -> (x, $[This is just an example program in the "entities" language
-                                      (this note is defined in trans/check.str) ])
+      <parse-test-get-input>i
+
+  parse-test-get-input :
+    file(f) -> <resolve-path(|<current-path>) ; read-text-file ; spt-parse-string>f
+    
+  parse-test-get-input :
+    string(_,s,_) -> <spt-parse-string>s
+
+  parse-test-get-expected :
+    pattern(p) -> p
+
+  parse-test-get-expected :
+    success() -> wildcard()
+
+  parse-test-get-expected :
+    file(f) -> <resolve-path(|<current-path>) ; ReadFromFile; explode-aterm>f
+
+ 
+    
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/generate.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/trans/generate.str	Mon Dec 20 19:34:18 2010	(r21578)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/generate.str	Wed Dec 22 11:32:38 2010	(r21579)
@@ -18,13 +18,11 @@
         $[ package tests;
         
            import org.strategoxt.lang.Context;
-           import trans.trans;
+           import trans.*;
            import org.junit.Test;
            import static org.junit.Assert.assertNull;
            import static org.junit.Assert.assertNotNull;
            import static org.junit.Assert.assertEquals;
-           import trans.parse_string_0_0;
-           import trans.aterm_eq_0_1;
            import org.strategoxt.stratego_lib.read_text_file_0_0;
            import org.spoofax.interpreter.terms.*;
            import java.io.IOException;
@@ -39,11 +37,11 @@
            }
         ])
     with 
-      d'* := <map-with-index(try(desugar-test) ; test-to-java)> d*
+      d'* := <mapconcat(?parse-tests(<id>) <+ ![]) ; map-with-index(try(desugar-test) ; test-to-java)> d*
 
-
-  desugar-test :
-    parse-test(i, r) -> parse-test(" ", description(""), i, r)
+    desugar-test = fail
+//  desugar-test :
+//    parse-test(i, r) -> parse-test(" ", description(""), i, r)
 
   escape-string = 
   	string-replace(|"\\","\\\\")
@@ -66,7 +64,7 @@
       $[
           String input = "[s']"; 
           String description = "[d']";
-          IStrategoTerm ast = parse_string_0_0.instance.invoke(context, context.getFactory().makeString(input));
+          IStrategoTerm ast = spt_parse_string_0_0.instance.invoke(context, context.getFactory().makeString(input));
       ]
       with 
         d' := <escape-string>d
@@ -77,7 +75,7 @@
       $[
           IStrategoTerm input = read_text_file_0_0.instance.invoke(context, context.getFactory().makeString("[f']")); 
           String description = "[d']";
-          IStrategoTerm ast = parse_string_0_0.instance.invoke(context, input);
+          IStrategoTerm ast = spt_parse_string_0_0.instance.invoke(context, input);
       ]
       with 
         d' := <escape-string>d
@@ -106,7 +104,7 @@
           } catch (IOException e) {
              // do some logging 	 	
           }
-          assertEquals(description, parse_string_0_0.instance.invoke(context, context.getFactory().makeString(input)), expected ); 
+          assertEquals(description, spt_parse_string_0_0.instance.invoke(context, context.getFactory().makeString(input)), expected ); 
       ]  
       with 
         f' := <resolve-path(|<current-path>) ; escape-string>f

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/spoofax_testing.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/trans/spoofax_testing.str	Mon Dec 20 19:34:18 2010	(r21578)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/spoofax_testing.str	Wed Dec 22 11:32:38 2010	(r21579)
@@ -73,4 +73,5 @@
       id
     | <spt-get-parsetable>
     )    
-    
\ No newline at end of file
+
+        
\ No newline at end of file

From R.B.Vermaas at tudelft.nl  Wed Dec 22 12:33:18 2010
From: R.B.Vermaas at tudelft.nl (Rob Vermaas)
Date: Wed, 22 Dec 2010 11:33:18 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21580 -
	spoofax-imp/trunk/org.strategoxt.imp.testing/syntax
Message-ID: <201012221133.oBMBXIBN008537@proliant.st.ewi.tudelft.nl>

Author: rob
Date: Wed Dec 22 11:33:17 2010
New Revision: 21580
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21580&sc=1

Log:
temporarily add stratego sdf def

Added:
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Stratego-Sugar.def

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Stratego-Sugar.def
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Stratego-Sugar.def	Wed Dec 22 11:33:17 2010	(r21580)
@@ -0,0 +1,855 @@
+definition
+module Stratego-Sugar-Overlays
+imports
+  Stratego-Core-Identifiers
+  Stratego-Sugar-Terms
+
+exports %% RECOVERY RULES START HERE
+  lexical syntax
+      -> ";" {recover, cons("INSERTION")}
+
+exports
+  sorts Overlay
+  context-free syntax
+    Id 			 "=" Term 	-> Overlay {cons("OverlayNoArgs")}
+    Id "(" {Id ","}* ")" "=" Term 	-> Overlay {cons("Overlay")}
+
+module Stratego-Sugar-DynamicRules
+imports
+  Stratego-Core-Identifiers
+  Stratego-Sugar-Strategies
+  Stratego-Sugar-Rules
+
+exports
+ 
+  sorts ScopeLabels
+  context-free syntax
+
+    "{|" ScopeLabels ":" Strategy "|}" -> Strategy {cons("DynRuleScope")}
+
+    {DynRuleScopeId ","}*   -> ScopeLabels
+    "~" Term		    -> ScopeLabels {cons("ScopeLabels")}
+
+  sorts DynRuleDef DynRuleId DynRuleScopeId RuleDec
+  context-free syntax
+
+    "rules" "(" DynRuleDef* ")" -> Strategy {cons("GenDynRules")}
+
+    Id "+" Term                 -> DynRuleDef {cons("AddScopeLabel")} 
+    DynRuleId ":-"  Term        -> DynRuleDef {cons("UndefineDynRule")}
+    DynRuleId ":"   Rule        -> DynRuleDef {cons("SetDynRule")}
+    DynRuleId ":+"  Rule        -> DynRuleDef {cons("AddDynRule")}
+    DynRuleId ":"   Term        -> DynRuleDef {cons("SetDynRuleMatch")}
+
+    DynRuleId ":="  Term        -> DynRuleDef {cons("DynRuleAssign")}
+    DynRuleId ":+="  Term       -> DynRuleDef {cons("DynRuleAssignAdd")}
+
+    DynRuleId ":"   Rule "depends" "on" Term -> DynRuleDef {cons("SetDynRuleDepends")}
+
+    RuleDec "." Term            -> DynRuleId {cons("LabeledDynRuleId")}
+    RuleDec "+" Term            -> DynRuleId {cons("AddLabelDynRuleId")}
+    RuleDec                     -> DynRuleId {cons("DynRuleId")}
+
+    Id "." Term                 -> DynRuleScopeId {cons("LabeledDynRuleScopeId")}
+    Id                          -> DynRuleScopeId {cons("DynRuleScopeId")}
+
+  context-free syntax
+
+    Id                          -> RuleDec {cons("RDecNoArgs")}
+    Id "(" {Typedid ","}* ")"   -> RuleDec {cons("RDec")}
+    Id "(" {Typedid ","}* 
+       "|" {Typedid ","}* ")"   -> RuleDec {cons("RDecT")}
+
+  sorts RuleNames
+  context-free syntax
+    {Id ","}*				  -> RuleNames
+    "~" Term				  -> RuleNames {cons("RuleNames")}
+
+    "/" RuleNames "\\*" Strategy          -> Strategy {cons("DynRuleIntersectFix")}
+
+  syntax
+    %% no space after RuleNames
+    "\\" <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleUnionFix")}
+
+    %% 1 space after RuleNames
+    "\\" <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleUnionFix")}
+
+    %% no space after RuleNames
+    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
+        <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}
+
+    %% 1 space after RuleNames
+    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
+        <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}
+
+
+  context-free syntax
+    Strategy "/" RuleNames"\\" Strategy  -> Strategy {cons("DynRuleIntersect"),right}
+    Strategy "\\" RuleNames "/" Strategy  -> Strategy {cons("DynRuleUnion"),right}
+
+    Strategy "/" RuleNames "\\" 
+                 RuleNames "/"  Strategy  -> Strategy {cons("DynRuleIntersectUnion"),right}
+
+  priorities
+    <StrategyAngle-CF> <LAYOUT?-CF> <Term-CF> -> <Strategy-CF> {cons("BA")}
+  > {
+
+    %% no space after RuleNames
+    "\\" <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleUnionFix")}
+
+    %% 1 space after RuleNames
+    "\\" <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleUnionFix")}
+
+    %% no space after RuleNames
+    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
+        <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}
+
+    %% 1 space after RuleNames
+    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
+        <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}
+
+    }
+  > <Strategy-CF> <LAYOUT?-CF> "=>" <LAYOUT?-CF> <Term-CF> -> <Strategy-CF> {cons("AM")}
+
+  context-free priorities
+    StrategyAngle Term 		          -> Strategy {cons("BA")}
+  > "/" RuleNames "\\*" Strategy          -> Strategy {cons("DynRuleIntersectFix")}
+  > Strategy "=>" Term 		  	  -> Strategy {cons("AM")}
+  > Strategy "/" RuleNames "\\" Strategy  -> Strategy {cons("DynRuleIntersect"),right}
+  > Strategy "\\" RuleNames "/" Strategy  -> Strategy {cons("DynRuleUnion"),right}
+  > Strategy "/" RuleNames "\\" 
+                 RuleNames "/"  Strategy  -> Strategy {cons("DynRuleIntersectUnion"),right}
+  > Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
+
+module Stratego-Sugar-Rules
+imports Stratego-Sugar-Strategies
+exports
+
+  sorts RuleDef
+  context-free syntax
+    Id ":" Rule 				-> RuleDef {cons("RDefNoArgs")}
+    
+    Anno+ RuleDef               -> Def {cons("AnnoDef")}
+
+    Id "(" {Typedid ","}* ")" ":" Rule 		-> RuleDef {cons("RDef")}
+
+    Id "(" {Typedid ","}* 
+       "|" {Typedid ","}* ")" ":" Rule 		-> RuleDef {cons("RDefT")}
+
+  sorts Rule RuleCond
+  context-free syntax
+    Term "->" Term           	    -> Rule {cons("RuleNoCond")} %% backward comp.
+    Term "->" Term "where" Strategy -> Rule {cons("Rule")}       %% backward comp.
+    Term "->" Term RuleCond+	    -> Rule {cons("Rule"), avoid}
+
+    "where" Strategy -> RuleCond {cons("WhereClause")}
+    "with"  Strategy -> RuleCond {cons("WithClause")}
+
+module Stratego-Sugar-Strategies
+imports
+  Stratego-Core-Strategies
+  Stratego-Sugar-Terms
+  Stratego-Sugar-Constants
+  Stratego-Sugar-Signatures
+
+exports
+  context-free syntax
+    Id  		      "=" Strategy -> StrategyDef {cons("SDefNoArgs")}
+    Id "(" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("SDef")}
+
+  context-free syntax
+    ID 				  	  -> Typedid {cons("DefaultVarDec")}
+
+  sorts Rule
+
+  sorts StrategyParen StrategyCurly StrategyAngle
+  context-free syntax
+
+    %% Abstraction
+
+    SVar "(" {Strategy ","}* ")" 	  -> Strategy {cons("Call")}
+
+    %% Match and build
+
+    "{" Strategy "}" 			  -> Strategy {cons("ScopeDefault")}
+
+     %%"<" Strategy ">" Term 		  -> Strategy {cons("BA")}
+     StrategyAngle Term 		  -> Strategy {cons("BA")}
+     "<" Strategy ">"			  -> StrategyAngle {bracket} %% {cons("AngleStrat")}
+
+    %% Combinators
+
+    Strategy "<+" Strategy 		  -> Strategy {cons("LChoice"),right}
+
+    "rec" Id "(" Strategy ")" 		  -> Strategy {cons("Rec")}
+
+    "not"   "(" Strategy ")" 		  -> Strategy {cons("Not")}
+    "where" "(" Strategy ")" 		  -> Strategy {cons("Where")}
+    "with"  "(" Strategy ")" 		  -> Strategy {cons("With"), prefer}
+    "test"  "(" Strategy ")" 		  -> Strategy {cons("Test")}
+
+    %% Primitives
+
+    "prim" "(" String ")" 		  -> Strategy {cons("PrimNoArgs")}
+    "prim" "(" String "," {Term ","}* ")" -> Strategy {cons("Prim")}
+
+    %% Congruence operators
+
+    String 				  -> Strategy {cons("StrCong")}
+    Int 				  -> Strategy {cons("IntCong")}
+    Real 				  -> Strategy {cons("RealCong")}
+    Char 			 	  -> Strategy {cons("CharCong")}
+
+    String "(" {Strategy ","}* ")" 	  -> Strategy {cons("CongQ")}
+
+    %%"(" {Strategy ","}* ")" 		  -> Strategy {cons("TupleCong"),avoid}
+
+    Strategy StrategyCurly		  -> Strategy {cons("AnnoCong")}
+    
+    "{" Strategy "}"		  	  -> StrategyCurly {cons("StrategyCurly")}
+
+    "("  ")" 		  		  -> Strategy {cons("EmptyTupleCong")}
+   "(" Strategy  ")" 		          -> Strategy {bracket}
+    "(" Strategy "," {Strategy ","}+ ")"  -> Strategy {cons("TupleCong")}
+
+%%    Mod 	  			  -> Strategy {cons("ModCongNoArgs")}
+%%    Mod "(" {Strategy ","}* ")"	  	  -> Strategy {cons("ModCong")}
+%%    Id "^" Id				  -> Mod {cons("Mod")}
+    "[" {Strategy ","}* "]" 		  -> Strategy {cons("ListCongNoTail")}
+    "[" {Strategy ","}* "|" Strategy "]"  -> Strategy {cons("ListCong")}
+
+%%    Strategy "#" "(" StrategyInj ")" 	  -> Strategy {cons("ExplodeCong")}
+%%    Strategy "#" "(" Strategy ")" 	  -> Strategy {cons("ExplodeCong")}
+    Strategy "#" StrategyParen	  	  -> Strategy {cons("ExplodeCong")}
+
+  %% Syntactic sugar sugar
+
+  sorts SwitchCase
+  context-free syntax
+
+    SVar  		  		  -> Strategy {cons("CallNoArgs")}
+    "\\" Rule "\\" 			  -> Strategy {cons("LRule")}
+    "(" Rule ")" 			  -> Strategy {cons("SRule")}
+    Strategy "+" Strategy 		  -> Strategy {cons("Choice"),right} 
+    Strategy "+>" Strategy 		  -> Strategy {cons("RChoice"),right}
+
+    "proceed" "(" {Strategy "," }+ ")" -> Strategy {cons("Proceed"), prefer}
+
+    "if" Strategy "then" Strategy 
+                  "else" Strategy "end"   -> Strategy {cons("CondChoice")}
+    "if" Strategy "then" Strategy "end"   -> Strategy {cons("IfThen")}
+
+    "switch" Strategy SwitchCase* "end"   -> Strategy {cons("SwitchChoiceNoOtherwise")}
+    "switch" Strategy SwitchCase*
+         "otherwise" ":" Strategy "end"   -> Strategy {cons("SwitchChoice")}
+
+    "case" Strategy ":" Strategy          -> SwitchCase {cons("SwitchCase")}
+
+    Strategy "=>" Term 		  	  -> Strategy {cons("AM")}
+
+    Term ":=" Term			  -> Strategy {cons("Assign")}
+
+  %% Priorities
+
+  context-free priorities
+    { Strategy StrategyCurly		  -> Strategy
+      Strategy "#" StrategyParen          -> Strategy
+    }
+  > { "!" Term 				  -> Strategy
+      "?" Term 				  -> Strategy
+    }
+  > StrategyAngle Term 		          -> Strategy
+  > Strategy "=>" Term 		  	  -> Strategy
+  > Strategy ";" Strategy 		  -> Strategy
+  > {right: 
+     Strategy "+" Strategy 		  -> Strategy
+     Strategy "<+" Strategy 		  -> Strategy
+     Strategy "+>" Strategy 		  -> Strategy
+     
+     Strategy "<" StrategyMid 
+              "+" Strategy 		  -> Strategy
+    }
+
+  context-free priorities
+    Strategy 				  -> StrategyMid
+  > Strategy "+" Strategy 		  -> Strategy
+
+  context-free priorities
+    { Strategy StrategyCurly      -> Strategy
+      Strategy "#" StrategyParen  -> Strategy
+    }
+    .> Term ":=" Term -> Strategy
+
+
+module Stratego-Sugar-Terms
+imports
+  Stratego-Core-Terms
+  Stratego-Sugar-Strategies
+
+exports
+  sorts LID
+  context-free syntax
+    LId 			-> LID  {cons("ListVar")}
+    LID				-> Var  {cons("Var")}
+    LID				-> ID
+
+  context-free syntax
+    "_" PreTerm 		 -> PreTerm {cons("BuildDefaultPT")}
+    "_" Term 			 -> Term {cons("BuildDefault"),prefer}
+
+    Char 			 -> PreTerm {cons("Char")}
+
+    PreTerm "{" {Term ","}* "}"	 -> Term {cons("AnnoList")}
+    PreTerm                      -> Term {cons("NoAnnoList")}
+
+    "<" Strategy ">" Term 	 -> PreTerm {cons("App")}
+    "<" Strategy ">" Term 	 -> Term {cons("App"),prefer}
+
+    StrategyAngle		 -> PreTerm {cons("RootApp")}
+    StrategyAngle		 -> Term {cons("RootApp"),prefer}
+
+    "(" {Term ","}* ")" 	 -> PreTerm {cons("Tuple")}
+    "[" {Term ","}* "]" 	 -> PreTerm {cons("List")}
+    "[" {Term ","}* "|" Term "]" -> PreTerm {cons("ListTail")}
+
+  context-free priorities
+    Term "#" "(" Term ")" 	 -> PreTerm {cons("Explode")}
+  > PreTerm "{" {Term ","}* "}"	 -> Term {cons("AnnoList")}
+  > Var "@" Term 		 -> Term {cons("As")}
+
+module Stratego-Sugar-Signatures
+imports
+  Stratego-Core-Signatures
+  Stratego-Sugar-Constants
+
+exports
+
+  sorts Sort
+  context-free syntax
+    "[" {Sort ","}* "]"		 -> Sort {cons("SortList")}
+    "[" {Sort ","}* "|" Sort "]" -> Sort {cons("SortListTl")}
+    "(" {Sort ","}* ")"		 -> Sort {cons("SortTuple")}
+
+  sorts Kind
+  context-free syntax
+    "*" 			-> Kind {cons("Star")}
+    "**" 			-> Kind {cons("StarStar")}
+
+module Stratego-Core-Signatures
+imports
+  Stratego-Core-Identifiers
+  Stratego-Core-Constants
+exports
+  sorts Sdecl
+  context-free syntax
+    "sorts" Sort* 		-> Sdecl {cons("Sorts")}
+    "constructors" Opdecl* 	-> Sdecl {cons("Constructors")}
+
+  sorts Sort
+  context-free syntax
+    LCID 			 -> Sort {cons("SortVar")}
+    UCID 			 -> Sort {cons("SortNoArgs")}
+    Id "(" {Sort ","}* ")" 	 -> Sort {cons("Sort")}
+
+  sorts Opdecl
+  context-free syntax
+    Id     ":" Type 		-> Opdecl {cons("OpDecl")}
+    String ":" Type 		-> Opdecl {cons("OpDeclQ")}
+           ":" Type 		-> Opdecl {cons("OpDeclInj")}
+
+  context-free syntax
+    "external" Id     ":" Type 	-> Opdecl {cons("ExtOpDecl")}
+    "external" String ":" Type 	-> Opdecl {cons("ExtOpDeclQ")}
+    "external"        ":" Type 	-> Opdecl {cons("ExtOpDeclInj")}
+
+  sorts Type ArgType ConstType FunType RetType
+  context-free syntax
+    Sort	                -> ConstType {cons("ConstType")}
+    {ArgType "*"}+ "->" RetType -> FunType {cons("FunType")}
+    "(" Type ")"                -> ArgType {bracket}
+    ConstType			-> ArgType
+    Type	                -> RetType
+    FunType			-> RetType {reject}
+
+    FunType			-> Type
+    ConstType			-> Type
+
+  %%%
+   %% Restriction is required for the Sort* in Sdecl: List(a) is
+   %% ambiguous.
+   %%%
+  context-free restrictions
+    Sort -/- [\(]
+
+module Stratego-Core-Terms
+imports
+  Stratego-Core-Identifiers
+  Stratego-Core-Constants
+
+exports
+  sorts ID Var Wld
+  context-free syntax
+    Id 				-> Var  {cons("Var")}
+    Id				-> ID
+    %% ":" Var                  -> Var  {cons("SeqVar")}
+
+  sorts Term PreTerm
+  context-free syntax
+    Var 			 -> PreTerm 
+    Var 			 -> Term {prefer}
+
+    "_" 			 -> Wld {cons("Wld")}
+    Wld 			 -> PreTerm
+    Wld 			 -> Term {prefer}
+
+    Int 			 -> PreTerm {cons("Int")}
+    Real 			 -> PreTerm {cons("Real")}
+    String 			 -> PreTerm {cons("Str")}
+
+    Id "(" {Term ","}* ")" 	 -> PreTerm {cons("Op")}
+    String "(" {Term ","}* ")" 	 -> PreTerm {cons("OpQ")}
+    Term "#" "(" Term ")" 	 -> PreTerm {cons("Explode")}
+
+    PreTerm "{^" PreTerm "}"	 -> Term {cons("Anno")}
+
+    Var "@" Term 		 -> Term {cons("As"),prefer}
+    Var "@" PreTerm 		 -> PreTerm {cons("As")}
+
+  context-free priorities
+    Term "#" "(" Term ")" 	 -> PreTerm {cons("Explode")}
+  > Var "@" Term 		 -> Term {cons("As")}
+
+module Stratego-Core-Strategies
+imports
+  Stratego-Core-Terms
+  Stratego-Core-Constants
+  Stratego-Core-Signatures
+
+exports
+  sorts Def
+  context-free syntax
+    StrategyDef					 -> Def 
+    Id						 -> SVar {cons("SVar")}
+    "let" Def* "in" Strategy "end"		 -> Strategy {cons("Let")}
+    SVar "(" {Strategy ","}* "|" {Term ","}* ")" -> Strategy {cons("CallT")}
+
+    "call" "(" Term "|" {Strategy ","}* "|" {Term ","}* ")" -> Strategy {cons("CallDynamic")}
+
+
+  sorts StrategyDef
+  context-free syntax
+    Id "(" {Typedid ","}* 
+       "|" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("SDefT")}
+
+    Anno+ StrategyDef -> Def {cons("AnnoDef")}
+
+    "external"
+    Id "(" {Typedid ","}* 
+       "|" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("ExtSDefInl")}
+
+    "external"
+    Id "(" {Typedid ","}* 
+       "|" {Typedid ","}* ")"		   -> StrategyDef {cons("ExtSDef")}
+
+    "external"
+    EmptyId "(" {Typedid ","}* 
+       "|" {Typedid ","}* ")"		   -> StrategyDef {cons("ExtSDef")}
+
+
+  sorts EmptyId
+  lexical syntax
+  
+    -> EmptyId
+
+  sorts Anno
+  context-free syntax
+    "extend"      -> Anno {cons("Extend")}
+    "override"    -> Anno {cons("Override")}
+    "internal"    -> Anno {cons("Internal")}
+%%  "sealed"      -> Anno {cons("Sealed")}
+%%  "extensible"  -> Anno {cons("Extensible")}
+%%  "overridable" -> Anno {cons("Overridable")}
+
+  lexical syntax
+    
+    "extend"      -> Keyword
+    "override"    -> Keyword
+    "internal"    -> Keyword
+    "sealed"      -> Keyword
+    "extensible"  -> Keyword
+    "overridable" -> Keyword
+
+  lexical restrictions
+  
+    "extend"
+    "override"
+    "internal"
+    "sealed"
+    "extensible"
+    "overridable" -/- [a-zA-Z0-9\'\-\_]
+
+  sorts Typedid
+  context-free syntax
+    ID ":" Type 			  -> Typedid {cons("VarDec")}
+
+
+  sorts Strategy SVar StrategyParen StrategyMid 
+  context-free syntax
+    "(" Strategy ")"			  -> StrategyParen {cons("ParenStrat")}
+
+    "fail" 				  -> Strategy {cons("Fail")}
+    "id" 				  -> Strategy {cons("Id")}
+
+    "proceed" "(" {Strategy ","}* "|" {Term ","}* ")" -> Strategy {cons("ProceedT"), prefer}
+    "proceed"                                         -> Strategy {cons("ProceedNoArgs"), prefer}
+
+    %% Match and build
+
+    "?" Term 				  -> Strategy {cons("Match")}
+    "!" Term 				  -> Strategy {cons("Build")}
+    "{" {ID ","}* ":" Strategy "}" 	  -> Strategy {cons("Scope")}
+
+    %% Combinators
+
+    Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
+    Strategy "<" StrategyMid 
+             "+" Strategy 		  -> Strategy {cons("GuardedLChoice"),right}
+    Strategy 				  -> StrategyMid
+
+    %% Primitives
+
+    "prim" "(" String "," {Strategy ","}* "|" {Term ","}*")"  -> Strategy {cons("PrimT")}
+
+    %% Traversal
+
+    "some" "(" Strategy ")" 		  -> Strategy {cons("Some")}
+    "one" "(" Strategy ")" 		  -> Strategy {cons("One")}
+    "all" "(" Strategy ")" 		  -> Strategy {cons("All")}
+
+  %% Priorities
+
+  context-free priorities
+    { "!" Term 				  -> Strategy {cons("Build")}
+      "?" Term 				  -> Strategy {cons("Match")}
+    }
+  > Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
+  > {right: 
+     Strategy "<" StrategyMid 
+              "+" Strategy 		  -> Strategy {cons("GuardedLChoice"),right}
+    }
+
+  context-free syntax
+    "import-term" "(" ModName ")" -> Strategy {cons("ImportTerm")}
+
+module Stratego-Core-Modules
+imports
+  Stratego-Core-Identifiers
+  Stratego-Core-Strategies
+  Stratego-Core-Signatures
+
+exports 
+  sorts Module
+  context-free syntax
+    "module" ModName Decl* 	 -> Module {cons("Module")}
+    "specification" Decl*	 -> Module {cons("Specification")}
+
+  sorts Decl 
+  context-free syntax
+    "imports" ImportModName* 	-> Decl {cons("Imports")}
+    "strategies" Def* 		-> Decl {cons("Strategies")}
+    "signature" Sdecl*  	-> Decl {cons("Signature")}
+
+  sorts ImportModName
+  context-free syntax
+    ModName              -> ImportModName {cons("Import")}
+  syntax
+    <ModName-CF> "/" "-" -> <ImportModName-CF> {cons("ImportWildcard")}
+
+module Stratego-Sugar-Modules
+imports
+  Stratego-Core-Modules
+  Stratego-Sugar-Strategies
+  Stratego-Sugar-Signatures
+  Stratego-Sugar-Overlays
+  Stratego-Sugar-Rules
+
+exports 
+
+  sorts Decl Def
+  context-free syntax
+    "rules" Def* 		-> Decl {cons("Rules")}
+    "overlays" Overlay* 	-> Decl {cons("Overlays")}
+
+    RuleDef 			-> Def 
+
+
+module Stratego-Sugar-StringQuotations
+exports
+
+  sorts
+    StringQuotation
+    StringQuotedPart1 StringQuotedChars1 DollarOpen1 DollarClose1 QuotedBracket1 Dollar1
+    StringQuotedPart2 StringQuotedChars2 DollarOpen2 DollarClose2 QuotedBracket2 Dollar2
+    StringQuotedPart3 StringQuotedChars3 DollarOpen3 DollarClose3 QuotedBracket3 Dollar3
+    StringQuotedPart4 StringQuotedChars4 DollarOpen4 DollarClose4 QuotedBracket4  Dollar4
+    Padding
+
+  context-free syntax
+
+    StringQuotation -> PreTerm
+
+  syntax
+
+    StringQuotation -> <PreTerm-CF>
+
+    "$" "[" Padding StringQuotedPart1*               "]"    -> StringQuotation {cons("StringQuotation1") }
+     Padding "[" <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> "]"    -> StringQuotedPart1 {cons("StringEscape1")}
+    <StringQuotedChars1-LEX>                                -> StringQuotedPart1 {cons("QStr")}
+    <Dollar1-LEX>                                           -> StringQuotedPart1 {cons("QDollar")}
+    "$" <QuotedBracket1-LEX> "$"                            -> StringQuotedPart1 {cons("QBr")}
+    ~[\[\]\$]+                                              -> <StringQuotedChars1-LEX>
+    [\[\]]                                                  -> <QuotedBracket1-LEX>
+    "$"                                                     -> <Dollar1-LEX>
+
+    "$" "{" Padding StringQuotedPart2*               "}"    -> StringQuotation {cons("StringQuotation2") }
+     Padding "{" <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> "}"    -> StringQuotedPart2 {cons("StringEscape2")}
+    <StringQuotedChars2-LEX>                                -> StringQuotedPart2 {cons("QStr")}
+    <Dollar2-LEX>                                           -> StringQuotedPart2 {cons("QDollar")}
+    "$" <QuotedBracket2-LEX> "$"                            -> StringQuotedPart2 {cons("QBr")}
+    ~[\{\}\$]+                                              -> <StringQuotedChars2-LEX>
+    [\{\}]                                                  -> <QuotedBracket2-LEX>
+    "$"                                                     -> <Dollar2-LEX>
+
+    "$" "(" Padding StringQuotedPart3*              ")"     -> StringQuotation {cons("StringQuotation3") }
+    Padding "(" <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> ")"     -> StringQuotedPart3 {cons("StringEscape3")}
+    <StringQuotedChars3-LEX>                                -> StringQuotedPart3 {cons("QStr")}
+    <Dollar3-LEX>                                           -> StringQuotedPart3 {cons("QDollar")}
+    "$" <QuotedBracket3-LEX> "$"                            -> StringQuotedPart3 {cons("QBr")}
+    ~[\(\)\$]+                                              -> <StringQuotedChars3-LEX>
+    [\(\)]                                                  -> <QuotedBracket3-LEX>
+    "$"                                                     -> <Dollar3-LEX>
+
+    "$" "<" Padding StringQuotedPart4*               ">"    -> StringQuotation {cons("StringQuotation4") }
+    Padding "<"  <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> ">"    -> StringQuotedPart4 {cons("StringEscape4")}
+    <StringQuotedChars4-LEX>                                -> StringQuotedPart4 {cons("QStr")}
+    <Dollar4-LEX>                                           -> StringQuotedPart4 {cons("QDollar")}
+    "$" <QuotedBracket4-LEX> "$"                            -> StringQuotedPart4 {cons("QBr")}
+    ~[\<\>\$]+                                              -> <StringQuotedChars4-LEX>
+    [\<\>]                                                  -> <QuotedBracket4-LEX>
+    "$"                                                     -> <Dollar4-LEX>
+   
+    %% Padding is a dummy lexical that will contain the indentation prefix of every quotation
+    <Padding-LEX>                                           -> Padding
+                                                            -> <Padding-LEX> {indentpadding}
+
+  lexical restrictions
+
+    StringQuotedChars1 -/- ~[\[\]\$]   
+    StringQuotedChars2 -/- ~[\{\}\$]    
+    StringQuotedChars3 -/- ~[\(\)\$]    
+    StringQuotedChars4 -/- ~[\<\>\$]
+    Dollar1            -/- [\[\]] . [\$]
+    Dollar2            -/- [\{\}] . [\$]
+    Dollar3            -/- [\(\)] . [\$]
+    Dollar4            -/- [\<\>] . [\$]
+
+module Stratego-Core-Constants
+exports
+  sorts Int Real String StrChar
+  lexical syntax
+    [\-]? [0-9]+ 		-> Int
+    [\-]? [0-9]+ [\.] [0-9]+ 	-> Real
+    "\"" StrChar* "\"" 		-> String
+    ~[\"\\] 			-> StrChar
+    [\\] [\"tnr\\] 		-> StrChar
+
+
+module Stratego-Sugar-Constants
+imports
+  Stratego-Core-Identifiers
+  Stratego-Core-Constants
+  Stratego-Sugar-StringQuotations
+exports
+  sorts Char CharChar
+  lexical syntax
+    "'" CharChar "'"		-> Char
+    ~[\']			-> CharChar
+    [\\] [\'ntr\ ]		-> CharChar
+    Char		 	-> Id {reject}
+
+module Stratego-Core-Identifiers
+exports
+  sorts ModName ModNamePart
+  lexical syntax
+    {ModNamePart "/"}+ -> ModName
+    [a-zA-Z\.\_] [a-zA-Z0-9\'\.\-\_]* -> ModNamePart
+  lexical restrictions
+    ModName -/- [a-zA-Z0-9\'\.\-\_]
+  lexical syntax
+    "imports" 		-> ModName {reject}
+    "overlays" 		-> ModName {reject}
+    "rules" 		-> ModName {reject}
+    "signature" 	-> ModName {reject}
+    "strategies" 	-> ModName {reject}
+
+  sorts Id LId LCID UCID Wld
+  lexical syntax
+    [a-zA-Z\_] [a-zA-Z0-9\'\-\_]*     -> Id
+    [a-zA-Z\_] [a-zA-Z0-9\'\-\_]* "*" -> LId
+    [\'] [a-z]+                       -> Id
+
+    [a-z] [a-zA-Z0-9\'\-\_]*  -> LCID
+    [A-Z] [a-zA-Z0-9\'\-\_]*  -> UCID
+
+  lexical restrictions
+    Id   -/- [a-zA-Z0-9\'\_\*]
+    Id   -/- [\-].~[\>]
+    LId  -/- [a-zA-Z0-9\'\-\_]
+    LCID -/- [a-zA-Z0-9\'\-\_]
+    UCID -/- [a-zA-Z0-9\'\-\_]
+
+  lexical syntax
+    "_"     -> Id {reject}
+    "'"     -> Id {reject}
+
+    Keyword -> Id   {reject}
+    Keyword -> LId  {reject}
+    Keyword -> LCID {reject}
+    Keyword -> UCID {reject}
+
+  lexical restrictions
+    "all"
+    "case" %% not reserved kw
+    "constructors"
+    "else" %% not reserved kw
+    "end" %% not reserved kw
+    "external" %% not reserved kw
+    "fail"
+    "id"
+    "if" %% not reserved kw
+    "in"
+    "imports" %% not reserved kw
+    "let"
+    "module"
+    "not"
+    "one"
+    "overlays"
+    "otherwise" %% not reserved kw
+    "prim"
+    "rec" %% not reserved kw
+    "rules"
+    "script"
+    "signature"
+    "some"
+    "sorts"
+    "strategies"
+    "stratego"
+    "switch" %% not reserved kw
+    "test"
+    "then" %% not reserved kw
+    "where"
+    "import-term"
+      -/- [a-zA-Z0-9\'\-\_]
+  
+  context-free restrictions
+    Wld -/- [a-zA-Z0-9\'\-\_]
+
+  sorts Keyword
+  lexical syntax
+    "all"               -> Keyword
+    "constructors" 	-> Keyword
+    "fail" 		-> Keyword
+    "id" 		-> Keyword
+    "in" 		-> Keyword
+    "let" 		-> Keyword
+    "module" 		-> Keyword
+    "not" 		-> Keyword
+    "one" 		-> Keyword
+    "overlays" 		-> Keyword
+    "prim" 		-> Keyword
+    "rules" 		-> Keyword
+    "script" 		-> Keyword
+    "signature" 	-> Keyword
+    "some" 		-> Keyword
+    "sorts" 		-> Keyword
+    "strategies" 	-> Keyword
+    "stratego" 		-> Keyword
+    "test" 		-> Keyword
+    "where" 		-> Keyword
+    "import-term"	-> Keyword
+
+
+module Stratego-Core-Layout
+exports
+  sorts Ws ShortCom LongCom CommChar Asterisk Eof 
+  lexical syntax
+    [\t\ \n\r]			-> Ws
+
+    "//" ~[\n]* ([\n] | Eof)	-> ShortCom
+    "/*" CommChar* "*/"	-> LongCom
+				-> Eof  
+
+    ~[\*]     -> CommChar
+
+    "*"       -> Asterisk
+    Asterisk  -> CommChar
+
+  lexical restrictions
+    Asterisk -/- [\/]
+    Eof      -/- ~[]
+
+  lexical syntax
+    ShortCom 	-> LAYOUT
+    LongCom 	-> LAYOUT
+    Ws 		-> LAYOUT
+
+  context-free restrictions
+    LAYOUT? -/- [\ \t\n\r]
+    LAYOUT? -/- [\/].[\*]
+    LAYOUT? -/- [\/].[\/]
+
+module Stratego-Sugar-Layout
+imports Stratego-Core-Layout
+%%exports
+%%  sorts VeryLongCom Eof VLCchar Backslash
+%%  lexical syntax
+%%    "\\end{code}" VLCchar* "\\begin{code}" -> VeryLongCom
+%%    "\\begin{code}" 			   -> VeryLongCom
+%%    "\\end{code}" VLCchar* Eof 		   -> VeryLongCom
+%%    "\\literate" VLCchar* "\\begin{code}"  -> VeryLongCom
+%%    ~[\\] 				   -> VLCchar
+%%    Backslash 				   -> VLCchar
+%%    [\\] 				   -> Backslash
+
+%%  lexical restrictions
+%%    Backslash -/- [b].[e].[g].[i].[n].[\{].[c].[o].[d].[e].[\}]
+%%    Eof -/- ~[]
+
+%%  lexical syntax
+%%    VeryLongCom -> LAYOUT
+
+
+
+module Stratego-Sugar
+imports
+  Stratego-Sugar-Layout
+  Stratego-Core-Identifiers
+  Stratego-Sugar-Constants 
+  Stratego-Sugar-Modules
+  Stratego-Sugar-Signatures
+  Stratego-Sugar-Terms
+  Stratego-Sugar-Strategies
+  Stratego-Sugar-Rules
+  Stratego-Sugar-DynamicRules
+  Stratego-Sugar-Overlays
+
+hiddens
+  context-free start-symbols Module

From L.C.L.Kats at tudelft.nl  Wed Dec 22 13:09:03 2010
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Wed, 22 Dec 2010 12:09:03 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21581 - in
	spoofax-imp/trunk: org.strategoxt.imp.generator/src/sdf2imp/project
	org.strategoxt.imp.testing
	org.strategoxt.imp.testing/.externalToolBuilders org.strategoxt.i...
Message-ID: <201012221209.oBMC93jB009383@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: Wed Dec 22 12:09:03 2010
New Revision: 21581
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21581&sc=1

Log:
Resolved a build problem for clean projects that compile Stratego to a jar:
- java.jar task should be executed before stratego.jar task
- in the case of org.strategoxt.imp.testing, the java jar should not have a circular dependency on the stratego jar

Deleted:
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing.generated.pp
Modified:
   spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-build-xml.str
   spoofax-imp/trunk/org.strategoxt.imp.testing/.classpath
   spoofax-imp/trunk/org.strategoxt.imp.testing/.externalToolBuilders/Spoofax-Testing build.main.xml.launch
   spoofax-imp/trunk/org.strategoxt.imp.testing/build.main.xml

Modified: spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-build-xml.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-build-xml.str	Wed Dec 22 11:33:17 2010	(r21580)
+++ spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-build-xml.str	Wed Dec 22 12:09:03 2010	(r21581)
@@ -76,8 +76,8 @@
     <project name="build.generated">
 
         <target name="spoofaximp.default" depends="spoofaximp.default.ctree"/>
-        <target name="spoofaximp.default.ctree" depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.ctree,java.jar,sdf2imp,refresh"/>
-        <target name="spoofaximp.default.jar"   depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.jar,  java.jar,sdf2imp,refresh"/>
+        <target name="spoofaximp.default.ctree" depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,java.jar,stratego.ctree,sdf2imp,refresh"/>
+        <target name="spoofaximp.default.jar"   depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,java.jar,stratego.jar,  sdf2imp,refresh"/>
     
         <!-- Initialization -->
         <available file="${build}/<%= pkgdir %>/strategies/Main.class" property="java.jar.enabled"/>

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/.classpath
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/.classpath	Wed Dec 22 11:33:17 2010	(r21580)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/.classpath	Wed Dec 22 12:09:03 2010	(r21581)
@@ -1,10 +1,8 @@
-<?xml version="1.0" encoding="UTF-8" ?>
-
+<?xml version="1.0" encoding="UTF-8"?>
 <classpath>
-	<classpathentry kind="src" excluding="trans/**" path="editor/java"/>
+	<classpathentry excluding="trans/**" kind="src" path="editor/java"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/J2SE-1.5"/>
 	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
-        <classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
-        <classpathentry kind="lib" path="include/spoofax_testing.jar"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/.externalToolBuilders/Spoofax-Testing build.main.xml.launch
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/.externalToolBuilders/Spoofax-Testing build.main.xml.launch	Wed Dec 22 11:33:17 2010	(r21580)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/.externalToolBuilders/Spoofax-Testing build.main.xml.launch	Wed Dec 22 12:09:03 2010	(r21581)
@@ -2,8 +2,12 @@
 <launchConfiguration type="org.eclipse.ant.AntLaunchConfigurationType">
 <stringAttribute key="bad_container_name" value=".externalToolBuilders"/>
 <booleanAttribute key="org.eclipse.ant.ui.DEFAULT_VM_INSTALL" value="false"/>
-<listAttribute key="org.eclipse.debug.core.MAPPED_RESOURCE_PATHS"/>
-<listAttribute key="org.eclipse.debug.core.MAPPED_RESOURCE_TYPES"/>
+<listAttribute key="org.eclipse.debug.core.MAPPED_RESOURCE_PATHS">
+<listEntry value="/org.strategoxt.imp.testing/build.main.xml"/>
+</listAttribute>
+<listAttribute key="org.eclipse.debug.core.MAPPED_RESOURCE_TYPES">
+<listEntry value="1"/>
+</listAttribute>
 <booleanAttribute key="org.eclipse.debug.ui.ATTR_LAUNCH_IN_BACKGROUND" value="false"/>
 <listAttribute key="org.eclipse.jdt.launching.CLASSPATH">
 <listEntry value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&#10;&lt;runtimeClasspathEntry containerPath=&quot;org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/java-1.5.0-sun-1.5.0.18&quot; path=&quot;1&quot; type=&quot;4&quot;/&gt;&#10;"/>
@@ -14,7 +18,6 @@
 <booleanAttribute key="org.eclipse.jdt.launching.DEFAULT_CLASSPATH" value="false"/>
 <stringAttribute key="org.eclipse.jdt.launching.PROJECT_ATTR" value=""/>
 <stringAttribute key="org.eclipse.jdt.launching.SOURCE_PATH_PROVIDER" value="org.eclipse.ant.ui.AntClasspathProvider"/>
-<stringAttribute key="org.eclipse.ui.externaltools.ATTR_ANT_TARGETS" value="all,"/>
 <stringAttribute key="org.eclipse.ui.externaltools.ATTR_LAUNCH_CONFIGURATION_BUILD_SCOPE" value="${none}"/>
 <stringAttribute key="org.eclipse.ui.externaltools.ATTR_LOCATION" value="${project_loc}/build.main.xml"/>
 <booleanAttribute key="org.eclipse.ui.externaltools.ATTR_TRIGGERS_CONFIGURED" value="true"/>

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/build.main.xml
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/build.main.xml	Wed Dec 22 11:33:17 2010	(r21580)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/build.main.xml	Wed Dec 22 12:09:03 2010	(r21581)
@@ -30,7 +30,7 @@
         <property name="externaljar" value="../lib.jar"/>
         <property name="externaljarflags" value="-la org.lib"/>
         -->
-    
+     
         <!-- Environment configuration for command-line builds -->
         <condition property="build.strategoxt.sdf" value="${eclipse.spoofaximp.nativeprefix}" else="">
             <isset property="eclipse.spoofaximp.nativeprefix"/>
@@ -40,5 +40,5 @@
         <import file="build.generated.xml"/>
     
         <!-- Main target -->
-        <target name="all" depends="spoofaximp.default.jar"/>
+        <target name="all" depends="init,java.jar,spoofaximp.default.jar"/>
     </project>

From n.bruning at student.tudelft.nl  Sat Dec 25 20:16:19 2010
From: n.bruning at student.tudelft.nl (Nathan Bruning)
Date: Sat, 25 Dec 2010 19:16:19 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21582 -
	spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms
Message-ID: <201012251916.oBPJGJt6031979@proliant.st.ewi.tudelft.nl>

Author: NathanBruning
Date: Sat Dec 25 19:16:18 2010
New Revision: 21582
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21582&sc=1

Log:
Memory-efficient term writing

Added:
   spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/InlineWriter.java
Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/BasicTermFactory.java

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/BasicTermFactory.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/BasicTermFactory.java	Wed Dec 22 12:09:03 2010	(r21581)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/BasicTermFactory.java	Sat Dec 25 19:16:18 2010	(r21582)
@@ -8,11 +8,13 @@
 package org.spoofax.interpreter.terms;
 
 import java.io.BufferedInputStream;
+import java.io.BufferedWriter;
 import java.io.ByteArrayInputStream;
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.io.OutputStreamWriter;
 import java.io.PushbackInputStream;
 import java.io.Writer;
 import java.util.ArrayList;
@@ -310,15 +312,13 @@
     }
 
     public void unparseToFile(IStrategoTerm t, OutputStream ous) throws IOException {
-        ITermPrinter tp = new InlinePrinter();
-        t.prettyPrint(tp);
-        ous.write(tp.getString().getBytes());
+        Writer out = new BufferedWriter(new OutputStreamWriter(ous));
+        unparseToFile(t, out);
     }
 
     public void unparseToFile(IStrategoTerm t, Writer out) throws IOException {
-        ITermPrinter tp = new InlinePrinter();
+        ITermPrinter tp = new InlineWriter(out);
         t.prettyPrint(tp);
-        out.write(tp.getString());
     }
 
     public boolean hasConstructor(String name, int arity) {

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/InlineWriter.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/InlineWriter.java	Sat Dec 25 19:16:18 2010	(r21582)
@@ -0,0 +1,73 @@
+package org.spoofax.interpreter.terms;
+
+import java.io.IOException;
+import java.io.Writer;
+
+/**
+ * Term printer that writes directly to a {@link Writer}, without building the
+ * entire string representation in-memory. Does not support {@link #reset()} or
+ * {@link #getString()}. If an {@link IOException} is thrown by the
+ * {@link Writer}, it is wrapped in a {@link RuntimeException}.
+ * 
+ * Based on {@link InlinePrinter}.
+ * 
+ * @author Nathan Bruning
+ * 
+ */
+public class InlineWriter implements ITermPrinter {
+
+    Writer writer;
+
+    public InlineWriter(Writer writer) {
+        this.writer = writer;
+    }
+
+    public void print(String string) {
+        /*
+         * UNDONE: don't break empty strategostrings if (string.matches("^ *$"))
+         * { return ; }
+         */
+        tryWrite(string);
+    }
+
+    public String getString() {
+        throw new UnsupportedOperationException();
+    }
+
+    public void indent(int i) {
+    }
+
+    public void nextIndentOff() {
+    }
+
+    public void outdent(int i) {
+    }
+
+    @Override
+    public String toString() {
+        return getString();
+    }
+
+    public void reset() {
+        throw new UnsupportedOperationException();
+    }
+
+    public void println(String string, boolean b) {
+        /*
+         * if (string.matches("^ *$")) { return ; }
+         */
+        tryWrite(string);
+    }
+
+    public void println(String string) {
+        tryWrite(string);
+    }
+
+    protected void tryWrite(String string) {
+        try {
+            writer.write(string);
+        } catch (IOException e) {
+            throw new RuntimeException("Cannot write term", e);
+        }
+    }
+}

From L.C.L.Kats at tudelft.nl  Mon Dec 27 13:14:06 2010
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Mon, 27 Dec 2010 12:14:06 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21583 -
	spoofax/branches/spoofax-new-terms
Message-ID: <201012271214.oBRCE6V4007245@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: Mon Dec 27 12:14:04 2010
New Revision: 21583
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21583&sc=1

Log:
A new branch for new terms and integrating jsglr-gwt

Added:
   spoofax/branches/spoofax-new-terms/
      - copied from r21582, spoofax/trunk/

From L.C.L.Kats at tudelft.nl  Mon Dec 27 13:17:39 2010
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Mon, 27 Dec 2010 12:17:39 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21584 -
	spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr
Message-ID: <201012271217.oBRCHdrQ008038@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: Mon Dec 27 12:17:39 2010
New Revision: 21584
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21584&sc=1

Log:
Replacing jsglr with jsglr-gwt

Deleted:
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/

From L.C.L.Kats at tudelft.nl  Mon Dec 27 13:28:24 2010
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Mon, 27 Dec 2010 12:28:24 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21585 -
	spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr
Message-ID: <201012271228.oBRCSOgR010412@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: Mon Dec 27 12:28:23 2010
New Revision: 21585
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21585&sc=1

Log:
Replacing jsglr with jsglr-gwt (copy from branch; reintegrate merge requires FSFSv3)

Added:
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/
      - copied from r21584, spoofax/branches/jsglr-gwt/jsglr-gwt/

From L.C.L.Kats at tudelft.nl  Mon Dec 27 13:43:27 2010
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Mon, 27 Dec 2010 12:43:27 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21586 -
	strategoxt-java-backend/branches/strategoxt-java-backend-new-terms
Message-ID: <201012271243.oBRChRV4013700@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: Mon Dec 27 12:43:27 2010
New Revision: 21586
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21586&sc=1

Log:
Branch for new term library

Added:
   strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/
      - copied from r21585, strategoxt-java-backend/trunk/

From L.C.L.Kats at tudelft.nl  Mon Dec 27 13:43:30 2010
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Mon, 27 Dec 2010 12:43:30 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21587 -
	spoofax-imp/branches/spoofax-imp-new-terms
Message-ID: <201012271243.oBRChUcJ013715@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: Mon Dec 27 12:43:30 2010
New Revision: 21587
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21587&sc=1

Log:
Branch for new term library

Added:
   spoofax-imp/branches/spoofax-imp-new-terms/
      - copied from r21585, spoofax-imp/trunk/

From r.t.lindeman at student.tudelft.nl  Tue Dec 28 12:58:16 2010
From: r.t.lindeman at student.tudelft.nl (Ricky Lindeman)
Date: Tue, 28 Dec 2010 11:58:16 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21588 - in
	spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer:
	test/src/testimports/localmod/util
	test/src/testimports/localmod/util/dir.str test/src/testimpo...
Message-ID: <201012281158.oBSBwGgr004408@proliant.st.ewi.tudelft.nl>

Author: RickyLindeman
Date: Tue Dec 28 11:58:16 2010
New Revision: 21588
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21588&sc=1

Log:
* refactored transformer test-suite
 * add testcases for adding the debug information to the strategoxt source code
 * modified testimports test to handle directories that end with ".str"

Added:
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/test/src/testimports/localmod/util/dir.str/
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/test/src/testimports/localmod/util/subdir/
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/test/src/testimports/localmod/util/subdir/test-empty.str
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/tests/
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/tests/imports-test.str
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/tests/parsing-test.str
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/tests/strategoxt-parsing-test.str
Modified:
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/test/src/testimports/localmod/util/utils.str
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/gen-debug-var-arg.str
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/gen-debug-var.str
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/str-reader.str
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/trans-str.str
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/transformer-test-suite.str
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/traverse-imports.str

Added: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/test/src/testimports/localmod/util/subdir/test-empty.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/test/src/testimports/localmod/util/subdir/test-empty.str	Tue Dec 28 11:58:16 2010	(r21588)
@@ -0,0 +1,5 @@
+module localmod/util/subdir/test-empty
+
+strategies
+	
+	is-empty = ?[] 
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/test/src/testimports/localmod/util/utils.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/test/src/testimports/localmod/util/utils.str	Mon Dec 27 12:43:30 2010	(r21587)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/test/src/testimports/localmod/util/utils.str	Tue Dec 28 11:58:16 2010	(r21588)
@@ -2,11 +2,10 @@
 
 imports 
 	localmod/syntax/varsyntax
+	localmod/util/subdir/test-empty
 	
 strategies
 	
-	is-empty = ?[] 
-	
 	
 	first = 
 		debug(!"first: ") ;

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/gen-debug-var-arg.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/gen-debug-var-arg.str	Mon Dec 27 12:43:30 2010	(r21587)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/gen-debug-var-arg.str	Tue Dec 28 11:58:16 2010	(r21588)
@@ -21,16 +21,27 @@
 rules
 	
 	// current term is a Term
-	// create a WhereClause containing all s-var call for each variable in the mtach term
+	// create a WhereClause containing all s-var call for each variable in the match term
 	match-term-to-s-var-clause(|filename, name) :
 		match-term -> clause
 		//where <debug(!"match-term ")> match-term
 		where
+			// collect all Var in this term and create a Seq containing a s-var calls for each variable
+			seq := <create-s-var-calls-for-Term(|filename, name)> match-term
+			; clause := WhereClause(seq)
+	
+	
+	// current term should be a stratego Term.
+	// for each variable create a s-var call and join them using Seq()
+	create-s-var-calls-for-Term(|filename, name):
+		term -> seq
+		where
 			// collect all Var in this term
-			vars* := <collect(?Var(_))> match-term
+			vars* := <collect(?Var(_))> term
 			; s-vars* := <map(create-s-var-call-with-term(|filename, name))> vars*
 			; seq := <create-seqs> s-vars*
-			; clause := WhereClause(seq)
+
+			
 	
 	// create a where clause containing s-var calls for each term that is used as argument
 	t-args-to-s-var-where-clause(|filename, name) :
@@ -89,6 +100,11 @@
 		s* -> s
 		where <eq> (<length> s*, 1)
 		where s := <last> s*
+		
+	// list is size 0, just return the empty list
+	create-seqs:
+		s* -> s*
+		where <eq> (<length> s*, 0)
 	
 	
 strategies

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/gen-debug-var.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/gen-debug-var.str	Mon Dec 27 12:43:30 2010	(r21587)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/gen-debug-var.str	Tue Dec 28 11:58:16 2010	(r21588)
@@ -10,6 +10,7 @@
   assert
   location-util
   gen-debug-var-arg
+  str-reader
   
 rules
 	
@@ -120,6 +121,8 @@
     		; build-term' := <var-wrap-s(|filename, r-name)> build-term
 
 	// current term should be the match-term of a Rule
+	// the current term is a Term which can contain multiple free vars,
+	// create a s-var for each variable and return the clauses
 	try-s-var-for-match(|filename, r-name, clauses*) = 
 		(match-clause := <match-term-to-s-var-clause(|filename, r-name)>)
     	< // if first strategy succeeds
@@ -164,12 +167,22 @@
 	// match againt Assign(Var("local_var"), term)
 	// and create a Seq(assign, s-var)
 	// s-var will emit debug info
+	//
+	// Assign grammar: 
+	//   Term ":=" Term -> Strategy {cons("Assign")}
+	// Assign is desugared as: 
+	//   |[ t1 := t2 ]| -> |[ !t2; ?t1 ]|
 	match-assign-build-s-var(|filename, name):
-		 d at Assign(lhs, rhs){a} -> Seq(d, s-var-call)
+		 d at Assign(lhs, rhs){a} -> Seq(d, s-var-calls-seq)
 	with
-		var-name := <get-var-name> lhs
+		s-var-calls-seq := <create-s-var-calls-for-Term(|filename, name)> lhs
+		<+ (pp-stratego-ast; debug(!" with clause failed unexpectedly in rule 'match-assign-build-s-var'"))
+		/*
+		var-name := <get-var-name +> debug(!"get-var-name failed: ")> lhs 
 		; s-var-call := <create-s-var-call(|filename, name, var-name, a)>
-
+		*/
+		
+	//NoAnnoList(Op("Stream",[Var("pointer")]))
 	
 	// create a s-var strategy call
 	create-s-var-call(|filename, name, var-name, a) =

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/str-reader.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/str-reader.str	Mon Dec 27 12:43:30 2010	(r21587)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/str-reader.str	Tue Dec 28 11:58:16 2010	(r21588)
@@ -110,6 +110,18 @@
   pp-stratego-ast = 
   	pp-stratego-string
 	
+	
+strategies // parsing stratego
+	
+  // ignore current term
+  // returns aterm
+  parse-stratego-with-locations(|file-path) =
+	!FILE(file-path) 
+	; parse-stratego-trm(| [ "-i", file-path
+	  , "--preserve-locations" // added in rev:21513 of strategoxt, use a build from source
+	    ]
+	    )
+	 
   // ignore current term, just return the ast of a stratego program	
   get-anno-ast(|file-path) = 
       where(
@@ -132,4 +144,40 @@
     ; implode-asfix
       
   on-parse-error = debug(!"Parse error: ")
+  
+strategies // directory walking
+	
+		// fails if the current path does not have the ".str"-extension or when it is a directory
+	is-stratego-file = has-extension(|"str"); file-exists; filemode; not(isdir)
+	
+	// returns a list of paths, for which the strategy s holds.
+	// Strategy s should make the distinction between files and directories if needed,
+	// as s is applied to all elements in a directory (the elements returned by <readdir>)
+	//
+	// current term should be a String pointing to a directory name
+	walk-dir(s) = 
+		?base-dir
+		; readdir //
+		; fullpaths* := <map(prefix-with(|base-dir))> // prefix the file name with the base-dir
+		//; debug(!"list-dirs: ")
+		; has-str* := <filter(s)>
+		//; debug(!"list str: ")
+		; dirs-only* := <filter-dirs> fullpaths* // keep directories
+		; str-in-subdirs* := <map(walk-dir(s)) ; flatten-list> dirs-only*
+		//; debug(!"str-in-subdirs* ")
+		; <flatten-list> [str-in-subdirs*, has-str*]
+		// walk over the directories
+	
+	// prefix the current file name with a path prefix
+	prefix-with(|prefix) :
+		filename -> path
+		with
+			path := <concat-strings> [prefix, "/", filename]
+	
+	// in the list of paths, only keep the ones that are directories
+	filter-dirs :
+		paths* -> dirs*
+		with
+		 dirs* := <filter(file-exists ; filemode ; isdir)> paths*
+		 //< list-dirs-in-dir + ![]
 	
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/tests/imports-test.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/tests/imports-test.str	Tue Dec 28 11:58:16 2010	(r21588)
@@ -0,0 +1,188 @@
+module tests/imports-test
+
+imports
+  str-reader
+  libstratego-lib
+  gen-debug-info
+  assert
+  gen-lookup
+  traverse-imports // show all files used as import
+  trans-str
+
+imports
+  libstratego-lib
+  libstratego-sglr
+  libstratego-xtc
+  libstrc
+
+strategies // test get-internal-files
+	
+	
+  
+  test-list-imports-1 = 
+  	echo(|"test-list-imports-1")
+  	; get-project-dir => project-dir
+  	; !"test/src" => input-base-dir
+  	; !"testimports/localvar.str" => main-str-file
+  	; <concat-strings> [project-dir, "/", input-base-dir, "/", main-str-file] => absolute-location
+  	; echo(|"reading ast from: ")
+  	; echo(|absolute-location)
+  	//; !["-i",  absolute-location, "-I", "."]
+  	; args := ["-i", absolute-location]
+  	; <list-imports(|args)> absolute-location
+  	; ?(files, _)
+  	; <debug(!"files: ")> files
+  	  
+  test-list-imports-2 = 
+  	echo(|"test-list-imports-2")
+  	; get-project-dir => project-dir
+  	; !"test/src" => input-base-dir
+  	; !"testogetarts/ogetarts.str" => main-str-file
+  	; <concat-strings> [project-dir, "/", input-base-dir, "/", main-str-file] => absolute-location
+  	; echo(|"reading ast from: ")
+  	; echo(|absolute-location)
+  	//; !["-i",  absolute-location, "-I", "."]
+  	; args := ["-i", absolute-location]
+  	; <list-imports(|args)> absolute-location
+  	; ?(files, _)
+  	; <debug(!"files: ")> files
+  	  
+  // list the imports of this project
+  // project dir
+  test-list-imports-3 = 
+  	echo(|"test-list-imports-3")
+  	; get-project-dir => project-dir
+  	; !"trans" => input-base-dir
+  	; !"stratego-transformer.str" => main-str-file
+  	; <concat-strings> [project-dir, "/", input-base-dir, "/", main-str-file] => absolute-location
+  	; echo(|"reading ast from: ")
+  	; echo(|absolute-location)
+  	//; !["-i",  absolute-location, "-I", "."]
+  	; include-dir := <concat-strings> [project-dir, "/", "include"]
+  	; lib-dir := <concat-strings> [project-dir, "/", "lib"] 
+  	; syntax-dir := <concat-strings> [project-dir, "/", "syntax"]
+  	; args := [/*"pack-stratego-io", */"--slack"/*, "--imports"*/
+  	  , "-i", absolute-location
+  	    //, "-I", include-dir // not needed!, will contain output
+  	      //, "-I", lib-dir
+  	        //, "-I", syntax-dir
+  	          , "-I", project-dir
+  	            //, "-I", "."
+  	            ]
+  	; debug(!"arguments: ")
+  	; incl := [ //include-dir, // not needed, include dir only contains generated output
+  	  lib-dir, syntax-dir, project-dir]
+  	; <set-config> ("-I", incl)  
+  	//; <set-config> ("-i", absolute-location)
+  	; <list-imports(|args)> absolute-location
+  	; ?(files, _)
+  	; <debug(!"files: ")> ""
+  	; <map(debug)> files
+
+  // list the imports of this project
+  // only ".", missing syntax and lib
+  test-list-imports-4 = 
+  	echo(|"test-list-imports-4")
+  	; get-project-dir => project-dir
+  	; !"trans" => input-base-dir
+  	; !"stratego-transformer.str" => main-str-file
+  	; <concat-strings> [project-dir, "/", input-base-dir, "/", main-str-file] => absolute-location
+  	; echo(|"reading ast from: ")
+  	; echo(|absolute-location)
+  	//; !["-i",  absolute-location, "-I", "."]
+  	; include-dir := <concat-strings> [project-dir, "/", "include"]
+  	; lib-dir := <concat-strings> [project-dir, "/", "lib"] 
+  	; syntax-dir := <concat-strings> [project-dir, "/", "syntax"]
+  	; args := [/*"pack-stratego-io", */"--slack"/*, "--imports"*/
+  	  , "-i", absolute-location
+  	    //, "-I", include-dir // not needed!, will contain output
+  	      //, "-I", lib-dir
+  	        //, "-I", syntax-dir
+  	          , "-I", "."
+  	            ]
+  	; debug(!"arguments: ")
+  	; incl := [
+  	  	//include-dir, lib-dir, syntax-dir, project-dir
+  	  	"." ]
+  	; <set-config> ("-I", incl)  
+  	//; <set-config> ("-i", absolute-location)
+  	; <list-imports(|args)> absolute-location
+  	; ?(files, _)
+  	; <debug(!"files: ")> ""
+  	; <map(debug)> files
+  	  
+  // list the imports of this project	  
+  // only ".", missing syntax and lib
+  // current term: (basepath, stratego-file)
+  test-list-imports-5 = 
+  	echo(|"test-list-imports-5")
+  	; get-project-dir => project-dir
+  	; !"trans" => input-base-dir
+  	; !"stratego-transformer.str" => main-str-file
+  	; <concat-strings> [project-dir, "/", input-base-dir] => base-path
+  	; !(base-path, main-str-file)
+  	; files := <get-internal-files(|["."])>//; map(try-dbg); debug
+  	//; debug(!"not-empty: ")
+  	//; existing-files := <map(try-dbg)>
+  	//; abs-files := <filter(is-abspath)>
+  	; <debug(!"files: ")> ""
+  	; <map(debug)> files
+  	; missing := <filter(is-relpath)> files
+  	; <debug(!"missing: ")> ""
+  	; <map(debug)> missing
+  	; echo(|"end test-list-imports-5")
+  
+  // list the imports of this project	  
+  // current term: (basepath, stratego-file)
+  // "-I" project-dir
+  // all imports
+  test-list-imports-6 = 
+  	echo(|"test-list-imports-6")
+  	; get-project-dir => project-dir
+  	; !"trans" => input-base-dir
+  	; !"stratego-transformer.str" => main-str-file
+  	; <concat-strings> [project-dir, "/", input-base-dir] => base-path
+  	//; lib-dir := <concat-strings> [project-dir, "/", "lib"] 
+  	//; syntax-dir := <concat-strings> [project-dir, "/", "syntax"]
+  	; !(base-path, main-str-file)
+  	// also include "./include/Test.str" and "./lib/editor-common.generated.str"
+  	; files := <get-internal-files(|[project-dir])> //; map(try-dbg); debug
+  	; <debug(!"files: ")> ""
+  	; <map(debug)> files
+  	; missing := <filter(is-relpath)> files
+  	; <debug(!"missing: ")> ""
+  	; <map(debug)> missing
+  	; echo(|"end test-list-imports-6")
+
+  // list the imports of the testimports sample stratego file
+  // "." contains all imports
+  // current term: (basepath, stratego-file)
+  test-list-imports-7 = 
+  	echo(|"test-list-imports-7")
+  	; get-project-dir => project-dir
+  	; !"test/src/testimports" => input-base-dir
+  	; !"test/generated/testimports" => output-base-dir
+  	; !"localvar.str" => main-str-file
+  	; <concat-strings> [project-dir, "/", input-base-dir] => base-path
+  	; <concat-strings> [project-dir, "/", output-base-dir] => output-base-path
+  	; !(base-path, main-str-file)
+  	; files := <get-internal-files(|["."])> //; map(try-dbg); debug
+  	; <debug(!"files: ")> ""
+  	; <map(debug)> files
+  	; missing := <filter(is-relpath)> files
+  	; <debug(!"missing: ")> ""
+  	; <map(debug)> missing
+  	; real-files := <filter(is-abspath)> files
+  	; map(handle-file(|base-path, output-base-path)) // do apply-debug-trans for each file
+  	//; echo(|"end test-list-imports-7")
+
+	test-list-imports-8 =
+		echo(|"test-list-imports-8")
+	  	; get-project-dir => project-dir
+	  	; !"test/src/testimports" => input-base-dir
+	  	; !"test/generated/testimports" => output-base-dir
+	  	; !"localvar.str" => main-str-file
+  		; <concat-strings> [project-dir, "/", input-base-dir] => base-path
+  		; <concat-strings> [project-dir, "/", output-base-dir] => output-base-path	  	  
+  	  	; !(base-path, output-base-path, main-str-file)
+  	  	; apply-debug-project(|["."])

Added: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/tests/parsing-test.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/tests/parsing-test.str	Tue Dec 28 11:58:16 2010	(r21588)
@@ -0,0 +1,89 @@
+module tests/parsing-test
+
+imports
+  str-reader
+  libstratego-lib
+  gen-debug-info
+  assert
+  gen-lookup
+  traverse-imports // show all files used as import
+  trans-str
+
+imports
+  libstratego-lib
+  libstratego-sglr
+  libstratego-xtc
+  libstrc
+  
+strategies
+
+  // show ast with complete location annotation
+  foo1 = 
+  	echo(|"Start foo1")
+  	; get-project-dir => project-dir
+  	; !"test/src" => input-base-dir
+  	; !"test/generated" => output-base-dir
+  	; !"example.tes" => sma-file
+  	; <concat-strings> [project-dir, "/", input-base-dir, "/", sma-file] => absolute-location
+  	; echo(|"reading ast from: ")
+  	; echo(|absolute-location)
+  	; get-anno-ast(|absolute-location)
+  	; assert-module
+  	// ; debug
+  	; echo(|"End foo1")
+	
+	  // show ast with complete location annotation
+  bar1 = 
+  	echo(|"Start bar1")
+  	; get-project-dir => project-dir
+  	; !"test/src" => input-base-dir
+  	; !"test/generated" => output-base-dir
+  	; !"localvar.tes" => sma-file
+  	; <concat-strings> [project-dir, "/", input-base-dir, "/", sma-file] => absolute-location
+  	; echo(|"reading ast from: ")
+  	; echo(|absolute-location)
+  	; get-anno-ast(|absolute-location)
+  	; assert-module
+  	// ; debug
+  	; echo(|"End bar1")
+  	  
+  	  
+strategies
+	// test util methods
+	test-test-parse-stratego = 
+		debug(!"start")
+		//; f := "test/src/testimports/localvar.str"
+		; f := "test/src/localvar/localvar.str"
+		; abspath
+		; debug(!"abspath")
+		//; p := "/home/rlindeman/Documents/TU/strategoxt/spoofax-imp/source/org.strategoxt.imp.debug.stratego.transformer"
+		//; file := <concat-strings> [p, "/", f]
+		//; <get-config <+ ![]> "-I"; debug(!"get-config: ")
+		//; !FILE(file) // absolute location
+		; !FILE(f) // relative
+	    ; parse-stratego-trm(
+    		| [ "-i", f
+    		//, "--preserve-positions"
+    		, "--preserve-locations" // added in rev:21513 of strategoxt, use a build from source
+    		//, "--asfix"
+      		//, "--default-syntax", "Stratego-Sugar"
+      		//, "-I", <stratego-sugar-table-path>
+      		//, "-I", <stratego-attributes-table-path>
+      		//, "-I", <stratego-attributes-in-stratego-table-path>
+      		//, "-I", <aster-runtime-path>
+      		//	| <get-config <+ ![]> "-I"
+      		]
+    	)
+		/*
+    xtc-ensure-file => FILE(file);
+    parse-stratego-trm(
+    | [ "-i", file
+      , "--default-syntax", "Stratego-Attributes"
+      , "-I", <stratego-attributes-table-path>
+      , "-I", <stratego-attributes-in-stratego-table-path>
+      , "-I", <aster-runtime-path>
+      | <get-config <+ ![]> "-I"
+      ]
+    )
+
+    )*/
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/tests/strategoxt-parsing-test.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/tests/strategoxt-parsing-test.str	Tue Dec 28 11:58:16 2010	(r21588)
@@ -0,0 +1,70 @@
+module tests/strategoxt-parsing-test
+
+imports
+  str-reader
+  libstratego-lib
+  gen-debug-info
+  assert
+  gen-lookup
+  traverse-imports // show all files used as import
+  trans-str
+
+imports
+  libstratego-lib
+  libstratego-sglr
+  libstratego-xtc
+  libstrc
+  
+strategies
+	
+	// list all stratego (.str) files in the strategoxt source directory
+	test-walk-strategoxt-source = 
+		echo(|"test-walk-strategoxt-source")
+		; base-path := "/home/rlindeman/Documents/TU/strategoxt/strategoxt"
+		; str-files* := <walk-dir(is-stratego-file)>
+		; size := <length> str-files*
+		; <debug(!"str files count: ")> size
+		; <map(debug)> str-files*
+	
+	// walk over al stratego files in the strategoxt source and add debug information.
+	// output will be placed in test/generated/teststrxt
+	test-apply-debug-strategoxt-full = 
+		echo(|"test-apply-debug-strategoxt-1")
+		// get the stratego files
+		// source s in the base-path
+		; base-path := "/home/rlindeman/Documents/TU/strategoxt/strategoxt"
+		; get-project-dir => project-dir
+		; !"test/generated/teststrxt" => output-base-dir
+		; output-base-path := <concat-strings> [project-dir, "/", output-base-dir]
+		; str-files* := <walk-dir(is-stratego-file)> base-path
+		; <map(handle-file(|base-path, output-base-path))> str-files*
+		 
+	test-apply-debug-strategoxt-1 = 
+		echo(|"test-apply-debug-strategoxt-1")
+		// get the stratego files
+		// source s in the base-path
+		; base-path := "/home/rlindeman/Documents/TU/strategoxt/strategoxt"
+		; get-project-dir => project-dir
+		; !"test/generated/teststrxt" => output-base-dir
+		; output-base-path := <concat-strings> [project-dir, "/", output-base-dir]
+		//; str-files* := <walk-dir(is-stratego-file)> base-path
+		; str-files* := ["/home/rlindeman/Documents/TU/strategoxt/strategoxt/stratego-libraries/lib/tests/dynamic-rules/dr-propconst-tests-1.str"]
+		; <map(handle-file(|base-path, output-base-path))> str-files*
+		; run-time
+		  
+		  	// the file /home/rlindeman/Documents/TU/strategoxt/strategoxt/stratego-libraries/lib/tests/dynamic-rules/dr-propconst-tests-1.str
+	// failed because of a java memory error.
+	
+	
+	
+		// list of files in the given directory and its sub directories...
+	test-walk-dir = 
+		echo(|"test-walk-dir")
+	  	; get-project-dir => project-dir
+	  	; !"test/src/testimports" => input-base-dir
+	  	; <concat-strings> [project-dir, "/", input-base-dir] => base-path
+		//; base-path := ""
+		; str-files* := <walk-dir(is-stratego-file)>
+		; size := <length> str-files*
+		; <debug(!"str files count: ")> size
+		; <map(debug)> str-files*
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/trans-str.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/trans-str.str	Mon Dec 27 12:43:30 2010	(r21587)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/trans-str.str	Tue Dec 28 11:58:16 2010	(r21588)
@@ -43,7 +43,7 @@
 strategies
 	
 	//get-project-dir = !"/home/rlindeman/workspace/strj-dbg-transformer"	
-	get-project-dir = !"/home/rlindeman/Documents/TU/webdsl/spoofax-imp/source/org.strategoxt.imp.debug.stratego.transformer"
+	get-project-dir = !"/home/rlindeman/Documents/TU/strategoxt/spoofax-imp/source/org.strategoxt.imp.debug.stratego.transformer"
 
 
   	  

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/transformer-test-suite.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/transformer-test-suite.str	Mon Dec 27 12:43:30 2010	(r21587)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/transformer-test-suite.str	Tue Dec 28 11:58:16 2010	(r21588)
@@ -9,38 +9,22 @@
   traverse-imports // show all files used as import
   trans-str
 
+imports
+  libstratego-lib
+  libstratego-sglr
+  libstratego-xtc
+  libstrc
+
+imports
+	tests/imports-test
+	tests/parsing-test
+	tests/strategoxt-parsing-test
+
+
 strategies // test the apply-debug-trans internal steps
 	
 
-  // show ast with complete location annotation
-  foo1 = 
-  	echo(|"Start foo1")
-  	; get-project-dir => project-dir
-  	; !"test/src" => input-base-dir
-  	; !"test/generated" => output-base-dir
-  	; !"example.tes" => sma-file
-  	; <concat-strings> [project-dir, "/", input-base-dir, "/", sma-file] => absolute-location
-  	; echo(|"reading ast from: ")
-  	; echo(|absolute-location)
-  	; get-anno-ast(|absolute-location)
-  	; assert-module
-  	// ; debug
-  	; echo(|"End foo1")
-	
-	  // show ast with complete location annotation
-  bar1 = 
-  	echo(|"Start bar1")
-  	; get-project-dir => project-dir
-  	; !"test/src" => input-base-dir
-  	; !"test/generated" => output-base-dir
-  	; !"localvar.tes" => sma-file
-  	; <concat-strings> [project-dir, "/", input-base-dir, "/", sma-file] => absolute-location
-  	; echo(|"reading ast from: ")
-  	; echo(|absolute-location)
-  	; get-anno-ast(|absolute-location)
-  	; assert-module
-  	// ; debug
-  	; echo(|"End bar1")
+
   	  
   // filter unnecessary Location-annotations	
   foo2 = 
@@ -154,172 +138,6 @@
   test-apply-debug-2 = !("asdf", "ddfg", "asfd"); apply-debug-trans
   test-apply-debug-3 = !"asdf"; apply-debug-trans
   
-strategies // test get-internal-files
-	
-	
-  
-  test-list-imports-1 = 
-  	echo(|"test-list-imports-1")
-  	; get-project-dir => project-dir
-  	; !"test/src" => input-base-dir
-  	; !"testimports/localvar.str" => main-str-file
-  	; <concat-strings> [project-dir, "/", input-base-dir, "/", main-str-file] => absolute-location
-  	; echo(|"reading ast from: ")
-  	; echo(|absolute-location)
-  	//; !["-i",  absolute-location, "-I", "."]
-  	; args := ["-i", absolute-location]
-  	; <list-imports(|args)> absolute-location
-  	; ?(files, _)
-  	; <debug(!"files: ")> files
-  	  
-  test-list-imports-2 = 
-  	echo(|"test-list-imports-2")
-  	; get-project-dir => project-dir
-  	; !"test/src" => input-base-dir
-  	; !"testogetarts/ogetarts.str" => main-str-file
-  	; <concat-strings> [project-dir, "/", input-base-dir, "/", main-str-file] => absolute-location
-  	; echo(|"reading ast from: ")
-  	; echo(|absolute-location)
-  	//; !["-i",  absolute-location, "-I", "."]
-  	; args := ["-i", absolute-location]
-  	; <list-imports(|args)> absolute-location
-  	; ?(files, _)
-  	; <debug(!"files: ")> files
-  	  
-  // project dir
-  test-list-imports-3 = 
-  	echo(|"test-list-imports-3")
-  	; get-project-dir => project-dir
-  	; !"trans" => input-base-dir
-  	; !"stratego-transformer.str" => main-str-file
-  	; <concat-strings> [project-dir, "/", input-base-dir, "/", main-str-file] => absolute-location
-  	; echo(|"reading ast from: ")
-  	; echo(|absolute-location)
-  	//; !["-i",  absolute-location, "-I", "."]
-  	; include-dir := <concat-strings> [project-dir, "/", "include"]
-  	; lib-dir := <concat-strings> [project-dir, "/", "lib"] 
-  	; syntax-dir := <concat-strings> [project-dir, "/", "syntax"]
-  	; args := [/*"pack-stratego-io", */"--slack"/*, "--imports"*/
-  	  , "-i", absolute-location
-  	    //, "-I", include-dir // not needed!, will contain output
-  	      //, "-I", lib-dir
-  	        //, "-I", syntax-dir
-  	          , "-I", project-dir
-  	            //, "-I", "."
-  	            ]
-  	; debug(!"arguments: ")
-  	; incl := [ //include-dir, // not needed, include dir only contains generated output
-  	  lib-dir, syntax-dir, project-dir]
-  	; <set-config> ("-I", incl)  
-  	//; <set-config> ("-i", absolute-location)
-  	; <list-imports(|args)> absolute-location
-  	; ?(files, _)
-  	; <debug(!"files: ")> ""
-  	; <map(debug)> files
-
-  // only ".", missing syntax and lib
-  test-list-imports-4 = 
-  	echo(|"test-list-imports-4")
-  	; get-project-dir => project-dir
-  	; !"trans" => input-base-dir
-  	; !"stratego-transformer.str" => main-str-file
-  	; <concat-strings> [project-dir, "/", input-base-dir, "/", main-str-file] => absolute-location
-  	; echo(|"reading ast from: ")
-  	; echo(|absolute-location)
-  	//; !["-i",  absolute-location, "-I", "."]
-  	; include-dir := <concat-strings> [project-dir, "/", "include"]
-  	; lib-dir := <concat-strings> [project-dir, "/", "lib"] 
-  	; syntax-dir := <concat-strings> [project-dir, "/", "syntax"]
-  	; args := [/*"pack-stratego-io", */"--slack"/*, "--imports"*/
-  	  , "-i", absolute-location
-  	    //, "-I", include-dir // not needed!, will contain output
-  	      //, "-I", lib-dir
-  	        //, "-I", syntax-dir
-  	          , "-I", "."
-  	            ]
-  	; debug(!"arguments: ")
-  	; incl := [
-  	  	//include-dir, lib-dir, syntax-dir, project-dir
-  	  	"." ]
-  	; <set-config> ("-I", incl)  
-  	//; <set-config> ("-i", absolute-location)
-  	; <list-imports(|args)> absolute-location
-  	; ?(files, _)
-  	; <debug(!"files: ")> ""
-  	; <map(debug)> files
-  	  
-  // only ".", missing syntax and lib
-  // current term: (basepath, stratego-file)
-  test-list-imports-5 = 
-  	echo(|"test-list-imports-5")
-  	; get-project-dir => project-dir
-  	; !"trans" => input-base-dir
-  	; !"stratego-transformer.str" => main-str-file
-  	; <concat-strings> [project-dir, "/", input-base-dir] => base-path
-  	; !(base-path, main-str-file)
-  	; files := <get-internal-files(|["."])>//; map(try-dbg); debug
-  	//; debug(!"not-empty: ")
-  	//; existing-files := <map(try-dbg)>
-  	//; abs-files := <filter(is-abspath)>
-  	; <debug(!"files: ")> ""
-  	; <map(debug)> files
-  	; missing := <filter(is-relpath)> files
-  	; <debug(!"missing: ")> ""
-  	; <map(debug)> missing
-  	; echo(|"end test-list-imports-5")
-  	  
-  // current term: (basepath, stratego-file)
-  // "-I" project-dir
-  // all imports
-  test-list-imports-6 = 
-  	echo(|"test-list-imports-6")
-  	; get-project-dir => project-dir
-  	; !"trans" => input-base-dir
-  	; !"stratego-transformer.str" => main-str-file
-  	; <concat-strings> [project-dir, "/", input-base-dir] => base-path
-  	//; lib-dir := <concat-strings> [project-dir, "/", "lib"] 
-  	//; syntax-dir := <concat-strings> [project-dir, "/", "syntax"]
-  	; !(base-path, main-str-file)
-  	// also include "./include/Test.str" and "./lib/editor-common.generated.str"
-  	; files := <get-internal-files(|[project-dir])> //; map(try-dbg); debug
-  	; <debug(!"files: ")> ""
-  	; <map(debug)> files
-  	; missing := <filter(is-relpath)> files
-  	; <debug(!"missing: ")> ""
-  	; <map(debug)> missing
-  	; echo(|"end test-list-imports-6")
-
-  // "." contains all imports
-  // current term: (basepath, stratego-file)
-  test-list-imports-7 = 
-  	echo(|"test-list-imports-7")
-  	; get-project-dir => project-dir
-  	; !"test/src/testimports" => input-base-dir
-  	; !"test/generated/testimports" => output-base-dir
-  	; !"localvar.str" => main-str-file
-  	; <concat-strings> [project-dir, "/", input-base-dir] => base-path
-  	; <concat-strings> [project-dir, "/", output-base-dir] => output-base-path
-  	; !(base-path, main-str-file)
-  	; files := <get-internal-files(|["."])> //; map(try-dbg); debug
-  	; <debug(!"files: ")> ""
-  	; <map(debug)> files
-  	; missing := <filter(is-relpath)> files
-  	; <debug(!"missing: ")> ""
-  	; <map(debug)> missing
-  	; real-files := <filter(is-abspath)> files
-  	; map(handle-file(|base-path, output-base-path)) // do apply-debug-trans for each file
-  	//; echo(|"end test-list-imports-7")
-
-	test-list-imports-8 =
-		echo(|"test-list-imports-8")
-	  	; get-project-dir => project-dir
-	  	; !"test/src/testimports" => input-base-dir
-	  	; !"test/generated/testimports" => output-base-dir
-	  	; !"localvar.str" => main-str-file
-  		; <concat-strings> [project-dir, "/", input-base-dir] => base-path
-  		; <concat-strings> [project-dir, "/", output-base-dir] => output-base-path	  	  
-  	  	; !(base-path, output-base-path, main-str-file)
-  	  	; apply-debug-project(|["."])
   	  	  	
 strategies // test split-path
 	  	
@@ -348,4 +166,9 @@
   	echo(|"test-extract-base-from-path-2")
   	; create-s; split-path(|<create-sub>)
   	; debug(!"parent, child: ")
-  	; echo(|"end test-extract-base-from-path-2")
\ No newline at end of file
+  	; echo(|"end test-extract-base-from-path-2")
+  	  
+
+		
+
+	

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/traverse-imports.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/traverse-imports.str	Mon Dec 27 12:43:30 2010	(r21587)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.transformer/trans/traverse-imports.str	Tue Dec 28 11:58:16 2010	(r21588)
@@ -10,6 +10,8 @@
   trans-str
   
 strategies
+	// Calls pack-stratego to determine which files are imported by the given stratego file.
+	// pack-stratego is recursive as it also finds the files the imported files import.
 	// current term should be a string pointing to a stratego file
 	list-imports(|args) =
 		?ffile
@@ -33,7 +35,11 @@
       // current is FILE
     ; pack-stratego(|<pack-include-path>) => (files, spec)
 
+  // Returns a list of all files that are used as imports (or used by other imports) for the given stratego-file.
+  // 
+  //
   // directories is a list of strings, each element is a directory used by "-I"
+  // current term should a tuple with the basepath and the stratego-file which is relative to the basepath.
   get-internal-files(|directories) :
   	(basepath, stratego-file) -> real-files
   	where
@@ -53,7 +59,8 @@
   create-I:
   	directory -> ["-I", directory]
   	
-  	// if real-file start with base-path
+  	// current term should be an absolute path to a stratego file
+  	// and it should start with base-path
   	// strip the basepath from real-file => inputfilePath
   	// call apply-debug-trans
   	// sourceBasedir = base-path
@@ -61,6 +68,7 @@
   	// (sourceBasedir, inputfilePath, outputfilename)
   handle-file(|base-path, output-base-path) = 
   	?absolute-stratego-file
+  	; where(<debug(!"file: ")> absolute-stratego-file)
   	; split-path(|base-path) => (parent, rel-path)
   	; sourceBasedir := base-path
   	; inputfilePath := rel-path

From L.C.L.Kats at tudelft.nl  Tue Dec 28 13:30:23 2010
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Tue, 28 Dec 2010 12:30:23 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21589 -
	spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/META-INF
	spoofax/branches/spoofax-new-terms/spoofax/_attic
	spoofax/branches/spoofax-new-terms...
Message-ID: <201012281230.oBSCUN0r011572@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: Tue Dec 28 12:30:22 2010
New Revision: 21589
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21589&sc=1

Log:
- Moved org.spoofax.aterm and org.spoofax.adapter.aterm to the _attic

Added:
   spoofax/branches/spoofax-new-terms/spoofax/_attic/
   spoofax/branches/spoofax-new-terms/spoofax/_attic/org.spoofax.aterm/
      - copied from r21584, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.aterm/
   spoofax/branches/spoofax-new-terms/spoofax/_attic/org.spoofax.interpreter.adapter.aterm/
      - copied from r21584, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.aterm/
   spoofax/branches/spoofax-new-terms/spoofax/_attic/org.spoofax.interpreter.adapter.aterm-feature/
      - copied from r21584, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.aterm-feature/
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/.classpath
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/.project
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/.settings/
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/.settings/org.eclipse.jdt.core.prefs
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/.settings/org.eclipse.pde.core.prefs
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/META-INF/
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/META-INF/MANIFEST.MF
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/build.properties
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/legacy-src/
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/legacy-src/org/
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/legacy-src/org/spoofax/
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/legacy-src/org/spoofax/interpreter/
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/legacy-src/org/spoofax/interpreter/terms/
      - copied from r21584, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/NotImplementedException.java
      - copied unchanged from r21584, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/NotImplementedException.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/
Deleted:
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.aterm/
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.aterm/
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.aterm-feature/
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/NotImplementedException.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/legacy-src/org/spoofax/interpreter/terms/BasicStrategoAppl.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/legacy-src/org/spoofax/interpreter/terms/BasicStrategoArrayList.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/legacy-src/org/spoofax/interpreter/terms/BasicStrategoConstructor.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/legacy-src/org/spoofax/interpreter/terms/BasicStrategoInt.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/legacy-src/org/spoofax/interpreter/terms/BasicStrategoList.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/legacy-src/org/spoofax/interpreter/terms/BasicStrategoPlaceholder.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/legacy-src/org/spoofax/interpreter/terms/BasicStrategoReal.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/legacy-src/org/spoofax/interpreter/terms/BasicStrategoString.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/legacy-src/org/spoofax/interpreter/terms/BasicStrategoTerm.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/legacy-src/org/spoofax/interpreter/terms/BasicStrategoTuple.java
Modified:
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/META-INF/MANIFEST.MF
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.compiler/src/java/org/spoofax/compiler/CompileStratego.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.compiler/src/java/org/spoofax/compiler/Compiler.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.compiler/src/java/org/spoofax/compiler/Main.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.editor/src/org/spoofax/editor/internal/stratego/StrategoParser.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/META-INF/MANIFEST.MF
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/core/Interpreter.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/META-INF/MANIFEST.MF
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLRLibrary.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLR_open_parsetable.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLR_parse_stratego.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLR_parse_string_pt.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter/src/java/org/spoofax/interpreter/ConcreteInterpreter.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter/src/java/org/spoofax/interpreter/cli/Main.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/_attic/rnsglr/Parser.java
   strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/META-INF/MANIFEST.MF
   strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/Makefile.am

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/META-INF/MANIFEST.MF
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/META-INF/MANIFEST.MF	Tue Dec 28 11:58:16 2010	(r21588)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/META-INF/MANIFEST.MF	Tue Dec 28 12:30:22 2010	(r21589)
@@ -5,7 +5,7 @@
 Bundle-Version: 0.1.1.qualifier
 Require-Bundle: org.eclipse.imp.runtime,
  org.spoofax.aterm,
- org.spoofax.jsglr,
+ org.spoofax.jsglr;bundle-version="0.3.0",
  org.spoofax.interpreter.core,
  org.spoofax.interpreter.adapter.aterm,
  org.spoofax.interpreter.library.jsglr,

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.compiler/src/java/org/spoofax/compiler/CompileStratego.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.compiler/src/java/org/spoofax/compiler/CompileStratego.java	Tue Dec 28 11:58:16 2010	(r21588)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.compiler/src/java/org/spoofax/compiler/CompileStratego.java	Tue Dec 28 12:30:22 2010	(r21589)
@@ -6,7 +6,7 @@
 
 import org.spoofax.interpreter.core.InterpreterException;
 import org.spoofax.interpreter.terms.IStrategoTerm;
-import org.spoofax.jsglr.InvalidParseTableException;
+import org.spoofax.jsglr.client.InvalidParseTableException;
 
 public class CompileStratego {
 

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.compiler/src/java/org/spoofax/compiler/Compiler.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.compiler/src/java/org/spoofax/compiler/Compiler.java	Tue Dec 28 11:58:16 2010	(r21588)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.compiler/src/java/org/spoofax/compiler/Compiler.java	Tue Dec 28 12:30:22 2010	(r21589)
@@ -9,7 +9,7 @@
 import org.spoofax.interpreter.adapter.aterm.WrappedATermFactory;
 import org.spoofax.interpreter.library.jsglr.JSGLRLibrary;
 import org.spoofax.interpreter.terms.IStrategoTerm;
-import org.spoofax.jsglr.InvalidParseTableException;
+import org.spoofax.jsglr.client.InvalidParseTableException;
 
 /**
  * @deprecated use strc-java instead

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.compiler/src/java/org/spoofax/compiler/Main.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.compiler/src/java/org/spoofax/compiler/Main.java	Tue Dec 28 11:58:16 2010	(r21588)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.compiler/src/java/org/spoofax/compiler/Main.java	Tue Dec 28 12:30:22 2010	(r21589)
@@ -9,7 +9,7 @@
 import org.spoofax.interpreter.core.InterpreterException;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.InlinePrinter;
-import org.spoofax.jsglr.InvalidParseTableException;
+import org.spoofax.jsglr.client.InvalidParseTableException;
 
 /**
  * @deprecated use strc-java instead

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.editor/src/org/spoofax/editor/internal/stratego/StrategoParser.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.editor/src/org/spoofax/editor/internal/stratego/StrategoParser.java	Tue Dec 28 11:58:16 2010	(r21588)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.editor/src/org/spoofax/editor/internal/stratego/StrategoParser.java	Tue Dec 28 12:30:22 2010	(r21589)
@@ -11,9 +11,9 @@
 //import java.io.IOException;
 
 //import org.spoofax.editor.SpoofaxEditorPlugin;
-//import org.spoofax.jsglr.InvalidParseTableException;
-//import org.spoofax.jsglr.ParseTable;
-//import org.spoofax.jsglr.ParseTableManager;
+//import org.spoofax.jsglr.client.InvalidParseTableException;
+//import org.spoofax.jsglr.client.ParseTable;
+//import org.spoofax.jsglr.client.ParseTableManager;
 //import org.spoofax.jsglr.SGLR;
 //import org.spoofax.jsglr.SGLRException;
 

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/META-INF/MANIFEST.MF
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/META-INF/MANIFEST.MF	Tue Dec 28 11:58:16 2010	(r21588)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/META-INF/MANIFEST.MF	Tue Dec 28 12:30:22 2010	(r21589)
@@ -2,9 +2,10 @@
 Bundle-ManifestVersion: 2
 Bundle-Name: Stratego Interpreter Core
 Bundle-SymbolicName: org.spoofax.interpreter.core;singleton=true
-Bundle-Version: 0.3.13.qualifier
+Bundle-Version: 0.4.0.qualifier
 Require-Bundle: org.junit,
- org.junit4
+ org.junit4,
+ org.spoofax.terms
 Eclipse-LazyStart: false
 Export-Package: org.spoofax,
  org.spoofax.interpreter.core,

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/core/Interpreter.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/core/Interpreter.java	Tue Dec 28 11:58:16 2010	(r21588)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/core/Interpreter.java	Tue Dec 28 12:30:22 2010	(r21589)
@@ -16,7 +16,7 @@
 import org.spoofax.interpreter.library.ssl.SSLLibrary;
 import org.spoofax.interpreter.stratego.SDefT;
 import org.spoofax.interpreter.stratego.StupidFormatter;
-import org.spoofax.interpreter.terms.BasicTermFactory;
+import org.spoofax.interpreter.terms.BasicTermFactory;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.ITermFactory;
 

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/META-INF/MANIFEST.MF
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/META-INF/MANIFEST.MF	Tue Dec 28 11:58:16 2010	(r21588)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/META-INF/MANIFEST.MF	Tue Dec 28 12:30:22 2010	(r21589)
@@ -8,7 +8,7 @@
 Require-Bundle: org.eclipse.ui,
  org.eclipse.core.runtime,
  org.spoofax.interpreter.core,
- org.spoofax.jsglr,
+ org.spoofax.jsglr;bundle-version="0.3.0",
  org.spoofax.interpreter.adapter.aterm,
  org.spoofax.aterm
 Bundle-ActivationPolicy: lazy

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLRLibrary.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLRLibrary.java	Tue Dec 28 11:58:16 2010	(r21588)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLRLibrary.java	Tue Dec 28 12:30:22 2010	(r21589)
@@ -7,8 +7,8 @@
 import org.spoofax.interpreter.adapter.aterm.WrappedATermFactory;
 import org.spoofax.interpreter.library.AbstractStrategoOperatorRegistry;
 import org.spoofax.interpreter.terms.ITermFactory;
-import org.spoofax.jsglr.ParseTable;
-import org.spoofax.jsglr.ParseTableManager;
+import org.spoofax.jsglr.client.ParseTable;
+import org.spoofax.jsglr.client.ParseTableManager;
 
 import aterm.ATermFactory;
 

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLR_open_parsetable.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLR_open_parsetable.java	Tue Dec 28 11:58:16 2010	(r21588)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLR_open_parsetable.java	Tue Dec 28 12:30:22 2010	(r21589)
@@ -7,8 +7,8 @@
 import org.spoofax.interpreter.stratego.Strategy;
 import org.spoofax.interpreter.terms.IStrategoInt;
 import org.spoofax.interpreter.terms.IStrategoTerm;
-import org.spoofax.jsglr.InvalidParseTableException;
-import org.spoofax.jsglr.ParseTable;
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParseTable;
 
 import aterm.ATerm;
 

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLR_parse_stratego.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLR_parse_stratego.java	Tue Dec 28 11:58:16 2010	(r21588)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLR_parse_stratego.java	Tue Dec 28 12:30:22 2010	(r21589)
@@ -11,11 +11,11 @@
 import org.spoofax.interpreter.stratego.Strategy;
 import org.spoofax.interpreter.terms.IStrategoString;
 import org.spoofax.interpreter.terms.IStrategoTerm;
-import org.spoofax.jsglr.InvalidParseTableException;
-import org.spoofax.jsglr.ParseTable;
-import org.spoofax.jsglr.ParseTableManager;
-import org.spoofax.jsglr.SGLR;
-import org.spoofax.jsglr.SGLRException;
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParseTable;
+import org.spoofax.jsglr.client.SGLR;
+import org.spoofax.jsglr.io.ParseTableManager;
+import org.spoofax.jsglr.shared.SGLRException;
 
 import aterm.ATerm;
 import aterm.ATermFactory;

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLR_parse_string_pt.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLR_parse_string_pt.java	Tue Dec 28 11:58:16 2010	(r21588)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLR_parse_string_pt.java	Tue Dec 28 12:30:22 2010	(r21589)
@@ -14,7 +14,7 @@
 import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoString;
 import org.spoofax.interpreter.terms.IStrategoTerm;
-import org.spoofax.jsglr.ParseTable;
+import org.spoofax.jsglr.client.ParseTable;
 import org.spoofax.jsglr.SGLR;
 import org.spoofax.jsglr.SGLRException;
 

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter/src/java/org/spoofax/interpreter/ConcreteInterpreter.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter/src/java/org/spoofax/interpreter/ConcreteInterpreter.java	Tue Dec 28 11:58:16 2010	(r21588)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter/src/java/org/spoofax/interpreter/ConcreteInterpreter.java	Tue Dec 28 12:30:22 2010	(r21589)
@@ -5,7 +5,7 @@
 import org.spoofax.interpreter.core.Interpreter;
 import org.spoofax.interpreter.core.InterpreterException;
 import org.spoofax.interpreter.adapter.aterm.WrappedATermFactory;
-import org.spoofax.jsglr.InvalidParseTableException;
+import org.spoofax.jsglr.client.InvalidParseTableException;
 import org.spoofax.compiler.Compiler;
 
 public class ConcreteInterpreter extends Interpreter {

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter/src/java/org/spoofax/interpreter/cli/Main.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter/src/java/org/spoofax/interpreter/cli/Main.java	Tue Dec 28 11:58:16 2010	(r21588)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter/src/java/org/spoofax/interpreter/cli/Main.java	Tue Dec 28 12:30:22 2010	(r21589)
@@ -6,7 +6,7 @@
 
 import org.spoofax.interpreter.ConcreteInterpreter;
 import org.spoofax.interpreter.core.InterpreterException;
-import org.spoofax.jsglr.InvalidParseTableException;
+import org.spoofax.jsglr.client.InvalidParseTableException;
 
 public class Main {
 

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/_attic/rnsglr/Parser.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/_attic/rnsglr/Parser.java	Tue Dec 28 11:58:16 2010	(r21588)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/_attic/rnsglr/Parser.java	Tue Dec 28 12:30:22 2010	(r21589)
@@ -5,7 +5,7 @@
 
 import org.spoofax.jsglr.ActionItem;
 import org.spoofax.jsglr.NotImplementedException;
-import org.spoofax.jsglr.ParseTable;
+import org.spoofax.jsglr.client.ParseTable;
 import org.spoofax.jsglr.Reduce;
 import org.spoofax.jsglr.ReduceLookahead;
 import org.spoofax.jsglr.Shift;

Added: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/.classpath
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/.classpath	Tue Dec 28 12:30:22 2010	(r21589)
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/J2SE-1.5"/>
+	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="legacy-src"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>

Added: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/.project
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/.project	Tue Dec 28 12:30:22 2010	(r21589)
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>org.spoofax.terms</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.pde.ManifestBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.pde.SchemaBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.pde.PluginNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>

Added: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/.settings/org.eclipse.jdt.core.prefs
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/.settings/org.eclipse.jdt.core.prefs	Tue Dec 28 12:30:22 2010	(r21589)
@@ -0,0 +1,8 @@
+#Mon Dec 27 13:35:17 CET 2010
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.5
+org.eclipse.jdt.core.compiler.compliance=1.5
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.source=1.5

Added: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/.settings/org.eclipse.pde.core.prefs
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/.settings/org.eclipse.pde.core.prefs	Tue Dec 28 12:30:22 2010	(r21589)
@@ -0,0 +1,4 @@
+#Mon Dec 27 13:35:17 CET 2010
+eclipse.preferences.version=1
+pluginProject.extensions=false
+resolve.requirebundle=false

Added: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/META-INF/MANIFEST.MF
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/META-INF/MANIFEST.MF	Tue Dec 28 12:30:22 2010	(r21589)
@@ -0,0 +1,7 @@
+Manifest-Version: 1.0
+Bundle-ManifestVersion: 2
+Bundle-Name: org.spoofax.terms
+Bundle-SymbolicName: org.spoofax.terms
+Bundle-Version: 1.0.0.qualifier
+Bundle-RequiredExecutionEnvironment: J2SE-1.5
+Export-Package: org.spoofax, org.spoofax.interpreter.terms, org.spoofax.terms, org.spoofax.terms.io

Added: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/build.properties
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/build.properties	Tue Dec 28 12:30:22 2010	(r21589)
@@ -0,0 +1,4 @@
+source.. = src/
+output.. = bin/
+bin.includes = META-INF/,\
+               .

Copied: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/NotImplementedException.java (from r21584, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/NotImplementedException.java)
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/NotImplementedException.java	Tue Dec 28 12:30:22 2010	(r21589, copy of r21584, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/NotImplementedException.java)
@@ -0,0 +1,28 @@
+/*
+ * Created on 17. sep.. 2006
+ *
+ * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
+ * 
+ * Licensed under the GNU General Public License, v2
+ */
+package org.spoofax;
+
+public class NotImplementedException extends RuntimeException {
+
+    private final String message;
+    
+    public NotImplementedException() {
+        message = "Not Implemented";
+    }
+    
+    public NotImplementedException(String message) {
+        this.message = message;
+    }
+
+    private static final long serialVersionUID = -1028814795329444374L;
+
+    @Override
+    public String toString() {
+        return message;
+    }
+}

Modified: strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/META-INF/MANIFEST.MF
==============================================================================
--- strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/META-INF/MANIFEST.MF	Tue Dec 28 11:58:16 2010	(r21588)
+++ strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/META-INF/MANIFEST.MF	Tue Dec 28 12:30:22 2010	(r21589)
@@ -70,7 +70,7 @@
 Require-Bundle: org.spoofax.aterm,
  org.spoofax.interpreter.core,
  org.spoofax.interpreter.adapter.aterm,
- org.spoofax.jsglr,
+ org.spoofax.jsglr;bundle-version="0.3.0",
  org.spoofax.interpreter.library.jsglr,
  org.eclipse.ant.core;bundle-version="3.0.0",
  org.eclipse.core.runtime;bundle-version="3.0.0"

Modified: strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/Makefile.am
==============================================================================
--- strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/Makefile.am	Tue Dec 28 11:58:16 2010	(r21588)
+++ strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/Makefile.am	Tue Dec 28 12:30:22 2010	(r21589)
@@ -126,6 +126,7 @@
 	rm -rf spoofax-libs-tmp/META-INF
 	$(JAR) cf spoofax-libs.jar.tmp -C spoofax-libs-tmp .
 	$(JAR) uf spoofax-libs.jar.tmp -C $(SPOOFAX)/org.spoofax.interpreter.core/bin/ .
+	$(JAR) uf spoofax-libs.jar.tmp -C $(SPOOFAX)/org.spoofax.terms/bin/ .
 	$(JAR) uf spoofax-libs.jar.tmp -C $(SPOOFAX)/org.spoofax.jsglr/bin/ .
 	$(JAR) uf spoofax-libs.jar.tmp -C $(SPOOFAX)/org.spoofax.aterm/bin/ .
 	$(JAR) uf spoofax-libs.jar.tmp -C $(SPOOFAX)/org.spoofax.interpreter.adapter.aterm/bin/ .

From L.C.L.Kats at tudelft.nl  Tue Dec 28 15:15:56 2010
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Tue, 28 Dec 2010 14:15:56 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21590 -
	spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/META-INF
	spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strate...
Message-ID: <201012281415.oBSEFuH7002475@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: Tue Dec 28 14:15:54 2010
New Revision: 21590
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21590&sc=1

Log:
refactoring

Added:
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/aterm/
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/aterm/pure/
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/INonIOTermFactory.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/ITerm.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/AbstractIOTermFactory.java
      - copied, changed from r21589, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/legacy-src/org/spoofax/interpreter/terms/BasicTermFactory.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/ITermFactory.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/InlinePrinter.java
      - copied, changed from r21589, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/legacy-src/org/spoofax/interpreter/terms/InlinePrinter.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/InlineWriter.java
      - copied, changed from r21589, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/legacy-src/org/spoofax/interpreter/terms/InlineWriter.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/baf/
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/baf/BAFReader.java
      - copied, changed from r21586, strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/terms/BAFReader.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/baf/BitStream.java
      - copied, changed from r21589, spoofax/branches/spoofax-new-terms/spoofax/_attic/org.spoofax.aterm/src/aterm/pure/BitStream.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/baf/MemoryMappedBitStream.java
      - copied, changed from r21589, spoofax/branches/spoofax-new-terms/spoofax/_attic/org.spoofax.aterm/src/aterm/pure/MemoryMappedBitStream.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/baf/ParseException.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/
      - copied from r21586, strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/terms/
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/LazyTerm.java
      - copied, changed from r21586, strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/LazyTerm.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/TermWrapperException.java
      - copied, changed from r21586, strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/TermWrapperException.java
Deleted:
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/legacy-src/org/spoofax/interpreter/terms/BasicTermFactory.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/legacy-src/org/spoofax/interpreter/terms/InlinePrinter.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/legacy-src/org/spoofax/interpreter/terms/InlineWriter.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/BAFReader.java
   strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/LazyTerm.java
   strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/TermWrapperException.java
   strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/terms/
Modified:
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/META-INF/MANIFEST.MF
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/DescriptorFactory.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AstNode.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/IMPParseStringPTPrimitive.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/SourceMappings.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/WrappedAstNode.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.compiler/META-INF/MANIFEST.MF
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.compiler/src/java/org/spoofax/compiler/Main.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.editor/META-INF/MANIFEST.MF
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.editor/src/org/spoofax/editor/internal/SPX_debug.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.asm/src/org/spoofax/interpreter/adapter/asm/WrappedASMNode.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/META-INF/MANIFEST.MF
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/ecjadapter/Main.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/ecjadapter/ParseJava.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/AbstractECJNode.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/ECJFactory.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedASTNodeList.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedECJNode.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedGenericAppl.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/library/ecj/ECJ_search_for_supertype_type_refs_in_hierarchy.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/core/Interpreter.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_printnl.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_write_term_to_string.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/StrategoHashMap.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/StrategoSet.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLRLibrary.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/META-INF/MANIFEST.MF
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/legacy-src/org/spoofax/interpreter/terms/ITermFactory.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoWrapped.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/TermFactory.java
   strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/META-INF/MANIFEST.MF
   strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/ImportTerm.java

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/META-INF/MANIFEST.MF
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/META-INF/MANIFEST.MF	Tue Dec 28 12:30:22 2010	(r21589)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/META-INF/MANIFEST.MF	Tue Dec 28 14:15:54 2010	(r21590)
@@ -24,7 +24,8 @@
  org.eclipse.debug.ui,
  org.spoofax.compiler,
  org.strategoxt.imp.generator,
- org.strategoxt.strj
+ org.strategoxt.strj,
+ org.spoofax.terms
 Export-Package: org.strategoxt.imp.runtime,
  org.strategoxt.imp.runtime.dynamicloading,
  org.strategoxt.imp.runtime.parser,

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/DescriptorFactory.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/DescriptorFactory.java	Tue Dec 28 12:30:22 2010	(r21589)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/DescriptorFactory.java	Tue Dec 28 14:15:54 2010	(r21590)
@@ -14,12 +14,12 @@
 import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.jsglr.ParseTable;
 import org.spoofax.jsglr.SGLRException;
+import org.spoofax.terms.io.baf.BAFReader;
 import org.strategoxt.imp.generator.sdf2imp;
 import org.strategoxt.imp.runtime.Debug;
 import org.strategoxt.imp.runtime.Environment;
 import org.strategoxt.imp.runtime.parser.JSGLRI;
 import org.strategoxt.lang.WeakValueHashMap;
-import org.strategoxt.lang.terms.BAFReader;
 
 /**
  * @author Lennart Kats <lennart add lclnet.nl>

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AstNode.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AstNode.java	Tue Dec 28 12:30:22 2010	(r21589)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AstNode.java	Tue Dec 28 14:15:54 2010	(r21590)
@@ -13,7 +13,7 @@
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.ITermPrinter;
-import org.spoofax.interpreter.terms.InlinePrinter;
+import org.spoofax.terms.io.InlinePrinter;
 import org.strategoxt.imp.runtime.Environment;
 import org.strategoxt.imp.runtime.parser.SGLRParseController;
 import org.strategoxt.imp.runtime.parser.tokens.SGLRToken;

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/IMPParseStringPTPrimitive.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/IMPParseStringPTPrimitive.java	Tue Dec 28 12:30:22 2010	(r21589)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/IMPParseStringPTPrimitive.java	Tue Dec 28 14:15:54 2010	(r21590)
@@ -16,8 +16,8 @@
 import org.strategoxt.imp.runtime.Environment;
 import org.strategoxt.imp.runtime.parser.JSGLRI;
 import org.strategoxt.imp.runtime.stratego.SourceMappings.MappableTerm;
-import org.strategoxt.lang.LazyTerm;
 import org.strategoxt.lang.compat.sglr.JSGLR_parse_string_pt_compat;
+import org.strategoxt.lang.terms.LazyTerm;
 
 import aterm.ATerm;
 import aterm.ATermFactory;

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/SourceMappings.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/SourceMappings.java	Tue Dec 28 12:30:22 2010	(r21589)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/SourceMappings.java	Tue Dec 28 14:15:54 2010	(r21590)
@@ -11,7 +11,7 @@
 import org.spoofax.interpreter.terms.IStrategoString;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.strategoxt.imp.runtime.parser.tokens.SGLRTokenizer;
-import org.strategoxt.lang.LazyTerm;
+import org.strategoxt.lang.terms.LazyTerm;
 
 import aterm.ATerm;
 

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/WrappedAstNode.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/WrappedAstNode.java	Tue Dec 28 12:30:22 2010	(r21589)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/WrappedAstNode.java	Tue Dec 28 14:15:54 2010	(r21590)
@@ -2,7 +2,7 @@
 
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoTerm;
-import org.spoofax.interpreter.terms.InlinePrinter;
+import org.spoofax.terms.io.InlinePrinter;
 import org.strategoxt.lang.terms.StrategoTerm;
 import org.strategoxt.lang.terms.TermFactory;
 

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.compiler/META-INF/MANIFEST.MF
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.compiler/META-INF/MANIFEST.MF	Tue Dec 28 12:30:22 2010	(r21589)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.compiler/META-INF/MANIFEST.MF	Tue Dec 28 14:15:54 2010	(r21590)
@@ -9,8 +9,7 @@
  org.spoofax.jsglr,
  org.spoofax.interpreter.adapter.aterm,
  org.junit,
- org.junit,
- org.junit
+ org.spoofax.terms
 Bundle-ActivationPolicy: lazy
 Export-Package: org.spoofax.compiler
 Bundle-RequiredExecutionEnvironment: J2SE-1.5

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.compiler/src/java/org/spoofax/compiler/Main.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.compiler/src/java/org/spoofax/compiler/Main.java	Tue Dec 28 12:30:22 2010	(r21589)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.compiler/src/java/org/spoofax/compiler/Main.java	Tue Dec 28 14:15:54 2010	(r21590)
@@ -8,8 +8,8 @@
 
 import org.spoofax.interpreter.core.InterpreterException;
 import org.spoofax.interpreter.terms.IStrategoTerm;
-import org.spoofax.interpreter.terms.InlinePrinter;
 import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.terms.io.InlinePrinter;
 
 /**
  * @deprecated use strc-java instead

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.editor/META-INF/MANIFEST.MF
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.editor/META-INF/MANIFEST.MF	Tue Dec 28 12:30:22 2010	(r21589)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.editor/META-INF/MANIFEST.MF	Tue Dec 28 14:15:54 2010	(r21590)
@@ -19,7 +19,8 @@
  org.spoofax.interpreter.core,
  org.spoofax.interpreter.adapter.aterm,
  org.spoofax.interpreter.library.eclipse,
- org.spoofax.interpreter.library.jsglr
+ org.spoofax.interpreter.library.jsglr,
+ org.spoofax.terms
 Bundle-Vendor: Spoofax.org
 Bundle-ClassPath: spoofax.jar
 Bundle-ActivationPolicy: lazy

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.editor/src/org/spoofax/editor/internal/SPX_debug.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.editor/src/org/spoofax/editor/internal/SPX_debug.java	Tue Dec 28 12:30:22 2010	(r21589)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.editor/src/org/spoofax/editor/internal/SPX_debug.java	Tue Dec 28 14:15:54 2010	(r21590)
@@ -7,7 +7,7 @@
 import org.spoofax.interpreter.library.AbstractPrimitive;
 import org.spoofax.interpreter.stratego.Strategy;
 import org.spoofax.interpreter.terms.IStrategoTerm;
-import org.spoofax.interpreter.terms.InlinePrinter;
+import org.spoofax.terms.io.InlinePrinter;
 
 public class SPX_debug extends AbstractPrimitive {
 

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.asm/src/org/spoofax/interpreter/adapter/asm/WrappedASMNode.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.asm/src/org/spoofax/interpreter/adapter/asm/WrappedASMNode.java	Tue Dec 28 12:30:22 2010	(r21589)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.asm/src/org/spoofax/interpreter/adapter/asm/WrappedASMNode.java	Tue Dec 28 14:15:54 2010	(r21590)
@@ -4,7 +4,7 @@
 import org.spoofax.interpreter.terms.IStrategoConstructor;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.ITermPrinter;
-import org.spoofax.interpreter.terms.InlinePrinter;
+import org.spoofax.terms.io.InlinePrinter;
 
 public abstract class WrappedASMNode implements IStrategoTerm {
 

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/META-INF/MANIFEST.MF
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/META-INF/MANIFEST.MF	Tue Dec 28 12:30:22 2010	(r21589)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/META-INF/MANIFEST.MF	Tue Dec 28 14:15:54 2010	(r21590)
@@ -9,7 +9,8 @@
  org.junit,
  org.spoofax.interpreter.core,
  org.spoofax.interpreter.adapter.aterm,
- org.eclipse.text
+ org.eclipse.text,
+ org.spoofax.terms
 Bundle-Vendor: Spoofax.org
 Export-Package: 
  org.spoofax.interpreter.adapter.ecj,

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/ecjadapter/Main.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/ecjadapter/Main.java	Tue Dec 28 12:30:22 2010	(r21589)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/ecjadapter/Main.java	Tue Dec 28 14:15:54 2010	(r21590)
@@ -20,7 +20,7 @@
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.ITermFactory;
 import org.spoofax.interpreter.terms.ITermPrinter;
-import org.spoofax.interpreter.terms.InlinePrinter;
+import org.spoofax.terms.io.InlinePrinter;
 
 public class Main {
 

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/ecjadapter/ParseJava.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/ecjadapter/ParseJava.java	Tue Dec 28 12:30:22 2010	(r21589)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/ecjadapter/ParseJava.java	Tue Dec 28 14:15:54 2010	(r21590)
@@ -23,7 +23,7 @@
 import org.spoofax.interpreter.adapter.ecj.ECJFactory;
 import org.spoofax.interpreter.core.InterpreterException;
 import org.spoofax.interpreter.terms.IStrategoTerm;
-import org.spoofax.interpreter.terms.InlinePrinter;
+import org.spoofax.terms.io.InlinePrinter;
 
 public class ParseJava {
 

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/AbstractECJNode.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/AbstractECJNode.java	Tue Dec 28 12:30:22 2010	(r21589)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/AbstractECJNode.java	Tue Dec 28 14:15:54 2010	(r21590)
@@ -7,13 +7,13 @@
  */
 package org.spoofax.interpreter.adapter.ecj;
 
-import org.spoofax.interpreter.terms.BasicTermFactory;
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.terms.io.AbstractIOTermFactory;
 
 public abstract class AbstractECJNode implements IStrategoTerm {
 	public IStrategoList getAnnotations() {
-		return BasicTermFactory.EMPTY_LIST;
+		return AbstractIOTermFactory.EMPTY_LIST;
 	}
     
     public int getStorageType() {

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/ECJFactory.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/ECJFactory.java	Tue Dec 28 12:30:22 2010	(r21589)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/ECJFactory.java	Tue Dec 28 14:15:54 2010	(r21590)
@@ -44,7 +44,7 @@
 import org.spoofax.interpreter.terms.IStrategoTuple;
 import org.spoofax.interpreter.terms.ITermFactory;
 import org.spoofax.interpreter.terms.ITermPrinter;
-import org.spoofax.interpreter.terms.InlinePrinter;
+import org.spoofax.terms.io.InlinePrinter;
 
 public class ECJFactory implements ITermFactory {
 

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedASTNodeList.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedASTNodeList.java	Tue Dec 28 12:30:22 2010	(r21589)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedASTNodeList.java	Tue Dec 28 14:15:54 2010	(r21590)
@@ -12,10 +12,10 @@
 
 import org.eclipse.jdt.core.dom.ASTNode;
 import org.spoofax.NotImplementedException;
-import org.spoofax.interpreter.terms.BasicTermFactory;
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.ITermPrinter;
+import org.spoofax.terms.io.AbstractIOTermFactory;
 
 public class WrappedASTNodeList implements IStrategoList {
 
@@ -146,6 +146,6 @@
     }
     
     public IStrategoList getAnnotations() {
-    	return BasicTermFactory.EMPTY_LIST;
+    	return AbstractIOTermFactory.EMPTY_LIST;
     }
 }

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedECJNode.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedECJNode.java	Tue Dec 28 12:30:22 2010	(r21589)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedECJNode.java	Tue Dec 28 14:15:54 2010	(r21590)
@@ -7,9 +7,9 @@
  */
 package org.spoofax.interpreter.adapter.ecj;
 
-import org.spoofax.interpreter.terms.BasicTermFactory;
 import org.spoofax.interpreter.terms.IStrategoConstructor;
 import org.spoofax.interpreter.terms.IStrategoList;
+import org.spoofax.terms.io.AbstractIOTermFactory;
 
 
 public abstract class WrappedECJNode extends AbstractECJAppl {
@@ -21,7 +21,7 @@
     public abstract Object getWrappee();
     
     public IStrategoList getAnnotations() {
-    	return BasicTermFactory.EMPTY_LIST;
+    	return AbstractIOTermFactory.EMPTY_LIST;
     }
     
     public int getStorageType() {

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedGenericAppl.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedGenericAppl.java	Tue Dec 28 12:30:22 2010	(r21589)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedGenericAppl.java	Tue Dec 28 14:15:54 2010	(r21590)
@@ -7,12 +7,12 @@
  */
 package org.spoofax.interpreter.adapter.ecj;
 
-import org.spoofax.interpreter.terms.BasicTermFactory;
 import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoConstructor;
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.ITermPrinter;
+import org.spoofax.terms.io.AbstractIOTermFactory;
 
 public class WrappedGenericAppl implements IStrategoAppl {
 
@@ -34,7 +34,7 @@
     }
     
     public IStrategoList getAnnotations() {
-    	return BasicTermFactory.EMPTY_LIST;
+    	return AbstractIOTermFactory.EMPTY_LIST;
     }
 
     public IStrategoConstructor getConstructor() {

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/library/ecj/ECJ_search_for_supertype_type_refs_in_hierarchy.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/library/ecj/ECJ_search_for_supertype_type_refs_in_hierarchy.java	Tue Dec 28 12:30:22 2010	(r21589)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/library/ecj/ECJ_search_for_supertype_type_refs_in_hierarchy.java	Tue Dec 28 14:15:54 2010	(r21590)
@@ -28,7 +28,7 @@
 import org.spoofax.interpreter.stratego.Strategy;
 import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoTerm;
-import org.spoofax.interpreter.terms.InlinePrinter;
+import org.spoofax.terms.io.InlinePrinter;
 
 public class ECJ_search_for_supertype_type_refs_in_hierarchy extends AbstractPrimitive {
 

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/core/Interpreter.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/core/Interpreter.java	Tue Dec 28 12:30:22 2010	(r21589)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/core/Interpreter.java	Tue Dec 28 14:15:54 2010	(r21590)
@@ -16,9 +16,9 @@
 import org.spoofax.interpreter.library.ssl.SSLLibrary;
 import org.spoofax.interpreter.stratego.SDefT;
 import org.spoofax.interpreter.stratego.StupidFormatter;
-import org.spoofax.interpreter.terms.BasicTermFactory;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.ITermFactory;
+import org.spoofax.terms.io.AbstractIOTermFactory;
 
 public class Interpreter {
 
@@ -26,7 +26,7 @@
     private final StrategoCoreLoader loader;
 
     public Interpreter() {
-        this(new BasicTermFactory());
+        this(new AbstractIOTermFactory());
     }
 
     public Interpreter(ITermFactory factory) {

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_printnl.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_printnl.java	Tue Dec 28 12:30:22 2010	(r21589)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_printnl.java	Tue Dec 28 14:15:54 2010	(r21590)
@@ -18,8 +18,8 @@
 import org.spoofax.interpreter.stratego.Strategy;
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoTerm;
-import org.spoofax.interpreter.terms.InlinePrinter;
 import org.spoofax.interpreter.terms.PrettyPrinter;
+import org.spoofax.terms.io.InlinePrinter;
 
 public class SSL_printnl extends AbstractPrimitive {
 

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_write_term_to_string.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_write_term_to_string.java	Tue Dec 28 12:30:22 2010	(r21589)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_write_term_to_string.java	Tue Dec 28 14:15:54 2010	(r21590)
@@ -12,7 +12,7 @@
 import org.spoofax.interpreter.library.AbstractPrimitive;
 import org.spoofax.interpreter.stratego.Strategy;
 import org.spoofax.interpreter.terms.IStrategoTerm;
-import org.spoofax.interpreter.terms.InlinePrinter;
+import org.spoofax.terms.io.InlinePrinter;
 
 public class SSL_write_term_to_string extends AbstractPrimitive {
     

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/StrategoHashMap.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/StrategoHashMap.java	Tue Dec 28 12:30:22 2010	(r21589)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/StrategoHashMap.java	Tue Dec 28 14:15:54 2010	(r21590)
@@ -2,10 +2,10 @@
 
 import java.util.LinkedHashMap;
 
-import org.spoofax.interpreter.terms.BasicTermFactory;
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.ITermPrinter;
+import org.spoofax.terms.io.AbstractIOTermFactory;
 
 public class StrategoHashMap extends LinkedHashMap<IStrategoTerm, IStrategoTerm> implements IStrategoTerm {
 
@@ -16,7 +16,7 @@
     }
 
     public IStrategoTerm[] getAllSubterms() {
-        return BasicTermFactory.EMPTY;
+        return AbstractIOTermFactory.EMPTY;
     }
 
     public IStrategoList getAnnotations() {

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/StrategoSet.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/StrategoSet.java	Tue Dec 28 12:30:22 2010	(r21589)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/StrategoSet.java	Tue Dec 28 14:15:54 2010	(r21590)
@@ -17,10 +17,10 @@
 import java.util.Set;
 import java.util.Map.Entry;
 
-import org.spoofax.interpreter.terms.BasicTermFactory;
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.ITermPrinter;
+import org.spoofax.terms.io.AbstractIOTermFactory;
 
 public class StrategoSet implements IStrategoTerm, Serializable {
         
@@ -98,7 +98,7 @@
     }
 
     public IStrategoTerm[] getAllSubterms() {
-        return BasicTermFactory.EMPTY;
+        return AbstractIOTermFactory.EMPTY;
     }
 
     public IStrategoList getAnnotations() {

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLRLibrary.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLRLibrary.java	Tue Dec 28 12:30:22 2010	(r21589)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLRLibrary.java	Tue Dec 28 14:15:54 2010	(r21590)
@@ -8,7 +8,7 @@
 import org.spoofax.interpreter.library.AbstractStrategoOperatorRegistry;
 import org.spoofax.interpreter.terms.ITermFactory;
 import org.spoofax.jsglr.client.ParseTable;
-import org.spoofax.jsglr.client.ParseTableManager;
+import org.spoofax.jsglr.io.ParseTableManager;
 
 import aterm.ATermFactory;
 

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/META-INF/MANIFEST.MF
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/META-INF/MANIFEST.MF	Tue Dec 28 12:30:22 2010	(r21589)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/META-INF/MANIFEST.MF	Tue Dec 28 14:15:54 2010	(r21590)
@@ -4,4 +4,9 @@
 Bundle-SymbolicName: org.spoofax.terms
 Bundle-Version: 1.0.0.qualifier
 Bundle-RequiredExecutionEnvironment: J2SE-1.5
-Export-Package: org.spoofax, org.spoofax.interpreter.terms, org.spoofax.terms, org.spoofax.terms.io
+Export-Package: org.spoofax,
+ org.spoofax.interpreter.terms,
+ org.spoofax.terms,
+ org.spoofax.terms.io,
+ org.spoofax.terms.io.baf,
+ org.strategoxt.lang.terms

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/legacy-src/org/spoofax/interpreter/terms/ITermFactory.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/legacy-src/org/spoofax/interpreter/terms/ITermFactory.java	Tue Dec 28 12:30:22 2010	(r21589)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/legacy-src/org/spoofax/interpreter/terms/ITermFactory.java	Tue Dec 28 14:15:54 2010	(r21590)
@@ -7,24 +7,12 @@
  */
 package org.spoofax.interpreter.terms;
 
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.io.Writer;
 
 
 
 public interface ITermFactory extends IStrategoTermBuilder {
-
-    public IStrategoTerm parseFromFile(String path) throws IOException;
-    
-    public IStrategoTerm parseFromStream(InputStream inputStream) throws IOException;
     
     public IStrategoTerm parseFromString(String text);
-    
-    public void unparseToFile(IStrategoTerm t, OutputStream ous) throws IOException;
-    
-    public void unparseToFile(IStrategoTerm t, Writer out) throws IOException;
 
     public IStrategoAppl replaceAppl(IStrategoConstructor constructor, IStrategoTerm[] kids, IStrategoAppl old);
     

Added: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/INonIOTermFactory.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/INonIOTermFactory.java	Tue Dec 28 14:15:54 2010	(r21590)
@@ -0,0 +1,6 @@
+package org.spoofax.terms;
+
+
+public interface INonIOTermFactory {
+
+}

Added: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/ITerm.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/ITerm.java	Tue Dec 28 14:15:54 2010	(r21590)
@@ -0,0 +1,7 @@
+package org.spoofax.terms;
+
+import org.spoofax.interpreter.terms.IStrategoTerm;
+
+public interface ITerm extends IStrategoTerm {
+
+}

Copied and modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/AbstractIOTermFactory.java (from r21589, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/legacy-src/org/spoofax/interpreter/terms/BasicTermFactory.java)
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/legacy-src/org/spoofax/interpreter/terms/BasicTermFactory.java	Tue Dec 28 12:30:22 2010	(r21589, copy source)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/AbstractIOTermFactory.java	Tue Dec 28 14:15:54 2010	(r21590)
@@ -5,7 +5,7 @@
  * 
  * Licensed under the GNU General Public License, v2
  */
-package org.spoofax.interpreter.terms;
+package org.spoofax.terms.io;
 
 import java.io.BufferedInputStream;
 import java.io.BufferedWriter;
@@ -27,12 +27,24 @@
 import java.util.WeakHashMap;
 
 import org.spoofax.NotImplementedException;
+import org.spoofax.interpreter.terms.IStrategoAppl;
+import org.spoofax.interpreter.terms.IStrategoConstructor;
+import org.spoofax.interpreter.terms.IStrategoInt;
+import org.spoofax.interpreter.terms.IStrategoList;
+import org.spoofax.interpreter.terms.IStrategoPlaceholder;
+import org.spoofax.interpreter.terms.IStrategoReal;
+import org.spoofax.interpreter.terms.IStrategoString;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.IStrategoTuple;
+import org.spoofax.interpreter.terms.ITermFactory;
+import org.spoofax.interpreter.terms.ITermPrinter;
+import org.spoofax.interpreter.terms.ParseError;
 
-public class BasicTermFactory implements ITermFactory {
+public class AbstractIOTermFactory implements ITermFactory {
 
     public static final IStrategoTerm[] EMPTY = {};
 
-    public static final BasicStrategoList EMPTY_LIST = new BasicStrategoList(null, null, null);
+    public static final IStrategoList EMPTY_LIST = new StrategoList(null, null, null, IStrategoTerm.MAXIMALLY_SHARED);
     
     private static final int MAX_POOLED_STRING_LENGTH = 100;
 

Added: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/ITermFactory.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/ITermFactory.java	Tue Dec 28 14:15:54 2010	(r21590)
@@ -0,0 +1,20 @@
+package org.spoofax.terms.io;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.Writer;
+
+import org.spoofax.interpreter.terms.IStrategoTerm;
+
+public interface ITermFactory extends org.spoofax.terms.INonIOTermFactory {
+
+    public IStrategoTerm parseFromFile(String path) throws IOException;
+    
+    public IStrategoTerm parseFromStream(InputStream inputStream) throws IOException;
+    
+    public void unparseToFile(IStrategoTerm t, OutputStream ous) throws IOException;
+    
+    public void unparseToFile(IStrategoTerm t, Writer out) throws IOException;
+
+}

Copied and modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/InlinePrinter.java (from r21589, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/legacy-src/org/spoofax/interpreter/terms/InlinePrinter.java)
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/legacy-src/org/spoofax/interpreter/terms/InlinePrinter.java	Tue Dec 28 12:30:22 2010	(r21589, copy source)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/InlinePrinter.java	Tue Dec 28 14:15:54 2010	(r21590)
@@ -1,4 +1,6 @@
-package org.spoofax.interpreter.terms;
+package org.spoofax.terms.io;
+
+import org.spoofax.interpreter.terms.ITermPrinter;
 
 public class InlinePrinter implements ITermPrinter {
 	private final StringBuilder out;

Copied and modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/InlineWriter.java (from r21589, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/legacy-src/org/spoofax/interpreter/terms/InlineWriter.java)
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/legacy-src/org/spoofax/interpreter/terms/InlineWriter.java	Tue Dec 28 12:30:22 2010	(r21589, copy source)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/InlineWriter.java	Tue Dec 28 14:15:54 2010	(r21590)
@@ -1,8 +1,10 @@
-package org.spoofax.interpreter.terms;
+package org.spoofax.terms.io;
 
 import java.io.IOException;
 import java.io.Writer;
 
+import org.spoofax.interpreter.terms.ITermPrinter;
+
 /**
  * Term printer that writes directly to a {@link Writer}, without building the
  * entire string representation in-memory. Does not support {@link #reset()} or

Copied and modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/baf/BAFReader.java (from r21586, strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/terms/BAFReader.java)
==============================================================================
--- strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/terms/BAFReader.java	Mon Dec 27 12:43:27 2010	(r21586, copy source)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/baf/BAFReader.java	Tue Dec 28 14:15:54 2010	(r21590)
@@ -17,7 +17,7 @@
  * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
  * Boston, MA  02111-1307, USA.
  */
-package org.strategoxt.lang.terms;
+package org.spoofax.terms.io.baf;
 
 import java.io.BufferedInputStream;
 import java.io.ByteArrayInputStream;
@@ -35,9 +35,6 @@
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.ITermFactory;
 
-import aterm.ParseError;
-import aterm.pure.BitStream;
-import aterm.pure.MemoryMappedBitStream;
 
 /**
  * A BAFReader that uses IStrategoTerms.
@@ -98,15 +95,15 @@
         }
     }
 
-    public IStrategoTerm readFromBinaryFile(boolean headerAlreadyRead) throws ParseError, IOException {
+    public IStrategoTerm readFromBinaryFile(boolean headerAlreadyRead) throws ParseException, IOException {
 
         if(!headerAlreadyRead && !isBinaryATerm(reader))
-            throw new ParseError("Input is not a BAF file");
+            throw new ParseException("Input is not a BAF file");
 
         int val = reader.readInt();
 
         if (val != BAF_VERSION)
-            throw new ParseError("Wrong BAF version (wanted " + BAF_VERSION + ", got " + val + "), giving up");
+            throw new ParseException("Wrong BAF version (wanted " + BAF_VERSION + ", got " + val + "), giving up");
 
         nrUniqueSymbols = reader.readInt();
         int nrUniqueTerms = reader.readInt();
@@ -179,7 +176,7 @@
         }
     }
     
-    private IStrategoTerm readTerm(SymEntry e) throws ParseError, IOException {
+    private IStrategoTerm readTerm(SymEntry e) throws ParseException, IOException {
         // TODO: Optimize readTerm?
         //       e.g., throw in some rounds of native-stack based reading
         ArrayList<ReadTermFrame> stack = readerStacks.get();
@@ -231,7 +228,7 @@
                 }
     
                 if (argSym.terms[val] == null) 
-                    throw new ParseError("Malformed ATerm: Cannot be null");
+                    throw new ParseException("Malformed ATerm: Cannot be null");
     
                 outputArgs[i] = argSym.terms[val];
             }

Copied and modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/baf/BitStream.java (from r21589, spoofax/branches/spoofax-new-terms/spoofax/_attic/org.spoofax.aterm/src/aterm/pure/BitStream.java)
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/_attic/org.spoofax.aterm/src/aterm/pure/BitStream.java	Tue Dec 28 12:30:22 2010	(r21589, copy source)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/baf/BitStream.java	Tue Dec 28 14:15:54 2010	(r21590)
@@ -1,7 +1,7 @@
 /**
  * 
  */
-package aterm.pure;
+package org.spoofax.terms.io.baf;
 
 import java.io.EOFException;
 import java.io.IOException;

Copied and modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/baf/MemoryMappedBitStream.java (from r21589, spoofax/branches/spoofax-new-terms/spoofax/_attic/org.spoofax.aterm/src/aterm/pure/MemoryMappedBitStream.java)
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/_attic/org.spoofax.aterm/src/aterm/pure/MemoryMappedBitStream.java	Tue Dec 28 12:30:22 2010	(r21589, copy source)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/baf/MemoryMappedBitStream.java	Tue Dec 28 14:15:54 2010	(r21590)
@@ -1,4 +1,4 @@
-package aterm.pure;
+package org.spoofax.terms.io.baf;
 
 import java.io.FileInputStream;
 import java.io.IOException;

Added: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/baf/ParseException.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/baf/ParseException.java	Tue Dec 28 14:15:54 2010	(r21590)
@@ -0,0 +1,13 @@
+package org.spoofax.terms.io.baf;
+
+import java.io.IOException;
+
+public class ParseException extends IOException {
+
+	private static final long serialVersionUID = -6872866324323614820L;
+
+	public ParseException(String msg) {
+		super(msg);
+	}
+
+}

Copied and modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/LazyTerm.java (from r21586, strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/LazyTerm.java)
==============================================================================
--- strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/LazyTerm.java	Mon Dec 27 12:43:27 2010	(r21586, copy source)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/LazyTerm.java	Tue Dec 28 14:15:54 2010	(r21590)
@@ -1,4 +1,4 @@
-package org.strategoxt.lang;
+package org.strategoxt.lang.terms;
 
 import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoConstructor;

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoWrapped.java
==============================================================================
--- strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/terms/StrategoWrapped.java	Mon Dec 27 12:43:27 2010	(r21586)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoWrapped.java	Tue Dec 28 14:15:54 2010	(r21590)
@@ -9,7 +9,6 @@
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.IStrategoTuple;
 import org.spoofax.interpreter.terms.ITermPrinter;
-import org.strategoxt.lang.TermWrapperException;
 
 /**
  * A wrapped Stratego term of any type.

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/TermFactory.java
==============================================================================
--- strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/terms/TermFactory.java	Mon Dec 27 12:43:27 2010	(r21586)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/TermFactory.java	Tue Dec 28 14:15:54 2010	(r21590)
@@ -13,7 +13,6 @@
 import java.util.HashMap;
 import java.util.WeakHashMap;
 
-import org.spoofax.interpreter.terms.BasicTermFactory;
 import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoConstructor;
 import org.spoofax.interpreter.terms.IStrategoInt;
@@ -23,14 +22,15 @@
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.IStrategoTuple;
 import org.spoofax.interpreter.terms.ITermFactory;
-import org.strategoxt.lang.StrategoException;
+import org.spoofax.terms.io.AbstractIOTermFactory;
+import org.spoofax.terms.io.baf.BAFReader;
 
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
  */
-public class TermFactory extends BasicTermFactory implements ITermFactory {
+public class TermFactory extends AbstractIOTermFactory implements ITermFactory {
 
-    public static final IStrategoTerm[] EMPTY = BasicTermFactory.EMPTY;
+    public static final IStrategoTerm[] EMPTY = AbstractIOTermFactory.EMPTY;
     
     private static final int MY_STORAGE_TYPE = SHARABLE;
     
@@ -65,7 +65,7 @@
             	if (asyncStringPool.containsKey(name)) {
             		return true;
             	} else if (name.length() > MAX_POOLED_STRING_LENGTH) {
-            		throw new StrategoException("String too long to be pooled (newname not allowed): " + name);
+            		throw new UnsupportedOperationException("String too long to be pooled (newname not allowed): " + name);
             	} else {
                 	// HACK: pre-allocating strings to avoid race condition 
             		asyncStringPool.put(name, new WeakReference<StrategoString>(new StrategoString(name, null, STRING_STORAGE_TYPE)));

Copied and modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/TermWrapperException.java (from r21586, strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/TermWrapperException.java)
==============================================================================
--- strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/TermWrapperException.java	Mon Dec 27 12:43:27 2010	(r21586, copy source)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/TermWrapperException.java	Tue Dec 28 14:15:54 2010	(r21590)
@@ -1,11 +1,9 @@
-package org.strategoxt.lang;
-
-import org.spoofax.interpreter.adapter.aterm.WrapperException;
+package org.strategoxt.lang.terms;
 
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
  */
-public class TermWrapperException extends WrapperException {
+public class TermWrapperException extends UnsupportedOperationException {
 	private static final long serialVersionUID = 5194285844333201169L;
 
 	public TermWrapperException(String message) {

Modified: strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/META-INF/MANIFEST.MF
==============================================================================
--- strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/META-INF/MANIFEST.MF	Tue Dec 28 12:30:22 2010	(r21589)
+++ strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/META-INF/MANIFEST.MF	Tue Dec 28 14:15:54 2010	(r21590)
@@ -71,6 +71,7 @@
  org.spoofax.interpreter.core,
  org.spoofax.interpreter.adapter.aterm,
  org.spoofax.jsglr;bundle-version="0.3.0",
+ org.spoofax.terms,
  org.spoofax.interpreter.library.jsglr,
  org.eclipse.ant.core;bundle-version="3.0.0",
  org.eclipse.core.runtime;bundle-version="3.0.0"

Modified: strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/ImportTerm.java
==============================================================================
--- strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/ImportTerm.java	Tue Dec 28 12:30:22 2010	(r21589)
+++ strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/ImportTerm.java	Tue Dec 28 14:15:54 2010	(r21590)
@@ -10,6 +10,7 @@
 import org.spoofax.interpreter.adapter.aterm.ATermConverter;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.ITermFactory;
+import org.strategoxt.lang.terms.LazyTerm;
 
 import aterm.ATerm;
 import aterm.ATermFactory;
@@ -62,7 +63,7 @@
 		
 		InputStream stream = openStream();
 		try {
-			IStrategoTerm result = factory.parseFromStream(stream);
+			IStrategoTerm result = ((org.spoofax.terms.io.ITermFactory) factory).parseFromStream(stream);
 			return result;
 		} catch (java.io.IOException e) {
 			throw new StrategoException(container.getSimpleName()

From L.C.L.Kats at tudelft.nl  Tue Dec 28 16:31:36 2010
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Tue, 28 Dec 2010 15:31:36 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21591 -
	spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services
	spoofax-imp/branches/spoofax-imp-new-terms/org.strate...
Message-ID: <201012281531.oBSFVaD4018887@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: Tue Dec 28 15:31:36 2010
New Revision: 21591
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21591&sc=1

Log:
refactoring

Added:
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/
      - copied from r21589, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/legacy-src/org/spoofax/interpreter/terms/
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/io/
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/io/IFileTermFactory.java
      - copied, changed from r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/ITermFactory.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/AbstractTermFactory.java
      - copied, changed from r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/AbstractIOTermFactory.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/LazyTerm.java
      - copied, changed from r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/LazyTerm.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoAnnotation.java
      - copied, changed from r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoAnnotation.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoAppl.java
      - copied, changed from r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoAppl.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoConstructor.java
      - copied, changed from r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoConstructor.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoInt.java
      - copied, changed from r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoInt.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoList.java
      - copied, changed from r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoList.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoPlaceholder.java
      - copied, changed from r21585, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/BasicStrategoPlaceholder.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoReal.java
      - copied, changed from r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoReal.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoString.java
      - copied, changed from r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoString.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoTerm.java
      - copied, changed from r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoTerm.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoTuple.java
      - copied, changed from r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoTuple.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoWrapped.java
      - copied, changed from r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoWrapped.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/TermFactory.java
      - copied, changed from r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/TermFactory.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/TermWrapperException.java
      - copied, changed from r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/TermWrapperException.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/StreamTermReader.java
      - copied, changed from r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/AbstractIOTermFactory.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/baf/BAFStreamTermReader.java
      - copied, changed from r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/TermFactory.java
Replaced:
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/ITermFactory.java
      - copied unchanged from r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/legacy-src/org/spoofax/interpreter/terms/ITermFactory.java
Deleted:
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/legacy-src/org/
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/aterm/
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/BasicTermFactory.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/InlinePrinter.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/InlineWriter.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/ITerm.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/ITermFactory.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/baf/ParseException.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/LazyTerm.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoAnnotation.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoAppl.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoConstructor.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoInt.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoList.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoReal.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoString.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoTerm.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoTuple.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoWrapped.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/TermFactory.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/TermWrapperException.java
Modified:
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/ContentProposer.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/IMPParseStringPTPrimitive.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginTextFragmentPrimitive.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/SetTotalWorkUnitsPrimitive.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/SourceMappings.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/TextChangePrimitive.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/WrappedAstNode.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/WrappedAstNodeFactory.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/.classpath
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/META-INF/MANIFEST.MF
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/AbstractIOTermFactory.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/baf/BAFReader.java
   strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/HybridInterpreter.java
   strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/Context.java
   strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/ImportTerm.java
   strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/SRTS_EXT_newint_0_0.java
   strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/Term.java

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/ContentProposer.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/ContentProposer.java	Tue Dec 28 14:15:54 2010	(r21590)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/ContentProposer.java	Tue Dec 28 15:31:36 2010	(r21591)
@@ -29,6 +29,7 @@
 import org.spoofax.interpreter.terms.IStrategoString;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.jsglr.SGLRException;
+import org.spoofax.terms.TermFactory;
 import org.strategoxt.imp.runtime.Debug;
 import org.strategoxt.imp.runtime.Environment;
 import org.strategoxt.imp.runtime.dynamicloading.DynamicParseController;
@@ -43,7 +44,6 @@
 import org.strategoxt.imp.runtime.stratego.CandidateSortsPrimitive;
 import org.strategoxt.imp.runtime.stratego.StrategoConsole;
 import org.strategoxt.imp.runtime.stratego.adapter.WrappedAstNodeFactory;
-import org.strategoxt.lang.terms.TermFactory;
 
 /**
  * Content completion.

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/IMPParseStringPTPrimitive.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/IMPParseStringPTPrimitive.java	Tue Dec 28 14:15:54 2010	(r21590)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/IMPParseStringPTPrimitive.java	Tue Dec 28 15:31:36 2010	(r21591)
@@ -13,11 +13,11 @@
 import org.spoofax.jsglr.NoRecoveryRulesException;
 import org.spoofax.jsglr.ParseTable;
 import org.spoofax.jsglr.SGLRException;
+import org.spoofax.terms.LazyTerm;
 import org.strategoxt.imp.runtime.Environment;
 import org.strategoxt.imp.runtime.parser.JSGLRI;
 import org.strategoxt.imp.runtime.stratego.SourceMappings.MappableTerm;
 import org.strategoxt.lang.compat.sglr.JSGLR_parse_string_pt_compat;
-import org.strategoxt.lang.terms.LazyTerm;
 
 import aterm.ATerm;
 import aterm.ATermFactory;

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginTextFragmentPrimitive.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginTextFragmentPrimitive.java	Tue Dec 28 14:15:54 2010	(r21590)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginTextFragmentPrimitive.java	Tue Dec 28 15:31:36 2010	(r21591)
@@ -8,9 +8,9 @@
 import org.spoofax.interpreter.stratego.Strategy;
 import org.spoofax.interpreter.terms.IStrategoString;
 import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.terms.StrategoInt;
+import org.spoofax.terms.StrategoTuple;
 import org.strategoxt.imp.runtime.stratego.adapter.IWrappedAstNode;
-import org.strategoxt.lang.terms.StrategoInt;
-import org.strategoxt.lang.terms.StrategoTuple;
 
 /**
  * Returns the textfragment that corresponds to the given char position (offset, offset-end)

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/SetTotalWorkUnitsPrimitive.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/SetTotalWorkUnitsPrimitive.java	Tue Dec 28 14:15:54 2010	(r21590)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/SetTotalWorkUnitsPrimitive.java	Tue Dec 28 15:31:36 2010	(r21591)
@@ -7,9 +7,9 @@
 import org.spoofax.interpreter.library.ssl.SSLLibrary;
 import org.spoofax.interpreter.stratego.Strategy;
 import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.terms.StrategoInt;
 import org.strategoxt.imp.runtime.services.StrategoAnalysisJob;
 import org.strategoxt.imp.runtime.services.StrategoProgressMonitor;
-import org.strategoxt.lang.terms.StrategoInt;
 
 public class SetTotalWorkUnitsPrimitive extends AbstractPrimitive {
 

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/SourceMappings.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/SourceMappings.java	Tue Dec 28 14:15:54 2010	(r21590)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/SourceMappings.java	Tue Dec 28 15:31:36 2010	(r21591)
@@ -10,8 +10,8 @@
 import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoString;
 import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.terms.LazyTerm;
 import org.strategoxt.imp.runtime.parser.tokens.SGLRTokenizer;
-import org.strategoxt.lang.terms.LazyTerm;
 
 import aterm.ATerm;
 

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/TextChangePrimitive.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/TextChangePrimitive.java	Tue Dec 28 14:15:54 2010	(r21590)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/TextChangePrimitive.java	Tue Dec 28 15:31:36 2010	(r21591)
@@ -14,11 +14,11 @@
 import org.spoofax.interpreter.stratego.Strategy;
 import org.spoofax.interpreter.terms.IStrategoString;
 import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.terms.StrategoInt;
+import org.spoofax.terms.StrategoTuple;
 import org.strategoxt.imp.runtime.EditorState;
 import org.strategoxt.imp.runtime.Environment;
 import org.strategoxt.imp.runtime.stratego.adapter.IWrappedAstNode;
-import org.strategoxt.lang.terms.StrategoInt;
-import org.strategoxt.lang.terms.StrategoTuple;
 
 /**
  * Applies a text-change in the current document

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/WrappedAstNode.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/WrappedAstNode.java	Tue Dec 28 14:15:54 2010	(r21590)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/WrappedAstNode.java	Tue Dec 28 15:31:36 2010	(r21591)
@@ -2,9 +2,9 @@
 
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.terms.StrategoTerm;
+import org.spoofax.terms.TermFactory;
 import org.spoofax.terms.io.InlinePrinter;
-import org.strategoxt.lang.terms.StrategoTerm;
-import org.strategoxt.lang.terms.TermFactory;
 
 public abstract class WrappedAstNode extends StrategoTerm implements IWrappedAstNode, IStrategoTerm, Cloneable {
 	

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/WrappedAstNodeFactory.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/WrappedAstNodeFactory.java	Tue Dec 28 14:15:54 2010	(r21590)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/WrappedAstNodeFactory.java	Tue Dec 28 15:31:36 2010	(r21591)
@@ -13,7 +13,7 @@
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.IStrategoTuple;
 import org.spoofax.interpreter.terms.ITermFactory;
-import org.strategoxt.lang.terms.TermFactory;
+import org.spoofax.terms.TermFactory;
 
 /**
  * A factory creating ATerms from AST nodes.

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/.classpath
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/.classpath	Tue Dec 28 14:15:54 2010	(r21590)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/.classpath	Tue Dec 28 15:31:36 2010	(r21591)
@@ -3,6 +3,5 @@
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/J2SE-1.5"/>
 	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
 	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="legacy-src"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/META-INF/MANIFEST.MF
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/META-INF/MANIFEST.MF	Tue Dec 28 14:15:54 2010	(r21590)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/META-INF/MANIFEST.MF	Tue Dec 28 15:31:36 2010	(r21591)
@@ -8,5 +8,5 @@
  org.spoofax.interpreter.terms,
  org.spoofax.terms,
  org.spoofax.terms.io,
- org.spoofax.terms.io.baf,
- org.strategoxt.lang.terms
+ org.spoofax.terms.io.baf
+ 
\ No newline at end of file

Copied: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/ITermFactory.java (from r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/legacy-src/org/spoofax/interpreter/terms/ITermFactory.java)
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/ITermFactory.java	Tue Dec 28 15:31:36 2010	(r21591, copy of r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/legacy-src/org/spoofax/interpreter/terms/ITermFactory.java)
@@ -0,0 +1,23 @@
+/*
+ * Created on 30. aug.. 2006
+ *
+ * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
+ * 
+ * Licensed under the GNU General Public License, v2
+ */
+package org.spoofax.interpreter.terms;
+
+
+
+
+public interface ITermFactory extends IStrategoTermBuilder {
+    
+    public IStrategoTerm parseFromString(String text);
+
+    public IStrategoAppl replaceAppl(IStrategoConstructor constructor, IStrategoTerm[] kids, IStrategoAppl old);
+    
+    public IStrategoList replaceList(IStrategoTerm[] kids, IStrategoList old);
+    
+    public IStrategoTuple replaceTuple(IStrategoTerm[] kids, IStrategoTuple old);
+
+}

Copied and modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/io/IFileTermFactory.java (from r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/ITermFactory.java)
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/ITermFactory.java	Tue Dec 28 14:15:54 2010	(r21590, copy source)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/io/IFileTermFactory.java	Tue Dec 28 15:31:36 2010	(r21591)
@@ -1,4 +1,4 @@
-package org.spoofax.terms.io;
+package org.spoofax.interpreter.terms.io;
 
 import java.io.IOException;
 import java.io.InputStream;
@@ -7,7 +7,7 @@
 
 import org.spoofax.interpreter.terms.IStrategoTerm;
 
-public interface ITermFactory extends org.spoofax.terms.INonIOTermFactory {
+public interface IFileTermFactory extends org.spoofax.interpreter.terms.ITermFactory {
 
     public IStrategoTerm parseFromFile(String path) throws IOException;
     

Copied and modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/AbstractTermFactory.java (from r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/AbstractIOTermFactory.java)
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/AbstractIOTermFactory.java	Tue Dec 28 14:15:54 2010	(r21590, copy source)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/AbstractTermFactory.java	Tue Dec 28 15:31:36 2010	(r21591)
@@ -1,11 +1,4 @@
-/*
- * Created on 27. jan.. 2007
- *
- * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
- * 
- * Licensed under the GNU General Public License, v2
- */
-package org.spoofax.terms.io;
+package org.spoofax.terms;
 
 import java.io.BufferedInputStream;
 import java.io.BufferedWriter;
@@ -20,6 +13,7 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
@@ -39,283 +33,50 @@
 import org.spoofax.interpreter.terms.ITermFactory;
 import org.spoofax.interpreter.terms.ITermPrinter;
 import org.spoofax.interpreter.terms.ParseError;
+import org.spoofax.terms.io.AbstractIOTermFactory;
 
-public class AbstractIOTermFactory implements ITermFactory {
+public abstract class AbstractTermFactory implements ITermFactory {
 
-    public static final IStrategoTerm[] EMPTY = {};
+	public static final IStrategoList EMPTY_LIST = new StrategoList(null, null, null, IStrategoTerm.MAXIMALLY_SHARED);
 
-    public static final IStrategoList EMPTY_LIST = new StrategoList(null, null, null, IStrategoTerm.MAXIMALLY_SHARED);
-    
-    private static final int MAX_POOLED_STRING_LENGTH = 100;
+    public static final IStrategoTerm[] EMPTY = new IStrategoTerm[0];
 
-    private static final Map<BasicStrategoConstructor, BasicStrategoConstructor> ctorCache =
-        Collections.synchronizedMap(new WeakHashMap<BasicStrategoConstructor,BasicStrategoConstructor>());
-    
-    private static final Set<String> stringPool =
-        Collections.synchronizedSet(new HashSet<String>());
-    
-    private IStrategoConstructor placeholderConstructor;
+    private static final HashMap<StrategoConstructor, StrategoConstructor> asyncCtorCache =
+        new HashMap<StrategoConstructor, StrategoConstructor>();
     
-    public IStrategoTerm parseFromFile(String path) throws IOException {
-        InputStream stream = new FileInputStream(path);
-        try {
-            return parseFromStream(stream);
-        } finally {
-            stream.close();
-        }
-    }
 
-    public IStrategoTerm parseFromStream(InputStream inputStream) throws IOException {
-        /*
-        PushbackInputStream pushbackStream;
-        
-        if (inputStream instanceof FileInputStream) {
-            FileChannel channel = ((FileInputStream)inputStream).getChannel();
-            pushbackStream = new ChannelPushbackInputStream(channel);
-        } else {
-            if (!(inputStream instanceof BufferedInputStream) && !(inputStream instanceof ChannelPushbackInputStream))
-                inputStream = new BufferedInputStream(inputStream);
-            pushbackStream = new PushbackInputStream(inputStream);
-        }
-        
-        return parseFromStream(pushbackStream);
-        */
-        if (!(inputStream instanceof BufferedInputStream))
-            inputStream = new BufferedInputStream(inputStream);
-        PushbackInputStream bis = new PushbackInputStream(inputStream);
-        
-        return parseFromStream(bis);
-    }
-
-    protected IStrategoTerm parseFromStream(PushbackInputStream bis) throws IOException {
-        parseSkip(bis);
-        final int ch = bis.read();
-        switch(ch) {
-        case '[': return parseAnno(bis, parseList(bis));
-        case '(': return parseAnno(bis, parseTuple(bis));
-        case '"': return parseAnno(bis, parseString(bis));
-        case '<': return parsePlaceholder(bis);
-        default:
-            bis.unread(ch);
-            if (Character.isLetter(ch)) {
-                return parseAnno(bis, parseAppl(bis));
-            }
-            else if (Character.isDigit(ch) || ch == '-')
-                return parseAnno(bis, parseNumber(bis));
-        }
-        throw new ParseError("Invalid term: '" + (char)ch + "'");
-    }
-    
-    private IStrategoTerm parseAnno(PushbackInputStream bis, IStrategoTerm term) throws IOException {
-        parseSkip(bis);
-        final int ch = bis.read();
-        if (ch == '{') {
-            List<IStrategoTerm> annos = parseTermSequence(bis, '}');
-            return annotateTerm(term, makeList(annos));
-        } else {
-            bis.unread(ch);
-            return term;
-        }
+    public boolean hasConstructor(String ctorName, int arity) {
+    	throw new UnsupportedOperationException();
     }
 
-    private IStrategoTerm parseString(PushbackInputStream bis) throws IOException {
-        int ch = bis.read();
-        if(ch == '"')
-            return makeString("");
-        StringBuilder sb = new StringBuilder();
-        boolean escaped = false;
-        do {
-            escaped = false;
-            if(ch == '\\') {
-                escaped = true;
-                ch = bis.read();
-            }
-            if(escaped) {
-                switch(ch) {
-                case 'n':
-                    sb.append('\n');
-                    break;
-                case 't':
-                    sb.append('\t');
-                    break;
-                case 'b':
-                    sb.append('\b');
-                    break;
-                case 'f':
-                    sb.append('\f');
-                    break;
-                case 'r':
-                    sb.append('\r');
-                    break;
-                case '\\':
-                    sb.append('\\');
-                    break;
-                case '\'':
-                    sb.append('\'');
-                    break;
-                case '\"':
-                    sb.append('\"');
-                    break;
-                case '0':
-                case '1':
-                case '2':
-                case '3':
-                case '4':
-                case '5':
-                case '6':
-                case '7':
-                case '8':
-                case '9':
-                    throw new NotImplementedException();
-                default:
-                    sb.append("\\" + (char)ch); 
-                }
-                ch = bis.read();
-            } else if(ch != '\"') {
-                if (ch == -1)
-                    throw new ParseError("Unterminated string: " + sb);
-                sb.append((char)ch);
-                ch = bis.read();
-            }
-        } while(escaped || ch != '\"');
-        return makeString(sb.toString());
-    }
-
-    private IStrategoTerm parseAppl(PushbackInputStream bis) throws IOException {
-        //System.err.println("appl");
-        // TODO: share stringbuilder instances?
-        StringBuilder sb = new StringBuilder();
-        int ch;
-        
-        ch = bis.read();
-        do {
-            sb.append((char)ch);
-            ch = bis.read();
-        } // TODO: use a switch for this
-          while(Character.isLetterOrDigit(ch) || ch == '_' || ch == '-'
-            || ch == '+' || ch == '*' || ch == '$');
-        
-        //System.err.println(" - " + sb.toString());
-        
-        bis.unread(ch);
-        parseSkip(bis);
-        ch = bis.read();
-
-        if(ch == '(') {
-            List<IStrategoTerm> l = parseTermSequence(bis, ')');
-            IStrategoConstructor c = makeConstructor(sb.toString(), l.size());
-            return makeAppl(c, l.toArray(EMPTY));
-        } else {
-            bis.unread(ch);
-            IStrategoConstructor c = makeConstructor(sb.toString(), 0);
-            return makeAppl(c, new IStrategoTerm[0]);
+    public StrategoConstructor makeConstructor(String name, int arity) {
+        StrategoConstructor result = new StrategoConstructor(name, arity);
+        synchronized (TermFactory.class) {
+	        StrategoConstructor cached = asyncCtorCache.get(result);
+	        if (cached == null) {
+	            asyncCtorCache.put(result, result);
+	        } else {
+	            result = cached;
+	        }
         }
+        return result;
     }
-    
-    private IStrategoTerm parsePlaceholder(PushbackInputStream bis) throws IOException {
-        IStrategoTerm template = parseFromStream(bis);
-        parseSkip(bis);
-        if (bis.read() != '>')
-            throw new ParseError("Expected: '>'");
-        return makePlaceholder(template);
-    }
-
-    private IStrategoTerm parseTuple(PushbackInputStream bis) throws IOException {
-        //System.err.println("tuple");
-        return makeTuple(parseTermSequence(bis, ')').toArray(EMPTY));
-    }
-
-    private List<IStrategoTerm> parseTermSequence(PushbackInputStream bis, char endChar) throws IOException {
-        //System.err.println("sequence");
-        List<IStrategoTerm> els = Collections.emptyList();
-        parseSkip(bis);
-        int ch = bis.read();
-        if(ch == endChar)
-            return els;
-        els = new ArrayList<IStrategoTerm>();
-        bis.unread(ch);
-        do {
-            els.add(parseFromStream(bis));
-            parseSkip(bis);
-            ch = bis.read();
-        } while(ch == ',');
-        
-        if (ch != endChar) {
-            bis.unread(ch);
-            parseSkip(bis);
-            ch = bis.read();
-        }
 
-        if(ch != endChar)
-            throw new ParseError("Sequence must end with '" + endChar + "', saw '" + (char)ch + "'");
-        
-        return els;
-    }
-
-    private IStrategoTerm parseList(PushbackInputStream bis) throws IOException {
-        //System.err.println("list");
-        return makeList(parseTermSequence(bis, ']'));
-    }
-
-    private IStrategoTerm parseNumber(PushbackInputStream bis) throws IOException {
-        //System.err.println("number");
-        String whole = parseDigitSequence(bis);
-        
-        int ch = bis.read();
-        if(ch == '.') {
-            String frac = parseDigitSequence(bis);
-            ch = bis.read();
-            if(ch == 'e' || ch == 'E') {
-                String exp = parseDigitSequence(bis);
-                double d = Double.parseDouble(whole + "." + frac + "e" + exp);
-                return makeReal(d);
-            }
-            bis.unread(ch);
-            double d = Double.parseDouble(whole + "." + frac);
-            return makeReal(d);
-        }
-        bis.unread(ch);
-        return makeInt(Integer.parseInt(whole));
-    }
+    public abstract IStrategoAppl makeAppl(IStrategoConstructor constructor,
+			IStrategoTerm[] kids, IStrategoList annotations);
 
-    private String parseDigitSequence(PushbackInputStream bis) throws IOException {
-        StringBuilder sb = new StringBuilder();
-        int ch = bis.read();
-        do {
-            sb.append((char)ch);
-            ch = bis.read();
-        } while(Character.isDigit(ch));
-        bis.unread(ch);
-        return sb.toString(); 
-    }
+    public abstract IStrategoTuple makeTuple(
+			IStrategoTerm[] kids, IStrategoList annotations);
 
-    public IStrategoTerm parseFromString(String text) {
-        try {
-            return parseFromStream(new ByteArrayInputStream(text.getBytes()));
-        } catch(IOException e) {
-            return null;
-        }
-    }
-    
-    private void parseSkip(PushbackInputStream input) throws IOException {
-        for (;;) {
-            int b = input.read();
-            switch (b) {
-                case ' ': case '\t': case '\n':
-                    continue;
-                default:
-                    input.unread(b);
-                    return;
-            }
-        }
-    }
+    public abstract IStrategoList makeList(
+			IStrategoTerm[] kids, IStrategoList annotations);
 
     public IStrategoAppl replaceAppl(IStrategoConstructor constructor, IStrategoTerm[] kids,
             IStrategoAppl old) {
         return makeAppl(constructor, kids, old.getAnnotations());
     }
 
-    public IStrategoTuple replaceTuple(IStrategoTerm[] kids, IStrategoTuple old) {
+	public IStrategoTuple replaceTuple(IStrategoTerm[] kids, IStrategoTuple old) {
         return makeTuple(kids, old.getAnnotations());
     }
     
@@ -323,24 +84,6 @@
         return makeList(kids, old.getAnnotations());
     }
 
-    public void unparseToFile(IStrategoTerm t, OutputStream ous) throws IOException {
-        Writer out = new BufferedWriter(new OutputStreamWriter(ous));
-        unparseToFile(t, out);
-    }
-
-    public void unparseToFile(IStrategoTerm t, Writer out) throws IOException {
-        ITermPrinter tp = new InlineWriter(out);
-        t.prettyPrint(tp);
-    }
-
-    public boolean hasConstructor(String name, int arity) {
-    	if (name.length() > MAX_POOLED_STRING_LENGTH)
-            throw new UnsupportedOperationException("String too long to be pooled: " + name);
-    	return arity == 0
-            ? stringPool.contains(name)
-            : ctorCache.get(new BasicStrategoConstructor(name, arity)) != null;
-    }
-
     public final IStrategoAppl makeAppl(IStrategoConstructor ctr, IStrategoList kids,
             IStrategoList annotations) {
         return makeAppl(ctr, kids.getAllSubterms(), annotations);
@@ -350,55 +93,14 @@
         return makeAppl(ctr, kids, null);
     }
 
-    public IStrategoAppl makeAppl(IStrategoConstructor ctr,
-            IStrategoTerm[] terms, IStrategoList annotations) {
-        return new BasicStrategoAppl(ctr, terms, annotations);
-    }
-
     public final IStrategoAppl makeAppl(IStrategoConstructor ctr, IStrategoTerm... terms) {
         return makeAppl(ctr, terms, null);
     }
 
-    public IStrategoConstructor makeConstructor(String name, int arity) {
-        BasicStrategoConstructor result = new BasicStrategoConstructor(name, arity);
-        BasicStrategoConstructor cached = ctorCache.get(result);
-        if (cached == null) {
-            ctorCache.put(result, result);
-            if (arity == 0) stringPool.add(name);
-        } else {
-            result = cached;
-        }
-        return result;
-    }
-    
-    public IStrategoPlaceholder makePlaceholder(IStrategoTerm template) {
-        if (placeholderConstructor == null)
-            placeholderConstructor = makeConstructor("<>", 1);
-        return new BasicStrategoPlaceholder(placeholderConstructor, template);
-    }
-
-    public IStrategoInt makeInt(int i) {
-        return new BasicStrategoInt(i, null);
-    }
-
     public final IStrategoList makeList(IStrategoTerm... terms) {
         return makeList(terms, null);
     }
 
-    public IStrategoList makeList(IStrategoTerm[] terms, IStrategoList outerAnnos) {
-        BasicStrategoList result = EMPTY_LIST;
-        int i = terms.length - 1;
-        while (i > 0) {
-            result = new BasicStrategoList(terms[i--], result, null);
-        }
-        if (i == 0) {
-            result = new BasicStrategoList(terms[0], result, outerAnnos);
-        } else {
-            return new BasicStrategoList(null, null, outerAnnos);
-        }
-        return result;
-    }
-
     public IStrategoList makeList(Collection<IStrategoTerm> terms) {
         return makeList(terms.toArray(EMPTY));
     }
@@ -409,47 +111,17 @@
     }
 
     public final IStrategoList makeListCons(IStrategoTerm head, IStrategoList tail) {
-        return makeListCons(head, tail, null);
-    }
-    
-    public IStrategoList makeListCons(IStrategoTerm head, IStrategoList tail, IStrategoList annotations) {
-        return new BasicStrategoList(head, tail, annotations);
-    }
-
-    public IStrategoReal makeReal(double d) {
-        return new BasicStrategoReal(d, null);
+        return makeListCons (head, tail, null);
     }
 
-    public IStrategoString makeString(String s) {
-    	if (s.length() <= MAX_POOLED_STRING_LENGTH)
-    	    stringPool.add(s);
-        return new BasicStrategoString(s, null);
-    }
+    public abstract IStrategoList makeListCons(IStrategoTerm head, IStrategoList tail, IStrategoList annos);
 
-    public final IStrategoTuple makeTuple(IStrategoTerm... terms) {
+	public final IStrategoTuple makeTuple(IStrategoTerm... terms) {
         return makeTuple(terms, null);
     }
-
-    public IStrategoTuple makeTuple(IStrategoTerm[] terms, IStrategoList annotations) {
-        return new BasicStrategoTuple(terms, annotations);
-    }
     
-    public IStrategoTerm annotateTerm(IStrategoTerm term, IStrategoList annotations) {
-        if (term instanceof BasicStrategoTerm) {
-            if (term.getAnnotations() == annotations) { // cheap check
-                return term;
-            } else {
-                BasicStrategoTerm result = ((BasicStrategoTerm) term).clone();
-                result.internalSetAnnotations(annotations);
-                assert result.getStorageType() != IStrategoTerm.MAXIMALLY_SHARED;
-                return result;
-            }
-        } else if (term == null) {
-            throw new IllegalArgumentException("Term to annotate cannot be null");
-        } else {
-            // TODO: Use a generic annotation wrapper class?
-            throw new NotImplementedException("Annotating term of type " + term.getClass().getName() + " in " + getClass().getSimpleName());
-        }
+    public IStrategoTerm parseFromString(String text) {
+    	return reader.parseFromString(text);
     }
 
 }

Copied and modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/LazyTerm.java (from r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/LazyTerm.java)
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/LazyTerm.java	Tue Dec 28 14:15:54 2010	(r21590, copy source)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/LazyTerm.java	Tue Dec 28 15:31:36 2010	(r21591)
@@ -1,4 +1,4 @@
-package org.strategoxt.lang.terms;
+package org.spoofax.terms;
 
 import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoConstructor;

Copied and modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoAnnotation.java (from r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoAnnotation.java)
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoAnnotation.java	Tue Dec 28 14:15:54 2010	(r21590, copy source)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoAnnotation.java	Tue Dec 28 15:31:36 2010	(r21591)
@@ -1,4 +1,4 @@
-package org.strategoxt.lang.terms;
+package org.spoofax.terms;
 
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoTerm;

Copied and modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoAppl.java (from r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoAppl.java)
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoAppl.java	Tue Dec 28 14:15:54 2010	(r21590, copy source)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoAppl.java	Tue Dec 28 15:31:36 2010	(r21591)
@@ -5,7 +5,7 @@
  * 
  * Licensed under the GNU General Public License, v2
  */
-package org.strategoxt.lang.terms;
+package org.spoofax.terms;
 
 import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoConstructor;

Copied and modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoConstructor.java (from r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoConstructor.java)
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoConstructor.java	Tue Dec 28 14:15:54 2010	(r21590, copy source)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoConstructor.java	Tue Dec 28 15:31:36 2010	(r21591)
@@ -5,7 +5,7 @@
  * 
  * Licensed under the GNU General Public License, v2
  */
-package org.strategoxt.lang.terms;
+package org.spoofax.terms;
 
 import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoConstructor;

Copied and modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoInt.java (from r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoInt.java)
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoInt.java	Tue Dec 28 14:15:54 2010	(r21590, copy source)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoInt.java	Tue Dec 28 15:31:36 2010	(r21591)
@@ -5,7 +5,7 @@
  * 
  * Licensed under the GNU General Public License, v2
  */
-package org.strategoxt.lang.terms;
+package org.spoofax.terms;
 
 import org.spoofax.interpreter.terms.IStrategoInt;
 import org.spoofax.interpreter.terms.IStrategoList;

Copied and modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoList.java (from r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoList.java)
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoList.java	Tue Dec 28 14:15:54 2010	(r21590, copy source)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoList.java	Tue Dec 28 15:31:36 2010	(r21591)
@@ -5,7 +5,7 @@
  * 
  * Licensed under the GNU General Public License, v2
  */
-package org.strategoxt.lang.terms;
+package org.spoofax.terms;
 
 import java.util.NoSuchElementException;
 

Copied and modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoPlaceholder.java (from r21585, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/BasicStrategoPlaceholder.java)
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/BasicStrategoPlaceholder.java	Mon Dec 27 12:28:23 2010	(r21585, copy source)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoPlaceholder.java	Tue Dec 28 15:31:36 2010	(r21591)
@@ -1,12 +1,18 @@
-package org.spoofax.interpreter.terms;
+package org.spoofax.terms;
+
+import org.spoofax.interpreter.terms.IStrategoConstructor;
+import org.spoofax.interpreter.terms.IStrategoList;
+import org.spoofax.interpreter.terms.IStrategoPlaceholder;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.ITermPrinter;
 
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
  */
-public class BasicStrategoPlaceholder extends BasicStrategoAppl implements IStrategoPlaceholder {
+public class StrategoPlaceholder extends StrategoAppl implements IStrategoPlaceholder {
 
-    public BasicStrategoPlaceholder(IStrategoConstructor ctor, IStrategoTerm template) {
-        super(ctor, new IStrategoTerm[] { template });
+    public StrategoPlaceholder(IStrategoConstructor ctor, IStrategoTerm template, IStrategoList annotations, int storageType) {
+        super(ctor, new IStrategoTerm[] { template }, annotations, storageType);
     }
     
     public IStrategoTerm getTemplate() {

Copied and modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoReal.java (from r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoReal.java)
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoReal.java	Tue Dec 28 14:15:54 2010	(r21590, copy source)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoReal.java	Tue Dec 28 15:31:36 2010	(r21591)
@@ -5,7 +5,7 @@
  * 
  * Licensed under the GNU General Public License, v2
  */
-package org.strategoxt.lang.terms;
+package org.spoofax.terms;
 
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoReal;

Copied and modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoString.java (from r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoString.java)
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoString.java	Tue Dec 28 14:15:54 2010	(r21590, copy source)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoString.java	Tue Dec 28 15:31:36 2010	(r21591)
@@ -5,7 +5,7 @@
  * 
  * Licensed under the GNU General Public License, v2
  */
-package org.strategoxt.lang.terms;
+package org.spoofax.terms;
 
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoString;

Copied and modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoTerm.java (from r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoTerm.java)
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoTerm.java	Tue Dec 28 14:15:54 2010	(r21590, copy source)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoTerm.java	Tue Dec 28 15:31:36 2010	(r21591)
@@ -5,12 +5,13 @@
  * 
  * Licensed under the GNU General Public License, v2
  */
-package org.strategoxt.lang.terms;
+package org.spoofax.terms;
 
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.ITermPrinter;
-import static org.strategoxt.lang.terms.TermFactory.EMPTY_LIST;;
+
+import static org.spoofax.terms.TermFactory.EMPTY_LIST;
 
 public abstract class StrategoTerm implements IStrategoTerm, Cloneable {
 	

Copied and modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoTuple.java (from r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoTuple.java)
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoTuple.java	Tue Dec 28 14:15:54 2010	(r21590, copy source)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoTuple.java	Tue Dec 28 15:31:36 2010	(r21591)
@@ -5,7 +5,7 @@
  * 
  * Licensed under the GNU General Public License, v2
  */
-package org.strategoxt.lang.terms;
+package org.spoofax.terms;
 
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoTerm;

Copied and modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoWrapped.java (from r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoWrapped.java)
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/StrategoWrapped.java	Tue Dec 28 14:15:54 2010	(r21590, copy source)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoWrapped.java	Tue Dec 28 15:31:36 2010	(r21591)
@@ -1,4 +1,4 @@
-package org.strategoxt.lang.terms;
+package org.spoofax.terms;
 
 import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoConstructor;

Copied and modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/TermFactory.java (from r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/TermFactory.java)
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/TermFactory.java	Tue Dec 28 14:15:54 2010	(r21590, copy source)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/TermFactory.java	Tue Dec 28 15:31:36 2010	(r21591)
@@ -1,36 +1,30 @@
-package org.strategoxt.lang.terms;
+package org.spoofax.terms;
 
 import static java.lang.Math.min;
 import static org.spoofax.interpreter.terms.IStrategoTerm.MAXIMALLY_SHARED;
 import static org.spoofax.interpreter.terms.IStrategoTerm.SHARABLE;
 import static org.spoofax.interpreter.terms.IStrategoTerm.STRING;
 
-import java.io.BufferedInputStream;
-import java.io.IOException;
-import java.io.InputStream;
 import java.lang.ref.WeakReference;
 import java.util.Collection;
-import java.util.HashMap;
 import java.util.WeakHashMap;
 
 import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoConstructor;
 import org.spoofax.interpreter.terms.IStrategoInt;
 import org.spoofax.interpreter.terms.IStrategoList;
+import org.spoofax.interpreter.terms.IStrategoPlaceholder;
 import org.spoofax.interpreter.terms.IStrategoReal;
 import org.spoofax.interpreter.terms.IStrategoString;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.IStrategoTuple;
 import org.spoofax.interpreter.terms.ITermFactory;
-import org.spoofax.terms.io.AbstractIOTermFactory;
-import org.spoofax.terms.io.baf.BAFReader;
 
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
+ * @author Karl T. Kalleberg <karltk add strategoxt.org>
  */
-public class TermFactory extends AbstractIOTermFactory implements ITermFactory {
-
-    public static final IStrategoTerm[] EMPTY = AbstractIOTermFactory.EMPTY;
+public class TermFactory extends AbstractTermFactory implements ITermFactory {
     
     private static final int MY_STORAGE_TYPE = SHARABLE;
     
@@ -41,6 +35,8 @@
     public static final int MAX_POOLED_STRING_LENGTH = 100;
     
     private static final IStrategoInt[] intCache = initIntCache();
+    
+    private IStrategoConstructor placeholderConstructor;
 
     /**
      * The singleton maximally shared empty list instance.
@@ -50,15 +46,11 @@
      */
     public static final StrategoList EMPTY_LIST =
     	new StrategoList(null, null, null, MAXIMALLY_SHARED); 
-
-    private static final HashMap<StrategoConstructor, StrategoConstructor> asyncCtorCache =
-        new HashMap<StrategoConstructor, StrategoConstructor>();
     
     // StrategoXT/801: must use weak keys and values, and must maintain maximal sharing to avoid early collection
     private static final WeakHashMap<String, WeakReference<StrategoString>> asyncStringPool =
         new WeakHashMap<String, WeakReference<StrategoString>>();
     
-    @Override
     public boolean hasConstructor(String name, int arity) {
         synchronized (TermFactory.class) {
         	if (arity == 0) {
@@ -78,44 +70,7 @@
         	}
         }
     }
-    
-    @Override
-    public IStrategoTerm parseFromStream(InputStream inputStream) throws IOException {
-        /*
-    	BufferedInputStream bis;
-        if (inputStream instanceof BufferedInputStream) {
-            bis = (BufferedInputStream) inputStream;
-        } else if (inputStream instanceof FileInputStream) {
-        	FileChannel channel = ((FileInputStream) inputStream).getChannel();
-			ChannelPushbackInputStream pis = new ChannelPushbackInputStream(channel);
-			if (BAFReader.isBinaryATerm(pis)) {
-				return new BAFReader(this, pis).readFromBinaryFile(true);
-			} else {
-				return super.parseFromStream(pis);
-			}
-        } else {
-            bis = new BufferedInputStream(inputStream);
-        }
-        if (BAFReader.isBinaryATerm(bis)) {
-            return new BAFReader(this, bis).readFromBinaryFile(true);
-        } else {
-            return super.parseFromStream(bis);
-        }
-        */
-    	BufferedInputStream bis;
-        if (inputStream instanceof BufferedInputStream)
-            bis = (BufferedInputStream) inputStream;
-        else
-            bis = new BufferedInputStream(inputStream);
-        
-        if (BAFReader.isBinaryATerm(bis)) {
-            return new BAFReader(this, bis).readFromBinaryFile(true);
-        } else {
-            return super.parseFromStream(bis);
-        }
-    }
 
-    @Override
     public IStrategoAppl makeAppl(IStrategoConstructor ctr,
             IStrategoTerm[] terms, IStrategoList annotations) {
     	int storageType = MY_STORAGE_TYPE;
@@ -125,21 +80,6 @@
         return new StrategoAppl(ctr, terms, annotations, storageType);
     }
 
-    @Override
-    public StrategoConstructor makeConstructor(String name, int arity) {
-        StrategoConstructor result = new StrategoConstructor(name, arity);
-        synchronized (TermFactory.class) {
-	        StrategoConstructor cached = asyncCtorCache.get(result);
-	        if (cached == null) {
-	            asyncCtorCache.put(result, result);
-	        } else {
-	            result = cached;
-	        }
-        }
-        return result;
-    }
-
-    @Override
     public IStrategoInt makeInt(int i) {
     	if (0 <= i && i <= 255)
     		return intCache[i];
@@ -154,7 +94,6 @@
     	return results;
     }
     
-    @Override
     public IStrategoList makeList(IStrategoTerm[] terms, IStrategoList outerAnnos) {
         StrategoList result = EMPTY_LIST;
         int storageType = MY_STORAGE_TYPE;
@@ -178,12 +117,10 @@
         return result;
     }
 
-    @Override
     public IStrategoList makeList(Collection<IStrategoTerm> terms) {
         return makeList(terms.toArray(EMPTY));
     }
     
-    @Override
     public IStrategoList makeListCons(IStrategoTerm head, IStrategoList tail, IStrategoList annotations) {
     	int storageType = min(MY_STORAGE_TYPE, getStorageType(head, tail));
     	
@@ -191,12 +128,10 @@
     	return new StrategoList(head, tail, annotations, storageType);
     }
 
-    @Override
     public IStrategoReal makeReal(double d) {
         return new StrategoReal(d, null);
     }
 
-    @Override
     public IStrategoString makeString(String s) {
     	if (s.length() > MAX_POOLED_STRING_LENGTH)
     		return new StrategoString(s, null, MY_STORAGE_TYPE);
@@ -212,7 +147,6 @@
     	}
     }
 
-    @Override
     public IStrategoTuple makeTuple(IStrategoTerm[] terms, IStrategoList annos) {
         int storageType = min(MY_STORAGE_TYPE, getStorageType(terms));
 		return new StrategoTuple(terms, annos, storageType);
@@ -240,7 +174,6 @@
     	return result;
     }
     
-    @Override
     public IStrategoTerm annotateTerm(IStrategoTerm term, IStrategoList annotations) {
         if (term.getAnnotations() == annotations) { // cheap check
             return term;
@@ -279,4 +212,10 @@
         }
     }
 
+	public IStrategoPlaceholder makePlaceholder(IStrategoTerm template) {
+        if (placeholderConstructor == null)
+            placeholderConstructor = makeConstructor("<>", 1);
+        return new StrategoPlaceholder(placeholderConstructor, template, EMPTY_LIST, MY_STORAGE_TYPE);
+	}
+
 }

Copied and modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/TermWrapperException.java (from r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/TermWrapperException.java)
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/TermWrapperException.java	Tue Dec 28 14:15:54 2010	(r21590, copy source)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/TermWrapperException.java	Tue Dec 28 15:31:36 2010	(r21591)
@@ -1,4 +1,4 @@
-package org.strategoxt.lang.terms;
+package org.spoofax.terms;
 
 /**
  * @author Lennart Kats <lennart add lclnet.nl>

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/AbstractIOTermFactory.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/AbstractIOTermFactory.java	Tue Dec 28 14:15:54 2010	(r21590)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/AbstractIOTermFactory.java	Tue Dec 28 15:31:36 2010	(r21591)
@@ -7,320 +7,28 @@
  */
 package org.spoofax.terms.io;
 
-import java.io.BufferedInputStream;
 import java.io.BufferedWriter;
-import java.io.ByteArrayInputStream;
-import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.io.OutputStreamWriter;
-import java.io.PushbackInputStream;
 import java.io.Writer;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.WeakHashMap;
 
-import org.spoofax.NotImplementedException;
-import org.spoofax.interpreter.terms.IStrategoAppl;
-import org.spoofax.interpreter.terms.IStrategoConstructor;
-import org.spoofax.interpreter.terms.IStrategoInt;
-import org.spoofax.interpreter.terms.IStrategoList;
-import org.spoofax.interpreter.terms.IStrategoPlaceholder;
-import org.spoofax.interpreter.terms.IStrategoReal;
-import org.spoofax.interpreter.terms.IStrategoString;
 import org.spoofax.interpreter.terms.IStrategoTerm;
-import org.spoofax.interpreter.terms.IStrategoTuple;
-import org.spoofax.interpreter.terms.ITermFactory;
 import org.spoofax.interpreter.terms.ITermPrinter;
-import org.spoofax.interpreter.terms.ParseError;
+import org.spoofax.interpreter.terms.io.IFileTermFactory;
+import org.spoofax.terms.AbstractTermFactory;
 
-public class AbstractIOTermFactory implements ITermFactory {
-
-    public static final IStrategoTerm[] EMPTY = {};
-
-    public static final IStrategoList EMPTY_LIST = new StrategoList(null, null, null, IStrategoTerm.MAXIMALLY_SHARED);
-    
-    private static final int MAX_POOLED_STRING_LENGTH = 100;
-
-    private static final Map<BasicStrategoConstructor, BasicStrategoConstructor> ctorCache =
-        Collections.synchronizedMap(new WeakHashMap<BasicStrategoConstructor,BasicStrategoConstructor>());
-    
-    private static final Set<String> stringPool =
-        Collections.synchronizedSet(new HashSet<String>());
-    
-    private IStrategoConstructor placeholderConstructor;
-    
-    public IStrategoTerm parseFromFile(String path) throws IOException {
-        InputStream stream = new FileInputStream(path);
-        try {
-            return parseFromStream(stream);
-        } finally {
-            stream.close();
-        }
-    }
+public abstract class AbstractIOTermFactory extends AbstractTermFactory implements IFileTermFactory {
+	
+	private final StreamTermReader reader = new StreamTermReader(this);
 
     public IStrategoTerm parseFromStream(InputStream inputStream) throws IOException {
-        /*
-        PushbackInputStream pushbackStream;
-        
-        if (inputStream instanceof FileInputStream) {
-            FileChannel channel = ((FileInputStream)inputStream).getChannel();
-            pushbackStream = new ChannelPushbackInputStream(channel);
-        } else {
-            if (!(inputStream instanceof BufferedInputStream) && !(inputStream instanceof ChannelPushbackInputStream))
-                inputStream = new BufferedInputStream(inputStream);
-            pushbackStream = new PushbackInputStream(inputStream);
-        }
-        
-        return parseFromStream(pushbackStream);
-        */
-        if (!(inputStream instanceof BufferedInputStream))
-            inputStream = new BufferedInputStream(inputStream);
-        PushbackInputStream bis = new PushbackInputStream(inputStream);
-        
-        return parseFromStream(bis);
-    }
-
-    protected IStrategoTerm parseFromStream(PushbackInputStream bis) throws IOException {
-        parseSkip(bis);
-        final int ch = bis.read();
-        switch(ch) {
-        case '[': return parseAnno(bis, parseList(bis));
-        case '(': return parseAnno(bis, parseTuple(bis));
-        case '"': return parseAnno(bis, parseString(bis));
-        case '<': return parsePlaceholder(bis);
-        default:
-            bis.unread(ch);
-            if (Character.isLetter(ch)) {
-                return parseAnno(bis, parseAppl(bis));
-            }
-            else if (Character.isDigit(ch) || ch == '-')
-                return parseAnno(bis, parseNumber(bis));
-        }
-        throw new ParseError("Invalid term: '" + (char)ch + "'");
-    }
-    
-    private IStrategoTerm parseAnno(PushbackInputStream bis, IStrategoTerm term) throws IOException {
-        parseSkip(bis);
-        final int ch = bis.read();
-        if (ch == '{') {
-            List<IStrategoTerm> annos = parseTermSequence(bis, '}');
-            return annotateTerm(term, makeList(annos));
-        } else {
-            bis.unread(ch);
-            return term;
-        }
-    }
-
-    private IStrategoTerm parseString(PushbackInputStream bis) throws IOException {
-        int ch = bis.read();
-        if(ch == '"')
-            return makeString("");
-        StringBuilder sb = new StringBuilder();
-        boolean escaped = false;
-        do {
-            escaped = false;
-            if(ch == '\\') {
-                escaped = true;
-                ch = bis.read();
-            }
-            if(escaped) {
-                switch(ch) {
-                case 'n':
-                    sb.append('\n');
-                    break;
-                case 't':
-                    sb.append('\t');
-                    break;
-                case 'b':
-                    sb.append('\b');
-                    break;
-                case 'f':
-                    sb.append('\f');
-                    break;
-                case 'r':
-                    sb.append('\r');
-                    break;
-                case '\\':
-                    sb.append('\\');
-                    break;
-                case '\'':
-                    sb.append('\'');
-                    break;
-                case '\"':
-                    sb.append('\"');
-                    break;
-                case '0':
-                case '1':
-                case '2':
-                case '3':
-                case '4':
-                case '5':
-                case '6':
-                case '7':
-                case '8':
-                case '9':
-                    throw new NotImplementedException();
-                default:
-                    sb.append("\\" + (char)ch); 
-                }
-                ch = bis.read();
-            } else if(ch != '\"') {
-                if (ch == -1)
-                    throw new ParseError("Unterminated string: " + sb);
-                sb.append((char)ch);
-                ch = bis.read();
-            }
-        } while(escaped || ch != '\"');
-        return makeString(sb.toString());
-    }
-
-    private IStrategoTerm parseAppl(PushbackInputStream bis) throws IOException {
-        //System.err.println("appl");
-        // TODO: share stringbuilder instances?
-        StringBuilder sb = new StringBuilder();
-        int ch;
-        
-        ch = bis.read();
-        do {
-            sb.append((char)ch);
-            ch = bis.read();
-        } // TODO: use a switch for this
-          while(Character.isLetterOrDigit(ch) || ch == '_' || ch == '-'
-            || ch == '+' || ch == '*' || ch == '$');
-        
-        //System.err.println(" - " + sb.toString());
-        
-        bis.unread(ch);
-        parseSkip(bis);
-        ch = bis.read();
-
-        if(ch == '(') {
-            List<IStrategoTerm> l = parseTermSequence(bis, ')');
-            IStrategoConstructor c = makeConstructor(sb.toString(), l.size());
-            return makeAppl(c, l.toArray(EMPTY));
-        } else {
-            bis.unread(ch);
-            IStrategoConstructor c = makeConstructor(sb.toString(), 0);
-            return makeAppl(c, new IStrategoTerm[0]);
-        }
-    }
-    
-    private IStrategoTerm parsePlaceholder(PushbackInputStream bis) throws IOException {
-        IStrategoTerm template = parseFromStream(bis);
-        parseSkip(bis);
-        if (bis.read() != '>')
-            throw new ParseError("Expected: '>'");
-        return makePlaceholder(template);
-    }
-
-    private IStrategoTerm parseTuple(PushbackInputStream bis) throws IOException {
-        //System.err.println("tuple");
-        return makeTuple(parseTermSequence(bis, ')').toArray(EMPTY));
-    }
-
-    private List<IStrategoTerm> parseTermSequence(PushbackInputStream bis, char endChar) throws IOException {
-        //System.err.println("sequence");
-        List<IStrategoTerm> els = Collections.emptyList();
-        parseSkip(bis);
-        int ch = bis.read();
-        if(ch == endChar)
-            return els;
-        els = new ArrayList<IStrategoTerm>();
-        bis.unread(ch);
-        do {
-            els.add(parseFromStream(bis));
-            parseSkip(bis);
-            ch = bis.read();
-        } while(ch == ',');
-        
-        if (ch != endChar) {
-            bis.unread(ch);
-            parseSkip(bis);
-            ch = bis.read();
-        }
-
-        if(ch != endChar)
-            throw new ParseError("Sequence must end with '" + endChar + "', saw '" + (char)ch + "'");
-        
-        return els;
-    }
-
-    private IStrategoTerm parseList(PushbackInputStream bis) throws IOException {
-        //System.err.println("list");
-        return makeList(parseTermSequence(bis, ']'));
-    }
-
-    private IStrategoTerm parseNumber(PushbackInputStream bis) throws IOException {
-        //System.err.println("number");
-        String whole = parseDigitSequence(bis);
-        
-        int ch = bis.read();
-        if(ch == '.') {
-            String frac = parseDigitSequence(bis);
-            ch = bis.read();
-            if(ch == 'e' || ch == 'E') {
-                String exp = parseDigitSequence(bis);
-                double d = Double.parseDouble(whole + "." + frac + "e" + exp);
-                return makeReal(d);
-            }
-            bis.unread(ch);
-            double d = Double.parseDouble(whole + "." + frac);
-            return makeReal(d);
-        }
-        bis.unread(ch);
-        return makeInt(Integer.parseInt(whole));
-    }
-
-    private String parseDigitSequence(PushbackInputStream bis) throws IOException {
-        StringBuilder sb = new StringBuilder();
-        int ch = bis.read();
-        do {
-            sb.append((char)ch);
-            ch = bis.read();
-        } while(Character.isDigit(ch));
-        bis.unread(ch);
-        return sb.toString(); 
-    }
-
-    public IStrategoTerm parseFromString(String text) {
-        try {
-            return parseFromStream(new ByteArrayInputStream(text.getBytes()));
-        } catch(IOException e) {
-            return null;
-        }
-    }
-    
-    private void parseSkip(PushbackInputStream input) throws IOException {
-        for (;;) {
-            int b = input.read();
-            switch (b) {
-                case ' ': case '\t': case '\n':
-                    continue;
-                default:
-                    input.unread(b);
-                    return;
-            }
-        }
-    }
-
-    public IStrategoAppl replaceAppl(IStrategoConstructor constructor, IStrategoTerm[] kids,
-            IStrategoAppl old) {
-        return makeAppl(constructor, kids, old.getAnnotations());
-    }
-
-    public IStrategoTuple replaceTuple(IStrategoTerm[] kids, IStrategoTuple old) {
-        return makeTuple(kids, old.getAnnotations());
+        return reader.parseFromStream(inputStream);
     }
     
-    public IStrategoList replaceList(IStrategoTerm[] kids, IStrategoList old) {
-        return makeList(kids, old.getAnnotations());
+    public IStrategoTerm parseFromFile(String path) throws IOException {
+    	return reader.parseFromFile(path);
     }
 
     public void unparseToFile(IStrategoTerm t, OutputStream ous) throws IOException {
@@ -333,123 +41,4 @@
         t.prettyPrint(tp);
     }
 
-    public boolean hasConstructor(String name, int arity) {
-    	if (name.length() > MAX_POOLED_STRING_LENGTH)
-            throw new UnsupportedOperationException("String too long to be pooled: " + name);
-    	return arity == 0
-            ? stringPool.contains(name)
-            : ctorCache.get(new BasicStrategoConstructor(name, arity)) != null;
-    }
-
-    public final IStrategoAppl makeAppl(IStrategoConstructor ctr, IStrategoList kids,
-            IStrategoList annotations) {
-        return makeAppl(ctr, kids.getAllSubterms(), annotations);
-    }
-
-    public final IStrategoAppl makeAppl(IStrategoConstructor ctr, IStrategoList kids) {
-        return makeAppl(ctr, kids, null);
-    }
-
-    public IStrategoAppl makeAppl(IStrategoConstructor ctr,
-            IStrategoTerm[] terms, IStrategoList annotations) {
-        return new BasicStrategoAppl(ctr, terms, annotations);
-    }
-
-    public final IStrategoAppl makeAppl(IStrategoConstructor ctr, IStrategoTerm... terms) {
-        return makeAppl(ctr, terms, null);
-    }
-
-    public IStrategoConstructor makeConstructor(String name, int arity) {
-        BasicStrategoConstructor result = new BasicStrategoConstructor(name, arity);
-        BasicStrategoConstructor cached = ctorCache.get(result);
-        if (cached == null) {
-            ctorCache.put(result, result);
-            if (arity == 0) stringPool.add(name);
-        } else {
-            result = cached;
-        }
-        return result;
-    }
-    
-    public IStrategoPlaceholder makePlaceholder(IStrategoTerm template) {
-        if (placeholderConstructor == null)
-            placeholderConstructor = makeConstructor("<>", 1);
-        return new BasicStrategoPlaceholder(placeholderConstructor, template);
-    }
-
-    public IStrategoInt makeInt(int i) {
-        return new BasicStrategoInt(i, null);
-    }
-
-    public final IStrategoList makeList(IStrategoTerm... terms) {
-        return makeList(terms, null);
-    }
-
-    public IStrategoList makeList(IStrategoTerm[] terms, IStrategoList outerAnnos) {
-        BasicStrategoList result = EMPTY_LIST;
-        int i = terms.length - 1;
-        while (i > 0) {
-            result = new BasicStrategoList(terms[i--], result, null);
-        }
-        if (i == 0) {
-            result = new BasicStrategoList(terms[0], result, outerAnnos);
-        } else {
-            return new BasicStrategoList(null, null, outerAnnos);
-        }
-        return result;
-    }
-
-    public IStrategoList makeList(Collection<IStrategoTerm> terms) {
-        return makeList(terms.toArray(EMPTY));
-    }
-    
-    @Deprecated
-    public final IStrategoList makeList(IStrategoTerm head, IStrategoList tail) {
-        return makeListCons(head, tail);
-    }
-
-    public final IStrategoList makeListCons(IStrategoTerm head, IStrategoList tail) {
-        return makeListCons(head, tail, null);
-    }
-    
-    public IStrategoList makeListCons(IStrategoTerm head, IStrategoList tail, IStrategoList annotations) {
-        return new BasicStrategoList(head, tail, annotations);
-    }
-
-    public IStrategoReal makeReal(double d) {
-        return new BasicStrategoReal(d, null);
-    }
-
-    public IStrategoString makeString(String s) {
-    	if (s.length() <= MAX_POOLED_STRING_LENGTH)
-    	    stringPool.add(s);
-        return new BasicStrategoString(s, null);
-    }
-
-    public final IStrategoTuple makeTuple(IStrategoTerm... terms) {
-        return makeTuple(terms, null);
-    }
-
-    public IStrategoTuple makeTuple(IStrategoTerm[] terms, IStrategoList annotations) {
-        return new BasicStrategoTuple(terms, annotations);
-    }
-    
-    public IStrategoTerm annotateTerm(IStrategoTerm term, IStrategoList annotations) {
-        if (term instanceof BasicStrategoTerm) {
-            if (term.getAnnotations() == annotations) { // cheap check
-                return term;
-            } else {
-                BasicStrategoTerm result = ((BasicStrategoTerm) term).clone();
-                result.internalSetAnnotations(annotations);
-                assert result.getStorageType() != IStrategoTerm.MAXIMALLY_SHARED;
-                return result;
-            }
-        } else if (term == null) {
-            throw new IllegalArgumentException("Term to annotate cannot be null");
-        } else {
-            // TODO: Use a generic annotation wrapper class?
-            throw new NotImplementedException("Annotating term of type " + term.getClass().getName() + " in " + getClass().getSimpleName());
-        }
-    }
-
 }

Copied and modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/StreamTermReader.java (from r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/AbstractIOTermFactory.java)
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/AbstractIOTermFactory.java	Tue Dec 28 14:15:54 2010	(r21590, copy source)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/StreamTermReader.java	Tue Dec 28 15:31:36 2010	(r21591)
@@ -9,7 +9,6 @@
 
 import java.io.BufferedInputStream;
 import java.io.BufferedWriter;
-import java.io.ByteArrayInputStream;
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -18,43 +17,28 @@
 import java.io.PushbackInputStream;
 import java.io.Writer;
 import java.util.ArrayList;
-import java.util.Collection;
 import java.util.Collections;
-import java.util.HashSet;
 import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.WeakHashMap;
 
 import org.spoofax.NotImplementedException;
-import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoConstructor;
-import org.spoofax.interpreter.terms.IStrategoInt;
-import org.spoofax.interpreter.terms.IStrategoList;
-import org.spoofax.interpreter.terms.IStrategoPlaceholder;
-import org.spoofax.interpreter.terms.IStrategoReal;
-import org.spoofax.interpreter.terms.IStrategoString;
 import org.spoofax.interpreter.terms.IStrategoTerm;
-import org.spoofax.interpreter.terms.IStrategoTuple;
 import org.spoofax.interpreter.terms.ITermFactory;
 import org.spoofax.interpreter.terms.ITermPrinter;
 import org.spoofax.interpreter.terms.ParseError;
+import org.spoofax.terms.AbstractTermFactory;
 
-public class AbstractIOTermFactory implements ITermFactory {
+public class StreamTermReader {
 
-    public static final IStrategoTerm[] EMPTY = {};
-
-    public static final IStrategoList EMPTY_LIST = new StrategoList(null, null, null, IStrategoTerm.MAXIMALLY_SHARED);
-    
-    private static final int MAX_POOLED_STRING_LENGTH = 100;
-
-    private static final Map<BasicStrategoConstructor, BasicStrategoConstructor> ctorCache =
-        Collections.synchronizedMap(new WeakHashMap<BasicStrategoConstructor,BasicStrategoConstructor>());
-    
-    private static final Set<String> stringPool =
-        Collections.synchronizedSet(new HashSet<String>());
+	private final ITermFactory factory;
+	
+    public StreamTermReader(ITermFactory factory) {
+    	this.factory = factory;
+    }
     
-    private IStrategoConstructor placeholderConstructor;
+    public ITermFactory getFactory() {
+		return factory;
+	}
     
     public IStrategoTerm parseFromFile(String path) throws IOException {
         InputStream stream = new FileInputStream(path);
@@ -111,7 +95,7 @@
         final int ch = bis.read();
         if (ch == '{') {
             List<IStrategoTerm> annos = parseTermSequence(bis, '}');
-            return annotateTerm(term, makeList(annos));
+            return factory.annotateTerm(term, factory.makeList(annos));
         } else {
             bis.unread(ch);
             return term;
@@ -121,7 +105,7 @@
     private IStrategoTerm parseString(PushbackInputStream bis) throws IOException {
         int ch = bis.read();
         if(ch == '"')
-            return makeString("");
+            return factory.makeString("");
         StringBuilder sb = new StringBuilder();
         boolean escaped = false;
         do {
@@ -178,7 +162,7 @@
                 ch = bis.read();
             }
         } while(escaped || ch != '\"');
-        return makeString(sb.toString());
+        return factory.makeString(sb.toString());
     }
 
     private IStrategoTerm parseAppl(PushbackInputStream bis) throws IOException {
@@ -203,12 +187,12 @@
 
         if(ch == '(') {
             List<IStrategoTerm> l = parseTermSequence(bis, ')');
-            IStrategoConstructor c = makeConstructor(sb.toString(), l.size());
-            return makeAppl(c, l.toArray(EMPTY));
+            IStrategoConstructor c = factory.makeConstructor(sb.toString(), l.size());
+            return factory.makeAppl(c, l.toArray(AbstractTermFactory.EMPTY));
         } else {
             bis.unread(ch);
-            IStrategoConstructor c = makeConstructor(sb.toString(), 0);
-            return makeAppl(c, new IStrategoTerm[0]);
+            IStrategoConstructor c = factory.makeConstructor(sb.toString(), 0);
+            return factory.makeAppl(c, new IStrategoTerm[0]);
         }
     }
     
@@ -217,12 +201,12 @@
         parseSkip(bis);
         if (bis.read() != '>')
             throw new ParseError("Expected: '>'");
-        return makePlaceholder(template);
+        return factory.makePlaceholder(template);
     }
 
     private IStrategoTerm parseTuple(PushbackInputStream bis) throws IOException {
         //System.err.println("tuple");
-        return makeTuple(parseTermSequence(bis, ')').toArray(EMPTY));
+        return factory.makeTuple(parseTermSequence(bis, ')').toArray(AbstractTermFactory.EMPTY));
     }
 
     private List<IStrategoTerm> parseTermSequence(PushbackInputStream bis, char endChar) throws IOException {
@@ -254,7 +238,7 @@
 
     private IStrategoTerm parseList(PushbackInputStream bis) throws IOException {
         //System.err.println("list");
-        return makeList(parseTermSequence(bis, ']'));
+        return factory.makeList(parseTermSequence(bis, ']'));
     }
 
     private IStrategoTerm parseNumber(PushbackInputStream bis) throws IOException {
@@ -268,14 +252,14 @@
             if(ch == 'e' || ch == 'E') {
                 String exp = parseDigitSequence(bis);
                 double d = Double.parseDouble(whole + "." + frac + "e" + exp);
-                return makeReal(d);
+                return factory.makeReal(d);
             }
             bis.unread(ch);
             double d = Double.parseDouble(whole + "." + frac);
-            return makeReal(d);
+            return factory.makeReal(d);
         }
         bis.unread(ch);
-        return makeInt(Integer.parseInt(whole));
+        return factory.makeInt(Integer.parseInt(whole));
     }
 
     private String parseDigitSequence(PushbackInputStream bis) throws IOException {
@@ -288,14 +272,6 @@
         bis.unread(ch);
         return sb.toString(); 
     }
-
-    public IStrategoTerm parseFromString(String text) {
-        try {
-            return parseFromStream(new ByteArrayInputStream(text.getBytes()));
-        } catch(IOException e) {
-            return null;
-        }
-    }
     
     private void parseSkip(PushbackInputStream input) throws IOException {
         for (;;) {
@@ -310,19 +286,6 @@
         }
     }
 
-    public IStrategoAppl replaceAppl(IStrategoConstructor constructor, IStrategoTerm[] kids,
-            IStrategoAppl old) {
-        return makeAppl(constructor, kids, old.getAnnotations());
-    }
-
-    public IStrategoTuple replaceTuple(IStrategoTerm[] kids, IStrategoTuple old) {
-        return makeTuple(kids, old.getAnnotations());
-    }
-    
-    public IStrategoList replaceList(IStrategoTerm[] kids, IStrategoList old) {
-        return makeList(kids, old.getAnnotations());
-    }
-
     public void unparseToFile(IStrategoTerm t, OutputStream ous) throws IOException {
         Writer out = new BufferedWriter(new OutputStreamWriter(ous));
         unparseToFile(t, out);
@@ -333,123 +296,4 @@
         t.prettyPrint(tp);
     }
 
-    public boolean hasConstructor(String name, int arity) {
-    	if (name.length() > MAX_POOLED_STRING_LENGTH)
-            throw new UnsupportedOperationException("String too long to be pooled: " + name);
-    	return arity == 0
-            ? stringPool.contains(name)
-            : ctorCache.get(new BasicStrategoConstructor(name, arity)) != null;
-    }
-
-    public final IStrategoAppl makeAppl(IStrategoConstructor ctr, IStrategoList kids,
-            IStrategoList annotations) {
-        return makeAppl(ctr, kids.getAllSubterms(), annotations);
-    }
-
-    public final IStrategoAppl makeAppl(IStrategoConstructor ctr, IStrategoList kids) {
-        return makeAppl(ctr, kids, null);
-    }
-
-    public IStrategoAppl makeAppl(IStrategoConstructor ctr,
-            IStrategoTerm[] terms, IStrategoList annotations) {
-        return new BasicStrategoAppl(ctr, terms, annotations);
-    }
-
-    public final IStrategoAppl makeAppl(IStrategoConstructor ctr, IStrategoTerm... terms) {
-        return makeAppl(ctr, terms, null);
-    }
-
-    public IStrategoConstructor makeConstructor(String name, int arity) {
-        BasicStrategoConstructor result = new BasicStrategoConstructor(name, arity);
-        BasicStrategoConstructor cached = ctorCache.get(result);
-        if (cached == null) {
-            ctorCache.put(result, result);
-            if (arity == 0) stringPool.add(name);
-        } else {
-            result = cached;
-        }
-        return result;
-    }
-    
-    public IStrategoPlaceholder makePlaceholder(IStrategoTerm template) {
-        if (placeholderConstructor == null)
-            placeholderConstructor = makeConstructor("<>", 1);
-        return new BasicStrategoPlaceholder(placeholderConstructor, template);
-    }
-
-    public IStrategoInt makeInt(int i) {
-        return new BasicStrategoInt(i, null);
-    }
-
-    public final IStrategoList makeList(IStrategoTerm... terms) {
-        return makeList(terms, null);
-    }
-
-    public IStrategoList makeList(IStrategoTerm[] terms, IStrategoList outerAnnos) {
-        BasicStrategoList result = EMPTY_LIST;
-        int i = terms.length - 1;
-        while (i > 0) {
-            result = new BasicStrategoList(terms[i--], result, null);
-        }
-        if (i == 0) {
-            result = new BasicStrategoList(terms[0], result, outerAnnos);
-        } else {
-            return new BasicStrategoList(null, null, outerAnnos);
-        }
-        return result;
-    }
-
-    public IStrategoList makeList(Collection<IStrategoTerm> terms) {
-        return makeList(terms.toArray(EMPTY));
-    }
-    
-    @Deprecated
-    public final IStrategoList makeList(IStrategoTerm head, IStrategoList tail) {
-        return makeListCons(head, tail);
-    }
-
-    public final IStrategoList makeListCons(IStrategoTerm head, IStrategoList tail) {
-        return makeListCons(head, tail, null);
-    }
-    
-    public IStrategoList makeListCons(IStrategoTerm head, IStrategoList tail, IStrategoList annotations) {
-        return new BasicStrategoList(head, tail, annotations);
-    }
-
-    public IStrategoReal makeReal(double d) {
-        return new BasicStrategoReal(d, null);
-    }
-
-    public IStrategoString makeString(String s) {
-    	if (s.length() <= MAX_POOLED_STRING_LENGTH)
-    	    stringPool.add(s);
-        return new BasicStrategoString(s, null);
-    }
-
-    public final IStrategoTuple makeTuple(IStrategoTerm... terms) {
-        return makeTuple(terms, null);
-    }
-
-    public IStrategoTuple makeTuple(IStrategoTerm[] terms, IStrategoList annotations) {
-        return new BasicStrategoTuple(terms, annotations);
-    }
-    
-    public IStrategoTerm annotateTerm(IStrategoTerm term, IStrategoList annotations) {
-        if (term instanceof BasicStrategoTerm) {
-            if (term.getAnnotations() == annotations) { // cheap check
-                return term;
-            } else {
-                BasicStrategoTerm result = ((BasicStrategoTerm) term).clone();
-                result.internalSetAnnotations(annotations);
-                assert result.getStorageType() != IStrategoTerm.MAXIMALLY_SHARED;
-                return result;
-            }
-        } else if (term == null) {
-            throw new IllegalArgumentException("Term to annotate cannot be null");
-        } else {
-            // TODO: Use a generic annotation wrapper class?
-            throw new NotImplementedException("Annotating term of type " + term.getClass().getName() + " in " + getClass().getSimpleName());
-        }
-    }
-
 }

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/baf/BAFReader.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/baf/BAFReader.java	Tue Dec 28 14:15:54 2010	(r21590)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/baf/BAFReader.java	Tue Dec 28 15:31:36 2010	(r21591)
@@ -34,6 +34,7 @@
 import org.spoofax.interpreter.terms.IStrategoString;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.ITermFactory;
+import org.spoofax.interpreter.terms.ParseError;
 
 
 /**
@@ -95,15 +96,15 @@
         }
     }
 
-    public IStrategoTerm readFromBinaryFile(boolean headerAlreadyRead) throws ParseException, IOException {
+    public IStrategoTerm readFromBinaryFile(boolean headerAlreadyRead) throws ParseError, IOException {
 
         if(!headerAlreadyRead && !isBinaryATerm(reader))
-            throw new ParseException("Input is not a BAF file");
+            throw new ParseError("Input is not a BAF file");
 
         int val = reader.readInt();
 
         if (val != BAF_VERSION)
-            throw new ParseException("Wrong BAF version (wanted " + BAF_VERSION + ", got " + val + "), giving up");
+            throw new ParseError("Wrong BAF version (wanted " + BAF_VERSION + ", got " + val + "), giving up");
 
         nrUniqueSymbols = reader.readInt();
         int nrUniqueTerms = reader.readInt();
@@ -176,7 +177,7 @@
         }
     }
     
-    private IStrategoTerm readTerm(SymEntry e) throws ParseException, IOException {
+    private IStrategoTerm readTerm(SymEntry e) throws ParseError, IOException {
         // TODO: Optimize readTerm?
         //       e.g., throw in some rounds of native-stack based reading
         ArrayList<ReadTermFrame> stack = readerStacks.get();
@@ -228,7 +229,7 @@
                 }
     
                 if (argSym.terms[val] == null) 
-                    throw new ParseException("Malformed ATerm: Cannot be null");
+                    throw new ParseError("Malformed ATerm: Cannot be null");
     
                 outputArgs[i] = argSym.terms[val];
             }
@@ -296,9 +297,10 @@
           } else if (name.equals("<_>")) {
               throw new NotImplementedException("ATerm placeholders");
               // return factory.makePlaceholder(args[0]);
-          } else if (false) {
+          } /* UNDONE: exception
+            else if (false) {
               throw new NotImplementedException("ATerm blobs");
-          }
+          }*/
       }
 
       if(isDebugging()) {

Copied and modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/baf/BAFStreamTermReader.java (from r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/TermFactory.java)
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/lang/terms/TermFactory.java	Tue Dec 28 14:15:54 2010	(r21590, copy source)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/baf/BAFStreamTermReader.java	Tue Dec 28 15:31:36 2010	(r21591)
@@ -1,85 +1,22 @@
-package org.strategoxt.lang.terms;
-
-import static java.lang.Math.min;
-import static org.spoofax.interpreter.terms.IStrategoTerm.MAXIMALLY_SHARED;
-import static org.spoofax.interpreter.terms.IStrategoTerm.SHARABLE;
-import static org.spoofax.interpreter.terms.IStrategoTerm.STRING;
+package org.spoofax.terms.io.baf;
 
 import java.io.BufferedInputStream;
 import java.io.IOException;
 import java.io.InputStream;
-import java.lang.ref.WeakReference;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.WeakHashMap;
 
-import org.spoofax.interpreter.terms.IStrategoAppl;
-import org.spoofax.interpreter.terms.IStrategoConstructor;
-import org.spoofax.interpreter.terms.IStrategoInt;
-import org.spoofax.interpreter.terms.IStrategoList;
-import org.spoofax.interpreter.terms.IStrategoReal;
-import org.spoofax.interpreter.terms.IStrategoString;
 import org.spoofax.interpreter.terms.IStrategoTerm;
-import org.spoofax.interpreter.terms.IStrategoTuple;
 import org.spoofax.interpreter.terms.ITermFactory;
-import org.spoofax.terms.io.AbstractIOTermFactory;
-import org.spoofax.terms.io.baf.BAFReader;
+import org.spoofax.terms.io.StreamTermReader;
 
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
  */
-public class TermFactory extends AbstractIOTermFactory implements ITermFactory {
-
-    public static final IStrategoTerm[] EMPTY = AbstractIOTermFactory.EMPTY;
-    
-    private static final int MY_STORAGE_TYPE = SHARABLE;
-    
-    // Strings should be MAXIMALLY_SHARED, but we use
-    // a weaker assumption instead to be safe (StrategoXT/834)
-    private static final int STRING_STORAGE_TYPE = SHARABLE;
-    
-    public static final int MAX_POOLED_STRING_LENGTH = 100;
-    
-    private static final IStrategoInt[] intCache = initIntCache();
-
-    /**
-     * The singleton maximally shared empty list instance.
-     * 
-     * Other empty lists may exists, but this is the only one
-     * that may be marked maximally shared.
-     */
-    public static final StrategoList EMPTY_LIST =
-    	new StrategoList(null, null, null, MAXIMALLY_SHARED); 
-
-    private static final HashMap<StrategoConstructor, StrategoConstructor> asyncCtorCache =
-        new HashMap<StrategoConstructor, StrategoConstructor>();
-    
-    // StrategoXT/801: must use weak keys and values, and must maintain maximal sharing to avoid early collection
-    private static final WeakHashMap<String, WeakReference<StrategoString>> asyncStringPool =
-        new WeakHashMap<String, WeakReference<StrategoString>>();
-    
-    @Override
-    public boolean hasConstructor(String name, int arity) {
-        synchronized (TermFactory.class) {
-        	if (arity == 0) {
-            	if (asyncStringPool.containsKey(name)) {
-            		return true;
-            	} else if (name.length() > MAX_POOLED_STRING_LENGTH) {
-            		throw new UnsupportedOperationException("String too long to be pooled (newname not allowed): " + name);
-            	} else {
-                	// HACK: pre-allocating strings to avoid race condition 
-            		asyncStringPool.put(name, new WeakReference<StrategoString>(new StrategoString(name, null, STRING_STORAGE_TYPE)));
-            		return false;
-            	}
-        	} else {
-        		// UNDONE: requires zeroary constructors to be registered in the string pool 
-        		// return asyncCtorCache.get(new StrategoConstructor(name, arity)) != null;
-        		throw new UnsupportedOperationException();
-        	}
-        }
-    }
+public class BAFStreamTermReader extends StreamTermReader {
+	
+	public BAFStreamTermReader(ITermFactory factory) {
+		super(factory);
+	}
     
-    @Override
     public IStrategoTerm parseFromStream(InputStream inputStream) throws IOException {
         /*
     	BufferedInputStream bis;
@@ -109,174 +46,10 @@
             bis = new BufferedInputStream(inputStream);
         
         if (BAFReader.isBinaryATerm(bis)) {
-            return new BAFReader(this, bis).readFromBinaryFile(true);
+            return new BAFReader(getFactory(), bis).readFromBinaryFile(true);
         } else {
             return super.parseFromStream(bis);
         }
     }
 
-    @Override
-    public IStrategoAppl makeAppl(IStrategoConstructor ctr,
-            IStrategoTerm[] terms, IStrategoList annotations) {
-    	int storageType = MY_STORAGE_TYPE;
-		storageType = min(storageType, getStorageType(terms));
-    	if (storageType != 0)
-        	storageType = min(storageType, getStorageType(annotations));
-        return new StrategoAppl(ctr, terms, annotations, storageType);
-    }
-
-    @Override
-    public StrategoConstructor makeConstructor(String name, int arity) {
-        StrategoConstructor result = new StrategoConstructor(name, arity);
-        synchronized (TermFactory.class) {
-	        StrategoConstructor cached = asyncCtorCache.get(result);
-	        if (cached == null) {
-	            asyncCtorCache.put(result, result);
-	        } else {
-	            result = cached;
-	        }
-        }
-        return result;
-    }
-
-    @Override
-    public IStrategoInt makeInt(int i) {
-    	if (0 <= i && i <= 255)
-    		return intCache[i];
-    	return new StrategoInt(i, null);
-    }
-
-    private static final IStrategoInt[] initIntCache() {
-    	IStrategoInt[] results = new IStrategoInt[256];
-    	for (int i = 0; i < results.length; i++) {
-    		results[i] = new StrategoInt(i);
-    	}
-    	return results;
-    }
-    
-    @Override
-    public IStrategoList makeList(IStrategoTerm[] terms, IStrategoList outerAnnos) {
-        StrategoList result = EMPTY_LIST;
-        int storageType = MY_STORAGE_TYPE;
-        int i = terms.length - 1;
-        while (i > 0) {
-        	IStrategoTerm head = terms[i--];
-            storageType = min(storageType, getStorageType(head));
-			result = new StrategoList(head, result, null, storageType);
-        }
-        if (i == 0) {
-        	IStrategoTerm head = terms[0];
-            storageType = min(storageType, getStorageType(head));
-			result = new StrategoList(head, result, outerAnnos, storageType);
-        } else {
-        	if (outerAnnos == null || outerAnnos.isEmpty()) {
-        		return EMPTY_LIST;
-        	} else {
-        		return new StrategoList(null, null, outerAnnos, MY_STORAGE_TYPE);
-        	}
-        }
-        return result;
-    }
-
-    @Override
-    public IStrategoList makeList(Collection<IStrategoTerm> terms) {
-        return makeList(terms.toArray(EMPTY));
-    }
-    
-    @Override
-    public IStrategoList makeListCons(IStrategoTerm head, IStrategoList tail, IStrategoList annotations) {
-    	int storageType = min(MY_STORAGE_TYPE, getStorageType(head, tail));
-    	
-    	if (head == null) return EMPTY_LIST;
-    	return new StrategoList(head, tail, annotations, storageType);
-    }
-
-    @Override
-    public IStrategoReal makeReal(double d) {
-        return new StrategoReal(d, null);
-    }
-
-    @Override
-    public IStrategoString makeString(String s) {
-    	if (s.length() > MAX_POOLED_STRING_LENGTH)
-    		return new StrategoString(s, null, MY_STORAGE_TYPE);
-    	
-    	synchronized (TermFactory.class) {
-	    	WeakReference<StrategoString> resultRef = asyncStringPool.get(s);
-	    	StrategoString result = resultRef == null ? null : resultRef.get();
-	    	if (result == null) {
-	        	result = new StrategoString(s, null, STRING_STORAGE_TYPE);
-	        	asyncStringPool.put(s, new WeakReference<StrategoString>(result));
-	    	}
-	    	return result;
-    	}
-    }
-
-    @Override
-    public IStrategoTuple makeTuple(IStrategoTerm[] terms, IStrategoList annos) {
-        int storageType = min(MY_STORAGE_TYPE, getStorageType(terms));
-		return new StrategoTuple(terms, annos, storageType);
-    }
-    
-    protected static int getStorageType(IStrategoTerm term) {
-    	return term == null ? MAXIMALLY_SHARED : term.getStorageType();
-    }
-    
-    protected static int getStorageType(IStrategoTerm term1, IStrategoTerm term2) {
-    	int result = term1.getStorageType();
-    	if (result == 0) return 0;
-    	return min(result, term2.getStorageType());
-    }
-    
-    protected static int getStorageType(IStrategoTerm[] terms) {
-    	int result = MY_STORAGE_TYPE;
-    	for (IStrategoTerm term : terms) {
-    		int type = term.getStorageType();
-    		if (type < result) { 
-        		if (type == 0) return 0;
-    			result = type;
-    		}
-    	}
-    	return result;
-    }
-    
-    @Override
-    public IStrategoTerm annotateTerm(IStrategoTerm term, IStrategoList annotations) {
-        if (term.getAnnotations() == annotations) { // cheap check
-            return term;
-        } else if (term.getStorageType() == MAXIMALLY_SHARED) {
-			if (term == EMPTY_LIST) {
-				if (annotations == EMPTY_LIST || annotations.isEmpty()) {
-					return EMPTY_LIST;
-				} else {
-					return new StrategoList(null, null, annotations, MY_STORAGE_TYPE);
-				}
-			} else if (term.getTermType() == STRING) {
-				String value = ((IStrategoString) term).stringValue();
-				if (annotations == EMPTY_LIST || annotations.isEmpty()) {
-					return makeString(value);
-				} else {
-					return new StrategoString(value, annotations, MY_STORAGE_TYPE);
-				}
-			} else if (term.getAnnotations() == EMPTY_LIST) {
-				return new StrategoAnnotation(this, term, annotations, MY_STORAGE_TYPE);
-			} else if (term instanceof StrategoAnnotation) {
-				term = ((StrategoAnnotation) term).getWrapped();
-				int storageType = min(MY_STORAGE_TYPE, getStorageType(term));
-				return new StrategoAnnotation(this, term, annotations, storageType);
-			} else {
-				throw new UnsupportedOperationException("Unable to annotate term of type " + term.getClass().getName());
-			}
-        } else if ((annotations == EMPTY_LIST || annotations.isEmpty()) && term.getTermType() == STRING) {
-    		return makeString(((IStrategoString) term).stringValue());
-        } else if (term instanceof StrategoTerm) {
-        	StrategoTerm result = ((StrategoTerm) term).clone();
-    	    result.internalSetAnnotations(annotations);
-    	    assert result.getStorageType() != MAXIMALLY_SHARED;
-    	    return result;
-    	} else {
-            throw new UnsupportedOperationException("Unable to annotate term of type " + term.getClass().getName() + " in " + getClass().getName());
-        }
-    }
-
 }

Modified: strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/HybridInterpreter.java
==============================================================================
--- strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/HybridInterpreter.java	Tue Dec 28 14:15:54 2010	(r21590)
+++ strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/HybridInterpreter.java	Tue Dec 28 15:31:36 2010	(r21591)
@@ -26,6 +26,7 @@
 import org.spoofax.interpreter.terms.IStrategoString;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.ITermFactory;
+import org.spoofax.terms.TermFactory;
 import org.strategoxt.lang.Context;
 import org.strategoxt.lang.InteropRegisterer;
 import org.strategoxt.lang.InteropSDefT;
@@ -33,7 +34,6 @@
 import org.strategoxt.lang.StrategoErrorExit;
 import org.strategoxt.lang.StrategoException;
 import org.strategoxt.lang.StrategoExit;
-import org.strategoxt.lang.terms.TermFactory;
 
 /**
  * An interpreter that uses STRJ-compiled versions of the Stratego standard libraries.

Modified: strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/Context.java
==============================================================================
--- strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/Context.java	Tue Dec 28 14:15:54 2010	(r21590)
+++ strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/Context.java	Tue Dec 28 15:31:36 2010	(r21591)
@@ -22,9 +22,9 @@
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.ITermFactory;
+import org.spoofax.terms.TermFactory;
 import org.strategoxt.lang.compat.CompatManager;
 import org.strategoxt.lang.compat.SSL_EXT_java_call;
-import org.strategoxt.lang.terms.TermFactory;
 
 /**
  * The runtime context of a compiled Stratego strategy.

Modified: strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/ImportTerm.java
==============================================================================
--- strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/ImportTerm.java	Tue Dec 28 14:15:54 2010	(r21590)
+++ strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/ImportTerm.java	Tue Dec 28 15:31:36 2010	(r21591)
@@ -10,7 +10,7 @@
 import org.spoofax.interpreter.adapter.aterm.ATermConverter;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.ITermFactory;
-import org.strategoxt.lang.terms.LazyTerm;
+import org.spoofax.terms.LazyTerm;
 
 import aterm.ATerm;
 import aterm.ATermFactory;
@@ -63,7 +63,7 @@
 		
 		InputStream stream = openStream();
 		try {
-			IStrategoTerm result = ((org.spoofax.terms.io.ITermFactory) factory).parseFromStream(stream);
+			IStrategoTerm result = ((org.spoofax.interpreter.terms.io.IFileTermFactory) factory).parseFromStream(stream);
 			return result;
 		} catch (java.io.IOException e) {
 			throw new StrategoException(container.getSimpleName()

Modified: strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/SRTS_EXT_newint_0_0.java
==============================================================================
--- strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/SRTS_EXT_newint_0_0.java	Tue Dec 28 14:15:54 2010	(r21590)
+++ strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/SRTS_EXT_newint_0_0.java	Tue Dec 28 15:31:36 2010	(r21591)
@@ -6,7 +6,7 @@
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.ITermPrinter;
-import org.strategoxt.lang.terms.TermFactory;
+import org.spoofax.terms.TermFactory;
 
 /**
  * @author Lennart Kats <lennart add lclnet.nl>

Modified: strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/Term.java
==============================================================================
--- strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/Term.java	Tue Dec 28 14:15:54 2010	(r21590)
+++ strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/Term.java	Tue Dec 28 15:31:36 2010	(r21591)
@@ -3,7 +3,7 @@
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.ITermFactory;
-import org.strategoxt.lang.terms.TermFactory;
+import org.spoofax.terms.TermFactory;
 
 public class Term {
 	

From L.C.L.Kats at tudelft.nl  Tue Dec 28 17:57:18 2010
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Tue, 28 Dec 2010 16:57:18 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21592 - in
	spoofax/branches/spoofax-new-terms/spoofax:
	org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/core
	org.spoofax.interpreter.core/src/java/org/spoofax...
Message-ID: <201012281657.oBSGvIcZ005560@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: Tue Dec 28 16:57:17 2010
New Revision: 21592
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21592&sc=1

Log:
refactoring

Added:
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/PushbackStringIterator.java
      - copied, changed from r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/PushbackStringIterator.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StringTermReader.java
      - copied, changed from r21591, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/StreamTermReader.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/TermReader.java
      - copied, changed from r21591, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/StreamTermReader.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/baf/BAFTermReader.java
      - copied, changed from r21591, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/baf/BAFStreamTermReader.java
Deleted:
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/PushbackStringIterator.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/legacy-src/
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/INonIOTermFactory.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/StreamTermReader.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/baf/BAFStreamTermReader.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/strategoxt/
Modified:
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/core/Interpreter.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/core/StrategoCoreLoader.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_read_term_from_stream.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_write_term_to_stream_baf.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_write_term_to_stream_saf.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_write_term_to_stream_taf.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_write_term_to_stream_text.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/ImportTerm.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLR_parse_string_pt.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/.classpath
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/META-INF/MANIFEST.MF
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/SGLR.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/shared/terms/ATermFactory.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/META-INF/MANIFEST.MF
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/ITermFactory.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/ParseError.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/AbstractTermFactory.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/AbstractIOTermFactory.java

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/core/Interpreter.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/core/Interpreter.java	Tue Dec 28 15:31:36 2010	(r21591)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/core/Interpreter.java	Tue Dec 28 16:57:17 2010	(r21592)
@@ -8,17 +8,18 @@
  */
 package org.spoofax.interpreter.core;
 
-import java.io.IOException;
-import java.io.InputStream;
-
-import org.spoofax.interpreter.library.IOAgent;
-import org.spoofax.interpreter.library.IOperatorRegistry;
-import org.spoofax.interpreter.library.ssl.SSLLibrary;
-import org.spoofax.interpreter.stratego.SDefT;
-import org.spoofax.interpreter.stratego.StupidFormatter;
-import org.spoofax.interpreter.terms.IStrategoTerm;
-import org.spoofax.interpreter.terms.ITermFactory;
-import org.spoofax.terms.io.AbstractIOTermFactory;
+import java.io.IOException;
+import java.io.InputStream;
+
+import org.spoofax.interpreter.library.IOAgent;
+import org.spoofax.interpreter.library.IOperatorRegistry;
+import org.spoofax.interpreter.library.ssl.SSLLibrary;
+import org.spoofax.interpreter.stratego.SDefT;
+import org.spoofax.interpreter.stratego.StupidFormatter;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.ITermFactory;
+import org.spoofax.terms.TermFactory;
+import org.spoofax.terms.io.baf.BAFTermReader;
 
 public class Interpreter {
 
@@ -26,7 +27,7 @@
     private final StrategoCoreLoader loader;
 
     public Interpreter() {
-        this(new AbstractIOTermFactory());
+        this(new TermFactory());
     }
 
     public Interpreter(ITermFactory factory) {
@@ -167,11 +168,11 @@
         if (stream == null)
             throw new IOException("Could not load Stratego core input from null stream");
             
-       load(context.getProgramFactory().parseFromStream(stream));
+       load(new BAFTermReader(context.getProgramFactory()).parseFromStream(stream));
     }
     
     public final void load(String file) throws IOException, InterpreterException {
-        load(context.getProgramFactory().parseFromFile(file));
+        load(new BAFTermReader(context.getProgramFactory()).parseFromFile(file));
     }
 
 	public void load(IStrategoTerm term) throws InterpreterException {

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/core/StrategoCoreLoader.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/core/StrategoCoreLoader.java	Tue Dec 28 15:31:36 2010	(r21591)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/core/StrategoCoreLoader.java	Tue Dec 28 16:57:17 2010	(r21592)
@@ -41,6 +41,7 @@
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoString;
 import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.terms.io.baf.BAFTermReader;
 
 public class StrategoCoreLoader {
 
@@ -365,7 +366,7 @@
     
     @Deprecated
     public void load(String path) throws IOException, InterpreterException {
-        doLoad(context.getProgramFactory().parseFromFile(path));
+        doLoad(new BAFTermReader(context.getProgramFactory()).parseFromFile(path));
     }
     
     public void load(IStrategoTerm prg) throws InterpreterException {
@@ -425,7 +426,7 @@
         if (stream == null)
             throw new IOException("Could not load Stratego core input from null stream");
             
-        doLoad(context.getProgramFactory().parseFromStream(stream));
+        doLoad(new BAFTermReader(context.getProgramFactory()).parseFromStream(stream));
     }
 
 }

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_read_term_from_stream.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_read_term_from_stream.java	Tue Dec 28 15:31:36 2010	(r21591)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_read_term_from_stream.java	Tue Dec 28 16:57:17 2010	(r21592)
@@ -16,6 +16,7 @@
 import org.spoofax.interpreter.library.AbstractPrimitive;
 import org.spoofax.interpreter.stratego.Strategy;
 import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.terms.io.baf.BAFTermReader;
 
 public class SSL_read_term_from_stream extends AbstractPrimitive {
 
@@ -45,7 +46,7 @@
             return false;
 
         try {
-            env.setCurrent(env.getFactory().parseFromStream(is));
+            env.setCurrent(new BAFTermReader(env.getFactory()).parseFromStream(is));
         } catch(IOException e) {
             or.getIOAgent().printError("SSL_read_term_from_stream: " + e.getMessage());
             return false;

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_write_term_to_stream_baf.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_write_term_to_stream_baf.java	Tue Dec 28 15:31:36 2010	(r21591)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_write_term_to_stream_baf.java	Tue Dec 28 16:57:17 2010	(r21592)
@@ -16,6 +16,7 @@
 import org.spoofax.interpreter.library.AbstractPrimitive;
 import org.spoofax.interpreter.stratego.Strategy;
 import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.terms.io.baf.BAFTermReader;
 
 public class SSL_write_term_to_stream_baf extends AbstractPrimitive {
 
@@ -38,7 +39,7 @@
             return false;
         
         try {
-            env.getFactory().unparseToFile(targs[1], out);
+            new BAFTermReader(env.getFactory()).unparseToFile(targs[1], out);
             out.flush();
         } catch(IOException e) {
             throw new InterpreterException(e);

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_write_term_to_stream_saf.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_write_term_to_stream_saf.java	Tue Dec 28 15:31:36 2010	(r21591)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_write_term_to_stream_saf.java	Tue Dec 28 16:57:17 2010	(r21592)
@@ -16,6 +16,7 @@
 import org.spoofax.interpreter.library.AbstractPrimitive;
 import org.spoofax.interpreter.stratego.Strategy;
 import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.terms.io.baf.BAFTermReader;
 
 public class SSL_write_term_to_stream_saf extends AbstractPrimitive {
 
@@ -38,7 +39,7 @@
             return false;
         
         try {
-            env.getFactory().unparseToFile(targs[1], out);
+            new BAFTermReader(env.getFactory()).unparseToFile(targs[1], out);
             out.flush();
         } catch(IOException e) {
             throw new InterpreterException(e);

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_write_term_to_stream_taf.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_write_term_to_stream_taf.java	Tue Dec 28 15:31:36 2010	(r21591)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_write_term_to_stream_taf.java	Tue Dec 28 16:57:17 2010	(r21592)
@@ -16,6 +16,7 @@
 import org.spoofax.interpreter.library.AbstractPrimitive;
 import org.spoofax.interpreter.stratego.Strategy;
 import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.terms.io.baf.BAFTermReader;
 
 public class SSL_write_term_to_stream_taf extends AbstractPrimitive {
 
@@ -35,7 +36,7 @@
             return false;
         
         try {
-            env.getFactory().unparseToFile(targs[1], out);
+            new BAFTermReader(env.getFactory()).unparseToFile(targs[1], out);
             out.flush();
         } catch(IOException e) {
             throw new InterpreterException(e);

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_write_term_to_stream_text.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_write_term_to_stream_text.java	Tue Dec 28 15:31:36 2010	(r21591)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_write_term_to_stream_text.java	Tue Dec 28 16:57:17 2010	(r21592)
@@ -16,6 +16,7 @@
 import org.spoofax.interpreter.library.AbstractPrimitive;
 import org.spoofax.interpreter.stratego.Strategy;
 import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.terms.io.baf.BAFTermReader;
 
 public class SSL_write_term_to_stream_text extends AbstractPrimitive {
 
@@ -35,7 +36,7 @@
             return false;
         
         try {
-            env.getFactory().unparseToFile(targs[1],out);
+            new BAFTermReader(env.getFactory()).unparseToFile(targs[1],out);
             out.flush();
         } catch(IOException e) {
             throw new InterpreterException(e);

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/ImportTerm.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/ImportTerm.java	Tue Dec 28 15:31:36 2010	(r21591)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/ImportTerm.java	Tue Dec 28 16:57:17 2010	(r21592)
@@ -16,6 +16,7 @@
 import org.spoofax.interpreter.library.IOAgent;
 import org.spoofax.interpreter.library.ssl.SSLLibrary;
 import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.terms.io.baf.BAFTermReader;
 
 public class ImportTerm extends Strategy {
 
@@ -36,7 +37,7 @@
                 IOAgent io = op.getIOAgent();
 
                 input = io.openInputStream(path, true);
-                result = env.getFactory().parseFromStream(input);
+                result = new BAFTermReader(env.getFactory()).parseFromStream(input);
             } catch (IOException e) {
                 throw new InterpreterException("import-term failed for " + path, e);
             } catch (RuntimeException e) {

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLR_parse_string_pt.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLR_parse_string_pt.java	Tue Dec 28 15:31:36 2010	(r21591)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLR_parse_string_pt.java	Tue Dec 28 16:57:17 2010	(r21592)
@@ -15,8 +15,8 @@
 import org.spoofax.interpreter.terms.IStrategoString;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.jsglr.client.ParseTable;
-import org.spoofax.jsglr.SGLR;
-import org.spoofax.jsglr.SGLRException;
+import org.spoofax.jsglr.client.SGLR;
+import org.spoofax.jsglr.shared.SGLRException;
 
 import aterm.ATerm;
 import aterm.ATermFactory;
@@ -104,7 +104,7 @@
 		
 		SGLR parser = new SGLR(atermFactory, table);
 		
-		ATerm resultATerm = parser.parse(input.stringValue(), startSymbol);
+		ATerm resultATerm = (ATerm) parser.parse(input.stringValue(), startSymbol);
 		IStrategoTerm result = getATermConverter(env).convert(resultATerm);
 		
 		return result;

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/.classpath
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/.classpath	Tue Dec 28 15:31:36 2010	(r21591)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/.classpath	Tue Dec 28 16:57:17 2010	(r21592)
@@ -1,9 +1,11 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
 	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" output="test-classes" path="test"/>
+	<classpathentry kind="src" path="test"/>
 	<classpathentry kind="con" path="com.google.gwt.eclipse.core.GWT_CONTAINER"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/3"/>
-	<classpathentry kind="output" path="war/WEB-INF/classes"/>
+	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/org.spoofax.terms"/>
+	<classpathentry kind="output" path="bin"/>
 </classpath>

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/META-INF/MANIFEST.MF
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/META-INF/MANIFEST.MF	Tue Dec 28 15:31:36 2010	(r21591)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/META-INF/MANIFEST.MF	Tue Dec 28 16:57:17 2010	(r21592)
@@ -11,7 +11,7 @@
  org.spoofax.jsglr.shared,
  org.spoofax.jsglr.shared.terms
 Bundle-Vendor: Spoofax.org
-Require-Bundle: org.spoofax.aterm,
- org.junit,
- org.spoofax.interpreter.core
+Require-Bundle: org.junit,
+ org.spoofax.interpreter.core,
+ org.spoofax.terms
 Bundle-RequiredExecutionEnvironment: J2SE-1.5

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/SGLR.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/SGLR.java	Tue Dec 28 15:31:36 2010	(r21591)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/SGLR.java	Tue Dec 28 16:57:17 2010	(r21592)
@@ -13,6 +13,7 @@
 import java.util.Queue;
 import java.util.Set;
 
+import org.spoofax.PushbackStringIterator;
 import org.spoofax.jsglr.shared.ArrayDeque;
 import org.spoofax.jsglr.shared.BadTokenException;
 import org.spoofax.jsglr.shared.SGLRException;

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/shared/terms/ATermFactory.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/shared/terms/ATermFactory.java	Tue Dec 28 15:31:36 2010	(r21591)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/shared/terms/ATermFactory.java	Tue Dec 28 16:57:17 2010	(r21592)
@@ -6,8 +6,8 @@
 import java.util.HashMap;
 import java.util.List;
 
+import org.spoofax.PushbackStringIterator;
 import org.spoofax.jsglr.client.NotImplementedException;
-import org.spoofax.jsglr.client.PushbackStringIterator;
 
 public class ATermFactory implements Serializable {
 

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/META-INF/MANIFEST.MF
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/META-INF/MANIFEST.MF	Tue Dec 28 15:31:36 2010	(r21591)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/META-INF/MANIFEST.MF	Tue Dec 28 16:57:17 2010	(r21592)
@@ -9,4 +9,3 @@
  org.spoofax.terms,
  org.spoofax.terms.io,
  org.spoofax.terms.io.baf
- 
\ No newline at end of file

Copied and modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/PushbackStringIterator.java (from r21590, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/PushbackStringIterator.java)
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/PushbackStringIterator.java	Tue Dec 28 14:15:54 2010	(r21590, copy source)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/PushbackStringIterator.java	Tue Dec 28 16:57:17 2010	(r21592)
@@ -1,4 +1,4 @@
-package org.spoofax.jsglr.client;
+package org.spoofax;
 
 public class PushbackStringIterator {
 

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/ITermFactory.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/ITermFactory.java	Tue Dec 28 15:31:36 2010	(r21591)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/ITermFactory.java	Tue Dec 28 16:57:17 2010	(r21592)
@@ -7,11 +7,21 @@
  */
 package org.spoofax.interpreter.terms;
 
+import org.spoofax.terms.io.TermReader;
 
-
-
+/**
+ * 
+ * @author Karl T. Kalleberg <karltk add strategoxt.org>
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
 public interface ITermFactory extends IStrategoTermBuilder {
     
+	/**
+	 * Parses a term from a string.
+	 * 
+	 * @see TermReader#parseFromStream(java.io.InputStream)
+	 * @see TermReader#parseFromFile(String)
+	 */
     public IStrategoTerm parseFromString(String text);
 
     public IStrategoAppl replaceAppl(IStrategoConstructor constructor, IStrategoTerm[] kids, IStrategoAppl old);

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/ParseError.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/ParseError.java	Tue Dec 28 15:31:36 2010	(r21591)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/ParseError.java	Tue Dec 28 16:57:17 2010	(r21592)
@@ -1,22 +1,10 @@
-/*
- * Created on 28. jan.. 2007
- *
- * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
- * 
- * Licensed under the GNU General Public License, v2
- */
 package org.spoofax.interpreter.terms;
 
 public class ParseError extends RuntimeException {
 
-    private static final long serialVersionUID = 7598516227302756592L;
-    private final String msg; 
-    public ParseError(String msg) {
-        this.msg = msg;
-    }
+	private static final long serialVersionUID = 7598516227302756592L;
 
-    @Override
-    public String getMessage() {
-        return msg;
+	public ParseError(String m) {
+        super(m);
     }
 }

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/AbstractTermFactory.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/AbstractTermFactory.java	Tue Dec 28 15:31:36 2010	(r21591)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/AbstractTermFactory.java	Tue Dec 28 16:57:17 2010	(r21592)
@@ -1,45 +1,22 @@
 package org.spoofax.terms;
 
-import java.io.BufferedInputStream;
-import java.io.BufferedWriter;
-import java.io.ByteArrayInputStream;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.io.OutputStreamWriter;
-import java.io.PushbackInputStream;
-import java.io.Writer;
-import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.WeakHashMap;
 
-import org.spoofax.NotImplementedException;
 import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoConstructor;
-import org.spoofax.interpreter.terms.IStrategoInt;
 import org.spoofax.interpreter.terms.IStrategoList;
-import org.spoofax.interpreter.terms.IStrategoPlaceholder;
-import org.spoofax.interpreter.terms.IStrategoReal;
-import org.spoofax.interpreter.terms.IStrategoString;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.IStrategoTuple;
 import org.spoofax.interpreter.terms.ITermFactory;
-import org.spoofax.interpreter.terms.ITermPrinter;
-import org.spoofax.interpreter.terms.ParseError;
-import org.spoofax.terms.io.AbstractIOTermFactory;
 
 public abstract class AbstractTermFactory implements ITermFactory {
 
 	public static final IStrategoList EMPTY_LIST = new StrategoList(null, null, null, IStrategoTerm.MAXIMALLY_SHARED);
 
     public static final IStrategoTerm[] EMPTY = new IStrategoTerm[0];
+    
+    private final StringTermReader reader = new StringTermReader(this);
 
     private static final HashMap<StrategoConstructor, StrategoConstructor> asyncCtorCache =
         new HashMap<StrategoConstructor, StrategoConstructor>();

Copied and modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StringTermReader.java (from r21591, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/StreamTermReader.java)
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/StreamTermReader.java	Tue Dec 28 15:31:36 2010	(r21591, copy source)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StringTermReader.java	Tue Dec 28 16:57:17 2010	(r21592)
@@ -5,73 +5,40 @@
  * 
  * Licensed under the GNU General Public License, v2
  */
-package org.spoofax.terms.io;
+package org.spoofax.terms;
 
-import java.io.BufferedInputStream;
-import java.io.BufferedWriter;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.io.OutputStreamWriter;
-import java.io.PushbackInputStream;
-import java.io.Writer;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 
 import org.spoofax.NotImplementedException;
+import org.spoofax.PushbackStringIterator;
 import org.spoofax.interpreter.terms.IStrategoConstructor;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.ITermFactory;
-import org.spoofax.interpreter.terms.ITermPrinter;
 import org.spoofax.interpreter.terms.ParseError;
-import org.spoofax.terms.AbstractTermFactory;
 
-public class StreamTermReader {
+/**
+ * @author Karl T. Kalleberg <karltk add strategoxt.org>
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class StringTermReader {
 
-	private final ITermFactory factory;
+	protected final ITermFactory factory;
 	
-    public StreamTermReader(ITermFactory factory) {
+    public StringTermReader(ITermFactory factory) {
     	this.factory = factory;
     }
     
     public ITermFactory getFactory() {
 		return factory;
 	}
-    
-    public IStrategoTerm parseFromFile(String path) throws IOException {
-        InputStream stream = new FileInputStream(path);
-        try {
-            return parseFromStream(stream);
-        } finally {
-            stream.close();
-        }
-    }
 
-    public IStrategoTerm parseFromStream(InputStream inputStream) throws IOException {
-        /*
-        PushbackInputStream pushbackStream;
-        
-        if (inputStream instanceof FileInputStream) {
-            FileChannel channel = ((FileInputStream)inputStream).getChannel();
-            pushbackStream = new ChannelPushbackInputStream(channel);
-        } else {
-            if (!(inputStream instanceof BufferedInputStream) && !(inputStream instanceof ChannelPushbackInputStream))
-                inputStream = new BufferedInputStream(inputStream);
-            pushbackStream = new PushbackInputStream(inputStream);
-        }
-        
-        return parseFromStream(pushbackStream);
-        */
-        if (!(inputStream instanceof BufferedInputStream))
-            inputStream = new BufferedInputStream(inputStream);
-        PushbackInputStream bis = new PushbackInputStream(inputStream);
-        
-        return parseFromStream(bis);
+    public IStrategoTerm parseFromString(String s) throws ParseError {
+        return parseFromString(new PushbackStringIterator(s));
     }
 
-    protected IStrategoTerm parseFromStream(PushbackInputStream bis) throws IOException {
+    protected IStrategoTerm parseFromString(PushbackStringIterator bis) throws ParseError {
         parseSkip(bis);
         final int ch = bis.read();
         switch(ch) {
@@ -90,7 +57,7 @@
         throw new ParseError("Invalid term: '" + (char)ch + "'");
     }
     
-    private IStrategoTerm parseAnno(PushbackInputStream bis, IStrategoTerm term) throws IOException {
+    private IStrategoTerm parseAnno(PushbackStringIterator bis, IStrategoTerm term) throws ParseError {
         parseSkip(bis);
         final int ch = bis.read();
         if (ch == '{') {
@@ -102,7 +69,7 @@
         }
     }
 
-    private IStrategoTerm parseString(PushbackInputStream bis) throws IOException {
+    private IStrategoTerm parseString(PushbackStringIterator bis) throws ParseError {
         int ch = bis.read();
         if(ch == '"')
             return factory.makeString("");
@@ -165,7 +132,7 @@
         return factory.makeString(sb.toString());
     }
 
-    private IStrategoTerm parseAppl(PushbackInputStream bis) throws IOException {
+    private IStrategoTerm parseAppl(PushbackStringIterator bis) throws ParseError {
         //System.err.println("appl");
         // TODO: share stringbuilder instances?
         StringBuilder sb = new StringBuilder();
@@ -196,20 +163,20 @@
         }
     }
     
-    private IStrategoTerm parsePlaceholder(PushbackInputStream bis) throws IOException {
-        IStrategoTerm template = parseFromStream(bis);
+    private IStrategoTerm parsePlaceholder(PushbackStringIterator bis) throws ParseError {
+        IStrategoTerm template = parseFromString(bis);
         parseSkip(bis);
         if (bis.read() != '>')
             throw new ParseError("Expected: '>'");
         return factory.makePlaceholder(template);
     }
 
-    private IStrategoTerm parseTuple(PushbackInputStream bis) throws IOException {
+    private IStrategoTerm parseTuple(PushbackStringIterator bis) throws ParseError {
         //System.err.println("tuple");
         return factory.makeTuple(parseTermSequence(bis, ')').toArray(AbstractTermFactory.EMPTY));
     }
 
-    private List<IStrategoTerm> parseTermSequence(PushbackInputStream bis, char endChar) throws IOException {
+    private List<IStrategoTerm> parseTermSequence(PushbackStringIterator bis, char endChar) throws ParseError {
         //System.err.println("sequence");
         List<IStrategoTerm> els = Collections.emptyList();
         parseSkip(bis);
@@ -219,7 +186,7 @@
         els = new ArrayList<IStrategoTerm>();
         bis.unread(ch);
         do {
-            els.add(parseFromStream(bis));
+            els.add(parseFromString(bis));
             parseSkip(bis);
             ch = bis.read();
         } while(ch == ',');
@@ -236,12 +203,12 @@
         return els;
     }
 
-    private IStrategoTerm parseList(PushbackInputStream bis) throws IOException {
+    private IStrategoTerm parseList(PushbackStringIterator bis) throws ParseError {
         //System.err.println("list");
         return factory.makeList(parseTermSequence(bis, ']'));
     }
 
-    private IStrategoTerm parseNumber(PushbackInputStream bis) throws IOException {
+    private IStrategoTerm parseNumber(PushbackStringIterator bis) throws ParseError {
         //System.err.println("number");
         String whole = parseDigitSequence(bis);
         
@@ -262,7 +229,7 @@
         return factory.makeInt(Integer.parseInt(whole));
     }
 
-    private String parseDigitSequence(PushbackInputStream bis) throws IOException {
+    private String parseDigitSequence(PushbackStringIterator bis) throws ParseError {
         StringBuilder sb = new StringBuilder();
         int ch = bis.read();
         do {
@@ -273,7 +240,7 @@
         return sb.toString(); 
     }
     
-    private void parseSkip(PushbackInputStream input) throws IOException {
+    private void parseSkip(PushbackStringIterator input) throws ParseError {
         for (;;) {
             int b = input.read();
             switch (b) {
@@ -286,14 +253,4 @@
         }
     }
 
-    public void unparseToFile(IStrategoTerm t, OutputStream ous) throws IOException {
-        Writer out = new BufferedWriter(new OutputStreamWriter(ous));
-        unparseToFile(t, out);
-    }
-
-    public void unparseToFile(IStrategoTerm t, Writer out) throws IOException {
-        ITermPrinter tp = new InlineWriter(out);
-        t.prettyPrint(tp);
-    }
-
 }

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/AbstractIOTermFactory.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/AbstractIOTermFactory.java	Tue Dec 28 15:31:36 2010	(r21591)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/AbstractIOTermFactory.java	Tue Dec 28 16:57:17 2010	(r21592)
@@ -19,9 +19,10 @@
 import org.spoofax.interpreter.terms.io.IFileTermFactory;
 import org.spoofax.terms.AbstractTermFactory;
 
+ at Deprecated
 public abstract class AbstractIOTermFactory extends AbstractTermFactory implements IFileTermFactory {
 	
-	private final StreamTermReader reader = new StreamTermReader(this);
+	private final TermReader reader = new TermReader(this);
 
     public IStrategoTerm parseFromStream(InputStream inputStream) throws IOException {
         return reader.parseFromStream(inputStream);

Copied and modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/TermReader.java (from r21591, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/StreamTermReader.java)
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/StreamTermReader.java	Tue Dec 28 15:31:36 2010	(r21591, copy source)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/TermReader.java	Tue Dec 28 16:57:17 2010	(r21592)
@@ -27,19 +27,14 @@
 import org.spoofax.interpreter.terms.ITermPrinter;
 import org.spoofax.interpreter.terms.ParseError;
 import org.spoofax.terms.AbstractTermFactory;
+import org.spoofax.terms.StringTermReader;
 
-public class StreamTermReader {
-
-	private final ITermFactory factory;
+public class TermReader extends StringTermReader {
 	
-    public StreamTermReader(ITermFactory factory) {
-    	this.factory = factory;
+    public TermReader(ITermFactory factory) {
+    	super(factory);
     }
     
-    public ITermFactory getFactory() {
-		return factory;
-	}
-    
     public IStrategoTerm parseFromFile(String path) throws IOException {
         InputStream stream = new FileInputStream(path);
         try {

Copied and modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/baf/BAFTermReader.java (from r21591, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/baf/BAFStreamTermReader.java)
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/baf/BAFStreamTermReader.java	Tue Dec 28 15:31:36 2010	(r21591, copy source)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/baf/BAFTermReader.java	Tue Dec 28 16:57:17 2010	(r21592)
@@ -6,14 +6,14 @@
 
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.ITermFactory;
-import org.spoofax.terms.io.StreamTermReader;
+import org.spoofax.terms.io.TermReader;
 
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
  */
-public class BAFStreamTermReader extends StreamTermReader {
+public class BAFTermReader extends TermReader {
 	
-	public BAFStreamTermReader(ITermFactory factory) {
+	public BAFTermReader(ITermFactory factory) {
 		super(factory);
 	}
     

From L.C.L.Kats at tudelft.nl  Tue Dec 28 18:13:50 2010
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Tue, 28 Dec 2010 17:13:50 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21593 - in
	spoofax/branches/spoofax-new-terms/spoofax:
	org.spoofax.compiler/META-INF
	org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl
	org.spoofax....
Message-ID: <201012281713.oBSHDoLL009358@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: Tue Dec 28 17:13:49 2010
New Revision: 21593
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21593&sc=1

Log:
added support for "term attachments"

Added:
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/AbstractTermAttachment.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/ITermAttachment.java
Modified:
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.compiler/META-INF/MANIFEST.MF
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/StrategoHashMap.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/StrategoSet.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter/META-INF/MANIFEST.MF
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/IStrategoTerm.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/LazyTerm.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoTerm.java

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.compiler/META-INF/MANIFEST.MF
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.compiler/META-INF/MANIFEST.MF	Tue Dec 28 16:57:17 2010	(r21592)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.compiler/META-INF/MANIFEST.MF	Tue Dec 28 17:13:49 2010	(r21593)
@@ -6,7 +6,7 @@
 Bundle-Vendor: Spoofax.org
 Require-Bundle: org.spoofax.interpreter.core,
  org.spoofax.interpreter.library.jsglr,
- org.spoofax.jsglr,
+ org.spoofax.jsglr;bundle-version="0.3.0",
  org.spoofax.interpreter.adapter.aterm,
  org.junit,
  org.spoofax.terms

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/StrategoHashMap.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/StrategoHashMap.java	Tue Dec 28 16:57:17 2010	(r21592)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/StrategoHashMap.java	Tue Dec 28 17:13:49 2010	(r21593)
@@ -4,8 +4,9 @@
 
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.ITermAttachment;
 import org.spoofax.interpreter.terms.ITermPrinter;
-import org.spoofax.terms.io.AbstractIOTermFactory;
+import org.spoofax.terms.AbstractTermFactory;
 
 public class StrategoHashMap extends LinkedHashMap<IStrategoTerm, IStrategoTerm> implements IStrategoTerm {
 
@@ -16,7 +17,7 @@
     }
 
     public IStrategoTerm[] getAllSubterms() {
-        return AbstractIOTermFactory.EMPTY;
+        return AbstractTermFactory.EMPTY;
     }
 
     public IStrategoList getAnnotations() {
@@ -55,5 +56,13 @@
     public String toString() {
         return String.valueOf(hashCode());
     }
+    
+    public <T extends ITermAttachment> T getAttachment(Class<T> attachment) {
+        throw new UnsupportedOperationException();
+    }
+    
+    public void addAttachment(ITermAttachment attachment) {
+        throw new UnsupportedOperationException();
+    }
 
 }

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/StrategoSet.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/StrategoSet.java	Tue Dec 28 16:57:17 2010	(r21592)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/StrategoSet.java	Tue Dec 28 17:13:49 2010	(r21593)
@@ -14,13 +14,14 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
 import java.util.Map.Entry;
+import java.util.Set;
 
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.ITermAttachment;
 import org.spoofax.interpreter.terms.ITermPrinter;
-import org.spoofax.terms.io.AbstractIOTermFactory;
+import org.spoofax.terms.AbstractTermFactory;
 
 public class StrategoSet implements IStrategoTerm, Serializable {
         
@@ -98,7 +99,7 @@
     }
 
     public IStrategoTerm[] getAllSubterms() {
-        return AbstractIOTermFactory.EMPTY;
+        return AbstractTermFactory.EMPTY;
     }
 
     public IStrategoList getAnnotations() {
@@ -137,4 +138,13 @@
     public String toString() {
         return String.valueOf(hashCode());
     }
+    
+    public <T extends ITermAttachment> T getAttachment(Class<T> attachment) {
+        throw new UnsupportedOperationException();
+    }
+    
+    public void addAttachment(ITermAttachment attachment) {
+        throw new UnsupportedOperationException();
+    }
+
 }

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter/META-INF/MANIFEST.MF
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter/META-INF/MANIFEST.MF	Tue Dec 28 16:57:17 2010	(r21592)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter/META-INF/MANIFEST.MF	Tue Dec 28 17:13:49 2010	(r21593)
@@ -7,9 +7,10 @@
 Require-Bundle: org.junit,
  org.spoofax.interpreter.core,
  org.spoofax.compiler,
- org.spoofax.jsglr,
+ org.spoofax.jsglr;bundle-version="0.3.0",
  org.spoofax.aterm,
- org.spoofax.interpreter.adapter.aterm
+ org.spoofax.interpreter.adapter.aterm,
+ org.spoofax.terms
 Export-Package: org.spoofax.interpreter
 Eclipse-LazyStart: true
 Bundle-Vendor: Spoofax.org

Added: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/AbstractTermAttachment.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/AbstractTermAttachment.java	Tue Dec 28 17:13:49 2010	(r21593)
@@ -0,0 +1,28 @@
+package org.spoofax.interpreter.terms;
+
+public abstract class AbstractTermAttachment implements ITermAttachment {
+	
+	private ITermAttachment next;
+	
+	protected abstract boolean isAttachmentType(Class<?> type);
+
+	@SuppressWarnings("unchecked")
+	public <T extends ITermAttachment> T tryGetAttachment(Class<T> type) {
+		if (isAttachmentType(type)) {
+			return (T) this;
+		} else if (next != null) {
+			return next.tryGetAttachment(type);
+		} else {
+			return null;
+		}
+	}
+
+	public void addAttachment(ITermAttachment attachment) {
+		if (next != null) {
+			next = attachment;
+		} else {
+			next.addAttachment(attachment);
+		}
+	}
+
+}

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/IStrategoTerm.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/IStrategoTerm.java	Tue Dec 28 16:57:17 2010	(r21592)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/IStrategoTerm.java	Tue Dec 28 17:13:49 2010	(r21593)
@@ -56,4 +56,8 @@
     public boolean match(IStrategoTerm second);
     
     public void prettyPrint(ITermPrinter pp);
+    
+    public<T extends ITermAttachment> T getAttachment(Class<T> attachment);
+    
+    public void addAttachment(ITermAttachment attachment);
 }

Added: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/ITermAttachment.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/ITermAttachment.java	Tue Dec 28 17:13:49 2010	(r21593)
@@ -0,0 +1,7 @@
+package org.spoofax.interpreter.terms;
+
+public interface ITermAttachment {
+	<T extends ITermAttachment> T tryGetAttachment(Class<T> type);
+	
+	void addAttachment(ITermAttachment attachment);
+}

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/LazyTerm.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/LazyTerm.java	Tue Dec 28 16:57:17 2010	(r21592)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/LazyTerm.java	Tue Dec 28 17:13:49 2010	(r21593)
@@ -15,7 +15,7 @@
  */
 public abstract class LazyTerm implements IStrategoAppl, IStrategoInt, IStrategoList, IStrategoReal, IStrategoString, IStrategoTuple {
 
-	// TODO: base class should be StrategoWrapped :o
+	// TODO: base class should be StrategoWrapped, or vice versa :o
 	
 	private IStrategoTerm term;
 	

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoTerm.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoTerm.java	Tue Dec 28 16:57:17 2010	(r21592)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoTerm.java	Tue Dec 28 17:13:49 2010	(r21593)
@@ -9,6 +9,7 @@
 
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.ITermAttachment;
 import org.spoofax.interpreter.terms.ITermPrinter;
 
 import static org.spoofax.terms.TermFactory.EMPTY_LIST;
@@ -23,6 +24,8 @@
 
     private IStrategoList annotations;
     
+    private ITermAttachment attachment;
+    
     protected StrategoTerm(IStrategoList annotations) {
         assert annotations == null || !annotations.isEmpty() || annotations == TermFactory.EMPTY_LIST;
     	if (annotations != TermFactory.EMPTY_LIST)
@@ -175,4 +178,20 @@
     		this.hashCode = UNKNOWN_HASH;
     	}
     }
+    
+    public <T extends ITermAttachment> T getAttachment(Class<T> type) {
+    	if (attachment != null) {
+    		return attachment.tryGetAttachment(type); 
+    	} else {
+    		return null;
+    	}
+    }
+    
+    public void addAttachment(ITermAttachment attachment) {
+    	if (this.attachment == null) {
+    		this.attachment = attachment;
+    	} else {
+    		this.attachment.addAttachment(attachment);
+    	}
+    }
 }

From L.C.L.Kats at tudelft.nl  Wed Dec 29 14:13:20 2010
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Wed, 29 Dec 2010 13:13:20 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21594 -
	spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl
	spoofax/branches/spoofax-new-terms/spoofax/org...
Message-ID: <201012291313.oBTDDKrp016706@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: Wed Dec 29 13:13:19 2010
New Revision: 21594
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21594&sc=1

Log:
- jsglr now uses org.spoofax.terms terms with token/sort attachments
- various changes to the term library

Added:
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/ElementImploderAttachment.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/ImploderAttachment.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/SimpleTermVisitor.java
      - copied, changed from r21591, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/AstNodeVisitor.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/TermTreeFactory.java
      - copied, changed from r21591, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/ATermTreeFactory.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/ISimpleTerm.java
      - copied, changed from r21591, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/IAstNode.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/IStrategoNamed.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoListIterator.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/Term.java
      - copied, changed from r21591, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/Term.java
Deleted:
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/Term.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/ATermTreeFactory.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/AstNodeVisitor.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/IAstNode.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/shared/terms/
Modified:
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/StrategoHashMap.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/StrategoSet.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/META-INF/MANIFEST.MF
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/META-INF/MANIFEST.MF
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/_attic/rnsglr/Tree.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/client/JSGLREntryPoint.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/Main.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/Asfix2TreeBuilder.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/Disambiguator.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ITreeBuilder.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/IndentationFilter.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/KeywordRecognizer.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/Label.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ParseNode.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ParseTable.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ParseTreeTools.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ProductionAttributes.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/SGLR.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/AstAnnoImploder.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/ITreeFactory.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/ITreeInspector.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/LabelInfo.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/ProductionAttributeReader.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/TokenKindManager.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/incremental/DamageRegionAnalyzer.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/incremental/IncrementalInputBuilder.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/incremental/NeighbourDamageExpander.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/incremental/SortAnalyzer.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/io/ParseTableManager.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/io/SGLR.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/server/RemoteParseTableServiceImpl.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/shared/BadTokenException.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/shared/RemoteParseTableService.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/shared/RemoteParseTableServiceAsync.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/shared/SGLRException.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/shared/Tools.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/tests/ParseTestCase.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/tests/TestTokenize.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/tests/Makefile
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/NotImplementedException.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/AbstractTermAttachment.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/IStrategoAppl.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/IStrategoString.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/IStrategoTerm.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/IStrategoTermBuilder.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/ITermAttachment.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/ITermFactory.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/AbstractTermFactory.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/LazyTerm.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoAnnotation.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoAppl.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoConstructor.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoInt.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoList.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoPlaceholder.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoReal.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoString.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoTerm.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoTuple.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoWrapped.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StringTermReader.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/TermFactory.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/AbstractIOTermFactory.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/TermReader.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/baf/BAFTermReader.java
   strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/ImportTerm.java

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/StrategoHashMap.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/StrategoHashMap.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/StrategoHashMap.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -61,8 +61,12 @@
         throw new UnsupportedOperationException();
     }
     
-    public void addAttachment(ITermAttachment attachment) {
+    public void putAttachment(ITermAttachment attachment) {
         throw new UnsupportedOperationException();
     }
+    
+    public boolean isList() {
+        return false;
+    }
 
 }

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/StrategoSet.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/StrategoSet.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/StrategoSet.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -143,8 +143,12 @@
         throw new UnsupportedOperationException();
     }
     
-    public void addAttachment(ITermAttachment attachment) {
+    public void putAttachment(ITermAttachment attachment) {
         throw new UnsupportedOperationException();
     }
+    
+    public boolean isList() {
+        return false;
+    }
 
 }

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/META-INF/MANIFEST.MF
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/META-INF/MANIFEST.MF	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/META-INF/MANIFEST.MF	Wed Dec 29 13:13:19 2010	(r21594)
@@ -9,8 +9,7 @@
  org.eclipse.core.runtime,
  org.spoofax.interpreter.core,
  org.spoofax.jsglr;bundle-version="0.3.0",
- org.spoofax.interpreter.adapter.aterm,
- org.spoofax.aterm
+ org.spoofax.interpreter.adapter.aterm
 Bundle-ActivationPolicy: lazy
 Export-Package: org.spoofax.interpreter.library.jsglr
 Bundle-RequiredExecutionEnvironment: J2SE-1.5

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/META-INF/MANIFEST.MF
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/META-INF/MANIFEST.MF	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/META-INF/MANIFEST.MF	Wed Dec 29 13:13:19 2010	(r21594)
@@ -8,10 +8,8 @@
  org.spoofax.jsglr.client,
  org.spoofax.jsglr.client.imploder,
  org.spoofax.jsglr.client.incremental,
- org.spoofax.jsglr.shared,
- org.spoofax.jsglr.shared.terms
+ org.spoofax.jsglr.shared
 Bundle-Vendor: Spoofax.org
 Require-Bundle: org.junit,
- org.spoofax.interpreter.core,
  org.spoofax.terms
 Bundle-RequiredExecutionEnvironment: J2SE-1.5

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/_attic/rnsglr/Tree.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/_attic/rnsglr/Tree.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/_attic/rnsglr/Tree.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -6,7 +6,7 @@
 
 public class Tree {
 
-	static Tree makeTreeAppl(ATerm production, Arguments children) {
+	static Tree makeTreeAppl(IStrategoTerm production, Arguments children) {
 		throw new NotImplementedException();
 	}
 

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/client/JSGLREntryPoint.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/client/JSGLREntryPoint.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/client/JSGLREntryPoint.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -1,5 +1,6 @@
 package org.spoofax.client;
 
+import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.jsglr.client.InvalidParseTableException;
 import org.spoofax.jsglr.client.ParseException;
 import org.spoofax.jsglr.client.ParseTable;
@@ -7,8 +8,7 @@
 import org.spoofax.jsglr.shared.BadTokenException;
 import org.spoofax.jsglr.shared.SGLRException;
 import org.spoofax.jsglr.shared.TokenExpectedException;
-import org.spoofax.jsglr.shared.terms.ATerm;
-import org.spoofax.jsglr.shared.terms.ATermFactory;
+import org.spoofax.terms.TermFactory;
 
 import com.google.gwt.core.client.EntryPoint;
 import com.google.gwt.core.client.GWT;
@@ -46,7 +46,7 @@
 		//		rpts.fetchParseTable("Stratego2.tbl", new AsyncCallback<ATerm>() {
 		//
 		//			@Override
-		//			public void onSuccess(ATerm result) {
+		//			public void onSuccess(IStrategoTerm result) {
 		//				parseAndGo(result);
 		//			}
 		//
@@ -60,12 +60,12 @@
 	private void parseAndGo(String table) {
 		try {
 			System.out.println(table.length());
-			final ATermFactory af = new ATermFactory();
-			final ATerm pt = af.parse(table);
+			final TermFactory af = new TermFactory();
+			final IStrategoTerm pt = af.parseFromString(table);
 			System.out.println(pt.toString().length());
-			final SGLR sglr = new SGLR(af, new ParseTable(pt));
+			final SGLR sglr = new SGLR(af, new ParseTable(pt, af));
 			long now = System.currentTimeMillis();
-			final ATerm r = (ATerm) sglr.parse(strategoSampleCode());
+			final IStrategoTerm r = (IStrategoTerm) sglr.parse(strategoSampleCode(), null);
 			now = System.currentTimeMillis() - now;
 			if(r != null) {
 				RootPanel.get().add(new Label(r.toString()));

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/Main.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/Main.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/Main.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -14,16 +14,17 @@
 import java.io.OutputStreamWriter;
 import java.io.Writer;
 
+import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.jsglr.client.InvalidParseTableException;
 import org.spoofax.jsglr.client.ParseTable;
-import org.spoofax.jsglr.client.SGLR;
+import org.spoofax.jsglr.io.SGLR;
 import org.spoofax.jsglr.client.imploder.TreeBuilder;
 import org.spoofax.jsglr.io.FileTools;
 import org.spoofax.jsglr.shared.BadTokenException;
 import org.spoofax.jsglr.shared.SGLRException;
 import org.spoofax.jsglr.shared.Tools;
-import org.spoofax.jsglr.shared.terms.ATerm;
-import org.spoofax.jsglr.shared.terms.ATermFactory;
+import org.spoofax.terms.TermFactory;
+import org.spoofax.terms.io.baf.BAFTermReader;
 
 public class Main {
 	
@@ -89,9 +90,10 @@
 			usage();
 		}
 
-		final ATermFactory factory = new ATermFactory();
+		final TermFactory factory = new TermFactory();
 		long tableLoadingTime = System.currentTimeMillis();
-		final ParseTable pt = new ParseTable(factory.parseFromString(FileTools.loadFileAsString(parseTableFile)));
+		final IStrategoTerm tableTerm = new BAFTermReader(factory).parseFromFile(parseTableFile);
+		final ParseTable pt = new ParseTable(tableTerm, factory);
 		final SGLR sglr = new SGLR(factory, pt);
 
 		tableLoadingTime = System.currentTimeMillis() - tableLoadingTime;
@@ -143,7 +145,7 @@
 		Object t = null;
 		try {
 			parsingTime = System.currentTimeMillis();
-			t = sglr.parse(FileTools.loadFileAsString(input), startSymbol);
+			t = sglr.parse(input, startSymbol);
 			parsingTime = System.currentTimeMillis() - parsingTime;
 		} catch(final BadTokenException e) {
 			System.err.println("Parsing failed : " + e.getMessage());
@@ -151,8 +153,9 @@
 			// Detailed message for other exceptions
 			System.err.println("Parsing failed : " + e);
 		}
-		if(t != null && !NO_OUTPUT.equals(output)){
-			((ATerm) t).writeTo(out);
+		if(t != null && !NO_OUTPUT.equals(output)) {
+			BAFTermReader termIO = new BAFTermReader(sglr.getParseTable().getFactory());
+			termIO.unparseToFile((IStrategoTerm) t, out);
 			out.close();
 		}
 		return parsingTime;

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/Asfix2TreeBuilder.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/Asfix2TreeBuilder.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/Asfix2TreeBuilder.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -2,34 +2,34 @@
 
 import java.util.List;
 
+import org.spoofax.interpreter.terms.IStrategoAppl;
+import org.spoofax.interpreter.terms.IStrategoConstructor;
+import org.spoofax.interpreter.terms.IStrategoList;
+import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.jsglr.client.imploder.ITokenizer;
-import org.spoofax.jsglr.shared.terms.AFun;
-import org.spoofax.jsglr.shared.terms.ATerm;
-import org.spoofax.jsglr.shared.terms.ATermAppl;
-import org.spoofax.jsglr.shared.terms.ATermFactory;
-import org.spoofax.jsglr.shared.terms.ATermList;
+import org.spoofax.terms.TermFactory;
 
 public class Asfix2TreeBuilder extends BottomupTreeBuilder {
 
-	private final ATermFactory factory = new ATermFactory();
-	private final AFun applAFun;
-	private final AFun ambAFun;
-	private final AFun parseTreeAFun;
-	private ATermAppl[] labels;
+	private final TermFactory factory = new TermFactory();
+	private final IStrategoConstructor applIStrategoConstructor;
+	private final IStrategoConstructor ambIStrategoConstructor;
+	private final IStrategoConstructor parseTreeIStrategoConstructor;
+	private IStrategoAppl[] labels;
 	private int labelStart;
 
 	public Asfix2TreeBuilder() {
-		applAFun = factory.makeAFun("appl", 2, false);
-		ambAFun = factory.makeAFun("amb", 1, false);
-		parseTreeAFun = factory.makeAFun("parsetree", 2, false);
+		applIStrategoConstructor = factory.makeConstructor("appl", 2);
+		ambIStrategoConstructor = factory.makeConstructor("amb", 1);
+		parseTreeIStrategoConstructor = factory.makeConstructor("parsetree", 2);
 	}
 
 	public void initializeTable(ParseTable table, int productionCount, int labelStart, int labelCount) {
-		labels = new ATermAppl[labelCount - labelStart];
+		labels = new IStrategoAppl[labelCount - labelStart];
 		this.labelStart = labelStart;
 	}
 
-	public void initializeLabel(int labelNumber, ATermAppl parseTreeProduction) {
+	public void initializeLabel(int labelNumber, IStrategoAppl parseTreeProduction) {
 		labels[labelNumber - labelStart] = parseTreeProduction;
 	}
 
@@ -37,24 +37,25 @@
 		// Not used here
 	}
 
-	public ATerm buildNode(int labelNumber, List<Object> subtrees) {
-		ATermList ls = factory.makeList();
+	public IStrategoTerm buildNode(int labelNumber, List<Object> subtrees) {
+		IStrategoList ls = factory.makeList();
 		for(int i = subtrees.size() - 1; i >= 0; i--) {
-        	ls = factory.makeList((ATerm)subtrees.get(i), ls);
+        	ls = factory.makeListCons((IStrategoTerm) subtrees.get(i), ls);
 		}
-		return factory.makeAppl(applAFun, labels[labelNumber - labelStart], ls);
+		return factory.makeAppl(applIStrategoConstructor, labels[labelNumber - labelStart], ls);
 	}
 
-	public ATerm buildAmb(List<Object> alternatives) {
-		return factory.makeAppl(ambAFun, alternatives.toArray(new ATerm[alternatives.size()]));
+	public IStrategoTerm buildAmb(List<Object> alternatives) {
+		IStrategoTerm[] alternatives2 = alternatives.toArray(new IStrategoTerm[alternatives.size()]);
+		return factory.makeAppl(ambIStrategoConstructor, alternatives2);
 	}
 
-	public ATerm buildProduction(int productionNumber) {
+	public IStrategoTerm buildProduction(int productionNumber) {
 		return factory.makeInt(productionNumber);
 	}
 
-	public ATerm buildTreeTop(Object node, int ambCount) {
-		return factory.makeAppl(parseTreeAFun, (ATerm)node, factory.makeInt(ambCount));
+	public IStrategoTerm buildTreeTop(Object node, int ambCount) {
+		return factory.makeAppl(parseTreeIStrategoConstructor, (IStrategoAppl) node, factory.makeInt(ambCount));
 	}
 
 	public ITokenizer getTokenizer() {

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/Disambiguator.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/Disambiguator.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/Disambiguator.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -10,10 +10,10 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.ParseError;
 import org.spoofax.jsglr.shared.SGLRException;
 import org.spoofax.jsglr.shared.Tools;
-import org.spoofax.jsglr.shared.terms.ATerm;
-import org.spoofax.jsglr.shared.terms.ParseError;
 
 /**
  * @author Karl Trygve Kalleberg <karltk near strategoxt.org>
@@ -273,7 +273,7 @@
 		return t;
 	}
 
-	private ATerm getProduction(AbstractParseNode t) {
+	private IStrategoTerm getProduction(AbstractParseNode t) {
 		if (t instanceof ParseNode) {
 			return parseTable.getProduction(((ParseNode) t).getLabel());
 		} else {
@@ -297,13 +297,16 @@
 		return t;
 	}
 
-	private boolean matchProdOnTopSort(ATerm prod, String sort) throws FilterException {
+	private boolean matchProdOnTopSort(IStrategoTerm prod, String sort) throws FilterException {
 		try {
+			throw new org.spoofax.NotImplementedException("Top sort selection needs to be reimplemented now we're no longer using ATerms!!");
+			/* FIXME: Top sort selection needs to be reimplemented now we're no longer using ATerms!!
 			sort = sort.replaceAll("\"", "");
 			return prod.match("prod([cf(opt(layout)),cf(sort(\"" + sort + "\")),cf(opt(layout))], sort(\"<START>\"),no-attrs)") != null
 			|| prod.match("prod([cf(sort(\"" + sort + "\"))], sort(\"<START>\"),no-attrs)") != null
 			|| prod.match("prod([lex(sort(\"" + sort + "\"))], sort(\"<START>\"),no-attrs)") != null
 			|| prod.match("prod([sort(\"" + sort + "\")], sort(\"<START>\"),no-attrs)") != null;
+			*/
 		} catch (final ParseError e) {
 			throw new FilterException(parser, "Could not select desired top sort: " + sort, e);
 		}
@@ -321,7 +324,7 @@
 			default: return new Amb(results.toArray(new AbstractParseNode[results.size()]));
 			}
 		} else {
-			final ATerm prod = getProduction(t);
+			final IStrategoTerm prod = getProduction(t);
 			return matchProdOnTopSort(prod, sort) ? t : null;
 		}
 	}
@@ -331,7 +334,7 @@
 			if (amb instanceof Amb) {
 				addTopSortAlternatives(amb, sort, results);
 			} else {
-				final ATerm prod = getProduction(amb);
+				final IStrategoTerm prod = getProduction(amb);
 				if (matchProdOnTopSort(prod, sort)) {
 					results.add(amb);
 				}
@@ -620,7 +623,7 @@
         if (ATisEqual(t, injT)) {
            return newTree;
         } else {
-          ATermList sons = (ATermList)ATgetArgument((ATerm) t, 1);
+          IStrategoList sons = (IStrategoList)ATgetArgument((ATerm) t, 1);
           tree newSon = SG_Replace_Under_Injections((tree)ATgetFirst(sons),
                                                     injT, newTree);
           return ATsetArgument((ATermAppl)t, (ATerm)ATmakeList1((ATerm)newSon), 1);

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ITreeBuilder.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ITreeBuilder.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ITreeBuilder.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -1,12 +1,12 @@
 package org.spoofax.jsglr.client;
 
+import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.jsglr.client.imploder.ITokenizer;
-import org.spoofax.jsglr.shared.terms.ATermAppl;
 
 public interface ITreeBuilder {
 
 	void initializeTable(ParseTable table, int productionCount, int labelStart, int labelCount);
-	void initializeLabel(int labelNumber, ATermAppl parseTreeProduction);
+	void initializeLabel(int labelNumber, IStrategoAppl parseTreeProduction);
 	void initializeInput(String filename, String input);
 	
 	Object buildTree(AbstractParseNode node);

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/IndentationFilter.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/IndentationFilter.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/IndentationFilter.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -1,32 +1,32 @@
 package org.spoofax.jsglr.client;
 
-import static org.spoofax.jsglr.client.Term.termAt;
+import static org.spoofax.terms.Term.termAt;
 
-import org.spoofax.jsglr.shared.terms.ATerm;
-import org.spoofax.jsglr.shared.terms.ATermAppl;
-import org.spoofax.jsglr.shared.terms.ATermList;
+import org.spoofax.interpreter.terms.IStrategoList;
+import org.spoofax.interpreter.terms.IStrategoNamed;
+import org.spoofax.interpreter.terms.IStrategoTerm;
 
 public class IndentationFilter {
 
-    public static void resolveAmbiguitiesByIndentation(ATerm node)
+    public static void resolveAmbiguitiesByIndentation(IStrategoTerm node)
     {
-        if (node.getChildCount()>1)
+        if (node.getSubtermCount()>1)
         {
-            ATermList contents;
-            if ("amb".equals(((ATermAppl) node).getName())){
+            IStrategoList contents;
+            if ("amb".equals(((IStrategoNamed) node).getName())){
                 contents = termAt(node, 0);
             }
             else{
                 contents = termAt(node, 1);
             }
-            for (int i = 0; i < contents.getChildCount(); i++) {
-                resolveAmbiguitiesByIndentation((ATerm) contents.getChildAt(i));
+            for (int i = 0; i < contents.getSubtermCount(); i++) {
+                resolveAmbiguitiesByIndentation(contents.getSubterm(i));
             }
         }
 
-        if ("amb".equals(((ATermAppl) node).getName())){
-            ATermList ambs = termAt(node, 0);
-            node = (ATerm) ambs.getChildAt(0);
+        if ("amb".equals(((IStrategoNamed) node).getName())){
+            IStrategoList ambs = termAt(node, 0);
+            node = ambs.getSubterm(0);
         }
     }
 

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/KeywordRecognizer.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/KeywordRecognizer.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/KeywordRecognizer.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -1,13 +1,15 @@
 package org.spoofax.jsglr.client;
 
-import static org.spoofax.jsglr.shared.Tools.termAt;
+import static org.spoofax.terms.Term.isTermAppl;
+import static org.spoofax.terms.Term.termAt;
 
 import java.util.HashSet;
 import java.util.Set;
 
-import org.spoofax.jsglr.shared.terms.AFun;
-import org.spoofax.jsglr.shared.terms.ATerm;
-import org.spoofax.jsglr.shared.terms.ATermAppl;
+import org.spoofax.interpreter.terms.IStrategoAppl;
+import org.spoofax.interpreter.terms.IStrategoConstructor;
+import org.spoofax.interpreter.terms.IStrategoNamed;
+import org.spoofax.interpreter.terms.IStrategoTerm;
 
 /**
  * Recognizes keywords in a language without considering their context.
@@ -18,18 +20,16 @@
  */
 public class KeywordRecognizer {
 	
-	private final AFun litFun;
-	
 	private final Set<String> keywords = new HashSet<String>();
 	
 	protected KeywordRecognizer(ParseTable table) {
-		litFun = table.getFactory().makeAFun("lit", 1, false);
 		if (table != null) {
+			IStrategoConstructor litFun = table.getFactory().makeConstructor("lit", 1);
 			for (Label l : table.getLabels()) {
 				if (l != null) {
-					ATerm rhs = termAt(l.getProduction(), 1);
-					if (rhs instanceof ATermAppl && ((ATermAppl) rhs).getAFun() == litFun) {
-						ATermAppl lit = termAt(rhs, 0);
+					IStrategoTerm rhs = termAt(l.getProduction(), 1);
+					if (isTermAppl(rhs) && ((IStrategoAppl) rhs).getConstructor() == litFun) {
+						IStrategoNamed lit = termAt(rhs, 0);
 						String litString = lit.getName();
 						if (isPotentialKeyword(litString))
 							keywords.add(litString);

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/Label.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/Label.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/Label.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -9,18 +9,18 @@
 
 import java.io.Serializable;
 
-import org.spoofax.jsglr.shared.terms.ATermAppl;
+import org.spoofax.interpreter.terms.IStrategoAppl;
 
 public class Label implements Serializable {
 
     private static final long serialVersionUID = -4080621639747161438L;
 
     /*package*/ final int labelNumber;
-    /*package*/ final ATermAppl prod;
+    /*package*/ final IStrategoAppl prod;
     private final ProductionAttributes productionAttributes;
     private final boolean injection;
 
-    public Label(int labelNumber, ATermAppl prod, ProductionAttributes productionAttributes, boolean injection) {
+    public Label(int labelNumber, IStrategoAppl prod, ProductionAttributes productionAttributes, boolean injection) {
         this.labelNumber = labelNumber;
         this.prod = prod;
         this.productionAttributes = productionAttributes;
@@ -54,7 +54,7 @@
         return injection;
     }
 
-    public ATermAppl getProduction() {
+    public IStrategoAppl getProduction() {
         return prod;
     }
 

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ParseNode.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ParseNode.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ParseNode.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -11,10 +11,10 @@
 import java.util.Arrays;
 import java.util.List;
 
+import org.spoofax.interpreter.terms.IStrategoList;
+import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.jsglr.client.imploder.TopdownTreeBuilder;
-import org.spoofax.jsglr.shared.terms.ATerm;
-import org.spoofax.jsglr.shared.terms.ATermFactory;
-import org.spoofax.jsglr.shared.terms.ATermList;
+import org.spoofax.terms.TermFactory;
 
 public class ParseNode extends AbstractParseNode {
 
@@ -71,10 +71,10 @@
     /**
      * todo: stolen from TAFReader; move elsewhere
      */
-    public static ATermList makeList(ATermFactory factory, List<ATerm> terms) {
-        ATermList result = factory.makeList();
+    public static IStrategoList makeList(TermFactory factory, List<IStrategoTerm> terms) {
+        IStrategoList result = factory.makeList();
         for (int i = terms.size() - 1; i >= 0; i--) {
-        	result = factory.makeList(terms.get(i), result);
+        	result = factory.makeListCons(terms.get(i), result);
         }
         return result;
     }

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ParseTable.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ParseTable.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ParseTable.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -8,6 +8,12 @@
 package org.spoofax.jsglr.client;
 
 import static java.util.Arrays.asList;
+import static org.spoofax.interpreter.terms.IStrategoTerm.APPL;
+import static org.spoofax.interpreter.terms.IStrategoTerm.LIST;
+import static org.spoofax.terms.Term.intAt;
+import static org.spoofax.terms.Term.isTermInt;
+import static org.spoofax.terms.Term.javaInt;
+import static org.spoofax.terms.Term.termAt;
 
 import java.io.Serializable;
 import java.util.ArrayList;
@@ -16,11 +22,14 @@
 import java.util.List;
 import java.util.Map;
 
-import org.spoofax.jsglr.shared.terms.AFun;
-import org.spoofax.jsglr.shared.terms.ATerm;
-import org.spoofax.jsglr.shared.terms.ATermAppl;
-import org.spoofax.jsglr.shared.terms.ATermFactory;
-import org.spoofax.jsglr.shared.terms.ATermList;
+import org.spoofax.interpreter.terms.IStrategoAppl;
+import org.spoofax.interpreter.terms.IStrategoConstructor;
+import org.spoofax.interpreter.terms.IStrategoList;
+import org.spoofax.interpreter.terms.IStrategoNamed;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.ITermFactory;
+import org.spoofax.terms.Term;
+import org.spoofax.terms.TermFactory;
 
 public class ParseTable implements Serializable {
 
@@ -52,11 +61,11 @@
 
     private boolean hasRecovers;
 
-    transient private ATermFactory factory;
+    transient private ITermFactory factory;
 
-    transient public AFun applAFun;
+    transient public IStrategoConstructor applIStrategoConstructor;
 
-    transient public AFun ambAFun;
+    transient public IStrategoConstructor ambIStrategoConstructor;
 
     private Label[] injections;
 
@@ -86,29 +95,34 @@
     	}
     }
                                              
-    public ParseTable(ATerm pt) throws InvalidParseTableException {
-        initAFuns(pt.getFactory());
+    public ParseTable(IStrategoTerm pt, ITermFactory factory) throws InvalidParseTableException {
+        initIStrategoConstructors(factory);
         parse(pt);
     }
+    
+    @Deprecated
+    public ParseTable(IStrategoTerm pt) throws InvalidParseTableException {
+    	this(pt, new TermFactory());
+    }
 
-    public void initAFuns(ATermFactory factory) {
+    public void initIStrategoConstructors(ITermFactory factory) {
         this.factory = factory;
-        applAFun = factory.makeAFun("appl", 2, false);
-        ambAFun = factory.makeAFun("amb", 1, false);
+        applIStrategoConstructor = factory.makeConstructor("appl", 2);
+        ambIStrategoConstructor = factory.makeConstructor("amb", 1);
     }
 
-    public ATermFactory getFactory() {
+    public ITermFactory getFactory() {
         return factory;
     }
 
-    private boolean parse(ATerm pt) throws InvalidParseTableException {
-        int version = Term.intAt(pt, 0);
-        if (pt.getChildCount() == 1) // Seen with ParseTable(0)
+    private boolean parse(IStrategoTerm pt) throws InvalidParseTableException {
+        int version = intAt(pt, 0);
+        if (pt.getSubtermCount() == 1) // Seen with ParseTable(0)
           throw new InvalidParseTableException("Invalid parse table (possibly wrong start symbol specified)\n" + pt);
-        startState = Term.intAt(pt, 1);
-        ATermList labelsTerm = Term.listAt(pt, 2);
-        ATermAppl statesTerm = Term.applAt(pt, 3);
-        ATermAppl prioritiesTerm = Term.applAt(pt, 4);
+        startState = intAt(pt, 1);
+        IStrategoList labelsTerm = termAt(pt, 2);
+        IStrategoNamed statesTerm = termAt(pt, 3);
+        IStrategoNamed prioritiesTerm = termAt(pt, 4);
 
         if (version != 4 && version !=6) {
             throw new InvalidParseTableException("Only supports version 4 and 6 tables.");
@@ -132,17 +146,17 @@
         return true;
     }
 
-    private Priority[] parsePriorities(ATermAppl prioritiesTerm) throws InvalidParseTableException {
+    private Priority[] parsePriorities(IStrategoNamed prioritiesTerm) throws InvalidParseTableException {
 
-        ATermList prods = Term.listAt(prioritiesTerm, 0);
+        IStrategoList prods = termAt(prioritiesTerm, 0);
         List<Priority> ret = new ArrayList<Priority>();
 
         while (!prods.isEmpty()) {
-            ATermAppl a = (ATermAppl) prods.getFirst();
-            prods = prods.getNext();
+            IStrategoNamed a = (IStrategoNamed) prods.head();
+            prods = prods.tail();
 
-            int left = Term.intAt(a, 0);
-            int right = Term.intAt(a, 1);
+            int left = intAt(a, 0);
+            int right = intAt(a, 1);
             if (a.getName().equals("left-prio")) {
                 // handled by parseAssociativities
             } else if (a.getName().equals("right-prio")) {
@@ -154,7 +168,7 @@
                     ret.add(new Priority(Priority.GTR, left, right));
             } else if (a.getName().equals("arg-gtr-prio")) {
             	int arg = right;
-            	right = Term.intAt(a, 1);
+            	right = intAt(a, 1);
                 if(left != right)
                     ret.add(new Priority(Priority.GTR, left, right, arg));
             } else {
@@ -164,14 +178,14 @@
         return ret.toArray(new Priority[0]);
     }
 
-    private Associativity[] parseAssociativities(ATermAppl prioritiesTerm) throws InvalidParseTableException {
+    private Associativity[] parseAssociativities(IStrategoNamed prioritiesTerm) throws InvalidParseTableException {
 
-        ATermList prods = Term.listAt(prioritiesTerm, 0);
+        IStrategoList prods = termAt(prioritiesTerm, 0);
         List<Associativity> ret = new ArrayList<Associativity>();
 
-        for (ATermAppl a = (ATermAppl) prods.getFirst(); !prods.getNext().isEmpty(); prods = prods.getNext()) {
-            int left = Term.intAt(a, 0);
-            int right = Term.intAt(a, 1);
+        for (IStrategoNamed a = (IStrategoNamed) prods.head(); !prods.tail().isEmpty(); prods = prods.tail()) {
+            int left = intAt(a, 0);
+            int right = intAt(a, 1);
             if (a.getName().equals("left-prio")) {
                 if(left == right)
                     ret.add(new Associativity(Priority.LEFT, left));
@@ -192,69 +206,70 @@
         return ret.toArray(new Associativity[0]);
     }
 
-    private Label[] parseLabels(ATermList labelsTerm) throws InvalidParseTableException {
+    private Label[] parseLabels(IStrategoList labelsTerm) throws InvalidParseTableException {
 
-        final Label[] ret = new Label[labelsTerm.getChildCount() + LABEL_BASE];
+        final Label[] ret = new Label[labelsTerm.getSubtermCount() + LABEL_BASE];
 
         while (!labelsTerm.isEmpty()) {
             
-        	final ATermAppl a = (ATermAppl) labelsTerm.getFirst();
-            final ATermAppl prod = Term.applAt(a, 0);
-            final int labelNumber = Term.intAt(a, 1);
+        	final IStrategoNamed a = (IStrategoNamed) labelsTerm.head();
+            final IStrategoAppl prod = termAt(a, 0);
+            final int labelNumber = intAt(a, 1);
             final boolean injection = isInjection(prod);
-            final ProductionAttributes pa = parseProductionAttributes(Term.applAt(prod, 2));
+            IStrategoAppl attrs = termAt(prod, 2);
+			final ProductionAttributes pa = parseProductionAttributes(attrs);
             
             ret[labelNumber] = new Label(labelNumber, prod, pa, injection);
 
-            labelsTerm = labelsTerm.getNext();
+            labelsTerm = labelsTerm.tail();
         }
 
         return ret;
     }
 
-    private boolean isInjection(ATermAppl prod) {
+    private boolean isInjection(IStrategoNamed prod) {
 
     	// Injections are terms on the following form:
     	//  . prod([<term>],cf(<term>),<term>)
     	//  . prod([<term>],lex(sort(<str>)),<term>)
     	//  . lit(<str>)
 
-        if(!prod.getAFun().getName().equals("prod"))
+        if(!prod.getName().equals("prod"))
         	return false;
         
         
-        if(prod.getChildAt(1).getType() != ATerm.APPL)
+        if(prod.getSubterm(1).getTermType() != APPL)
         	return false;
         
-        final String nm = ((ATermAppl)prod.getChildAt(1)).getName();
+        final String nm = ((IStrategoNamed)prod.getSubterm(1)).getName();
         
         if(!(nm.equals("cf") || nm.equals("lex")))
         	return false;
 
-        if(prod.getChildAt(0).getType() != ATerm.LIST)
+        if(prod.getSubterm(0).getTermType() != LIST)
         	return false;
 
-        ATermList ls = ((ATermList)prod.getChildAt(0));
+        IStrategoList ls = ((IStrategoList)prod.getSubterm(0));
 
-        if(ls.getChildCount() < 1)
+        if(ls.getSubtermCount() < 1)
         	return false;
         
-        if(ls.getFirst().getType() != ATerm.APPL)
+        if(ls.head().getTermType() != APPL)
         	return false;
         
-        final AFun fun = ((ATermAppl)ls.getFirst()).getAFun();
+        final IStrategoConstructor fun = ((IStrategoAppl)ls.head()).getConstructor();
         return !(fun.getName().equals("lit") && fun.getArity() == 1);
     }
 
-    private ProductionAttributes parseProductionAttributes(ATermAppl attr)
+    private ProductionAttributes parseProductionAttributes(IStrategoAppl attr)
             throws InvalidParseTableException {
         if (attr.getName().equals("attrs")) {
             int type = 0;
             boolean isRecover = false;
-            ATerm term = null;
+            IStrategoTerm term = null;
 
-            for (ATermList ls = (ATermList) attr.getChildAt(0); !ls.isEmpty(); ls = ls.getNext()) {
-                ATermAppl t = (ATermAppl) ls.getFirst();
+            for (IStrategoList ls = (IStrategoList) attr.getSubterm(0); !ls.isEmpty(); ls = ls.tail()) {
+                IStrategoNamed t = (IStrategoNamed) ls.head();
                 String ctor = t.getName();
                 if (ctor.equals("reject")) {
                     type = ProductionType.REJECT;
@@ -269,7 +284,7 @@
                     type = ProductionType.BRACKET;
                 } else {
                     if (ctor.equals("assoc")) {
-                        ATermAppl a = (ATermAppl) t.getChildAt(0);
+                        IStrategoNamed a = (IStrategoNamed) t.getSubterm(0);
                         if (a.getName().equals("left") || a.getName().equals("assoc")) {
                         	// ('assoc' is identical to 'left' for the parser)
                             type = ProductionType.LEFT_ASSOCIATIVE;
@@ -283,20 +298,20 @@
                         } else {
                             throw new InvalidParseTableException("Unknown assocativity: " + a.getName());
                         }
-                    } else if (	ctor.equals("term") && t.getChildCount() == 1) {
+                    } else if (	ctor.equals("term") && t.getSubtermCount() == 1) {
                         // Term needs to be shaped as term(cons(Constructor)) to be a constructor
-                    	if(t.getChildAt(0) instanceof ATermAppl) {
-                    	    ATermAppl child = (ATermAppl) t.getChildAt(0);
-                            if (child.getChildCount() == 1 && child.getName().equals("cons")) {
-                    			term = t.getChildAt(0).getChildAt(0);
-                    		} else if (child.getChildCount() == 0 && child.getName().equals("recover")) {
+                    	if(t.getSubterm(0) instanceof IStrategoNamed) {
+                    	    IStrategoNamed child = (IStrategoNamed) t.getSubterm(0);
+                            if (child.getSubtermCount() == 1 && child.getName().equals("cons")) {
+                    			term = t.getSubterm(0).getSubterm(0);
+                    		} else if (child.getSubtermCount() == 0 && child.getName().equals("recover")) {
                     		    hasRecovers = isRecover = true;
                     		}
                     	}
                     	// TODO Support other terms that are not a constructor (custom annotations)
                     } else if (ctor.equals("id")) {
                         // FIXME not certain about this
-                        term = t.getChildAt(0);
+                        term = t.getSubterm(0);
                     } else {
                         throw new InvalidParseTableException("Unknown attribute: " + t);
                     }
@@ -309,17 +324,17 @@
         throw new InvalidParseTableException("Unknown attribute type: " + attr);
     }
 
-    private State[] parseStates(ATermAppl statesTerm) throws InvalidParseTableException {
+    private State[] parseStates(IStrategoNamed statesTerm) throws InvalidParseTableException {
 
-        ATermList states = Term.listAt(statesTerm, 0);
-        State[] ret = new State[states.getChildCount()];
+        IStrategoList states = termAt(statesTerm, 0);
+        State[] ret = new State[states.getSubtermCount()];
         for(int i = 0; i < ret.length; i++) {
-            ATermAppl stateRec = (ATermAppl) states.getFirst();
-            states = states.getNext();
+            IStrategoNamed stateRec = (IStrategoNamed) states.head();
+            states = states.tail();
 
-            int stateNumber = Term.intAt(stateRec, 0);
-            Goto[] gotos = parseGotos(Term.listAt(stateRec, 1));
-            Action[] actions = parseActions(Term.listAt(stateRec, 2));
+            int stateNumber = intAt(stateRec, 0);
+            Goto[] gotos = parseGotos((IStrategoList) termAt(stateRec, 1));
+            Action[] actions = parseActions((IStrategoList) termAt(stateRec, 2));
 
             ret[i] = new State(stateNumber, gotos, actions);
         }
@@ -339,45 +354,45 @@
     }
 
 
-    private Action[] parseActions(ATermList actionList) throws InvalidParseTableException {
-        Action[] ret = new Action[actionList.getChildCount()];
+    private Action[] parseActions(IStrategoList actionList) throws InvalidParseTableException {
+        Action[] ret = new Action[actionList.getSubtermCount()];
 
         for(int i = 0; i < ret.length; i++) {
-            ATermAppl action = (ATermAppl) actionList.getFirst();
-            actionList = actionList.getNext();
-            RangeList ranges = parseRanges(Term.listAt(action, 0));
-            ActionItem[] items = parseActionItems(Term.listAt(action, 1));
+            IStrategoNamed action = (IStrategoNamed) actionList.head();
+            actionList = actionList.tail();
+            RangeList ranges = parseRanges((IStrategoList) termAt(action, 0));
+            ActionItem[] items = parseActionItems((IStrategoList) termAt(action, 1));
             ret[i] = new Action(ranges, items);
         }
         return ret;
     }
 
-    private ActionItem[] parseActionItems(ATermList items) throws InvalidParseTableException {
+    private ActionItem[] parseActionItems(IStrategoList items) throws InvalidParseTableException {
 
-        ActionItem[] ret = new ActionItem[items.getChildCount()];
+        ActionItem[] ret = new ActionItem[items.getSubtermCount()];
 
         for(int i = 0; i < ret.length; i++) {
             ActionItem item = null;
-            ATermAppl a = (ATermAppl) items.getFirst();
-            items = items.getNext();
+            IStrategoAppl a = (IStrategoAppl) items.head();
+            items = items.tail();
 
-            if (a.getName().equals("reduce") && a.getAFun().getArity() == 3) {
-                int productionArity = Term.intAt(a, 0);
-                int label = Term.intAt(a, 1);
-                int status = Term.intAt(a, 2);
+            if (a.getName().equals("reduce") && a.getConstructor().getArity() == 3) {
+                int productionArity = intAt(a, 0);
+                int label = intAt(a, 1);
+                int status = intAt(a, 2);
                 boolean isRecoverAction = getLabel(label).getAttributes().isRecoverProduction();
                 item = makeReduce(productionArity, label, status, isRecoverAction);
-            } else if(a.getName().equals("reduce") && a.getAFun().getArity() == 4) {
-                int productionArity = Term.intAt(a, 0);
-                int label = Term.intAt(a, 1);
-                int status = Term.intAt(a, 2);
-                RangeList[] charClasses = parseCharRanges(Term.listAt(a, 3));
+            } else if(a.getName().equals("reduce") && a.getConstructor().getArity() == 4) {
+                int productionArity = intAt(a, 0);
+                int label = intAt(a, 1);
+                int status = intAt(a, 2);
+                RangeList[] charClasses = parseCharRanges((IStrategoList) termAt(a, 3));
                 item = makeReduceLookahead(productionArity, label, status, charClasses);
 
             } else if (a.getName().equals("accept")) {
                 item = new Accept();
             } else if (a.getName().equals("shift")) {
-                int nextState = Term.intAt(a, 0);
+                int nextState = intAt(a, 0);
                 item = makeShift(nextState);
             } else {
                 throw new InvalidParseTableException("Unknown action " + a.getName());
@@ -387,31 +402,31 @@
         return ret;
     }
 
-    private RangeList[] parseCharRanges(ATermList list) throws InvalidParseTableException {
-        RangeList[] ret = new RangeList[list.getChildCount()];
+    private RangeList[] parseCharRanges(IStrategoList list) throws InvalidParseTableException {
+        RangeList[] ret = new RangeList[list.getSubtermCount()];
         for (int i=0;i<ret.length; i++) {
-            ATermAppl t = Term.asAppl(list.getFirst());
-            list = list.getNext();
-            ATermList l, n;
+            IStrategoNamed t = (IStrategoNamed) list.head();
+            list = list.tail();
+            IStrategoList l, n;
             if (t.getName().equals("look")) { // sdf2bundle 2.4
-                l = Term.listAt(Term.applAt(t, 0), 0);
-                n = Term.listAt(t, 1);
+                l = termAt(termAt(t, 0), 0);
+                n = termAt(t, 1);
             } else { // sdf2bundle 2.6
                 assert t.getName().equals("follow-restriction");
-                l = Term.listAt(Term.termAt(Term.listAt(t, 0), 0), 0);
-                n = Term.listAt(t, 0).getNext();
+                l = termAt(Term.termAt(termAt(t, 0), 0), 0);
+                n = ((IStrategoList) termAt(t, 0)).tail();
             }
 
             // FIXME: multiple lookahead are not fully supported or tested
             //        (and should work for both 2.4 and 2.6 tables)
 
-            if (n.getChildCount() > 0 && Term.termAt(l, 1) == null) {
+            if (n.getSubtermCount() > 0 && Term.termAt(l, 1) == null) {
                 // This handles restrictions like:
                 //   LAYOUT? -/- [\/].[\/]
                 // where there is no other restriction that starts with a [\/]
 
-                ret[i] = new RangeList(new Range(Term.intAt(l, 0)));
-            } else if (n.getChildCount() > 0) {
+                ret[i] = new RangeList(new Range(intAt(l, 0)));
+            } else if (n.getSubtermCount() > 0) {
                 // This handles restrictions like:
                 //   LAYOUT? -/- [\/].[\/\+].[\*]
                 throw new InvalidParseTableException("Multiple lookahead not fully supported");
@@ -453,14 +468,14 @@
         }
     }
 
-    private Goto[] parseGotos(ATermList gotos) throws InvalidParseTableException {
-        Goto[] ret = new Goto[gotos.getChildCount()];
+    private Goto[] parseGotos(IStrategoList gotos) throws InvalidParseTableException {
+        Goto[] ret = new Goto[gotos.getSubtermCount()];
         for(int i = 0; i < ret.length; i++) {
-            ATermAppl go = (ATermAppl) gotos.getFirst();
-            gotos = gotos.getNext();
+            IStrategoNamed go = (IStrategoNamed) gotos.head();
+            gotos = gotos.tail();
 
-            ATermList rangeList = Term.listAt(go, 0);
-            int newStateNumber = Term.intAt(go, 1);
+            IStrategoList rangeList = termAt(go, 0);
+            int newStateNumber = intAt(go, 1);
             RangeList ranges = parseRanges(rangeList);
             //int[] productionLabels = parseProductionLabels(rangeList);
             ret[i] = makeGoto(newStateNumber, ranges);
@@ -469,18 +484,18 @@
         return ret;
     }
 
-//    private int[] parseProductionLabels(ATermList ranges) throws InvalidParseTableException {
+//    private int[] parseProductionLabels(IStrategoList ranges) throws InvalidParseTableException {
 //
 //        int[] ret = new int[ranges.getChildCount()];
 //
 //        for (int i = 0; i < ranges.getChildCount(); i++) {
-//            ATerm t = Term.termAt(ranges, i);
-//            if (Term.isInt(t)) {
-//                ret[i] = Term.toInt(t);
+//            IStrategoTerm t = Term.termAt(ranges, i);
+//            if (isTermInt(t)) {
+//                ret[i] = javaInt(t);
 //            } else {
-////                else if(Term.isAppl(t) && ((ATermAppl)t).getName().equals("range")) {
-////                int s = Term.intAt(t, 0);
-////                int e = Term.intAt(t, 1);
+////                else if(Term.isAppl(t) && ((IStrategoNamed)t).getName().equals("range")) {
+////                int s = intAt(t, 0);
+////                int e = intAt(t, 1);
 //                Tools.debug(t);
 //                throw new InvalidParseTableException("");
 //            }
@@ -488,18 +503,18 @@
 //        return ret;
 //    }
 
-    private RangeList parseRanges(ATermList ranges) throws InvalidParseTableException {
+    private RangeList parseRanges(IStrategoList ranges) throws InvalidParseTableException {
         // TODO: Optimize - directly create int[] for RangeList, don't bother with intermediate Range objects
-        Range[] ret = new Range[ranges.getChildCount()];
+        Range[] ret = new Range[ranges.getSubtermCount()];
 
         for(int i = 0; i < ret.length; i++) {
-            ATerm t = ranges.getFirst();
-            ranges = ranges.getNext();
-            if (Term.isInt(t)) {
-                ret[i] = makeRange(Term.toInt(t));
+            IStrategoTerm t = ranges.head();
+            ranges = ranges.tail();
+            if (isTermInt(t)) {
+                ret[i] = makeRange(javaInt(t));
             } else {
-                int low = Term.intAt(t, 0);
-                int hi = Term.intAt(t, 1);
+                int low = intAt(t, 0);
+                int hi = intAt(t, 1);
                 ret[i] = makeRange(low, hi);
             }
         }
@@ -602,7 +617,7 @@
     	return productionNodes[currentToken];
     }
 
-    public ATerm getProduction(int prod) {
+    public IStrategoTerm getProduction(int prod) {
         if (prod < NUM_CHARS) {
             return factory.makeInt(prod);
         }

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ParseTreeTools.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ParseTreeTools.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ParseTreeTools.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -1,14 +1,13 @@
 package org.spoofax.jsglr.client;
 
-import org.spoofax.jsglr.shared.terms.AFun;
-import org.spoofax.jsglr.shared.terms.ATerm;
-import org.spoofax.jsglr.shared.terms.ATermAppl;
-import org.spoofax.jsglr.shared.terms.ATermFactory;
-import org.spoofax.jsglr.shared.terms.ATermInt;
-import org.spoofax.jsglr.shared.terms.ATermList;
+import org.spoofax.jsglr.client.imploder.ProductionAttributeReader;
 
+/**
+ * @deprecated Use {@link ProductionAttributeReader} instead.
+ */
 public class ParseTreeTools {
 
+	/* UNDONE: no longer maintained - use ProductionAttributeReader instead!!
 	private final static int PARSE_TREE = 0;
 	private final static int APPL_PROD = 0;
 	private final static int APPL_ARGS = 1;
@@ -17,36 +16,36 @@
 	private final static int TERM_CONS = 0;
 	private final static int CONS_NAME = 0;
 
-	private final AFun parsetreeFun;
-	private final AFun applFun;
-	private final AFun termFun;
-	private final AFun prodFun;
-	private final AFun noattrsFun;
-	private final AFun consFun;
+	private final IStrategoConstructor parsetreeFun;
+	private final IStrategoConstructor applFun;
+	private final IStrategoConstructor termFun;
+	private final IStrategoConstructor prodFun;
+	private final IStrategoConstructor noattrsFun;
+	private final IStrategoConstructor consFun;
 
-	public ParseTreeTools(ATermFactory factory) {
+	public ParseTreeTools(TermFactory factory) {
 		super();
-		parsetreeFun = factory.makeAFun("parsetree", 2, false);
-		applFun = factory.makeAFun("appl", 2, false);
-		prodFun = factory.makeAFun("prod", 3, false);
-		noattrsFun = factory.makeAFun("no-attrs", 0, false);
-		termFun = factory.makeAFun("term", 1, false);
-		consFun = factory.makeAFun("cons", 1, false);
+		parsetreeFun = factory.makeConstructor("parsetree", 2);
+		applFun = factory.makeConstructor("appl", 2);
+		prodFun = factory.makeConstructor("prod", 3);
+		noattrsFun = factory.makeConstructor("no-attrs", 0);
+		termFun = factory.makeConstructor("term", 1);
+		consFun = factory.makeConstructor("cons", 1);
 	}
 
-	private static ATermAppl assertAppl(ATerm t) {
-		if(t instanceof ATermAppl) {
-			return (ATermAppl) t;
+	private static IStrategoAppl assertAppl(IStrategoTerm t) {
+		if(isTermAppl(t)) {
+			return (IStrategoAppl) t;
 		}
 		else {
-			throw new IllegalArgumentException("Expected aterm application: " + t);
+			throw new IllegalArgumentException("Expected IStrategoTerm application: " + t);
 		}
 	}
 
-	private static ATermAppl assertAppl(ATerm t, AFun fun) {
-		ATermAppl result = assertAppl(t);
-		if(result.getAFun() != fun) {
-			throw new IllegalArgumentException("Expected application of function " + fun + ": " + result.getAFun());
+	private static IStrategoAppl assertAppl(IStrategoTerm t, IStrategoConstructor fun) {
+		IStrategoAppl result = assertAppl(t);
+		if(result.getConstructor() != fun) {
+			throw new IllegalArgumentException("Expected application of function " + fun + ": " + result.getConstructor());
 		}
 
 		return result;
@@ -56,35 +55,37 @@
 	 * Given a production or application returns the constructor name
 	 * attached to the production, or null if there is no constructor.
 	 *
+	 * @deprecated Use {@link ProductionAttributeReader#getConsAttribute()} instead.
+	 *
 	 * @author Martin Bravenboer
 	 * @author Lennart Kats
-	 */
-	public String getConstructor(ATerm arg) {
-		ATermAppl appl = assertAppl(arg, applFun);
+	 *
+	public String getConstructor(IStrategoTerm arg) {
+		IStrategoAppl appl = assertAppl(arg, applFun);
 
-		ATermAppl prod;
-		if(appl.getAFun() == prodFun) {
+		IStrategoAppl prod;
+		if(appl.getConstructor() == prodFun) {
 			prod = appl;
 		}
-		else if(appl.getAFun() == applFun) {
-			prod = assertAppl((ATerm) appl.getChildAt(APPL_PROD), prodFun);
+		else if(appl.getConstructor() == applFun) {
+			prod = assertAppl(appl.getSubterm(APPL_PROD), prodFun);
 		}
 		else {
 			throw new IllegalArgumentException("Expected prod or appl: " + arg);
 		}
 
-		ATermAppl attrs = assertAppl((ATerm) prod.getChildAt(PROD_ATTRS));
-		if(attrs.getAFun() == noattrsFun) {
+		IStrategoAppl attrs = assertAppl(prod.getSubterm(PROD_ATTRS));
+		if(attrs.getConstructor() == noattrsFun) {
 			return null;
 		}
 		else {
-			for(ATerm attr: (ATermList) attrs.getChildAt(ATTRS_LIST)) {
+			for(IStrategoTerm attr: (IStrategoList) attrs.getSubterm(ATTRS_LIST)) {
 				if (attr instanceof ATermAppl) {
 					ATermAppl namedAttr = (ATermAppl) attr;
-					if (namedAttr.getAFun() == termFun) {
-						namedAttr = (ATermAppl) namedAttr.getChildAt(TERM_CONS);
-						if (namedAttr.getAFun() == consFun) {
-							namedAttr = (ATermAppl) namedAttr.getChildAt(CONS_NAME);
+					if (namedAttr.getConstructor() == termFun) {
+						namedAttr = (ATermAppl) namedAttr.getSubterm(TERM_CONS);
+						if (namedAttr.getConstructor() == consFun) {
+							namedAttr = (ATermAppl) namedAttr.getSubterm(CONS_NAME);
 							return namedAttr.getName();
 						}
 					}
@@ -99,8 +100,8 @@
 	 * Yields a parse tree (parsetree or appl) to a String.
 	 *
 	 * @author Martin Bravenboer
-	 */
-	public String yield(ATerm parsetree) {
+	 *
+	public String yield(IStrategoTerm parsetree) {
 		StringBuilder builder = new StringBuilder();
 		yield(parsetree, builder);
 		return builder.toString();
@@ -110,11 +111,11 @@
 	 * Yields a parse tree (parsetree or appl) to a string builder.
 	 *
 	 * @author Martin Bravenboer
-	 */
-	public void yield(ATerm parsetree, StringBuilder builder) {
+	 *
+	public void yield(IStrategoTerm parsetree, StringBuilder builder) {
 		ATermAppl appl = assertAppl(parsetree);
-		if(appl.getAFun() == parsetreeFun) {
-			appl = assertAppl((ATerm) appl.getChildAt(PARSE_TREE));
+		if(appl.getConstructor() == parsetreeFun) {
+			appl = assertAppl((ATerm) appl.getSubterm(PARSE_TREE));
 		}
 
 		yieldAppl(appl, builder);
@@ -122,12 +123,12 @@
 
 	/**
 	 * Private helper for the yield method.
-	 */
+	 *
 	private void yieldAppl(ATermAppl appl, StringBuilder builder) {
-		for(ATerm t : (ATermList) appl.getChildAt(APPL_ARGS)) {
+		for(IStrategoTerm t : (IStrategoList) appl.getSubterm(APPL_ARGS)) {
 			if(t instanceof ATermAppl) {
 				ATermAppl arg = (ATermAppl) t;
-				if(arg.getAFun() == applFun) {
+				if(arg.getConstructor() == applFun) {
 					yieldAppl(arg, builder);
 				}
 				else {
@@ -143,4 +144,5 @@
 			}
 		}
 	}
-}
\ No newline at end of file
+    */
+}

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ProductionAttributes.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ProductionAttributes.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ProductionAttributes.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -12,7 +12,7 @@
 
 import java.io.Serializable;
 
-import org.spoofax.jsglr.shared.terms.ATerm;
+import org.spoofax.interpreter.terms.IStrategoTerm;
 
 public class ProductionAttributes implements Serializable {
 
@@ -22,9 +22,9 @@
 
     private final boolean isRecover;
 
-    private final transient ATerm abstractCtor;
+    private final transient IStrategoTerm abstractCtor;
 
-    ProductionAttributes(ATerm ctor, int type, boolean isRecover) {
+    ProductionAttributes(IStrategoTerm ctor, int type, boolean isRecover) {
         this.type = type;
         this.abstractCtor = ctor;
         this.isRecover = isRecover;
@@ -34,7 +34,7 @@
         return type;
     }
 
-    public final ATerm getTerm() {
+    public final IStrategoTerm getTerm() {
         return abstractCtor;
     }
 

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/SGLR.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/SGLR.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/SGLR.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -14,12 +14,13 @@
 import java.util.Set;
 
 import org.spoofax.PushbackStringIterator;
+import org.spoofax.interpreter.terms.ITermFactory;
 import org.spoofax.jsglr.shared.ArrayDeque;
 import org.spoofax.jsglr.shared.BadTokenException;
 import org.spoofax.jsglr.shared.SGLRException;
 import org.spoofax.jsglr.shared.TokenExpectedException;
 import org.spoofax.jsglr.shared.Tools;
-import org.spoofax.jsglr.shared.terms.ATermFactory;
+import org.spoofax.terms.TermFactory;
 
 public class SGLR {
 
@@ -43,7 +44,7 @@
 
 	protected volatile boolean asyncAborted;
 
-	private ATermFactory factory;
+	private ITermFactory factory;
 
 	public Frame acceptingStack;
 
@@ -137,7 +138,7 @@
 		basicInit(null);
 	}
 
-	public SGLR(ATermFactory pf, ParseTable parseTable) {
+	public SGLR(ITermFactory pf, ParseTable parseTable) {
 		assert pf != null;
 		assert parseTable != null;
 		// Init with a new factory for both serialized or BAF instances.
@@ -209,10 +210,10 @@
 		asyncAborted = false;
 	}
 
-	private void basicInit(ATermFactory factory) {
+	private void basicInit(ITermFactory factory) {
 		this.factory = factory;
 		if (factory == null) {
-			factory = new ATermFactory();
+			factory = new TermFactory();
 		}
 		activeStacks = new ArrayDeque<Frame>();
 		forActor = new ArrayDeque<Frame>();
@@ -936,7 +937,7 @@
 		this.disambiguator = disambiguator;
 	}
 
-	public ATermFactory getFactory() {
+	public ITermFactory getFactory() {
 		return factory;
 	}
 

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/AstAnnoImploder.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/AstAnnoImploder.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/AstAnnoImploder.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -1,18 +1,27 @@
 package org.spoofax.jsglr.client.imploder;
 
+import static org.spoofax.interpreter.terms.IStrategoTerm.APPL;
+import static org.spoofax.interpreter.terms.IStrategoTerm.INT;
+import static org.spoofax.interpreter.terms.IStrategoTerm.LIST;
+import static org.spoofax.interpreter.terms.IStrategoTerm.PLACEHOLDER;
+import static org.spoofax.interpreter.terms.IStrategoTerm.REAL;
+import static org.spoofax.interpreter.terms.IStrategoTerm.STRING;
+import static org.spoofax.terms.Term.isTermInt;
+import static org.spoofax.terms.Term.isTermNamed;
+import static org.spoofax.terms.Term.javaInt;
+import static org.spoofax.terms.Term.termAt;
+
 import java.util.ArrayList;
 import java.util.List;
 
+import org.spoofax.interpreter.terms.IStrategoInt;
+import org.spoofax.interpreter.terms.IStrategoList;
+import org.spoofax.interpreter.terms.IStrategoNamed;
+import org.spoofax.interpreter.terms.IStrategoPlaceholder;
+import org.spoofax.interpreter.terms.IStrategoReal;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.ITermFactory;
 import org.spoofax.jsglr.client.NotImplementedException;
-import org.spoofax.jsglr.shared.terms.ATerm;
-import org.spoofax.jsglr.shared.terms.ATermAppl;
-import org.spoofax.jsglr.shared.terms.ATermFactory;
-import org.spoofax.jsglr.shared.terms.ATermInt;
-import org.spoofax.jsglr.shared.terms.ATermList;
-import org.spoofax.jsglr.shared.terms.ATermPlaceholder;
-
-import static org.spoofax.jsglr.shared.Tools.*;
-
 
 /**
  * Implodes {ast} annotations in asfix trees.
@@ -30,9 +39,9 @@
 	
 	private final IToken leftToken, rightToken;
 	
-	private final ATermFactory termFactory;
+	private final ITermFactory termFactory;
 	
-	public AstAnnoImploder(ITreeFactory<TNode> factory, ATermFactory termFactory, List<TNode> placeholderValues, IToken leftToken, IToken rightToken) {
+	public AstAnnoImploder(ITreeFactory<TNode> factory, ITermFactory termFactory, List<TNode> placeholderValues, IToken leftToken, IToken rightToken) {
 		this.factory = factory;
 		this.termFactory = termFactory;
 		this.placeholderValues = placeholderValues;
@@ -40,54 +49,52 @@
 		this.rightToken = rightToken;
 	}
 	
-	public TNode implode(ATerm ast, String sort) {
+	public TNode implode(IStrategoTerm ast, String sort) {
 		// Placeholder terms are represented as strings; must parse them and fill in their arguments
 		String astString = ast.toString();
 		if (astString.startsWith("\"") && astString.endsWith("\"")) {
 			astString = astString.substring(1, astString.length() - 1);
 			astString = astString.replace("\\\\", "\\").replace("\\\"", "\"");
-			ast = termFactory.parse(astString);
+			ast = termFactory.parseFromString(astString);
 		}
 		
 		return toNode(ast, sort);
 	}
 	
-	private TNode toNode(ATerm term, String sort) {
-		switch (term.getType()) {
-			case ATerm.PLACEHOLDER:
+	private TNode toNode(IStrategoTerm term, String sort) {
+		switch (term.getTermType()) {
+			case PLACEHOLDER:
 				return placeholderToNode(term, sort);
 				
-			case ATerm.APPL:
-				return applToNode(term, sort);
+			case APPL: case STRING:
+				return namedToNode(term, sort);
 				
-			case ATerm.LIST:
+			case LIST:
 				return listToNode(term, sort);
 				
-			case ATerm.INT:
-				ATermInt i = (ATermInt) term;
-				return factory.createIntTerminal(sort, leftToken, i.getInt());
+			case INT:
+				IStrategoInt i = (IStrategoInt) term;
+				return factory.createIntTerminal(sort, leftToken, i.intValue());
 				
-			/*
-			case ATerm.REAL:
-				ATermInt i = (ATermReal) term;
-				return factory.createRealTerminal(sort, leftToken, i.getReal());
-			*/
+			case REAL:
+				IStrategoReal r = (IStrategoReal) term;
+				return factory.createRealTerminal(sort, leftToken, r.realValue());
 				
 			default:
 				throw new IllegalStateException("Unexpected term type encountered in {ast} attribute");
 		}
 	}
 	
-	private TNode placeholderToNode(ATerm placeholder, String sort) {
-		ATerm term = ((ATermPlaceholder) placeholder).getPlaceholder();
-		if (term.getType() == ATerm.INT) {
-			int id = ((ATermInt) term).getInt();
+	private TNode placeholderToNode(IStrategoTerm placeholder, String sort) {
+		IStrategoTerm term = ((IStrategoPlaceholder) placeholder).getTemplate();
+		if (isTermInt(term)) {
+			int id = javaInt(term);
 			if (1 <= id && id <= placeholderValues.size()) {
 				return placeholderValues.get(id - 1);
 			}
-		} else if (term.getType() == ATerm.APPL) {
-			String type = ((ATermAppl) term).getName();
-			if ("conc".equals(type) && term.getChildCount() == 2) {
+		} else if (isTermNamed(term)) {
+			String type = ((IStrategoNamed) term).getName();
+			if ("conc".equals(type) && term.getSubtermCount() == 2) {
 				TNode left = toNode(termAt(term, 0), null);
 				TNode right = toNode(termAt(term, 1), null);
 				List<TNode> children = new ArrayList<TNode>();
@@ -96,7 +103,7 @@
 				for (TNode node : factory.getChildren(right))
 					children.add(node);
 				return factory.createList(sort, leftToken, rightToken, children);
-			} else if ("yield".equals(type) && term.getChildCount() == 1) {
+			} else if ("yield".equals(type) && term.getSubtermCount() == 1) {
 				throw new NotImplementedException("not implemented: yield in {ast} attribute");
 			}
 		}
@@ -104,24 +111,24 @@
 		throw new IllegalStateException("Error in syntax definition: illegal placeholder in {ast} attribute: " + placeholder);
 	}
 	
-	private TNode applToNode(ATerm term, String sort) {
-		ATermAppl appl = (ATermAppl) term;
-		ArrayList<TNode> children = new ArrayList<TNode>(appl.getChildCount());
-		for (int i = 0; i < appl.getChildCount(); i++) {
+	private TNode namedToNode(IStrategoTerm term, String sort) {
+		IStrategoNamed appl = (IStrategoNamed) term;
+		ArrayList<TNode> children = new ArrayList<TNode>(appl.getSubtermCount());
+		for (int i = 0; i < appl.getSubtermCount(); i++) {
 			children.add(toNode(termAt(appl, i), null));
 		}
-		if (appl.getType() == ATerm.STRING) {
+		if (appl.getTermType() == STRING) {
 			return factory.createStringTerminal(sort, appl.getName(), leftToken);
 		} else {
 			return factory.createNonTerminal(sort, appl.getName(), leftToken, rightToken, children);
 		}
 	}
 	
-	private TNode listToNode(ATerm term, String sort) {
+	private TNode listToNode(IStrategoTerm term, String sort) {
 		// TODO: Fishy (Spoofax/49)
-		ATermList list = (ATermList) term;
-		ArrayList<TNode> children = new ArrayList<TNode>(list.getChildCount());
-		for (int i = 0; i < term.getChildCount(); i++) {
+		IStrategoList list = (IStrategoList) term;
+		ArrayList<TNode> children = new ArrayList<TNode>(list.getSubtermCount());
+		for (int i = 0; i < term.getSubtermCount(); i++) {
 			children.add(toNode(termAt(term, i), null));
 		}
 		return factory.createList(sort, leftToken, rightToken, children);

Added: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/ElementImploderAttachment.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/ElementImploderAttachment.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -0,0 +1,21 @@
+package org.spoofax.jsglr.client.imploder;
+
+/** 
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class ElementImploderAttachment extends ImploderAttachment {
+	
+	public ElementImploderAttachment(String sort, IToken leftToken, IToken rightToken) {
+		super(sort, leftToken, rightToken);
+	}
+
+	@Override
+	public String getSort() {
+		return super.getSort() + "*";
+	}
+	
+	@Override
+	public String getElementSort() {
+		return super.getSort();
+	}
+}

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/ITreeFactory.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/ITreeFactory.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/ITreeFactory.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -2,13 +2,14 @@
 
 import java.util.List;
 
+import org.spoofax.interpreter.terms.ISimpleTerm;
 import org.spoofax.jsglr.client.ITreeBuilder;
 
 /**
  * Constructs tree nodes for imploded parse trees.
  * 
  * @see TreeBuilder  An {@link ITreeBuilder} that creates imploded trees.
- * @see IAstNode     An interface for tree nodes with tokens.
+ * @see ISimpleTerm     An interface for tree nodes with tokens.
  * 
  * @author Lennart Kats <lennart add lclnet.nl>
  */
@@ -54,4 +55,6 @@
 	 * Create an injection node.
 	 */
 	TNode createInjection(String sort, List<TNode> children);
+
+	void setEnableTokens(boolean enableTokens);
 }

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/ITreeInspector.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/ITreeInspector.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/ITreeInspector.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -1,8 +1,10 @@
 package org.spoofax.jsglr.client.imploder;
 
+import org.spoofax.interpreter.terms.ISimpleTerm;
+
 /**
  * @see ITreeFactory  Constructs tree nodes.
- * @see IAstNode      An interface for tree nodes with tokens.
+ * @see ISimpleTerm      An interface for tree nodes with tokens.
  *
  * @author Lennart Kats <lennart add lclnet.nl>
  */

Added: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/ImploderAttachment.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/ImploderAttachment.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -0,0 +1,98 @@
+package org.spoofax.jsglr.client.imploder;
+
+import org.spoofax.interpreter.terms.AbstractTermAttachment;
+import org.spoofax.interpreter.terms.ISimpleTerm;
+import org.spoofax.interpreter.terms.ITermAttachment;
+
+/** 
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class ImploderAttachment extends AbstractTermAttachment {
+	
+	private final IToken leftToken, rightToken;
+	
+	private final String sort;
+	
+	public ImploderAttachment(String sort, IToken leftToken, IToken rightToken) {
+		this.sort = sort;
+		this.leftToken = leftToken;
+		this.rightToken = rightToken;
+	}
+	
+	public Class<? extends ITermAttachment> getAttachmentType() {
+		return ImploderAttachment.class;
+	}
+	
+	public IToken getLeftToken() {
+		return leftToken;
+	}
+	
+	public IToken getRightToken() {
+		return rightToken;
+	}
+	
+	public String getSort() {
+		return sort;
+	}
+	
+	/**
+	 * The element sort for lists and tuples.
+	 * 
+	 * @throws UnsupportedOperationException
+	 *             If the node is not a list or tuple.
+	 */
+	public String getElementSort() {
+		throw new UnsupportedOperationException();
+	}
+
+	public static IToken getLeftToken(ISimpleTerm term) {
+		ImploderAttachment attachment = term.getAttachment(ImploderAttachment.class);
+		if (attachment == null) {
+			return null;
+		} else {
+			return attachment.getLeftToken();
+		}
+	}
+
+	public static IToken getRightToken(ISimpleTerm term) {
+		ImploderAttachment attachment = term.getAttachment(ImploderAttachment.class);
+		if (attachment == null) {
+			return null;
+		} else {
+			return attachment.getRightToken();
+		}
+	}
+
+	public static String getSort(ISimpleTerm term) {
+		ImploderAttachment attachment = term.getAttachment(ImploderAttachment.class);
+		if (attachment == null) {
+			return null;
+		} else {
+			return attachment.getSort();
+		}
+	}
+	
+	/**
+	 * The element sort for lists and tuples.
+	 * 
+	 * @throws UnsupportedOperationException
+	 *             If the node is not a list or tuple.
+	 */
+	public static String getElementSort(ISimpleTerm term) {
+		ImploderAttachment attachment = term.getAttachment(ImploderAttachment.class);
+		if (attachment == null) {
+			return null;
+		} else {
+			return attachment.getElementSort();
+		}
+	}
+	
+	@Override
+	public String toString() {
+		if (getLeftToken() != null) {
+			return "(" + sort + ",\"" + getLeftToken().getTokenizer().toString(getLeftToken(), getRightToken()) + "\")";
+		} else {
+			return "(" + sort + ",null)";
+		}
+	}
+}

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/LabelInfo.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/LabelInfo.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/LabelInfo.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -1,23 +1,23 @@
 package org.spoofax.jsglr.client.imploder;
 
-import static org.spoofax.jsglr.shared.Tools.termAt;
+import static org.spoofax.terms.Term.termAt;
 
-import org.spoofax.jsglr.shared.terms.ATerm;
-import org.spoofax.jsglr.shared.terms.ATermAppl;
-import org.spoofax.jsglr.shared.terms.ATermList;
+import org.spoofax.interpreter.terms.IStrategoAppl;
+import org.spoofax.interpreter.terms.IStrategoList;
+import org.spoofax.interpreter.terms.IStrategoTerm;
 
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
  */
 public class LabelInfo {
 
-	private final ATermAppl production;
+	private final IStrategoAppl production;
 	
 	private final String sort;
 	
 	private final String constructor;
 	
-	private final ATerm astAttribute;
+	private final IStrategoTerm astAttribute;
 	
 	private final boolean isNonContextFree;
 	
@@ -41,10 +41,10 @@
 	
 	private final String metaVarConstructor;
 	
-	public LabelInfo(ProductionAttributeReader reader, ATermAppl production) {
+	public LabelInfo(ProductionAttributeReader reader, IStrategoAppl production) {
 		this.production = production;
-		ATermAppl rhs = getRHS();
-		ATermAppl attrs = getAttrs();
+		IStrategoAppl rhs = getRHS();
+		IStrategoAppl attrs = getAttrs();
 		sort = reader.getSort(rhs);
 		constructor = reader.getConsAttribute(attrs);
 		astAttribute = reader.getAstAttribute(attrs);
@@ -57,19 +57,19 @@
 		isLayout = reader.isLayout(rhs);
 		isLiteral = reader.isLiteral(rhs);
 		isOptional = reader.isOptional(rhs);
-		isSortProduction = reader.sortFun == rhs.getAFun() || reader.parameterizedSortFun == rhs.getAFun();
+		isSortProduction = reader.sortFun == rhs.getConstructor() || reader.parameterizedSortFun == rhs.getConstructor();
 		metaVarConstructor = reader.getMetaVarConstructor(rhs);
 	}
     
-	protected ATermList getLHS() {
+	protected IStrategoList getLHS() {
     	return termAt(production, 0);
     }
     
-	protected ATermAppl getRHS() {
+	protected IStrategoAppl getRHS() {
     	return termAt(production, 1);
     }
     
-	protected ATermAppl getAttrs() {
+	protected IStrategoAppl getAttrs() {
     	return termAt(production, 2);
     }
 	
@@ -81,7 +81,7 @@
 		return constructor;
 	}
 	
-	public ATerm getAstAttribute() {
+	public IStrategoTerm getAstAttribute() {
 		return astAttribute;
 	}
 	

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/ProductionAttributeReader.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/ProductionAttributeReader.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/ProductionAttributeReader.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -1,16 +1,17 @@
 package org.spoofax.jsglr.client.imploder;
 
-import static org.spoofax.jsglr.shared.Tools.applAt;
-import static org.spoofax.jsglr.shared.Tools.asAppl;
-import static org.spoofax.jsglr.shared.Tools.asJavaString;
-import static org.spoofax.jsglr.shared.Tools.isAppl;
-import static org.spoofax.jsglr.shared.Tools.termAt;
-
-import org.spoofax.jsglr.shared.terms.AFun;
-import org.spoofax.jsglr.shared.terms.ATerm;
-import org.spoofax.jsglr.shared.terms.ATermAppl;
-import org.spoofax.jsglr.shared.terms.ATermFactory;
-import org.spoofax.jsglr.shared.terms.ATermList;
+import static org.spoofax.terms.StrategoListIterator.iterable;
+import static org.spoofax.terms.Term.isTermAppl;
+import static org.spoofax.terms.Term.isTermNamed;
+import static org.spoofax.terms.Term.javaString;
+import static org.spoofax.terms.Term.termAt;
+
+import org.spoofax.interpreter.terms.IStrategoAppl;
+import org.spoofax.interpreter.terms.IStrategoConstructor;
+import org.spoofax.interpreter.terms.IStrategoList;
+import org.spoofax.interpreter.terms.IStrategoNamed;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.ITermFactory;
 
 
 /**
@@ -28,117 +29,117 @@
 	
 	private final int ALT_SORT_RIGHT = 1;
 	
-	protected final AFun sortFun;
+	protected final IStrategoConstructor sortFun;
 	
-	protected final AFun parameterizedSortFun;
+	protected final IStrategoConstructor parameterizedSortFun;
 	
-	protected final AFun attrsFun;
+	protected final IStrategoConstructor attrsFun;
 	
-	protected final AFun noAttrsFun;
+	protected final IStrategoConstructor noAttrsFun;
 	
-	protected final AFun preferFun;
+	protected final IStrategoConstructor preferFun;
 	
-	protected final AFun avoidFun;
+	protected final IStrategoConstructor avoidFun;
 	
-	private final AFun varSymFun;
+	private final IStrategoConstructor varSymFun;
 	
-	private final AFun altFun;
+	private final IStrategoConstructor altFun;
 	
-	private final AFun charClassFun;
+	private final IStrategoConstructor charClassFun;
 	
-	private final AFun litFun;
+	private final IStrategoConstructor litFun;
 	
-	private final AFun cilitFun;
+	private final IStrategoConstructor cilitFun;
 	
-	private final AFun lexFun;
+	private final IStrategoConstructor lexFun;
 	
-	private final AFun optFun;
+	private final IStrategoConstructor optFun;
 	
-	private final AFun layoutFun;
+	private final IStrategoConstructor layoutFun;
 	
-	private final AFun cfFun;
+	private final IStrategoConstructor cfFun;
 	
-	private final AFun varsymFun;
+	private final IStrategoConstructor varsymFun;
 	
-	private final AFun seqFun;
+	private final IStrategoConstructor seqFun;
 	
-	private final AFun iterFun;
+	private final IStrategoConstructor iterFun;
 	
-	private final AFun iterStarFun;
+	private final IStrategoConstructor iterStarFun;
 	
-	private final AFun iterPlusFun;
+	private final IStrategoConstructor iterPlusFun;
 	
-	private final AFun iterSepFun;
+	private final IStrategoConstructor iterSepFun;
 	
-	private final AFun iterStarSepFun;
+	private final IStrategoConstructor iterStarSepFun;
 	
-	private final AFun iterPlusSepFun;
+	private final IStrategoConstructor iterPlusSepFun;
 	
-	public ProductionAttributeReader(ATermFactory factory) {
-		sortFun = factory.makeAFun("sort", 1, false);
+	public ProductionAttributeReader(ITermFactory factory) {
+		sortFun = factory.makeConstructor("sort", 1);
 		parameterizedSortFun =
-			factory.makeAFun("parameterized-sort", 2, false);
-		attrsFun = factory.makeAFun("attrs", 1, false);
-		noAttrsFun = factory.makeAFun("no-attrs", 0, false);
-		preferFun = factory.makeAFun("prefer", 0, false);
-		avoidFun = factory.makeAFun("avoid", 0, false);
-		varSymFun = factory.makeAFun("varsym", 1, false);
-		altFun = factory.makeAFun("alt", 2, false);
-		charClassFun = factory.makeAFun("char-class", 1, false);
-		litFun = factory.makeAFun("lit", 1, false);
-		cilitFun = factory.makeAFun("cilit", 1, false);
-		lexFun = factory.makeAFun("lex", 1, false);
-		optFun = factory.makeAFun("opt", 1, false);
-		layoutFun = factory.makeAFun("layout", 0, false);
-		cfFun = factory.makeAFun("cf", 1, false);
-		varsymFun = factory.makeAFun("varsym", 1, false);
-		seqFun = factory.makeAFun("seq", 2, false);
-		iterFun = factory.makeAFun("iter", 1, false);
-		iterStarFun = factory.makeAFun("iter-star", 1, false);
-		iterPlusFun = factory.makeAFun("iter-plus", 1, false);
-		iterSepFun = factory.makeAFun("iter-sep", 2, false);
-		iterStarSepFun = factory.makeAFun("iter-star-sep", 2, false);
-		iterPlusSepFun = factory.makeAFun("iter-plus-sep", 2, false);
-	}
-
-	public String getConsAttribute(ATermAppl attrs) {
-		ATerm consAttr = getAttribute(attrs, "cons");
-		return consAttr == null ? null : ((ATermAppl) consAttr).getName();
+			factory.makeConstructor("parameterized-sort", 2);
+		attrsFun = factory.makeConstructor("attrs", 1);
+		noAttrsFun = factory.makeConstructor("no-attrs", 0);
+		preferFun = factory.makeConstructor("prefer", 0);
+		avoidFun = factory.makeConstructor("avoid", 0);
+		varSymFun = factory.makeConstructor("varsym", 1);
+		altFun = factory.makeConstructor("alt", 2);
+		charClassFun = factory.makeConstructor("char-class", 1);
+		litFun = factory.makeConstructor("lit", 1);
+		cilitFun = factory.makeConstructor("cilit", 1);
+		lexFun = factory.makeConstructor("lex", 1);
+		optFun = factory.makeConstructor("opt", 1);
+		layoutFun = factory.makeConstructor("layout", 0);
+		cfFun = factory.makeConstructor("cf", 1);
+		varsymFun = factory.makeConstructor("varsym", 1);
+		seqFun = factory.makeConstructor("seq", 2);
+		iterFun = factory.makeConstructor("iter", 1);
+		iterStarFun = factory.makeConstructor("iter-star", 1);
+		iterPlusFun = factory.makeConstructor("iter-plus", 1);
+		iterSepFun = factory.makeConstructor("iter-sep", 2);
+		iterStarSepFun = factory.makeConstructor("iter-star-sep", 2);
+		iterPlusSepFun = factory.makeConstructor("iter-plus-sep", 2);
+	}
+
+	public String getConsAttribute(IStrategoAppl attrs) {
+		IStrategoTerm consAttr = getAttribute(attrs, "cons");
+		return consAttr == null ? null : ((IStrategoNamed) consAttr).getName();
 	}
 	
 	// FIXME: support meta-var constructors
-	public String getMetaVarConstructor(ATermAppl rhs) {
-		if (rhs.getChildCount() == 1 && varSymFun == rhs.getAFun()) {
-			return isIterFun(((ATermAppl) rhs.getChildAt(0)).getAFun())
+	public String getMetaVarConstructor(IStrategoAppl rhs) {
+		if (rhs.getSubtermCount() == 1 && varSymFun == rhs.getConstructor()) {
+			return isIterFun(((IStrategoAppl) termAt(rhs, 0)).getConstructor())
 					? "meta-listvar"
 					: "meta-var";
 		}
 		return null;
 	}
 	
-	public ATerm getAstAttribute(ATermAppl attrs) {
+	public IStrategoTerm getAstAttribute(IStrategoAppl attrs) {
 		return getAttribute(attrs, "ast");
 	}
 	
-	public boolean isIndentPaddingLexical(ATermAppl attrs) {
+	public boolean isIndentPaddingLexical(IStrategoAppl attrs) {
 		return getAttribute(attrs, "indentpadding") != null;
 	}
 
 	/** Return the contents of a term attribute (e.g., "cons"), or null if not found. */
-	public ATerm getAttribute(ATermAppl attrs, String attrName) {
-		if (attrs.getAFun() == noAttrsFun)
+	public IStrategoTerm getAttribute(IStrategoAppl attrs, String attrName) {
+		if (attrs.getConstructor() == noAttrsFun)
 			return null;
 		
-		ATermList list = termAt(attrs, 0);
+		IStrategoList list = termAt(attrs, 0);
 		
-		for (ATerm attr : list) {			
-			if (attr instanceof ATermAppl) {
-				ATermAppl namedAttr = (ATermAppl) attr;
+		for (IStrategoTerm attr : iterable(list)) {			
+			if (isTermNamed(attr)) {
+				IStrategoNamed namedAttr = (IStrategoNamed) attr;
 				if (namedAttr.getName().equals("term")) {
 					namedAttr = termAt(namedAttr, 0);
 					
 					if (namedAttr.getName().equals(attrName))
-						return namedAttr.getChildCount() == 1 ? termAt(namedAttr, 0) : namedAttr;
+						return namedAttr.getSubtermCount() == 1 ? termAt(namedAttr, 0) : namedAttr;
 				}				
 			}
 		}
@@ -149,40 +150,41 @@
 	/** 
 	 * Get the RTG sort name of a production RHS, or for lists, the RTG element sort name.
 	 */
-    public String getSort(ATermAppl rhs) {
-    	for (ATerm current = rhs; current.getChildCount() > 0 && isAppl(current); current = termAt(current, 0)) {
-    		AFun cons = asAppl(current).getAFun();
+    public String getSort(IStrategoAppl rhs) {
+    	for (IStrategoTerm current = rhs; current.getSubtermCount() > 0 && isTermAppl(current); current = termAt(current, 0)) {
+    		IStrategoAppl currentAppl = (IStrategoAppl) current;
+			IStrategoConstructor cons = currentAppl.getConstructor();
 			if (cons == sortFun)
-    			return asJavaString(termAt(current, 0));
+    			return javaString(termAt(current, 0));
     		if (cons == parameterizedSortFun)
-    			return getParameterizedSortName(current);
+    			return getParameterizedSortName(currentAppl);
     		if (cons == charClassFun)
     			return null;
     		if (cons == altFun)
-    			return getAltSortName(current);
+    			return getAltSortName(currentAppl);
     	}
     	
     	return null;
     }
     
-    private String getParameterizedSortName(ATerm node) {
+    private String getParameterizedSortName(IStrategoAppl parameterizedSort) {
     	StringBuilder result = new StringBuilder();
     	
-    	result.append(applAt(node, PARAMETRIZED_SORT_NAME).getName());
+    	result.append(((IStrategoNamed)termAt(parameterizedSort, PARAMETRIZED_SORT_NAME)).getName());
     	result.append('_');
     	
-		ATermList args = termAt(node, PARAMETRIZED_SORT_ARGS);
+		IStrategoList args = termAt(parameterizedSort, PARAMETRIZED_SORT_ARGS);
 		
-        for (ATermAppl arg = (ATermAppl) args.getFirst(); !args.getNext().isEmpty(); args = args.getNext()) {
-			result.append(arg.getName());
+        for (IStrategoTerm arg : iterable(args)) {
+			result.append(((IStrategoNamed) arg).getName());
 		}
 		
 		return result.toString();
     }
     
-    private String getAltSortName(ATerm node) {
-		String left = getSort(applAt(node, ALT_SORT_LEFT));
-		String right = getSort(applAt(node, ALT_SORT_RIGHT));
+    private String getAltSortName(IStrategoAppl node) {
+		String left = getSort((IStrategoAppl) termAt(node, ALT_SORT_LEFT));
+		String right = getSort((IStrategoAppl) termAt(node, ALT_SORT_RIGHT));
 		
 		// HACK: In the RTG, alt sorts appear with a number at the end
 		return left + "_" + right + "0";
@@ -197,46 +199,47 @@
 	 * 
 	 * @return true if the current node is lexical.
 	 */
-	public boolean isNonContextFree(ATermAppl rhs) {
-		return (lexFun == rhs.getAFun() || isLiteral(rhs)
+	public boolean isNonContextFree(IStrategoAppl rhs) {
+		return (lexFun == rhs.getConstructor() || isLiteral(rhs)
 		    || isLayout(rhs)) || isVariableNode(rhs);
 	}
 	
-	public boolean isLexical(ATermAppl rhs) {
-		return lexFun == rhs.getAFun();
+	public boolean isLexical(IStrategoAppl rhs) {
+		return lexFun == rhs.getConstructor();
 	}
 
-	public boolean isLayout(ATermAppl rhs) {
-		ATerm details = termAt(rhs, 0);
-		if (!isAppl(details))
+	public boolean isLayout(IStrategoAppl rhs) {
+		IStrategoTerm details = termAt(rhs, 0);
+		if (!isTermAppl(details))
 			return false;
 		
-		if (optFun == asAppl(details).getAFun())
-			details = applAt(details, 0);
+		if (optFun == ((IStrategoAppl) details).getConstructor())
+			details = termAt(details, 0);
 		
-		return layoutFun == asAppl(details).getAFun();
+		return layoutFun == ((IStrategoAppl) details).getConstructor();
 	}
 
-	public boolean isLiteral(ATermAppl rhs) {
-		AFun fun = rhs.getAFun();
+	public boolean isLiteral(IStrategoAppl rhs) {
+		IStrategoConstructor fun = rhs.getConstructor();
 		return litFun == fun || cilitFun == fun;
 	}
 	
-	public boolean isList(ATermAppl rhs) {
-		ATermAppl details = cfFun == rhs.getAFun()
-		                  ? applAt(rhs, 0)
-		                  : rhs;
+	public boolean isList(IStrategoAppl rhs) {
+		IStrategoAppl details = rhs;
+		
+		if (rhs.getConstructor() == cfFun)
+			details = termAt(details, 0);
 		              	
-	  	if (details.getAFun() == optFun)
-	  		details = applAt(details, 0);
+	  	if (details.getConstructor() == optFun)
+	  		details = termAt(details, 0);
 	  	
-		AFun fun = details.getAFun();
+		IStrategoConstructor fun = details.getConstructor();
 		
 		 // FIXME: Spoofax/159: AsfixImploder creates tuples instead of lists for seqs
 		return isIterFun(fun) || seqFun == fun;
 	}
 
-	public boolean isIterFun(AFun fun) {
+	public boolean isIterFun(IStrategoConstructor fun) {
 		return iterFun == fun || iterStarFun == fun || iterPlusFun == fun
 				|| iterSepFun == fun || iterStarSepFun == fun || iterPlusSepFun == fun;
 	}
@@ -247,22 +250,24 @@
 	 * @see #isVariableNode(ATermAppl) 
 	 * @return true if the current node is lexical.
 	 */
-	public boolean isVariableNode(ATermAppl rhs) {
-		return varsymFun == rhs.getAFun();
+	public boolean isVariableNode(IStrategoAppl rhs) {
+		return varsymFun == rhs.getConstructor();
 	}
 
-	public boolean isLexLayout(ATermAppl rhs) {
-		if (rhs.getChildCount() != 1) return false;
-		ATerm child = rhs.getChildAt(0);
-		return isAppl(child) && layoutFun == ((ATermAppl) child).getAFun()
-			&& lexFun == rhs.getAFun();
+	public boolean isLexLayout(IStrategoAppl rhs) {
+		if (rhs.getSubtermCount() != 1) return false;
+		IStrategoTerm child = rhs.getSubterm(0);
+		return isTermAppl(child) && layoutFun == ((IStrategoAppl) child).getConstructor()
+			&& lexFun == rhs.getConstructor();
 	}
 
-	public boolean isOptional(ATermAppl rhs) {
-		if (rhs.getAFun() == optFun)
+	public boolean isOptional(IStrategoAppl rhs) {
+		if (rhs.getConstructor() == optFun)
 			return true;
-		rhs = termAt(rhs, 0);
-		return rhs.getChildCount() == 1 && rhs.getAFun() == optFun;
+		IStrategoTerm contents = termAt(rhs, 0);
+		return contents.getSubtermCount() == 1
+			&& isTermAppl(contents)
+			&& ((IStrategoAppl) contents).getConstructor() == optFun;
 	}
 
 }

Copied and modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/SimpleTermVisitor.java (from r21591, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/AstNodeVisitor.java)
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/AstNodeVisitor.java	Tue Dec 28 15:31:36 2010	(r21591, copy source)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/SimpleTermVisitor.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -2,16 +2,18 @@
 
 import java.util.Iterator;
 
+import org.spoofax.interpreter.terms.ISimpleTerm;
+
 
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
  */
-public abstract class AstNodeVisitor implements IAstNodeVisitor {
+public abstract class SimpleTermVisitor implements ISimpleTermVisitor {
 	
-	public final boolean visit(IAstNode tree) {
-		Iterator<IAstNode> iterator = tryGetListIterator(tree); 
-		for (int i = 0, max = tree.getChildCount(); i < max; i++) {
-			IAstNode child = iterator == null ? tree.getChildAt(i) : iterator.next();
+	public final boolean visit(ISimpleTerm tree) {
+		Iterator<ISimpleTerm> iterator = tryGetListIterator(tree); 
+		for (int i = 0, max = tree.getSubtermCount(); i < max; i++) {
+			ISimpleTerm child = iterator == null ? tree.getSubterm(i) : iterator.next();
 			preVisit(child);
 			boolean isDone = visit(child);
 			postVisit(child);
@@ -21,19 +23,19 @@
 	}
 
 	@SuppressWarnings("unchecked")
-	protected static Iterator<IAstNode> tryGetListIterator(IAstNode tree) {
+	protected static Iterator<ISimpleTerm> tryGetListIterator(ISimpleTerm tree) {
 		if (tree instanceof Iterable) {
-			return ((Iterable<IAstNode>) tree).iterator();
+			return ((Iterable<ISimpleTerm>) tree).iterator();
 		} else {
 			return null;
 		}
 	}
 	
-	public void preVisit(IAstNode node) {
+	public void preVisit(ISimpleTerm node) {
 		// No default implementation
 	}
 	
-	public void postVisit(IAstNode node) {
+	public void postVisit(ISimpleTerm node) {
 		// No default implementation
 	}
 	
@@ -44,8 +46,8 @@
 
 //Local interface avoids abstract method and subsequent @Override annotation requirement
 
-interface IAstNodeVisitor {
-	void preVisit(IAstNode node);
+interface ISimpleTermVisitor {
+	void preVisit(ISimpleTerm node);
 
-	void postVisit(IAstNode node);
+	void postVisit(ISimpleTerm node);
 }
\ No newline at end of file

Copied and modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/TermTreeFactory.java (from r21591, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/ATermTreeFactory.java)
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/ATermTreeFactory.java	Tue Dec 28 15:31:36 2010	(r21591, copy source)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/TermTreeFactory.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -1,166 +1,215 @@
 package org.spoofax.jsglr.client.imploder;
 
-import static org.spoofax.jsglr.shared.terms.ATerm.APPL;
-import static org.spoofax.jsglr.shared.terms.ATerm.INT;
-import static org.spoofax.jsglr.shared.terms.ATerm.LIST;
-import static org.spoofax.jsglr.shared.terms.ATerm.STRING;
-import static org.spoofax.jsglr.shared.terms.ATerm.TUPLE;
+import static org.spoofax.interpreter.terms.IStrategoTerm.APPL;
+import static org.spoofax.interpreter.terms.IStrategoTerm.INT;
+import static org.spoofax.interpreter.terms.IStrategoTerm.LIST;
+import static org.spoofax.interpreter.terms.IStrategoTerm.MUTABLE;
+import static org.spoofax.interpreter.terms.IStrategoTerm.REAL;
+import static org.spoofax.interpreter.terms.IStrategoTerm.STRING;
+import static org.spoofax.interpreter.terms.IStrategoTerm.TUPLE;
+import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getElementSort;
+import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getSort;
+import static org.spoofax.terms.AbstractTermFactory.EMPTY;
+import static org.spoofax.terms.StrategoListIterator.iterable;
+import static org.spoofax.terms.Term.isTermAppl;
+import static org.spoofax.terms.Term.isTermString;
 
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 
+import org.spoofax.interpreter.terms.IStrategoAppl;
+import org.spoofax.interpreter.terms.IStrategoConstructor;
+import org.spoofax.interpreter.terms.IStrategoInt;
+import org.spoofax.interpreter.terms.IStrategoList;
+import org.spoofax.interpreter.terms.IStrategoString;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.ITermFactory;
 import org.spoofax.jsglr.client.NotImplementedException;
-import org.spoofax.jsglr.shared.terms.AFun;
-import org.spoofax.jsglr.shared.terms.ATerm;
-import org.spoofax.jsglr.shared.terms.ATermAppl;
-import org.spoofax.jsglr.shared.terms.ATermFactory;
-import org.spoofax.jsglr.shared.terms.ATermInt;
-import org.spoofax.jsglr.shared.terms.ATermList;
-import org.spoofax.jsglr.shared.terms.ATermString;
-import org.spoofax.jsglr.shared.terms.ATermTuple;
+import org.spoofax.terms.TermFactory;
 
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
  */
-public class ATermTreeFactory implements ITreeFactory<ATerm> {
+public class TermTreeFactory implements ITreeFactory<IStrategoTerm> {
 	
-	private final ATermFactory factory;
+	private final ITermFactory originalFactory;
 	
-	public ATermTreeFactory() {
-		this(new ATermFactory());
+	private ITermFactory factory;
+	
+	private boolean enableTokens;
+	
+	public TermTreeFactory() {
+		this(new TermFactory());
+	}
+	
+	/**
+	 * Creates a new TermTreeFactory.
+	 * Must be done using an ITermFactory that supports creating
+	 * mutable terms; this constructor calls setDefaultStorageType(MUTABLE).
+	 */
+	public TermTreeFactory(ITermFactory factory) {
+		originalFactory = factory;
+		setEnableTokens(false);
 	}
 	
-	public ATermTreeFactory(ATermFactory factory) {
-		this.factory = factory;
+	public void setEnableTokens(boolean enableTokens) {
+		this.enableTokens = enableTokens;
+		if (enableTokens) {
+			factory = originalFactory.getFactoryWithStorageType(MUTABLE);
+			if (factory.getDefaultStorageType() != MUTABLE
+					|| factory.makeList(EMPTY).getStorageType() != MUTABLE
+					|| factory.makeString("Sanity").getStorageType() != MUTABLE) {
+				throw new IllegalStateException("Term factory does not support MUTABLE terms, required for creating terms with (token) attachments");
+			}
+		} else {
+			factory = originalFactory;
+		}
 	}
 	
-	public ATermFactory getTermFactory() {
+	/**
+	 * @deprecated May return a copy of the term factory that creates mutable terms.
+	 */
+	public ITermFactory getTermFactory() {
 		return factory;
 	}
 	
-	public AFun createConstructor(String name, int childCount) {
-		return factory.makeAFun(name, childCount, false);
+	public ITermFactory getOriginalTermFactory() {
+		return originalFactory;
+	}
+	
+	public IStrategoConstructor createConstructor(String name, int childCount) {
+		return factory.makeConstructor(name, childCount);
 	}
 
-	public ATermAppl createNonTerminal(String sort, String constructor,
-			IToken leftToken, IToken rightToken, List<ATerm> children) {
+	public IStrategoTerm createNonTerminal(String sort, String constructor,
+			IToken leftToken, IToken rightToken, List<IStrategoTerm> children) {
 		
-		// TODO: Optimize - cache afuns? hard to do up front, messy to do now in the LabelInfo objects 
-		AFun afun = factory.makeAFun(constructor, children.size(), false);
-		ATermAppl result = factory.makeAppl(afun, toArray(children));
-		result.internalSetTokens(leftToken, rightToken);
-		result.internalSetSort(sort);
+		// TODO: Optimize - cache IStrategoConstructors in fields? hard to do up front, messy to do now in the LabelInfo objects 
+		IStrategoConstructor cons = factory.makeConstructor(constructor, children.size());
+		IStrategoTerm result = factory.makeAppl(cons, children.toArray(new IStrategoTerm[children.size()]));
+		configure(result, sort, leftToken, rightToken, false);
 		return result;
 	}
 
-	public ATermInt createIntTerminal(String sort, IToken token, int value) {
-		ATermInt result = factory.makeInt(value);
-		result.internalSetTokens(token, token);
-		result.internalSetSort(sort);
+	public IStrategoTerm createIntTerminal(String sort, IToken token, int value) {
+		IStrategoTerm result = factory.makeInt(value);
+		configure(result, sort, token, token, false);
 		return result;
 	}
 
-	public ATerm createRealTerminal(String sort, IToken token, double value) {
-		throw new UnsupportedOperationException("ATermReal not supported");
+	public IStrategoTerm createRealTerminal(String sort, IToken token, double value) {
+		IStrategoTerm result = factory.makeReal(value);
+		configure(result, sort, token, token, false);
+		return result;
 	}
 
-	public ATermString createStringTerminal(String sort, String value, IToken token) {
-		ATermString result = factory.makeString(value);
-		result.internalSetTokens(token, token);
-		result.internalSetSort(sort);
+	public IStrategoTerm createStringTerminal(String sort, String value, IToken token) {
+		IStrategoTerm result = factory.makeString(value);
+		configure(result, sort, token, token, false);
 		return result;
 	}
 
-	public ATermTuple createTuple(String elementSort, IToken leftToken,
-			IToken rightToken, List<ATerm> children) {
+	public IStrategoTerm createTuple(String elementSort, IToken leftToken,
+			IToken rightToken, List<IStrategoTerm> children) {
 		
-		ATermTuple result = factory.makeTuple(toArray(children));
-		result.internalSetTokens(leftToken, rightToken);
-		result.internalSetSort(elementSort);
+		IStrategoTerm result = factory.makeTuple(toArray(children));
+		configure(result, elementSort, leftToken, rightToken, true);
 		return result;
 	}
 
-	public ATermAppl createAmb(List<ATerm> alternatives) {
+	public IStrategoTerm createAmb(List<IStrategoTerm> alternatives) {
 		IToken leftToken = null; 
 		IToken rightToken = null;
 		if (alternatives.size() > 0) {
-			leftToken = alternatives.get(0).getLeftToken();
-			rightToken = alternatives.get(alternatives.size() - 1).getRightToken();
+			leftToken = getLeftToken(alternatives.get(0));
+			rightToken = getRightToken(alternatives.get(alternatives.size() - 1));
 		}
 		
-		List<ATerm> alternativesInList = new ArrayList<ATerm>();
+		List<IStrategoTerm> alternativesInList = new ArrayList<IStrategoTerm>();
 		alternativesInList.add(createList(null, leftToken, rightToken, alternatives));
 		
 		return createNonTerminal(null, "amb", leftToken, rightToken, alternativesInList);
 	}
 
-	public ATermList createList(String elementSort, IToken leftToken,
-			IToken rightToken, List<ATerm> children) {
+	public IStrategoTerm createList(String elementSort, IToken leftToken,
+			IToken rightToken, List<IStrategoTerm> children) {
 		
-		ATermList result = factory.makeList(toArray(children));
-		result.internalSetTokens(leftToken, rightToken);
-		result.internalSetSort(elementSort);
+		IStrategoTerm result = factory.makeList(toArray(children));
+		configure(result, elementSort, leftToken, rightToken, true);
 		return result;
 	}
 	
-	public ATerm recreateNode(ATerm oldNode, IToken leftToken, IToken rightToken, List<ATerm> children) {
-		switch (oldNode.getType()) {
+	public IStrategoTerm recreateNode(IStrategoTerm oldNode, IToken leftToken, IToken rightToken, List<IStrategoTerm> children) {
+		switch (oldNode.getTermType()) {
 			case INT:
-				return createIntTerminal(null, leftToken, ((ATermInt) oldNode).getInt());
+				return createIntTerminal(getSort(oldNode), leftToken, ((IStrategoInt) oldNode).intValue());
 			case APPL:
-				return createNonTerminal(null, ((ATermAppl) oldNode).getName(), leftToken, rightToken, children);
+				return createNonTerminal(getSort(oldNode), ((IStrategoAppl) oldNode).getName(), leftToken, rightToken, children);
 			case LIST:
-				return createList(null, leftToken, rightToken, children);
+				return createList(getElementSort(oldNode), leftToken, rightToken, children);
 			case STRING:
-				return createStringTerminal(null, ((ATermString) oldNode).getString(), leftToken);
+				return createStringTerminal(getSort(oldNode), ((IStrategoString) oldNode).stringValue(), leftToken);
 			case TUPLE:
+				return createTuple(getElementSort(oldNode), leftToken, rightToken, children);
+			case REAL:
 			default:
-				throw new NotImplementedException("Recreating term of type " + oldNode.getType() + ": " + oldNode); 
+				throw new NotImplementedException("Recreating term of type " + oldNode.getTermType() + " (" + oldNode + ") not supported"); 
 		}
 	}
 
-	public String tryGetStringValue(ATerm node) {
-		return node.getType() == ATerm.STRING ? ((ATermString) node).getString() : null;
+	public String tryGetStringValue(IStrategoTerm node) {
+		return isTermString(node) ? ((IStrategoString) node).stringValue() : null;
 	}
 
-	public ATerm createInjection(String sort, List<ATerm> children) {
+	public IStrategoTerm createInjection(String sort, List<IStrategoTerm> children) {
 		return children.get(0);
 	}
 
-	public Iterable<ATerm> getChildren(ATerm node) {
+	public Iterable<IStrategoTerm> getChildren(IStrategoTerm node) {
 		if (node instanceof Iterable<?>) {
 			@SuppressWarnings("unchecked")
-			Iterable<ATerm> result = (Iterable<ATerm>) node;
+			Iterable<IStrategoTerm> result = (Iterable<IStrategoTerm>) node;
 			return result;
 		} else {
-			if (node.getChildCount() == 0)
+			if (node.getSubtermCount() == 0)
 				return Collections.emptyList();
-			ArrayList<ATerm> children = new ArrayList<ATerm>(node.getChildCount());
-			for (int i = 0, max = node.getChildCount(); i < max; i++) {
-				children.add(node.getChildAt(i));
+			ArrayList<IStrategoTerm> children = new ArrayList<IStrategoTerm>(node.getSubtermCount());
+			for (int i = 0, max = node.getSubtermCount(); i < max; i++) {
+				children.add(node.getSubterm(i));
 			}
 			return children;
 		}
 	}
 
-	private static ATerm[] toArray(List<ATerm> children) {
-		return children.toArray(new ATerm[children.size()]);
+	private static IStrategoTerm[] toArray(List<IStrategoTerm> children) {
+		return children.toArray(new IStrategoTerm[children.size()]);
 	}
 
-	public IToken getLeftToken(ATerm node) {
-		return node.getLeftToken();
+	public final IToken getLeftToken(IStrategoTerm term) {
+		return ImploderAttachment.getLeftToken(term);
 	}
 
-	public IToken getRightToken(ATerm node) {
-		return node.getRightToken();
+	public final IToken getRightToken(IStrategoTerm term) {
+		return ImploderAttachment.getRightToken(term);
 	}
 	
-	public Iterable<ATerm> tryGetAmbChildren(ATerm node) {
-		if (node.getType() == APPL && "amb".equals(((ATermAppl) node).getName())) {
-			return (ATermList) node.getChildAt(0);
+	public Iterable<IStrategoTerm> tryGetAmbChildren(IStrategoTerm node) {
+		// TODO: optimize - use getConstructor() instead and make an ambConstructor field
+		if (isTermAppl(node) && "amb".equals(((IStrategoAppl) node).getName())) {
+			return iterable((IStrategoList) node.getSubterm(0));
 		} else {
 			return null;
 		}
 	}
+	
+	protected void configure(IStrategoTerm term, String sort, IToken leftToken, IToken rightToken, boolean isListOrTuple) {
+		assert isListOrTuple
+			== (term.getTermType() == TUPLE || term.getTermType() == LIST);
+		if (enableTokens) {
+			term.putAttachment(isListOrTuple ?
+				  new ElementImploderAttachment(sort, leftToken, rightToken)
+				: new ImploderAttachment(sort, leftToken, rightToken));
+		}
+	}
 }

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/TokenKindManager.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/TokenKindManager.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/TokenKindManager.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -7,14 +7,13 @@
 import static org.spoofax.jsglr.client.imploder.IToken.TK_OPERATOR;
 import static org.spoofax.jsglr.client.imploder.IToken.TK_STRING;
 import static org.spoofax.jsglr.client.imploder.IToken.TK_VAR;
-import static org.spoofax.jsglr.shared.Tools.applAt;
-import static org.spoofax.jsglr.shared.Tools.asAppl;
-import static org.spoofax.jsglr.shared.Tools.intAt;
-import static org.spoofax.jsglr.shared.Tools.isAppl;
-import static org.spoofax.jsglr.shared.Tools.termAt;
+import static org.spoofax.terms.Term.intAt;
+import static org.spoofax.terms.Term.isTermAppl;
+import static org.spoofax.terms.Term.termAt;
 
-import org.spoofax.jsglr.shared.terms.ATerm;
-import org.spoofax.jsglr.shared.terms.ATermAppl;
+import org.spoofax.interpreter.terms.IStrategoAppl;
+import org.spoofax.interpreter.terms.IStrategoString;
+import org.spoofax.interpreter.terms.IStrategoTerm;
 
 /**
  * Class that handles producing and printing token kinds.
@@ -60,8 +59,8 @@
 	protected static boolean isOperator(LabelInfo label) {
 		if (!label.isLiteral()) return false;
 		
-		ATermAppl lit = applAt(label.getRHS(), 0);
-		String contents = lit.getName();
+		IStrategoString lit = termAt(label.getRHS(), 0);
+		String contents = lit.stringValue();
 		
 		for (int i = 0; i < contents.length(); i++) {
 			char c = contents.charAt(i);
@@ -75,11 +74,11 @@
 		return topdownHasSpaces(label.getRHS());
 	}
 	
-	private static boolean topdownHasSpaces(ATerm term) {
+	private static boolean topdownHasSpaces(IStrategoTerm term) {
 		// Return true if any character range of this contains spaces
-		for (int i = 0; i < term.getChildCount(); i++) {
-			ATerm child = termAt(term, i);
-			if (isAppl(child) && asAppl(child).getName().equals("range")) {
+		for (int i = 0; i < term.getSubtermCount(); i++) {
+			IStrategoTerm child = termAt(term, i);
+			if (isRangeAppl(child)) {
 				int start = intAt(child, RANGE_START);
 				int end = intAt(child, RANGE_END);
 				if (start <= ' ' && ' ' <= end) return true;
@@ -90,18 +89,23 @@
 		
 		return false;
 	}
+
+	private static boolean isRangeAppl(IStrategoTerm child) {
+		// TODO: Optimize - use getConstructor() instead and make a "range" field
+		return isTermAppl(child) && ((IStrategoAppl) child).getName().equals("range");
+	}
 	
 	protected static boolean isNumberLiteral(LabelInfo label) {
-		ATerm range = getFirstRange(label.getLHS());
+		IStrategoTerm range = getFirstRange(label.getLHS());
 		
 		return range != null && intAt(range, RANGE_START) == '0' && intAt(range, RANGE_END) == '9';
 	}
 	
-	private static ATerm getFirstRange(ATerm term) {
+	private static IStrategoTerm getFirstRange(IStrategoTerm term) {
 		// Get very first character range in this term
-		for (int i = 0; i < term.getChildCount(); i++) {
-			ATerm child = termAt(term, i);
-			if (isAppl(child) && asAppl(child).getName().equals("range")) {
+		for (int i = 0; i < term.getSubtermCount(); i++) {
+			IStrategoTerm child = termAt(term, i);
+			if (isRangeAppl(child)) {
 				return child;
 			} else {
 				child = getFirstRange(child);

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -7,20 +7,20 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import org.spoofax.interpreter.terms.IStrategoAppl;
+import org.spoofax.interpreter.terms.ITermFactory;
 import org.spoofax.jsglr.client.AbstractParseNode;
 import org.spoofax.jsglr.client.Amb;
 import org.spoofax.jsglr.client.ParseNode;
 import org.spoofax.jsglr.client.ParseProductionNode;
 import org.spoofax.jsglr.client.ParseTable;
 import org.spoofax.jsglr.client.RecoveryConnector;
-import org.spoofax.jsglr.shared.terms.ATermAppl;
-import org.spoofax.jsglr.shared.terms.ATermFactory;
 
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
  * @author Karl Trygve Kalleberg <karltk near strategoxt dot org>
  */
- at SuppressWarnings({"rawtypes", "unchecked"})
+ at SuppressWarnings({"rawtypes", "unchecked"}) // FIXME: class-wide {"rawtypes", "unchecked"}?!
 public class TreeBuilder extends TopdownTreeBuilder {
 	
 	public static final char SKIPPED_CHAR = (char) -1; // TODO: sync with ParseErorHandler
@@ -47,7 +47,7 @@
 	
 	private ProductionAttributeReader prodReader;
 
-	private ATermFactory termFactory;
+	private ITermFactory termFactory;
 	
 	private LabelInfo[] labels;
 	
@@ -78,22 +78,23 @@
 	public TreeBuilder(ITreeFactory treeFactory, boolean disableTokens) {
 		this.factory = treeFactory;
 		this.disableTokens = disableTokens;
+		treeFactory.setEnableTokens(!disableTokens);
 	}
 
 	public void initializeTable(ParseTable table, int productionCount, int labelStart, int labelCount) {
 		this.table = table;
 		this.termFactory = table.getFactory();
 		if (initializeFactories) {
-			factory = new ATermTreeFactory(termFactory);
+			factory = new TermTreeFactory(termFactory);
 		}
-		assert !(factory instanceof ATermTreeFactory) || ((ATermTreeFactory) factory).getTermFactory() == table.getFactory(); 
+		assert !(factory instanceof TermTreeFactory) || ((TermTreeFactory) factory).getOriginalTermFactory() == table.getFactory(); 
 		assert !(tokenizer instanceof Tokenizer) || ((Tokenizer) tokenizer).getKeywordRecognizer() == table.getKeywordRecognizer(); 
 		this.prodReader = new ProductionAttributeReader(termFactory);
 		this.labels = new LabelInfo[labelCount - labelStart];
 		this.labelStart = labelStart;
 	}
 
-	public void initializeLabel(int labelNumber, ATermAppl parseTreeProduction) {
+	public void initializeLabel(int labelNumber, IStrategoAppl parseTreeProduction) {
 		labels[labelNumber - labelStart] = new LabelInfo(prodReader, parseTreeProduction);
 	}
 	
@@ -165,7 +166,7 @@
 				inLexicalContext = lexicalStart = true;
 			} else if (subnodes.length > 0 && subnodes[0] instanceof ParseProductionNode
 					&& label.isSortProduction()
-					&& label.getLHS().getChildCount() == 1) {
+					&& label.getLHS().getSubtermCount() == 1) {
 				return createIntTerminal(label, subnodes);
 			}
 		}

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/incremental/DamageRegionAnalyzer.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/incremental/DamageRegionAnalyzer.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/incremental/DamageRegionAnalyzer.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -1,5 +1,8 @@
 package org.spoofax.jsglr.client.incremental;
 
+import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getLeftToken;
+import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getRightToken;
+import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getSort;
 import static org.spoofax.jsglr.client.imploder.Tokenizer.findLeftMostLayoutToken;
 import static org.spoofax.jsglr.client.imploder.Tokenizer.findRightMostLayoutToken;
 import static org.spoofax.jsglr.client.incremental.IncrementalSGLR.isRangeOverlap;
@@ -10,7 +13,7 @@
 import java.util.List;
 import java.util.Set;
 
-import org.spoofax.jsglr.client.imploder.IAstNode;
+import org.spoofax.interpreter.terms.ISimpleTerm;
 import org.spoofax.jsglr.client.imploder.IToken;
 
 /**
@@ -40,26 +43,26 @@
 	 * Gets all non-list tree nodes from the original tree
 	 * that are in the damage region according to {@link #isDamageTreeNode}.
 	 */
-	public List<IAstNode> getDamageNodes(IAstNode tree) {
-		return getDamageRegionTreeNodes(tree, new ArrayList<IAstNode>(), true, 0);
+	public List<ISimpleTerm> getDamageNodes(ISimpleTerm tree) {
+		return getDamageRegionTreeNodes(tree, new ArrayList<ISimpleTerm>(), true, 0);
 	}
 	
 	/**
 	 * Gets all non-list tree nodes from the partial result tree
 	 * that are in the damage region according to {@link #isDamageTreeNode}.
 	 */
-	public List<IAstNode> getDamageNodesForPartialTree(IAstNode tree, int skippedChars) {
-		return getDamageRegionTreeNodes(tree, new ArrayList<IAstNode>(), false, skippedChars);
+	public List<ISimpleTerm> getDamageNodesForPartialTree(ISimpleTerm tree, int skippedChars) {
+		return getDamageRegionTreeNodes(tree, new ArrayList<ISimpleTerm>(), false, skippedChars);
 	}
 
-	private List<IAstNode> getDamageRegionTreeNodes(IAstNode tree, List<IAstNode> results, boolean isOriginalTree, int skippedChars) {
+	private List<ISimpleTerm> getDamageRegionTreeNodes(ISimpleTerm tree, List<ISimpleTerm> results, boolean isOriginalTree, int skippedChars) {
 		if (!tree.isList() && isDamageTreeNode(tree, isOriginalTree, skippedChars)) {
 			results.add(tree);
 		} else {
 			// Recurse
-			Iterator<IAstNode> iterator = tryGetListIterator(tree); 
-			for (int i = 0, max = tree.getChildCount(); i < max; i++) {
-				IAstNode child = iterator == null ? tree.getChildAt(i) : iterator.next();
+			Iterator<ISimpleTerm> iterator = tryGetListIterator(tree); 
+			for (int i = 0, max = tree.getSubtermCount(); i < max; i++) {
+				ISimpleTerm child = iterator == null ? tree.getSubterm(i) : iterator.next();
 				getDamageRegionTreeNodes(child, results, isOriginalTree, skippedChars);
 			}
 		}
@@ -73,20 +76,20 @@
 	 * with a sort in {@link #incrementalSorts} regardless of whether they own the tokens
 	 * or not.
 	 */
-	protected boolean isDamageTreeNode(IAstNode tree, boolean isOriginalTree, int skippedChars) {
-		IToken current = findLeftMostLayoutToken(tree.getLeftToken());
-		IToken last = findRightMostLayoutToken(tree.getRightToken());
+	protected boolean isDamageTreeNode(ISimpleTerm tree, boolean isOriginalTree, int skippedChars) {
+		IToken current = findLeftMostLayoutToken(getLeftToken(tree));
+		IToken last = findRightMostLayoutToken(getRightToken(tree));
 		if (current != null && last != null) {
 			if (!isDamagedRange(
 					current.getStartOffset(), last.getEndOffset(), isOriginalTree, skippedChars))
 				return false;
-			if (incrementalSorts.contains(tree.getSort()))
+			if (incrementalSorts.contains(getSort(tree)))
 				return true;
-			Iterator<IAstNode> iterator = tryGetListIterator(tree); 
-			for (int i = 0, max = tree.getChildCount(); i < max; i++) {
-				IAstNode child = iterator == null ? tree.getChildAt(i) : iterator.next();
-				IToken childLeft = findLeftMostLayoutToken(child.getLeftToken());
-				IToken childRight = findRightMostLayoutToken(child.getRightToken());
+			Iterator<ISimpleTerm> iterator = tryGetListIterator(tree); 
+			for (int i = 0, max = tree.getSubtermCount(); i < max; i++) {
+				ISimpleTerm child = iterator == null ? tree.getSubterm(i) : iterator.next();
+				IToken childLeft = findLeftMostLayoutToken(getLeftToken(child));
+				IToken childRight = findRightMostLayoutToken(getRightToken(child));
 				if (childLeft != null && childRight != null) {
 					if (childLeft.getIndex() > current.getIndex()
 							&& isDamagedRange(

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/incremental/IncrementalInputBuilder.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/incremental/IncrementalInputBuilder.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/incremental/IncrementalInputBuilder.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -1,5 +1,8 @@
 package org.spoofax.jsglr.client.incremental;
 
+import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getLeftToken;
+import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getRightToken;
+import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getSort;
 import static java.lang.Math.max;
 import static java.lang.Math.min;
 import static org.spoofax.jsglr.client.incremental.IncrementalSGLR.DEBUG;
@@ -9,7 +12,7 @@
 import java.util.Iterator;
 import java.util.Set;
 
-import org.spoofax.jsglr.client.imploder.IAstNode;
+import org.spoofax.interpreter.terms.ISimpleTerm;
 import org.spoofax.jsglr.client.imploder.IToken;
 
 /**
@@ -63,7 +66,7 @@
 		this.damageSizeChange = damageAnalyzer.damageSizeChange;
 	}
 
-	public String buildPartialInput(IAstNode oldTree) throws IncrementalSGLRException {
+	public String buildPartialInput(ISimpleTerm oldTree) throws IncrementalSGLRException {
 		isSkipping = isDamagePrinted = false;
 		skippedCharsAfterDamage = skippedCharsBeforeDamage = 0;
 		appendTree(oldTree);
@@ -88,9 +91,9 @@
 	/**
 	 * @return true if the current node was printed to the {@link #result} string.
 	 */
-	private boolean appendTree(IAstNode oldTree) throws IncrementalSGLRException {
-		IToken left = oldTree.getLeftToken();
-		IToken right = oldTree.getRightToken();
+	private boolean appendTree(ISimpleTerm oldTree) throws IncrementalSGLRException {
+		IToken left = getLeftToken(oldTree);
+		IToken right = getRightToken(oldTree);
 		int startOffset = 0;
 		int endOffset = 0;
 		boolean isSkippingStart = false;
@@ -99,18 +102,18 @@
 			startOffset = left.getStartOffset();
 			endOffset = right.getEndOffset();
 			
-			if (!isSkipping && !oldTree.isList() && incrementalSorts.contains(oldTree.getSort())
+			if (!isSkipping && !oldTree.isList() && incrementalSorts.contains(getSort(oldTree))
 					&& !isRangeOverlap(damageStart, damageEnd, startOffset, endOffset)) {
 					   //!isDamagedNodeOrLayout(left, right)) {
 				isSkipping = isSkippingStart = true;
 			}
 
 			boolean wasSkipped = false;
-			Iterator<IAstNode> iterator = tryGetListIterator(oldTree); 
-			for (int i = 0, max = oldTree.getChildCount(); i < max; i++) {
-				IAstNode child = iterator == null ? oldTree.getChildAt(i) : iterator.next();
-				IToken childLeft = child.getLeftToken();
-				IToken childRight = child.getRightToken();
+			Iterator<ISimpleTerm> iterator = tryGetListIterator(oldTree); 
+			for (int i = 0, max = oldTree.getSubtermCount(); i < max; i++) {
+				ISimpleTerm child = iterator == null ? oldTree.getSubterm(i) : iterator.next();
+				IToken childLeft = getLeftToken(child);
+				IToken childRight = getRightToken(child);
 				if (childLeft != null)
 					appendToken(startOffset, childLeft.getStartOffset() - 1);
 				if (wasSkipped) isSkipping = false;
@@ -121,7 +124,7 @@
 			appendToken(startOffset, endOffset);
 			if (wasSkipped) isSkipping = false;
 		} else {
-			assert oldTree.getChildCount() == 0 :
+			assert oldTree.getSubtermCount() == 0 :
 				"No tokens for tree with children??";
 		}
 		

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -2,15 +2,17 @@
 
 import static java.lang.Math.max;
 import static java.lang.Math.min;
+import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getLeftToken;
+import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getSort;
 
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
 
+import org.spoofax.interpreter.terms.ISimpleTerm;
 import org.spoofax.jsglr.client.ParseException;
 import org.spoofax.jsglr.client.SGLR;
-import org.spoofax.jsglr.client.imploder.IAstNode;
 import org.spoofax.jsglr.client.imploder.ITreeFactory;
 import org.spoofax.jsglr.shared.BadTokenException;
 import org.spoofax.jsglr.shared.SGLRException;
@@ -21,7 +23,7 @@
  * 
  * @author Lennart Kats <lennart add lclnet.nl>
  */
-public class IncrementalSGLR<TNode extends IAstNode> {
+public class IncrementalSGLR<TNode extends ISimpleTerm> {
 	
 	public static boolean DEBUG = false;
 	
@@ -72,7 +74,7 @@
 
 		// Determine damage size
 		lastReconstructedNodes = Collections.emptyList();
-		String oldInput = oldTree.getLeftToken().getTokenizer().getInput();
+		String oldInput = getLeftToken(oldTree).getTokenizer().getInput();
 		int damageStart = getDamageStart(newInput, oldInput);
 		int damageSizeChange = newInput.length() - oldInput.length();
 		int damageEnd = getDamageEnd(newInput, oldInput, damageStart, damageSizeChange);
@@ -99,8 +101,8 @@
 		// Construct and parse partial input
 		String partialInput = inputBuilder.buildPartialInput(oldTree);
 		int skippedChars = inputBuilder.getLastSkippedCharsBeforeDamage();
-		IAstNode partialTree = (IAstNode) parser.parse(partialInput, startSymbol);
-		List<IAstNode> repairedNodes = damageAnalyzer.getDamageNodesForPartialTree(partialTree, skippedChars);
+		ISimpleTerm partialTree = (ISimpleTerm) parser.parse(partialInput, startSymbol);
+		List<ISimpleTerm> repairedNodes = damageAnalyzer.getDamageNodesForPartialTree(partialTree, skippedChars);
 		sanityCheckRepairedTree(repairedNodes);
 		
 		// Combine old tree with new partial tree
@@ -134,7 +136,7 @@
 			+ oldInput.substring(damageEnd + 1)).equals(newInput);
 	}
 
-	private void sanityCheckOldTree(IAstNode oldTree, List<IAstNode> damagedNodes)
+	private void sanityCheckOldTree(ISimpleTerm oldTree, List<ISimpleTerm> damagedNodes)
 			throws IncrementalSGLRException {
 		
 		if (DEBUG) System.out.println("Damaged: " + damagedNodes);
@@ -144,22 +146,22 @@
 			throw new IncrementalSGLRException("Postcondition failed: old tree is ambiguous");
 		}
 		
-		for (IAstNode node : damagedNodes) {
-			if (!incrementalSorts.contains(node.getSort()))
+		for (ISimpleTerm node : damagedNodes) {
+			if (!incrementalSorts.contains(getSort(node)))
 				throw new IncrementalSGLRException("Precondition failed: unsafe change to tree node of type "
-						+ node.getSort() + " at line " + node.getLeftToken().getLine());
+						+ getSort(node) + " at line " + getLeftToken(node).getLine());
 		}
 	}
 	
-	private void sanityCheckRepairedTree(List<IAstNode> repairedTreeNodes)
+	private void sanityCheckRepairedTree(List<ISimpleTerm> repairedTreeNodes)
 			throws IncrementalSGLRException {
 		
 		if (DEBUG) System.out.println("\nRepaired: " + repairedTreeNodes);
 		
-		for (IAstNode node : repairedTreeNodes) {
-			if (!incrementalSorts.contains(node.getSort())) {
+		for (ISimpleTerm node : repairedTreeNodes) {
+			if (!incrementalSorts.contains(getSort(node))) {
 				throw new IncrementalSGLRException("Postcondition failed: unsafe tree parsed of type "
-						+ node.getSort()  + " at line " + node.getLeftToken().getLine());
+						+ getSort(node)  + " at line " + getLeftToken(node).getLine());
 			} else if (isAmbiguous(node)) {
 				// Not yet supported by IncrementalTreeBuilder
 				throw new IncrementalSGLRException("Postcondition failed: updated tree is ambiguous");
@@ -167,8 +169,8 @@
 		}
 	}
 	
-	private static boolean isAmbiguous(IAstNode tree) {
-		return tree.getLeftToken().getTokenizer().isAmbigous();
+	private static boolean isAmbiguous(ISimpleTerm tree) {
+		return getLeftToken(tree).getTokenizer().isAmbigous();
 	}
 
 	protected static boolean isRangeOverlap(int start1, int end1, int start2, int end2) {
@@ -176,9 +178,9 @@
 	}
 
 	@SuppressWarnings("unchecked")
-	static Iterator<IAstNode> tryGetListIterator(IAstNode oldTree) {
+	static Iterator<ISimpleTerm> tryGetListIterator(ISimpleTerm oldTree) {
 		if (oldTree.isList() && oldTree instanceof Iterable)
-			return ((Iterable<IAstNode>) oldTree).iterator();
+			return ((Iterable<ISimpleTerm>) oldTree).iterator();
 		else
 			return null;
 	}

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/incremental/IncrementalTreeBuilder.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -6,6 +6,9 @@
 import static org.spoofax.jsglr.client.imploder.IToken.TK_ERROR_EOF_UNEXPECTED;
 import static org.spoofax.jsglr.client.imploder.IToken.TK_ERROR_KEYWORD;
 import static org.spoofax.jsglr.client.imploder.IToken.TK_UNKNOWN;
+import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getElementSort;
+import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getLeftToken;
+import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getRightToken;
 import static org.spoofax.jsglr.client.imploder.Tokenizer.findLeftMostLayoutToken;
 import static org.spoofax.jsglr.client.imploder.Tokenizer.findRightMostLayoutToken;
 import static org.spoofax.jsglr.client.imploder.Tokenizer.getTokenAfter;
@@ -17,7 +20,7 @@
 import java.util.List;
 import java.util.Set;
 
-import org.spoofax.jsglr.client.imploder.IAstNode;
+import org.spoofax.interpreter.terms.ISimpleTerm;
 import org.spoofax.jsglr.client.imploder.IToken;
 import org.spoofax.jsglr.client.imploder.ITokenizer;
 import org.spoofax.jsglr.client.imploder.ITreeFactory;
@@ -28,7 +31,7 @@
  * 
  * @author Lennart Kats <lennart add lclnet.nl>
  */
-public class IncrementalTreeBuilder<TNode extends IAstNode> {
+public class IncrementalTreeBuilder<TNode extends ISimpleTerm> {
 	
 	private static final int NO_STOP_OFFSET = Integer.MAX_VALUE;
 
@@ -44,7 +47,7 @@
 	
 	private final int damageSizeChange;
 
-	private final List<IAstNode> repairedNodes;
+	private final List<ISimpleTerm> repairedNodes;
 
 	private final Tokenizer newTokenizer;
 
@@ -58,7 +61,7 @@
 	 * @param skippedChars @see {@link IncrementalInputBuilder#getLastSkippedCharsBeforeDamage()}
 	 */
 	public IncrementalTreeBuilder(IncrementalSGLR<TNode> parser, DamageRegionAnalyzer damageAnalyzer,
-			String input, String filename, List<IAstNode> repairedTreeNodes, int skippedChars) {
+			String input, String filename, List<ISimpleTerm> repairedTreeNodes, int skippedChars) {
 		this.damageAnalyzer = damageAnalyzer;
 		this.factory = parser.factory;
 		this.incrementalSorts = damageAnalyzer.incrementalSorts;
@@ -73,7 +76,7 @@
 	/**
 	 * Builds the output tree based on the old tree and the list of repaired tree nodes.
 	 */
-	public TNode buildOutput(IAstNode oldTreeNode) throws IncrementalSGLRException {
+	public TNode buildOutput(ISimpleTerm oldTreeNode) throws IncrementalSGLRException {
 		isRepairedNodesInserted = false;
 		TNode result = buildOutputSubtree(oldTreeNode, 0);
 		if (!isRepairedNodesInserted)
@@ -86,49 +89,49 @@
 		return reconstructedNodes;
 	}
 	
-	private TNode buildOutputSubtree(IAstNode oldTreeNode, int offsetChange) {
-		final List<IAstNode> children;
+	private TNode buildOutputSubtree(ISimpleTerm oldTreeNode, int offsetChange) {
+		final List<ISimpleTerm> children;
 		final IToken beforeStartToken = newTokenizer.currentToken();
-		IToken startToken = oldTreeNode.getLeftToken();
+		IToken startToken = getLeftToken(oldTreeNode);
 		
 		sanityCheckOldTreeNode(oldTreeNode);
 		
-		if (oldTreeNode.isList() && incrementalSorts.contains(oldTreeNode.getElementSort())) {
+		if (oldTreeNode.isList() && incrementalSorts.contains(getElementSort(oldTreeNode))) {
 			// UNDONE: assert offsetChange == 0 : "Nested incrementalSorts lists?";
-			children = new ArrayList<IAstNode>(oldTreeNode.getChildCount() + repairedNodes.size());
+			children = new ArrayList<ISimpleTerm>(oldTreeNode.getSubtermCount() + repairedNodes.size());
 
-			Iterator<IAstNode> iterator = tryGetListIterator(oldTreeNode); 
-			for (int i = 0, max = oldTreeNode.getChildCount(); i < max; i++) {
-				IAstNode child = iterator == null ? oldTreeNode.getChildAt(i) : iterator.next();
+			Iterator<ISimpleTerm> iterator = tryGetListIterator(oldTreeNode); 
+			for (int i = 0, max = oldTreeNode.getSubtermCount(); i < max; i++) {
+				ISimpleTerm child = iterator == null ? oldTreeNode.getSubterm(i) : iterator.next();
 
-				copyTokensAndTryAddRepairedNodes(oldTreeNode, children, startToken, child.getLeftToken(), child.getRightToken());
+				copyTokensAndTryAddRepairedNodes(oldTreeNode, children, startToken, getLeftToken(child), getRightToken(child));
 
 				if (!damageAnalyzer.isDamageTreeNode(child, true, skippedChars)) {
-					startToken = getTokenAfter(child.getRightToken());
+					startToken = getTokenAfter(getRightToken(child));
 					children.add(buildOutputSubtree(child, offsetChange));
 				}
 			}
-			IToken stopToken = getTokenAfter(findRightMostLayoutToken(oldTreeNode.getRightToken()));
+			IToken stopToken = getTokenAfter(findRightMostLayoutToken(getRightToken(oldTreeNode)));
 			copyTokensAndTryAddRepairedNodes(oldTreeNode, children, startToken, stopToken, stopToken);
 		} else {
 			children = copyChildrenToList(oldTreeNode);
 			for (int i = 0; i < children.size(); i++) {
-				IAstNode child = children.get(i);
+				ISimpleTerm child = children.get(i);
 				
 				int myOffsetChange = offsetChange + (isRepairedNodesInserted ? damageSizeChange : 0);
-				copyTokens(startToken, findLeftMostLayoutToken(child.getLeftToken()), NO_STOP_OFFSET/*child.getLeftToken().getEndOffset() + 1*/, myOffsetChange);
-				startToken = getTokenAfter(child.getRightToken());
+				copyTokens(startToken, findLeftMostLayoutToken(getLeftToken(child)), NO_STOP_OFFSET/*getLeftToken(child).getEndOffset() + 1*/, myOffsetChange);
+				startToken = getTokenAfter(getRightToken(child));
 
 				children.set(i, buildOutputSubtree(child, offsetChange));
 			}
 		}
 		int myOffsetChange = offsetChange + (isRepairedNodesInserted ? damageSizeChange : 0);
-		IToken stopToken = getTokenAfter(oldTreeNode.getRightToken());
+		IToken stopToken = getTokenAfter(getRightToken(oldTreeNode));
 		copyTokens(startToken, stopToken, NO_STOP_OFFSET/*stopToken.getEndOffset() + 1*/, myOffsetChange);
 		return buildOutputNode(oldTreeNode, children, beforeStartToken);
 	}
 
-	private void sanityCheckOldTreeNode(IAstNode oldTreeNode) {
+	private void sanityCheckOldTreeNode(ISimpleTerm oldTreeNode) {
 		// (Also checked in IncrementalSGLR precondition.)
 		// TODO: incremental parsing with ambiguous trees
 		@SuppressWarnings("unchecked")
@@ -138,7 +141,7 @@
 	}
 
 	@SuppressWarnings("unchecked")
-	private TNode buildOutputNode(IAstNode oldTreeNode, List<IAstNode> children, IToken beforeStartToken) {
+	private TNode buildOutputNode(ISimpleTerm oldTreeNode, List<ISimpleTerm> children, IToken beforeStartToken) {
 		IToken startToken;
 		if (newTokenizer.currentToken() == beforeStartToken) {
 			startToken = newTokenizer.makeToken(newTokenizer.getStartOffset() - 1, TK_UNKNOWN, true);
@@ -148,7 +151,7 @@
 		return factory.recreateNode((TNode) oldTreeNode, startToken, newTokenizer.currentToken(), (List<TNode>) children);
 	}
 
-	private void copyTokensAndTryAddRepairedNodes(IAstNode oldTreeNode, List<IAstNode> children,
+	private void copyTokensAndTryAddRepairedNodes(ISimpleTerm oldTreeNode, List<ISimpleTerm> children,
 			IToken firstToken, IToken stopToken, IToken childEndToken) {
 		
 		if (!isRepairedNodesInserted && childEndToken.getEndOffset() >= damageStart) {
@@ -161,13 +164,13 @@
 		}
 	}
 
-	private void insertRepairedNodes(IAstNode oldTreeNode, List<IAstNode> children) {
+	private void insertRepairedNodes(ISimpleTerm oldTreeNode, List<ISimpleTerm> children) {
 		if (repairedNodes.size() > 0) {
-			IToken firstToken = getTokenBefore(repairedNodes.get(0).getLeftToken());
+			IToken firstToken = getTokenBefore(getLeftToken(repairedNodes.get(0)));
 	
-			for (IAstNode node : repairedNodes) {
-				copyTokens(firstToken, node.getLeftToken(), NO_STOP_OFFSET/*node.getLeftToken().getEndOffset() + 1*/, skippedChars);
-				firstToken = getTokenAfter(node.getRightToken());
+			for (ISimpleTerm node : repairedNodes) {
+				copyTokens(firstToken, getLeftToken(node), NO_STOP_OFFSET/*getLeftToken(node).getEndOffset() + 1*/, skippedChars);
+				firstToken = getTokenAfter(getRightToken(node));
 				
 				TNode reconstructed = buildOutputSubtree(node, skippedChars);
 				reconstructedNodes.add(reconstructed);
@@ -216,11 +219,11 @@
 		}
 	}
 
-	private static List<IAstNode> copyChildrenToList(IAstNode tree) {
-		List<IAstNode> results = new ArrayList<IAstNode>(tree.getChildCount());
-		Iterator<IAstNode> iterator = tryGetListIterator(tree); 
-		for (int i = 0, max = tree.getChildCount(); i < max; i++) {
-			IAstNode child = iterator == null ? tree.getChildAt(i) : iterator.next();
+	private static List<ISimpleTerm> copyChildrenToList(ISimpleTerm tree) {
+		List<ISimpleTerm> results = new ArrayList<ISimpleTerm>(tree.getSubtermCount());
+		Iterator<ISimpleTerm> iterator = tryGetListIterator(tree); 
+		for (int i = 0, max = tree.getSubtermCount(); i < max; i++) {
+			ISimpleTerm child = iterator == null ? tree.getSubterm(i) : iterator.next();
 			results.add(child);
 		}
 		return results;

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/incremental/NeighbourDamageExpander.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/incremental/NeighbourDamageExpander.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/incremental/NeighbourDamageExpander.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -2,14 +2,17 @@
 
 import static java.lang.Math.max;
 import static java.lang.Math.min;
+import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getElementSort;
+import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getLeftToken;
+import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getRightToken;
 import static org.spoofax.jsglr.client.incremental.IncrementalSGLR.isRangeOverlap;
 
 import java.util.Iterator;
 import java.util.Set;
 
-import org.spoofax.jsglr.client.imploder.AstNodeVisitor;
-import org.spoofax.jsglr.client.imploder.IAstNode;
+import org.spoofax.interpreter.terms.ISimpleTerm;
 import org.spoofax.jsglr.client.imploder.IToken;
+import org.spoofax.jsglr.client.imploder.SimpleTermVisitor;
 import org.spoofax.jsglr.client.imploder.Tokenizer;
 
 /**
@@ -21,7 +24,7 @@
  */
 public class NeighbourDamageExpander {
 
-	private final IAstNode oldTree;
+	private final ISimpleTerm oldTree;
 
 	private final Set<String> incrementalSorts;
 	
@@ -29,11 +32,11 @@
 
 	private final int damageEnd;
 	
-	private IAstNode leftNeighbour;
+	private ISimpleTerm leftNeighbour;
 	
-	private IAstNode rightNeighbour;
+	private ISimpleTerm rightNeighbour;
 
-	public NeighbourDamageExpander(IAstNode oldTree, Set<String> incrementalSorts,
+	public NeighbourDamageExpander(ISimpleTerm oldTree, Set<String> incrementalSorts,
 			int damageStart, int damageEnd) {
 		this.oldTree = oldTree;
 		this.incrementalSorts = incrementalSorts;
@@ -46,7 +49,7 @@
 		if (leftNeighbour == null) {
 			return damageStart;
 		} else {
-			return min(damageStart, leftNeighbour.getLeftToken().getStartOffset());
+			return min(damageStart, getLeftToken(leftNeighbour).getStartOffset());
 		}
 	}
 	
@@ -54,28 +57,28 @@
 		if (rightNeighbour == null) {
 			return damageEnd;
 		} else {
-			return max(damageEnd, rightNeighbour.getRightToken().getEndOffset());
+			return max(damageEnd, getRightToken(rightNeighbour).getEndOffset());
 		}
 	}
 	
 	private void initNeighbours() {
-		new AstNodeVisitor() {
+		new SimpleTermVisitor() {
 			boolean done;
 			
-			public void preVisit(IAstNode node) {
-				if (node.isList() && incrementalSorts.contains(node.getElementSort())
+			public void preVisit(ISimpleTerm node) {
+				if (node.isList() && incrementalSorts.contains(getElementSort(node))
 						&& isDamagedNode(node, true, true)) {
 					visitIncrementalSortsList(node);
 				}
 			}
 			
-			private void visitIncrementalSortsList(IAstNode list) {
+			private void visitIncrementalSortsList(ISimpleTerm list) {
 				boolean foundDamagedNode = false;
 				
-				Iterator<IAstNode> iterator = tryGetListIterator(list);
-				IAstNode lastChild = null;
-				for (int i = 0, max = list.getChildCount(); i < max; i++) {
-					IAstNode child = iterator == null ? list.getChildAt(i) : iterator.next();
+				Iterator<ISimpleTerm> iterator = tryGetListIterator(list);
+				ISimpleTerm lastChild = null;
+				for (int i = 0, max = list.getSubtermCount(); i < max; i++) {
+					ISimpleTerm child = iterator == null ? list.getSubterm(i) : iterator.next();
 					if (!foundDamagedNode) {
 						if (isDamagedNode(child, true, true)) {
 							if (leftNeighbour == null || isLeftCollateralDamage(child))
@@ -103,9 +106,9 @@
 		}.visit(oldTree);
 	}
 
-	private boolean isDamagedNode(IAstNode node, boolean considerLeftLayout, boolean considerRightLayout) {
-		IToken left = node.getLeftToken();
-		IToken right = node.getRightToken();
+	private boolean isDamagedNode(ISimpleTerm node, boolean considerLeftLayout, boolean considerRightLayout) {
+		IToken left = getLeftToken(node);
+		IToken right = getRightToken(node);
 		if (left == null || right == null) return false;
 		if (considerLeftLayout)
 			left = Tokenizer.findLeftMostLayoutToken(left);
@@ -116,12 +119,12 @@
 		return isRangeOverlap(damageStart, damageEnd, startOffset, endOffset);
 	}
 
-	private boolean isLeftCollateralDamage(IAstNode child) {
+	private boolean isLeftCollateralDamage(ISimpleTerm child) {
 		assert isDamagedNode(child, true, true);
 		return !isDamagedNode(child, true, false);
 	}
 
-	private boolean isRightCollateralDamage(IAstNode child) {
+	private boolean isRightCollateralDamage(ISimpleTerm child) {
 		assert isDamagedNode(child, true, true);
 		return !isDamagedNode(child, false, true);
 	}

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/incremental/SortAnalyzer.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/incremental/SortAnalyzer.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/incremental/SortAnalyzer.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -1,19 +1,19 @@
 package org.spoofax.jsglr.client.incremental;
 
-import static org.spoofax.jsglr.shared.Tools.termAt;
-import static org.spoofax.jsglr.shared.terms.ATerm.APPL;
+import static org.spoofax.terms.Term.isTermAppl;
+import static org.spoofax.terms.Term.termAt;
 
 import java.util.HashSet;
 import java.util.Set;
 
+import org.spoofax.interpreter.terms.IStrategoAppl;
+import org.spoofax.interpreter.terms.IStrategoConstructor;
+import org.spoofax.interpreter.terms.IStrategoList;
+import org.spoofax.interpreter.terms.IStrategoString;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.ITermFactory;
 import org.spoofax.jsglr.client.Label;
 import org.spoofax.jsglr.client.ParseTable;
-import org.spoofax.jsglr.shared.terms.AFun;
-import org.spoofax.jsglr.shared.terms.ATerm;
-import org.spoofax.jsglr.shared.terms.ATermAppl;
-import org.spoofax.jsglr.shared.terms.ATermFactory;
-import org.spoofax.jsglr.shared.terms.ATermList;
-import org.spoofax.jsglr.shared.terms.ATermString;
 
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
@@ -22,17 +22,17 @@
 
 	private final ParseTable table;
 	
-	private final AFun sortFun;
+	private final IStrategoConstructor sortFun;
 	
-	private final AFun cfFun;
+	private final IStrategoConstructor cfFun;
 	
-	private final AFun lexFun;
+	private final IStrategoConstructor lexFun;
 
 	public SortAnalyzer(ParseTable table) {
 		this.table = table;
-		sortFun = table.getFactory().makeAFun("sort", 1, false);
-		cfFun = table.getFactory().makeAFun("cf", 1, false);
-		lexFun = table.getFactory().makeAFun("lex", 1, false);
+		sortFun = table.getFactory().makeConstructor("sort", 1);
+		cfFun = table.getFactory().makeConstructor("cf", 1);
+		lexFun = table.getFactory().makeConstructor("lex", 1);
 	}
 	
 	public Set<String> getInjectionsTo(String... sorts) {
@@ -44,33 +44,33 @@
 	}
 	
 	private void addInjectionsTo(String sort, Set<String> results) {
-		ATermFactory factory = table.getFactory();
-		ATerm sortTerm = factory.makeAppl(sortFun, factory.makeString(sort));
+		ITermFactory factory = table.getFactory();
+		IStrategoTerm sortTerm = factory.makeAppl(sortFun, factory.makeString(sort));
 		for (Label l : table.getLabels()) {
 			if (l != null) {
-				ATermAppl production = l.getProduction();
-				ATermAppl toSort = termAt(production, 1);
+				IStrategoAppl production = l.getProduction();
+				IStrategoTerm toSort = termAt(production, 1);
 				toSort = stripFun(toSort, cfFun);
 				toSort = stripFun(toSort, lexFun);
 				if (toSort.equals(sortTerm)) {
-					ATermList lhs = termAt(production, 0);
-					if (lhs.getChildCount() != 1) continue;
-					if (lhs.getFirst().getType() != APPL) continue;
-					ATermAppl lhsFirst = (ATermAppl) lhs.getFirst();
+					IStrategoList lhs = termAt(production, 0);
+					if (lhs.getSubtermCount() != 1) continue;
+					if (!isTermAppl(lhs.head())) continue;
+					IStrategoTerm lhsFirst = lhs.head();
 					lhsFirst = stripFun(lhsFirst, cfFun);
 					lhsFirst = stripFun(lhsFirst, lexFun);
-					if (lhsFirst.getAFun() != sortFun) continue;
-					ATermString fromSort = termAt(lhsFirst, 0);
-					results.add(fromSort.getString());
+					if (((IStrategoAppl) lhsFirst).getConstructor() != sortFun) continue;
+					IStrategoString fromSort = termAt(lhsFirst, 0);
+					results.add(fromSort.stringValue());
 				}
 			}
 		}
 		results.add(sort);
 	}
 	
-	public ATermAppl stripFun(ATermAppl appl, AFun fun) {
-		if (appl.getAFun() == fun) {
-			return (ATermAppl) termAt(appl, 0);
+	public IStrategoTerm stripFun(IStrategoTerm appl, IStrategoConstructor fun) {
+		if (isTermAppl(appl) && ((IStrategoAppl) appl).getConstructor() == fun) {
+			return termAt(appl, 0);
 		} else {
 			return appl;
 		}

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/io/ParseTableManager.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/io/ParseTableManager.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/io/ParseTableManager.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -20,30 +20,31 @@
 import java.util.HashMap;
 import java.util.Map;
 
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.ITermFactory;
 import org.spoofax.jsglr.client.InvalidParseTableException;
 import org.spoofax.jsglr.client.ParseTable;
 import org.spoofax.jsglr.shared.Tools;
-import org.spoofax.jsglr.shared.terms.ATerm;
-import org.spoofax.jsglr.shared.terms.ATermFactory;
+import org.spoofax.terms.TermFactory;
 
 public class ParseTableManager {
     
     private final Map<String, CachedTable> cache =
         new HashMap<String, CachedTable>();
     
-    private final ATermFactory factory;
+    private final ITermFactory factory;
     
     private boolean useDiskCache;
     
     public ParseTableManager() {
-        this(new ATermFactory());
+        this(new TermFactory());
     }
     
-    public ParseTableManager(ATermFactory factory) {
+    public ParseTableManager(ITermFactory factory) {
         this(factory, false);
     }
     
-    public ParseTableManager(ATermFactory factory, boolean useDiskCache) {
+    public ParseTableManager(ITermFactory factory, boolean useDiskCache) {
         this.factory = factory;
         this.useDiskCache = useDiskCache;
     }
@@ -66,7 +67,7 @@
         			cached.lastModified() >= table.lastModified()) {
         		try {
 					pt = loadFromDiskCache(cachedTable);
-					pt.initAFuns(factory);
+					pt.initIStrategoConstructors(factory);
 				} catch (ClassNotFoundException e) {
 				}
         	}
@@ -117,12 +118,12 @@
 
         // TODO: optimize - load table directly from stream
         String tableString = FileTools.loadFileAsString(new InputStreamReader(stream));
-        return initializeParseTable(factory.parseFromString(tableString));
+        return initializeParseTable(factory, factory.parseFromString(tableString));
     }
 
-	private ParseTable initializeParseTable(ATerm pt) throws InvalidParseTableException {
+	private ParseTable initializeParseTable(ITermFactory factory, IStrategoTerm pt) throws InvalidParseTableException {
         long start = System.currentTimeMillis();
-		ParseTable parseTable = new ParseTable(pt);
+		ParseTable parseTable = new ParseTable(pt, factory);
         long elapsed = System.currentTimeMillis() - start;
 
         if (SGLR.isLogging()) {
@@ -141,12 +142,12 @@
         return parseTable;
 	}
 
-    public ATermFactory getFactory() {
+    public ITermFactory getFactory() {
         return factory;
     }
 
-	public ParseTable loadFromTerm(ATerm term) throws InvalidParseTableException {
-		return initializeParseTable(term);
+	public ParseTable loadFromTerm(ITermFactory factory, IStrategoTerm term) throws InvalidParseTableException {
+		return initializeParseTable(factory, term);
 	}
 	
 	/**

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/io/SGLR.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/io/SGLR.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/io/SGLR.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -6,13 +6,13 @@
 import java.util.Timer;
 import java.util.TimerTask;
 
+import org.spoofax.interpreter.terms.ITermFactory;
 import org.spoofax.jsglr.client.ParseException;
 import org.spoofax.jsglr.client.ParseTable;
 import org.spoofax.jsglr.client.ParseTimeoutException;
 import org.spoofax.jsglr.shared.BadTokenException;
 import org.spoofax.jsglr.shared.SGLRException;
 import org.spoofax.jsglr.shared.TokenExpectedException;
-import org.spoofax.jsglr.shared.terms.ATermFactory;
 
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
@@ -59,7 +59,7 @@
 		}
 	}
 
-	public SGLR(ATermFactory pf, ParseTable parseTable) {
+	public SGLR(ITermFactory pf, ParseTable parseTable) {
 		super(pf, parseTable);
 	}
 

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/server/RemoteParseTableServiceImpl.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/server/RemoteParseTableServiceImpl.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/server/RemoteParseTableServiceImpl.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -5,41 +5,35 @@
 import java.io.IOException;
 import java.io.InputStream;
 
+import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.jsglr.shared.RemoteParseTableService;
-import org.spoofax.jsglr.shared.terms.ATerm;
-import org.spoofax.jsglr.shared.terms.ATermFactory;
+import org.spoofax.terms.TermFactory;
+import org.spoofax.terms.io.baf.BAFTermReader;
 
 import com.google.gwt.user.server.rpc.RemoteServiceServlet;
 
 @SuppressWarnings("serial")
 public class RemoteParseTableServiceImpl extends RemoteServiceServlet implements RemoteParseTableService {
 
-	public ATerm fetchParseTable(String resourceName) {
-		final ATermFactory f = new ATermFactory();
+	public IStrategoTerm fetchParseTable(String resourceName) {
+		final TermFactory f = new TermFactory();
 		try {
 			final InputStream is = new FileInputStream(resourceName);
-			System.out.println("Loading into buffer");
-			final char[] buffer = new char[12*1024*1024]; // FIXME 12 MBs should be enough for everyone
-			for(int i = 0; i < buffer.length; i++) {
-				final int ch = is.read();
-				if(ch == -1) {
-					break;
-				}
-				buffer[i] = (char)ch;
-			}
-			System.out.println("Loading from buffer");
-			final ATerm e = f.parse(new String(buffer));
+			final IStrategoTerm e = new BAFTermReader(f).parseFromStream(is);
+			is.close();
 			System.out.println("Loaded term, serializing");
 			return e;
 		} catch(final FileNotFoundException e) {
+			e.printStackTrace();
 		} catch(final IOException e) {
+			e.printStackTrace();
 		}
 		System.err.println("Failed to load parse table " + resourceName);
 		return null;
 	}
 
-	public ATerm readTermFromFile(String string) {
-		return new ATermFactory().makeInt(0);
+	public IStrategoTerm readTermFromFile(String string) {
+		return new TermFactory().makeInt(0);
 	}
 
 	public String fetchText(String string) {

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/shared/BadTokenException.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/shared/BadTokenException.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/shared/BadTokenException.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -1,8 +1,8 @@
 package org.spoofax.jsglr.shared;
 
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.ITermFactory;
 import org.spoofax.jsglr.client.SGLR;
-import org.spoofax.jsglr.shared.terms.ATerm;
-import org.spoofax.jsglr.shared.terms.ATermFactory;
 
 /**
  * Exception thrown when a specific token was unexpected by the parser.
@@ -66,10 +66,10 @@
 
 
     @Override
-    protected ATerm toLocationATerm() {
-        ATermFactory factory = getParser().getFactory();
+    protected IStrategoTerm toLocationATerm() {
+        ITermFactory factory = getParser().getFactory();
         return factory.makeAppl(
-            factory.makeAFun("area", 6, false),
+            factory.makeConstructor("area", 6),
             factory.makeInt(getLineNumber()),
             factory.makeInt(getColumnNumber()),
             factory.makeInt(getLineNumber()),

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/shared/RemoteParseTableService.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/shared/RemoteParseTableService.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/shared/RemoteParseTableService.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -1,6 +1,6 @@
 package org.spoofax.jsglr.shared;
 
-import org.spoofax.jsglr.shared.terms.ATerm;
+import org.spoofax.interpreter.terms.IStrategoTerm;
 
 import com.google.gwt.user.client.rpc.RemoteService;
 import com.google.gwt.user.client.rpc.RemoteServiceRelativePath;
@@ -8,9 +8,9 @@
 @RemoteServiceRelativePath("parsetable")
 public interface RemoteParseTableService extends RemoteService {
 
-	ATerm fetchParseTable(String resourceName);
+	IStrategoTerm fetchParseTable(String resourceName);
 
-	ATerm readTermFromFile(String string);
+	IStrategoTerm readTermFromFile(String string);
 
 	String fetchText(String string);
 }

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/shared/RemoteParseTableServiceAsync.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/shared/RemoteParseTableServiceAsync.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/shared/RemoteParseTableServiceAsync.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -1,15 +1,15 @@
 package org.spoofax.jsglr.shared;
 
-import org.spoofax.jsglr.shared.terms.ATerm;
+import org.spoofax.interpreter.terms.IStrategoTerm;
 
 import com.google.gwt.user.client.rpc.AsyncCallback;
 
 
 public interface RemoteParseTableServiceAsync {
 
-	void fetchParseTable(String resourcePath, AsyncCallback<ATerm> callback);
+	void fetchParseTable(String resourcePath, AsyncCallback<IStrategoTerm> callback);
 
-	void readTermFromFile(String string, AsyncCallback<ATerm> callback);
+	void readTermFromFile(String string, AsyncCallback<IStrategoTerm> callback);
 
 	void fetchText(String string, AsyncCallback<String> callback);
 

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/shared/SGLRException.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/shared/SGLRException.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/shared/SGLRException.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -7,9 +7,9 @@
  */
 package org.spoofax.jsglr.shared;
 
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.ITermFactory;
 import org.spoofax.jsglr.client.SGLR;
-import org.spoofax.jsglr.shared.terms.ATerm;
-import org.spoofax.jsglr.shared.terms.ATermFactory;
 
 public class SGLRException extends Exception {
 
@@ -34,7 +34,7 @@
         return parser;
     }
 
-    public final ATerm toTerm() {
+    public final IStrategoTerm toTerm() {
         return toTerm("-");
     }
 
@@ -42,21 +42,21 @@
         return getMessage();
     }
 
-    public ATerm toTerm(String filename) {
+    public IStrategoTerm toTerm(String filename) {
         if (parser == null)
             throw new UnsupportedOperationException();
 
-        ATermFactory factory = parser.getFactory();
+        ITermFactory factory = parser.getFactory();
         return factory.makeAppl(
-            factory.makeAFun("error", 2, false),
-            factory.makeAppl(factory.makeAFun("Parse error", 0, true)),
+            factory.makeConstructor("error", 2),
+            factory.makeString("Parse error"),
             factory.makeList(
                 factory.makeAppl(
-                    factory.makeAFun("localized", 2, false),
-                    factory.makeAppl(factory.makeAFun(getShortMessage(), 0, true)),
+                    factory.makeConstructor("localized", 2),
+                    factory.makeString(getShortMessage()),
                     factory.makeAppl(
-                        factory.makeAFun("area-in-file", 2, false),
-                        factory.makeAppl(factory.makeAFun(filename, 0, true)),
+                        factory.makeConstructor("area-in-file", 2),
+                        factory.makeString(filename),
                         toLocationATerm()
                     )
                 )
@@ -64,10 +64,10 @@
         );
     }
 
-    protected ATerm toLocationATerm() {
-        ATermFactory factory = parser.getFactory();
+    protected IStrategoTerm toLocationATerm() {
+        ITermFactory factory = parser.getFactory();
         return factory.makeAppl(
-            factory.makeAFun("area", 6, false),
+            factory.makeConstructor("area", 6),
             factory.makeInt(0),
             factory.makeInt(0),
             factory.makeInt(0),

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/shared/Tools.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/shared/Tools.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/shared/Tools.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -8,10 +8,6 @@
 package org.spoofax.jsglr.shared;
 
 import org.spoofax.jsglr.client.Measures;
-import org.spoofax.jsglr.shared.terms.ATerm;
-import org.spoofax.jsglr.shared.terms.ATermAppl;
-import org.spoofax.jsglr.shared.terms.ATermInt;
-import org.spoofax.jsglr.shared.terms.ATermString;
 
 
 public class Tools {
@@ -58,33 +54,6 @@
     public static Measures getMeasures() {
         return measures;
     }
-    
-    // Terms
-
-    public static ATermAppl applAt(ATerm pt, int i) {
-        return termAt(pt, i);
-    }
-    
-    public static String asJavaString(ATerm s) {
-    	return ((ATermString) s).getString();
-    }
-
-    @SuppressWarnings("unchecked") // casting is inherently unsafe, but doesn't warrant a warning here
-    public static<T extends ATerm> T termAt(ATerm t, int i) {
-        return (T) t.getChildAt(i);
-    }
-    
-    public static ATermAppl asAppl(ATerm t) {
-        return (ATermAppl) t;
-    }
-
-    public static boolean isAppl(ATerm t) {
-        return t.getType() == ATerm.APPL;
-    }
-    
-    public static int intAt(ATerm pt, int i) {
-        return ((ATermInt) pt.getChildAt(i)).getInt();
-    }
 
 
 }

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/tests/ParseTestCase.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/tests/ParseTestCase.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/tests/ParseTestCase.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -7,27 +7,30 @@
  */
 package org.spoofax.jsglr.tests;
 
+import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getLeftToken;
 import static org.spoofax.jsglr.client.incremental.CommentDamageExpander.C_STYLE;
 
+import java.io.IOException;
 import java.util.HashSet;
 import java.util.Set;
 
 import junit.framework.TestCase;
 
+import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.jsglr.client.InvalidParseTableException;
 import org.spoofax.jsglr.client.ParseTable;
 import org.spoofax.jsglr.client.ParserException;
 import org.spoofax.jsglr.client.PathListPool;
 import org.spoofax.jsglr.client.PooledPathList;
 import org.spoofax.jsglr.client.SGLR;
-import org.spoofax.jsglr.client.imploder.ATermTreeFactory;
+import org.spoofax.jsglr.client.imploder.TermTreeFactory;
 import org.spoofax.jsglr.client.imploder.TreeBuilder;
 import org.spoofax.jsglr.client.incremental.IncrementalSGLR;
 import org.spoofax.jsglr.io.FileTools;
 import org.spoofax.jsglr.shared.SGLRException;
 import org.spoofax.jsglr.shared.Tools;
-import org.spoofax.jsglr.shared.terms.ATerm;
-import org.spoofax.jsglr.shared.terms.ATermFactory;
+import org.spoofax.terms.TermFactory;
+import org.spoofax.terms.io.baf.BAFTermReader;
 
 public abstract class ParseTestCase extends TestCase {
 
@@ -37,10 +40,10 @@
 	
 	protected ParseTable table;
 
-	protected IncrementalSGLR<ATerm> incrementalSGLR;
+	protected IncrementalSGLR<IStrategoTerm> incrementalSGLR;
 
 	// shared by all tests
-	static final ATermFactory pf = new ATermFactory();
+	static final TermFactory pf = new TermFactory();
 	//RemoteParseTableServiceAsync parseTableService = GWT.create(RemoteParseTableService.class);
 
 	@Override
@@ -56,11 +59,11 @@
 		Tools.setLogging(false);
 		final String fn = "tests/grammars/" + grammar + ".tbl";
 
-		final ATerm result = pf.parseFromString(FileTools.loadFileAsString(fn));
-		table = new ParseTable(result);
+		final IStrategoTerm result = tryReadTermFromFile(fn);
+		table = new ParseTable(result, pf);
 		sglr = new SGLR(pf, table);
 		//        parseTableService.fetchParseTable("tests/grammars/" + grammar + ".tbl",
-		//        		new AsyncCallback<ATerm>() {
+		//        		new AsyncCallback<IStrategoTerm>() {
 		//
 		//					@Override
 		//					public void onFailure(Throwable caught) {
@@ -69,7 +72,7 @@
 		//					}
 		//
 		//					@Override
-		//					public void onSuccess(ATerm result) {
+		//					public void onSuccess(IStrategoTerm result) {
 		//				        try {
 		//							sglr = new SGLR(pf, new ParseTable(result));
 		//						} catch (InvalidParseTableException e) {
@@ -79,18 +82,26 @@
 		//				});
 
 		if (incrementalSorts.length > 0) {
-			ATermTreeFactory factory = new ATermTreeFactory(sglr.getFactory());
+			TermTreeFactory factory = new TermTreeFactory(sglr.getFactory());
 			TreeBuilder builder = new TreeBuilder(factory);
 			sglr.setTreeBuilder(builder);
 			//Set<String> sorts = new SortAnalyzer(table).getInjectionsTo(incrementalSorts);
 			Set<String> sorts = new HashSet<String>();
 	    	for (String sort : incrementalSorts)
 	    		sorts.add(sort);
-			incrementalSGLR = new IncrementalSGLR<ATerm>(sglr, C_STYLE, factory, sorts);
+			incrementalSGLR = new IncrementalSGLR<IStrategoTerm>(sglr, C_STYLE, factory, sorts);
 	        IncrementalSGLR.DEBUG = true;
 		}
 	}
 
+	private IStrategoTerm tryReadTermFromFile(String fn) {
+		try {
+			return new BAFTermReader(pf).parseFromFile(fn);
+		} catch (IOException e) {
+			throw new RuntimeException(e);
+		}
+	}
+
 
 	@Override
 	protected void tearDown() throws Exception {
@@ -100,7 +111,7 @@
 	}
 
 	boolean doCompare = true;
-	public ATerm doParseTest(final String s) {
+	public IStrategoTerm doParseTest(final String s) {
 
 		//		parseTableService.fetchText("tests/data/" + s + "." + suffix,
 		//				new AsyncCallback<String>() {
@@ -115,9 +126,9 @@
 		final String result = loadAsString(s);
 		assertNotNull("Data file is missing: " + s, result);
 		long parseTime = System.nanoTime();
-		ATerm parsed = null;
+		IStrategoTerm parsed = null;
 		try {
-			parsed = (ATerm) sglr.parse(result);
+			parsed = (IStrategoTerm) sglr.parse(result, null);
 		} catch (SGLRException e) {
 			e.printStackTrace();
 			throw new RuntimeException(e);
@@ -128,9 +139,9 @@
 		if (doCompare) {
 			doCompare(s, parsed);
 		} else {
-			if (parsed.getLeftToken() != null)
-				System.out.println(parsed.getLeftToken().getTokenizer());
-			System.out.println(parsed.toString(8));
+			if (getLeftToken(parsed) != null)
+				System.out.println(getLeftToken(parsed).getTokenizer());
+			System.out.println(toCompactString(parsed));
 		}
 
 		System.out.println(PathListPool.cacheMisses);
@@ -139,69 +150,71 @@
 		return parsed;
 	}
 	
-	public ATerm doParseIncrementalTest(ATerm oldTree, String newFile) throws Exception {
+	public IStrategoTerm doParseIncrementalTest(IStrategoTerm oldTree, String newFile) throws Exception {
 		String contents = loadAsString(newFile);
 		assertNotNull(contents);
 		long parseTime = System.nanoTime();
 		System.out.println("------------------------");
 		System.out.println("Parsing " + newFile);
-    	ATerm newTree = (ATerm) incrementalSGLR.parseIncremental(contents, newFile, null, oldTree);
+    	IStrategoTerm newTree = incrementalSGLR.parseIncremental(contents, newFile, null, oldTree);
 		parseTime = System.nanoTime() - parseTime;
 		System.out.println("Incremental parsing " + newFile + " took " + parseTime/1000/1000 + " millis" + (IncrementalSGLR.DEBUG ? " including debug printing" : ""));
 		String extension =
 			table.getTreeBuilder() instanceof TreeBuilder ? ".itrm" : ".trm";
 		if (doCompare) {
-			final String x = FileTools.loadFileAsString("tests/data/" + newFile + extension);
-			assertNotNull("Data file is missing: " + newFile + extension, x);
-			final ATerm wanted = newTree.getFactory().parse(x);
-			System.out.println(newTree.toString(8));
-			System.out.println(wanted.toString(8));
-	    	if (!newTree.simpleMatch(wanted))
+			final IStrategoTerm wanted = tryReadTermFromFile("tests/data/" + newFile + extension);
+			System.out.println(toCompactString(newTree));
+			System.out.println(toCompactString(wanted));
+	    	if (!newTree.match(wanted))
 	    		fail();
 	    	doTokenStreamEqualityTest(oldTree, newTree);
 		} else {
-			System.out.println(newTree.toString(8));
+			System.out.println(toCompactString(newTree));
 		}
     	return newTree;
 	}
 	
-	private void doTokenStreamEqualityTest(ATerm oldTree, ATerm newTree) {
+	private void doTokenStreamEqualityTest(IStrategoTerm oldTree, IStrategoTerm newTree) {
 		// Actual token equality test is now performed
 		// using assertions in IncrementalTreeBuilder
-		String tokens = newTree.getLeftToken().getTokenizer().toString();
+		String tokens = getLeftToken(newTree).getTokenizer().toString();
 		if (tokens.length() > 300)
 			tokens = tokens.substring(0, 300) + "...";
 		System.out.println(tokens);
 	}
 
 	protected String loadAsString(final String testFile) {
-		return FileTools.loadFileAsString("tests/data/" + testFile + "." + suffix);
+		return FileTools.tryLoadFileAsString("tests/data/" + testFile + "." + suffix);
 	}
 
-	private void doCompare(String s, final ATerm parsed) {
-		//parseTableService.readTermFromFile("tests/data/" + s + ".trm", new AsyncCallback<ATerm>() {
+	private void doCompare(String s, final IStrategoTerm parsed) {
+		//parseTableService.readTermFromFile("tests/data/" + s + ".trm", new AsyncCallback<IStrategoTerm>() {
 		String extension =
 			table.getTreeBuilder() instanceof TreeBuilder ? ".itrm" : ".trm";
-		final String x = FileTools.loadFileAsString("tests/data/" + s + extension);
-		final ATerm wanted = parsed.getFactory().parse(x);
+		final String x = FileTools.tryLoadFileAsString("tests/data/" + s + extension);
+		final IStrategoTerm wanted = pf.parseFromString(x);
 		//			@Override
 		//			public void onFailure(Throwable caught) {
 		//				fail();
 		//			}
 		//
 		//			@Override
-		//			public void onSuccess(ATerm loaded) {
+		//			public void onSuccess(IStrategoTerm loaded) {
 		assertNotNull(x);
 
-		System.out.println(parsed.toString(8));
-		System.out.println(wanted.toString(8));
-		if(!parsed.simpleMatch(wanted)) {
+		System.out.println(toCompactString(parsed));
+		System.out.println(toCompactString(wanted));
+		if(!parsed.match(wanted)) {
 			fail();
 		}
 		//			}
 		//		});
 
 	}
+	
+	private static String toCompactString(IStrategoTerm term) {
+		return term.toString(8);
+	}
 
 	public String getModuleName() {
 		return "org.spoofax.JsglrGWT";

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/tests/TestIncrementalSGLR.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -1,17 +1,19 @@
 package org.spoofax.jsglr.tests;
 
+import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getLeftToken;
+
+import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.jsglr.client.InvalidParseTableException;
 import org.spoofax.jsglr.client.ParserException;
 import org.spoofax.jsglr.client.incremental.IncrementalSGLR;
 import org.spoofax.jsglr.client.incremental.IncrementalSGLRException;
-import org.spoofax.jsglr.shared.terms.ATerm;
 
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
  */
 public class TestIncrementalSGLR extends ParseTestCase {
 
-	private static ATerm java4Result, java5Result, java7Result, java8Result;
+	private static IStrategoTerm java4Result, java5Result, java7Result, java8Result;
 	
     @Override
 	public void gwtSetUp() throws ParserException, InvalidParseTableException {
@@ -22,22 +24,22 @@
         		IncrementalSGLR.class.desiredAssertionStatus());
     }
     
-    private ATerm getJava4Result() {
+    private IStrategoTerm getJava4Result() {
     	if (java4Result == null) java4Result = doParseTest("java4");
     	return java4Result;
     }
     
-    private ATerm getJava5Result() {
+    private IStrategoTerm getJava5Result() {
     	if (java5Result == null) java5Result = doParseTest("java5");
     	return java5Result;
     }
     
-    private ATerm getJava7Result() {
+    private IStrategoTerm getJava7Result() {
     	if (java7Result == null) java7Result = doParseTest("java7");
     	return java7Result;
     }
     
-    private ATerm getJava8Result() {
+    private IStrategoTerm getJava8Result() {
     	if (java8Result == null) java8Result = doParseTest("java8");
     	return java8Result;
     }
@@ -59,7 +61,7 @@
     }
     
     public void testJava55() throws Exception {
-    	ATerm result = doParseIncrementalTest(getJava5Result(), "java5-increment5");
+    	IStrategoTerm result = doParseIncrementalTest(getJava5Result(), "java5-increment5");
     	assertFalse("There is no foo", result.toString().contains("\"foo\""));
     	assertFalse("There is no baz", result.toString().contains("\"bar\""));
     	assertTrue("There is only foobaz", result.toString().contains("\"foobaz\""));
@@ -97,71 +99,71 @@
     	suffix = "java.recover";
     	sglr.setUseStructureRecovery(true);
     	doCompare = false;
-    	ATerm java6 = doParseTest("java6");
-    	ATerm java61 = doParseIncrementalTest(java6, "java6-increment");
+    	IStrategoTerm java6 = doParseTest("java6");
+    	IStrategoTerm java61 = doParseIncrementalTest(java6, "java6-increment");
     	assertFalse(java6.toString().contains("baz"));
     	assertTrue(java61.toString().contains("baz"));
-    	assertTrue(java61.getLeftToken().getTokenizer().toString().toString().contains("sense"));
+    	assertTrue(getLeftToken(java61).getTokenizer().toString().toString().contains("sense"));
     }
     
     public void testJava7() throws Exception {
-    	ATerm java7 = getJava7Result();
+    	IStrategoTerm java7 = getJava7Result();
     	doParseIncrementalTest(java7, "java7-increment");
     }
     
     public void testJava72() throws Exception {
-    	ATerm java7 = getJava7Result();
+    	IStrategoTerm java7 = getJava7Result();
     	doParseIncrementalTest(java7, "java7-increment2");
     	assertFalse(isReparsed("foo"));
     }
     
     public void testJava73() throws Exception {
-    	ATerm java7 = getJava7Result();
+    	IStrategoTerm java7 = getJava7Result();
     	doParseIncrementalTest(java7, "java7-increment3");
     	int reparsed = incrementalSGLR.getLastReconstructedNodes().size();
     	assertTrue("Expected 1 reparsed node: " + reparsed, reparsed <= 4);
     }
     
     public void testJava8() throws Exception {
-    	ATerm java8 = getJava8Result();
-    	ATerm java8Increment = doParseIncrementalTest(java8, "java8-increment");
-    	assertTrue("Comment should be in input tokens", java8.getLeftToken().getTokenizer().toString().contains("comment"));
-    	assertTrue("Comment should be in output tokens", java8Increment.getLeftToken().getTokenizer().toString().contains("comment"));
+    	IStrategoTerm java8 = getJava8Result();
+    	IStrategoTerm java8Increment = doParseIncrementalTest(java8, "java8-increment");
+    	assertTrue("Comment should be in input tokens", getLeftToken(java8).getTokenizer().toString().contains("comment"));
+    	assertTrue("Comment should be in output tokens", getLeftToken(java8Increment).getTokenizer().toString().contains("comment"));
     	assertTrue(isReparsed("foo"));
     	assertFalse(isReparsed("qux"));
     }
     
     public void testJava82() throws Exception {
-    	ATerm java8 = getJava8Result();
-    	ATerm java8Increment = doParseIncrementalTest(java8, "java8-increment2");
-    	assertTrue("Comment should be in input tokens", java8.getLeftToken().getTokenizer().toString().contains("comment"));
-    	assertTrue("Comment should be in output tokens", java8Increment.getLeftToken().getTokenizer().toString().contains("comment"));
+    	IStrategoTerm java8 = getJava8Result();
+    	IStrategoTerm java8Increment = doParseIncrementalTest(java8, "java8-increment2");
+    	assertTrue("Comment should be in input tokens", getLeftToken(java8).getTokenizer().toString().contains("comment"));
+    	assertTrue("Comment should be in output tokens", getLeftToken(java8Increment).getTokenizer().toString().contains("comment"));
     	// Here, qux is reparsed because comment damage handler and then neighbour damage handler
     	// epand the damage zone
     	// assertFalse(isReparsed("qux"));
     }
     
     public void testJava83() throws Exception {
-    	ATerm java8 = getJava8Result();
-    	ATerm java8Increment = doParseIncrementalTest(java8, "java8-increment3");
-    	assertTrue("Comment should be in input tokens", java8.getLeftToken().getTokenizer().toString().contains("comment"));
-    	assertTrue("Comment should be in output tokens", java8Increment.getLeftToken().getTokenizer().toString().contains("comment"));
+    	IStrategoTerm java8 = getJava8Result();
+    	IStrategoTerm java8Increment = doParseIncrementalTest(java8, "java8-increment3");
+    	assertTrue("Comment should be in input tokens", getLeftToken(java8).getTokenizer().toString().contains("comment"));
+    	assertTrue("Comment should be in output tokens", getLeftToken(java8Increment).getTokenizer().toString().contains("comment"));
     	assertFalse(isReparsed("qux"));
     }
     
     public void testJava84() throws Exception {
-    	ATerm java8 = getJava8Result();
-    	ATerm java8Increment = doParseIncrementalTest(java8, "java8-increment4");
-    	assertTrue("Comment should be in input tokens", java8.getLeftToken().getTokenizer().toString().contains("comment"));
-    	assertTrue("Comment should be in output tokens", java8Increment.getLeftToken().getTokenizer().toString().contains("comment"));
+    	IStrategoTerm java8 = getJava8Result();
+    	IStrategoTerm java8Increment = doParseIncrementalTest(java8, "java8-increment4");
+    	assertTrue("Comment should be in input tokens", getLeftToken(java8).getTokenizer().toString().contains("comment"));
+    	assertTrue("Comment should be in output tokens", getLeftToken(java8Increment).getTokenizer().toString().contains("comment"));
     	assertFalse(isReparsed("qux"));
     }
     
     public void testJava85() throws Exception {
-    	ATerm java8 = getJava8Result();
-    	ATerm java8Increment = doParseIncrementalTest(java8, "java8-increment5");
-    	assertTrue("Comment should be in input tokens", java8.getLeftToken().getTokenizer().toString().contains("comment"));
-    	assertTrue("Comment should be in output tokens", java8Increment.getLeftToken().getTokenizer().toString().contains("comment"));
+    	IStrategoTerm java8 = getJava8Result();
+    	IStrategoTerm java8Increment = doParseIncrementalTest(java8, "java8-increment5");
+    	assertTrue("Comment should be in input tokens", getLeftToken(java8).getTokenizer().toString().contains("comment"));
+    	assertTrue("Comment should be in output tokens", getLeftToken(java8Increment).getTokenizer().toString().contains("comment"));
     	assertFalse(isReparsed("qux"));
     }
     
@@ -169,8 +171,8 @@
     	suffix = "java.recover";
     	sglr.setUseStructureRecovery(true);
     	doCompare = false;
-    	ATerm java9 = doParseTest("java9");
-    	ATerm java91 = doParseIncrementalTest(java9,  "java9-increment");
+    	IStrategoTerm java9 = doParseTest("java9");
+    	IStrategoTerm java91 = doParseIncrementalTest(java9,  "java9-increment");
     	try {
     		doParseIncrementalTest(java91, "java9-increment2");
     	} catch (IncrementalSGLRException e) {
@@ -184,7 +186,7 @@
     	suffix = "java.recover";
     	sglr.setUseStructureRecovery(true);
     	doCompare = false;
-    	ATerm java9 = doParseTest("java9");
+    	IStrategoTerm java9 = doParseTest("java9");
     	try {
     		doParseIncrementalTest(java9, "java9-increment3");
     	} catch (IncrementalSGLRException e) {
@@ -195,6 +197,7 @@
     }
 
     public void testJava4() throws Exception {
+    	fail("Known faiure: regression with the long lexical chain optimization causing Case(Lit(Char(NamedEscape(116)))) to be imploded as Case(Lit(Char(NamedEscape()))); needs to be looked into again");
     	doParseIncrementalTest(getJava4Result(), "java4-increment");
     	assertTrue(isReparsed("foo"));
     	int reparsed = incrementalSGLR.getLastReconstructedNodes().size();

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/tests/TestTokenize.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/tests/TestTokenize.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/tests/TestTokenize.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -1,13 +1,15 @@
 package org.spoofax.jsglr.tests;
 
+import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getLeftToken;
+
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.util.Iterator;
 
+import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.jsglr.client.imploder.IToken;
 import org.spoofax.jsglr.client.imploder.ITokenizer;
 import org.spoofax.jsglr.client.imploder.TreeBuilder;
-import org.spoofax.jsglr.shared.terms.ATerm;
 
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
@@ -23,8 +25,8 @@
 	}
 
     public void testJava5() throws FileNotFoundException, IOException {
-    	ATerm parsed = doParseTest("java5");
-    	ITokenizer tokenizer = parsed.getLeftToken().getTokenizer();
+    	IStrategoTerm parsed = doParseTest("java5");
+    	ITokenizer tokenizer = getLeftToken(parsed).getTokenizer();
     	Iterator<IToken> tokens = tokenizer.iterator();
     	System.out.println(tokenizer);
     	
@@ -60,8 +62,8 @@
     
     public void testJava6() throws FileNotFoundException, IOException {
     	suffix = "java.recover";
-    	ATerm parsed = doParseTest("java6");
-    	ITokenizer tokenizer = parsed.getLeftToken().getTokenizer();
+    	IStrategoTerm parsed = doParseTest("java6");
+    	ITokenizer tokenizer = getLeftToken(parsed).getTokenizer();
     	Iterator<IToken> tokens = tokenizer.iterator();
     	System.out.println(tokenizer);
     	

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/tests/Makefile
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/tests/Makefile	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/tests/Makefile	Wed Dec 29 13:13:19 2010	(r21594)
@@ -34,10 +34,15 @@
 SGLROPTS=-2 -t #-fd -fe -fi -fp -fr -t -lvd
 #../../../sglr/sglr-2.1M1/sglr/sglr/sglr
 
-all: $(TRM_FILES) $(ITRM_FILES)
+all: grammars $(TRM_FILES) $(ITRM_FILES)
 	cd grammars && make 
 	echo .$(TRM_FILES).
 
+grammars: .PHONY
+	$(MAKE) -C grammars
+
+.PHONY:
+
 _all: $(TESTS) $(SGLR_TRACES) $(JSGLR_TRACES)
 
 %.itrm : %.trm

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/NotImplementedException.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/NotImplementedException.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/NotImplementedException.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -8,21 +8,14 @@
 package org.spoofax;
 
 public class NotImplementedException extends RuntimeException {
-
-    private final String message;
     
     public NotImplementedException() {
-        message = "Not Implemented";
+        super("Not Implemented");
     }
     
     public NotImplementedException(String message) {
-        this.message = message;
+        super(message);
     }
 
     private static final long serialVersionUID = -1028814795329444374L;
-
-    @Override
-    public String toString() {
-        return message;
-    }
 }

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/AbstractTermAttachment.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/AbstractTermAttachment.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/AbstractTermAttachment.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -1,28 +1,18 @@
 package org.spoofax.interpreter.terms;
 
+/** 
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
 public abstract class AbstractTermAttachment implements ITermAttachment {
 	
 	private ITermAttachment next;
-	
-	protected abstract boolean isAttachmentType(Class<?> type);
 
-	@SuppressWarnings("unchecked")
-	public <T extends ITermAttachment> T tryGetAttachment(Class<T> type) {
-		if (isAttachmentType(type)) {
-			return (T) this;
-		} else if (next != null) {
-			return next.tryGetAttachment(type);
-		} else {
-			return null;
-		}
+	public final ITermAttachment getNext() {
+		return next;
 	}
-
-	public void addAttachment(ITermAttachment attachment) {
-		if (next != null) {
-			next = attachment;
-		} else {
-			next.addAttachment(attachment);
-		}
+	
+	public final void setNext(ITermAttachment next) {
+		this.next = next;
 	}
 
 }

Copied and modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/ISimpleTerm.java (from r21591, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/IAstNode.java)
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/IAstNode.java	Tue Dec 28 15:31:36 2010	(r21591, copy source)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/ISimpleTerm.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -1,31 +1,18 @@
-package org.spoofax.jsglr.client.imploder;
+package org.spoofax.interpreter.terms;
+
 
 /**
- * An interface for tree nodes with tokens.
- * 
- * @see ITreeFactory
- *      A factory interface that typically constructs nodes of this type.
+ * A simple tree-like interface for terms.
  * 
  * @author Lennart Kats <lennart add lclnet.nl>
  */
-public interface IAstNode {
-	IToken getLeftToken();
-	
-	IToken getRightToken();
-	
-	int getChildCount();
+public interface ISimpleTerm {
 	
-	IAstNode getChildAt(int i);
+	int getSubtermCount();
 	
-	String getSort();
+	ISimpleTerm getSubterm(int i);
 
-	/**
-	 * The element sort for lists and tuples.
-	 * 
-	 * @throws UnsupportedOperationException
-	 *             If the node is not a list or tuple.
-	 */
-	String getElementSort();
+	public<T extends ITermAttachment> T getAttachment(Class<T> type);
 	
 	boolean isList();
 }
\ No newline at end of file

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/IStrategoAppl.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/IStrategoAppl.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/IStrategoAppl.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -8,9 +8,11 @@
 package org.spoofax.interpreter.terms;
 
 
-public interface IStrategoAppl extends IStrategoTerm {
+public interface IStrategoAppl extends IStrategoTerm, IStrategoNamed {
 
     public IStrategoConstructor getConstructor();
+    
+    @Deprecated
     public IStrategoTerm[] getArguments();
 
 }

Added: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/IStrategoNamed.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/IStrategoNamed.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -0,0 +1,9 @@
+package org.spoofax.interpreter.terms;
+
+/** 
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public interface IStrategoNamed extends IStrategoTerm {
+
+	String getName();
+}

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/IStrategoString.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/IStrategoString.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/IStrategoString.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -7,7 +7,7 @@
  */
 package org.spoofax.interpreter.terms;
 
-public interface IStrategoString extends IStrategoTerm {
+public interface IStrategoString extends IStrategoTerm, IStrategoNamed {
 
     public String stringValue();
 

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/IStrategoTerm.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/IStrategoTerm.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/IStrategoTerm.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -7,8 +7,9 @@
  */
 package org.spoofax.interpreter.terms;
 
+import java.io.IOException;
 
-public interface IStrategoTerm {
+public interface IStrategoTerm extends ISimpleTerm {
 
     public static final int APPL = 1;
     public static final int LIST = 2;
@@ -55,9 +56,19 @@
     
     public boolean match(IStrategoTerm second);
     
+    /**
+     * @see org.spoofax.terms.io.TermReader#unparseToFile(IStrategoTerm, java.io.OutputStream)
+     * @see org.spoofax.terms.io.TermReader#unparseToFile(IStrategoTerm, java.io.Writer)
+     * @see writeToString(Appendable, int)
+     */
+    @Deprecated
     public void prettyPrint(ITermPrinter pp);
     
+    public String toString(int maxDepth);
+    
+    public void writeToString(Appendable output, int maxDepth) throws IOException;
+    
     public<T extends ITermAttachment> T getAttachment(Class<T> attachment);
     
-    public void addAttachment(ITermAttachment attachment);
+    public void putAttachment(ITermAttachment attachment);
 }

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/IStrategoTermBuilder.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/IStrategoTermBuilder.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/IStrategoTermBuilder.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -13,14 +13,8 @@
 public interface IStrategoTermBuilder {
     
     public IStrategoConstructor makeConstructor(String string, int arity);
-
-    // TODO: Remove makeAppl() and makeList() overloads to avoid accidental invocation
     
-    /**
-     * @deprecated Use {@link #makeAppl(IStrategoConstructor, IStrategoTerm...)} instead.
-     */
-    @Deprecated
-    public IStrategoAppl makeAppl(IStrategoConstructor ctr, IStrategoList kids);
+    // @Deprecated public IStrategoAppl makeAppl(IStrategoConstructor ctr, IStrategoList kids);
     public IStrategoAppl makeAppl(IStrategoConstructor ctr, IStrategoTerm... terms);
 
     public IStrategoPlaceholder makePlaceholder(IStrategoTerm template);
@@ -31,17 +25,28 @@
     public IStrategoList makeList(IStrategoTerm... terms);
     public IStrategoList makeList(Collection<IStrategoTerm> terms);
 
-    /**
-     * @deprecated Use {@link #makeListCons(IStrategoTerm, IStrategoList)} instead. 
-     */
-    @Deprecated
-    public IStrategoList makeList(IStrategoTerm head, IStrategoList tail);
+    // @Deprecated public IStrategoList makeList(IStrategoTerm head, IStrategoList tail);
     public IStrategoList makeListCons(IStrategoTerm head, IStrategoList tail);
     
     public IStrategoTerm annotateTerm(IStrategoTerm term, IStrategoList annotations);
 
     public boolean hasConstructor(String ctorName, int arity);
     
+    public int getDefaultStorageType();
+    
+    /**
+     * Sets the default storage type for terms, returning a (usually new) factory
+     * that guarantees it will never create terms with a higher storage
+     * type value than the given value.
+     * 
+     * Implementors should note that even strings and empty lists
+     * follow this contract, allowing users to create mutable
+     * terms and use term attachments.
+     * 
+     * @throws UnsupportedOperationException if the given storage type is not supported.
+     */
+    public IStrategoTermBuilder getFactoryWithStorageType(int storageType);
+    
 }
 
 

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/ITermAttachment.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/ITermAttachment.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/ITermAttachment.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -1,7 +1,18 @@
 package org.spoofax.interpreter.terms;
 
+/** 
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
 public interface ITermAttachment {
-	<T extends ITermAttachment> T tryGetAttachment(Class<T> type);
 	
-	void addAttachment(ITermAttachment attachment);
+	/**
+	 * The type of this attachment.
+	 * Should be implemented non-reflectively, i.e.
+	 * 'return ImploderAttachment.class', not 'getClass()'.
+	 */
+	Class<? extends ITermAttachment> getAttachmentType();
+	
+	void setNext(ITermAttachment attachment);
+
+	ITermAttachment getNext();
 }

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/ITermFactory.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/ITermFactory.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/ITermFactory.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -29,5 +29,6 @@
     public IStrategoList replaceList(IStrategoTerm[] kids, IStrategoList old);
     
     public IStrategoTuple replaceTuple(IStrategoTerm[] kids, IStrategoTuple old);
-
+    
+    public ITermFactory getFactoryWithStorageType(int storageType);
 }

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/AbstractTermFactory.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/AbstractTermFactory.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/AbstractTermFactory.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -1,5 +1,9 @@
 package org.spoofax.terms;
 
+import static java.lang.Math.min;
+import static org.spoofax.interpreter.terms.IStrategoTerm.MAXIMALLY_SHARED;
+import static org.spoofax.interpreter.terms.IStrategoTerm.MUTABLE;
+
 import java.util.Collection;
 import java.util.HashMap;
 
@@ -21,6 +25,19 @@
     private static final HashMap<StrategoConstructor, StrategoConstructor> asyncCtorCache =
         new HashMap<StrategoConstructor, StrategoConstructor>();
     
+    protected int defaultStorageType;
+    
+    public AbstractTermFactory(int defaultStorageType) {
+		this.defaultStorageType = defaultStorageType;
+	}
+    
+    public final int getDefaultStorageType() {
+		return defaultStorageType;
+	}
+    
+    protected final boolean isTermSharingAllowed() {
+    	return defaultStorageType != MUTABLE;
+    }
 
     public boolean hasConstructor(String ctorName, int arity) {
     	throw new UnsupportedOperationException();
@@ -79,7 +96,7 @@
     }
 
     public IStrategoList makeList(Collection<IStrategoTerm> terms) {
-        return makeList(terms.toArray(EMPTY));
+        return makeList(terms.toArray(new IStrategoTerm[terms.size()]));
     }
     
     @Deprecated
@@ -100,5 +117,27 @@
     public IStrategoTerm parseFromString(String text) {
     	return reader.parseFromString(text);
     }
+    
+    protected static int getStorageType(IStrategoTerm term) {
+    	return term == null ? MAXIMALLY_SHARED : term.getStorageType();
+    }
+    
+    protected static int getStorageType(IStrategoTerm term1, IStrategoTerm term2) {
+    	int result = term1.getStorageType();
+    	if (result == 0) return 0;
+    	return min(result, term2.getStorageType());
+    }
+    
+    protected int getStorageType(IStrategoTerm[] terms) {
+    	int result = defaultStorageType;
+    	for (IStrategoTerm term : terms) {
+    		int type = term.getStorageType();
+    		if (type < result) { 
+        		if (type == 0) return 0;
+    			result = type;
+    		}
+    	}
+    	return result;
+    }
 
 }

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/LazyTerm.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/LazyTerm.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/LazyTerm.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -4,6 +4,7 @@
 import org.spoofax.interpreter.terms.IStrategoConstructor;
 import org.spoofax.interpreter.terms.IStrategoInt;
 import org.spoofax.interpreter.terms.IStrategoList;
+import org.spoofax.interpreter.terms.IStrategoNamed;
 import org.spoofax.interpreter.terms.IStrategoReal;
 import org.spoofax.interpreter.terms.IStrategoString;
 import org.spoofax.interpreter.terms.IStrategoTerm;
@@ -11,11 +12,13 @@
 import org.spoofax.interpreter.terms.ITermPrinter;
 
 /**
+ * A lazily initialized term,
+ * 
+ * @see StrategoWrapped  A non-lazy wrapped term that supports attachments separate from its base term.
+ *
  * @author Lennart Kats <lennart add lclnet.nl>
  */
 public abstract class LazyTerm implements IStrategoAppl, IStrategoInt, IStrategoList, IStrategoReal, IStrategoString, IStrategoTuple {
-
-	// TODO: base class should be StrategoWrapped, or vice versa :o
 	
 	private IStrategoTerm term;
 	
@@ -48,6 +51,7 @@
 		return getWrapped().getTermType();
 	}
 
+	@Deprecated
 	public void prettyPrint(ITermPrinter pp) {
 		getWrapped().prettyPrint(pp);
 	}
@@ -72,7 +76,7 @@
 	}
 
 	public int getStorageType() {
-		return Math.min(SHARABLE, getWrapped().getStorageType());
+		return MUTABLE; // let's not spread these guys // Math.min(SHARABLE, getWrapped().getStorageType());
 	}
 
 	public boolean match(IStrategoTerm second) {
@@ -132,6 +136,12 @@
 			throw new TermWrapperException("Called getConstructor() on a term that is not of type APPL");
 		return ((IStrategoAppl) getWrapped()).getConstructor();
 	}
+	
+	public String getName() {
+		if (getTermType() != STRING && getTermType() != APPL)
+			throw new TermWrapperException("Called getName() on a term that is not of type STRING or APPL");
+		return ((IStrategoNamed) getWrapped()).getName();
+	}
 
 	public int intValue() {
 		if (getTermType() != INT)

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoAnnotation.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoAnnotation.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoAnnotation.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -1,11 +1,18 @@
 package org.spoofax.terms;
 
+import java.io.IOException;
+
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.ITermFactory;
 import org.spoofax.interpreter.terms.ITermPrinter;
 
 /**
+ * Wraps any term with annotations.
+ * 
+ * @see ITermFactory#annotateTerm(IStrategoTerm, IStrategoList)
+ *          Should generally be used to efficiently annotate a term.
+ * 
  * @author Lennart Kats <lennart add lclnet.nl>
  */
 public class StrategoAnnotation extends StrategoWrapped {
@@ -14,7 +21,7 @@
 	
 	private final ITermFactory factory;
 	
-	public StrategoAnnotation(ITermFactory factory, IStrategoTerm term, IStrategoList annotations, int storageType) {
+	protected StrategoAnnotation(ITermFactory factory, IStrategoTerm term, IStrategoList annotations, int storageType) {
 		super(term, annotations);
 		
 		if (!term.getAnnotations().isEmpty())
@@ -58,12 +65,22 @@
 	@Override
 	public String toString() {
 		StringBuilder result = new StringBuilder();
-		result.append(getWrapped().toString());
-		appendAnnotations(result);
+		try {
+			getWrapped().writeToString(result, Integer.MAX_VALUE);
+			appendAnnotations(result, Integer.MAX_VALUE);
+		} catch (IOException e) {
+			throw new RuntimeException(e); // shan't happen
+		}
 		return result.toString();
 	}
 	
+	public void writeToString(Appendable output, int maxDepth) throws IOException {
+		getWrapped().writeToString(output, maxDepth);
+		appendAnnotations(output, maxDepth);
+	}
+	
 	@Override
+	@Deprecated
 	public void prettyPrint(ITermPrinter pp) {
 		getWrapped().prettyPrint(pp);
 		printAnnotations(pp);

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoAppl.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoAppl.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoAppl.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -7,6 +7,8 @@
  */
 package org.spoofax.terms;
 
+import java.io.IOException;
+
 import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoConstructor;
 import org.spoofax.interpreter.terms.IStrategoList;
@@ -34,6 +36,7 @@
         return storageType;
     }
     
+    @Deprecated
     public IStrategoTerm[] getArguments() {
         return kids;
     }
@@ -41,6 +44,10 @@
     public IStrategoConstructor getConstructor() {
         return ctor;
     }
+    
+    public String getName() {
+    	return ctor.getName();
+    }
 
     public IStrategoTerm[] getAllSubterms() {
         return kids;
@@ -97,6 +104,7 @@
         }
     }
 
+    @Deprecated
     public void prettyPrint(ITermPrinter pp) {
         pp.print(ctor.getName());
         IStrategoTerm[] kids = getAllSubterms();
@@ -114,22 +122,23 @@
         printAnnotations(pp);
     }
 
-    @Override
-    public String toString() {
-        StringBuilder sb = new StringBuilder();
-        sb.append(ctor.getName());
+    public void writeToString(Appendable output, int maxDepth) throws IOException {
+        output.append(ctor.getName());
         IStrategoTerm[] kids = getAllSubterms();
         if(kids.length > 0) {
-            sb.append("(");
-            sb.append(kids[0]);
-            for(int i = 1; i < kids.length; i++) {
-                sb.append(",");
-                sb.append(kids[i].toString());
+            output.append('(');
+            if (maxDepth == 0) {
+            	output.append("...");
+            } else {
+	            kids[0].writeToString(output, maxDepth - 1);
+	            for(int i = 1; i < kids.length; i++) {
+	                output.append(',');
+	                kids[i].writeToString(output, maxDepth - 1);
+	            }
+	            output.append(')');
             }
-            sb.append(")");
         }
-        appendAnnotations(sb);
-        return sb.toString();
+        appendAnnotations(output, maxDepth);
     }
 
     @Override

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoConstructor.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoConstructor.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoConstructor.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -7,6 +7,8 @@
  */
 package org.spoofax.terms;
 
+import java.io.IOException;
+
 import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoConstructor;
 import org.spoofax.interpreter.terms.IStrategoList;
@@ -75,7 +77,14 @@
     @Override
     public String toString() {
         return name + "/" + arity;
-    }    
+    }
+    
+    public void writeToString(Appendable output, int maxDepth) throws IOException {
+    	output.append(name);
+    	output.append('/');
+    	output.append(Integer.toString(arity));
+    }
+    
     public IStrategoConstructor getConstructor() {
         return this;
     }

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoInt.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoInt.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoInt.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -7,6 +7,8 @@
  */
 package org.spoofax.terms;
 
+import java.io.IOException;
+
 import org.spoofax.interpreter.terms.IStrategoInt;
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoTerm;
@@ -70,17 +72,15 @@
         }
     }
 
-    public void prettyPrint(ITermPrinter pp) {
+    @Deprecated
+	public void prettyPrint(ITermPrinter pp) {
         pp.print(String.valueOf(intValue()));
         printAnnotations(pp);
     }
-
-    @Override
-    public String toString() {
-        StringBuilder result = new StringBuilder();
-        result.append(intValue());
-        appendAnnotations(result);
-        return result.toString();
+    
+    public void writeToString(Appendable output, int maxDepth) throws IOException {
+    	output.append(Integer.toString(intValue()));
+        appendAnnotations(output, maxDepth);
     }
     
     @Override

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoList.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoList.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoList.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -7,6 +7,8 @@
  */
 package org.spoofax.terms;
 
+import java.io.IOException;
+import java.util.Iterator;
 import java.util.NoSuchElementException;
 
 import org.spoofax.interpreter.terms.IStrategoList;
@@ -16,7 +18,7 @@
 /**
  * A basic stratego list implementation using a linked-list data structure.
  */
-public class StrategoList extends StrategoTerm implements IStrategoList {
+public class StrategoList extends StrategoTerm implements IStrategoList, Iterable<IStrategoTerm> {
 	
 	private static final int UNKNOWN_SIZE = -1;
 	
@@ -167,6 +169,7 @@
         }
     }
 
+    @Deprecated
     public void prettyPrint(ITermPrinter pp) {
         if(!isEmpty()) {
             pp.println("[");
@@ -188,20 +191,21 @@
         printAnnotations(pp);
     }
     
-    @Override
-    public String toString() {
-        StringBuilder sb = new StringBuilder();
-        sb.append("[");
+    public void writeToString(Appendable output, int maxDepth) throws IOException {
+        output.append('[');
         if(!isEmpty()) {
-            sb.append(head().toString());
-            for (IStrategoList cur = tail(); !cur.isEmpty(); cur = cur.tail()) {
-                sb.append(",");
-                sb.append(cur.head().toString());
+            if (maxDepth == 0) {
+            	output.append("...");
+            } else {
+	            head().writeToString(output, maxDepth - 1);
+	            for (IStrategoList cur = tail(); !cur.isEmpty(); cur = cur.tail()) {
+	                output.append(',');
+	                cur.head().writeToString(output, maxDepth - 1);
+	            }
             }
         }
-        sb.append("]");
-        appendAnnotations(sb);
-        return sb.toString();
+        output.append(']');
+        appendAnnotations(output, maxDepth);
     }
 
     @Override
@@ -219,4 +223,8 @@
 		result = prime * result + ((tail == null) ? 0 : tail.hashCode());
 		return result;
     }
+
+	public Iterator<IStrategoTerm> iterator() {
+		return new StrategoListIterator(this);
+	}
 }

Added: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoListIterator.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoListIterator.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -0,0 +1,40 @@
+package org.spoofax.terms;
+
+import java.util.Iterator;
+
+import org.spoofax.interpreter.terms.IStrategoList;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+
+public class StrategoListIterator implements Iterator<IStrategoTerm> {
+	
+	private IStrategoList current;
+
+	public StrategoListIterator(IStrategoList list) {
+		current = list;
+	}
+	
+	@SuppressWarnings("unchecked")
+	public static Iterable<IStrategoTerm> iterable(final IStrategoList list) {
+		if (list instanceof Iterable)
+			return ((Iterable<IStrategoTerm>) list);
+		return new Iterable<IStrategoTerm>() {
+			public Iterator<IStrategoTerm> iterator() {
+				return new StrategoListIterator(list);
+			}
+		};
+	}
+
+	public boolean hasNext() {
+		return !current.isEmpty();
+	}
+
+	public IStrategoTerm next() {
+		IStrategoTerm result = current.head();
+		current = current.tail();
+		return result;
+	}
+
+	public void remove() {
+		throw new UnsupportedOperationException();
+	}
+}

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoPlaceholder.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoPlaceholder.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoPlaceholder.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -1,5 +1,7 @@
 package org.spoofax.terms;
 
+import java.io.IOException;
+
 import org.spoofax.interpreter.terms.IStrategoConstructor;
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoPlaceholder;
@@ -23,14 +25,17 @@
     public int getTermType() {
         return PLACEHOLDER;
     }
-
-    @Override
-    public String toString() {
-        return "<" + getTemplate() + ">";
+    
+    public void writeToString(Appendable output, int maxDepth) throws IOException {
+    	output.append('<');
+    	getTemplate().writeToString(output, maxDepth - 1);
+    	output.append('>');
+    	appendAnnotations(output, maxDepth);
     }
     
     @Override
-    public void prettyPrint(ITermPrinter pp) {
+    @Deprecated
+	public void prettyPrint(ITermPrinter pp) {
         pp.print("<");
         getTemplate().prettyPrint(pp);
         pp.print(">");

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoReal.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoReal.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoReal.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -7,6 +7,8 @@
  */
 package org.spoofax.terms;
 
+import java.io.IOException;
+
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoReal;
 import org.spoofax.interpreter.terms.IStrategoTerm;
@@ -70,17 +72,15 @@
         }
     }
 
-    public void prettyPrint(ITermPrinter pp) {
+    @Deprecated
+	public void prettyPrint(ITermPrinter pp) {
         pp.print("" + realValue());
         printAnnotations(pp);
     }
-
-    @Override
-    public String toString() {
-        StringBuilder result = new StringBuilder();
-        result.append(realValue());
-        appendAnnotations(result);
-        return result.toString();
+    
+    public void writeToString(Appendable output, int maxDepth) throws IOException {
+    	output.append(Double.toString(realValue()));
+        appendAnnotations(output, maxDepth);
     }
 
     @Override

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoString.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoString.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoString.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -7,6 +7,8 @@
  */
 package org.spoofax.terms;
 
+import java.io.IOException;
+
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoString;
 import org.spoofax.interpreter.terms.IStrategoTerm;
@@ -83,7 +85,12 @@
         return value;
     }
     
-    public void prettyPrint(ITermPrinter pp) {
+    public String getName() {
+    	return value;
+    }
+    
+    @Deprecated
+	public void prettyPrint(ITermPrinter pp) {
         pp.print("\"");
         pp.print(stringValue().replace("\\", "\\\\").replace("\"", "\\\"")
         		.replace("\n", "\\n").replace("\r", "\\r"));
@@ -91,15 +98,12 @@
         printAnnotations(pp);
     }
  
-    @Override
-    public String toString() {
-        StringBuilder result = new StringBuilder();
-        result.append("\"");
-        result.append(stringValue().replace("\\", "\\\\").replace("\"", "\\\"")
+    public void writeToString(Appendable output, int maxDepth) throws IOException {
+    	output.append("\"");
+    	output.append(stringValue().replace("\\", "\\\\").replace("\"", "\\\"")
         		.replace("\n", "\\n").replace("\r", "\\r"));
-        result.append("\"");
-        appendAnnotations(result);
-        return result.toString();
+    	output.append("\"");
+        appendAnnotations(output, maxDepth);
     }
     
     @Override

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoTerm.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoTerm.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoTerm.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -7,6 +7,8 @@
  */
 package org.spoofax.terms;
 
+import java.io.IOException;
+
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.ITermAttachment;
@@ -122,22 +124,39 @@
     protected abstract int hashFunction();
     
     @Override
-    public abstract String toString();
+    public String toString() {
+    	return toString(Integer.MAX_VALUE);
+    }
+    
+    public String toString(int maxDepth) {
+    	StringBuilder result = new StringBuilder();
+    	try {
+    		writeToString(result, maxDepth);
+    	} catch (IOException e) {
+    		throw new RuntimeException(e); // shan't happen
+    	}
+    	return result.toString();
+    }
     
-    protected void appendAnnotations(StringBuilder sb) {
+    public final void writeToString(Appendable output) throws IOException {
+    	writeToString(output, Integer.MAX_VALUE);
+    }
+
+	protected void appendAnnotations(Appendable sb, int maxDepth) throws IOException {
         IStrategoList annos = getAnnotations();
         if (annos.size() == 0) return;
         
         sb.append('{');
-        sb.append(annos.get(0));
+        annos.get(0).writeToString(sb, maxDepth);
         for (annos = annos.tail(); !annos.isEmpty(); annos = annos.tail()) {
             sb.append(',');
-            sb.append(annos.head().toString());        	
+            annos.head().writeToString(sb, maxDepth);        	
         }
         sb.append('}');
     }
     
-    protected void printAnnotations(ITermPrinter pp) {
+	@Deprecated
+	protected void printAnnotations(ITermPrinter pp) {
         IStrategoList annos = getAnnotations();
         if (annos.size() == 0) return;
         
@@ -179,19 +198,40 @@
     	}
     }
     
-    public <T extends ITermAttachment> T getAttachment(Class<T> type) {
-    	if (attachment != null) {
-    		return attachment.tryGetAttachment(type); 
-    	} else {
-    		return null;
+    public boolean isList() {
+    	return getTermType() == LIST;
+    }
+    
+    @SuppressWarnings("unchecked")
+	public<T extends ITermAttachment> T getAttachment(Class<T> type) {
+    	for (ITermAttachment a = this.attachment; a != null; a = a.getNext()) {
+    		if (a.getAttachmentType() == type)
+    			return (T) a;
     	}
+		return null;
     }
     
-    public void addAttachment(ITermAttachment attachment) {
+    public void putAttachment(ITermAttachment attachment) {
+    	assert getStorageType() == MUTABLE : "Attachments only supported for mutable, non-shared terms; failed for " + this;
+    	assert attachment.getNext() == null;
     	if (this.attachment == null) {
     		this.attachment = attachment;
     	} else {
-    		this.attachment.addAttachment(attachment);
+    		Class<?> newType = attachment.getAttachmentType();
+    		if (this.attachment.getAttachmentType() == newType) {
+    			attachment.setNext(this.attachment.getNext());
+    			this.attachment = attachment;
+    		} else {
+    			ITermAttachment previous = attachment;
+    			for (ITermAttachment a = previous.getNext(); a != null; a = a.getNext()) {
+	        		if (a.getAttachmentType() == newType) {
+	        			attachment.setNext(a.getNext());
+	        			previous.setNext(attachment);
+	        			return;
+	        		}
+	        	}
+    			previous.setNext(attachment);
+    		}
     	}
     }
 }

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoTuple.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoTuple.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoTuple.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -7,6 +7,8 @@
  */
 package org.spoofax.terms;
 
+import java.io.IOException;
+
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.IStrategoTuple;
@@ -96,6 +98,7 @@
         }
     }
 
+    @Deprecated
     public void prettyPrint(ITermPrinter pp) {
         int sz = size();
         if(sz > 0) {
@@ -118,21 +121,22 @@
         printAnnotations(pp);
     }
     
-    @Override
-    public String toString() {
-        StringBuilder sb = new StringBuilder();
-        sb.append("(");
+    public void writeToString(Appendable output, int maxDepth) throws IOException {
+        output.append('(');
         IStrategoTerm[] kids = getAllSubterms();
-        if(kids.length > 0) {
-            sb.append(kids[0].toString());
-            for(int i = 1; i < kids.length; i++) {
-                sb.append(",");
-                sb.append(kids[i].toString());
-            }
-        }
-        sb.append(")");
-        appendAnnotations(sb);
-        return sb.toString();
+		if (kids.length > 0) {
+			if (maxDepth == 0) {
+				output.append("...");
+			} else {
+				kids[0].writeToString(output, maxDepth - 1);
+				for (int i = 1; i < kids.length; i++) {
+					output.append(',');
+					kids[i].writeToString(output, maxDepth - 1);
+				}
+			}
+		}
+        output.append(')');
+        appendAnnotations(output, maxDepth);
     }
     
     @Override

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoWrapped.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoWrapped.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoWrapped.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -1,9 +1,12 @@
 package org.spoofax.terms;
 
+import java.io.IOException;
+
 import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoConstructor;
 import org.spoofax.interpreter.terms.IStrategoInt;
 import org.spoofax.interpreter.terms.IStrategoList;
+import org.spoofax.interpreter.terms.IStrategoNamed;
 import org.spoofax.interpreter.terms.IStrategoReal;
 import org.spoofax.interpreter.terms.IStrategoString;
 import org.spoofax.interpreter.terms.IStrategoTerm;
@@ -11,11 +14,14 @@
 import org.spoofax.interpreter.terms.ITermPrinter;
 
 /**
- * A wrapped Stratego term of any type.
+ * A wrapped Stratego term of any type that supports attachments separate from its base term.
  * 
+ * @see StrategoAnnotation  A term wrapped with additional annotations.
+ * @see LazyTerm            A lazily initialized term.
+ *
  * @author Lennart Kats <lennart add lclnet.nl>
  */
-public abstract class StrategoWrapped extends StrategoTerm implements IStrategoAppl, IStrategoInt, IStrategoList, IStrategoReal, IStrategoString, IStrategoTuple {
+public class StrategoWrapped extends StrategoTerm implements IStrategoAppl, IStrategoInt, IStrategoList, IStrategoReal, IStrategoString, IStrategoTuple {
 	
 	private final IStrategoTerm wrapped;
 	
@@ -44,7 +50,9 @@
 		return wrapped;
 	}
 
-	public abstract int getStorageType();
+	public int getStorageType() {
+		return MUTABLE;
+	}
 	
 	// Common accessors
 
@@ -74,6 +82,7 @@
 		return wrapped.getTermType();
 	}
 
+	@Deprecated
 	public void prettyPrint(ITermPrinter pp) {
 		wrapped.prettyPrint(pp);
 	}
@@ -83,6 +92,11 @@
 		return wrapped.toString();
 	}
 	
+	public void writeToString(Appendable output, int maxDepth) throws IOException {
+		wrapped.writeToString(output, maxDepth);
+	}
+	
+	
 	// Semi-specialized accessors
 
 	public final IStrategoTerm get(int index) {
@@ -148,6 +162,12 @@
 			throw new TermWrapperException("Called realValue() on a term that is not of type REAL");
 		return ((IStrategoReal) wrapped).realValue();
 	}
+	
+	public String getName() {
+		if (getTermType() != STRING && getTermType() != APPL)
+			throw new TermWrapperException("Called getName() on a term that is not of type STRING or APPL");
+		return ((IStrategoNamed) wrapped).getName();
+	}
 
 	public String stringValue() {
 		if (getTermType() != STRING)

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StringTermReader.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StringTermReader.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/StringTermReader.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -155,11 +155,11 @@
         if(ch == '(') {
             List<IStrategoTerm> l = parseTermSequence(bis, ')');
             IStrategoConstructor c = factory.makeConstructor(sb.toString(), l.size());
-            return factory.makeAppl(c, l.toArray(AbstractTermFactory.EMPTY));
+            return factory.makeAppl(c, l.toArray(new IStrategoTerm[l.size()]));
         } else {
             bis.unread(ch);
             IStrategoConstructor c = factory.makeConstructor(sb.toString(), 0);
-            return factory.makeAppl(c, new IStrategoTerm[0]);
+            return factory.makeAppl(c, AbstractTermFactory.EMPTY);
         }
     }
     

Copied and modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/Term.java (from r21591, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/Term.java)
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/Term.java	Tue Dec 28 15:31:36 2010	(r21591, copy source)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/Term.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -1,63 +1,78 @@
-/*
- * Created on 04.des.2005
- *
- * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
- *
- * Licensed under the GNU Lesser General Public License, v2.1
- */
-package org.spoofax.jsglr.client;
-
-import org.spoofax.jsglr.shared.terms.ATerm;
-import org.spoofax.jsglr.shared.terms.ATermAppl;
-import org.spoofax.jsglr.shared.terms.ATermInt;
-import org.spoofax.jsglr.shared.terms.ATermList;
+package org.spoofax.terms;
+
+import org.spoofax.interpreter.terms.IStrategoAppl;
+import org.spoofax.interpreter.terms.IStrategoInt;
+import org.spoofax.interpreter.terms.IStrategoList;
+import org.spoofax.interpreter.terms.IStrategoReal;
+import org.spoofax.interpreter.terms.IStrategoString;
+import org.spoofax.interpreter.terms.IStrategoTerm;
 
 public class Term {
+    public static String stringAt(IStrategoTerm t, int i) {
+        return ((IStrategoString) t.getSubterm(i)).stringValue();
+    }
 
-    public static ATermInt asInt(ATerm t) {
-        return (ATermInt) t;
+    public static int intAt(IStrategoTerm t, int i) {
+        return ((IStrategoInt) t.getSubterm(i)).intValue();
     }
 
+    @SuppressWarnings("unchecked") // casting is inherently unsafe, but doesn't warrant a warning here
+    public static<T extends IStrategoTerm> T termAt(IStrategoTerm t, int i) {
+        return (T) t.getSubterm(i);
+    }
 
-    public static ATermAppl asAppl(ATerm t) {
-        return (ATermAppl) t;
+    public static IStrategoReal realAt(IStrategoList t, int i) {
+        return (IStrategoReal) t.getSubterm(i);
     }
 
-    public static int toInt(ATermInt t) {
-        return t.getInt();
+    public static boolean isTermString(IStrategoTerm t) {
+        return t.getTermType() == IStrategoTerm.STRING;
     }
 
-    public static int toInt(ATerm t) {
-        return ((ATermInt)t).getInt();
+    public static String javaString(IStrategoTerm t) {
+        return ((IStrategoString)t).stringValue();
     }
 
-    public static int intAt(ATerm pt, int i) {
-        return asInt((ATerm) pt.getChildAt(i)).getInt();
+    public static boolean isTermList(IStrategoTerm t) {
+        return t.getTermType() == IStrategoTerm.LIST;
+    }
+    
+    public static boolean isTermInt(IStrategoTerm t) {
+        return t.getTermType() == IStrategoTerm.INT;
     }
 
-    public static ATermList listAt(ATerm pt, int i) {
-        return termAt(pt, i);
+    public static boolean isTermReal(IStrategoTerm t) {
+        return t.getTermType() == IStrategoTerm.REAL;
     }
 
-    public static ATermAppl applAt(ATerm pt, int i) {
-        return termAt(pt, i);
+    public static boolean isTermAppl(IStrategoTerm t) {
+        return t.getTermType() == IStrategoTerm.APPL;
+    }
+    
+    public static boolean isTermNamed(IStrategoTerm t) {
+    	int type = t.getTermType();
+    	return type == IStrategoTerm.APPL || type == IStrategoTerm.STRING;
     }
 
-    @SuppressWarnings("unchecked") // casting is inherently unsafe, but doesn't warrant a warning here
-    public static<T extends ATerm> T termAt(ATerm t, int i) {
-        return (T) t.getChildAt(i);
+    public static int javaInt(IStrategoTerm term) {
+        return ((IStrategoInt)term).intValue();
     }
 
-    public static boolean isInt(ATerm t) {
-        return t.getType() == ATerm.INT;
+    public static boolean hasConstructor(IStrategoAppl t, String ctorName) {
+        return t.getConstructor().getName().equals(ctorName);
     }
 
-//    public static ATermList makeList(ATermFactory f, List<ATerm> kids) {
-//    	return f.makeList(kids);
-//    }
+    public static boolean isTermTuple(IStrategoTerm t) {
+        return t.getTermType() == IStrategoTerm.TUPLE;
+    }
 
-    public static boolean isAppl(ATerm t) {
-        return t.getType() == ATerm.APPL;
+    public static int asJavaInt(IStrategoTerm term) {
+        return ((IStrategoInt)term).intValue();
     }
 
+    public static String asJavaString(IStrategoTerm term) {
+        return ((IStrategoString)term).stringValue();
+    }
+
+
 }

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/TermFactory.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/TermFactory.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/TermFactory.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -3,10 +3,10 @@
 import static java.lang.Math.min;
 import static org.spoofax.interpreter.terms.IStrategoTerm.MAXIMALLY_SHARED;
 import static org.spoofax.interpreter.terms.IStrategoTerm.SHARABLE;
+import static org.spoofax.interpreter.terms.IStrategoTerm.MUTABLE;
 import static org.spoofax.interpreter.terms.IStrategoTerm.STRING;
 
 import java.lang.ref.WeakReference;
-import java.util.Collection;
 import java.util.WeakHashMap;
 
 import org.spoofax.interpreter.terms.IStrategoAppl;
@@ -26,8 +26,6 @@
  */
 public class TermFactory extends AbstractTermFactory implements ITermFactory {
     
-    private static final int MY_STORAGE_TYPE = SHARABLE;
-    
     // Strings should be MAXIMALLY_SHARED, but we use
     // a weaker assumption instead to be safe (StrategoXT/834)
     private static final int STRING_STORAGE_TYPE = SHARABLE;
@@ -51,6 +49,20 @@
     private static final WeakHashMap<String, WeakReference<StrategoString>> asyncStringPool =
         new WeakHashMap<String, WeakReference<StrategoString>>();
     
+    public TermFactory() {
+    	super(SHARABLE);
+    }
+    
+    public ITermFactory getFactoryWithStorageType(int storageType) {
+    	if (storageType > SHARABLE)
+    		throw new UnsupportedOperationException();
+    	if (storageType == defaultStorageType)
+    		return this;
+    	TermFactory result = new TermFactory();
+    	result.defaultStorageType = storageType;
+    	return result;
+    }
+    
     public boolean hasConstructor(String name, int arity) {
         synchronized (TermFactory.class) {
         	if (arity == 0) {
@@ -73,7 +85,7 @@
 
     public IStrategoAppl makeAppl(IStrategoConstructor ctr,
             IStrategoTerm[] terms, IStrategoList annotations) {
-    	int storageType = MY_STORAGE_TYPE;
+    	int storageType = defaultStorageType;
 		storageType = min(storageType, getStorageType(terms));
     	if (storageType != 0)
         	storageType = min(storageType, getStorageType(annotations));
@@ -94,9 +106,13 @@
     	return results;
     }
     
+    protected IStrategoList makeList() {
+    	return isTermSharingAllowed() ? EMPTY_LIST : new StrategoList(null, null, null, defaultStorageType);
+    }
+    
     public IStrategoList makeList(IStrategoTerm[] terms, IStrategoList outerAnnos) {
-        StrategoList result = EMPTY_LIST;
-        int storageType = MY_STORAGE_TYPE;
+    	int storageType = defaultStorageType;
+        IStrategoList result = makeList();
         int i = terms.length - 1;
         while (i > 0) {
         	IStrategoTerm head = terms[i--];
@@ -109,22 +125,18 @@
 			result = new StrategoList(head, result, outerAnnos, storageType);
         } else {
         	if (outerAnnos == null || outerAnnos.isEmpty()) {
-        		return EMPTY_LIST;
+        		return makeList();
         	} else {
-        		return new StrategoList(null, null, outerAnnos, MY_STORAGE_TYPE);
+        		return new StrategoList(null, null, outerAnnos, defaultStorageType);
         	}
         }
         return result;
     }
-
-    public IStrategoList makeList(Collection<IStrategoTerm> terms) {
-        return makeList(terms.toArray(EMPTY));
-    }
     
     public IStrategoList makeListCons(IStrategoTerm head, IStrategoList tail, IStrategoList annotations) {
-    	int storageType = min(MY_STORAGE_TYPE, getStorageType(head, tail));
+    	int storageType = min(defaultStorageType, getStorageType(head, tail));
     	
-    	if (head == null) return EMPTY_LIST;
+    	if (head == null) return makeList();
     	return new StrategoList(head, tail, annotations, storageType);
     }
 
@@ -134,7 +146,7 @@
 
     public IStrategoString makeString(String s) {
     	if (s.length() > MAX_POOLED_STRING_LENGTH)
-    		return new StrategoString(s, null, MY_STORAGE_TYPE);
+    		return new StrategoString(s, null, defaultStorageType);
     	
     	synchronized (TermFactory.class) {
 	    	WeakReference<StrategoString> resultRef = asyncStringPool.get(s);
@@ -143,37 +155,17 @@
 	        	result = new StrategoString(s, null, STRING_STORAGE_TYPE);
 	        	asyncStringPool.put(s, new WeakReference<StrategoString>(result));
 	    	}
+        	if (!isTermSharingAllowed() && STRING_STORAGE_TYPE != MUTABLE) 
+        		return new StrategoWrapped(result);
 	    	return result;
     	}
     }
 
     public IStrategoTuple makeTuple(IStrategoTerm[] terms, IStrategoList annos) {
-        int storageType = min(MY_STORAGE_TYPE, getStorageType(terms));
+        int storageType = min(defaultStorageType, getStorageType(terms));
 		return new StrategoTuple(terms, annos, storageType);
     }
     
-    protected static int getStorageType(IStrategoTerm term) {
-    	return term == null ? MAXIMALLY_SHARED : term.getStorageType();
-    }
-    
-    protected static int getStorageType(IStrategoTerm term1, IStrategoTerm term2) {
-    	int result = term1.getStorageType();
-    	if (result == 0) return 0;
-    	return min(result, term2.getStorageType());
-    }
-    
-    protected static int getStorageType(IStrategoTerm[] terms) {
-    	int result = MY_STORAGE_TYPE;
-    	for (IStrategoTerm term : terms) {
-    		int type = term.getStorageType();
-    		if (type < result) { 
-        		if (type == 0) return 0;
-    			result = type;
-    		}
-    	}
-    	return result;
-    }
-    
     public IStrategoTerm annotateTerm(IStrategoTerm term, IStrategoList annotations) {
         if (term.getAnnotations() == annotations) { // cheap check
             return term;
@@ -182,20 +174,20 @@
 				if (annotations == EMPTY_LIST || annotations.isEmpty()) {
 					return EMPTY_LIST;
 				} else {
-					return new StrategoList(null, null, annotations, MY_STORAGE_TYPE);
+					return new StrategoList(null, null, annotations, defaultStorageType);
 				}
 			} else if (term.getTermType() == STRING) {
 				String value = ((IStrategoString) term).stringValue();
 				if (annotations == EMPTY_LIST || annotations.isEmpty()) {
 					return makeString(value);
 				} else {
-					return new StrategoString(value, annotations, MY_STORAGE_TYPE);
+					return new StrategoString(value, annotations, defaultStorageType);
 				}
 			} else if (term.getAnnotations() == EMPTY_LIST) {
-				return new StrategoAnnotation(this, term, annotations, MY_STORAGE_TYPE);
+				return new StrategoAnnotation(this, term, annotations, defaultStorageType);
 			} else if (term instanceof StrategoAnnotation) {
 				term = ((StrategoAnnotation) term).getWrapped();
-				int storageType = min(MY_STORAGE_TYPE, getStorageType(term));
+				int storageType = min(defaultStorageType, getStorageType(term));
 				return new StrategoAnnotation(this, term, annotations, storageType);
 			} else {
 				throw new UnsupportedOperationException("Unable to annotate term of type " + term.getClass().getName());
@@ -215,7 +207,7 @@
 	public IStrategoPlaceholder makePlaceholder(IStrategoTerm template) {
         if (placeholderConstructor == null)
             placeholderConstructor = makeConstructor("<>", 1);
-        return new StrategoPlaceholder(placeholderConstructor, template, EMPTY_LIST, MY_STORAGE_TYPE);
+        return new StrategoPlaceholder(placeholderConstructor, template, EMPTY_LIST, defaultStorageType);
 	}
 
 }

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/AbstractIOTermFactory.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/AbstractIOTermFactory.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/AbstractIOTermFactory.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -21,8 +21,12 @@
 
 @Deprecated
 public abstract class AbstractIOTermFactory extends AbstractTermFactory implements IFileTermFactory {
-	
+
 	private final TermReader reader = new TermReader(this);
+	
+	public AbstractIOTermFactory(int defaultStorageType) {
+		super(defaultStorageType);
+	}
 
     public IStrategoTerm parseFromStream(InputStream inputStream) throws IOException {
         return reader.parseFromStream(inputStream);

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/TermReader.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/TermReader.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/TermReader.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -59,11 +59,15 @@
         
         return parseFromStream(pushbackStream);
         */
-        if (!(inputStream instanceof BufferedInputStream))
-            inputStream = new BufferedInputStream(inputStream);
-        PushbackInputStream bis = new PushbackInputStream(inputStream);
-        
-        return parseFromStream(bis);
+    	try {
+	        if (!(inputStream instanceof BufferedInputStream))
+	            inputStream = new BufferedInputStream(inputStream);
+	        PushbackInputStream bis = new PushbackInputStream(inputStream);
+	        
+	        return parseFromStream(bis);
+    	} finally {
+    		inputStream.close();
+    	}
     }
 
     protected IStrategoTerm parseFromStream(PushbackInputStream bis) throws IOException {
@@ -183,11 +187,11 @@
         if(ch == '(') {
             List<IStrategoTerm> l = parseTermSequence(bis, ')');
             IStrategoConstructor c = factory.makeConstructor(sb.toString(), l.size());
-            return factory.makeAppl(c, l.toArray(AbstractTermFactory.EMPTY));
+            return factory.makeAppl(c, l.toArray(new IStrategoTerm[l.size()]));
         } else {
             bis.unread(ch);
             IStrategoConstructor c = factory.makeConstructor(sb.toString(), 0);
-            return factory.makeAppl(c, new IStrategoTerm[0]);
+            return factory.makeAppl(c, AbstractTermFactory.EMPTY);
         }
     }
     

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/baf/BAFTermReader.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/baf/BAFTermReader.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/baf/BAFTermReader.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -39,17 +39,21 @@
             return super.parseFromStream(bis);
         }
         */
-    	BufferedInputStream bis;
-        if (inputStream instanceof BufferedInputStream)
-            bis = (BufferedInputStream) inputStream;
-        else
-            bis = new BufferedInputStream(inputStream);
-        
-        if (BAFReader.isBinaryATerm(bis)) {
-            return new BAFReader(getFactory(), bis).readFromBinaryFile(true);
-        } else {
-            return super.parseFromStream(bis);
-        }
+    	BufferedInputStream bis = null;
+    	try {
+	        if (inputStream instanceof BufferedInputStream)
+	            bis = (BufferedInputStream) inputStream;
+	        else
+	            bis = new BufferedInputStream(inputStream);
+	        
+	        if (BAFReader.isBinaryATerm(bis)) {
+	            return new BAFReader(getFactory(), bis).readFromBinaryFile(true);
+	        } else {
+	            return super.parseFromStream(bis);
+	        }
+    	} finally {
+    		if (bis != null) bis.close();
+    	}
     }
 
 }

Modified: strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/ImportTerm.java
==============================================================================
--- strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/ImportTerm.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/ImportTerm.java	Wed Dec 29 13:13:19 2010	(r21594)
@@ -11,6 +11,7 @@
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.ITermFactory;
 import org.spoofax.terms.LazyTerm;
+import org.spoofax.terms.io.TermReader;
 
 import aterm.ATerm;
 import aterm.ATermFactory;
@@ -63,7 +64,7 @@
 		
 		InputStream stream = openStream();
 		try {
-			IStrategoTerm result = ((org.spoofax.interpreter.terms.io.IFileTermFactory) factory).parseFromStream(stream);
+			IStrategoTerm result = new TermReader(factory).parseFromStream(stream);
 			return result;
 		} catch (java.io.IOException e) {
 			throw new StrategoException(container.getSimpleName()

From R.B.Vermaas at tudelft.nl  Wed Dec 29 16:20:19 2010
From: R.B.Vermaas at tudelft.nl (Rob Vermaas)
Date: Wed, 29 Dec 2010 15:20:19 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21595 - hydra
Message-ID: <201012291520.oBTFKJ3h012331@proliant.st.ewi.tudelft.nl>

Author: rob
Date: Wed Dec 29 15:20:19 2010
New Revision: 21595
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21595&sc=1

Log:
for all stratego builds set stack size to unlimited

Modified:
   hydra/build.nix

Modified: hydra/build.nix
==============================================================================
--- hydra/build.nix	Wed Dec 29 13:13:19 2010	(r21594)
+++ hydra/build.nix	Wed Dec 29 15:20:19 2010	(r21595)
@@ -90,6 +90,10 @@
 
       meta.maintainers = if specpkgs ? notifyAddresses then specpkgs.notifyAddresses else [] ;
 
+      preHook = ''
+        ulimit -s unlimited
+      '';
+
     } // pkgs.lib.optionalAttrs (pkgs.stdenv.system == "i686-cygwin") 
             { preConfigure = ''
                 export PATH=$PATH:$out/bin:${pkgs.lib.concatStringsSep ":" (map (p: "${p}/bin") buildInputs)}

From R.B.Vermaas at tudelft.nl  Wed Dec 29 16:28:36 2010
From: R.B.Vermaas at tudelft.nl (Rob Vermaas)
Date: Wed, 29 Dec 2010 15:28:36 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21596 - hydra
Message-ID: <201012291528.oBTFSaD9014136@proliant.st.ewi.tudelft.nl>

Author: rob
Date: Wed Dec 29 15:28:36 2010
New Revision: 21596
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21596&sc=1

Log:
stratego builds: ok, maybe not unlimited

Modified:
   hydra/build.nix

Modified: hydra/build.nix
==============================================================================
--- hydra/build.nix	Wed Dec 29 15:20:19 2010	(r21595)
+++ hydra/build.nix	Wed Dec 29 15:28:36 2010	(r21596)
@@ -91,7 +91,7 @@
       meta.maintainers = if specpkgs ? notifyAddresses then specpkgs.notifyAddresses else [] ;
 
       preHook = ''
-        ulimit -s unlimited
+        ulimit -s 64000
       '';
 
     } // pkgs.lib.optionalAttrs (pkgs.stdenv.system == "i686-cygwin") 

From m.dejonge at tudelft.nl  Thu Dec 30 22:14:59 2010
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Thu, 30 Dec 2010 21:14:59 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21597 -
	spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego
Message-ID: <201012302114.oBULEx0S014751@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: Thu Dec 30 21:14:57 2010
New Revision: 21597
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21597&sc=1

Log:
bugfixes layout preservation

Added:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginSeparatorWithLayoutPrimitive.java   (contents, props changed)
Modified:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/DocumentStructure.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/IMPLibrary.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginSeparatingWhitespacePrimitive.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/DocumentStructure.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/DocumentStructure.java	Wed Dec 29 15:28:36 2010	(r21596)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/DocumentStructure.java	Thu Dec 30 21:14:57 2010	(r21597)
@@ -29,18 +29,17 @@
 	private int getLayoutEnd() {
 		int endOffset;
 		if(!commentsAfter.isEmpty())
-			endOffset=commentsAfter.get(commentsAfter.size()-1).getEndOffset()+1;
+			endOffset=commentsAfter.get(commentsAfter.size()-1).getEndOffset();
 		else
-			endOffset=node.getRightIToken().getEndOffset()+1;
-		int lookForward=endOffset-1;
+			endOffset=node.getRightIToken().getEndOffset();
+		int lookForward=endOffset;
 		do{
 			if(getLexStream().getCharValue(lookForward)=='\n'){
-				endOffset=lookForward+1;
-				break;
+				endOffset=lookForward;
 			}
 			lookForward++;
 		} while(lookForward < getLexStream().getStreamLength() && Character.isWhitespace(getLexStream().getCharValue(lookForward)));
-		return endOffset;
+		return endOffset+1; //exclusive end
 	}
 
 	private int getLayoutStart() {
@@ -298,11 +297,11 @@
 				result+=4;//TODO: use editor settings 
 			}
 			else if (c=='\n')
-				return 0;//empty lines have 0 indent
+				return -1;//empty lines have -1 indent
 			if (!Character.isWhitespace(c))
 				return result;
 		}
-		return 0;
+		return -1;
 	}
 	
 	private static String getIndentation(String line) {
@@ -327,6 +326,7 @@
 		return TokenKind.valueOf(tok.getKind())==TokenKind.TK_LAYOUT;
 	}
 	
+	
 	public class TextFragment{
 		private int start;
 		private int end;

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/IMPLibrary.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/IMPLibrary.java	Wed Dec 29 15:28:36 2010	(r21596)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/IMPLibrary.java	Thu Dec 30 21:14:57 2010	(r21597)
@@ -41,6 +41,7 @@
 		add(new OriginIndentationPrimitive());
 		add(new OriginSeparatingWhitespacePrimitive());
 		add(new OriginSeparatorPrimitive());
+		add(new OriginSeparatorWithLayoutPrimitive());
 	}
 
 	public String getOperatorRegistryName() {

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginSeparatingWhitespacePrimitive.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginSeparatingWhitespacePrimitive.java	Wed Dec 29 15:28:36 2010	(r21596)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginSeparatingWhitespacePrimitive.java	Thu Dec 30 21:14:57 2010	(r21597)
@@ -20,5 +20,4 @@
 		ITermFactory factory = env.getFactory();
 		return factory.makeString(loStructure.getSeperatingWhitespace());
 	}
-
 }

Added: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginSeparatorWithLayoutPrimitive.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginSeparatorWithLayoutPrimitive.java	Thu Dec 30 21:14:57 2010	(r21597)
@@ -0,0 +1,103 @@
+package org.strategoxt.imp.runtime.stratego;
+
+import lpg.runtime.ILexStream;
+import lpg.runtime.IPrsStream;
+import lpg.runtime.IToken;
+
+import org.spoofax.interpreter.core.IContext;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.ITermFactory;
+import org.strategoxt.imp.runtime.parser.ast.AstNode;
+import org.strategoxt.imp.runtime.parser.ast.AstNodeFactory;
+import org.strategoxt.imp.runtime.parser.ast.ListAstNode;
+import org.strategoxt.imp.runtime.parser.ast.SubListAstNode;
+import org.strategoxt.imp.runtime.stratego.adapter.IStrategoAstNode;
+import org.strategoxt.imp.runtime.stratego.adapter.IWrappedAstNode;
+
+/**
+ * @author Maartje de Jonge
+ */
+public class OriginSeparatorWithLayoutPrimitive extends AbstractOriginPrimitive {
+
+	public OriginSeparatorWithLayoutPrimitive() {
+		super("SSL_EXT_origin_separator_with_lo");
+	}
+
+	/**
+	 * Returns the separator and its location plus layout 
+	 * after a list element or sublist (before in case of last element(s)).
+	 * Returns null if the separator can not be found.
+	 */
+	@Override
+	protected IStrategoTerm call(IContext env, IWrappedAstNode node) {
+		IStrategoAstNode originNode=node.getNode();
+		SubListAstNode sublist;
+		AstNode left;
+		AstNode right;
+		if(originNode instanceof SubListAstNode){
+			sublist = (SubListAstNode) originNode;							
+		}
+		else{
+			IStrategoAstNode parent = node.getNode().getParent();
+			if(!(parent instanceof ListAstNode))
+				return null;
+			sublist = (SubListAstNode) new AstNodeFactory().createSublist((ListAstNode) parent, originNode, originNode, true);
+		}
+		ListAstNode list = sublist.getCompleteList();
+		int lastIndexList = list.getChildren().size()-1;
+		boolean atEnd=false;
+		if(sublist.getIndexEnd() < lastIndexList){
+			left = sublist.getLastChild();
+			right = list.getChildren().get(sublist.getIndexEnd()+1);
+		}
+		else if(sublist.getIndexStart() > 0){
+			right = sublist.getFirstChild();
+			left = list.getChildren().get(sublist.getIndexStart()-1);
+			atEnd=true;
+		}
+		else
+			return null; //complete list has no separator
+		
+		IPrsStream tokens=left.getRightIToken().getIPrsStream();
+		int startTokenSearch = left.getRightIToken().getTokenIndex()+1;
+		int endTokenSearch = right.getLeftIToken().getTokenIndex()-1;
+		int startSeparation=-1;
+		int endSeparation=-1;
+		int loopIndex=startTokenSearch;
+		while (loopIndex <= endTokenSearch) {
+			IToken tok = tokens.getTokenAt(loopIndex);
+			if(!DocumentStructure.isLayoutToken(tok)){
+				if(startSeparation==-1)
+					startSeparation=tok.getStartOffset();
+				endSeparation=tok.getEndOffset()+1;
+			}
+			loopIndex++;
+		}
+		ILexStream lex = originNode.getLeftIToken().getILexStream();
+		int endOfSep=endSeparation;
+		int startOfSep=startSeparation;
+		if(startSeparation!=-1){
+			if(sublist.getIndexStart() > 0){
+				String potentialLayout = lex.toString(left.getRightIToken().getEndOffset()+1, startOfSep-1);
+				int newlineIndex=potentialLayout.lastIndexOf('\n');
+				if(newlineIndex>=0){
+					startOfSep=left.getRightIToken().getEndOffset()+1+newlineIndex+1;
+				}
+			}
+			if(!atEnd){
+				String potentialLayout_r = lex.toString(endOfSep, right.getLeftIToken().getStartOffset()-1);
+				int newlineIndex_r=potentialLayout_r.lastIndexOf('\n');
+				if(newlineIndex_r>=0){
+					endOfSep=endOfSep+1+newlineIndex_r;
+				}
+			}		
+			ITermFactory factory = env.getFactory();
+			return factory.makeTuple(
+					factory.makeInt(startOfSep),
+					factory.makeInt(endOfSep),
+					factory.makeString(lex.toString(startOfSep, endOfSep-1))
+			);
+		}
+		return null;
+	}
+}

From L.C.L.Kats at tudelft.nl  Fri Dec 31 13:06:26 2010
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Fri, 31 Dec 2010 12:06:26 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21598 -
	spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model
Message-ID: <201012311206.oBVC6QrI006254@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: Fri Dec 31 12:06:26 2010
New Revision: 21598
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21598&sc=1

Log:
Note about term factories

Modified:
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/EStrategoStackFrame.java

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/EStrategoStackFrame.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/EStrategoStackFrame.java	Thu Dec 30 21:14:57 2010	(r21597)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.debug.core/src/org/strjdbg/eclipse/core/str/model/EStrategoStackFrame.java	Fri Dec 31 12:06:26 2010	(r21598)
@@ -75,6 +75,7 @@
 			{
 				for(String dynamicRuleName : this.frameData.getDynamicRules())
 				{
+					TODO: Use an (I)TermFactory to create terms; invoking string term constructors like this breaks all kinds of things! (LK)
 					EStrategoVariable v = new EStrategoVariable(this.fTarget, new BasicStrategoString("rule contents"), dynamicRuleName);
 					v.setValueChanged(true);
 					vars.add(v);

From L.C.L.Kats at tudelft.nl  Fri Dec 31 13:07:47 2010
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Fri, 31 Dec 2010 12:07:47 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r21599 -
	spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.debug.stratego.runtime/META-INF
	spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.debug.s...
Message-ID: <201012311207.oBVC7l2h006519@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: Fri Dec 31 12:07:46 2010
New Revision: 21599
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=21599&sc=1

Log:
Couple more changes related to org.spoofax.terms

Added:
   spoofax/branches/spoofax-new-terms/spoofax/_attic/org.spoofax.editor/
      - copied from r21593, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.editor/
   spoofax/branches/spoofax-new-terms/spoofax/_attic/org.spoofax.interpreter/
      - copied from r21593, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter/
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.aterm/
      - copied from r21593, spoofax/branches/spoofax-new-terms/spoofax/_attic/org.spoofax.aterm/
Replaced:
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/ITermFactory.java
      - copied unchanged from r21594, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/ITermFactory.java
Deleted:
   spoofax/branches/spoofax-new-terms/spoofax/_attic/org.spoofax.aterm/
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.editor/
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter/
   strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/compat/sglr/JSGLR_open_parsetable_compat.java
Modified:
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.debug.stratego.runtime/META-INF/MANIFEST.MF
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.debug.stratego.transformer/META-INF/MANIFEST.MF
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.aster/META-INF/MANIFEST.MF
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.aterm/META-INF/MANIFEST.MF
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.aterm/editor/java/org/strategoxt/imp/editors/aterm/ATermParseController.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.aterm/editor/java/org/strategoxt/imp/editors/aterm/Activator.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.editorservice/META-INF/MANIFEST.MF
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.pp/META-INF/MANIFEST.MF
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.rtg/META-INF/MANIFEST.MF
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.sdf/META-INF/MANIFEST.MF
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.spoofax/META-INF/MANIFEST.MF
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.stratego/META-INF/MANIFEST.MF
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.generator/META-INF/MANIFEST.MF
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.generator/src/sdf2imp/project/create-manifest.str
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.metatooling/META-INF/MANIFEST.MF
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building/DynamicDescriptorBuilder.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/stratego/IMPParseStrategoFileStrategy.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/wizards/NewEditorWizard.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.nativebundle/META-INF/MANIFEST.MF
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/META-INF/MANIFEST.MF
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/Environment.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/Descriptor.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/DescriptorFactory.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/DynamicParseTableProvider.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/ParseControllerFactory.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/ParseTableProvider.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/AbstractSGLRI.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/CSGLRI.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/JSGLRI.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ParseErrorHandler.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/SGLRParseController.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/StandAloneSGLRI.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AmbAsfixImploder.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AsfixAnalyzer.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AsfixImploder.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AstAnnoImploder.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/ProductionAttributeReader.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/tokens/KeywordRecognizer.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/tokens/TokenKindManager.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/ContentProposer.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/CustomStrategyBuilder.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoBuilder.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoObserver.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/IMPAnnoLocationPrimitive.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/IMPImplodeAsfixStrategy.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/IMPParseStringPTPrimitive.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/SourceMappings.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/StrategoTermPath.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/IStrategoAstNode.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/WrappedAstNodeAppl.java
   spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.testing/META-INF/MANIFEST.MF
   spoofax/branches/spoofax-new-terms/spoofax/_attic/org.spoofax.interpreter/META-INF/MANIFEST.MF
   spoofax/branches/spoofax-new-terms/spoofax/_attic/org.spoofax.interpreter/src/java/org/spoofax/interpreter/ConcreteInterpreter.java
   spoofax/branches/spoofax-new-terms/spoofax/_attic/org.spoofax.interpreter/src/java/org/spoofax/interpreter/cli/Main.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.compiler/META-INF/MANIFEST.MF
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.compiler/src/java/org/spoofax/compiler/Compiler.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/META-INF/MANIFEST.MF
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_write_term_to_string.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/StrategoHashMap.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/StrategoSet.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/META-INF/MANIFEST.MF
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLRLibrary.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLRPrimitive.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLR_open_parsetable.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLR_parse_stratego.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLR_parse_string_pt.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/SGLR.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/io/ParseTableManager.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/io/SGLR.java
   spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/LazyTerm.java
   spoofax/branches/spoofax-new-terms/spoofax/xlet/META-INF/MANIFEST.MF
   strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/META-INF/MANIFEST.MF
   strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/build.properties
   strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/Makefile.am
   strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/Context.java
   strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/ImportTerm.java
   strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/SRTS_EXT_newint_0_0.java
   strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/compat/CompatManager.java
   strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/compat/sglr/AbstractFilterSetting.java
   strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/compat/sglr/JSGLR_parse_string_pt_compat.java
   strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/compat/sglr/SGLRCompatLibrary.java
   strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/compat/sglr/STRSGLR_get_parse_error.java
   strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/parallel/stratego_parallel/ParallelJobExecutor.java
   strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/spoofax-libs.jar

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.debug.stratego.runtime/META-INF/MANIFEST.MF
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.debug.stratego.runtime/META-INF/MANIFEST.MF	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.debug.stratego.runtime/META-INF/MANIFEST.MF	Fri Dec 31 12:07:46 2010	(r21599)
@@ -14,7 +14,6 @@
   org.eclipse.ui.editors,
   org.eclipse.ui.workbench.texteditor,
   org.strategoxt.imp.runtime,
-  org.spoofax.aterm,
   org.spoofax.jsglr,
   org.strategoxt.strj
 Bundle-RequiredExecutionEnvironment: J2SE-1.5

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.debug.stratego.transformer/META-INF/MANIFEST.MF
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.debug.stratego.transformer/META-INF/MANIFEST.MF	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.debug.stratego.transformer/META-INF/MANIFEST.MF	Fri Dec 31 12:07:46 2010	(r21599)
@@ -14,7 +14,6 @@
  org.eclipse.ui.editors,
  org.eclipse.ui.workbench.texteditor,
  org.strategoxt.imp.runtime,
- org.spoofax.aterm,
  org.spoofax.jsglr,
  org.strategoxt.strj
 Bundle-RequiredExecutionEnvironment: J2SE-1.5

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.aster/META-INF/MANIFEST.MF
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.aster/META-INF/MANIFEST.MF	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.aster/META-INF/MANIFEST.MF	Fri Dec 31 12:07:46 2010	(r21599)
@@ -14,7 +14,6 @@
   org.eclipse.ui.editors,
   org.eclipse.ui.workbench.texteditor,
   org.strategoxt.imp.runtime,
-  org.spoofax.aterm,
   org.spoofax.jsglr,
   org.strategoxt.strj
 Bundle-RequiredExecutionEnvironment: J2SE-1.5

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.aterm/META-INF/MANIFEST.MF
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.aterm/META-INF/MANIFEST.MF	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.aterm/META-INF/MANIFEST.MF	Fri Dec 31 12:07:46 2010	(r21599)
@@ -14,7 +14,6 @@
   org.eclipse.ui.editors,
   org.eclipse.ui.workbench.texteditor,
   org.strategoxt.imp.runtime,
-  org.spoofax.aterm,
   org.spoofax.jsglr,
   org.strategoxt.strj
 Bundle-RequiredExecutionEnvironment: J2SE-1.5

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.aterm/editor/java/org/strategoxt/imp/editors/aterm/ATermParseController.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.aterm/editor/java/org/strategoxt/imp/editors/aterm/ATermParseController.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.aterm/editor/java/org/strategoxt/imp/editors/aterm/ATermParseController.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -11,7 +11,7 @@
 
 public class ATermParseController extends DynamicParseController 
 { 
-  public static final String LANGUAGE = new String("ATerm");
+  public static final String LANGUAGE = new String("IStrategoTerm");
 
   private static final String TABLE = "/include/" + LANGUAGE + ".tbl";
 

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.aterm/editor/java/org/strategoxt/imp/editors/aterm/Activator.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.aterm/editor/java/org/strategoxt/imp/editors/aterm/Activator.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.aterm/editor/java/org/strategoxt/imp/editors/aterm/Activator.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -6,9 +6,9 @@
 
 public class Activator extends PluginBase 
 { 
-  public static final String kPluginID = "ATerm";
+  public static final String kPluginID = "IStrategoTerm";
 
-  public static final String kLanguageName = "ATerm";
+  public static final String kLanguageName = "IStrategoTerm";
 
   protected static Activator sPlugin;
 

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.editorservice/META-INF/MANIFEST.MF
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.editorservice/META-INF/MANIFEST.MF	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.editorservice/META-INF/MANIFEST.MF	Fri Dec 31 12:07:46 2010	(r21599)
@@ -14,7 +14,6 @@
  org.eclipse.ui.editors,
  org.eclipse.ui.workbench.texteditor,
  org.strategoxt.imp.runtime,
- org.spoofax.aterm,
  org.spoofax.jsglr,
  org.spoofax.interpreter.core,
  org.strategoxt.strj

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.pp/META-INF/MANIFEST.MF
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.pp/META-INF/MANIFEST.MF	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.pp/META-INF/MANIFEST.MF	Fri Dec 31 12:07:46 2010	(r21599)
@@ -14,7 +14,6 @@
   org.eclipse.ui.editors,
   org.eclipse.ui.workbench.texteditor,
   org.strategoxt.imp.runtime,
-  org.spoofax.aterm,
   org.spoofax.jsglr
 Bundle-RequiredExecutionEnvironment: J2SE-1.5
 Export-Package: org.strategoxt.imp.editors.pp

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.rtg/META-INF/MANIFEST.MF
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.rtg/META-INF/MANIFEST.MF	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.rtg/META-INF/MANIFEST.MF	Fri Dec 31 12:07:46 2010	(r21599)
@@ -14,7 +14,6 @@
   org.eclipse.ui.editors,
   org.eclipse.ui.workbench.texteditor,
   org.strategoxt.imp.runtime,
-  org.spoofax.aterm,
   org.spoofax.jsglr,
   org.strategoxt.strj
 Bundle-RequiredExecutionEnvironment: J2SE-1.5

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.sdf/META-INF/MANIFEST.MF
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.sdf/META-INF/MANIFEST.MF	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.sdf/META-INF/MANIFEST.MF	Fri Dec 31 12:07:46 2010	(r21599)
@@ -14,7 +14,6 @@
   org.eclipse.ui.editors,
   org.eclipse.ui.workbench.texteditor,
   org.strategoxt.imp.runtime,
-  org.spoofax.aterm,
   org.spoofax.jsglr,
   org.strategoxt.strj
 Bundle-RequiredExecutionEnvironment: J2SE-1.5

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.spoofax/META-INF/MANIFEST.MF
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.spoofax/META-INF/MANIFEST.MF	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.spoofax/META-INF/MANIFEST.MF	Fri Dec 31 12:07:46 2010	(r21599)
@@ -14,7 +14,6 @@
   org.eclipse.ui.editors,
   org.eclipse.ui.workbench.texteditor,
   org.strategoxt.imp.runtime,
-  org.spoofax.aterm,
   org.spoofax.jsglr,
   org.strategoxt.strj
 Bundle-RequiredExecutionEnvironment: J2SE-1.5

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.stratego/META-INF/MANIFEST.MF
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.stratego/META-INF/MANIFEST.MF	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.editors.stratego/META-INF/MANIFEST.MF	Fri Dec 31 12:07:46 2010	(r21599)
@@ -14,7 +14,6 @@
   org.eclipse.ui.editors,
   org.eclipse.ui.workbench.texteditor,
   org.strategoxt.imp.runtime,
-  org.spoofax.aterm,
   org.spoofax.jsglr,
   org.strategoxt.strj
 Bundle-RequiredExecutionEnvironment: J2SE-1.5

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.generator/META-INF/MANIFEST.MF
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.generator/META-INF/MANIFEST.MF	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.generator/META-INF/MANIFEST.MF	Fri Dec 31 12:07:46 2010	(r21599)
@@ -5,10 +5,8 @@
 Bundle-Version: 0.1.2.qualifier
 Bundle-ClassPath: lib/make_permissive.jar,
  lib/sdf2imp.jar
-Require-Bundle: org.spoofax.aterm,
- org.spoofax.jsglr,
+Require-Bundle: org.spoofax.jsglr,
  org.spoofax.interpreter.core,
- org.spoofax.interpreter.adapter.aterm,
  org.spoofax.interpreter.library.jsglr,
  org.eclipse.core.runtime,
  org.eclipse.core.resources,

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.generator/src/sdf2imp/project/create-manifest.str
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.generator/src/sdf2imp/project/create-manifest.str	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.generator/src/sdf2imp/project/create-manifest.str	Fri Dec 31 12:07:46 2010	(r21599)
@@ -30,7 +30,6 @@
   org.eclipse.ui.editors,
   org.eclipse.ui.workbench.texteditor,
   org.strategoxt.imp.runtime,
-  org.spoofax.aterm,
   org.spoofax.jsglr,
   org.strategoxt.strj
 Bundle-RequiredExecutionEnvironment: J2SE-1.5

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.metatooling/META-INF/MANIFEST.MF
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.metatooling/META-INF/MANIFEST.MF	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.metatooling/META-INF/MANIFEST.MF	Fri Dec 31 12:07:46 2010	(r21599)
@@ -6,10 +6,8 @@
 Require-Bundle: org.strategoxt.imp.runtime,
  org.strategoxt.imp.generator,
  org.eclipse.imp.runtime,
- org.spoofax.aterm,
  org.spoofax.jsglr,
  org.spoofax.interpreter.core,
- org.spoofax.interpreter.adapter.aterm,
  org.spoofax.interpreter.library.jsglr,
  lpg.runtime,
  org.eclipse.core.runtime,

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building/DynamicDescriptorBuilder.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building/DynamicDescriptorBuilder.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building/DynamicDescriptorBuilder.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -57,7 +57,6 @@
 		try {
 			agent = new EditorIOAgent();
 			context = new Context(Environment.getTermFactory(), agent);
-			context.getCompatManager().setATermFactory(Environment.getATermFactory());
 			context.registerClassLoader(sdf2imp.class.getClassLoader());
 			sdf2imp.init(context);
 			assert sdf2imp._consSdfMainModuleFlag_0 != null && stratego_lib._consAlert_0 != null;

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/stratego/IMPParseStrategoFileStrategy.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/stratego/IMPParseStrategoFileStrategy.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/stratego/IMPParseStrategoFileStrategy.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -11,10 +11,10 @@
 import org.eclipse.imp.language.LanguageRegistry;
 import org.spoofax.interpreter.terms.IStrategoString;
 import org.spoofax.interpreter.terms.IStrategoTerm;
-import org.spoofax.jsglr.InvalidParseTableException;
-import org.spoofax.jsglr.NoRecoveryRulesException;
-import org.spoofax.jsglr.ParseTable;
-import org.spoofax.jsglr.SGLRException;
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.NoRecoveryRulesException;
+import org.spoofax.jsglr.client.ParseTable;
+import org.spoofax.jsglr.shared.SGLRException;
 import org.strategoxt.imp.editors.stratego.StrategoSugarParseController;
 import org.strategoxt.imp.runtime.Environment;
 import org.strategoxt.imp.runtime.dynamicloading.BadDescriptorException;

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/wizards/NewEditorWizard.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/wizards/NewEditorWizard.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/wizards/NewEditorWizard.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -119,7 +119,6 @@
 		EditorIOAgent agent = new EditorIOAgent();
 		agent.setAlwaysActivateConsole(true);
 		Context context = new Context(Environment.getTermFactory(), agent);
-		context.getCompatManager().setATermFactory(Environment.getATermFactory());
 		context.registerClassLoader(make_permissive.class.getClassLoader());
 		sdf2imp.init(context);
 		monitor.worked(1);

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.nativebundle/META-INF/MANIFEST.MF
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.nativebundle/META-INF/MANIFEST.MF	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.nativebundle/META-INF/MANIFEST.MF	Fri Dec 31 12:07:46 2010	(r21599)
@@ -7,8 +7,7 @@
 Bundle-ActivationPolicy: lazy
 Bundle-RequiredExecutionEnvironment: J2SE-1.5
 Import-Package: org.osgi.framework;version="1.3.0"
-Require-Bundle: org.spoofax.aterm,
- org.strategoxt.strj,
+Require-Bundle: org.strategoxt.strj,
  org.eclipse.core.runtime,
  org.strategoxt.imp.runtime
 Export-Package: org.strategoxt.imp.nativebundle

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/META-INF/MANIFEST.MF
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/META-INF/MANIFEST.MF	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/META-INF/MANIFEST.MF	Fri Dec 31 12:07:46 2010	(r21599)
@@ -4,10 +4,8 @@
 Bundle-SymbolicName: org.strategoxt.imp.runtime;singleton:=true
 Bundle-Version: 0.1.1.qualifier
 Require-Bundle: org.eclipse.imp.runtime,
- org.spoofax.aterm,
  org.spoofax.jsglr;bundle-version="0.3.0",
  org.spoofax.interpreter.core,
- org.spoofax.interpreter.adapter.aterm,
  org.spoofax.interpreter.library.jsglr,
  lpg.runtime;bundle-version="[2.0.17,2.0.17.qualifier]",
  org.eclipse.core.runtime,

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/Environment.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/Environment.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/Environment.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -19,18 +19,15 @@
 import org.eclipse.imp.language.Language;
 import org.eclipse.jface.dialogs.ErrorDialog;
 import org.eclipse.swt.widgets.Display;
-import org.spoofax.interpreter.adapter.aterm.ATermConverter;
-import org.spoofax.interpreter.adapter.aterm.UnsharedWrappedATermFactory;
-import org.spoofax.interpreter.adapter.aterm.WrappedATermFactory;
 import org.spoofax.interpreter.core.InterpreterException;
 import org.spoofax.interpreter.core.InterpreterExit;
 import org.spoofax.interpreter.core.StackTracer;
 import org.spoofax.interpreter.library.jsglr.JSGLRLibrary;
 import org.spoofax.interpreter.terms.IStrategoTerm;
-import org.spoofax.jsglr.InvalidParseTableException;
-import org.spoofax.jsglr.ParseTable;
-import org.spoofax.jsglr.ParseTableManager;
-import org.spoofax.jsglr.SGLR;
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParseTable;
+import org.spoofax.jsglr.io.ParseTableManager;
+import org.spoofax.jsglr.io.SGLR;
 import org.strategoxt.HybridInterpreter;
 import org.strategoxt.imp.runtime.dynamicloading.BadDescriptorException;
 import org.strategoxt.imp.runtime.dynamicloading.Descriptor;
@@ -44,11 +41,8 @@
 import org.strategoxt.imp.runtime.stratego.adapter.WrappedAstNodeFactory;
 import org.strategoxt.lang.compat.sglr.SGLRCompatLibrary;
 
-import aterm.ATermFactory;
-import aterm.pure.PureFactory;
-
 /**
- * Environment class that maintains a maximally shared ATerm environment and
+ * Environment class that maintains a term factories, languages, and
  * parse tables, shared by any editors or other plugins.
  *
  * Methods in this class are either synchronized on the {@link #getSyncRoot()}
@@ -59,12 +53,6 @@
  */
 public final class Environment {
 	
-	private final static WrappedATermFactory wrappedFactory;
-		
-	private final static ATermFactory factory;
-	
-	private final static ATermConverter atermConverter;
-	
 	private final static ParseTableManager parseTableManager;
 	
 	private final static Map<String, ParseTableProvider> parseTables;
@@ -84,14 +72,11 @@
 	private static SWTSafeLock lock = new SWTSafeLock();
 	
 	static {
-		wrappedFactory = new UnsharedWrappedATermFactory();
-		factory = new PureFactory();
-		parseTableManager = new ParseTableManager(factory);
-		parseTables = Collections.synchronizedMap(new HashMap<String, ParseTableProvider>());
 		descriptors = Collections.synchronizedMap(new HashMap<String, Descriptor>());
 		unmanagedTables = Collections.synchronizedMap(new HashMap<String, ParseTableProvider>());
 		wrappedAstNodeFactory = new WrappedAstNodeFactory();
-		atermConverter = new ATermConverter(factory, wrappedAstNodeFactory, true);
+		parseTableManager = new ParseTableManager(wrappedAstNodeFactory);
+		parseTables = Collections.synchronizedMap(new HashMap<String, ParseTableProvider>());
 		checkJVMOptions();
 	}
 
@@ -159,25 +144,11 @@
 		// (no state; no assertion)
 		return wrappedAstNodeFactory;
 	}
-
-	public static WrappedATermFactory getWrappedATermFactory() {
-		// (stateful factory)
-		assertLock();
-		return wrappedFactory;
-	}
-	
-	public static ATermConverter getATermConverter() {
-		assert getStrategoLock().isHeldByCurrentThread();
-	    return atermConverter;
-	}
-	
-	public static ATermFactory getATermFactory() {
-	    return factory;
-	}
 	
+	@Deprecated
 	public static SGLR createSGLR(ParseTable parseTable) {
 		// (no state; no assertion)
-		return new SGLR(factory, parseTable);
+		return new SGLR(parseTable);
 	}
 	
 	// ENVIRONMENT ACCESS AND MANIPULATION
@@ -209,7 +180,6 @@
 				}
 			};
 		
-		result.getCompiledContext().getCompatManager().setATermFactory(getATermFactory());
 		result.getCompiledContext().getExceptionHandler().setEnabled(false);
 		result.getCompiledContext().registerComponent("stratego_lib"); // ensure op. registry available
 		result.getCompiledContext().registerComponent("stratego_sglr"); // ensure op. registry available
@@ -233,7 +203,6 @@
 				IMPJSGLRLibrary.REGISTRY_NAME, // is spoofax-specific
 				JSGLRLibrary.REGISTRY_NAME,    // connected to the library above
 				IMPLibrary.REGISTRY_NAME);     // also used
-		result.getCompiledContext().getCompatManager().setATermFactory(getATermFactory());
 		result.getCompiledContext().getExceptionHandler().setEnabled(false);
 		IMPJSGLRLibrary parseLibrary = ((IMPJSGLRLibrary) result.getContext().getOperatorRegistry(IMPJSGLRLibrary.REGISTRY_NAME));
 		parseLibrary.addOverrides(result.getCompiledContext());

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/Descriptor.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/Descriptor.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/Descriptor.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -247,7 +247,7 @@
 	
 	public boolean isATermEditor() {
 		try {
-			return "ATerm".equals(getLanguage().getName());
+			return "IStrategoTerm".equals(getLanguage().getName());
 		} catch (BadDescriptorException e) {
 			return false;
 		}

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/DescriptorFactory.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/DescriptorFactory.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/DescriptorFactory.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -12,8 +12,8 @@
 import org.eclipse.core.runtime.IPath;
 import org.eclipse.imp.language.Language;
 import org.spoofax.interpreter.terms.IStrategoAppl;
-import org.spoofax.jsglr.ParseTable;
-import org.spoofax.jsglr.SGLRException;
+import org.spoofax.jsglr.client.ParseTable;
+import org.spoofax.jsglr.shared.SGLRException;
 import org.spoofax.terms.io.baf.BAFReader;
 import org.strategoxt.imp.generator.sdf2imp;
 import org.strategoxt.imp.runtime.Debug;
@@ -112,7 +112,7 @@
 		byte[] buffer = new byte[6];
 		int bufferSize = input.read(buffer);
 		if (bufferSize != -1) input.unread(buffer, 0, bufferSize);
-		if ((bufferSize == 6 && new String(buffer).equals("Module")) || BAFReader.isBinaryATerm(input)) { 
+		if ((bufferSize == 6 && new String(buffer).equals("Module")) || BAFReader.isBinaryIStrategoTerm(input)) { 
 			return (IStrategoAppl) Environment.getTermFactory().parseFromStream(input);
 		} else {
 			return null;

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/DynamicParseTableProvider.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/DynamicParseTableProvider.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/DynamicParseTableProvider.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -8,7 +8,7 @@
 
 import org.eclipse.core.resources.IResource;
 import org.spoofax.interpreter.terms.IStrategoTerm;
-import org.spoofax.jsglr.InvalidParseTableException;
+import org.spoofax.jsglr.client.InvalidParseTableException;
 import org.strategoxt.imp.runtime.Environment;
 import org.strategoxt.imp.runtime.parser.SGLRParseController;
 import org.strategoxt.imp.runtime.services.StrategoObserver;

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/ParseControllerFactory.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/ParseControllerFactory.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/ParseControllerFactory.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -6,7 +6,7 @@
 import org.eclipse.imp.language.Language;
 import org.eclipse.imp.parser.IParseController;
 import org.eclipse.imp.services.ILanguageSyntaxProperties;
-import org.spoofax.jsglr.InvalidParseTableException;
+import org.spoofax.jsglr.client.InvalidParseTableException;
 import org.strategoxt.imp.runtime.Environment;
 import org.strategoxt.imp.runtime.parser.SGLRParseController;
 

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/ParseTableProvider.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/ParseTableProvider.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/ParseTableProvider.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -6,8 +6,8 @@
 
 import org.eclipse.core.resources.IFile;
 import org.eclipse.core.runtime.CoreException;
-import org.spoofax.jsglr.InvalidParseTableException;
-import org.spoofax.jsglr.ParseTable;
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParseTable;
 import org.strategoxt.imp.runtime.Debug;
 import org.strategoxt.imp.runtime.Environment;
 import org.strategoxt.imp.runtime.parser.SGLRParseController;

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/AbstractSGLRI.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/AbstractSGLRI.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/AbstractSGLRI.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -14,9 +14,9 @@
 import org.eclipse.core.runtime.IProgressMonitor;
 import org.eclipse.core.runtime.NullProgressMonitor;
 import org.eclipse.core.runtime.OperationCanceledException;
-import org.spoofax.jsglr.BadTokenException;
-import org.spoofax.jsglr.SGLRException;
-import org.spoofax.jsglr.TokenExpectedException;
+import org.spoofax.jsglr.shared.BadTokenException;
+import org.spoofax.jsglr.shared.SGLRException;
+import org.spoofax.jsglr.shared.TokenExpectedException;
 import org.strategoxt.imp.runtime.Debug;
 import org.strategoxt.imp.runtime.parser.ast.AmbAsfixImploder;
 import org.strategoxt.imp.runtime.parser.ast.AsfixImploder;
@@ -27,7 +27,7 @@
 import org.strategoxt.imp.runtime.parser.tokens.TokenKindManager;
 import org.strategoxt.lang.WeakValueHashMap;
 
-import aterm.ATerm;
+import org.spoofax.interpreter.terms.IStrategoTerm;
 
 /**
  * IMP IParser implementation for SGLR, imploding parse trees to AST nodes and tokens.
@@ -37,8 +37,8 @@
 public abstract class AbstractSGLRI {
 	
 	@SuppressWarnings("unused")
-	private static final Map<CachingKey, ATerm> parsedCache =
-		Collections.synchronizedMap(new WeakValueHashMap<CachingKey, ATerm>());
+	private static final Map<CachingKey, IStrategoTerm> parsedCache =
+		Collections.synchronizedMap(new WeakValueHashMap<CachingKey, IStrategoTerm>());
 	
 	private final SGLRParseController controller;
 	
@@ -116,7 +116,7 @@
 	protected RootAstNode parse(char[] inputChars, String filename, IProgressMonitor monitor)
 			throws TokenExpectedException, BadTokenException, SGLRException, IOException {
 
-		ATerm asfix = parseNoImplode(inputChars, filename);
+		IStrategoTerm asfix = parseNoImplode(inputChars, filename);
 		if (monitor.isCanceled())
 			throw new OperationCanceledException();
 		return internalImplode(asfix);
@@ -152,7 +152,7 @@
 	 * 
 	 * @note May only work with the latest parse tree produced.
 	 */
-	protected RootAstNode internalImplode(ATerm asfix) {
+	protected RootAstNode internalImplode(IStrategoTerm asfix) {
 		AstNode imploded = imploder.implode(asfix, currentTokenizer);
 		SGLRParseController controller = getController() == null ? null : getController();
 		IResource resource = controller == null ? null : controller.getResource();
@@ -163,13 +163,13 @@
 	 * Parse an input, returning the AST and initializing the parse stream.
 	 * Also initializes a new tokenizer for the given input.
 	 */ 
-	public ATerm parseNoImplode(char[] inputChars, String filename)
+	public IStrategoTerm parseNoImplode(char[] inputChars, String filename)
 			throws TokenExpectedException, BadTokenException, SGLRException, IOException {
 		
 		/* UNDONE: disabled the parse cache for now
 		 * TODO: revise parse cache?
 		CachingKey cachingKey = new CachingKey(parseTableId, startSymbol, inputChars, filename);
-		ATerm result = parsedCache.get(cachingKey);
+		IStrategoTerm result = parsedCache.get(cachingKey);
 		if (result != null) {
 			currentTokenizer = getTokenizer(result);
 			assert currentTokenizer != null;
@@ -180,7 +180,7 @@
 		Debug.startTimer();
 		try {
 			currentTokenizer = new SGLRTokenizer(inputChars, filename);
-			ATerm result = doParseNoImplode(inputChars, filename);
+			IStrategoTerm result = doParseNoImplode(inputChars, filename);
 			// parsedCache.put(cachingKey, result);
 			// putTokenizer(result, currentTokenizer);
 		
@@ -190,7 +190,7 @@
 		}
 	}
 	
-	protected abstract ATerm doParseNoImplode(char[] inputChars, String filename)
+	protected abstract IStrategoTerm doParseNoImplode(char[] inputChars, String filename)
 			throws TokenExpectedException, BadTokenException, SGLRException, IOException;
 
 	private char[] toCharArray(InputStream input) throws IOException {

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/CSGLRI.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/CSGLRI.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/CSGLRI.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -8,12 +8,12 @@
 
 import lpg.runtime.IPrsStream;
 
-import org.spoofax.jsglr.SGLRException;
+import org.spoofax.jsglr.shared.SGLRException;
 import org.strategoxt.imp.runtime.Environment;
 import org.strategoxt.imp.runtime.parser.tokens.TokenKindManager;
 import org.strategoxt.lang.compat.NativeCallHelper;
 
-import aterm.ATerm;
+import org.spoofax.interpreter.terms.IStrategoTerm;
 import aterm.ATermAppl;
 import aterm.ATermFactory;
 
@@ -66,7 +66,7 @@
 	}
 
 	@Override
-	protected ATerm doParseNoImplode(char[] inputChars, String filename) throws SGLRException, IOException {
+	protected IStrategoTerm doParseNoImplode(char[] inputChars, String filename) throws SGLRException, IOException {
 		ATermFactory factory = Environment.getATermFactory();
 		File outputFile = File.createTempFile("parserOutput", null);
 		File inputFile = filename == null || !new File(filename).exists()

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/JSGLRI.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/JSGLRI.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/JSGLRI.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -6,20 +6,18 @@
 
 import lpg.runtime.IPrsStream;
 
-import org.spoofax.jsglr.BadTokenException;
-import org.spoofax.jsglr.Disambiguator;
-import org.spoofax.jsglr.FilterException;
-import org.spoofax.jsglr.NoRecoveryRulesException;
-import org.spoofax.jsglr.ParseTable;
-import org.spoofax.jsglr.SGLR;
-import org.spoofax.jsglr.SGLRException;
-import org.spoofax.jsglr.TokenExpectedException;
+import org.spoofax.jsglr.client.Disambiguator;
+import org.spoofax.jsglr.client.FilterException;
+import org.spoofax.jsglr.client.NoRecoveryRulesException;
+import org.spoofax.jsglr.client.ParseTable;
+import org.spoofax.jsglr.io.SGLR;
+import org.spoofax.jsglr.shared.BadTokenException;
+import org.spoofax.jsglr.shared.SGLRException;
+import org.spoofax.jsglr.shared.TokenExpectedException;
 import org.strategoxt.imp.runtime.Environment;
 import org.strategoxt.imp.runtime.dynamicloading.ParseTableProvider;
 import org.strategoxt.imp.runtime.parser.tokens.TokenKindManager;
 
-import aterm.ATerm;
-
 /**
  * IMP IParser implementation using JSGLR, imploding parse trees to AST nodes and tokens.
  *
@@ -104,7 +102,7 @@
 	}
 	
 	@Override
-	protected ATerm doParseNoImplode(char[] inputChars, String filename)
+	protected IStrategoTerm doParseNoImplode(char[] inputChars, String filename)
 			throws TokenExpectedException, BadTokenException, SGLRException, IOException {
 		
 		return doParseNoImplode(toByteStream(inputChars), inputChars, filename);
@@ -125,7 +123,7 @@
 		}
 	}
 	
-	private ATerm doParseNoImplode(InputStream inputStream, char[] inputChars, String filename)
+	private IStrategoTerm doParseNoImplode(InputStream inputStream, char[] inputChars, String filename)
 			throws TokenExpectedException, BadTokenException, SGLRException, IOException {
 		
 		// Read stream using tokenizer/lexstream

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ParseErrorHandler.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ParseErrorHandler.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ParseErrorHandler.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -1,9 +1,9 @@
 package org.strategoxt.imp.runtime.parser;
 
 import static java.lang.Math.min;
-import static org.spoofax.jsglr.Term.applAt;
-import static org.spoofax.jsglr.Term.listAt;
-import static org.spoofax.jsglr.Term.termAt;
+import static org.spoofax.terms.Term.applAt;
+import static org.spoofax.terms.Term.listAt;
+import static org.spoofax.terms.Term.termAt;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -19,12 +19,12 @@
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.ITermFactory;
 import org.spoofax.interpreter.terms.TermConverter;
-import org.spoofax.jsglr.BadTokenException;
+import org.spoofax.jsglr.shared.BadTokenException;
 import org.spoofax.jsglr.MultiBadTokenException;
 import org.spoofax.jsglr.ParseTimeoutException;
 import org.spoofax.jsglr.RecoveryConnector;
 import org.spoofax.jsglr.RegionRecovery;
-import org.spoofax.jsglr.TokenExpectedException;
+import org.spoofax.jsglr.shared.TokenExpectedException;
 import org.strategoxt.imp.generator.sdf2imp;
 import org.strategoxt.imp.generator.simplify_ambiguity_report_0_0;
 import org.strategoxt.imp.runtime.Environment;
@@ -40,10 +40,10 @@
 import org.strategoxt.stratego_sglr.implode_asfix_0_0;
 import org.strategoxt.stratego_sglr.stratego_sglr;
 
-import aterm.ATerm;
+import org.spoofax.interpreter.terms.IStrategoTerm;
 import aterm.ATermAppl;
 import aterm.ATermInt;
-import aterm.ATermList;
+import org.spoofax.interpreter.terms.IStrategoList;
 
 /**
  * SGLR parse error reporting for a particular SGLR Parse controller and file. 
@@ -143,7 +143,7 @@
 	/**
 	 * Report WATER + INSERT errors from parse tree
 	 */
-	public void gatherNonFatalErrors(char[] inputChars, SGLRTokenizer tokenizer, ATerm top) {
+	public void gatherNonFatalErrors(char[] inputChars, SGLRTokenizer tokenizer, IStrategoTerm top) {
 		try {
 			errorReports.clear();
 			offset = 0;
@@ -267,7 +267,7 @@
 		
 		if ("amb".equals(term.getAFun().getName())) {
 			// Report errors in first ambiguous branch and update offset
-			ATermList ambs = termAt(term, 0);
+			IStrategoList ambs = termAt(term, 0);
 			reportRecoveredErrors(tokenizer, (ATermAppl) ambs.getFirst(), startOffset, outerStartOffset);
 			
 			reportAmbiguity(tokenizer, term, startOffset);
@@ -277,7 +277,7 @@
 		ATermAppl prod = termAt(term, 0);
 		ATermAppl rhs = termAt(prod, 1);
 		ATermAppl attrs = termAt(prod, 2);
-		ATermList contents = termAt(term, 1);
+		IStrategoList contents = termAt(term, 1);
 		boolean lexicalStart = false;
 		
 		if (!inLexicalContext && AsfixAnalyzer.isLexicalNode(rhs) || AsfixAnalyzer.isVariableNode(rhs)) {
@@ -286,8 +286,8 @@
 		
 		// Recursively visit the subtree and update the offset
 		for (int i = 0; i < contents.getLength(); i++) {
-			ATerm child = contents.elementAt(i);
-			if (child.getType() == ATerm.INT) {
+			IStrategoTerm child = contents.elementAt(i);
+			if (child.getType() == IStrategoTerm.INT) {
 				offset += 1;				
 			} else {
 				reportRecoveredErrors(tokenizer, (ATermAppl) child, startOffset, outerStartOffset);
@@ -334,7 +334,7 @@
 		if (lexicalStart) inLexicalContext = false;
 	}
 	
-	private static String toString(ATermList chars) {
+	private static String toString(IStrategoList chars) {
 		// TODO: move to SSL_implode_string.call() ?
         StringBuilder result = new StringBuilder(chars.getLength());
 
@@ -561,7 +561,7 @@
 	
 	private static String getDeprecatedProductionMessage(ATermAppl attrs) {
 		if ("attrs".equals(attrs.getName())) {
-			ATermList attrList = termAt(attrs, 0);
+			IStrategoList attrList = termAt(attrs, 0);
 			while (!attrList.isEmpty()) {
 				ATermAppl attr = (ATermAppl) attrList.getFirst();
 				attrList = attrList.getNext();

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/SGLRParseController.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/SGLRParseController.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/SGLRParseController.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -28,14 +28,14 @@
 import org.eclipse.jface.text.IDocument;
 import org.eclipse.jface.text.IRegion;
 import org.eclipse.jface.text.Region;
-import org.spoofax.jsglr.BadTokenException;
-import org.spoofax.jsglr.InvalidParseTableException;
+import org.spoofax.jsglr.shared.BadTokenException;
+import org.spoofax.jsglr.client.InvalidParseTableException;
 import org.spoofax.jsglr.NoRecoveryRulesException;
-import org.spoofax.jsglr.ParseTable;
+import org.spoofax.jsglr.client.ParseTable;
 import org.spoofax.jsglr.ParseTimeoutException;
-import org.spoofax.jsglr.SGLRException;
+import org.spoofax.jsglr.shared.SGLRException;
 import org.spoofax.jsglr.StartSymbolException;
-import org.spoofax.jsglr.TokenExpectedException;
+import org.spoofax.jsglr.shared.TokenExpectedException;
 import org.strategoxt.imp.runtime.Debug;
 import org.strategoxt.imp.runtime.EditorState;
 import org.strategoxt.imp.runtime.Environment;
@@ -55,7 +55,7 @@
 import org.strategoxt.imp.runtime.services.StrategoObserver;
 import org.strategoxt.imp.runtime.services.TokenColorer;
 
-import aterm.ATerm;
+import org.spoofax.interpreter.terms.IStrategoTerm;
 
 /**
  * IMP parse controller for an SGLR parser; instantiated for a particular source file.
@@ -283,7 +283,7 @@
 			Debug.startTimer();
 			
 			if (monitor.isCanceled()) return null;
-			ATerm asfix = parseNoImplode(inputChars, filename);
+			IStrategoTerm asfix = parseNoImplode(inputChars, filename);
 			if (monitor.isCanceled()) return null;
 			RootAstNode ast = parser.internalImplode(asfix);
 
@@ -345,7 +345,7 @@
 		}
 	}
 
-	private ATerm parseNoImplode(char[] inputChars, String filename)
+	private IStrategoTerm parseNoImplode(char[] inputChars, String filename)
 			throws TokenExpectedException, BadTokenException, SGLRException, IOException {
 		try {
 			return parser.parseNoImplode(inputChars, filename);

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/StandAloneSGLRI.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/StandAloneSGLRI.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/StandAloneSGLRI.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -4,13 +4,13 @@
 import java.io.InputStream;
 
 import org.eclipse.imp.language.Language;
-import org.spoofax.jsglr.BadTokenException;
+import org.spoofax.jsglr.shared.BadTokenException;
 import org.spoofax.jsglr.Disambiguator;
-import org.spoofax.jsglr.InvalidParseTableException;
+import org.spoofax.jsglr.client.InvalidParseTableException;
 import org.spoofax.jsglr.NoRecoveryRulesException;
-import org.spoofax.jsglr.ParseTable;
-import org.spoofax.jsglr.SGLRException;
-import org.spoofax.jsglr.TokenExpectedException;
+import org.spoofax.jsglr.client.ParseTable;
+import org.spoofax.jsglr.shared.SGLRException;
+import org.spoofax.jsglr.shared.TokenExpectedException;
 import org.strategoxt.imp.runtime.Environment;
 import org.strategoxt.imp.runtime.dynamicloading.ParseTableProvider;
 import org.strategoxt.imp.runtime.stratego.adapter.IStrategoAstNode;

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AmbAsfixImploder.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AmbAsfixImploder.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AmbAsfixImploder.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -1,16 +1,13 @@
 package org.strategoxt.imp.runtime.parser.ast;
 
-import static org.spoofax.jsglr.Term.asAppl;
-import static org.spoofax.jsglr.Term.isAppl;
-import static org.spoofax.jsglr.Term.termAt;
+import static org.spoofax.terms.Term.termAt;
 import static org.strategoxt.imp.runtime.parser.ast.AsfixAnalyzer.AMB_FUN;
 
+import org.spoofax.interpreter.terms.IStrategoList;
+import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.strategoxt.imp.runtime.parser.tokens.TokenKindManager;
 
-import aterm.ATerm;
 import aterm.ATermAppl;
-import aterm.ATermList;
-import aterm.pure.ATermListImpl;
 
 /**
  * An asfix imploder class that can also produce ambiguous nodes.
@@ -26,15 +23,15 @@
 	/**
 	 * Resolve or ambiguities with avoid/prefer annotations.
 	 * 
-	 * @see org.strategoxt.imp.runtime.parser.ast.AsfixImploder#resolveAmbiguities(aterm.ATerm)
+	 * @see org.strategoxt.imp.runtime.parser.ast.AsfixImploder#resolveAmbiguities(org.spoofax.interpreter.terms.IStrategoTerm)
 	 */
 	@Override
-	protected ATermAppl resolveAmbiguities(ATerm node) {
+	protected ATermAppl resolveAmbiguities(IStrategoTerm node) {
 		// TODO: disable when prefer/avoid disambiguation works in Disambiguator
 		if (AMB_FUN != ((ATermAppl) node).getAFun())
 			return (ATermAppl) node;
 		
-		final ATermListImpl ambs = termAt(node, 0);
+		final IStrategoList ambs = termAt(node, 0);
 		
 	alts:
 		for (int i = 0; i < ambs.getLength(); i++) {
@@ -46,10 +43,10 @@
 	            ATermAppl attrs = termAt(appl, PROD_ATTRS);
 	            
 	            if ("attrs".equals(attrs.getName())) {
-	                ATermList attrList = termAt(attrs, 0);
+	                IStrategoList attrList = termAt(attrs, 0);
 	                
 	                for (int j = 0; j < attrList.getLength(); j++) {
-	                    ATerm attr = termAt(attrList, j);
+	                    IStrategoTerm attr = termAt(attrList, j);
 	                    if (isAppl(attr) && "prefer".equals(asAppl(attr).getName())) {
 	                        return resolveAmbiguities(amb);
 	                    } else if (isAppl(attr) && "avoid".equals(asAppl(attr).getName())) {

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AsfixAnalyzer.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AsfixAnalyzer.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AsfixAnalyzer.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -1,13 +1,13 @@
 package org.strategoxt.imp.runtime.parser.ast;
 
-import static org.spoofax.jsglr.Term.applAt;
-import static org.spoofax.jsglr.Term.asAppl;
-import static org.spoofax.jsglr.Term.isAppl;
-import static org.spoofax.jsglr.Term.termAt;
+import static org.spoofax.terms.Term.applAt;
+import static org.spoofax.terms.Term.asAppl;
+import static org.spoofax.terms.Term.isAppl;
+import static org.spoofax.terms.Term.termAt;
 import static org.strategoxt.imp.runtime.Environment.getATermFactory;
 import jjtraveler.Visitable;
 import aterm.AFun;
-import aterm.ATerm;
+import org.spoofax.interpreter.terms.IStrategoTerm;
 import aterm.ATermAppl;
 
 public class AsfixAnalyzer {
@@ -43,7 +43,7 @@
 	private static final AFun ITER_PLUS_SEP_FUN = getATermFactory().makeAFun("iter-plus-sep", 2, false);
 
 	public static boolean isLayout(ATermAppl sort) {
-		ATerm details = termAt(sort, 0);
+		IStrategoTerm details = termAt(sort, 0);
 		if (!isAppl(details))
 			return false;
 		

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AsfixImploder.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AsfixImploder.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AsfixImploder.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -1,12 +1,12 @@
 package org.strategoxt.imp.runtime.parser.ast;
 
 import static java.lang.Math.max;
-import static org.spoofax.jsglr.Term.applAt;
-import static org.spoofax.jsglr.Term.asAppl;
-import static org.spoofax.jsglr.Term.intAt;
-import static org.spoofax.jsglr.Term.isAppl;
-import static org.spoofax.jsglr.Term.isInt;
-import static org.spoofax.jsglr.Term.termAt;
+import static org.spoofax.terms.Term.applAt;
+import static org.spoofax.terms.Term.asAppl;
+import static org.spoofax.terms.Term.intAt;
+import static org.spoofax.terms.Term.isAppl;
+import static org.spoofax.terms.Term.isInt;
+import static org.spoofax.terms.Term.termAt;
 import static org.strategoxt.imp.runtime.parser.ast.AsfixAnalyzer.*;
 import static org.strategoxt.imp.runtime.parser.ast.ProductionAttributeReader.*;
 import static org.strategoxt.imp.runtime.parser.tokens.TokenKind.TK_ERROR;
@@ -28,11 +28,11 @@
 import org.strategoxt.imp.runtime.parser.tokens.SGLRTokenizer;
 import org.strategoxt.imp.runtime.parser.tokens.TokenKindManager;
 
-import aterm.ATerm;
+import org.spoofax.interpreter.terms.IStrategoTerm;
 import aterm.ATermAppl;
 import aterm.ATermInt;
-import aterm.ATermList;
-import aterm.pure.ATermListImpl;
+import org.spoofax.interpreter.terms.IStrategoList;
+import aterm.pure.IStrategoList;
 
 /**
  * Implodes an Asfix tree to AstNode nodes and IToken tokens.
@@ -78,12 +78,12 @@
 		this.tokenManager = tokenManager;
 	}
 	
-	public AstNode implode(ATerm asfix, SGLRTokenizer tokenizer) {
+	public AstNode implode(IStrategoTerm asfix, SGLRTokenizer tokenizer) {
 		this.tokenizer = tokenizer;
 		
 		// FIXME: static fields are used in helper classes that refer to Environment.getATermFactory()
 		if (asfix.getFactory() != Environment.getATermFactory())
-			throw new IllegalArgumentException("Argument ATerm does not use the Environment.getATermFactory() factory");
+			throw new IllegalArgumentException("Argument IStrategoTerm does not use the Environment.getATermFactory() factory");
 		
 		// TODO: Return null if imploded tree has null constructor??
 		
@@ -98,7 +98,7 @@
 		if (offset != 0 || tokenizer.getStartOffset() != 0)
 			throw new IllegalStateException("Race condition in AsfixImploder (" + tokenizer.getLexStream().getFileName() + "; might be caused by stack overflow)");
 		
-		ATerm top = (ATerm) asfix.getChildAt(PARSE_TREE);
+		IStrategoTerm top = (IStrategoTerm) asfix.getChildAt(PARSE_TREE);
 		AstNode result;
 		offset = 0;
 		inLexicalContext = false;
@@ -124,7 +124,7 @@
 	/**
 	 * Implode any appl(_, _).
 	 */
-	protected AstNode implodeAppl(ATerm term) {
+	protected AstNode implodeAppl(IStrategoTerm term) {
 		// Note that this method significantly impacts our stack usage;
 		// method extraction should be carefully considered...
 		
@@ -133,10 +133,10 @@
 			return implodeAmbAppl(appl);
 		
 		ATermAppl prod = termAt(appl, APPL_PROD);
-		ATermList lhs = termAt(prod, PROD_LHS);
+		IStrategoList lhs = termAt(prod, PROD_LHS);
 		ATermAppl rhs = termAt(prod, PROD_RHS);
 		ATermAppl attrs = termAt(prod, PROD_ATTRS);
-		ATermList contents = termAt(appl, APPL_CONTENTS);
+		IStrategoList contents = termAt(appl, APPL_CONTENTS);
 		IToken prevToken = tokenizer.currentToken();
 		int lastOffset = offset;
 		
@@ -147,7 +147,7 @@
 		
 		if (!inLexicalContext
 				&& (SORT_FUN == rhs.getAFun() || PARAMETERIZED_SORT_FUN == rhs.getAFun())
-				&& lhs.getLength() == 1 && termAt(contents, 0).getType() == ATerm.INT) {
+				&& lhs.getLength() == 1 && termAt(contents, 0).getType() == IStrategoTerm.INT) {
 			return setAnnos(createIntTerminal(contents, rhs), appl.getAnnotations());
 		}
 		
@@ -162,7 +162,7 @@
 
 		// Recurse
 		for (int i = 0; i < contents.getLength(); i++) {
-			ATerm child = contents.elementAt(i);
+			IStrategoTerm child = contents.elementAt(i);
 			if (isInt(child)) {
 				consumeLexicalChar((ATermInt) child);
 			} else {
@@ -182,14 +182,14 @@
 	}
 	
 	protected AmbAstNode implodeAmbAppl(ATermAppl node) { 
-		final ATermListImpl ambs = termAt(node, 0);
+		final IStrategoList ambs = termAt(node, 0);
 		final ArrayList<AstNode> results = new ArrayList<AstNode>();
 		
 		final int oldOffset = offset;
 		final int oldBeginOffset = tokenizer.getStartOffset();
 		final boolean oldLexicalContext = inLexicalContext;
 		
-		for (ATerm amb : ambs) {
+		for (IStrategoTerm amb : ambs) {
 			// Restore lexical state for each branch
 			offset = oldOffset;
 			tokenizer.setStartOffset(oldBeginOffset);
@@ -204,7 +204,7 @@
 		return new AmbAstNode(results);
 	}
 	
-	private AstNode setAnnos(AstNode node, ATermList annos) {
+	private AstNode setAnnos(AstNode node, IStrategoList annos) {
 		if (node != null && annos != null && !annos.isEmpty()) {
 			IStrategoTerm termAnnos = Environment.getATermConverter().convert(annos);
 			node.setAnnotations((IStrategoList) termAnnos);
@@ -212,7 +212,7 @@
 		return node;
 	}
 
-	private AstNode createStringTerminal(ATermList lhs, ATermAppl rhs, ATermAppl attrs) {
+	private AstNode createStringTerminal(IStrategoList lhs, ATermAppl rhs, ATermAppl attrs) {
 		inLexicalContext = false;
 		String sort = reader.getSort(rhs);
 		IToken token = tokenizer.makeToken(offset, tokenManager.getTokenKind(lhs, rhs), sort != null);
@@ -231,14 +231,14 @@
 		return result;
 	}
 	
-	private IntAstNode createIntTerminal(ATermList contents, ATermAppl rhs) {
+	private IntAstNode createIntTerminal(IStrategoList contents, ATermAppl rhs) {
 		IToken token = tokenizer.makeToken(offset, tokenManager.getTokenKind(contents, rhs), true);
 		String sort = reader.getSort(rhs);
 		int value = intAt(contents, 0);
 		return factory.createIntTerminal(sort, token, value);
 	}
 
-	private AstNode createNodeOrInjection(ATermList lhs, ATermAppl rhs, ATermAppl attrs,
+	private AstNode createNodeOrInjection(IStrategoList lhs, ATermAppl rhs, ATermAppl attrs,
 			IToken prevToken, ArrayList<AstNode> children, boolean isList) {
 		
 		String constructor = reader.getConsAttribute(attrs);
@@ -249,7 +249,7 @@
 				return createNode(attrs, sort, null, prevToken, children, true, false);
 			}
 			
-			ATerm ast = reader.getAstAttribute(attrs);
+			IStrategoTerm ast = reader.getAstAttribute(attrs);
 			if (ast != null) {
 				return createAstNonTerminal(rhs, prevToken, children, ast);
 			} else if (OPT_FUN == applAt(rhs, 0).getAFun()) {
@@ -330,7 +330,7 @@
 	}
 
 	/** Implode a context-free node with an {ast} annotation. */
-	private AstNode createAstNonTerminal(ATermAppl rhs, IToken prevToken, ArrayList<AstNode> children, ATerm ast) {
+	private AstNode createAstNonTerminal(ATermAppl rhs, IToken prevToken, ArrayList<AstNode> children, IStrategoTerm ast) {
 		IToken left = getStartToken(prevToken);
 		IToken right = getEndToken(left, tokenizer.currentToken());
 		AstAnnoImploder imploder = new AstAnnoImploder(factory, children, left, right);
@@ -340,11 +340,11 @@
 	/**
 	 * Resolve or ignore any ambiguities in the parse tree.
 	 */
-	protected ATermAppl resolveAmbiguities(final ATerm node) {
+	protected ATermAppl resolveAmbiguities(final IStrategoTerm node) {
 		if (AMB_FUN != ((ATermAppl) node).getAFun())
 			return (ATermAppl) node;
 		
-		final ATermListImpl ambs = termAt(node, 0);
+		final IStrategoList ambs = termAt(node, 0);
 		
 		ATermAppl lastNonAvoid = null;
 		ATermAppl firstOption = null;
@@ -358,10 +358,10 @@
 			ATermAppl attrs = termAt(appl, PROD_ATTRS);
 			
 			if (ATTRS_FUN == attrs.getAFun()) {
-				ATermList attrList = termAt(attrs, 0);
+				IStrategoList attrList = termAt(attrs, 0);
 				
 				for (int j = 0; j < attrList.getLength(); j++) {
-					ATerm attr = termAt(attrList, j);
+					IStrategoTerm attr = termAt(attrList, j);
 					if (isAppl(attr) && PREFER_FUN == asAppl(attr).getAFun()) {
 						return prod;
 					} else if (isAppl(attr) && AVOID_FUN == asAppl(attr).getAFun()) {
@@ -385,10 +385,10 @@
 		}
 	}
 	
-	private static void reportUnresolvedAmb(ATermList ambs) {
+	private static void reportUnresolvedAmb(IStrategoList ambs) {
 		Debug.log("Ambiguity found during implosion: ");
 		
-		for (ATerm amb : ambs) {
+		for (IStrategoTerm amb : ambs) {
 			String ambString = amb.toString();
 			if (ambString.length() > 1000) ambString = ambString.substring(0, 1000) + "...";
 			Debug.log("  amb: ", ambString);

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AstAnnoImploder.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AstAnnoImploder.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AstAnnoImploder.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -1,7 +1,7 @@
 package org.strategoxt.imp.runtime.parser.ast;
 
-import static org.spoofax.jsglr.Term.termAt;
-import static org.spoofax.jsglr.Term.toInt;
+import static org.spoofax.terms.Term.termAt;
+import static org.spoofax.terms.Term.toInt;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -11,10 +11,10 @@
 import org.spoofax.NotImplementedException;
 import org.strategoxt.imp.runtime.Environment;
 
-import aterm.ATerm;
+import org.spoofax.interpreter.terms.IStrategoTerm;
 import aterm.ATermAppl;
 import aterm.ATermInt;
-import aterm.ATermList;
+import org.spoofax.interpreter.terms.IStrategoList;
 import aterm.ATermPlaceholder;
 
 
@@ -41,7 +41,7 @@
 		this.rightToken = rightToken;
 	}
 	
-	public AstNode implode(ATerm ast, String sort) {
+	public AstNode implode(IStrategoTerm ast, String sort) {
 		// Placeholder terms are represented as strings; must parse them and fill in their arguments
 		String astString = ast.toString();
 		if (astString.startsWith("\"") && astString.endsWith("\"")) {
@@ -53,22 +53,22 @@
 		return toAstNode(ast, sort);
 	}
 	
-	private AstNode toAstNode(ATerm term, String sort) {
+	private AstNode toAstNode(IStrategoTerm term, String sort) {
 		switch (term.getType()) {
-			case ATerm.PLACEHOLDER:
+			case IStrategoTerm.PLACEHOLDER:
 				return placeholderToAstNode(term, sort);
 				
-			case ATerm.APPL:
+			case IStrategoTerm.APPL:
 				return applToAstNode(term, sort);
 				
-			case ATerm.LIST:
+			case IStrategoTerm.LIST:
 				return listToAstNode(term, sort);
 				
-			case ATerm.INT:
+			case IStrategoTerm.INT:
 				ATermInt i = (ATermInt) term;
 				return factory.createIntTerminal(sort, leftToken, i.getInt());
 				
-			case ATerm.REAL:
+			case IStrategoTerm.REAL:
 				throw new NotImplementedException("reals in {ast} attribute");
 				
 			default:
@@ -76,14 +76,14 @@
 		}
 	}
 	
-	private AstNode placeholderToAstNode(ATerm placeholder, String sort) {
-		ATerm term = ((ATermPlaceholder) placeholder).getPlaceholder();
-		if (term.getType() == ATerm.INT) {
+	private AstNode placeholderToAstNode(IStrategoTerm placeholder, String sort) {
+		IStrategoTerm term = ((ATermPlaceholder) placeholder).getPlaceholder();
+		if (term.getType() == IStrategoTerm.INT) {
 			int id = toInt(term);
 			if (1 <= id && id <= placeholderValues.size()) {
 				return placeholderValues.get(id - 1);
 			}
-		} else if (term.getType() == ATerm.APPL) {
+		} else if (term.getType() == IStrategoTerm.APPL) {
 			String type = ((ATermAppl) term).getName();
 			if ("conc".equals(type) && term.getChildCount() == 2) {
 				AstNode left = toAstNode(termAt(term, 0), null);
@@ -101,7 +101,7 @@
 		throw new IllegalStateException("Error in syntax definition: illegal placeholder in {ast} attribute: " + placeholder);
 	}
 	
-	private AstNode applToAstNode(ATerm term, String sort) {
+	private AstNode applToAstNode(IStrategoTerm term, String sort) {
 		ATermAppl appl = (ATermAppl) term;
 		ArrayList<AstNode> children = new ArrayList<AstNode>(appl.getChildCount());
 		for (int i = 0; i < appl.getChildCount(); i++) {
@@ -114,9 +114,9 @@
 		}
 	}
 	
-	private AstNode listToAstNode(ATerm term, String sort) {
+	private AstNode listToAstNode(IStrategoTerm term, String sort) {
 		// TODO: Fishy (Spoofax/49)
-		ATermList list = (ATermList) term;
+		IStrategoList list = (IStrategoList) term;
 		ArrayList<AstNode> children = new ArrayList<AstNode>(list.getChildCount());
 		for (int i = 0; i < term.getChildCount(); i++) {
 			children.add(toAstNode(termAt(term, i), null));

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/ProductionAttributeReader.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/ProductionAttributeReader.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/ProductionAttributeReader.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -1,15 +1,15 @@
 package org.strategoxt.imp.runtime.parser.ast;
 
 import static org.strategoxt.imp.runtime.Environment.getATermFactory;
-import static org.spoofax.jsglr.Term.*;
+import static org.spoofax.terms.Term.*;
 
 import java.util.HashMap;
 import java.util.Map;
 
 import aterm.AFun;
-import aterm.ATerm;
+import org.spoofax.interpreter.terms.IStrategoTerm;
 import aterm.ATermAppl;
-import aterm.ATermList;
+import org.spoofax.interpreter.terms.IStrategoList;
 
 /**
  * Extracts attributes from parse table productions.
@@ -48,7 +48,7 @@
 	private final Map<ATermAppl, String> sortCache = new HashMap<ATermAppl, String>();
 
 	public String getConsAttribute(ATermAppl attrs) {
-		ATerm consAttr = getAttribute(attrs, "cons");
+		IStrategoTerm consAttr = getAttribute(attrs, "cons");
 		return consAttr == null ? null : ((ATermAppl) consAttr).getName();
 	}
 	
@@ -62,7 +62,7 @@
 		return null;
 	}
 	
-	public ATerm getAstAttribute(ATermAppl attrs) {
+	public IStrategoTerm getAstAttribute(ATermAppl attrs) {
 		return getAttribute(attrs, "ast");
 	}
 	
@@ -71,14 +71,14 @@
 	}
 
 	/** Return the contents of a term attribute (e.g., "cons"), or null if not found. */
-	public ATerm getAttribute(ATermAppl attrs, String attrName) {
+	public IStrategoTerm getAttribute(ATermAppl attrs, String attrName) {
 		if (attrs.getAFun() == NO_ATTRS_FUN)
 			return null;
 		
-		ATermList list = termAt(attrs, 0);
+		IStrategoList list = termAt(attrs, 0);
 		
 		for (int i = 0; i < list.getLength(); i++) {
-			ATerm attr = list.elementAt(i);
+			IStrategoTerm attr = list.elementAt(i);
 			
 			if (attr instanceof ATermAppl) {
 				ATermAppl namedAttr = (ATermAppl) attr;
@@ -108,7 +108,7 @@
     }
     
     private String getSortUncached(ATermAppl node) {
-    	for (ATerm current = node; current.getChildCount() > 0 && isAppl(current); current = termAt(current, 0)) {
+    	for (IStrategoTerm current = node; current.getChildCount() > 0 && isAppl(current); current = termAt(current, 0)) {
     		AFun cons = asAppl(current).getAFun();
 			if (cons == SORT_FUN)
     			return applAt(current, 0).getName();
@@ -123,13 +123,13 @@
     	return null;
     }
     
-    private static String getParameterizedSortName(ATerm node) {
+    private static String getParameterizedSortName(IStrategoTerm node) {
     	StringBuilder result = new StringBuilder();
     	
     	result.append(applAt(node, PARAMETRIZED_SORT_NAME).getName());
     	result.append('_');
     	
-		ATermList args = termAt(node, PARAMETRIZED_SORT_ARGS);
+		IStrategoList args = termAt(node, PARAMETRIZED_SORT_ARGS);
 		
         for (ATermAppl arg = (ATermAppl) args.getFirst(); !args.getNext().isEmpty(); args = args.getNext()) {
 			result.append(arg.getName());
@@ -138,7 +138,7 @@
 		return result.toString();
     }
     
-    private String getAltSortName(ATerm node) {
+    private String getAltSortName(IStrategoTerm node) {
 		String left = getSort(applAt(node, ALT_SORT_LEFT));
 		String right = getSort(applAt(node, ALT_SORT_RIGHT));
 		

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/tokens/KeywordRecognizer.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/tokens/KeywordRecognizer.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/tokens/KeywordRecognizer.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -1,7 +1,7 @@
 package org.strategoxt.imp.runtime.parser.tokens;
 
 import static java.util.Collections.synchronizedMap;
-import static org.spoofax.jsglr.Term.termAt;
+import static org.spoofax.terms.Term.termAt;
 
 import java.util.HashSet;
 import java.util.Map;
@@ -9,13 +9,13 @@
 import java.util.WeakHashMap;
 
 import org.spoofax.jsglr.Label;
-import org.spoofax.jsglr.ParseTable;
+import org.spoofax.jsglr.client.ParseTable;
 import org.strategoxt.imp.runtime.Debug;
 import org.strategoxt.imp.runtime.Environment;
 import org.strategoxt.imp.runtime.dynamicloading.Descriptor;
 
 import aterm.AFun;
-import aterm.ATerm;
+import org.spoofax.interpreter.terms.IStrategoTerm;
 import aterm.ATermAppl;
 
 /**
@@ -36,7 +36,7 @@
 		if (table != null) {
 			for (Label l : table.getLabels()) {
 				if (l != null) {
-					ATerm rhs = termAt(l.getProduction(), 1);
+					IStrategoTerm rhs = termAt(l.getProduction(), 1);
 					if (rhs instanceof ATermAppl && ((ATermAppl) rhs).getAFun() == litFun) {
 						ATermAppl lit = termAt(rhs, 0);
 						String litString = lit.getName();

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/tokens/TokenKindManager.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/tokens/TokenKindManager.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/tokens/TokenKindManager.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -1,12 +1,12 @@
 package org.strategoxt.imp.runtime.parser.tokens;
 
-import static org.spoofax.jsglr.Term.*;
+import static org.spoofax.terms.Term.*;
 
 import org.strategoxt.imp.runtime.parser.ast.AsfixAnalyzer;
 
-import aterm.ATerm;
+import org.spoofax.interpreter.terms.IStrategoTerm;
 import aterm.ATermAppl;
-import aterm.ATermList;
+import org.spoofax.interpreter.terms.IStrategoList;
 
 import static org.strategoxt.imp.runtime.parser.tokens.TokenKind.*;
 
@@ -29,7 +29,7 @@
 	/**
 	 * Get the token kind for a given sort.
 	 */
-	public TokenKind getTokenKind(ATermList pattern, ATermAppl sort) {
+	public TokenKind getTokenKind(IStrategoList pattern, ATermAppl sort) {
 		// TODO2: Optimization - cache default token kinds?
 		
 		if (AsfixAnalyzer.isLayout(sort)) {
@@ -86,14 +86,14 @@
 		return Character.isLetterOrDigit(c) || c == '_';
 	}
 	
-	protected static boolean isStringLiteral(ATermList pattern) {
+	protected static boolean isStringLiteral(IStrategoList pattern) {
 		return topdownHasSpaces(pattern);
 	}
 	
-	private static boolean topdownHasSpaces(ATerm term) {
+	private static boolean topdownHasSpaces(IStrategoTerm term) {
 		// Return true if any character range of this contains spaces
 		for (int i = 0; i < term.getChildCount(); i++) {
-			ATerm child = termAt(term, i);
+			IStrategoTerm child = termAt(term, i);
 			if (isAppl(child) && asAppl(child).getName().equals("range")) {
 				int start = intAt(child, RANGE_START);
 				int end = intAt(child, RANGE_END);
@@ -106,16 +106,16 @@
 		return false;
 	}
 	
-	protected static boolean isNumberLiteral(ATermList pattern) {
-		ATerm range = getFirstRange(pattern);
+	protected static boolean isNumberLiteral(IStrategoList pattern) {
+		IStrategoTerm range = getFirstRange(pattern);
 		
 		return range != null && intAt(range, RANGE_START) == '0' && intAt(range, RANGE_END) == '9';
 	}
 	
-	private static ATerm getFirstRange(ATerm term) {
+	private static IStrategoTerm getFirstRange(IStrategoTerm term) {
 		// Get very first character range in this term
 		for (int i = 0; i < term.getChildCount(); i++) {
-			ATerm child = termAt(term, i);
+			IStrategoTerm child = termAt(term, i);
 			if (isAppl(child) && asAppl(child).getName().equals("range")) {
 				return child;
 			} else {

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/ContentProposer.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/ContentProposer.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/ContentProposer.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -28,7 +28,7 @@
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoString;
 import org.spoofax.interpreter.terms.IStrategoTerm;
-import org.spoofax.jsglr.SGLRException;
+import org.spoofax.jsglr.shared.SGLRException;
 import org.spoofax.terms.TermFactory;
 import org.strategoxt.imp.runtime.Debug;
 import org.strategoxt.imp.runtime.Environment;

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/CustomStrategyBuilder.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/CustomStrategyBuilder.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/CustomStrategyBuilder.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -98,7 +98,7 @@
 		// Try invoke using (term)
 		IStrategoTerm input = getDerivedFromEditor() == null
 				? node.getTerm()
-				: getObserver().implodeATerm(getObserver().getImplodableNode(node).getTerm());
+				: getObserver().implodeIStrategoTerm(getObserver().getImplodableNode(node).getTerm());
 		IStrategoTerm result = getObserver().invoke(getBuilderRule(), input, node.getResource());
 		if (result != null) return addFileName(result, node.getResource());
 		String[] trace1 = getObserver().getRuntime().getCompiledContext().getTrace();

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoBuilder.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoBuilder.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoBuilder.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -82,7 +82,7 @@
 	/**
 	 * Creates a new Stratego builder.
 	 * 
-	 * @param derivedFromEditor  The editor the present editor is derived from, if the present editor is an ATerm editor.
+	 * @param derivedFromEditor  The editor the present editor is derived from, if the present editor is an IStrategoTerm editor.
 	 */
 	public StrategoBuilder(StrategoObserver observer, String caption, String builderRule,
 			boolean openEditor, boolean realTime, boolean cursor, boolean source, boolean persistent,
@@ -253,7 +253,7 @@
 			// ByteArrayOutputStream trace = new ByteArrayOutputStream();
 			// observer.getRuntime().getCompiledContext().printStackTrace(new PrintStream(trace), false);
 			String errorReport = e.getMessage();
-			if (e.getTerm() != null) errorReport += "\n\t" + toEscapedString(ppATerm(e.getTerm()));
+			if (e.getTerm() != null) errorReport += "\n\t" + toEscapedString(ppIStrategoTerm(e.getTerm()));
 			return errorReport;
 		}
 	}
@@ -268,7 +268,7 @@
 	private String getResultString(IStrategoTerm resultTerm) {
 		resultTerm = termAt(resultTerm, 1);
 		
-		return isTermString(resultTerm) ? asJavaString(resultTerm) : ppATerm(resultTerm).stringValue();
+		return isTermString(resultTerm) ? asJavaString(resultTerm) : ppIStrategoTerm(resultTerm).stringValue();
 	}
 
 	private void scheduleOpenEditorAndListener(final EditorState editor, final IStrategoAstNode node, final IFile file)
@@ -311,7 +311,7 @@
 		return result;
 	}
 
-	private IStrategoString ppATerm(IStrategoTerm term) {
+	private IStrategoString ppIStrategoTerm(IStrategoTerm term) {
 		Context context = observer.getRuntime().getCompiledContext();
 		term = aterm_escape_strings_0_0.instance.invoke(context, term);
 		term = pp_aterm_box_0_0.instance.invoke(context, term);

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoObserver.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoObserver.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoObserver.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -507,7 +507,7 @@
 
 	/**
 	 * Create an input term for a control rule,
-	 * based on the ATerm syntax of the AST of the source file.
+	 * based on the IStrategoTerm syntax of the AST of the source file.
 	 */
 	public IStrategoTuple makeATermInputTerm(IStrategoAstNode node, boolean includeSubNode, IResource resource) {
 		assert getLock().isHeldByCurrentThread();
@@ -520,9 +520,9 @@
 		if (includeSubNode) {
 			node = getImplodableNode(node);
 			IStrategoTerm[] inputParts = {
-					implodeATerm(node.getTerm()),
-					StrategoTermPath.createPathFromParsedATerm(node, runtime.getCompiledContext()),
-					implodeATerm(getRoot(node).getTerm()),
+					implodeIStrategoTerm(node.getTerm()),
+					StrategoTermPath.createPathFromParsedIStrategoTerm(node, runtime.getCompiledContext()),
+					implodeIStrategoTerm(getRoot(node).getTerm()),
 					factory.makeString(path),
 					factory.makeString(absolutePath)
 				};
@@ -532,7 +532,7 @@
 		}
 	}
 
-	protected IStrategoTerm implodeATerm(IStrategoTerm term) {
+	protected IStrategoTerm implodeIStrategoTerm(IStrategoTerm term) {
 		return implode_aterm_0_0.instance.invoke(runtime.getCompiledContext(), term);
 	}
 
@@ -540,10 +540,10 @@
 		if (node.isList() && node.getChildren().size() == 1)
 			node = (IStrategoAstNode) node.getChildren().get(0);
 		for (; node != null; node = node.getParent()) {
-			if (implodeATerm(node.getTerm()) != null)
+			if (implodeIStrategoTerm(node.getTerm()) != null)
 				return node;
 		}
-		throw new IllegalStateException("Could not identify selected AST node from ATerm editor");
+		throw new IllegalStateException("Could not identify selected AST node from IStrategoTerm editor");
 	}
 	
 	/**

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/IMPAnnoLocationPrimitive.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/IMPAnnoLocationPrimitive.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/IMPAnnoLocationPrimitive.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -13,7 +13,7 @@
 import org.strategoxt.imp.runtime.stratego.SourceMappings.MappableTerm;
 import org.strategoxt.lang.compat.sglr.STRSGLR_anno_location;
 
-import aterm.ATerm;
+import org.spoofax.interpreter.terms.IStrategoTerm;
 
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
@@ -43,7 +43,7 @@
 		if (oldChars == null)
 			return true;
 
-		ATerm newAsfixTerm = Environment.getATermConverter().convert(newAsfix);
+		IStrategoTerm newAsfixTerm = Environment.getATermConverter().convert(newAsfix);
 		File inputFile = oldAsfix instanceof IStrategoAppl
 			? mappings.getInputFile((IStrategoAppl) oldAsfix)
 			: null;

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/IMPImplodeAsfixStrategy.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/IMPImplodeAsfixStrategy.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/IMPImplodeAsfixStrategy.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -17,7 +17,7 @@
 import org.strategoxt.lang.Strategy;
 import org.strategoxt.stratego_sglr.implode_asfix_1_0;
 
-import aterm.ATerm;
+import org.spoofax.interpreter.terms.IStrategoTerm;
 
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
@@ -41,7 +41,7 @@
 		
 		SourceMappings mappings = ((IMPJSGLRLibrary) library).getMappings();
 		char[] inputChars = mappings.getInputChars(asfix);
-		ATerm asfixATerm = mappings.getInputTerm(asfix);
+		IStrategoTerm asfixIStrategoTerm = mappings.getInputTerm(asfix);
 		File inputFile = mappings.getInputFile((IStrategoAppl) asfix);
 		SGLRTokenizer tokenizer = mappings.getTokenizer(asfix);
 		
@@ -50,7 +50,7 @@
 			return outer.invoke(context, asfix, implodeConcreteSyntax);
 		}
 		
-		AstNode result = imploder.implode(asfixATerm, tokenizer);
+		AstNode result = imploder.implode(asfixIStrategoTerm, tokenizer);
 		IResource resource;
 		try {
 			resource = EditorIOAgent.getResource(inputFile);

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/IMPParseStringPTPrimitive.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/IMPParseStringPTPrimitive.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/IMPParseStringPTPrimitive.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -11,19 +11,19 @@
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.jsglr.Disambiguator;
 import org.spoofax.jsglr.NoRecoveryRulesException;
-import org.spoofax.jsglr.ParseTable;
-import org.spoofax.jsglr.SGLRException;
+import org.spoofax.jsglr.client.ParseTable;
+import org.spoofax.jsglr.shared.SGLRException;
 import org.spoofax.terms.LazyTerm;
 import org.strategoxt.imp.runtime.Environment;
 import org.strategoxt.imp.runtime.parser.JSGLRI;
 import org.strategoxt.imp.runtime.stratego.SourceMappings.MappableTerm;
 import org.strategoxt.lang.compat.sglr.JSGLR_parse_string_pt_compat;
 
-import aterm.ATerm;
+import org.spoofax.interpreter.terms.IStrategoTerm;
 import aterm.ATermFactory;
 
 /**
- * Parses strings to asfix trees, caching the internal ATerm
+ * Parses strings to asfix trees, caching the internal IStrategoTerm
  * for implosion with {@link IMPImplodeAsfixStrategy}. 
  * 
  * @author Lennart Kats <lennart add lclnet.nl>
@@ -64,7 +64,7 @@
 		}
 		char[] inputChars = input.toCharArray();
 		
-		final ATerm asfix = parser.parseNoImplode(inputChars, path);
+		final IStrategoTerm asfix = parser.parseNoImplode(inputChars, path);
 		MappableTerm result = new MappableTerm(new LazyTerm() {
 			@Override
 			protected IStrategoTerm init() {

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/SourceMappings.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/SourceMappings.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/SourceMappings.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -13,7 +13,7 @@
 import org.spoofax.terms.LazyTerm;
 import org.strategoxt.imp.runtime.parser.tokens.SGLRTokenizer;
 
-import aterm.ATerm;
+import org.spoofax.interpreter.terms.IStrategoTerm;
 
 /**
  * Maintains mappings between input streams, parse trees, etc. and their origins.
@@ -30,7 +30,7 @@
 	
 	private final Map<MappableKey, char[]> inputCharMap = new WeakHashMap<MappableKey, char[]>();
 
-	private final Map<MappableKey, ATerm> inputTermMap = new WeakHashMap<MappableKey, ATerm>();
+	private final Map<MappableKey, IStrategoTerm> inputTermMap = new WeakHashMap<MappableKey, IStrategoTerm>();
 
 	private final Map<MappableKey, SGLRTokenizer> tokenizerMap = new WeakHashMap<MappableKey, SGLRTokenizer>();
 
@@ -52,8 +52,8 @@
 		return inputCharMap.put(asfix.key, inputChars);
 	}
 
-	public ATerm putInputTerm(MappableTerm asfix, ATerm asfixATerm) {
-		return inputTermMap.put(asfix.key, asfixATerm);
+	public IStrategoTerm putInputTerm(MappableTerm asfix, IStrategoTerm asfixIStrategoTerm) {
+		return inputTermMap.put(asfix.key, asfixIStrategoTerm);
 	}
 	
 	public SGLRTokenizer putTokenizer(MappableTerm asfix, SGLRTokenizer tokenizer) {
@@ -76,7 +76,7 @@
 		return getValue(inputCharMap, asfix);
 	}
 	
-	public ATerm getInputTerm(IStrategoTerm asfix) {
+	public IStrategoTerm getInputTerm(IStrategoTerm asfix) {
 		return getValue(inputTermMap, asfix);
 	}
 	

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/StrategoTermPath.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/StrategoTermPath.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/StrategoTermPath.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -64,11 +64,11 @@
 	}
 	
 	/**
-	 * Creates a term path given the AST Node of a parsed ATerm file.
+	 * Creates a term path given the AST Node of a parsed IStrategoTerm file.
 	 * The resulting path relates to the actual AST, ignoring the 'appl' etc constructors
-	 * of the ATerm syntax.
+	 * of the IStrategoTerm syntax.
 	 */
-	public static IStrategoList createPathFromParsedATerm(final IStrategoAstNode node, Context context) {
+	public static IStrategoList createPathFromParsedIStrategoTerm(final IStrategoAstNode node, Context context) {
 		IStrategoTerm top = node.getRoot().getTerm();
 		final IStrategoTerm marker = context.getFactory().makeString(ContentProposer.COMPLETION_TOKEN);
 		top = oncetd_1_0.instance.invoke(context, top, new Strategy() {

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/IStrategoAstNode.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/IStrategoAstNode.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/IStrategoAstNode.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -10,7 +10,7 @@
 import org.strategoxt.imp.runtime.parser.SGLRParseController;
 
 /**
- * Interface for an AST node that can be converted into an ATerm. 
+ * Interface for an AST node that can be converted into an IStrategoTerm. 
  * 
  * @author Lennart Kats <lennart add lclnet.nl>
  */

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/WrappedAstNodeAppl.java
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/WrappedAstNodeAppl.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/WrappedAstNodeAppl.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -6,7 +6,7 @@
 import org.spoofax.interpreter.terms.ITermPrinter;
 
 /**
- * A constructor application AST node wrapped into an ATerm.
+ * A constructor application AST node wrapped into an IStrategoTerm.
  * 
  * @author Lennart Kats <lennart add lclnet.nl>
  * @author Karl Trygve Kalleberg <karltk add strategoxt.org>

Modified: spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.testing/META-INF/MANIFEST.MF
==============================================================================
--- spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.testing/META-INF/MANIFEST.MF	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax-imp/branches/spoofax-imp-new-terms/org.strategoxt.imp.testing/META-INF/MANIFEST.MF	Fri Dec 31 12:07:46 2010	(r21599)
@@ -16,7 +16,6 @@
  org.eclipse.jface.text,
  org.eclipse.ui.editors,
  org.eclipse.ui.workbench.texteditor,
- org.spoofax.aterm,
  org.spoofax.jsglr,
  org.strategoxt.strj,
  org.eclipse.jdt.junit,

Modified: spoofax/branches/spoofax-new-terms/spoofax/_attic/org.spoofax.interpreter/META-INF/MANIFEST.MF
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter/META-INF/MANIFEST.MF	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/_attic/org.spoofax.interpreter/META-INF/MANIFEST.MF	Fri Dec 31 12:07:46 2010	(r21599)
@@ -8,8 +8,6 @@
  org.spoofax.interpreter.core,
  org.spoofax.compiler,
  org.spoofax.jsglr;bundle-version="0.3.0",
- org.spoofax.aterm,
- org.spoofax.interpreter.adapter.aterm,
  org.spoofax.terms
 Export-Package: org.spoofax.interpreter
 Eclipse-LazyStart: true

Modified: spoofax/branches/spoofax-new-terms/spoofax/_attic/org.spoofax.interpreter/src/java/org/spoofax/interpreter/ConcreteInterpreter.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter/src/java/org/spoofax/interpreter/ConcreteInterpreter.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/_attic/org.spoofax.interpreter/src/java/org/spoofax/interpreter/ConcreteInterpreter.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -1,5 +1,6 @@
 package org.spoofax.interpreter;
 
+/* Obsolete; replaced by whatever
 import java.io.IOException;
 
 import org.spoofax.interpreter.core.Interpreter;
@@ -26,3 +27,4 @@
     	return (WrappedATermFactory)super.getFactory();
     }
 }
+*/
\ No newline at end of file

Modified: spoofax/branches/spoofax-new-terms/spoofax/_attic/org.spoofax.interpreter/src/java/org/spoofax/interpreter/cli/Main.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter/src/java/org/spoofax/interpreter/cli/Main.java	Tue Dec 28 17:13:49 2010	(r21593)
+++ spoofax/branches/spoofax-new-terms/spoofax/_attic/org.spoofax.interpreter/src/java/org/spoofax/interpreter/cli/Main.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -1,5 +1,6 @@
 package org.spoofax.interpreter.cli;
 
+/* Replaced by org.strategoxt.HybridInterpreter
 import java.io.IOException;
 import java.util.LinkedList;
 import java.util.List;
@@ -60,3 +61,4 @@
 		}
 	}
 }
+*/
\ No newline at end of file

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.compiler/META-INF/MANIFEST.MF
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.compiler/META-INF/MANIFEST.MF	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.compiler/META-INF/MANIFEST.MF	Fri Dec 31 12:07:46 2010	(r21599)
@@ -7,7 +7,6 @@
 Require-Bundle: org.spoofax.interpreter.core,
  org.spoofax.interpreter.library.jsglr,
  org.spoofax.jsglr;bundle-version="0.3.0",
- org.spoofax.interpreter.adapter.aterm,
  org.junit,
  org.spoofax.terms
 Bundle-ActivationPolicy: lazy

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.compiler/src/java/org/spoofax/compiler/Compiler.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.compiler/src/java/org/spoofax/compiler/Compiler.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.compiler/src/java/org/spoofax/compiler/Compiler.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -6,10 +6,10 @@
 
 import org.spoofax.interpreter.core.Interpreter;
 import org.spoofax.interpreter.core.InterpreterException;
-import org.spoofax.interpreter.adapter.aterm.WrappedATermFactory;
 import org.spoofax.interpreter.library.jsglr.JSGLRLibrary;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.terms.TermFactory;
 
 /**
  * @deprecated use strc-java instead
@@ -20,18 +20,18 @@
 	private String sharePath;
 	
     public Compiler() throws IOException, InterpreterException, InvalidParseTableException {
-    	this(sharePath(), new WrappedATermFactory());
+    	this(sharePath(), new TermFactory());
     }
     
-	public Compiler(String sharePath, WrappedATermFactory factory) throws IOException, InterpreterException, InvalidParseTableException {
+	public Compiler(String sharePath, TermFactory factory) throws IOException, InterpreterException, InvalidParseTableException {
 		this.sharePath = sharePath;
 		init(factory);
     }
     
-    private void init(WrappedATermFactory factory) throws IOException, InterpreterException, InvalidParseTableException
+    private void init(TermFactory factory) throws IOException, InterpreterException, InvalidParseTableException
     {
 		compiler = new Interpreter(factory);
-		compiler.addOperatorRegistry("JSGLR", new JSGLRLibrary(factory));
+		compiler.addOperatorRegistry("JSGLR", new JSGLRLibrary());
 		compiler.load(sharePath + "/libstratego-lib.ctree");
 		compiler.load(sharePath + "/libstratego-sglr.ctree");
 		compiler.load(sharePath + "/libstrc.ctree");

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/META-INF/MANIFEST.MF
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/META-INF/MANIFEST.MF	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.adapter.ecj/META-INF/MANIFEST.MF	Fri Dec 31 12:07:46 2010	(r21599)
@@ -8,7 +8,6 @@
  org.eclipse.core.runtime,
  org.junit,
  org.spoofax.interpreter.core,
- org.spoofax.interpreter.adapter.aterm,
  org.eclipse.text,
  org.spoofax.terms
 Bundle-Vendor: Spoofax.org

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_write_term_to_string.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_write_term_to_string.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_write_term_to_string.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -12,11 +12,8 @@
 import org.spoofax.interpreter.library.AbstractPrimitive;
 import org.spoofax.interpreter.stratego.Strategy;
 import org.spoofax.interpreter.terms.IStrategoTerm;
-import org.spoofax.terms.io.InlinePrinter;
 
 public class SSL_write_term_to_string extends AbstractPrimitive {
-    
-    private final InlinePrinter printer = new InlinePrinter();
 
     protected SSL_write_term_to_string() {
         super("SSL_write_term_to_string", 0, 1);
@@ -26,9 +23,7 @@
     public boolean call(IContext env, Strategy[] svars, IStrategoTerm[] tvars)
             throws InterpreterException {
         
-        tvars[0].prettyPrint(printer);
-        String result = printer.toString();
-        printer.reset();
+        String result = tvars[0].toString();
         env.setCurrent(env.getFactory().makeString(result));
         return true;
     }

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/StrategoHashMap.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/StrategoHashMap.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/StrategoHashMap.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -1,5 +1,6 @@
 package org.spoofax.interpreter.library.ssl;
 
+import java.io.IOException;
 import java.util.LinkedHashMap;
 
 import org.spoofax.interpreter.terms.IStrategoList;
@@ -57,6 +58,15 @@
         return String.valueOf(hashCode());
     }
     
+    public String toString(int maxDepth) {
+        return toString();
+    }
+    
+    public void writeToString(Appendable output, int maxDepth)
+            throws IOException {
+        output.append(toString());
+    }
+    
     public <T extends ITermAttachment> T getAttachment(Class<T> attachment) {
         throw new UnsupportedOperationException();
     }

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/StrategoSet.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/StrategoSet.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/StrategoSet.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -7,6 +7,7 @@
  */
 package org.spoofax.interpreter.library.ssl;
 
+import java.io.IOException;
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collection;
@@ -139,6 +140,15 @@
         return String.valueOf(hashCode());
     }
     
+    public String toString(int maxDepth) {
+        return toString();
+    }
+    
+    public void writeToString(Appendable output, int maxDepth)
+            throws IOException {
+        output.append(toString());
+    }
+    
     public <T extends ITermAttachment> T getAttachment(Class<T> attachment) {
         throw new UnsupportedOperationException();
     }

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/META-INF/MANIFEST.MF
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/META-INF/MANIFEST.MF	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/META-INF/MANIFEST.MF	Fri Dec 31 12:07:46 2010	(r21599)
@@ -8,8 +8,7 @@
 Require-Bundle: org.eclipse.ui,
  org.eclipse.core.runtime,
  org.spoofax.interpreter.core,
- org.spoofax.jsglr;bundle-version="0.3.0",
- org.spoofax.interpreter.adapter.aterm
+ org.spoofax.jsglr;bundle-version="0.3.0"
 Bundle-ActivationPolicy: lazy
 Export-Package: org.spoofax.interpreter.library.jsglr
 Bundle-RequiredExecutionEnvironment: J2SE-1.5

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLRLibrary.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLRLibrary.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLRLibrary.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -3,42 +3,28 @@
 import java.util.HashMap;
 import java.util.Map;
 
-import org.spoofax.interpreter.adapter.aterm.ATermConverter;
-import org.spoofax.interpreter.adapter.aterm.WrappedATermFactory;
 import org.spoofax.interpreter.library.AbstractStrategoOperatorRegistry;
 import org.spoofax.interpreter.terms.ITermFactory;
 import org.spoofax.jsglr.client.ParseTable;
 import org.spoofax.jsglr.io.ParseTableManager;
 
-import aterm.ATermFactory;
-
 public class JSGLRLibrary extends AbstractStrategoOperatorRegistry {
     
 	public static final String REGISTRY_NAME = "JSGLR";
 	
 	private ParseTableManager parseTableManager;
 	
-	private ATermFactory atermFactory;
+	private ITermFactory ITermFactory;
 	
 	private int parseTableCounter;
 	
 	private Map<Integer, ParseTable> parseTables;
 	
-	private ATermConverter atermConverter;
-	
-	private ITermFactory lastFactory;
-
-	@Deprecated
-	public JSGLRLibrary(WrappedATermFactory termFactory) {
-		this(termFactory.getFactory());
-    }
-	
-	public JSGLRLibrary(ATermFactory atermFactory) {
-		this.atermFactory = atermFactory;
+	public JSGLRLibrary() {
 		init();
-        add(new JSGLR_parse_stratego(atermFactory));
+        add(new JSGLR_parse_stratego());
         add(new JSGLR_open_parsetable());
-        add(new JSGLR_parse_string_pt(atermFactory));
+        add(new JSGLR_parse_string_pt());
 	}
 
 	public String getOperatorRegistryName() {
@@ -52,7 +38,7 @@
 
 	public ParseTableManager getParseTableManager() {
 		if(parseTableManager == null)
-			parseTableManager = new ParseTableManager(atermFactory);
+			parseTableManager = new ParseTableManager(ITermFactory);
 		return parseTableManager;
 	}
 
@@ -66,10 +52,4 @@
 	public ParseTable getParseTable(int idx) {
 		return parseTables.get(idx);
 	}
-	
-	public ATermConverter getATermConverter(ITermFactory factory) {
-		if (lastFactory != factory)
-			atermConverter = new ATermConverter(atermFactory, factory, true);
-		return atermConverter;
-	}
 }

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLRPrimitive.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLRPrimitive.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLRPrimitive.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -1,6 +1,5 @@
 package org.spoofax.interpreter.library.jsglr;
 
-import org.spoofax.interpreter.adapter.aterm.ATermConverter;
 import org.spoofax.interpreter.core.IContext;
 import org.spoofax.interpreter.library.AbstractPrimitive;
 
@@ -13,9 +12,5 @@
     protected static JSGLRLibrary getLibrary(IContext env) {
         return (JSGLRLibrary) env.getOperatorRegistry(JSGLRLibrary.REGISTRY_NAME);
     }
-    
-    protected static ATermConverter getATermConverter(IContext env) {
-    	return getLibrary(env).getATermConverter(env.getFactory());
-    }
 
 }

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLR_open_parsetable.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLR_open_parsetable.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLR_open_parsetable.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -10,8 +10,6 @@
 import org.spoofax.jsglr.client.InvalidParseTableException;
 import org.spoofax.jsglr.client.ParseTable;
 
-import aterm.ATerm;
-
 public class JSGLR_open_parsetable extends JSGLRPrimitive {
     
     // TODO: Do (non-static) caching at the IContext level
@@ -35,7 +33,7 @@
 	        return true;
 	    }
 	    
-	    ATerm tableTerm = getATermConverter(env).convert(tvars[0]);
+	    IStrategoTerm tableTerm = tvars[0];
 		
 		JSGLRLibrary lib = getLibrary(env);
 		try {

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLR_parse_stratego.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLR_parse_stratego.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLR_parse_stratego.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -11,24 +11,19 @@
 import org.spoofax.interpreter.stratego.Strategy;
 import org.spoofax.interpreter.terms.IStrategoString;
 import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.ITermFactory;
 import org.spoofax.jsglr.client.InvalidParseTableException;
 import org.spoofax.jsglr.client.ParseTable;
-import org.spoofax.jsglr.client.SGLR;
 import org.spoofax.jsglr.io.ParseTableManager;
+import org.spoofax.jsglr.io.SGLR;
 import org.spoofax.jsglr.shared.SGLRException;
 
-import aterm.ATerm;
-import aterm.ATermFactory;
-
 public class JSGLR_parse_stratego extends JSGLRPrimitive {
 	
-	private final ATermFactory atermFactory;
-	
-	private SGLR StrategoSGLR;
+	private SGLR strategoSGLR;
 	
-	JSGLR_parse_stratego(ATermFactory atermFactory) {
+	JSGLR_parse_stratego() {
 		super("JSGLR_parse_stratego", 0, 1);
-		this.atermFactory = atermFactory;
 	}
 	
 	@Override
@@ -38,13 +33,13 @@
 		if (!Tools.isTermString(tvars[0]))
 			return false;
 		String path = ((IStrategoString)tvars[0]).stringValue();
-		ATerm parsed = null;
-		if(StrategoSGLR == null)
-			initialize();
-		if(StrategoSGLR == null)
+		IStrategoTerm parsed = null;
+		if(strategoSGLR == null)
+			initialize(env.getFactory());
+		if(strategoSGLR == null)
 			return false;
 		try {
-			parsed = StrategoSGLR.parse(new BufferedInputStream(new FileInputStream(path)));
+			parsed = (IStrategoTerm) strategoSGLR.parse(new BufferedInputStream(new FileInputStream(path)), null);
 		} catch (FileNotFoundException e) {
 			System.err.println("File not found.");
 			return false;
@@ -57,18 +52,18 @@
 		}
 		if (parsed == null)
 			return false;
-		env.setCurrent(getATermConverter(env).convert(parsed));
+		env.setCurrent(parsed);
 		return true;
 	}
 
-	private void initialize() {
+	private void initialize(ITermFactory factory) {
 		// FIXME this must be cleaned
-		ParseTableManager ptm = new ParseTableManager(atermFactory);
+		ParseTableManager ptm = new ParseTableManager(factory);
 
 		ParseTable pt;
 		try {
 			pt = ptm.loadFromFile(System.getProperty("share.dir") + "/Stratego.tbl");
-			StrategoSGLR = new SGLR(atermFactory, pt);
+			strategoSGLR = new SGLR(factory, pt);
 		} catch (FileNotFoundException e) {
 			e.printStackTrace();
 		} catch (IOException e) {

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLR_parse_string_pt.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLR_parse_string_pt.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLR_parse_string_pt.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -18,25 +18,18 @@
 import org.spoofax.jsglr.client.SGLR;
 import org.spoofax.jsglr.shared.SGLRException;
 
-import aterm.ATerm;
-import aterm.ATermFactory;
-
 public class JSGLR_parse_string_pt extends JSGLRPrimitive {
-
-	private final ATermFactory atermFactory;
 	
 	private SGLRException lastException;
 	
 	private String lastPath;
-
-	protected JSGLR_parse_string_pt(ATermFactory factory) {
+	
+	protected JSGLR_parse_string_pt() {
 		super("JSGLR_parse_string_pt", 1, 4);
-		this.atermFactory = factory;
 	}
 	
-	protected JSGLR_parse_string_pt(ATermFactory factory, String name, int svars, int tvars) {
+	protected JSGLR_parse_string_pt(String name, int svars, int tvars) {
 		super(name, svars, tvars);
-		this.atermFactory = factory;
 	}
 	
 	public String getLastPath() {
@@ -90,7 +83,7 @@
 			return false;
 		} catch (SGLRException e) {
 			lastException = e;
-			IStrategoTerm errorTerm = getATermConverter(env).convert(e.toTerm(lastPath));
+			IStrategoTerm errorTerm = e.toTerm(lastPath);
 			env.setCurrent(errorTerm);
 			
 			// FIXME: Stratego doesn't seem to print the erroneous line in Java
@@ -102,10 +95,9 @@
 			ParseTable table, String startSymbol)
 			throws InterpreterException, IOException, SGLRException {
 		
-		SGLR parser = new SGLR(atermFactory, table);
+		SGLR parser = new SGLR(table);
 		
-		ATerm resultATerm = (ATerm) parser.parse(input.stringValue(), startSymbol);
-		IStrategoTerm result = getATermConverter(env).convert(resultATerm);
+		IStrategoTerm result = (IStrategoTerm) parser.parse(input.stringValue(), startSymbol);
 		
 		return result;
 	}

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/SGLR.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/SGLR.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/SGLR.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -20,7 +20,6 @@
 import org.spoofax.jsglr.shared.SGLRException;
 import org.spoofax.jsglr.shared.TokenExpectedException;
 import org.spoofax.jsglr.shared.Tools;
-import org.spoofax.terms.TermFactory;
 
 public class SGLR {
 
@@ -38,29 +37,27 @@
 	private static long parseTime=0;
 	private static int parseCount=0;
 
-	public Frame startFrame;
+	protected Frame startFrame;
 
 	private long startTime;
 
 	protected volatile boolean asyncAborted;
 
-	private ITermFactory factory;
+	protected Frame acceptingStack;
 
-	public Frame acceptingStack;
-
-	public ArrayDeque<Frame> activeStacks;
+	protected final ArrayDeque<Frame> activeStacks;
 
 	private ParseTable parseTable;
 
-	public int currentToken;
+	protected int currentToken;
 
-	public int tokensSeen;
+	protected int tokensSeen;
 
 	protected int lineNumber;
 
 	protected int columnNumber;
 
-	private ArrayDeque<ActionState> forShifter;
+	private final ArrayDeque<ActionState> forShifter;
 
 	private ArrayDeque<Frame> forActor;
 
@@ -78,7 +75,7 @@
 
 	private AmbiguityManager ambiguityManager;
 
-	public Disambiguator disambiguator;
+	protected Disambiguator disambiguator;
 
 	private int rejectCount;
 
@@ -134,16 +131,25 @@
         // Default does nothing (not supported by GWT)
     }
 
-	SGLR() {
-		basicInit(null);
-	}
-
+	@Deprecated
 	public SGLR(ITermFactory pf, ParseTable parseTable) {
-		assert pf != null;
+		this(parseTable);
+	}
+	
+	public SGLR(ParseTable parseTable) {
 		assert parseTable != null;
 		// Init with a new factory for both serialized or BAF instances.
 		this.parseTable = parseTable;
-		basicInit(pf);
+
+		activeStacks = new ArrayDeque<Frame>();
+		forActor = new ArrayDeque<Frame>();
+		forActorDelayed = new ArrayDeque<Frame>();
+		forShifter = new ArrayDeque<ActionState>();
+
+		disambiguator = new Disambiguator();
+		useIntegratedRecovery = false;
+		recoverIntegrator = null;
+		history = new ParserHistory();
 	}
 
 	public void setUseStructureRecovery(boolean useRecovery, IRecoveryParser parser) {
@@ -210,22 +216,6 @@
 		asyncAborted = false;
 	}
 
-	private void basicInit(ITermFactory factory) {
-		this.factory = factory;
-		if (factory == null) {
-			factory = new TermFactory();
-		}
-		activeStacks = new ArrayDeque<Frame>();
-		forActor = new ArrayDeque<Frame>();
-		forActorDelayed = new ArrayDeque<Frame>();
-		forShifter = new ArrayDeque<ActionState>();
-
-		disambiguator = new Disambiguator();
-		useIntegratedRecovery = false;
-		recoverIntegrator = null;
-		history = new ParserHistory();
-	}
-
 	public static boolean isDebugging() {
 		return Tools.debugging;
 	}
@@ -864,7 +854,6 @@
 		clearForShifterDeep();
 
 		this.parseTable = null;
-		this.factory = null;
 		this.ambiguityManager = null;
 	}
 
@@ -937,8 +926,9 @@
 		this.disambiguator = disambiguator;
 	}
 
+	@Deprecated
 	public ITermFactory getFactory() {
-		return factory;
+		return parseTable.getFactory();
 	}
 
 	public int getReductionCount() {

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/io/ParseTableManager.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/io/ParseTableManager.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/io/ParseTableManager.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -146,7 +146,7 @@
         return factory;
     }
 
-	public ParseTable loadFromTerm(ITermFactory factory, IStrategoTerm term) throws InvalidParseTableException {
+	public ParseTable loadFromTerm(IStrategoTerm term) throws InvalidParseTableException {
 		return initializeParseTable(factory, term);
 	}
 	

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/io/SGLR.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/io/SGLR.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/io/SGLR.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -62,6 +62,10 @@
 	public SGLR(ITermFactory pf, ParseTable parseTable) {
 		super(pf, parseTable);
 	}
+	
+	public SGLR(ParseTable parseTable) {
+		super(parseTable);
+	}
 
 	/**
 	 * @deprecated Call {@link #parse(InputStream, String)} instead.

Copied: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/ITermFactory.java (from r21594, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/ITermFactory.java)
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/ITermFactory.java	Fri Dec 31 12:07:46 2010	(r21599, copy of r21594, spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/ITermFactory.java)
@@ -0,0 +1,34 @@
+/*
+ * Created on 30. aug.. 2006
+ *
+ * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
+ * 
+ * Licensed under the GNU General Public License, v2
+ */
+package org.spoofax.interpreter.terms;
+
+import org.spoofax.terms.io.TermReader;
+
+/**
+ * 
+ * @author Karl T. Kalleberg <karltk add strategoxt.org>
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public interface ITermFactory extends IStrategoTermBuilder {
+    
+	/**
+	 * Parses a term from a string.
+	 * 
+	 * @see TermReader#parseFromStream(java.io.InputStream)
+	 * @see TermReader#parseFromFile(String)
+	 */
+    public IStrategoTerm parseFromString(String text);
+
+    public IStrategoAppl replaceAppl(IStrategoConstructor constructor, IStrategoTerm[] kids, IStrategoAppl old);
+    
+    public IStrategoList replaceList(IStrategoTerm[] kids, IStrategoList old);
+    
+    public IStrategoTuple replaceTuple(IStrategoTerm[] kids, IStrategoTuple old);
+    
+    public ITermFactory getFactoryWithStorageType(int storageType);
+}

Modified: spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/LazyTerm.java
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/LazyTerm.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax/branches/spoofax-new-terms/spoofax/org.spoofax.terms/src/org/spoofax/terms/LazyTerm.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -1,5 +1,7 @@
 package org.spoofax.terms;
 
+import java.io.IOException;
+
 import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoConstructor;
 import org.spoofax.interpreter.terms.IStrategoInt;
@@ -9,6 +11,7 @@
 import org.spoofax.interpreter.terms.IStrategoString;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.IStrategoTuple;
+import org.spoofax.interpreter.terms.ITermAttachment;
 import org.spoofax.interpreter.terms.ITermPrinter;
 
 /**
@@ -161,4 +164,24 @@
 		return ((IStrategoString) getWrapped()).stringValue();
 	}
 
+	public String toString(int maxDepth) {
+		return getWrapped().toString(maxDepth);
+	}
+
+	public void writeToString(Appendable output, int maxDepth) throws IOException {
+		getWrapped().writeToString(output, maxDepth);
+	}
+
+	public <T extends ITermAttachment> T getAttachment(Class<T> attachment) {
+		return getWrapped().getAttachment(attachment);
+	}
+
+	public void putAttachment(ITermAttachment attachment) {
+		getWrapped().putAttachment(attachment);
+	}
+
+	public boolean isList() {
+		return getWrapped().isList();
+	}
+
 }
\ No newline at end of file

Modified: spoofax/branches/spoofax-new-terms/spoofax/xlet/META-INF/MANIFEST.MF
==============================================================================
--- spoofax/branches/spoofax-new-terms/spoofax/xlet/META-INF/MANIFEST.MF	Fri Dec 31 12:06:26 2010	(r21598)
+++ spoofax/branches/spoofax-new-terms/spoofax/xlet/META-INF/MANIFEST.MF	Fri Dec 31 12:07:46 2010	(r21599)
@@ -4,4 +4,3 @@
 Bundle-SymbolicName: org.spoofax.xlet
 Bundle-Version: 0.1.0
 Bundle-Localization: plugin
-Require-Bundle: org.spoofax.interpreter

Modified: strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/META-INF/MANIFEST.MF
==============================================================================
--- strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/META-INF/MANIFEST.MF	Fri Dec 31 12:06:26 2010	(r21598)
+++ strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/META-INF/MANIFEST.MF	Fri Dec 31 12:07:46 2010	(r21599)
@@ -4,26 +4,9 @@
 Bundle-SymbolicName: org.strategoxt.strj;singleton:=true
 Bundle-Version: 0.17.92.qualifier
 Export-Package: .,
- aterm,
- aterm.pure,
- aterm.pure.binary,
- aterm.pure.binary.test,
- aterm.stream,
- aterm.test,
- jjtraveler,
- jjtraveler.graph,
- jjtraveler.reflective,
- jjtraveler.util,
- junit.awtui,
- junit.extensions,
- junit.framework,
- junit.runner,
- junit.swingui,
- junit.swingui.icons,
- junit.textui,
  org.spoofax,
- org.spoofax.interpreter,
- org.spoofax.interpreter.adapter.aterm,
+ org.spoofax.terms,
+ org.spoofax.terms.io,
  org.spoofax.interpreter.core,
  org.spoofax.interpreter.library,
  org.spoofax.interpreter.library.java,
@@ -34,9 +17,6 @@
  org.spoofax.interpreter.test,
  org.spoofax.interpreter.test.language,
  org.spoofax.interpreter.test.library,
- org.spoofax.jsglr,
- org.spoofax.jsglr.rnsglr,
- org.spoofax.jsglr.tests,
  org.spoofax.xlet,
  org.strategoxt,
  org.strategoxt.eclipse.ant,
@@ -54,7 +34,6 @@
  org.strategoxt.lang.compat.stratego_rtg_compat,
  org.strategoxt.lang.compat.strc_compat,
  org.strategoxt.lang.parallel.collections,
- org.strategoxt.lang.terms,
  org.strategoxt.stratego_aterm,
  org.strategoxt.stratego_gpp,
  org.strategoxt.stratego_lib,
@@ -65,8 +44,7 @@
  org.strategoxt.stratego_xtc,
  org.strategoxt.strc,
  org.strategoxt.strj,
- org.strategoxt.tools,
- shared
+ org.strategoxt.tools
 Require-Bundle: org.spoofax.aterm,
  org.spoofax.interpreter.core,
  org.spoofax.interpreter.adapter.aterm,

Modified: strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/build.properties
==============================================================================
--- strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/build.properties	Fri Dec 31 12:06:26 2010	(r21598)
+++ strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/build.properties	Fri Dec 31 12:07:46 2010	(r21599)
@@ -2,6 +2,6 @@
                java/strategoxt.jar,\
                .,\
                plugin.xml
-source.. = java/eclipse/
+source.. = java/eclipse/,java/runtime/
 output.. = bin/
 bin.excludes = java/bin/

Modified: strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/Makefile.am
==============================================================================
--- strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/Makefile.am	Fri Dec 31 12:06:26 2010	(r21598)
+++ strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/Makefile.am	Fri Dec 31 12:07:46 2010	(r21599)
@@ -81,6 +81,7 @@
 	rm -rf bin/* lib/org/strategoxt/*
 
 SPOOFAX=../../../spoofax/trunk/spoofax
+#SPOOFAX=../../../../spoofax/branches/spoofax-new-terms/spoofax
 CLASSPATH=runtime:lib:compiler:tools:spoofax-libs.jar:.
 JAVACFLAGS=-J-Xmx1024m -J-Xms512m -J-server -J-XX:+UseConcMarkSweepGC -cp $(CLASSPATH) -source 5 -target 5 -nowarn -d bin
 JAVAC=`if which ecj >/dev/null; then echo ecj; else echo javac; fi`
@@ -120,16 +121,12 @@
 new-libs :
 	rm -rf spoofax-libs-tmp
 	mkdir spoofax-libs-tmp
-	cat $(SPOOFAX)/org.spoofax.aterm/lib/jjtraveler-0.4.3.jar | (cd spoofax-libs-tmp; $(JAR) x)
-	cat $(SPOOFAX)/org.spoofax.aterm/lib/shared-objects-1.4.jar | (cd spoofax-libs-tmp; $(JAR) x)
 	cat $(SPOOFAX)/share/java/junit-3.8.1.jar | (cd spoofax-libs-tmp; $(JAR) x)
 	rm -rf spoofax-libs-tmp/META-INF
 	$(JAR) cf spoofax-libs.jar.tmp -C spoofax-libs-tmp .
 	$(JAR) uf spoofax-libs.jar.tmp -C $(SPOOFAX)/org.spoofax.interpreter.core/bin/ .
 	$(JAR) uf spoofax-libs.jar.tmp -C $(SPOOFAX)/org.spoofax.terms/bin/ .
 	$(JAR) uf spoofax-libs.jar.tmp -C $(SPOOFAX)/org.spoofax.jsglr/bin/ .
-	$(JAR) uf spoofax-libs.jar.tmp -C $(SPOOFAX)/org.spoofax.aterm/bin/ .
-	$(JAR) uf spoofax-libs.jar.tmp -C $(SPOOFAX)/org.spoofax.interpreter.adapter.aterm/bin/ .
 	$(JAR) uf spoofax-libs.jar.tmp -C $(SPOOFAX)/org.spoofax.interpreter.library.jsglr/bin/ .
 	rm -rf spoofax-libs-tmp
 	mv spoofax-libs.jar.tmp spoofax-libs.jar

Modified: strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/Context.java
==============================================================================
--- strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/Context.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/Context.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -10,7 +10,6 @@
 import java.util.concurrent.CancellationException;
 
 import org.spoofax.IAsyncCancellable;
-import org.spoofax.interpreter.adapter.aterm.WrappedATermFactory;
 import org.spoofax.interpreter.core.InterpreterException;
 import org.spoofax.interpreter.core.InterpreterExit;
 import org.spoofax.interpreter.core.StackTracer;
@@ -74,9 +73,6 @@
         addOperatorRegistry(new JFFLibrary(factory));
 
     	if (ioAgent != null) setIOAgent(ioAgent);
-    	
-    	if (factory instanceof WrappedATermFactory)
-    		throw new IllegalArgumentException("WrappedATermFactory is not supported at this time");
 
         compat.init();
     }

Modified: strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/ImportTerm.java
==============================================================================
--- strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/ImportTerm.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/ImportTerm.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -7,15 +7,11 @@
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
 
-import org.spoofax.interpreter.adapter.aterm.ATermConverter;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.ITermFactory;
 import org.spoofax.terms.LazyTerm;
 import org.spoofax.terms.io.TermReader;
 
-import aterm.ATerm;
-import aterm.ATermFactory;
-
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
  */
@@ -27,10 +23,6 @@
 	
 	private final Class<?> container;
 	
-	private ATermFactory atermFactory;
-	
-	private ATerm aterm;
-	
 	private ZipFile lastZipFile;
 	
 	public ImportTerm(ITermFactory factory, Class<?> container, String path, String name) {
@@ -41,27 +33,8 @@
 		this.name = name;
 	}
 	
-	public ATerm getATerm(ATermFactory factory) {
-		if (aterm == null) {
-			aterm = initATerm(factory);
-			atermFactory = factory;
-		} else if (factory != atermFactory) {
-			try {
-				aterm = factory.importTerm(aterm);
-			} catch (RuntimeException e) {
-				 // factory.importTerm(aterm) may not be implemented, try again...
-				aterm = initATerm(factory);
-			}
-			atermFactory = factory;
-		}
-		return aterm;
-	}
-	
 	@Override
 	protected IStrategoTerm init() {
-		if (aterm != null)
-			return new ATermConverter(aterm.getFactory(), factory, true).convert(aterm);
-		
 		InputStream stream = openStream();
 		try {
 			IStrategoTerm result = new TermReader(factory).parseFromStream(stream);
@@ -84,28 +57,6 @@
 			}
 		}
 	}
-	
-	private ATerm initATerm(ATermFactory factory) {
-		if (getWrapped(true) != null)
-			return new ATermConverter(factory, this.factory, false).convert(getWrapped());
-		InputStream stream = null;
-		try {
-			stream = openStream();
-			return factory.readFromFile(stream);
-		} catch (java.io.IOException e) {
-			throw new StrategoException(container.getSimpleName()
-					+ ": Could not read imported term file " + name, e);
-		} catch (RuntimeException e) {
-			throw new StrategoException(container.getSimpleName()
-					+ ": Could not read imported term file " + name, e);
-		} finally {
-			try {
-				if (stream != null) stream.close();
-			} catch (IOException e) {
-				e.printStackTrace(); // won't happen
-			}
-		}
-	}
 
 	private InputStream openStream() {
 		InputStream result = tryOpenStreamFromJar();

Modified: strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/SRTS_EXT_newint_0_0.java
==============================================================================
--- strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/SRTS_EXT_newint_0_0.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/SRTS_EXT_newint_0_0.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -1,10 +1,13 @@
 package org.strategoxt.lang;
 
+import java.io.IOException;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import org.spoofax.NotImplementedException;
 import org.spoofax.interpreter.terms.IStrategoInt;
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.ITermAttachment;
 import org.spoofax.interpreter.terms.ITermPrinter;
 import org.spoofax.terms.TermFactory;
 
@@ -76,6 +79,27 @@
 		public String toString() {
 			return String.valueOf(value);
 		}
+
+		public String toString(int maxDepth) {
+			return toString();
+		}
+
+		public void writeToString(Appendable output, int maxDepth)
+				throws IOException {
+			output.append(toString());
+		}
+
+		public <T extends ITermAttachment> T getAttachment(Class<T> attachment) {
+			return null;
+		}
+
+		public void putAttachment(ITermAttachment attachment) {
+			throw new NotImplementedException();
+		}
+
+		public boolean isList() {
+			return false;
+		}
 		
 	}
 }

Modified: strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/compat/CompatManager.java
==============================================================================
--- strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/compat/CompatManager.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/compat/CompatManager.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -1,6 +1,5 @@
 package org.strategoxt.lang.compat;
 
-import java.lang.ref.WeakReference;
 import java.util.HashSet;
 import java.util.Set;
 
@@ -8,9 +7,6 @@
 import org.strategoxt.lang.Context;
 import org.strategoxt.lang.compat.sglr.SGLRCompatLibrary;
 
-import aterm.ATermFactory;
-import aterm.pure.PureFactory;
-
 /**
  * Handles per-context library compatibility components.
  *
@@ -22,16 +18,6 @@
 	
 	private static final Set<String> asyncComponents = new HashSet<String>();
 	
-	/**
-	 * The last ATermFactory used by the CompatManager. ATermFactories are
-	 * guaranteed thread-safe, and by sharing them we make sure only one
-	 * instance is used by CompatManager ensuring low memory consumption and
-	 * high compatibility.
-	 */
-	private static WeakReference<ATermFactory> lastATermFactory;
-	
-	private ATermFactory atermFactory;
-	
 	public CompatManager(Context context) {
 		this.context = context;
 	}
@@ -53,20 +39,6 @@
 		}
 	}
 	
-	public void setATermFactory(ATermFactory atermFactory) {
-		this.atermFactory = atermFactory;
-		lastATermFactory = new WeakReference<ATermFactory>(atermFactory);
-	}
-	
-	private ATermFactory getATermFactory() {
-		if (atermFactory == null) {
-			atermFactory = lastATermFactory == null ? null : lastATermFactory.get();
-			if (atermFactory == null) 
-				setATermFactory(new PureFactory());
-		}
-		return atermFactory;
-	}
-	
 	/**
 	 * Dynamically loads any compatibility library or operator registry
 	 * associated with a Stratego library.
@@ -77,9 +49,8 @@
 			report_failure_compat_1_0.init();
 			ReadFromFile_cached_0_0.init();
 		} else if ("stratego_sglr".equals(component)) {
-			ATermFactory factory = getATermFactory();
-			context.addOperatorRegistry(new JSGLRLibrary(factory));
-			context.addOperatorRegistry(new SGLRCompatLibrary(factory));
+			context.addOperatorRegistry(new JSGLRLibrary());
+			context.addOperatorRegistry(new SGLRCompatLibrary());
 		}
 	}
 }

Modified: strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/compat/sglr/AbstractFilterSetting.java
==============================================================================
--- strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/compat/sglr/AbstractFilterSetting.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/compat/sglr/AbstractFilterSetting.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -4,7 +4,7 @@
 import org.spoofax.interpreter.library.AbstractPrimitive;
 import org.spoofax.interpreter.stratego.Strategy;
 import org.spoofax.interpreter.terms.IStrategoTerm;
-import org.spoofax.jsglr.Disambiguator;
+import org.spoofax.jsglr.client.Disambiguator;
 
 /**
  * @author Lennart Kats <lennart add lclnet.nl>

Modified: strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/compat/sglr/JSGLR_parse_string_pt_compat.java
==============================================================================
--- strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/compat/sglr/JSGLR_parse_string_pt_compat.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/compat/sglr/JSGLR_parse_string_pt_compat.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -7,15 +7,10 @@
 import org.spoofax.interpreter.library.jsglr.JSGLR_parse_string_pt;
 import org.spoofax.interpreter.terms.IStrategoString;
 import org.spoofax.interpreter.terms.IStrategoTerm;
-import org.spoofax.jsglr.Disambiguator;
-import org.spoofax.jsglr.ParseTable;
-import org.spoofax.jsglr.SGLR;
-import org.spoofax.jsglr.SGLRException;
+import org.spoofax.jsglr.client.Disambiguator;
+import org.spoofax.jsglr.client.SGLR;
 import org.strategoxt.lang.compat.override.jsglr_parser_compat.jsglr_parser_compat;
 
-import aterm.ATerm;
-import aterm.ATermFactory;
-
 /**
  * Extends the JSGLR_parse_string_pt primitive with support
  * for filter settings.
@@ -29,25 +24,23 @@
 	public static final String NAME = "JSGLR_parse_string_pt_compat"; 
 	
 	private final Disambiguator filterSettings;
-	
-	private final ATermFactory atermFactory;
 
-	protected JSGLR_parse_string_pt_compat(ATermFactory atermFactory, Disambiguator filterSettings) {
-		super(atermFactory, NAME, 1, 4);
+	protected JSGLR_parse_string_pt_compat(Disambiguator filterSettings) {
+		super(NAME, 1, 4);
 		this.filterSettings = filterSettings;
-		this.atermFactory = atermFactory;
 	}
 	
 	@Override
 	protected IStrategoTerm call(IContext env, IStrategoString input,
-			ParseTable table, String startSymbol)
-			throws InterpreterException, IOException, SGLRException {
+			org.spoofax.jsglr.client.ParseTable table, String startSymbol)
+			throws InterpreterException, IOException,
+			org.spoofax.jsglr.shared.SGLRException {
 		
-		SGLR parser = new SGLR(atermFactory, table);
+		SGLR parser = new SGLR(table);
 		parser.setDisambiguator(filterSettings);
 		
-		ATerm resultATerm = parser.parse(input.stringValue(), startSymbol);
-		return getATermConverter(env).convert(resultATerm);
+		IStrategoTerm result = (IStrategoTerm) parser.parse(input.stringValue(), startSymbol);
+		return result;
 	}
 
 }

Modified: strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/compat/sglr/SGLRCompatLibrary.java
==============================================================================
--- strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/compat/sglr/SGLRCompatLibrary.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/compat/sglr/SGLRCompatLibrary.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -1,9 +1,8 @@
 package org.strategoxt.lang.compat.sglr;
 
 import org.spoofax.interpreter.library.AbstractStrategoOperatorRegistry;
-import org.spoofax.jsglr.Disambiguator;
-
-import aterm.ATermFactory;
+import org.spoofax.interpreter.library.jsglr.JSGLR_open_parsetable;
+import org.spoofax.jsglr.client.Disambiguator;
 
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
@@ -18,15 +17,15 @@
 		return filterSettings;
 	}
 	
-	public SGLRCompatLibrary(ATermFactory atermFactory) {
-		initPrimitives(atermFactory);
+	public SGLRCompatLibrary() {
+		initPrimitives();
 	}
 	
-	protected void initPrimitives(ATermFactory atermFactory) {
+	protected void initPrimitives() {
 		initFilterSettings();
 		
-		add(new JSGLR_parse_string_pt_compat(atermFactory, filterSettings));
-		add(new JSGLR_open_parsetable_compat(atermFactory));
+		add(new JSGLR_parse_string_pt_compat(filterSettings));
+		add(new JSGLR_open_parsetable());
 		add(new STRSGLR_get_parse_error());
 		add(new STRSGLR_clear_parse_error());
 		add(new STRSGLR_anno_location());

Modified: strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/compat/sglr/STRSGLR_get_parse_error.java
==============================================================================
--- strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/compat/sglr/STRSGLR_get_parse_error.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/compat/sglr/STRSGLR_get_parse_error.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -6,8 +6,6 @@
 import org.spoofax.interpreter.stratego.Strategy;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 
-import aterm.ATerm;
-
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
  */
@@ -21,9 +19,9 @@
 	public boolean call(IContext env, Strategy[] svars, IStrategoTerm[] tvars) {
 		IOperatorRegistry or = env.getOperatorRegistry(SGLRCompatLibrary.REGISTRY_NAME);
 		JSGLR_parse_string_pt_compat parser = (JSGLR_parse_string_pt_compat) or.get(JSGLR_parse_string_pt_compat.NAME);
-		ATerm result = parser.getLastException().toTerm(parser.getLastPath());
+		IStrategoTerm result = parser.getLastException().toTerm(parser.getLastPath());
 		if (result == null) return false;
-		env.setCurrent(getATermConverter(env).convert(result));
+		env.setCurrent(result);
 		return true;
 	}
 }

Modified: strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/parallel/stratego_parallel/ParallelJobExecutor.java
==============================================================================
--- strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/parallel/stratego_parallel/ParallelJobExecutor.java	Fri Dec 31 12:06:26 2010	(r21598)
+++ strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/runtime/org/strategoxt/lang/parallel/stratego_parallel/ParallelJobExecutor.java	Fri Dec 31 12:07:46 2010	(r21599)
@@ -9,7 +9,7 @@
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 
-import org.spoofax.jsglr.NotImplementedException;
+import org.spoofax.NotImplementedException;
 
 /**
  * Executes jobs, in parallel.

Modified: strategoxt-java-backend/branches/strategoxt-java-backend-new-terms/java/spoofax-libs.jar
==============================================================================
Binary file (source and/or target). No diff available.

