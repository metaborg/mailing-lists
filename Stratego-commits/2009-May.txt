From zef at zefhemel.com  Wed May 20 10:35:32 2009
From: zef at zefhemel.com (Zef Hemel)
Date: Wed, 20 May 2009 08:35:32 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19453 - zef - in
	pil/trunk: src/pil/syntax src/pil/typechecker test
Message-ID: <200905200835.n4K8Z0fo019531@proliant.st.ewi.tudelft.nl>

Author: zef
Date: 2009-05-20 08:35:31 +0000 (Wed, 20 May 2009)
New Revision: 19453

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19453&view=rev

Modified:
   pil/trunk/src/pil/syntax/PIL-Expression.sdf
   pil/trunk/src/pil/syntax/PIL-Lexical.sdf
   pil/trunk/src/pil/typechecker/rename.str
   pil/trunk/test/generic.pil

Log:
BBG! (Bugs Be Gone)


Changes:

Modified: pil/trunk/src/pil/syntax/PIL-Expression.sdf
===================================================================
--- pil/trunk/src/pil/syntax/PIL-Expression.sdf	2009-05-19 14:55:36 UTC (rev 19452)
+++ pil/trunk/src/pil/syntax/PIL-Expression.sdf	2009-05-20 08:35:31 UTC (rev 19453)
@@ -30,7 +30,7 @@
     "!" Exp                               -> Exp {cons("Not")}
     Exp "." MethodId "(" {Exp ","}* ")"   -> Exp {cons("MethodCall")}
     Exp "." "as" "<" Type ">"             -> Exp {cons("CastCall"), prefer}
-    QId "<" {Type ","}* ">" "(" {Exp ","}* ")" -> Exp {cons("GenericFunctionCall")}
+    QId "<" {Type ","}* ">" "(" {Exp ","}* ")" -> Exp {cons("GenericFunctionCall"), prefer}
     QId "(" {Exp ","}* ")"                -> Exp {cons("FunctionCall")}
     %%"(" Type ")" Exp                      -> Exp {cons("Cast")}
     "new" Type "(" {Exp ","}* ")"         -> Exp {cons("ObjectCreation")}

Modified: pil/trunk/src/pil/syntax/PIL-Lexical.sdf
===================================================================
--- pil/trunk/src/pil/syntax/PIL-Lexical.sdf	2009-05-19 14:55:36 UTC (rev 19452)
+++ pil/trunk/src/pil/syntax/PIL-Lexical.sdf	2009-05-20 08:35:31 UTC (rev 19453)
@@ -71,6 +71,7 @@
   context-free restrictions
     LAYOUT? -/- [\ \t\12\n\r]
     Id      -/- [a-zA-Z0-9]
+    "new"   -/- [a-zA-Z0-9]
     
   lexical restrictions
     Asterisk   -/- [\/]

Modified: pil/trunk/src/pil/typechecker/rename.str
===================================================================
--- pil/trunk/src/pil/typechecker/rename.str	2009-05-19 14:55:36 UTC (rev 19452)
+++ pil/trunk/src/pil/typechecker/rename.str	2009-05-20 08:35:31 UTC (rev 19453)
@@ -9,12 +9,13 @@
   pil-rename-bound(|t) :
     x -> y
     with  y := x{<newname> x}
+       ; t2 := <pil-rename-all> t
        ; rules (
            PilRename : Var(x) -> Var(y)
            PilRename : FunctionCall(x, e*) -> FunctionCall(y, e2*) where e2* := <pil-rename-all> e*
            PilRename : MethodCall(e, x, e*) -> MethodCall(e2, y, e2*) where e2 := <pil-rename-all> e; e2* := <pil-rename-all> e*
            PilRename : VarLHS(x) -> VarLHS(y)
-           PilTypeOf : y -> t
+           PilTypeOf : y -> t2
          )
 
   pil-rename-farg :

Modified: pil/trunk/test/generic.pil
===================================================================
--- pil/trunk/test/generic.pil	2009-05-19 14:55:36 UTC (rev 19452)
+++ pil/trunk/test/generic.pil	2009-05-20 08:35:31 UTC (rev 19453)
@@ -1,13 +1,12 @@
 //external <T> void addAll(List<T> list, List<T> items);
 
 class Wrapper<T> {
-  T obj = null;
   new(T obj) {
-    this.obj = obj;
+    List<T> l = new List<T>();
+    l.add(obj);
   }
 }
 
 void main(Array<String> args) {
   Wrapper<Int> s = new Wrapper<Int>(10);
-  println(s.obj);
 }



From L.C.L.Kats at tudelft.nl  Wed May 20 14:44:33 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Wed, 20 May 2009 12:44:33 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19454 - LennartKats -
	spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
	spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms
	spoofax/trunk/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr
	spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building
Message-ID: <200905201244.n4KCi1qF023272@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-05-20 12:44:33 +0000 (Wed, 20 May 2009)
New Revision: 19454

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19454&view=rev

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building/FileTrackingIOAgent.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLRException.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/InlinePrinter.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLR_parse_string_pt.java

Log:
Build fixes.

Changes:

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLRException.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLRException.java	2009-05-20 08:35:31 UTC (rev 19453)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLRException.java	2009-05-20 12:44:33 UTC (rev 19454)
@@ -38,6 +38,9 @@
     }
     
     public ATerm toTerm(String filename) {
+        if (parser == null)
+            throw new UnsupportedOperationException();
+        
         ATermFactory factory = parser.getFactory();
         return factory.makeAppl(
             factory.makeAFun("error", 2, false),

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/InlinePrinter.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/InlinePrinter.java	2009-05-20 08:35:31 UTC (rev 19453)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/InlinePrinter.java	2009-05-20 12:44:33 UTC (rev 19454)
@@ -26,6 +26,15 @@
 
 	public void outdent(int i) {
 	}
+	
+	@Override
+	public String toString() {
+	    return getString();
+	}
+	
+	public void reset() {
+	    out.setLength(0);
+	}
 
 	public void println(String string, boolean b) {
 		if (string.matches("^ *$")) {

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLR_parse_string_pt.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLR_parse_string_pt.java	2009-05-20 08:35:31 UTC (rev 19453)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/JSGLR_parse_string_pt.java	2009-05-20 12:44:33 UTC (rev 19454)
@@ -10,6 +10,7 @@
 import org.spoofax.interpreter.core.InterpreterException;
 import org.spoofax.interpreter.core.Tools;
 import org.spoofax.interpreter.stratego.Strategy;
+import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.TermConverter;
 import org.spoofax.jsglr.ParseTable;
@@ -20,21 +21,53 @@
 
 public class JSGLR_parse_string_pt extends JSGLRPrimitive {
 
-	private WrappedATermFactory factory;
+	private final WrappedATermFactory factory;
+	
+	private SGLRException lastException;
+	
+	private String lastPath;
 
 	protected JSGLR_parse_string_pt(WrappedATermFactory termFactory) {
 		super("JSGLR_parse_string_pt", 1, 4);
 		this.factory = termFactory;
 	}
+	
+	public String getLastPath() {
+		return lastPath;
+	}
+	
+	public SGLRException getLastException() {
+		return lastException;
+	}
+	
+	public void clearLastException() {
+		lastException = null;
+	}
 
 	@Override
 	public boolean call(IContext env, Strategy[] svars, IStrategoTerm[] tvars)
 			throws InterpreterException {
 		
-		if(!Tools.isTermString(tvars[0]))
+		clearLastException();
+		
+		if (!Tools.isTermString(tvars[0]))
 			return false;
-		if(!Tools.isTermInt(tvars[1]))
+		if (!Tools.isTermInt(tvars[1]))
 			return false;
+		if(!Tools.isTermString(tvars[3]))
+			return false;
+
+		String startSymbol;
+		if (Tools.isTermString(tvars[2])) {
+			startSymbol = Tools.asJavaString(tvars[2]);
+		} else if (tvars[2].getSubtermCount() == 0 && tvars[2].getTermType() == IStrategoTerm.APPL && ((IStrategoAppl) tvars[2]).getConstructor().getName().equals("None")) {
+			startSymbol = null;
+		} else {
+			return false;
+		}
+
+		lastPath = Tools.asJavaString(tvars[3]);
+		Strategy onParseError = svars[0];
 		
 		JSGLRLibrary lib = getLibrary(env);
 		ParseTable pt = lib.getParseTable(Tools.asJavaInt(tvars[1]));
@@ -45,7 +78,7 @@
 		
 		InputStream is = new ByteArrayInputStream(Tools.asJavaString(tvars[0]).getBytes());
 		try {
-			IStrategoTerm result = factory.wrapTerm(parser.parse(is));
+			IStrategoTerm result = factory.wrapTerm(parser.parse(is, startSymbol));
 			if (!(tvars[0] instanceof WrappedATerm))
 				result = TermConverter.convert(env.getFactory(), result);
 			
@@ -54,7 +87,12 @@
 		} catch (IOException e) {
 			e.printStackTrace();
 		} catch (SGLRException e) {
-			e.printStackTrace();
+			lastException = e;
+			IStrategoTerm errorTerm = factory.wrapTerm(e.toTerm(lastPath));
+			env.setCurrent(TermConverter.convert(env.getFactory(), errorTerm));
+			
+			// TODO: Stratego doesn't seem to print the erroneous line in Java
+			return onParseError.evaluate(env);
 		}
 		return false;
 	}

Modified: spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building/FileTrackingIOAgent.java
===================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building/FileTrackingIOAgent.java	2009-05-20 08:35:31 UTC (rev 19453)
+++ spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building/FileTrackingIOAgent.java	2009-05-20 12:44:33 UTC (rev 19454)
@@ -43,7 +43,7 @@
 	}
 	
 	@Override
-	public int openRandomAccessFile(String fn, String mode) throws FileNotFoundException {
+	public int openRandomAccessFile(String fn, String mode) throws FileNotFoundException, IOException {
 		track(fn);
 		return super.openRandomAccessFile(fn, mode);
 	}



From L.C.L.Kats at tudelft.nl  Wed May 20 14:45:02 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Wed, 20 May 2009 12:45:02 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19455 - LennartKats -
	spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building
Message-ID: <200905201244.n4KCiUWe023281@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-05-20 12:45:02 +0000 (Wed, 20 May 2009)
New Revision: 19455

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19455&view=rev

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building/FileTrackingIOAgent.java

Log:


Changes:

Modified: spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building/FileTrackingIOAgent.java
===================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building/FileTrackingIOAgent.java	2009-05-20 12:44:33 UTC (rev 19454)
+++ spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building/FileTrackingIOAgent.java	2009-05-20 12:45:02 UTC (rev 19455)
@@ -2,6 +2,7 @@
 
 import java.io.File;
 import java.io.FileNotFoundException;
+import java.io.IOException;
 import java.io.InputStream;
 import java.util.HashSet;
 import java.util.Set;



From L.C.L.Kats at tudelft.nl  Wed May 20 15:00:52 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Wed, 20 May 2009 13:00:52 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19458 - LennartKats -
	spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser
Message-ID: <200905201300.n4KD0Kxt023409@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-05-20 13:00:52 +0000 (Wed, 20 May 2009)
New Revision: 19458

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19458&view=rev

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/CSGLRI.java

Log:


Changes:

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/CSGLRI.java
===================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/CSGLRI.java	2009-05-20 13:00:28 UTC (rev 19457)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/CSGLRI.java	2009-05-20 13:00:52 UTC (rev 19458)
@@ -86,7 +86,7 @@
 			ATermAppl result = (ATermAppl) factory.readFromFile(outputFile.getAbsolutePath());
 			
 			if ("error".equals(result.getName()))
-				throw new SGLRException("CSGLR Parse error: " + result); // (actual error isn't extracted atm)
+				throw new SGLRException(null, "CSGLR Parse error: " + result); // (actual error isn't extracted atm)
 			
 			return result;
 		} catch (InterruptedException e) {



From karltk at strategoxt.org  Fri May 22 14:17:37 2009
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Fri, 22 May 2009 12:17:37 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19465 - karltk -
	spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms
Message-ID: <200905221217.n4MCH12I018851@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: 2009-05-22 12:17:36 +0000 (Fri, 22 May 2009)
New Revision: 19465

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19465&view=rev

Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/BasicStrategoArrayList.java

Log:
Make it publicly accessible.

Changes:

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/BasicStrategoArrayList.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/BasicStrategoArrayList.java	2009-05-20 15:33:07 UTC (rev 19464)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/BasicStrategoArrayList.java	2009-05-22 12:17:36 UTC (rev 19465)
@@ -16,7 +16,7 @@
         this.kids = kids;
     }
 
-    protected BasicStrategoArrayList(IStrategoTerm[] kids) {
+    public BasicStrategoArrayList(IStrategoTerm[] kids) {
         super(null);
         this.kids = kids;
     }



From karltk at strategoxt.org  Fri May 22 14:22:48 2009
From: karltk at strategoxt.org (Karl Trygve Kalleberg)
Date: Fri, 22 May 2009 12:22:48 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19466 - karltk - in
	spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj:
	scripts/spoofax/bindings/eclipse
	src/org/spoofax/interpreter/adapter/ecj
	src/org/spoofax/interpreter/library/ecj
Message-ID: <200905221222.n4MCMCkF018894@proliant.st.ewi.tudelft.nl>

Author: karltk
Date: 2009-05-22 12:22:48 +0000 (Fri, 22 May 2009)
New Revision: 19466

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19466&view=rev

Added:
   spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedActualTypeSignature.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/library/ecj/ECJ_search_for_supertype_type_refs_no_generics.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/library/ecj/ECJ_signature_to_type.java
Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/scripts/spoofax/bindings/eclipse/eclipse-compiler-ffi.str
   spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/AbstractECJNode.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/ECJFactory.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedASTNode.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedITypeParameter.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/library/ecj/ECJLibrary.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/library/ecj/ECJ_search_for_supertype_type_refs_in_hierarchy.java

Log:
 * Added wrapper for Signatures. These are read-only terms for now. 
 * Added proper equals and match for all WrappedASTNode children. This fixes make-set.
 * Added variant of search for supertype where generic parameters are not heeded; should probably go away again.
 * Added strategy parameter to search_for_type_refs_in_hierarchy so that the ActualTypeSignature of each type may be filtered on.
 * Added signature_to_type to facilitate conversion from Signature to a Type.
 * Extended ecj-name-of to deal with ParameterizedType and IType (by erasure)
 * Extended ecj-dotted-name-of to deal with ParameterizedType (by erasure)



Changes:

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/scripts/spoofax/bindings/eclipse/eclipse-compiler-ffi.str
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/scripts/spoofax/bindings/eclipse/eclipse-compiler-ffi.str	2009-05-22 12:17:36 UTC (rev 19465)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/scripts/spoofax/bindings/eclipse/eclipse-compiler-ffi.str	2009-05-22 12:22:48 UTC (rev 19466)
@@ -19,10 +19,12 @@
   Binding        : Int * Int * String -> Binding
   TypeBinding    : List(String) * String * List(TypeBinding) * TypeBinding * List(TypeBinding) * Int * ITypeBinding -> TypeBinding
   TypeParameter  : List(String) -> TypeParameter
+  ITypeParameter : String * List(String) -> ITypeParameter
   DottedName     : String -> DottedName
   IType          : DottedName * Int * IType * DottedName * List(DottedName) * List(TypeParameter) -> IType
   ITypeHierarchy : IType * List(IType) -> ITypeHierarchy
   PrimitiveName  : String -> Name
+  ActualTypeSignature : String * String * String * ActualTypeSignature -> ActualTypeSignature
   
 strategies
 
@@ -210,13 +212,24 @@
       DottedName(?typename)
     ; prim("ECJ_search_for_supertype_type_refs", scope, typename)      
 
-  /** @param scope - IType
+  /** @param scope - IJavaElement
     * @type DottedName -> List(IType) 
     */
-  ecj-search-for-supertype-type-refs-in-hierarchy(|scope) = 
+  ecj-search-for-supertype-type-refs-no-generics(|scope) = 
       DottedName(?typename)
-    ; prim("ECJ_search_for_supertype_type_refs_in_hierarchy", scope, typename)      
+    ; prim("ECJ_search_for_supertype_type_refs_no_generics", scope, typename)      
 
+  /** Search for a given type name (type erasure) in the parent type hierarchy
+    * of the parameter 'scope'.
+    * 
+    * @param accept - Signature -> _ 
+    * @param scope - IType
+    * @type DottedName -> List(IType) 
+    */
+  ecj-search-for-supertype-type-refs-in-hierarchy(accept|scope) = 
+      DottedName(?typename)
+    ; prim("ECJ_search_for_supertype_type_refs_in_hierarchy", accept | scope, typename)      
+
   /** 
    * Check compilation units with the given type name for the presence of a type
    * with the given name. This is a shallow check.
@@ -316,6 +329,12 @@
   /** @type -> PrimitiveName */
   ecj-name-of = ?PrimitiveType(<id>) ; !PrimitiveName(<id>)
   
+  /** @type -> SimpleName / QualifiedName */
+  ecj-name-of = ?IType(<id>, _, _, _, _, _) ; ecj-as-qualified-name
+  
+  /** @type ParameterizedType -> SimpleName / QualifiedName */
+  ecj-name-of = ?ParameterizedType(<id>, _)
+  
   /**
    * Computes the dotted name of an AST node, if this is possible
    * 
@@ -332,6 +351,9 @@
   /** @type PrimitiveType -> DottedName  */
   ecj-dotted-name-of = ?PrimitiveType(x); !DottedName(x)
   
+  /** @type ParameterizedType -> DottedName  */
+  ecj-dotted-name-of = ?ParameterizedType(<ecj-dotted-name-of>, _)
+  
   /** @type */    
   ecj-package-of = ?CompilationUnit(<id>, _, _)
   
@@ -502,6 +524,13 @@
    */
   ecj-string-name-of = ecj-dotted-name-of ; ?DottedName(<id>)
   
+   /** 
+    * @type String -> Type
+    */
+  ecj-signature-to-type =
+    ?x
+    ; prim("ECJ_signature_to_type", x)
+  
 overlays
 
   PublicMod    = Modifier(ModifierKeyword(1))

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/AbstractECJNode.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/AbstractECJNode.java	2009-05-22 12:17:36 UTC (rev 19465)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/AbstractECJNode.java	2009-05-22 12:22:48 UTC (rev 19466)
@@ -15,4 +15,11 @@
 	public IStrategoList getAnnotations() {
 		return BasicTermFactory.EMPTY_LIST;
 	}
+
+    @Override
+    public boolean equals(Object obj) {
+        if(!(obj instanceof IStrategoTerm))
+            return false;
+        return match((IStrategoTerm)obj);
+    }
 }

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/ECJFactory.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/ECJFactory.java	2009-05-22 12:17:36 UTC (rev 19465)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/ECJFactory.java	2009-05-22 12:22:48 UTC (rev 19466)
@@ -25,109 +25,13 @@
 import org.eclipse.jdt.core.IType;
 import org.eclipse.jdt.core.ITypeHierarchy;
 import org.eclipse.jdt.core.ITypeParameter;
-import org.eclipse.jdt.core.dom.AST;
-import org.eclipse.jdt.core.dom.ASTNode;
-import org.eclipse.jdt.core.dom.AbstractTypeDeclaration;
-import org.eclipse.jdt.core.dom.Annotation;
-import org.eclipse.jdt.core.dom.AnnotationTypeDeclaration;
-import org.eclipse.jdt.core.dom.AnnotationTypeMemberDeclaration;
-import org.eclipse.jdt.core.dom.AnonymousClassDeclaration;
-import org.eclipse.jdt.core.dom.ArrayAccess;
-import org.eclipse.jdt.core.dom.ArrayCreation;
-import org.eclipse.jdt.core.dom.ArrayInitializer;
-import org.eclipse.jdt.core.dom.ArrayType;
-import org.eclipse.jdt.core.dom.AssertStatement;
-import org.eclipse.jdt.core.dom.Assignment;
-import org.eclipse.jdt.core.dom.Block;
-import org.eclipse.jdt.core.dom.BlockComment;
-import org.eclipse.jdt.core.dom.BodyDeclaration;
-import org.eclipse.jdt.core.dom.BooleanLiteral;
-import org.eclipse.jdt.core.dom.BreakStatement;
-import org.eclipse.jdt.core.dom.CastExpression;
-import org.eclipse.jdt.core.dom.CatchClause;
-import org.eclipse.jdt.core.dom.CharacterLiteral;
-import org.eclipse.jdt.core.dom.ClassInstanceCreation;
-import org.eclipse.jdt.core.dom.Comment;
-import org.eclipse.jdt.core.dom.CompilationUnit;
-import org.eclipse.jdt.core.dom.ConditionalExpression;
-import org.eclipse.jdt.core.dom.ConstructorInvocation;
-import org.eclipse.jdt.core.dom.ContinueStatement;
-import org.eclipse.jdt.core.dom.DoStatement;
-import org.eclipse.jdt.core.dom.EmptyStatement;
-import org.eclipse.jdt.core.dom.EnhancedForStatement;
-import org.eclipse.jdt.core.dom.EnumConstantDeclaration;
-import org.eclipse.jdt.core.dom.EnumDeclaration;
-import org.eclipse.jdt.core.dom.Expression;
-import org.eclipse.jdt.core.dom.ExpressionStatement;
-import org.eclipse.jdt.core.dom.FieldAccess;
-import org.eclipse.jdt.core.dom.FieldDeclaration;
-import org.eclipse.jdt.core.dom.ForStatement;
-import org.eclipse.jdt.core.dom.IBinding;
-import org.eclipse.jdt.core.dom.IExtendedModifier;
-import org.eclipse.jdt.core.dom.IMethodBinding;
-import org.eclipse.jdt.core.dom.ITypeBinding;
-import org.eclipse.jdt.core.dom.IfStatement;
-import org.eclipse.jdt.core.dom.ImportDeclaration;
-import org.eclipse.jdt.core.dom.InfixExpression;
-import org.eclipse.jdt.core.dom.Initializer;
-import org.eclipse.jdt.core.dom.InstanceofExpression;
-import org.eclipse.jdt.core.dom.Javadoc;
-import org.eclipse.jdt.core.dom.LabeledStatement;
-import org.eclipse.jdt.core.dom.LineComment;
-import org.eclipse.jdt.core.dom.MarkerAnnotation;
-import org.eclipse.jdt.core.dom.MemberRef;
-import org.eclipse.jdt.core.dom.MemberValuePair;
-import org.eclipse.jdt.core.dom.MethodDeclaration;
-import org.eclipse.jdt.core.dom.MethodInvocation;
-import org.eclipse.jdt.core.dom.MethodRef;
-import org.eclipse.jdt.core.dom.MethodRefParameter;
-import org.eclipse.jdt.core.dom.Modifier;
-import org.eclipse.jdt.core.dom.Name;
-import org.eclipse.jdt.core.dom.NormalAnnotation;
-import org.eclipse.jdt.core.dom.NullLiteral;
-import org.eclipse.jdt.core.dom.NumberLiteral;
-import org.eclipse.jdt.core.dom.PackageDeclaration;
-import org.eclipse.jdt.core.dom.ParameterizedType;
-import org.eclipse.jdt.core.dom.ParenthesizedExpression;
-import org.eclipse.jdt.core.dom.PostfixExpression;
-import org.eclipse.jdt.core.dom.PrefixExpression;
-import org.eclipse.jdt.core.dom.PrimitiveType;
-import org.eclipse.jdt.core.dom.QualifiedName;
-import org.eclipse.jdt.core.dom.QualifiedType;
-import org.eclipse.jdt.core.dom.ReturnStatement;
-import org.eclipse.jdt.core.dom.SimpleName;
-import org.eclipse.jdt.core.dom.SimpleType;
-import org.eclipse.jdt.core.dom.SingleMemberAnnotation;
-import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
-import org.eclipse.jdt.core.dom.Statement;
-import org.eclipse.jdt.core.dom.StringLiteral;
-import org.eclipse.jdt.core.dom.SuperConstructorInvocation;
-import org.eclipse.jdt.core.dom.SuperFieldAccess;
-import org.eclipse.jdt.core.dom.SuperMethodInvocation;
-import org.eclipse.jdt.core.dom.SwitchCase;
-import org.eclipse.jdt.core.dom.SwitchStatement;
-import org.eclipse.jdt.core.dom.SynchronizedStatement;
-import org.eclipse.jdt.core.dom.TagElement;
-import org.eclipse.jdt.core.dom.TextElement;
-import org.eclipse.jdt.core.dom.ThisExpression;
-import org.eclipse.jdt.core.dom.ThrowStatement;
-import org.eclipse.jdt.core.dom.TryStatement;
-import org.eclipse.jdt.core.dom.Type;
-import org.eclipse.jdt.core.dom.TypeDeclaration;
-import org.eclipse.jdt.core.dom.TypeDeclarationStatement;
-import org.eclipse.jdt.core.dom.TypeLiteral;
-import org.eclipse.jdt.core.dom.TypeParameter;
-import org.eclipse.jdt.core.dom.VariableDeclaration;
-import org.eclipse.jdt.core.dom.VariableDeclarationExpression;
-import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
-import org.eclipse.jdt.core.dom.VariableDeclarationStatement;
-import org.eclipse.jdt.core.dom.WhileStatement;
-import org.eclipse.jdt.core.dom.WildcardType;
+import org.eclipse.jdt.core.dom.*;
 import org.eclipse.jdt.core.dom.InfixExpression.Operator;
 import org.eclipse.jdt.core.dom.Modifier.ModifierKeyword;
 import org.eclipse.jdt.core.dom.PrimitiveType.Code;
 import org.spoofax.DebugUtil;
 import org.spoofax.NotImplementedException;
+import org.spoofax.interpreter.terms.BasicStrategoArrayList;
 import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoConstructor;
 import org.spoofax.interpreter.terms.IStrategoInt;
@@ -236,6 +140,7 @@
     private static final int IMPORT_REFERENCE = 93;
     private static final int ANONYMOUS_CLASS_DECLARATION = 94;
     private static final int ASSIGNMENT_OPERATOR = 95;
+	private static ASTMatcher astMatcher;
         
     private Map<String,Integer> ctorNameToIndexMap;
     private AST ast;
@@ -1203,7 +1108,7 @@
             if((!isJavadoc(kids[0]) && !isNone(kids[0]))
                     || !isModifierList(kids[1])
                     || !isSimpleName(kids[2])
-                    || !isTypeList(kids[3])
+                    || !isTypeParameterList(kids[3])
                     || (!isType(kids[4]) && !isNone(kids[4]))
                     || !isTypeList(kids[5])
                     || !isBodyDeclarationList(kids[6])
@@ -1216,7 +1121,7 @@
                 x.setJavadoc(asJavadoc(kids[0]));
             x.modifiers().addAll(asModifierList(kids[1]));
             x.setName(asSimpleName(kids[2]));
-            x.typeParameters().addAll(asTypeList(kids[3]));
+            x.typeParameters().addAll(asTypeParameterList(kids[3]));
             if(isNone(kids[4])) 
                 x.setSuperclassType(null);
             else 
@@ -1309,7 +1214,7 @@
 
     private Javadoc asJavadoc(IStrategoTerm term) {
         Javadoc x = ((WrappedJavadoc)term).getWrappee();
-        return x.getParent() == null ? x : (Javadoc)ASTNode.copySubtree(ast, x);
+        return x.getParent() == null && x.getAST() == ast ? x : (Javadoc)ASTNode.copySubtree(ast, x);
     }
 
     @SuppressWarnings("unchecked")
@@ -1324,7 +1229,11 @@
 
     private IExtendedModifier asExtendedModifier(IStrategoTerm term) {
     	final IExtendedModifier x = ((IWrappedExtendedModifier)term).getModifierWrappee();
-    	return ((ASTNode)x).getParent() == null ? x : (IExtendedModifier)ASTNode.copySubtree(ast, (ASTNode)x);
+    	final ASTNode an = ((ASTNode)x);
+    	if(an.getParent() == null && an.getAST() == ast)
+    		return x;
+    	else 
+    		return (IExtendedModifier)ASTNode.copySubtree(ast, an);
     }
 
     private boolean isExtendedModifierList(IStrategoTerm term) {
@@ -1353,7 +1262,7 @@
 
     private TypeParameter asTypeParameter(IStrategoTerm term) {
         TypeParameter x = ((WrappedTypeParameter)term).getWrappee();
-        return x.getParent() == null ? x : (TypeParameter)ASTNode.copySubtree(ast, x);
+        return x.getParent() == null && x.getAST() == ast ? x : (TypeParameter)ASTNode.copySubtree(ast, x);
     }
 
     @SuppressWarnings("unchecked")
@@ -1369,7 +1278,7 @@
 
     private TagElement asTagElement(IStrategoTerm term) {
     	TagElement x = ((WrappedTagElement)term).getWrappee(); 
-        return x.getParent() == null ? x : (TagElement)ASTNode.copySubtree(ast, x);
+        return x.getParent() == null && x.getAST() == ast ? x : (TagElement)ASTNode.copySubtree(ast, x);
     }
 
     @SuppressWarnings("unchecked")
@@ -1411,7 +1320,7 @@
 
     private AbstractTypeDeclaration asAbstractTypeDeclaration(IStrategoTerm term) {
         AbstractTypeDeclaration x = ((WrappedAbstractTypeDeclaration)term).getWrappee();
-        return x.getParent() == null ? x : (AbstractTypeDeclaration)ASTNode.copySubtree(ast, x);
+        return x.getParent() == null && x.getAST() == ast ? x : (AbstractTypeDeclaration)ASTNode.copySubtree(ast, x);
     }
 
     @SuppressWarnings("unchecked")
@@ -1436,12 +1345,12 @@
 
     private ImportDeclaration asImportDeclaration(IStrategoTerm term) {
         ImportDeclaration x = ((WrappedImportDeclaration)term).getWrappee();
-        return x.getParent() == null ? x : (ImportDeclaration)ASTNode.copySubtree(ast, x);
+        return x.getParent() == null && x.getAST() == ast ? x : (ImportDeclaration)ASTNode.copySubtree(ast, x);
     }
 
     private PackageDeclaration asPackageDeclaration(IStrategoTerm term) {
         PackageDeclaration x = ((WrappedPackageDeclaration)term).getWrappee();
-        return x.getParent() == null ? x : (PackageDeclaration)ASTNode.copySubtree(ast, x);
+        return x.getParent() == null && x.getAST() == ast ? x : (PackageDeclaration)ASTNode.copySubtree(ast, x);
     }
 
 
@@ -1457,7 +1366,7 @@
 
     private EnumConstantDeclaration asEnumConstantDeclaration(IStrategoTerm term) {
         EnumConstantDeclaration x = ((WrappedEnumConstantDeclaration)term).getWrappee();
-        return x.getParent() == null ? x : (EnumConstantDeclaration)ASTNode.copySubtree(ast, x);
+        return x.getParent() == null && x.getAST() == ast ? x : (EnumConstantDeclaration)ASTNode.copySubtree(ast, x);
     }
 
 
@@ -1473,12 +1382,12 @@
 
     private ASTNode asASTNode(IStrategoTerm term) {
         ASTNode x = ((WrappedASTNode)term).getWrappee();
-        return x.getParent() == null ? x : ASTNode.copySubtree(ast, x);
+        return x.getParent() == null && x.getAST() == ast ? x : ASTNode.copySubtree(ast, x);
     }
 
     private MethodRefParameter asMethodRefParameter(IStrategoTerm term) {
         MethodRefParameter x = ((WrappedMethodRefParameter)term).getWrappee();
-        return x.getParent() == null ? x : (MethodRefParameter)ASTNode.copySubtree(ast, x);
+        return x.getParent() == null && x.getAST() == ast ? x : (MethodRefParameter)ASTNode.copySubtree(ast, x);
     }
 
     @SuppressWarnings("unchecked")
@@ -1493,7 +1402,7 @@
 
     private MemberValuePair asMemberValuePair(IStrategoTerm term) {
         MemberValuePair x = ((WrappedMemberValuePair)term).getWrappee();
-        return x.getParent() == null ? x : (MemberValuePair)ASTNode.copySubtree(ast, x);
+        return x.getParent() == null && x.getAST() == ast ? x : (MemberValuePair)ASTNode.copySubtree(ast, x);
     }
 
     private Code asTypeCode(IStrategoTerm term) {
@@ -1506,7 +1415,7 @@
 
     private Name asName(IStrategoTerm term) {
         Name x = ((WrappedName)term).getWrappee();
-        return x.getParent() == null ? x : (Name)ASTNode.copySubtree(ast, x);
+        return x.getParent() == null && x.getAST() == ast ? x : (Name)ASTNode.copySubtree(ast, x);
     }
 
     @SuppressWarnings("unchecked")
@@ -1521,7 +1430,7 @@
 
     private AbstractTypeDeclaration asTypeDecl(IStrategoTerm term) {
         AbstractTypeDeclaration x = ((WrappedAbstractTypeDeclaration)term).getWrappee();
-        return x.getParent() == null ? x : (AbstractTypeDeclaration)ASTNode.copySubtree(ast, x);
+        return x.getParent() == null && x.getAST() == ast ? x : (AbstractTypeDeclaration)ASTNode.copySubtree(ast, x);
     }
 
     @SuppressWarnings("unchecked")
@@ -1536,27 +1445,27 @@
 
     private ArrayInitializer asArrayInitializer(IStrategoTerm term) {
         ArrayInitializer x = ((WrappedArrayInitializer)term).getWrappee();
-        return x.getParent() == null ? x : (ArrayInitializer)ASTNode.copySubtree(ast, x);
+        return x.getParent() == null && x.getAST() == ast ? x : (ArrayInitializer)ASTNode.copySubtree(ast, x);
     }
 
     private ArrayType asArrayType(IStrategoTerm term) {
         ArrayType x = ((WrappedArrayType)term).getWrappee();
-        return x.getParent() == null ? x : (ArrayType)ASTNode.copySubtree(ast, x);
+        return x.getParent() == null && x.getAST() == ast ? x : (ArrayType)ASTNode.copySubtree(ast, x);
     }
 
     private Type asType(IStrategoTerm term) {
         Type x = ((WrappedType)term).getWrappee();
-        return x.getParent() == null ? x : (Type)ASTNode.copySubtree(ast, x);
+        return x.getParent() == null && x.getAST() == ast ? x : (Type)ASTNode.copySubtree(ast, x);
     }
 
     private SingleVariableDeclaration asSingleVariableDeclaration(IStrategoTerm term) {
         SingleVariableDeclaration x = ((WrappedSingleVariableDeclaration)term).getWrappee();
-        return x.getParent() == null ? x : (SingleVariableDeclaration)ASTNode.copySubtree(ast, x);
+        return x.getParent() == null && x.getAST() == ast ? x : (SingleVariableDeclaration)ASTNode.copySubtree(ast, x);
     }
 
     private Block asBlock(IStrategoTerm term) {
         Block x = ((WrappedBlock)term).getWrappee();
-        return x.getParent() == null ? x : (Block)ASTNode.copySubtree(ast, x);
+        return x.getParent() == null && x.getAST() == ast ? x : (Block)ASTNode.copySubtree(ast, x);
     }
 
     private PrefixExpression.Operator asPrefixOperator(IStrategoTerm term) {
@@ -1585,7 +1494,7 @@
 
     private Expression asExpression(IStrategoTerm term) {
         Expression x = ((WrappedExpression) term).getWrappee();
-        return x.getParent() == null ? x : (Expression)ASTNode.copySubtree(ast, x);
+        return x.getParent() == null && x.getAST() == ast ? x : (Expression)ASTNode.copySubtree(ast, x);
     }
 
     private int asInt(IStrategoTerm term) {
@@ -1612,32 +1521,32 @@
 
     private BodyDeclaration asBodyDeclaration(IStrategoTerm k) {
         BodyDeclaration x = ((WrappedBodyDeclaration)k).getWrappee();
-        return x.getParent() == null ? x : (BodyDeclaration)ASTNode.copySubtree(ast, x);
+        return x.getParent() == null && x.getAST() == ast ? x : (BodyDeclaration)ASTNode.copySubtree(ast, x);
     }
 
     private SimpleName asSimpleName(IStrategoTerm term) {
         SimpleName x = ((WrappedSimpleName)term).getWrappee();
-        return x.getParent() == null ? x : (SimpleName)ASTNode.copySubtree(ast, x);
+        return x.getParent() == null && x.getAST() == ast ? x : (SimpleName)ASTNode.copySubtree(ast, x);
     }
 
     private Modifier asModifier(IStrategoTerm term) {
         Modifier x = ((WrappedModifier)term).getWrappee();
-        return x.getParent() == null ? x : (Modifier)ASTNode.copySubtree(ast, x);
+        return x.getParent() == null && x.getAST() == ast ? x : (Modifier)ASTNode.copySubtree(ast, x);
     }
 
     private VariableDeclarationFragment asVariableDeclarationFragment(IStrategoTerm term) {
     	VariableDeclarationFragment x = ((WrappedVariableDeclarationFragment)term).getWrappee();
-    	return x.getParent() == null ? x : (VariableDeclarationFragment) ASTNode.copySubtree(ast, x);
+    	return x.getParent() == null && x.getAST() == ast ? x : (VariableDeclarationFragment) ASTNode.copySubtree(ast, x);
     }
 
     private AnonymousClassDeclaration asAnonymousClassDeclaration(IStrategoTerm term) {
         AnonymousClassDeclaration x = ((WrappedAnonymousClassDeclaration)term).getWrappee();
-        return x.getParent() == null ? x : (AnonymousClassDeclaration) ASTNode.copySubtree(ast, x);
+        return x.getParent() == null && x.getAST() == ast ? x : (AnonymousClassDeclaration) ASTNode.copySubtree(ast, x);
     }
 
     private CatchClause asCatchClause(IStrategoTerm term) {
     	CatchClause x = ((WrappedCatchClause)term).getWrappee();
-    	return x.getParent() == null ? x : (CatchClause) ASTNode.copySubtree(ast, x);
+    	return x.getParent() == null && x.getAST() == ast ? x : (CatchClause) ASTNode.copySubtree(ast, x);
     }
 
     private String asString(IStrategoTerm term) {
@@ -1656,7 +1565,7 @@
 
     private Statement asStatement(IStrategoTerm term) {
         Statement x = ((WrappedStatement)term).getWrappee();
-        return x.getParent() == null ? x : (Statement)ASTNode.copySubtree(ast, x); 
+        return x.getParent() == null && x.getAST() == ast ? x : (Statement)ASTNode.copySubtree(ast, x); 
     }
 
     private boolean isAbstractTypeDeclarationList(IStrategoTerm term) {
@@ -1889,10 +1798,11 @@
 
     private boolean isTypeList(IStrategoTerm term) {
         if(term instanceof IStrategoList) {
-            IStrategoList list = (IStrategoList)term;
-            if(list.size() > 0) 
-                return isType(list.head());
-            return true;
+        	for(IStrategoTerm t : ((IStrategoList)term).getAllSubterms()) {
+        		if(!isType(t))
+        			return false;
+        	}
+        	return true;
         }
         return false;
     }
@@ -3132,6 +3042,8 @@
 			return wrap(((Boolean)o) ? 1 : 0);
 		if(o instanceof ASTNode)
 			return genericWrap((ASTNode)o);
+		if(o instanceof IType)
+			return wrap((IType)o);
 		
 		throw new NotImplementedException(" " + o.getClass());
 	}
@@ -3146,5 +3058,31 @@
 		else
 			return new WrappedIJavaElement(el);
 	}
-    
+
+	public static IStrategoAppl wrapSignature(String s) {
+		if(s == null)
+			return None.INSTANCE;
+		else
+			return new WrappedActualTypeSignature(s);
+		
+	}
+
+	public static IStrategoTerm wrapSignatures(String[] signatures) {
+		if(signatures == null)
+			return None.INSTANCE;
+		else {
+			IStrategoAppl[] ws = new WrappedActualTypeSignature[signatures.length];
+			for(int i = 0; i < signatures.length; i++)
+				ws[i] = wrapSignature(signatures[i]);
+			return new BasicStrategoArrayList(ws);
+		}
+
+	}
+
+	public static ASTMatcher getMatcher() {
+		if(astMatcher == null)
+			astMatcher = new ASTMatcher();
+		return astMatcher;
+	}
+
 }

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedASTNode.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedASTNode.java	2009-05-22 12:17:36 UTC (rev 19465)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedASTNode.java	2009-05-22 12:22:48 UTC (rev 19466)
@@ -2,6 +2,7 @@
 
 import org.eclipse.jdt.core.dom.ASTNode;
 import org.spoofax.interpreter.terms.IStrategoConstructor;
+import org.spoofax.interpreter.terms.IStrategoTerm;
 
 public abstract class WrappedASTNode extends AbstractECJAppl {
 
@@ -10,4 +11,11 @@
     }
 
     public abstract ASTNode getWrappee();
+    
+    @Override
+    public boolean match(IStrategoTerm second) {
+    	if(!(second instanceof WrappedASTNode))
+    		return false;
+    	return getWrappee().subtreeMatch(ECJFactory.getMatcher(), ((WrappedASTNode)second).getWrappee());
+    }
 }

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedActualTypeSignature.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedActualTypeSignature.java	                        (rev 0)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedActualTypeSignature.java	2009-05-22 12:22:48 UTC (rev 19466)
@@ -0,0 +1,38 @@
+package org.spoofax.interpreter.adapter.ecj;
+
+import org.eclipse.jdt.core.Signature;
+import org.spoofax.interpreter.terms.IStrategoConstructor;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+
+public class WrappedActualTypeSignature extends AbstractECJAppl {
+
+	private final String wrappee;
+    private final static IStrategoConstructor CTOR = new ASTCtor("ActualTypeSignature", 4);
+
+	protected WrappedActualTypeSignature(String signature) {
+		super(CTOR);
+		wrappee = signature;
+
+	}
+
+	@Override
+	public IStrategoTerm getSubterm(int index) {
+		switch(index) {
+		case 0:
+			return ECJFactory.wrap(Signature.getSignatureQualifier(wrappee));
+		case 1: 
+			return ECJFactory.wrap(Signature.getSignatureSimpleName(wrappee));
+		case 2: {
+			final String te = Signature.getTypeErasure(wrappee);
+			final String p = Signature.getSignatureQualifier(te);
+			final String n = Signature.getSignatureSimpleName(te);
+			return ECJFactory.wrap(p.isEmpty() ? n : p + "." + n);
+		}
+		case 3:
+			return ECJFactory.wrapSignatures(Signature.getTypeArguments(wrappee));
+		default:
+			throw new ArrayIndexOutOfBoundsException();
+		}
+	}
+
+}

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedITypeParameter.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedITypeParameter.java	2009-05-22 12:17:36 UTC (rev 19465)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedITypeParameter.java	2009-05-22 12:22:48 UTC (rev 19466)
@@ -9,13 +9,18 @@
 
 import org.eclipse.jdt.core.ITypeParameter;
 import org.eclipse.jdt.core.JavaModelException;
+import org.eclipse.jdt.core.Signature;
+import org.eclipse.jdt.core.dom.AST;
+import org.eclipse.jdt.core.dom.Name;
+import org.eclipse.jdt.core.dom.ParameterizedType;
+import org.eclipse.jdt.core.dom.Type;
 import org.spoofax.interpreter.terms.IStrategoConstructor;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 
 public class WrappedITypeParameter extends AbstractECJAppl {
 
     private final ITypeParameter wrappee;
-    private final static IStrategoConstructor CTOR = new ASTCtor("TypeParameter", 1);
+    private final static IStrategoConstructor CTOR = new ASTCtor("ITypeParameter", 2);
     
     WrappedITypeParameter(ITypeParameter wrappee) {
         super(CTOR);
@@ -30,8 +35,10 @@
     public IStrategoTerm getSubterm(int index) {
         switch(index) {
         case 0:
+        	return ECJFactory.wrap(wrappee.getElementName());
+        case 1:
         	try {
-        	return ECJFactory.wrap(wrappee.getBounds());
+        		return ECJFactory.wrap(wrappee.getBounds());
         	} catch(JavaModelException e) {
         		e.printStackTrace();
         		return None.INSTANCE;
@@ -39,5 +46,4 @@
         }
         throw new ArrayIndexOutOfBoundsException();
     }
-
 }

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/library/ecj/ECJLibrary.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/library/ecj/ECJLibrary.java	2009-05-22 12:17:36 UTC (rev 19465)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/library/ecj/ECJLibrary.java	2009-05-22 12:22:48 UTC (rev 19466)
@@ -64,6 +64,8 @@
         add(new ECJ_search_for_supertype_type_refs_in_hierarchy());
         add(new ECJ_unbacked_compilation_unit_for_type());
         add(new ECJ_create_package());
+        add(new ECJ_signature_to_type());
+        add(new ECJ_search_for_supertype_type_refs_no_generics());
     }
     
     public IProject getCurrentProject() {

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/library/ecj/ECJ_search_for_supertype_type_refs_in_hierarchy.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/library/ecj/ECJ_search_for_supertype_type_refs_in_hierarchy.java	2009-05-22 12:17:36 UTC (rev 19465)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/library/ecj/ECJ_search_for_supertype_type_refs_in_hierarchy.java	2009-05-22 12:22:48 UTC (rev 19466)
@@ -26,16 +26,18 @@
 import org.spoofax.interpreter.core.Tools;
 import org.spoofax.interpreter.library.AbstractPrimitive;
 import org.spoofax.interpreter.stratego.Strategy;
+import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.InlinePrinter;
 
 public class ECJ_search_for_supertype_type_refs_in_hierarchy extends AbstractPrimitive {
 
 	public ECJ_search_for_supertype_type_refs_in_hierarchy() {
-		super("ECJ_search_for_supertype_type_refs_in_hierarchy", 0, 2);
+		super("ECJ_search_for_supertype_type_refs_in_hierarchy", 1, 2);
 	}
 
 	@Override
-	public boolean call(IContext env, Strategy[] svars, IStrategoTerm[] tvars)
+	public boolean call(final IContext env, Strategy[] svars, IStrategoTerm[] tvars)
 	throws InterpreterException {
 
 		if(!ECJTools.isIType(tvars[0]))
@@ -43,13 +45,14 @@
 		if(!Tools.isTermString(tvars[1]))
 			return false;
 
-		// TODO: This only works in 3.4, what to do for other versions? 
+	// TODO: This only works in 3.4, what to do for other versions? 
 
 		// FIXME this method will currently only return exact type matches.
 		//       it is unclear whether searches for the supertype Foo<Object>
 		//       should also allow Foo<Bar> to be returned; for now, it's explicitly
 		//       forbidden
 
+		final Strategy acceptor = svars[0];
 		final String className = Tools.asJavaString(tvars[1]);
 		final SearchPattern sp = SearchPattern.createPattern(
 				className, 
@@ -69,11 +72,16 @@
 					IType t = (IType)match.getElement();
 					//System.out.println(" * " + t.getFullyQualifiedName());
 					for(String s : t.getSuperInterfaceTypeSignatures()) {
-						final String p = Signature.toString(s);
-						if(p.equals(className)) {
-							results.add(t);
-							return;
+						IStrategoAppl a = ECJFactory.wrapSignature(s);
+						try {
+							env.setCurrent(a);
+							if(acceptor.evaluate(env)) {
+								results.add(t);
+							}
+						} catch(InterpreterException e) {
+							// FIXME: log
 						}
+						
 					}
 				}
 

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/library/ecj/ECJ_search_for_supertype_type_refs_no_generics.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/library/ecj/ECJ_search_for_supertype_type_refs_no_generics.java	                        (rev 0)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/library/ecj/ECJ_search_for_supertype_type_refs_no_generics.java	2009-05-22 12:22:48 UTC (rev 19466)
@@ -0,0 +1,105 @@
+/*
+ * Created on 9. sep. 2008
+ *
+ * Copyright (c) 2005-2008, Karl Trygve Kalleberg <karltk at ii.uib.no>
+ * 
+ * Licensed under the GNU General Public License, v2
+ */
+package org.spoofax.interpreter.library.ecj;
+
+import java.util.Collection;
+import java.util.LinkedList;
+
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.jdt.core.IType;
+import org.eclipse.jdt.core.Signature;
+import org.eclipse.jdt.core.search.IJavaSearchConstants;
+import org.eclipse.jdt.core.search.IJavaSearchScope;
+import org.eclipse.jdt.core.search.SearchEngine;
+import org.eclipse.jdt.core.search.SearchMatch;
+import org.eclipse.jdt.core.search.SearchParticipant;
+import org.eclipse.jdt.core.search.SearchPattern;
+import org.eclipse.jdt.core.search.SearchRequestor;
+import org.spoofax.interpreter.adapter.ecj.ECJFactory;
+import org.spoofax.interpreter.core.IContext;
+import org.spoofax.interpreter.core.InterpreterException;
+import org.spoofax.interpreter.core.Tools;
+import org.spoofax.interpreter.library.AbstractPrimitive;
+import org.spoofax.interpreter.stratego.Strategy;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+
+public class ECJ_search_for_supertype_type_refs_no_generics extends AbstractPrimitive {
+
+	public ECJ_search_for_supertype_type_refs_no_generics() {
+		super("ECJ_search_for_supertype_type_refs_no_generics", 0, 2);
+	}
+
+	@Override
+	public boolean call(IContext env, Strategy[] svars, IStrategoTerm[] tvars)
+	throws InterpreterException {
+
+		if(!ECJTools.isIType(tvars[0]))
+			return false;
+		if(!Tools.isTermString(tvars[1]))
+			return false;
+
+		// TODO: This only works in 3.4, what to do for other versions? 
+
+		// FIXME this method will currently only return exact type matches.
+		//       it is unclear whether searches for the supertype Foo<Object>
+		//       should also allow Foo<Bar> to be returned; for now, it's explicitly
+		//       forbidden
+
+		final String className = Tools.asJavaString(tvars[1]).replaceAll("*", "[^,]+");
+		final SearchPattern sp = SearchPattern.createPattern(
+				className, 
+				IJavaSearchConstants.TYPE, 
+				IJavaSearchConstants.IMPLEMENTORS, //SUPERTYPE_TYPE_REFERENCE, 
+				SearchPattern.R_EXACT_MATCH | SearchPattern.R_CASE_SENSITIVE);
+
+
+		try { 
+			final IJavaSearchScope ss = SearchEngine.createHierarchyScope(ECJTools.asIType(tvars[0]));
+			final Collection<IType> results = new LinkedList<IType>();
+			final SearchRequestor requestor = new SearchRequestor() {
+
+				@Override
+				public void acceptSearchMatch(SearchMatch match) throws CoreException {
+					//System.out.println(match.getElement() + "/" + match.getClass().toString() + "/" + match.getElement().getClass().toString());
+					IType t = (IType)match.getElement();
+					//System.out.println(" * " + t.getFullyQualifiedName());
+					for(String s : t.getSuperInterfaceTypeSignatures()) {
+						final String p = Signature.toString(s);
+						int x = 0;
+						if(p.equals(className)) {
+							results.add(t);
+							return;
+						}
+					}
+				}
+
+			};
+
+			final SearchEngine se = new SearchEngine();
+	        final ECJLibrary ecj = (ECJLibrary)env.getOperatorRegistry(ECJLibrary.REGISTRY_NAME);
+
+
+			se.search(sp, 
+					new SearchParticipant[] { SearchEngine.getDefaultSearchParticipant() },
+					ss, 
+					requestor,
+					ecj.getNullProgressMonitor());
+			final IStrategoTerm[] r = new IStrategoTerm[results.size()];
+			int pos = 0;
+			for(IType t : results)
+				r[pos++] = ECJFactory.wrap(t);
+			env.setCurrent(env.getFactory().makeList(r));
+		} catch(CoreException e) {
+			e.printStackTrace();
+			return false;
+		}
+
+		return true;
+	}
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/library/ecj/ECJ_signature_to_type.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/library/ecj/ECJ_signature_to_type.java	                        (rev 0)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/library/ecj/ECJ_signature_to_type.java	2009-05-22 12:22:48 UTC (rev 19466)
@@ -0,0 +1,64 @@
+/*
+ * Created on 9. okt.. 2006
+ *
+ * Copyright (c) 2005, Karl Trygve Kalleberg <karltk at ii.uib.no>
+ * 
+ * Licensed under the GNU General Public License, v2
+ */
+package org.spoofax.interpreter.library.ecj;
+
+import org.eclipse.jdt.core.Signature;
+import org.eclipse.jdt.core.dom.AST;
+import org.eclipse.jdt.core.dom.Name;
+import org.eclipse.jdt.core.dom.ParameterizedType;
+import org.eclipse.jdt.core.dom.Type;
+import org.spoofax.NotImplementedException;
+import org.spoofax.interpreter.adapter.ecj.ECJFactory;
+import org.spoofax.interpreter.core.IContext;
+import org.spoofax.interpreter.core.InterpreterException;
+import org.spoofax.interpreter.core.Tools;
+import org.spoofax.interpreter.stratego.Strategy;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+
+public class ECJ_signature_to_type extends ECJPrimitive {
+
+    public ECJ_signature_to_type() {
+        super("ECJ_signature_to_type", 0, 1);
+    }
+    
+    @Override
+    public boolean call(IContext env, Strategy[] svars, IStrategoTerm[] tvars)
+            throws InterpreterException {
+    	
+    	if(!Tools.isTermString(tvars[0]))
+    		return false;
+    	
+    	final ECJFactory factory = (ECJFactory)env.getFactory();
+    	final Type t = signatureStringToType(
+    			factory.getAST(), 
+    			Signature.createTypeSignature(Tools.asJavaString(tvars[0]), false));
+    	env.setCurrent(ECJFactory.wrapType(t));
+    	return true;
+    	
+    }
+    
+	private Type signatureStringToType(final AST ast, final String signatureName) {
+		final String[] args = Signature.getTypeArguments(signatureName);
+		final String qual = Signature.getQualifier(signatureName);
+		final String base = Signature.getSignatureSimpleName(Signature.getTypeErasure(signatureName));
+		final Name n = qual.length() == 0 ? ast.newName(base) : ast.newName(qual + "." + base);
+
+		final Type bt = ast.newSimpleType(n);
+		if(args.length == 0) 
+			return bt;
+		else {
+			ParameterizedType pt = ast.newParameterizedType(bt);
+			for(String s : args) {
+				pt.typeArguments().add(signatureStringToType(ast, s));
+			}
+			return pt;
+		}
+	}
+
+
+}



From L.C.L.Kats at tudelft.nl  Tue May 26 10:39:25 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Tue, 26 May 2009 08:39:25 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19467 - LennartKats - in
	spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter:
	library/ssl stratego
Message-ID: <200905260838.n4Q8chcS028587@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-05-26 08:39:25 +0000 (Tue, 26 May 2009)
New Revision: 19467

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19467&view=rev

Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_fputs.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/All.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/CallT.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/ExtSDef.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/GuardedLChoice.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/Hook.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/Let.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/One.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/SDefT.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/Scope.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/Seq.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/Some.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/Strategy.java

Log:
Updated some of the interpreter classes to allow further public/protected access to their internals. Some fields made private with added accessors.

Changes:

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_fputs.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_fputs.java	2009-05-22 12:22:48 UTC (rev 19466)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_fputs.java	2009-05-26 08:39:25 UTC (rev 19467)
@@ -7,8 +7,7 @@
  */
 package org.spoofax.interpreter.library.ssl;
 
-import java.io.IOException;
-import java.io.OutputStream;
+import java.io.PrintStream;
 
 import org.spoofax.interpreter.core.IContext;
 import org.spoofax.interpreter.core.InterpreterException;
@@ -33,12 +32,8 @@
 
         SSLLibrary or = (SSLLibrary) env.getOperatorRegistry(SSLLibrary.REGISTRY_NAME);
         
-        OutputStream ous = or.getIOAgent().getOutputStream(Tools.asJavaInt(targs[1]));
-        try {
-            ous.write(Tools.javaString(targs[0]).getBytes());
-        } catch(IOException e) {
-            throw new InterpreterException(e);
-        }
+        PrintStream ous = or.getIOAgent().getOutputStream(Tools.asJavaInt(targs[1]));
+        ous.print(Tools.javaString(targs[0]));
         
         env.setCurrent(targs[1]);
         

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/All.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/All.java	2009-05-22 12:22:48 UTC (rev 19466)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/All.java	2009-05-26 08:39:25 UTC (rev 19467)
@@ -69,13 +69,13 @@
     	final All th = this;
     	body.getHook().push(new Hook(){
     		IStrategoTerm oldterm = old;
-    		IConstruct onSuccess(IContext env) throws InterpreterException
+    		public IConstruct onSuccess(IContext env) throws InterpreterException
     		{
     			list[i] = env.current();
     			env.setCurrent(oldterm);
     			return evalAll(env, i + 1, list);
     		}
-    		IConstruct onFailure(IContext env) throws InterpreterException
+    		public IConstruct onFailure(IContext env) throws InterpreterException
     		{
     			return th.getHook().pop().onFailure(env);
     		}

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/CallT.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/CallT.java	2009-05-22 12:22:48 UTC (rev 19466)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/CallT.java	2009-05-26 08:39:25 UTC (rev 19467)
@@ -19,11 +19,11 @@
 
 public class CallT extends Strategy {
 
-    protected final String name;
+    private final String name;
 
-    protected final Strategy[] svars;
+    private final Strategy[] svars;
 
-    protected final IStrategoTerm[] tvars;
+    private final IStrategoTerm[] tvars;
 
     private static int counter = 0;
 
@@ -49,7 +49,7 @@
             throw new InterpreterException("Not found '" + name + "'");
 
         if(DebugUtil.tracing) {
-            System.err.println("[" + depth + "] - " + sdef.name);
+            System.err.println("[" + depth + "] - " + sdef.getName());
             depth++;
         }
     
@@ -110,12 +110,12 @@
         final CallT th = this;
         Strategy body = sdef.getBody();
         body.getHook().push(new Hook(){
-        	IConstruct onSuccess(IContext env) throws InterpreterException {
+        	public IConstruct onSuccess(IContext env) throws InterpreterException {
                 env.restoreVarScope(oldVarScope);
                 env.getStackTracer().popOnSuccess();
         		return th.getHook().pop().onSuccess(env);
         	}
-        	IConstruct onFailure(IContext env) throws InterpreterException {
+        	public IConstruct onFailure(IContext env) throws InterpreterException {
         		env.restoreVarScope(oldVarScope);
         		env.getStackTracer().popOnFailure();
         		return th.getHook().pop().onFailure(env);
@@ -195,12 +195,12 @@
         final CallT th = this;
         Strategy body = sdef.getBody();
         body.getHook().push(new Hook(){
-        	IConstruct onSuccess(IContext env) throws InterpreterException {
+        	public IConstruct onSuccess(IContext env) throws InterpreterException {
                 env.restoreVarScope(oldVarScope);
                 env.getStackTracer().popOnSuccess();
         		return th.getHook().pop().onSuccess(env);
         	}
-        	IConstruct onFailure(IContext env) throws InterpreterException {
+        	public IConstruct onFailure(IContext env) throws InterpreterException {
         		env.restoreVarScope(oldVarScope);
         		env.getStackTracer().popOnFailure();
         		return th.getHook().pop().onFailure(env);
@@ -290,12 +290,12 @@
 	    class WithArgsHook extends Hook {
 	        boolean result;
             @Override
-            IConstruct onFailure(IContext env) throws InterpreterException {
+            public IConstruct onFailure(IContext env) throws InterpreterException {
                 result = false;
                 return null;
             }
             @Override
-            IConstruct onSuccess(IContext env) throws InterpreterException {
+            public IConstruct onSuccess(IContext env) throws InterpreterException {
                 result = false;
                 return null;
             }

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/ExtSDef.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/ExtSDef.java	2009-05-22 12:22:48 UTC (rev 19466)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/ExtSDef.java	2009-05-26 08:39:25 UTC (rev 19467)
@@ -18,7 +18,7 @@
 
     @Override
     public String toString() {
-        return "ExtSDefT(\"" + name + "\")";
+        return "ExtSDefT(\"" + getName() + "\")";
     }
 
     @Override

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/GuardedLChoice.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/GuardedLChoice.java	2009-05-22 12:22:48 UTC (rev 19466)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/GuardedLChoice.java	2009-05-26 08:39:25 UTC (rev 19467)
@@ -43,11 +43,11 @@
         	final Strategy second = children[n].second;
         	Strategy first = children[n].first;
         	first.getHook().push(new Hook(){
-        		IConstruct onSuccess(IContext env) {
+        		public IConstruct onSuccess(IContext env) {
                 	second.getHook().push(getHook().pop());
     				return second;
     			}
-    			IConstruct onFailure(IContext env) throws InterpreterException {
+        		public IConstruct onFailure(IContext env) throws InterpreterException {
     	        	env.setCurrent(oldCurrent);
     	        	env.getVarScope().restoreUnboundVars(bi);    				
     				return eval(env, n+1);

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/Hook.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/Hook.java	2009-05-22 12:22:48 UTC (rev 19466)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/Hook.java	2009-05-26 08:39:25 UTC (rev 19467)
@@ -9,6 +9,6 @@
 	{
 	}
 	
-	abstract IConstruct onSuccess(IContext env) throws InterpreterException;
-	abstract IConstruct onFailure(IContext env) throws InterpreterException;
+	public abstract IConstruct onSuccess(IContext env) throws InterpreterException;
+	public abstract IConstruct onFailure(IContext env) throws InterpreterException;
 }

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/Let.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/Let.java	2009-05-22 12:22:48 UTC (rev 19466)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/Let.java	2009-05-26 08:39:25 UTC (rev 19467)
@@ -49,12 +49,12 @@
         final Strategy th = this;
         body.getHook().push(new Hook(){
 			@Override
-			IConstruct onFailure(IContext env) throws InterpreterException {
+            public IConstruct onFailure(IContext env) throws InterpreterException {
 				env.popVarScope();
 				return th.getHook().pop().onFailure(env);
 			}
 			@Override
-			IConstruct onSuccess(IContext env) throws InterpreterException {
+            public IConstruct onSuccess(IContext env) throws InterpreterException {
 		        env.popVarScope();
 				return th.getHook().pop().onSuccess(env);
 			}

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/One.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/One.java	2009-05-22 12:22:48 UTC (rev 19466)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/One.java	2009-05-26 08:39:25 UTC (rev 19467)
@@ -55,12 +55,12 @@
     	env.setCurrent(list[n]);
     	body.getHook().push(new Hook(){
 			@Override
-			IConstruct onFailure(IContext env) throws InterpreterException {
+			public IConstruct onFailure(IContext env) throws InterpreterException {
 				env.setCurrent(old);
 				return eval(env, n+1, list);
 			}
 			@Override
-			IConstruct onSuccess(IContext env) throws InterpreterException {
+			public IConstruct onSuccess(IContext env) throws InterpreterException {
 				IStrategoTerm[] kids = old.getAllSubterms();
 				kids[n] = env.current();
 				switch (old.getTermType()) {

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/SDefT.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/SDefT.java	2009-05-22 12:22:48 UTC (rev 19466)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/SDefT.java	2009-05-26 08:39:25 UTC (rev 19467)
@@ -15,15 +15,15 @@
 import org.spoofax.interpreter.core.VarScope;
 
 public class SDefT implements IConstruct {
-    protected String name;
+    private String name;
 
-    protected SVar[] strategyArgs;
+    private SVar[] strategyArgs;
 
-    protected String[] termArgs;
+    private String[] termArgs;
 
-    protected Strategy body;
+    private Strategy body;
 
-    protected VarScope scope;
+    private VarScope scope;
 
     public static class SVar {
         public final String name;
@@ -85,6 +85,8 @@
         this.body = actual;
         this.scope = scope;
     }
+    
+    protected SDefT() {}
 
     public  IConstruct eval(IContext e) throws InterpreterException {
         //e.getVarScope().dump("", true);
@@ -94,18 +96,34 @@
     public String getName() {
         return name;
     }
+    
+    protected void setName(String name) {
+        this.name = name;
+    }
 
     public Strategy getBody() {
         return body;
     }
+    
+    protected void setBody(Strategy body) {
+        this.body = body;
+    }
 
     public String[] getTermParams() {
         return termArgs;
     }
+    
+    protected void setTermParams(String[] termArgs) {
+        this.termArgs = termArgs;
+    }
 
     public SVar[] getStrategyParams() {
         return strategyArgs;
     }
+    
+    protected void setStrategyParams(SVar[] strategyArgs) {
+        this.strategyArgs = strategyArgs;
+    }
 
     public VarScope getScope() {
         return scope;

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/Scope.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/Scope.java	2009-05-22 12:22:48 UTC (rev 19466)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/Scope.java	2009-05-26 08:39:25 UTC (rev 19467)
@@ -38,12 +38,12 @@
         final Strategy th = this;
         body.getHook().push(new Hook(){
 			@Override
-			IConstruct onFailure(IContext env) throws InterpreterException {
+			public IConstruct onFailure(IContext env) throws InterpreterException {
 				env.popVarScope();
 				return th.getHook().pop().onFailure(env);
 			}
 			@Override
-			IConstruct onSuccess(IContext env) throws InterpreterException {
+			public IConstruct onSuccess(IContext env) throws InterpreterException {
 		        env.popVarScope();
 				return th.getHook().pop().onSuccess(env);
 			}

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/Seq.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/Seq.java	2009-05-22 12:22:48 UTC (rev 19466)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/Seq.java	2009-05-26 08:39:25 UTC (rev 19467)
@@ -36,11 +36,11 @@
 		final Strategy th = this;
 		children[n].getHook().push(new Hook(){
 			@Override
-			IConstruct onFailure(IContext env) throws InterpreterException {
+			public IConstruct onFailure(IContext env) throws InterpreterException {
 				return th.getHook().pop().onFailure(env);
 			}
 			@Override
-			IConstruct onSuccess(IContext env) throws InterpreterException {
+			public IConstruct onSuccess(IContext env) throws InterpreterException {
 				return eval(env, n+1);
 			}
 		});

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/Some.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/Some.java	2009-05-22 12:22:48 UTC (rev 19466)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/Some.java	2009-05-26 08:39:25 UTC (rev 19467)
@@ -68,12 +68,12 @@
     	env.setCurrent(list[n]);
     	body.getHook().push(new Hook(){
 			@Override
-			IConstruct onFailure(IContext env) throws InterpreterException {
+			public IConstruct onFailure(IContext env) throws InterpreterException {
 				env.setCurrent(old);
 				return eval(env, n+1, hadsome, list);
 			}
 			@Override
-			IConstruct onSuccess(IContext env) throws InterpreterException {
+			public IConstruct onSuccess(IContext env) throws InterpreterException {
 				list[n] = env.current();
 				env.setCurrent(old);
 				return eval(env, n+1, true, list);

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/Strategy.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/Strategy.java	2009-05-22 12:22:48 UTC (rev 19466)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/stratego/Strategy.java	2009-05-26 08:39:25 UTC (rev 19467)
@@ -73,11 +73,11 @@
     	}
     	getHook().push(new Hook(){
 			@Override
-			IConstruct onFailure(IContext env) throws InterpreterException {
+			public IConstruct onFailure(IContext env) throws InterpreterException {
 				throw new Finished(false);
 			}
 			@Override
-			IConstruct onSuccess(IContext env) throws InterpreterException {
+			public IConstruct onSuccess(IContext env) throws InterpreterException {
 				throw new Finished(true);
 			}
     	});



From L.C.L.Kats at tudelft.nl  Tue May 26 12:20:47 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Tue, 26 May 2009 10:20:47 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19468 - LennartKats -
	in strategoxt/branches/strategoxt-annos: stratego-front/syn
	stratego-front/syn/attic stratego-libraries/tool-doc/lib
	strc-core/lib/stratego/strc/model
Message-ID: <200905261020.n4QAK42w030638@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-05-26 10:20:47 +0000 (Tue, 26 May 2009)
New Revision: 19468

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19468&view=rev

Modified:
   strategoxt/branches/strategoxt-annos/stratego-front/syn/Stratego-Core-Strategies.sdf
   strategoxt/branches/strategoxt-annos/stratego-front/syn/attic/Stratego-Strategies.sdf
   strategoxt/branches/strategoxt-annos/stratego-libraries/tool-doc/lib/Makefile.am
   strategoxt/branches/strategoxt-annos/strc-core/lib/stratego/strc/model/model.str

Log:


Changes:

Modified: strategoxt/branches/strategoxt-annos/stratego-front/syn/Stratego-Core-Strategies.sdf
===================================================================
--- strategoxt/branches/strategoxt-annos/stratego-front/syn/Stratego-Core-Strategies.sdf	2009-05-26 08:39:25 UTC (rev 19467)
+++ strategoxt/branches/strategoxt-annos/stratego-front/syn/Stratego-Core-Strategies.sdf	2009-05-26 10:20:47 UTC (rev 19468)
@@ -69,6 +69,7 @@
 
     "fail" 				  -> Strategy {cons("Fail")}
     "id" 				  -> Strategy {cons("Id")}
+    "override" 			  -> Strategy {cons("Override")}
 
     %% Match and build
 

Modified: strategoxt/branches/strategoxt-annos/stratego-front/syn/attic/Stratego-Strategies.sdf
===================================================================
--- strategoxt/branches/strategoxt-annos/stratego-front/syn/attic/Stratego-Strategies.sdf	2009-05-26 08:39:25 UTC (rev 19467)
+++ strategoxt/branches/strategoxt-annos/stratego-front/syn/attic/Stratego-Strategies.sdf	2009-05-26 10:20:47 UTC (rev 19468)
@@ -34,7 +34,6 @@
 
     "fail" 				  -> Strategy {cons("Fail")}
     "id" 				  -> Strategy {cons("Id")}
-    "override" 			  -> Strategy {cons("Override")}
 
     %% Abstraction
 

Modified: strategoxt/branches/strategoxt-annos/stratego-libraries/tool-doc/lib/Makefile.am
===================================================================
--- strategoxt/branches/strategoxt-annos/stratego-libraries/tool-doc/lib/Makefile.am	2009-05-26 08:39:25 UTC (rev 19467)
+++ strategoxt/branches/strategoxt-annos/stratego-libraries/tool-doc/lib/Makefile.am	2009-05-26 10:20:47 UTC (rev 19468)
@@ -7,7 +7,7 @@
 	$(SGLRI) --heuristic-filters on -p $(STRATEGOBOXTBL_UNINSTALLED) -i $< | $(METAEXPLODE) -o $@
 
 
-nobase_data_DATA = libstratego-tool-doc.rtree
+nobase_data_DATA = libstratego-tool-doc.rtree libstratego-tool-doc.ctree
 lib_LTLIBRARIES  = libstratego-tool-doc.la
 EXTRA_DIST = $(tooldoclib) $(tooldoclib:.str=.rtree) libstratego-tool-doc.rtree
 CLEANFILES = $(wildcard *.dep) 
@@ -36,3 +36,6 @@
 libstratego-tool-doc.rtree libstratego-tool-doc.c : $(tooldoclib:.str=.rtree) 
 	$(STRC_UNINSTALLED) $(STRINCLUDES) -c --library -i $(srcdir)/stratego-tool-doc.str -o libstratego-tool-doc.rtree --verbose 1 $(STRCFLAGS)
 	rm libstratego-tool-doc.str
+
+libstratego-tool-doc.ctree : $(tooldoclib:.str=.rtree) 
+	$(STRC_UNINSTALLED) $(STRINCLUDES) -F --library -i $(srcdir)/stratego-tool-doc.str -o libstratego-tool-doc.ctree --verbose 1 $(STRCFLAGS)

Modified: strategoxt/branches/strategoxt-annos/strc-core/lib/stratego/strc/model/model.str
===================================================================
--- strategoxt/branches/strategoxt-annos/strc-core/lib/stratego/strc/model/model.str	2009-05-26 08:39:25 UTC (rev 19467)
+++ strategoxt/branches/strategoxt-annos/strc-core/lib/stratego/strc/model/model.str	2009-05-26 10:20:47 UTC (rev 19468)
@@ -67,6 +67,9 @@
       end
     ; rules( ModDefinition :+ sig -> def )
 
+  mark-always-needed(|name,sarity,tarity) =
+    rules( AlwaysNeeded :+= (name,sarity,tarity) )
+
   /**
    * Remove all definitions for a given signature.
    *



From L.C.L.Kats at tudelft.nl  Wed May 27 13:02:03 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Wed, 27 May 2009 11:02:03 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19470 - LennartKats - in
	spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library:
	. ssl
Message-ID: <200905271101.n4RB1JMP015781@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-05-27 11:02:03 +0000 (Wed, 27 May 2009)
New Revision: 19470

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19470&view=rev

Added:
   spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_fflush.java
Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/IOAgent.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_write_term_to_stream_baf.java

Log:
- Added SSL_flush
- Don't fail when closing a stream for the second time
- No warning when writing a non-binary term

Changes:

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/IOAgent.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/IOAgent.java	2009-05-27 10:55:04 UTC (rev 19469)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/IOAgent.java	2009-05-27 11:02:03 UTC (rev 19470)
@@ -118,7 +118,7 @@
     public boolean closeRandomAccessFile(int fd) throws InterpreterException {
         OutputStream stream = outStreams.get(fd);
         if(stream == null)
-            return false;
+            return true; // already closed: be forgiving
         try {
             stream.close();
         } catch(IOException e) {

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_fflush.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_fflush.java	                        (rev 0)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_fflush.java	2009-05-27 11:02:03 UTC (rev 19470)
@@ -0,0 +1,45 @@
+/*
+ * Created on 11. jan.. 2007
+ *
+ * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
+ * 
+ * Licensed under the GNU General Public License, v2
+ */
+package org.spoofax.interpreter.library.ssl;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+import org.spoofax.interpreter.core.IContext;
+import org.spoofax.interpreter.core.InterpreterException;
+import org.spoofax.interpreter.core.Tools;
+import org.spoofax.interpreter.library.AbstractPrimitive;
+import org.spoofax.interpreter.stratego.Strategy;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+
+public class SSL_fflush extends AbstractPrimitive {
+
+    SSL_fflush() {
+        super("SSL_flush", 0, 1);
+    }
+    
+    @Override
+    public boolean call(IContext env, Strategy[] svars, IStrategoTerm[] tvars)
+            throws InterpreterException {
+
+        if(!Tools.isTermInt(tvars[0]))
+            return false;
+        
+        SSLLibrary or = (SSLLibrary) env.getOperatorRegistry(SSLLibrary.REGISTRY_NAME);
+        OutputStream stream = or.getIOAgent().getOutputStream(Tools.asJavaInt(tvars[0]));
+        if (stream == null) return false;
+        
+        try {
+            stream.flush();
+            return true;
+        } catch (IOException e) {
+            return false;
+        }
+    }
+
+}

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_write_term_to_stream_baf.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_write_term_to_stream_baf.java	2009-05-27 10:55:04 UTC (rev 19469)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_write_term_to_stream_baf.java	2009-05-27 11:02:03 UTC (rev 19470)
@@ -36,8 +36,6 @@
         OutputStream os = or.getIOAgent().getOutputStream(Tools.asJavaInt(tvars[0]));
         if(os == null)
             return false;
-
-        System.err.println("warning: Only writing of text ATerms is supported on this platform");
         
         try {
             env.getFactory().unparseToFile(tvars[1], os);



From L.C.L.Kats at tudelft.nl  Wed May 27 13:17:02 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Wed, 27 May 2009 11:17:02 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19473 - LennartKats -
	spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
Message-ID: <200905271116.n4RBGIuN016195@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-05-27 11:17:02 +0000 (Wed, 27 May 2009)
New Revision: 19473

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19473&view=rev

Modified:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Tools.java

Log:
Don't eagerly initialize .jsglr-log

Changes:

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Tools.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Tools.java	2009-05-27 11:12:31 UTC (rev 19472)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Tools.java	2009-05-27 11:17:02 UTC (rev 19473)
@@ -16,7 +16,7 @@
 public class Tools {
     
     private static OutputStream fos;
-    private static String outfile = null;
+    private static String outfile = ".jsglr-log";
 
     static boolean debugging = false;
     static boolean logging = false;
@@ -25,10 +25,6 @@
     static int timeout = 0;
     
     private static Measures measures;
-
-    static {
-    	initOutput();
-    }
     
     public static void setOutput(String d) {
         outfile = d;
@@ -38,8 +34,6 @@
     private static void initOutput() {
         if(fos == null) {
             try {
-                if(outfile == null)
-                    outfile = ".jsglr-log";
                 fos = new BufferedOutputStream(new FileOutputStream(outfile));
             } catch (FileNotFoundException e) {
                 e.printStackTrace();
@@ -56,13 +50,17 @@
     }
 
     public static void logger(Object ...s) {
-        try {
-            for(Object o : s)
-                fos.write(o.toString().getBytes());
-            fos.write("\n".getBytes());
-            fos.flush();
-        } catch (IOException e) {
-            e.printStackTrace();
+        if (logging) {
+            if (fos == null)
+                initOutput();
+            try {
+                for(Object o : s)
+                    fos.write(o.toString().getBytes());
+                fos.write("\n".getBytes());
+                fos.flush();
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
         }
     }
  



From L.C.L.Kats at tudelft.nl  Wed May 27 15:59:16 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Wed, 27 May 2009 13:59:16 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19474 - LennartKats -
	spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl
Message-ID: <200905271358.n4RDwWHb018782@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-05-27 13:59:16 +0000 (Wed, 27 May 2009)
New Revision: 19474

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19474&view=rev

Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_mkdir.java

Log:
C version of SSL_mkdir ignores 'mode' argument. Let's do that here as well.

Changes:

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_mkdir.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_mkdir.java	2009-05-27 11:17:02 UTC (rev 19473)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_mkdir.java	2009-05-27 13:59:16 UTC (rev 19474)
@@ -21,15 +21,18 @@
             throws InterpreterException {
 
         if (!Tools.isTermString(tvars[0])) return false;
+        // if (!Tools.isTermList(tvars[1])) return false;
         
         SSLLibrary op = (SSLLibrary) env.getOperatorRegistry(SSLLibrary.REGISTRY_NAME);
+        int result = op.getIOAgent().mkdir(Tools.asJavaString(tvars[0])) ? 0 : -1;
+        
+        /* access parameter is ignored in C version
         AbstractPrimitive access = op.get("SSL_access");
         
-        int result = op.getIOAgent().mkdir(Tools.asJavaString(tvars[0])) ? 0 : -1;
-        
         if (result == 0) { // Set access rights
             result = access.call(env, svars, tvars) ? 0 : -1;
         }
+        */
         
         env.setCurrent(env.getFactory().makeInt(result));
         



From L.C.L.Kats at tudelft.nl  Wed May 27 16:03:53 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Wed, 27 May 2009 14:03:53 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19475 - LennartKats -
	in strc-java/trunk/trans: . lib
Message-ID: <200905271403.n4RE39Y5019033@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-05-27 14:03:53 +0000 (Wed, 27 May 2009)
New Revision: 19475

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19475&view=rev

Modified:
   strc-java/trunk/trans/Makefile.am
   strc-java/trunk/trans/backend-simplify.str
   strc-java/trunk/trans/java-postprocess.str
   strc-java/trunk/trans/lib/dr-scoping.str
   strc-java/trunk/trans/s2j-options.str
   strc-java/trunk/trans/s2j.str
   strc-java/trunk/trans/split-large-strategies.str
   strc-java/trunk/trans/strj.str

Log:
- Added libstratego-tooldoc
- Added -la java-front option that doesn't require an import dir
- Split up >64K "init" methods
- Minor fixes and tweaks to the generator


Changes:

Modified: strc-java/trunk/trans/Makefile.am
===================================================================
--- strc-java/trunk/trans/Makefile.am	2009-05-27 13:59:16 UTC (rev 19474)
+++ strc-java/trunk/trans/Makefile.am	2009-05-27 14:03:53 UTC (rev 19475)
@@ -39,10 +39,10 @@
 	$(SCOMPILE) $(STRINCLUDES) $(STRCFLAGS) $(SCFLAGS) -i $< -o $@ -F -m main-strj
 
 strj.java : strj.ctree strj
-	./strj -i $< -o $@ -la org.strategoxt.libstratego_lib -la org.strategoxt.libstratego_xtc -la org.strategoxt.libstratego_gpp -la org.strategoxt.libstrc -la org.strategoxt.libjava_front -m main-strj
+	./strj -i $< -o $@ -la stratego-lib -la stratego-xtc -la stratego-gpp -la strc -la java-front -m main-strj
 
 %.java : %.str strj
-	./strj -i $< -o $@ --verbose 2 -la org.strategoxt.libstratego_lib
+	./strj -i $< -o $@ --verbose 2 -la stratego-lib -la java-front
 
 %.class : %.java
 	$(JAVAC) $(JAVACFLAGS) $<

Modified: strc-java/trunk/trans/backend-simplify.str
===================================================================
--- strc-java/trunk/trans/backend-simplify.str	2009-05-27 13:59:16 UTC (rev 19474)
+++ strc-java/trunk/trans/backend-simplify.str	2009-05-27 14:03:53 UTC (rev 19475)
@@ -31,7 +31,9 @@
 rules
 
   remove-closure-allocs =
-    alltd(remove-closure-alloc-let)
+    {| RemoveClosureAlloc :
+      alltd(remove-closure-alloc-let)
+    |}
   
   remove-closure-alloc-let :
     Let(def*, s) -> Let(def'*, s')

Modified: strc-java/trunk/trans/java-postprocess.str
===================================================================
--- strc-java/trunk/trans/java-postprocess.str	2009-05-27 13:59:16 UTC (rev 19474)
+++ strc-java/trunk/trans/java-postprocess.str	2009-05-27 14:03:53 UTC (rev 19475)
@@ -8,6 +8,14 @@
 imports
   libjava-front
 
+overlays
+
+  /**
+   * Minimum number of statements in an init method required to split it up,
+   * in order to circumvent the 64K method size limit.
+   */
+  LARGE_METHOD_SIZE = 600
+
 strategies
 
   java-relabel =
@@ -50,6 +58,40 @@
 
 strategies
 
+  java-split-method =
+    try(java-split-method' <+ ![<id>])
+
+  java-split-method' :
+    class-body-dec |[
+      mod* t x(param*) {
+        bstm*
+      }
+    ]| ->
+    class-body-dec* |[ 
+      ~*<java-split-method> |[
+        mod* t x(param*) {
+          x'(e_param*);
+          bstm2*
+        }
+      ]|
+
+      mod2* t x'(param*) {
+        bstm1*
+      }
+    ]|
+    where
+      <gt> (<length> bstm*, LARGE_METHOD_SIZE())
+    with
+      x'               := <newname> x
+    ; e_param*         := <map(java-param-to-arg)> param*
+    ; mod2*            := <map(try(\<Public + Protected> -> Private()\))> mod*
+    ; (bstm1*, bstm2*) := <split-at(|LARGE_METHOD_SIZE())> bstm*
+
+  java-param-to-arg :
+    param |[ t x ]| -> expr |[ x ]|
+
+strategies
+
   java-simplify =
     topdown-consnil(
       try(Block(flatten-list))
@@ -63,7 +105,7 @@
     ?[_ | _] < [s | s] + all(s)
   
   java-simplify-stm :
-    [Empty() | s*] -> s*
+    [<Empty + Semicolon> | s*] -> s*
   
   java-simplify-stm :
     If(e, s1, Empty()) -> If(e, s1)
@@ -98,7 +140,7 @@
     topdown-consnil(try(
       optimize-match-test
     ))
-  ; topdown(try( // should be done after previous pass
+  ; bottomup(repeat( // should be done after previous pass
       optimize-if-true-break
     ))
 
@@ -120,12 +162,13 @@
         ? ((IStrategoAppl) term).getConstructor()
         : null;
       Success: {
-        Fail: {
-          if (x_actualcons != x_cons) break Fail;
-          bstm_decl*
-          bstm_body*
+        if (x_actualcons == x_cons) {
+          Fail: {
+            bstm_decl*
+            bstm_body*
+          }
+          term = x_cached;
         }
-        term = x_cached;
         bstm_othermatch'*
       }
       bstm_tail*
@@ -149,28 +192,19 @@
     ]| ->
     bstm* |[
       Success: {
-        Fail: {
-          if (x_actualcons != x_cons) break Fail;
-          bstm_decl*
-          bstm_body*
-         }
-        term = x_cached;
+        if (x_actualcons == x_cons) {
+          Fail: {
+            bstm_decl*
+            bstm_body*
+           }
+          term = x_cached;
+        }
         bstm_othermatch'*
       }
       bstm_tail*
     ]|
     with
       bstm_othermatch'* := <try(replace-match-test1(|x_actualcons, x_cached))> bstm_othermatch*
-
-  replace-match-test1(|x_actualcons) :
-    bstm* |[
-      ~*<match-decls-and-appl-test => (bstm_decl*, x_cons, bstm_body*)>
-    ]| ->
-    bstm* |[
-      if (x_actualcons != x_cons) break Fail;
-      bstm_decl*
-      bstm_body*
-    ]|
   
   match-decls-and-appl-test :
     bstm* |[ IStrategoTerm x = null; bstm* ]| -> ([<Hd> | bstm_decl*], x_cons, bstm_body*)
@@ -179,13 +213,34 @@
     
   match-decls-and-appl-test :
     bstm* |[
-      if (~e:ExprName(Id("term")).getTermType() != IStrategoTerm.APPL || x_cons != ((IStrategoAppl) term).getConstructor())
+      if (~e:ExprName(Id("term")).getTermType() != IStrategoTerm.APPL || e_cons != ((IStrategoAppl) term).getConstructor())
         break Fail;
       bstm_body*
     ]| ->
     ([], x_cons, bstm_body*)
-    
+    with
+      !e_cons => |[ x.x_cons ]|
+    <+
+      !e_cons => |[ x_cons ]|
+
   optimize-if-true-break :
+    bstm |[ { Fail: { if (TRUE) break Success; } bstm* } ]| -> |[ if (TRUE) break Success; ]|
+  
+  optimize-if-true-break :
+    bstm |[ if (e) if (TRUE) stm ]| -> |[ if (e) stm ]|
+  
+  optimize-if-true-break :
+    bstm |[ Success: { if (e) break Success; bstm* } ]| -> |[ if (!e) { bstm* } ]|
+  
+  optimize-if-true-break :
+    bstm |[ if (!(e1 == e2)) stm ]| -> |[ if (e1 != e2) stm ]|
+  
+  optimize-if-true-break :
+    bstm |[ if (e1) { if (e2) stm } ]| -> |[ if (e1 && e2) stm ]|
+    where
+      not(!e2 => expr |[ TRUE ]|)
+  
+  optimize-if-true-break :
     |[ Fail: { bstm* } ]| -> |[ Fail: { bstm'* } ]|
     where
       !bstm*

Modified: strc-java/trunk/trans/lib/dr-scoping.str
===================================================================
--- strc-java/trunk/trans/lib/dr-scoping.str	2009-05-27 13:59:16 UTC (rev 19474)
+++ strc-java/trunk/trans/lib/dr-scoping.str	2009-05-27 14:03:53 UTC (rev 19475)
@@ -9,25 +9,29 @@
 strategies
 
   dr-scope-all-verbose(s) =
-    dr-scope-all-start
-  ; s
-  <+
-    stack := <prim("SSL_stacktrace_get_all_frame_names")>
-  ; if if-verbose3(?true); !true then
-      !stack
-    ; report-failure(
-        log(|Error(), ["Compilation failed (", <run-time ; real-to-string(|2)>, " secs)"])
-      ; <exit> 1
-      )
-    else
-      dr-scope-all-end; fail
-    end
+    {| DrScopedRules :
+      dr-scope-all-start
+    ; s
+    <+
+      stack := <prim("SSL_stacktrace_get_all_frame_names")>
+    ; if if-verbose3(?true); !true then
+        !stack
+      ; report-failure(
+          log(|Error(), ["Compilation failed (", <run-time ; real-to-string(|2)>, " secs)"])
+        ; <exit> 1
+        )
+      else
+        dr-scope-all-end; fail
+      end
+    |}
 
   dr-scope-all(s) =
-    finally(
-      dr-scope-all-start; s
-    , dr-scope-all-end
-    )
+    {| DrScopedRules :
+      finally(
+        dr-scope-all-start; s
+      , dr-scope-all-end
+      )
+    |}
 
   dr-scope-all-start =
     where(
@@ -53,4 +57,3 @@
         }
       )
     )
-

Modified: strc-java/trunk/trans/s2j-options.str
===================================================================
--- strc-java/trunk/trans/s2j-options.str	2009-05-27 13:59:16 UTC (rev 19474)
+++ strc-java/trunk/trans/s2j-options.str	2009-05-27 14:03:53 UTC (rev 19475)
@@ -38,7 +38,7 @@
       "--stacktrace" + "-s"
     , <set-config> ("--stacktrace", <string-to-int; (0 + 1 + 2)>); !()
     , <conc-strings> ("--stacktrace i | -s i  Enable stacktracing ",
-                      "(0 = no, 1 = yes [default], 2 = only if assertions disabled for this class)")
+                      "(0 = no, 1 = always [default], 2 = only if assertions (java -ea) disabled for a class)")
     )
   + ArgOption(
       "-D"
@@ -57,7 +57,7 @@
     )
     
   translate-default-library =
-    if "stratego-lib" + "stratego-xtc" + "stratego-sglr" + "stratego-rtg" + "stratego-aterm" + "stratego-gpp" + "strc" then
+    if "stratego-lib" + "stratego-xtc" + "stratego-sglr" + "stratego-rtg" + "stratego-aterm" + "stratego-gpp" + "strc" + "stratego-tool-doc" + "java-front" then
       <conc-strings> ("org.strategoxt.lib", <id>)
     end
   ; if not(is-substring(!".")) then

Modified: strc-java/trunk/trans/s2j.str
===================================================================
--- strc-java/trunk/trans/s2j.str	2009-05-27 13:59:16 UTC (rev 19474)
+++ strc-java/trunk/trans/s2j.str	2009-05-27 14:03:53 UTC (rev 19475)
@@ -120,14 +120,27 @@
        if (constantFactory == termFactory)
          return;
        constantFactory = termFactory;
+       initConstructors(termFactory);
+       initConstants(termFactory);
        ~*import-inits
-       ~*cnstr-inits
-       ~*cnst-inits
        ~*def-inits
        context.postInit("~x_name");
      }
+     
+     ~*<java-split-method> |[
+       private static void initConstructors(ITermFactory termFactory) {
+         ~*cnstr-inits
+       }
+     ]|
+     
+     ~*<java-split-method> |[
+       private static void initConstants(ITermFactory termFactory) {
+         ~*cnst-inits
+       }
+     ]|
 
      ~*main
+     ~*register
      ~*constant
 
      ~*constant-defs
@@ -143,6 +156,7 @@
     ; x_name        := <MainClassName>
     ; pkgname       := <!package-dec? |[ package ~x:<get-config> "-p"; ]| <+ !None()>
     ; main          := <java-main-methods>
+    ; register      := <java-register-method> defs
     ; constant      := <java-constant-methods>
     ; switch <get-config> "--stacktrace"
         case 0: e_traces := |[ false ]|
@@ -189,6 +203,7 @@
     _ -> []
     where
       <get-config> "--library"
+    ; not(<get-config> "-m")
 
   java-main-methods :
     _ ->
@@ -224,7 +239,7 @@
      }
     ]|
     where
-      not(<get-config> "--library")
+      <get-config> "-m" <+ not(<get-config> "--library")
     with
       x_name := <MainClassName>
     ; main   := <get-config <+ !"main"> "-m"
@@ -252,7 +267,22 @@
         }
       }
     ]|
+  
+  java-register-method :
+    defs ->
+    <java-split-method> |[
+      public static void registerInterop(org.spoofax.interpreter.core.IContext context, Context compiledContext) {
+        init(compiledContext);
+        bstm*
+      }
+    ]|
+    with
+      bstm* := <filter(java-register-strategy)> defs
 
+  java-register-strategy :
+    SDefT(x,_,_,_) ->
+    |[ context.getVarScope().addSVar("~x", new InteropStrategyDef(x.class, context, compiledContext)); ]|
+
 rules
 
   translate-constant-definition : // TODO: check if contant definition name not taken
@@ -295,11 +325,14 @@
       x' := <conc-strings> (x, "_override")
     ; rules(DefInit :+= |[ x.instance = new x'(); ]|)
     with
-      e_s*      := <translate-args> s*
-    ; e_t*      := <translate-args> t*
-    ; outercall := |[ term = outer.invoke(context, term, e_s*, e_t*); ]|
-    ; def'      := <alltd(\Override() -> outercall\)> def
-    ; body      := <translate-definition-body> def'
+      {| OuterInvoke :
+        e_s* := <translate-args> s*
+      ; e_t* := <translate-args> t*
+      ; rules(
+          OuterInvoke := |[ outer.invoke(context, term, e_s*, e_t*) ]|
+        )
+      ; body := <translate-definition-body> def
+      |}
 
   translate-outer-definition-extend :
     AnnoDef([Extend()], def @ SDefT(x, s*, t*, s)) ->
@@ -314,11 +347,15 @@
       x' := <conc-strings> (x, "_extension")
     ; rules(DefInit :+= |[ x.instance = new x'(); ]|)
     with
-      e_s*      := <translate-args> s*
-    ; e_t*      := <translate-args> t*
-    ; outercall := |[ term = outer.invoke(context, term, e_s*, e_t*); ]|
-    ; def'      := SDefT(x, s*, t*, GuardedLChoice(s, Id(), Escape(outercall)))
-    ; body      := <translate-definition-body> def'
+      {| OuterInvoke :
+        e_s* := <translate-args> s*
+      ; e_t* := <translate-args> t*
+      ; def' := SDefT(x, s*, t*, GuardedLChoice(s, Id(), Override()))
+      ; rules(
+          OuterInvoke := |[ outer.invoke(context, term, e_s*, e_t*) ]|
+        )
+      ; body := <translate-definition-body> def'
+      |}
 
   translate-outer-definition-internal :
     AnnoDef([Internal()], def @ SDefT(x, s*, t*, s)) ->
@@ -415,7 +452,8 @@
        }
     ]|
     with
-      {| IsStrategyArg, java-CheckBuild, CurrentLiftedFrame:
+      {| IsStrategyArg, java-CheckBuild, CurrentLiftedFrame, java-CheckBuild,
+         IsLiftedTVar, IsLiftedSVar, LiftedTVars, LiftedSVars:
         (s'*, [])          := <translate-params> s*
       ; (t'*,  bstm_init*) := <translate-params> t*
       ; param*             := <conc> (s'*, t'*)   
@@ -492,7 +530,15 @@
     Fail() -> |[ if (TRUE) break Fail; ]| // (avoid unreachable stm error)
 
   translate-Override :
-    Override() -> <fatal-err(|"override call illegal in this context")>
+    Override() ->
+    bstm* |[
+      term = e_outer;
+      if (term == null) break Fail;
+    ]|
+    with
+      e_outer := <OuterInvoke>
+    <+
+      fatal-err(|"override call illegal in this context")
 
   translate-Escape :
     Escape(java) -> java
@@ -573,10 +619,12 @@
   translate-Let : 
     Let(defs, body) -> body'
     with
-      !defs
-    ; record-inner-definitions
-    ; list-loop(rules(LiftedDef :+= <translate-inner-definition>))
-    ; body' := <translate-strategy> body
+      {| InnerDefinition :
+        !defs
+      ; record-inner-definitions
+      ; list-loop(rules(LiftedDef :+= <translate-inner-definition>))
+      ; body' := <translate-strategy> body
+      |}
 
   record-inner-definitions =
     list-loop({
@@ -834,9 +882,6 @@
  */
 rules
 
-  // TODO: Fix constants being generated multiple times
-  //       e.g., <conc> ([], []) does this; it's got something to do with annos 
-
   /** @type Term -> Exp */
   java-construct-term =
        java-Cache 
@@ -872,11 +917,11 @@
     Op("Nil", [])
     + Op("Cons", [id, java-proper-list])
     // UNDONE: + Op("Cons", [id, java-proper-list + ?|[ getConstant(e1, e2) ]|])
+    // TODO: Fix constants being generated multiple times
+    //       e.g., <conc> ([], []) does this; it's got something to do with annos 
     + Op(id, id)
       ; not(is-ListOp)
 
-// helpers
-
 strategies
     
   is-TupleOp = ?Op("", _)
@@ -1024,15 +1069,18 @@
 strategies
 
   JavaTranslate =
-      rules(ConstructorDecl :+= <JavaDeclareConstructor>)
-    ; rules(ConstructorInit :+= <JavaInitConstructorQ <+ JavaInitConstructor>)
+      ?OpDecl(c, t)
+    ; rules(
+        ConstructorDecl :+= <JavaDeclareConstructor>
+        ConstructorInit :+= <JavaInitConstructorQ <+ JavaInitConstructor>
+      )
 
   JavaDeclareConstructor :
     OpDecl(c, t) -> class-body-dec|[ public static IStrategoConstructor x; ]|
   where
     not(OpDecl("", id) + OpDecl("Cons", [id, id]) + OpDecl("Nil", []))
   with 
-    n := <Arity> t
+    n := <Arity <+ is-int> t
   ; x := <java-ConstructorName> (c, n)
   ; rules(IsLocalOpDecl: (c, n))
 
@@ -1043,12 +1091,22 @@
     ; n' := <int-to-string> n
   
   java-ConstructorName-expr =
-    if IsLocalOpDecl then
-      with(x_main := <MainClassName>)
-    ; !expr |[ x_main.~x:<java-ConstructorName> ]|
-    else
-      !expr |[ ~x:<java-ConstructorName> ]|
-    end
+    with(
+      IsLocalOpDecl
+    <+
+      // HACK: locally redefine external constructors to avoid ambiguous imports
+      //       (should this be done for congruences as well?)
+      JavaCopyConstructor
+    )
+  ; !expr |[ ~x:<MainClassName>.~x:<java-ConstructorName> ]|
+  
+  JavaCopyConstructor =
+    ((c, n) -> OpDecl(c, n))
+  ; rules(
+      IsLocalOpDecl: (c, n)
+      ConstructorDecl :+= <oncetd(\Public() -> Protected()\)> <JavaDeclareConstructor>
+      ConstructorInit :+= <JavaInitConstructorQ <+ JavaInitConstructor>
+    )
 
   JavaInitConstructorQ :
     OpDecl(c, t) ->
@@ -1058,7 +1116,7 @@
     ]|
   where 
       <string-as-chars(unescape-chars; un-double-quote-chars)> c => c' 
-    ; ar := <Arity> t
+    ; ar := <Arity <+ is-int> t
     ; x  := <java-ConstructorName> (c, ar)
 
   JavaInitConstructor :
@@ -1067,9 +1125,13 @@
       x = termFactory.makeConstructor("~c", ~expr:<java-mk-int-const> ar);
     ]|
   where 
-      ar := <Arity> t
+      ar := <Arity <+ is-int> t
     ; x  := <java-ConstructorName> (c, ar)
   
+  /**
+   * Locally redefines some standard list and Some/None constructors,
+   * which appear in nearly every grammar.
+   */
   add-default-constructors =
     with(
       add-private-constructor(|"Some", 1)
@@ -1081,9 +1143,8 @@
     if not(<IsLocalOpDecl> (name, arity)) then
       x := <java-ConstructorName> (name, arity)
     ; rules(
+        IsLocalOpDecl: (name, arity)
         ConstructorDecl :+= class-body-dec|[ public static IStrategoConstructor x; ]|
-      )
-    ; rules(
         ConstructorInit :+=
           |[ x = termFactory.makeConstructor("~name", ~expr:<java-mk-int-const> arity); ]|
       )
@@ -1115,24 +1176,24 @@
       stm_assign := <java-VarToWrite> (x, trm)
 
   translate-Match :
-    Match(Var(x){"bound"}, trm) ->
-    stm|[ 
-      if(!e.match(~expr:trm)) 
+    Match(Var(x){"bound"}, e) ->
+    stm |[
+      if (e != e_var && !e_var.match(e)) 
         break Fail;
      ]|
     with
-      e := <java-VarToReadRef> Var(x)
+      e_var := <java-VarToReadRef> Var(x)
 
   translate-Match :
     Match(Var(x){"(un)bound"}, e) ->
-    stm|[ 
-      if (e_x == null)
+    stm |[
+      if (e_var == null)
         stm_assign
-      else if (!e_x.match(e))
+      else if (e_var != e && !e_var.match(e))
         break Fail;
     ]|
     with 
-      e_x := <java-VarToReadRef> Var(x)
+      e_var      := <java-VarToReadRef> Var(x)
     ; stm_assign := <java-VarToWrite> (x, e)
 
   translate-Match :
@@ -1177,9 +1238,8 @@
     ; stm0 := <translate-Match> Match(pt1, e)
     ; stm1 := <translate-Match> Match(pt2, ExprName(Id(x)))
 
-  /**
-   * @todo  String constants should probably be cached, just like constructor names
-   */
+  // String constants are not cached for comparison,
+  // since we do comparison modulo annotations
   translate-Match :
     Match(Str(str), e) -> 
     stm|[
@@ -1219,23 +1279,23 @@
   translate-Match :
     Match(op at Op(c, ts), e) ->
     bstm* |[
-      // (this pattern is matched optimized in java-postprocess)
+      // (this pattern is matched and optimized in java-postprocess)
       if (e.getTermType() != IStrategoTerm.APPL || e_nomatch) break Fail;
       ~bstm*:match-args
     ]|
   where
     <not(is-ListOp + is-TupleOp)> op
   with
-    x_cons     := <java-ConstructorName> (c, <length> ts)
+    e_cons     := <java-ConstructorName-expr> (c, <length> ts)
   ; match-args := <translate-Match-args> (e, ts)
   ; if not(<get-config> "-sc" => "off") then
-      e_nomatch := |[ x_cons != ((IStrategoAppl) e).getConstructor() ]|
+      e_nomatch := |[ e_cons != ((IStrategoAppl) e).getConstructor() ]|
     else
-      e_nomatch := |[ !x_cons.equals(((IStrategoAppl) e).getConstructor()) ]|
+      e_nomatch := |[ !e_cons.equals(((IStrategoAppl) e).getConstructor()) ]|
     end
 
   /**
-   * Translate a match of an Op, but not a Cons/2 or Nil/0.
+   * Translate a match of a tuple.
    */
   translate-Match :
     Match(op at Op(c, ts), e) ->

Modified: strc-java/trunk/trans/split-large-strategies.str
===================================================================
--- strc-java/trunk/trans/split-large-strategies.str	2009-05-27 13:59:16 UTC (rev 19474)
+++ strc-java/trunk/trans/split-large-strategies.str	2009-05-27 14:03:53 UTC (rev 19475)
@@ -59,6 +59,6 @@
     ]|
     with
       x_split  := <newname> <conc-strings> (x, "_fragment_")
-    ; x_unused := "unused"
+    ; x_unused := <newname> "unused"
     ; log(|Notice(), ["Split up very large strategy ", x])
 

Modified: strc-java/trunk/trans/strj.str
===================================================================
--- strc-java/trunk/trans/strj.str	2009-05-27 13:59:16 UTC (rev 19474)
+++ strc-java/trunk/trans/strj.str	2009-05-27 14:03:53 UTC (rev 19475)
@@ -43,6 +43,7 @@
         strc-front-end
       )
     end
+  ; try(mark-always-needed(|<get-config> "-m", 0, 0))
   ; strc-optimize
   ; s2j
   ; log-timed(output-java | "Pretty printing succeeded", 1)



From zef at zefhemel.com  Thu May 28 14:01:28 2009
From: zef at zefhemel.com (Zef Hemel)
Date: Thu, 28 May 2009 12:01:28 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19483 - zef -
	pil/trunk/src/lib/db
Message-ID: <200905281200.n4SC0hse001434@proliant.st.ewi.tudelft.nl>

Author: zef
Date: 2009-05-28 12:01:28 +0000 (Thu, 28 May 2009)
New Revision: 19483

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19483&view=rev

Modified:
   pil/trunk/src/lib/db/query.pil
   pil/trunk/src/lib/db/test.pil

Log:
Simple querylists work.


Changes:

Modified: pil/trunk/src/lib/db/query.pil
===================================================================
--- pil/trunk/src/lib/db/query.pil	2009-05-28 06:41:25 UTC (rev 19482)
+++ pil/trunk/src/lib/db/query.pil	2009-05-28 12:01:28 UTC (rev 19483)
@@ -18,21 +18,15 @@
   }
 
   QuerySet<T> filter(Filter filter) {
-    return null;
-    /*
     QuerySet<T> c = clone();
-    //c.filter = new AndFilter(this.filter, filter);
+    c.filter = new AndFilter(this.filter, filter);
     return c;
-    */
   }
 
   QuerySet<T> orderBy(OrderBy orderBy) {
-    return null;
-    /*
     QuerySet<T> c = clone();
     c.orderColumns.add(orderBy);
     return c;
-    */
   }
 
   QuerySet<T> newThis() {

Modified: pil/trunk/src/lib/db/test.pil
===================================================================
--- pil/trunk/src/lib/db/test.pil	2009-05-28 06:41:25 UTC (rev 19482)
+++ pil/trunk/src/lib/db/test.pil	2009-05-28 12:01:28 UTC (rev 19483)
@@ -90,8 +90,7 @@
   //zef.address.set(null, session);
   println("Now flushing again.");
   session.flush();
-  var q = new QuerySet<User>(typeof User);
-  q = q.filter(new OrFilter(new PropertyFilter("age", "<", 10), new PropertyFilter("age", ">", 26)));
+  var q = new QuerySet<User>(typeof User).filter(new OrFilter(new PropertyFilter("age", "<", 10), new PropertyFilter("age", ">", 26)));
   for(User user : q.list(session)) {
     println(user.name);
     println(user.age);



From zef at zefhemel.com  Thu May 28 14:38:26 2009
From: zef at zefhemel.com (Zef Hemel)
Date: Thu, 28 May 2009 12:38:26 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19485 - zef -
	pil/trunk/src/lib/db
Message-ID: <200905281237.n4SCbfja002182@proliant.st.ewi.tudelft.nl>

Author: zef
Date: 2009-05-28 12:38:26 +0000 (Thu, 28 May 2009)
New Revision: 19485

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19485&view=rev

Modified:
   pil/trunk/src/lib/db/collection.pil
   pil/trunk/src/lib/db/db.pil
   pil/trunk/src/lib/db/model.pil
   pil/trunk/src/lib/db/test.pil
   pil/trunk/src/lib/db/util.pil

Log:
Refactoring


Changes:

Modified: pil/trunk/src/lib/db/collection.pil
===================================================================
--- pil/trunk/src/lib/db/collection.pil	2009-05-28 12:02:14 UTC (rev 19484)
+++ pil/trunk/src/lib/db/collection.pil	2009-05-28 12:38:26 UTC (rev 19485)
@@ -6,7 +6,7 @@
 import pil::db::query
 import pil::reflect
 
-class pil::db::model::OneToOne<T> {
+class pil::db::model::SimpleReference<T> {
   String id = null;
   T value = null;
   Class cls = null;
@@ -34,7 +34,7 @@
   }
 }
 
-class pil::db::model::OneToOneWithInverse<T> extends OneToOne<T> {
+class pil::db::model::OneToOne<T> extends SimpleReference<T> {
   String inverseField = null;
   Entity self = null;
 
@@ -66,7 +66,7 @@
   }
 }
 
-class pil::db::model::OneToManyWithInverse<T> extends QuerySet<T> {
+class pil::db::model::OneToMany<T> extends QuerySet<T> {
   Set<T> local = new Set<T>();
   Entity self = null;
   String inverseField = null;
@@ -79,7 +79,7 @@
 
   void add(T item, DatabaseSession session) {
     session.add(item.as<Entity>);
-    ManyToOneWithInverse<Object> invProp = getObjectField(item, inverseField).as<ManyToOneWithInverse<Object>>;
+    ManyToOne<Object> invProp = getObjectField(item, inverseField).as<ManyToOne<Object>>;
     if(invProp.get(session) != self) {
       local.add(item);
       invProp.set(self, session);
@@ -95,18 +95,18 @@
 
   void remove(T item, DatabaseSession session) {
     session.add(item.as<Entity>);
-    getObjectField(item, inverseField).as<ManyToOneWithInverse<Object>>.set(null, session);
+    getObjectField(item, inverseField).as<ManyToOne<Object>>.set(null, session);
     if(local.contains(item)) {
       local.remove(item);
     }
   }
 
   QuerySet<T> newThis() {
-    return new OneToManyWithInverse<T>(self, cls, inverseField);
+    return new OneToMany<T>(self, cls, inverseField);
   }
 }
 
-class pil::db::model::ManyToOneWithInverse<T> {
+class pil::db::model::ManyToOne<T> {
   Entity self = null;
   Class cls = null;
   String inverseField = null;
@@ -128,12 +128,12 @@
     var oldValue = this.value;
     this.value = value;
     if(oldValue != null) {
-      getObjectField(oldValue.as<Entity>, inverseField).as<OneToManyWithInverse<Object>>.remove(self, session);
+      getObjectField(oldValue.as<Entity>, inverseField).as<OneToMany<Object>>.remove(self, session);
     }
     if(value != null) {
       this.id = value.as<Entity>.id;
       session.add(value.as<Entity>);
-      var inverseOneToMany = getObjectField(value, inverseField).as<OneToManyWithInverse<Object>>;
+      var inverseOneToMany = getObjectField(value, inverseField).as<OneToMany<Object>>;
       if(inverseOneToMany.contains(self, session)) {
         inverseOneToMany.add(self, session);
       }

Modified: pil/trunk/src/lib/db/db.pil
===================================================================
--- pil/trunk/src/lib/db/db.pil	2009-05-28 12:02:14 UTC (rev 19484)
+++ pil/trunk/src/lib/db/db.pil	2009-05-28 12:38:26 UTC (rev 19485)
@@ -77,12 +77,13 @@
   String simpleSelectFrom(Class cls) {
     var mapping = classMappings[cls];
     var sql = new MutableString("`" + mapping.tableName + "`.`id`, ");
+    var sqlParts = new List<String>();
     for(FieldMapping f : mapping.fieldMappings) {
-      sql.append("`" + mapping.tableName + "`.`" + f.fieldName + "`");
-      if(f != mapping.fieldMappings[mapping.fieldMappings.length-1]) {
-        sql.append(", ");
+      if(f.isSelectField()) {
+        sqlParts.add("`" + mapping.tableName + "`.`" + f.fieldName + "`");
       }
     }
+    sql.append(joinStrings(", ", sqlParts));
     sql.append(" FROM `" + mapping.tableName + "`");
     return sql.as<String>;
   }
@@ -103,10 +104,10 @@
     for(FieldMapping f : mapping.fieldMappings) {
       if(f instanceof OneToOneFieldMapping) {
         getObjectField(o, f.fieldName).as<OneToOne<Object>>.setId(r.getString(counter));
-      } else if(f instanceof OneToManyWithInverseFieldMapping) {
+      } else if(f instanceof OneToManyFieldMapping) {
         // nothing
-      } else if(f instanceof ManyToOneWithInverseFieldMapping) {
-        getObjectField(o, f.fieldName).as<ManyToOneWithInverse<Object>>.setId(r.getString(counter));
+      } else if(f instanceof ManyToOneFieldMapping) {
+        getObjectField(o, f.fieldName).as<ManyToOne<Object>>.setId(r.getString(counter));
       } else {
         setObjectField(o, f.fieldName, r.getObject(counter));
       }

Modified: pil/trunk/src/lib/db/model.pil
===================================================================
--- pil/trunk/src/lib/db/model.pil	2009-05-28 12:02:14 UTC (rev 19484)
+++ pil/trunk/src/lib/db/model.pil	2009-05-28 12:38:26 UTC (rev 19485)
@@ -90,6 +90,10 @@
   String createSQL(Dialect dialect) {
     return "ERROR!";
   }
+
+  Bool isSelectField() {
+    return true;
+  }
 }
 
 class pil::db::model::ValueFieldMapping extends pil::db::model::FieldMapping {
@@ -120,7 +124,7 @@
   }
 }
 
-class pil::db::model::OneToManyWithInverseFieldMapping extends pil::db::model::FieldMapping {
+class pil::db::model::OneToManyFieldMapping extends pil::db::model::FieldMapping {
   Class listCls = null;
 
   new(String fieldName, Class listCls) extends super(fieldName) {
@@ -130,9 +134,13 @@
   String createSQL(Dialect dialect) {
     return "";
   }
+
+  Bool isSelectField() {
+    return false;
+  }
 }
 
-class pil::db::model::ManyToOneWithInverseFieldMapping extends pil::db::model::FieldMapping {
+class pil::db::model::ManyToOneFieldMapping extends pil::db::model::FieldMapping {
   Class cls = null;
 
   new(String fieldName, Class cls) extends super(fieldName) {

Modified: pil/trunk/src/lib/db/test.pil
===================================================================
--- pil/trunk/src/lib/db/test.pil	2009-05-28 12:02:14 UTC (rev 19484)
+++ pil/trunk/src/lib/db/test.pil	2009-05-28 12:38:26 UTC (rev 19485)
@@ -13,8 +13,8 @@
   String name = null;
   Int age = 0;
   String bio = null;
-  OneToOneWithInverse<Address> address = new OneToOneWithInverse<Address>(this, typeof Address, "owner");
-  OneToManyWithInverse<Message> messages = new OneToManyWithInverse<Message>(this, typeof Message, "sender");
+  OneToOne<Address> address = new OneToOne<Address>(this, typeof Address, "owner");
+  OneToMany<Message> messages = new OneToMany<Message>(this, typeof Message, "sender");
 
   ClassMapping getMapping() {
     var fields = new List<FieldMapping>();
@@ -22,12 +22,13 @@
     fields.add(new ValueFieldMapping("age", pil::db::type::intType, 0));
     fields.add(new ValueFieldMapping("bio", pil::db::type::stringType, 1024));
     fields.add(new OneToOneFieldMapping("address", typeof Address));
+    fields.add(new OneToManyFieldMapping("messages", typeof Message));
     return new ClassMapping(typeof User, "User", fields.as<Array<FieldMapping>>);
   }
 }
 
 class Address extends Entity {
-  OneToOneWithInverse<User> owner = new OneToOneWithInverse<User>(this, typeof User, "address");
+  OneToOne<User> owner = new OneToOne<User>(this, typeof User, "address");
   String street = null;
   Int number = 0;
 
@@ -41,12 +42,12 @@
 }
 
 class Message extends Entity {
-  ManyToOneWithInverse<User> sender = new ManyToOneWithInverse<User>(this, typeof User, "messages");
+  ManyToOne<User> sender = new ManyToOne<User>(this, typeof User, "messages");
   String message = "";
 
   ClassMapping getMapping() {
     var fields = new List<FieldMapping>();
-    fields.add(new ManyToOneWithInverseFieldMapping("sender", typeof User));
+    fields.add(new ManyToOneFieldMapping("sender", typeof User));
     fields.add(new ValueFieldMapping("message", pil::db::type::stringType, 255));
     return new ClassMapping(typeof Message, "Message", fields.as<Array<FieldMapping>>);
   }
@@ -90,10 +91,10 @@
   //zef.address.set(null, session);
   println("Now flushing again.");
   session.flush();
-  var q = new QuerySet<User>(typeof User).filter(new OrFilter(new PropertyFilter("age", "<", 10), new PropertyFilter("age", ">", 26)));
+  println("All users where age < 10 or age > 25 order descending by age:");
+  var q = new QuerySet<User>(typeof User).filter(new OrFilter(new PropertyFilter("age", "<", 10), new PropertyFilter("age", ">", 26))).orderBy(new OrderBy(typeof User, "age", false));
   for(User user : q.list(session)) {
-    println(user.name);
-    println(user.age);
+    println(user.name + " age " + user.age.as<String>);
   }
   println("Now printing all of Zef's messages:");
   for(Message message : zef.messages.list(session)) {

Modified: pil/trunk/src/lib/db/util.pil
===================================================================
--- pil/trunk/src/lib/db/util.pil	2009-05-28 12:02:14 UTC (rev 19484)
+++ pil/trunk/src/lib/db/util.pil	2009-05-28 12:38:26 UTC (rev 19485)
@@ -39,9 +39,9 @@
 Object pil::db::util::dbValue(Object value) {
   if(value instanceof OneToOne<Object>) {
     return value.as<OneToOne<Object>>.id;
-  } else if(value instanceof ManyToOneWithInverse<Object>) {
-    return value.as<ManyToOneWithInverse<Object>>.id;
-  } else if(value instanceof OneToManyWithInverse<Object>) {
+  } else if(value instanceof ManyToOne<Object>) {
+    return value.as<ManyToOne<Object>>.id;
+  } else if(value instanceof OneToMany<Object>) {
     return null;
   } else {
     return value;



From zef at zefhemel.com  Thu May 28 16:21:45 2009
From: zef at zefhemel.com (Zef Hemel)
Date: Thu, 28 May 2009 14:21:45 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19486 - zef -
	pil/trunk/src/lib/db
Message-ID: <200905281421.n4SEL06d003942@proliant.st.ewi.tudelft.nl>

Author: zef
Date: 2009-05-28 14:21:44 +0000 (Thu, 28 May 2009)
New Revision: 19486

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19486&view=rev

Modified:
   pil/trunk/src/lib/db/db.pil
   pil/trunk/src/lib/db/model.pil
   pil/trunk/src/lib/db/query.pil
   pil/trunk/src/lib/db/test.pil

Log:
Prefetching seems to work, partly at least.


Changes:

Modified: pil/trunk/src/lib/db/db.pil
===================================================================
--- pil/trunk/src/lib/db/db.pil	2009-05-28 12:38:26 UTC (rev 19485)
+++ pil/trunk/src/lib/db/db.pil	2009-05-28 14:21:44 UTC (rev 19486)
@@ -69,7 +69,7 @@
     var sql = "SELECT " + simpleSelectFrom(cls);
     sql = sql + " WHERE id = ?";
     for(Result r : queryWithArgs(sql, new Array<Object>(id))) {
-      return resultToEntity(cls, r);
+      return resultToEntity(cls, r, 0);
     }
     return null;
   }
@@ -88,19 +88,32 @@
     return sql.as<String>;
   }
 
+  String simpleSelect(Class cls) {
+    var mapping = classMappings[cls];
+    var sql = new MutableString("`" + mapping.tableName + "`.`id`, ");
+    var sqlParts = new List<String>();
+    for(FieldMapping f : mapping.fieldMappings) {
+      if(f.isSelectField()) {
+        sqlParts.add("`" + mapping.tableName + "`.`" + f.fieldName + "`");
+      }
+    }
+    sql.append(joinStrings(", ", sqlParts));
+    return sql.as<String>;
+  }
+
   List<Entity> all(Class cls) {
     var results = new List<Entity>();
     for(Result r : query("SELECT " + simpleSelectFrom(cls))) {
-      results.add(resultToEntity(cls, r));
+      results.add(resultToEntity(cls, r, 0));
     }
     return results;
   }
 
-  Entity resultToEntity(Class cls, Result r) {
+  Entity resultToEntity(Class cls, Result r, Int fieldOffset) {
     var mapping = classMappings[cls];
     var o = cls.newInstance().as<Entity>;
-    var counter = 1;
-    o.id = r.getString(0);
+    var counter = fieldOffset + 1;
+    o.id = r.getString(fieldOffset);
     for(FieldMapping f : mapping.fieldMappings) {
       if(f instanceof OneToOneFieldMapping) {
         getObjectField(o, f.fieldName).as<OneToOne<Object>>.setId(r.getString(counter));

Modified: pil/trunk/src/lib/db/model.pil
===================================================================
--- pil/trunk/src/lib/db/model.pil	2009-05-28 12:38:26 UTC (rev 19485)
+++ pil/trunk/src/lib/db/model.pil	2009-05-28 14:21:44 UTC (rev 19486)
@@ -110,7 +110,7 @@
   }
 }
 
-class pil::db::model::OneToOneFieldMapping extends pil::db::model::FieldMapping {
+class pil::db::model::SimpleReferenceFieldMapping extends pil::db::model::FieldMapping {
   Class cls = null;
 
   new(String fieldName, Class cls) extends super(fieldName) {
@@ -124,6 +124,11 @@
   }
 }
 
+class pil::db::model::OneToOneFieldMapping extends pil::db::model::SimpleReferenceFieldMapping {
+  new(String fieldName, Class cls) extends super(fieldName, cls) {
+  }
+}
+
 class pil::db::model::OneToManyFieldMapping extends pil::db::model::FieldMapping {
   Class listCls = null;
 

Modified: pil/trunk/src/lib/db/query.pil
===================================================================
--- pil/trunk/src/lib/db/query.pil	2009-05-28 12:38:26 UTC (rev 19485)
+++ pil/trunk/src/lib/db/query.pil	2009-05-28 14:21:44 UTC (rev 19486)
@@ -11,6 +11,7 @@
   Class cls = null;
   Filter filter = new NullFilter();
   List<OrderBy> orderColumns = new List<OrderBy>();
+  List<String> prefetchFields = new List<String>();
   DatabaseSession session = null;
 
   new(Class cls) {
@@ -29,6 +30,12 @@
     return c;
   }
 
+  QuerySet<T> prefetch(String field) {
+    QuerySet<T> c = clone();
+    c.prefetchFields.add(field);
+    return c;
+  }
+
   QuerySet<T> newThis() {
     return new QuerySet<T>(cls);
   }
@@ -37,6 +44,10 @@
     QuerySet<T> c = newThis();
     c.filter = filter;
     c.session = session;
+    c.prefetchFields = new List<String>();
+    for(String f : prefetchFields) {
+      c.prefetchFields.add(f);
+    }
     c.orderColumns = new List<OrderBy>();
     for(OrderBy item : orderColumns) {
       c.orderColumns.add(item);
@@ -58,13 +69,38 @@
 
   List<Entity> list(DatabaseSession session) {
     var args = new List<Object>();
-    var sql = "SELECT " + session.simpleSelectFrom(cls) + " WHERE " + filter.createSQL(session.dialect, args);
+    var selectSql = "SELECT " + session.simpleSelect(cls);
+    var mapping = classMappings[cls];
+    var joinSql = "";
+
+    for(String prefetchField : prefetchFields) {
+      if(mapping.fields[prefetchField] instanceof SimpleReferenceFieldMapping) {
+        var cls2 = mapping.fields[prefetchField].as<SimpleReferenceFieldMapping>.cls;
+        var mapping2 = classMappings[cls2];
+        selectSql = selectSql + ", " + session.simpleSelect(cls2);
+        joinSql = joinSql + "LEFT JOIN `" + mapping2.tableName + "` ON `" + mapping2.tableName + "`.`id` = `" + mapping.tableName + "`.`" + prefetchField + "` ";
+      }
+    }
+
+    var whereSql = "WHERE " + filter.createSQL(session.dialect, args);
+    var sql = selectSql + " FROM `" + mapping.tableName + "` " + joinSql + " " + whereSql;
     if(orderColumns.length > 0) {
       sql = sql + " ORDER BY " + joinStrings(", ", map<OrderBy,String>(String(OrderBy ob) { ob.createSQL(session.dialect) }, orderColumns));
     }
     var results = new List<Entity>();
     for(Result r : session.queryWithArgs(sql, args.as<Array<Object>>)) {
-      results.add(session.resultToEntity(cls, r));
+      var e = session.resultToEntity(cls, r, 0);
+      var offset = mapping.fieldMappings.length;
+      for(String prefetchField : prefetchFields) {
+        var cls2 = mapping.fields[prefetchField].as<SimpleReferenceFieldMapping>.cls;
+        var mapping2 = classMappings[cls2];
+        var e2 = session.resultToEntity(cls2, r, offset);
+        SimpleReference<Object> sr = getObjectField(e, prefetchField).as<SimpleReference<Object>>;
+        sr.id = e2.id;
+        sr.value = e2;
+        offset = offset + mapping2.fieldMappings.length;
+      }
+      results.add(e);
     }
     return results;
   }

Modified: pil/trunk/src/lib/db/test.pil
===================================================================
--- pil/trunk/src/lib/db/test.pil	2009-05-28 12:38:26 UTC (rev 19485)
+++ pil/trunk/src/lib/db/test.pil	2009-05-28 14:21:44 UTC (rev 19486)
@@ -92,9 +92,9 @@
   println("Now flushing again.");
   session.flush();
   println("All users where age < 10 or age > 25 order descending by age:");
-  var q = new QuerySet<User>(typeof User).filter(new OrFilter(new PropertyFilter("age", "<", 10), new PropertyFilter("age", ">", 26))).orderBy(new OrderBy(typeof User, "age", false));
+  var q = new QuerySet<User>(typeof User).filter(new OrFilter(new PropertyFilter("age", "<", 10), new PropertyFilter("age", ">", 26))).prefetch("address").orderBy(new OrderBy(typeof User, "age", false));
   for(User user : q.list(session)) {
-    println(user.name + " age " + user.age.as<String>);
+    println(user.name + " age " + user.age.as<String> + " street: " + user.address.get(session).street);
   }
   println("Now printing all of Zef's messages:");
   for(Message message : zef.messages.list(session)) {



From zef at zefhemel.com  Thu May 28 16:59:26 2009
From: zef at zefhemel.com (Zef Hemel)
Date: Thu, 28 May 2009 14:59:26 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19488 - zef -
	pil/trunk/src/lib/db
Message-ID: <200905281458.n4SEwfiA004248@proliant.st.ewi.tudelft.nl>

Author: zef
Date: 2009-05-28 14:59:26 +0000 (Thu, 28 May 2009)
New Revision: 19488

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19488&view=rev

Modified:
   pil/trunk/src/lib/db/test.pil
   pil/trunk/src/lib/db/util.pil

Log:
Building a test suite


Changes:

Modified: pil/trunk/src/lib/db/test.pil
===================================================================
--- pil/trunk/src/lib/db/test.pil	2009-05-28 14:47:30 UTC (rev 19487)
+++ pil/trunk/src/lib/db/test.pil	2009-05-28 14:59:26 UTC (rev 19488)
@@ -5,14 +5,18 @@
 import "collection.pil"
 import "query.pil"
 
+import "/Domain/tudelft.net/Users/zhemel/svn/pil/src/lib/test.pil"
+
+import pil::test
+
 import pil::db
 import pil::db::model
 import pil::db::query
 
 class User extends Entity {
-  String name = null;
+  String name = "";
   Int age = 0;
-  String bio = null;
+  String bio = "";
   OneToOne<Address> address = new OneToOne<Address>(this, typeof Address, "owner");
   OneToMany<Message> messages = new OneToMany<Message>(this, typeof Message, "sender");
 
@@ -29,7 +33,7 @@
 
 class Address extends Entity {
   OneToOne<User> owner = new OneToOne<User>(this, typeof User, "address");
-  String street = null;
+  String street = "";
   Int number = 0;
 
   ClassMapping getMapping() {
@@ -53,6 +57,47 @@
   }
 }
 
+void cleanup(DatabaseSession session) {
+  session.updateQuery("DELETE FROM User");
+  session.updateQuery("DELETE FROM Address");
+  session.updateQuery("DELETE FROM Message");
+}
+
+void testSimple(DatabaseSession session) {
+  println("Simple test");
+  var u = new User();
+  u.name = "User 1";
+  u.age = 1;
+  session.add(u);
+  session.flush();
+  var u2 = session.get(typeof User, u.id).as<User>;
+  assertEqual(u.id, u2.id, "Id check");
+  assertEqual(u.name, u2.name, "name check");
+  assertEqual(u.age, u2.age, "age check");
+}
+
+void testOneToOne(DatabaseSession session) {
+  var u = new User();
+  u.name = "Zef Hemel";
+  u.age = 25;
+  u.bio = "He's a nice guy.";
+  session.add(u);
+  var uAddr = new Address();
+  uAddr.street = "Chopinplein";
+  uAddr.number = 64;
+  u.address.set(uAddr, session);
+  session.flush();
+  assertEqual(u.address.get(session).id, uAddr.id, "reference check");
+  assertEqual(u.id, uAddr.owner.get(session).id, "reference check");
+
+  var u2 = session.get(typeof User, u.id).as<User>;
+  assertEqual(u.address.get(session).id, u2.address.get(session).id, "database check");
+
+  u.address.set(null, session);
+  assertEqual(u.address.get(session), null, "reference check");
+  assertEqual(uAddr.owner.get(session), null, "reference check");
+}
+
 void main(Array<String> args) {
   var dialect = new pil::db::dialect::MySQLDialect();
   var db = new pil::db::Database(dialect, "localhost", "root", "", "pildb");
@@ -63,6 +108,13 @@
   session.registerEntityClass(typeof Address);
   session.updateSchemas();
 
+  cleanup(session);
+  testSimple(session);
+  cleanup(session);
+  testOneToOne(session);
+  reportTestResults();
+  /*
+
   var zef = new User();
   zef.name = "Zef Hemel";
   zef.age = 25;
@@ -100,5 +152,6 @@
   for(Message message : zef.messages.list(session)) {
     println(message.message);
   }
+  */
 }
 

Modified: pil/trunk/src/lib/db/util.pil
===================================================================
--- pil/trunk/src/lib/db/util.pil	2009-05-28 14:47:30 UTC (rev 19487)
+++ pil/trunk/src/lib/db/util.pil	2009-05-28 14:59:26 UTC (rev 19488)
@@ -37,7 +37,9 @@
 }
 
 Object pil::db::util::dbValue(Object value) {
-  if(value instanceof OneToOne<Object>) {
+  if(value == null) {
+    return null;
+  } else if(value instanceof OneToOne<Object>) {
     return value.as<OneToOne<Object>>.id;
   } else if(value instanceof ManyToOne<Object>) {
     return value.as<ManyToOne<Object>>.id;



From zef at zefhemel.com  Fri May 29 14:27:01 2009
From: zef at zefhemel.com (Zef Hemel)
Date: Fri, 29 May 2009 12:27:01 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19494 - zef - in
	pil/trunk/src: lib/db pil/backend/java pil/syntax pil/typechecker
Message-ID: <200905291226.n4TCQEN8019925@proliant.st.ewi.tudelft.nl>

Author: zef
Date: 2009-05-29 12:27:00 +0000 (Fri, 29 May 2009)
New Revision: 19494

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19494&view=rev

Modified:
   pil/trunk/src/lib/db/collection.pil
   pil/trunk/src/lib/db/db.pil
   pil/trunk/src/lib/db/query.pil
   pil/trunk/src/lib/db/test.pil
   pil/trunk/src/pil/backend/java/builtin.str
   pil/trunk/src/pil/backend/java/expression.str
   pil/trunk/src/pil/syntax/PIL-Expression.sdf
   pil/trunk/src/pil/syntax/PIL-pretty.pp
   pil/trunk/src/pil/typechecker/expression.str
   pil/trunk/src/pil/typechecker/rename.str

Log:
Added super calls


Changes:

Modified: pil/trunk/src/lib/db/collection.pil
===================================================================
--- pil/trunk/src/lib/db/collection.pil	2009-05-29 12:01:50 UTC (rev 19493)
+++ pil/trunk/src/lib/db/collection.pil	2009-05-29 12:27:00 UTC (rev 19494)
@@ -74,7 +74,7 @@
   new(Entity self, Class cls, String inverseField) extends super(cls) {
     this.self = self;
     this.inverseField = inverseField;
-    this.filter = new PropertyFilter(inverseField, "=", self.id);
+    //this.filter = new PropertyFilter(inverseField, "=", self.id);
   }
 
   void add(T item, DatabaseSession session) {
@@ -86,6 +86,10 @@
     }
   }
 
+  List<T> list(DatabaseSession session) {
+    return super.list(session);
+  }
+
   Bool contains(T item, DatabaseSession session) {
     if(local.contains(item)) {
       return true;

Modified: pil/trunk/src/lib/db/db.pil
===================================================================
--- pil/trunk/src/lib/db/db.pil	2009-05-29 12:01:50 UTC (rev 19493)
+++ pil/trunk/src/lib/db/db.pil	2009-05-29 12:27:00 UTC (rev 19494)
@@ -34,6 +34,12 @@
 
   List<Result> queryWithArgs(String sql, Array<Object> args) {
     println(sql);
+    var l = new List<Object>();
+    for(Object o : args) {
+      l.add(o);
+    }
+    print("Arguments: ");
+    println(l);
     return conn.query(sql, args);
   }
 
@@ -114,6 +120,7 @@
     var o = cls.newInstance().as<Entity>;
     var counter = fieldOffset + 1;
     o.id = r.getString(fieldOffset);
+    println("Just read: " + o.id);
     for(FieldMapping f : mapping.fieldMappings) {
       if(f instanceof OneToOneFieldMapping) {
         getObjectField(o, f.fieldName).as<OneToOne<Object>>.setId(r.getString(counter));

Modified: pil/trunk/src/lib/db/query.pil
===================================================================
--- pil/trunk/src/lib/db/query.pil	2009-05-29 12:01:50 UTC (rev 19493)
+++ pil/trunk/src/lib/db/query.pil	2009-05-29 12:27:00 UTC (rev 19494)
@@ -67,7 +67,7 @@
     throw new Exception("Cannot do contains check!");
   }
 
-  List<Entity> list(DatabaseSession session) {
+  List<T> list(DatabaseSession session) {
     var args = new List<Object>();
     var selectSql = "SELECT " + session.simpleSelect(cls);
     var mapping = classMappings[cls];
@@ -87,7 +87,7 @@
     if(orderColumns.length > 0) {
       sql = sql + " ORDER BY " + joinStrings(", ", map<OrderBy,String>(String(OrderBy ob) { ob.createSQL(session.dialect) }, orderColumns));
     }
-    var results = new List<Entity>();
+    var results = new List<T>();
     for(Result r : session.queryWithArgs(sql, args.as<Array<Object>>)) {
       var e = session.resultToEntity(cls, r, 0);
       var offset = mapping.fieldMappings.length;
@@ -100,7 +100,7 @@
         sr.value = e2;
         offset = offset + mapping2.fieldMappings.length;
       }
-      results.add(e);
+      results.add(e.as<T>);
     }
     return results;
   }

Modified: pil/trunk/src/lib/db/test.pil
===================================================================
--- pil/trunk/src/lib/db/test.pil	2009-05-29 12:01:50 UTC (rev 19493)
+++ pil/trunk/src/lib/db/test.pil	2009-05-29 12:27:00 UTC (rev 19494)
@@ -77,6 +77,7 @@
 }
 
 void testOneToOne(DatabaseSession session) {
+  println("1:1 tests");
   var u = new User();
   u.name = "Zef Hemel";
   u.age = 25;
@@ -96,8 +97,28 @@
   u.address.set(null, session);
   assertEqual(u.address.get(session), null, "reference check");
   assertEqual(uAddr.owner.get(session), null, "reference check");
+  session.flush();
 }
 
+void testOneToMany(DatabaseSession session) {
+  println("1:N tests");
+  var u = new User();
+  u.name = "User 1";
+  var m = new Message();
+  m.message = "Hello world!";
+  u.messages.add(m, session);
+  assertEqual(m.sender.get(session), u, "back reference");
+  session.flush();
+
+  var u2 = session.get(typeof User, u.id).as<User>;
+  println("u2 id: " + u2.id);
+  var messages = u2.messages.list(session);
+  assertEqual(messages.length, 1, "number of messages check");
+  for(Message m2 : messages) {
+    assertEqual(m2.id, m.id, "message id check");
+  }
+}
+
 void main(Array<String> args) {
   var dialect = new pil::db::dialect::MySQLDialect();
   var db = new pil::db::Database(dialect, "localhost", "root", "", "pildb");
@@ -112,6 +133,8 @@
   testSimple(session);
   cleanup(session);
   testOneToOne(session);
+  cleanup(session);
+  testOneToMany(session);
   reportTestResults();
   /*
 

Modified: pil/trunk/src/pil/backend/java/builtin.str
===================================================================
--- pil/trunk/src/pil/backend/java/builtin.str	2009-05-29 12:01:50 UTC (rev 19493)
+++ pil/trunk/src/pil/backend/java/builtin.str	2009-05-29 12:27:00 UTC (rev 19494)
@@ -322,11 +322,16 @@
 
   pil-exp-to-java-spec :
     pil-exp|[ new pil::List<t>(e*) ]| -> expr|[ pil.Utils.fromArrayToList(e_ar) ]|
+    where not(e* := [])
     with e2* := <map(pil-expression-to-java)> e*
        ;    (ClassOrInterfaceType(t2, _) := <pil-java-type> t
          <+ t2 := <pil-java-type> t)
        ; e_ar := NewArray(t2, [Dim()], ArrayInit(e2*))
 
+  pil-exp-to-java-spec :
+    pil-exp|[ new pil::List<t>() ]| -> expr|[ new java.util.ArrayList<t2>() ]|
+    with ClassOrInterfaceType(t2, _) := <pil-java-type> t
+      <+ t2 := <pil-java-type> t
 
   pil-exp-to-java-spec :
     e at pil-exp|[ e1.get(e2) ]| -> <pil-unbox-java-expression(|e)> expr|[ e3.get(e4) ]|

Modified: pil/trunk/src/pil/backend/java/expression.str
===================================================================
--- pil/trunk/src/pil/backend/java/expression.str	2009-05-29 12:01:50 UTC (rev 19493)
+++ pil/trunk/src/pil/backend/java/expression.str	2009-05-29 12:27:00 UTC (rev 19494)
@@ -67,6 +67,11 @@
        ; x := <pil-java-safe-id> mx
        ; e2* := <map(pil-expression-to-java)> e1*
 
+  pil-exp-to-java-spec :
+    MethodCall(Super{_}, mx, e1*) -> expr |[ super.x(e2*) ]|
+    with x := <pil-java-safe-id> mx
+       ; e2* := <map(pil-expression-to-java)> e1*
+
   pil-exp-to-java :
     pil-exp|[ qid(e*) ]| -> Invoke(Method(<pil-qid-to-method-name> qid), <map(pil-expression-to-java)> e*)
 

Modified: pil/trunk/src/pil/syntax/PIL-Expression.sdf
===================================================================
--- pil/trunk/src/pil/syntax/PIL-Expression.sdf	2009-05-29 12:01:50 UTC (rev 19493)
+++ pil/trunk/src/pil/syntax/PIL-Expression.sdf	2009-05-29 12:27:00 UTC (rev 19494)
@@ -16,6 +16,7 @@
     "false"                     -> Exp {cons("False")}
     "null"                      -> Exp {cons("Null")}
     "this"                      -> Exp {cons("This")}
+    "super"                     -> Exp {cons("Super")}
 
   context-free syntax %% Expressions
     "(" Exp ")"                           -> Exp {bracket}

Modified: pil/trunk/src/pil/syntax/PIL-pretty.pp
===================================================================
--- pil/trunk/src/pil/syntax/PIL-pretty.pp	2009-05-29 12:01:50 UTC (rev 19493)
+++ pil/trunk/src/pil/syntax/PIL-pretty.pp	2009-05-29 12:27:00 UTC (rev 19494)
@@ -114,6 +114,7 @@
    SuperClassDeclaration                       -- KW["extends"] _1,
    True                                        -- KW["true"],
    This                                        -- KW["this"],
+   Super                                       -- KW["super"],
    UpdateCall                                  -- _1 KW["["] _2 KW["]"],
    Var                                         -- _1,
    VarLHS                                      -- _1,

Modified: pil/trunk/src/pil/typechecker/expression.str
===================================================================
--- pil/trunk/src/pil/typechecker/expression.str	2009-05-29 12:01:50 UTC (rev 19493)
+++ pil/trunk/src/pil/typechecker/expression.str	2009-05-29 12:27:00 UTC (rev 19494)
@@ -98,6 +98,15 @@
     This(){(qid, x*)} -> GenericType(qid, <map(\ _ -> pil-type|[ pil::Object ]| \)> x*)
 
   pil-eq-type-of :
+    Super(){qid} -> t
+    where not(<is-tuple> qid)
+    with pil-decl|[ anno* external class qid2 extends t { ecbd* } ]| := <pil-lookup-class> SimpleType(qid)
+
+  pil-eq-type-of : 
+    Super(){(qid, x*)} -> t
+    with pil-decl|[ anno* external class qid2 extends t { ecbd* } ]| := <pil-lookup-class> GenericType(qid, <map(\ _ -> pil-type|[ pil::Object ]| \)> x*)
+
+  pil-eq-type-of :
     Var(x){qid} -> <pil-lookup-field; pil-get-field-type> (SimpleType(qid), x)
 
   pil-eq-type-of :

Modified: pil/trunk/src/pil/typechecker/rename.str
===================================================================
--- pil/trunk/src/pil/typechecker/rename.str	2009-05-29 12:01:50 UTC (rev 19493)
+++ pil/trunk/src/pil/typechecker/rename.str	2009-05-29 12:27:00 UTC (rev 19494)
@@ -164,6 +164,10 @@
   pil-rename :
     This() -> This(){<PilCurrentClass>}
 
+  pil-rename :
+    Super() -> Super(){<PilCurrentClass>}
+
+
   pil-rename : // object field
     Var(x) -> Var(x){<PilCurrentClass>}
     where not(PilRename)



From L.C.L.Kats at tudelft.nl  Fri May 29 17:41:54 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Fri, 29 May 2009 15:41:54 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19500 - LennartKats - in
	spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime:
	parser parser/ast stratego stratego/adapter
Message-ID: <200905291541.n4TFf7xI022425@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-05-29 15:41:54 +0000 (Fri, 29 May 2009)
New Revision: 19500

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19500&view=rev

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/JSGLRI.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ParseErrorHandler.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/SGLRParseController.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AmbAsfixImploder.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/StrategoListProxy.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/IWrappedAstNode.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/WrappedAstNode.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/WrappedAstNodeAppl.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/WrappedAstNodeFactory.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/WrappedAstNodeLink.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/WrappedAstNodeList.java

Log:
Fixed some regressions:
- Yet another parse error handler ambiguity handling fix
- Disabled the priority filter
- Set BackTrackRecovery2


Changes:

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/JSGLRI.java
===================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/JSGLRI.java	2009-05-29 15:28:16 UTC (rev 19499)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/JSGLRI.java	2009-05-29 15:41:54 UTC (rev 19500)
@@ -4,6 +4,7 @@
 import java.io.InputStream;
 
 import org.spoofax.jsglr.BadTokenException;
+import org.spoofax.jsglr.NoRecovery;
 import org.spoofax.jsglr.ParseTable;
 import org.spoofax.jsglr.RecoverAlgorithm;
 import org.spoofax.jsglr.SGLR;
@@ -23,6 +24,8 @@
 	
 	private final ParseTable parseTable;
 	
+	private RecoverAlgorithm recoverHandler = new NoRecovery();
+	
 	private SGLR parser;
 	
 	// Initialization and parsing
@@ -44,6 +47,7 @@
 	}
 	
 	public void setRecoverHandler(RecoverAlgorithm recoverHandler) {
+		this.recoverHandler = recoverHandler;
 		parser.setRecoverHandler(recoverHandler);
 	}
 	
@@ -59,6 +63,9 @@
 	 */
 	void resetState() {
 		parser = Environment.createSGLR(parseTable);
+		parser.setRecoverHandler(recoverHandler);
+		// XXX: Must run with filters enabled, when they're no longer b0rked
+		parser.getDisambiguator().setFilterPriorities(false);
 	}
 	
 	private ATerm doParseNoImplode(InputStream inputStream, char[] inputChars)

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ParseErrorHandler.java
===================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ParseErrorHandler.java	2009-05-29 15:28:16 UTC (rev 19499)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ParseErrorHandler.java	2009-05-29 15:41:54 UTC (rev 19500)
@@ -32,6 +32,8 @@
 	private final AstMessageHandler handler = new AstMessageHandler(AstMessageHandler.PARSE_MARKER_TYPE);
 	
 	private final ISourceInfo sourceInfo;
+	
+	private boolean isRecoveryEnabled = true;
 
 	private IMessageHandler messages;
 	
@@ -46,11 +48,19 @@
 		handler.clearMarkers(sourceInfo.getResource());
 	}
 	
-	public void setMessages (IMessageHandler messages) {
+	public void setMessages(IMessageHandler messages) {
 		this.messages = messages;
-	}	
+	}
 	
 	/**
+	 * Informs the parse error handler that recovery is unavailable.
+	 * This information is reflected in any parse error messages.
+	 */
+	public void setRecoveryEnabled(boolean recoveryEnabled) {
+		this.isRecoveryEnabled = recoveryEnabled;
+	}
+	
+	/**
 	 * Report WATER + INSERT errors from parse tree
 	 */
 	public void reportNonFatalErrors(SGLRTokenizer tokenizer, ATerm top) {
@@ -71,9 +81,11 @@
 		//       (which wasn't working before...)
 		
 		if ("amb".equals(((ATermAppl) term).getAFun().getName())) {
-			for (int i = 0; i < term.getChildCount(); i++) {
-				reportOnRepairedCode(tokenizer, (ATerm) term.getChildAt(i));
+			
+			for (ATermList cons = (ATermList) term.getChildAt(0); !cons.isEmpty(); cons = cons.getNext()) {
+				reportOnRepairedCode(tokenizer, cons.getFirst());
 			}
+			return;
 		}
 		
 		ATermAppl prod = termAt(term, 0);
@@ -156,6 +168,10 @@
 		//messages.handleSimpleMessage(
 		// 		message, max(0, left.getStartOffset()), max(0, right.getEndOffset()),
 		// 		left.getColumn(), right.getEndColumn(), left.getLine(), right.getEndLine());
+		
+		if (!isRecoveryEnabled)
+			message += " (recovery unavailable)";
+		
 		handler.addMarker(sourceInfo.getResource(), left, right, message, IMarker.SEVERITY_ERROR);
 	}	
 	

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/SGLRParseController.java
===================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/SGLRParseController.java	2009-05-29 15:28:16 UTC (rev 19499)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/SGLRParseController.java	2009-05-29 15:41:54 UTC (rev 19500)
@@ -22,6 +22,7 @@
 import org.eclipse.imp.services.IAnnotationTypeInfo;
 import org.eclipse.imp.services.ILanguageSyntaxProperties;
 import org.eclipse.jface.text.IRegion;
+import org.spoofax.jsglr.BackTrackRecovery2;
 import org.spoofax.jsglr.BadTokenException;
 import org.spoofax.jsglr.ParseTable;
 import org.spoofax.jsglr.ParseTimeoutException;
@@ -122,6 +123,7 @@
     	ParseTable table = Environment.getParseTable(language);
 		parser = new JSGLRI(table, startSymbol, this, tokenManager);
 		parser.setKeepAmbiguities(false); // not interested in ambiguities in the editor
+		parser.setRecoverHandler(new BackTrackRecovery2());
     }
 
     public void initialize(IPath filePath, ISourceProject project,
@@ -163,6 +165,7 @@
 			
 			// (must not be synchronized; uses workspace lock)
 			errorHandler.clearErrors();
+			errorHandler.setRecoveryEnabled(true);
 			errorHandler.reportNonFatalErrors(parser.getTokenizer(), asfix);
 				
 			Debug.stopTimer("File parsed: " + filename);
@@ -173,15 +176,19 @@
 			// TODO: Don't show stack trace for this
 			if (monitor.isCanceled()) return null;
 			errorHandler.clearErrors();
+			errorHandler.setRecoveryEnabled(false);
 			errorHandler.reportError(parser.getTokenizer(), e);
 		} catch (BadTokenException e) {
 			errorHandler.clearErrors();
+			errorHandler.setRecoveryEnabled(false);
 			errorHandler.reportError(parser.getTokenizer(), e);
 		} catch (SGLRException e) {
 			errorHandler.clearErrors();
+			errorHandler.setRecoveryEnabled(false);
 			errorHandler.reportError(parser.getTokenizer(), e);
 		} catch (IOException e) {
 			errorHandler.clearErrors();
+			errorHandler.setRecoveryEnabled(false);
 			errorHandler.reportError(parser.getTokenizer(), e);
 		} catch (OperationCanceledException e) {
 			return null;

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AmbAsfixImploder.java
===================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AmbAsfixImploder.java	2009-05-29 15:28:16 UTC (rev 19499)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AmbAsfixImploder.java	2009-05-29 15:41:54 UTC (rev 19500)
@@ -8,7 +8,6 @@
 
 import aterm.ATerm;
 import aterm.ATermAppl;
-import aterm.ATermList;
 import aterm.pure.ATermListImpl;
 
 /**

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/StrategoListProxy.java
===================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/StrategoListProxy.java	2009-05-29 15:28:16 UTC (rev 19499)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/StrategoListProxy.java	2009-05-29 15:41:54 UTC (rev 19500)
@@ -19,6 +19,10 @@
 	public void setWrapped(IStrategoList wrapped) {
 		this.wrapped = wrapped;
 	}
+    
+	public int getStorageType() {
+		return IMMUTABLE;
+	}
 
 	public IStrategoTerm get(int index) {
 		return getWrapped().get(index);

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/IWrappedAstNode.java
===================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/IWrappedAstNode.java	2009-05-29 15:28:16 UTC (rev 19499)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/IWrappedAstNode.java	2009-05-29 15:41:54 UTC (rev 19500)
@@ -8,5 +8,5 @@
  * @author Lennart Kats <lennart add lclnet.nl>
  */
 public interface IWrappedAstNode extends IStrategoTerm {
-	IAst getNode();
+	IStrategoAstNode getNode();
 }

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/WrappedAstNode.java
===================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/WrappedAstNode.java	2009-05-29 15:28:16 UTC (rev 19499)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/WrappedAstNode.java	2009-05-29 15:41:54 UTC (rev 19500)
@@ -8,13 +8,17 @@
 import org.spoofax.interpreter.terms.InlinePrinter;
 
 public abstract class WrappedAstNode implements IWrappedAstNode, IStrategoTerm, Cloneable {
-	private final IAst node;
+	private final IStrategoAstNode node;
 	
 	private final WrappedAstNodeFactory factory;
 	
 	private IStrategoList annotations;
+    
+	public int getStorageType() {
+		return IMMUTABLE;
+	}
 	
-	public final IAst getNode() {
+	public final IStrategoAstNode getNode() {
 		return node;
 	}
 	
@@ -22,7 +26,7 @@
 		return factory;
 	}
 	
-	protected WrappedAstNode(WrappedAstNodeFactory factory, IAst node) {
+	protected WrappedAstNode(WrappedAstNodeFactory factory, IStrategoAstNode node) {
 		this.factory = factory;
 		this.node = node;
 	}

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/WrappedAstNodeAppl.java
===================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/WrappedAstNodeAppl.java	2009-05-29 15:28:16 UTC (rev 19499)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/WrappedAstNodeAppl.java	2009-05-29 15:41:54 UTC (rev 19500)
@@ -26,12 +26,6 @@
 		constructor = factory.makeConstructor(node.getConstructor(), node.getChildren().size());
 	}
 	
-	protected WrappedAstNodeAppl(WrappedAstNodeFactory factory, IAst node) {
-		super(factory, node);
-		
-		constructor = factory.makeConstructor(node.getClass().getSimpleName(), node.getChildren().size());
-	}
-	
 	public final IStrategoTerm[] getArguments() {
 		return getAllSubterms();
 	}

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/WrappedAstNodeFactory.java
===================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/WrappedAstNodeFactory.java	2009-05-29 15:28:16 UTC (rev 19499)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/WrappedAstNodeFactory.java	2009-05-29 15:41:54 UTC (rev 19500)
@@ -39,7 +39,7 @@
 		}
 	}
 	
-	protected WrappedAstNodeList wrapList(IAst node, int offset) {
+	protected WrappedAstNodeList wrapList(IStrategoAstNode node, int offset) {
 		return new WrappedAstNodeList(this, node, offset);
 	}
 	

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/WrappedAstNodeLink.java
===================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/WrappedAstNodeLink.java	2009-05-29 15:28:16 UTC (rev 19499)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/WrappedAstNodeLink.java	2009-05-29 15:41:54 UTC (rev 19500)
@@ -21,7 +21,7 @@
 	
 	private final IStrategoTerm wrapped;
 	
-	public WrappedAstNodeLink(WrappedAstNodeFactory factory, IStrategoTerm term, IAst node) {
+	public WrappedAstNodeLink(WrappedAstNodeFactory factory, IStrategoTerm term, IStrategoAstNode node) {
 		super(factory, node);
 		this.wrapped = term;
 		assert !(wrapped instanceof IWrappedAstNode);

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/WrappedAstNodeList.java
===================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/WrappedAstNodeList.java	2009-05-29 15:28:16 UTC (rev 19499)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/adapter/WrappedAstNodeList.java	2009-05-29 15:41:54 UTC (rev 19500)
@@ -19,11 +19,11 @@
 	
 	private WrappedAstNodeList tail;
 	
-	protected WrappedAstNodeList(WrappedAstNodeFactory factory, IAst node) {
+	protected WrappedAstNodeList(WrappedAstNodeFactory factory, IStrategoAstNode node) {
 		this(factory, node, 0);
 	}
 
-	protected WrappedAstNodeList(WrappedAstNodeFactory factory, IAst node, int offset) {
+	protected WrappedAstNodeList(WrappedAstNodeFactory factory, IStrategoAstNode node, int offset) {
 		super(factory, node);
 		this.offset = offset;
 	}



From mdjonge at xs4all.nl  Wed May 20 14:58:55 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Wed, 20 May 2009 12:58:55 -0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19456 - MaartjeDeJonge
	- sglr-recovery
Message-ID: <200905201258.n4KCwcTd023366@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-05-20 12:59:10 +0000 (Wed, 20 May 2009)
New Revision: 19456

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19456&view=rev

Added:
   sglr-recovery/TestCoarseGrained/

Log:
Initial import.

Changes:



From mdjonge at xs4all.nl  Wed May 20 15:00:15 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Wed, 20 May 2009 13:00:15 -0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19457 - MaartjeDeJonge
	- in sglr-recovery/TestCoarseGrained: . grammars src src/test
	test_inputs test_inputs/common_cases test_inputs/problem_cases
Message-ID: <200905201259.n4KCxuvV023392@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-05-20 13:00:28 +0000 (Wed, 20 May 2009)
New Revision: 19457

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19457&view=rev

Added:
   sglr-recovery/TestCoarseGrained/.classpath
   sglr-recovery/TestCoarseGrained/.project
   sglr-recovery/TestCoarseGrained/grammars/
   sglr-recovery/TestCoarseGrained/grammars/Java-15.tbl
   sglr-recovery/TestCoarseGrained/implode.sh
   sglr-recovery/TestCoarseGrained/src/
   sglr-recovery/TestCoarseGrained/src/test/
   sglr-recovery/TestCoarseGrained/src/test/BaseTest.java
   sglr-recovery/TestCoarseGrained/src/test/Java_ComonCases.java
   sglr-recovery/TestCoarseGrained/src/test/Java_ProblemCases.java
   sglr-recovery/TestCoarseGrained/test_inputs/
   sglr-recovery/TestCoarseGrained/test_inputs/common_cases/
   sglr-recovery/TestCoarseGrained/test_inputs/common_cases/currentLineError.java
   sglr-recovery/TestCoarseGrained/test_inputs/common_cases/doubleClosed_If.java
   sglr-recovery/TestCoarseGrained/test_inputs/common_cases/flawedDeclaration.java
   sglr-recovery/TestCoarseGrained/test_inputs/common_cases/flawedImport.java
   sglr-recovery/TestCoarseGrained/test_inputs/common_cases/flawedMethodHeader.java
   sglr-recovery/TestCoarseGrained/test_inputs/common_cases/flawed_IfBlock.java
   sglr-recovery/TestCoarseGrained/test_inputs/common_cases/previousLineError.java
   sglr-recovery/TestCoarseGrained/test_inputs/common_cases/unclosedMethod.java
   sglr-recovery/TestCoarseGrained/test_inputs/common_cases/unclosed_If.java
   sglr-recovery/TestCoarseGrained/test_inputs/problem_cases/
   sglr-recovery/TestCoarseGrained/test_inputs/problem_cases/methodOutsideClass.java
   sglr-recovery/TestCoarseGrained/test_inputs/problem_cases/morePartsStructureError.java
   sglr-recovery/TestCoarseGrained/test_inputs/problem_cases/multipleErrors.java
   sglr-recovery/TestCoarseGrained/test_inputs/problem_cases/priorSiblingError.java
   sglr-recovery/TestCoarseGrained/test_inputs/problem_cases/sloppyCode.java
   sglr-recovery/TestCoarseGrained/test_inputs/problem_cases/testFile.java
   sglr-recovery/TestCoarseGrained/test_inputs/problem_cases/unclosedClassBody.java
   sglr-recovery/TestCoarseGrained/test_inputs/problem_cases/wrongIndentation1.java
   sglr-recovery/TestCoarseGrained/test_inputs/problem_cases/wrongSeparator.java
   sglr-recovery/TestCoarseGrained/test_outputs/

Log:


Changes:

Added: sglr-recovery/TestCoarseGrained/.classpath
===================================================================
--- sglr-recovery/TestCoarseGrained/.classpath	                        (rev 0)
+++ sglr-recovery/TestCoarseGrained/.classpath	2009-05-20 13:00:28 UTC (rev 19457)
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/3"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/org.spoofax.jsglr [spoofax-recovery branch]"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/org.spoofax.aterm"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>

Added: sglr-recovery/TestCoarseGrained/.project
===================================================================
--- sglr-recovery/TestCoarseGrained/.project	                        (rev 0)
+++ sglr-recovery/TestCoarseGrained/.project	2009-05-20 13:00:28 UTC (rev 19457)
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>TestCoarseGrained</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>

Added: sglr-recovery/TestCoarseGrained/grammars/Java-15.tbl
===================================================================
(Binary files differ)


Property changes on: sglr-recovery/TestCoarseGrained/grammars/Java-15.tbl
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: sglr-recovery/TestCoarseGrained/implode.sh
===================================================================
--- sglr-recovery/TestCoarseGrained/implode.sh	                        (rev 0)
+++ sglr-recovery/TestCoarseGrained/implode.sh	2009-05-20 13:00:28 UTC (rev 19457)
@@ -0,0 +1,15 @@
+#!/bin/sh
+
+
+
+
+for sampleName in test_outputs/*.pt
+do
+	sample=${sampleName%.*}
+	echo $sample
+	#pp-aterm -i $sample.pt -o $sample.pt.read
+	#implode-asfix -i $sample.pt | pp-aterm -o $sample.asfix.ast		
+	#implodePT -i $sample.pt | pp-aterm -o $sample.pt.ast	
+	#pp-java -i $sample.asfix.ast -o $sample.asfix.java
+    implode-asfix -i $sample.pt | pp-java -o $sample.recovered.java
+done


Property changes on: sglr-recovery/TestCoarseGrained/implode.sh
___________________________________________________________________
Added: svn:executable
   + *

Added: sglr-recovery/TestCoarseGrained/src/test/BaseTest.java
===================================================================
--- sglr-recovery/TestCoarseGrained/src/test/BaseTest.java	                        (rev 0)
+++ sglr-recovery/TestCoarseGrained/src/test/BaseTest.java	2009-05-20 13:00:28 UTC (rev 19457)
@@ -0,0 +1,52 @@
+package test;
+
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+import org.spoofax.jsglr.ParseTableManager;
+import org.spoofax.jsglr.SGLR;
+import org.spoofax.jsglr.SGLRException;
+import org.spoofax.jsglr.Tools;
+
+import aterm.ATerm;
+
+import junit.framework.TestCase;
+
+public abstract class BaseTest extends TestCase{
+	
+	protected String parseTable;
+	protected String fileName;
+	protected String inputDir;
+	
+	protected SGLR sglr;
+	private InputStream fis;
+	
+	@Override
+	protected void setUp() throws Exception {		
+		ParseTableManager ptm = new ParseTableManager();		
+        sglr = new SGLR(ptm.getFactory(), ptm.loadFromFile(parseTable));
+        sglr.setUseStructureRecovery(true);
+        Tools.setDebug(false);
+        Tools.setLogging(false);
+	}
+	
+	protected ATerm parseTestfile() throws IOException, SGLRException
+	{
+		String input = "test_inputs/"+inputDir+"/"+fileName;
+		String output = "test_outputs/"+fileName+".pt";
+		Tools.debug("INPUT FILE: "+fileName);
+		Tools.debug("");
+		Tools.debug("ERROR FRAGMENT: ");
+		fis = new FileInputStream(input);
+		ATerm t=sglr.parse(fis);
+		Tools.debug("");
+		Tools.debug("***************************");
+		OutputStream ous = new FileOutputStream(output);
+        if(t != null)
+            ous.write(t.toString().getBytes());
+        return t;
+	}
+}

Added: sglr-recovery/TestCoarseGrained/src/test/Java_ComonCases.java
===================================================================
--- sglr-recovery/TestCoarseGrained/src/test/Java_ComonCases.java	                        (rev 0)
+++ sglr-recovery/TestCoarseGrained/src/test/Java_ComonCases.java	2009-05-20 13:00:28 UTC (rev 19457)
@@ -0,0 +1,71 @@
+package test;
+
+import java.io.IOException;
+
+import junit.framework.Assert;
+
+import org.spoofax.jsglr.SGLRException;
+
+public class Java_ComonCases extends BaseTest{
+	
+	public Java_ComonCases()
+	{
+		super();
+		inputDir="common_cases";
+		parseTable="grammars/Java-15.tbl";		
+	}	
+	
+	public void testCurrentLineError() throws IOException, SGLRException
+	{		
+		fileName ="currentLineError.java";
+		parseTestfile();
+	}
+	
+	public void testIfBlock() throws IOException, SGLRException
+	{		
+		fileName ="flawed_IfBlock.java";
+		parseTestfile();
+	}
+	
+	public void testPreviousLineError() throws IOException, SGLRException
+	{		
+		fileName ="previousLineError.java";
+		parseTestfile();
+	}
+	
+	public void testDoubleClosedIf() throws IOException, SGLRException
+	{		
+		fileName ="doubleClosed_If.java";
+		parseTestfile();
+	}
+	
+	public void testMethodHeader() throws IOException, SGLRException
+	{
+		fileName ="flawedMethodHeader.java";
+		parseTestfile();
+	}
+
+	public void testUnclosedMethod() throws IOException, SGLRException
+	{
+		fileName ="unclosedMethod.java";
+		parseTestfile();
+	}
+	
+	public void testUnclosedIf() throws IOException, SGLRException
+	{		
+		fileName ="unclosed_If.java";
+		parseTestfile();
+	}
+	
+	public void testErrorInDeclaration() throws IOException, SGLRException
+	{
+		fileName ="flawedDeclaration.java";
+		parseTestfile();
+	}
+	
+	public void testErrorInImports() throws IOException, SGLRException
+	{
+		fileName ="flawedImport.java";
+		parseTestfile();
+	}	
+}

Added: sglr-recovery/TestCoarseGrained/src/test/Java_ProblemCases.java
===================================================================
--- sglr-recovery/TestCoarseGrained/src/test/Java_ProblemCases.java	                        (rev 0)
+++ sglr-recovery/TestCoarseGrained/src/test/Java_ProblemCases.java	2009-05-20 13:00:28 UTC (rev 19457)
@@ -0,0 +1,74 @@
+package test;
+
+import java.io.IOException;
+
+import junit.framework.Assert;
+
+import org.spoofax.jsglr.SGLRException;
+
+public class Java_ProblemCases extends BaseTest{
+	
+	public Java_ProblemCases()
+	{
+		super();
+		parseTable="grammars/Java-15.tbl";
+		inputDir="problem_cases";		
+	}
+	
+	public void testTestFile() throws IOException, SGLRException
+	{
+		fileName ="testFile.java";
+		parseTestfile();
+	}
+	
+	/*
+	public void testWrongIndentation1() throws IOException, SGLRException
+	{
+		fileName ="wrongIndentation1.java";
+		parseTestfile();
+	}*/	
+	
+	public void testMultipleErrors() throws IOException, SGLRException
+	{		
+		fileName ="multipleErrors.java";
+		parseTestfile();
+	}
+	
+	public void testUnclosedClass() throws IOException, SGLRException
+	{
+		fileName ="unclosedClassBody.java";
+		parseTestfile();
+	}
+	
+	public void testPriorSibling() throws IOException, SGLRException
+	{
+		fileName ="priorSiblingError.java";
+		parseTestfile();
+	}
+	
+	public void testMorePartsStructError() throws IOException, SGLRException
+	{
+		fileName ="morePartsStructureError.java";
+		parseTestfile();
+	}	
+	
+	public void testOutsideMethod() throws IOException, SGLRException
+	{
+		fileName ="methodOutsideClass.java";
+		parseTestfile();
+	}	
+	
+	public void testSloppyCode() throws IOException, SGLRException
+	{
+		fileName ="sloppyCode.java";
+		parseTestfile();
+	}
+	
+	public void testwrongSeparator() throws IOException, SGLRException
+	{		
+		fileName ="wrongSeparator.java";
+		parseTestfile();
+	}
+	
+	
+}

Added: sglr-recovery/TestCoarseGrained/test_inputs/common_cases/currentLineError.java
===================================================================
--- sglr-recovery/TestCoarseGrained/test_inputs/common_cases/currentLineError.java	                        (rev 0)
+++ sglr-recovery/TestCoarseGrained/test_inputs/common_cases/currentLineError.java	2009-05-20 13:00:28 UTC (rev 19457)
@@ -0,0 +1,29 @@
+package test;
+
+import java.io.IOException;
+import junit.framework.Assert;
+import org.spoofax.jsglr.SGLRException;
+class X {
+	
+  private int correctMethod1(){
+     corr2();    
+     return corrInt;
+  }
+
+  private int ErrorFragment(){
+      int corrLine1;
+      corrLine2();
+      bla bla bla
+      corrLine3();
+  }      
+  
+  private int correctMethod2(){
+      corr2();
+      corr2();
+      int corrInt=1;
+      return corrInt;
+  }
+  
+
+}
+

Added: sglr-recovery/TestCoarseGrained/test_inputs/common_cases/doubleClosed_If.java
===================================================================
--- sglr-recovery/TestCoarseGrained/test_inputs/common_cases/doubleClosed_If.java	                        (rev 0)
+++ sglr-recovery/TestCoarseGrained/test_inputs/common_cases/doubleClosed_If.java	2009-05-20 13:00:28 UTC (rev 19457)
@@ -0,0 +1,31 @@
+package org.spoofax.jsglr;
+
+import java.io.IOException;
+import java.util.ArrayList;
+
+class X {
+	
+  private int correctMethod1(){
+     bla();
+     bla();
+     int i=1;
+     return 2;
+  }
+	
+  private int wronglyClosedMethod(){
+	  if(true)//{
+         i=5;
+      }
+      int j;
+      bla();      
+  }     
+  
+  private int correctMethod2(){
+      bla();
+      bla();
+      int i=1;
+      return 2;
+  }
+
+
+}
\ No newline at end of file

Added: sglr-recovery/TestCoarseGrained/test_inputs/common_cases/flawedDeclaration.java
===================================================================
--- sglr-recovery/TestCoarseGrained/test_inputs/common_cases/flawedDeclaration.java	                        (rev 0)
+++ sglr-recovery/TestCoarseGrained/test_inputs/common_cases/flawedDeclaration.java	2009-05-20 13:00:28 UTC (rev 19457)
@@ -0,0 +1,19 @@
+package org.spoofax.jsglr;
+
+import java.io.IOException;
+import java.util.ArrayList;
+
+class X {
+	
+  private int anInt; 
+  private int errorDeclaration //;
+  private String aString;  
+	
+  private int correctMethod(){
+     bla();
+     bla();
+     int i=1;
+     return 2;
+  }	
+  
+}
\ No newline at end of file

Added: sglr-recovery/TestCoarseGrained/test_inputs/common_cases/flawedImport.java
===================================================================
--- sglr-recovery/TestCoarseGrained/test_inputs/common_cases/flawedImport.java	                        (rev 0)
+++ sglr-recovery/TestCoarseGrained/test_inputs/common_cases/flawedImport.java	2009-05-20 13:00:28 UTC (rev 19457)
@@ -0,0 +1,16 @@
+package org.spoofax.jsglr;
+
+import java.io.IOException;
+import java.ErrorImport //;
+import java.io;
+
+class X {
+  
+  private int correctMethod1(){
+      bla();
+      bla();
+      int i=1;
+      return 2;
+  }
+
+}
\ No newline at end of file

Added: sglr-recovery/TestCoarseGrained/test_inputs/common_cases/flawedMethodHeader.java
===================================================================
--- sglr-recovery/TestCoarseGrained/test_inputs/common_cases/flawedMethodHeader.java	                        (rev 0)
+++ sglr-recovery/TestCoarseGrained/test_inputs/common_cases/flawedMethodHeader.java	2009-05-20 13:00:28 UTC (rev 19457)
@@ -0,0 +1,27 @@
+package org.spoofax.jsglr;
+
+import java.io.IOException;
+import java.util.ArrayList;
+
+class X {
+	
+  private ErrorFragment(){
+	 int i=1;
+     int i;
+  }
+	
+  private int correctMethod1(){
+     bla();
+     bla();
+     int i=1;
+     return 2;
+  }
+    
+  private int correctMethod2(){
+      bla();
+      bla();
+      int i=1;
+      return 2;
+  }
+
+}
\ No newline at end of file

Added: sglr-recovery/TestCoarseGrained/test_inputs/common_cases/flawed_IfBlock.java
===================================================================
--- sglr-recovery/TestCoarseGrained/test_inputs/common_cases/flawed_IfBlock.java	                        (rev 0)
+++ sglr-recovery/TestCoarseGrained/test_inputs/common_cases/flawed_IfBlock.java	2009-05-20 13:00:28 UTC (rev 19457)
@@ -0,0 +1,25 @@
+class X {
+	
+  private int correctMethod1(){
+     corr2();    
+     return corrInt;
+  }
+
+  private int ErrorFragment(){
+      int corrLine1;
+      corrLine2();
+      if(bla))
+    	  int i=0;    	          
+      corrLine3();
+  }      
+  
+  private int correctMethod2(){
+      corr2();
+      corr2();
+      int corrInt=1;
+      return corrInt;
+  }
+  
+
+}
+

Added: sglr-recovery/TestCoarseGrained/test_inputs/common_cases/previousLineError.java
===================================================================
--- sglr-recovery/TestCoarseGrained/test_inputs/common_cases/previousLineError.java	                        (rev 0)
+++ sglr-recovery/TestCoarseGrained/test_inputs/common_cases/previousLineError.java	2009-05-20 13:00:28 UTC (rev 19457)
@@ -0,0 +1,24 @@
+class X {
+	
+  private int correctMethod1(){
+     corr2();    
+     return corrInt;
+  }
+
+  private int ErrorFragment(){
+      int corrLine1;
+      corrLine2();
+      int i = bla( 
+      corrLine3();
+  }      
+  
+  private int correctMethod2(){
+      corr2();
+      corr2();
+      int corrInt=1;
+      return corrInt;
+  }
+  
+
+}
+

Added: sglr-recovery/TestCoarseGrained/test_inputs/common_cases/unclosedMethod.java
===================================================================
--- sglr-recovery/TestCoarseGrained/test_inputs/common_cases/unclosedMethod.java	                        (rev 0)
+++ sglr-recovery/TestCoarseGrained/test_inputs/common_cases/unclosedMethod.java	2009-05-20 13:00:28 UTC (rev 19457)
@@ -0,0 +1,21 @@
+class X {
+	
+  private int correctMethod1(){
+     corr2();    
+     return corrInt;
+  }
+
+  private int UnclosedMethod(){
+      int corrLine1;
+      corrLine2();//}     
+  
+  private int correctMethod2(){
+      corr2();
+      corr2();
+      int corrInt=1;
+      return corrInt;
+  }
+  
+
+}
+

Added: sglr-recovery/TestCoarseGrained/test_inputs/common_cases/unclosed_If.java
===================================================================
--- sglr-recovery/TestCoarseGrained/test_inputs/common_cases/unclosed_If.java	                        (rev 0)
+++ sglr-recovery/TestCoarseGrained/test_inputs/common_cases/unclosed_If.java	2009-05-20 13:00:28 UTC (rev 19457)
@@ -0,0 +1,29 @@
+package org.spoofax.jsglr;
+
+import java.io.IOException;
+import java.util.ArrayList;
+
+class X {
+	
+  private int correctMethod1(){
+     bla();
+     bla();
+     int i=1;
+     return 2;
+  }
+	
+  private int UnclosedIf(){
+	  if(true){
+		  i=5;
+	  //}
+	  return 7;  	
+  } 
+	  
+  private int correctMethod2(){
+      bla();
+      bla();
+      int i=1;
+      return 2;
+  }
+
+}
\ No newline at end of file

Added: sglr-recovery/TestCoarseGrained/test_inputs/problem_cases/methodOutsideClass.java
===================================================================
--- sglr-recovery/TestCoarseGrained/test_inputs/problem_cases/methodOutsideClass.java	                        (rev 0)
+++ sglr-recovery/TestCoarseGrained/test_inputs/problem_cases/methodOutsideClass.java	2009-05-20 13:00:28 UTC (rev 19457)
@@ -0,0 +1,21 @@
+class X {
+	
+  private int correctMethod1(){
+     corr2();
+     corr2();
+     if(true)
+        return 5;
+     int corrInt=1;
+     return corrInt;
+  }
+  
+  private int bla(){
+	  bla();
+  }
+}
+  int outsideClassMethod(){
+	  return 5;
+  }
+  
+
+  
\ No newline at end of file

Added: sglr-recovery/TestCoarseGrained/test_inputs/problem_cases/morePartsStructureError.java
===================================================================
--- sglr-recovery/TestCoarseGrained/test_inputs/problem_cases/morePartsStructureError.java	                        (rev 0)
+++ sglr-recovery/TestCoarseGrained/test_inputs/problem_cases/morePartsStructureError.java	2009-05-20 13:00:28 UTC (rev 19457)
@@ -0,0 +1,30 @@
+class X {
+	
+  private int correctMethod1(){
+     corr2();    
+     return corrInt;
+  }
+
+  private int errorFragment(){
+      int corrLine1;
+      corrLine2();
+      if(bla()){
+          int i;
+          return 2; // }
+      else if (true)
+          return 4;
+      else
+          return 5;
+      corrLine3();
+  }     
+  
+  private int correctMethod2(){
+      corr2();
+      corr2();
+      int corrInt=1;
+      return corrInt;
+  }
+  
+
+}
+

Added: sglr-recovery/TestCoarseGrained/test_inputs/problem_cases/multipleErrors.java
===================================================================
--- sglr-recovery/TestCoarseGrained/test_inputs/problem_cases/multipleErrors.java	                        (rev 0)
+++ sglr-recovery/TestCoarseGrained/test_inputs/problem_cases/multipleErrors.java	2009-05-20 13:00:28 UTC (rev 19457)
@@ -0,0 +1,32 @@
+class X {
+	
+  private int correctMethod1(){
+     corr2();
+     corr2();
+     if(true)
+        return 5;
+     int corrInt=1;
+     return corrInt;
+  }
+  
+  private int correctMethod2(){
+      corr2();
+      corr2();
+      int corrInt=1;
+      return corrInt;  }
+
+
+  bla() mm ss
+  bla()^^*_+
+  int i=1* sdf
+  return 22 at dd   
+  
+  private int correctMethod3(){
+      corr2();
+      corr2();
+      int corrInt=1;
+      return corrInt;
+  }  
+
+}
+

Added: sglr-recovery/TestCoarseGrained/test_inputs/problem_cases/priorSiblingError.java
===================================================================
--- sglr-recovery/TestCoarseGrained/test_inputs/problem_cases/priorSiblingError.java	                        (rev 0)
+++ sglr-recovery/TestCoarseGrained/test_inputs/problem_cases/priorSiblingError.java	2009-05-20 13:00:28 UTC (rev 19457)
@@ -0,0 +1,28 @@
+class X {
+	
+  private int correctMethod1(){
+     corr2();    
+     return corrInt;
+  }
+
+  private int errorFragment(){
+      int i;
+      if(true)
+          doSomething();
+      }
+      int j;
+      int k;
+      doSomething2();
+      return 5;
+  }  
+  
+  private int correctMethod2(){
+      corr2();
+      corr2();
+      int corrInt=1;
+      return corrInt;
+  }
+  
+
+}
+

Added: sglr-recovery/TestCoarseGrained/test_inputs/problem_cases/sloppyCode.java
===================================================================
--- sglr-recovery/TestCoarseGrained/test_inputs/problem_cases/sloppyCode.java	                        (rev 0)
+++ sglr-recovery/TestCoarseGrained/test_inputs/problem_cases/sloppyCode.java	2009-05-20 13:00:28 UTC (rev 19457)
@@ -0,0 +1,54 @@
+class X {
+	
+  private int correctMethod1(){
+     corr2();
+     corr2();
+     if(true)
+        return 5;
+     int corrInt=1;
+     return corrInt;
+  }
+
+  private int ErrorTooMuchClosing(){
+      if(bla1()){
+         while(true)//{
+             bla2();
+         }
+         stm();
+      }
+      int i;
+      int j;
+      bla3();
+  }
+
+  int i
+
+  private int ErrorMissingClosing(){
+     if(bla1()){
+       bla();
+       while(true){
+           bla2();
+           stm(); //}
+     }
+     int i;
+     int j;
+     bla3();
+  }
+      
+  private int correctMethod3(){
+      corr2();
+      corr2();
+      int corrInt=1;
+      return corrInt;
+  }
+  
+  private int correctMethod4(){
+      corr2();
+      corr2();
+      int corrInt=1;
+      return corrInt;
+  }
+  
+
+}
+

Added: sglr-recovery/TestCoarseGrained/test_inputs/problem_cases/testFile.java
===================================================================
--- sglr-recovery/TestCoarseGrained/test_inputs/problem_cases/testFile.java	                        (rev 0)
+++ sglr-recovery/TestCoarseGrained/test_inputs/problem_cases/testFile.java	2009-05-20 13:00:28 UTC (rev 19457)
@@ -0,0 +1,38 @@
+class X {
+
+	 private int correctMethod1(){
+	     corr2();
+	     corr2();
+	     if(true)
+	        return 5;
+	     int corrInt=1;
+	     return corrInt;
+   }
+	
+  private int correctMethod1(){
+     corr2();
+     corr2();
+     if(true)
+        return 5;
+     int corrInt=1;
+     return corrInt;
+  }
+  
+ 
+
+  private int wronglyOpen(){ 
+      if(true){
+          bla();
+      i=1;    	
+  }    
+
+  private int correctMethod2(){
+      corr2();
+      corr2();
+      int corrInt=1;
+      return corrInt;
+  }
+  
+
+}
+

Added: sglr-recovery/TestCoarseGrained/test_inputs/problem_cases/unclosedClassBody.java
===================================================================
--- sglr-recovery/TestCoarseGrained/test_inputs/problem_cases/unclosedClassBody.java	                        (rev 0)
+++ sglr-recovery/TestCoarseGrained/test_inputs/problem_cases/unclosedClassBody.java	2009-05-20 13:00:28 UTC (rev 19457)
@@ -0,0 +1,20 @@
+class X {
+	
+	  private int correctMethod1(){
+	     corr2();
+	     corr2();
+	     if(true)
+	        return 5;
+	     int corrInt=1;
+	     return corrInt;
+	  }
+	  	  
+	  private int bla(){
+		  bla();
+	  }
+	  
+	  
+	  
+	     
+
+  
\ No newline at end of file

Added: sglr-recovery/TestCoarseGrained/test_inputs/problem_cases/wrongIndentation1.java
===================================================================
--- sglr-recovery/TestCoarseGrained/test_inputs/problem_cases/wrongIndentation1.java	                        (rev 0)
+++ sglr-recovery/TestCoarseGrained/test_inputs/problem_cases/wrongIndentation1.java	2009-05-20 13:00:28 UTC (rev 19457)
@@ -0,0 +1,22 @@
+package org.spoofax.jsglr;
+
+import java.io.IOException;
+import java.util.ArrayList;
+
+class X {
+	
+  private int correctMethod1(){
+     bla();
+     bla();
+     int i=1;
+     return 2;
+  }
+  
+  private int correctMethod2(){
+      bla();
+      bla();
+      int i=1;
+      return 2;
+  }
+
+}
\ No newline at end of file

Added: sglr-recovery/TestCoarseGrained/test_inputs/problem_cases/wrongSeparator.java
===================================================================
--- sglr-recovery/TestCoarseGrained/test_inputs/problem_cases/wrongSeparator.java	                        (rev 0)
+++ sglr-recovery/TestCoarseGrained/test_inputs/problem_cases/wrongSeparator.java	2009-05-20 13:00:28 UTC (rev 19457)
@@ -0,0 +1,24 @@
+class X {
+	
+  private int correctMethod1(){
+     corr2();    
+     return corrInt;
+  }
+
+  private enum errorEnum {
+      firstEl*
+      secondEl*
+      thirdEl*
+      fourthEl*
+  }  
+  
+  private int correctMethod2(){
+      corr2();
+      corr2();
+      int corrInt=1;
+      return corrInt;
+  }
+  
+
+}
+



From mdjonge at xs4all.nl  Wed May 20 15:18:35 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Wed, 20 May 2009 13:18:35 -0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19459 - MaartjeDeJonge
	- sglr-recovery
Message-ID: <200905201317.n4KDH8YS023912@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-05-20 13:17:40 +0000 (Wed, 20 May 2009)
New Revision: 19459

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19459&view=rev

Removed:
   sglr-recovery/TestCoarseGrained/

Log:
moved to sglr-bridges

Changes:



From mdjonge at xs4all.nl  Wed May 20 16:35:19 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Wed, 20 May 2009 14:35:19 -0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19461 - MaartjeDeJonge
	- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
Message-ID: <200905201435.n4KEZ0BF024699@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-05-20 14:35:32 +0000 (Wed, 20 May 2009)
New Revision: 19461

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19461&view=rev

Modified:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IndentInfo.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IndentTokenizer.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IndentationDisambiguator.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IndentationHandler.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java

Log:
some comments added

Changes:

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IndentInfo.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IndentInfo.java	2009-05-20 14:04:23 UTC (rev 19460)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IndentInfo.java	2009-05-20 14:35:32 UTC (rev 19461)
@@ -1,11 +1,12 @@
 package org.spoofax.jsglr;
 
-import java.util.List;
-
 import org.spoofax.ArrayDeque;
 
-import aterm.ATerm;
-
+/*
+ * Should be created before parsing the first character of a line
+ * Keeps information about indentation of a line.
+ * Keeps parser state in order to support backtracking
+ */
 public class IndentInfo {
     
     private int lineNumber;
@@ -15,17 +16,11 @@
         
     public ArrayDeque<Frame> getStackNodes() {
         return stackNodes;
-    }
-
-    public void setStackNodes(ArrayDeque<Frame> stackNodes) {
-        this.stackNodes = stackNodes;
-    }
+    }   
     
     public void fillStackNodes(ArrayDeque<Frame> nodes) {
-        stackNodes.clear();
-        ArrayDeque<Frame> stackNodes=new ArrayDeque<Frame>();
-        stackNodes.addAll(nodes);
-        setStackNodes(stackNodes);
+        stackNodes.clear();        
+        stackNodes.addAll(nodes);        
     } 
 
     public int getLineNumber() {
@@ -52,20 +47,8 @@
         this.indentValue = indentValue;
     }
     
-    public IndentInfo()
-    {
-        lineNumber=-1;
-        tokensSeen=-1;
-        indentValue=-1;
-        stackNodes=new ArrayDeque<Frame>();
-        
-    }
-    
     public static IndentInfo cloneIndentInfo(IndentInfo original){
-        IndentInfo cloneResult = new IndentInfo();
-        cloneResult.setTokensSeen(original.getTokensSeen());
-        cloneResult.setIndentValue(original.getIndentValue());
-        cloneResult.setLineNumber(original.getLineNumber());
+        IndentInfo cloneResult = new IndentInfo(original.getLineNumber(), original.getTokensSeen(), original.getIndentValue());
         cloneResult.fillStackNodes(original.getStackNodes());
         return cloneResult;    
     }
@@ -78,6 +61,9 @@
         stackNodes=new ArrayDeque<Frame>();
     }
 
+    /*
+     * Calculates the biggest reduce belonging to this backtrack point.
+     */
     public int maxReduceLength() {
         int maxPathLength = 0;
         for (Frame activeStack : stackNodes) {
@@ -91,6 +77,7 @@
         return maxPathLength;
     }    
     
+    //Calculates the start position of the biggest reduce
     public int structureStartPosition()
     {
         return tokensSeen - maxReduceLength();        

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IndentTokenizer.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IndentTokenizer.java	2009-05-20 14:04:23 UTC (rev 19460)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IndentTokenizer.java	2009-05-20 14:35:32 UTC (rev 19461)
@@ -5,23 +5,31 @@
 
 import org.spoofax.ArrayDeque;
 
+/*
+ * Creates tokens DEDENT and INDENT based on indentation.
+ * Use: use this class for whitespace sensitive languages like python.
+ * In the grammar: Use [244] and [245] as chars indicating indent and dedent respectively
+ */
 public class IndentTokenizer {
         
     private static final char INDENT_TOK = 244; //char used to represent indentation in syntax definition
     private static final char DEDENT_TOK = 245; //char used to represent 'dedentation' in syntax definition
     private Stack<Integer> indentStack;
-    int dedentCount;
-    boolean indentShift;
+    private int dedentCount;
+    private boolean indentShift;
     private boolean strictMode;
     private IndentationHandler myIndentHandler;
     
+    /*
+     * Creates indent and dedent tokens during parsing
+     */
     public IndentTokenizer(IndentationHandler indentInfo, boolean isStrictMode)
     {
         indentStack = new Stack<Integer>();
         this.strictMode=isStrictMode;
         myIndentHandler = indentInfo;
         initEvaluationVariables();
-}
+    }
  
     private void initEvaluationVariables() {
         myIndentHandler.initEvaluationVariables();
@@ -48,7 +56,9 @@
             indentShift=true;
         }
     }
-    
+    /*
+     * Recognizes an indent or dedent at the new line and tries to parse a indent-token or dedent-token
+     */
     public void handleIndentShifts(SGLR parser) throws IOException, ParseException
     {
         int curTok=parser.currentToken;

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IndentationDisambiguator.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IndentationDisambiguator.java	2009-05-20 14:04:23 UTC (rev 19460)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IndentationDisambiguator.java	2009-05-20 14:35:32 UTC (rev 19461)
@@ -8,8 +8,11 @@
 import aterm.ATermList;
 
 //TODO: implement all indentation rules 
-// RULE: All list elements have same indentation,  WEIGHT: 2
-// RULE: If elements have same indentation, prefer sibling interpretation, WEIGHT: 1
+// RULE 1: All list elements have same indentation
+// RULE 2: If elements have same indentation, prefer sibling interpretation
+// Rule 3: Closing tokens have same indentation as the first element
+// Rule 4: No dedent for siblings
+// Rule 5: ...
 
 /*Summary:
  * This class offers the possibility to disambiguate based on layout considerations.
@@ -20,22 +23,27 @@
  * and pick the option with the smallest deviation score or, if deviation is not conclusive, the highest congruence score. 
  * - A low deviation score means that few elements of the same list have differences in indentation    
  * - A high congruence score means that elements with the same indentation are contained in the same list, if possible
- * Algorithm:
- * Sums the differences in indentation between siblings for each list in the tree
- * Sums the number of list elements with the same indentation
  */
 public class IndentationDisambiguator {
      
-    private IndentationHandler myIndentHandler;
-    private IndentationHandler aHandler;
+    private IndentationHandler myIndentHandler; //keeps up with the indentation by dept-first inspection of the ATerm branch
+    private IndentationHandler helperIndentHandler; //helps to find the start indent
     private int indentDeviationListElements;// Sum differences in indentation of list elements, calculated for the root term.
     private int indentCongruenceOfListElements; //Number of congruent list elements  
-    private int indentDeviationClosingTokens;
+    private int indentDeviationClosingTokens; 
   
+    /*
+     * Gets the indent deviation of closing tokens with respect to the first child
+     * (does not work correct on the moment)
+     */
     public int getIndentDeviationClosingTokens() {
         return indentDeviationClosingTokens;
     }
 
+    /*
+     * Gets the deviation-sum of list elements with respect to the first child
+     * (Zero is good, high score shows a bad interpretation with respect to layout)
+     */
     public int getIndentDeviationListElements() {
         return indentDeviationListElements;
     }    
@@ -51,7 +59,7 @@
     public IndentationDisambiguator()
     {
         myIndentHandler=new IndentationHandler();
-        aHandler = new IndentationHandler();
+        helperIndentHandler = new IndentationHandler();
         initEvaluationVariables();
     }
  
@@ -75,6 +83,9 @@
         calcIndentationScore(branch);
     } 
     
+    /*
+     * evaluates an ATerm assuming a start-indentation for the first character
+     */
     public void evaluateIndentation(ATerm branch, int startIndent)
     {
         initEvaluationVariables();
@@ -120,13 +131,13 @@
         //calculate score by depth-first traversal
         else if (t.getChildCount()>1)              
         {            
-            aHandler.setIndentValue(myIndentHandler.getIndentValue());            
+            helperIndentHandler.setIndentValue(myIndentHandler.getIndentValue());            
             ATermList contents = termAt(t, 1);           
             int prevSiblingIdentValue = -1; 
             int firstChildIndentValue=-1;            
             for (int i = 0; i < contents.getLength(); i++) {                
-                aHandler.setIndentValue(myIndentHandler.getIndentValue());
-                int indentCurrentChild =findStartIndent(contents.elementAt(i), aHandler);
+                helperIndentHandler.setIndentValue(myIndentHandler.getIndentValue());
+                int indentCurrentChild =findStartIndent(contents.elementAt(i), helperIndentHandler);
                 if (indentCurrentChild >= 0 && prevSiblingIdentValue >=0) {
                     if(isListProduction(t)){                        
                         int diff = indentCurrentChild - prevSiblingIdentValue;                        
@@ -154,7 +165,7 @@
                     //Tools.debug("prev sib: "+prevSiblingIdentValue);
                     if(firstChildIndentValue<0){
                         firstChildIndentValue=indentCurrentChild;
-                        aHandler.setInLeftMargin(true);
+                        helperIndentHandler.setInLeftMargin(true);
                         //Tools.debug("first Child: "+firstChildIndentValue);
                     }
                     //Tools.debug("prev sib: "+prevSiblingIdentValue);

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IndentationHandler.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IndentationHandler.java	2009-05-20 14:04:23 UTC (rev 19460)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IndentationHandler.java	2009-05-20 14:35:32 UTC (rev 19461)
@@ -1,17 +1,24 @@
 package org.spoofax.jsglr;
 
+/*
+ * Keeps up with indentation by inspecting characters
+ * Use: inspect characters during parsing, or during the traversal of an ATerm
+ */
 public class IndentationHandler {
        
-    private boolean isInLeftMargin; //current position is in left margin
-    private int indentValue; //value of left margin for current position (set after parser read token)
+    private boolean isInLeftMargin; 
+    private int indentValue; 
     private boolean lineMarginFound;  
     
+    /*
+     * Says whether the indenthandler is supposed to be in the left margin 
+     */
     public void setInLeftMargin(boolean isInLeftMargin) {
         this.isInLeftMargin = isInLeftMargin;
     }
 
     /*
-     * In left marge of current line 
+     * Says whether the indenthandler is in left margin of current line 
      * (Last characters were: '/n' + layout)
      */
     public boolean isInLeftMargin() {
@@ -37,7 +44,9 @@
         return lineMarginFound;
     }    
 
-    //Keeps up with the value of the left indentation
+    /*
+     * Keeps up with the value of the left indentation
+     */
     public IndentationHandler()
     {
         initEvaluationVariables();

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java	2009-05-20 14:04:23 UTC (rev 19460)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java	2009-05-20 14:35:32 UTC (rev 19461)
@@ -5,11 +5,12 @@
 
 /*
  * Gives a coarse-grained recovery based on indentation and big-reduction.
- * Returns erroneous code fragments for inspection by refined recover methods
+ * Skips erroneous code fragments 
+ * These fragments can be recovered by refined recover methods
  */
 public class StructureRecovery extends RecoveryBase{
     
-    public enum SkipAction{
+    private enum SkipAction{
         SKIP_PREVIOUS,
         SKIP_CURRENT,
         SKIP_SIBLINGS,
@@ -25,20 +26,28 @@
     private ArrayList<IndentInfo> newLinePoints;   
     private int indexConstruct;
     private IndentInfo skipPoint;
-    public SkipAction recoverAction; //MJ: for testing
+    private SkipAction recoverAction;
     private int startSkipPosition;
     private int errorDetectionPosition;
     private boolean isForcingAccept;
     private boolean isInRecoverMode;
     
-    public boolean isInEofRecovery(){
+    /*
+     * Says wether the fallback recovery "find-accepting-state" is on.
+     * If this is the case, the parser must perform all possible reduce actions without a current token
+     */
+    public boolean useAcceptingStateRecovery(){
         return isForcingAccept;        
     }
-        
+    
+    /*
+     * Coarse-grained recovery by skipping code-fragments near the error.
+     * Uses layout to take human intention into account
+     */
     public StructureRecovery(){
         super();        
         newLinePoints = new ArrayList<IndentInfo>();
-        skipPoint=new IndentInfo();
+        skipPoint=new IndentInfo(0, 0, 0);
         //isDebugMode = true;        
         skipIndentHandler = new IndentationHandler();        
         indexConstruct=0;
@@ -75,6 +84,10 @@
         return newLinePoint;
     }    
 
+    /*
+     * (non-Javadoc)
+     * @see org.spoofax.jsglr.RecoveryBase#recover()
+     */
     @Override
     public void recover() throws IOException
     {
@@ -316,7 +329,9 @@
     protected boolean meetsRecoverCriteria() {
         return myParser.acceptingStack == null;//TODO: handle endless loop && myParser.currentToken != myParser.EOF;
     }
-    
+
+    //////////////////////////////////////// LOG INFO ////////////////////////////////////////////////////////////////
+
     private IndentInfo findNewLinePoint(int tokensSeen){
         for (int i = newLinePoints.size()-1; i >=0; i--) {
             if(newLinePoints.get(i).getTokensSeen()<=tokensSeen)
@@ -324,9 +339,7 @@
         }
         return null;
     }
-
-    //////////////////////////////////////// LOG INFO ////////////////////////////////////////////////////////////////
-
+    
     private void logRecoverResult() {
         if (isDebugMode) {
             if (recoverySucceeded()) {



From mdjonge at xs4all.nl  Wed May 20 16:36:14 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Wed, 20 May 2009 14:36:14 -0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19462 - MaartjeDeJonge
	- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
Message-ID: <200905201435.n4KEZv5Q024709@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-05-20 14:36:29 +0000 (Wed, 20 May 2009)
New Revision: 19462

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19462&view=rev

Modified:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java

Log:


Changes:

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-05-20 14:35:32 UTC (rev 19461)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-05-20 14:36:29 UTC (rev 19462)
@@ -328,7 +328,7 @@
 
         while (forShifter.size() > 0) {
             ActionState as = forShifter.remove();
-            if(roughRecoverParse.isInEofRecovery())
+            if(roughRecoverParse.useAcceptingStateRecovery())
                 prod=parseTable.lookupProduction(as.currentToken);
             if (!parseTable.hasRejects() || !as.st.allLinksRejected()) {
                 Frame st1 = findStack(activeStacks, as.s);
@@ -403,7 +403,7 @@
         State s = st.peek();
         logBeforeActor(st, s);        
         for (Action action : s.getActions()) {
-            if(roughRecoverParse.isInEofRecovery())
+            if(roughRecoverParse.useAcceptingStateRecovery())
                 currentToken = action.getFirstCharValue();
             if (action.accepts(currentToken)) {
                 for (ActionItem ai : action.getActionItems()) {
@@ -579,7 +579,7 @@
     
     private void handleAmbiguity(int numberOfAvoids, IParseNode t, Link nl) {        
         //if both branches contain no recover productions, create an Amb node.
-        if(roughRecoverParse.isInEofRecovery())
+        if(roughRecoverParse.useAcceptingStateRecovery())
             return; //no ambiguity!
         if(numberOfAvoids == 0 && nl.avoidCount==0){
             createAmbNode(t, nl);
@@ -635,7 +635,7 @@
                 continue; //stacknode will find reduction in regular process
 
             for (Action action : st2.peek().getActions()) {
-                if (action.accepts(currentToken) || (roughRecoverParse.isInEofRecovery())) {
+                if (action.accepts(currentToken) || (roughRecoverParse.useAcceptingStateRecovery())) {
                     for (ActionItem ai : action.getActionItems()) {                  
                         switch(ai.type) {
                             case ActionItem.REDUCE:



From mdjonge at xs4all.nl  Wed May 20 17:08:53 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Wed, 20 May 2009 15:08:53 -0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19463 - MaartjeDeJonge
	- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
Message-ID: <200905201508.n4KF8aRt025229@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-05-20 15:09:09 +0000 (Wed, 20 May 2009)
New Revision: 19463

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19463&view=rev

Modified:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java

Log:
continue if previous child does not exist

Changes:

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java	2009-05-20 14:36:29 UTC (rev 19462)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java	2009-05-20 15:09:09 UTC (rev 19463)
@@ -194,7 +194,8 @@
 
     private void skipPreviousConstruct() throws IOException {        
         setSkipPoint(newLinePoints.get(findIndexOfPreviousConstruct(indexConstruct)));
-        doSkipRecoverStep();
+        if(skipPoint.getTokensSeen()!=getConstructPoint().getTokensSeen())//no previous child
+            doSkipRecoverStep();
     }
 
     private int findIndexOfPreviousConstruct(int currentIndex) {
@@ -242,9 +243,8 @@
     }    
     
     private void continueParsing() throws IOException{        
-        if (isDebugMode) {
-            Tools.debug("-- RecoverParse started -- ");
-        }
+        //if (isDebugMode) 
+            Tools.debug("-- RecoverParse started -- ");        
         myParser.doParseStep();
         while(myParser.currentToken != SGLR.EOF && myParser.activeStacks.size() > 0) {                        
             readNextToken();            
@@ -274,9 +274,8 @@
     }    
     
     private void skipConstruct(IndentInfo skipP) throws IOException{
-        if (isDebugMode) {
-            Tools.debug("-- Skip started --");
-        }  
+        if (isDebugMode)
+            Tools.debug("-- Skip started --");        
         tokenIndex = skipP.getTokensSeen(); 
         skipIndentHandler.setInLeftMargin(false);
         boolean endSkipFound=false;
@@ -320,9 +319,8 @@
         tokenIndex++;
         myParser.currentToken = currentToken;
         skipIndentHandler.updateIndentation(currentToken);
-        if (isDebugMode) {
-            Tools.debug((char)myParser.currentToken + "(" + (tokenIndex - 1) + ")");
-        }
+        if (isDebugMode)
+            Tools.debug((char)myParser.currentToken + "(" + (tokenIndex - 1) + ")");        
     }    
     
     @Override



From mdjonge at xs4all.nl  Wed May 20 17:32:52 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Wed, 20 May 2009 15:32:52 -0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19464 - MaartjeDeJonge
	- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
Message-ID: <200905201532.n4KFWZbN025587@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-05-20 15:33:07 +0000 (Wed, 20 May 2009)
New Revision: 19464

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19464&view=rev

Modified:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java

Log:
while => do ... while

Changes:

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java	2009-05-20 15:09:09 UTC (rev 19463)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java	2009-05-20 15:33:07 UTC (rev 19464)
@@ -150,7 +150,7 @@
 
     private void skipChilds() throws IOException {
         int index = indexConstruct;
-        while ((recoverySucceeded()==false) && (myParser.currentToken != SGLR.EOF)&& index >=0) {
+        do {
             setSkipPoint(newLinePoints.get(index));
             int indent = skipPoint.getIndentValue();
             while (!hasDedent(skipPoint.getIndentValue(), indent) && (recoverySucceeded()==false) && (myParser.currentToken != SGLR.EOF)) {
@@ -161,7 +161,7 @@
                 index = newIndex;
             else
                 index = -1;//no prior childs
-        }        
+        } while ((recoverySucceeded()==false) && (myParser.currentToken != SGLR.EOF)&& index >=0);      
     }
     
     private boolean hasDedent(int indentNew, int indentOld) {
@@ -175,9 +175,9 @@
         else{
             setSkipPoint(newLinePoints.get(bigReduceIndex));
         }
-        while(recoverySucceeded()==false && myParser.currentToken != SGLR.EOF){
+        do {
            doSkipRecoverStep();
-        }        
+        } while(recoverySucceeded()==false && myParser.currentToken != SGLR.EOF);  
     } 
     
     private int findIndexOfParentConstruct() {
@@ -243,7 +243,7 @@
     }    
     
     private void continueParsing() throws IOException{        
-        //if (isDebugMode) 
+        if (isDebugMode) 
             Tools.debug("-- RecoverParse started -- ");        
         myParser.doParseStep();
         while(myParser.currentToken != SGLR.EOF && myParser.activeStacks.size() > 0) {                        



From mdjonge at xs4all.nl  Wed May 27 12:54:38 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Wed, 27 May 2009 10:54:38 -0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19469 - MaartjeDeJonge
	- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
Message-ID: <200905271054.n4RAsKPS015549@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-05-27 10:55:04 +0000 (Wed, 27 May 2009)
New Revision: 19469

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19469&view=rev

Added:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryIntegrator.java
Modified:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java

Log:
integration of structure-recovery and bridge-parsing

Changes:

Added: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryIntegrator.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryIntegrator.java	                        (rev 0)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryIntegrator.java	2009-05-27 10:55:04 UTC (rev 19469)
@@ -0,0 +1,41 @@
+package org.spoofax.jsglr;
+
+import java.io.IOException;
+
+public class RecoveryIntegrator {
+    private SGLR mySGLR;
+    
+    private StructureRecovery getStructureRecovery(){
+        return mySGLR.getRoughRecoverParse();
+    }
+    
+    public RecoveryIntegrator(SGLR parser){
+        mySGLR=parser;
+    }
+    
+    public void recover() throws IOException{
+        getStructureRecovery().recover();
+        String errorFragment = getStructureRecovery().getErrorFragment();
+        String repairedFragment = "/*"+errorFragment+"*/"; //TODO: use bridgeparser here
+        mySGLR.activeStacks=getStructureRecovery().getStartSkipPosition().getStackNodes();
+        Tools.debug("** Parse Repaired **");
+        tryParsing(repairedFragment);
+        if(mySGLR.activeStacks.size()>0){
+            Tools.debug("** Parse Remaining **");
+            getStructureRecovery().parseRemainingTokens();            
+        }
+    }
+    
+    private void tryParsing(String repairedFragment) throws IOException{
+        int indexFragment=0;
+        while((repairedFragment.charAt(indexFragment)==' ' || repairedFragment.charAt(indexFragment)=='\t') && indexFragment<repairedFragment.length()-1)
+            indexFragment++;        
+        while(indexFragment<repairedFragment.length() && mySGLR.activeStacks.size() > 0) {                        
+            mySGLR.currentToken=repairedFragment.charAt(indexFragment);
+            indexFragment++;
+            mySGLR.doParseStep();       
+            Tools.debug((char)mySGLR.currentToken);
+        }       
+    }
+
+}

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-05-26 10:20:47 UTC (rev 19468)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-05-27 10:55:04 UTC (rev 19469)
@@ -93,6 +93,8 @@
     //Keeps track of the indentation for each line
     private IndentationHandler indentHandler;
     
+    private RecoveryIntegrator recoverIntegrator;
+    
     //Keeps track of the indentation for each line
     public IndentationHandler getIndentHandler() {
         return indentHandler;
@@ -101,6 +103,10 @@
     //Creates a coarse grained recovery based on layout and big reductions    
     private StructureRecovery roughRecoverParse;
     
+    public StructureRecovery getRoughRecoverParse() {
+        return roughRecoverParse;
+    }
+
     private boolean useStructureRecovery;
 
     //Creates indent- and dedent- tokens
@@ -164,7 +170,9 @@
         recoverHandler.initialize(this);
         roughRecoverParse = new StructureRecovery();
         roughRecoverParse.initialize(this);
-        useStructureRecovery = false;        
+        useStructureRecovery = false;
+        recoverIntegrator=new RecoveryIntegrator(this);
+    
     }
 
     public static boolean isDebugging() {
@@ -241,7 +249,8 @@
             
             
             if(roughRecoverParse.meetsRecoverCriteria() && useStructureRecovery){
-                roughRecoverParse.recover();
+                recoverIntegrator.recover();
+                //roughRecoverParse.recover();
                 if(acceptingStack==null)
                     return sglrParse(startSymbol);
             }            

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java	2009-05-26 10:20:47 UTC (rev 19468)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java	2009-05-27 10:55:04 UTC (rev 19469)
@@ -27,11 +27,24 @@
     private int indexConstruct;
     private IndentInfo skipPoint;
     private SkipAction recoverAction;
-    private int startSkipPosition;
+    private IndentInfo startSkipPosition;
     private int errorDetectionPosition;
     private boolean isForcingAccept;
     private boolean isInRecoverMode;
     
+    public IndentInfo getStartSkipPosition() {
+        return startSkipPosition;
+    }
+    
+    public String getErrorFragment() {
+        String errorFragment="";
+        for (int i = startSkipPosition.getTokensSeen(); i < skipPoint.getTokensSeen(); i++) {
+            errorFragment+= recoverTokenStream[i];
+        }
+        Tools.debug(errorFragment);
+        return errorFragment;
+    }
+
     /*
      * Says wether the fallback recovery "find-accepting-state" is on.
      * If this is the case, the parser must perform all possible reduce actions without a current token
@@ -54,7 +67,7 @@
         bigReduceIndex = 0;
         previousBigReduceIndex =0;
         recoverAction =SkipAction.SKIP_PREVIOUS;
-        startSkipPosition=0;
+        startSkipPosition=new IndentInfo(0, 0, 0);
         errorDetectionPosition=-1;
         isForcingAccept=false;
         isInRecoverMode=false;
@@ -95,7 +108,7 @@
         indexConstruct=newLinePoints.size()-1;//Todo: consistent with use failure index 
         errorDetectionPosition=myParser.tokensSeen;
         recoverAction = SkipAction.SKIP_PREVIOUS;//TODO: 1 if ...
-        logBeforeRecover();         
+       // logBeforeRecover();         
         while (recoverySucceeded()==false && recoverAction != SkipAction.FAILED) {
             if(isDebugMode)
                 Tools.debug("ACTION: "+recoverAction);
@@ -134,7 +147,7 @@
                 break;          
             }            
         }
-        logRecoverFragment(startSkipPosition, skipPoint.getTokensSeen()-1);
+        //logRecoverFragment(startSkipPosition.getTokensSeen(), skipPoint.getTokensSeen()-1);
         isInRecoverMode=false;
     }
 
@@ -226,7 +239,12 @@
 
     private void setSkipPoint(IndentInfo startPoint) {
         skipPoint=IndentInfo.cloneIndentInfo(startPoint);
-        startSkipPosition = skipPoint.getTokensSeen();
+        startSkipPosition = IndentInfo.cloneIndentInfo(startPoint);
+        int tokIndexLine=startSkipPosition.getTokensSeen();
+        while (recoverTokenStream[tokIndexLine] != '\n' && tokIndexLine>0) {
+            tokIndexLine-=1;
+        }
+        startSkipPosition.setTokensSeen(tokIndexLine);
     }
     
     private IndentInfo getConstructPoint() {
@@ -237,7 +255,7 @@
         myParser.activeStacks.addAll(skipPoint.getStackNodes());
         skipConstruct(skipPoint);               
         if(isDebugMode)
-            logRecoverFragment(startSkipPosition, tokenIndex-2);
+            logRecoverFragment(startSkipPosition.getTokensSeen(), tokenIndex-2);
         continueParsing();        
         logRecoverResult();
     }    
@@ -253,6 +271,16 @@
                 return; //end of attempt                     
         }       
     }
+    
+    public void parseRemainingTokens() throws IOException{
+        int startIndex=skipPoint.getTokensSeen();
+        for (int i = startIndex; i < recoverTokenCount; i++) {
+            myParser.currentToken=recoverTokenStream[i];
+            myParser.doParseStep();
+            Tools.debug((char)myParser.currentToken);
+        }
+        
+    }
 
     private boolean meetsSuccessCriteriaForRecovery() {
         if(skipIndentHandler.lineMarginEnded() && tokenIndex == recoverTokenCount)



From mdjonge at xs4all.nl  Wed May 27 13:03:03 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Wed, 27 May 2009 11:03:03 -0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19471 - MaartjeDeJonge
	- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
Message-ID: <200905271102.n4RB2kG1015799@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-05-27 11:03:30 +0000 (Wed, 27 May 2009)
New Revision: 19471

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19471&view=rev

Added:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java
Removed:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryIntegrator.java
Modified:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java

Log:
rename + remove debug statements

Changes:

Copied: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java (from rev 19469, spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryIntegrator.java)
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java	                        (rev 0)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java	2009-05-27 11:03:30 UTC (rev 19471)
@@ -0,0 +1,39 @@
+package org.spoofax.jsglr;
+
+import java.io.IOException;
+
+public class RecoveryConnector {
+    private SGLR mySGLR;
+    
+    private StructureRecovery getStructureRecovery(){
+        return mySGLR.getRoughRecoverParse();
+    }
+    
+    public RecoveryConnector(SGLR parser){
+        mySGLR=parser;
+    }
+    
+    public void recover() throws IOException{
+        getStructureRecovery().recover();
+        String errorFragment = getStructureRecovery().getErrorFragment();
+        String repairedFragment = "/*"+errorFragment+"*/"; //TODO: use bridgeparser here
+        mySGLR.activeStacks=getStructureRecovery().getStartSkipPosition().getStackNodes();
+        
+        tryParsing(repairedFragment);
+        if(mySGLR.activeStacks.size()>0){
+            getStructureRecovery().parseRemainingTokens();            
+        }
+    }
+    
+    private void tryParsing(String repairedFragment) throws IOException{
+        int indexFragment=0;
+        while((repairedFragment.charAt(indexFragment)==' ' || repairedFragment.charAt(indexFragment)=='\t') && indexFragment<repairedFragment.length()-1)
+            indexFragment++;        
+        while(indexFragment<repairedFragment.length() && mySGLR.activeStacks.size() > 0) {                        
+            mySGLR.currentToken=repairedFragment.charAt(indexFragment);
+            indexFragment++;
+            mySGLR.doParseStep();
+        }       
+    }
+
+}


Property changes on: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java
___________________________________________________________________
Added: svn:mergeinfo
   + /spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/RecoveryIntegrator.java:18440

Deleted: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryIntegrator.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryIntegrator.java	2009-05-27 11:02:03 UTC (rev 19470)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryIntegrator.java	2009-05-27 11:03:30 UTC (rev 19471)
@@ -1,41 +0,0 @@
-package org.spoofax.jsglr;
-
-import java.io.IOException;
-
-public class RecoveryIntegrator {
-    private SGLR mySGLR;
-    
-    private StructureRecovery getStructureRecovery(){
-        return mySGLR.getRoughRecoverParse();
-    }
-    
-    public RecoveryIntegrator(SGLR parser){
-        mySGLR=parser;
-    }
-    
-    public void recover() throws IOException{
-        getStructureRecovery().recover();
-        String errorFragment = getStructureRecovery().getErrorFragment();
-        String repairedFragment = "/*"+errorFragment+"*/"; //TODO: use bridgeparser here
-        mySGLR.activeStacks=getStructureRecovery().getStartSkipPosition().getStackNodes();
-        Tools.debug("** Parse Repaired **");
-        tryParsing(repairedFragment);
-        if(mySGLR.activeStacks.size()>0){
-            Tools.debug("** Parse Remaining **");
-            getStructureRecovery().parseRemainingTokens();            
-        }
-    }
-    
-    private void tryParsing(String repairedFragment) throws IOException{
-        int indexFragment=0;
-        while((repairedFragment.charAt(indexFragment)==' ' || repairedFragment.charAt(indexFragment)=='\t') && indexFragment<repairedFragment.length()-1)
-            indexFragment++;        
-        while(indexFragment<repairedFragment.length() && mySGLR.activeStacks.size() > 0) {                        
-            mySGLR.currentToken=repairedFragment.charAt(indexFragment);
-            indexFragment++;
-            mySGLR.doParseStep();       
-            Tools.debug((char)mySGLR.currentToken);
-        }       
-    }
-
-}

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-05-27 11:02:03 UTC (rev 19470)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-05-27 11:03:30 UTC (rev 19471)
@@ -93,7 +93,7 @@
     //Keeps track of the indentation for each line
     private IndentationHandler indentHandler;
     
-    private RecoveryIntegrator recoverIntegrator;
+    private RecoveryConnector recoverIntegrator;
     
     //Keeps track of the indentation for each line
     public IndentationHandler getIndentHandler() {
@@ -171,7 +171,7 @@
         roughRecoverParse = new StructureRecovery();
         roughRecoverParse.initialize(this);
         useStructureRecovery = false;
-        recoverIntegrator=new RecoveryIntegrator(this);
+        recoverIntegrator=new RecoveryConnector(this);
     
     }
 

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java	2009-05-27 11:02:03 UTC (rev 19470)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java	2009-05-27 11:03:30 UTC (rev 19471)
@@ -276,8 +276,7 @@
         int startIndex=skipPoint.getTokensSeen();
         for (int i = startIndex; i < recoverTokenCount; i++) {
             myParser.currentToken=recoverTokenStream[i];
-            myParser.doParseStep();
-            Tools.debug((char)myParser.currentToken);
+            myParser.doParseStep();            
         }
         
     }



From mdjonge at xs4all.nl  Wed May 27 13:12:04 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Wed, 27 May 2009 11:12:04 -0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19472 - MaartjeDeJonge
	- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
Message-ID: <200905271111.n4RBBlnv015880@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-05-27 11:12:31 +0000 (Wed, 27 May 2009)
New Revision: 19472

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19472&view=rev

Modified:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java

Log:
bridge connection

Changes:

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java	2009-05-27 11:03:30 UTC (rev 19471)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java	2009-05-27 11:12:31 UTC (rev 19472)
@@ -16,14 +16,18 @@
     public void recover() throws IOException{
         getStructureRecovery().recover();
         String errorFragment = getStructureRecovery().getErrorFragment();
-        String repairedFragment = "/*"+errorFragment+"*/"; //TODO: use bridgeparser here
-        mySGLR.activeStacks=getStructureRecovery().getStartSkipPosition().getStackNodes();
-        
+        String repairedFragment = repairBridges(errorFragment);
+        mySGLR.activeStacks=getStructureRecovery().getStartSkipPosition().getStackNodes();        
         tryParsing(repairedFragment);
         if(mySGLR.activeStacks.size()>0){
             getStructureRecovery().parseRemainingTokens();            
         }
     }
+
+    private String repairBridges(String errorFragment) {
+        String repairedFragment = "/*"+errorFragment+"*/"; //TODO: use bridgeparser here
+        return repairedFragment;
+    }
     
     private void tryParsing(String repairedFragment) throws IOException{
         int indexFragment=0;



From emma at cs.lth.se  Wed May 27 16:24:44 2009
From: emma at cs.lth.se (Emma NilssonNyman)
Date: Wed, 27 May 2009 14:24:44 -0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19476 -
	EmmaNilssonNyman -
	spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
Message-ID: <200905271424.n4REOMSo019228@proliant.st.ewi.tudelft.nl>

Author: EmmaNilssonNyman
Date: 2009-05-27 14:25:06 +0000 (Wed, 27 May 2009)
New Revision: 19476

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19476&view=rev

Modified:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java

Log:
Changed visibility on activeStacks, currentToken and doParseStep() in SGLR.java

Changes:

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java	2009-05-27 14:03:53 UTC (rev 19475)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java	2009-05-27 14:25:06 UTC (rev 19476)
@@ -2,6 +2,7 @@
 
 import java.io.IOException;
 
+
 public class RecoveryConnector {
     private SGLR mySGLR;
     
@@ -11,6 +12,7 @@
     
     public RecoveryConnector(SGLR parser){
         mySGLR=parser;
+        // TODO This only works for Java with this bridge parser
     }
     
     public void recover() throws IOException{

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-05-27 14:03:53 UTC (rev 19475)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-05-27 14:25:06 UTC (rev 19476)
@@ -52,11 +52,11 @@
 
     protected Frame acceptingStack;
 
-    protected ArrayDeque<Frame> activeStacks;
+    public ArrayDeque<Frame> activeStacks;
 
     private ParseTable parseTable;
 
-    protected int currentToken;
+    public int currentToken;
 
     protected int tokensSeen;
 
@@ -282,7 +282,7 @@
         currentToken = getNextToken();    
     }
 
-    protected void doParseStep() throws IOException {               
+    public void doParseStep() throws IOException {               
         parseCharacter(); //applies reductions on active stack structure and fills forshifter                      
         shifter(); //renewes active stacks with states in forshifter
     }    



From emma at cs.lth.se  Thu May 28 16:47:06 2009
From: emma at cs.lth.se (Emma NilssonNyman)
Date: Thu, 28 May 2009 14:47:06 -0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19487 -
	EmmaNilssonNyman -
	sglr-recovery/trunk/recovery-runtime/src/sglrbridges
	spoofax/branches/spoofax-recovery/META-INF
	spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
Message-ID: <200905281446.n4SEkirN004157@proliant.st.ewi.tudelft.nl>

Author: EmmaNilssonNyman
Date: 2009-05-28 14:47:30 +0000 (Thu, 28 May 2009)
New Revision: 19487

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19487&view=rev

Added:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IRecoveryParser.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IRecoveryResult.java
Modified:
   sglr-recovery/trunk/recovery-runtime/src/sglrbridges/BridgeRecoveryParser.java
   spoofax/branches/spoofax-recovery/META-INF/MANIFEST.MF
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java

Log:
Modofied the SGLR recovery interface

Changes:

Modified: sglr-recovery/trunk/recovery-runtime/src/sglrbridges/BridgeRecoveryParser.java
===================================================================
--- sglr-recovery/trunk/recovery-runtime/src/sglrbridges/BridgeRecoveryParser.java	2009-05-28 14:21:44 UTC (rev 19486)
+++ sglr-recovery/trunk/recovery-runtime/src/sglrbridges/BridgeRecoveryParser.java	2009-05-28 14:47:30 UTC (rev 19487)
@@ -13,6 +13,8 @@
 import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.jsglr.BadTokenException;
+import org.spoofax.jsglr.IRecoveryParser;
+import org.spoofax.jsglr.IRecoveryResult;
 import org.spoofax.jsglr.InvalidParseTableException;
 import org.spoofax.jsglr.NoRecovery;
 import org.spoofax.jsglr.SGLRException;
@@ -32,7 +34,7 @@
 	
 	private final StandAloneSGLRI tokenParser;
 	
-	private final ISGLRBridgeParser bridgeParser;
+	private final IRecoveryParser bridgeParser;
 	
 	public BridgeRecoveryParser(InputStream parseTable, String startSymbol, InputStream tokenParseTable) throws IOException,
 			InvalidParseTableException {
@@ -43,7 +45,7 @@
 		tokenParser.setKeepAmbiguities(true);
 		tokenParser.setRecoverHandler(new NoRecovery());
 		
-		bridgeParser = new JavaSGLRBridgeParser(); // TODO: Properly select/load appropriate bridge parser
+		bridgeParser = new JavaSGLRBridgeParser(tokenParser); // TODO: Properly select/load appropriate bridge parser
 	}
 
 	public static void main(String[] args) throws Exception {
@@ -99,17 +101,17 @@
 		try {
 			String content = node.yield();
 			System.out.println("TEXT TO RECOVER:\n" + content);
-			tokenParser.setStartSymbol(sort);
-			node = tokenParser.parse(content.toCharArray(), null);
-			
-			RecoveryResult result = bridgeParser.recover((IStrategoAppl) node.getTerm());
-			String recovered = result.getResultAsString(); 
+			IRecoveryResult result = bridgeParser.recover(content, sort);
+			String recovered = result.getResult();
+			/*
 			Collection<RecoveryResult.Suggestion> suggestions = result.getSuggestions();
 			int i = 1; 
 			for (RecoveryResult.Suggestion s : suggestions) {
 				System.out.println("Recovery suggestion " + i++ + " : " + s);
 			}
+			*/
 			
+			
 			System.out.println("RECOVERED:\n" + recovered);
 			
 			// TODO: check log to see if recovered area changed
@@ -123,6 +125,8 @@
 			throw new RuntimeException(e); // not expected
 		} catch (SGLRException e) {
 			logLocalParseError(node, e);
+		} catch (Exception e) {
+			e.printStackTrace();
 		} finally {
 			getParser().setStartSymbol(getStartSymbol());
 		}

Modified: spoofax/branches/spoofax-recovery/META-INF/MANIFEST.MF
===================================================================
--- spoofax/branches/spoofax-recovery/META-INF/MANIFEST.MF	2009-05-28 14:21:44 UTC (rev 19486)
+++ spoofax/branches/spoofax-recovery/META-INF/MANIFEST.MF	2009-05-28 14:47:30 UTC (rev 19487)
@@ -6,5 +6,6 @@
 Export-Package: org.spoofax.jsglr
 Bundle-Vendor: Spoofax.org
 Require-Bundle: org.spoofax.aterm,
- org.junit
+ org.junit,
+ org.spoofax.interpreter.core
 Bundle-RequiredExecutionEnvironment: J2SE-1.5

Added: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IRecoveryParser.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IRecoveryParser.java	                        (rev 0)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IRecoveryParser.java	2009-05-28 14:47:30 UTC (rev 19487)
@@ -0,0 +1,6 @@
+package org.spoofax.jsglr;
+
+public interface IRecoveryParser {
+    IRecoveryResult recover(String text) throws Exception;
+    IRecoveryResult recover(String text, String startSymbol) throws Exception;
+}

Added: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IRecoveryResult.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IRecoveryResult.java	                        (rev 0)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IRecoveryResult.java	2009-05-28 14:47:30 UTC (rev 19487)
@@ -0,0 +1,5 @@
+package org.spoofax.jsglr;
+
+public interface IRecoveryResult {
+    public String getResult();
+}

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java	2009-05-28 14:21:44 UTC (rev 19486)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java	2009-05-28 14:47:30 UTC (rev 19487)
@@ -2,17 +2,17 @@
 
 import java.io.IOException;
 
-
 public class RecoveryConnector {
     private SGLR mySGLR;
+    private IRecoveryParser recoveryParser;
     
     private StructureRecovery getStructureRecovery(){
         return mySGLR.getRoughRecoverParse();
     }
     
-    public RecoveryConnector(SGLR parser){
+    public RecoveryConnector(SGLR parser, IRecoveryParser recoveryParser){
         mySGLR=parser;
-        // TODO This only works for Java with this bridge parser
+        this.recoveryParser = recoveryParser;
     }
     
     public void recover() throws IOException{
@@ -27,8 +27,23 @@
     }
 
     private String repairBridges(String errorFragment) {
-        String repairedFragment = "/*"+errorFragment+"*/"; //TODO: use bridgeparser here
-        return repairedFragment;
+        try {
+            // TODO call recover(errorFragement, startSymbol) instead
+            IRecoveryResult result = recoveryParser.recover(errorFragment);
+            String repairedFragment = result.getResult(); 
+            return repairedFragment;
+        } catch (TokenExpectedException e) {
+            e.printStackTrace();
+        } catch (BadTokenException e) {
+            e.printStackTrace();
+        } catch (SGLRException e) {
+            e.printStackTrace();
+        } catch (IOException e) {
+            e.printStackTrace();
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return "/*" + errorFragment + "*/";
     }
     
     private void tryParsing(String repairedFragment) throws IOException{

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-05-28 14:21:44 UTC (rev 19486)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-05-28 14:47:30 UTC (rev 19487)
@@ -136,7 +136,8 @@
         return recoverHandler;
     }
 
-    public void setUseStructureRecovery(boolean useRoughRecovery) {
+    public void setUseStructureRecovery(boolean useRoughRecovery, IRecoveryParser parser) {
+        this.recoverIntegrator = new RecoveryConnector(this, parser);
         this.useStructureRecovery = useRoughRecovery;
     }
     
@@ -171,7 +172,7 @@
         roughRecoverParse = new StructureRecovery();
         roughRecoverParse.initialize(this);
         useStructureRecovery = false;
-        recoverIntegrator=new RecoveryConnector(this);
+        recoverIntegrator = null;
     
     }
 



From emma at cs.lth.se  Fri May 29 10:22:21 2009
From: emma at cs.lth.se (Emma NilssonNyman)
Date: Fri, 29 May 2009 08:22:21 -0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19490 -
	EmmaNilssonNyman -
	spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
Message-ID: <200905290822.n4T8LxTg016342@proliant.st.ewi.tudelft.nl>

Author: EmmaNilssonNyman
Date: 2009-05-29 08:22:46 +0000 (Fri, 29 May 2009)
New Revision: 19490

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19490&view=rev

Modified:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java

Log:
Small fix in RecoveryConnector to avoid StringIndexOutOfBoundsException

Changes:

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java	2009-05-28 20:35:25 UTC (rev 19489)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java	2009-05-29 08:22:46 UTC (rev 19490)
@@ -48,7 +48,7 @@
     
     private void tryParsing(String repairedFragment) throws IOException{
         int indexFragment=0;
-        while((repairedFragment.charAt(indexFragment)==' ' || repairedFragment.charAt(indexFragment)=='\t') && indexFragment<repairedFragment.length()-1)
+        while(indexFragment<repairedFragment.length()-1 && (repairedFragment.charAt(indexFragment)==' ' || repairedFragment.charAt(indexFragment)=='\t'))
             indexFragment++;        
         while(indexFragment<repairedFragment.length() && mySGLR.activeStacks.size() > 0) {                        
             mySGLR.currentToken=repairedFragment.charAt(indexFragment);



From mdjonge at xs4all.nl  Fri May 29 13:56:10 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Fri, 29 May 2009 11:56:10 -0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19491 - MaartjeDeJonge
	- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
Message-ID: <200905291155.n4TBtlA6019495@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-05-29 11:56:34 +0000 (Fri, 29 May 2009)
New Revision: 19491

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19491&view=rev

Added:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParserHistory.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryRefactored.java
Modified:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java

Log:


Changes:

Added: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParserHistory.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParserHistory.java	                        (rev 0)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParserHistory.java	2009-05-29 11:56:34 UTC (rev 19491)
@@ -0,0 +1,172 @@
+package org.spoofax.jsglr;
+
+import java.io.IOException;
+import java.util.ArrayList;
+
+public class ParserHistory {
+    
+    private int previousBigReduceIndex;
+    private int bigReduceIndex;    
+    private int indexConstruct;    
+    private ArrayList<IndentInfo> newLinePoints;      
+    private char[] recoverTokenStream;
+    private int recoverTokenCount;
+    private int tokenIndex;
+    
+    public ParserHistory(){
+        previousBigReduceIndex=0;
+        bigReduceIndex=0;
+        newLinePoints=new ArrayList<IndentInfo>();        
+        recoverTokenStream = new char[200];
+        recoverTokenCount = 0;
+        indexConstruct=0;
+        tokenIndex=0;
+    }
+    
+    /*
+     * Set current token based on recover tokens or read from new tokens
+     */
+    public void readRecoverToken(SGLR myParser) throws IOException{        
+        if (hasFinishedRecoverTokens()) {
+            myParser.readNextToken();                
+            myParser.getIndentHandler().updateIndentation(myParser.currentToken);
+            keepToken((char)myParser.currentToken);
+        }
+        myParser.currentToken = recoverTokenStream[tokenIndex];
+        tokenIndex++;
+    }
+    
+    public boolean hasFinishedRecoverTokens() {
+        return tokenIndex >= recoverTokenCount;
+    }
+    
+    public int getTokensSeenStartLine(int tokPosition){
+        int tokIndexLine=tokPosition;
+        while (recoverTokenStream[tokIndexLine] != '\n' && tokIndexLine>0) {
+            tokIndexLine-=1;
+        }
+        return tokIndexLine;
+    }
+    
+    public int getTokenIndex() {
+        return tokenIndex;
+    }
+
+    public void setTokenIndex(int tokenIndex) {
+        this.tokenIndex = tokenIndex;
+    }
+
+    public void afterStreamRead(SGLR myParser) {
+        keepToken((char)myParser.currentToken);
+        if(myParser.getIndentHandler().lineMarginEnded())
+            keepNewLinePoint(myParser);
+    }
+
+    private void keepToken(char currentToken) {
+        recoverTokenStream[recoverTokenCount++] = currentToken;         
+        if (recoverTokenCount == recoverTokenStream.length) {
+            char[] copy = recoverTokenStream;
+            recoverTokenStream = new char[recoverTokenStream.length * 2];
+            System.arraycopy(copy, 0, recoverTokenStream, 0, copy.length);
+        }
+    }
+    
+    private void keepNewLinePoint(SGLR myParser) {
+        int indent = myParser.getIndentHandler().getIndentValue();
+        IndentInfo newLinePoint= new IndentInfo(myParser.lineNumber, myParser.tokensSeen-1, indent);
+        newLinePoint.fillStackNodes(myParser.activeStacks);
+        newLinePoints.add(newLinePoint);
+        //TODO: findBigReduceIndex()
+        if(newLinePoints.get(bigReduceIndex).maxReduceLength()< newLinePoint.maxReduceLength()){
+            previousBigReduceIndex = bigReduceIndex;
+            bigReduceIndex = newLinePoints.size()-1;                 
+        }
+    }
+    
+    public String getFragment(int startTok, int endTok) {
+        String fragment="";
+        for (int i = startTok; i <= endTok; i++) {
+            if(i >= recoverTokenCount)
+                break;
+            fragment+= recoverTokenStream[i];
+        }        
+        return fragment;
+    }
+    
+    public IndentInfo getConstructPoint() {
+        return newLinePoints.get(indexConstruct);
+    }
+    
+    public IndentInfo startBigReduce() {
+        return newLinePoints.get(bigReduceIndex);
+    }   
+    
+    public IndentInfo startPreviousBigReduce() {
+        return newLinePoints.get(previousBigReduceIndex);
+    } 
+    
+    public void setIndexOnParentConstruct() {
+        int parentConstructIndex=0;
+        int loopIndex = newLinePoints.size()-2;
+        while ( loopIndex >= 0 && parentConstructIndex==0) {
+            if(newLinePoints.get(loopIndex).getIndentValue()< getConstructPoint().getIndentValue()){
+                parentConstructIndex = loopIndex;               
+            }
+            loopIndex--;
+        }
+        indexConstruct = parentConstructIndex;
+    } 
+    
+    public int nrOfLines(){
+        return newLinePoints.size();
+    }
+    
+    public IndentInfo getLine(int index){
+        return newLinePoints.get(index);
+    }
+    
+    public void setIndexOnLastConstruct(){
+        indexConstruct=newLinePoints.size()-1;        
+    }
+
+    public boolean setIndexOnPreviousConstruct() {
+
+        if(indexConstruct<=0)
+            return false;
+        int previousConstructIndex=-1;
+        int loopIndex = indexConstruct -1;
+        IndentInfo currentLine=newLinePoints.get(indexConstruct);
+        while ( loopIndex >= 0 && previousConstructIndex==-1) {
+            IndentInfo priorLine=newLinePoints.get(loopIndex);            
+            if(priorLine.getIndentValue()==currentLine.getIndentValue()){
+                if(loopIndex!=indexConstruct - 1 || priorLine.structureStartPosition() <= currentLine.structureStartPosition()){ //skip closing tag
+                    previousConstructIndex = loopIndex;   
+                }          
+            }
+            if(priorLine.getIndentValue()< currentLine.getIndentValue()){
+                return false;//first child               
+            }
+            loopIndex--;
+        }        
+        indexConstruct = previousConstructIndex;
+        return true;   
+    }
+    
+    ///////////////////////////////// LOG /////////////////////////////////////////////////////////////////
+    public void logBigReductionList() {        
+        for (int i = 0; i < newLinePoints.size(); i++) {
+            logBigReduction(newLinePoints.get(i));
+        }
+       // Tools.debug(info);
+        Tools.debug("**** BR-list ****");
+        Tools.debug("***************************");
+    }
+
+    private void logBigReduction(IndentInfo brPoint) {
+        Tools.debug("LINE: " +brPoint.getLineNumber());
+        Tools.debug("INDENT: " +brPoint.getIndentValue());
+        Tools.debug("REDUCE-LENGTH: " +brPoint.maxReduceLength());
+        Tools.debug("TOKEN-POSITION: " +brPoint.getTokensSeen());        
+        Tools.debug("........................");
+    }
+}

Added: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryRefactored.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryRefactored.java	                        (rev 0)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryRefactored.java	2009-05-29 11:56:34 UTC (rev 19491)
@@ -0,0 +1,351 @@
+package org.spoofax.jsglr;
+import java.io.IOException;
+import java.util.ArrayList;
+
+
+public class RecoveryRefactored {
+    private enum SkipAction{
+        SKIP_PREVIOUS,
+        SKIP_CURRENT,
+        SKIP_SIBLINGS,
+        SKIP_PARENT,
+        SKIP_FROM_BIGREDUCE,    
+        ENFORCE_ACCEPT,
+        FAILED        
+    }    
+    
+    private SGLR myParser;
+    private IndentationHandler skipIndentHandler;    
+    private IndentInfo skipPoint;
+    private SkipAction recoverAction;
+    private IndentInfo startSkipPosition;
+    private int errorDetectionPosition;    
+    protected boolean isDebugMode;
+    private ArrayList<IndentInfo> recoverNewLinePoints;   
+    
+    public IndentInfo getStartSkipPosition() {
+        return startSkipPosition;
+    }
+    
+    public String getErrorFragment() {       
+        return getHistory().getFragment(startSkipPosition.getTokensSeen(), skipPoint.getTokensSeen()-1);
+    }
+    
+    
+    /*
+     * Coarse-grained recovery by skipping code-fragments near the error.
+     * Uses layout to take human intention into account
+     */
+    public RecoveryRefactored(SGLR parser){
+        super();
+        myParser=parser;       
+        skipPoint=new IndentInfo(0, 0, 0);               
+        skipIndentHandler = new IndentationHandler();
+        recoverAction =SkipAction.SKIP_PREVIOUS;
+        startSkipPosition=new IndentInfo(0, 0, 0);
+        errorDetectionPosition=-1;
+        recoverNewLinePoints=new ArrayList<IndentInfo>();
+        isDebugMode=false;
+        //isDebugMode=true;
+    }
+
+    private ParserHistory getHistory() {
+        return myParser.history;
+    }
+
+    /*
+     * (non-Javadoc)
+     * @see org.spoofax.jsglr.RecoveryBase#recover()
+     */
+    public void recover() throws IOException {
+        getHistory().setIndexOnLastConstruct();
+        errorDetectionPosition=myParser.tokensSeen;
+        recoverAction = SkipAction.SKIP_PREVIOUS;//TODO: 1 if ...        
+       // logBeforeRecover();         
+        while (recoverySucceeded()==false && recoverAction != SkipAction.FAILED) {
+            if(isDebugMode)
+                Tools.debug("ACTION: "+recoverAction);
+            switch (recoverAction) {
+            case SKIP_PREVIOUS:
+                if(getHistory().setIndexOnPreviousConstruct()){
+                    skipCurrentConstruct();
+                }                
+                getHistory().setIndexOnLastConstruct();
+                recoverAction=SkipAction.SKIP_CURRENT;
+                break;
+            case SKIP_CURRENT:
+                skipCurrentConstruct();
+                recoverAction=SkipAction.SKIP_SIBLINGS;                
+                break;
+            case SKIP_SIBLINGS:
+                skipChilds();
+                recoverAction=SkipAction.SKIP_PARENT;
+                break;
+            case SKIP_PARENT:
+                getHistory().setIndexOnParentConstruct();
+                if(getHistory().getConstructPoint().getTokensSeen()<= getHistory().startPreviousBigReduce().getTokensSeen())
+                    recoverAction=SkipAction.SKIP_FROM_BIGREDUCE;
+                else
+                    recoverAction = SkipAction.SKIP_CURRENT;
+                break;
+            case SKIP_FROM_BIGREDUCE:
+                skipFromBigReduce();
+                recoverAction = SkipAction.ENFORCE_ACCEPT;
+                break;            
+            case ENFORCE_ACCEPT:
+                myParser.setEofRecoverParse(true);
+                forcingParse(); 
+                myParser.setEofRecoverParse(false);
+                recoverAction=SkipAction.FAILED;
+                break;  
+            case FAILED:                                
+                break;          
+            }            
+        }
+        //logRecoverFragment(startSkipPosition.getTokensSeen(), skipPoint.getTokensSeen()-1);
+        
+    }
+
+    private void forcingParse() throws IOException{
+        EofRecovery eofR = new EofRecovery();        
+        eofR.myParser=myParser;
+        eofR.enforceAccept(getHistory().startBigReduce().getStackNodes());
+    }
+
+    private boolean recoverySucceeded() {
+        return (myParser.activeStacks.size() > 0 || myParser.acceptingStack!=null);
+    }    
+
+    private void skipChilds() throws IOException {        
+        do {
+            setSkipPoint(getHistory().getConstructPoint());
+            int indent = skipPoint.getIndentValue();
+            while (!hasDedent(skipPoint.getIndentValue(), indent) && (recoverySucceeded()==false) && (myParser.currentToken != SGLR.EOF)) {
+                doSkipRecoverStep();
+            }            
+        } while ((recoverySucceeded()==false) && (myParser.currentToken != SGLR.EOF)&& getHistory().setIndexOnPreviousConstruct());      
+    }
+    
+    private boolean hasDedent(int indentNew, int indentOld) {
+        return indentNew !=indentOld;
+    }
+    
+    private void skipFromBigReduce() throws IOException {
+        boolean skipFromCurrent=getHistory().getConstructPoint().structureStartPosition()==getHistory().startPreviousBigReduce().structureStartPosition();
+        if(skipFromCurrent)
+            setSkipPoint(getHistory().getConstructPoint());
+        else {
+            boolean startOnPrevious = getHistory().startBigReduce().getIndentValue()>getHistory().startPreviousBigReduce().getIndentValue();
+            if(startOnPrevious){
+                setSkipPoint(getHistory().startPreviousBigReduce()); 
+            }
+            else{
+                setSkipPoint(getHistory().startBigReduce());
+            }
+        }
+        do {
+           doSkipRecoverStep();
+        } while(recoverySucceeded()==false && myParser.currentToken != SGLR.EOF);  
+    } 
+   
+    private void skipCurrentConstruct() throws IOException{  
+        //IndentInfo lineInfo = newLinePoints.get(failureIndex);
+        IndentInfo startPoint =getHistory().getConstructPoint();
+        setSkipPoint(startPoint);
+        doSkipRecoverStep();
+    }
+
+    private void setSkipPoint(IndentInfo startPoint) {
+        skipPoint=IndentInfo.cloneIndentInfo(startPoint);
+        startSkipPosition = IndentInfo.cloneIndentInfo(startPoint);
+        int tokIndexLine=getHistory().getTokensSeenStartLine(startSkipPosition.getTokensSeen());
+        startSkipPosition.setTokensSeen(tokIndexLine);
+    }
+    
+    
+
+    private void doSkipRecoverStep() throws IOException {
+        myParser.activeStacks.addAll(skipPoint.getStackNodes());
+        skipConstruct(skipPoint);
+        continueParsing();
+    }    
+    
+    private void continueParsing() throws IOException{
+        recoverNewLinePoints.clear();
+        if (isDebugMode) 
+            Tools.debug("-- RecoverParse started -- ");        
+        myParser.doParseStep();
+        while(myParser.currentToken != SGLR.EOF && myParser.activeStacks.size() > 0) {                        
+            readNextToken();            
+            myParser.doParseStep();
+            updateRecoverLinePoint(myParser);
+            if(meetsSuccessCriteriaForRecovery())
+                return; //end of attempt                     
+        }       
+    }
+    
+    public void parseRemainingTokens() throws IOException{
+        getHistory().setTokenIndex(skipPoint.getTokensSeen());
+        while(!getHistory().hasFinishedRecoverTokens()){        
+            getHistory().readRecoverToken(myParser);
+            myParser.doParseStep();            
+        }        
+    }
+
+    private boolean meetsSuccessCriteriaForRecovery() {
+        if(skipIndentHandler.lineMarginEnded() && getHistory().hasFinishedRecoverTokens())
+            return inspectLinePoints();
+        return false;
+    }
+    
+    private boolean inspectLinePoints() {        
+        boolean nonReduceLine = false;
+        for (int i = recoverNewLinePoints.size()-1; i >=0; i--) {
+            IndentInfo inspectedLine=recoverNewLinePoints.get(i);
+            if(inspectedLine.structureStartPosition()> errorDetectionPosition)
+                nonReduceLine=true;
+            if(nonReduceLine && inspectedLine.structureStartPosition() < errorDetectionPosition)
+                return true;
+            if(inspectedLine.getTokensSeen() < errorDetectionPosition)
+                return false;
+        }        
+        return false;
+    }    
+    
+    private void skipConstruct(IndentInfo skipP) throws IOException{
+        if (isDebugMode)
+            Tools.debug("-- Skip started --");        
+        getHistory().setTokenIndex(skipP.getTokensSeen()); 
+        skipIndentHandler.setInLeftMargin(false);
+        boolean endSkipFound=false;
+        while (endSkipFound==false) {//TODO: rewrite endskip criterium
+            readNextToken(); 
+            if (getHistory().getTokenIndex()>=getHistory().getLine(getHistory().nrOfLines()-1).getTokensSeen() && (skipIndentHandler.lineMarginEnded() && skipIndentHandler.getIndentValue() <= skipP.getIndentValue()) || myParser.currentToken==SGLR.EOF) {
+                endSkipFound=true;                 
+                int indent = skipIndentHandler.getIndentValue();
+                skipPoint = new IndentInfo(-1, getHistory().getTokenIndex() -1, indent);
+                skipPoint.fillStackNodes(myParser.activeStacks);
+            }
+            else{                
+                parseAsLayout();                
+            }
+        }        
+    }
+
+    private void parseAsLayout() throws IOException {        
+        switch (myParser.currentToken) {                
+        case '\n':
+            myParser.doParseStep();
+            break;
+        case '\t':
+            myParser.doParseStep();
+            break;
+        default:
+            myParser.currentToken=' ';
+            myParser.doParseStep();
+            break;
+        }
+    }
+    
+    private void readNextToken() throws IOException {
+        getHistory().readRecoverToken(myParser);
+        skipIndentHandler.updateIndentation(myParser.currentToken);
+        if (isDebugMode)
+            Tools.debug((char)myParser.currentToken); 
+    }    
+    
+    protected boolean meetsRecoverCriteria() {
+        return myParser.acceptingStack == null;//TODO: handle endless loop && myParser.currentToken != myParser.EOF;
+    } 
+   
+    private void updateRecoverLinePoint(SGLR myParser) {
+        if(myParser.getIndentHandler().lineMarginEnded()){
+            int indent = myParser.getIndentHandler().getIndentValue();
+            IndentInfo newLinePoint= new IndentInfo(myParser.lineNumber, myParser.tokensSeen-1, indent);
+            newLinePoint.fillStackNodes(myParser.activeStacks);
+            recoverNewLinePoints.add(newLinePoint);  
+        }      
+    }
+}
+
+    /*
+    //////////////////////////////////////// LOG INFO ////////////////////////////////////////////////////////////////
+
+    private IndentInfo findNewLinePoint(int tokensSeen){
+        for (int i = newLinePoints.size()-1; i >=0; i--) {
+            if(newLinePoints.get(i).getTokensSeen()<=tokensSeen)
+                return newLinePoints.get(i);            
+        }
+        return null;
+    }
+    
+    private void logRecoverResult() {
+        if (isDebugMode) {
+            if (recoverySucceeded()) {
+                Tools.debug("-- RecoverParse succeeded --");
+            } else {
+                Tools.debug("-- RecoverParse failed --");
+            }
+        }
+    }
+    
+    protected void logBeforeRecover() {
+        //TODO: log-before and log-after recover to super class 
+        if(isDebugMode){
+            logBigReductionList();
+            logLastParsedFragment();
+        }
+    }
+    
+    private void logRecoverFragment(int tokStart, int tokEnd) {        
+        String errorFragment ="";
+        for (int i = tokStart; i < tokEnd+1; i++) {
+            errorFragment+= recoverTokenStream[i];
+        }
+        Tools.debug(errorFragment);           
+    }
+    
+    private void logLastParsedFragment() {        
+        int tokEnd = recoverTokenCount -1;
+        int tokStart = Math.max(tokEnd - 30, 0);
+        String beforeErrorFragment ="... ";
+        for (int i = tokStart; i < tokEnd+1; i++) {
+            beforeErrorFragment+= recoverTokenStream[i];
+        }
+        Tools.debug(beforeErrorFragment);
+        Tools.debug("**** Before error ****");
+        Tools.debug("***************************");
+    }
+    
+    private void logBigReductionList() {        
+        for (int i = 0; i < newLinePoints.size(); i++) {
+            logBigReduction(newLinePoints.get(i));
+        }
+       // Tools.debug(info);
+        Tools.debug("**** BR-list ****");
+        Tools.debug("***************************");
+    }
+
+    private void logBigReduction(IndentInfo brPoint) {
+        Tools.debug("LINE: " +brPoint.getLineNumber());
+        Tools.debug("INDENT: " +brPoint.getIndentValue());
+        Tools.debug("REDUCE-LENGTH: " +brPoint.maxReduceLength());
+        Tools.debug("TOKEN-POSITION: " +brPoint.getTokensSeen());        
+        Tools.debug("........................");
+    }
+    
+    private void logBigReduceInfo(IndentInfo newLinePoint) {
+        IndentInfo test = findNewLinePoint(newLinePoint.structureStartPosition());
+        Tools.debug("StructurePos" +newLinePoint.structureStartPosition());
+        Tools.debug("current line" +newLinePoint.getLineNumber());
+        if (test !=null) {
+            Tools.debug("line: " + test.getLineNumber());
+            Tools.debug("pos: " + test.getTokensSeen());
+            Tools.debug("indent: " + test.getIndentValue());
+        }
+        else
+            Tools.debug("Null - " + myParser.lineNumber);
+    }
+
+}
+*/
\ No newline at end of file

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-05-29 08:22:46 UTC (rev 19490)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-05-29 11:56:34 UTC (rev 19491)
@@ -95,25 +95,26 @@
     
     private RecoveryConnector recoverIntegrator;
     
+    private boolean useStructureRecovery;
+    
     //Keeps track of the indentation for each line
     public IndentationHandler getIndentHandler() {
         return indentHandler;
     }
     
-    //Creates a coarse grained recovery based on layout and big reductions    
-    private StructureRecovery roughRecoverParse;
+    ParserHistory history;
     
-    public StructureRecovery getRoughRecoverParse() {
-        return roughRecoverParse;
+    private boolean eofRecoverParse;
+
+    public void setEofRecoverParse(boolean eofRecoverParse) {
+        this.eofRecoverParse = eofRecoverParse;
     }
 
-    private boolean useStructureRecovery;
-
     //Creates indent- and dedent- tokens
     //Meant for parsing of indentation based languages
     //TODO: still under construction
     private IndentTokenizer indentTokenHandler;
-    
+       
     SGLR() {
         basicInit(null);
     }
@@ -121,7 +122,6 @@
     public SGLR(final ATermFactory pf, ParseTable parseTable) {
         assert pf != null;
         assert parseTable != null;
-
         // Init with a new factory for both serialized or BAF instances.
         basicInit(pf);
 
@@ -141,6 +141,11 @@
         this.useStructureRecovery = useRoughRecovery;
     }
     
+    public void setUseStructureRecovery(boolean useRoughRecovery) {        
+        this.useStructureRecovery = useRoughRecovery;
+        this.recoverIntegrator = new RecoveryConnector(this, null);
+    }
+    
     /**
      * Aborts an asynchronously running parse job, causing it to throw an exception.     * 
      * (Provides no guarantee that the parser is actually cancelled.)
@@ -168,12 +173,11 @@
         //recoverHandler = new SimpleRecovering(this);
         recoverHandler = new NoRecovery();
         //recoverHandler = new CoarseGrainedRecovery();        
-        recoverHandler.initialize(this);
-        roughRecoverParse = new StructureRecovery();
-        roughRecoverParse.initialize(this);
+        recoverHandler.initialize(this);        
         useStructureRecovery = false;
         recoverIntegrator = null;
-    
+        history=new ParserHistory(); 
+        setEofRecoverParse(false);
     }
 
     public static boolean isDebugging() {
@@ -238,20 +242,18 @@
             do {
                 readNextToken();                
                 indentHandler.updateIndentation(currentToken);
-                //indentTokenHandler.handleIndentShifts(this);
-                roughRecoverParse.afterStreamRead(currentToken);
-                recoverHandler.afterStreamRead(currentToken);
+                //indentTokenHandler.handleIndentShifts(this);                
+                //recoverHandler.afterStreamRead(currentToken);
+                history.afterStreamRead(this);
                 doParseStep(); 
-                recoverHandler.afterParseStep();                
-                roughRecoverParse.afterParseStep();
-                
+                //recoverHandler.afterParseStep();
                 //  Tools.debug("SGLR: "+(char)currentToken);             
             } while (currentToken != SGLR.EOF && activeStacks.size() > 0);
             
+           // history.logBigReductionList();
             
-            if(roughRecoverParse.meetsRecoverCriteria() && useStructureRecovery){
-                recoverIntegrator.recover();
-                //roughRecoverParse.recover();
+            if(useStructureRecovery && acceptingStack==null){
+                recoverIntegrator.recover();                
                 if(acceptingStack==null)
                     return sglrParse(startSymbol);
             }            
@@ -338,7 +340,7 @@
 
         while (forShifter.size() > 0) {
             ActionState as = forShifter.remove();
-            if(roughRecoverParse.useAcceptingStateRecovery())
+            if(eofRecoverParse)
                 prod=parseTable.lookupProduction(as.currentToken);
             if (!parseTable.hasRejects() || !as.st.allLinksRejected()) {
                 Frame st1 = findStack(activeStacks, as.s);
@@ -413,7 +415,7 @@
         State s = st.peek();
         logBeforeActor(st, s);        
         for (Action action : s.getActions()) {
-            if(roughRecoverParse.useAcceptingStateRecovery())
+            if(eofRecoverParse)
                 currentToken = action.getFirstCharValue();
             if (action.accepts(currentToken)) {
                 for (ActionItem ai : action.getActionItems()) {
@@ -589,7 +591,7 @@
     
     private void handleAmbiguity(int numberOfAvoids, IParseNode t, Link nl) {        
         //if both branches contain no recover productions, create an Amb node.
-        if(roughRecoverParse.useAcceptingStateRecovery())
+        if(eofRecoverParse)
             return; //no ambiguity!
         if(numberOfAvoids == 0 && nl.avoidCount==0){
             createAmbNode(t, nl);
@@ -645,7 +647,7 @@
                 continue; //stacknode will find reduction in regular process
 
             for (Action action : st2.peek().getActions()) {
-                if (action.accepts(currentToken) || (roughRecoverParse.useAcceptingStateRecovery())) {
+                if (action.accepts(currentToken) || eofRecoverParse) {
                     for (ActionItem ai : action.getActionItems()) {                  
                         switch(ai.type) {
                             case ActionItem.REDUCE:

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java	2009-05-29 08:22:46 UTC (rev 19490)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java	2009-05-29 11:56:34 UTC (rev 19491)
@@ -110,7 +110,7 @@
         recoverAction = SkipAction.SKIP_PREVIOUS;//TODO: 1 if ...
        // logBeforeRecover();         
         while (recoverySucceeded()==false && recoverAction != SkipAction.FAILED) {
-            if(isDebugMode)
+            //if(isDebugMode)
                 Tools.debug("ACTION: "+recoverAction);
             switch (recoverAction) {
             case SKIP_PREVIOUS:



From mdjonge at xs4all.nl  Fri May 29 13:57:14 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Fri, 29 May 2009 11:57:14 -0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19492 - MaartjeDeJonge
	- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
Message-ID: <200905291156.n4TBurpg019505@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-05-29 11:57:39 +0000 (Fri, 29 May 2009)
New Revision: 19492

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19492&view=rev

Modified:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java

Log:
use refactored class

Changes:

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java	2009-05-29 11:56:34 UTC (rev 19491)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java	2009-05-29 11:57:39 UTC (rev 19492)
@@ -5,25 +5,25 @@
 public class RecoveryConnector {
     private SGLR mySGLR;
     private IRecoveryParser recoveryParser;
+    private RecoveryRefactored skipRecovery;
     
-    private StructureRecovery getStructureRecovery(){
-        return mySGLR.getRoughRecoverParse();
-    }
-    
     public RecoveryConnector(SGLR parser, IRecoveryParser recoveryParser){
         mySGLR=parser;
         this.recoveryParser = recoveryParser;
+        skipRecovery = new RecoveryRefactored(mySGLR);
     }
     
     public void recover() throws IOException{
-        getStructureRecovery().recover();
-        String errorFragment = getStructureRecovery().getErrorFragment();
-        String repairedFragment = repairBridges(errorFragment);
-        mySGLR.activeStacks=getStructureRecovery().getStartSkipPosition().getStackNodes();        
+        
+        skipRecovery.recover();
+        String errorFragment = skipRecovery.getErrorFragment();
+        Tools.debug(errorFragment);        
+        String repairedFragment = repairBridges(errorFragment);        
+        mySGLR.activeStacks=skipRecovery.getStartSkipPosition().getStackNodes();   
         tryParsing(repairedFragment);
-        if(mySGLR.activeStacks.size()>0){
-            getStructureRecovery().parseRemainingTokens();            
-        }
+        if(mySGLR.activeStacks.size()>0){           
+            skipRecovery.parseRemainingTokens();
+        }        
     }
 
     private String repairBridges(String errorFragment) {



From mdjonge at xs4all.nl  Fri May 29 14:01:23 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Fri, 29 May 2009 12:01:23 -0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19493 - MaartjeDeJonge
	- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
Message-ID: <200905291201.n4TC13Jo019691@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-05-29 12:01:50 +0000 (Fri, 29 May 2009)
New Revision: 19493

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19493&view=rev

Added:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java
Removed:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryRefactored.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java

Log:
replaced old code with new refactored code

Changes (first 1000 lines of the diffs):

Deleted: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryRefactored.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryRefactored.java	2009-05-29 11:57:39 UTC (rev 19492)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryRefactored.java	2009-05-29 12:01:50 UTC (rev 19493)
@@ -1,351 +0,0 @@
-package org.spoofax.jsglr;
-import java.io.IOException;
-import java.util.ArrayList;
-
-
-public class RecoveryRefactored {
-    private enum SkipAction{
-        SKIP_PREVIOUS,
-        SKIP_CURRENT,
-        SKIP_SIBLINGS,
-        SKIP_PARENT,
-        SKIP_FROM_BIGREDUCE,    
-        ENFORCE_ACCEPT,
-        FAILED        
-    }    
-    
-    private SGLR myParser;
-    private IndentationHandler skipIndentHandler;    
-    private IndentInfo skipPoint;
-    private SkipAction recoverAction;
-    private IndentInfo startSkipPosition;
-    private int errorDetectionPosition;    
-    protected boolean isDebugMode;
-    private ArrayList<IndentInfo> recoverNewLinePoints;   
-    
-    public IndentInfo getStartSkipPosition() {
-        return startSkipPosition;
-    }
-    
-    public String getErrorFragment() {       
-        return getHistory().getFragment(startSkipPosition.getTokensSeen(), skipPoint.getTokensSeen()-1);
-    }
-    
-    
-    /*
-     * Coarse-grained recovery by skipping code-fragments near the error.
-     * Uses layout to take human intention into account
-     */
-    public RecoveryRefactored(SGLR parser){
-        super();
-        myParser=parser;       
-        skipPoint=new IndentInfo(0, 0, 0);               
-        skipIndentHandler = new IndentationHandler();
-        recoverAction =SkipAction.SKIP_PREVIOUS;
-        startSkipPosition=new IndentInfo(0, 0, 0);
-        errorDetectionPosition=-1;
-        recoverNewLinePoints=new ArrayList<IndentInfo>();
-        isDebugMode=false;
-        //isDebugMode=true;
-    }
-
-    private ParserHistory getHistory() {
-        return myParser.history;
-    }
-
-    /*
-     * (non-Javadoc)
-     * @see org.spoofax.jsglr.RecoveryBase#recover()
-     */
-    public void recover() throws IOException {
-        getHistory().setIndexOnLastConstruct();
-        errorDetectionPosition=myParser.tokensSeen;
-        recoverAction = SkipAction.SKIP_PREVIOUS;//TODO: 1 if ...        
-       // logBeforeRecover();         
-        while (recoverySucceeded()==false && recoverAction != SkipAction.FAILED) {
-            if(isDebugMode)
-                Tools.debug("ACTION: "+recoverAction);
-            switch (recoverAction) {
-            case SKIP_PREVIOUS:
-                if(getHistory().setIndexOnPreviousConstruct()){
-                    skipCurrentConstruct();
-                }                
-                getHistory().setIndexOnLastConstruct();
-                recoverAction=SkipAction.SKIP_CURRENT;
-                break;
-            case SKIP_CURRENT:
-                skipCurrentConstruct();
-                recoverAction=SkipAction.SKIP_SIBLINGS;                
-                break;
-            case SKIP_SIBLINGS:
-                skipChilds();
-                recoverAction=SkipAction.SKIP_PARENT;
-                break;
-            case SKIP_PARENT:
-                getHistory().setIndexOnParentConstruct();
-                if(getHistory().getConstructPoint().getTokensSeen()<= getHistory().startPreviousBigReduce().getTokensSeen())
-                    recoverAction=SkipAction.SKIP_FROM_BIGREDUCE;
-                else
-                    recoverAction = SkipAction.SKIP_CURRENT;
-                break;
-            case SKIP_FROM_BIGREDUCE:
-                skipFromBigReduce();
-                recoverAction = SkipAction.ENFORCE_ACCEPT;
-                break;            
-            case ENFORCE_ACCEPT:
-                myParser.setEofRecoverParse(true);
-                forcingParse(); 
-                myParser.setEofRecoverParse(false);
-                recoverAction=SkipAction.FAILED;
-                break;  
-            case FAILED:                                
-                break;          
-            }            
-        }
-        //logRecoverFragment(startSkipPosition.getTokensSeen(), skipPoint.getTokensSeen()-1);
-        
-    }
-
-    private void forcingParse() throws IOException{
-        EofRecovery eofR = new EofRecovery();        
-        eofR.myParser=myParser;
-        eofR.enforceAccept(getHistory().startBigReduce().getStackNodes());
-    }
-
-    private boolean recoverySucceeded() {
-        return (myParser.activeStacks.size() > 0 || myParser.acceptingStack!=null);
-    }    
-
-    private void skipChilds() throws IOException {        
-        do {
-            setSkipPoint(getHistory().getConstructPoint());
-            int indent = skipPoint.getIndentValue();
-            while (!hasDedent(skipPoint.getIndentValue(), indent) && (recoverySucceeded()==false) && (myParser.currentToken != SGLR.EOF)) {
-                doSkipRecoverStep();
-            }            
-        } while ((recoverySucceeded()==false) && (myParser.currentToken != SGLR.EOF)&& getHistory().setIndexOnPreviousConstruct());      
-    }
-    
-    private boolean hasDedent(int indentNew, int indentOld) {
-        return indentNew !=indentOld;
-    }
-    
-    private void skipFromBigReduce() throws IOException {
-        boolean skipFromCurrent=getHistory().getConstructPoint().structureStartPosition()==getHistory().startPreviousBigReduce().structureStartPosition();
-        if(skipFromCurrent)
-            setSkipPoint(getHistory().getConstructPoint());
-        else {
-            boolean startOnPrevious = getHistory().startBigReduce().getIndentValue()>getHistory().startPreviousBigReduce().getIndentValue();
-            if(startOnPrevious){
-                setSkipPoint(getHistory().startPreviousBigReduce()); 
-            }
-            else{
-                setSkipPoint(getHistory().startBigReduce());
-            }
-        }
-        do {
-           doSkipRecoverStep();
-        } while(recoverySucceeded()==false && myParser.currentToken != SGLR.EOF);  
-    } 
-   
-    private void skipCurrentConstruct() throws IOException{  
-        //IndentInfo lineInfo = newLinePoints.get(failureIndex);
-        IndentInfo startPoint =getHistory().getConstructPoint();
-        setSkipPoint(startPoint);
-        doSkipRecoverStep();
-    }
-
-    private void setSkipPoint(IndentInfo startPoint) {
-        skipPoint=IndentInfo.cloneIndentInfo(startPoint);
-        startSkipPosition = IndentInfo.cloneIndentInfo(startPoint);
-        int tokIndexLine=getHistory().getTokensSeenStartLine(startSkipPosition.getTokensSeen());
-        startSkipPosition.setTokensSeen(tokIndexLine);
-    }
-    
-    
-
-    private void doSkipRecoverStep() throws IOException {
-        myParser.activeStacks.addAll(skipPoint.getStackNodes());
-        skipConstruct(skipPoint);
-        continueParsing();
-    }    
-    
-    private void continueParsing() throws IOException{
-        recoverNewLinePoints.clear();
-        if (isDebugMode) 
-            Tools.debug("-- RecoverParse started -- ");        
-        myParser.doParseStep();
-        while(myParser.currentToken != SGLR.EOF && myParser.activeStacks.size() > 0) {                        
-            readNextToken();            
-            myParser.doParseStep();
-            updateRecoverLinePoint(myParser);
-            if(meetsSuccessCriteriaForRecovery())
-                return; //end of attempt                     
-        }       
-    }
-    
-    public void parseRemainingTokens() throws IOException{
-        getHistory().setTokenIndex(skipPoint.getTokensSeen());
-        while(!getHistory().hasFinishedRecoverTokens()){        
-            getHistory().readRecoverToken(myParser);
-            myParser.doParseStep();            
-        }        
-    }
-
-    private boolean meetsSuccessCriteriaForRecovery() {
-        if(skipIndentHandler.lineMarginEnded() && getHistory().hasFinishedRecoverTokens())
-            return inspectLinePoints();
-        return false;
-    }
-    
-    private boolean inspectLinePoints() {        
-        boolean nonReduceLine = false;
-        for (int i = recoverNewLinePoints.size()-1; i >=0; i--) {
-            IndentInfo inspectedLine=recoverNewLinePoints.get(i);
-            if(inspectedLine.structureStartPosition()> errorDetectionPosition)
-                nonReduceLine=true;
-            if(nonReduceLine && inspectedLine.structureStartPosition() < errorDetectionPosition)
-                return true;
-            if(inspectedLine.getTokensSeen() < errorDetectionPosition)
-                return false;
-        }        
-        return false;
-    }    
-    
-    private void skipConstruct(IndentInfo skipP) throws IOException{
-        if (isDebugMode)
-            Tools.debug("-- Skip started --");        
-        getHistory().setTokenIndex(skipP.getTokensSeen()); 
-        skipIndentHandler.setInLeftMargin(false);
-        boolean endSkipFound=false;
-        while (endSkipFound==false) {//TODO: rewrite endskip criterium
-            readNextToken(); 
-            if (getHistory().getTokenIndex()>=getHistory().getLine(getHistory().nrOfLines()-1).getTokensSeen() && (skipIndentHandler.lineMarginEnded() && skipIndentHandler.getIndentValue() <= skipP.getIndentValue()) || myParser.currentToken==SGLR.EOF) {
-                endSkipFound=true;                 
-                int indent = skipIndentHandler.getIndentValue();
-                skipPoint = new IndentInfo(-1, getHistory().getTokenIndex() -1, indent);
-                skipPoint.fillStackNodes(myParser.activeStacks);
-            }
-            else{                
-                parseAsLayout();                
-            }
-        }        
-    }
-
-    private void parseAsLayout() throws IOException {        
-        switch (myParser.currentToken) {                
-        case '\n':
-            myParser.doParseStep();
-            break;
-        case '\t':
-            myParser.doParseStep();
-            break;
-        default:
-            myParser.currentToken=' ';
-            myParser.doParseStep();
-            break;
-        }
-    }
-    
-    private void readNextToken() throws IOException {
-        getHistory().readRecoverToken(myParser);
-        skipIndentHandler.updateIndentation(myParser.currentToken);
-        if (isDebugMode)
-            Tools.debug((char)myParser.currentToken); 
-    }    
-    
-    protected boolean meetsRecoverCriteria() {
-        return myParser.acceptingStack == null;//TODO: handle endless loop && myParser.currentToken != myParser.EOF;
-    } 
-   
-    private void updateRecoverLinePoint(SGLR myParser) {
-        if(myParser.getIndentHandler().lineMarginEnded()){
-            int indent = myParser.getIndentHandler().getIndentValue();
-            IndentInfo newLinePoint= new IndentInfo(myParser.lineNumber, myParser.tokensSeen-1, indent);
-            newLinePoint.fillStackNodes(myParser.activeStacks);
-            recoverNewLinePoints.add(newLinePoint);  
-        }      
-    }
-}
-
-    /*
-    //////////////////////////////////////// LOG INFO ////////////////////////////////////////////////////////////////
-
-    private IndentInfo findNewLinePoint(int tokensSeen){
-        for (int i = newLinePoints.size()-1; i >=0; i--) {
-            if(newLinePoints.get(i).getTokensSeen()<=tokensSeen)
-                return newLinePoints.get(i);            
-        }
-        return null;
-    }
-    
-    private void logRecoverResult() {
-        if (isDebugMode) {
-            if (recoverySucceeded()) {
-                Tools.debug("-- RecoverParse succeeded --");
-            } else {
-                Tools.debug("-- RecoverParse failed --");
-            }
-        }
-    }
-    
-    protected void logBeforeRecover() {
-        //TODO: log-before and log-after recover to super class 
-        if(isDebugMode){
-            logBigReductionList();
-            logLastParsedFragment();
-        }
-    }
-    
-    private void logRecoverFragment(int tokStart, int tokEnd) {        
-        String errorFragment ="";
-        for (int i = tokStart; i < tokEnd+1; i++) {
-            errorFragment+= recoverTokenStream[i];
-        }
-        Tools.debug(errorFragment);           
-    }
-    
-    private void logLastParsedFragment() {        
-        int tokEnd = recoverTokenCount -1;
-        int tokStart = Math.max(tokEnd - 30, 0);
-        String beforeErrorFragment ="... ";
-        for (int i = tokStart; i < tokEnd+1; i++) {
-            beforeErrorFragment+= recoverTokenStream[i];
-        }
-        Tools.debug(beforeErrorFragment);
-        Tools.debug("**** Before error ****");
-        Tools.debug("***************************");
-    }
-    
-    private void logBigReductionList() {        
-        for (int i = 0; i < newLinePoints.size(); i++) {
-            logBigReduction(newLinePoints.get(i));
-        }
-       // Tools.debug(info);
-        Tools.debug("**** BR-list ****");
-        Tools.debug("***************************");
-    }
-
-    private void logBigReduction(IndentInfo brPoint) {
-        Tools.debug("LINE: " +brPoint.getLineNumber());
-        Tools.debug("INDENT: " +brPoint.getIndentValue());
-        Tools.debug("REDUCE-LENGTH: " +brPoint.maxReduceLength());
-        Tools.debug("TOKEN-POSITION: " +brPoint.getTokensSeen());        
-        Tools.debug("........................");
-    }
-    
-    private void logBigReduceInfo(IndentInfo newLinePoint) {
-        IndentInfo test = findNewLinePoint(newLinePoint.structureStartPosition());
-        Tools.debug("StructurePos" +newLinePoint.structureStartPosition());
-        Tools.debug("current line" +newLinePoint.getLineNumber());
-        if (test !=null) {
-            Tools.debug("line: " + test.getLineNumber());
-            Tools.debug("pos: " + test.getTokensSeen());
-            Tools.debug("indent: " + test.getIndentValue());
-        }
-        else
-            Tools.debug("Null - " + myParser.lineNumber);
-    }
-
-}
-*/
\ No newline at end of file

Deleted: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java	2009-05-29 11:57:39 UTC (rev 19492)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java	2009-05-29 12:01:50 UTC (rev 19493)
@@ -1,436 +0,0 @@
-package org.spoofax.jsglr;
-
-import java.io.IOException;
-import java.util.ArrayList;
-
-/*
- * Gives a coarse-grained recovery based on indentation and big-reduction.
- * Skips erroneous code fragments 
- * These fragments can be recovered by refined recover methods
- */
-public class StructureRecovery extends RecoveryBase{
-    
-    private enum SkipAction{
-        SKIP_PREVIOUS,
-        SKIP_CURRENT,
-        SKIP_SIBLINGS,
-        SKIP_PARENT,
-        SKIP_FROM_BIGREDUCE,    
-        ENFORCE_ACCEPT,
-        FAILED        
-    }
-    
-    private IndentationHandler skipIndentHandler;
-    private int previousBigReduceIndex;
-    private int bigReduceIndex;    
-    private ArrayList<IndentInfo> newLinePoints;   
-    private int indexConstruct;
-    private IndentInfo skipPoint;
-    private SkipAction recoverAction;
-    private IndentInfo startSkipPosition;
-    private int errorDetectionPosition;
-    private boolean isForcingAccept;
-    private boolean isInRecoverMode;
-    
-    public IndentInfo getStartSkipPosition() {
-        return startSkipPosition;
-    }
-    
-    public String getErrorFragment() {
-        String errorFragment="";
-        for (int i = startSkipPosition.getTokensSeen(); i < skipPoint.getTokensSeen(); i++) {
-            errorFragment+= recoverTokenStream[i];
-        }
-        Tools.debug(errorFragment);
-        return errorFragment;
-    }
-
-    /*
-     * Says wether the fallback recovery "find-accepting-state" is on.
-     * If this is the case, the parser must perform all possible reduce actions without a current token
-     */
-    public boolean useAcceptingStateRecovery(){
-        return isForcingAccept;        
-    }
-    
-    /*
-     * Coarse-grained recovery by skipping code-fragments near the error.
-     * Uses layout to take human intention into account
-     */
-    public StructureRecovery(){
-        super();        
-        newLinePoints = new ArrayList<IndentInfo>();
-        skipPoint=new IndentInfo(0, 0, 0);
-        //isDebugMode = true;        
-        skipIndentHandler = new IndentationHandler();        
-        indexConstruct=0;
-        bigReduceIndex = 0;
-        previousBigReduceIndex =0;
-        recoverAction =SkipAction.SKIP_PREVIOUS;
-        startSkipPosition=new IndentInfo(0, 0, 0);
-        errorDetectionPosition=-1;
-        isForcingAccept=false;
-        isInRecoverMode=false;
-    }
-    
-    @Override
-    public void afterStreamRead(int currToken){        
-        super.afterStreamRead(currToken);        
-        if(myParser.getIndentHandler().lineMarginEnded())
-            keepNewLinePoint();
-    }
-
-    private void keepNewLinePoint() {
-        IndentInfo newLinePoint = createNewlinePoint();
-        newLinePoints.add(newLinePoint);
-        //TODO: findBigReduceIndex()
-        if((isInRecoverMode==false) && newLinePoints.get(bigReduceIndex).maxReduceLength()< newLinePoint.maxReduceLength()){
-            previousBigReduceIndex = bigReduceIndex;
-            bigReduceIndex = newLinePoints.size()-1;                 
-        }
-    }    
-
-    private IndentInfo createNewlinePoint() {
-        int indent = myParser.getIndentHandler().getIndentValue();
-        IndentInfo newLinePoint= new IndentInfo(myParser.lineNumber, myParser.tokensSeen-1, indent);
-        newLinePoint.fillStackNodes(myParser.activeStacks);
-        return newLinePoint;
-    }    
-
-    /*
-     * (non-Javadoc)
-     * @see org.spoofax.jsglr.RecoveryBase#recover()
-     */
-    @Override
-    public void recover() throws IOException
-    {
-        isInRecoverMode=true;
-        indexConstruct=newLinePoints.size()-1;//Todo: consistent with use failure index 
-        errorDetectionPosition=myParser.tokensSeen;
-        recoverAction = SkipAction.SKIP_PREVIOUS;//TODO: 1 if ...
-       // logBeforeRecover();         
-        while (recoverySucceeded()==false && recoverAction != SkipAction.FAILED) {
-            //if(isDebugMode)
-                Tools.debug("ACTION: "+recoverAction);
-            switch (recoverAction) {
-            case SKIP_PREVIOUS:
-                skipPreviousConstruct();
-                recoverAction=SkipAction.SKIP_CURRENT;
-                break;
-            case SKIP_CURRENT:
-                skipCurrentConstruct();
-                recoverAction=SkipAction.SKIP_SIBLINGS;                
-                break;
-            case SKIP_SIBLINGS:
-                skipChilds();
-                recoverAction=SkipAction.SKIP_PARENT;
-                break;
-            case SKIP_PARENT:
-                indexConstruct = findIndexOfParentConstruct();
-                if(getConstructPoint().getTokensSeen()<=newLinePoints.get(previousBigReduceIndex).getTokensSeen())
-                    recoverAction=SkipAction.SKIP_FROM_BIGREDUCE;
-                else
-                    recoverAction = SkipAction.SKIP_CURRENT;
-                break;
-            case SKIP_FROM_BIGREDUCE:
-                boolean startOnPrev = newLinePoints.get(bigReduceIndex).getIndentValue()>newLinePoints.get(previousBigReduceIndex).getIndentValue();
-                skipFromBigReduce(startOnPrev);
-                recoverAction = SkipAction.ENFORCE_ACCEPT;
-                break;            
-            case ENFORCE_ACCEPT:
-                isForcingAccept=true;
-                forcingParse(); 
-                isForcingAccept=false;
-                recoverAction=SkipAction.FAILED;
-                break;  
-            case FAILED:                                
-                break;          
-            }            
-        }
-        //logRecoverFragment(startSkipPosition.getTokensSeen(), skipPoint.getTokensSeen()-1);
-        isInRecoverMode=false;
-    }
-
-    private void forcingParse() throws IOException{
-        EofRecovery eofR = new EofRecovery();        
-        eofR.myParser=myParser;
-        eofR.enforceAccept(newLinePoints.get(bigReduceIndex).getStackNodes());
-    }
-
-    private boolean recoverySucceeded() {
-        return (myParser.activeStacks.size() > 0 || myParser.acceptingStack!=null);
-    }    
-
-    private void skipChilds() throws IOException {
-        int index = indexConstruct;
-        do {
-            setSkipPoint(newLinePoints.get(index));
-            int indent = skipPoint.getIndentValue();
-            while (!hasDedent(skipPoint.getIndentValue(), indent) && (recoverySucceeded()==false) && (myParser.currentToken != SGLR.EOF)) {
-                doSkipRecoverStep();
-            }
-            int newIndex = findIndexOfPreviousConstruct(index);
-            if(newIndex<index)
-                index = newIndex;
-            else
-                index = -1;//no prior childs
-        } while ((recoverySucceeded()==false) && (myParser.currentToken != SGLR.EOF)&& index >=0);      
-    }
-    
-    private boolean hasDedent(int indentNew, int indentOld) {
-        return indentNew !=indentOld;
-    }
-    
-    private void skipFromBigReduce(boolean startOnPrevious) throws IOException {
-        if(startOnPrevious){
-            setSkipPoint(newLinePoints.get(previousBigReduceIndex)); 
-        }
-        else{
-            setSkipPoint(newLinePoints.get(bigReduceIndex));
-        }
-        do {
-           doSkipRecoverStep();
-        } while(recoverySucceeded()==false && myParser.currentToken != SGLR.EOF);  
-    } 
-    
-    private int findIndexOfParentConstruct() {
-        int parentConstructIndex=0;
-        int loopIndex = newLinePoints.size()-2;
-        while ( loopIndex >= 0 && parentConstructIndex==0) {
-            if(newLinePoints.get(loopIndex).getIndentValue()< getConstructPoint().getIndentValue()){
-                parentConstructIndex = loopIndex;               
-            }
-            loopIndex--;
-        }
-        return parentConstructIndex;
-    }    
-
-    private void skipPreviousConstruct() throws IOException {        
-        setSkipPoint(newLinePoints.get(findIndexOfPreviousConstruct(indexConstruct)));
-        if(skipPoint.getTokensSeen()!=getConstructPoint().getTokensSeen())//no previous child
-            doSkipRecoverStep();
-    }
-
-    private int findIndexOfPreviousConstruct(int currentIndex) {
-        int previousConstructIndex=0;
-        int loopIndex = currentIndex -1;
-        IndentInfo currentLine=newLinePoints.get(currentIndex);
-        while ( loopIndex >= 0 && previousConstructIndex==0) {
-            IndentInfo priorLine=newLinePoints.get(loopIndex);            
-            if(priorLine.getIndentValue()==currentLine.getIndentValue()){
-                if(loopIndex!=currentIndex - 1 || priorLine.structureStartPosition() <= currentLine.structureStartPosition()){ //skip closing tag
-                    previousConstructIndex = loopIndex;   
-                }          
-            }
-            if(priorLine.getIndentValue()< currentLine.getIndentValue()){
-                previousConstructIndex = currentIndex;//first child               
-            }
-            loopIndex--;
-        }
-        return previousConstructIndex;
-    }
-
-    private void skipCurrentConstruct() throws IOException{  
-        //IndentInfo lineInfo = newLinePoints.get(failureIndex);
-        IndentInfo startPoint =getConstructPoint();
-        setSkipPoint(startPoint);
-        doSkipRecoverStep();
-    }
-
-    private void setSkipPoint(IndentInfo startPoint) {
-        skipPoint=IndentInfo.cloneIndentInfo(startPoint);
-        startSkipPosition = IndentInfo.cloneIndentInfo(startPoint);
-        int tokIndexLine=startSkipPosition.getTokensSeen();
-        while (recoverTokenStream[tokIndexLine] != '\n' && tokIndexLine>0) {
-            tokIndexLine-=1;
-        }
-        startSkipPosition.setTokensSeen(tokIndexLine);
-    }
-    
-    private IndentInfo getConstructPoint() {
-        return newLinePoints.get(indexConstruct);
-    }
-
-    private void doSkipRecoverStep() throws IOException {
-        myParser.activeStacks.addAll(skipPoint.getStackNodes());
-        skipConstruct(skipPoint);               
-        if(isDebugMode)
-            logRecoverFragment(startSkipPosition.getTokensSeen(), tokenIndex-2);
-        continueParsing();        
-        logRecoverResult();
-    }    
-    
-    private void continueParsing() throws IOException{        
-        if (isDebugMode) 
-            Tools.debug("-- RecoverParse started -- ");        
-        myParser.doParseStep();
-        while(myParser.currentToken != SGLR.EOF && myParser.activeStacks.size() > 0) {                        
-            readNextToken();            
-            myParser.doParseStep();
-            if(meetsSuccessCriteriaForRecovery())
-                return; //end of attempt                     
-        }       
-    }
-    
-    public void parseRemainingTokens() throws IOException{
-        int startIndex=skipPoint.getTokensSeen();
-        for (int i = startIndex; i < recoverTokenCount; i++) {
-            myParser.currentToken=recoverTokenStream[i];
-            myParser.doParseStep();            
-        }
-        
-    }
-
-    private boolean meetsSuccessCriteriaForRecovery() {
-        if(skipIndentHandler.lineMarginEnded() && tokenIndex == recoverTokenCount)
-            return inspectLinePoints();
-        return false;
-    }
-
-    private boolean inspectLinePoints() {        
-        boolean nonReduceLine = false;
-        for (int i = newLinePoints.size()-1; i >=0; i--) {
-            if(newLinePoints.get(i).structureStartPosition()> errorDetectionPosition)
-                nonReduceLine=true;
-            if(nonReduceLine && newLinePoints.get(i).structureStartPosition() < errorDetectionPosition)
-                return true;
-            if(newLinePoints.get(i).getTokensSeen() < errorDetectionPosition)
-                return false;
-        }        
-        return false;
-    }    
-    
-    private void skipConstruct(IndentInfo skipP) throws IOException{
-        if (isDebugMode)
-            Tools.debug("-- Skip started --");        
-        tokenIndex = skipP.getTokensSeen(); 
-        skipIndentHandler.setInLeftMargin(false);
-        boolean endSkipFound=false;
-        while (endSkipFound==false) {//TODO: rewrite endskip criterium
-            readNextToken(); 
-            if (tokenIndex>=getConstructPoint().getTokensSeen() && (skipIndentHandler.lineMarginEnded() && skipIndentHandler.getIndentValue() <= skipP.getIndentValue()) || myParser.currentToken==SGLR.EOF) {
-                endSkipFound=true;                 
-                int indent = skipIndentHandler.getIndentValue();
-                skipPoint = new IndentInfo(-1, tokenIndex -1, indent);
-                skipPoint.fillStackNodes(myParser.activeStacks);
-            }
-            else{                
-                parseAsLayout();                
-            }
-        }        
-    }
-
-    private void parseAsLayout() throws IOException {        
-        switch (myParser.currentToken) {                
-        case '\n':
-            myParser.doParseStep();
-            break;
-        case '\t':
-            myParser.doParseStep();
-            break;
-        default:
-            myParser.currentToken=' ';
-            myParser.doParseStep();
-            break;
-        }
-    }
-    
-    private void readNextToken() throws IOException {
-        char currentToken;
-        if (tokenIndex >= recoverTokenCount) {
-            myParser.readNextToken();                
-            myParser.getIndentHandler().updateIndentation(myParser.currentToken);
-            afterStreamRead(myParser.currentToken); //keeps recover token TODO: rename 
-        }
-        currentToken = recoverTokenStream[tokenIndex];
-        tokenIndex++;
-        myParser.currentToken = currentToken;
-        skipIndentHandler.updateIndentation(currentToken);
-        if (isDebugMode)
-            Tools.debug((char)myParser.currentToken + "(" + (tokenIndex - 1) + ")");        
-    }    
-    
-    @Override
-    protected boolean meetsRecoverCriteria() {
-        return myParser.acceptingStack == null;//TODO: handle endless loop && myParser.currentToken != myParser.EOF;
-    }
-
-    //////////////////////////////////////// LOG INFO ////////////////////////////////////////////////////////////////
-
-    private IndentInfo findNewLinePoint(int tokensSeen){
-        for (int i = newLinePoints.size()-1; i >=0; i--) {
-            if(newLinePoints.get(i).getTokensSeen()<=tokensSeen)
-                return newLinePoints.get(i);            
-        }
-        return null;
-    }
-    
-    private void logRecoverResult() {
-        if (isDebugMode) {
-            if (recoverySucceeded()) {
-                Tools.debug("-- RecoverParse succeeded --");
-            } else {
-                Tools.debug("-- RecoverParse failed --");
-            }
-        }
-    }
-    
-    protected void logBeforeRecover() {
-        //TODO: log-before and log-after recover to super class 
-        if(isDebugMode){
-            logBigReductionList();
-            logLastParsedFragment();
-        }
-    }
-    
-    private void logRecoverFragment(int tokStart, int tokEnd) {        
-        String errorFragment ="";
-        for (int i = tokStart; i < tokEnd+1; i++) {
-            errorFragment+= recoverTokenStream[i];
-        }
-        Tools.debug(errorFragment);           
-    }
-    
-    private void logLastParsedFragment() {        
-        int tokEnd = recoverTokenCount -1;
-        int tokStart = Math.max(tokEnd - 30, 0);
-        String beforeErrorFragment ="... ";
-        for (int i = tokStart; i < tokEnd+1; i++) {
-            beforeErrorFragment+= recoverTokenStream[i];
-        }
-        Tools.debug(beforeErrorFragment);
-        Tools.debug("**** Before error ****");
-        Tools.debug("***************************");
-    }
-    
-    private void logBigReductionList() {        
-        for (int i = 0; i < newLinePoints.size(); i++) {
-            logBigReduction(newLinePoints.get(i));
-        }
-       // Tools.debug(info);
-        Tools.debug("**** BR-list ****");
-        Tools.debug("***************************");
-    }
-
-    private void logBigReduction(IndentInfo brPoint) {
-        Tools.debug("LINE: " +brPoint.getLineNumber());
-        Tools.debug("INDENT: " +brPoint.getIndentValue());
-        Tools.debug("REDUCE-LENGTH: " +brPoint.maxReduceLength());
-        Tools.debug("TOKEN-POSITION: " +brPoint.getTokensSeen());        
-        Tools.debug("........................");
-    }
-    
-    private void logBigReduceInfo(IndentInfo newLinePoint) {
-        IndentInfo test = findNewLinePoint(newLinePoint.structureStartPosition());
-        Tools.debug("StructurePos" +newLinePoint.structureStartPosition());
-        Tools.debug("current line" +newLinePoint.getLineNumber());
-        if (test !=null) {
-            Tools.debug("line: " + test.getLineNumber());
-            Tools.debug("pos: " + test.getTokensSeen());
-            Tools.debug("indent: " + test.getIndentValue());
-        }
-        else
-            Tools.debug("Null - " + myParser.lineNumber);
-    }
-
-}

Copied: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java (from rev 19491, spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryRefactored.java)
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java	                        (rev 0)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java	2009-05-29 12:01:50 UTC (rev 19493)
@@ -0,0 +1,351 @@
+package org.spoofax.jsglr;
+import java.io.IOException;
+import java.util.ArrayList;
+
+
+public class StructureRecovery {
+    private enum SkipAction{
+        SKIP_PREVIOUS,
+        SKIP_CURRENT,
+        SKIP_SIBLINGS,
+        SKIP_PARENT,
+        SKIP_FROM_BIGREDUCE,    
+        ENFORCE_ACCEPT,
+        FAILED        
+    }    
+    
+    private SGLR myParser;
+    private IndentationHandler skipIndentHandler;    
+    private IndentInfo skipPoint;
+    private SkipAction recoverAction;
+    private IndentInfo startSkipPosition;
+    private int errorDetectionPosition;    
+    protected boolean isDebugMode;
+    private ArrayList<IndentInfo> recoverNewLinePoints;   
+    
+    public IndentInfo getStartSkipPosition() {
+        return startSkipPosition;
+    }
+    
+    public String getErrorFragment() {       
+        return getHistory().getFragment(startSkipPosition.getTokensSeen(), skipPoint.getTokensSeen()-1);
+    }
+    
+    
+    /*
+     * Coarse-grained recovery by skipping code-fragments near the error.
+     * Uses layout to take human intention into account
+     */
+    public StructureRecovery(SGLR parser){
+        super();
+        myParser=parser;       
+        skipPoint=new IndentInfo(0, 0, 0);               
+        skipIndentHandler = new IndentationHandler();
+        recoverAction =SkipAction.SKIP_PREVIOUS;
+        startSkipPosition=new IndentInfo(0, 0, 0);
+        errorDetectionPosition=-1;
+        recoverNewLinePoints=new ArrayList<IndentInfo>();
+        isDebugMode=false;
+        //isDebugMode=true;
+    }
+
+    private ParserHistory getHistory() {
+        return myParser.history;
+    }
+
+    /*
+     * (non-Javadoc)
+     * @see org.spoofax.jsglr.RecoveryBase#recover()
+     */
+    public void recover() throws IOException {
+        getHistory().setIndexOnLastConstruct();
+        errorDetectionPosition=myParser.tokensSeen;
+        recoverAction = SkipAction.SKIP_PREVIOUS;//TODO: 1 if ...        
+       // logBeforeRecover();         
+        while (recoverySucceeded()==false && recoverAction != SkipAction.FAILED) {
+            if(isDebugMode)
+                Tools.debug("ACTION: "+recoverAction);
+            switch (recoverAction) {
+            case SKIP_PREVIOUS:
+                if(getHistory().setIndexOnPreviousConstruct()){
+                    skipCurrentConstruct();
+                }                
+                getHistory().setIndexOnLastConstruct();
+                recoverAction=SkipAction.SKIP_CURRENT;
+                break;
+            case SKIP_CURRENT:
+                skipCurrentConstruct();
+                recoverAction=SkipAction.SKIP_SIBLINGS;                
+                break;
+            case SKIP_SIBLINGS:
+                skipChilds();
+                recoverAction=SkipAction.SKIP_PARENT;
+                break;
+            case SKIP_PARENT:
+                getHistory().setIndexOnParentConstruct();
+                if(getHistory().getConstructPoint().getTokensSeen()<= getHistory().startPreviousBigReduce().getTokensSeen())
+                    recoverAction=SkipAction.SKIP_FROM_BIGREDUCE;
+                else
+                    recoverAction = SkipAction.SKIP_CURRENT;
+                break;
+            case SKIP_FROM_BIGREDUCE:
+                skipFromBigReduce();
+                recoverAction = SkipAction.ENFORCE_ACCEPT;
+                break;            
+            case ENFORCE_ACCEPT:
+                myParser.setEofRecoverParse(true);
+                forcingParse(); 
+                myParser.setEofRecoverParse(false);
+                recoverAction=SkipAction.FAILED;
+                break;  
+            case FAILED:                                
+                break;          
+            }            
+        }
+        //logRecoverFragment(startSkipPosition.getTokensSeen(), skipPoint.getTokensSeen()-1);
+        
+    }
+
+    private void forcingParse() throws IOException{
+        EofRecovery eofR = new EofRecovery();        
+        eofR.myParser=myParser;
+        eofR.enforceAccept(getHistory().startBigReduce().getStackNodes());
+    }
+
+    private boolean recoverySucceeded() {
+        return (myParser.activeStacks.size() > 0 || myParser.acceptingStack!=null);
+    }    
+
+    private void skipChilds() throws IOException {        
+        do {
+            setSkipPoint(getHistory().getConstructPoint());
+            int indent = skipPoint.getIndentValue();
+            while (!hasDedent(skipPoint.getIndentValue(), indent) && (recoverySucceeded()==false) && (myParser.currentToken != SGLR.EOF)) {
+                doSkipRecoverStep();
+            }            
+        } while ((recoverySucceeded()==false) && (myParser.currentToken != SGLR.EOF)&& getHistory().setIndexOnPreviousConstruct());      
+    }
+    
+    private boolean hasDedent(int indentNew, int indentOld) {
+        return indentNew !=indentOld;
+    }
+    
+    private void skipFromBigReduce() throws IOException {
+        boolean skipFromCurrent=getHistory().getConstructPoint().structureStartPosition()==getHistory().startPreviousBigReduce().structureStartPosition();
+        if(skipFromCurrent)
+            setSkipPoint(getHistory().getConstructPoint());
+        else {
+            boolean startOnPrevious = getHistory().startBigReduce().getIndentValue()>getHistory().startPreviousBigReduce().getIndentValue();
+            if(startOnPrevious){
+                setSkipPoint(getHistory().startPreviousBigReduce()); 
+            }
+            else{
+                setSkipPoint(getHistory().startBigReduce());
+            }
+        }
+        do {
+           doSkipRecoverStep();
+        } while(recoverySucceeded()==false && myParser.currentToken != SGLR.EOF);  
+    } 
+   
+    private void skipCurrentConstruct() throws IOException{  
+        //IndentInfo lineInfo = newLinePoints.get(failureIndex);
+        IndentInfo startPoint =getHistory().getConstructPoint();
+        setSkipPoint(startPoint);
+        doSkipRecoverStep();
+    }
+
+    private void setSkipPoint(IndentInfo startPoint) {
+        skipPoint=IndentInfo.cloneIndentInfo(startPoint);
+        startSkipPosition = IndentInfo.cloneIndentInfo(startPoint);
+        int tokIndexLine=getHistory().getTokensSeenStartLine(startSkipPosition.getTokensSeen());
+        startSkipPosition.setTokensSeen(tokIndexLine);
+    }
+    
+    
+
+    private void doSkipRecoverStep() throws IOException {
+        myParser.activeStacks.addAll(skipPoint.getStackNodes());
+        skipConstruct(skipPoint);
+        continueParsing();
+    }    
+    
+    private void continueParsing() throws IOException{
+        recoverNewLinePoints.clear();
+        if (isDebugMode) 
+            Tools.debug("-- RecoverParse started -- ");        
+        myParser.doParseStep();
+        while(myParser.currentToken != SGLR.EOF && myParser.activeStacks.size() > 0) {                        
+            readNextToken();            
+            myParser.doParseStep();
+            updateRecoverLinePoint(myParser);
+            if(meetsSuccessCriteriaForRecovery())
+                return; //end of attempt                     
+        }       
+    }
+    
+    public void parseRemainingTokens() throws IOException{
+        getHistory().setTokenIndex(skipPoint.getTokensSeen());
+        while(!getHistory().hasFinishedRecoverTokens()){        
+            getHistory().readRecoverToken(myParser);
+            myParser.doParseStep();            
+        }        
+    }
+
+    private boolean meetsSuccessCriteriaForRecovery() {

(164 diff lines omitted)


From mdjonge at xs4all.nl  Fri May 29 16:22:05 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Fri, 29 May 2009 14:22:05 -0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19495 - MaartjeDeJonge
	- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
Message-ID: <200905291421.n4TELkXo021342@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-05-29 14:22:33 +0000 (Fri, 29 May 2009)
New Revision: 19495

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19495&view=rev

Modified:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java

Log:
add recover lines to parser history

Changes:

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java	2009-05-29 12:27:00 UTC (rev 19494)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java	2009-05-29 14:22:33 UTC (rev 19495)
@@ -9,9 +9,9 @@
         SKIP_CURRENT,
         SKIP_SIBLINGS,
         SKIP_PARENT,
-        SKIP_FROM_BIGREDUCE,    
+        SKIP_FORWARD,    
         ENFORCE_ACCEPT,
-        FAILED        
+        STOPPED        
     }    
     
     private SGLR myParser;
@@ -38,17 +38,29 @@
      */
     public StructureRecovery(SGLR parser){
         super();
-        myParser=parser;       
-        skipPoint=new IndentInfo(0, 0, 0);               
-        skipIndentHandler = new IndentationHandler();
-        recoverAction =SkipAction.SKIP_PREVIOUS;
-        startSkipPosition=new IndentInfo(0, 0, 0);
-        errorDetectionPosition=-1;
-        recoverNewLinePoints=new ArrayList<IndentInfo>();
+        myParser=parser;  
+        initialize();
+        reset();
         isDebugMode=false;
         //isDebugMode=true;
     }
 
+    private void reset() {        
+        errorDetectionPosition=-1;
+        recoverAction =SkipAction.SKIP_PREVIOUS;
+        skipIndentHandler.initEvaluationVariables();
+        skipIndentHandler.setInLeftMargin(false);
+        recoverNewLinePoints.clear();
+        myParser.setEofRecoverParse(false);
+    }
+
+    private void initialize() {
+        skipPoint=new IndentInfo(0, 0, 0);               
+        skipIndentHandler = new IndentationHandler();        
+        startSkipPosition=new IndentInfo(0, 0, 0);        
+        recoverNewLinePoints=new ArrayList<IndentInfo>();
+    }
+
     private ParserHistory getHistory() {
         return myParser.history;
     }
@@ -62,7 +74,7 @@
         errorDetectionPosition=myParser.tokensSeen;
         recoverAction = SkipAction.SKIP_PREVIOUS;//TODO: 1 if ...        
        // logBeforeRecover();         
-        while (recoverySucceeded()==false && recoverAction != SkipAction.FAILED) {
+        while (recoverySucceeded()==false && recoverAction != SkipAction.STOPPED) {
             if(isDebugMode)
                 Tools.debug("ACTION: "+recoverAction);
             switch (recoverAction) {
@@ -84,11 +96,11 @@
             case SKIP_PARENT:
                 getHistory().setIndexOnParentConstruct();
                 if(getHistory().getConstructPoint().getTokensSeen()<= getHistory().startPreviousBigReduce().getTokensSeen())
-                    recoverAction=SkipAction.SKIP_FROM_BIGREDUCE;
+                    recoverAction=SkipAction.SKIP_FORWARD;
                 else
                     recoverAction = SkipAction.SKIP_CURRENT;
                 break;
-            case SKIP_FROM_BIGREDUCE:
+            case SKIP_FORWARD:
                 skipFromBigReduce();
                 recoverAction = SkipAction.ENFORCE_ACCEPT;
                 break;            
@@ -96,12 +108,14 @@
                 myParser.setEofRecoverParse(true);
                 forcingParse(); 
                 myParser.setEofRecoverParse(false);
-                recoverAction=SkipAction.FAILED;
+                recoverAction=SkipAction.STOPPED;
                 break;  
-            case FAILED:                                
+            case STOPPED:                                
                 break;          
             }            
         }
+        getHistory().mergeRecoverLines(recoverNewLinePoints);
+        reset();
         //logRecoverFragment(startSkipPosition.getTokensSeen(), skipPoint.getTokensSeen()-1);
         
     }
@@ -176,9 +190,9 @@
             Tools.debug("-- RecoverParse started -- ");        
         myParser.doParseStep();
         while(myParser.currentToken != SGLR.EOF && myParser.activeStacks.size() > 0) {                        
-            readNextToken();            
-            myParser.doParseStep();
+            readNextToken();     
             updateRecoverLinePoint(myParser);
+            myParser.doParseStep();            
             if(meetsSuccessCriteriaForRecovery())
                 return; //end of attempt                     
         }       
@@ -261,11 +275,11 @@
     private void updateRecoverLinePoint(SGLR myParser) {
         if(myParser.getIndentHandler().lineMarginEnded()){
             int indent = myParser.getIndentHandler().getIndentValue();
-            IndentInfo newLinePoint= new IndentInfo(myParser.lineNumber, myParser.tokensSeen-1, indent);
+            IndentInfo newLinePoint= new IndentInfo(myParser.lineNumber, getHistory().getTokenIndex(), indent);
             newLinePoint.fillStackNodes(myParser.activeStacks);
             recoverNewLinePoints.add(newLinePoint);  
         }      
-    }
+    }    
 }
 
     /*



From mdjonge at xs4all.nl  Fri May 29 16:24:00 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Fri, 29 May 2009 14:24:00 -0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19496 - MaartjeDeJonge
	- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
Message-ID: <200905291423.n4TENgkq021363@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-05-29 14:24:29 +0000 (Fri, 29 May 2009)
New Revision: 19496

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19496&view=rev

Modified:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParserHistory.java

Log:
add recover lines to parser history

Changes:

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParserHistory.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParserHistory.java	2009-05-29 14:22:33 UTC (rev 19495)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParserHistory.java	2009-05-29 14:24:29 UTC (rev 19496)
@@ -58,6 +58,7 @@
 
     public void afterStreamRead(SGLR myParser) {
         keepToken((char)myParser.currentToken);
+        tokenIndex++;
         if(myParser.getIndentHandler().lineMarginEnded())
             keepNewLinePoint(myParser);
     }
@@ -152,6 +153,13 @@
         return true;   
     }
     
+    public void mergeRecoverLines(ArrayList<IndentInfo> recoverNewLinePoints) {
+        if(recoverNewLinePoints.size()==0)
+            return;
+        newLinePoints.remove(newLinePoints.size()-1); //remove line of error detection
+        newLinePoints.addAll(recoverNewLinePoints);        
+    }
+    
     ///////////////////////////////// LOG /////////////////////////////////////////////////////////////////
     public void logBigReductionList() {        
         for (int i = 0; i < newLinePoints.size(); i++) {
@@ -169,4 +177,5 @@
         Tools.debug("TOKEN-POSITION: " +brPoint.getTokensSeen());        
         Tools.debug("........................");
     }
+    
 }



From mdjonge at xs4all.nl  Fri May 29 16:45:33 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Fri, 29 May 2009 14:45:33 -0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19497 - MaartjeDeJonge
	- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
Message-ID: <200905291444.n4TEivOs021526@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-05-29 14:45:44 +0000 (Fri, 29 May 2009)
New Revision: 19497

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19497&view=rev

Modified:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java

Log:
clean code

Changes:

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java	2009-05-29 14:24:29 UTC (rev 19496)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java	2009-05-29 14:45:44 UTC (rev 19497)
@@ -2,8 +2,12 @@
 import java.io.IOException;
 import java.util.ArrayList;
 
-
+/*
+ * Coarse-grained recovery by skipping code-fragments near the error.
+ * Uses layout to take human intention into account
+ */
 public class StructureRecovery {
+    
     private enum SkipAction{
         SKIP_PREVIOUS,
         SKIP_CURRENT,
@@ -21,12 +25,18 @@
     private IndentInfo startSkipPosition;
     private int errorDetectionPosition;    
     protected boolean isDebugMode;
-    private ArrayList<IndentInfo> recoverNewLinePoints;   
-    
+    private ArrayList<IndentInfo> recoverlines;   
+   
+    /*
+     * Parser state before the skipping
+     */
     public IndentInfo getStartSkipPosition() {
         return startSkipPosition;
     }
     
+    /*
+     * Skipped fragment containing errors
+     */
     public String getErrorFragment() {       
         return getHistory().getFragment(startSkipPosition.getTokensSeen(), skipPoint.getTokensSeen()-1);
     }
@@ -50,7 +60,7 @@
         recoverAction =SkipAction.SKIP_PREVIOUS;
         skipIndentHandler.initEvaluationVariables();
         skipIndentHandler.setInLeftMargin(false);
-        recoverNewLinePoints.clear();
+        recoverlines.clear();
         myParser.setEofRecoverParse(false);
     }
 
@@ -58,7 +68,7 @@
         skipPoint=new IndentInfo(0, 0, 0);               
         skipIndentHandler = new IndentationHandler();        
         startSkipPosition=new IndentInfo(0, 0, 0);        
-        recoverNewLinePoints=new ArrayList<IndentInfo>();
+        recoverlines=new ArrayList<IndentInfo>();
     }
 
     private ParserHistory getHistory() {
@@ -66,14 +76,12 @@
     }
 
     /*
-     * (non-Javadoc)
-     * @see org.spoofax.jsglr.RecoveryBase#recover()
+     * Recovers by skipping (parse as whitespace) part of the input string
      */
     public void recover() throws IOException {
         getHistory().setIndexOnLastConstruct();
         errorDetectionPosition=myParser.tokensSeen;
-        recoverAction = SkipAction.SKIP_PREVIOUS;//TODO: 1 if ...        
-       // logBeforeRecover();         
+        recoverAction = SkipAction.SKIP_PREVIOUS;
         while (recoverySucceeded()==false && recoverAction != SkipAction.STOPPED) {
             if(isDebugMode)
                 Tools.debug("ACTION: "+recoverAction);
@@ -101,7 +109,7 @@
                     recoverAction = SkipAction.SKIP_CURRENT;
                 break;
             case SKIP_FORWARD:
-                skipFromBigReduce();
+                skipForward();
                 recoverAction = SkipAction.ENFORCE_ACCEPT;
                 break;            
             case ENFORCE_ACCEPT:
@@ -114,10 +122,8 @@
                 break;          
             }            
         }
-        getHistory().mergeRecoverLines(recoverNewLinePoints);
-        reset();
-        //logRecoverFragment(startSkipPosition.getTokensSeen(), skipPoint.getTokensSeen()-1);
-        
+        getHistory().mergeRecoverLines(recoverlines);
+        reset();        
     }
 
     private void forcingParse() throws IOException{
@@ -130,6 +136,9 @@
         return (myParser.activeStacks.size() > 0 || myParser.acceptingStack!=null);
     }    
 
+    /*
+     * Skips children around the error
+     */
     private void skipChilds() throws IOException {        
         do {
             setSkipPoint(getHistory().getConstructPoint());
@@ -144,7 +153,10 @@
         return indentNew !=indentOld;
     }
     
-    private void skipFromBigReduce() throws IOException {
+    /*
+     * Looks for a recovery by skipping forward from Parent, big-reduce or previous big-reduce
+     */
+    private void skipForward() throws IOException {
         boolean skipFromCurrent=getHistory().getConstructPoint().structureStartPosition()==getHistory().startPreviousBigReduce().structureStartPosition();
         if(skipFromCurrent)
             setSkipPoint(getHistory().getConstructPoint());
@@ -162,8 +174,7 @@
         } while(recoverySucceeded()==false && myParser.currentToken != SGLR.EOF);  
     } 
    
-    private void skipCurrentConstruct() throws IOException{  
-        //IndentInfo lineInfo = newLinePoints.get(failureIndex);
+    private void skipCurrentConstruct() throws IOException{         
         IndentInfo startPoint =getHistory().getConstructPoint();
         setSkipPoint(startPoint);
         doSkipRecoverStep();
@@ -175,8 +186,6 @@
         int tokIndexLine=getHistory().getTokensSeenStartLine(startSkipPosition.getTokensSeen());
         startSkipPosition.setTokensSeen(tokIndexLine);
     }
-    
-    
 
     private void doSkipRecoverStep() throws IOException {
         myParser.activeStacks.addAll(skipPoint.getStackNodes());
@@ -185,7 +194,7 @@
     }    
     
     private void continueParsing() throws IOException{
-        recoverNewLinePoints.clear();
+        recoverlines.clear();
         if (isDebugMode) 
             Tools.debug("-- RecoverParse started -- ");        
         myParser.doParseStep();
@@ -212,10 +221,13 @@
         return false;
     }
     
+    /*
+     * Criteria: a reduction over the errorDetectionPoin + a non-reduce line 
+     */
     private boolean inspectLinePoints() {        
         boolean nonReduceLine = false;
-        for (int i = recoverNewLinePoints.size()-1; i >=0; i--) {
-            IndentInfo inspectedLine=recoverNewLinePoints.get(i);
+        for (int i = recoverlines.size()-1; i >=0; i--) {
+            IndentInfo inspectedLine=recoverlines.get(i);
             if(inspectedLine.structureStartPosition()> errorDetectionPosition)
                 nonReduceLine=true;
             if(nonReduceLine && inspectedLine.structureStartPosition() < errorDetectionPosition)
@@ -226,15 +238,18 @@
         return false;
     }    
     
+    /*
+     * Skips line plus childlines (indentation)
+     */
     private void skipConstruct(IndentInfo skipP) throws IOException{
         if (isDebugMode)
             Tools.debug("-- Skip started --");        
         getHistory().setTokenIndex(skipP.getTokensSeen()); 
         skipIndentHandler.setInLeftMargin(false);
         boolean endSkipFound=false;
-        while (endSkipFound==false) {//TODO: rewrite endskip criterium
+        while (endSkipFound==false) {
             readNextToken(); 
-            if (getHistory().getTokenIndex()>=getHistory().getLine(getHistory().nrOfLines()-1).getTokensSeen() && (skipIndentHandler.lineMarginEnded() && skipIndentHandler.getIndentValue() <= skipP.getIndentValue()) || myParser.currentToken==SGLR.EOF) {
+            if ((reachedErrorDetectionLine() && endOfConstruct(skipP)) || myParser.currentToken==SGLR.EOF) {
                 endSkipFound=true;                 
                 int indent = skipIndentHandler.getIndentValue();
                 skipPoint = new IndentInfo(-1, getHistory().getTokenIndex() -1, indent);
@@ -246,6 +261,14 @@
         }        
     }
 
+    private boolean endOfConstruct(IndentInfo skipP) {
+        return (skipIndentHandler.lineMarginEnded() && skipIndentHandler.getIndentValue() <= skipP.getIndentValue());
+    }
+
+    private boolean reachedErrorDetectionLine() {
+        return getHistory().getTokenIndex()>=getHistory().getLine(getHistory().nrOfLines()-1).getTokensSeen();
+    }
+
     private void parseAsLayout() throws IOException {        
         switch (myParser.currentToken) {                
         case '\n':
@@ -266,18 +289,14 @@
         skipIndentHandler.updateIndentation(myParser.currentToken);
         if (isDebugMode)
             Tools.debug((char)myParser.currentToken); 
-    }    
-    
-    protected boolean meetsRecoverCriteria() {
-        return myParser.acceptingStack == null;//TODO: handle endless loop && myParser.currentToken != myParser.EOF;
-    } 
-   
+    }       
+       
     private void updateRecoverLinePoint(SGLR myParser) {
         if(myParser.getIndentHandler().lineMarginEnded()){
             int indent = myParser.getIndentHandler().getIndentValue();
             IndentInfo newLinePoint= new IndentInfo(myParser.lineNumber, getHistory().getTokenIndex(), indent);
             newLinePoint.fillStackNodes(myParser.activeStacks);
-            recoverNewLinePoints.add(newLinePoint);  
+            recoverlines.add(newLinePoint);  
         }      
     }    
 }
@@ -303,8 +322,7 @@
         }
     }
     
-    protected void logBeforeRecover() {
-        //TODO: log-before and log-after recover to super class 
+    protected void logBeforeRecover() {        
         if(isDebugMode){
             logBigReductionList();
             logLastParsedFragment();



From mdjonge at xs4all.nl  Fri May 29 16:58:25 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Fri, 29 May 2009 14:58:25 -0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19498 - MaartjeDeJonge
	- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
Message-ID: <200905291458.n4TEw8TW021619@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-05-29 14:58:55 +0000 (Fri, 29 May 2009)
New Revision: 19498

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19498&view=rev

Modified:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParserHistory.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java

Log:
renaming

Changes:

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParserHistory.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParserHistory.java	2009-05-29 14:45:44 UTC (rev 19497)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParserHistory.java	2009-05-29 14:58:55 UTC (rev 19498)
@@ -13,18 +13,32 @@
     private int recoverTokenCount;
     private int tokenIndex;
     
-    public ParserHistory(){
-        previousBigReduceIndex=0;
-        bigReduceIndex=0;
+    public int getTokenIndex() {
+        return tokenIndex;
+    }
+
+    public void setTokenIndex(int tokenIndex) {
+        this.tokenIndex = tokenIndex;
+    }
+    
+    public ParserHistory(){    
         newLinePoints=new ArrayList<IndentInfo>();        
+        reset();
+    }
+    
+    //TODO: call from parser
+    public void reset(){
+        newLinePoints.clear();
         recoverTokenStream = new char[200];
         recoverTokenCount = 0;
         indexConstruct=0;
         tokenIndex=0;
+        previousBigReduceIndex=0;
+        bigReduceIndex=0;
     }
     
     /*
-     * Set current token based on recover tokens or read from new tokens
+     * Set current token of parser based on recover tokens or read from new tokens
      */
     public void readRecoverToken(SGLR myParser) throws IOException{        
         if (hasFinishedRecoverTokens()) {
@@ -47,16 +61,8 @@
         }
         return tokIndexLine;
     }
-    
-    public int getTokenIndex() {
-        return tokenIndex;
-    }
 
-    public void setTokenIndex(int tokenIndex) {
-        this.tokenIndex = tokenIndex;
-    }
-
-    public void afterStreamRead(SGLR myParser) {
+    public void keepTokenAndState(SGLR myParser) {
         keepToken((char)myParser.currentToken);
         tokenIndex++;
         if(myParser.getIndentHandler().lineMarginEnded())
@@ -98,15 +104,15 @@
         return newLinePoints.get(indexConstruct);
     }
     
-    public IndentInfo startBigReduce() {
+    public IndentInfo getBigReducePoint() {
         return newLinePoints.get(bigReduceIndex);
     }   
     
-    public IndentInfo startPreviousBigReduce() {
+    public IndentInfo getPreviousBigReducePoint() {
         return newLinePoints.get(previousBigReduceIndex);
     } 
     
-    public void setIndexOnParentConstruct() {
+    public void moveToParentConstruct() {
         int parentConstructIndex=0;
         int loopIndex = newLinePoints.size()-2;
         while ( loopIndex >= 0 && parentConstructIndex==0) {
@@ -126,11 +132,11 @@
         return newLinePoints.get(index);
     }
     
-    public void setIndexOnLastConstruct(){
+    public void moveToLastConstruct(){
         indexConstruct=newLinePoints.size()-1;        
     }
 
-    public boolean setIndexOnPreviousConstruct() {
+    public boolean moveToPreviousConstruct() {
 
         if(indexConstruct<=0)
             return false;
@@ -153,13 +159,13 @@
         return true;   
     }
     
-    public void mergeRecoverLines(ArrayList<IndentInfo> recoverNewLinePoints) {
+    public void addRecoverLines(ArrayList<IndentInfo> recoverNewLinePoints) {
         if(recoverNewLinePoints.size()==0)
             return;
         newLinePoints.remove(newLinePoints.size()-1); //remove line of error detection
         newLinePoints.addAll(recoverNewLinePoints);        
     }
-    
+    /*
     ///////////////////////////////// LOG /////////////////////////////////////////////////////////////////
     public void logBigReductionList() {        
         for (int i = 0; i < newLinePoints.size(); i++) {
@@ -176,6 +182,6 @@
         Tools.debug("REDUCE-LENGTH: " +brPoint.maxReduceLength());
         Tools.debug("TOKEN-POSITION: " +brPoint.getTokensSeen());        
         Tools.debug("........................");
-    }
+    }*/
     
 }

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-05-29 14:45:44 UTC (rev 19497)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-05-29 14:58:55 UTC (rev 19498)
@@ -244,7 +244,7 @@
                 indentHandler.updateIndentation(currentToken);
                 //indentTokenHandler.handleIndentShifts(this);                
                 //recoverHandler.afterStreamRead(currentToken);
-                history.afterStreamRead(this);
+                history.keepTokenAndState(this);
                 doParseStep(); 
                 //recoverHandler.afterParseStep();
                 //  Tools.debug("SGLR: "+(char)currentToken);             

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java	2009-05-29 14:45:44 UTC (rev 19497)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java	2009-05-29 14:58:55 UTC (rev 19498)
@@ -79,7 +79,7 @@
      * Recovers by skipping (parse as whitespace) part of the input string
      */
     public void recover() throws IOException {
-        getHistory().setIndexOnLastConstruct();
+        getHistory().moveToLastConstruct();
         errorDetectionPosition=myParser.tokensSeen;
         recoverAction = SkipAction.SKIP_PREVIOUS;
         while (recoverySucceeded()==false && recoverAction != SkipAction.STOPPED) {
@@ -87,10 +87,10 @@
                 Tools.debug("ACTION: "+recoverAction);
             switch (recoverAction) {
             case SKIP_PREVIOUS:
-                if(getHistory().setIndexOnPreviousConstruct()){
+                if(getHistory().moveToPreviousConstruct()){
                     skipCurrentConstruct();
                 }                
-                getHistory().setIndexOnLastConstruct();
+                getHistory().moveToLastConstruct();
                 recoverAction=SkipAction.SKIP_CURRENT;
                 break;
             case SKIP_CURRENT:
@@ -102,8 +102,8 @@
                 recoverAction=SkipAction.SKIP_PARENT;
                 break;
             case SKIP_PARENT:
-                getHistory().setIndexOnParentConstruct();
-                if(getHistory().getConstructPoint().getTokensSeen()<= getHistory().startPreviousBigReduce().getTokensSeen())
+                getHistory().moveToParentConstruct();
+                if(getHistory().getConstructPoint().getTokensSeen()<= getHistory().getPreviousBigReducePoint().getTokensSeen())
                     recoverAction=SkipAction.SKIP_FORWARD;
                 else
                     recoverAction = SkipAction.SKIP_CURRENT;
@@ -122,14 +122,14 @@
                 break;          
             }            
         }
-        getHistory().mergeRecoverLines(recoverlines);
+        getHistory().addRecoverLines(recoverlines);
         reset();        
     }
 
     private void forcingParse() throws IOException{
         EofRecovery eofR = new EofRecovery();        
         eofR.myParser=myParser;
-        eofR.enforceAccept(getHistory().startBigReduce().getStackNodes());
+        eofR.enforceAccept(getHistory().getBigReducePoint().getStackNodes());
     }
 
     private boolean recoverySucceeded() {
@@ -146,7 +146,7 @@
             while (!hasDedent(skipPoint.getIndentValue(), indent) && (recoverySucceeded()==false) && (myParser.currentToken != SGLR.EOF)) {
                 doSkipRecoverStep();
             }            
-        } while ((recoverySucceeded()==false) && (myParser.currentToken != SGLR.EOF)&& getHistory().setIndexOnPreviousConstruct());      
+        } while ((recoverySucceeded()==false) && (myParser.currentToken != SGLR.EOF)&& getHistory().moveToPreviousConstruct());      
     }
     
     private boolean hasDedent(int indentNew, int indentOld) {
@@ -157,16 +157,16 @@
      * Looks for a recovery by skipping forward from Parent, big-reduce or previous big-reduce
      */
     private void skipForward() throws IOException {
-        boolean skipFromCurrent=getHistory().getConstructPoint().structureStartPosition()==getHistory().startPreviousBigReduce().structureStartPosition();
+        boolean skipFromCurrent=getHistory().getConstructPoint().structureStartPosition()==getHistory().getPreviousBigReducePoint().structureStartPosition();
         if(skipFromCurrent)
             setSkipPoint(getHistory().getConstructPoint());
         else {
-            boolean startOnPrevious = getHistory().startBigReduce().getIndentValue()>getHistory().startPreviousBigReduce().getIndentValue();
+            boolean startOnPrevious = getHistory().getBigReducePoint().getIndentValue()>getHistory().getPreviousBigReducePoint().getIndentValue();
             if(startOnPrevious){
-                setSkipPoint(getHistory().startPreviousBigReduce()); 
+                setSkipPoint(getHistory().getPreviousBigReducePoint()); 
             }
             else{
-                setSkipPoint(getHistory().startBigReduce());
+                setSkipPoint(getHistory().getBigReducePoint());
             }
         }
         do {



From mdjonge at xs4all.nl  Fri May 29 17:27:46 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Fri, 29 May 2009 15:27:46 -0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19499 - MaartjeDeJonge
	- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
Message-ID: <200905291527.n4TFRTqp022317@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-05-29 15:28:16 +0000 (Fri, 29 May 2009)
New Revision: 19499

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19499&view=rev

Modified:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParserHistory.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java

Log:
performance improvement by "lazy" big reduce setting 

Changes:

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParserHistory.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParserHistory.java	2009-05-29 14:58:55 UTC (rev 19498)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParserHistory.java	2009-05-29 15:28:16 UTC (rev 19499)
@@ -82,12 +82,27 @@
         int indent = myParser.getIndentHandler().getIndentValue();
         IndentInfo newLinePoint= new IndentInfo(myParser.lineNumber, myParser.tokensSeen-1, indent);
         newLinePoint.fillStackNodes(myParser.activeStacks);
-        newLinePoints.add(newLinePoint);
-        //TODO: findBigReduceIndex()
-        if(newLinePoints.get(bigReduceIndex).maxReduceLength()< newLinePoint.maxReduceLength()){
-            previousBigReduceIndex = bigReduceIndex;
-            bigReduceIndex = newLinePoints.size()-1;                 
+        newLinePoints.add(newLinePoint);       
+    }
+    
+    public void setBigReducePoints(){
+        int brLength=newLinePoints.get(bigReduceIndex).maxReduceLength();
+        int oldBR=bigReduceIndex;
+        for (int i = newLinePoints.size()-1; i > bigReduceIndex; i--) {
+            IndentInfo point=newLinePoints.get(i);                      
+            if(point.maxReduceLength() >= brLength){                
+                bigReduceIndex = i;
+                previousBigReduceIndex=oldBR;
+                break;
+            }
         }
+        for (int j = bigReduceIndex-1; j > oldBR; j--) {
+            IndentInfo point=newLinePoints.get(j);                      
+            if(point.maxReduceLength() >= brLength){                
+                previousBigReduceIndex = j;
+                break;
+            }
+        }
     }
     
     public String getFragment(int startTok, int endTok) {

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java	2009-05-29 14:58:55 UTC (rev 19498)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java	2009-05-29 15:28:16 UTC (rev 19499)
@@ -79,6 +79,7 @@
      * Recovers by skipping (parse as whitespace) part of the input string
      */
     public void recover() throws IOException {
+        getHistory().setBigReducePoints();
         getHistory().moveToLastConstruct();
         errorDetectionPosition=myParser.tokensSeen;
         recoverAction = SkipAction.SKIP_PREVIOUS;



