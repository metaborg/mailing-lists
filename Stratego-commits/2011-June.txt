From R.B.Vermaas at tudelft.nl  Wed Jun  1 09:49:31 2011
From: R.B.Vermaas at tudelft.nl (Rob Vermaas)
Date: Wed, 01 Jun 2011 07:49:31 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r22971 - hydra
Message-ID: <20110601074931.6A89A2B8056@mx2.tudelft.nl>

Author: rob
Date: Wed Jun  1 07:49:30 2011
New Revision: 22971
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=22971&sc=1

Log:
java.jar build after compile phase

Modified:
   hydra/spoofax-fun.nix

Modified: hydra/spoofax-fun.nix
==============================================================================
--- hydra/spoofax-fun.nix	Tue May 31 14:51:24 2011	(r22970)
+++ hydra/spoofax-fun.nix	Wed Jun  1 07:49:30 2011	(r22971)
@@ -91,15 +91,33 @@
                   <tasks>
                           <echo>Running ant script</echo>
                           <property name="externaljarx" refid="maven.compile.classpath"/>
-                          <property name="eclipse.spoofaximp.jars" value="utils"/>
+                          <property name="eclipse.spoofaximp.jars" value="utils/"/>
                           <property name="eclipse.spoofaximp.strategojar" value="utils/strategoxt.jar"/>
                           <property name="eclipse.home" value="${eclipse}/eclipse"/>
-                          <property name="java.jar.enabled" value="true"/>
                           <property name="build.compiler" value="org.eclipse.jdt.core.JDTCompilerAdapter"/>
                           <ant antfile="build.main.xml" inheritRefs="true">
                           </ant>
                   </tasks>
                </configuration>
+               <goals>
+                  <goal>run</goal>
+               </goals>
+       </execution>
+       <execution>
+               <id>process-classes</id>
+               <phase>process-classes</phase>
+               <configuration>
+                  <tasks>
+                          <echo>Running ant script</echo>
+                          <property name="eclipse.spoofaximp.jars" value="utils/"/>
+                          <property name="eclipse.spoofaximp.strategojar" value="utils/strategoxt.jar"/>
+                          <property name="eclipse.home" value="${eclipse}/eclipse"/>
+                          <property name="build.compiler" value="org.eclipse.jdt.core.JDTCompilerAdapter"/>
+                          <ant antfile="build.main.xml" inheritRefs="true">
+                            <target name="java.jar"/>
+                          </ant>
+                  </tasks>
+               </configuration>
                <goals>
                   <goal>run</goal>
                </goals>

From L.C.L.Kats at tudelft.nl  Wed Jun  1 11:09:16 2011
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Wed, 01 Jun 2011 09:09:16 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r22972 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/tests/grammars
Message-ID: <20110601090916.49167CC030@mx4.tudelft.nl>

Author: LennartKats
Date: Wed Jun  1 09:09:15 2011
New Revision: 22972
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=22972&sc=1

Log:
StrategoStratego syntax

Added:
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests/grammars/StrategoStratego.def.in
Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests/grammars/Makefile

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/tests/grammars/Makefile
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/tests/grammars/Makefile	Wed Jun  1 07:49:30 2011	(r22971)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests/grammars/Makefile	Wed Jun  1 09:09:15 2011	(r22972)
@@ -32,7 +32,7 @@
 #	   echo;		\
 #	 done) >$@
 
-Stratego.def: Stratego.def.in
+%.def: %.def.in
 	ln -sf $< $@
 
 #Java-SQL.def: Java-SQL.def.in

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests/grammars/StrategoStratego.def.in
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests/grammars/StrategoStratego.def.in	Wed Jun  1 09:09:15 2011	(r22972)
@@ -0,0 +1,1189 @@
+definition
+module EmbeddedStratego[E1 E2]
+imports Stratego
+exports
+  context-free syntax
+
+              "|[" Module "]|" -> E1 {cons("ToTerm"),prefer}
+    "Module"  "|[" Module "]|" -> E1 {cons("ToTerm")}
+
+              "|[" Decl   "]|" -> E1 {cons("ToTerm")}
+              "|[" Sdecl  "]|" -> E1 {cons("ToTerm")}
+
+              "|[" Opdecl "]|" -> E1 {cons("ToTerm")}
+    "Constr"  "|[" Opdecl "]|" -> E1 {cons("ToTerm")}
+
+              "|[" Type   "]|" -> E1 {cons("ToTerm")}
+    "Type"    "|[" Type   "]|" -> E1 {cons("ToTerm")}
+
+    "Sort"    "|[" Sort   "]|" -> E1 {cons("ToTerm")}
+
+              "|[" Term   "]|" -> E1 {cons("ToTerm")}
+    "Term"    "|[" Term   "]|" -> E1 {cons("ToTerm")}
+
+              "|[" Def    "]|" -> E1 {cons("ToTerm")}
+    "Def"     "|[" Def    "]|" -> E1 {cons("ToTerm")}
+
+             "|[" Rule      "]|" -> E1 {cons("ToTerm")}
+    "Rule"   "|[" Rule      "]|" -> E1 {cons("ToTerm")}
+             "|[" StratRule "]|" -> E1 {cons("ToTerm")}
+
+               "|[" Strategy "]|" -> E1 {cons("ToTerm")}
+    "Strat"    "|[" Strategy "]|" -> E1 {cons("ToTerm")}
+    "Strategy" "|[" Strategy "]|" -> E1 {cons("ToTerm")}
+
+    "O"        "|[" Overlay  "]|" -> E1 {cons("ToTerm")}
+    "Overlay"  "|[" Overlay  "]|" -> E1 {cons("ToTerm")}
+
+    "Typedid"    "|[" Typedid    "]|" -> E1 {cons("ToTerm")}
+    "DynRuleDef" "|[" DynRuleDef "]|" -> E1 {cons("ToTerm")}
+
+  context-free syntax
+    "~"         E2 -> ModName          {cons("FromTerm")}
+
+    "~"         E2 -> Term             {cons("FromTerm")}
+    "~term:"    E2 -> Term             {cons("FromTerm")}
+    %%"~term*:" E2 -> {Term ","}*      {cons("FromTerm")}
+    "~term*:"   E2 -> {Term ","}+      {cons("FromTerm")}
+    "~"         E2 -> {ID   ","}+      {cons("FromTerm")}
+
+    "~"         E2 -> Strategy         {cons("FromTerm")}
+    "~strat:"   E2 -> Strategy         {cons("FromTerm")}
+    "~*"        E2 -> {Strategy ","}+  {cons("FromTerm")}
+    "~strat*:"  E2 -> {Strategy ","}+  {cons("FromTerm")}
+
+    "~srt:"     E2 -> Sort {cons("FromTerm")}
+    "~srtvar:"  E2 -> LCID {cons("FromTerm")}
+    "~srtid:"   E2 -> UCID {cons("FromTerm")}
+
+    "~id:"    E2 -> Id     {cons("FromTerm")}
+    "~int:"   E2 -> Int    {cons("FromTerm")}
+    "~str:"   E2 -> String {cons("FromTerm")}
+
+    Id "/" Id -> Id {cons("ManglePrefix")}
+    Id "\\" Id -> Id {cons("MangleSuffix")}
+
+    "~"   E2 -> Def       {cons("FromTerm")}
+    "~*"  E2 -> Def+      {cons("FromTerm")}
+
+    "~*"  E2 -> Opdecl+      {cons("FromTerm")}
+    "~*"  E2 -> {Type "*"}+  {cons("FromTerm")}
+
+    "~*"          E2 -> {Typedid ","}+   {cons("FromTerm")}
+    "~typed-id*:" E2 -> {Typedid ","}+   {cons("FromTerm")}
+
+  %%%
+   %% Hacks
+   %%
+   %% Why are these hacks nessary? What do they do?
+   %%%
+  context-free syntax 
+    "<" Strategy ">" -> StrategyAngle {bracket}
+    "(" Strategy ")" -> Strategy      {bracket,prefer}
+
+%%%
+ %% Identifiers
+ %%%
+
+  variables
+    [xyzfglc][0-9\']*       -> Id       {prefer}
+    [xyzfgl][0-9\']*  "*"   -> {Id ","}+ {prefer}
+    "xs"[0-9\']*            -> {Id ","}+ {prefer,obsolete}
+
+    [xyzfgl][0-9\']*  "*"   -> {ID ","}+ {prefer}
+
+%%%
+ %% Terms
+ %%%
+
+  variables
+    TermMetaVar     -> Term        {prefer}
+    TermListMetaVar -> {Term ","}+ {prefer}
+    TermListMetaVar -> {Term ","}+ {prefer,obsolete}
+
+  lexical syntax
+    [t][0-9\']*      -> TermMetaVar
+    "t:"Id           -> TermMetaVar
+    [t][0-9\']*  "*" -> TermListMetaVar
+    "ts"[0-9\']*     -> TermListMetaVar
+
+    TermMetaVar      -> MetaVar
+    TermListMetaVar  -> MetaVar
+
+%%%
+ %% Cleanup
+ %%%
+
+  variables
+    "str"[0-9\']* -> String
+
+  lexical syntax
+    "str"[0-9\']* -> Id {reject}
+
+  variables
+    "s"[0-9\']*           -> Strategy {prefer}
+    "ss"[0-9\']*          -> {Strategy ","}+ {prefer,obsolete}
+    "s"[0-9\']*   "*"     -> {Strategy ","}+ {prefer}
+
+    [r][0-9\']*           -> Rule {prefer}
+
+    "rd"[0-9\']*          -> RuleDef {prefer}
+    "rd"[0-9\']*  "*"     -> RuleDef* {prefer}
+
+    "a"[0-9\']*           -> Typedid        {prefer}
+    "a"[0-9\']*   "*"     -> {Typedid ","}+ {prefer}
+    "as"[0-9\']*          -> {Typedid ","}+ {prefer,obsolete}
+
+    "tp"[0-9\']*          -> Type 
+    "tp"[0-9\']*  "*"     -> {Type "*"}+  
+
+    "srt" [0-9\']*        -> Sort         {prefer}
+    "srt" [0-9\']* "*"    -> {Sort ","}*  {prefer}
+    "srt" [xyz] [0-9\']*  -> UCID         {prefer}
+
+    "M"   [0-9\']*        -> ModName {prefer}
+
+    "sc" [0-9\']*         -> SwitchCase {prefer}
+    "sc" [0-9\']* "*"     -> SwitchCase* {prefer}
+
+  variables
+    "sc" [0-9\']*         -> DynRuleScopeId        {prefer}
+    "sc" [0-9\']* "*"     -> {DynRuleScopeId ","}+ {prefer}
+
+    "dr" [0-9\']*         -> DynRuleId {prefer}
+
+    "drd"[0-9\']*         -> DynRuleDef {prefer}
+    "drd"[0-9\']*  "*"    -> DynRuleDef+ {prefer}
+
+%%%
+ %%
+ %% Disambiguation
+ %%%
+
+  lexical syntax
+    MetaVar -> Id  {reject}
+    MetaVar -> LId {reject}
+
+    "xs"[0-9\']*    -> Id  {reject}
+    [s][0-9\']*     -> Id  {reject}
+    "ss"[0-9\']*    -> Id  {reject}
+    [r][0-9\']*     -> Id  {reject}
+     "a"[0-9\']*    -> Id  {reject}
+    "as"[0-9\']*    -> Id  {reject}
+
+module EmbeddedStrategoMix[Ctx0 E1 E2]
+imports EmbeddedStratego[E1 E2]
+          [ MetaVar            => MetaVar[[Ctx0]]
+            TermListMetaVar    => TermListMetaVar[[Ctx0]]
+            TermMetaVar        => TermMetaVar[[Ctx0]]
+            RuleNames          => RuleNames[[Ctx0]]
+            RuleDec            => RuleDec[[Ctx0]]
+            DynRuleScopeId     => DynRuleScopeId[[Ctx0]]
+            DynRuleId          => DynRuleId[[Ctx0]]
+            DynRuleDef         => DynRuleDef[[Ctx0]]
+            ScopeLabels        => ScopeLabels[[Ctx0]]
+            RuleCond           => RuleCond[[Ctx0]]
+            Rule               => Rule[[Ctx0]]
+            RuleDef            => RuleDef[[Ctx0]]
+            Overlay            => Overlay[[Ctx0]]
+            SwitchCase         => SwitchCase[[Ctx0]]
+            StrategyCurly      => StrategyCurly[[Ctx0]]
+            StrategyAngle      => StrategyAngle[[Ctx0]]
+            Kind               => Kind[[Ctx0]]
+            LID                => LID[[Ctx0]]
+            ImportModName      => ImportModName[[Ctx0]]
+            Decl               => Decl[[Ctx0]]
+            Module             => Module[[Ctx0]]
+            StrategyParen      => StrategyParen[[Ctx0]]
+            Typedid            => Typedid[[Ctx0]]
+            Anno               => Anno[[Ctx0]]
+            EmptyId            => EmptyId[[Ctx0]]
+            StrategyDef        => StrategyDef[[Ctx0]]
+            SVar               => SVar[[Ctx0]]
+            Def                => Def[[Ctx0]]
+            Type               => Type[[Ctx0]]
+            RetType            => RetType[[Ctx0]]
+            ArgType            => ArgType[[Ctx0]]
+            FunType            => FunType[[Ctx0]]
+            ConstType          => ConstType[[Ctx0]]
+            Opdecl             => Opdecl[[Ctx0]]
+            Sort               => Sort[[Ctx0]]
+            Sdecl              => Sdecl[[Ctx0]]
+            Wld                => Wld[[Ctx0]]
+            ID                 => ID[[Ctx0]]
+            Var                => Var[[Ctx0]]
+            CharChar           => CharChar[[Ctx0]]
+            Char               => Char[[Ctx0]]
+            Padding            => Padding[[Ctx0]]
+            Dollar4            => Dollar4[[Ctx0]]
+            QuotedBracket4     => QuotedBracket4[[Ctx0]]
+            StringQuotedChars4 => StringQuotedChars4[[Ctx0]]
+            StringQuotedPart4  => StringQuotedPart4[[Ctx0]]
+            Dollar3            => Dollar3[[Ctx0]]
+            QuotedBracket3     => QuotedBracket3[[Ctx0]]
+            StringQuotedChars3 => StringQuotedChars3[[Ctx0]]
+            StringQuotedPart3  => StringQuotedPart3[[Ctx0]]
+            Dollar2            => Dollar2[[Ctx0]]
+            QuotedBracket2     => QuotedBracket2[[Ctx0]]
+            StringQuotedChars2 => StringQuotedChars2[[Ctx0]]
+            StringQuotedPart2  => StringQuotedPart2[[Ctx0]]
+            Dollar1            => Dollar1[[Ctx0]]
+            QuotedBracket1     => QuotedBracket1[[Ctx0]]
+            StringQuotedChars1 => StringQuotedChars1[[Ctx0]]
+            StringQuotedPart1  => StringQuotedPart1[[Ctx0]]
+            StringQuotation    => StringQuotation[[Ctx0]]
+            StrChar            => StrChar[[Ctx0]]
+            String             => String[[Ctx0]]
+            Real               => Real[[Ctx0]]
+            Int                => Int[[Ctx0]]
+            Keyword            => Keyword[[Ctx0]]
+            UCID               => UCID[[Ctx0]]
+            LCID               => LCID[[Ctx0]]
+            LId                => LId[[Ctx0]]
+            Id                 => Id[[Ctx0]]
+            ModNamePart        => ModNamePart[[Ctx0]]
+            ModName            => ModName[[Ctx0]]
+            PreTerm            => PreTerm[[Ctx0]]
+            Term               => Term[[Ctx0]]
+            StrategyMid        => StrategyMid[[Ctx0]]
+            Strategy           => Strategy[[Ctx0]] ]
+
+
+module Stratego-Sugar-Overlays
+imports
+  Stratego-Core-Identifiers
+  Stratego-Sugar-Terms
+
+exports
+  sorts Overlay
+  context-free syntax
+    Id 			 "=" Term 	-> Overlay {cons("OverlayNoArgs")}
+    Id "(" {Id ","}* ")" "=" Term 	-> Overlay {cons("Overlay")}
+
+module Stratego-Sugar-DynamicRules
+imports
+  Stratego-Core-Identifiers
+  Stratego-Sugar-Strategies
+  Stratego-Sugar-Rules
+
+exports
+ 
+  sorts ScopeLabels
+  context-free syntax
+
+    "{|" ScopeLabels ":" Strategy "|}" -> Strategy {cons("DynRuleScope")}
+
+    {DynRuleScopeId ","}*   -> ScopeLabels
+    "~" Term		    -> ScopeLabels {cons("ScopeLabels")}
+
+  sorts DynRuleDef DynRuleId DynRuleScopeId RuleDec
+  context-free syntax
+
+    "rules" "(" DynRuleDef* ")" -> Strategy {cons("GenDynRules")}
+
+    Id "+" Term                 -> DynRuleDef {cons("AddScopeLabel")} 
+    DynRuleId ":-"  Term        -> DynRuleDef {cons("UndefineDynRule")}
+    DynRuleId ":"   Rule        -> DynRuleDef {cons("SetDynRule")}
+    DynRuleId ":+"  Rule        -> DynRuleDef {cons("AddDynRule")}
+    DynRuleId ":"   Term        -> DynRuleDef {cons("SetDynRuleMatch")}
+
+    DynRuleId ":="  Term        -> DynRuleDef {cons("DynRuleAssign")}
+    DynRuleId ":+="  Term       -> DynRuleDef {cons("DynRuleAssignAdd")}
+
+    DynRuleId ":"   Rule "depends" "on" Term -> DynRuleDef {cons("SetDynRuleDepends")}
+
+    RuleDec "." Term            -> DynRuleId {cons("LabeledDynRuleId")}
+    RuleDec "+" Term            -> DynRuleId {cons("AddLabelDynRuleId")}
+    RuleDec                     -> DynRuleId {cons("DynRuleId")}
+
+    Id "." Term                 -> DynRuleScopeId {cons("LabeledDynRuleScopeId")}
+    Id                          -> DynRuleScopeId {cons("DynRuleScopeId")}
+
+  context-free syntax
+
+    Id                          -> RuleDec {cons("RDecNoArgs")}
+    Id "(" {Typedid ","}* ")"   -> RuleDec {cons("RDec")}
+    Id "(" {Typedid ","}* 
+       "|" {Typedid ","}* ")"   -> RuleDec {cons("RDecT")}
+
+  sorts RuleNames
+  context-free syntax
+    {Id ","}*				  -> RuleNames
+    "~" Term				  -> RuleNames {cons("RuleNames")}
+
+    "/" RuleNames "\\*" Strategy          -> Strategy {cons("DynRuleIntersectFix")}
+
+  syntax
+    %% no space after RuleNames
+    "\\" <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleUnionFix")}
+
+    %% 1 space after RuleNames
+    "\\" <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleUnionFix")}
+
+    %% no space after RuleNames
+    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
+        <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}
+
+    %% 1 space after RuleNames
+    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
+        <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}
+
+
+  context-free syntax
+    Strategy "/" RuleNames"\\" Strategy  -> Strategy {cons("DynRuleIntersect"),right}
+    Strategy "\\" RuleNames "/" Strategy  -> Strategy {cons("DynRuleUnion"),right}
+
+    Strategy "/" RuleNames "\\" 
+                 RuleNames "/"  Strategy  -> Strategy {cons("DynRuleIntersectUnion"),right}
+
+  priorities
+    <StrategyAngle-CF> <LAYOUT?-CF> <Term-CF> -> <Strategy-CF> {cons("BA")}
+  > {
+
+    %% no space after RuleNames
+    "\\" <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleUnionFix")}
+
+    %% 1 space after RuleNames
+    "\\" <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleUnionFix")}
+
+    %% no space after RuleNames
+    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
+        <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}
+
+    %% 1 space after RuleNames
+    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
+        <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}
+
+    }
+  > <Strategy-CF> <LAYOUT?-CF> "=>" <LAYOUT?-CF> <Term-CF> -> <Strategy-CF> {cons("AM")}
+
+  context-free priorities
+    StrategyAngle Term 		          -> Strategy {cons("BA")}
+  > "/" RuleNames "\\*" Strategy          -> Strategy {cons("DynRuleIntersectFix")}
+  > Strategy "=>" Term 		  	  -> Strategy {cons("AM")}
+  > Strategy "/" RuleNames "\\" Strategy  -> Strategy {cons("DynRuleIntersect"),right}
+  > Strategy "\\" RuleNames "/" Strategy  -> Strategy {cons("DynRuleUnion"),right}
+  > Strategy "/" RuleNames "\\" 
+                 RuleNames "/"  Strategy  -> Strategy {cons("DynRuleIntersectUnion"),right}
+  > Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
+
+module Stratego-Sugar-Rules
+imports Stratego-Sugar-Strategies
+exports
+
+  sorts RuleDef
+  context-free syntax
+    Id ":" Rule 				-> RuleDef {cons("RDefNoArgs")}
+    
+    Anno+ RuleDef               -> Def {cons("AnnoDef")}
+
+    Id "(" {Typedid ","}* ")" ":" Rule 		-> RuleDef {cons("RDef")}
+
+    Id "(" {Typedid ","}* 
+       "|" {Typedid ","}* ")" ":" Rule 		-> RuleDef {cons("RDefT")}
+
+  sorts Rule RuleCond
+  context-free syntax
+    Term "->" Term           	    -> Rule {cons("RuleNoCond")} %% backward comp.
+    Term "->" Term "where" Strategy -> Rule {cons("Rule")}       %% backward comp.
+    Term "->" Term RuleCond+	    -> Rule {cons("Rule"), avoid}
+
+    "where" Strategy -> RuleCond {cons("WhereClause")}
+    "with"  Strategy -> RuleCond {cons("WithClause")}
+
+module Stratego-Sugar-Strategies
+imports
+  Stratego-Core-Strategies
+  Stratego-Sugar-Terms
+  Stratego-Sugar-Constants
+  Stratego-Sugar-Signatures
+
+exports
+  context-free syntax
+    Id  		      "=" Strategy -> StrategyDef {cons("SDefNoArgs")}
+    Id "(" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("SDef")}
+
+  context-free syntax
+    ID 				  	  -> Typedid {cons("DefaultVarDec")}
+
+  sorts Rule
+
+  sorts StrategyParen StrategyCurly StrategyAngle
+  context-free syntax
+
+    %% Abstraction
+
+    SVar "(" {Strategy ","}* ")" 	  -> Strategy {cons("Call")}
+
+    %% Match and build
+
+    "{" Strategy "}" 			  -> Strategy {cons("ScopeDefault")}
+
+     %%"<" Strategy ">" Term 		  -> Strategy {cons("BA")}
+     StrategyAngle Term 		  -> Strategy {cons("BA")}
+     "<" Strategy ">"			  -> StrategyAngle {bracket} %% {cons("AngleStrat")}
+
+    %% Combinators
+
+    Strategy "<+" Strategy 		  -> Strategy {cons("LChoice"),right}
+
+    "rec" Id "(" Strategy ")" 		  -> Strategy {cons("Rec")}
+
+    "not"   "(" Strategy ")" 		  -> Strategy {cons("Not")}
+    "where" "(" Strategy ")" 		  -> Strategy {cons("Where")}
+    "with"  "(" Strategy ")" 		  -> Strategy {cons("With"), prefer}
+    "test"  "(" Strategy ")" 		  -> Strategy {cons("Test")}
+
+    %% Primitives
+
+    "prim" "(" String ")" 		  -> Strategy {cons("PrimNoArgs")}
+    "prim" "(" String "," {Term ","}* ")" -> Strategy {cons("Prim")}
+
+    %% Congruence operators
+
+    String 				  -> Strategy {cons("StrCong")}
+    Int 				  -> Strategy {cons("IntCong")}
+    Real 				  -> Strategy {cons("RealCong")}
+    Char 			 	  -> Strategy {cons("CharCong")}
+
+    String "(" {Strategy ","}* ")" 	  -> Strategy {cons("CongQ")}
+
+    %%"(" {Strategy ","}* ")" 		  -> Strategy {cons("TupleCong"),avoid}
+
+    Strategy StrategyCurly		  -> Strategy {cons("AnnoCong")}
+    
+    "{" Strategy "}"		  	  -> StrategyCurly {cons("StrategyCurly")}
+
+    "("  ")" 		  		  -> Strategy {cons("EmptyTupleCong")}
+   "(" Strategy  ")" 		          -> Strategy {bracket}
+    "(" Strategy "," {Strategy ","}+ ")"  -> Strategy {cons("TupleCong")}
+
+%%    Mod 	  			  -> Strategy {cons("ModCongNoArgs")}
+%%    Mod "(" {Strategy ","}* ")"	  	  -> Strategy {cons("ModCong")}
+%%    Id "^" Id				  -> Mod {cons("Mod")}
+    "[" {Strategy ","}* "]" 		  -> Strategy {cons("ListCongNoTail")}
+    "[" {Strategy ","}* "|" Strategy "]"  -> Strategy {cons("ListCong")}
+
+%%    Strategy "#" "(" StrategyInj ")" 	  -> Strategy {cons("ExplodeCong")}
+%%    Strategy "#" "(" Strategy ")" 	  -> Strategy {cons("ExplodeCong")}
+    Strategy "#" StrategyParen	  	  -> Strategy {cons("ExplodeCong")}
+
+  %% Syntactic sugar sugar
+
+  sorts SwitchCase
+  context-free syntax
+
+    SVar  		  		  -> Strategy {cons("CallNoArgs")}
+    "\\" Rule "\\" 			  -> Strategy {cons("LRule")}
+    "(" Rule ")" 			  -> Strategy {cons("SRule")}
+    Strategy "+" Strategy 		  -> Strategy {cons("Choice"),right} 
+    Strategy "+>" Strategy 		  -> Strategy {cons("RChoice"),right}
+
+    "proceed"                          -> Strategy {cons("ProceedNoArgs"), prefer}
+    "proceed" "(" {Strategy "," }+ ")" -> Strategy {cons("Proceed"), prefer}
+
+    "if" Strategy "then" Strategy 
+                  "else" Strategy "end"   -> Strategy {cons("CondChoice")}
+    "if" Strategy "then" Strategy "end"   -> Strategy {cons("IfThen")}
+
+    "switch" Strategy SwitchCase* "end"   -> Strategy {cons("SwitchChoiceNoOtherwise")}
+    "switch" Strategy SwitchCase*
+         "otherwise" ":" Strategy "end"   -> Strategy {cons("SwitchChoice")}
+
+    "case" Strategy ":" Strategy          -> SwitchCase {cons("SwitchCase")}
+
+    Strategy "=>" Term 		  	  -> Strategy {cons("AM")}
+
+    Term ":=" Term			  -> Strategy {cons("Assign")}
+
+  %% Priorities
+
+  context-free priorities
+    { Strategy StrategyCurly		  -> Strategy
+      Strategy "#" StrategyParen          -> Strategy
+    }
+  > { "!" Term 				  -> Strategy
+      "?" Term 				  -> Strategy
+    }
+  > StrategyAngle Term 		          -> Strategy
+  > Strategy "=>" Term 		  	  -> Strategy
+  > Strategy ";" Strategy 		  -> Strategy
+  > {right: 
+     Strategy "+" Strategy 		  -> Strategy
+     Strategy "<+" Strategy 		  -> Strategy
+     Strategy "+>" Strategy 		  -> Strategy
+     
+     Strategy "<" StrategyMid 
+              "+" Strategy 		  -> Strategy
+    }
+
+  context-free priorities
+    Strategy 				  -> StrategyMid
+  > Strategy "+" Strategy 		  -> Strategy
+
+  context-free priorities
+    { Strategy StrategyCurly      -> Strategy
+      Strategy "#" StrategyParen  -> Strategy
+    }
+    .> Term ":=" Term -> Strategy
+
+
+module Stratego-Sugar-Terms
+imports
+  Stratego-Core-Terms
+  Stratego-Sugar-Strategies
+
+exports
+  sorts LID
+  context-free syntax
+    LId 			-> LID  {cons("ListVar")}
+    LID				-> Var  {cons("Var")}
+    LID				-> ID
+
+  context-free syntax
+    "_" PreTerm 		 -> PreTerm {cons("BuildDefaultPT")}
+    "_" Term 			 -> Term {cons("BuildDefault"),prefer}
+
+    Char 			 -> PreTerm {cons("Char")}
+
+    PreTerm "{" {Term ","}* "}"	 -> Term {cons("AnnoList")}
+    PreTerm                      -> Term {cons("NoAnnoList")}
+
+    "<" Strategy ">" Term 	 -> PreTerm {cons("App")}
+    "<" Strategy ">" Term 	 -> Term {cons("App"),prefer}
+
+    StrategyAngle		 -> PreTerm {cons("RootApp")}
+    StrategyAngle		 -> Term {cons("RootApp"),prefer}
+
+    "(" {Term ","}* ")" 	 -> PreTerm {cons("Tuple")}
+    "[" {Term ","}* "]" 	 -> PreTerm {cons("List")}
+    "[" {Term ","}* "|" Term "]" -> PreTerm {cons("ListTail")}
+
+  context-free priorities
+    Term "#" "(" Term ")" 	 -> PreTerm {cons("Explode")}
+  > PreTerm "{" {Term ","}* "}"	 -> Term {cons("AnnoList")}
+  > Var "@" Term 		 -> Term {cons("As")}
+
+module Stratego-Sugar-Signatures
+imports
+  Stratego-Core-Signatures
+  Stratego-Sugar-Constants
+
+exports
+
+  sorts Sort
+  context-free syntax
+    "[" {Sort ","}* "]"		 -> Sort {cons("SortList")}
+    "[" {Sort ","}* "|" Sort "]" -> Sort {cons("SortListTl")}
+    "(" {Sort ","}* ")"		 -> Sort {cons("SortTuple")}
+
+  sorts Kind
+  context-free syntax
+    "*" 			-> Kind {cons("Star")}
+    "**" 			-> Kind {cons("StarStar")}
+
+module Stratego-Core-Signatures
+imports
+  Stratego-Core-Identifiers
+  Stratego-Core-Constants
+exports
+  sorts Sdecl
+  context-free syntax
+    "sorts" Sort* 		-> Sdecl {cons("Sorts")}
+    "constructors" Opdecl* 	-> Sdecl {cons("Constructors")}
+
+  sorts Sort
+  context-free syntax
+    LCID 			 -> Sort {cons("SortVar")}
+    UCID 			 -> Sort {cons("SortNoArgs")}
+    Id "(" {Sort ","}* ")" 	 -> Sort {cons("Sort")}
+
+  sorts Opdecl
+  context-free syntax
+    Id     ":" Type 		-> Opdecl {cons("OpDecl")}
+    String ":" Type 		-> Opdecl {cons("OpDeclQ")}
+           ":" Type 		-> Opdecl {cons("OpDeclInj")}
+
+  context-free syntax
+    "external" Id     ":" Type 	-> Opdecl {cons("ExtOpDecl")}
+    "external" String ":" Type 	-> Opdecl {cons("ExtOpDeclQ")}
+    "external"        ":" Type 	-> Opdecl {cons("ExtOpDeclInj")}
+
+  sorts Type ArgType ConstType FunType RetType
+  context-free syntax
+    Sort	                -> ConstType {cons("ConstType")}
+    {ArgType "*"}+ "->" RetType -> FunType {cons("FunType")}
+    "(" Type ")"                -> ArgType {bracket}
+    ConstType			-> ArgType
+    Type	                -> RetType
+    FunType			-> RetType {reject}
+
+    FunType			-> Type
+    ConstType			-> Type
+
+  %%%
+   %% Restriction is required for the Sort* in Sdecl: List(a) is
+   %% ambiguous.
+   %%%
+  context-free restrictions
+    Sort -/- [\(]
+
+module Stratego-Core-Terms
+imports
+  Stratego-Core-Identifiers
+  Stratego-Core-Constants
+
+exports
+  sorts ID Var Wld
+  context-free syntax
+    Id 				-> Var  {cons("Var")}
+    Id				-> ID
+    %% ":" Var                  -> Var  {cons("SeqVar")}
+
+  sorts Term PreTerm
+  context-free syntax
+    Var 			 -> PreTerm 
+    Var 			 -> Term {prefer}
+
+    "_" 			 -> Wld {cons("Wld")}
+    Wld 			 -> PreTerm
+    Wld 			 -> Term {prefer}
+
+    Int 			 -> PreTerm {cons("Int")}
+    Real 			 -> PreTerm {cons("Real")}
+    String 			 -> PreTerm {cons("Str")}
+
+    Id "(" {Term ","}* ")" 	 -> PreTerm {cons("Op")}
+    String "(" {Term ","}* ")" 	 -> PreTerm {cons("OpQ")}
+    Term "#" "(" Term ")" 	 -> PreTerm {cons("Explode")}
+
+    PreTerm "{^" PreTerm "}"	 -> Term {cons("Anno")}
+
+    Var "@" Term 		 -> Term {cons("As"),prefer}
+    Var "@" PreTerm 		 -> PreTerm {cons("As")}
+
+  context-free priorities
+    Term "#" "(" Term ")" 	 -> PreTerm {cons("Explode")}
+  > Var "@" Term 		 -> Term {cons("As")}
+
+module Stratego-Core-Strategies
+imports
+  Stratego-Core-Terms
+  Stratego-Core-Constants
+  Stratego-Core-Signatures
+
+exports
+  sorts Def
+  context-free syntax
+    StrategyDef					 -> Def 
+    Id						 -> SVar {cons("SVar")}
+    "let" Def* "in" Strategy "end"		 -> Strategy {cons("Let")}
+    SVar "(" {Strategy ","}* "|" {Term ","}* ")" -> Strategy {cons("CallT")}
+
+    "call" "(" Term "|" {Strategy ","}* "|" {Term ","}* ")" -> Strategy {cons("CallDynamic")}
+
+
+  sorts StrategyDef
+  context-free syntax
+    Id "(" {Typedid ","}* 
+       "|" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("SDefT")}
+
+    Anno+ StrategyDef -> Def {cons("AnnoDef")}
+
+    "external"
+    Id "(" {Typedid ","}* 
+       "|" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("ExtSDefInl")}
+
+    "external"
+    Id "(" {Typedid ","}* 
+       "|" {Typedid ","}* ")"		   -> StrategyDef {cons("ExtSDef")}
+
+    "external"
+    EmptyId "(" {Typedid ","}* 
+       "|" {Typedid ","}* ")"		   -> StrategyDef {cons("ExtSDef")}
+
+
+  sorts EmptyId
+  lexical syntax
+  
+    -> EmptyId
+
+  sorts Anno
+  context-free syntax
+    "extend"      -> Anno {cons("Extend")}
+    "override"    -> Anno {cons("Override")}
+    "internal"    -> Anno {cons("Internal")}
+%%  "sealed"      -> Anno {cons("Sealed")}
+%%  "extensible"  -> Anno {cons("Extensible")}
+%%  "overridable" -> Anno {cons("Overridable")}
+
+  lexical syntax
+    
+    "extend"      -> Keyword
+    "override"    -> Keyword
+    "internal"    -> Keyword
+    "sealed"      -> Keyword
+    "extensible"  -> Keyword
+    "overridable" -> Keyword
+
+  lexical restrictions
+  
+    "extend"
+    "override"
+    "internal"
+    "sealed"
+    "extensible"
+    "overridable" -/- [a-zA-Z0-9\'\-\_]
+
+  sorts Typedid
+  context-free syntax
+    ID ":" Type 			  -> Typedid {cons("VarDec")}
+
+
+  sorts Strategy SVar StrategyParen StrategyMid 
+  context-free syntax
+    "(" Strategy ")"			  -> StrategyParen {cons("ParenStrat")}
+
+    "fail" 				  -> Strategy {cons("Fail")}
+    "id" 				  -> Strategy {cons("Id")}
+
+    "proceed" "(" {Strategy ","}* "|" {Term ","}* ")" -> Strategy {cons("ProceedT"), prefer}
+    "proceed"                                         -> Strategy {cons("ProceedNoArgs"), prefer}
+
+    %% Match and build
+
+    "?" Term 				  -> Strategy {cons("Match")}
+    "!" Term 				  -> Strategy {cons("Build")}
+    "{" {ID ","}* ":" Strategy "}" 	  -> Strategy {cons("Scope")}
+
+    %% Combinators
+
+    Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
+    Strategy "<" StrategyMid 
+             "+" Strategy 		  -> Strategy {cons("GuardedLChoice"),right}
+    Strategy 				  -> StrategyMid
+
+    %% Primitives
+
+    "prim" "(" String "," {Strategy ","}* "|" {Term ","}*")"  -> Strategy {cons("PrimT")}
+
+    %% Traversal
+
+    "some" "(" Strategy ")" 		  -> Strategy {cons("Some")}
+    "one" "(" Strategy ")" 		  -> Strategy {cons("One")}
+    "all" "(" Strategy ")" 		  -> Strategy {cons("All")}
+
+  %% Priorities
+
+  context-free priorities
+    { "!" Term 				  -> Strategy {cons("Build")}
+      "?" Term 				  -> Strategy {cons("Match")}
+    }
+  > Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
+  > {right: 
+     Strategy "<" StrategyMid 
+              "+" Strategy 		  -> Strategy {cons("GuardedLChoice"),right}
+    }
+
+  context-free syntax
+    "import-term" "(" ModName ")" -> Strategy {cons("ImportTerm")}
+
+module Stratego-Core-Modules
+imports
+  Stratego-Core-Identifiers
+  Stratego-Core-Strategies
+  Stratego-Core-Signatures
+
+exports 
+  sorts Module
+  context-free syntax
+    "module" ModName Decl* 	 -> Module {cons("Module")}
+    "specification" Decl*	 -> Module {cons("Specification")}
+
+  sorts Decl 
+  context-free syntax
+    "imports" ImportModName* 	-> Decl {cons("Imports")}
+    "strategies" Def* 		-> Decl {cons("Strategies")}
+    "signature" Sdecl*  	-> Decl {cons("Signature")}
+
+  sorts ImportModName
+  context-free syntax
+    ModName              -> ImportModName {cons("Import")}
+  syntax
+    <ModName-CF> "/" "-" -> <ImportModName-CF> {cons("ImportWildcard")}
+
+module Stratego-Sugar-Modules
+imports
+  Stratego-Core-Modules
+  Stratego-Sugar-Strategies
+  Stratego-Sugar-Signatures
+  Stratego-Sugar-Overlays
+  Stratego-Sugar-Rules
+
+exports 
+
+  sorts Decl Def
+  context-free syntax
+    "rules" Def* 		-> Decl {cons("Rules")}
+    "overlays" Overlay* 	-> Decl {cons("Overlays")}
+
+    RuleDef 			-> Def 
+
+
+module Stratego-Sugar-StringQuotations
+exports
+
+  sorts
+    StringQuotation
+    StringQuotedPart1 StringQuotedChars1 DollarOpen1 DollarClose1 QuotedBracket1 Dollar1
+    StringQuotedPart2 StringQuotedChars2 DollarOpen2 DollarClose2 QuotedBracket2 Dollar2
+    StringQuotedPart3 StringQuotedChars3 DollarOpen3 DollarClose3 QuotedBracket3 Dollar3
+    StringQuotedPart4 StringQuotedChars4 DollarOpen4 DollarClose4 QuotedBracket4  Dollar4
+    Padding
+
+  context-free syntax
+
+    StringQuotation -> PreTerm
+
+  syntax
+
+    StringQuotation -> <PreTerm-CF>
+
+    "$" "[" Padding StringQuotedPart1*               "]"    -> StringQuotation {cons("StringQuotation1") }
+     Padding "[" <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> "]"    -> StringQuotedPart1 {cons("StringEscape1")}
+    <StringQuotedChars1-LEX>                                -> StringQuotedPart1 {cons("QStr")}
+    <Dollar1-LEX>                                           -> StringQuotedPart1 {cons("QDollar")}
+    "$" <QuotedBracket1-LEX> "$"                            -> StringQuotedPart1 {cons("QBr")}
+    ~[\[\]\$]+                                              -> <StringQuotedChars1-LEX>
+    [\[\]]                                                  -> <QuotedBracket1-LEX>
+    "$"                                                     -> <Dollar1-LEX>
+
+    "$" "{" Padding StringQuotedPart2*               "}"    -> StringQuotation {cons("StringQuotation2") }
+     Padding "{" <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> "}"    -> StringQuotedPart2 {cons("StringEscape2")}
+    <StringQuotedChars2-LEX>                                -> StringQuotedPart2 {cons("QStr")}
+    <Dollar2-LEX>                                           -> StringQuotedPart2 {cons("QDollar")}
+    "$" <QuotedBracket2-LEX> "$"                            -> StringQuotedPart2 {cons("QBr")}
+    ~[\{\}\$]+                                              -> <StringQuotedChars2-LEX>
+    [\{\}]                                                  -> <QuotedBracket2-LEX>
+    "$"                                                     -> <Dollar2-LEX>
+
+    "$" "(" Padding StringQuotedPart3*              ")"     -> StringQuotation {cons("StringQuotation3") }
+    Padding "(" <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> ")"     -> StringQuotedPart3 {cons("StringEscape3")}
+    <StringQuotedChars3-LEX>                                -> StringQuotedPart3 {cons("QStr")}
+    <Dollar3-LEX>                                           -> StringQuotedPart3 {cons("QDollar")}
+    "$" <QuotedBracket3-LEX> "$"                            -> StringQuotedPart3 {cons("QBr")}
+    ~[\(\)\$]+                                              -> <StringQuotedChars3-LEX>
+    [\(\)]                                                  -> <QuotedBracket3-LEX>
+    "$"                                                     -> <Dollar3-LEX>
+
+    "$" "<" Padding StringQuotedPart4*               ">"    -> StringQuotation {cons("StringQuotation4") }
+    Padding "<"  <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> ">"    -> StringQuotedPart4 {cons("StringEscape4")}
+    <StringQuotedChars4-LEX>                                -> StringQuotedPart4 {cons("QStr")}
+    <Dollar4-LEX>                                           -> StringQuotedPart4 {cons("QDollar")}
+    "$" <QuotedBracket4-LEX> "$"                            -> StringQuotedPart4 {cons("QBr")}
+    ~[\<\>\$]+                                              -> <StringQuotedChars4-LEX>
+    [\<\>]                                                  -> <QuotedBracket4-LEX>
+    "$"                                                     -> <Dollar4-LEX>
+   
+    %% Padding is a dummy lexical that will contain the indentation prefix of every quotation
+    <Padding-LEX>                                           -> Padding
+                                                            -> <Padding-LEX> {indentpadding}
+
+  lexical restrictions
+
+    StringQuotedChars1 -/- ~[\[\]\$]   
+    StringQuotedChars2 -/- ~[\{\}\$]    
+    StringQuotedChars3 -/- ~[\(\)\$]    
+    StringQuotedChars4 -/- ~[\<\>\$]
+    Dollar1            -/- [\[\]] . [\$]
+    Dollar2            -/- [\{\}] . [\$]
+    Dollar3            -/- [\(\)] . [\$]
+    Dollar4            -/- [\<\>] . [\$]
+
+module Stratego-Core-Constants
+exports
+  sorts Int Real String StrChar
+  lexical syntax
+    [\-]? [0-9]+ 		-> Int
+    [\-]? [0-9]+ [\.] [0-9]+ 	-> Real
+    "\"" StrChar* "\"" 		-> String
+    ~[\"\\] 			-> StrChar
+    [\\] [\"tnr\\] 		-> StrChar
+
+
+module Stratego-Sugar-Constants
+imports
+  Stratego-Core-Identifiers
+  Stratego-Core-Constants
+  Stratego-Sugar-StringQuotations
+exports
+  sorts Char CharChar
+  lexical syntax
+    "'" CharChar "'"		-> Char
+    ~[\']			-> CharChar
+    [\\] [\'ntr\ ]		-> CharChar
+    Char		 	-> Id {reject}
+
+module Stratego-Core-Identifiers
+exports
+  sorts ModName ModNamePart
+  lexical syntax
+    {ModNamePart "/"}+ -> ModName
+    [a-zA-Z\.\_] [a-zA-Z0-9\'\.\-\_]* -> ModNamePart
+  lexical restrictions
+    ModName -/- [a-zA-Z0-9\'\.\-\_]
+  lexical syntax
+    "imports" 		-> ModName {reject}
+    "overlays" 		-> ModName {reject}
+    "rules" 		-> ModName {reject}
+    "signature" 	-> ModName {reject}
+    "strategies" 	-> ModName {reject}
+
+  sorts Id LId LCID UCID Wld
+  lexical syntax
+    [a-zA-Z\_] [a-zA-Z0-9\'\-\_]*     -> Id
+    [a-zA-Z\_] [a-zA-Z0-9\'\-\_]* "*" -> LId
+    [\'] [a-z]+                       -> Id
+
+    [a-z] [a-zA-Z0-9\'\-\_]*  -> LCID
+    [A-Z] [a-zA-Z0-9\'\-\_]*  -> UCID
+
+  lexical restrictions
+    Id   -/- [a-zA-Z0-9\'\-\_\*]
+    LId  -/- [a-zA-Z0-9\'\-\_]
+    LCID -/- [a-zA-Z0-9\'\-\_]
+    UCID -/- [a-zA-Z0-9\'\-\_]
+
+  lexical syntax
+    "_"     -> Id {reject}
+    "'"     -> Id {reject}
+
+    Keyword -> Id   {reject}
+    Keyword -> LId  {reject}
+    Keyword -> LCID {reject}
+    Keyword -> UCID {reject}
+
+  lexical restrictions
+    "all"
+    "case" %% not reserved kw
+    "constructors"
+    "else" %% not reserved kw
+    "end" %% not reserved kw
+    "external" %% not reserved kw
+    "fail"
+    "id"
+    "if" %% not reserved kw
+    "in"
+    "imports" %% not reserved kw
+    "let"
+    "module"
+    "not"
+    "one"
+    "overlays"
+    "otherwise" %% not reserved kw
+    "prim"
+    "rec" %% not reserved kw
+    "rules"
+    "script"
+    "signature"
+    "some"
+    "sorts"
+    "strategies"
+    "stratego"
+    "switch" %% not reserved kw
+    "test"
+    "then" %% not reserved kw
+    "where"
+    "import-term"
+      -/- [a-zA-Z0-9\'\-\_]
+  
+  context-free restrictions
+    Wld -/- [a-zA-Z0-9\'\-\_]
+
+  sorts Keyword
+  lexical syntax
+    "all"               -> Keyword
+    "constructors" 	-> Keyword
+    "fail" 		-> Keyword
+    "id" 		-> Keyword
+    "in" 		-> Keyword
+    "let" 		-> Keyword
+    "module" 		-> Keyword
+    "not" 		-> Keyword
+    "one" 		-> Keyword
+    "overlays" 		-> Keyword
+    "prim" 		-> Keyword
+    "rules" 		-> Keyword
+    "script" 		-> Keyword
+    "signature" 	-> Keyword
+    "some" 		-> Keyword
+    "sorts" 		-> Keyword
+    "strategies" 	-> Keyword
+    "stratego" 		-> Keyword
+    "test" 		-> Keyword
+    "where" 		-> Keyword
+    "import-term"	-> Keyword
+
+
+module Stratego-Core-Layout
+exports
+  sorts Ws ShortCom LongCom CommChar Asterisk Eof 
+  lexical syntax
+    [\t\ \n\r]			-> Ws
+
+    "//" ~[\n]* ([\n] | Eof)	-> ShortCom
+    "/*" CommChar* "*/"	-> LongCom
+				-> Eof  
+
+    ~[\*]     -> CommChar
+
+    "*"       -> Asterisk
+    Asterisk  -> CommChar
+
+  lexical restrictions
+    Asterisk -/- [\/]
+    Eof      -/- ~[]
+
+  lexical syntax
+    ShortCom 	-> LAYOUT
+    LongCom 	-> LAYOUT
+    Ws 		-> LAYOUT
+
+  context-free restrictions
+    LAYOUT? -/- [\ \t\n\r]
+    LAYOUT? -/- [\/].[\*]
+    LAYOUT? -/- [\/].[\/]
+
+module Stratego-Sugar-Layout
+imports Stratego-Core-Layout
+%%exports
+%%  sorts VeryLongCom Eof VLCchar Backslash
+%%  lexical syntax
+%%    "\\end{code}" VLCchar* "\\begin{code}" -> VeryLongCom
+%%    "\\begin{code}" 			   -> VeryLongCom
+%%    "\\end{code}" VLCchar* Eof 		   -> VeryLongCom
+%%    "\\literate" VLCchar* "\\begin{code}"  -> VeryLongCom
+%%    ~[\\] 				   -> VLCchar
+%%    Backslash 				   -> VLCchar
+%%    [\\] 				   -> Backslash
+
+%%  lexical restrictions
+%%    Backslash -/- [b].[e].[g].[i].[n].[\{].[c].[o].[d].[e].[\}]
+%%    Eof -/- ~[]
+
+%%  lexical syntax
+%%    VeryLongCom -> LAYOUT
+
+
+
+module Stratego-Sugar
+imports
+  Stratego-Sugar-Layout
+  Stratego-Core-Identifiers
+  Stratego-Sugar-Constants 
+  Stratego-Sugar-Modules
+  Stratego-Sugar-Signatures
+  Stratego-Sugar-Terms
+  Stratego-Sugar-Strategies
+  Stratego-Sugar-Rules
+  Stratego-Sugar-DynamicRules
+  Stratego-Sugar-Overlays
+
+hiddens
+  context-free start-symbols Module
+
+module Stratego
+imports Stratego-Sugar
+hiddens
+  context-free start-symbols Module
+
+module StrategoMix[Ctx0]
+imports Stratego
+          [ RuleNames          => RuleNames[[Ctx0]]
+            RuleDec            => RuleDec[[Ctx0]]
+            DynRuleScopeId     => DynRuleScopeId[[Ctx0]]
+            DynRuleId          => DynRuleId[[Ctx0]]
+            DynRuleDef         => DynRuleDef[[Ctx0]]
+            ScopeLabels        => ScopeLabels[[Ctx0]]
+            RuleCond           => RuleCond[[Ctx0]]
+            Rule               => Rule[[Ctx0]]
+            RuleDef            => RuleDef[[Ctx0]]
+            Overlay            => Overlay[[Ctx0]]
+            SwitchCase         => SwitchCase[[Ctx0]]
+            StrategyCurly      => StrategyCurly[[Ctx0]]
+            StrategyAngle      => StrategyAngle[[Ctx0]]
+            Kind               => Kind[[Ctx0]]
+            LID                => LID[[Ctx0]]
+            ImportModName      => ImportModName[[Ctx0]]
+            Decl               => Decl[[Ctx0]]
+            Module             => Module[[Ctx0]]
+            StrategyParen      => StrategyParen[[Ctx0]]
+            Typedid            => Typedid[[Ctx0]]
+            Anno               => Anno[[Ctx0]]
+            EmptyId            => EmptyId[[Ctx0]]
+            StrategyDef        => StrategyDef[[Ctx0]]
+            SVar               => SVar[[Ctx0]]
+            Def                => Def[[Ctx0]]
+            Type               => Type[[Ctx0]]
+            RetType            => RetType[[Ctx0]]
+            ArgType            => ArgType[[Ctx0]]
+            FunType            => FunType[[Ctx0]]
+            ConstType          => ConstType[[Ctx0]]
+            Opdecl             => Opdecl[[Ctx0]]
+            Sort               => Sort[[Ctx0]]
+            Sdecl              => Sdecl[[Ctx0]]
+            Wld                => Wld[[Ctx0]]
+            ID                 => ID[[Ctx0]]
+            Var                => Var[[Ctx0]]
+            CharChar           => CharChar[[Ctx0]]
+            Char               => Char[[Ctx0]]
+            Padding            => Padding[[Ctx0]]
+            Dollar4            => Dollar4[[Ctx0]]
+            QuotedBracket4     => QuotedBracket4[[Ctx0]]
+            StringQuotedChars4 => StringQuotedChars4[[Ctx0]]
+            StringQuotedPart4  => StringQuotedPart4[[Ctx0]]
+            Dollar3            => Dollar3[[Ctx0]]
+            QuotedBracket3     => QuotedBracket3[[Ctx0]]
+            StringQuotedChars3 => StringQuotedChars3[[Ctx0]]
+            StringQuotedPart3  => StringQuotedPart3[[Ctx0]]
+            Dollar2            => Dollar2[[Ctx0]]
+            QuotedBracket2     => QuotedBracket2[[Ctx0]]
+            StringQuotedChars2 => StringQuotedChars2[[Ctx0]]
+            StringQuotedPart2  => StringQuotedPart2[[Ctx0]]
+            Dollar1            => Dollar1[[Ctx0]]
+            QuotedBracket1     => QuotedBracket1[[Ctx0]]
+            StringQuotedChars1 => StringQuotedChars1[[Ctx0]]
+            StringQuotedPart1  => StringQuotedPart1[[Ctx0]]
+            StringQuotation    => StringQuotation[[Ctx0]]
+            StrChar            => StrChar[[Ctx0]]
+            String             => String[[Ctx0]]
+            Real               => Real[[Ctx0]]
+            Int                => Int[[Ctx0]]
+            Keyword            => Keyword[[Ctx0]]
+            UCID               => UCID[[Ctx0]]
+            LCID               => LCID[[Ctx0]]
+            LId                => LId[[Ctx0]]
+            Id                 => Id[[Ctx0]]
+            ModNamePart        => ModNamePart[[Ctx0]]
+            ModName            => ModName[[Ctx0]]
+            PreTerm            => PreTerm[[Ctx0]]
+            Term               => Term[[Ctx0]]
+            StrategyMid        => StrategyMid[[Ctx0]]
+            Strategy           => Strategy[[Ctx0]] ]
+
+
+module StrategoStratego
+imports
+  StrategoMix[StrategoHost]
+  EmbeddedStrategoMix[StrategoObject PreTerm[[StrategoHost]] Term[[StrategoHost]]]
+
+hiddens
+  context-free start-symbols Module[[StrategoHost]]
\ No newline at end of file

From L.C.L.Kats at tudelft.nl  Wed Jun  1 11:19:03 2011
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Wed, 01 Jun 2011 09:19:03 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r22973 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/tests/grammars
Message-ID: <20110601091903.63C84108C0BB@mx3.tudelft.nl>

Author: LennartKats
Date: Wed Jun  1 09:19:02 2011
New Revision: 22973
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=22973&sc=1

Log:
StrategoStratego syntax

Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests/grammars/Makefile
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests/grammars/StrategoStratego.def.in

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/tests/grammars/Makefile
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/tests/grammars/Makefile	Wed Jun  1 09:09:15 2011	(r22972)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests/grammars/Makefile	Wed Jun  1 09:19:02 2011	(r22973)
@@ -14,13 +14,10 @@
 
 %.tbl : gen-%.def
 	@echo "Building table $@"
-	echo sdf2table -i $< -o $@ -t -m basic/$(basename $<)
 	sdf2table -i $< -o $@ -t -m basic/$(echo $(basename $<) | sed "s/gen-//")
 
-%.tbl : %.def
-	@echo "Building table $@"
-	echo sdf2table -i $< -o $@ -t -m basic/$(basename $<)
-	sdf2table -i $< -o $@ -t -m basic/$(basename $<)
+StrategoStratego.tbl : StrategoStratego.def
+	sdf2table -i $< -o $@ -m StrategoStratego
 
 %.def : basic/%.sdf Makefile
 	@echo "Packing $< to $@"

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/tests/grammars/StrategoStratego.def.in
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/tests/grammars/StrategoStratego.def.in	Wed Jun  1 09:09:15 2011	(r22972)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests/grammars/StrategoStratego.def.in	Wed Jun  1 09:19:02 2011	(r22973)
@@ -487,7 +487,6 @@
     Strategy "+" Strategy 		  -> Strategy {cons("Choice"),right} 
     Strategy "+>" Strategy 		  -> Strategy {cons("RChoice"),right}
 
-    "proceed"                          -> Strategy {cons("ProceedNoArgs"), prefer}
     "proceed" "(" {Strategy "," }+ ")" -> Strategy {cons("Proceed"), prefer}
 
     "if" Strategy "then" Strategy 
@@ -957,7 +956,8 @@
     [A-Z] [a-zA-Z0-9\'\-\_]*  -> UCID
 
   lexical restrictions
-    Id   -/- [a-zA-Z0-9\'\-\_\*]
+    Id   -/- [a-zA-Z0-9\'\_\*]
+    Id   -/- [\-].~[\>]
     LId  -/- [a-zA-Z0-9\'\-\_]
     LCID -/- [a-zA-Z0-9\'\-\_]
     UCID -/- [a-zA-Z0-9\'\-\_]

From L.C.L.Kats at tudelft.nl  Wed Jun  1 11:20:01 2011
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Wed, 01 Jun 2011 09:20:01 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r22974 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/tests/grammars
Message-ID: <20110601092001.1F52C7F806E@mx1.tudelft.nl>

Author: LennartKats
Date: Wed Jun  1 09:20:00 2011
New Revision: 22974
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=22974&sc=1

Log:
accidentally removed rule from Makefile

Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests/grammars/Makefile

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/tests/grammars/Makefile
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/tests/grammars/Makefile	Wed Jun  1 09:19:02 2011	(r22973)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests/grammars/Makefile	Wed Jun  1 09:20:00 2011	(r22974)
@@ -16,6 +16,11 @@
 	@echo "Building table $@"
 	sdf2table -i $< -o $@ -t -m basic/$(echo $(basename $<) | sed "s/gen-//")
 
+%.tbl : %.def
+	@echo "Building table $@"
+	echo sdf2table -i $< -o $@ -t -m basic/$(basename $<)
+	sdf2table -i $< -o $@ -t -m basic/$(basename $<)
+
 StrategoStratego.tbl : StrategoStratego.def
 	sdf2table -i $< -o $@ -m StrategoStratego
 

From L.C.L.Kats at tudelft.nl  Wed Jun  1 11:23:13 2011
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Wed, 01 Jun 2011 09:23:13 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r22975 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/tests/data
Message-ID: <20110601092313.ACC79CC1BC@mx4.tudelft.nl>

Author: LennartKats
Date: Wed Jun  1 09:23:12 2011
New Revision: 22975
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=22975&sc=1

Log:
some more test files

Added:
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests/data/s10-increment.str.recover
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests/data/s10.str.recover
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests/data/s11-increment.str
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests/data/s11.str.recover

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests/data/s10-increment.str.recover
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests/data/s10-increment.str.recover	Wed Jun  1 09:23:12 2011	(r22975)
@@ -0,0 +1,224 @@
+module analysis
+
+imports
+  include/NamingExperiment
+  libstratego-lib
+  types
+  lib/editor-common.generated
+
+signature constructors
+
+  Scope : String * List(Namespace) * List(Summary) -> Summary
+  Def : String * Namespace * Term -> Summary
+  Def : String * Namespace -> Summary
+  Use : String * Namespace -> Summary
+  Use : Namespace -> Annotation
+    
+  Entity : Namespace
+  Module : Namespace
+  Property : Namespace
+  Function : Namespace
+  Var : Namespace
+
+rules
+  
+  scope-override:
+    PropAccess(e, p) -> p*
+    with
+      ENTITY(e-type) := <type-of> e;
+      p*             := <index-lookup-all(|Entity())> e-type 
+
+  type-of = fail
+
+rules // "hardcoded"
+    
+  analyze:
+    ast -> (ast', summary)
+    with
+      base-uri :=
+      ast'    := <analyze(|[], "<root>")>;
+      summary := <to-summary> ast';
+      <index-summary> summary
+  
+  analyze(|path, outer-scope-name):
+    ast -> (ast', summary')
+    with
+      if summary-part := <get-definition> ast then
+        Def(outer-scope-name', _) := summary-part
+      else
+        outer-scope-name' := outer-scope-name
+      end;
+      if scope-types := <get-scope-types> ast then
+        (ast', summary) := <analyze-recurse-scoped(|path, outer-scope-name', scope-types)> ast
+      else
+        (ast', summary) := <analyze-recurse(|path, outer-scope-name')> ast
+      end;
+      if !summary-part then
+        summary-part-annotated := <get-definition> ast';
+        if type := <local-type-of> ast' then
+          Def(x, ns)              := summary-part-annotated;
+          summary-part-annotated' := Def(x, ns, type)
+        else
+          summary-part-annotated' := summary-part-annotated
+        end;
+        summary' := [summary-part-annotated' | summary]
+      else
+        summary' := summary
+      end
+  
+  analyze-recurse-scoped(|path, outer-scope-name, scope-types):
+    ast -> (ast', [Scope(outer-scope-name, scope-types, summary)])
+    with
+      path'               := [outer-scope-name | path];
+      (ast', summary) := <analyze-recurse(|path', "<anon>")> ast
+  
+  analyze-recurse(|path, outer-scope-name):
+    ast -> (ast'', summary)
+    where
+      analyzed      := <all(analyze(|path, outer-scope-name))> ast;
+      ast'          := <all(\(a, _) -> a\)> analyzed;
+      summary-parts := <get-appl-arguments(\(_, n) -> n\) <+ map(\(_, n) -> n\) <+ ![]> analyzed;
+      ast''         := <try(annotate-names(|path))> ast';
+      summary       := <concat> summary-parts
+
+  make-def(|name, scope) =
+    !Def(name, scope, <local-type-of>) <+ !Def(name, scope)
+
+rules // "hardcoded"
+    
+  index-summary =
+    index-summary(|[])
+
+  index-summary(|path) =
+    ?Def(x, ns); rules(GetName :+ (ns, path) -> x)
+  <+
+    ?Def(x, ns, t); rules(GetName :+ (ns, path) -> x  GetType: (ns, path, x) -> t)
+  <+
+    // TODO: don't ignore ns
+    ?Scope(x, ns, def*); <list-loop(index-summary(|[x | path]))> def*
+  <+
+    list-loop(index-summary(|path))
+
+  index-lookup =
+    ?var{a*};
+    index-lookup;
+    getfirst(SRTS-EXT-eq-ignore-annos(|var))
+
+  index-lookup-all =
+    if ?var{^[Use(namespace) | path]} then
+      index-lookup-all(|namespace, path)
+    else
+      ?var{^path}
+    end
+
+  index-lookup-all(|namespace) =
+    if ?var{^[Use(ns) | path]} then
+      index-lookup-all(|namespace, path)
+    else
+      ?var{^path};
+      index-lookup-all(|namespace, path)
+    end
+  
+  index-lookup-all(|namespace, path) =
+    do-manual-lookup-all(|namespace, path)
+  <+
+    <bagof-GetName> (namespace, path)
+  
+  do-manual-lookup-all(|namespace, path) =
+    try(origin-term)
+  
+  external SRTS-EXT-eq-ignore-annos(|t)
+
+rules // "generated"
+    
+  get-definition:
+    Module(x, _) -> Def(x, Module())
+  
+  get-definition:
+    Entity(x, _) -> Def(x, Entity())
+  
+  get-definition:
+    Property(x, _) -> Def(x, Property())
+  
+  get-definition:
+    Function(x, _, _) -> Def(x, Function())
+  
+  get-definition:
+    VarDecl(x, _) -> Def(x, Var())
+  
+  get-definition:
+    VarDeclInit(x, _, _) -> Def(x, Var())
+  
+  get-definition:
+    Param(x, _) -> Def(x, Var())
+
+rules // "generated"
+      
+  get-scope-types:
+    Module(_, _) -> [Entity(), Module()]
+  
+  get-scope-types:
+    Entity(_, _) -> [Property()]
+  
+  get-scope-types:
+    Function(_, _, _) -> [Var()]
+  
+  get-scope-types:
+    Block(_) -> [Var()]
+
+rules // "generated"
+    
+  annotate-names(|path):
+    Module(t1, t2) -> Module(t1{^path}, t2)
+    
+  annotate-names(|path):
+    Entity(t1, t2) -> Entity(t1{^path}, t2)
+    
+  annotate-names(|path):
+    Property(t1, t2) -> Property(t1{^path}, t2{^[Use(Entity()) | path]})
+    
+  annotate-names(|path):
+    Function(t1, t2, t3) -> Function(t1{^path}, t2, t3)
+    
+  annotate-names(|path):
+    Param(t1, t2) -> Param(t1{^path}, t2{^[Use(Entity()) | path]})
+    
+  annotate-names(|path):
+    VarDecl(t1, t2) -> VarDecl(t1{^path}, t2{^[Use(Entity()) | path]})
+    
+  annotate-names(|path):
+    VarDeclInit(t1, t2, t3) -> VarDeclInit(t1{^path}, t2{^[Use(Entity()) | path]}, t3)
+    
+  annotate-names(|path):
+    Assign(t1, t2) -> Assign(t1{^[Use(Var()) | path]}, t2)
+    
+  annotate-names(|path):
+    Var(t1) -> Var(t1{^[Use(Var()) | path]})
+    
+  annotate-names(|path):
+    PropAccess(t1, t2) -> PropAccess(t1, t2{^[Use(Entity()) | path]})
+
+  /*
+  get-uses:
+    Import(x) -> [(Module(), x)]
+  
+  get-uses:
+    Property(_, x) -> [(Entity(), x)]
+  
+  get-uses:
+    Param(_, x) -> [(Entity(), x)]
+  
+  get-uses:
+    VarDecl(_, x) -> [(Var(), x)]
+  
+  get-uses:
+    VarDeclInit(_, x, _) -> [(Var(), x)]
+  
+  get-uses:
+    Assign(x, _) -> [(Var(), x)]
+  
+  get-uses:
+    Var(x) -> [(Var(), x)]
+  
+  get-uses:
+    PropAccess(_, x) -> [(Var(), x)]

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests/data/s10.str.recover
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests/data/s10.str.recover	Wed Jun  1 09:23:12 2011	(r22975)
@@ -0,0 +1,225 @@
+module analysis
+
+imports
+  include/NamingExperiment
+  libstratego-lib
+  types
+  lib/editor-common.generated
+
+signature constructors
+
+  Scope : String * List(Namespace) * List(Summary) -> Summary
+  Def : String * Namespace * Term -> Summary
+  Def : String * Namespace -> Summary
+  Use : String * Namespace -> Summary
+  Use : Namespace -> Annotation
+    
+  Entity : Namespace
+  Module : Namespace
+  Property : Namespace
+  Function : Namespace
+  Var : Namespace
+
+rules
+  
+  scope-override:
+    PropAccess(e, p) -> p*
+    with
+      ENTITY(e-type) := <type-of> e;
+      p*             := <index-lookup-all(|Entity())> e-type 
+
+  type-of = fail
+
+rules // "hardcoded"
+    
+  analyze:
+    ast -> (ast', summary)
+    with
+      base-uri :=
+      ast'    := <analyze(|[], "<root>")>;
+      summary := <to-summary> ast';
+      <index-summary> summary
+  
+  analyze(|path, outer-scope-name):
+    ast -> (ast', summary')
+    with
+      if summary-part := <get-definition> ast then
+        Def(outer-scope-name', _) := summary-part
+      else
+        outer-scope-name' := outer-scope-name
+      end;
+      if scope-types := <get-scope-types> ast then
+        (ast', summary) := <analyze-recurse-scoped(|path, outer-scope-name', scope-types)> ast
+      else
+        (ast', summary) := <analyze-recurse(|path, outer-scope-name')> ast
+      end;
+      if !summary-part then
+        summary-part-annotated := <get-definition> ast';
+        if type := <local-type-of> ast' then
+          Def(x, ns)              := summary-part-annotated;
+          summary-part-annotated' := Def(x, ns, type)
+        else
+          summary-part-annotated' := summary-part-annotated
+        end;
+        summary' := [summary-part-annotated' | summary]
+      else
+        summary' := summary
+      end
+  
+  analyze-recurse-scoped(|path, outer-scope-name, scope-types):
+    ast -> (ast', [Scope(outer-scope-name, scope-types, summary)])
+    with
+      path'               := [outer-scope-name | path];
+      (ast', summary) := <analyze-recurse(|path', "<anon>")> ast
+  
+  analyze-recurse(|path, outer-scope-name):
+    ast -> (ast'', summary)
+    where
+      analyzed      := <all(analyze(|path, outer-scope-name))> ast;
+      ast'          := <all(\(a, _) -> a\)> analyzed;
+      summary-parts := <get-appl-arguments(\(_, n) -> n\) <+ map(\(_, n) -> n\) <+ ![]> analyzed;
+      ast''         := <try(annotate-names(|path))> ast';
+      summary       := <concat> summary-parts
+
+  make-def(|name, scope) =
+    !Def(name, scope, <local-type-of>) <+ !Def(name, scope)
+
+rules // "hardcoded"
+    
+  index-summary =
+    index-summary(|[])
+
+  index-summary(|path) =
+    ?Def(x, ns); rules(GetName :+ (ns, path) -> x)
+  <+
+    ?Def(x, ns, t); rules(GetName :+ (ns, path) -> x  GetType: (ns, path, x) -> t)
+  <+
+    // TODO: don't ignore ns
+    ?Scope(x, ns, def*); <list-loop(index-summary(|[x | path]))> def*
+  <+
+    list-loop(index-summary(|path))
+
+  index-lookup =
+    ?var{a*};
+    index-lookup;
+    getfirst(SRTS-EXT-eq-ignore-annos(|var))
+
+  index-lookup-all =
+    if ?var{^[Use(namespace) | path]} then
+      index-lookup-all(|namespace, path)
+    else
+      ?var{^path}
+    end
+
+  index-lookup-all(|namespace) =
+    if ?var{^[Use(ns) | path]} then
+      index-lookup-all(|namespace, path)
+    else
+      ?var{^path};
+      index-lookup-all(|namespace, path)
+    end
+  
+  index-lookup-all(|namespace, path) =
+    do-manual-lookup-all(|namespace, path)
+  <+
+    <bagof-GetName> (namespace, path)
+  
+  do-manual-lookup-all(|namespace, path) =
+    try(origin-term)
+  
+  external SRTS-EXT-eq-ignore-annos(|t)
+
+rules // "generated"
+    
+  get-definition:
+    Module(x, _) -> Def(x, Module())
+  
+  get-definition:
+    Entity(x, _) -> Def(x, Entity())
+  
+  get-definition:
+    Property(x, _) -> Def(x, Property())
+  
+  get-definition:
+    Function(x, _, _) -> Def(x, Function())
+  
+  get-definition:
+    VarDecl(x, _) -> Def(x, Var())
+  
+  get-definition:
+    VarDeclInit(x, _, _) -> Def(x, Var())
+  
+  get-definition:
+    Param(x, _) -> Def(x, Var())
+
+rules // "generated"
+      
+  get-scope-types:
+    Module(_, _) -> [Entity(), Module()]
+  
+  get-scope-types:
+    Entity(_, _) -> [Property()]
+  
+  get-scope-types:
+    Function(_, _, _) -> [Var()]
+  
+  get-scope-types:
+    Block(_) -> [Var()]
+
+rules // "generated"
+    
+  annotate-names(|path):
+    Module(t1, t2) -> Module(t1{^path}, t2)
+    
+  annotate-names(|path):
+    Entity(t1, t2) -> Entity(t1{^path}, t2)
+    
+  annotate-names(|path):
+    Property(t1, t2) -> Property(t1{^path}, t2{^[Use(Entity()) | path]})
+    
+  annotate-names(|path):
+    Function(t1, t2, t3) -> Function(t1{^path}, t2, t3)
+    
+  annotate-names(|path):
+    Param(t1, t2) -> Param(t1{^path}, t2{^[Use(Entity()) | path]})
+    
+  annotate-names(|path):
+    VarDecl(t1, t2) -> VarDecl(t1{^path}, t2{^[Use(Entity()) | path]})
+    
+  annotate-names(|path):
+    VarDeclInit(t1, t2, t3) -> VarDeclInit(t1{^path}, t2{^[Use(Entity()) | path]}, t3)
+    
+  annotate-names(|path):
+    Assign(t1, t2) -> Assign(t1{^[Use(Var()) | path]}, t2)
+    
+  annotate-names(|path):
+    Var(t1) -> Var(t1{^[Use(Var()) | path]})
+    
+  annotate-names(|path):
+    PropAccess(t1, t2) -> PropAccess(t1, t2{^[Use(Entity()) | path]})
+
+  /*
+  get-uses:
+    Import(x) -> [(Module(), x)]
+  
+  get-uses:
+    Property(_, x) -> [(Entity(), x)]
+  
+  get-uses:
+    Param(_, x) -> [(Entity(), x)]
+  
+  get-uses:
+    VarDecl(_, x) -> [(Var(), x)]
+  
+  get-uses:
+    VarDeclInit(_, x, _) -> [(Var(), x)]
+  
+  get-uses:
+    Assign(x, _) -> [(Var(), x)]
+  
+  get-uses:
+    Var(x) -> [(Var(), x)]
+  
+  get-uses:
+    PropAccess(_, x) -> [(Var(), x)]
+  */

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests/data/s11-increment.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests/data/s11-increment.str	Wed Jun  1 09:23:12 2011	(r22975)
@@ -0,0 +1,217 @@
+module analysis
+
+imports
+  include/NamingExperiment
+  libstratego-lib
+  types
+  lib/editor-common.generated
+
+signature constructors
+
+  Scope : String * List(Namespace) * List(Summary) -> Summary
+  Def : String * Namespace * Term -> Summary
+  Def : String * Namespace -> Summary
+  Use : String * Namespace -> Summary
+  Use : Namespace -> Annotation
+    
+  Entity : Namespace
+  Module : Namespace
+  Property : Namespace
+  Function : Namespace
+  Var : Namespace
+
+rules
+  
+  scope-override:
+    PropAccess(e, p) -> p*
+    with
+      ENTITY(e-type) := <type-of> e;
+      p*             := <index-lookup-all(|Entity())> e-type 
+
+  type-of = fail
+
+rules // "hardcoded"
+    
+  analyze:
+    ast -> (ast', summary)
+    with
+      base-uri := []; // TODO: customize base uri based on path or contents?
+      ast'     := <analyze(|base-uri, "<root>")>;
+      summary  := <to-summary> ast';
+      <index-summary> summary
+  
+  analyze(|base-uri, last-scope-name):
+    ast -> (ast', summary')
+    with
+      if summary-part := <get-definition> ast then
+        Def(last-scope-name', _) := summary-part
+      else
+        last-scope-name' := last-scope-name
+      end;
+      if scope-types := <get-scope-types> ast then
+        {| CurrentPath:
+          <list-loop(update-current-path(|base-uri, last-scope-name'))> scope-types;
+          ast' := <analyze-recurse(|base-uri, "<anon>")> ast
+        |}
+      else
+        ast' := <analyze-recurse(|base-uri, last-scope-name')> ast
+      end;
+      summary' //<![summary-part | summary] <+ !summary>
+  
+  update-current-path(|base-uri, name):
+    scope-type -> scope-type
+    where
+      path := [name | <CurrentPath <+ !base-uri>];
+      rules(CurrentPath: scope-type -> path)
+  
+  analyze-recurse(|path, last-scope-name):
+    ast -> (ast'', summary)
+    where
+      analyzed      := <all(analyze(|path, last-scope-name))> ast;
+      ast'          := <all(\(a, _) -> a\)> analyzed;
+      summary-parts := <get-appl-arguments(\(_, n) -> n\) <+ map(\(_, n) -> n\) <+ ![]> analyzed;
+      ast''         := <try(annotate-names(|path))> ast';
+      summary       := <concat> summary-parts
+
+  make-def(|name, scope) =
+    !Def(name, scope, <local-type-of>) <+ !Def(name, scope)
+
+rules // "hardcoded"
+    
+  index-summary =
+    index-summary(|[])
+
+  index-summary(|path) =
+    ?Def(x, ns); rules(GetName :+ (ns, path) -> x)
+  <+
+    ?Def(x, ns, t); rules(GetName :+ (ns, path) -> x  GetType: (ns, path, x) -> t)
+  <+
+    // TODO: don't ignore ns
+    ?Scope(x, ns, def*); <list-loop(index-summary(|[x | path]))> def*
+  <+
+    list-loop(index-summary(|path))
+
+  index-lookup =
+    ?var{a*};
+    index-lookup;
+    getfirst(SRTS-EXT-eq-ignore-annos(|var))
+
+  index-lookup-all =
+    if ?var{^[Use(namespace) | path]} then
+      index-lookup-all(|namespace, path)
+    else
+      ?var{^path}
+    end
+
+  index-lookup-all(|namespace) =
+    if ?var{^[Use(ns) | path]} then
+      index-lookup-all(|namespace, path)
+    else
+      ?var{^path};
+      index-lookup-all(|namespace, path)
+    end
+  
+  index-lookup-all(|namespace, path) =
+    do-manual-lookup-all(|namespace, path)
+  <+
+    <bagof-GetName> (namespace, path)
+  
+  do-manual-lookup-all(|namespace, path) =
+    try(origin-term)
+  
+  external SRTS-EXT-eq-ignore-annos(|t)
+
+rules // "generated"
+    
+  get-definition:
+    Module(x, _) -> Def(x, Module())
+  
+  get-definition:
+    Entity(x, _) -> Def(x, Entity())
+  
+  get-definition:
+    Property(x, _) -> Def(x, Property())
+  
+  get-definition:
+    Function(x, _, _) -> Def(x, Function())
+  
+  get-definition:
+    VarDecl(x, _) -> Def(x, Var())
+  
+  get-definition:
+    VarDeclInit(x, _, _) -> Def(x, Var())
+  
+  get-definition:
+    Param(x, _) -> Def(x, Var())
+
+rules // "generated"
+      
+  get-scope-types:
+    Module(_, _) -> [Entity(), Module()]
+  
+  get-scope-types:
+    Entity(_, _) -> [Property()]
+  
+  get-scope-types:
+    Function(_, _, _) -> [Var()]
+  
+  get-scope-types:
+    Block(_) -> [Var()]
+
+rules // "generated"
+    
+  annotate-names(|path):
+    Module(t1, t2) -> Module(t1{^path}, t2)
+    
+  annotate-names(|path):
+    Entity(t1, t2) -> Entity(t1{^path}, t2)
+    
+  annotate-names(|path):
+    Property(t1, t2) -> Property(t1{^path}, t2{^[Use(Entity()) | path]})
+    
+  annotate-names(|path):
+    Function(t1, t2, t3) -> Function(t1{^path}, t2, t3)
+    
+  annotate-names(|path):
+    Param(t1, t2) -> Param(t1{^path}, t2{^[Use(Entity()) | path]})
+    
+  annotate-names(|path):
+    VarDecl(t1, t2) -> VarDecl(t1{^path}, t2{^[Use(Entity()) | path]})
+    
+  annotate-names(|path):
+    VarDeclInit(t1, t2, t3) -> VarDeclInit(t1{^path}, t2{^[Use(Entity()) | path]}, t3)
+    
+  annotate-names(|path):
+    Assign(t1, t2) -> Assign(t1{^[Use(Var()) | path]}, t2)
+    
+  annotate-names(|path):
+    Var(t1) -> Var(t1{^[Use(Var()) | path]})
+    
+  annotate-names(|path):
+    PropAccess(t1, t2) -> PropAccess(t1, t2{^[Use(Entity()) | path]})
+
+  /*
+  get-uses:
+    Import(x) -> [(Module(), x)]
+  
+  get-uses:
+    Property(_, x) -> [(Entity(), x)]
+  
+  get-uses:
+    Param(_, x) -> [(Entity(), x)]
+  
+  get-uses:
+    VarDecl(_, x) -> [(Var(), x)]
+  
+  get-uses:
+    VarDeclInit(_, x, _) -> [(Var(), x)]
+  
+  get-uses:
+    Assign(x, _) -> [(Var(), x)]
+  
+  get-uses:
+    Var(x) -> [(Var(), x)]
+  
+  get-uses:
+    PropAccess(_, x) -> [(Var(), x)]
+  */

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests/data/s11.str.recover
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests/data/s11.str.recover	Wed Jun  1 09:23:12 2011	(r22975)
@@ -0,0 +1,217 @@
+module analysis
+
+imports
+  include/NamingExperiment
+  libstratego-lib
+  types
+  lib/editor-common.generated
+
+signature constructors
+
+  Scope : String * List(Namespace) * List(Summary) -> Summary
+  Def : String * Namespace * Term -> Summary
+  Def : String * Namespace -> Summary
+  Use : String * Namespace -> Summary
+  Use : Namespace -> Annotation
+    
+  Entity : Namespace
+  Module : Namespace
+  Property : Namespace
+  Function : Namespace
+  Var : Namespace
+
+rules
+  
+  scope-override:
+    PropAccess(e, p) -> p*
+    with
+      ENTITY(e-type) := <type-of> e;
+      p*             := <index-lookup-all(|Entity())> e-type 
+
+  type-of = fail
+
+rules // "hardcoded"
+    
+  analyze:
+    ast -> (ast', summary)
+    with
+      base-uri := []; // TODO: customize base uri based on path or contents?
+      ast'     := <analyze(|base-uri, "<root>")>;
+      summary  := <to-summary> ast';
+      <index-summary> summary
+  
+  analyze(|base-uri, last-scope-name):
+    ast -> (ast', summary')
+    with
+      if summary-part := <get-definition> ast then
+        Def(last-scope-name', _) := summary-part
+      else
+        last-scope-name' := last-scope-name
+      end;
+      if scope-types := <get-scope-types> ast then
+        {| CurrentPath:
+          <list-loop(update-current-path(|base-uri, last-scope-name'))> scope-types;
+          ast' := <analyze-recurse(|base-uri, "<anon>")> ast
+        |}
+      else
+        ast' := <analyze-recurse(|base-uri, last-scope-name')> ast
+      end;
+      summary' ://<![summary-part | summary] <+ !summary>
+  
+  update-current-path(|base-uri, name):
+    scope-type -> scope-type
+    where
+      path := [name | <CurrentPath <+ !base-uri>];
+      rules(CurrentPath: scope-type -> path)
+  
+  analyze-recurse(|path, last-scope-name):
+    ast -> (ast'', summary)
+    where
+      analyzed      := <all(analyze(|path, last-scope-name))> ast;
+      ast'          := <all(\(a, _) -> a\)> analyzed;
+      summary-parts := <get-appl-arguments(\(_, n) -> n\) <+ map(\(_, n) -> n\) <+ ![]> analyzed;
+      ast''         := <try(annotate-names(|path))> ast';
+      summary       := <concat> summary-parts
+
+  make-def(|name, scope) =
+    !Def(name, scope, <local-type-of>) <+ !Def(name, scope)
+
+rules // "hardcoded"
+    
+  index-summary =
+    index-summary(|[])
+
+  index-summary(|path) =
+    ?Def(x, ns); rules(GetName :+ (ns, path) -> x)
+  <+
+    ?Def(x, ns, t); rules(GetName :+ (ns, path) -> x  GetType: (ns, path, x) -> t)
+  <+
+    // TODO: don't ignore ns
+    ?Scope(x, ns, def*); <list-loop(index-summary(|[x | path]))> def*
+  <+
+    list-loop(index-summary(|path))
+
+  index-lookup =
+    ?var{a*};
+    index-lookup;
+    getfirst(SRTS-EXT-eq-ignore-annos(|var))
+
+  index-lookup-all =
+    if ?var{^[Use(namespace) | path]} then
+      index-lookup-all(|namespace, path)
+    else
+      ?var{^path}
+    end
+
+  index-lookup-all(|namespace) =
+    if ?var{^[Use(ns) | path]} then
+      index-lookup-all(|namespace, path)
+    else
+      ?var{^path};
+      index-lookup-all(|namespace, path)
+    end
+  
+  index-lookup-all(|namespace, path) =
+    do-manual-lookup-all(|namespace, path)
+  <+
+    <bagof-GetName> (namespace, path)
+  
+  do-manual-lookup-all(|namespace, path) =
+    try(origin-term)
+  
+  external SRTS-EXT-eq-ignore-annos(|t)
+
+rules // "generated"
+    
+  get-definition:
+    Module(x, _) -> Def(x, Module())
+  
+  get-definition:
+    Entity(x, _) -> Def(x, Entity())
+  
+  get-definition:
+    Property(x, _) -> Def(x, Property())
+  
+  get-definition:
+    Function(x, _, _) -> Def(x, Function())
+  
+  get-definition:
+    VarDecl(x, _) -> Def(x, Var())
+  
+  get-definition:
+    VarDeclInit(x, _, _) -> Def(x, Var())
+  
+  get-definition:
+    Param(x, _) -> Def(x, Var())
+
+rules // "generated"
+      
+  get-scope-types:
+    Module(_, _) -> [Entity(), Module()]
+  
+  get-scope-types:
+    Entity(_, _) -> [Property()]
+  
+  get-scope-types:
+    Function(_, _, _) -> [Var()]
+  
+  get-scope-types:
+    Block(_) -> [Var()]
+
+rules // "generated"
+    
+  annotate-names(|path):
+    Module(t1, t2) -> Module(t1{^path}, t2)
+    
+  annotate-names(|path):
+    Entity(t1, t2) -> Entity(t1{^path}, t2)
+    
+  annotate-names(|path):
+    Property(t1, t2) -> Property(t1{^path}, t2{^[Use(Entity()) | path]})
+    
+  annotate-names(|path):
+    Function(t1, t2, t3) -> Function(t1{^path}, t2, t3)
+    
+  annotate-names(|path):
+    Param(t1, t2) -> Param(t1{^path}, t2{^[Use(Entity()) | path]})
+    
+  annotate-names(|path):
+    VarDecl(t1, t2) -> VarDecl(t1{^path}, t2{^[Use(Entity()) | path]})
+    
+  annotate-names(|path):
+    VarDeclInit(t1, t2, t3) -> VarDeclInit(t1{^path}, t2{^[Use(Entity()) | path]}, t3)
+    
+  annotate-names(|path):
+    Assign(t1, t2) -> Assign(t1{^[Use(Var()) | path]}, t2)
+    
+  annotate-names(|path):
+    Var(t1) -> Var(t1{^[Use(Var()) | path]})
+    
+  annotate-names(|path):
+    PropAccess(t1, t2) -> PropAccess(t1, t2{^[Use(Entity()) | path]})
+
+  /*
+  get-uses:
+    Import(x) -> [(Module(), x)]
+  
+  get-uses:
+    Property(_, x) -> [(Entity(), x)]
+  
+  get-uses:
+    Param(_, x) -> [(Entity(), x)]
+  
+  get-uses:
+    VarDecl(_, x) -> [(Var(), x)]
+  
+  get-uses:
+    VarDeclInit(_, x, _) -> [(Var(), x)]
+  
+  get-uses:
+    Assign(x, _) -> [(Var(), x)]
+  
+  get-uses:
+    Var(x) -> [(Var(), x)]
+  
+  get-uses:
+    PropAccess(_, x) -> [(Var(), x)]
+  */

From L.C.L.Kats at tudelft.nl  Wed Jun  1 11:24:16 2011
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Wed, 01 Jun 2011 09:24:16 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r22976 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/tests/grammars
Message-ID: <20110601092416.DD568CC14B@mx4.tudelft.nl>

Author: LennartKats
Date: Wed Jun  1 09:24:15 2011
New Revision: 22976
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=22976&sc=1

Log:
correctly make SpoofaxConfiguration.tbl

Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests/grammars/Makefile

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/tests/grammars/Makefile
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/tests/grammars/Makefile	Wed Jun  1 09:23:12 2011	(r22975)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests/grammars/Makefile	Wed Jun  1 09:24:15 2011	(r22976)
@@ -24,6 +24,9 @@
 StrategoStratego.tbl : StrategoStratego.def
 	sdf2table -i $< -o $@ -m StrategoStratego
 
+SpoofaxConfiguration.tbl : SpoofaxConfiguration.def
+	sdf2table -i $< -o $@ -m SpoofaxConfiguration
+
 %.def : basic/%.sdf Makefile
 	@echo "Packing $< to $@"
 	pack-sdf -I . -i $< -o $@

From R.B.Vermaas at tudelft.nl  Wed Jun  1 11:45:15 2011
From: R.B.Vermaas at tudelft.nl (Rob Vermaas)
Date: Wed, 01 Jun 2011 09:45:15 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r22977 - hydra/jobs
Message-ID: <20110601094515.131B12B8090@mx2.tudelft.nl>

Author: rob
Date: Wed Jun  1 09:45:14 2011
New Revision: 22977
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=22977&sc=1

Log:
call tests

Modified:
   hydra/jobs/spoofax-imp.nix

Modified: hydra/jobs/spoofax-imp.nix
==============================================================================
--- hydra/jobs/spoofax-imp.nix	Wed Jun  1 09:24:15 2011	(r22976)
+++ hydra/jobs/spoofax-imp.nix	Wed Jun  1 09:45:14 2011	(r22977)
@@ -264,6 +264,7 @@
         done
 
         mvn package ${mvnFlags} -e
+        mvn integration-test ${mvnFlags} -e
       '';
           
       installPhase = ''

From seba at informatik.uni-marburg.de  Wed Jun  1 11:52:41 2011
From: seba at informatik.uni-marburg.de (Sebastian Erdweg)
Date: Wed, 01 Jun 2011 09:52:41 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r22978 -
	sugarj/trunk/stdlib/org/sugarj/init
Message-ID: <20110601095241.B9E51108C0A0@mx3.tudelft.nl>

Author: SebastianErdweg
Date: Wed Jun  1 09:52:36 2011
New Revision: 22978
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=22978&sc=1

Log:
renamed file

Added:
   sugarj/trunk/stdlib/org/sugarj/init/InitTrans.str
      - copied unchanged from r22956, sugarj/trunk/stdlib/org/sugarj/init/initTrans.str
Deleted:
   sugarj/trunk/stdlib/org/sugarj/init/initTrans.str

Copied: sugarj/trunk/stdlib/org/sugarj/init/InitTrans.str (from r22956, sugarj/trunk/stdlib/org/sugarj/init/initTrans.str)
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sugarj/trunk/stdlib/org/sugarj/init/InitTrans.str	Wed Jun  1 09:52:36 2011	(r22978, copy of r22956, sugarj/trunk/stdlib/org/sugarj/init/initTrans.str)
@@ -0,0 +1,58 @@
+module org/sugarj/init/initTrans
+imports libstrategolib
+        org/sugarj/languages/SugarJ
+
+imports org/sugarj/transformations/GenerateSignatures
+        org/sugarj/transformations/EditorServiceExtension
+
+signature constructors
+  NextToplevelDeclaration : ToplevelDeclaration * Rest -> NextToplevelDeclaration
+
+strategies
+  compile-error = ?CompileError(_,_)
+  compile-error(|msg) = !CompileError(msg,<id>)
+  
+  desugar = fail
+  changed-tree(s) = ?t; s; not(equal(|t))
+  
+  unlocked-bottomup(s) = ?Locked(t) < id + all(unlocked-bottomup(s)); s
+  traverse(s) = compile-error <+ unlocked-bottomup(try(s; traverse(s)))
+  unlock = bottomup(try(?Locked(<id>)))
+  
+  internal-main = traverse(desugar); unlock
+  main = io-wrap(internal-main)
+
+  sugarj-analyze:
+    (ast, path, project-path) -> (ast, errors, warnings, notes)
+    with
+      editor-init;
+      try(analyze);
+      errors   := <collect-all(constraint-error, conc)> ast;
+      warnings := <collect-all(constraint-warning, conc)> ast;
+      notes    := <collect-all(constraint-note, conc)> ast
+
+    editor-init =
+      // Ensure all dynamic rules are properly scoped
+      try(dr-scope-all-end);
+      dr-scope-all-start
+
+    analyze = fail
+    constraint-error = fail
+    constraint-warning = fail
+    constraint-note = fail
+
+signature
+  constructors
+    Locked : a -> a
+
+signature
+  constructors
+    Some : a -> Option(a)
+    None : Option(a)
+
+
+signature
+  constructors
+    Cons : a * List(a) -> List(a)
+    Nil  : List(a)
+    Conc : List(a) * List(a) -> List(a)
\ No newline at end of file

From seba at informatik.uni-marburg.de  Wed Jun  1 12:04:07 2011
From: seba at informatik.uni-marburg.de (Sebastian Erdweg)
Date: Wed, 01 Jun 2011 10:04:07 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r22979 -
	sugarj/trunk/stdlib/org/sugarj/init
Message-ID: <20110601100407.9ACF82B8097@mx2.tudelft.nl>

Author: SebastianErdweg
Date: Wed Jun  1 10:04:06 2011
New Revision: 22979
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=22979&sc=1

Log:
temporary delete

Deleted:
   sugarj/trunk/stdlib/org/sugarj/init/InitTrans.str

From seba at informatik.uni-marburg.de  Wed Jun  1 12:04:43 2011
From: seba at informatik.uni-marburg.de (Sebastian Erdweg)
Date: Wed, 01 Jun 2011 10:04:43 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r22980 - in
	sugarj/trunk/stdlib/org/sugarj: init stdlib
Message-ID: <20110601100443.87057108C045@mx3.tudelft.nl>

Author: SebastianErdweg
Date: Wed Jun  1 10:04:42 2011
New Revision: 22980
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=22980&sc=1

Log:
finished renaming

Added:
   sugarj/trunk/stdlib/org/sugarj/init/InitTrans.str
Modified:
   sugarj/trunk/stdlib/org/sugarj/stdlib/StdLib.java

Added: sugarj/trunk/stdlib/org/sugarj/init/InitTrans.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sugarj/trunk/stdlib/org/sugarj/init/InitTrans.str	Wed Jun  1 10:04:42 2011	(r22980)
@@ -0,0 +1,58 @@
+module org/sugarj/init/InitTrans
+imports libstrategolib
+        org/sugarj/languages/SugarJ
+
+imports org/sugarj/transformations/GenerateSignatures
+        org/sugarj/transformations/EditorServiceExtension
+
+signature constructors
+  NextToplevelDeclaration : ToplevelDeclaration * Rest -> NextToplevelDeclaration
+
+strategies
+  compile-error = ?CompileError(_,_)
+  compile-error(|msg) = !CompileError(msg,<id>)
+  
+  desugar = fail
+  changed-tree(s) = ?t; s; not(equal(|t))
+  
+  unlocked-bottomup(s) = ?Locked(t) < id + all(unlocked-bottomup(s)); s
+  traverse(s) = compile-error <+ unlocked-bottomup(try(s; traverse(s)))
+  unlock = bottomup(try(?Locked(<id>)))
+  
+  internal-main = traverse(desugar); unlock
+  main = io-wrap(internal-main)
+
+  sugarj-analyze:
+    (ast, path, project-path) -> (ast, errors, warnings, notes)
+    with
+      editor-init;
+      try(analyze);
+      errors   := <collect-all(constraint-error, conc)> ast;
+      warnings := <collect-all(constraint-warning, conc)> ast;
+      notes    := <collect-all(constraint-note, conc)> ast
+
+    editor-init =
+      // Ensure all dynamic rules are properly scoped
+      try(dr-scope-all-end);
+      dr-scope-all-start
+
+    analyze = fail
+    constraint-error = fail
+    constraint-warning = fail
+    constraint-note = fail
+
+signature
+  constructors
+    Locked : a -> a
+
+signature
+  constructors
+    Some : a -> Option(a)
+    None : Option(a)
+
+
+signature
+  constructors
+    Cons : a * List(a) -> List(a)
+    Nil  : List(a)
+    Conc : List(a) * List(a) -> List(a)
\ No newline at end of file

Modified: sugarj/trunk/stdlib/org/sugarj/stdlib/StdLib.java
==============================================================================
--- sugarj/trunk/stdlib/org/sugarj/stdlib/StdLib.java	Wed Jun  1 10:04:06 2011	(r22979)
+++ sugarj/trunk/stdlib/org/sugarj/stdlib/StdLib.java	Wed Jun  1 10:04:42 2011	(r22980)
@@ -68,8 +68,8 @@
   public static URI initGrammarAtomicImports = ensureFile("org/sugarj/init/initGrammar_atomicImports.sdf");
   public static String initGrammarAtomicImportsModule = "org/sugarj/init/initGrammar_atomicImports";
   public static URI initGrammarXTBL = ensureFile("org/sugarj/init/initGrammar.xtbl");
-  public static URI initTrans = ensureFile("org/sugarj/init/initTrans.str");
-  public static String initTransModule = "org/sugarj/init/initTrans";
+  public static URI initTrans = ensureFile("org/sugarj/init/InitTrans.str");
+  public static String initTransModule = "org/sugarj/init/InitTrans";
   public static URI initEditor = ensureFile("org/sugarj/init/initEditor.serv");
   public static String initEditorModule = "org/sugarj/init/initEditor";
 

From seba at informatik.uni-marburg.de  Wed Jun  1 12:09:20 2011
From: seba at informatik.uni-marburg.de (Sebastian Erdweg)
Date: Wed, 01 Jun 2011 10:09:20 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r22981 -
	sugarj/trunk/compiler/org/sugarj/driver
Message-ID: <20110601100920.51C7C2B8054@mx2.tudelft.nl>

Author: SebastianErdweg
Date: Wed Jun  1 10:09:19 2011
New Revision: 22981
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=22981&sc=1

Log:
fixed circular dependency detection

Modified:
   sugarj/trunk/compiler/org/sugarj/driver/Driver.java

Modified: sugarj/trunk/compiler/org/sugarj/driver/Driver.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/Driver.java	Wed Jun  1 10:04:42 2011	(r22980)
+++ sugarj/trunk/compiler/org/sugarj/driver/Driver.java	Wed Jun  1 10:09:19 2011	(r22981)
@@ -209,14 +209,19 @@
       currentlyProcessing.add(sourceFile);
     }
 
-    String source = FileCommands.readFileAsString(sourceFile.getPath());
-    String moduleName = FileCommands.fileName(sourceFile);
+    Result res;
     
-    Result res = compile(source, moduleName, sourceFile.getPath());
-
-    synchronized (currentlyProcessing) {
-      currentlyProcessing.remove(sourceFile);
+    try {
+      String source = FileCommands.readFileAsString(sourceFile.getPath());
+      String moduleName = FileCommands.fileName(sourceFile);
+      
+      res = compile(source, moduleName, sourceFile.getPath());
+    } finally {
+      synchronized (currentlyProcessing) {
+        currentlyProcessing.remove(sourceFile);
+      }
     }
+
     pendingInputFiles.remove(sourceFile);
 
     return res;

From R.B.Vermaas at tudelft.nl  Wed Jun  1 13:16:19 2011
From: R.B.Vermaas at tudelft.nl (Rob Vermaas)
Date: Wed, 01 Jun 2011 11:16:19 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r22982 - hydra/jobs
Message-ID: <20110601111619.4DBAB7F805F@mx1.tudelft.nl>

Author: rob
Date: Wed Jun  1 11:16:18 2011
New Revision: 22982
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=22982&sc=1

Log:
enable tests for jsglr

Modified:
   hydra/jobs/spoofax-imp.nix

Modified: hydra/jobs/spoofax-imp.nix
==============================================================================
--- hydra/jobs/spoofax-imp.nix	Wed Jun  1 10:09:19 2011	(r22981)
+++ hydra/jobs/spoofax-imp.nix	Wed Jun  1 11:16:18 2011	(r22982)
@@ -263,6 +263,9 @@
           cp -v org.strategoxt.strj/java/strategoxt.jar `dirname $e`/utils/
         done
 
+
+        sed -i 's|eclipse-plugin|eclipse-test-plugin|' org.spoofax.jsglr/pom.xml
+
         mvn package ${mvnFlags} -e
         mvn integration-test ${mvnFlags} -e
       '';

From R.B.Vermaas at tudelft.nl  Wed Jun  1 13:32:24 2011
From: R.B.Vermaas at tudelft.nl (Rob Vermaas)
Date: Wed, 01 Jun 2011 11:32:24 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r22983 - hydra/jobs
Message-ID: <20110601113224.BED50CC181@mx4.tudelft.nl>

Author: rob
Date: Wed Jun  1 11:32:23 2011
New Revision: 22983
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=22983&sc=1

Log:
revert

Modified:
   hydra/jobs/spoofax-imp.nix

Modified: hydra/jobs/spoofax-imp.nix
==============================================================================
--- hydra/jobs/spoofax-imp.nix	Wed Jun  1 11:16:18 2011	(r22982)
+++ hydra/jobs/spoofax-imp.nix	Wed Jun  1 11:32:23 2011	(r22983)
@@ -263,9 +263,6 @@
           cp -v org.strategoxt.strj/java/strategoxt.jar `dirname $e`/utils/
         done
 
-
-        sed -i 's|eclipse-plugin|eclipse-test-plugin|' org.spoofax.jsglr/pom.xml
-
         mvn package ${mvnFlags} -e
         mvn integration-test ${mvnFlags} -e
       '';

From seba at informatik.uni-marburg.de  Wed Jun  1 18:03:08 2011
From: seba at informatik.uni-marburg.de (Sebastian Erdweg)
Date: Wed, 01 Jun 2011 16:03:08 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r22984 -
	sugarj/trunk/compiler/org/sugarj/driver
Message-ID: <20110601160308.396542B8072@mx2.tudelft.nl>

Author: SebastianErdweg
Date: Wed Jun  1 16:03:02 2011
New Revision: 22984
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=22984&sc=1

Log:
improved generation of compound grammars and desugarings: no random names in imports => better caching

Modified:
   sugarj/trunk/compiler/org/sugarj/driver/ATermCommands.java
   sugarj/trunk/compiler/org/sugarj/driver/Driver.java
   sugarj/trunk/compiler/org/sugarj/driver/ModuleSystemCommands.java
   sugarj/trunk/compiler/org/sugarj/driver/Result.java
   sugarj/trunk/compiler/org/sugarj/driver/SDFCommands.java
   sugarj/trunk/compiler/org/sugarj/driver/STRCommands.java

Modified: sugarj/trunk/compiler/org/sugarj/driver/ATermCommands.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/ATermCommands.java	Wed Jun  1 11:32:23 2011	(r22983)
+++ sugarj/trunk/compiler/org/sugarj/driver/ATermCommands.java	Wed Jun  1 16:03:02 2011	(r22984)
@@ -337,7 +337,8 @@
     
     for (int i = left.getIndex(), max = right.getIndex(); i <= max; i++) {
       Token tok = ((Token) left.getTokenizer().getTokenAt(i));
-      tok.setError(msg);
+      if (tok.getError() == null || tok.getError().isEmpty())
+        tok.setError(msg);
       
       if (tok.getTokenizer().getInput().length() <= tok.getStartOffset() || tok.getTokenizer().getInput().charAt(tok.getStartOffset()) == '\n')
         break;

Modified: sugarj/trunk/compiler/org/sugarj/driver/Driver.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/Driver.java	Wed Jun  1 11:32:23 2011	(r22983)
+++ sugarj/trunk/compiler/org/sugarj/driver/Driver.java	Wed Jun  1 16:03:02 2011	(r22984)
@@ -321,23 +321,18 @@
       
       stopIfInterrupted();
             
-      try {
-        // check final grammar and transformation for errors
-        if (!Environment.noChecking) {
-          checkCurrentGrammar();
-        }
-        
-        stopIfInterrupted();
-        
-        // need to build current transformation program for editor services
-        checkCurrentTransformation();
-        
-      } catch (Exception e) {
-        e.printStackTrace();
+      // check final grammar and transformation for errors
+      if (!Environment.noChecking) {
+        checkCurrentGrammar();
       }
       
       stopIfInterrupted();
       
+      // need to build current transformation program for editor services
+      checkCurrentTransformation();
+      
+      stopIfInterrupted();
+      
       // COMPILE the generated java file
       compileGeneratedJavaFile();
       
@@ -354,6 +349,7 @@
     }
     finally {
       log.endTask(success, "done processing " + moduleName, "failed processing " + moduleName);
+      driverResult.setFailed(!success);
     }
   }
 
@@ -688,6 +684,16 @@
       currentTransProg = STRCommands.compile(currentTransSTR, "main", driverResult.getFileDependencies(), strParser, strjContext);
 
       return STRCommands.assimilate(currentTransProg, term, interp);
+    } catch (RuntimeException e) {
+      String msg = e.getClass().getName() + " " + e.getLocalizedMessage() != null ? e.getLocalizedMessage() : e.toString();
+      
+      if (!(e instanceof StrategoException))
+        e.printStackTrace();
+      else
+        log.logErr(msg);
+
+      ATermCommands.setErrorMessage(term, msg);
+      return term;
     } finally {
       log.endTask();
     }
@@ -787,7 +793,15 @@
 
         if (sourceUri != null && (res == null || pendingInputFiles.contains(res.getSourceFile()) || !res.isUpToDate(res.getSourceFile()))) {
           log.log("Need to compile the imported module first ; processing it now.");
-          compile(sourceUri);
+          
+          try {
+            Result importResult = compile(sourceUri);
+            if (importResult.hasFailed())
+              ATermCommands.setErrorMessage(toplevelDecl, "problems while compiling " + importModule);
+          } catch (Exception e) {
+            ATermCommands.setErrorMessage(toplevelDecl, "problems while compiling " + importModule);
+          }
+            
           log.log("CONTINUE PROCESSING'" + moduleName + "'.");
         }
         
@@ -820,26 +834,18 @@
         interp, 
         driverResult);
 
-    String grammarModule = ModuleSystemCommands.importSdf(
-        modulePath, 
-        currentGrammarModule, 
-        availableSDFImports, 
-        driverResult);
+    URI grammarModule = ModuleSystemCommands.importSdf(modulePath);
     if (grammarModule != null) {
       success = true;
-      currentGrammarSDF = grammarModule;
-      currentGrammarModule = FileCommands.fileName(grammarModule);
+      availableSDFImports.add(modulePath);
+      buildCompoundSdfModule();
     }
     
-    String transModule = ModuleSystemCommands.importStratego(
-        modulePath, 
-        currentTransModule, 
-        availableSTRImports, 
-        driverResult);
-    if (transModule != null) {
+    URI strModule = ModuleSystemCommands.importStratego(modulePath);
+    if (strModule != null) {
       success = true;
-      currentTransSTR = transModule;
-      currentTransModule = FileCommands.fileName(transModule);
+      availableSTRImports.add(modulePath);
+      buildCompoundStrModule();
     }
     
     success |= ModuleSystemCommands.importEditorServices(modulePath, driverResult);
@@ -1036,35 +1042,43 @@
        * adapt current grammar
        */
       if (FileCommands.exists(sdfExtension)) {
-        String currentGrammarName =
-          FileCommands.hashFileName("sugarj", currentGrammarModule + fullExtName);
-        currentGrammarSDF =
-          Environment.tmpDir + sep + currentGrammarName + ".sdf";
-        FileCommands.writeToFile(currentGrammarSDF, 
-            "module " + currentGrammarName + "\n"
-            + "imports " + currentGrammarModule + "\n" 
-            + "        " + fullExtName);
-        currentGrammarModule = currentGrammarName;
+        buildCompoundSdfModule();
       }
 
       /*
        * adapt current transformation
        */
-      if (FileCommands.exists(strExtension)) {
-        String currentTransName =
-          FileCommands.hashFileName("sugarj", currentTransModule + fullExtName);
-        currentTransSTR = Environment.tmpDir + sep + currentTransName + ".str";
-        FileCommands.writeToFile(currentTransSTR,
-            "module " + currentTransName + "\n" 
-            + "imports " + currentTransModule + "\n"
-            + "        " + fullExtName);
-        currentTransModule = currentTransName;
-      }
+      if (FileCommands.exists(strExtension))
+        buildCompoundStrModule();
 
     } finally {
       log.endTask();
     }
   }
+  
+  private void buildCompoundSdfModule() throws IOException {
+    currentGrammarSDF = FileCommands.newTempFile("sdf");
+    currentGrammarModule = FileCommands.fileName(currentGrammarSDF);
+    StringBuilder builder = new StringBuilder();
+    builder.append("module ").append(currentGrammarModule).append("\n");
+    builder.append("imports ");
+    for (String m : availableSDFImports)
+      builder.append(m).append(" ");
+    
+    FileCommands.writeToFile(currentGrammarSDF, builder.toString());
+  }
+  
+  private void buildCompoundStrModule() throws IOException {
+    currentTransSTR = FileCommands.newTempFile("str");
+    currentTransModule = FileCommands.fileName(currentTransSTR);
+    StringBuilder builder = new StringBuilder();
+    builder.append("module ").append(currentTransModule).append("\n");
+    builder.append("imports ");
+    for (String m : availableSTRImports)
+      builder.append(m).append(" ");
+    
+    FileCommands.writeToFile(currentTransSTR, builder.toString());
+  }
 
   private void checkCurrentGrammar() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, SGLRException {
     log.beginTask("checking grammar", "CHECK current grammar");
@@ -1076,7 +1090,7 @@
     }
   }
   
-  private void checkCurrentTransformation() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, SGLRException{
+  private void checkCurrentTransformation() throws TokenExpectedException, BadTokenException, IOException, InvalidParseTableException, SGLRException {
     log.beginTask("checking transformation", "CHECK current transformation");
     
     try {
@@ -1119,9 +1133,11 @@
 
     // list of imports that contain SDF extensions
     availableSDFImports = new ArrayList<String>();
+    availableSDFImports.add(StdLib.initGrammarModule);
 
     // list of imports that contain Stratego extensions
     availableSTRImports = new ArrayList<String>();
+    availableSTRImports.add(StdLib.initTransModule);
 
     inputTreeBuilder = new RetractableTreeBuilder();
     

Modified: sugarj/trunk/compiler/org/sugarj/driver/ModuleSystemCommands.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/ModuleSystemCommands.java	Wed Jun  1 11:32:23 2011	(r22983)
+++ sugarj/trunk/compiler/org/sugarj/driver/ModuleSystemCommands.java	Wed Jun  1 16:03:02 2011	(r22984)
@@ -2,7 +2,6 @@
 
 import static org.sugarj.driver.ATermCommands.isApplication;
 import static org.sugarj.driver.Environment.includePath;
-import static org.sugarj.driver.Environment.sep;
 import static org.sugarj.driver.Log.log;
 
 import java.io.BufferedReader;
@@ -16,7 +15,6 @@
 import java.net.URLClassLoader;
 import java.util.Collection;
 import java.util.Collections;
-import java.util.List;
 import java.util.Set;
 
 import org.spoofax.interpreter.terms.IStrategoTerm;
@@ -62,34 +60,14 @@
    * @return path to new grammar or null if no sdf file existed.
    * @throws IOException 
    */
-  public static String importSdf(String modulePath, String currentGrammarModule, List<String> availableSDFImports, Result driverResult) throws IOException {
+  public static URI importSdf(String modulePath) throws IOException {
     URI sdfUri = searchFile(modulePath, ".sdf");
     
     if (sdfUri == null)
       return null;
     
-    log.beginTask("Incorporation", "Incorporate the imported grammar " + modulePath);
-    try {
-      // build extension of current grammar
-      String newGrammarName = 
-        FileCommands.hashFileName("sugarj", currentGrammarModule + modulePath);
-        
-
-      String newGrammar = Environment.tmpDir + sep + newGrammarName + ".sdf";
-
-      String grammar = 
-        "module " + newGrammarName + "\n"
-      + "imports " + currentGrammarModule + "\n"
-      + "        " + modulePath;
-      
-      FileCommands.writeToFile(newGrammar, grammar);
-
-      availableSDFImports.add(modulePath);
-
-      return newGrammar;
-    } finally {
-      log.endTask();
-    }
+    log.log("Found syntax definition for " + modulePath);
+    return sdfUri;
   }
   
   /**
@@ -101,33 +79,14 @@
    * @return path to new Stratego module or null of no str file existed
    * @throws IOException 
    */
-  public static String importStratego(String modulePath, String currentTransModule, List<String> availableSTRImports, Result driverResult) throws IOException {
+  public static URI importStratego(String modulePath) throws IOException {
     URI strUri = searchFile(modulePath, ".str");
     
     if (strUri == null)
       return null;
-    
-    log.beginTask("Incorporation", "Incorporate the imported desugaring rules " + modulePath);
-    try {
-      // build extension of current transformation
-      String newTransName =
-        FileCommands.hashFileName("sugarj", currentTransModule + modulePath);
-
-      String newTrans = Environment.tmpDir + sep + newTransName + ".str";
-
-      String trans =
-          "module " + newTransName + "\n"
-        + "imports " + currentTransModule + "\n"
-        + "        " + modulePath;
-      
-      FileCommands.writeToFile(newTrans, trans);
 
-      availableSTRImports.add(modulePath);
-
-      return newTrans;
-    } finally {
-      log.endTask();
-    }
+    log.log("Found desugaring for " + modulePath);
+    return strUri;
   }
   
   /**

Modified: sugarj/trunk/compiler/org/sugarj/driver/Result.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/Result.java	Wed Jun  1 11:32:23 2011	(r22983)
+++ sugarj/trunk/compiler/org/sugarj/driver/Result.java	Wed Jun  1 16:03:02 2011	(r22984)
@@ -28,6 +28,7 @@
   private String sourceFile;
   private Integer sourceFileHash;
   private Set<String> allDependentFiles = new HashSet<String>();
+  private boolean failed = false;
 
   private final static Result OUTDATED_RESULT = new Result() {
     @Override
@@ -201,4 +202,12 @@
   public String getSourceFile() {
     return sourceFile;
   }
+  
+  public boolean hasFailed() {
+    return failed;
+  }
+  
+  public void setFailed(boolean hasFailed) {
+    this.failed = hasFailed;
+  }
 }
\ No newline at end of file

Modified: sugarj/trunk/compiler/org/sugarj/driver/SDFCommands.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/SDFCommands.java	Wed Jun  1 11:32:23 2011	(r22983)
+++ sugarj/trunk/compiler/org/sugarj/driver/SDFCommands.java	Wed Jun  1 16:03:02 2011	(r22984)
@@ -198,14 +198,17 @@
     log.beginTask("Searching", "Search parse table in cache");
     try {
       result = sdfCache.get(key);
+      
+      if (result == null || !new File(result).exists())
+        return null;
+
+      if (CommandExecution.CACHE_INFO)
+        log.log("Cache location: '" + result + "'");
+
+      return result;
     } finally {
       log.endTask(result != null);
     }
-    
-    if (result != null && !new File(result).exists())
-      return null;
-    
-    return result;
   }
   
   private static ModuleKey getModuleKeyForGrammar(String sdf, String module, Collection<String> dependentFiles, JSGLRI parser) throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, SGLRException {

Modified: sugarj/trunk/compiler/org/sugarj/driver/STRCommands.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/STRCommands.java	Wed Jun  1 11:32:23 2011	(r22983)
+++ sugarj/trunk/compiler/org/sugarj/driver/STRCommands.java	Wed Jun  1 16:03:02 2011	(r22984)
@@ -154,22 +154,19 @@
     
     log.beginTask("Searching", "Search assimilator in cache");
     try {
+      int h = key.hashCode();
       result = strCache.get(key);
       
-      // Ignore non-existing files
-      if (result != null && !FileCommands.exists(result))
-        result = null;
-      
-      if (result != null && CommandExecution.CACHE_INFO)
+      if (result == null || !new File(result).exists())
+        return null;
+
+      if (CommandExecution.CACHE_INFO)
         log.log("Cache location: '" + result + "'");
+      
+      return result;
     } finally {
       log.endTask(result != null);
     }
-    
-    if (result != null && !new File(result).exists())
-      return null;
-    
-    return result;
   }
 
 

From seba at informatik.uni-marburg.de  Thu Jun  2 17:53:21 2011
From: seba at informatik.uni-marburg.de (Sebastian Erdweg)
Date: Thu, 02 Jun 2011 15:53:21 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r22985 - in
	sugarj/trunk: compiler/org/sugarj/driver
	editor/editor/java/org/sugarj/editor feature update-site
Message-ID: <20110602155321.D4FE1CC0E9@mx4.tudelft.nl>

Author: SebastianErdweg
Date: Thu Jun  2 15:53:16 2011
New Revision: 22985
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=22985&sc=1

Log:
Sugarclipse progress monitor

Modified:
   sugarj/trunk/compiler/org/sugarj/driver/Driver.java
   sugarj/trunk/compiler/org/sugarj/driver/Result.java
   sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParser.java
   sugarj/trunk/feature/feature.xml
   sugarj/trunk/update-site/site.xml

Modified: sugarj/trunk/compiler/org/sugarj/driver/Driver.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/Driver.java	Wed Jun  1 16:03:02 2011	(r22984)
+++ sugarj/trunk/compiler/org/sugarj/driver/Driver.java	Thu Jun  2 15:53:16 2011	(r22985)
@@ -35,6 +35,7 @@
 import org.apache.commons.cli.HelpFormatter;
 import org.apache.commons.cli.Options;
 import org.apache.commons.collections.map.LRUMap;
+import org.eclipse.core.runtime.IProgressMonitor;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.jsglr.client.InvalidParseTableException;
 import org.spoofax.jsglr.client.ParseTable;
@@ -90,6 +91,8 @@
   private static List<URI> pendingInputFiles;
   private static List<URI> currentlyProcessing;
 
+  private IProgressMonitor monitor;
+  
   private Result driverResult = new Result();
   
   private String moduleName;
@@ -201,7 +204,7 @@
     Log.log.log(resultCache.size());
   }
   
-  public static Result compile(URI sourceFile) throws IOException, TokenExpectedException, BadTokenException, ParseException, InvalidParseTableException, SGLRException, InterruptedException {
+  public static Result compile(URI sourceFile, IProgressMonitor monitor) throws IOException, TokenExpectedException, BadTokenException, ParseException, InvalidParseTableException, SGLRException, InterruptedException {
     synchronized (currentlyProcessing) {
       // TODO we need better circular dependency handling
       if (currentlyProcessing.contains(sourceFile))
@@ -215,7 +218,7 @@
       String source = FileCommands.readFileAsString(sourceFile.getPath());
       String moduleName = FileCommands.fileName(sourceFile);
       
-      res = compile(source, moduleName, sourceFile.getPath());
+      res = compile(source, moduleName, sourceFile.getPath(), monitor);
     } finally {
       synchronized (currentlyProcessing) {
         currentlyProcessing.remove(sourceFile);
@@ -227,7 +230,7 @@
     return res;
   }
   
-  public static Result compile(String source, String moduleName, String file) throws IOException, TokenExpectedException, BadTokenException, ParseException, InvalidParseTableException, SGLRException, InterruptedException {
+  public static Result compile(String source, String moduleName, String file, IProgressMonitor monitor) throws IOException, TokenExpectedException, BadTokenException, ParseException, InvalidParseTableException, SGLRException, InterruptedException {
     Driver driver = new Driver();
     Entry<String, Driver> pending = null;
     
@@ -250,11 +253,11 @@
     
     if (pending != null) {
       waitForPending(file);
-      return compile(source, moduleName, file);
+      return compile(source, moduleName, file, monitor);
     }
     
     try {
-      driver.process(source, moduleName, file);
+      driver.process(source, moduleName, file, monitor);
       storeCaches();
     } finally {
         pendingRuns.remove(file);
@@ -279,7 +282,8 @@
    * @throws TokenExpectedException 
    * @throws InterruptedException 
    */
-  private void process(String source, String moduleName, String file) throws IOException, TokenExpectedException, BadTokenException, ParseException, InvalidParseTableException, SGLRException, InterruptedException {
+  private void process(String source, String moduleName, String file, IProgressMonitor monitor) throws IOException, TokenExpectedException, BadTokenException, ParseException, InvalidParseTableException, SGLRException, InterruptedException {
+    this.monitor = monitor;
     log.beginTask("processing", "BEGIN PROCESSING " + moduleName);
     boolean success = false;
     try {
@@ -295,7 +299,7 @@
         boolean wocache = Environment.wocache;
         Environment.wocache |= skipCache;
         
-        stopIfInterrupted();
+        stepped();
         
         // PARSE the next top-level declaration
         IncrementalParseResult parseResult =
@@ -303,7 +307,7 @@
         lastSugaredToplevelDecl = parseResult.getToplevelDecl();
         remainingInput = parseResult.getRest();
         
-        stopIfInterrupted();
+        stepped();
         
         // DESUGAR the parsed top-level declaration
         IStrategoTerm desugared = currentDesugar(lastSugaredToplevelDecl);
@@ -311,7 +315,7 @@
         // reset cache skipping
         Environment.wocache = wocache;
         
-        stopIfInterrupted();
+        stepped();
         
         // PROCESS the assimilated top-level declaration
         processToplevelDeclaration(desugared);
@@ -319,19 +323,19 @@
         done = parseResult.parsingFinished();
       }
       
-      stopIfInterrupted();
+      stepped();
             
       // check final grammar and transformation for errors
       if (!Environment.noChecking) {
         checkCurrentGrammar();
       }
       
-      stopIfInterrupted();
+      stepped();
       
       // need to build current transformation program for editor services
       checkCurrentTransformation();
       
-      stopIfInterrupted();
+      stepped();
       
       // COMPILE the generated java file
       compileGeneratedJavaFile();
@@ -795,7 +799,7 @@
           log.log("Need to compile the imported module first ; processing it now.");
           
           try {
-            Result importResult = compile(sourceUri);
+            Result importResult = compile(sourceUri, monitor);
             if (importResult.hasFailed())
               ATermCommands.setErrorMessage(toplevelDecl, "problems while compiling " + importModule);
           } catch (Exception e) {
@@ -1179,8 +1183,11 @@
         pendingInputFiles.add(uri);
       }
       
-      for (URI source : allInputFiles) {
-        Result res = compile(source);
+      IProgressMonitor monitor = new PrintProgressMonitor(System.out);
+      
+      for (final URI source : allInputFiles) {
+        monitor.beginTask("compile " + source.getPath(), IProgressMonitor.UNKNOWN);
+        Result res = compile(source, monitor);
         if (!DriverCLI.processResultCLI(res, source.getPath(), new File(".").getAbsolutePath()))
           throw new RuntimeException("compilation of " + source.getPath() + " failed");
       }
@@ -1523,8 +1530,14 @@
   
   private synchronized void stopIfInterrupted() throws InterruptedException {
     if (interrupt) {
+      monitor.setCanceled(true);
       log.log("interrupted " + mainModuleName);
       throw new InterruptedException();
     }
   }
+
+  private void stepped() throws InterruptedException {
+    stopIfInterrupted();
+    monitor.worked(1);
+  }
 }

Modified: sugarj/trunk/compiler/org/sugarj/driver/Result.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/Result.java	Wed Jun  1 16:03:02 2011	(r22984)
+++ sugarj/trunk/compiler/org/sugarj/driver/Result.java	Thu Jun  2 15:53:16 2011	(r22985)
@@ -32,7 +32,7 @@
 
   private final static Result OUTDATED_RESULT = new Result() {
     @Override
-    boolean isUpToDate(String file) {
+    public boolean isUpToDate(String file) {
       return false;
     }
 
@@ -76,7 +76,7 @@
     return editorServices;
   }
   
-  boolean isUpToDate(String inputFile) throws IOException {
+  public boolean isUpToDate(String inputFile) throws IOException {
     return isUpToDate(FileCommands.fileHash(inputFile));
   }
   

Modified: sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParser.java
==============================================================================
--- sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParser.java	Wed Jun  1 16:03:02 2011	(r22984)
+++ sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParser.java	Thu Jun  2 15:53:16 2011	(r22985)
@@ -3,9 +3,15 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.core.runtime.IStatus;
+import org.eclipse.core.runtime.Status;
+import org.eclipse.core.runtime.jobs.Job;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.jsglr.shared.BadTokenException;
 import org.spoofax.jsglr.shared.SGLRException;
@@ -26,10 +32,11 @@
 
   private String projectPath;
   private String outputPath;
-  private Result result;
   private List<String> includePath;
-
+  private boolean justReturn;
   
+  private static Map<String, Result> results = new HashMap<String, Result>();
+  private Result result;
   
   public SugarJParser(JSGLRI parser) {
     super(parser.getParseTable(), parser.getStartSymbol(), parser.getController());
@@ -40,6 +47,45 @@
   protected IStrategoTerm doParse(String input, String filename)
       throws TokenExpectedException, BadTokenException, SGLRException, IOException {
     
+    result = getResult(filename);
+
+    if (result instanceof PendingResult || (doJustReturn() && result.isUpToDate(filename)))
+      setJustReturn(false);
+    else 
+      scheduleParse(input, filename);
+        
+    if (result == null)
+      return null;
+    
+    if (result instanceof PendingResult)
+      return ((PendingResult) result).getResult().getSugaredSyntaxTree();
+    
+    return result.getSugaredSyntaxTree();
+  }
+  
+  private synchronized void scheduleParse(final String input, final String filename) {
+    putResult(filename, new PendingResult(getResult(filename)));
+    
+    Job parseJob = new Job("SugarJ parser: " + projectRelativePath(filename)) {
+      @Override
+      protected IStatus run(IProgressMonitor monitor) {
+        monitor.beginTask("parse " + projectRelativePath(filename), IProgressMonitor.UNKNOWN);
+        try {
+          Result result = runParser(input, filename, monitor);
+          putResult(filename, result);
+        } finally {
+          monitor.done();
+          setJustReturn(true);
+          getController().scheduleParserUpdate(0, false);
+        }
+        return Status.OK_STATUS;
+      }
+    };
+    
+    parseJob.schedule();
+  }
+  
+  private Result runParser(String input, String filename, IProgressMonitor monitor) {
     Environment.wocache = false;
 
     Environment.includePath.addAll(includePath);
@@ -69,15 +115,13 @@
     SugarJConsole.activateConsoleOnce();
     
     try {
-      result = Driver.compile(input, FileCommands.fileName(filename), filename);
+      return Driver.compile(input, FileCommands.fileName(filename), filename, monitor);
     } catch (Throwable e) {
       e.printStackTrace();
       throw new RuntimeException("parsing " + FileCommands.fileName(filename) + " failed", e);
     }
-    
-    return result.getSugaredSyntaxTree();
   }
-
+  
 
   public void setProjectPath(String projectPath) {
     this.projectPath = projectPath;
@@ -93,7 +137,8 @@
 
   @Override
   public Set<BadTokenException> getCollectedErrors() {
-    return result.getCollectedErrors();
+    final Set<BadTokenException> empty = Collections.emptySet();
+    return result == null ? empty : result.getCollectedErrors();
   }
 
 
@@ -102,4 +147,25 @@
     return result == null ? empty : new ArrayList<IStrategoTerm>(result.getEditorServices());
   }
   
+  private synchronized boolean doJustReturn() {
+    return justReturn;
+  }
+  
+  private synchronized void setJustReturn(boolean justReturn) {
+    this.justReturn = justReturn;
+  }
+
+  private static synchronized Result getResult(String file) {
+    return results.get(file);
+  }
+  
+  private static synchronized void putResult(String file, Result result) {
+    results.put(file, result);
+  }
+  
+  private String projectRelativePath(String filename) {
+    if (filename.startsWith(projectPath))
+      return filename.substring(projectPath.length() + 1);
+    return filename;
+  }
 }

Modified: sugarj/trunk/feature/feature.xml
==============================================================================
--- sugarj/trunk/feature/feature.xml	Wed Jun  1 16:03:02 2011	(r22984)
+++ sugarj/trunk/feature/feature.xml	Thu Jun  2 15:53:16 2011	(r22985)
@@ -1,8 +1,8 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <feature
       id="org.sugarj.editor"
-      label="SugarJ"
-      version="1.1.1.qualifier"
+      label="Sugarclipse"
+      version="1.2.3.qualifier"
       provider-name="sugarj.org">
 
    <description url="http://sugarj.org">

Modified: sugarj/trunk/update-site/site.xml
==============================================================================
--- sugarj/trunk/update-site/site.xml	Wed Jun  1 16:03:02 2011	(r22984)
+++ sugarj/trunk/update-site/site.xml	Thu Jun  2 15:53:16 2011	(r22985)
@@ -3,7 +3,7 @@
    <description name="SugarJ" url="sugarj.org/update">
       SugarJ
    </description>
-   <feature url="features/org.sugarj.editor_1.1.1.201105311536.jar" id="org.sugarj.editor" version="1.1.1.201105311536">
+   <feature url="features/org.sugarj.editor_1.2.3.201106021749.jar" id="org.sugarj.editor" version="1.2.3.201106021749">
       <category name="SugarJ"/>
    </feature>
    <category-def name="SugarJ" label="SugarJ">

From seba at informatik.uni-marburg.de  Thu Jun  2 18:17:32 2011
From: seba at informatik.uni-marburg.de (Sebastian Erdweg)
Date: Thu, 02 Jun 2011 16:17:32 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r22986 -
	sugarj/trunk/stdlib/org/sugarj/init
Message-ID: <20110602161732.F130CCC236@mx4.tudelft.nl>

Author: SebastianErdweg
Date: Thu Jun  2 16:17:28 2011
New Revision: 22986
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=22986&sc=1

Log:
editor services for SDF, Stratego and services

Modified:
   sugarj/trunk/stdlib/org/sugarj/init/initEditor.serv

Modified: sugarj/trunk/stdlib/org/sugarj/init/initEditor.serv
==============================================================================
--- sugarj/trunk/stdlib/org/sugarj/init/initEditor.serv	Thu Jun  2 15:53:16 2011	(r22985)
+++ sugarj/trunk/stdlib/org/sugarj/init/initEditor.serv	Thu Jun  2 16:17:28 2011	(r22986)
@@ -55,4 +55,285 @@
   JavaClassDec     
   JavaInterfaceDec
   JavaEnumDec 
-  
\ No newline at end of file
+
+  completions SDF
+    completion template : SugarDefElem =
+      "context-free syntax" "\n\t" (blank)
+  
+    completion template : SugarDefElem =
+      "lexical syntax" "\n\t" (blank)
+  
+    completion template : SugarDefElem =
+      "syntax" "\n\t" (blank)
+  
+    completion template : SugarDefElem =
+      "context-free restrictions" "\n\t" (blank)
+  
+    completion template : SugarDefElem =
+      "lexical restrictions" "\n\t" (blank)
+  
+    completion template : SugarDefElem =
+      "restrictions" "\n\t" (blank)
+  
+    completion template : SugarDefElem =
+      "sorts" "\n\t" (blank)
+  
+    completion template : SugarDefElem =
+      "variables" "\n\t" (blank)
+  
+    completion template : SugarDefElem =
+      "aliases" "\n\t" (blank)
+  
+    completion template : SugarDefElem =
+      "priorities" "\n\t" (blank)
+  
+    completion template : SugarDefElem = 
+      "lexical variables" "\n\t" (blank)
+  
+    completion template : Sdf2Attribute =
+      "cons" "(\"" <Name> "\")"
+  
+    completion template : Sdf2Attribute =
+      "deprecated" "(\"" <explanation> "\")"
+  
+    completion template : Sdf2Attribute =
+      "reject"
+  
+    completion template : Sdf2Attribute =
+      "left"
+  
+    completion template : Sdf2Attribute =
+      "right"
+  
+    completion template : Sdf2Attribute =
+      "non-assoc"
+  
+    completion template : Sdf2Attribute =
+      "avoid"
+  
+    completion template : Sdf2Attribute =
+      "prefer"
+  
+    completion template : Sdf2Attribute =
+      "bracket"
+  
+    completion template : Sdf2Attribute =
+      "recover"
+
+  
+  
+  folding Stratego
+    _.SDefNoArgs
+    _.SDefT
+    _.SDef
+    _.RDefNoArgs
+    _.RDefT
+    _.RDef
+  
+  colorer Stratego
+    // StrategyDef: 0 128 128 bold
+    // RuleDef:     0 128 128 bold
+    
+    // White background for variables and escapes
+    environment _.StringEscape1 : _ 255 255 255
+    environment _.StringEscape2 : _ 255 255 255
+    environment _.StringEscape3 : _ 255 255 255
+    environment _.StringEscape4 : _ 255 255 255
+    _.Wld     : _ 255 255 255
+  
+    _.StringEscape1 : gray  
+    _.StringEscape2 : gray  
+    _.StringEscape3 : gray 
+    _.StringEscape4 : gray
+    
+    _.Str     : blue
+    _.StrCong : blue
+    _.QStr    : blue
+    _.QDollar : blue
+    _.QBr     : gray
+    
+    StrategoRuleDef     : 0 64 128 bold
+    StrategoRuleDec     : 0 64 128 bold
+    StrategoStrategyDef : 0 64 128 bold
+    StrategoOverlay     : 0 64 128 bold
+    
+    //strategies    = 0    0    0
+    strategycalls = 0   64  128
+    terms         = 0    0    0
+    vars          = 0    0    0   255 255 255
+    sdefault      = 0    0    0
+    
+    _.RootApp : strategycalls
+    _.App     : strategycalls
+    
+    //Strategy  : strategies
+    StrategoSVar      : strategycalls
+    StrategoTerm      : terms
+    StrategoPreTerm   : terms
+    StrategoVar       : vars
+    _.Var     : vars
+    _.ListVar : vars
+    _.Assign  : sdefault
+    _.AM      : sdefault
+  
+    StrategoQuotedBracket1 : blue
+    StrategoQuotedBracket2 : blue
+    StrategoQuotedBracket3 : blue
+    StrategoQuotedBracket4 : blue
+
+  completions Stratego
+    completion template : StrategoStrategy =
+    "if" " " <e> " then\n\t" <s> "\nend"
+        
+    completion template : StrategoStrategy = 
+      "switch" " " <s> "\n\tcase " <c> ":" " " <s> "\n\totherwise: " <id> "\nend"
+  
+    completion template : StrategoStrategy =
+      "let" "\n\t" <x> " = " <s> "\nin\n\t" <s> "\nend"
+  
+    completion template : StrategoDef =
+      "where" "\n\t" (blank)
+      
+    completion template : StrategoDef =
+      "with" "\n\t" (blank)
+    
+    completion template : SugarDefElem =
+      "strategies" "\n\t" (blank)
+    
+    completion template : SugarDefElem =
+      "rules" "\n\t" (blank)
+
+  
+  
+  folding Editor services
+    _.EditorServicesDec
+    EditorServiceSection
+  
+  outliner Editor services
+    _.EditorServicesDec
+    EditorServiceSection
+    EditorServiceRefactoringRule
+    EditorServiceBuilderRule
+    EditorServiceCompletionRule
+    EditorServiceReferenceRule
+
+  
+  completions Editor services
+    completion template : EditorServiceSection =
+      "builders" "\n\t" (blank)
+  
+    completion template : EditorServiceSection =
+      "colorer" "\n\t" (blank)
+  
+    completion template : EditorServiceSection =
+      "folding" "\n\t" (blank)
+  
+    completion template : EditorServiceSection =
+      "outliner" "\n\t" (blank)
+  
+    completion template : EditorServiceSection =
+      "completions" "\n\t" (blank)
+  
+    completion template : EditorServiceSection =
+      "language" "\n\t" (blank)
+  
+    completion template : EditorServiceSection =
+      "references" "\n\t" (blank)
+  
+    completion template : EditorServiceCompletionRule =
+      "completion template" " : " <Sort> " =\n\t"
+        "\"" <prefix>  "\" <" <placeholder> ">" (blank)
+  
+    completion template : EditorServiceCompletionRule =
+      "identifier lexical" ":\n\t" <regex> (blank)
+  
+    completion template : EditorServiceCompletionRule =
+      "completion proposer" ":\n\t" <s> (blank)
+  
+    completion template : EditorServiceCompletionRule =
+      "completion keyword" ":\n\t" <k> (blank)
+  
+    completion template : EditorServiceCompletionRule =
+      "completion trigger" ":\n\t" <regex> (blank)
+  
+    completion template : EditorServiceBuilderRule =
+      "observer" ": " <s> (blank)
+  
+    completion template : EditorServiceBuilderRule =
+      "builder" ": " <"caption"> " = " <s> (blank)
+  
+    completion template : EditorServiceBuilderRule =
+      "builder caption" ": " <"caption"> (blank)
+  
+    completion template : EditorServiceLanguageProperty =
+      "unmanaged table" ": " <prefix> "*" (blank)
+  
+    completion template : EditorServiceLanguageProperty =
+      "line comment" ": " <prefix> (blank)
+  
+    completion template : EditorServiceLanguageProperty =
+      "block comment" ":\n\t" <prefix> " " <middle> " " <end> (blank)
+  
+    completion template : LanguageProperty =
+      "fences" ":\n\t" <f> " " <g> (blank)
+  
+    completion template : EditorServiceLanguageProperty =
+      "indent after" ":\n\t" <keyword> (blank)
+  
+    completion template : EditorServiceLanguageProperty =
+      "name" ":\n\t" <Name> (blank)
+  
+    completion template : EditorServiceLanguageProperty =
+      "url" ":\n\thttp://" <url> (blank)
+  
+    completion template : EditorServiceLanguageProperty =
+      "id" ":\n\t" <id> (blank)
+  
+    completion template : EditorServiceLanguageProperty =
+      "extends" ":\n\t" <Language> (blank)
+  
+    completion template : EditorServiceLanguageProperty =
+      "extensions" ":\n\t" <ext> (blank)
+  
+    completion template : EditorServiceLanguageProperty =
+      "start symbols" ":\n\t" <Start> (blank)
+  
+    completion template : EditorServiceLanguageProperty =
+      "disambiguator" ":\n\t" <s> (blank)
+  
+    completion template : EditorServiceLanguageProperty =
+      "description" ":\n\t" <description> (blank)
+  
+    completion template : EditorServiceLanguageProperty =
+      "table" ":\n\t" <table> (blank)
+  
+    completion template : EditorServiceLanguageProperty =
+      "table provider" ":\n\t" <provider> (blank)
+  
+    completion template : EditorServiceReferenceRule =
+      "reference" " _ : " <s> (blank)
+  
+    completion template : EditorServiceReferenceRule =
+      "occurrence" " _ : " <s> (blank)
+  
+    completion template : EditorServiceReferenceRule =
+      "hover" " _ : " <s> (blank)
+ 
+ 
+    completion template : EditorServiceRefactoringRule =
+      "provider" ": " <provider.jar> (blank)
+    completion template : EditorServiceBuilderRule =
+      "provider" ": " <provider.jar> (blank)
+    completion template : EditorServiceCompletionRule =
+      "provider" ": " <provider.jar> (blank)
+    completion template : EditorServiceReferenceRule =
+      "provider" ": " <provider.jar> (blank)
+ 
+    completion template : EditorServiceRefactoringRule =
+      "on save" ": " <s> (blank)
+    completion template : EditorServiceBuilderRule =
+      "on save" ": " <s> (blank)
+    completion template : EditorServiceCompletionRule =
+      "on save" ": " <s> (blank)
+    completion template : EditorServiceReferenceRule =
+      "on save" ": " <s> (blank)
\ No newline at end of file

From seba at informatik.uni-marburg.de  Thu Jun  2 20:22:54 2011
From: seba at informatik.uni-marburg.de (Sebastian Erdweg)
Date: Thu, 02 Jun 2011 18:22:54 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r22987 - in
	sugarj/trunk: compiler/org/sugarj/driver
	editor/editor/java/org/sugarj/editor
Message-ID: <20110602182254.54896108C0E8@mx3.tudelft.nl>

Author: SebastianErdweg
Date: Thu Jun  2 18:22:53 2011
New Revision: 22987
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=22987&sc=1

Log:
preliminary parsing

Modified:
   sugarj/trunk/compiler/org/sugarj/driver/Driver.java
   sugarj/trunk/compiler/org/sugarj/driver/Result.java
   sugarj/trunk/compiler/org/sugarj/driver/SDFCommands.java
   sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParser.java

Modified: sugarj/trunk/compiler/org/sugarj/driver/Driver.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/Driver.java	Thu Jun  2 16:17:28 2011	(r22986)
+++ sugarj/trunk/compiler/org/sugarj/driver/Driver.java	Thu Jun  2 18:22:53 2011	(r22987)
@@ -60,7 +60,7 @@
  */
 public class Driver{
   
-  public final static String CACHE_VERSION = "editor-base-0.11";
+  public final static String CACHE_VERSION = "editor-base-0.12";
   
   private static class Key {
     private String source;
@@ -652,10 +652,10 @@
   private IStrategoTerm currentParse(String remainingInput, boolean recovery) throws IOException,
       InvalidParseTableException, TokenExpectedException, BadTokenException, SGLRException {
     // recompile the current grammar definition
-    ParseTable currentGrammarTBL;
+    String currentGrammarTBL = SDFCommands.compile(currentGrammarSDF, currentGrammarModule, driverResult.getFileDependencies(), sdfParser, sdfContext, makePermissiveContext);
+    driverResult.setLastParseTable(currentGrammarTBL);
+    ParseTable table = org.strategoxt.imp.runtime.Environment.loadParseTable(currentGrammarTBL);
     
-    currentGrammarTBL = SDFCommands.compile(currentGrammarSDF, currentGrammarModule, driverResult.getFileDependencies(), sdfParser, sdfContext, makePermissiveContext);
-
     IStrategoTerm parseResult = null;
 
     parser.setUseRecovery(recovery);
@@ -663,7 +663,7 @@
     // read next toplevel decl and stop if that fails
     try {
       parseResult = SDFCommands.parseImplode(
-          currentGrammarTBL,
+          table,
           remainingInput,
           "NextToplevelDeclaration",
           false,
@@ -1429,9 +1429,21 @@
     if (Environment.cacheDir == null)
       return;
     
-    String sdfCache = FileCommands.findFile("sdfCache" + "-" + CACHE_VERSION, Environment.cacheDir);
-    String strCache = FileCommands.findFile("strCache" + "-" + CACHE_VERSION, Environment.cacheDir);
-
+    String cacheVersion = FileCommands.findFile("version", Environment.cacheDir);
+    
+    if (cacheVersion == null || !FileCommands.readFileAsString(cacheVersion).equals(CACHE_VERSION)) {
+      if (cacheVersion == null)
+        cacheVersion = Environment.cacheDir + Environment.sep + "version";
+      
+      for (File f : new File(Environment.cacheDir).listFiles())
+        f.delete();
+      
+      FileCommands.writeToFile(cacheVersion, CACHE_VERSION);
+    }
+    
+    String sdfCache = FileCommands.findFile("sdfCache", Environment.cacheDir);
+    String strCache = FileCommands.findFile("strCache", Environment.cacheDir);
+    
     if (SDFCommands.sdfCache == null && sdfCache != null)
       try {
         log.log("load sdf cache from " + sdfCache);
@@ -1466,16 +1478,23 @@
     if (Environment.cacheDir == null || Environment.rocache)
       return;
     
-    String sdfCache = FileCommands.findFile("sdfCache" + "-" + CACHE_VERSION , Environment.cacheDir);
-    String strCache = FileCommands.findFile("strCache" + "-" + CACHE_VERSION, Environment.cacheDir);
+    String cacheVersion = FileCommands.findFile("version", Environment.cacheDir);
+    if (cacheVersion == null || !FileCommands.readFileAsString(cacheVersion).equals(CACHE_VERSION)) {
+      if (cacheVersion == null)
+        cacheVersion = Environment.cacheDir + Environment.sep + "version";
+      FileCommands.writeToFile(cacheVersion, CACHE_VERSION);
+    }
+    
+    String sdfCache = FileCommands.findFile("sdfCache", Environment.cacheDir);
+    String strCache = FileCommands.findFile("strCache", Environment.cacheDir);
 
     if (sdfCache == null) {
-      sdfCache = Environment.cacheDir + sep + "sdfCache" + "-" + CACHE_VERSION;
+      sdfCache = Environment.cacheDir + sep + "sdfCache";
       FileCommands.createFile(sdfCache);
     }
 
     if (strCache == null) {
-      strCache = Environment.cacheDir + sep + "strCache" + "-" + CACHE_VERSION;
+      strCache = Environment.cacheDir + sep + "strCache";
       FileCommands.createFile(strCache);
     }
     
@@ -1529,7 +1548,7 @@
   }
   
   private synchronized void stopIfInterrupted() throws InterruptedException {
-    if (interrupt) {
+    if (interrupt || monitor.isCanceled()) {
       monitor.setCanceled(true);
       log.log("interrupted " + mainModuleName);
       throw new InterruptedException();

Modified: sugarj/trunk/compiler/org/sugarj/driver/Result.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/Result.java	Thu Jun  2 16:17:28 2011	(r22986)
+++ sugarj/trunk/compiler/org/sugarj/driver/Result.java	Thu Jun  2 18:22:53 2011	(r22987)
@@ -29,6 +29,7 @@
   private Integer sourceFileHash;
   private Set<String> allDependentFiles = new HashSet<String>();
   private boolean failed = false;
+  private String lastParseTable;
 
   private final static Result OUTDATED_RESULT = new Result() {
     @Override
@@ -37,7 +38,7 @@
     }
 
     @Override
-    boolean isUpToDate(int hash) {
+    public boolean isUpToDate(int hash) {
       return false;
     }
   };
@@ -80,7 +81,7 @@
     return isUpToDate(FileCommands.fileHash(inputFile));
   }
   
-  boolean isUpToDate(int inputHash) throws IOException {
+  public boolean isUpToDate(int inputHash) throws IOException {
     if (inputHash != sourceFileHash)
       return false;
     
@@ -210,4 +211,12 @@
   public void setFailed(boolean hasFailed) {
     this.failed = hasFailed;
   }
+  
+  public void setLastParseTable(String parseTable) {
+    this.lastParseTable = parseTable;
+  }
+  
+  public String getLastParseTable() {
+    return lastParseTable;
+  }
 }
\ No newline at end of file

Modified: sugarj/trunk/compiler/org/sugarj/driver/SDFCommands.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/SDFCommands.java	Thu Jun  2 16:17:28 2011	(r22986)
+++ sugarj/trunk/compiler/org/sugarj/driver/SDFCommands.java	Thu Jun  2 18:22:53 2011	(r22987)
@@ -155,7 +155,7 @@
    * @throws BadTokenException 
    * @throws TokenExpectedException 
    */
-  public static ParseTable compile(String sdf, String module, Collection<String> dependentFiles, JSGLRI sdfParser, Context sdfContext, Context makePermissiveContext) throws IOException,
+  public static String compile(String sdf, String module, Collection<String> dependentFiles, JSGLRI sdfParser, Context sdfContext, Context makePermissiveContext) throws IOException,
       InvalidParseTableException, TokenExpectedException, BadTokenException, SGLRException {
     ModuleKey key = getModuleKeyForGrammar(sdf, module, dependentFiles, sdfParser);
     String tbl = lookupGrammarInCache(key);
@@ -167,7 +167,7 @@
     if (tbl != null)
       log.log("use generated table " + tbl);
     
-    return org.strategoxt.imp.runtime.Environment.loadParseTable(tbl);
+    return tbl;
   }
   
   

Modified: sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParser.java
==============================================================================
--- sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParser.java	Thu Jun  2 16:17:28 2011	(r22986)
+++ sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParser.java	Thu Jun  2 18:22:53 2011	(r22987)
@@ -13,11 +13,16 @@
 import org.eclipse.core.runtime.Status;
 import org.eclipse.core.runtime.jobs.Job;
 import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.jsglr.client.ITreeBuilder;
+import org.spoofax.jsglr.client.ParseTable;
+import org.spoofax.jsglr.client.imploder.TermTreeFactory;
+import org.spoofax.jsglr.client.imploder.TreeBuilder;
 import org.spoofax.jsglr.shared.BadTokenException;
 import org.spoofax.jsglr.shared.SGLRException;
 import org.spoofax.jsglr.shared.TokenExpectedException;
 import org.strategoxt.eclipse.ant.StrategoJarAntPropertyProvider;
 import org.strategoxt.imp.runtime.parser.JSGLRI;
+import org.sugarj.driver.ATermCommands;
 import org.sugarj.driver.CommandExecution;
 import org.sugarj.driver.Driver;
 import org.sugarj.driver.Environment;
@@ -37,6 +42,8 @@
   
   private static Map<String, Result> results = new HashMap<String, Result>();
   private Result result;
+  private JSGLRI parser;
+  private String parserTable;
   
   public SugarJParser(JSGLRI parser) {
     super(parser.getParseTable(), parser.getStartSymbol(), parser.getController());
@@ -49,14 +56,41 @@
     
     result = getResult(filename);
 
-    if (result instanceof PendingResult || (doJustReturn() && result.isUpToDate(filename)))
+    if (result instanceof PendingResult)
+      setJustReturn(false);
+    else if (doJustReturn() && result.isUpToDate(input.hashCode())) {
       setJustReturn(false);
+      return result.getSugaredSyntaxTree();
+    }
     else 
       scheduleParse(input, filename);
         
     if (result == null)
       return null;
     
+    String lastParseTable;
+    
+    if (result instanceof PendingResult)
+      lastParseTable = ((PendingResult) result).getResult().getLastParseTable();
+    else
+      lastParseTable = result.getLastParseTable();
+  
+    if (lastParseTable != null && lastParseTable.equals(parserTable))
+      return parser.parse(input, filename);
+    
+    if (lastParseTable != null) {
+      try {
+        ParseTable parseTable = org.strategoxt.imp.runtime.Environment.loadParseTable(lastParseTable);
+        ITreeBuilder builder = new TreeBuilder(new TermTreeFactory(ATermCommands.factory));
+        
+        parser = new JSGLRI(parseTable, "SugarCompilationUnit");
+        parserTable = lastParseTable;
+        parser.getParser().setTreeBuilder(builder);
+        return parser.parse(input, filename);
+      } catch (Exception e) {
+      }
+    }
+    
     if (result instanceof PendingResult)
       return ((PendingResult) result).getResult().getSugaredSyntaxTree();
     
@@ -64,28 +98,37 @@
   }
   
   private synchronized void scheduleParse(final String input, final String filename) {
-    putResult(filename, new PendingResult(getResult(filename)));
+    final Result oldResult = getResult(filename);
+    putResult(filename, new PendingResult(oldResult));
     
     Job parseJob = new Job("SugarJ parser: " + projectRelativePath(filename)) {
       @Override
       protected IStatus run(IProgressMonitor monitor) {
         monitor.beginTask("parse " + projectRelativePath(filename), IProgressMonitor.UNKNOWN);
+        Result result = null;
         try {
-          Result result = runParser(input, filename, monitor);
+          result = runParser(input, filename, monitor);
           putResult(filename, result);
+        } catch (InterruptedException e) {
+          result = null;
+        } catch (Exception e) {
+          org.strategoxt.imp.runtime.Environment.logException(e);
         } finally {
           monitor.done();
-          setJustReturn(true);
-          getController().scheduleParserUpdate(0, false);
+          if (result != null) {
+            setJustReturn(true);
+            getController().scheduleParserUpdate(0, false);
+          } 
+          else
+            putResult(filename, oldResult);
         }
         return Status.OK_STATUS;
       }
     };
-    
     parseJob.schedule();
   }
   
-  private Result runParser(String input, String filename, IProgressMonitor monitor) {
+  private Result runParser(String input, String filename, IProgressMonitor monitor) throws InterruptedException {
     Environment.wocache = false;
 
     Environment.includePath.addAll(includePath);
@@ -116,7 +159,9 @@
     
     try {
       return Driver.compile(input, FileCommands.fileName(filename), filename, monitor);
-    } catch (Throwable e) {
+    } catch (InterruptedException e) {
+      throw e;
+    } catch (Exception e) {
       e.printStackTrace();
       throw new RuntimeException("parsing " + FileCommands.fileName(filename) + " failed", e);
     }

From seba at informatik.uni-marburg.de  Sat Jun  4 14:43:13 2011
From: seba at informatik.uni-marburg.de (Sebastian Erdweg)
Date: Sat, 04 Jun 2011 12:43:13 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r22988 -
	sugarj/trunk/stdlib/org/sugarj/languages
Message-ID: <20110604124313.B33422B8027@mx2.tudelft.nl>

Author: SebastianErdweg
Date: Sat Jun  4 12:43:12 2011
New Revision: 22988
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=22988&sc=1

Log:


Modified:
   sugarj/trunk/stdlib/org/sugarj/languages/SugarJ.def

Modified: sugarj/trunk/stdlib/org/sugarj/languages/SugarJ.def
==============================================================================
--- sugarj/trunk/stdlib/org/sugarj/languages/SugarJ.def	Thu Jun  2 18:22:53 2011	(r22987)
+++ sugarj/trunk/stdlib/org/sugarj/languages/SugarJ.def	Sat Jun  4 12:43:12 2011	(r22988)
@@ -75,6 +75,9 @@
     SugarJLayout? -/- [\/] . [\*]
     SugarJLayout? -/- [\/] . [\/]
 
+  context-free start-symbols
+  	SugarCompilationUnit
+
   context-free syntax
     JavaPackageDec? JavaImportDec* TypeOrSugarDec* -> SugarCompilationUnit {prefer, cons("CompilationUnit")}
     JavaTypeDec                                    -> TypeOrSugarDec       {cons("JavaTypeDec")}

From seba at informatik.uni-marburg.de  Sat Jun  4 14:43:34 2011
From: seba at informatik.uni-marburg.de (Sebastian Erdweg)
Date: Sat, 04 Jun 2011 12:43:34 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r22989 - in
	sugarj/trunk: compiler/org/sugarj/driver
	editor/editor/java/org/sugarj/editor
Message-ID: <20110604124334.E7EFB2B8035@mx2.tudelft.nl>

Author: SebastianErdweg
Date: Sat Jun  4 12:43:33 2011
New Revision: 22989
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=22989&sc=1

Log:
log generated files and remove on recompilation

Modified:
   sugarj/trunk/compiler/org/sugarj/driver/Driver.java
   sugarj/trunk/compiler/org/sugarj/driver/FileCommands.java
   sugarj/trunk/compiler/org/sugarj/driver/Result.java
   sugarj/trunk/compiler/org/sugarj/driver/STRCommands.java
   sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParser.java

Modified: sugarj/trunk/compiler/org/sugarj/driver/Driver.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/Driver.java	Sat Jun  4 12:43:12 2011	(r22988)
+++ sugarj/trunk/compiler/org/sugarj/driver/Driver.java	Sat Jun  4 12:43:33 2011	(r22989)
@@ -11,10 +11,12 @@
 import static org.sugarj.driver.Environment.sep;
 import static org.sugarj.driver.Log.log;
 
+import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
+import java.io.FileReader;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
@@ -95,11 +97,9 @@
   
   private Result driverResult = new Result();
   
-  private String moduleName;
-  private String javaOutDir;
   private String javaOutFile;
   private String relPackageName;
-  private String mainModuleName;
+  private String relativePath;
 
   private String currentGrammarSDF;
   private String currentGrammarModule;
@@ -204,7 +204,7 @@
     Log.log.log(resultCache.size());
   }
   
-  public static Result compile(URI sourceFile, IProgressMonitor monitor) throws IOException, TokenExpectedException, BadTokenException, ParseException, InvalidParseTableException, SGLRException, InterruptedException {
+  public static Result compile(URI sourceFile, String relativePath, IProgressMonitor monitor) throws IOException, TokenExpectedException, BadTokenException, ParseException, InvalidParseTableException, SGLRException, InterruptedException {
     synchronized (currentlyProcessing) {
       // TODO we need better circular dependency handling
       if (currentlyProcessing.contains(sourceFile))
@@ -216,9 +216,7 @@
     
     try {
       String source = FileCommands.readFileAsString(sourceFile.getPath());
-      String moduleName = FileCommands.fileName(sourceFile);
-      
-      res = compile(source, moduleName, sourceFile.getPath(), monitor);
+      res = compile(source, relativePath, sourceFile.getPath(), monitor);
     } finally {
       synchronized (currentlyProcessing) {
         currentlyProcessing.remove(sourceFile);
@@ -230,14 +228,14 @@
     return res;
   }
   
-  public static Result compile(String source, String moduleName, String file, IProgressMonitor monitor) throws IOException, TokenExpectedException, BadTokenException, ParseException, InvalidParseTableException, SGLRException, InterruptedException {
+  public static Result compile(String source, String relativePath, String file, IProgressMonitor monitor) throws IOException, TokenExpectedException, BadTokenException, ParseException, InvalidParseTableException, SGLRException, InterruptedException {
     Driver driver = new Driver();
     Entry<String, Driver> pending = null;
     
     synchronized (Driver.class) {
       pending = getPendingRun(file);
       if (pending != null && !pending.getKey().equals(source)) {
-        log.log("interrupting " + moduleName);
+        log.log("interrupting " + relativePath);
         pending.getValue().interrupt();
       }
 
@@ -253,11 +251,11 @@
     
     if (pending != null) {
       waitForPending(file);
-      return compile(source, moduleName, file, monitor);
+      return compile(source, relativePath, file, monitor);
     }
     
     try {
-      driver.process(source, moduleName, file, monitor);
+      driver.process(source, relativePath, file, monitor);
       storeCaches();
     } finally {
         pendingRuns.remove(file);
@@ -270,10 +268,6 @@
   /**
    * Process the given Extensible Java file.
    * 
-   * @param moduleFileName
-   *        the file to process.
-   * @param outdir
-   *        the directory to write the output into.
    * @throws IOException 
    * @throws SGLRException 
    * @throws InvalidParseTableException 
@@ -282,13 +276,20 @@
    * @throws TokenExpectedException 
    * @throws InterruptedException 
    */
-  private void process(String source, String moduleName, String file, IProgressMonitor monitor) throws IOException, TokenExpectedException, BadTokenException, ParseException, InvalidParseTableException, SGLRException, InterruptedException {
+  private void process(String source, String relativePath, String file, IProgressMonitor monitor) throws IOException, TokenExpectedException, BadTokenException, ParseException, InvalidParseTableException, SGLRException, InterruptedException {
     this.monitor = monitor;
-    log.beginTask("processing", "BEGIN PROCESSING " + moduleName);
+    log.beginTask("processing", "BEGIN PROCESSING " + relativePath);
     boolean success = false;
     try {
-      init(moduleName);
+      relativePath = FileCommands.dropExtension(relativePath);
+      init(relativePath);
       driverResult.setSourceFile(file, source.hashCode());
+      
+      if (relativePath != null) {
+        javaOutFile = Environment.bin + sep + relativePath + ".java";
+        driverResult.setGenerationLog(Environment.bin + sep + relativePath + ".gen");
+        clearGeneratedStuff();
+      }
 
       remainingInput = source;
   
@@ -352,7 +353,7 @@
       success = false;
     }
     finally {
-      log.endTask(success, "done processing " + moduleName, "failed processing " + moduleName);
+      log.endTask(success, "done processing " + relativePath, "failed processing " + relativePath);
       driverResult.setFailed(!success);
     }
   }
@@ -362,7 +363,7 @@
     try {
       List<String> path = new ArrayList<String>(Environment.includePath);
       path.add(StdLib.stdLibDir.getPath());
-      path.add(javaOutDir);
+      path.add(Environment.bin);
       
       driverResult.compileJava(javaOutFile, bin, path, generatedJavaClasses);
     } finally {
@@ -598,9 +599,10 @@
     if (isApplication(toplevelDecl, "PackageDec"))
       processPackageDec(toplevelDecl);
     else {
+      if (relPackageName == null)
+        checkPackageName(toplevelDecl);
       if (javaOutFile == null)
-        javaOutFile = javaOutDir + sep + relPackageNameSep() + mainModuleName + ".java";
-      
+        javaOutFile = Environment.bin + sep + relPackageNameSep() + FileCommands.fileName(driverResult.getSourceFile()) + ".java";
       try {
         if (isApplication(toplevelDecl, "TypeImportDec") || isApplication(toplevelDecl, "TypeImportOnDemandDec")) {
           if (!Environment.atomicImportParsing)
@@ -718,15 +720,31 @@
 
       log.log("The SDF / Stratego package name is '" + relPackageName + "'.");
 
-      javaOutFile =
-          javaOutDir + sep + relPackageNameSep() + mainModuleName + ".java";
+      checkPackageName(toplevelDecl);
       
+      if (javaOutFile == null)
+        javaOutFile = Environment.bin + sep + relPackageNameSep() + FileCommands.fileName(driverResult.getSourceFile()) + ".java";
       driverResult.generateFile(javaOutFile, SDFCommands.prettyPrintJava(toplevelDecl, interp) + "\n");
     } finally {
       log.endTask();
     }
   }
   
+  private void checkPackageName(IStrategoTerm toplevelDecl) {
+    if (relativePath != null) {
+      String packageName = relPackageName == null ? "" : relPackageName.replace('/', '.');
+      
+      int i = relativePath.lastIndexOf('/');
+      String expectedPackage = i >= 0 ? relativePath.substring(0, i) : relativePath;
+      expectedPackage = expectedPackage.replace('/', '.');
+      if (!packageName.equals(expectedPackage))
+        ATermCommands.setErrorMessage(
+            toplevelDecl,
+            "The declared package " + packageName +
+            " does not match the expected package " + expectedPackage + ".");
+    }
+  }
+  
   private void processImportDecs(IStrategoTerm toplevelDecl) throws IOException, TokenExpectedException, BadTokenException, ParseException, InvalidParseTableException, SGLRException {
     List<IStrategoTerm> pendingImports = new ArrayList<IStrategoTerm>();
     pendingImports.add(toplevelDecl);
@@ -799,14 +817,14 @@
           log.log("Need to compile the imported module first ; processing it now.");
           
           try {
-            Result importResult = compile(sourceUri, monitor);
+            Result importResult = compile(sourceUri, modulePath, monitor);
             if (importResult.hasFailed())
               ATermCommands.setErrorMessage(toplevelDecl, "problems while compiling " + importModule);
           } catch (Exception e) {
             ATermCommands.setErrorMessage(toplevelDecl, "problems while compiling " + importModule);
           }
             
-          log.log("CONTINUE PROCESSING'" + moduleName + "'.");
+          log.log("CONTINUE PROCESSING'" + relativePath + "'.");
         }
         
         if (depUri == null)
@@ -1120,14 +1138,11 @@
       driverResult.addEditorService(service);
   }
   
-  private void init(String moduleName) throws FileNotFoundException, IOException, InvalidParseTableException {
-    this.moduleName = moduleName;
-
-    javaOutDir = Environment.bin;
+  private void init(String relativePath) throws FileNotFoundException, IOException, InvalidParseTableException {
     javaOutFile = null; 
     // FileCommands.createFile(tmpOutdir, relModulePath + ".java");
 
-    mainModuleName = moduleName;
+    this.relativePath = relativePath;
 
     currentGrammarSDF = StdLib.initGrammar.getPath();
     currentGrammarModule = StdLib.initGrammarModule;
@@ -1187,7 +1202,7 @@
       
       for (final URI source : allInputFiles) {
         monitor.beginTask("compile " + source.getPath(), IProgressMonitor.UNKNOWN);
-        Result res = compile(source, monitor);
+        Result res = compile(source, null, monitor);
         if (!DriverCLI.processResultCLI(res, source.getPath(), new File(".").getAbsolutePath()))
           throw new RuntimeException("compilation of " + source.getPath() + " failed");
       }
@@ -1550,7 +1565,7 @@
   private synchronized void stopIfInterrupted() throws InterruptedException {
     if (interrupt || monitor.isCanceled()) {
       monitor.setCanceled(true);
-      log.log("interrupted " + mainModuleName);
+      log.log("interrupted " + relativePath);
       throw new InterruptedException();
     }
   }
@@ -1559,4 +1574,15 @@
     stopIfInterrupted();
     monitor.worked(1);
   }
+  
+  private void clearGeneratedStuff() throws IOException {
+    if (driverResult.getGenerationLog() != null && FileCommands.exists(driverResult.getGenerationLog())) {
+      BufferedReader br = new BufferedReader(new FileReader(driverResult.getGenerationLog()));
+      String line;
+      while ((line = br.readLine()) != null)
+        FileCommands.delete(line);
+      br.close();
+      FileCommands.writeToFile(driverResult.getGenerationLog(), "");
+    }
+  }
 }

Modified: sugarj/trunk/compiler/org/sugarj/driver/FileCommands.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/FileCommands.java	Sat Jun  4 12:43:12 2011	(r22988)
+++ sugarj/trunk/compiler/org/sugarj/driver/FileCommands.java	Sat Jun  4 12:43:33 2011	(r22989)
@@ -318,6 +318,15 @@
     
     return null;
   }
+  
+  public static String dropExtension(String file) {
+    int i = file.lastIndexOf('.');
+    
+    if (i > 0)
+      return file.substring(0, i);
+    
+    return file;
+  }
 
   public static void trimQuotes(String file) throws IOException {
     String s = readFileAsString(file);

Modified: sugarj/trunk/compiler/org/sugarj/driver/Result.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/Result.java	Sat Jun  4 12:43:12 2011	(r22988)
+++ sugarj/trunk/compiler/org/sugarj/driver/Result.java	Sat Jun  4 12:43:33 2011	(r22989)
@@ -30,6 +30,7 @@
   private Set<String> allDependentFiles = new HashSet<String>();
   private boolean failed = false;
   private String lastParseTable;
+  private String generationLog;
 
   private final static Result OUTDATED_RESULT = new Result() {
     @Override
@@ -58,10 +59,21 @@
     return allDependentFiles;
   }
   
+  void setGenerationLog(String file) {
+    this.generationLog = file;
+  }
+  
+  String getGenerationLog() {
+    return generationLog;
+  }
+  
   void generateFile(String file, String content) throws IOException {
     FileCommands.writeToFile(file, content);
     generatedFileHashes.put(file, FileCommands.fileHash(file));
     allDependentFiles.add(file);
+    
+    if (generationLog != null)
+      FileCommands.appendToFile(generationLog, file + "\n");
   }
   
   void appendToFile(String file, String content) throws IOException {
@@ -133,6 +145,9 @@
   }
   
   void writeDependencyFile(String dep) throws IOException {
+    if (generationLog != null)
+      FileCommands.appendToFile(generationLog, dep + "\n");
+
     BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(dep));
     
     try {

Modified: sugarj/trunk/compiler/org/sugarj/driver/STRCommands.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/STRCommands.java	Sat Jun  4 12:43:12 2011	(r22988)
+++ sugarj/trunk/compiler/org/sugarj/driver/STRCommands.java	Sat Jun  4 12:43:33 2011	(r22989)
@@ -56,9 +56,6 @@
     
     
     List<String> cmd = new ArrayList<String>(Arrays.asList(new String[] {
-//        "java",
-//        "-Xss4M",
-//        "-jar", toWindowsPath(Environment.strategoxt_jar),
         "-i", toWindowsPath(str),
         "-o", toWindowsPath(java),
         "-m", main,
@@ -154,7 +151,6 @@
     
     log.beginTask("Searching", "Search assimilator in cache");
     try {
-      int h = key.hashCode();
       result = strCache.get(key);
       
       if (result == null || !new File(result).exists())

Modified: sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParser.java
==============================================================================
--- sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParser.java	Sat Jun  4 12:43:12 2011	(r22988)
+++ sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParser.java	Sat Jun  4 12:43:33 2011	(r22989)
@@ -158,7 +158,7 @@
     SugarJConsole.activateConsoleOnce();
     
     try {
-      return Driver.compile(input, FileCommands.fileName(filename), filename, monitor);
+      return Driver.compile(input, projectRelativePath(filename), filename, monitor);
     } catch (InterruptedException e) {
       throw e;
     } catch (Exception e) {

From seba at informatik.uni-marburg.de  Sat Jun  4 16:00:06 2011
From: seba at informatik.uni-marburg.de (Sebastian Erdweg)
Date: Sat, 04 Jun 2011 14:00:06 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r22990 - in
	sugarj/trunk: compiler/org/sugarj/driver
	editor/editor/java/org/sugarj/editor
Message-ID: <20110604140006.7E02D108C009@mx3.tudelft.nl>

Author: SebastianErdweg
Date: Sat Jun  4 14:00:01 2011
New Revision: 22990
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=22990&sc=1

Log:
use Java project source folder and library setup for SugarJ compiler

Modified:
   sugarj/trunk/compiler/org/sugarj/driver/Driver.java
   sugarj/trunk/compiler/org/sugarj/driver/Environment.java
   sugarj/trunk/compiler/org/sugarj/driver/ModuleSystemCommands.java
   sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParseController.java
   sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParser.java

Modified: sugarj/trunk/compiler/org/sugarj/driver/Driver.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/Driver.java	Sat Jun  4 12:43:33 2011	(r22989)
+++ sugarj/trunk/compiler/org/sugarj/driver/Driver.java	Sat Jun  4 14:00:01 2011	(r22990)
@@ -1183,7 +1183,15 @@
     try {
       String[] sources = handleOptions(args);
 
-      ClassLoader loader = new URLClassLoader(new URL[] {new File(Environment.src).toURI().toURL()});
+      if (Environment.sourcePath.isEmpty())
+        Environment.sourcePath.add(".");
+      
+      URL[] urls = new URL[Environment.sourcePath.size()];
+      int i = 0;
+      for (String path : Environment.sourcePath)
+        urls[i++] = new File(path).toURI().toURL();
+      
+      ClassLoader loader = new URLClassLoader(urls);
       
       for (String source : sources)
       {
@@ -1302,7 +1310,7 @@
 
     if (line.hasOption("sourcepath"))
       for (String path : line.getOptionValue("sourcepath").split(Environment.classpathsep))
-        Environment.src = path;
+        Environment.sourcePath.add(path);
  
     if (line.hasOption("d"))
       Environment.bin = line.getOptionValue("d");

Modified: sugarj/trunk/compiler/org/sugarj/driver/Environment.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/Environment.java	Sat Jun  4 12:43:33 2011	(r22989)
+++ sugarj/trunk/compiler/org/sugarj/driver/Environment.java	Sat Jun  4 14:00:01 2011	(r22990)
@@ -24,7 +24,8 @@
   public static String sep = "/";
   public static String classpathsep = File.pathSeparator;
   
-  public static String src = ".";
+  public static Set<String> sourcePath = new HashSet<String>();
+  
   public static String bin = ".";
   public static String cacheDir = null;
   

Modified: sugarj/trunk/compiler/org/sugarj/driver/ModuleSystemCommands.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/ModuleSystemCommands.java	Sat Jun  4 12:43:33 2011	(r22989)
+++ sugarj/trunk/compiler/org/sugarj/driver/ModuleSystemCommands.java	Sat Jun  4 14:00:01 2011	(r22990)
@@ -14,7 +14,6 @@
 import java.net.URL;
 import java.net.URLClassLoader;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Set;
 
 import org.spoofax.interpreter.terms.IStrategoTerm;
@@ -120,10 +119,10 @@
     if (modulePath.startsWith("org/sugarj"))
       return null;
     
-    URI result = searchFile(modulePath, ".sugj", Collections.singleton(Environment.src));
+    URI result = searchFile(modulePath, ".sugj", Environment.sourcePath);
     
     if (result == null)
-      result = searchFile(modulePath, ".java", Collections.singleton(Environment.src));
+      result = searchFile(modulePath, ".java", Environment.sourcePath);
     
     return result;
   }

Modified: sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParseController.java
==============================================================================
--- sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParseController.java	Sat Jun  4 12:43:33 2011	(r22989)
+++ sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParseController.java	Sat Jun  4 14:00:01 2011	(r22990)
@@ -8,6 +8,7 @@
 import org.eclipse.imp.parser.IMessageHandler;
 import org.eclipse.imp.parser.IParseController;
 import org.eclipse.jdt.core.IJavaProject;
+import org.eclipse.jdt.core.IPackageFragmentRoot;
 import org.eclipse.jdt.core.JavaCore;
 import org.eclipse.jdt.core.JavaModelException;
 import org.strategoxt.imp.runtime.Environment;
@@ -25,6 +26,7 @@
 
   private String outputPath;
   private ArrayList<String> includePath;
+  private ArrayList<String> sourcePath;
   
   @Override
   public IParseController getWrapped() {
@@ -38,6 +40,7 @@
         sugarjParser.setProjectPath(projectPath);
         sugarjParser.setOutputPath(outputPath);
         sugarjParser.setIncludePath(includePath);
+        sugarjParser.setSourcePath(sourcePath);
         
         ((SGLRParseController) result).setParser(sugarjParser);
       }
@@ -75,7 +78,18 @@
           
           outputPath = projectPath + File.separator + javaProject.getOutputLocation().makeRelativeTo(project.getRawProject().getFullPath()).toString();
           
+          sourcePath = new ArrayList<String>();
           includePath = new ArrayList<String>();
+          for (IPackageFragmentRoot root : javaProject.getAllPackageFragmentRoots()) {
+            IPath path = root.getPath();
+            boolean externalPath = root.getResource() == null;
+            String p = externalPath ? path.toString() : projectPath + File.separator + path.makeRelativeTo(project.getRawProject().getFullPath());
+            if (root.getKind() == IPackageFragmentRoot.K_SOURCE)
+              sourcePath.add(p);
+            else if (root.getKind() == IPackageFragmentRoot.K_BINARY)
+              includePath.add(p);
+          }
+          
           for (String reqProject : javaProject.getRequiredProjectNames()) {
             IJavaProject reqJavaProject = JavaCore.create(project.getRawProject().getWorkspace().getRoot().getProject(reqProject));
             IPath reqProjectPath = reqJavaProject.getProject().getLocation().makeAbsolute();
@@ -93,6 +107,7 @@
       sugarjParser.setProjectPath(projectPath);
       sugarjParser.setOutputPath(outputPath);
       sugarjParser.setIncludePath(includePath);
+      sugarjParser.setSourcePath(sourcePath);
     }
   }
 }
\ No newline at end of file

Modified: sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParser.java
==============================================================================
--- sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParser.java	Sat Jun  4 12:43:33 2011	(r22989)
+++ sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParser.java	Sat Jun  4 14:00:01 2011	(r22990)
@@ -38,6 +38,7 @@
   private String projectPath;
   private String outputPath;
   private List<String> includePath;
+  private List<String> sourcePath;
   private boolean justReturn;
   
   private static Map<String, Result> results = new HashMap<String, Result>();
@@ -131,11 +132,14 @@
   private Result runParser(String input, String filename, IProgressMonitor monitor) throws InterruptedException {
     Environment.wocache = false;
 
+    assert includePath != null;
     Environment.includePath.addAll(includePath);
     Environment.includePath.add(new StrategoJarAntPropertyProvider().getAntPropertyValue(""));
     
+    assert sourcePath != null;
+    Environment.sourcePath.addAll(sourcePath);
+    
     assert projectPath != null;
-    Environment.src = projectPath;
     Environment.bin = outputPath != null ? outputPath : projectPath;
 
     if (Environment.cacheDir == null)
@@ -180,6 +184,10 @@
     this.includePath = includePath;
   }
 
+  public void setSourcePath(List<String> sourcePath) {
+    this.sourcePath = sourcePath;
+  }
+
   @Override
   public Set<BadTokenException> getCollectedErrors() {
     final Set<BadTokenException> empty = Collections.emptySet();
@@ -209,8 +217,17 @@
   }
   
   private String projectRelativePath(String filename) {
-    if (filename.startsWith(projectPath))
-      return filename.substring(projectPath.length() + 1);
-    return filename;
+    String path = null;
+    for (String s : sourcePath)
+      if (filename.startsWith(s)) {
+        String newPath = filename.substring(s.length() + 1);
+        if (path == null || newPath.length() < path.length())
+          path = newPath;
+      }
+    
+    if (path != null)
+      return path;
+    
+    throw new IllegalStateException("Ressource " + filename + " not inside any source folder.");
   }
 }

From L.C.L.Kats at tudelft.nl  Sat Jun  4 16:26:21 2011
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Sat, 04 Jun 2011 14:26:21 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r22991 -
	sglr-recovery/trunk/permissive-grammars/trans/make-permissive
	spoofax-imp/trunk/org.strategoxt.imp.generator/lib
Message-ID: <20110604142621.4FF042B8027@mx2.tudelft.nl>

Author: LennartKats
Date: Sat Jun  4 14:26:20 2011
New Revision: 22991
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=22991&sc=1

Log:
Use deterministic names for generated sorts in make-permissive

Modified:
   sglr-recovery/trunk/permissive-grammars/trans/make-permissive/insert-sections.astr
   sglr-recovery/trunk/permissive-grammars/trans/make-permissive/make-permissive.astr
   spoofax-imp/trunk/org.strategoxt.imp.generator/lib/make_permissive.jar

Modified: sglr-recovery/trunk/permissive-grammars/trans/make-permissive/insert-sections.astr
==============================================================================
--- sglr-recovery/trunk/permissive-grammars/trans/make-permissive/insert-sections.astr	Sat Jun  4 14:00:01 2011	(r22990)
+++ sglr-recovery/trunk/permissive-grammars/trans/make-permissive/insert-sections.astr	Sat Jun  4 14:26:20 2011	(r22991)
@@ -104,7 +104,7 @@
     where
       (pattern, closinglit) := <split-last> pattern-and-lit
     with
-      openingsort := <newname> "INSERTSTART"
+      openingsort := "INSERTSTART"
 
   def Test is-comment-prod:
     prod([lit(_) | pattern-and-lit], target, _) -> id
@@ -149,7 +149,7 @@
       openingquote.eq(|closingquote);
       openingquote.is-quote-lit
     with
-      openingquotesort := <newname> "INSERTOPENQUOTE"
+      openingquotesort := "INSERTOPENQUOTE"
       
   def id.pattern-allows-newlines =
     fail // TODO: Check if string pattern does not allow newlines?

Modified: sglr-recovery/trunk/permissive-grammars/trans/make-permissive/make-permissive.astr
==============================================================================
--- sglr-recovery/trunk/permissive-grammars/trans/make-permissive/make-permissive.astr	Sat Jun  4 14:00:01 2011	(r22990)
+++ sglr-recovery/trunk/permissive-grammars/trans/make-permissive/make-permissive.astr	Sat Jun  4 14:26:20 2011	(r22991)
@@ -59,6 +59,7 @@
       );
       */
       
+      // TODO: write directly to stream
       sdf-desugar;      
       parenthesize-Sdf2;
       pp-commented-sdf-string;

Modified: spoofax-imp/trunk/org.strategoxt.imp.generator/lib/make_permissive.jar
==============================================================================
Binary file (source and/or target). No diff available.

From L.C.L.Kats at tudelft.nl  Sat Jun  4 17:23:35 2011
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Sat, 04 Jun 2011 15:23:35 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r22992 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder
	strategoxt-java-backend/trunk/java
Message-ID: <20110604152335.CD399CC153@mx4.tudelft.nl>

Author: LennartKats
Date: Sat Jun  4 15:23:34 2011
New Revision: 22992
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=22992&sc=1

Log:
Partial fix for Spoofax/372: Meta (list) variables are not imploded properly

Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/ProductionAttributeReader.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/Tokenizer.java
   strategoxt-java-backend/trunk/java/spoofax-libs.jar

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/ProductionAttributeReader.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/ProductionAttributeReader.java	Sat Jun  4 14:26:20 2011	(r22991)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/ProductionAttributeReader.java	Sat Jun  4 15:23:34 2011	(r22992)
@@ -196,11 +196,9 @@
 	
 	// FIXME: support meta-var constructors
 	public String getMetaVarConstructor(IStrategoAppl rhs) {
-		if (rhs.getSubtermCount() == 1 && varSymFun == rhs.getConstructor()) {
-			if(applAt(rhs, 0).getConstructor() == cfFun) { //FIXME: adhoc fix, correct/complete?
-				rhs=applAt(rhs, 0);
-			}
-			return isIterFun(applAt(rhs, 0).getConstructor())
+		if (varSymFun == rhs.getConstructor()) {
+			rhs = termAt(rhs, 0);
+			return isList(rhs)
 					? "meta-listvar"
 					: "meta-var";
 		}
@@ -341,7 +339,10 @@
 	public boolean isList(IStrategoAppl rhs) {
 		IStrategoAppl details = rhs;
 		
-		if (rhs.getConstructor() == cfFun)
+		if (details.getConstructor() == varsymFun)
+			details = termAt(details, 0);
+		
+		if (details.getConstructor() == cfFun)
 			details = termAt(details, 0);
 		              	
 	  	if (details.getConstructor() == optFun)

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/Tokenizer.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/Tokenizer.java	Sat Jun  4 14:26:20 2011	(r22991)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/Tokenizer.java	Sat Jun  4 15:23:34 2011	(r22992)
@@ -280,6 +280,7 @@
 
 	private void bindAstNode(ISimpleTerm node, int tokenIndex, int endTokenIndex) {
 		assert getTokenizer(node) == this;
+		int tokenCount = getTokenCount(); 
 		
 		// Set ast node for spaces between children and recursively for children
 		Iterator<ISimpleTerm> iterator = SimpleTermVisitor.tryGetListIterator(node); 
@@ -289,7 +290,7 @@
 			int childStart = getLeftToken(child).getIndex();
 			int childEnd = getRightToken(child).getIndex();
 			
-			while (tokenIndex < childStart) {
+			while (tokenIndex < childStart && tokenIndex < tokenCount) {
 				Token token = getTokenAt(tokenIndex++);
 				token.setAstNode(node);
 			}
@@ -299,7 +300,7 @@
 		}
 		
 		// Set ast node for tokens after children
-		while (tokenIndex <= endTokenIndex) {
+		while (tokenIndex <= endTokenIndex && tokenIndex < tokenCount) {
 			Token token = getTokenAt(tokenIndex++);
 			token.setAstNode(node);
 		}

Modified: strategoxt-java-backend/trunk/java/spoofax-libs.jar
==============================================================================
Binary file (source and/or target). No diff available.

From tobivollebregt at gmail.com  Sat Jun  4 18:21:16 2011
From: tobivollebregt at gmail.com (Tobi Vollebregt)
Date: Sat, 04 Jun 2011 16:21:16 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r22993 - in
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax: . lib
Message-ID: <20110604162116.4C64CCC142@mx4.tudelft.nl>

Author: tvo
Date: Sat Jun  4 16:21:15 2011
New Revision: 22993
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=22993&sc=1

Log:
SpoofaxLang: add {SDF, ESV, Stratego}-Stratego concrete syntax embeddings (for TemplateLang)

Added:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/EditorService.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/EmbeddedStratego.sdf
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/EmbeddedStrategoMix.sdf
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Stratego-EditorService.sdf
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Stratego-Sdf2.sdf
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/StrategoStratego.sdf
Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/build.generated.xml
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/build.main.xml
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/EditorService.def

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/build.generated.xml
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/build.generated.xml	Sat Jun  4 15:23:34 2011	(r22992)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/build.generated.xml	Sat Jun  4 16:21:15 2011	(r22993)
@@ -7,7 +7,7 @@
         <target name="spoofaximp.default.jar" depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,java.jar,stratego.jar.helper,sdf2imp,refresh"/>
     
         <!-- Initialization -->
-        <available file="${build}/org/strategoxt/imp/editors/spoofax/strategies/Main.class" property="java.jar.enabled"/>
+        <available file="${src-gen}/org/strategoxt/imp/editors/spoofax/strategies/Main.java" property="java.jar.enabled"/>
         <condition property="java.jar.import" value="-la org.strategoxt.imp.editors.spoofax.strategies" else="">
             <isset property="java.jar.enabled"/>
         </condition>
@@ -19,9 +19,12 @@
         <condition property="externaldefimport" value="-I &quot;${externaldefdir}&quot;" else="">
             <isset property="externaldef"/>
         </condition>
-        <condition property="externaljarimport" value=":${externaljar}" else="">
+        <condition property="externaljarimport1" value=":${externaljar}" else="">
             <isset property="externaljar"/>
         </condition>
+        <condition property="externaljarimport2" value=":${externaljarx}" else="">
+            <isset property="externaljarx"/>
+        </condition>
         <condition property="build.compiler" value="org.eclipse.jdt.core.JDTCompilerAdapter">
             <isset property="eclipse.running"/>
         </condition>
@@ -378,7 +381,7 @@
                 <param name="build.stratego.outputfile" value="${src-gen}/trans/Main.java"/>
                 <param name="build.stratego.extraargs" value="-la java-front ${java.jar.import}"/>
             </antcall>
-            <javac classpath="utils/strategoxt.jar:${src-gen}${externaljarimport}${java.jar.classpath}" srcdir="${src-gen}" includes="trans/**" destdir="${build}" source="1.5" target="1.5" debug="on"/>
+            <javac classpath="utils/strategoxt.jar:${src-gen}${externaljarimport1}${externaljarimport2}${java.jar.classpath}" srcdir="${src-gen}" includes="trans/**" destdir="${build}" source="1.5" target="1.5" debug="on"/>
             <!-- copy imported terms -->
             <copy todir="${build}/trans">
                 <fileset dir="${src-gen}/trans" excludes="**/*.java"/>
@@ -489,9 +492,9 @@
 	        <javac destdir="${build}" source="1.5" target="1.5" debug="on">
 	    		<!-- attribute in javac: srcdir="${src-gen}" -->
 	    		<src path="${src-gen}"/>
-	        	<!-- attribute in javac: classpath="utils/strategoxt.jar:${src-gen}${externaljarimport}${java.jar.classpath}"  -->
+	        	<!-- attribute in javac: classpath="utils/strategoxt.jar:${src-gen}${externaljarimport1}${externaljarimport2}${java.jar.classpath}"  -->
 	        	<classpath>
-	        		<pathelement path="utils/strategoxt.jar:${src-gen}${externaljarimport}${java.jar.classpath}"/> <!-- the path attribute accepts colon- or semicolon-separated lists of locations -->
+	        		<pathelement path="utils/strategoxt.jar:${src-gen}${externaljarimport1}${externaljarimport2}${java.jar.classpath}"/> <!-- the path attribute accepts colon- or semicolon-separated lists of locations -->
 	        		<pathelement location="utils/stratego-debug-runtime.jar"/> <!-- The location attribute specifies a single file or directory relative to the project's base directory (or an absolute filename) -->
 	        		<pathelement location="utils/stratego-debug-runtime-java.jar"/>
 	        	</classpath>

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/build.main.xml
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/build.main.xml	Sat Jun  4 15:23:34 2011	(r22992)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/build.main.xml	Sat Jun  4 16:21:15 2011	(r22993)
@@ -1,13 +1,13 @@
 <?xml version="1.0" encoding="UTF-8" ?>
 
 <project name="SpoofaxLang" default="all">
-        
+
         <!-- Key input modules -->
         <property name="sdfmodule" value="SpoofaxLang"/>
         <property name="metasdfmodule" value="Stratego-SpoofaxLang"/>
         <property name="esvmodule" value="SpoofaxLang"/>
         <property name="strmodule" value="spoofaxlang"/>
-    
+
         <!-- Project directories -->
         <property name="trans" location="trans"/>
         <property name="src-gen" location="editor/java"/>
@@ -16,33 +16,80 @@
         <property name="lib" location="lib"/>
         <property name="build" location="bin"/>
         <property name="dist" location="bin/dist"/>
-        
+
         <!-- Imports -->
         <property name="build.sdf.imports" value="
         	              -Idef &quot;${basedir}/lib/Stratego-Attributes.def&quot;
                         -Idef &quot;${basedir}/lib/SDF.def&quot;
                         -Idef &quot;${basedir}/lib/EditorService.def&quot;"/>
         <property name="build.stratego.args" value="
-                        --library
                         -I &quot;${trans}&quot;
                         -I &quot;${basedir}&quot;
                         -la stratego-lib -la stratego-sglr -la stratego-gpp -la stratego-xtc -la stratego-aterm
         	              -la strc -la stratego-sdf"/>
-        
+
         <!-- Optional: external .def and .jar locations
         <property name="externaldef" location="syntax/${sdfmodule}.def"/>
         <property name="externaljar" value="../lib.jar"/>
         <property name="externaljarflags" value="-la org.lib"/>
         -->
-    
+
         <!-- Environment configuration for command-line builds -->
         <condition property="build.strategoxt.sdf" value="${eclipse.spoofaximp.nativeprefix}" else="">
             <isset property="eclipse.spoofaximp.nativeprefix"/>
         </condition>
         <property name="build.strategoxt.stratego" location="${user.home}/.nix-profile/bin"/>
-    
+
         <import file="build.generated.xml"/>
-    
+
         <!-- Main target -->
-        <target name="all" depends="spoofaximp.default.jar"/>
-    </project>
\ No newline at end of file
+        <target name="all" depends="meta-sdf2table-stratego-sdf2,meta-sdf2table-stratego-esv,meta-sdf2table-strategostratego,spoofaximp.default.jar"/>
+
+        <!-- Target to create -Permissive grammar and parse table for Stratego-Sdf2.def -->
+        <available file="include/Stratego-Sdf2.tbl" property="stratego-sdf2.available"/>
+        <target name="meta-sdf2table-stratego-sdf2" unless="stratego-sdf2.available">
+          <fail unless="eclipse.spoofaximp.jars" message="Property eclipse.spoofaximp.jars must point to the directory containing StrategoMix.def" />
+          <antcall target="pack-sdf.helper">
+            <param name="syntax" value="${lib}" />
+            <param name="sdfmodule" value="Stratego-Sdf2" />
+            <param name="build.sdf.imports" value="-Idef &quot;${eclipse.spoofaximp.jars}/StrategoMix.def&quot; ${build.sdf.imports}" />
+          </antcall>
+          <antcall target="sdf2table">
+            <param name="sdfmodule" value="Stratego-Sdf2" />
+            <param name="build.sdf.imports" value="-Idef &quot;${eclipse.spoofaximp.jars}/StrategoMix.def&quot; ${build.sdf.imports}" />
+          </antcall>
+          <antcall target="meta-sdf2table.helper" />
+        </target>
+
+        <!-- Target to create -Permissive grammar and parse table for Stratego-EditorService.def -->
+        <available file="include/Stratego-EditorService.tbl" property="stratego-esv.available"/>
+        <target name="meta-sdf2table-stratego-esv" unless="stratego-esv.available">
+          <fail unless="eclipse.spoofaximp.jars" message="Property eclipse.spoofaximp.jars must point to the directory containing StrategoMix.def" />
+          <antcall target="pack-sdf.helper">
+            <param name="syntax" value="${lib}" />
+            <param name="sdfmodule" value="Stratego-EditorService" />
+            <param name="build.sdf.imports" value="-Idef &quot;${eclipse.spoofaximp.jars}/StrategoMix.def&quot; ${build.sdf.imports}" />
+          </antcall>
+          <antcall target="sdf2table">
+            <param name="sdfmodule" value="Stratego-EditorService" />
+            <param name="build.sdf.imports" value="-Idef &quot;${eclipse.spoofaximp.jars}/StrategoMix.def&quot; ${build.sdf.imports}" />
+          </antcall>
+          <antcall target="meta-sdf2table.helper" />
+        </target>
+
+      	<!-- Target to create -Permissive grammar and parse table for Stratego-EditorService.def -->
+        <available file="include/StrategoStratego.tbl" property="strategostratego.available"/>
+        <target name="meta-sdf2table-strategostratego" unless="strategostratego.available">
+          <fail unless="eclipse.spoofaximp.jars" message="Property eclipse.spoofaximp.jars must point to the directory containing StrategoMix.def" />
+          <antcall target="pack-sdf.helper">
+            <param name="syntax" value="${lib}" />
+            <param name="sdfmodule" value="StrategoStratego" />
+            <param name="build.sdf.imports" value="-Idef &quot;${eclipse.spoofaximp.jars}/StrategoMix.def&quot; ${build.sdf.imports}" />
+          </antcall>
+          <antcall target="sdf2table">
+            <param name="sdfmodule" value="StrategoStratego" />
+            <param name="build.sdf.imports" value="-Idef &quot;${eclipse.spoofaximp.jars}/StrategoMix.def&quot; ${build.sdf.imports}" />
+          </antcall>
+          <antcall target="meta-sdf2table.helper" />
+        </target>
+</project>

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/EditorService.def
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/EditorService.def	Sat Jun  4 15:23:34 2011	(r22992)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/EditorService.def	Sat Jun  4 16:21:15 2011	(r22993)
@@ -17,7 +17,7 @@
   	
   	"pp-table" ":" StrategoCall -> SemanticRule {cons("PPTable")}
   	"pretty-print" ":" StrategoCall -> SemanticRule {cons("PrettyPrint")}
-    "refactoring"  ":" String "=" SemanticNode+ "->" StrategoCall BuilderOption* -> SemanticRule {cons("Refactoring")}
+    "refactoring"  SemanticNode* ":" String "="   StrategoCall BuilderOption* -> SemanticRule {cons("Refactoring")}
 
 module BuildersService
 
@@ -60,7 +60,7 @@
     CompletionPart CompletionAnno
 
   syntax
-  
+
     "completions" <SectionName-LEX> <LAYOUT?-CF> <SemanticRule*-CF> -> <Section-CF> {cons("Completions")}
 
     "completions" -> <ReservedName-CF>
@@ -73,23 +73,28 @@
 
     "identifier" "lexical" ":" PropertyValue -> SemanticRule {cons("IdentifierLexical")}
 
-    "completion" "keyword" ":" PropertyValue CompletionAnno -> SemanticRule {cons("CompletionKeyword")}
-    
-    "completion" "template" ":" CompletionPart CompletionPart* CompletionAnno -> SemanticRule {cons("CompletionTemplate")}
-    
+    "completion" "keyword" ":" PropertyValue OptCompletionAnno -> SemanticRule {cons("CompletionKeyword")}
+
     %% Deprecated: conflicts with content completion
-    "completion" "template" ":" Id CompletionPart+ CompletionAnno -> SemanticRule {cons("CompletionTemplate"), avoid, deprecated("Add quotes to the starting literal")}
-    
-    "completion" "template" ":" Sort "=" CompletionPart CompletionPart* CompletionAnno -> SemanticRule {cons("CompletionTemplateWithSort")}
-    
+    "completion" "template" ":" Id CompletionPart+ OptCompletionAnno -> SemanticRule {cons("CompletionTemplate"), avoid, deprecated("Add quotes to the starting literal")}
+
+    %% Deprecated: replaced by CompletionTemplateEx
+    "completion" "template" ":" Sort "=" CompletionPart CompletionPart* OptCompletionAnno -> SemanticRule {cons("CompletionTemplateWithSort"), avoid, deprecated("Move the sort before ':' and remove '='")}
+
     %% Used as content completion triggers
-    "completion" "template" ":" PropertyValue CompletionPart* CompletionAnno -> SemanticRule {cons("CompletionTemplate"), recover, avoid}
-    "completion" "template" ":" Sort "=" PropertyValue CompletionPart* CompletionAnno -> SemanticRule {cons("CompletionTemplateWithSort"), recover, avoid}
+    %% "completion" "template" PropertyValue CompletionPart* OptCompletionAnno -> SemanticRule {cons("CompletionTemplate"), recover, avoid}
+    "completion" "template" Sort* ":" PropertyValue CompletionPart* CompletionAnno* -> SemanticRule {cons("CompletionTemplateEx"), recover, avoid}
+
+    "completion" "trigger" ":" PropertyValue OptCompletionAnno -> SemanticRule {cons("CompletionTrigger")}
+
+    %% New completion template
+    "completion" "template" Sort* ":" CompletionPrefix CompletionPart+ CompletionAnno* -> SemanticRule {cons("CompletionTemplateEx")}
+
+               -> CompletionPrefix {cons("NoCompletionPrefix")}
+    String "=" -> CompletionPrefix {cons("CompletionPrefix")}
 
-    "completion" "trigger" ":" PropertyValue CompletionAnno -> SemanticRule {cons("CompletionTrigger")}
-  
   context-free syntax
-  
+
     "completions" -> StrategoCall {reject}
     "completion"  -> StrategoCall {reject}
     "identifier"  -> StrategoCall {reject}
@@ -97,26 +102,32 @@
     "builder"     -> StrategoCall {reject}
     "occurrence"  -> StrategoCall {reject}
     ReservedName  -> StrategoCall {reject}
-    
+
     String      -> CompletionPart
     Placeholder -> CompletionPart {cons("Placeholder")}
+    "(cursor)"  -> CompletionPart {cons("Cursor")}
+    PlaceholderWithSortPrefix Id ">" -> CompletionPart {cons("PlaceholderWithSort")}
+
+                   -> OptCompletionAnno {cons("None")}
+    CompletionAnno -> OptCompletionAnno
 
-                 -> CompletionAnno {cons("None")}
     "(disabled)" -> CompletionAnno {cons("Disable")}
     "(disable)"  -> CompletionAnno {cons("Disable"), deprecated("Use (disabled) instead")}
     "(blank)"    -> CompletionAnno {cons("Blank")}
+    "(linked)"   -> CompletionAnno {cons("Linked")}
     "(blank)"    -> PropertyValue {reject}
     "(disable)"  -> PropertyValue {reject}
+    "(linked)"   -> PropertyValue {reject}
     "completion" -> PropertyValue {reject}
     "template"   -> PropertyValue {reject}
     "trigger"    -> PropertyValue {reject}
     "identifier" -> PropertyValue {reject}
 
   lexical syntax
-    
+
+    "<" PlaceholderChar* ":" -> PlaceholderWithSortPrefix
     "<" PlaceholderChar* ">" -> Placeholder
-    ~[\>\n]                  -> PlaceholderChar
-    
+    ~[\:\>\n]                -> PlaceholderChar
 
 
 module ReferencesService

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/EditorService.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/EditorService.str	Sat Jun  4 16:21:15 2011	(r22993)
@@ -0,0 +1,149 @@
+module EditorService
+
+signature
+  constructors
+    ImportRenamed              : ModuleName * Id -> Import
+    Import                     : ModuleName -> Import
+    NoImports                  : Imports
+    Imports                    : List(Import) -> Imports
+    Module                     : ModuleName * Imports * List(Section) -> Module
+                               : String -> ModuleName
+    Source                     : BuilderOption
+    Cursor                     : BuilderOption
+    Meta                       : BuilderOption
+    Persistent                 : BuilderOption
+    RealTime                   : BuilderOption
+    OpenEditor                 : BuilderOption
+    Linked                     : CompletionAnno
+    Blank                      : CompletionAnno
+    Disable                    : CompletionAnno
+                               : CompletionAnno -> OptCompletionAnno
+    None                       : OptCompletionAnno
+    PlaceholderWithSort        : PlaceholderWithSortPrefix * Id -> CompletionPart
+    Cursor                     : CompletionPart
+    Placeholder                : Placeholder -> CompletionPart
+                               : String -> CompletionPart
+    CompletionPrefix           : String -> CompletionPrefix
+    NoCompletionPrefix         : CompletionPrefix
+                               : String -> Placeholder
+                               : String -> PlaceholderWithSortPrefix
+                               : String -> AttributeId
+                               : Id -> AttributeId
+                               : NoColor -> MaybeColor
+                               : Color -> MaybeColor
+    NoColor                    : NoColor
+    ColorRGB                   : Int * Int * Int -> Color
+    ColorDefault               : Color
+    BOLD_ITALIC                : Font
+    ITALIC                     : Font
+    BOLD                       : Font
+    NORMAL                     : Font
+    TK_UNKNOWN                 : TokenKindName
+    TK_ERROR                   : TokenKindName
+    TK_VAR                     : TokenKindName
+    TK_OPERATOR                : TokenKindName
+    TK_KEYWORD                 : TokenKindName
+    TK_STRING                  : TokenKindName
+    TK_LAYOUT                  : TokenKindName
+    TK_NUMBER                  : TokenKindName
+    TK_IDENTIFIER              : TokenKindName
+    Literal                    : Id -> ColorNode
+    Token                      : TokenKindName -> ColorNode
+                               : Node -> ColorNode
+    AttributeRef               : AttributeId -> Attribute
+    Attribute                  : Color * MaybeColor * Font -> Attribute
+    ColorDef                   : AttributeId * Attribute -> ColorRule
+    ColorRuleNamed             : ColorNode * String * Attribute -> ColorRule
+    ColorRuleAllNamed          : ColorNode * String * Attribute -> ColorRule
+    ColorRule                  : ColorNode * Attribute -> ColorRule
+    ColorRuleAll               : ColorNode * Attribute -> ColorRule
+    OutlineRule                : Node -> OutlineRule
+    None                       : FoldingAnno
+    Folded                     : FoldingAnno
+    Disable                    : FoldingAnno
+    FoldRuleAll                : Node * FoldingAnno -> FoldingRule
+    FoldRule                   : Node * FoldingAnno -> FoldingRule
+    IndentDef                  : PropertyValue -> IndentDef
+    FenceDef                   : PropertyValue * PropertyValue -> FenceDef
+    NoContinuation             : NoContinuation
+    BlockCommentDef            : PropertyValue * NoContinuation * PropertyValue -> BlockCommentDef
+    BlockCommentDef            : PropertyValue * PropertyValue * PropertyValue -> BlockCommentDef
+    IdentifierLexical          : PropertyValue -> LanguageProperty
+    IndentDefs                 : List(IndentDef) -> LanguageProperty
+    FenceDefs                  : List(FenceDef) -> LanguageProperty
+    BlockCommentDefs           : BlockCommentDef -> LanguageProperty
+    LineCommentPrefix          : PropertyValue -> LanguageProperty
+    UnmanagedTablePrefix       : Id -> LanguageProperty
+    Aliases                    : PropertyValues -> LanguageProperty
+    Extends                    : PropertyValues -> LanguageProperty
+    URL                        : URL -> LanguageProperty
+    StartSymbols               : PropertyValues -> LanguageProperty
+    StartSymbols               : List(Sort) -> LanguageProperty
+    TableProvider              : StrategoCall -> LanguageProperty
+    Table                      : PropertyValue -> LanguageProperty
+    Description                : PropertyValue -> LanguageProperty
+    Extensions                 : PropertyValues -> LanguageProperty
+    LanguageId                 : PropertyValue -> LanguageProperty
+    LanguageName               : PropertyValue -> LanguageProperty
+    Values                     : List(PropertyValue) -> PropertyValues
+                               : String -> URL
+                               : String -> PropertyValue
+                               : String -> PropertyValue
+    Refactorings               : String * List(SemanticRule) -> Section
+    Builders                   : String * List(SemanticRule) -> Section
+    Completions                : String * List(SemanticRule) -> Section
+    References                 : String * List(SemanticRule) -> Section
+    Colorer                    : String * List(ColorRule) -> Section
+    Outliner                   : String * List(OutlineRule) -> Section
+    Folding                    : String * List(FoldingRule) -> Section
+    Language                   : String * List(LanguageProperty) -> Section
+    None                       : OnSaveAnno
+    Attribute                  : StrategoId -> StrategoCall
+    Strategy                   : StrategoId -> StrategoCall
+    Refactoring                : List(SemanticNode) * String * StrategoCall * List(BuilderOption) -> SemanticRule
+    PrettyPrint                : StrategoCall -> SemanticRule
+    PPTable                    : StrategoCall -> SemanticRule
+    BuilderCaption             : PropertyValue -> SemanticRule
+    Builder                    : String * StrategoCall * List(BuilderOption) -> SemanticRule
+    SemanticObserver           : StrategoCall -> SemanticRule
+    CompletionTemplateEx       : List(Sort) * CompletionPrefix * List(CompletionPart) * List(CompletionAnno) -> SemanticRule
+    CompletionTrigger          : PropertyValue * OptCompletionAnno -> SemanticRule
+    CompletionTemplateEx       : List(Sort) * PropertyValue * List(CompletionPart) * List(CompletionAnno) -> SemanticRule
+    CompletionTemplateWithSort : Sort * CompletionPart * List(CompletionPart) * OptCompletionAnno -> SemanticRule
+    CompletionTemplate         : Id * List(CompletionPart) * OptCompletionAnno -> SemanticRule
+    CompletionKeyword          : PropertyValue * OptCompletionAnno -> SemanticRule
+    IdentifierLexical          : PropertyValue -> SemanticRule
+    CompletionProposer         : StrategoCall -> SemanticRule
+    OccurrenceRule             : SemanticNode * StrategoCall -> SemanticRule
+    HoverRule                  : SemanticNode * StrategoCall -> SemanticRule
+    ReferenceRule              : SemanticNode * StrategoCall -> SemanticRule
+    ReferenceHoverRule         : SemanticNode * StrategoCall * StrategoCall -> SemanticRule
+    OnSave                     : StrategoCall * OnSaveAnno -> SemanticRule
+    SemanticProvider           : PropertyValue -> SemanticRule
+                               : Node -> SemanticNode
+                               : String -> SemanticNode
+                               : String -> StrategoId
+    SortAndConstructor         : Sort * ConstructorId -> Node
+                               : Constructor -> Node
+                               : Sort -> Node
+    Constructor                : Id -> ConstructorId
+    ConstructorOnly            : ConstructorId -> Constructor
+    String                     : STRING -> String
+    ListSort                   : Id -> Sort
+    Sort                       : Id -> Sort
+                               : String -> STRING
+                               : String -> Int
+                               : String -> Id
+
+
+signature
+  constructors
+    Some : a -> Option(a)
+    None : Option(a)
+
+
+signature
+  constructors
+    Cons : a * List(a) -> List(a)
+    Nil  : List(a)
+    Conc : List(a) * List(a) -> List(a)

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/EmbeddedStratego.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/EmbeddedStratego.sdf	Sat Jun  4 16:21:15 2011	(r22993)
@@ -0,0 +1,171 @@
+module EmbeddedStratego [E1 E2]
+imports Stratego
+exports
+  context-free syntax
+
+              "|[" Module "]|" -> E1 {cons("ToTerm"),prefer}
+    "Module"  "|[" Module "]|" -> E1 {cons("ToTerm")}
+
+              "|[" Decl   "]|" -> E1 {cons("ToTerm")}
+              "|[" Sdecl  "]|" -> E1 {cons("ToTerm")}
+
+              "|[" Opdecl "]|" -> E1 {cons("ToTerm")}
+    "Constr"  "|[" Opdecl "]|" -> E1 {cons("ToTerm")}
+
+              "|[" Type   "]|" -> E1 {cons("ToTerm")}
+    "Type"    "|[" Type   "]|" -> E1 {cons("ToTerm")}
+
+    "Sort"    "|[" Sort   "]|" -> E1 {cons("ToTerm")}
+
+              "|[" Term   "]|" -> E1 {cons("ToTerm")}
+    "Term"    "|[" Term   "]|" -> E1 {cons("ToTerm")}
+
+              "|[" Def    "]|" -> E1 {cons("ToTerm")}
+    "Def"     "|[" Def    "]|" -> E1 {cons("ToTerm")}
+
+             "|[" Rule      "]|" -> E1 {cons("ToTerm")}
+    "Rule"   "|[" Rule      "]|" -> E1 {cons("ToTerm")}
+             "|[" StratRule "]|" -> E1 {cons("ToTerm")}
+
+               "|[" Strategy "]|" -> E1 {cons("ToTerm")}
+    "Strat"    "|[" Strategy "]|" -> E1 {cons("ToTerm")}
+    "Strategy" "|[" Strategy "]|" -> E1 {cons("ToTerm")}
+
+    "O"        "|[" Overlay  "]|" -> E1 {cons("ToTerm")}
+    "Overlay"  "|[" Overlay  "]|" -> E1 {cons("ToTerm")}
+
+    "Typedid"    "|[" Typedid    "]|" -> E1 {cons("ToTerm")}
+    "DynRuleDef" "|[" DynRuleDef "]|" -> E1 {cons("ToTerm")}
+
+  context-free syntax
+    "~"         E2 -> ModName          {cons("FromTerm")}
+
+    "~"         E2 -> Term             {cons("FromTerm")}
+    "~term:"    E2 -> Term             {cons("FromTerm")}
+    %%"~term*:" E2 -> {Term ","}*      {cons("FromTerm")}
+    "~term*:"   E2 -> {Term ","}+      {cons("FromTerm")}
+    "~"         E2 -> {ID   ","}+      {cons("FromTerm")}
+
+    "~"         E2 -> Strategy         {cons("FromTerm")}
+    "~strat:"   E2 -> Strategy         {cons("FromTerm")}
+    "~*"        E2 -> {Strategy ","}+  {cons("FromTerm")}
+    "~strat*:"  E2 -> {Strategy ","}+  {cons("FromTerm")}
+
+    "~srt:"     E2 -> Sort {cons("FromTerm")}
+    "~srtvar:"  E2 -> LCID {cons("FromTerm")}
+    "~srtid:"   E2 -> UCID {cons("FromTerm")}
+
+    "~id:"    E2 -> Id     {cons("FromTerm")}
+    "~int:"   E2 -> Int    {cons("FromTerm")}
+    "~str:"   E2 -> String {cons("FromTerm")}
+
+    Id "/" Id -> Id {cons("ManglePrefix")}
+    Id "\\" Id -> Id {cons("MangleSuffix")}
+
+    "~"   E2 -> Def       {cons("FromTerm")}
+    "~*"  E2 -> Def+      {cons("FromTerm")}
+
+    "~*"  E2 -> Opdecl+      {cons("FromTerm")}
+    "~*"  E2 -> {Type "*"}+  {cons("FromTerm")}
+
+    "~*"          E2 -> {Typedid ","}+   {cons("FromTerm")}
+    "~typed-id*:" E2 -> {Typedid ","}+   {cons("FromTerm")}
+
+  %%%
+   %% Hacks
+   %%
+   %% Why are these hacks nessary? What do they do?
+   %%%
+  context-free syntax
+    "<" Strategy ">" -> StrategyAngle {bracket}
+    "(" Strategy ")" -> Strategy      {bracket,prefer}
+
+%%%
+ %% Identifiers
+ %%%
+
+  variables
+    [xyzfglc][0-9\']*       -> Id       {prefer}
+    [xyzfgl][0-9\']*  "*"   -> {Id ","}+ {prefer}
+    "xs"[0-9\']*            -> {Id ","}+ {prefer,obsolete}
+
+    [xyzfgl][0-9\']*  "*"   -> {ID ","}+ {prefer}
+
+%%%
+ %% Terms
+ %%%
+
+  variables
+    TermMetaVar     -> Term        {prefer}
+    TermListMetaVar -> {Term ","}+ {prefer}
+    TermListMetaVar -> {Term ","}+ {prefer,obsolete}
+
+  lexical syntax
+    [t][0-9\']*      -> TermMetaVar
+    "t:"Id           -> TermMetaVar
+    [t][0-9\']*  "*" -> TermListMetaVar
+    "ts"[0-9\']*     -> TermListMetaVar
+
+    TermMetaVar      -> MetaVar
+    TermListMetaVar  -> MetaVar
+
+%%%
+ %% Cleanup
+ %%%
+
+  variables
+    "str"[0-9\']* -> String
+
+  lexical syntax
+    "str"[0-9\']* -> Id {reject}
+
+  variables
+    "s"[0-9\']*           -> Strategy {prefer}
+    "ss"[0-9\']*          -> {Strategy ","}+ {prefer,obsolete}
+    "s"[0-9\']*   "*"     -> {Strategy ","}+ {prefer}
+
+    [r][0-9\']*           -> Rule {prefer}
+
+    "rd"[0-9\']*          -> RuleDef {prefer}
+    "rd"[0-9\']*  "*"     -> RuleDef* {prefer}
+
+    %% "a"[0-9\']*           -> Typedid        {prefer}
+    %% "a"[0-9\']*   "*"     -> {Typedid ","}+ {prefer}
+    %% "as"[0-9\']*          -> {Typedid ","}+ {prefer,obsolete}
+
+    "tp"[0-9\']*          -> Type
+    "tp"[0-9\']*  "*"     -> {Type "*"}+
+
+    "srt" [0-9\']*        -> Sort         {prefer}
+    "srt" [0-9\']* "*"    -> {Sort ","}*  {prefer}
+    "srt" [xyz] [0-9\']*  -> UCID         {prefer}
+
+    "M"   [0-9\']*        -> ModName {prefer}
+
+    "sc" [0-9\']*         -> SwitchCase {prefer}
+    "sc" [0-9\']* "*"     -> SwitchCase* {prefer}
+
+  variables
+    "sc" [0-9\']*         -> DynRuleScopeId        {prefer}
+    "sc" [0-9\']* "*"     -> {DynRuleScopeId ","}+ {prefer}
+
+    "dr" [0-9\']*         -> DynRuleId {prefer}
+
+    "drd"[0-9\']*         -> DynRuleDef {prefer}
+    "drd"[0-9\']*  "*"    -> DynRuleDef+ {prefer}
+
+%%%
+ %%
+ %% Disambiguation
+ %%%
+
+  lexical syntax
+    MetaVar -> Id  {reject}
+    MetaVar -> LId {reject}
+
+    "xs"[0-9\']*    -> Id  {reject}
+    [s][0-9\']*     -> Id  {reject}
+    "ss"[0-9\']*    -> Id  {reject}
+    [r][0-9\']*     -> Id  {reject}
+    %%  "a"[0-9\']*    -> Id  {reject}
+    %% "as"[0-9\']*    -> Id  {reject}

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/EmbeddedStrategoMix.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/EmbeddedStrategoMix.sdf	Sat Jun  4 16:21:15 2011	(r22993)
@@ -0,0 +1,76 @@
+module EmbeddedStrategoMix[Ctx0 E1 E2]
+imports EmbeddedStratego[E1 E2]
+          [ MetaVar            => MetaVar[[Ctx0]]
+            TermListMetaVar    => TermListMetaVar[[Ctx0]]
+            TermMetaVar        => TermMetaVar[[Ctx0]]
+            RuleNames          => RuleNames[[Ctx0]]
+            RuleDec            => RuleDec[[Ctx0]]
+            DynRuleScopeId     => DynRuleScopeId[[Ctx0]]
+            DynRuleId          => DynRuleId[[Ctx0]]
+            DynRuleDef         => DynRuleDef[[Ctx0]]
+            ScopeLabels        => ScopeLabels[[Ctx0]]
+            RuleCond           => RuleCond[[Ctx0]]
+            Rule               => Rule[[Ctx0]]
+            RuleDef            => RuleDef[[Ctx0]]
+            Overlay            => Overlay[[Ctx0]]
+            SwitchCase         => SwitchCase[[Ctx0]]
+            StrategyCurly      => StrategyCurly[[Ctx0]]
+            StrategyAngle      => StrategyAngle[[Ctx0]]
+            Kind               => Kind[[Ctx0]]
+            LID                => LID[[Ctx0]]
+            ImportModName      => ImportModName[[Ctx0]]
+            Decl               => Decl[[Ctx0]]
+            Module             => Module[[Ctx0]]
+            StrategyParen      => StrategyParen[[Ctx0]]
+            Typedid            => Typedid[[Ctx0]]
+            Anno               => Anno[[Ctx0]]
+            EmptyId            => EmptyId[[Ctx0]]
+            StrategyDef        => StrategyDef[[Ctx0]]
+            SVar               => SVar[[Ctx0]]
+            Def                => Def[[Ctx0]]
+            Type               => Type[[Ctx0]]
+            RetType            => RetType[[Ctx0]]
+            ArgType            => ArgType[[Ctx0]]
+            FunType            => FunType[[Ctx0]]
+            ConstType          => ConstType[[Ctx0]]
+            Opdecl             => Opdecl[[Ctx0]]
+            Sort               => Sort[[Ctx0]]
+            Sdecl              => Sdecl[[Ctx0]]
+            Wld                => Wld[[Ctx0]]
+            ID                 => ID[[Ctx0]]
+            Var                => Var[[Ctx0]]
+            CharChar           => CharChar[[Ctx0]]
+            Char               => Char[[Ctx0]]
+            Padding            => Padding[[Ctx0]]
+            Dollar4            => Dollar4[[Ctx0]]
+            QuotedBracket4     => QuotedBracket4[[Ctx0]]
+            StringQuotedChars4 => StringQuotedChars4[[Ctx0]]
+            StringQuotedPart4  => StringQuotedPart4[[Ctx0]]
+            Dollar3            => Dollar3[[Ctx0]]
+            QuotedBracket3     => QuotedBracket3[[Ctx0]]
+            StringQuotedChars3 => StringQuotedChars3[[Ctx0]]
+            StringQuotedPart3  => StringQuotedPart3[[Ctx0]]
+            Dollar2            => Dollar2[[Ctx0]]
+            QuotedBracket2     => QuotedBracket2[[Ctx0]]
+            StringQuotedChars2 => StringQuotedChars2[[Ctx0]]
+            StringQuotedPart2  => StringQuotedPart2[[Ctx0]]
+            Dollar1            => Dollar1[[Ctx0]]
+            QuotedBracket1     => QuotedBracket1[[Ctx0]]
+            StringQuotedChars1 => StringQuotedChars1[[Ctx0]]
+            StringQuotedPart1  => StringQuotedPart1[[Ctx0]]
+            StringQuotation    => StringQuotation[[Ctx0]]
+            StrChar            => StrChar[[Ctx0]]
+            String             => String[[Ctx0]]
+            Real               => Real[[Ctx0]]
+            Int                => Int[[Ctx0]]
+            Keyword            => Keyword[[Ctx0]]
+            UCID               => UCID[[Ctx0]]
+            LCID               => LCID[[Ctx0]]
+            LId                => LId[[Ctx0]]
+            Id                 => Id[[Ctx0]]
+            ModNamePart        => ModNamePart[[Ctx0]]
+            ModName            => ModName[[Ctx0]]
+            PreTerm            => PreTerm[[Ctx0]]
+            Term               => Term[[Ctx0]]
+            StrategyMid        => StrategyMid[[Ctx0]]
+            Strategy           => Strategy[[Ctx0]] ]

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Stratego-EditorService.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Stratego-EditorService.sdf	Sat Jun  4 16:21:15 2011	(r22993)
@@ -0,0 +1,72 @@
+%% Adapted from org.strategoxt.imp.generator/src/syntax/Stratego-Java-EditorService.sdf
+%% Removed Java imports
+%% Added QuotedTerms -> CompletionPart+ production
+%% Added "~anno:" Term[[StrategoHost]] -> CompletionAnno production
+%% Removed QuotedTerm -> CompletionPart
+
+module Stratego-EditorService
+imports
+  EditorService
+  StrategoMix[StrategoHost]
+
+exports
+  context-free start-symbols Module[[StrategoHost]]
+
+  sorts
+    QuotedTerm
+    QuotedTerms
+
+  context-free syntax
+
+    %% (Anti-)quotations
+    "descriptor" "|[" Module "]|" -> Term[[StrategoHost]] {cons("ToMetaExpr")}
+
+                 "|[" Module "]|" -> Term[[StrategoHost]] {cons("ToMetaExpr")}
+
+    "descriptor" "|[" OutlineRule  "]|" -> Term[[StrategoHost]] {cons("ToMetaExpr")}
+    "descriptor" "|[" ColorRule    "]|" -> Term[[StrategoHost]] {cons("ToMetaExpr")}
+    "descriptor" "|[" FoldingRule  "]|" -> Term[[StrategoHost]] {cons("ToMetaExpr"), avoid}
+    "descriptor" "|[" SemanticRule "]|" -> Term[[StrategoHost]] {cons("ToMetaExpr")}
+
+                 "|[" OutlineRule  "]|" -> Term[[StrategoHost]] {cons("ToMetaExpr")}
+                 "|[" ColorRule    "]|" -> Term[[StrategoHost]] {cons("ToMetaExpr")}
+                 "|[" FoldingRule  "]|" -> Term[[StrategoHost]] {cons("ToMetaExpr"), avoid}
+                 "|[" SemanticRule "]|" -> Term[[StrategoHost]] {cons("ToMetaExpr")}
+
+    "descriptor" "|[" Section "]|" -> Term[[StrategoHost]] {cons("ToMetaExpr")}
+                 "|[" Section "]|" -> Term[[StrategoHost]] {cons("ToMetaExpr")}
+
+    QuotedTerm -> Id {cons("FromMetaExpr"), avoid}
+    QuotedTerm -> PropertyValue {cons("FromMetaExpr"), avoid}
+    QuotedTerm -> URL {cons("FromMetaExpr"), avoid}
+    QuotedTerm -> ModuleName {cons("FromMetaExpr")}
+    QuotedTerm -> Color {cons("FromMetaExpr")}
+    QuotedTerm -> Font  {cons("FromMetaExpr")}
+    QuotedTerm -> SectionName {cons("FromMetaExpr")}
+    QuotedTerm -> SemanticRule {cons("FromMetaExpr"), avoid}
+    %% QuotedTerm -> CompletionPart {cons("FromMetaExpr")}
+    QuotedTerm -> Section {cons("FromMetaExpr")}
+    QuotedTerm -> String {cons("FromMetaExpr")}
+
+    QuotedTerms -> OutlineRule*   {cons("FromMetaExpr")}
+    QuotedTerms -> ColorRule*     {cons("FromMetaExpr")}
+    QuotedTerms -> FoldingRule*   {cons("FromMetaExpr")}
+    QuotedTerms -> PropertyValues {cons("FromMetaExpr")}
+    QuotedTerms -> SemanticRule*  {cons("FromMetaExpr")}
+    QuotedTerms -> CompletionPart+ {cons("FromMetaExpr")}
+    QuotedTerms -> Section*        {cons("FromMetaExpr")}
+
+    "~"  Term[[StrategoHost]] -> QuotedTerm  {bracket}
+    "~*" Term[[StrategoHost]] -> QuotedTerms {bracket}
+
+    "~sort:" Term[[StrategoHost]] -> Sort {cons("FromMetaExpr"), prefer}
+    "~anno:" Term[[StrategoHost]] -> CompletionAnno {cons("FromMetaExpr"), prefer}
+
+    %% Stratego applications as anti-quotation
+    "<" Strategy[[StrategoHost]] ">" Term[[StrategoHost]] -> QuotedTerm {cons("App")}
+    StrategyAngle[[StrategoHost]]                         -> QuotedTerm {cons("RootApp"), avoid}
+
+  lexical syntax
+
+    "<" ~[]* ">" -> PropertyValue {reject}
+    "~" ~[]*     -> PropertyValue {reject}

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Stratego-Sdf2.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Stratego-Sdf2.sdf	Sat Jun  4 16:21:15 2011	(r22993)
@@ -0,0 +1,216 @@
+%%%
+ %% The definition of Sdf2 in Stratego tries to stay as close to the ASF+SDF
+ %% specification of SDF2 in "Syntax Definition for Language Prototyping" by
+ %% Eelco Visser.
+ %%
+ %% @author Martin Bravenboer
+ %%%
+module Stratego-Sdf2
+imports
+  languages/sdf2/syntax/Sdf2
+  StrategoMix[StrategoHost]
+
+exports
+  context-free start-symbols Module[[StrategoHost]]
+
+exports
+  %% HACK
+  context-free syntax
+    Group "." -> Group {non-assoc,cons("non-transitive")}
+
+
+  context-free syntax
+
+        "|[" SDF "]|" -> Term[[StrategoHost]] {cons("ToTerm")}
+    "d" "|[" SDF "]|" -> Term[[StrategoHost]] {cons("ToTerm")}
+
+        "|[" Module "]|" -> Term[[StrategoHost]] {cons("ToTerm")}
+    "m" "|[" Module "]|" -> Term[[StrategoHost]] {cons("ToTerm")}
+    "M" "|[" ModuleName "]|" -> Term[[StrategoHost]] {cons("ToTerm")}
+
+    "i" "|[" Import "]|" -> Term[[StrategoHost]] {cons("ToTerm")}
+
+        "|[" Section  "]|" -> Term[[StrategoHost]] {cons("ToTerm")}
+    "s" "|[" Section  "]|" -> Term[[StrategoHost]] {cons("ToTerm")}
+
+         "|[" Grammar  "]|" -> Term[[StrategoHost]] {cons("ToTerm")}
+         "|[" Grammar* "]|" -> Term[[StrategoHost]] {cons("ToTerm")}
+    "G"  "|[" Grammar  "]|" -> Term[[StrategoHost]] {cons("ToTerm")}
+    "G*" "|[" Grammar* "]|" -> Term[[StrategoHost]] {cons("ToTerm")}
+
+    "is" "|[" ImpSection "]|" -> Term[[StrategoHost]] {cons("ToTerm")}
+
+        "|[" Attributes "]|" -> Term[[StrategoHost]] {cons("ToTerm")}
+    "$" "|[" Attributes "]|" -> Term[[StrategoHost]] {cons("ToTerm")}
+
+        "|[" Production  "]|" -> Term[[StrategoHost]] {cons("ToTerm"), prefer}
+    "p" "|[" Production  "]|" -> Term[[StrategoHost]] {cons("ToTerm")}
+
+         "|[" Productions "]|" -> Term[[StrategoHost]] {cons("ToTerm")}
+    "p*" "|[" Productions "]|" -> Term[[StrategoHost]] {cons("ToTerm")}
+
+        "|[" Restriction "]|" -> Term[[StrategoHost]] {cons("ToTerm")}
+    "r" "|[" Restriction "]|" -> Term[[StrategoHost]] {cons("ToTerm")}
+
+         "|[" Restrictions "]|" -> Term[[StrategoHost]] {cons("ToTerm")}
+    "r*" "|[" Restrictions "]|" -> Term[[StrategoHost]] {cons("ToTerm")}
+
+         "|[" Symbol      "]|" -> Term[[StrategoHost]] {cons("ToTerm")}
+    "A"  "|[" Symbol      "]|" -> Term[[StrategoHost]] {cons("ToTerm")}
+    "A*" "|[" Symbols     "]|" -> Term[[StrategoHost]] {cons("ToTerm")}
+
+    "cc" "|[" CharClass "]|" -> Term[[StrategoHost]] {cons("ToTerm")}
+
+         "|[" Renaming "]|" -> Term[[StrategoHost]] {cons("ToTerm")}
+    "ro" "|[" Renaming "]|" -> Term[[StrategoHost]] {cons("ToTerm")}
+
+         "|[" Alias "]|" -> Term[[StrategoHost]] {cons("ToTerm")}
+    "al" "|[" Alias "]|" -> Term[[StrategoHost]] {cons("ToTerm")}
+
+    "~"     Var[[StrategoHost]]  -> Symbol {cons("FromTerm")}
+    "~sym:" Term[[StrategoHost]] -> Symbol {cons("FromTerm")}
+
+
+%%%
+ %% Tricky: the reject needs to be lexical syntax to
+ %% avoid reject of variables. These lexical rejects only
+ %% reject the literal alternatives of an ambiguity. Thus,
+ %% the context-free variable is still allowed.
+ %%%
+
+  lexical syntax
+    %% MetaVar -> Sort {reject}
+    MetaVar -> IdCon  {reject}
+    MetaVar -> StrCon {reject}
+
+%%%
+ %% Symbols: Section 7.1
+ %%%
+
+  variables
+    SymbolMetaVar      -> Symbol
+    SymbolMetaVar "*"  -> Symbol*
+    SymbolMetaVar "+"  -> Symbol+
+
+    SymbolMetaVar "*"  -> {Symbol ","}*
+    SymbolMetaVar "+"  -> {Symbol ","}+
+
+  lexical syntax
+    [ABC][0-9\']* -> SymbolMetaVar
+    SymbolMetaVar -> MetaVar
+
+  lexical restrictions
+    SymbolMetaVar -/- [A-Za-z0-9]
+
+%%%
+ %% Grammar: Section 7.2
+ %%%
+
+  variables
+    "G" [0-9\']* -> Grammar
+
+%%%
+ %% Productions and attributes: Section 7.3.1
+ %%%
+
+  variables
+    "attr" [0-9\']*     -> Attribute
+    "attr" [0-9\']* "*" -> {Attribute ","}*
+    "attr" [0-9\']* "+" -> {Attribute ","}+
+    "attrs" [0-9\']*        -> Attributes
+
+    "p" [0-9\']*     -> Production
+    "p" [0-9\']* "*" -> Production*
+    "p" [0-9\']* "+" -> Production+
+
+%%%
+ %% Sort: Section 7.4.1
+ %%%
+
+  variables
+     SortMetaVar -> Sort
+
+  lexical syntax
+    "S" [0-9\']* -> SortMetaVar
+    SortMetaVar -> MetaVar
+
+  lexical restrictions
+    SortMetaVar -/- [A-Za-z0-9]
+
+%%%
+ %% CharClass: Section 7.4.2
+ %%%
+
+  variables
+    "cc" [0-9\']* -> CharClass {prefer}
+
+%%%
+ %% Literals
+ %%%
+
+  variables
+    StrConMetaVar -> StrCon
+
+  lexical syntax
+    "L" [0-9\']*  -> StrConMetaVar
+    StrConMetaVar -> MetaVar
+
+  lexical restrictions
+    StrConMetaVar -/- [A-Za-z0-9]
+
+%%%
+ %% Groups and priorities
+ %%%
+
+  variables %% section 8.1.1
+    "g" [0-9\']*      -> Group
+    "gg" [0-9\']* "*" -> {Group ">"}*
+    "gg" [0-9\']* "+" -> {Group ">"}+
+
+    "pr" [0-9\']*     -> Priority
+    "pr" [0-9\']* "*" -> {Priority ","}*
+    "pr" [0-9\']* "+" -> {Priority ","}+
+
+    AssocMetaVar -> Associativity
+
+  lexical syntax
+    "as" [0-9\']* -> AssocMetaVar
+
+  lexical restrictions
+    AssocMetaVar -/- [A-Za-z0-9]
+
+  variables %% section 8.4.1
+    "restr" [0-9\']*     -> Restriction
+    "restr" [0-9\']* "*" -> Restriction*
+    "restr" [0-9\']* "+" -> Restriction+
+
+  variables %% section 9.1.1
+    "ro" [0-9\']*     -> Renaming
+    "ro" [0-9\']* "*" -> Renaming*
+    "ro" [0-9\']* "+" -> Renaming+
+
+  variables %% section 9.2.1
+    "al" [0-9\']*     -> Alias
+    "al" [0-9\']* "*" -> Alias*
+    "al" [0-9\']* "+" -> Alias+
+
+  variables %% section 9.3.1
+    "Mid" [0-9\']* -> ModuleId
+    "M"   [0-9\']* -> ModuleName
+
+    "s" [0-9\']*     -> Section
+    "s" [0-9\']* "*" -> Section*
+    "s" [0-9\']* "+" -> Section+
+
+    "m" [0-9\']*     -> Module
+    "m" [0-9\']* "*" -> Module*
+    "m" [0-9\']* "+" -> Module+
+
+    "d" [0-9\']*     -> Definition
+
+    "i" [0-9\']*     -> Import
+    "i" [0-9\']* "*" -> Import*
+    "i" [0-9\']* "+" -> Import+
+
+    "is" [0-9\']*     -> ImpSection
+    "is" [0-9\']* "*" -> ImpSection*

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/StrategoStratego.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/StrategoStratego.sdf	Sat Jun  4 16:21:15 2011	(r22993)
@@ -0,0 +1,7 @@
+module StrategoStratego
+imports
+  StrategoMix[StrategoHost]
+  EmbeddedStrategoMix[StrategoObject PreTerm[[StrategoHost]] Term[[StrategoHost]]]
+
+hiddens
+  context-free start-symbols Module[[StrategoHost]]

From tobivollebregt at gmail.com  Sat Jun  4 18:34:12 2011
From: tobivollebregt at gmail.com (Tobi Vollebregt)
Date: Sat, 04 Jun 2011 16:34:12 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r22994 - in
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax: editor
	syntax trans trans/analyze/sdf trans/codegen
	trans/codegen/esv trans/codegen/sdf trans/codegen/str ...
Message-ID: <20110604163412.87C687F806C@mx1.tudelft.nl>

Author: tvo
Date: Sat Jun  4 16:34:11 2011
New Revision: 22994
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=22994&sc=1

Log:
SpoofaxLang: add TemplateLang

Changes to TemplateLang:
* Tab characters work somewhat (1 tab = 2 spaces still hardcoded)
* Escaped single quote works now
* Added tests
* more?

Additional changes to SpoofaxLang:
* Renamed nomalize-all to normalize-all
* Renamed pre-complile-compilation-unit to pre-compile-compilation-unit
* Changed __intenral reserved word to __internal
* Factored out common utils to access SDF attributes (i.e. fetch-cons)

Added:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/syntax/TemplateLang.sdf
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/template/
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/template/to-esv.meta
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/template/to-esv.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/template/to-sdf.meta
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/template/to-sdf.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/template/to-str.meta
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/template/to-str.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/template/
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/template/declare.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/normalize/templatelang.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/templatelang/
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/templatelang/desugar.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/templatelang/to-esv.meta
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/templatelang/to-esv.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/templatelang/to-sdf.meta
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/templatelang/to-sdf.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/templatelang/to-str.meta
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/templatelang/to-str.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/attributes.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/sdf2conflicts.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/templatelang.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/tokenize.str
Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/editor/SpoofaxLang-Builders.esv
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/editor/SpoofaxLang-Colorer.esv
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/editor/SpoofaxLang-Completions.esv
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/syntax/SPXCommon.sdf
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/syntax/SpoofaxLang.sdf
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/analyze/sdf/check.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/compile.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/esv/to-esv.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/sdf/to-name-analysis.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/sdf/to-sdf.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/str/to-stratego.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/declare.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/parse-adapter.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/sdf/declare-signature.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/sdf/declare.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/normalize/main.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/spoofaxlang.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/resources/test.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/annotations.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/contract.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/debug.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/editor/SpoofaxLang-Builders.esv
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/editor/SpoofaxLang-Builders.esv	Sat Jun  4 16:21:15 2011	(r22993)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/editor/SpoofaxLang-Builders.esv	Sat Jun  4 16:34:11 2011	(r22994)
@@ -4,49 +4,52 @@
 imports SpoofaxLang-Builders.generated
 
 builders
-                                                                      
-  // This file can be used for custom analysis and builder rules.     
-  //                                                                  
-  // See the imported file for a brief introduction and examples.     
+
+  // This file can be used for custom analysis and builder rules.
+  //
+  // See the imported file for a brief introduction and examples.
 
 builders
-                                                                                                                               
-  provider                  : include/spoofaxlang.jar                                                                          
-                                                                                                                               
-	observer                  : editor-analyze                                                                                   
-                                                                                                                               
+
+  provider                  : include/spoofaxlang.jar
+
+	observer                  : editor-analyze
+
   builder : "Show abstract syntax (for selection)" =
-    generate-aterm (openeditor) (realtime) (meta) (source)                                                                       
-                                                                                                                               
+    generate-aterm (openeditor) (realtime) (meta) (source)
+
   builder : "Show name analysis (for selection)" =
-    generate-name-analysis (openeditor) (realtime) (meta) (source) 
-    
+    generate-name-analysis (openeditor) (realtime) (meta) (source)
+
   //builder : "Show SDF (for selection)" =
-  //  generate-sdf (openeditor) (realtime)           
-    
+  //  generate-sdf (openeditor) (realtime)
+
   //builder : "Show Stratego (for selection)" =
-  //  generate-str (openeditor) (realtime)      
-    
+  //  generate-str (openeditor) (realtime)
+
  // builder : "Show Editor Descriptor (for selection)" =
-  //  generate-esv (openeditor) (realtime)              
-  
-  //builder: "generate signatures" = 
+  //  generate-esv (openeditor) (realtime)
+
+  //builder: "generate signatures" =
 	//	generate-signatures-from-SDF (realtime) (openeditor) (meta)
-	
+
 	builder : "Build-All" =
     build-all (openeditor) (realtime) (meta)
-   
+
   //builder : "test desugar" =
   // generate-desugar (openeditor) (realtime) (meta)
-  
-  builder : "Compile-All" =  
+
+  builder : "Compile-All" =
     compile-spx(openeditor) (realtime) (meta)
-  
-  
-  builder : "Show Configuration" =  
+
+
+  builder : "Show Configuration" =
     show-configuration(openeditor) (realtime) (meta)
-  
-  /*  	                                                                                                                             
-  builder : "test-resolve" =  
+
+  /*
+  builder : "test-resolve" =
     test-resolving-symbol (openeditor) (realtime) (meta)
-  */                                                                                                   
\ No newline at end of file
+  */
+
+  builder : "Test TemplateLang" =
+    run-templatelang-tests (meta)

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/editor/SpoofaxLang-Colorer.esv
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/editor/SpoofaxLang-Colorer.esv	Sat Jun  4 16:21:15 2011	(r22993)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/editor/SpoofaxLang-Colorer.esv	Sat Jun  4 16:34:11 2011	(r22994)
@@ -3,32 +3,47 @@
 imports SpoofaxLang-Colorer.generated
 
 colorer
-                                                                      
-  // This file can be used for custom colorer rules.                  
-  //                                                                  
-  // See the imported file for a brief introduction and examples.     
-  
-  
+  // TemplateLang colorer rules
+
+  _.String                : template
+  _.Escape                : 127 0 85 bold
+  _.Layout                : template
+  _.Newline               : template //0 0 255 255 0 0  (highlight trailing whitespace)
+  PlaceholderText1        : template
+  PlaceholderText2        : template
+  _.Placeholder           : _ bold
+  PlaceholderSort.Sort    : _ bold
+  PlaceholderSuffix._     : _ bold
+
+  template = 0 0 255 // 240 240 240
+
+colorer
+
+  // This file can be used for custom colorer rules.
+  //
+  // See the imported file for a brief introduction and examples.
+
+
   _.Constructor : 64 64 255 bold
-  Namespace     : darkgreen 
+  Namespace     : darkgreen
   Label         : gray
-  
+
   _.namespaceref  : 0   96  96 italic
   _.namespaceref2 : 0   96  96 italic
   _.namespacedef  : 0   96  96 italic
-  
-  
-  
+
+
+
    layout     : 63 127 95    italic
 
   environment var:
     0 128 64
     255 255 255
     italic
-    
+
   // StrategyDef: 0 128 128 bold
   // RuleDef:     0 128 128 bold
-  
+
   // White background for variables and escapes
   environment _.StringEscape1 : _ 255 255 255
   environment _.StringEscape2 : _ 255 255 255
@@ -36,31 +51,31 @@
   environment _.StringEscape4 : _ 255 255 255
   _.Wld     : _ 255 255 255
 
-  _.StringEscape1 : gray  
-  _.StringEscape2 : gray  
-  _.StringEscape3 : gray  
+  _.StringEscape1 : gray
+  _.StringEscape2 : gray
+  _.StringEscape3 : gray
   _.StringEscape4 : gray
-  
+
   _.Str     : blue
   _.StrCong : blue
   _.QStr    : blue
   _.QDollar : blue
   _.QBr     : gray
-  
+
   RuleDef     : 0 64 128 bold
   RuleDec     : 0 64 128 bold
   StrategyDef : 0 64 128 bold
   Overlay     : 0 64 128 bold
-  
+
   //strategies    = 0    0    0
   strategycalls = 0   64  128
   terms         = 0    0    0
-  vars          = 24 170 222 242 242 242 
+  vars          = 24 170 222 242 242 242
   sdefault      = 0    0    0
-  
+
   _.RootApp : strategycalls
   _.App     : strategycalls
-  
+
   //Strategy  : strategies
   SVar      : strategycalls
   Term      : terms
@@ -74,4 +89,4 @@
   QuotedBracket1 : blue
   QuotedBracket2 : blue
   QuotedBracket3 : blue
-  QuotedBracket4 : blue
\ No newline at end of file
+  QuotedBracket4 : blue

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/editor/SpoofaxLang-Completions.esv
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/editor/SpoofaxLang-Completions.esv	Sat Jun  4 16:21:15 2011	(r22993)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/editor/SpoofaxLang-Completions.esv	Sat Jun  4 16:34:11 2011	(r22994)
@@ -3,199 +3,212 @@
 imports SpoofaxLang-Completions.generated
 
 completions
-	   // Semantic (identifier) completion:
-	   completion proposer:
-	   			 editor-complete
-	  
+     // Semantic (identifier) completion:
+     completion proposer:
+            editor-complete
+
 completions
-	  //Syntax completion for SDF Definition
-	  completion trigger:
-	    "->\s*[A-Za-z0-9]+\s*\{"
-	
-	  completion trigger:
-	    "->\s*[A-Za-z0-9]+\s*\{[^}]+,[\ \t]*"
-	
-	  completion trigger:
-	    "->[\ \t]+"                                                             
-	  
-	  completion template:
-	  	"context-free syntax" "\n\t" (blank)
-	
-	  completion template:
-	  	"lexical syntax" "\n\t" (blank)
-	
-	  completion template:
-	  	"syntax" "\n\t" (blank)
-	
-	  completion template:
-	  	"imports" "\n\t" (blank)
-	
-	  completion template:
-	  	"exports" "\n\t" (blank)
-	
-	  completion template:
-	    "hiddens" "\n\t" (blank)
-	
-	  completion template:
-	  	"context-free restrictions" "\n\t" (blank)
-	
-	  completion template:
-	  	"lexical restrictions" "\n\t" (blank)
-	
-	  completion template:
-	  	"restrictions" "\n\t" (blank)
-	
-	  completion template:
-	  	"context-free start-symbols" "\n\t" <Start> (blank)
-	
-	  completion template:
-	  	"lexical start-symbols" "\n\t" <Start> (blank)
-	
-	  completion template:
-	  	"start-symbols" "\n\t" <Start> (blank)
-	
-	  completion template:
-	  	"sorts" "\n\t" (blank)
-	
-	  completion template:
-	  	"variables" "\n\t" (blank)
-	
-	  completion template:
-	  	"aliases" "\n\t" (blank)
-	
-	  completion template:
-	  	"priorities" "\n\t" (blank)
-	
-	  completion template : Module =
-	  	"module" " " <x> "\n\t\nexports\n\t" (blank)
-	
-	  completion template: 
-	  	"lexical variables" "\n\t" (blank)
-	
-	  completion template:
-	    "{cons" "(\"" <Name> "\")"
-	
-	  completion template:
-	    "{deprecated" "(\"" <explanation> "\")"
-	
-	  completion keyword:
-	    "{reject"
-	
-	  completion keyword:
-	    "{left"
-	
-	  completion keyword:
-	    "{right"
-	
-	  completion keyword:
-	    "{non-assoc"
-	
-	  completion keyword:
-	    "{avoid"
-	
-	  completion keyword:
-	    "{prefer"
-	
-	  completion keyword:
-	    "{bracket"
-	
-	  completion keyword:
-	    "{recover"
-	
-	  completion template:
-	    ", cons" "(\"" <Name> "\")"
-	
-	  completion template:
-	    ", deprecated" "(\"" <explanation> "\")"
-	
-	  completion keyword:
-	    ", reject"
-	
-	  completion keyword:
-	    ", left"
-	
-	  completion keyword:
-	    ", right"
-	
-	  completion keyword:
-	    ", non-assoc"
-	
-	  completion keyword:
-	    ", avoid"
-	
-	  completion keyword:
-	    ", prefer"
-	
-	  completion keyword:
-	    ", bracket"
-	
-	  completion keyword:
-	    ", recover"
-	
-	  completion template:
-	    ",cons" "(\"" <Name> "\")"
-	
-	  completion template:
-	    ",deprecated" "(\"" <explanation> "\")"
-	
-	  completion keyword:
-	    ",reject"
-	
-	  completion keyword:
-	    ",left"
-	
-	  completion keyword:
-	    ",right"
-	
-	  completion keyword:
-	    ",non-assoc"
-	
-	  completion keyword:
-	    ",avoid"
-	
-	  completion keyword:
-	    ",prefer"
-	
-	  completion keyword:
-	    ",bracket"
-	
-	  completion keyword:
-	    ",recover"
-                                                               
+    // TemplateLang completions
+    completion template TemplateProduction : "template" =
+      <Sort> "." <Cons> " = <<" (cursor) ">>" (blank)
+
+    completion template TemplateProduction : "multiline template" =
+      <Sort> "." <Cons> " = <<\n\t" (cursor) "\n>>" (blank)
+
+    completion template TemplatePart1 : "placeholder" = "<" <text> ":" <Sort> ">"
+    completion template TemplatePart2 : "placeholder" = "[" <text> ":" <Sort> "]"
+
+    completion template PlaceholderOption : "separator" "=\"" (cursor) "\""
+    completion template PlaceholderOptions : "separator" = "; separator=\"" (cursor) "\""
 
 completions
-     
+    //Syntax completion for SDF Definition
+    completion trigger:
+      "->\s*[A-Za-z0-9]+\s*\{"
+
+    completion trigger:
+      "->\s*[A-Za-z0-9]+\s*\{[^}]+,[\ \t]*"
+
+    completion trigger:
+      "->[\ \t]+"
+
+    completion template:
+      "context-free syntax" "\n\t" (blank)
+
+    completion template:
+      "lexical syntax" "\n\t" (blank)
+
+    completion template:
+      "syntax" "\n\t" (blank)
+
+    completion template:
+      "imports" "\n\t" (blank)
+
+    completion template:
+      "exports" "\n\t" (blank)
+
+    completion template:
+      "hiddens" "\n\t" (blank)
+
+    completion template:
+      "context-free restrictions" "\n\t" (blank)
+
+    completion template:
+      "lexical restrictions" "\n\t" (blank)
+
+    completion template:
+      "restrictions" "\n\t" (blank)
+
+    completion template:
+      "context-free start-symbols" "\n\t" <Start> (blank)
+
+    completion template:
+      "lexical start-symbols" "\n\t" <Start> (blank)
+
+    completion template:
+      "start-symbols" "\n\t" <Start> (blank)
+
+    completion template:
+      "sorts" "\n\t" (blank)
+
+    completion template:
+      "variables" "\n\t" (blank)
+
+    completion template:
+      "aliases" "\n\t" (blank)
+
+    completion template:
+      "priorities" "\n\t" (blank)
+
+    completion template : Module =
+      "module" " " <x> "\n\t\nexports\n\t" (blank)
+
+    completion template:
+      "lexical variables" "\n\t" (blank)
+
+    completion template:
+      "{cons" "(\"" <Name> "\")"
+
+    completion template:
+      "{deprecated" "(\"" <explanation> "\")"
+
+    completion keyword:
+      "{reject"
+
+    completion keyword:
+      "{left"
+
+    completion keyword:
+      "{right"
+
+    completion keyword:
+      "{non-assoc"
+
+    completion keyword:
+      "{avoid"
+
+    completion keyword:
+      "{prefer"
+
+    completion keyword:
+      "{bracket"
+
+    completion keyword:
+      "{recover"
+
+    completion template:
+      ", cons" "(\"" <Name> "\")"
+
+    completion template:
+      ", deprecated" "(\"" <explanation> "\")"
+
+    completion keyword:
+      ", reject"
+
+    completion keyword:
+      ", left"
+
+    completion keyword:
+      ", right"
+
+    completion keyword:
+      ", non-assoc"
+
+    completion keyword:
+      ", avoid"
+
+    completion keyword:
+      ", prefer"
+
+    completion keyword:
+      ", bracket"
+
+    completion keyword:
+      ", recover"
+
+    completion template:
+      ",cons" "(\"" <Name> "\")"
+
+    completion template:
+      ",deprecated" "(\"" <explanation> "\")"
+
+    completion keyword:
+      ",reject"
+
+    completion keyword:
+      ",left"
+
+    completion keyword:
+      ",right"
+
+    completion keyword:
+      ",non-assoc"
+
+    completion keyword:
+      ",avoid"
+
+    completion keyword:
+      ",prefer"
+
+    completion keyword:
+      ",bracket"
+
+    completion keyword:
+      ",recover"
+
+
+completions
+
   completion template : Strategy =
     "if" " " <e> " then\n\t" <s> "\nend"
-      
-  completion template : Strategy = 
+
+  completion template : Strategy =
     "switch" " " <s> "\n\tcase " <c> ":" " " <s> "\n\totherwise: " <id> "\nend"
 
   completion template : Strategy =
-  	"let" "\n\t" <x> " = " <s> "\nin\n\t" <s> "\nend"
+    "let" "\n\t" <x> " = " <s> "\nin\n\t" <s> "\nend"
 
   completion template : Def =
-  	"where" "\n\t" (blank)
-  	
+    "where" "\n\t" (blank)
+
   completion template : Def =
-  	"with" "\n\t" (blank)
-  
+    "with" "\n\t" (blank)
+
   completion template:
     "strategies" "\n\t" (blank)
-  
+
   completion template:
     "rules" "\n\t" (blank)
-  
+
   completion template : Decl =
     "imports" "\n\t" <Module> (blank)
-  
+
   completion template:
     "signature constructors" "\n\t" (blank)
-  
+
   completion template:
     "signature sorts" "\n\t" (blank)
 
-  completion template : Module = 
-    "module " <name> "\n\nstrategies\n\n\t"                                      
-                                         
-  
\ No newline at end of file
+  completion template : Module =
+    "module " <name> "\n\nstrategies\n\n\t"
+

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/syntax/SPXCommon.sdf
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/syntax/SPXCommon.sdf	Sat Jun  4 16:21:15 2011	(r22993)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/syntax/SPXCommon.sdf	Sat Jun  4 16:34:11 2011	(r22994)
@@ -3,42 +3,44 @@
 exports
 
   lexical syntax
-  
+
+    [a-zA-Z]* "CONTENTCOMPLETE" [0-9]+ -> CONTENTCOMPLETE {avoid}
+
     [a-zA-Z][a-zA-Z0-9\_\-]* -> ID
     "-"? [0-9]+            -> INT
-    
+
     "\"" StringChar* "\"" -> STRING
     ~[\"\n]               -> StringChar
     "\\\""                -> StringChar
     BackSlashChar         -> StringChar
     "\\"                  -> BackSlashChar
-    
-    [\ \t\n\r] -> LAYOUT 
-    
+
+    [\ \t\n\r] -> LAYOUT
+
     [\*]                             -> CommentChar
     "/*" (~[\*] | CommentChar)* "*/" -> LAYOUT
     "//" ~[\n\r]* ([\n\r] | EOF)     -> LAYOUT
-    
+
     -> EOF
-  
+
   lexical restrictions
-  
+
     %% Ensure greedy matching for lexicals
-  
+
     CommentChar   -/- [\/]
     INT           -/- [0-9]
     ID            -/- [a-zA-Z0-9\_\-]
-    
+
     %% EOF may not be followed by any char
-    
+
     EOF           -/- ~[]
 
-    %% Backslash chars in strings may not be followed by " 
-    
+    %% Backslash chars in strings may not be followed by "
+
     BackSlashChar -/- [\"]
 
   context-free restrictions
-  
+
     %% Ensure greedy matching for comments
 
     LAYOUT? -/- [\ \t\n\r]
@@ -46,31 +48,31 @@
     LAYOUT? -/- [\/].[\*]
 
 	lexical restrictions
-		
+
 		"main"
-		"module" 
-		"package" 
-		"imports"	
+		"module"
+		"package"
+		"imports"
 		"language" -/- [A-Za-z0-9\_]
-		 
 
-	lexical syntax     
-    
+
+	lexical syntax
+
     "language"          -> Reserved
     "project"           -> Reserved
     "retain"            -> Reserved
     "with"              -> Reserved
     "unimports"         -> Reserved
-    
-   
-    
+
+
+
     "imports"           -> Reserved
     "overlays"          -> Reserved
     "rules"             -> Reserved
     "signature"         -> Reserved
     "strategies"        -> Reserved
     "attributes"        -> Reserved
-    
+
     "aliases"           -> Reserved
     "lexical"           -> Reserved
     "priorities"        -> Reserved
@@ -92,19 +94,20 @@
     "sorts"             -> Reserved
     "restrictions"      -> Reserved
   	"as"								-> Reserved
- 		"main"							-> Reserved 
+ 		"main"							-> Reserved
  		"__default"					-> Reserved
- 		"__intenral"				-> Reserved 
- 		
+ 		"__internal"				-> Reserved
+ 		"template"          -> Reserved
+ 		"templates"         -> Reserved
+
  		Reserved 						-> ReservedName[[ESV]]
  		ReservedName[[ESV]]	-> ID {reject}
- 		
- 	    
-	lexical syntax 
+
+
+	lexical syntax
  		"package"  	-> EnclosingSymbol
 		"assembly"  -> EnclosingSymbol
 		"module"  	-> EnclosingSymbol
-		
-	context-free syntax 	
+
+	context-free syntax
 		"main"			-> MainID{cons("Main")}
-		
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/syntax/SpoofaxLang.sdf
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/syntax/SpoofaxLang.sdf	Sat Jun  4 16:21:15 2011	(r22993)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/syntax/SpoofaxLang.sdf	Sat Jun  4 16:34:11 2011	(r22994)
@@ -6,6 +6,7 @@
   SPXCommon
   Concepts
   Naming
+  TemplateLang
   EditorServiceMix[ESV]
   Stratego-AttributesMix[STR] [
     "imports" ImportModName* -> Decl {cons("Imports")}
@@ -28,81 +29,81 @@
     Start
 
   lexical syntax
-    {ID "/"}+       -> QID 
+    {ID "/"}+       -> QID
     {ID ("/"|".")}+ -> QIDWithDots
-		
+
   context-free syntax
-  
+
 		ImportSection* PackageDefinition* 							-> Start{cons("CompilationUnit") }
 	  Module* 																				-> Start{cons("CompilationUnit") , prefer}
-    
+
     "package" QName Module*                         -> PackageDefinition {cons("Package")}
     MainID? "module" SPXModuleName Section*         				-> Module {cons("Module")}
-    
+
     Grammar[[SDF]] -> Section {cons("SDFSection")}
     Decl[[STR]]    -> Section {cons("STRSection")}
     Section[[ESV]] -> Section {cons("ESVSection")}
     ImportSection  -> Section
     ConceptSection -> Section
-    
-    ExportsOrHiddens Grammar[[SDF]] -> Section {cons("SDFSectionEH"), non-assoc}    
+
+    ExportsOrHiddens Grammar[[SDF]] -> Section {cons("SDFSectionEH"), non-assoc}
     "exports"                       -> ExportsOrHiddens {cons("Exports"), deprecated}
     "hiddens"                       -> ExportsOrHiddens {cons("Hiddens"), deprecated}
 
-    
+
     %% TODO: Support SDF .def "definitions"?
     %% TODO: Mark deprecated, ast, and maybe other attrs as keyword using a {prefer, ast} production
- 
+
   context-free syntax
     QID "[" Symbols[[SDF]] "]" -> QName  {cons("ParamName")}
-    QID		  				   -> LegacyImportName {cons("Name")}	
+    QID		  				   -> LegacyImportName {cons("Name")}
     {ID "." }+				   -> QName	 {cons("QName")}
 	ID	 					   -> QName	 {cons("Name"),prefer}
     ID  					   -> SPXModuleName	 {cons("SPXModuleName")}
-   	  
-	context-free syntax %% Imports   	
+
+	context-free syntax %% Imports
     %% TODO: SDF: "retains" clause eliminates need for "hiddens" section. except we need something to hide the start symbols
     %% Maybe a "with start symbols" clause, combined with a warning if the syntax has start symbols but the clause is not specified?
     "imports" Import*          -> ImportSection {cons("Imports"),prefer}
     "unimports" Import*        -> ImportSection {cons("Unimports")}
- 
-    ImportedModule 		                   -> Import 
+
+    ImportedModule 		                   -> Import
     ModuleName                           -> Import {cons("Import")}
     ModuleName "retain" Renamings[[SDF]] -> Import {cons("ImportRetain")}
     ModuleName          Renamings[[SDF]] -> Import {cons("ImportRename")}
     "namespace" QIDWithDots              -> Import {cons("NamespaceImport")}
     "(" Import ")"                       -> Import {bracket, deprecated}
 
-	context-free syntax    
+	context-free syntax
     LegacyImportName				 		-> ImportedModule{cons("ImportLegacyArtifact")}
-    QName "::" SPXModuleName 				-> ImportedModule{cons("ImportSpxModule"),prefer} 
+    QName "::" SPXModuleName 				-> ImportedModule{cons("ImportSpxModule"),prefer}
     QName		   					   		-> ImportedModule{cons("ImportPackage")  , prefer}
-    QName "as" ID					   		-> ImportedModule{cons("ImportPackageWithAlias"),prefer}	
+    QName "as" ID					   		-> ImportedModule{cons("ImportPackageWithAlias"),prefer}
 
 	context-free syntax
 		"[" {AttributeDef "," }+ "]"  	-> Attribute{cons("AttributeSection")}
-		
-		ID  -> AttributeDef 
+
+		ID  -> AttributeDef
 		ID Attribute-arguments-> AttributeDef{prefer}
-	  
-	  Target ":" Attribute -> AttributeDef{non-assoc} 
-	    
-	  EnclosingSymbol  -> Target{cons("Target")} 
-	    
+
+	  Target ":" Attribute -> AttributeDef{non-assoc}
+
+	  EnclosingSymbol  -> Target{cons("Target")}
+
 		ID-> Argument-name{cons("Argument-Name")}
-		ID -> Attribute-argument-expression	
-		
+		ID -> Attribute-argument-expression
+
 		Argument-name? Attribute-argument-expression -> Positional-argument{cons("Positional-argument")}
 		STRING -> Positional-argument{cons("Positional-argument")}
-		
+
 		ID "=" STRING -> Named-argument{cons("Named-argument")}
-	    
+
 		"(" {Named-argument ","}+ ")" -> Attribute-arguments
 	  "(" {Positional-argument ","}+ ")" -> Attribute-arguments
 	  "(" {Positional-argument ","}+  "," {Named-argument ","}*")" -> Attribute-arguments{prefer}
-	      
 
-  context-free syntax 
+
+  context-free syntax
     Reserved            -> ReservedName[[ESV]]
     ReservedName[[ESV]] -> ModuleName {reject}
 
@@ -113,12 +114,11 @@
     "deprecated"                -> Attribute[[SDF]] {prefer, ast("term(default(fun(unquoted(\"deprecated\"))))")}
     "deprecated" "(" STRING ")" -> Attribute[[SDF]] {prefer, ast("term(default(appl(unquoted(\"deprecated\"), [fun(quoted(<1>))])))")}
     "cons" "(" Constructor ")"  -> Attribute[[SDF]] {prefer, ast("term(default(appl(unquoted(\"cons\"), [fun(quoted(<1>))])))")}
-    StrCon[[SDF]]               -> Constructor	  
-  
-  
-    
-  %% for testing only. playing with code-contracts in spoofax lang. 
+    StrCon[[SDF]]               -> Constructor
+
+
+
+  %% for testing only. playing with code-contracts in spoofax lang.
   context-free syntax
-		Var[[STR]] "as" ID -> Var[[STR]] {avoid, cons("VarWithType")} 
- 
-  	    
\ No newline at end of file
+		Var[[STR]] "as" ID -> Var[[STR]] {avoid, cons("VarWithType")}
+

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/syntax/TemplateLang.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/syntax/TemplateLang.sdf	Sat Jun  4 16:34:11 2011	(r22994)
@@ -0,0 +1,155 @@
+module TemplateLang
+imports
+  SPXCommon
+
+exports
+  context-free syntax
+    %% tweaks for content completion
+    CONTENTCOMPLETE -> TemplateProduction {recover, cons("WATER")}
+    CONTENTCOMPLETE -> PlaceholderOption  {recover, cons("WATER")}
+    CONTENTCOMPLETE -> PlaceholderOptions {recover, cons("WATER")}
+
+  context-free syntax
+    %% options section
+    "template" "options" TemplateOption* -> Section {cons("TemplateOptions")}
+
+    "newlines" ":" NewlineOptionValue -> TemplateOption {cons("Newlines")}
+
+    "none"     -> NewlineOptionValue {cons("None")}
+    "leading"  -> NewlineOptionValue {cons("Leading")}
+    "trailing" -> NewlineOptionValue {cons("Trailing")}
+
+  context-free syntax
+    %% references to productions using sort.cons notation in priority specification
+    SortCons                                   -> Group[[SDF]]  {cons("simple-ref-group")}
+    "{" SortCons+ "}"                          -> Group[[SDF]]  {cons("prods-ref-group")}
+    "{" Associativity[[SDF]] ":" SortCons+ "}" -> Group[[SDF]]  {cons("assoc-ref-group")}
+
+  context-free syntax
+    %% "grammars"
+    "templates" TemplateProduction* -> Section {cons("TemplateSection")}
+
+    %% template productions
+    ID "=" Symbols[[SDF]] Attributes[[SDF]] -> Production[[SDF]] {cons("SdfProduction")}
+    ID "=" Template Attributes[[SDF]] -> TemplateProduction {cons("TemplateProduction")}
+
+    %% template productions `sort.cons = ...'
+    SortCons "=" Symbols[[SDF]] Attributes[[SDF]] -> Production[[SDF]] {cons("SdfProductionWithCons")}
+    SortCons "=" Template Attributes[[SDF]] -> TemplateProduction {cons("TemplateProductionWithCons")}
+
+    ID "." ID -> SortCons {cons("SortCons")}
+
+    %% placeholders
+    PlaceholderPrefix1 PlaceholderSort PlaceholderSuffix PlaceholderOptions ">" -> TemplatePart1 {cons("Placeholder")}
+    PlaceholderPrefix2 PlaceholderSort PlaceholderSuffix PlaceholderOptions "]" -> TemplatePart2 {cons("Placeholder")}
+
+    "<" -> PlaceholderPrefix1 {cons("None")}
+    "[" -> PlaceholderPrefix2 {cons("None")}
+
+    %% constructor identical to SDF sort to simplify some transformations
+    ID -> PlaceholderSort {cons("sort")}
+
+        -> PlaceholderSuffix {cons("None")}
+    "*" -> PlaceholderSuffix {cons("Star")}
+    "+" -> PlaceholderSuffix {cons("Plus")}
+    "?" -> PlaceholderSuffix {cons("Option")}
+
+                                 -> PlaceholderOptions {cons("NoOptions")}
+    ";" {PlaceholderOption ","}+ -> PlaceholderOptions {cons("Options")}
+
+    "wrap"                 -> PlaceholderOption {cons("Wrap")}
+    "anchor"               -> PlaceholderOption {cons("Anchor")}
+    "separator" "=" STRING -> PlaceholderOption {cons("Separator")}
+
+  syntax
+    %% placeholders (layout between "<", the text and ":" should be captured)
+    "<" <PlaceholderText1-LEX> ":" -> <PlaceholderPrefix1-CF> {cons("Text")}
+    "[" <PlaceholderText2-LEX> ":" -> <PlaceholderPrefix2-CF> {cons("Text")}
+
+    %% template parts
+    "<<" <TemplatePart1-CF>* ">>" -> <Template-CF> {cons("Template")}
+    <TemplateString1-LEX> -> <TemplatePart1-CF> {cons("String")}
+    <TemplateEscape1-LEX> -> <TemplatePart1-CF> {cons("Escape")}
+    <TemplateLayout-LEX>  -> <TemplatePart1-CF> {cons("Layout")}
+    <TemplateNewline-LEX> -> <TemplatePart1-CF> {cons("Newline")}
+
+    "[[" <TemplatePart2-CF>* "]]" -> <Template-CF> {cons("Template")}
+    <TemplateString2-LEX> -> <TemplatePart2-CF> {cons("String")}
+    <TemplateEscape2-LEX> -> <TemplatePart2-CF> {cons("Escape")}
+    <TemplateLayout-LEX>  -> <TemplatePart2-CF> {cons("Layout")}
+    <TemplateNewline-LEX> -> <TemplatePart2-CF> {cons("Newline")}
+
+    %% special: no placeholders, no newlines
+    "\"" <TemplatePartQ-CF>* "\"" -> <Template-CF> {cons("Template")}
+    <TemplateStringQ-LEX> -> <TemplatePartQ-CF> {cons("String")}
+    <TemplateEscapeQ-LEX> -> <TemplatePartQ-CF> {cons("Escape")}
+    <TemplateLayout-LEX>  -> <TemplatePartQ-CF> {cons("Layout")}
+
+  lexical syntax
+    ~[\<\>\:]+ -> PlaceholderText1
+    ~[\[\]\:]+ -> PlaceholderText2
+
+  lexical restrictions
+    PlaceholderText1 -/- ~[\:]
+    PlaceholderText2 -/- ~[\:]
+
+  lexical syntax
+    [\ \t\r]* [\n] -> TemplateNewline
+    [\ \t\r]+      -> TemplateLayout
+
+    (~[\\\<\>\ \t\r\n] | Backslash1)+ -> TemplateString1
+    (~[\\\[\]\ \t\r\n] | Backslash2)+ -> TemplateString2
+    ~[\\\"\ \t]+                      -> TemplateStringQ
+
+    [\\] -> Backslash1
+    [\\] -> Backslash2
+
+  lexical restrictions
+    TemplateLayout -/- [\ \t\r\n]
+
+    %% must be followed by:
+    TemplateString1 -/- ~[\\\<\>\ \t\r\n]
+    TemplateString2 -/- ~[\\\[\]\ \t\r\n]
+    TemplateStringQ -/- ~[\\\"\ \t]
+
+    %% if followed by a backslash, then the backslash must be followed by:
+    TemplateString1 -/- [\\].~[\<\>\\]
+    TemplateString2 -/- [\\].~[\[\]\\]
+
+    Backslash1 -/- [\<\>\\]
+    Backslash2 -/- [\[\]\\]
+
+  lexical syntax
+    %% this are the escapes which StringTemplate has
+    "\\<"  -> TemplateEscape1
+    "\\>"  -> TemplateEscape1
+    "\\\\" -> TemplateEscape1
+    "\\["  -> TemplateEscape2
+    "\\]"  -> TemplateEscape2
+    "\\\\" -> TemplateEscape2
+
+    "<" EscapedChar* ">"    -> TemplateEscape1
+    "<\\\\>" [\ \t\r]* [\n] -> TemplateEscape1
+    "[" EscapedChar* "]"    -> TemplateEscape2
+    "[\\\\]" [\ \t\r]* [\n] -> TemplateEscape2
+
+    %% double-backslash isn't allowed in <<>> / [[]] templates
+    %% (would clash with <\\> / [\\] line continuation construct)
+    ("\\\\" | EscapedChar)+ -> TemplateEscapeQ
+
+    %% escapes allowed in a placeholder-like construct
+    "\\ "  -> EscapedChar
+    "\\\"" -> EscapedChar
+    "\\t"  -> EscapedChar
+    "\\r"  -> EscapedChar
+    "\\n"  -> EscapedChar
+    "\\u" [0-9A-Fa-f]+ -> UnicodeEscapedChar
+    UnicodeEscapedChar -> EscapedChar
+
+    "\\" ~[] -> EscapedChar {recover, cons("WATER")}
+    "<" ~[\>]+ ">" -> TemplateEscape1 {recover, cons("WATER")}
+    "[" ~[\]]+ "]" -> TemplateEscape2 {recover, cons("WATER")}
+
+  lexical restrictions
+    TemplateEscapeQ    -/- [\\]
+    UnicodeEscapedChar -/- [0-9A-Fa-f]

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/analyze/sdf/check.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/analyze/sdf/check.str	Sat Jun  4 16:21:15 2011	(r22993)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/analyze/sdf/check.str	Sat Jun  4 16:34:11 2011	(r22994)
@@ -6,23 +6,31 @@
   context/sdf/declare
   context/-
   include/SpoofaxLang
-	
+  utils/attributes
+
 rules
 	analyze-section: SDFSectionEH(_, ast) -> <analyze-sdf-errors>ast
-		
-	analyze-section: 
-		SDFSection(ast) -> <analyze-sdf-errors>ast 
+
+	analyze-section:
+		SDFSection(ast) -> <analyze-sdf-errors>ast
 		where
 			<debug-analysis>$[ErrorChecking | SDF Section : [<pp-aterm>]]
-     
-	analyze-sdf-errors : 
+
+  analyze-section:
+    TemplateSection(ast) -> <analyze-sdf-errors>
+    where
+      <debug-analysis>$[ErrorChecking | Template Section : [<pp-aterm>]]
+
+	analyze-sdf-errors :
 		ast -> (error'*, warning'*, [])
 		where
 			<debug-analysis>$[ErrorChecking | SDF  : [<pp-aterm>]]
 		with
 	    // We only collect-om since we don't want inner warning dupes
-	    error*   := <collect-om(?context-free-syntax(<collect-om(context-free-syntax-error)>), conc)> ast;
-	    warning* := <collect-om(?context-free-syntax(<collect-om(context-free-syntax-warning)>), conc)> ast;
+	    error*   := <collect-om(?context-free-syntax(<collect-om(context-free-syntax-error)>)
+	                           + ?TemplateSection(<collect-om(context-free-templates-error)>), conc)> ast;
+	    warning* := <collect-om(?context-free-syntax(<collect-om(context-free-syntax-warning)>)
+	                           + ?TemplateSection(<collect-om(context-free-templates-warning)>), conc)> ast;
 	    if <file-exists> $[[<get-project-path>]/.disable-global-analysis] then
 	      serror* := []
 	    else
@@ -32,7 +40,7 @@
 	    warning'* := <flatten-list> warning*
 
 
-strategies 
+strategies
   /**
    * Tests if something is a non-terminal in terms of the AST produced.
    */
@@ -40,22 +48,22 @@
     ?sort(_) + ?opt(_) + is-iter
   + namespacedef(id, is-non-terminal) + namespaceref(is-non-terminal)
   + namespaceref2(id, is-non-terminal)
-  
+
   is-iter =
     ?iter(_) + ?iter-star(_) + ?iter-sep(_, _) + ?iter-star-sep(_, _)
-  
 
-// Limited exisiting sort checking  
+
+// Limited exisiting sort checking
 rules  //global checks
- 
+
   context-free-syntax-warning:
     sort(x) -> (x, $[No definition for [x]])
     where
-      not(<resolve-sdf-declarations> x) 
-  
+      not(<resolve-sdf-declarations> x)
+
   context-free-syntax-sort-error:
     parameterized-sort(_, _) -> [] // not supported
-  
+
   context-free-syntax-sort-error:
     'sorts(_) -> [] // ignored
 
@@ -73,25 +81,25 @@
         not(<one(term(default(appl(unquoted("cons" + "ast"), [fun(quoted(not("\"\"")))]))))> a'*);
         not(<one(?Constructor(_))> a'*);
         not(<one(bracket() + reject())> a'*);
-        not(!s; (sort("Keyword") + sort("\"Keyword\""))); 
+        not(!s; (sort("Keyword") + sort("\"Keyword\"")));
         target := a*
       else
         target := s
       end
-      
+
   context-free-syntax-warning:
     t @ term(default(appl(unquoted("cons"), a*))) -> (t, $[Single argument expected for {cons("Name")} attribute])
     where
       not(<length> a* => 1)
-  
+
   context-free-syntax-warning:
     t @ term(default(annotated(_, _))) -> (t, $[Use round parentheses () for attribute arguments])
-  
+
   context-free-syntax-error:
     prod([x], s, attrs(a*)) -> (a*, $[Illegal use of {bracket} attribute])
     where
       <one(bracket())> a*
-   
+
   // TODO: don't warn for | in {reject} productions
   context-free-syntax-warning:
     alt(x, y) -> (<id>, $[The | construct is deprecated: instead of A|B->C use A->C B->C])
@@ -126,7 +134,7 @@
   context-free-syntax-warning:
     prod(lhs @ [sort(x), opt(seq(lit(sep), [sort(xs)]))], sort(xs), _) ->
     (lhs, $[Use {[x] [sep]}+ instead for [sep]-separated lists])
-       
+
   // Instruct users to use { X ","? }* (seen in MDSD 2010)
 
   context-free-syntax-warning:
@@ -161,10 +169,36 @@
     iter(cs) -> (<id>, $[Character class iteration should be in lexical syntax section])
     where
       <oncetd(?range(_, _))> cs
-    
+
   context-free-syntax-warning:
-    iter-sep(_, bad @ sort(_)) -> (bad, "Non-terminal used as a list separator (use round braces for grouping non-terminals)") 
-  
+    iter-sep(_, bad @ sort(_)) -> (bad, "Non-terminal used as a list separator (use round braces for grouping non-terminals)")
+
   context-free-syntax-warning:
-    iter-star-sep(_, bad @ sort(_)) -> (bad, "Non-terminal used as a list separator (use round braces for grouping non-terminals)") 
+    iter-star-sep(_, bad @ sort(_)) -> (bad, "Non-terminal used as a list separator (use round braces for grouping non-terminals)")
+
+rules // TemplateLang - Local checks
+
+  context-free-syntax-error:
+    SdfProductionWithCons(_, _, attrs) ->
+      (x, $[Constructor already specified at start of production. Please remove this cons attribute.])
+    where
+      x := <fetch-cons> attrs
+
+  context-free-templates-error:
+    TemplateProductionWithCons(_, _, attrs) ->
+      (x, $[Constructor already specified at start of production. Please remove this cons attribute.])
+    where
+      x := <fetch-cons> attrs
 
+  context-free-templates-warning:
+    Template([head | tail]) ->
+      (head, $[It is recommended to insert a linebreak between the start of a multiline template and its first element.])
+    where
+      <not(?Newline(_))> head; // doesn't start with newline
+      <one(?Newline(_))> tail  // does contain a newline
+
+  context-free-templates-warning:
+    Layout(t) ->
+      (t, $[It is recommended not to use tab characters in templates.])
+    where
+      <explode-string; one('\t')> t

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/compile.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/compile.str	Sat Jun  4 16:21:15 2011	(r22993)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/compile.str	Sat Jun  4 16:34:11 2011	(r22994)
@@ -1,7 +1,7 @@
 module codegen/compile
 
-imports 
-	normalize/- 
+imports
+	normalize/-
 	utils/debug
 	utils/cache
 	utils/path
@@ -10,22 +10,22 @@
 	context/str/-
 	codegen/-
 imports
-	common 
-	config 
-imports 
+	common
+	config
+imports
 	include/SpoofaxLang
-imports	
+imports
 	analyze/main
 	lib/editor-common.generated
-	
-		
+
+
 //TODO : refactor : move it to declare all when handling all types of legacy artifacts. Currently only considering STR Libs
-	 
 
-rules			
-	// Starting a new compilation session   
+
+rules
+	// Starting a new compilation session
 	new-compile-session(s) =
-			{| 	CompiledPackage,currently-compiling-package,CompiledModule, 
+			{| 	CompiledPackage,currently-compiling-package,CompiledModule,
 			 		UsedBy,Using,
 			 		UsedLegacyArtifacts,UsingLegacyArtifacts,
 			 		GetSemanticProblems,
@@ -39,83 +39,83 @@
 							where(
 								<debug-compiler>$[============Starting new compiler session ==============]
 							);
-							compiler-init; // initializing compiler session 
+							compiler-init; // initializing compiler session
 							where(<debug-compiler>$[============Initialization is done  ==============]);
-							s;	
+							s;
 				      ?x
 				    ); !x
-			|} 
+			|}
 
 
-rules 	
-	// Compiler initialization 
-	compiler-init = 
-		// Getting Source directory to start parsing files if needed. 
+rules
+	// Compiler initialization
+	compiler-init =
+		// Getting Source directory to start parsing files if needed.
 		// Otherwise, it reads from the cache
-		where( 
+		where(
 			bagof-SPX-Source-Dir => spx-sources
 		);
-		//Iterating all the configured source directory 
-		<list-loop(parse-spx-sources)> spx-sources; 
-		//Initializes global symbols / default primitives 
-		init-declaration    	
+		//Iterating all the configured source directory
+		<list-loop(parse-spx-sources)> spx-sources;
+		//Initializes global symbols / default primitives
+		init-declaration
 
 
 
-strategies				    
+strategies
 	// Pre-compilation before starting up actual compilation
-	// Before starting primary compilation, 
+	// Before starting primary compilation,
 	// pre-compile normalize the parsed tree
-	// and creates scope-tree and namespace-reference table for 
-	// performing further compilation. 
-	pre-complile-compilation-unit = 
-		origin-track-forced(nomalize-all) // nomalize and builds scope-tree and  partial symbol table with the local information availble
-		//nomalize-all
+	// and creates scope-tree and namespace-reference table for
+	// performing further compilation.
+	pre-compile-compilation-unit =
+		origin-track-forced(normalize-all) // normalize and builds scope-tree and  partial symbol table with the local information availble
+		//normalize-all
+
+strategies
 
-strategies 			  
-	
 	// Main compilation events
-	compile-all = 
-		?current-term ; 
+	compile-all =
+		?current-term ;
 		enable-compiler-debugging;
 		new-compile-session(
-			list-of-package-qname := <get-package-list> 
+			list-of-package-qname := <get-package-list>
 			;<compile-internal>list-of-package-qname
-			;<debug>$[=========Getting list of errors============] 
-			;<get-all-analyzed-problems>()  
-			;debug(!"Errors : " ) // Get all errors 
+			;<debug>$[=========Getting list of errors============]
+			;<get-all-analyzed-problems>()
+			;debug(!"Errors : " ) // Get all errors
 		)
 		;disable-compiler-debugging
 		;!current-term //restoring current term to avoid side effects
-	
-	
-	// compiles all the packages stored at the filepath specified 
+
+
+	// compiles all the packages stored at the filepath specified
 	compile-packages-of: file-abs-path -> issues*
 	where
 		<debug-compiler>$[Compiling packages of  [<pp-aterm-forced>file-abs-path]]
 	where
 			Enable-Caching;
-			<debug-compiler>$[=========Try Getting  Semantic Problems From cache============]; 
+			<debug-compiler>$[=========Try Getting  Semantic Problems From cache============];
 			<get-cached-semantic-issues> file-abs-path => issues*
 		<+
 			//enable-compiler-debugging;
 			new-compile-session(
 			 	list-of-package-qname:= <get-packages-of-file> file-abs-path
-				;<compile-internal>list-of-package-qname 
-				;<debug-compiler>$[=========Getting list of errors============] 
-				;<get-semantic-problmes-by-file>file-abs-path => issues* 
-			) 
-			//find out the semantic errors  
+				;<compile-internal>list-of-package-qname
+				;<debug-compiler>$[=========Getting list of errors============]
+				;<get-semantic-problmes-by-file>file-abs-path => issues*
+			)
+			//find out the semantic errors
 			//;disable-compiler-debugging
 		where
-			if not(<fail-if-has-errors>issues*) then  
+			if not(<fail-if-has-errors>issues*) then
 				  <debug(!"Errors : ")>issues* 	  // get errors for this file only
 			end
-	
-	
+
+
 	// internal strategy of compilation used by different main compile strategies
-	compile-internal : list-of-package-qname* -> list-of-package-qname* 
-	where 
+	compile-internal : list-of-package-qname* -> list-of-package-qname*
+	where
 		<debug-compiler>$[=========Compiling packages===============
 		 				 [<pp-aterm-forced>list-of-package-qname* ]
 		 				 ]
@@ -123,60 +123,60 @@
 		<compile-main>list-of-package-qname*;
 		<analyze-main>list-of-package-qname*;
 		<debug-compiler>$[=========Compilation is done===============]
-	where 	    
-		if Enable-Caching then 
-			<debug-compiler>$[=========Caching Semantic Problems============]; 
+	where
+		if Enable-Caching then
+			<debug-compiler>$[=========Caching Semantic Problems============];
 			<cache-semantic-problems>()
 		end
 
 
 
-rules			   
-	
+rules
+
 	// Compiler main : Compiles provided list of packages and stores semantic problems
-	compile-main = 
+	compile-main =
 		?list-of-package-qnames;
 		where(
-			<debug-compiler>$[Compile-main | compiling packages : [<pp-aterm>] with modules:	
+			<debug-compiler>$[Compile-main | compiling packages : [<pp-aterm>] with modules:
 																		[<pp-aterm><all-keys-Declared;filter(?(Modules(),_) )>]
 			]
 		)
-		//Phase 1:  Resolve-all-import-reference for the listed packaged 
-		//				  in this way => dependecy list will be created automatically for 
+		//Phase 1:  Resolve-all-import-reference for the listed packaged
+		//				  in this way => dependecy list will be created automatically for
 		//				  efficient analysis
 		;where(<debug-compiler>$[compile-main | resolving-package-reference:])
-		;where( resolve-package-references )  
-		//Phase 2:  Compile all the legacy artifacts referred by Spx Packages 
-		//				  and make them accessible in the Global Scope 
+		;where( resolve-package-references )
+		//Phase 2:  Compile all the legacy artifacts referred by Spx Packages
+		//				  and make them accessible in the Global Scope
 		;where(<debug-compiler>$[compile-main | compile-legacy-artifacts:])
 		;where(compile-legacy-artifacts)
-		//Phase 3:  Compile Packagesand make them accessible in the different package 
+		//Phase 3:  Compile Packagesand make them accessible in the different package
 		//					namespace.
 		//					Use the dependency graph to first compile the depending on packages.
-		//					TODO : Optimize. Phase 2 and Phase 3 can be compiled together. 
+		//					TODO : Optimize. Phase 2 and Phase 3 can be compiled together.
 		;list-loop(compile-spx-package)
-		
-				
-				
-	//During analyze-package , just call this strategy 
-	compile-spx-package: 
+
+
+
+	//During analyze-package , just call this strategy
+	compile-spx-package:
 		package-typed-qname at Package(untyped-qname) -> <id>
-		where 
-			<debug-compiler>$[compile-spx-package| Planning to compile : [<pp-aterm>]] 
 		where
-			if should-compile-this-package  then //FOR handling circular referneces   
+			<debug-compiler>$[compile-spx-package| Planning to compile : [<pp-aterm>]]
+		where
+			if should-compile-this-package  then //FOR handling circular referneces
 				// Making this package as currently being compiled
 				where(
 					rules(
 						currently-compiling-package : package-typed-qname -> package-typed-qname
 					)
-				); 
+				);
 				// Getting List of Packages/Modules that this package is depending on.
-				<get-all-usings>untyped-qname => depeneding-typedqname* 
-			  ;<debug-compiler>$[	compile-spx-package | List of dependending-on packages/modules : [<pp-aterm>depeneding-typedqname*]]		
+				<get-all-usings>untyped-qname => depending-typedqname*
+			  ;<debug-compiler>$[	compile-spx-package | List of dependending-on packages/modules : [<pp-aterm>depending-typedqname*]]
 				// Start Compiling the dependent Spx Artifacts
-				;<list-loop(compile-depending-spx)>depeneding-typedqname*
-			
+				;<list-loop(compile-depending-spx)>depending-typedqname*
+
 				;{|GetEnclosingPackageName:
 						<declare-current-package-scope> package-typed-qname;
 						// Now, since all the depending-on artifacts are compiled
@@ -184,14 +184,14 @@
 						// Note: currently we are not considering any nested packages.
 						<declare-package>package-typed-qname;
 						<list-loop(compile-spx-module)><get-enclosed-modules>package-typed-qname
-						
+
 				|};
-			
+
 				// Making this package as compiled.
-				// TODO : consider keeping only 1 DR as a marker if compiled package. 
+				// TODO : consider keeping only 1 DR as a marker if compiled package.
 				where(
 					rules(
-						CompiledPackage : package-typed-qname -> package-typed-qname 
+						CompiledPackage : package-typed-qname -> package-typed-qname
 					)
 				)
 			else
@@ -199,58 +199,58 @@
 			end
 
 	// Compiles imported spx packages/modules
-	compile-depending-spx: 
+	compile-depending-spx:
 		typed-qname -> typed-qname
-		where 
+		where
 			<debug-compiler> $[compile-depending-spx > Compiling depending-on spx package/module :[<pp-aterm>]]
-		where 
+		where
 			if !typed-qname => Package(QName(_)) then
-				<compile-spx-package>typed-qname 					
+				<compile-spx-package>typed-qname
 			else
 				if !typed-qname => Module(QName(_)) then
 						// Even when only a module is imported using ImportSpxModule(_,_),
-						// The whole package is compiled to check consistency , and find 
+						// The whole package is compiled to check consistency , and find
 						// semantic errors.
-						// In later step , when look up is performed, any symbol other than 
+						// In later step , when look up is performed, any symbol other than
 						// symbols that consist in this particular module are marked/realized
-						// as private symbols. 
+						// as private symbols.
 						enclosing-package-typed-qname := <GetEnclosingScope>typed-qname;
 						<compile-spx-package>enclosing-package-typed-qname
 				else
 					<debug-compiler> $[compile-depending-spx | Illegenal depending spx artifact: [<pp-aterm> typed-qname]];
 					fail
 				end
-					
-			end		 
-	
+
+			end
+
 	// Compiles Spx Modules
-	compile-spx-module: 
+	compile-spx-module:
 		module-typed-qname at Module(untyped-qname) -> <id>
-		where 
-			<debug-compiler>$[compile-spx-module| Planning to Compile module: [<pp-aterm>]] 
-		where 
+		where
+			<debug-compiler>$[compile-spx-module| Planning to Compile module: [<pp-aterm>]]
+		where
 			if not(<CompiledModule>module-typed-qname) then
 				<debug-compiler>$[compile-spx-module| Currently Compiling : [<pp-aterm>]]; //this package is not compiled before
 				module-decl := <get-module-declaration>module-typed-qname;
 				{|GetEnclosingModuleName:
-						<declare-current-module-scope> module-typed-qname; 
+						<declare-current-module-scope> module-typed-qname;
 						<declare-module(declare-all)>module-decl
 				|};
 				where(rules(CompiledModule: module-typed-qname -> module-typed-qname))
 			else
 				<debug-compiler>$[compile-spx-module| Ignored as already in the queue : [<pp-aterm>]] //this package is not compiled before
-			end	
-	
-	
+			end
+
+
 	//TODO : append additional checks . compilation should be incremental and if source not changed, show the cached errors/warnings/infos
-	should-compile-this-package = 
+	should-compile-this-package =
 		?package-qname;
 		where(not(<currently-compiling-package>package-qname))
-		
 
-rules 
 
-	
+rules
+
+
 	// Compile sdf, str, esv modules which are imported in the global nameepsace
 	compile-legacy-artifacts: package-tqnames* -> package-tqnames*
 	where
@@ -258,56 +258,56 @@
 		<debug-compiler>$[compile-main | compile-legacy-artifacts | List:[<pp-aterm>upackages]]
 	where
 		{| Resolved-ExternalArtifact:
-					//TODO : Make it configurable which lib to include by default. Hence remove following hardcoding. 
+					//TODO : Make it configurable which lib to include by default. Hence remove following hardcoding.
 					<compile-legacy-artifact>(Globals() , Module(Name("libstratego-lib")) ,Unresolved());
-					<list-loop(compile-legacy-artifact-package)>upackages	
-					
+					<list-loop(compile-legacy-artifact-package)>upackages
+
 		|}
 
-	//Compile  a particular legacy SDF + STR Artifacts . Currently it only supports STR legacy artifacts . TODO  : add others 		
+	//Compile  a particular legacy SDF + STR Artifacts . Currently it only supports STR legacy artifacts . TODO  : add others
 	compile-legacy-artifact-package : p at Package(qname) ->p
-	with	
+	with
 		 <debug-compiler>$[compile-main | compile-legacy-artifacts | Current Package:[<pp-aterm>]]
 		;<bagof-UsingLegacyArtifacts>qname=> legacy-artifact-details*
 		;<debug-compiler>$[compile-main | compile-legacy-artifacts | Artifact List:[<pp-aterm>legacy-artifact-details*]]
 	with
 			{|GetEnclosingPackageName:
 						<declare-current-package-scope> p;
-						<map(compile-legacy-artifact)>legacy-artifact-details*	
+						<map(compile-legacy-artifact)>legacy-artifact-details*
 			|}
-			
-	compile-legacy-artifact: 
+
+	compile-legacy-artifact:
 		legacy-artifact-details@(namespace, m at Module(Name(modulename)) , resolving-path) -> legacy-artifact-details
 		where
-			<debug-compiler>$[compile-main | compile-legacy-artifact | planning to compile following legacy artifact: [<pp-aterm>]] 
+			<debug-compiler>$[compile-main | compile-legacy-artifact | planning to compile following legacy artifact: [<pp-aterm>]]
 		where
-			if not(<Resolved-ExternalArtifact>(namespace, modulename,resolving-path)) then // check to see if already taken care off.  	
-				if (!resolving-path => Unresolved()) then 
-					  // we are only supporting legacy STR lib at this moment which are not located in the file system . 
+			if not(<Resolved-ExternalArtifact>(namespace, modulename,resolving-path)) then // check to see if already taken care off.
+				if (!resolving-path => Unresolved()) then
+					  // we are only supporting legacy STR lib at this moment which are not located in the file system .
 					  // Hence, it is unresolved , we are giving it a try to resolve it as a lib
-						( <get-cached-lib-ast(read-stratego-signatures);declare-stratego-globals-top>modulename 
-						 <+ 
+						( <get-cached-lib-ast(read-stratego-signatures);declare-stratego-globals-top>modulename
+						 <+
 						  <read-stratego-signatures;declare-stratego-globals-top> modulename
 						);
-						<record-legeacy-global-import-is-resolved>(namespace , modulename) 
-				  <+			
+						<record-legeacy-global-import-is-resolved>(namespace , modulename)
+				  <+
 						<debug-compiler>$[compile-main | compile-legacy-artifact | Error :  failed to resolve]
 				else
 					// Verify that the resource has a known extension.
 					<has-known-extensions>resolving-path ;
 					{|GetEnclosingModuleName, LegacyModuleResolvedPath:
 							<declare-current-module-scope> <get_internal_module_qtname> <GetEnclosingPackageName>;
-							with( rules(LegacyModuleResolvedPath := resolving-path));  
-						
-							// Known Extension found. Handling it.  
+							with( rules(LegacyModuleResolvedPath := resolving-path));
+
+							// Known Extension found. Handling it.
 							// Parsing the legacy content.
-							// Recoding the declarations for further analysis. 
+							// Recoding the declarations for further analysis.
 							<debug-compiler>$[compile-main | compile-legacy-artifact | Compiling following legacy artifacts : [<pp-aterm>resolving-path] for package : [<GetEnclosingPackageName;pp-aterm>]];
 							<declare-legacy-artifact(|resolving-path)><parse-legacy-artifact>resolving-path
 					|}
-				<+ 
-					<debug-compiler>$[compile-main | compile-legacy-artifact > Error occured in handling [<pp-aterm>resolving-path]. Hence, it is ignored.]  
-				end 	 
+				<+
+					<debug-compiler>$[compile-main | compile-legacy-artifact > Error occured in handling [<pp-aterm>resolving-path]. Hence, it is ignored.]
+				end
 			end
 		where
-			rules ( Resolved-ExternalArtifact : (namespace, modulename,resolving-path) ->resolving-path) 
+			rules ( Resolved-ExternalArtifact : (namespace, modulename,resolving-path) ->resolving-path)

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/esv/to-esv.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/esv/to-esv.str	Sat Jun  4 16:21:15 2011	(r22993)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/esv/to-esv.str	Sat Jun  4 16:34:11 2011	(r22994)
@@ -1,5 +1,5 @@
 module codegen/esv/to-esv
-imports 
+imports
 	libstratego-lib
 	libstrc
 imports
@@ -7,176 +7,179 @@
   config
   utils/debug
   utils/path
-imports 
-	normalize/signatures 
+imports
+  normalize/main
+	normalize/signatures
 	include/SpoofaxLang
-imports 
-	codegen/main 
+imports
+	codegen/main
 	codegen/generate
+	codegen/template/to-esv
 	context/-
 imports
 	lib/editor-common.generated
 
-	
-signature constructors 
+
+signature constructors
   Module : ID * Imports * List(Section) -> Module
-	
-rules 
+
+rules
 
 	/**
-	* Packs all the esv definitions for the namespace and combine them as a 
-	* single *.main.packed.esv and store it in .showdow dir
-	* 
-	* OPTIMIZATION : If we allow arbitary order of different sections of ESV , 
+	* Packs all the esv definitions for the namespace and combine them as a
+	* single *.main.packed.esv and store it in .shadow dir
+	*
+	* OPTIMIZATION : If we allow arbitary order of different sections of ESV ,
 	*								then we can avoid store-esv-definitions .
 	*/
 	generate-esv-main: module-qname* -> <id>
-		with 
+		with
  			 project-path             := <ProjectPath>;
  			 Package(package-qname)   := <GetEnclosingPackageName>
- 		where 
+ 		where
 			<debug-compiler>$[codegen | ESV | Generate-esv-main  : [<pp-aterm>package-qname]]
-		with	 
+		with
  			 relative-autogen-path := <qname-to-path>package-qname
  			;package-esv-main-name := $[[<get-main-file-name>()].main.packed]
  			;autogen-dir           := $[[<Autogenerated-Artifacts-Dir>]/[relative-autogen-path]]
  			;root-directory 			 := $[[project-path]/[<Autogenerated-Artifacts-Dir>]]
- 		where 
+ 		where
  			{|  //TODO : consider removing DR and use collect instead
  					Declared-Language-Description,Declared-Builders-Description,Declared-Colorer-Description,
  					Declared-Folding-Description,Declared-Outliner-Description,Declared-References-Description,
  					Declared-Completions-Description:
-						
+
  						<map(get-original-module-declaration;store-esv-defintions)>module-qname*
  						;sections := <conc>
  						 					(
  						 					 <inject-package-ctree><get-main-file-name>(),   // adding ctree import by default
  						 					 <inject-table-definition><get-main-file-name>(),   // default table definition
- 						 					 <all-keys-Declared-Language-Description>, 
- 			 								 <all-keys-Declared-Builders-Description> ,  
- 			 								 <all-keys-Declared-Colorer-Description> , 
+ 						 					 <all-keys-Declared-Language-Description>,
+ 			 								 <all-keys-Declared-Builders-Description> ,
+ 			 								 <all-keys-Declared-Colorer-Description> ,
  			 								 <all-keys-Declared-Folding-Description>,
  			 								 <all-keys-Declared-Outliner-Description>,
  			 								 <all-keys-Declared-References-Description>,
- 			 								 <all-keys-Declared-Completions-Description>
+ 			 								 <all-keys-Declared-Completions-Description>,
+ 			 								 <map(get-original-module-declaration; template-module-to-esv)> module-qname*
  			 							   )
- 			|} 
- 			;esv-aterm := Module(package-esv-main-name, Import([]), sections) 
+ 			|}
+ 			;esv-aterm := Module(package-esv-main-name, Import([]), sections)
  			;<save-artifact(WriteToBinaryFile | package-qname , root-directory , <get-main-output-path(|$[[<get-main-file-name>()].main], "esv")>(root-directory , package-qname))>esv-aterm
 		where
 			<debug-compiler>$[ Codegen | ESV | Finished generation of packed esv for [<pp-aterm>package-qname].]
-		 		
-	
+
+
 	//Adding package ctree as the default semantic provider0
-	inject-package-ctree : 
-		lang-name -> [Builders("",[SemanticProvider(lang-output-ctree)])]  
-		where 
+	inject-package-ctree :
+		lang-name -> [Builders("",[SemanticProvider(lang-output-ctree)])]
+		where
 				lang-output-ctree := $[include/[lang-name].ctree]
-	
-	
+
+
 	// Injects the default table definition in ESV definition.
-	inject-table-definition : 
+	inject-table-definition :
 		lang-name -> [Language("Default Table Specifiactio" , [default-table-def])]
 		where
 			default-table-def := Table($[include/[lang-name].tbl])
-			
-	
+
+
 	//Returns all the imports for the current namespace.
- 	get-all-imports = 
+ 	get-all-imports =
  		?mod-qname*
  		;import-decl* := <map(to-esv-import) ; flatten-list ;	make-set> mod-qname*
- 		;!Imports(import-decl* ) 		
-	 		
+ 		;!Imports(import-decl* )
+
 rules
-	
+
 	/**
 	* Converts ( package-name , concept-name) to stratego import
-	* 
-	* @type ( package-name, concept-name) -> Import(name) 
-	*/		
-	to-esv-import:  
+	*
+	* @type ( package-name, concept-name) -> Import(name)
+	*/
+	to-esv-import:
 		Module(q at QName(qnameparts*))->Import(esv-import)
-		where 
+		where
 			esv-import:= <qname-to-path>q
-	
- 
-rules			   
- 	
+
+
+rules
+
  	/**
- 	* Storing different Esv langauge definitions so that it can be 
- 	* combined in *.main.packed.esv in a particular order 
+ 	* Storing different Esv language definitions so that it can be
+ 	* combined in *.main.packed.esv in a particular order
  	*/
  	store-esv-defintions:
  		 m at Module(attrb* , modname , section*) -> m
 		 with
-		 	<alltd(store-esv-def)> section* 
- 
- 	
- 	// Storing Esv Definitions that specifies Langauge 
- 	store-esv-def : 
+		 	<alltd(store-esv-def)> section*
+
+
+ 	// Storing Esv Definitions that specifies Langauge
+ 	store-esv-def :
  		l at Language(_,properties*) -> l
- 		with 
+ 		with
  			rules ( Declared-Language-Description :+ l -> l)
- 		
- 			 	 
- 	
+
+
+
  	/**
- 	* Storing Esv Definitions that specifies the builders for the 
- 	* langauge definition. 
+ 	* Storing Esv Definitions that specifies the builders for the
+ 	* language definition.
  	*/
  	store-esv-def : b at Builders(_,_) -> b
- 		with 
- 			rules ( Declared-Builders-Description :+ b -> b) 
- 	
+ 		with
+ 			rules ( Declared-Builders-Description :+ b -> b)
+
  	/**
- 	* Storing Esv Definitions that specifies the colorer for the 
- 	* langauge definition. 
+ 	* Storing Esv Definitions that specifies the colorer for the
+ 	* language definition.
  	*/
  	store-esv-def : c at Colorer(_,_) -> c
- 		with 
- 			rules ( Declared-Colorer-Description :+ c -> c) 
- 	
+ 		with
+ 			rules ( Declared-Colorer-Description :+ c -> c)
+
  	/**
- 	* Storing Esv Definitions that specifies the folding semantics for the 
- 	* langauge definition. 
+ 	* Storing Esv Definitions that specifies the folding semantics for the
+ 	* language definition.
  	*/
  	store-esv-def : f at Folding(_,_) -> f
- 		with 
+ 		with
  			rules ( Declared-Folding-Description :+ f -> f)
- 	
+
  	/**
- 	* Storing Esv Definitions that specifies the outliner for the 
- 	* langauge definition. 
- 	*/		
+ 	* Storing Esv Definitions that specifies the outliner for the
+ 	* language definition.
+ 	*/
  	store-esv-def : o at Outliner(_,_) -> o
- 		with 
+ 		with
  			rules ( Declared-Outliner-Description :+ o -> o)
  	/**
  	* Storing Esv Definitions that specifies the code completion
- 	* for the langauge definition. 
+ 	* for the language definition.
  	*/
  	store-esv-def : c at Completions(_,_) -> c
- 		with 
+ 		with
  			rules ( Declared-Completions-Description:+ c -> c)
- 	
+
  	/**
  	* Storing Esv Definitions that specifies the refencen resolving constructs
- 	* for the langauge definition. 
+ 	* for the language definition.
  	*/
  	store-esv-def : r at References(_,_) -> r
- 		with 
+ 		with
  			rules ( Declared-References-Description :+ r -> r)
- 	
+
  	/*
  	* optimization - ignores following section that are not relevant to the current computations.
  	*		a] str sections
  	*		b] sdf sections
+ 	*   c] template sections
  	*/
  	store-esv-def : s at SDFSection (_) -> s //Do nothing
- 	
+
  	store-esv-def : s at SDFSectionEH (_,_) -> s //Do nothing
- 	
+
  	store-esv-def : s at STRSection (_) -> s //Do nothing
- 	 
- 	
- 	 
\ No newline at end of file
+
+  store-esv-def : s at TemplateSection(_) -> s //Do nothing

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/sdf/to-name-analysis.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/sdf/to-name-analysis.str	Sat Jun  4 16:21:15 2011	(r22993)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/sdf/to-name-analysis.str	Sat Jun  4 16:34:11 2011	(r22994)
@@ -1,20 +1,21 @@
 module codegen/sdf/to-name-analysis
-imports 
+imports
   libstrc
   lib/editor-common.generated
   context/sdf/declare-signature
   context/sdf/declare
-  include/SpoofaxLang 
+  include/SpoofaxLang
   analyze/sdf/check
-  
+  utils/attributes
+
 rules
-  
+
   generate-name-analysis:
     (selected, position, ast, path, project-path) -> (filename, result)
     with
       filename := <guarantee-extension(|"name-analysis.str")> path;
       result   := <generate-name-analysis; pp-stratego-string> selected
-    
+
   generate-name-analysis:
     sdf ->
     Module("analysis-generated", [
@@ -23,7 +24,7 @@
         scope-rules
       , get-def-rules
       , annotate-names-rules
-      ])  
+      ])
     ])
     with
       namespaces           := <collect-all(fetch-namespace); flatten-list> sdf;
@@ -33,21 +34,21 @@
       annotate-names-rules := <collect-all(fetch-annotate-names-rule)> sdf
 
 rules
-  
+
   fetch-namespace:
     namespacedef(n, _) -> n
-  
+
   fetch-namespace:
     namespaceref(n) -> n
-  
+
   fetch-namespace:
     namespaceref2(n, _) -> n
-  
+
   namespace-to-signature:
     name -> OpDecl(name, ConstType(SortNoArgs("Namespace")))
 
 rules
-  
+
   fetch-scope-rule:
     prod(p*, _, attrs(a*)) ->
     RDefNoArgs(
@@ -65,7 +66,7 @@
       scopes'     := <make-set> <flatten-list> scopes;
       p'*         := <filter(non-terminal-to-wld)> p*;
       scope-terms := <map(![NoAnnoList(Op(<id>, []))])> scopes'
-  
+
   fetch-get-def-rules:
     prod(p*, _, attrs(a*)) ->
     [ RDefNoArgs(
@@ -88,11 +89,11 @@
     ]
     where
       p'*  := <filter(namespace-def-to-x(?namespace) <+ non-terminal-to-wld)> p*;
-      where(!namespace); 
+      where(!namespace);
       cons := <getfirst(fetch-cons-name)> a*
-  
+
   fetch-annotate-names-rule:
-    prod(p*, _, attrs(a*)) -> 
+    prod(p*, _, attrs(a*)) ->
     RDefT(
       "nam-annotate-names"
     , []
@@ -110,40 +111,34 @@
       annotated-vars := <zip(add-namespace-anno-1 <+ add-namespace-anno-2)> (p'*, vars)
 
 rules
-  
+
   // TODO: what about productions with inner namespaces?
   //       e.g. Var@=ID?
-  
+
   namespace-def-to-x(set-namespace):
-    namespacedef(<set-namespace>, _) -> Var("x") 
-  
+    namespacedef(<set-namespace>, _) -> Var("x")
+
   non-terminal-to-wld:
     <is-non-terminal> -> Wld()
-  
+
   non-terminal-to-new-var:
     <is-non-terminal> -> Var(<new>)
-  
+
   add-namespace-anno-1:
     (namespaceref(n), Var(x)) -> <add-namespace-anno-1> (namespaceref2(n, "ID"), Var(x))
-  
+
   add-namespace-anno-1:
     (namespaceref2(n, _), Var(x)) ->
     App(
       CallT(SVar("nam-annotate-use"), [], [NoAnnoList(Op(n, []))])
     , Var(x)
     )
-  
+
   add-namespace-anno-1:
     (namespacedef(n, _), Var(x)) -> AnnoList(Var(x), [Var("def-path")])
-  
+
   add-namespace-anno-2:
     (_, Var(x)) -> Var(x)
-  
-  fetch-cons-name:
-    term(default(appl(unquoted("cons"), [fun(quoted(cons))]))) -> <un-double-quote> cons
-  
-  fetch-cons-name:
-    Constructor(cons) -> <un-double-quote> cons
-  
+
   fetch-scope-names:
     term(default(appl(unquoted("scope"), [fun(quoted(scopes))]))) -> scopes

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/sdf/to-sdf.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/sdf/to-sdf.str	Sat Jun  4 16:21:15 2011	(r22993)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/sdf/to-sdf.str	Sat Jun  4 16:34:11 2011	(r22994)
@@ -9,66 +9,67 @@
 	include/SpoofaxLang
 	lib/editor-common.generated
   lib/sdf-desugar
-  lib/sdf-parenthesize  
-imports 
-	
+  lib/sdf-parenthesize
+imports
 	context/-
 	context/sdf/declare
 imports
+  normalize/main
 	normalize/signatures
-imports 
+imports
 	common
 	config
 	utils/annotations
+	utils/attributes
 	utils/path
 	utils/debug
-imports 	 
+imports
 	codegen/main
-	codegen/generate  
+	codegen/generate
+	codegen/template/to-sdf
 	utils/contract
-	
-      
+
 rules
- 
+
 	 emit-sdf:m at Module(attrb* , modname , section*) -> m
- 		with 
+ 		with
  			project-path := <ProjectPath>
- 			;package-typed-qname := <GetEnclosingPackageName> 
-			;module-typed-qname  := <GetEnclosingModuleName> 
-			<+ 
+ 			;package-typed-qname := <GetEnclosingPackageName>
+			;module-typed-qname  := <GetEnclosingModuleName>
+			<+
 			<debug-compiler>$[ Codegen | SDF | Failed to create current scope.];fail
 		where
 			 !module-typed-qname  => Module(module-untyped-qname)
 			;!package-typed-qname => Package(package-untyped-qname)
-			; Module(_, _ , section') := <get-module-declaration>module-typed-qname 
+			; Module(_, _ , section') := <get-module-declaration>module-typed-qname
 		where
 			root-directory := $[[project-path]/[<Autogenerated-Artifacts-Dir>]]
-   		;output-path     := <get-output-path(|"sdf")>(root-directory , module-untyped-qname) 
+   		;output-path     := <get-output-path(|"sdf")>(root-directory , module-untyped-qname)
     	;<debug-compiler>$[ Codegen | SDF | Found Section + Imports for the following module [<pp-aterm> module-untyped-qname].]
     where
     	sdf-string       := <pp-sdf-string'> 'module(<qname-to-path>module-untyped-qname, <to-sdf-imports-block>section* , <to-sdf-section-block>section* )
     	;<debug-compiler>$[ Codegen | SDF | Saving the artifacts of [<pp-aterm> module-untyped-qname].]
 		where
-			<save-artifact(| package-untyped-qname , root-directory, output-path)>sdf-string; 
-			<debug-compiler>$[ Codegen | SDF | Finishing generation of SDF for [<pp-aterm> module-untyped-qname].] 
-		
+			<save-artifact(| package-untyped-qname , root-directory, output-path)>sdf-string;
+			<debug-compiler>$[ Codegen | SDF | Finishing generation of SDF for [<pp-aterm> module-untyped-qname].]
+
 	generate-sdf-main:  module-qname* -> <id>
-		with 
+		with
  			 project-path             := <ProjectPath>;
  			 Package(package-qname)   := <GetEnclosingPackageName>;
  			 relative-autogen-path :=  <qname-to-path>package-qname;
  			 autogen-dir :=$[[<Autogenerated-Artifacts-Dir>]/[relative-autogen-path]];
 			 root-directory := $[[project-path]/[<Autogenerated-Artifacts-Dir>]];
-			 main-sdf-module-name :=<get-main-file-name>(); 
+			 main-sdf-module-name :=<get-main-file-name>();
 			 output-path := <get-main-output-path(|main-sdf-module-name, "sdf")>(root-directory, package-qname);
 			<debug-compiler>$[ Codegen | SDF | Generating main for the following package : [<pp-aterm> package-qname].]
  		where
-			sdf-string := 
+			sdf-string :=
 	    $[module [main-sdf-module-name]
 	         imports
-		      	[<map(pp-sdf-import)>module-qname*]   									 
+		      	[<map(pp-sdf-import)>module-qname*]
 	     ]
-	  where 
+	  where
 	  	<debug-compiler>$[ codegen | SDF | Content of the main SDF is generated for the package : [<pp-aterm> package-qname].]
 		where
 			<save-artifact(| package-qname , root-directory, output-path)>sdf-string;
@@ -76,76 +77,79 @@
 
 rules
 
-	to-sdf-section-block : sections* -> sdf-section-block 
-	with contracts( 
+	to-sdf-section-block : sections* -> sdf-section-block
+	with contracts(
 		contract-requires ( is-list |sections*)
 	)
-	where 
-		sdf-section* := <collect-om(?SDFSection(<id>) + ?SDFSectionEH(_, <id>), conc)>sections*;
+	where
+		sdf-section* := <conc> (
+		  <collect-om(?SDFSection(<id>) + ?SDFSectionEH(_, <id>), conc)> sections*,
+		  <collect-om(?TemplateSection(_)); template-sections-to-sdf> sections*
+		);
 		if <ensure-list-is-not-empty>sdf-section* then
 			sdf-section-block := <to-generated-artifact-block(list-to-conc-grammars; topdown(repeat(desugar-sdf-redux)), \s -> [exports(s)]\)>sdf-section*
 		else
 			sdf-section-block := []
-		end 	
+		end
+
 
-		
 	to-sdf-imports-block : sections*  -> sdf-import-block
-	with contracts( 
+	with contracts(
 		contract-requires ( is-list |sections*)
 	)
-	where 
+	where
 		spx-import-stmt* := <collect-om(?Imports(<id>) , conc);flatten-list;make-set> sections*;
 		if <ensure-list-is-not-empty>spx-import-stmt*  then
 			sdf-import-block := <to-generated-artifact-block(to-generated-artifacts-import-declarations(sdf-import-adapter), \s -> ['imports(s)]\)>spx-import-stmt*
 		else
 			sdf-import-block := []
-		end		
- 
+		end
+
  	// Resolved Imports are alraedy filtered out in the previous step.
- 	// Hence, native spx imports are added without any further 
- 	// verifications. 
+ 	// Hence, native spx imports are added without any further
+ 	// verifications.
  	sdf-import-adapter : name  -> 	'module(unparameterized(name))
- 	where 
+ 	where
  		<is-string>name
-	
+
 	// Additional verification is done during importing legacy artifacts.
 	// Here, both Unresolved libraries and Stratego Libs are Ignored.
-	// Basically anything Unresolved is not added as a import statment in 
-	// generated SDF definition. 
-	sdf-import-adapter : legacy-artifact at Name(name)  -> 	result
+	// Basically anything Unresolved is not added as a import statment in
+	// generated SDF definition.
+ 	sdf-import-adapter : legacy-artifact at Name(name)  -> 	result
  	where debug
- 	where 
- 		if <has-extension(|"sdf")+has-extension(|"def")><UsedLegacyArtifacts>(<GetEnclosingPackageName> , name)then  
+ 	where
+ 		if <has-extension(|"sdf")+has-extension(|"def")><UsedLegacyArtifacts>(<GetEnclosingPackageName> , name)then
 				// Importing Legacy artifact only if it is a SDF or DEF file
-				// Assumption : resolved global imports refers to stratego lib and declared in global scope. 
+				// Assumption : resolved global imports refers to stratego lib and declared in global scope.
 				result :=  'module(unparameterized(name)) ;
-				<record-def-import-reference>name			
+				<record-def-import-reference>name
 		else
-				result :=  [] 	
-		end 
-	
-	// Recoding references of def file so that we can specify -Idef arguments in pack-sdf 
-	// It would have been much cleaner if Pack-SDF by defult supports it without specifying this extra arguments.  	
+				result :=  []
+		end
+
+	// Recoding references of def file so that we can specify -Idef arguments in pack-sdf
+	// It would have been much cleaner if Pack-SDF by defult supports it without specifying this extra arguments.
 	record-def-import-reference =
-		where( 
-			?def-import-path;	
-			// Verifying whether it is indeed a def file. 
+		where(
+			?def-import-path;
+			// Verifying whether it is indeed a def file.
 			if (<has-extension(|"def")><UsedLegacyArtifacts>(<GetEnclosingPackageName> , def-import-path)) then
-				package-typed-qname := <GetEnclosingPackageName> ; 
-				rules(ImportedDef :+ package-typed-qname  ->  def-import-path)	
-			end		
+				package-typed-qname := <GetEnclosingPackageName> ;
+				rules(ImportedDef :+ package-typed-qname  ->  def-import-path)
+			end
 		)
 
 rules
 
 	override pp-sdf-string = fail // ensure compiler doesn't blow up
-	
+
   pp-sdf-string' =
-    sdf-desugar; 
-    parenthesize-Sdf2; 
-  	sdf-ppfix; 
-    ast2box(|[<pp-table-sdf>]); 
-    box2text-string(|80)			 
+    sdf-desugar;
+    parenthesize-Sdf2;
+  	sdf-ppfix;
+    ast2box(|[<pp-table-sdf>]);
+    box2text-string(|80)
 
 rules
   // TODO: also support Constructor("Module(<2>, <1>)") => {ast("...")}?
@@ -153,7 +157,7 @@
   //  term(default(fun(quoted(s)))) -> term(default(appl(unquoted("cons"), [fun(quoted(s))])))
 
   desugar-sdf-redux:
-    Constructor(s) -> term(default(appl(unquoted("cons"), [fun(quoted(s))])))
+    Constructor(s) -> sdf-cons(s)
 
   // HACK: remove scope from output
   desugar-sdf-redux:
@@ -170,21 +174,22 @@
 
   desugar-sdf-redux:
     namespaceref2(n, s) -> s
-  
+
+rules
+
   list-to-conc-grammars:
     [g1, g2 | gs] -> conc-grammars(g1, <list-to-conc-grammars> [g2 | gs])
-  
+
   list-to-conc-grammars:
     [g1] -> g1
-  
+
   list-to-conc-grammars:
     [] -> []
-	
-rules 
-	
+
+rules
+
 	//pretty printing as sdf imports
-	pp-sdf-import: Module(q at QName(qnameparts*))-> result 
-		where 
+	pp-sdf-import: Module(q at QName(qnameparts*))-> result
+		where
 				result := $[[<qname-to-path >q]
 									 ]
-			
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/str/to-stratego.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/str/to-stratego.str	Sat Jun  4 16:21:15 2011	(r22993)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/str/to-stratego.str	Sat Jun  4 16:34:11 2011	(r22994)
@@ -1,122 +1,144 @@
 module codegen/str/to-stratego
-imports 
+imports
 	libstrc
 imports
   libstratego-lib
 	lib/editor-common.generated
 imports
   include/SpoofaxLang
-imports 
+imports
 	common
 	config
-	utils/debug	
+	utils/debug
 	utils/path
-	utils/annotations	
-imports 	
-	codegen/sdf/to-signature
+	utils/annotations
+imports
 	codegen/compile
+  codegen/generate
 	codegen/main
-	codegen/generate
 	codegen/sdf/to-name-analysis
-imports	
+  codegen/sdf/to-signature
+	codegen/template/to-str
+imports
 	context/-
-imports	
+imports
 	normalize/signatures
 	utils/contract
+	utils/sdf2conflicts
+
+
 
-	
-	
 rules
 	// emit STR definition for the specified SPX module.
  	emit-str:
 		m at Module(attrb* , modname , section*) -> m
-		with 
+		with
  			 project-path := <ProjectPath>
  			;root-dir := $[[project-path]/[<Autogenerated-Artifacts-Dir>]]
  		with
- 			package-typed-qname := <GetEnclosingPackageName> 
-			;module-typed-qname  := <GetEnclosingModuleName> 
-			<+ 
-			<debug-compiler>$[ Codegen | STR | Failed to create current scope.] 
+ 			package-typed-qname := <GetEnclosingPackageName>
+			;module-typed-qname  := <GetEnclosingModuleName>
+			<+
+			<debug-compiler>$[ Codegen | STR | Failed to create current scope.]
 			;fail
 		where
 			 !module-typed-qname  => Module(module-untyped-qname)
 			;!package-typed-qname => Package(package-untyped-qname)
 			;!modname             => SPXModuleName(modulename-string)
-			;<debug-compiler> $[CodeGen | STR | generating code for the following module : [<pp-aterm>module-untyped-qname]] 
-		where 
+			;<debug-compiler> $[CodeGen | STR | generating code for the following module : [<pp-aterm>module-untyped-qname]]
+		where
 			emit-str-rtree(| package-untyped-qname, module-untyped-qname, root-dir);
 			emit-str-concrte-syntax (|package-untyped-qname, module-untyped-qname, root-dir)
 	 	 ;<debug-compiler>$[ Codegen | STR | Finishing generation of following module: [<pp-aterm> module-untyped-qname].]
 
-	
+
 	// emit stratego concrete syntax
-	emit-str-concrte-syntax (|package-untyped-qname, module-untyped-qname , root-dir) : 
+	emit-str-concrte-syntax (|package-untyped-qname, module-untyped-qname , root-dir) :
 		str-rtree -> str-concrete-syntax
-		with 
+		with
 			output-path-str 	    := <get-output-path(|"str")>(root-dir, module-untyped-qname)
    	where
 			 str-concrete-syntax := <to-str-string>str-rtree
 			;<save-artifact(|package-untyped-qname, root-dir,output-path-str)> str-concrete-syntax
-	
-	// emit stratego rtree 
-	emit-str-rtree (|package-untyped-qname, module-untyped-qname , root-dir): 
+
+	// emit stratego rtree
+	emit-str-rtree (|package-untyped-qname, module-untyped-qname , root-dir):
 		Module(attrb* , modname , section*) -> str-aterm
 		with
 			output-path-rtree    := <get-output-path(|"rtree")>(root-dir, module-untyped-qname)
-		where  
-			 str-section-def := <conc>(<collect-om(?STRSection(<id>), conc)> section* ,<get-name-analysis>section*)     
+		where
+			 str-section-def := <conc>(<collect-om(?STRSection(<id>), conc)> section* ,<get-name-analysis>section*)
 			;str-aterm := Module(
-			 										 <qname-to-path>module-untyped-qname, 
-			 										 <conc>(<to-str-imports-block(|module-untyped-qname)>section*, 
+			 										 <qname-to-path>module-untyped-qname,
+			 										 <conc>(<to-str-imports-block(|module-untyped-qname)>section*,
 			 											  		str-section-def
 			 													 )
 			 										)
-			;<save-artifact(WriteToBinaryFile | package-untyped-qname, root-dir,output-path-rtree)> str-aterm 
+			;<save-artifact(WriteToBinaryFile | package-untyped-qname, root-dir,output-path-rtree)> str-aterm
 
 	// Generates main stratego module for the specified package-name
 	generate-str-main:  module-qname* -> <id>
-		with 
+		with
  			 project-path             := <ProjectPath>;
  			 Package(package-qname)   := <GetEnclosingPackageName>;
- 			 root-directory 					:= $[[project-path]/[<Autogenerated-Artifacts-Dir>]]; 
+ 			 root-directory 					:= $[[project-path]/[<Autogenerated-Artifacts-Dir>]];
  		   <debug-compiler> $[CodeGen | STR | Generate-str-main from package-name: [<pp-aterm>package-qname]]
- 		where   	  
- 			 main-str-module-name :=  <get-main-file-name>(); 
-			 str-aterm := Module( main-str-module-name  ,[Imports(<get-str-imports(|<GetEnclosingPackageName>)>module-qname*)]);
+ 		with
+ 			 main-str-module-name :=  <get-main-file-name>();
+       pp-module-name := <conc-strings>(main-str-module-name, "-prettyprinter");
+			 str-aterm := Module(main-str-module-name, [
+			   Imports(<get-str-imports(|<GetEnclosingPackageName>)>module-qname*),
+			   Imports([Import(pp-module-name)])
+			 ]);
 			 str-string := <pp-stratego-string> <parenthesize-Stratego>  str-aterm
-		where
+		with
 			<save-artifact(save-to-file      | package-qname , root-directory, <get-main-output-path(|main-str-module-name, "str")>(root-directory, package-qname))>str-string;
 			<save-artifact(WriteToBinaryFile | package-qname , root-directory, <get-main-output-path(|main-str-module-name, "rtree")>(root-directory, package-qname))>str-aterm;
-			<debug-compiler>$[ Codegen | STR | Generation of Main STR Module for package : [<pp-aterm> package-qname] is done.] 
+			<debug-compiler>$[ Codegen | STR | Generation of Main STR Module for package : [<pp-aterm> package-qname] is done.]
+	  with
+	    <debug-compiler>$[ Codegen | STR | Generating prettyprinter from package-name: [<pp-aterm>package-qname]];
+	    {|DeclaredModule, GetEnclosingModuleName, SubtermConflicts:
+	      // HACK: this lacks any sanity wrt the original modules in which the SDF was placed ...
+	      rules(
+	        DeclaredModule :+ "__prettyprinter" -> "__prettyprinter"
+	        GetEnclosingModuleName := Module("__prettyprinter")
+	      );
+        section* := <map(get-original-module-declaration; ?Module(_, _, <id>)); concat> module-qname*;
+        section'* := <filter(?SDFSection(_) + ?SDFSectionEH(_, _) + ?TemplateSection(_))> section*;
+        pp-aterm := <sdf2conflicts;template-sections-to-stratego> section'*
+	    |};
+      pp-string := <pp-stratego-string> <parenthesize-Stratego> pp-aterm;
+      pp-qname := <QName(at-last([<conc-strings>(<id>, "-prettyprinter")]))> package-qname;
+      <save-artifact(save-to-file      | pp-qname , root-directory, <get-main-output-path(|pp-module-name, "str")>(root-directory, pp-qname))> pp-string;
+      <save-artifact(WriteToBinaryFile | pp-qname , root-directory, <get-main-output-path(|pp-module-name, "rtree")>(root-directory, pp-qname))> pp-aterm;
+	    <debug-compiler>$[ Codegen | STR | Generation of prettyprinter : [<pp-aterm>package-qname] is done.]
+
 
-	 			
-				
 rules
-	
+
 	// get name analysis for  the specified sections
-	get-name-analysis : sections* -> result 
-	where 
+	get-name-analysis : sections* -> result
+	where
 		sdf-section* := <collect-om(?SDFSection(<id>) + ?SDFSectionEH(_, <id>), conc)>sections*;
 		Module(_, result) := <generate-name-analysis>sdf-section*
 	<+
 		<debug-compiler>$[ Codegen | STR | Failed name analysis.]
-	
-	
+
+
 
 rules
-	
-	to-str-string: sections* -> str-section-block  
-	where 
+
+	to-str-string: sections* -> str-section-block
+	where
 		str-section-block := <parenthesize-Stratego; pp-stratego-string>sections*
 
-	to-str-imports-block(|module-qname): sections*  ->str-import-block 
-	with 
-		contracts( 
+	to-str-imports-block(|module-qname): sections*  ->str-import-block
+	with
+		contracts(
 			contract-requires ( is-list |sections*);
 			contract-requires ( ?QName(_)|module-qname)
 		)
-	where 
+	where
 		spx-import-stmt* := <collect-om(?Imports(<id>) , conc);flatten-list;make-set> sections*;
 		if <ensure-list-is-not-empty>spx-import-stmt*  then
 			str-import-block' := <to-generated-artifact-block(to-generated-artifacts-import-declarations(to-str-import), \s -> [Imports(s)]\)>spx-import-stmt*
@@ -124,46 +146,46 @@
 			str-import-block' := []
 		end;
 		module-qualified-path := <qname-to-path>module-qname ;
-		str-import-block := <flatten-list>[[Imports([Import(<get-signature-file-name>module-qualified-path)])], str-import-block'] 
+		str-import-block := <flatten-list>[[Imports([Import(<get-signature-file-name>module-qualified-path)])], str-import-block']
 
 
-rules						 
-	
-	// Returns the import statements for this package. 
+rules
+
+	// Returns the import statements for this package.
 	// In addition, it imports Internal Signatures for this package
 	// And by default add reference to libstratego-lib
-	get-str-imports(|package-qname): module-qnames* -> result 
+	get-str-imports(|package-qname): module-qnames* -> result
 	where
-		result' := <map(to-str-import);flatten-list>module-qnames*    
+		result' := <map(to-str-import);flatten-list>module-qnames*
 	where
 		<to-str-import><get_internal_module_qtname>package-qname => [_, sig-import];
 		result := <conc>([Import("libstratego-lib"),sig-import] , result')
-	
+
 rules
-				
-	to-str-import: 
+
+	to-str-import:
 		package-name -> [Import(package-name) , Import(<get-signature-file-name>package-name)]
-		where 
+		where
 			<is-string>package-name
-			
-	to-str-import: 
-		legacy-artifact at Name(name)  -> 	result 
+
+	to-str-import:
+		legacy-artifact at Name(name)  -> 	result
  		where
 			if(
-				<UsedLegacyArtifacts>(Globals() , name) => Resolved() 
-			<+ 
+				<UsedLegacyArtifacts>(Globals() , name) => Resolved()
+			<+
 				<has-extension(|"str")+	has-extension(|"rtree")><UsedLegacyArtifacts>(<GetEnclosingPackageName> , name)
 			)
 			then
 				// Importing legacy artifact. Please note that , for legacy artifact, signatrue is not included
-				// as it is taken care of during signature generation of _Internal module for every package. 
-				result :=  [Import(name)] 
+				// as it is taken care of during signature generation of _Internal module for every package.
+				result :=  [Import(name)]
 			else
 				result :=  []
 			end
-		
-	to-str-import: 
+
+	to-str-import:
 		Module(q at QName(qnameparts*))->[Import(str-import),Import(sig-import)]
-		where 
+		where
 			str-import:= <qname-to-path>q;
 			sig-import:= <get-signature-file-name>str-import

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/template/to-esv.meta
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/template/to-esv.meta	Sat Jun  4 16:34:11 2011	(r22994)
@@ -0,0 +1 @@
+Meta([Syntax("Stratego-EditorService")])

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/template/to-esv.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/template/to-esv.str	Sat Jun  4 16:34:11 2011	(r22994)
@@ -0,0 +1,150 @@
+module to-esv
+imports
+  libstratego-lib
+  lib/EditorService
+  include/SpoofaxLang
+imports
+  context/sdf/declare
+  context/template/declare
+  normalize/templatelang
+  utils/attributes
+  utils/contract
+  utils/templatelang
+
+strategies
+
+	/** @type Module -> List(Completions) */
+	template-module-to-esv:
+		Module(_, _, section*) -> <template-sections-to-esv> section*
+
+  /** @type List(TemplateSection) -> List(Completions) */
+  template-sections-to-esv:
+    section* -> completion*
+    with
+      contracts(
+        contract-requires(List | section*)
+      )
+    with
+      completion* := <filter(template-section-to-esv); concat> section*
+    with
+      contracts(
+        contract-requires(ListOf(?CompletionTemplateEx(_, _, _, _)) | completion*)
+      )
+
+  /** @type TemplateSection -> List(CompletionTemplate) */
+  template-section-to-esv:
+  	TemplateSection(prod*) -> completion*
+  	with
+  	  contracts(
+  	    // FIXME: remove TemplateProductionWithCons/3 when desugaring is performed before code generation.
+  	    contract-requires(ListOf(?TemplateProduction(_, _, _) + ?TemplateProductionWithCons(_, _, _)) | prod*)
+  	  )
+  	with
+  	  // FIXME: desugaring should have been performed before the current strategy is invoked.
+  	  completion* := <templatelang-desugar-top; map(template-to-completion-template)> prod*
+  	with
+  	  contracts(
+  	    contract-requires(ListOf(?CompletionTemplateEx(_, _, _, _)) | completion*)
+  	  )
+
+/*internal*/ strategies
+
+  template-to-completion-template:
+    TemplateProduction(sort, Template(e* @[_|_]), attr*) -> t
+    with
+      part* := <template-elements-to-completion-parts> e*;
+      anno  := <template-sort-to-anno> sort;
+      if prefix := String(<collect-one(?sdf-cons(<un-double-quote>))> attr*) then
+        t := |[ completion template ~sort : ~prefix = ~*part* ~anno:anno ]|
+      else
+        t := |[ completion template ~sort : ~*part* ~anno:anno ]|
+      end
+
+  template-elements-to-completion-parts =
+    map(try(placeholder-to-completion-part));
+    remove-cursor-except-first;
+    try-re-indent;
+    trim-layout;
+    map(try(text-to-completion-part));
+    concatenate-consecutive-strings;
+    map(try(String(templatelang-escape)))
+
+  template-sort-to-anno =
+    CanNotBeBlank < !None() + !Blank()
+
+  placeholder-to-completion-part:
+    Placeholder(Text(name), sort(sort), None(), _) -> PlaceholderWithSort($[<[name]:], sort)
+
+  placeholder-to-completion-part:
+    Placeholder(None(), sort(sort), None(), _) -> t with t :=
+      PlaceholderWithSort($[<[<try(generate-placeholder)> sort]:], sort)
+
+  // FIXME: does this make sense?
+  generate-placeholder =
+    bagof-Declaration;
+    map(\TemplateProduction(_, Template(e*), _) -> e*\);
+    filter(not([])); // is this desired?
+    qsort((percentage-string-elements, percentage-string-elements); gt);
+    Hd;
+    template-elements-to-string
+
+  percentage-string-elements =
+    ?e*;
+    <divr> (<length> <filter(?String(_))> e*, <length> e*)
+
+  template-elements-to-string =
+    trim-layout;
+    filter(
+         \Placeholder(Text(x), _, _, _) -> x\
+      <+ \Placeholder(None(), sort(x), _, _) -> x\
+      <+ \String(x) -> x\
+      <+ \Layout(x) -> <string-replace(|"\t", " ")> x\
+    );
+    concat-strings
+
+  placeholder-to-completion-part:
+    Placeholder(_, _, Option(), _) -> Cursor()
+
+  placeholder-to-completion-part:
+    Placeholder(_, _, Plus(), _) -> Cursor()
+
+  placeholder-to-completion-part:
+    Placeholder(_, _, Star(), _) -> Cursor()
+
+  text-to-completion-part:
+    Newline(_) -> String("\n")
+
+  text-to-completion-part:
+    Layout(t) -> String(t)
+
+  text-to-completion-part:
+    Indent(t) -> String(<string-replace(|"  ", "\t")> t)
+
+// removing cursors (including layout before and newline after, if present)
+
+  remove-cursor-except-first =
+       [Layout(id) + Indent(id), Cursor(), Newline(id) | remove-cursor]
+    <+ [Cursor(), Newline(id) | remove-cursor]
+    <+ [Layout(id) + Indent(id), Cursor() | remove-cursor]
+    <+ [Cursor() | remove-cursor]
+    <+ [id | remove-cursor-except-first]
+    <+ []
+
+  remove-cursor =
+       \[<?Layout(_) + ?Indent(_)>, Cursor(), Newline(_) | tail] -> <remove-cursor> tail\
+    <+ \[Cursor(), Newline(_) | tail] -> <remove-cursor> tail\
+    <+ \[<?Layout(_) + ?Indent(_)>, Cursor() | tail] -> <remove-cursor> tail\
+    <+ \[Cursor() | tail] -> <remove-cursor> tail\
+    <+ [id | remove-cursor]
+    <+ []
+
+strategies
+
+  nonempty-substring-from-last-occurence-of(|t) =
+    substring-after-last-occurence-of(|t);
+    not("");
+    <conc-strings> (t, <id>)
+
+  substring-after-last-occurence-of(|t) =
+    where(is-substring(!t));
+    repeat(is-substring(!t); implode-string)

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/template/to-sdf.meta
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/template/to-sdf.meta	Sat Jun  4 16:34:11 2011	(r22994)
@@ -0,0 +1 @@
+Meta([Syntax("Stratego-Sdf2")])

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/template/to-sdf.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/template/to-sdf.str	Sat Jun  4 16:34:11 2011	(r22994)
@@ -0,0 +1,224 @@
+module to-sdf
+imports
+  libstratego-lib
+  include/SpoofaxLang
+imports
+	common
+  context/template/declare
+  normalize/templatelang
+  utils/annotations
+  utils/contract
+  utils/debug
+  utils/tokenize
+  utils/templatelang
+
+strategies
+
+  /** @type List(TemplateSection) -> List(grammar) */
+  template-sections-to-sdf:
+    section* -> sdf-section'*
+    with
+    	contracts(
+        contract-requires(ListOf(?TemplateSection(_)) | section*)
+      )
+    with
+      // FIXME: desugaring should have been performed before the current strategy is invoked.
+      sdf-section*  := <templatelang-desugar-top; map(template-section-to-sdf)> section*;
+      sdf-section'* := <add-lexical-restrictions> sdf-section*
+    with
+      contracts(
+        contract-requires(ListOf(?context-free-syntax(_) + ?lexical-restrictions(_)) | sdf-section'*)
+    	)
+
+/*internal*/ strategies
+
+  /** @type TemplateSection -> grammar */
+  template-section-to-sdf:
+    TemplateSection(prod*) -> G|[
+      context-free syntax
+        p*
+    ]|
+    with
+      // main productions
+      // FIXME: declaring should have been performed before the current strategy is invoked.
+      p* := <declare-template-definition-main; map(template-production-to-sdf)> prod*
+
+  /** @type List(grammar) -> List(grammar) */
+  add-lexical-restrictions:
+    sdf-section* -> [sdf-section*, restrictions*]
+    with
+      let ends-with-identifier-char =
+            where(
+              explode-string;
+              /*un-double-quote-chars;*/
+              // Must end with idenfifier character, may not be preceded by backslash.
+              reverse; ?[<is-alphanum + '_' + '-'> | <not(?['\' | _])>]
+            )
+      in
+        A* := <collect-om(lit(ends-with-identifier-char)); nub; string-sort-ex> sdf-section*;
+        if !A* => [] then
+          restrictions* := []
+        else
+          restrictions* := [|[ lexical restrictions
+                                 A* -/- [A-Za-z0-9\_\-] ]|]
+        end
+      end
+
+  template-production-to-sdf-no-attrs:
+    TemplateProduction(S', t, _) -> p|[ A* -> S' ]|
+    with
+      A* := <template-to-sdf> t
+
+  template-production-to-sdf:
+    TemplateProduction(S', t, attrs') -> p|[ A* -> S' attrs' ]|
+    with
+      A* := <template-to-sdf> t
+
+  template-to-sdf:
+    Template(e* @[_|_]) -> A*
+    with
+      A* := <newlines-switch(id, trim-trailing-layout, trim-leading-layout);
+             combine-consecutive-newlines;
+             filter(template-element-to-sdf);
+             flatten-list> e*
+
+  template-to-sdf:
+    Template([]) -> []
+
+  template-element-to-sdf:
+    Newline(_){ /* neither Leading() nor Trailing() */ } -> A|[ "\\n" ]|
+    where not(use-no-newlines)
+
+  template-element-to-sdf:
+    Newline(_) -> A|[ "\\n" ]|
+    where use-leading-newlines
+    where not(has-annotation(|Leading()))
+
+  template-element-to-sdf:
+    Newline(_) -> A|[ "\\n" ]|
+    where use-trailing-newlines
+    where not(has-annotation(|Trailing()))
+
+  template-element-to-sdf:
+    String(x) -> <string-to-sdf> x
+
+// FIXME: unbreak this (remember to add {} anno to next strategy)
+/*
+  // Insert "\n" into generated grammar whenever
+  // 1) leading or trailing newlines is enabled
+  // 2) the sort itself does not contain a leading resp. trailing newline
+  // 3) the placeholder is on its own on the line
+  template-element-to-sdf:
+    p@ Placeholder(_, sort(sort), None(), _){Blank()} -> t'
+    with
+      t := <placeholder-to-sdf> p;
+      t' := <newlines-switch(id,
+        if not(<sort-has-leading-newline> sort) then
+          ?A; !A|[ ("\\n" A) ]|
+        end,
+        if not(<sort-has-trailing-newline> sort) then
+          ?A; !A|[ (A "\\n") ]|
+        end
+      )> t
+
+  // FIXME: generates suboptimal SDF (bad AST)
+  template-element-to-sdf:
+    p@ Placeholder(_, sort(sort), <?Plus() + ?Star() + ?Option()>, _){Blank()} -> t'
+    with
+      t := <placeholder-to-sdf> p;
+      t' := <newlines-switch(id,
+        if not(<sort-has-leading-newline> sort) then
+          ?A; !A|[ ("\\n" A)? ]|
+        end,
+        if not(<sort-has-trailing-newline> sort) then
+          ?A; !A|[ (A "\\n")? ]|
+        end
+      )> t
+*/
+
+  template-element-to-sdf:
+    Placeholder(_, _, _, _) -> <placeholder-to-sdf>
+
+  placeholder-to-sdf:
+    Placeholder(_, sort(S'), None(), _) -> A|[ S' ]|
+
+  // TODO: this needs improvement, too much duplication and not readable enough
+
+  placeholder-to-sdf:
+    Placeholder(_, sort(S), Star(), Options(option*)) -> A|[ S* ]|
+    where <not(one(Separator(not(all-whitespace))))> option*
+
+  placeholder-to-sdf:
+    Placeholder(_, sort(S), Star(), Options(option*)) -> A|[ { S L }* ]|
+    where <one(Separator(not(all-whitespace)))> option*
+    with L := <separator-to-literal> option*
+
+  placeholder-to-sdf:
+    Placeholder(_, sort(S), Plus(), Options(option*)) -> A|[ S+ ]|
+    where <not(one(Separator(not(all-whitespace))))> option*
+
+  placeholder-to-sdf:
+    Placeholder(_, sort(S), Plus(), Options(option*)) -> A|[ { S L }+ ]|
+    where <one(Separator(not(all-whitespace)))> option*
+    with L := <separator-to-literal> option*
+
+  // name conflicts with is-whitespace from the library
+  xxx-is-whitespace =
+    // if use-no-newlines then
+      ' ' + '\t' + '\r' + '\n'
+    // else
+    //   ' ' + '\t' + '\r'
+    // end
+
+  all-whitespace = string-as-chars(all(xxx-is-whitespace))
+
+  remove-whitespace = string-as-chars(filter(not(xxx-is-whitespace)))
+
+  separator-to-literal =
+    collect-one(?Separator(<remove-whitespace>)); escape//; double-quote
+
+  placeholder-to-sdf:
+    Placeholder(_, sort(S'), Option(), _) -> A|[ S'? ]|
+
+  sort-to-contentcomplete:
+    S' -> p|[ CONTENTCOMPLETE -> S' {cons("WATER"), avoid} ]|
+
+  sort-to-insertion:
+    S'@sort(x) -> p|[ -> S' {cons("INSERTION"), recover} ]|
+
+strategies
+
+  /**
+   * Sorts a list of terms on the outermost string within each term.
+   */
+  string-sort-ex =
+    qsort(
+      \(a, b) -> (<collect-one(is-string)> a, <collect-one(is-string)> b)\;
+      string-lt
+    )
+
+  string-to-sdf =
+    string-identifier-tokenize;
+    // FIXME: Case insensitive literals need ci-lit/single-quote.
+    map({raw, sdf:
+      ?raw; escape; !lit(</*double-quote*/ id >); ?sdf;
+      if <explode-string; last; (is-alphanum + '_')> raw then
+        rules(Restrictions :+= sdf)
+      end
+    })
+
+  /**
+   * Split on the edges delimiting identifiers and then strip layout
+   * from the resulting tokens and remove empty tokens.
+   * E.g. " func ( x y )" => ["func", "(", "x", "y", ")"]
+   */
+  string-identifier-tokenize =
+    // FIXME: Use layout defined by the language.
+    let is-layout = ' ' + '\t' + '\n' + '\r'
+        strip-layout = string-as-chars(filter(not(is-layout)))
+    in
+      // FIXME: Use identifier lexical defined by the language.
+      string-edge-tokenize(is-alphanum + '_');
+      filter(strip-layout; not(""))
+    end
+

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/template/to-str.meta
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/template/to-str.meta	Sat Jun  4 16:34:11 2011	(r22994)
@@ -0,0 +1 @@
+Meta([Syntax("StrategoStratego")])

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/template/to-str.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/template/to-str.str	Sat Jun  4 16:34:11 2011	(r22994)
@@ -0,0 +1,223 @@
+module to-str
+
+imports
+  libstratego-lib
+  libstrc
+  include/SpoofaxLang
+imports
+  context/str/parse
+	context/template/declare
+	normalize/templatelang
+  utils/sdf2conflicts
+  utils/templatelang
+
+strategies
+
+  template-sections-to-stratego =
+    template-sections-to-stratego-string;
+    parse-stratego-string;
+    alltd(try(un-double-quote); unescape)
+
+  template-sections-to-stratego-string:
+    section* ->
+    $[module prettyprinter
+      imports
+        libstratego-lib
+
+      strategies
+
+        pp-option(s) = \None() -> ""\ + \Some(t) -> <s> t\
+        pp-list(s|t) = map(s); separate-by(|t); concat-strings
+
+        [ih]
+
+      [section''*]
+
+      strategies // all other sorts used in placeholders
+
+        [strategy*]]
+    with
+      section'*  := <templatelang-desugar-top> section*;
+      section''* := <filter(template-section-to-stratego-string);
+                     separate-by(|"\n\n")> section'*
+    with
+      // All sorts used in pp minus all sorts for which a pp strategy has been
+      // created will get a `prettyprint-sort = is-string' default strategy.
+      sorts-used-in-pp := <collect-om(sort-used-in-prettyprinting); nub> section'*;
+      sorts-decl-in-pp := <collect-om(sort-decl-in-prettyprinting); nub> section'*;
+      sorts-without-pp := <diff> (sorts-used-in-pp, sorts-decl-in-pp);
+      strategy* := <map(sort-to-prettyprint-strategy); separate-by(|"\n\n")> sorts-without-pp
+    with
+      ih := <newlines-switch(
+        // No newlines: need to prepend a newline+indent if the string is non-empty.
+        !$[// ih = indent helper, t = indent string (including "\n")
+           pp-ih(|t) = ?"" <+ string-replace(|"\n", t); <conc-strings> (t, <id>)],
+        // Leading newlines: easy, since indent is (per definition) also leading.
+        !$[// ih = indent helper, t = indent string (including "\n")
+           pp-ih(|t) = ?"" <+
+             string-replace(|"\n", t);
+             if not(string-starts-with(|t)) then
+               <conc-strings> (t, <id>)
+             end],
+        // Trailing newlines: harder, since indent and newline are separated.
+        !$[// ih = indent helper, t = indent string (excluding "\n")
+           pp-ih(|t) = ?"" <+ all-lines(<conc-strings>(t, <id>))]
+      )>
+
+  template-section-to-stratego-string:
+    TemplateSection(prod*) ->
+    $[strategies
+
+        [strategy*]]
+    with
+      strategy* := <declare-template-definition-main;
+                    map(template-to-prettyprint-strategy);
+                    separate-by(|"\n\n")> prod*
+
+/*internal*/ strategies
+
+  sort-to-prettyprint-strategy:
+    sort -> $[prettyprint-[sort] = is-string]
+
+  sort-decl-in-prettyprinting:
+    TemplateProduction(sort, Template(_), _) -> sort
+
+  sort-used-in-prettyprinting:
+    Placeholder(_, sort(sort), _, _) -> sort
+
+  // Optimization for single-string-element templates
+  template-to-prettyprint-strategy:
+    TemplateProduction(sort, Template([String(t)]), attr*) ->
+    $[prettyprint-[sort]:
+        [cons]() -> "[result]"]
+    where
+      cons   := <collect-one(?sdf-cons(<un-double-quote>))> attr*
+    with
+      result := <templatelang-escape> t
+
+  template-to-prettyprint-strategy:
+    TemplateProduction(sort, Template(elem*), attr*) ->
+    <trim-chars(' ' + '\t' + '\r' + '\n')> // Workaround Stratego/856
+    $[prettyprint-[sort]:
+        [cons]([arg'*]) -> zz
+        with
+          [let'*]]
+    where
+      not(!elem* => [String(_)])
+    where
+      cons    := <collect-one(?sdf-cons(<un-double-quote>))> attr*
+    with
+      elem'*  := <try-re-indent;
+                  !(<id>, 0);
+                  thread-map(try(rename-template-element));
+                  ?(<id>, _)> elem*;
+      arg*    := <filter(template-element-to-cons-arg)> elem'*;
+      arg'*   := <separate-by(|", ")> arg*;
+      part*   := <newlines-switch(trim-layout, trim-trailing-layout,
+                                  trim-leading-layout ; trim-trailing-indent);
+                  listtd(template-element-to-stratego);
+                  concatenate-consecutive-strings;
+                  map(try(?String(<templatelang-escape; double-quote>)));
+                  separate-by(|", ")> elem'*;
+      result  := <concat-strings>["zz := <concat-strings> [", part*, "]"];
+      confl*  := <bagof-SubtermConflicts> Symbol(cons, <length> arg*);
+      if !confl* => [] then
+        let*  := <filter(template-element-to-prettyprint)> elem'*
+      else
+        let*  := <filter(?Placeholder(_, _, _, _));
+                  add-indices; map((dec, id));
+                  filter(template-element-to-parenthesize(|confl*))> elem'*
+      end;
+      let'*   := <separate-by(|";\n")> [let*, result]
+
+  // Production without cons but with bracket annotation
+  // (cons + bracket -> no need to parenthesize)
+  template-to-prettyprint-strategy:
+    TemplateProduction(sort, Template(elem*), attr*) ->
+    ${parenthesize-{sort}(not-allowed) =
+        if not-allowed then
+          <concat-strings> ["{open}", <prettyprint-{sort}>, "{close}"]
+        else
+          prettyprint-{sort}
+        end}
+    where
+      not(<collect-one(?sdf-cons(<un-double-quote>))> attr*);
+      <collect-one(?bracket())> attr*
+    where
+      <length> <filter(?Placeholder(_, _, _, _))> elem* => 1
+      <+ debug(!"Bracket production must have exactly one placeholder: "); fail
+    with
+      (before, placeholder, after) := <split-fetch-keep(?Placeholder(_, _, _, _))> elem*
+    where
+      [String(open)]  := <map(template-element-to-stratego'); concatenate-consecutive-strings> before;
+      [String(close)] := <map(template-element-to-stratego'); concatenate-consecutive-strings> after
+      <+ debug(!"Bracket production must have text before and after the placeholder: "); fail
+
+  rename-template-element:
+    (Placeholder(a, b@ sort(x), c, d){a*}, index) -> (Placeholder(a, b{newname}, c, d){a*}, newindex)
+    with
+      newname  := <implode-string> [<addi> ('a', index)];
+      newindex := <inc> index
+
+  template-element-to-cons-arg:
+    Placeholder(_, sort(_){name}, _, _) -> name
+
+  template-element-to-stratego =
+    newlines-switch(
+      // No newlines
+      \[Newline(_), Indent(indent), Placeholder(_, sort(_){name}, _, _){Blank()} | tail] ->
+        [$[<pp-ih(|"\n[indent]")> [name]'] | tail]\,
+      // Leading newlines
+      \[Newline(_), Indent(indent), Placeholder(_, sort(_){name}, _, _){Blank()} | tail] ->
+        [$[<pp-ih(|"\n[indent]")> [name]'] | tail]\,
+      // Trailing newlines
+      \[Indent(indent), Placeholder(_, sort(_){name}, _, _){Blank()}, Newline(_) | tail] ->
+        [$[<pp-ih(|"[indent]")> [name]'] | tail]\
+    )
+    // Anything else.
+    <+
+      [template-element-to-stratego' | id]
+    <+
+      []
+
+  template-element-to-stratego' =
+      \Placeholder(_, sort(_){name}, _, _) -> $[[name]']\
+    + \String(t) -> String(t)\
+    + \Layout(t) -> String(t)\
+    + \Indent(t) -> String(t)\
+    + \Newline(t) -> String(t)\
+
+  template-element-to-prettyprint:
+    Placeholder(_, sort(x){name}, None(), _) -> $[[name]' := <prettyprint-[x]> [name]]
+
+  template-element-to-prettyprint:
+    Placeholder(_, sort(x){name}, <Star() + Plus()>, Options(opt*)) -> t
+    with
+      if sep := <collect-one(?Separator(<id>))> opt* then
+        t := $[[name]' := <pp-list(prettyprint-[x]|"[<escape> sep]")> [name]]
+      else
+        t := $[[name]' := <pp-list(prettyprint-[x]|" ")> [name]]
+      end
+
+  template-element-to-prettyprint:
+    Placeholder(_, sort(x){name}, Option(), _) -> $[[name]' := <pp-option(prettyprint-[x])> [name]]
+
+  template-element-to-parenthesize(|conflicts):
+    (i0, Placeholder(_, sort(x){name}, None(), _)) -> $[[name]' := <parenthesize-[x]([na])> [name]]
+    where
+      not(<filter(?(i0, <id>))> conflicts => conflicts' => [])
+    with
+      let to-match =
+            {a*: \ Symbol(x, n) -> <concat-strings> ["?", x, "(", a*, ")"]
+                   with a* := <range; map(!"_"); separate-by(|", ")> (0, n) \}
+      in
+        na := <filter(to-match); separate-by(|" + ")> conflicts'
+      end
+
+  template-element-to-parenthesize(|conflicts):
+    (i0, p@ Placeholder(_, sort(x){name}, None(), _)) -> <template-element-to-prettyprint> p
+    where
+      <filter(?(i0, _))> conflicts => []
+
+  template-element-to-parenthesize(|conflicts):
+    (i0, p@ Placeholder(_, sort(x){name}, <not(?None())>, _)) -> <template-element-to-prettyprint> p

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/declare.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/declare.str	Sat Jun  4 16:21:15 2011	(r22993)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/declare.str	Sat Jun  4 16:34:11 2011	(r22994)
@@ -1,23 +1,24 @@
 module context/declare
 
-imports 
+imports
 	context/sdf/declare
 	context/sdf/declare-signature
 	context/str/declare
+	context/template/declare
 	context/-
-	normalize/signatures 
-imports 
+	normalize/signatures
+imports
 	include/SpoofaxLang
 	lib/editor-common.generated
 imports
 	utils/annotations
 	utils/debug
 	utils/contract
-	config	
+	config
 	common
 
-rules		
-	declare-package = 
+rules
+	declare-package =
 		contracts(
 			contract-requires(
 				?Package(QName(_))
@@ -26,118 +27,107 @@
 		get-enclosed-modules;
 		map(get-module-declaration);
 		list-loop(declare-module(declare-global-symbol))
-	
+
 	declare-module(s) = origin-track-forced(s)
-		
-	declare-all = declare-sdf-all; declare-esv-all ; declare-str-all; update-modified-module-declaration   
-	
-	declare-global-symbol = declare-str-global ;  update-modified-module-declaration
-		
-	init-declaration = init-record-signatures 
-
-	
-rules 
-	
+
+	declare-all = declare-spxmodules-all(declare-section); update-modified-module-declaration
+
+	declare-global-symbol = declare-global ;  update-modified-module-declaration
+
+	init-declaration = init-record-signatures ; init-template-options
+
+
+rules
+
 	declare-legacy-artifact(|resolved-path) : legacy-content -> legacy-content
-	where 
-		<has-extension(|"sdf") + has-extension(|"def")>resolved-path; 
+	where
+		<has-extension(|"sdf") + has-extension(|"def")>resolved-path;
 		<alltd(declare-sdf-definition-main)>legacy-content
-		
+
 	declare-legacy-artifact(|resolved-path) : legacy-content -> legacy-content
-	where 
-		<has-extension(|"str") + has-extension(|"rtree")>resolved-path; 
+	where
+		<has-extension(|"str") + has-extension(|"rtree")>resolved-path;
 		<alltd(declare-str-definition-main)>legacy-content
 
-rules	
-	
-	declare-sdf-all = declare-spxmodules-all(declare-sdf-section) 
-	declare-str-all = declare-spxmodules-all(declare-str-section)
-	declare-esv-all = declare-spxmodules-all(declare-esv-section)
-	declare-str-global = declare-spxmodules-all(declare-str-global-section)
-	
-	
-rules
-	
-	declare-spxmodules-all(s): 
-		Module(attrb* , modname , section*) -> Module(attrb* , modname , m-sections*) 
+rules
+
+	declare-global = declare-spxmodules-all(declare-global-section)
+
+
+rules
+
+	declare-spxmodules-all(s):
+		Module(attrb* , modname , section*) -> Module(attrb* , modname , m-sections*)
 		where
 			<alltd(s)>section* => m-sections*
-			
+
 	update-modified-module-declaration:
 		m at Module(attrb* , modname , section*) -> m
 		with
 				Package( package-qname) := <get-annotation(get-package-annotation)>modname
-		with 
-			<store-declaration(|Modules())>(<get-module-untyped-qname>(package-qname, modname),  m) 
-	
-rules 
-	declare-sdf-section: 
-		SDFSection(definition*) ->SDFSection(declared-definition*) 
-		where 
-			declared-definition* := <alltd(declare-sdf-definition-main)>definition*
-	
-	declare-sdf-section: 
-		SDFSectionEH(_,definition*) -><declare-sdf-section>SDFSection(definition*) 
-		
-	
-	declare-sdf-section: STRSection(def*) -> <id>
- 
-	declare-sdf-section: ESVSection(def*) -> <id>  
-
-rules	
-	declare-str-section: SDFSection(def*) -> <id>
-	
-	declare-str-section: SDFSectionEH(_,def*) -> <id>
-	
-	declare-str-section: s at STRSection(def*) -> STRSection(m-definition*)
-	where 
-		m-definition* := <declare-str-definition-main>def*
-	
-		
-	declare-str-section: ESVSection(def*) -> <id>   
-
-rules
-	
-	declare-str-global-section: SDFSection(def*) -> <id>
-	
-	declare-str-global-section: SDFSectionEH(_,def*) -> <id>
-	
-	declare-str-global-section: s at STRSection(def*) -> STRSection(m-definition*)
-	where 
+		with
+			<store-declaration(|Modules())>(<get-module-untyped-qname>(package-qname, modname),  m)
+
+rules
+	declare-section:
+		SDFSection(definition*) ->SDFSection(declared-definition*)
+		where
+			declared-definition* := <declare-sdf-definition-main>definition*
+
+	declare-section:
+		SDFSectionEH(_,definition*) -><declare-section>SDFSection(definition*)
+
+	declare-section:
+	  STRSection(def*) -> STRSection(m-definition*)
+    where
+      m-definition* := <declare-str-definition-main>def*
+
+  declare-section: ESVSection(def*) -> <id>
+
+  // TemplateLang
+  declare-section:
+    TemplateSection(definition*) -> TemplateSection(declared-definition*)
+    with
+      declared-definition* := <declare-template-definition-main> definition*
+
+  // TemplateLang
+  // FIXME: move to spoofax.configuration?
+  declare-section:
+  	TemplateOptions(option*) -> TemplateOptions(declared-option*)
+  	with
+  	  declared-option* := <declare-template-options-main> option*
+
+rules
+
+	declare-global-section: SDFSection(def*) -> <id>
+
+	declare-global-section: SDFSectionEH(_,def*) -> <id>
+
+	declare-global-section: s at STRSection(def*) -> STRSection(m-definition*)
+	where
 		m-definition* := <declare-stratego-globals-top>def*
-	
-		
-	declare-str-section: ESVSection(def*) -> <id>   
-
-rules	
-	
-	declare-esv-section: SDFSection(def*) -> <id>
-	
-	declare-esv-section: SDFSectionEH(_, def*) -> <id>
-	
-	declare-esv-section: STRSection(def*) -> <id>
- 
-	declare-esv-section: ESVSection(def*) -> <id> 
-	
-	
-	
-	
+
+  // TemplateLang
+  declare-global-section: TemplateSection(def*) -> <id>
+
+  // TemplateLang
+  declare-global-section: TemplateOptions(opt*) -> <id>
+
 rules
 
-	// Declaring current scope for further analyze 
+	// Declaring current scope for further analyze
 	declare-current-scope(| package-typed-qname , module-typed-qname)=
 		with(
 			<declare-current-package-scope>package-typed-qname;
 			<declare-current-module-scope>module-typed-qname
-		) 
+		)
 
-	declare-current-package-scope : 
-		package-typed-qname -> <id> 
-		with 
+	declare-current-package-scope :
+		package-typed-qname -> <id>
+		with
 			rules ( GetEnclosingPackageName      := package-typed-qname)
-		
+
 	declare-current-module-scope:
-			module-typed-qname -> <id> 
-			with 
+			module-typed-qname -> <id>
+			with
 				rules ( GetEnclosingModuleName      := module-typed-qname)
-	 	   
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/parse-adapter.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/parse-adapter.str	Sat Jun  4 16:21:15 2011	(r22993)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/parse-adapter.str	Sat Jun  4 16:34:11 2011	(r22994)
@@ -4,9 +4,9 @@
 	include/SpoofaxLang
 	context/signatures
 	normalize/signatures
-	lib/Configuration/SpoofaxConfiguration  
+	lib/Configuration/SpoofaxConfiguration
 	lib/editor-common.generated
-imports 
+imports
 	context/sdf/parse
 	context/str/parse
 	codegen/-
@@ -14,26 +14,26 @@
 	utils/path
 	utils/debug
 	utils/cache
-	utils/contract	
+	utils/contract
 	config
 	common
-	
+
 rules
 
-	parse-spx-sources : 
+	parse-spx-sources :
 		(sourcedir , searchOption) -> <id>
 		where
-			{| current-working-root-dir :  
+			{| current-working-root-dir :
 					rules(
 						current-working-root-dir  := <get-project-path>
 					);
-					if run-strategy( <chdir>sourcedir , fail | $[Warning | Failed to change current directory to : [<pp-aterm>sourcedir]]) then 
+					if run-strategy( <chdir>sourcedir , fail | $[Warning | Failed to change current directory to : [<pp-aterm>sourcedir]]) then
 						<parse-spx-compilationUnits(|searchOption)> <getcwd>;
 						run-strategy( <chdir> <current-working-root-dir> , fail | $[Warning | Failed  to change current directory to : [<pp-aterm><current-working-root-dir>]])
 					end
 			|}
-		
-	parse-spx-compilationUnits(|search-option) = 
+
+	parse-spx-compilationUnits(|search-option) =
 		readdir;
 		list-loop(
     	if <isdir> <filemode> then  //FIXME : filemode / isdir contains bug. Common folder is not considered as directory which is a bug
@@ -43,45 +43,44 @@
            <chdir> ".."
         end
       else
-        where(parse-spx-compilationUnit) <+ throw-unable-read-file 
+        where(parse-spx-compilationUnit) <+ throw-unable-read-file
       end
     )
-    
+
  	parse-spx-compilationUnit: filename -> <id>
  		where
- 			if has-extension(|"spx") then 
-	 			where (<debug-compiler>$[Pre-Compiling| Parsing following file : [<pp-aterm>]]); 
+ 			if has-extension(|"spx") then
+	 			where (<debug-compiler>$[Pre-Compiling| Parsing following file : [<pp-aterm>]]);
 	 			open-spx-compilation-unit(
-					spx-compilation-unit-path, 
-					spx-precompiled-cache-path, 
+					spx-compilation-unit-path,
+					spx-precompiled-cache-path,
 					parse-spoofaxlang-file ,
-					pre-complile-compilation-unit
+					pre-compile-compilation-unit
 				)
-			end 
+			end
+
 
-	
 rules
-	
-	parse-legacy-artifact: 
+
+	parse-legacy-artifact:
 		resolved-path-> parsed-string
-		where 
+		where
 			has-extension(|"sdf") + has-extension(|"def")
-		where 
+		where
 			parsed-string:= <parse-sdf-file>resolved-path
-	
-	
-	parse-legacy-artifact: 
+
+
+	parse-legacy-artifact:
 		resolved-path -> parsed-string
-		where 
+		where
 			has-extension(|"str")
-		where 
+		where
 			parsed-string:= <parse-stratego>resolved-path
-	
-	
-	parse-legacy-artifact: 
+
+
+	parse-legacy-artifact:
 		resolved-path -> parsed-string
-		where 
-			has-extension(|"rtree") 
-		where 
+		where
+			has-extension(|"rtree")
+		where
 			parsed-string:= <ReadFromFile>resolved-path
-	    
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/sdf/declare-signature.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/sdf/declare-signature.str	Sat Jun  4 16:21:15 2011	(r22993)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/sdf/declare-signature.str	Sat Jun  4 16:34:11 2011	(r22994)
@@ -1,139 +1,145 @@
 module context/sdf/declare-signature
 
-imports 
+imports
 	include/SpoofaxLang
-imports		
+imports
 	common
-	libstrc 
-	utils/debug		
-imports	
+	libstrc
+	utils/attributes
+	utils/debug
+imports
 	context/-
-imports  
+imports
 	context/sdf/declare
 	context/signatures
-	codegen/sdf/to-name-analysis
-		
+
 
 // TODO : refactor common functionily in seperate rules/strategy
 // DON'T like several things about this implementation. Need to refactor/re-implement.
 
 
-//TODO : write a pretty printer to convert Get-Operation-Declaration to Signatures' Aterm 
+//TODO : write a pretty printer to convert Get-Operation-Declaration to Signatures' Aterm
 
-rules 
-	getOperationSignatures = 
-		?opname; 
- 		<resolve-symbol-declarations(all-keys-Get-Operation-Signature, bagof-Get-Operation-Signature)><to-scoped-symbol>opname 
+rules
+	getOperationSignatures =
+		?opname;
+ 		<resolve-symbol-declarations(all-keys-Get-Operation-Signature, bagof-Get-Operation-Signature)><to-scoped-symbol>opname
  	<+
  		<debug-declaration> $[Waring | Failed to retrive OperationSignatures for opname[<pp-aterm>]. Returning  empty list . ];
  		![]
- 		
-strategies 
+
+strategies
 	// Returns right hand side of the production. In case of A -> B, it
 	// retunrs B.
-	get-rhs-sort-name = 
+	get-rhs-sort-name =
 			try(
-					?cf(<id>) 
+					?cf(<id>)
 				+ ?lex(<id>)
 			);
       repeat(
       	?label(_, <id>)
       );
-      ( 
-      		?sort(<id>) 
+      (
+      		?sort(<id>)
       	+ ?parameterized-sort(<id>, _)
+      	+ is-string                    // applies in TemplateLang
       )
 
 	is-lexical-sort = where(?lex(sort(_)))
-	
-	mark-as-lexical-syntax-block =	with(	rules (IsInsideLexicalSyntaxBlock :_) )			
-		
-		
-		
-			
-rules 
-	
-	//Stores operation name and operation declarations 
-	
+
+	mark-as-lexical-syntax-block =	with(	rules (IsInsideLexicalSyntaxBlock :_) )
+
+
+
+
+rules
+
+	//Stores operation name and operation declarations
+
 	/**
-  * Gets the operation name from the Production. It actually search all the attributes 
-  * in the attribute list and create  a dynamic rule that stores operation name. 
+  * Gets the operation name from the Production. It actually search all the attributes
+  * in the attribute list and create  a dynamic rule that stores operation name.
   */
-  get-opration-name = where(getfirst(fetch-cons-name) ; store-operation-name)  
-  
+  get-opration-name = where(getfirst(fetch-cons-name) ; store-operation-name)
+
   /**
   *	Store operation name from the RHS of the Production, i.e. from fun constructors.
   * It creates a dynamic rule to store the operation name.
   */
   store-operation-name : opname-> opname
-  with  
+  with
 		rules (get-op-name: _ -> opname)
-  where 
+  where
   		<debug-declaration> $[Operation Name :  [opname]]
-	
-	
-	store-operation-declaration: 
-		p at prod(_,rhs-sort, _) -> <id> 
-		with 
+
+
+	store-operation-declaration:
+		p at prod(lhs, rhs-sort, attrs) -> <id>
+		with
 			 	if is-lexical-sort then
 			 		if not (IsInsideLexicalSyntaxBlock ) then
 			 			// Karnel Syntax and not marked as Lexical Syntax Block.
-			 			// Hence, marking it as a lexical syntax 
+			 			// Hence, marking it as a lexical syntax
 			 			{| IsInsideLexicalSyntaxBlock:
 			 						mark-as-lexical-syntax-block;
-			 						<store-operation-declaration-internal>p	
+			 						<store-operation-declaration-internal>p
 			 			|}
 			 		end
 			 	end
 		where
-			<store-operation-declaration-internal>p	 	 
-			 	
-	
+			<store-operation-declaration-internal> (p, lhs, rhs-sort, attrs)
+
+  // TemplateLang
+  store-operation-declaration:
+    t at TemplateProduction(rhs-sort, lhs, attrs) -> <id>
+    where
+      <store-operation-declaration-internal> (t, lhs, rhs-sort, attrs)
+
 	store-operation-declaration-internal
-  	=  ?p at prod(lhs , rhs-sort, attrs(attribute-list))
-  		;rhs-sort-name := <get-rhs-sort-name>rhs-sort	
+  	=  ?(p, lhs , rhs-sort, attrs(attribute-list))
+  		;rhs-sort-name := <get-rhs-sort-name>rhs-sort
   		;{|lhs-sort, get-op-name:
   		 			<find-sorts>lhs
   					;<try(get-opration-name)>attribute-list
   					;if operation-name := <get-op-name> then
-  						lhs-operands-types := <reverse><bagof-lhs-sort>  
+  						lhs-operands-types := <reverse><bagof-lhs-sort>
   						;create-opname2opdecl-mapping(|operation-name , lhs-operands-types, rhs-sort-name , p)
   					else
   						<debug-declaration> $[DeclareSignature | Failed to retrive Operation Name . Hence Ignoring : [<pp-aterm> p].]
-  					end	  
+  					end
   		  |}
-			  
-	store-operation-declaration-internal 
-  	= 	?p at prod(lhs , rhs-sort, no-attrs()) 
-  		;rhs-sort-name := <get-rhs-sort-name>rhs-sort	
+
+	store-operation-declaration-internal
+  	=  ?(p, lhs, rhs-sort, no-attrs())
+  		;rhs-sort-name := <get-rhs-sort-name>rhs-sort
   	  ; {|lhs-sort :
-	  				if (IsInsideLexicalSyntaxBlock<+ (!rhs-sort; ?lex(sort(rhs-sort-name))))then 
+	  				if (IsInsideLexicalSyntaxBlock<+ (!rhs-sort; ?lex(sort(rhs-sort-name))))then
 							 rules ( lhs-sort :+ _ -> $[String] )
 						else
-							<find-sorts>lhs //TODO : consider ignorig :ID->ID-Prime operation decl 
+							<find-sorts>lhs //TODO : consider ignorig :ID->ID-Prime operation decl
 						end
 	  				;lhs-operands-types := <reverse><bagof-lhs-sort>
 	  				;operation-name := ""
-	  				;create-opname2opdecl-mapping(|operation-name , lhs-operands-types, rhs-sort-name , p)  
+	  				;create-opname2opdecl-mapping(|operation-name , lhs-operands-types, rhs-sort-name , p)
 			 |}
 
 	/*
-	store-operation-declaration 
+	store-operation-declaration
   	= ?p at prod(_ , lex(sort(rhs-sort-name)), no-attrs())
   		; {|lhs-sort :
 							rules ( lhs-sort :+ _ -> $[String] )
 		  				;lhs-operands-types := <reverse><bagof-lhs-sort>
 		  				;operation-name := ""
-		  				;create-opname2opdecl-mapping(|operation-name , lhs-operands-types, rhs-sort-name , p)  
+		  				;create-opname2opdecl-mapping(|operation-name , lhs-operands-types, rhs-sort-name , p)
 			 |}
 	*/
-			 
-  find-sorts  
+
+  find-sorts
   	= alltd(get-sort-decl)
 
-rules  
-	
-	// Gets sort declaration from the production	
+rules
+
+	// Gets sort declaration from the production
 	get-sort-decl:
 		a at alt(frstSort , restSort*) -> a
 		where
@@ -141,134 +147,146 @@
 						<find-sorts>frstSort
 					;	<find-sorts>restSort*
 					;	inner-sort* := <bagof-lhs-sort;reverse>
-					;	intermediate-resultant-sort-type :=<string-replace(|"(", "_Of_");string-replace(|")", "")> <separate-by(|"_"); concat-strings>inner-sort* 
+					;	intermediate-resultant-sort-type :=<string-replace(|"(", "_Of_");string-replace(|")", "")> <separate-by(|"_"); concat-strings>inner-sort*
 			|}
-			; <map(create-opname2opdecl-mapping(|"", intermediate-resultant-sort-type, "[N/A]" ))>inner-sort*	
+			; <map(create-opname2opdecl-mapping(|"", intermediate-resultant-sort-type, "[N/A]" ))>inner-sort*
 			; rules( lhs-sort :+ _ -> intermediate-resultant-sort-type)
-	
-	get-sort-decl: 
+
+	get-sort-decl:
 		seq( frst , rest*)-> seq( frst , rest*)
 		where
 			{| lhs-sort:
 						<find-sorts>frst
 					;	<find-sorts>rest*
 					;	inner-sort* := <bagof-lhs-sort;reverse>
-					;	intermediate-resultant-sort-type :=<string-replace(|"(", "_Of_");string-replace(|")", "")> <separate-by(|"_"); concat-strings>inner-sort* 
-					  
+					;	intermediate-resultant-sort-type :=<string-replace(|"(", "_Of_");string-replace(|")", "")> <separate-by(|"_"); concat-strings>inner-sort*
+
 			|}
-			; create-opname2opdecl-mapping(|"", inner-sort*, intermediate-resultant-sort-type, "[N/A]" ) 	
+			; create-opname2opdecl-mapping(|"", inner-sort*, intermediate-resultant-sort-type, "[N/A]" )
 		 	; rules( lhs-sort :+ _ -> intermediate-resultant-sort-type)
-	
-	get-sort-decl: 
+
+	get-sort-decl:
 		i at iter-star ( x ) -> i
-  	where 
+  	where
   		{| 	lhs-sort:
   					<find-sorts>x
   				; inner-sorts-tostring := <reverse;separate-by(|"_");concat-strings><bagof-lhs-sort>
   		|}
   		;ret-string := $[List([<string-replace(|"(", "_Of_");string-replace(|")", "")> inner-sorts-tostring])]
   		;rules ( lhs-sort :+ _ -> ret-string)
-	
-	
-	get-sort-decl: 
+
+
+	get-sort-decl:
 		i at iter( x ) -> i
-  	where 
+  	where
   		{| lhs-sort:
   					<find-sorts>x
   				; inner-sorts-tostring := <reverse;separate-by(|"_");concat-strings><bagof-lhs-sort>
   		|}
   		;ret-string := $[List([<string-replace(|"(", "_Of_");string-replace(|")", "")>inner-sorts-tostring])]
-  		;rules ( lhs-sort :+ _ -> ret-string) 
-			  
+  		;rules ( lhs-sort :+ _ -> ret-string)
+
  	get-sort-decl:
  		p at parameterized-sort(x, _) ->p
-		with 
+		with
 			rules( lhs-sort :+ _ -> x)
-			
-  get-sort-decl: 
+
+  get-sort-decl:
   	s at sort(x) -> s
-  	with 
+  	with
   		rules( lhs-sort :+ _ -> x)
-	
-	get-sort-decl: 
+
+	get-sort-decl:
 		o at opt(parameterized-sort(x, _)) -> o
   	with rules( lhs-sort :+ _ -> $[Option([x])])
-  	
-	get-sort-decl: 
+
+	get-sort-decl:
 		opt(sort(x)) -> opt(sort(x))
   	with rules( lhs-sort :+ _ -> $[Option([x])])
-	
-	get-sort-decl: 
+
+	get-sort-decl:
 		i at iter-star-sep(operand1, operand2) -> i
  		with {|lhs-sort:
 			 					 <find-sorts>operand1
 		 					  ;<find-sorts>operand2
-		 					  ; inner-sorts-tostring := <reverse;separate-by(|"_");concat-strings><bagof-lhs-sort>    
+		 					  ; inner-sorts-tostring := <reverse;separate-by(|"_");concat-strings><bagof-lhs-sort>
 				  |}
 				 	;ret-string := $[List([<string-replace(|"(", "_Of_");string-replace(|")", "")>inner-sorts-tostring])]
-  				;rules ( lhs-sort :+ _ -> ret-string)	 
-  				 
-	get-sort-decl: 
+  				;rules ( lhs-sort :+ _ -> ret-string)
+
+	get-sort-decl:
 		i at iter-sep(operand1, operand2) -> i
 		with {|lhs-sort:
 			 					 <find-sorts>operand1
 		 					  ;<find-sorts>operand2
-		 					  ;inner-sorts-tostring 
-		 					   		:= <reverse;separate-by(|"_");concat-strings><bagof-lhs-sort>    
+		 					  ;inner-sorts-tostring
+		 					   		:= <reverse;separate-by(|"_");concat-strings><bagof-lhs-sort>
 				  |}
 				 	;ret-string := $[List([<string-replace(|"(", "_Of_");string-replace(|")", "")>inner-sorts-tostring])]
-  				;rules ( lhs-sort :+ _ -> ret-string)	 
+  				;rules ( lhs-sort :+ _ -> ret-string)
+
+  // TemplateLang
+  get-sort-decl:
+    Placeholder(_, sort(x), None(), _) -> <id>
+    with rules( lhs-sort :+ _ -> x )
+
+  get-sort-decl:
+    Placeholder(_, sort(x), <?Plus() + ?Star()>, _) -> <id>
+    with rules( lhs-sort :+ _ -> $[List([x])] )
+
+  get-sort-decl:
+    Placeholder(_, sort(x), Option(), _) -> <id>
+    with rules( lhs-sort :+ _ -> $[Option([x])] )
 
-		
 strategies
-		
-	assert-equal-signature(|operation-name, opernand-sorts*, resultant-sort)= 
+
+	assert-equal-signature(|operation-name, opernand-sorts*, resultant-sort)=
 			?[hd|tl]
 			;(expected-op-name , expected-op-sorts*, ex-resultant-sort) := hd
 			;(
-			 			 operation-name := expected-op-name 
+			 			 operation-name := expected-op-name
 						;opernand-sorts* := expected-op-sorts*
 						;resultant-sort := ex-resultant-sort
 				  <+
 						<assert-equal-signature(|operation-name, opernand-sorts*, resultant-sort)>tl
-				)	 
-				
+				)
+
 	/**
 	* Create a dynamic rule that mapes operation name to the operation declaration.
 	*	Addinationally, Arity of Operation Decl. has also been stored.
-	* 
+	*
 	* @Param operation-name.
-	* @param Sort or Operand Types involve in the operation. 
+	* @param Sort or Operand Types involve in the operation.
 	* @Param Resultant Sort from the operation .
-	* @Param Production related to the operation.  
-	*	
-	*/		  
+	* @Param Production related to the operation.
+	*
+	*/
 	create-opname2opdecl-mapping(|operation-name, opernand-sorts*, resultant-sort , production) =
 		where (<debug-declaration> $[DeclareSDF | Storing Signature for following production: [<pp-aterm> production]])
 		;available-opdecl*     := <getOperationSignatures>operation-name
-		;scoped-operation-name := <to-scoped-symbol>operation-name   
+		;scoped-operation-name := <to-scoped-symbol>operation-name
 		;if(
-		 		(!available-opdecl* => []) 
-				<+ 
+		 		(!available-opdecl* => [])
+				<+
 				not (<assert-equal-signature(|operation-name, opernand-sorts*, resultant-sort)>available-opdecl*)
 			)
-			then 
-				record-operation-declaration(|scoped-operation-name  , operation-name  , opernand-sorts* , resultant-sort) // storing this operation declaration 
- 		else 
- 		 		<debug-declaration> 
+			then
+				record-operation-declaration(|scoped-operation-name  , operation-name  , opernand-sorts* , resultant-sort) // storing this operation declaration
+ 		else
+ 		 		<debug-declaration>
  		 			$[
- 		 				DeclareSignature | Waring | There is an existing operation declration of production: [<pp-aterm> production] as the following : [<pp-aterm>(operation-name, opernand-sorts* , resultant-sort)] 
- 		 				DeclareSignature | Debug-info: scoped-op-name [<pp-aterm>scoped-operation-name]. 
+ 		 				DeclareSignature | Waring | There is an existing operation declration of production: [<pp-aterm> production] as the following : [<pp-aterm>(operation-name, opernand-sorts* , resultant-sort)]
+ 		 				DeclareSignature | Debug-info: scoped-op-name [<pp-aterm>scoped-operation-name].
  		 			 ]
 		end
-			
-	
-	create-opname2opdecl-mapping(|operation-name, resultant-sort , production): alt-sort -> alt-sort  
-		where 
+
+
+	create-opname2opdecl-mapping(|operation-name, resultant-sort , production): alt-sort -> alt-sort
+		where
 			  alt-srt-lst := [alt-sort]
 			  ;create-opname2opdecl-mapping(|operation-name, alt-srt-lst, resultant-sort , production)
 
-	record-operation-declaration ( |scoped-op-name ,  opname , operand-sort* ,  resultant-sort) = 
+	record-operation-declaration ( |scoped-op-name ,  opname , operand-sort* ,  resultant-sort) =
 		where (
 			arg-length := <length>operand-sort*;
 			rules(
@@ -277,17 +295,17 @@
 				)
 			; <debug-declaration> $[DeclareSignature | Stored operation declration : [<pp-aterm> ( opname , operand-sort* ,  resultant-sort) ].]
 			; <debug-declaration> $[DeclareSignature | Stored operation signature  : [<pp-aterm> scoped-op-name] -> [<pp-aterm> (opname, <length>operand-sort*)].]
-	) 
-		
-	record-operation-declaration-at-global-scope ( | opname , operand-sort* ,  resultant-sort) = 
-		where ( <to-global-symbol> opname => scoped-op-name);	
-		record-operation-declaration( |scoped-op-name ,  opname , operand-sort* ,  resultant-sort) 
+	)
+
+	record-operation-declaration-at-global-scope ( | opname , operand-sort* ,  resultant-sort) =
+		where ( <to-global-symbol> opname => scoped-op-name);
+		record-operation-declaration( |scoped-op-name ,  opname , operand-sort* ,  resultant-sort)
 
 
 rules
-	init-record-signatures = 
-			record-operation-declaration-at-global-scope ( |"None", [] 		,"Option(a)"); 
+	init-record-signatures =
+			record-operation-declaration-at-global-scope ( |"None", [] 		,"Option(a)");
 			record-operation-declaration-at-global-scope ( |"Some", ["a"] ,"Option(a)");
 			record-operation-declaration-at-global-scope ( |"Cons", ["a","List(a)"] ,"List(a)");
 			record-operation-declaration-at-global-scope ( |"Nil", [] ,"List(a)");
-			record-operation-declaration-at-global-scope ( |"Conc", ["List(a)" , "List(a)"] ,"List(a)")
\ No newline at end of file
+			record-operation-declaration-at-global-scope ( |"Conc", ["List(a)" , "List(a)"] ,"List(a)")

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/sdf/declare.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/sdf/declare.str	Sat Jun  4 16:21:15 2011	(r22993)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/sdf/declare.str	Sat Jun  4 16:34:11 2011	(r22994)
@@ -1,55 +1,56 @@
 module context/sdf/declare
-imports 
+imports
 	libstratego-sdf
   lib/editor-common.generated
 	include/SpoofaxLang
-imports 
+imports
 	context/-
 	codegen/-
 	analyze/main
-	normalize/signatures	
+	normalize/signatures
 imports
 	common
 	utils/debug
 	utils/annotations
-imports  
+	utils/attributes
+imports
 	context/sdf/declare-signature
-imports 
+imports
 	libstratego-sdf
   lib/editor-common.generated
 	include/SpoofaxLang
- 
-rules 
+
+rules
 	resolve-sdf-declarations =
-		?symbol; 
- 		<resolve-symbol-declarations(all-keys-Declaration , bagof-Declaration)><to-scoped-symbol>symbol 
+		?symbol;
+ 		<resolve-symbol-declarations(all-keys-Declaration , bagof-Declaration)><to-scoped-symbol>symbol
  	<+
  		<debug-analysis> $[ErrorChecking| FAIL| Failed to retrive SDF declaration for symbol [<pp-aterm>]];
  		fail
- 		 
-	resolve-unique-sdf-declaration = 
- 		?symbol; 
- 		<resolve-symbol-unique-declaration(all-keys-Declaration , bagof-Declaration)><to-scoped-symbol>symbol 
+
+	resolve-unique-sdf-declaration =
+ 		?symbol;
+ 		<resolve-symbol-unique-declaration(all-keys-Declaration , bagof-Declaration)><to-scoped-symbol>symbol
  	<+
  		<debug-analysis> $[ErrorChecking| FAIL| Failed to retrive SDF declaration for symbol [<pp-aterm>]];
  		fail
-	
-	resolve-NamespaceSort-declaration = 
- 		?symbol; 
- 		<resolve-symbol-unique-declaration(all-keys-NamespaceSort , bagof-NamespaceSort)><to-scoped-symbol>symbol 
+
+	resolve-NamespaceSort-declaration =
+ 		?symbol;
+ 		<resolve-symbol-unique-declaration(all-keys-NamespaceSort , bagof-NamespaceSort)><to-scoped-symbol>symbol
  	<+
  		<debug-analysis> $[ErrorChecking| FAIL| Failed to retrive NamespaceSort declaration for symbol [<pp-aterm>]];
  		fail
-	
-					  
-rules	 
- // Traverse AST and declare sdf definition  
- //	Instead of declaring in the Global Scope 
- // now it is declared in a particular Scope. 
+
+
+rules
+ // Traverse AST and declare sdf definition
+ //	Instead of declaring in the Global Scope
+ // now it is declared in a particular Scope.
  // Here scope is defined by (Package-QName, Module-QName)
  declare-sdf-definition-main=
     	alltd(declare-sdf-definition)
-  
+
 rules
 
 
@@ -65,26 +66,38 @@
       <declare-sdf-definition> unparameterized(x);
       <alltd(declare-sdf-simple-definition)> y
 
-
 rules
-	  	 
- declare-sdf-definition:
-    prod @ prod(lhs, sort, _) -> <id>
+
+  declare-sdf-definition:
+    prod @ prod(lhs, sort, attrs) -> <id>
+    where
+    	<declare-sdf-definition-internal> (prod, lhs, sort, attrs)
+
+  declare-sdf-definition-internal:
+    (prod, lhs, sort, attrs) -> <id>
     where
       x:= <get-rhs-sort-name>sort;
-      qualified-sort-name := <to-scoped-symbol> x 
+      qualified-sort-name := <to-scoped-symbol> x
    	with
-   	//	enable-declaration-debugging;
+   		// enable-declaration-debugging;
    		<store-operation-declaration>prod
   	with
       <topdown(try(store-namespace-def))> lhs
+    with
+      if <fetch-cons-name> attrs => cons then
+        qualified-cons-name := <to-scoped-symbol> cons;
+        rules(
+        	// Needed for Sort.Cons references to the production.
+        	Declaration: (qualified-sort-name, qualified-cons-name) -> prod
+        )
+      end
     with
-      <Declaration> qualified-sort-name 
+      <Declaration> qualified-sort-name
     <+
       (
       	(GetEnclosingModuleName;get-module-abs-filepath <+ LegacyModuleResolvedPath) => file;
       	rules(
-       		Declaration		 :    qualified-sort-name  -> prod
+       		Declaration		 :    qualified-sort-name  -> prod
         	DeclarationFile:    qualified-sort-name  -> file
         	// Added following two dynamic rules for the ESV Def. analysis
         	SortDeclaration  :  qualified-sort-name -> x
@@ -95,11 +108,11 @@
     with
       <alltd(declare-sdf-usage)> lhs
      // ;disable-declaration-debugging
-		 
-  
+
+
   store-namespace-def:
     namespacedef(name, sort) -> <id>
-    with 
+    with
     	scoped-name  := <to-scoped-symbol> name
     where
       rules(NamespaceSort: scoped-name  -> sort)
@@ -107,11 +120,11 @@
   declare-sdf-definition:
 		lex-syntax at lexical-syntax(lex-defintions) ->lex-syntax
 		with{| IsInsideLexicalSyntaxBlock:
-							mark-as-lexical-syntax-block; 
+							mark-as-lexical-syntax-block;
 							<declare-sdf-definition-main> lex-defintions
 				|}
-					 
-				
+
+
 	declare-sdf-definition:
 		parameterized(x, y) -> parameterized(x, y)
   	where
@@ -122,17 +135,17 @@
 		'sorts(_) -> <id>
 		with
     	 alltd(declare-sdf-usage)
-  
+
 	declare-sdf-definition:
 		context-free-start-symbols(_) -> <id>
 		with
     	alltd(declare-sdf-usage)
-	  
+
   declare-sdf-definition:
 		lexical-start-symbols(_) -> <id>
 	  with
 	  	alltd(declare-sdf-usage)
-	  
+
 	declare-sdf-definition:
     kernel-start-symbols(_) -> <id>
     with
@@ -144,16 +157,16 @@
 	  	scoped-x:= <to-scoped-symbol>x;
 	  	rules(Declaration: scoped-x -> x)
 		where
-			<debug-declaration>$[DeclareSDF | Storing Declaration [<pp-aterm>scoped-x] -> [<pp-aterm>x]]	
-		
+			<debug-declaration>$[DeclareSDF | Storing Declaration [<pp-aterm>scoped-x] -> [<pp-aterm>x]]
+
 rules
-	
+
 	declare-sdf-usage:
     sort(x) -> <id>
     with
-    	x-with-scope := <to-scoped-symbol>x 
+    	x-with-scope := <to-scoped-symbol>x
       ;rules(Usage: (scope, x)-> x)
-	  
+
 	declare-sdf-usage:
     parameterized-sort(x, y) -> <id>
     where
@@ -162,17 +175,17 @@
         text-with-scope := <to-scoped-symbol>text;
         rules(Usage: text-with-scope -> text)
       end
-	
+
 rules
-	
+
 	propose-completion:
     sort(COMPLETION(x)) -> [decl*, use*]
     with
       decl* := <all-keys-Declaration> <to-scoped-symbol> x;
       use*  := <all-keys-Usage> <to-scoped-symbol>x
-	  
+
 	propose-completion:
     NOCONTEXT(COMPLETION(x)) -> [decl*, use*]
     with
       decl* := <all-keys-Declaration> <to-scoped-symbol>x;
-      use*  := <all-keys-Usage> <to-scoped-symbol> x
\ No newline at end of file
+      use*  := <all-keys-Usage> <to-scoped-symbol> x

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/template/declare.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/template/declare.str	Sat Jun  4 16:34:11 2011	(r22994)
@@ -0,0 +1,85 @@
+module context/template/declare
+
+imports
+  context/sdf/declare
+  include/SpoofaxLang
+  utils/annotations
+
+signature
+  constructors
+    // Options
+    Newlines : X
+
+strategies
+
+  /** @type List(TemplateProduction) -> List(TemplateProduction) */
+  declare-template-definition-main = map(declare-template-definition)
+
+  /** @type List(TemplateOption) -> List(TemplateOption) */
+  declare-template-options-main = map(declare-template-option)
+
+  init-template-options =
+    // defaults
+    rules(
+      Options :+ Newlines() -> None()
+    )
+
+rules
+
+  // Declarations are shared with SDF (same DR)
+  // The sorts and cons declared using templates are in exactly the same
+  // namespace as if they would be declared using an equivalent piece of SDF.
+
+  declare-template-definition:
+    template@ TemplateProduction(sort, Template(part*), attrs) ->
+      TemplateProduction(sort, Template(part'*), attrs)
+    with
+      <declare-sdf-definition-internal> (template, part*, sort, attrs);
+      part'* := <declare-template-placeholders> part*
+
+  declare-template-placeholders =
+    ?[Newline(_), Layout(_), Placeholder(_, _, _, _){}, Newline(_) | _];
+    [add-annotation(|Leading()), id, add-annotation(|Blank()), add-annotation(|Trailing()) | id];
+    [id, id, id | declare-template-placeholders]
+  <+
+    ?[Newline(_), Placeholder(_, _, _, _){}, Newline(_) | _];
+    [add-annotation(|Leading()), add-annotation(|Blank()), add-annotation(|Trailing()) | id];
+    [id, id | declare-template-placeholders]
+  <+
+    ?[Placeholder(_, sort(x), _, _){} | _];
+    [id | declare-template-placeholders];
+    rules(CanNotBeBlank :+ x -> x)
+  <+
+    ?[_ | _];
+    [id | declare-template-placeholders]
+  <+
+    ?[]
+
+rules
+
+  // Invoked by declare-sdf-definition-internal
+  declare-sdf-usage:
+    Placeholder(_, sort(x), _, _) -> <id>
+    with
+      rules(Usage: x -> x)
+
+rules // Options
+  // FIXME: move to spoofax.configuration
+
+  declare-template-option:
+    Newlines(t) -> <id>
+    with
+      rules(Options :+ Newlines() -> t)
+
+strategies
+
+  use-no-newlines       = <Options> Newlines() => None()
+  use-leading-newlines  = <Options> Newlines() => Leading()
+  use-trailing-newlines = <Options> Newlines() => Trailing()
+
+  newlines-switch(none, leading, trailing) =
+    switch <Options> Newlines()
+      case ?None(): none
+      case ?Leading(): leading
+      case ?Trailing(): trailing
+    end

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/normalize/main.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/normalize/main.str	Sat Jun  4 16:21:15 2011	(r22993)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/normalize/main.str	Sat Jun  4 16:34:11 2011	(r22994)
@@ -1,68 +1,69 @@
-module normalize/main 
+module normalize/main
 
 imports
   libstratego-lib
   libstrc
-imports 
+imports
 	normalize/stratego
 	normalize/signatures
-imports 
+	normalize/templatelang
+imports
 	include/SpoofaxLang
-imports 
+imports
 	utils/annotations
 	utils/debug
 	utils/cache
-imports 
+imports
 	common
 	config
-imports 
+imports
 	context/-
-	
-//TODO FIX : 
-// Design issues : 
+
+//TODO FIX :
+// Design issues :
 //	1. Package Common Imports are only for the current spx file at this moment
 //		 It could be kept as it is or make it common in the whole package. 
 //	2. When done with fixing origin tracking , normalize Import Statements
 	
-strategies		
-	nomalize-all = desugar-compilationa-unit
+strategies
+	normalize-all = desugar-compilation-unit
 
-rules	
-	
-	desugar-compilationa-unit: 
-		CompilationUnit(moduledef*) -> 	<desugar-compilationa-unit>CompilationUnit([] , [appneded-default-package-declaration])
-		where 
-			 appneded-default-package-declaration :=  Package(Name(<default_package_name>) , moduledef*)
-	
-	
-	
-	desugar-compilationa-unit: 
-		CompilationUnit(import* , package*) -> 	CompilationUnit( import* , modified-packages) 
-		with 
+rules
+
+	desugar-compilation-unit:
+		CompilationUnit(moduledef*) -> 	<desugar-compilation-unit>CompilationUnit([] , [appended-default-package-declaration])
+		where
+			 appended-default-package-declaration :=  Package(Name(<default_package_name>) , moduledef*)
+
+
+
+	desugar-compilation-unit:
+		CompilationUnit(import* , package*) -> 	CompilationUnit( import* , modified-packages)
+		with
 			{| PackageCommonImports:
 						<alltd(desugar-imports)> import*;
 						<alltd(desugar-spx-package)> package* => modified-packages
 			|}
-	
+
 	desugar-imports:
 		i at Imports(import*) -> i
-		with	
+		with
 			rules(
 				PackageCommonImports:+ _ -> i
 			)
-			
-rules	
-	
+
+rules
+
 	desugar-spx-package:
 		Package(Name(package-name) , modules* ) -> normalized-package-definition
-		with 
+		with
 			<debug-compiler>$[Desugaring Packages [<pp-aterm>package-name]]
-		where 
+		where
 			!QName([package-name]) 																=> package-qname;
-			<desugar-spx-package>Package(package-qname, modules*) => normalized-package-definition 
-		
-	
-	desugar-spx-package:	
+			<desugar-spx-package>Package(package-qname, modules*) => normalized-package-definition
+
+
+	desugar-spx-package:
 		p at Package(package-qname , modules* ) -> modifiedPackageDescription
 		with
 			!package-qname => QName(_);
@@ -74,27 +75,27 @@
 			   	);
 			   	<alltd(desugar-spx)> modules*  => desugared-modules*
 			|}
-		with 
+		with
 			currently-precompiling-spx-abspath  					=> package-abs-path;
 			!Package( package-qname , desugared-modules*) => modifiedPackageDescription
 		where
-			<store-package-abspath>(package-qname ,package-abs-path)
-		
+        <store-package-abspath>(package-qname ,package-abs-path)
+
 		/* it seems not to be needed at this moment. hence, commenting this code.
 		where
 			if <get-package-declaration> package-qname => Package(package-qname, module-def*) then
 				modifiedPackageDescription' 						 := Package(package-qname, <conc>(module-def* , desugared-modules*))
 			else
-				modifiedPackageDescription' 						 := modifiedPackageDescription 
+				modifiedPackageDescription' 						 := modifiedPackageDescription
 			end;
 			<store-declaration(|Packages())>	(package-qname,  modifiedPackageDescription')
-		*/	
+		*/
 
 rules
-		
-	desugar-spx: 
+
+	desugar-spx:
 		m at Module(attrb* , modname , section*) -> modifiedModuleDescription
-		with 
+		with
 			<debug-compiler>$[Desugaring Modules : [<pp-aterm>modname]]
 		where
 			EnclosingNamespace      								=>  package;
@@ -102,41 +103,50 @@
 		  !modname-with-annotation				      	=>  SPXModuleName(mod-name-string);
 		  !package							  								=>  Package(QName( package-name-part*));
 		  enclosing-module-name   								:=  [package-name-part*| [mod-name-string]];
-		  enclosing-module-qname   								:=  QName(enclosing-module-name) 
-		where 
+		  enclosing-module-qname   								:=  QName(enclosing-module-name)
+		where
 			{| EnclosingNamespace, EnclosingParentNamespace:
 			  	rules(
 						EnclosingNamespace 								:= 	Module(enclosing-module-qname)
-						EnclosingParentNamespace					:= package   
+						EnclosingParentNamespace					:= package
 					);
 					sections' := <conc>(<reverse><bagof-PackageCommonImports>, <alltd(desugar-spx)>section*)
 					;<debug-symboltable> $[ Storing enclosing namespace : [<pp-aterm>enclosing-module-qname]]
 			|}
-		with 
+		with
 			currently-precompiling-spx-abspath  												=> package-abs-path;
 			!Module(attrb* , modname-with-annotation , sections')				=> modifiedModuleDescription
-		where	
+		where
 			<store-module-abspath> (enclosing-module-qname, package-abs-path);
 			<store-declaration(|Modules())>(enclosing-module-qname,  modifiedModuleDescription);
 			<store-scope-reference>(Module(enclosing-module-qname),  package);
-			<store-original-declaration(|Modules())>(enclosing-module-qname,  m) // also storing original AST. 
+			<store-original-declaration(|Modules())>(enclosing-module-qname,  m) // also storing original AST.
 rules
-	
-	//Desugaring SDF Sections 
-	desugar-spx : SDFSection ( sectionDef ) -> <add-annotation(|<EnclosingNamespace>)> <id>
-	
-	desugar-spx : SDFSectionEH ( _, sectionDef ) -> <add-annotation(|<EnclosingNamespace>)> <id>
 
-rules	
-	//Desugarting STR sections 
+	//Desugaring SDF Sections
+	desugar-spx : SDFSection ( sectionDef ) -> <add-annotation(|<EnclosingNamespace>)> SDFSection( sectionDef' )
+	with
+		<templatelang-desugar-sdf-top> sectionDef => sectionDef'
+
+  // TODO: Maybe SDFSectionEH can be desugared into SDFSection.
+	desugar-spx : SDFSectionEH ( eh, sectionDef ) -> <add-annotation(|<EnclosingNamespace>)> SDFSectionEH( eh, sectionDef' )
+	with
+    <templatelang-desugar-sdf-top> sectionDef => sectionDef'
+
+rules
+	//Desugaring STR sections
 	desugar-spx : STRSection ( sectionDef ) -> <add-annotation(|<EnclosingNamespace>)> STRSection ( sectionDef' )
-		with 
-			<basic-stratego-desugar-top> sectionDef => sectionDef'  		
+		with
+			<basic-stratego-desugar-top> sectionDef => sectionDef'
 
-rules	
-	//Desugaring ESV Sections 
+rules
+	//Desugaring ESV Sections
 	desugar-spx : ESVSection ( sectionDef ) -> <add-annotation(|<EnclosingNamespace>)> <id>
 		with
 			<alltd(store-langauge-properties(|<EnclosingParentNamespace>))>sectionDef
-			
-			
\ No newline at end of file
+
+rules
+	//Desugaring template sections
+  desugar-spx : TemplateSection( sectionDef ) -> <add-annotation(|<EnclosingNamespace>)> TemplateSection( sectionDef' )
+  with
+  	<templatelang-desugar-top> sectionDef => sectionDef'
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/normalize/templatelang.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/normalize/templatelang.str	Sat Jun  4 16:34:11 2011	(r22994)
@@ -0,0 +1,80 @@
+module templatelang
+imports
+  libstratego-lib
+  include/SpoofaxLang
+  utils/attributes
+
+strategies
+
+  templatelang-desugar-sdf-top = alltd(templatelang-desugar-sdf)
+
+  templatelang-desugar-top = innermost(templatelang-desugar)
+
+rules
+
+  templatelang-desugar-sdf:
+    SdfProduction(sort, symbol*, attr*) -> prod(symbol*, sort(sort), attr*)
+
+  templatelang-desugar-sdf:
+    SdfProductionWithCons(SortCons(sort, cons), symbol*, attrs(attr*)) ->
+      prod(symbol*, sort(sort), attrs(attr'*))
+    with
+      attr'* := [sdf-cons(<double-quote> cons) | attr*]
+
+  templatelang-desugar-sdf:
+    SdfProductionWithCons(SortCons(sort, cons), symbol*, no-attrs()) ->
+      prod(symbol*, sort(sort), attrs(attr'*))
+    with
+      attr'* := [sdf-cons(<double-quote> cons)]
+
+rules
+
+  templatelang-desugar:
+    NoOptions() -> Options([])
+
+  templatelang-desugar:
+    no-attrs() -> attrs([])
+
+  templatelang-desugar:
+    TemplateProductionWithCons(SortCons(sort, cons), tmpl, attrs(attr*)) ->
+      TemplateProduction(sort, tmpl, attrs(attr'*))
+    with
+      attr'* := [sdf-cons(<double-quote> cons) | attr*]
+
+  templatelang-desugar:
+    Separator(x) -> Separator(<un-double-quote; unescape> x)
+
+  templatelang-desugar:
+    Escape(t) -> String(t')
+    with
+      let parse-unicode = {before*, mid, after*:
+             split-fetch-keep(not(is-hexnum)) => (before*, mid, after*);
+             ![<hex-chars-to-int> before*, mid | after*]
+          <+ ![<hex-chars-to-int>]
+          }
+          unescape =
+            string-as-chars(rec x(
+               \['\', ' ' | tail] -> [' '  | <x> tail]\
+            <+ \['\', '"' | tail] -> ['"'  | <x> tail]\
+            <+ \['\', '\''| tail] -> ['\'' | <x> tail]\
+            <+ \['\', 't' | tail] -> ['\t' | <x> tail]\
+            <+ \['\', 'r' | tail] -> ['\r' | <x> tail]\
+            <+ \['\', 'n' | tail] -> ['\n' | <x> tail]\
+            <+ \['\', '<' | tail] -> ['<'  | <x> tail]\
+            <+ \['\', '>' | tail] -> ['>'  | <x> tail]\
+            <+ \['\', '[' | tail] -> ['['  | <x> tail]\
+            <+ \['\', ']' | tail] -> [']'  | <x> tail]\
+            <+ \['\', 'u' | tail] -> <parse-unicode; [id | x]> tail\
+            <+ \['<', '\', '\', '>' | tail] -> <x> tail\
+            <+ \['[', '\', '\', ']' | tail] -> <x> tail\
+            <+ \[_ | tail] -> <x> tail\
+            <+ []
+            ))
+      in
+        t' := <unescape> t
+      end
+
+  templatelang-desugar:
+    Layout(t) -> Layout(t')
+    where
+      t' := <string-replace(|"\t", "  "); not(equal(|t))> t

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/spoofaxlang.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/spoofaxlang.str	Sat Jun  4 16:21:15 2011	(r22993)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/spoofaxlang.str	Sat Jun  4 16:34:11 2011	(r22994)
@@ -12,7 +12,7 @@
   lib/editor-common.generated
 imports
   codegen/str/to-stratego
-imports  
+imports
   analyze/sdf/check
   context/sdf/declare
   context/str/declare
@@ -22,51 +22,58 @@
 	codegen/esv/to-esv
 	codegen/sdf/to-sdf
   codegen/sdf/to-signature
-imports 
+imports
 	normalize/main
-	normalize/signatures   
-imports 
+	normalize/signatures
+imports
 	context/-
-imports	 
+imports
 	utils/cache
 	common
   config
 	unit-tests/-
+	unit-tests/templatelang/-
 imports
 	 editor/main
 	 codegen/main
 
-rules  
-   
+rules
+
   editor-complete:
     (node, position, ast, path, project-path) -> proposals
     where
       proposals := <propose-completion <+ ![]> node
- 
+
   editor-resolve:
     (sort(x), position, ast, path, project-path) -> target
     where
       target := <Declaration> x
- 
- /*  TODO : Fix Editor Resolve 
+
+ /*  TODO : Fix Editor Resolve
   editor-resolve:
     (unparameterized(x), position, ast, path, project-path) -> target
     where
       target := <parse-spoofaxlang-file> <resolve-import> x
  */
- 
+
 rules
-	
+
   generate-aterm:
     (selected, position, ast, path, project-path) -> (filename, result)
     with
       filename := <guarantee-extension(|"aterm")> path;
       result   := ast // we just return the input term
-	
+
 	generate-desugar:
     (selected, position, ast, path, project-path) -> (filename, result)
     with
       filename := <guarantee-extension(|"aterm.sugar")> path;
-      result   := <nomalize-all>ast // we just return the input term
+      result   := <normalize-all>ast // we just return the input term
 
-	 
+  run-templatelang-tests:
+    (selected, position, ast, path, project-path) -> None()
+    with
+      test-templatelang-to-sdf;
+      test-templatelang-to-esv;
+      test-templatelang-to-stratego;
+      test-templatelang-desugar

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/resources/test.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/resources/test.str	Sat Jun  4 16:21:15 2011	(r22993)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/resources/test.str	Sat Jun  4 16:34:11 2011	(r22994)
@@ -71,6 +71,6 @@
     (selected, position, ast, path, project-path) -> (filename, result)
     with
       filename := <guarantee-extension(|"aterm.sugar")> path;
-      result   := <nomalize-all>ast // we just return the input term
+      result   := <normalize-all>ast // we just return the input term
 
 	 

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/templatelang/desugar.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/templatelang/desugar.str	Sat Jun  4 16:34:11 2011	(r22994)
@@ -0,0 +1,44 @@
+module desugar
+
+imports
+  libstratego-lib
+  include/SpoofaxLang
+  normalize/templatelang
+  utils/attributes
+
+strategies
+
+  test-templatelang-desugar =
+    test-suite(!"templatelang-desugar",
+      apply-test(!"  transforms NoOptions() into Options([])",
+        templatelang-desugar, !NoOptions(), !Options([]));
+      apply-test(!"  transforms no-attrs() into attrs([])",
+        templatelang-desugar, !no-attrs(), !attrs([]));
+      apply-test(!"  replaces tabs with two spaces",
+        templatelang-desugar, !Layout("\t"), !Layout("  "));
+      apply-test(!"  unescapes common escape chars",
+        templatelang-desugar, !Escape("\\ \\'\\\"\\t\\r\\n"), !String(" '\"\t\r\n"));
+      apply-test(!"  unescapes escaped brackets",
+        templatelang-desugar, !Escape("\\<\\>\\[\\]"), !String("<>[]"));
+      apply-test(!"  unescapes unicode codepoints",
+        templatelang-desugar, !Escape("\\u41\\u61"), !String("Aa"));
+      apply-test(!"  un-double-quotes and unescapes separators",
+        templatelang-desugar, !Separator("\"\\n\""), !Separator("\n"))
+    );
+    test-suite(!"templatelang-desugar-sdf",
+      apply-test(!"  transforms SdfProductionWithCons without attrs into prod",
+        templatelang-desugar-sdf,
+        !SdfProductionWithCons(SortCons("X", "Y"), [], no-attrs()),
+        !prod([], sort("X"), attrs([sdf-cons("\"Y\"")]))
+      );
+      apply-test(!"  transforms SdfProductionWithCons with attrs into prod",
+        templatelang-desugar-sdf,
+        !SdfProductionWithCons(SortCons("X", "Y"), [], attrs([assoc(left())])),
+        !prod([], sort("X"), attrs([sdf-cons("\"Y\""), assoc(left())]))
+      );
+      apply-test(!"  transforms SdfProduction into prod",
+        templatelang-desugar-sdf,
+        !SdfProduction("X", [], no-attrs()),
+        !prod([], sort("X"), no-attrs())
+      )
+    )

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/templatelang/to-esv.meta
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/templatelang/to-esv.meta	Sat Jun  4 16:34:11 2011	(r22994)
@@ -0,0 +1 @@
+Meta([Syntax("Stratego-EditorService")])

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/templatelang/to-esv.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/templatelang/to-esv.str	Sat Jun  4 16:34:11 2011	(r22994)
@@ -0,0 +1,106 @@
+module to-esv
+
+imports
+  libstratego-lib
+  lib/editor-common.generated
+  include/SpoofaxLang
+imports
+  codegen/template/to-esv
+  context/template/declare
+  normalize/signatures
+
+strategies
+
+  test-templatelang-to-esv =
+    let err(|msg) = debug(!msg); fail
+
+        // Parse a string containing some template productions.
+        prepare-input = {x:
+          (<parse-spoofaxlang-string> <conc-strings> ("module x templates ", <id>)
+            <+ err(|"parse failed : "));
+          (?CompilationUnit([Module(_, _, x)])
+            <+ err(|"project failed : "));
+          !x
+        }
+
+        prepare-output = ![<id>]
+
+        // Run a test on a tuple (input, expected-output).
+        // Input is a string containing template productions.
+        // Output is an ESV AST for one completion template.
+        test' = {input, expected-output, actual-output:
+        	where(?(<id>, _); all-lines(<conc-strings> ("  ", <id>)); debug);
+          (prepare-input, prepare-output) => (input, expected-output);
+          (<template-sections-to-esv> input => actual-output
+            <+ err(|"template-sections-to-esv failed : "));
+          (<equal(|expected-output)> actual-output
+            <+ <debug> "actual output of template-sections-to-esv does not match expected output!";
+               <debug(!"actual   : ")> actual-output;
+               <debug(!"expected : ")> expected-output;
+               fail)
+        }
+
+        test-placeholders =
+          <test'> ($[X.Y = <<<Z>>>],
+            |[ completion template X: "Y" = <Z:Z> (blank) ]|);
+          <test'> ($[X.Y = <<< display text : Z>>>],
+            |[ completion template X: "Y" = < display text :Z> (blank) ]|);
+          <test'> ($[X.Y = <<<Z?>>>],
+            |[ completion template X: "Y" = (cursor) (blank) ]|);
+          <test'> ($[X.Y = <<<Z+>>>],
+            |[ completion template X: "Y" = (cursor) (blank) ]|);
+          <test'> ($[X.Y = <<<Z*>>>],
+            |[ completion template X: "Y" = (cursor) (blank) ]|);
+          <test'> ($[X.Y = <<<Z+; separator=", ">>>],
+            |[ completion template X: "Y" = (cursor) (blank) ]|);
+          <test'> ($[X.Y = <<<Z*; separator=" + ">>>],
+            |[ completion template X: "Y" = (cursor) (blank) ]|);
+
+          // Text around it
+          <test'> ($[X.Y = <<foo <Z> bar>>],
+            |[ completion template X: "Y" = "foo " <Z:Z> " bar" (blank) ]|);
+          <test'> ($[X.Y = <<foo <Z?> bar>>],
+            |[ completion template X: "Y" = "foo " (cursor) " bar" (blank) ]|);
+
+          // Multiple placeholders => only one "(cursor)" directive
+          <test'> ($[X.Y = <<<A?> <B?>>>],
+            |[ completion template X: "Y" = (cursor) (blank) ]|);
+          <test'> ($[X.Y = <<<A?> <B?> <C?>>>],
+            |[ completion template X: "Y" = (cursor) (blank) ]|)
+
+        with-newlines(s) = {|Options: {x:
+          ?x; rules( Options :+ Newlines() -> x ); s
+        }|}
+
+    in with({|DeclaredModule, GetEnclosingModuleName, Options:
+    	<debug> "test suite: TemplateLang->ESV";
+
+      // Default
+      rules(
+        DeclaredModule :+ "__test" -> "__test"
+        GetEnclosingModuleName := Module("__test")
+        Options :+ Newlines() -> None()
+      );
+      newlines := [None(), Leading(), Trailing()];
+
+      // Test placeholders.
+      <list-loop(with-newlines(test-placeholders))> newlines;
+
+      // Test a complete statement.
+      statement := $[
+        Statement.IfThen = <<
+          if <Exp> then
+            <Statement*; separator="\n">
+          end
+        >>];
+
+      statement-output := |[
+        completion template Statement: "IfThen" =
+          "if " <Exp:Exp> " then\\n\\t" (cursor) "\\nend" (blank)
+      ]|;
+
+      <list-loop(with-newlines(<test'> (statement, statement-output)))> newlines;
+
+      <debug> "TemplateLang->ESV tests finished."
+    |})
+    end

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/templatelang/to-sdf.meta
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/templatelang/to-sdf.meta	Sat Jun  4 16:34:11 2011	(r22994)
@@ -0,0 +1 @@
+Meta([Syntax("Stratego-Sdf2")])

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/templatelang/to-sdf.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/templatelang/to-sdf.str	Sat Jun  4 16:34:11 2011	(r22994)
@@ -0,0 +1,129 @@
+/* unit tests for TemplateLang -> SDF generation */
+
+module to-sdf
+
+imports
+  libstratego-lib
+  libstratego-sglr
+  lib/editor-common.generated
+  include/SpoofaxLang
+imports
+  codegen/template/to-sdf
+  normalize/signatures
+  utils/attributes
+
+// FIXME: don't be lazy, get this from some import!
+signature
+  constructors
+    Newlines : Unknown
+
+strategies
+
+  test-templatelang-to-sdf =
+
+    let err(|msg) = debug(!msg); fail
+
+        // Parse a string containing some template productions.
+        prepare-input = {x:
+          (<parse-spoofaxlang-string> <conc-strings> ("module x templates ", <id>)
+            <+ err(|"parse failed : "));
+          (?CompilationUnit([Module(_, _, x)])
+            <+ err(|"project failed : "));
+          !x
+        }
+
+        // Put quotes around literals, get rid of conc-grammars.
+        prepare-output =
+          alltd(/*lit(double-quote) + ci-lit(single-quote) + */quoted(double-quote));
+          alltd(\conc-grammars(x, y) -> [x, y]\);
+          flatten-list
+
+        // Run a test on a tuple (input, expected-output).
+        // Input is a string containing template productions.
+        // Output is an SDF AST as build by G*|[ ]| CS embedding.
+        test' = {input, expected-output, actual-output:
+          where(?(<id>, _); all-lines(<conc-strings> ("  ", <id>)); debug);
+          (prepare-input, prepare-output) => (input, expected-output);
+          (<template-sections-to-sdf> input => actual-output
+            <+ err(|"template-sections-to-sdf failed : "));
+          (<equal(|expected-output)> actual-output
+            <+ <debug> "actual output of template-sections-to-sdf does not match expected output!";
+               <debug(!"actual   : ")> actual-output;
+               <debug(!"expected : ")> expected-output;
+               fail)
+        }
+
+        test-placeholders =
+          <test'> ($[X.Y = <<<Z>>>],
+            G*|[ context-free syntax Z -> X {cons("Y")} ]|);
+          <test'> ($[X.Y = <<<this text is ignored : Z>>>],
+            G*|[ context-free syntax Z -> X {cons("Y")} ]|);
+          <test'> ($[X.Y = <<<Z?>>>],
+            G*|[ context-free syntax Z? -> X {cons("Y")} ]|);
+          <test'> ($[X.Y = <<<Z+>>>],
+            G*|[ context-free syntax Z+ -> X {cons("Y")} ]|);
+          <test'> ($[X.Y = <<<Z*>>>],
+            G*|[ context-free syntax Z* -> X {cons("Y")} ]|);
+          <test'> ($[X.Y = <<<Z+; separator=", ">>>],
+            G*|[ context-free syntax {Z ","}+ -> X {cons("Y")} ]|);
+          <test'> ($[X.Y = <<<Z*; separator=" + ">>>],
+            G*|[ context-free syntax {Z "+"}* -> X {cons("Y")} ]|)
+
+        with-newlines(s) = {|Options: {x:
+          ?x; rules( Options :+ Newlines() -> x ); s
+        }|}
+
+    in with({|DeclaredModule, GetEnclosingModuleName, Options:
+      <debug> "test suite: TemplateLang->SDF";
+
+      // Default
+      rules(
+        DeclaredModule :+ "__test" -> "__test"
+        GetEnclosingModuleName := Module("__test")
+        Options :+ Newlines() -> None()
+      );
+      newlines := [None(), Leading(), Trailing()];
+
+      // Test placeholders.
+      <list-loop(with-newlines(test-placeholders))> newlines;
+
+      // Test a complete statement.
+      statement := $[
+        Statement.IfThen = <<
+          if <Exp> then
+            <Statement*; separator="\n">
+          end
+        >>];
+
+      statement-restrictions := G*|[
+        lexical restrictions
+          "end" "if" "then" -/- [A-Za-z0-9\_\-]
+      ]|;
+      statement-no-newlines-output := G*|[
+        context-free syntax
+          "if" Exp "then" Statement* "end" -> Statement {cons("IfThen")}
+      ]|;
+      statement-leading-newlines-output := G*|[
+        context-free syntax
+          "\\n" "if" Exp "then" Statement* "\\n" "end" -> Statement {cons("IfThen")}
+      ]|;
+      statement-trailing-newlines-output := G*|[
+        context-free syntax
+          "if" Exp "then" "\\n" Statement* "end" "\\n" -> Statement {cons("IfThen")}
+      ]|;
+
+      !None()    ; with-newlines(<test'> (statement, [statement-no-newlines-output      , statement-restrictions]));
+      !Leading() ; with-newlines(<test'> (statement, [statement-leading-newlines-output , statement-restrictions]));
+      !Trailing(); with-newlines(<test'> (statement, [statement-trailing-newlines-output, statement-restrictions]));
+
+      // Test splitting of literal text at identifier boundaries.
+      <test'> ($[X.Y = "f(x, y)"], G*|[
+        context-free syntax
+          "f" "(" "x" "," "y" ")" -> X {cons("Y")}
+        lexical restrictions
+          "f" "x" "y" -/- [A-Za-z0-9\_\-]
+      ]|);
+
+      <debug> "TemplateLang->SDF tests finished."
+    |})
+    end

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/templatelang/to-str.meta
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/templatelang/to-str.meta	Sat Jun  4 16:34:11 2011	(r22994)
@@ -0,0 +1 @@
+Meta([Syntax("StrategoStratego")])

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/templatelang/to-str.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/templatelang/to-str.str	Sat Jun  4 16:34:11 2011	(r22994)
@@ -0,0 +1,119 @@
+module to-str
+
+imports
+  libstratego-lib
+  libstrc
+  lib/editor-common.generated
+  include/SpoofaxLang
+imports
+  codegen/template/to-str
+  context/template/declare
+  normalize/signatures
+
+strategies
+
+  test-templatelang-to-stratego =
+    let err(|msg) = debug(!msg); fail
+
+        // Parse a string containing some template productions.
+        prepare-input = {x:
+          (<parse-spoofaxlang-string> <conc-strings> ("module x templates ", <id>)
+            <+ err(|"parse failed : "));
+          (?CompilationUnit([Module(_, _, x)])
+            <+ err(|"project failed : "));
+          !x
+        }
+
+        prepare-output = id
+
+        // Run a test on a tuple (input, expected-output).
+        // Input is a string containing template productions.
+        // Output is a Stratego AST as build by |[ ]| CS embedding.
+        test' = {input, expected-output, actual-output:
+          where(?(<id>, _); all-lines(<conc-strings> ("  ", <id>)); debug);
+          (prepare-input, prepare-output) => (input, expected-output);
+          (<template-sections-to-stratego> input => actual-output
+            <+ err(|"template-sections-to-stratego failed : "));
+          // Instead of checking for exact equality we check that the output appears within the input.
+          // This way boilerplate parts can be left out in the majority of the tests.
+          (<oncetd(?expected-output)> actual-output
+            <+ <debug> "actual output of template-sections-to-stratego does not match expected output!";
+               <debug(!"actual   : ")> /*<pp-stratego-string> <parenthesize-Stratego>*/ actual-output;
+               <debug(!"expected : ")> /*<pp-stratego-string> <parenthesize-Stratego>*/ expected-output;
+               fail)
+        }
+
+        test-placeholders =
+          <test'> ($[X.Y = <<<Z>>>],
+            |[ prettyprint-X: Y(a) -> zz
+               with a' := <prettyprint-Z> a;
+                    zz := <concat-strings> [a'] ]|);
+          <test'> ($[X.Y = <<<this text is ignored : Z>>>],
+            |[ prettyprint-X: Y(a) -> zz
+               with a' := <prettyprint-Z> a;
+                    zz := <concat-strings> [a'] ]|);
+          // We got the hang of it; just test whether the varying part looks correct.
+          <test'> ($[X.Y = <<<Z?>>>],
+            |[ a' := <pp-option(prettyprint-Z)> a ]|);
+          <test'> ($[X.Y = <<<Z+>>>],
+            |[ a' := <pp-list(prettyprint-Z|" ")> a ]|);
+          <test'> ($[X.Y = <<<Z*>>>],
+            |[ a' := <pp-list(prettyprint-Z|" ")> a ]|);
+          <test'> ($[X.Y = <<<Z+; separator=", ">>>],
+            |[ a' := <pp-list(prettyprint-Z|", ")> a ]|);
+          <test'> ($[X.Y = <<<Z*; separator=" + ">>>],
+            |[ a' := <pp-list(prettyprint-Z|" + ")> a ]|)
+
+        with-newlines(s) = {|Options: {x:
+          ?x; rules( Options :+ Newlines() -> x ); s
+        }|}
+
+    in with({|DeclaredModule, GetEnclosingModuleName, Options:
+      <debug> "test suite: TemplateLang->Stratego";
+
+      // Default
+      rules(
+        DeclaredModule :+ "__test" -> "__test"
+        GetEnclosingModuleName := Module("__test")
+        Options :+ Newlines() -> None()
+      );
+      newlines := [None(), Leading(), Trailing()];
+
+      // Test placeholders.
+      <list-loop(with-newlines(test-placeholders))> newlines;
+
+      // Test a complete statement.
+      statement := $[
+        Statement.IfThen = <<
+          if <Exp> then
+            <Statement*; separator="\n">
+          end
+        >>];
+
+      statement-no-newlines-output := |[
+        prettyprint-Statement: IfThen(a, b) -> zz
+        with a' := <prettyprint-Exp> a;
+             b' := <pp-list(prettyprint-Statement|"\n")> b;
+             zz := <concat-strings> ["if ", a', " then", <pp-ih(|"\n  ")> b', "\nend"]
+      ]|;
+      statement-leading-newlines-output := |[
+             zz := <concat-strings> ["\nif ", a', " then", <pp-ih(|"\n  ")> b', "\nend"]
+      ]|;
+      statement-trailing-newlines-output := |[
+             zz := <concat-strings> ["if ", a', " then\n", <pp-ih(|"  ")> b', "end\n"]
+      ]|;
+
+      !None()    ; with-newlines(<test'> (statement, statement-no-newlines-output));
+      !Leading() ; with-newlines(<test'> (statement, statement-leading-newlines-output));
+      !Trailing(); with-newlines(<test'> (statement, statement-trailing-newlines-output));
+
+      // Test that undeclared sorts get a trivial prettyprinting strategy.
+      // (And undeclared sorts only, hence the inclusion of the whole section.)
+      <test'> (statement, |[
+        strategies
+          prettyprint-Exp = is-string
+      ]|);
+
+      <debug> "TemplateLang->Stratego tests finished."
+    |})
+    end

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/annotations.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/annotations.str	Sat Jun  4 16:21:15 2011	(r22993)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/annotations.str	Sat Jun  4 16:34:11 2011	(r22994)
@@ -1,25 +1,25 @@
-/**  
-* Based on copy from WebDSL revision 4115. 
+/**
+* Based on copy from WebDSL revision 4115.
 * Modified version from revision 4115.
 */
 module lib/annotations
 
 imports
   libstrategolib
-
-rules 
+
+rules
   add-annotation(|new-anno): elem -> elem{new-anno, anno*}
-		where 
+		where
 			anno* := <get-annos> elem
 
 	add-annotations(|new-annos): elem -> out
-		where 
+		where
 			<is-list> new-annos
-		where 
+		where
 			<gt> (<length> new-annos,0)
 		with (
 			if <?[i]> new-annos
-			then 
+			then
 				// we are at the last item
 				out := <add-annotation(|<last> new-annos)> elem
 			else
@@ -28,7 +28,7 @@
 				out := <add-annotations(|ii*)> <add-annotation(|i)> elem
 			end
 		)
-	
+
 	copy-annotations(|copyFrom) =
 		?elem;
 		<get-annos>copyFrom => srcAnnos;
@@ -37,25 +37,29 @@
 		else
 			!<add-annotations(|srcAnnos)> elem
 		end
-	
+
 	copy-add-annotations(|copyFrom,new-annos) : elem -> <copy-annotations(|copyFrom); (add-annotations(|new-annos) <+ add-annotation(|new-annos))> elem
-	
+
 	// Return given anno if found, fail otherwise
 	get-annotation(|anno): elem -> anno
-		where 
-			(?_{anno*}; 
-			!anno*; 
+		where
+			(?_{anno*};
+			!anno*;
 			fetch-elem(?anno))
 
 	// Return anno for which the strategy succeeds, fail otherwise
 	get-annotation(s) = ?_{anno*}; !anno*; fetch-elem(s)
-  
+
 	// Succeed if no anno matches
 	has-no-anno(s) = not(get-annotation(s))
-  
+
 	// Add annotation if not present, fail otherwise
 	add-new-anno(|anno) = where(has-no-anno(?anno)); add-annotation(|anno)
-	
+
 	// remove annotation from a particular term
 	remove-annotations = rm-annotations
- 
\ No newline at end of file
+
+  // Succeed if the term anno is present as annotation of the current term
+  has-annotation(|anno):
+    x{a*} -> <id>
+    where <one(?anno)> a*

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/attributes.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/attributes.str	Sat Jun  4 16:34:11 2011	(r22994)
@@ -0,0 +1,25 @@
+module utils/attributes
+imports
+	libstratego-lib
+	libstratego-sglr
+	include/SpoofaxLang
+
+overlays
+  sdf-cons(x) = term(default(appl(unquoted("cons"), [fun(quoted(x))])))
+
+strategies
+
+  fetch-cons =
+    ?sdf-cons(_) + ?Constructor(_)
+
+  fetch-cons:
+    attrs(attr*) -> <getfirst(fetch-cons)> attr*
+
+  fetch-cons-name:
+    sdf-cons(cons) -> <un-double-quote> cons
+
+  fetch-cons-name:
+    Constructor(cons) -> <un-double-quote> cons
+
+  fetch-cons-name:
+    attrs(attr*) -> <getfirst(fetch-cons-name)> attr*

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/contract.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/contract.str	Sat Jun  4 16:21:15 2011	(r22993)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/contract.str	Sat Jun  4 16:34:11 2011	(r22994)
@@ -1,49 +1,51 @@
-module 	utils/contract 
-imports 
+module 	utils/contract
+imports
 	common
-	utils/debug	
+	utils/debug
 
 
-//Draft of code contracts for stratego 
-rules 
+//Draft of code contracts for stratego
+rules
 
 	contract-requires ( s , on-fail | arg , expected) =
 			contract-requires ( s | arg , expected)
 		<+
-			on-fail 
-		
-		
+			on-fail
+
+
 	contract-requires ( s | arg , expected) =
 			where(<s>arg)
 		<+
 			<debug> $[Contract | Requires Failed - actual :[<pp-aterm>arg] expected : [expected]]
-			;fail 	 
-	
-	
+			;fail
+
+
 	contract-requires ( s | arg ) = <contract-requires (s)> arg
-	
-	
+
+
 	contract-requires (s) =
 			where(s)
 		<+
 			<debug> $[Contract | Requires Failed - argument :[<pp-aterm>] ]
-			;fail 	 
-	
-	
+			;fail
+
+
 	contracts ( s ) =  where(s) <+ fail
-	
-	
+
+
 	with-verification (preconditions, s ) = with-verification (preconditions, s , id)
-	 
-	
+
+
 	with-verification (preconditions, s , postconditions) = where(preconditions) ; s ; where(postconditions) <+ fail
 
 
 rules
-	
+
 	run-strategy(  s  , on-fail | msg) = s <+  <debug> msg ; on-fail
-	 
+
 rules
-	String = is-string 
-	
-	List = is-list	    
\ No newline at end of file
+	String = is-string
+
+	List = is-list
+
+	ListOf(s) = list-loop(s)

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/debug.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/debug.str	Sat Jun  4 16:21:15 2011	(r22993)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/debug.str	Sat Jun  4 16:34:11 2011	(r22994)
@@ -1,61 +1,65 @@
 module utils/debug
 
-imports 
+imports
 	common
 
-strategies 
+strategies
 	enable-debug-all  = rules ( DebugAll: _ )
-	
+
 	disable-debug-all  = rules ( DebugAll:- _ )
 
-strategies 
-		
+strategies
+
 	enable-stratego-debugging  = rules(DebugStr: x -> x)
-	
+
 	disable-stratego-debugging = rules(DebugStr:- _ )
-	
+
 	debug-str = not(DebugStr) <+ debug
-  
-strategies 
+
+strategies
 
 	enable-sdf-debugging  = rules(DebugSDF: _)
-	
+
 	disable-sdf-debugging = rules(DebugSDF:- _ )
-	
-	// Dubug switches  
+
+	// Debug switches
 	enable-declaration-debugging  = rules(DebugDeclaration: x -> x)
-	
+
 	disable-declaration-debugging = rules(DebugDeclaration:- _ )
-	
-	debug-declaration = not(DebugDeclaration <+ DebugAll)  <+ debug(!"--- Declaration | ") 
- 
- 
- 
-	// Dubug switches  for symbol table
+
+	debug-declaration = not(DebugDeclaration <+ DebugAll)  <+ debug(!"--- Declaration | ")
+
+
+
+	// Debug switches  for symbol table
 	enable-symboltable-debugging  = rules(DebugSymbolTable: x -> x)
-	
+
 	disable-symboltable-debugging = rules(DebugSymbolTable:- _ )
-	
-	debug-symboltable = not(DebugSymbolTable <+ DebugAll)  <+ debug(!"--- SymbolTable | ") 
- 
- 
-  // Dubug switches for semantic analysis  
+
+	debug-symboltable = not(DebugSymbolTable <+ DebugAll)  <+ debug(!"--- SymbolTable | ")
+
+
+  // Debug switches for semantic analysis
 	enable-semantic-analysis-debugging = rules(DebugSemanticAnalysis: x -> x)
-	
+
 	disable-semantic-analysis-debugging = rules(DebugSemanticAnalysis:- _ )
-	
-	debug-analysis = not(DebugSemanticAnalysis <+ DebugAll)  <+ debug(!"--- SemanticAnalysis | ") 
- 
- 
- 	// Dubug switches for compile  
+
+	debug-analysis = not(DebugSemanticAnalysis <+ DebugAll)  <+ debug(!"--- SemanticAnalysis | ")
+
+
+ 	// Debug switches for compile
 	enable-compiler-debugging  = rules(DebugCompiler: x -> x)
-	
+
 	disable-compiler-debugging = rules(DebugCompiler:- _ )
-	
+
 	debug-compiler = not(DebugCompiler <+ DebugAll)  <+ debug(!"--- Compiler | ")
- 
- rules 
- 	
+
+
+  // Debug switches for TemplateLang
+  debug-templatelang = debug(!"--- TemplateLang | ")
+
+ rules
+
  	debug-time(s|msg) =
       where(starttime := <times>)
     ; s
@@ -66,13 +70,12 @@
         ; debug
       )
 
-rules 
+rules
 	throw-unable-read-exception(|message) = debug(!message);fail
 	throw-unable-read-file = debug(!"unable to read file : ")
 
-rules 
+rules
 	throw-precompile-exception = debug(!"Could not precompile: "); fail
 	throw-invalid-argument-exception(|strategy-name) = <debug>$[invalid argument at [strategy-name] : [<pp-aterm><id>]]; fail
-	
-	
-	      
\ No newline at end of file
+
+

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/sdf2conflicts.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/sdf2conflicts.str	Sat Jun  4 16:34:11 2011	(r22994)
@@ -0,0 +1,263 @@
+// Author: Tobi Vollebregt
+
+// Calculates SubtermConflicts from an SDF definition.
+// (instead of calculating them from a parse table as sdf2parenthesize does)
+
+// This is slightly inspired by sdftools/trans/sdf2ast-conflicts.str
+
+module sdf2conflicts
+imports
+  libstratego-lib
+  libstratego-sglr
+
+signature
+  constructors
+    Symbol : String * Int -> Symbol
+
+overlays
+  sdf-cons(name) = term(default(appl(unquoted("cons"), [fun(quoted(name))])))
+
+strategies
+
+  /*
+   * sdf2conflicts: Calculate set of conflicts that are filtered out using
+   * priorities, i.e. that need parenthesis when prettyprinting.
+   *
+   * The input term is an SDF AST. It is not modified. The main side-effect
+   * is the initialization of the SubtermConflicts dynamic rule:
+   *
+   *  SubtermConflicts: Symbol => (Int, Symbol)
+   *
+   * This maps each symbol (cons + arity) X to a list of pairs (arg, Y)
+   * which mean that Y is not allowed as child of X at position arg.
+   * (To get to the list use `<bagof-SubtermConflicts> symbol'!)
+   */
+  sdf2conflicts:
+    ast -> ast
+    with
+      prod-hash := <new-hashtable> // (sym*, sort) => attr*
+    with
+      let err(|msg) = debug(!<conc-strings> (msg, ": ")); fail
+
+          // push the attributes of a production into prod-hash
+          declare-prod =
+      	    \ p@ prod(sym*, sort, attrs(attr*)) -> p
+      	      with <hashtable-pushlist(|(sym*, sort), attr*)> prod-hash \
+
+          // add all attributes defined anywhere to a production
+          lookup-prod = {attr*:
+          	\ p@ prod(sym*, sort, _) -> prod(sym*, sort, attrs(attr*))
+          	  with attr* := <hashtable-get(|(sym*, sort)) <+ ![]> prod-hash \
+          }
+
+          priority-section =
+            ?context-free-priorities(<id>)
+          + ?lexical-priorities(<id>)
+          + ?priorities(<id>)
+
+          // get rid of simple-group ; add attributes to productions
+          normalize-group-and-add-attributes =
+            assoc-group(id, map(lookup-prod))
+          + prods-group(map(lookup-prod))
+          + \ simple-group(p) -> prods-group([<lookup-prod> p]) \
+
+          // from core-sdf-grammar2rtg.str
+          /**
+           * @type  Symbol -> Symbol
+           */
+          is-empty-sym = ?lit(_)
+          is-empty-sym = ?ci-lit(_)
+          is-empty-sym = ?layout()
+          is-empty-sym = opt(is-empty-sym)
+          is-empty-sym = cf(is-empty-sym)
+          is-empty-sym = lex(is-empty-sym)
+          is-empty-sym = label(id, is-empty-sym)
+
+          cons-of-prod =
+            ?prod(_, _, attrs(<id>));
+            fetch-elem(?sdf-cons(<un-double-quote>))
+
+          assoc-of-prod =
+            ?prod(_, _, attrs(<id>));
+            fetch-elem(?assoc(<id>))
+
+          // from sdf2ast-conflicts.str
+          Prod2Symbol = {x, n:
+            \ p at prod(syms, _, _) -> Symbol(x, n)
+              where
+                n := <filter(not(is-empty-sym)); length> syms
+              ; x := <cons-of-prod <+ err(|"production does not have a cons")> p \
+          }
+
+          // from sdf2ast-conflicts.str
+          /**
+           * @type Int -> Int
+           */
+          arg-for-symbol(|p) = {arg, syms, syms':
+            ?arg
+            ; prod(syms, _, _) := p
+            ; syms' := <add-indices; retain-all((id, not(is-empty-sym)); ?(<id>, _))> syms
+            ; (<get-index; dec> (<inc> arg, syms') <+ !())
+          }
+
+          chaintd(s) = list-loop(chain(listtd(where(s))))
+
+          chainloop(s) = list-loop(chain(list-loop(s)))
+
+          fetch-group =
+            try(?non-transitive(<id>));
+            try(?with-arguments(<id>, _))
+
+          fetch-prods =
+            fetch-group;
+            (?assoc-group(_, <id>) + ?prods-group(<id>))
+
+          for-each-prod-pair(s) =
+            (fetch-prods, fetch-prods);
+            for-each-pair(s)
+
+          add-subterm-conflict(|lhs, arg, rhs) =
+            if not(<bagof-SubtermConflicts; fetch(?(arg, rhs))> lhs) then
+              {lhs', arg', rhs':
+                <debug(!"adding subterm conflict: ")> (lhs, (arg, rhs));
+                lhs' := lhs;
+                arg' := arg;
+                rhs' := rhs;
+                rules(SubtermConflicts :+ lhs' -> (arg', rhs'))
+              }
+            end
+
+          add-prio(|arg) = {lhs, rhs, lhs', rhs':
+            ?(lhs, rhs);
+            lhs' := <Prod2Symbol> lhs;
+            rhs' := <Prod2Symbol> rhs;
+            add-subterm-conflict(|lhs', arg, rhs')
+          }
+
+          add-gtr-prio = {lhs, rhs, n:
+            ?(lhs, rhs);
+            Symbol(_, n) := <Prod2Symbol> lhs;
+            <range> (0, n);
+            map(\ arg -> arg with <add-prio(|arg)> (lhs, rhs) \)
+          }
+
+          add-arg-gtr-prio(|indices) = {lhs, rhs:
+            ?(lhs, rhs);
+            !indices;
+            map(\ arg -> arg with <add-prio(|<arg-for-symbol(|lhs)> arg)> (lhs, rhs) \)
+          }
+
+          add-left-assoc = {lhs, rhs, n:
+            ?(lhs, rhs);
+            Symbol(_, n) := <Prod2Symbol> lhs;
+            <add-prio(|<dec> n)> (lhs, rhs)
+          }
+
+          add-right-assoc = {lhs, rhs:
+            ?(lhs, rhs);
+            <add-prio(|0)> (lhs, rhs)
+          }
+
+          add-group(match) = {first, second, indices, indices':
+          	?[]
+          + ?[_]
+          + ?[first, second | _];
+            if <match> first then
+              if <?with-arguments(_, default(indices))> first then
+              	indices' := <map(string-to-int)> indices;
+                <for-each-prod-pair(add-arg-gtr-prio(|indices'))> (first, second)
+              else
+                <for-each-prod-pair(add-gtr-prio)> (first, second)
+              end
+            end
+          }
+
+          add-transitives = chaintd(add-group(not(?non-transitive(_))))
+
+          add-non-transitives = chaintd(add-group(?non-transitive(_)))
+
+          // Associativity within a group
+          // (does not make group members self-associative)
+          // Note: In SDF if there is only one group member it does
+          //       make it self-associative. (StrategoXT/863)
+          add-associativity = {associativity, prod*:
+            fetch-group;
+            if ?assoc-group(associativity, prod*) then
+              if <?left() + ?assoc() + ?non-assoc()> associativity then
+                <for-each-pair(eq <+ add-left-assoc)> (prod*, prod*)
+              end;
+              if <?right() + ?non-assoc()> associativity then
+                <for-each-pair(eq <+ add-right-assoc)> (prod*, prod*)
+              end
+            end
+          }
+
+          add-associativities = chainloop(add-associativity)
+
+          add-self-associativity = {associativity, p:
+            ?p@ prod(_, _, _);
+            if assoc-of-prod => associativity then
+              if <?left() + ?assoc() + ?non-assoc()> associativity then
+                <add-left-assoc> (p, p)
+              end;
+              if <?right() + ?non-assoc()> associativity then
+                <add-right-assoc> (p, p)
+              end
+            end
+          }
+
+          add-self-associativities =
+            with(
+              <hashtable-getlist> prod-hash;
+              list-loop(
+                \ ((sym*, sort), attr*) -> prod(sym*, sort, attrs(attr*)) \;
+                add-self-associativity
+              )
+            )
+
+          make-transitive-step =
+            all-keys-SubtermConflicts; nub; // List(Symbol)
+            // For each symbol X
+            list-loop({lhs:
+              ?lhs;
+              bagof-SubtermConflicts; // List((Int, Symbol))
+              // For each symbol Y with X > Y
+              list-loop({arg:
+                ?(arg, <bagof-SubtermConflicts>); // List((Int, Symbol))
+                // For each symbol Z with Y > Z
+                list-loop({rhs:
+                  ?(_, rhs);
+                  // Add X > Z if it doesn't exist
+                  add-subterm-conflict(|lhs, arg, rhs)
+                })
+              })
+            })
+
+          make-transitive =
+            with( \SubtermConflicts/* make-transitive-step )
+
+          // Debug
+          print-SubtermConflicts(|msg) =
+            with(
+              <debug> msg;
+              all-keys-SubtermConflicts;
+              list-loop(debug(!"key: "); bagof-SubtermConflicts; debug(!"values: "))
+            )
+
+      in
+        !ast;
+        alltd(declare-prod);
+        collect-om(priority-section); concat; // List(chain(_))
+        alltd(normalize-group-and-add-attributes);
+
+        add-transitives;
+        // print-SubtermConflicts(|"=== before applying transitivity relation ===");
+        make-transitive;
+        add-non-transitives;
+        add-associativities;
+        add-self-associativities
+
+        ;print-SubtermConflicts(|"=== FINAL ===")
+      end
+    with
+      <hashtable-destroy> prod-hash

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/templatelang.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/templatelang.str	Sat Jun  4 16:34:11 2011	(r22994)
@@ -0,0 +1,101 @@
+module templatelang
+
+imports
+  libstratego-lib
+  lib/editor-common.generated
+  include/SpoofaxLang
+imports
+  context/sdf/declare
+
+signature
+  constructors
+    // Options
+    Newlines : X
+    // Other
+    Indent : String -> Indent
+
+strategies
+
+  sort-has-leading-newline =
+    bagof-Declaration;
+    ?[_|_];
+    all(?TemplateProduction(_, Template([Newline(_)| _]), _))
+
+  sort-has-trailing-newline =
+    bagof-Declaration;
+    ?[_|_];
+    let trailing-newline =
+          at-suffix([Newline(id), ?Layout(_) + ?Indent(_)] <+ [Newline(id)])
+    in
+      all(?TemplateProduction(_, Template(<trailing-newline>), _))
+    end
+
+strategies // Utility strategies
+
+  // is-layout is already defined somewhere else
+  xxx-is-layout = ?Layout(_) + ?Indent(_) + ?Newline(_)
+
+  trim-leading-layout =
+    ltrim(xxx-is-layout)
+
+  trim-trailing-layout =
+    rtrim(xxx-is-layout)
+
+  trim-trailing-indent =
+    rtrim(?Indent(_))
+
+  trim-layout =
+    trim-leading-layout;
+    trim-trailing-layout
+
+  // This doesn't take the indentation due to everything up to
+  // the open brackets of the template into account.
+  get-indent-string =
+    let get-indent =
+             \[Newline(_), Layout(y), _ | tail] -> [<string-replace(|"\t", "  "); string-length> y | <get-indent> tail]\
+          <+ \[Newline(_), Layout(_)] -> []\
+          <+ \[Newline(_), Newline(_) | tail] -> <get-indent> tail\
+          <+ \[Newline(_), y | tail] -> [0 | <get-indent> tail]\
+          <+ \[_ | tail] -> <get-indent> tail\
+          <+ []
+    in
+      get-indent; list-min => size;
+      // Build string from right to left, as list.
+      ![]; repeat(![' ' | <id>] | size); !['\n' | <id>];
+      implode-string
+    end
+
+  re-indent(|indent-string) =
+    \[Newline(_), Layout(indent) | tail] -> result
+    with
+      // Add a newline because indent-string contains a newline as anchor.
+      indent' := <string-replace(|indent-string, "")> <conc-strings>("\n", indent);
+      tail' := <re-indent(|indent-string)> tail;
+      result := [Newline("\n"), Indent(indent') | tail']\
+  <+
+    \[head | tail] -> [head | <re-indent(|indent-string)> tail]\
+  <+
+    []
+
+  try-re-indent =
+    if get-indent-string => is then
+      re-indent(|is)
+    end
+
+  concatenate-consecutive-strings =
+       \[String(a), String(b) | tail] -> <concatenate-consecutive-strings> [String(<conc-strings> (a, b)) | tail]\
+    <+ [id | concatenate-consecutive-strings]
+    <+ []
+
+  combine-consecutive-newlines =
+       \[Newline(x){a*}, Newline(_){b*} | tail] -> <combine-consecutive-newlines> [Newline(x){a*, b*} | tail]\
+    <+ [id | combine-consecutive-newlines]
+    <+ []
+
+  templatelang-escape =
+    string-replace(|"\\", "\\\\");
+    string-replace(|"\t", "\\t");
+    string-replace(|"\r", "\\r");
+    string-replace(|"\n", "\\n");
+    string-replace(|"'", "\\'");
+    string-replace(|"\"", "\\\"")

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/tokenize.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/tokenize.str	Sat Jun  4 16:34:11 2011	(r22994)
@@ -0,0 +1,39 @@
+module tokenize
+
+imports
+  libstratego-lib
+
+strategies
+
+  /**
+   * @see edge-tokenize
+   * @type String -> List(String)
+   */
+  string-edge-tokenize(s) =
+    explode-string;
+    edge-tokenize(s);
+    map(implode-string)
+
+  /**
+   * Edge-triggered tokenizer; a new token starts whenever s starts
+   * succeeding or starts failing, i.e. when for two consecutive list items
+   * s succeeds on the first item but s fails on the second item or
+   * s fails on the first item and s succeeds on the second item.
+   *
+   * @type List(a) -> List(List(a))
+   */
+  edge-tokenize(s) =
+    ?[first | tail];
+    if second := <Hd> tail then
+      tokens := <edge-tokenize(s)> tail;
+      if (<s> first) < (<not(s)> second) + (<s> second) then
+        ![[first] | tokens]
+      else
+        [firstToken | restTokens] := tokens;
+        ![[first | firstToken] | restTokens]
+      end
+    else
+      ![[first]]
+    end
+  <+
+    []

From tobivollebregt at gmail.com  Sat Jun  4 18:36:18 2011
From: tobivollebregt at gmail.com (Tobi Vollebregt)
Date: Sat, 04 Jun 2011 16:36:18 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r22995 -
	spoofax-contrib/DatabaseTemplateLang
Message-ID: <20110604163618.EB3172B8062@mx2.tudelft.nl>

Author: tvo
Date: Sat Jun  4 16:36:18 2011
New Revision: 22995
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=22995&sc=1

Log:
Copy of DatabaseSPXLang to demonstrate TemplateLang

Added:
   spoofax-contrib/DatabaseTemplateLang/
      - copied from r22994, spoofax-contrib/DatabaseSPXLang/

From tobivollebregt at gmail.com  Sat Jun  4 18:49:50 2011
From: tobivollebregt at gmail.com (Tobi Vollebregt)
Date: Sat, 04 Jun 2011 16:49:50 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r22996 - in
	spoofax-contrib/DatabaseTemplateLang: . .externalToolBuilders
	META-INF editor/java/DatabaseSPXLang
	editor/java/DatabaseTemplateLang editor/java/DatabaseTemplate...
Message-ID: <20110604164950.BDB572B804D@mx2.tudelft.nl>

Author: tvo
Date: Sat Jun  4 16:49:49 2011
New Revision: 22996
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=22996&sc=1

Log:
DatabaseTemplateLang: Rename the project, replace concrete syntax with templates.

Added:
   spoofax-contrib/DatabaseTemplateLang/.externalToolBuilders/DatabaseTemplateLang build.main.xml.launch
      - copied unchanged from r22995, spoofax-contrib/DatabaseTemplateLang/.externalToolBuilders/DatabaseSPXLang build.main.xml.launch
   spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseTemplateLang/
      - copied from r22995, spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseSPXLang/
   spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseTemplateLang/DatabaseTemplateLangParseController.java
      - copied, changed from r22995, spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseSPXLang/DatabaseSPXLangParseController.java
   spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseTemplateLang/DatabaseTemplateLangParseControllerGenerated.java
      - copied, changed from r22995, spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseSPXLang/DatabaseSPXLangParseControllerGenerated.java
   spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseTemplateLang/DatabaseTemplateLangValidator.java
      - copied, changed from r22995, spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseSPXLang/DatabaseSPXLangValidator.java
Deleted:
   spoofax-contrib/DatabaseTemplateLang/.externalToolBuilders/DatabaseSPXLang build.main.xml.launch
   spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseSPXLang/
   spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseTemplateLang/DatabaseSPXLangParseController.java
   spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseTemplateLang/DatabaseSPXLangParseControllerGenerated.java
   spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseTemplateLang/DatabaseSPXLangValidator.java
Modified:
   spoofax-contrib/DatabaseTemplateLang/.project
   spoofax-contrib/DatabaseTemplateLang/META-INF/MANIFEST.MF
   spoofax-contrib/DatabaseTemplateLang/build.spx.packages.xml
   spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseTemplateLang/Activator.java
   spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseTemplateLang/strategies/InteropRegisterer.java
   spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseTemplateLang/strategies/Main.java
   spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseTemplateLang/strategies/java_strategy_0_0.java
   spoofax-contrib/DatabaseTemplateLang/plugin.xml
   spoofax-contrib/DatabaseTemplateLang/src/databaselang.spx
   spoofax-contrib/DatabaseTemplateLang/src/languagedescription.spx
   spoofax-contrib/DatabaseTemplateLang/test/example.pp.sdb

Copied: spoofax-contrib/DatabaseTemplateLang/.externalToolBuilders/DatabaseTemplateLang build.main.xml.launch (from r22995, spoofax-contrib/DatabaseTemplateLang/.externalToolBuilders/DatabaseSPXLang build.main.xml.launch)
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/DatabaseTemplateLang/.externalToolBuilders/DatabaseTemplateLang build.main.xml.launch	Sat Jun  4 16:49:49 2011	(r22996, copy of r22995, spoofax-contrib/DatabaseTemplateLang/.externalToolBuilders/DatabaseSPXLang build.main.xml.launch)
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<launchConfiguration type="org.eclipse.ant.AntLaunchConfigurationType">
+<stringAttribute key="bad_container_name" value=".externalToolBuilders"/>
+<booleanAttribute key="org.eclipse.ant.ui.DEFAULT_VM_INSTALL" value="false"/>
+<listAttribute key="org.eclipse.debug.core.MAPPED_RESOURCE_PATHS"/>
+<listAttribute key="org.eclipse.debug.core.MAPPED_RESOURCE_TYPES"/>
+<booleanAttribute key="org.eclipse.debug.ui.ATTR_LAUNCH_IN_BACKGROUND" value="false"/>
+<listAttribute key="org.eclipse.jdt.launching.CLASSPATH">
+<listEntry value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&#10;&lt;runtimeClasspathEntry containerPath=&quot;org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/java-1.5.0-sun-1.5.0.18&quot; path=&quot;1&quot; type=&quot;4&quot;/&gt;&#10;"/>
+<listEntry value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&#10;&lt;runtimeClasspathEntry id=&quot;org.eclipse.ant.ui.classpathentry.antHome&quot;&gt;&#10;&lt;memento default=&quot;true&quot;/&gt;&#10;&lt;/runtimeClasspathEntry&gt;&#10;"/>
+<listEntry value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&#10;&lt;runtimeClasspathEntry id=&quot;org.eclipse.ant.ui.classpathentry.extraClasspathEntries&quot;&gt;&#10;&lt;memento/&gt;&#10;&lt;/runtimeClasspathEntry&gt;&#10;"/>
+</listAttribute>
+<stringAttribute key="org.eclipse.jdt.launching.CLASSPATH_PROVIDER" value="org.eclipse.ant.ui.AntClasspathProvider"/>
+<booleanAttribute key="org.eclipse.jdt.launching.DEFAULT_CLASSPATH" value="false"/>
+<stringAttribute key="org.eclipse.jdt.launching.PROJECT_ATTR" value=""/>
+<stringAttribute key="org.eclipse.jdt.launching.SOURCE_PATH_PROVIDER" value="org.eclipse.ant.ui.AntClasspathProvider"/>
+<stringAttribute key="org.eclipse.ui.externaltools.ATTR_ANT_TARGETS" value="build-spx-packages,"/>
+<stringAttribute key="org.eclipse.ui.externaltools.ATTR_LAUNCH_CONFIGURATION_BUILD_SCOPE" value="${none}"/>
+<stringAttribute key="org.eclipse.ui.externaltools.ATTR_LOCATION" value="${workspace_loc:/DatabaseSPXLang/build.spx.packages.xml}"/>
+<booleanAttribute key="org.eclipse.ui.externaltools.ATTR_TRIGGERS_CONFIGURED" value="true"/>
+<stringAttribute key="org.eclipse.ui.externaltools.ATTR_WORKING_DIRECTORY" value="${workspace_loc:/DatabaseSPXLang}"/>
+<stringAttribute key="process_factory_id" value="org.eclipse.ant.ui.remoteAntProcessFactory"/>
+</launchConfiguration>

Modified: spoofax-contrib/DatabaseTemplateLang/.project
==============================================================================
--- spoofax-contrib/DatabaseTemplateLang/.project	Sat Jun  4 16:36:18 2011	(r22995)
+++ spoofax-contrib/DatabaseTemplateLang/.project	Sat Jun  4 16:49:49 2011	(r22996)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8" ?>
 
 <projectDescription>
-      <name>DatabaseSPXLang</name>
+      <name>DatabaseTemplateLang</name>
       <comment></comment>
       <buildSpec>
         <buildCommand>
@@ -15,7 +15,7 @@
             <arguments>
                 <dictionary>
                     <key>LaunchConfigHandle</key>
-                    <value>&lt;project&gt;/.externalToolBuilders/DatabaseSPXLang build.main.xml.launch</value>
+                    <value>&lt;project&gt;/.externalToolBuilders/DatabaseTemplateLang build.main.xml.launch</value>
                 </dictionary>
             </arguments>
         </buildCommand>

Modified: spoofax-contrib/DatabaseTemplateLang/META-INF/MANIFEST.MF
==============================================================================
--- spoofax-contrib/DatabaseTemplateLang/META-INF/MANIFEST.MF	Sat Jun  4 16:36:18 2011	(r22995)
+++ spoofax-contrib/DatabaseTemplateLang/META-INF/MANIFEST.MF	Sat Jun  4 16:49:49 2011	(r22996)
@@ -1,9 +1,9 @@
 Manifest-Version: 1.0
 Bundle-ManifestVersion: 2
-Bundle-Name: DatabaseSPXLang Plug-in
-Bundle-SymbolicName: DatabaseSPXLang; singleton:=true
+Bundle-Name: DatabaseTemplateLang Plug-in
+Bundle-SymbolicName: DatabaseTemplateLang; singleton:=true
 Bundle-Version: 1.0.0
-Bundle-Activator: DatabaseSPXLang.Activator
+Bundle-Activator: DatabaseTemplateLang.Activator
 Import-Package: org.osgi.framework;version="1.3.0"
 Require-Bundle: org.eclipse.core.runtime,
   org.eclipse.core.resources,
@@ -18,4 +18,4 @@
   org.strategoxt.strj
 Bundle-RequiredExecutionEnvironment: J2SE-1.5
 Bundle-ActivationPolicy: lazy
-Export-Package: DatabaseSPXLang
+Export-Package: DatabaseTemplateLang

Modified: spoofax-contrib/DatabaseTemplateLang/build.spx.packages.xml
==============================================================================
--- spoofax-contrib/DatabaseTemplateLang/build.spx.packages.xml	Sat Jun  4 16:36:18 2011	(r22995)
+++ spoofax-contrib/DatabaseTemplateLang/build.spx.packages.xml	Sat Jun  4 16:49:49 2011	(r22996)
@@ -1,20 +1,20 @@
 <?xml version="1.0" encoding="UTF-8" ?>
-		
+
 		<project name="build.spx.packages" default="build-spx-packages">
-  <!-- autogenerated artifacts relative directory path -->	
+  <!-- autogenerated artifacts relative directory path -->
 		<property name="packages.root" location=".shadowdir"/>
-		
+
 		<!-- prject directories -->
   <property name="trans" location="trans"/>
   <property name="src-gen" location="editor/java"/>
   <property name="syntax" location="syntax"/>
   <property name="include" location="include"/>
   <property name="lib" location="lib"/>
-  <property name="build" location="bin"/> 
+  <property name="build" location="bin"/>
   <property name="dist" location="bin/dist"/>
-  
+
 		<!-- Environment configuration for command-line builds -->
-  <property name="build.sdf.imports" value= "-I &quot;${basedir}&quot; -I &quot;${packages.root}&quot;"/>
+  <property name="build.sdf.imports" value= "-I &quot;${basedir}&quot; "/>
   <property name="build.stratego.args" value="
                   --library
                   -I &quot;${packages.root}&quot;
@@ -25,21 +25,21 @@
       <isset property="eclipse.spoofaximp.nativeprefix"/>
   </condition>
   <property name="build.strategoxt.stratego" location="${user.home}/.nix-profile/bin"/>
-	  
+
 	  <import file="build.spx.packages.generated.xml"/>
 	  
-	  
 	  <target name="build.package.languages.DatabaseLang">
 	  	<property name="package.path" location=".shadowdir/languages/DatabaseLang"/>
-	  	<property name="lang.id.specific.directoy" value="DatabaseSPXLang"/>
-	  	<property name="package.name" value="DatabaseSPXLang"/>
+	  	<property name="lang.id.specific.directoy" value="DatabaseTemplateLang"/>
+	  	<property name="package.name" value="DatabaseTemplateLang"/>
 	  	<property name="package.qname" value="languages.DatabaseLang"/>
-	  	<property name="package.main.sdf.module" value="DatabaseSPXLang"/>
-	  	<property name="package.main.str.module" value="DatabaseSPXLang"/>
-	  	<property name="package.main.esv.module" value="DatabaseSPXLang.main"/>
-	  	<property name="metasdfmodule" value="Stratego-DatabaseSPXLang"/>
-	  	 
-	  	
+	  	<property name="package.main.sdf.module" value="DatabaseTemplateLang"/>
+	  	<property name="package.main.str.module" value="DatabaseTemplateLang"/>
+	  	<property name="package.main.esv.module" value="DatabaseTemplateLang.main"/>
+	  	<property name="metasdfmodule" value="Stratego-DatabaseTemplateLang"/>
+	  	<property name="lang.sdf.specific.params" value=""/>
+	  	<property name="lang.str.specific.params" value=""/>
+	  
 	  	<antcall target = "spx.default">
 	  	  <param name = "package.name"  value = "${package.name}"/>
 	  	  <param name = "package.qname"  value = "${package.qname}"/>
@@ -49,10 +49,12 @@
 	  		<param name = "package.main.str.module" value = "${package.main.str.module}"/>
 	  	 	<param name = "package.main.esv.module" value = "${package.main.esv.module}"/>
 	  		<param name = "metasdfmodule" value = "${metasdfmodule}"/>
+	  		<param name="lang.sdf.specific.params" value="${lang.sdf.specific.params}"/>
+	  		<param name="lang.str.specific.params" value="${lang.str.specific.params}"/>
 	  	</antcall>
-	  </target>	
+	  </target>
 	  
-		
+
 		<!-- Main target -->
 	<target name="build-spx-packages" depends="build.package.languages.DatabaseLang"/>
 </project>
\ No newline at end of file

Modified: spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseTemplateLang/Activator.java
==============================================================================
--- spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseSPXLang/Activator.java	Sat Jun  4 16:36:18 2011	(r22995)
+++ spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseTemplateLang/Activator.java	Sat Jun  4 16:49:49 2011	(r22996)
@@ -1,4 +1,4 @@
-package DatabaseSPXLang;
+package DatabaseTemplateLang;
 
 import org.eclipse.imp.preferences.PreferencesService;
 import org.eclipse.imp.runtime.PluginBase;
@@ -6,9 +6,9 @@
 
 public class Activator extends PluginBase 
 { 
-  public static final String kPluginID = "DatabaseSPXLang";
+  public static final String kPluginID = "DatabaseTemplateLang";
 
-  public static final String kLanguageName = "DatabaseSPXLang";
+  public static final String kLanguageName = "DatabaseTemplateLang";
 
   protected static Activator sPlugin;
 

Copied and modified: spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseTemplateLang/DatabaseTemplateLangParseController.java (from r22995, spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseSPXLang/DatabaseSPXLangParseController.java)
==============================================================================
--- spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseSPXLang/DatabaseSPXLangParseController.java	Sat Jun  4 16:36:18 2011	(r22995, copy source)
+++ spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseTemplateLang/DatabaseTemplateLangParseController.java	Sat Jun  4 16:49:49 2011	(r22996)
@@ -1,4 +1,4 @@
-package DatabaseSPXLang;
+package DatabaseTemplateLang;
 
-public class DatabaseSPXLangParseController extends DatabaseSPXLangParseControllerGenerated 
+public class DatabaseTemplateLangParseController extends DatabaseTemplateLangParseControllerGenerated 
 { }
\ No newline at end of file

Copied and modified: spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseTemplateLang/DatabaseTemplateLangParseControllerGenerated.java (from r22995, spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseSPXLang/DatabaseSPXLangParseControllerGenerated.java)
==============================================================================
--- spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseSPXLang/DatabaseSPXLangParseControllerGenerated.java	Sat Jun  4 16:36:18 2011	(r22995, copy source)
+++ spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseTemplateLang/DatabaseTemplateLangParseControllerGenerated.java	Sat Jun  4 16:49:49 2011	(r22996)
@@ -1,4 +1,4 @@
-package DatabaseSPXLang;
+package DatabaseTemplateLang;
 
 import java.io.InputStream;
 import java.io.IOException;
@@ -12,9 +12,9 @@
 import org.strategoxt.imp.runtime.dynamicloading.DescriptorFactory;
 import org.strategoxt.imp.runtime.dynamicloading.DynamicParseController;
 
-public class DatabaseSPXLangParseControllerGenerated extends DynamicParseController 
+public class DatabaseTemplateLangParseControllerGenerated extends DynamicParseController 
 { 
-  public static final String LANGUAGE = new String("DatabaseSPXLang");
+  public static final String LANGUAGE = new String("DatabaseTemplateLang");
 
   private static final String TABLE = "/include/" + LANGUAGE + ".tbl";
 
@@ -35,15 +35,15 @@
 
   protected static synchronized void setDescriptor(Descriptor descriptor)
   { 
-    DatabaseSPXLangParseControllerGenerated.descriptor = descriptor;
+    DatabaseTemplateLangParseControllerGenerated.descriptor = descriptor;
   }
 
   protected static void createDescriptor()
   { 
     try
     { 
-      InputStream descriptorStream = DatabaseSPXLangParseControllerGenerated.class.getResourceAsStream(DESCRIPTOR);
-      InputStream table = DatabaseSPXLangParseControllerGenerated.class.getResourceAsStream(TABLE);
+      InputStream descriptorStream = DatabaseTemplateLangParseControllerGenerated.class.getResourceAsStream(DESCRIPTOR);
+      InputStream table = DatabaseTemplateLangParseControllerGenerated.class.getResourceAsStream(TABLE);
       boolean filesystem = false;
       if(descriptorStream == null && new File("./" + DESCRIPTOR).exists())
       { 
@@ -60,7 +60,7 @@
       if(table == null)
         throw new BadDescriptorException("Could not load parse table from " + TABLE + " (not found in plugin: " + getPluginLocation() + ")");
       descriptor = DescriptorFactory.load(descriptorStream, table, filesystem ? Path.fromPortableString("./") : null);
-      descriptor.setAttachmentProvider(DatabaseSPXLangParseControllerGenerated.class);
+      descriptor.setAttachmentProvider(DatabaseTemplateLangParseControllerGenerated.class);
     }
     catch(BadDescriptorException exc)
     { 
@@ -78,7 +78,7 @@
 
   private static String getPluginLocation()
   { 
-    return DatabaseSPXLangParseController.class.getProtectionDomain().getCodeSource().getLocation().getFile();
+    return DatabaseTemplateLangParseController.class.getProtectionDomain().getCodeSource().getLocation().getFile();
   }
 
   @Override public IParseController getWrapped()

Copied and modified: spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseTemplateLang/DatabaseTemplateLangValidator.java (from r22995, spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseSPXLang/DatabaseSPXLangValidator.java)
==============================================================================
--- spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseSPXLang/DatabaseSPXLangValidator.java	Sat Jun  4 16:36:18 2011	(r22995, copy source)
+++ spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseTemplateLang/DatabaseTemplateLangValidator.java	Sat Jun  4 16:49:49 2011	(r22996)
@@ -1,12 +1,12 @@
-package DatabaseSPXLang;
+package DatabaseTemplateLang;
 
 import org.strategoxt.imp.runtime.dynamicloading.Descriptor;
 import org.strategoxt.imp.runtime.services.MetaFileLanguageValidator;
 
-public class DatabaseSPXLangValidator extends MetaFileLanguageValidator 
+public class DatabaseTemplateLangValidator extends MetaFileLanguageValidator 
 { 
   @Override public Descriptor getDescriptor()
   { 
-    return DatabaseSPXLangParseController.getDescriptor();
+    return DatabaseTemplateLangParseController.getDescriptor();
   }
 }
\ No newline at end of file

Modified: spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseTemplateLang/strategies/InteropRegisterer.java
==============================================================================
--- spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseSPXLang/strategies/InteropRegisterer.java	Sat Jun  4 16:36:18 2011	(r22995)
+++ spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseTemplateLang/strategies/InteropRegisterer.java	Sat Jun  4 16:49:49 2011	(r22996)
@@ -1,4 +1,4 @@
-package DatabaseSPXLang.strategies;
+package DatabaseTemplateLang.strategies;
 
 import org.strategoxt.lang.JavaInteropRegisterer;
 import org.strategoxt.lang.Strategy;

Modified: spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseTemplateLang/strategies/Main.java
==============================================================================
--- spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseSPXLang/strategies/Main.java	Sat Jun  4 16:36:18 2011	(r22995)
+++ spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseTemplateLang/strategies/Main.java	Sat Jun  4 16:49:49 2011	(r22996)
@@ -1,4 +1,4 @@
-package DatabaseSPXLang.strategies;
+package DatabaseTemplateLang.strategies;
 
 import org.strategoxt.lang.Context;
 

Modified: spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseTemplateLang/strategies/java_strategy_0_0.java
==============================================================================
--- spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseSPXLang/strategies/java_strategy_0_0.java	Sat Jun  4 16:36:18 2011	(r22995)
+++ spoofax-contrib/DatabaseTemplateLang/editor/java/DatabaseTemplateLang/strategies/java_strategy_0_0.java	Sat Jun  4 16:49:49 2011	(r22996)
@@ -1,4 +1,4 @@
-package DatabaseSPXLang.strategies;
+package DatabaseTemplateLang.strategies;
 
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.ITermFactory;

Modified: spoofax-contrib/DatabaseTemplateLang/plugin.xml
==============================================================================
--- spoofax-contrib/DatabaseTemplateLang/plugin.xml	Sat Jun  4 16:36:18 2011	(r22995)
+++ spoofax-contrib/DatabaseTemplateLang/plugin.xml	Sat Jun  4 16:49:49 2011	(r22996)
@@ -3,10 +3,10 @@
 
 <plugin>
        <extension point="org.eclipse.imp.runtime.languageDescription">
-          <language extensions="sdb" description="DatabaseSPXLang" language="DatabaseSPXLang" derivedFrom="DynamicRoot" validator="DatabaseSPXLang.DatabaseSPXLangValidator" validatorClass="DatabaseSPXLang.DatabaseSPXLangValidator"></language>
+          <language extensions="sdb" description="DatabaseTemplateLang" language="DatabaseTemplateLang" derivedFrom="DynamicRoot" validator="DatabaseTemplateLang.DatabaseTemplateLangValidator" validatorClass="DatabaseTemplateLang.DatabaseTemplateLangValidator"></language>
        </extension>
-       <extension id="DatabaseSPXLang.parser" name="DatabaseSPXLang Parser" point="org.eclipse.imp.runtime.parser">
-          <parser class="DatabaseSPXLang.DatabaseSPXLangParseController" language="DatabaseSPXLang">
+       <extension id="DatabaseTemplateLang.parser" name="DatabaseTemplateLang Parser" point="org.eclipse.imp.runtime.parser">
+          <parser class="DatabaseTemplateLang.DatabaseTemplateLangParseController" language="DatabaseTemplateLang">
           </parser>
        </extension>    
     </plugin>
\ No newline at end of file

Modified: spoofax-contrib/DatabaseTemplateLang/src/databaselang.spx
==============================================================================
--- spoofax-contrib/DatabaseTemplateLang/src/databaselang.spx	Sat Jun  4 16:36:18 2011	(r22995)
+++ spoofax-contrib/DatabaseTemplateLang/src/databaselang.spx	Sat Jun  4 16:49:49 2011	(r22996)
@@ -1,30 +1,37 @@
-package languages.DatabaseLang      
+package languages.DatabaseLang
 module syntaxdefinition
 
   context-free start-symbols
     Start
 
-  context-free syntax
-    "SCHEMA"  ID TableDef*																			-> Start {"DatabaseSchema"}
-    "CREATE" "TABLE"  ID "(" {TableProperty ","}* ")" ";"				-> TableDef {"TableDef"}
-    ID  DBType							         														-> TableProperty{"ColumnDef"}
-    "CONSTRAINT"  ID  RefConstraint															-> TableProperty{"ConstraintDef"}
-    "PRIMARY" "KEY" "(" ID ")"	 																-> RefConstraint{"PKConstraint"}
-    "FOREIGN" "KEY"  "(" ID ")" "REFERENCES"	ID "(" ID ")"			-> RefConstraint{"FKConstraint"} 
-     
-   
-	 	
-  context-free syntax 
-		"int"							 -> DBType{"IntegerDBType",prefer}
-		"varchar" 				 -> DBType{"StringDBType",  prefer}
-		"datetime" 				 -> DBType{"DateTimeDBType",prefer}
-		"uniqueidentifier" -> DBType{"UuidDBType",    prefer}		 
+  templates
+    Start.DatabaseSchema = <<
+     	SCHEMA <ID>
+    	<TableDef*; separator="\n">
+    >> {cons("Foo")}
+
+    TableDef.TableDef = <<
+      CREATE TABLE <ID> (
+        <TableProperty*; separator=",\n">
+      );
+    >>
+
+    TableProperty.ColumnDef = <<<ID> <DBType>>>
+    TableProperty.ConstraintDef = <<CONSTRAINT <ID> <RefConstraint>>>
+
+    RefConstraint.PKConstraint = <<PRIMARY KEY (<ID>)>>
+    RefConstraint.FKConstraint = <<FOREIGN KEY (<ID>) REFERENCES <ID> (<ID>)>>
+
+  templates
+    DBType.IntegerDBType  = "int"              {prefer}
+    DBType.StringDBType   = "varchar"          {prefer}
+    DBType.DateTimeDBType = "datetime"         {prefer}
+    DBType.UuidDBType     = "uniqueidentifier" {prefer}
 
 
-module languagebuilders 
+module languagebuilders
 		imports editor.generated
-  
-		
+
 	 	rules
 	 		// Prints the abstract syntax ATerm of a selection.
   		generate-aterm:
@@ -32,76 +39,38 @@
     		with
       		filename := <guarantee-extension(|"aterm")> path;
       		result   := selected // we just return the input term
-      		
-			// Prints the abstract syntax ATerm of a selection.
-  		prettyprint-aterm:
-    		(selected, position, ast, path, project-path) -> (filename, result)
-    		with
-      		filename := <guarantee-extension(|"pp.sdb")> path;
-      		result   := <pp-dblang>selected // we just return the input term
-
-module  prettyprinter
-	
-	rules	
-		pp-dblang: 
-			DatabaseSchema(x, td*) ->
-			$[SCHEMA [x]  
-  			[<pp-dblang> td*]
-			 ]	
-			
-		pp-dblang: 
-				TableDef(x, c*) -> 
-  			$[CREATE TABLE [x](  
-  					[<pp-dblang;separate-by(|","); concat-strings> c*]
-  			);
-  			]
-  		
-		pp-dblang : 
-				ColumnDef(x, t) -> 
-				$[[x] [<pp-db-type>t]
-    		]
-		pp-dblang:
-				ConstraintDef(x , refconstraint) -> 
-    		$[CONSTRAINT [x] [<pp-dblang>refconstraint]
-    		]
-			
-		pp-dblang:
-			FKConstraint(x, tName, cName) ->  
-			$[FOREIGN KEY ([x]) REFERENCES [tName]([cName])]
-			
-		pp-dblang: 
-			PKConstraint(cName) ->   
-			$[PRIMARY KEY ([cName])]
-		
-		pp-dblang : 
-			t* -> <map(pp-dblang)>t*
-			
-
-	rules 
-		pp-db-type: StringDBType() -> "varchar"
-
-		pp-db-type: IntegerDBType() -> "int"
-
-		pp-db-type: DateTimeDBType() -> "datetime"
-  	
-		pp-db-type: UuidDBType()-> "uniqueidentifier"
 
-			
+      // Prints the abstract syntax ATerm of a selection.
+      prettyprint-aterm:
+        (selected, position, ast, path, project-path) -> (filename, result)
+        with
+          filename := <guarantee-extension(|"pp.sdb")> path;
+          result   := <pp-dblang>selected // we just return the input term
+
+    strategies
+    	pp-dblang = 
+    		prettyprint-Start
+    		%% <+ prettyprint-TableDef
+    		%% <+ prettyprint-TableProperty
+    		%% <+ prettyprint-RefConstraint
+
+      // FIXME: make analysis aware of generated prettyprinting strategies 
+      // Suppress warning about undeclared strategy
+      prettyprint-Start = fail
 
-module adapter  
+module adapter
 
 	rules
 		unique-column-name = !"_ID"
-		
+
 		primary-key-name = is-string ; ! $[PK_[<id>]]
-		
+
 		foreign-key-name  = ?(cname , tablename) ; ! $[FK_[cname]_[tablename]_[<unique-column-name>]]
-		
-		foeirgn-key-constraint-def : 
+
+		foeirgn-key-constraint-def :
 			(cname , tablename) ->  FKConstraint( cname , tablename , <unique-column-name>)
-			
-		unique-key-column-def = 
-			![ColumnDef(<unique-column-name>  , UuidDBType()), 
+
+		unique-key-column-def =
+			![ColumnDef(<unique-column-name>  , UuidDBType()),
 				ConstraintDef(<unique-column-name;primary-key-name>, PKConstraint(<unique-column-name> ))
 			 ]
-			 	
\ No newline at end of file

Modified: spoofax-contrib/DatabaseTemplateLang/src/languagedescription.spx
==============================================================================
--- spoofax-contrib/DatabaseTemplateLang/src/languagedescription.spx	Sat Jun  4 16:36:18 2011	(r22995)
+++ spoofax-contrib/DatabaseTemplateLang/src/languagedescription.spx	Sat Jun  4 16:49:49 2011	(r22996)
@@ -1,25 +1,23 @@
-package languages.DatabaseLang 
-
-module languagedescription
-	
-	language General properties
-                  
-		name          : DatabaseSPXLang 
-  	id            : DatabaseSPXLang
-  	extends       : Root
-                  
-  	description   : "Spoofax/IMP-generated editor for the DatabaseSPXLang language"
-  	url           : http://strategoxt.org
-                  
-  	extensions    : sdb
-	  start symbols : Start    
-   
-
-		builders
-	  	provider : include/DatabaseSPXLang-java.jar   
-	  	
+package languages.DatabaseLang
+
+module languagedescription
+
+	language General properties
+
+		name          : DatabaseTemplateLang
+  	id            : DatabaseTemplateLang
+  	extends       : Root
+
+  	description   : "Spoofax/IMP-generated editor for the DatabaseTemplateLang language"
+  	url           : http://strategoxt.org
+
+  	extensions    : sdb
+	  start symbols : Start
+
+
+		builders
+	  	provider : include/DatabaseTemplateLang-java.jar
+
 	    builder  : "Show abstract syntax (for selection)" = generate-aterm (openeditor) (realtime) (meta) (source)
-	    
-	 		builder  : "Show concrete syntax (for selection)" = prettyprint-aterm (openeditor) (realtime) (meta) (source)
-	 		
-	 	
\ No newline at end of file
+
+	 		builder  : "Show concrete syntax (for selection)" = prettyprint-aterm (openeditor) (realtime) (meta) (source)

Modified: spoofax-contrib/DatabaseTemplateLang/test/example.pp.sdb
==============================================================================
--- spoofax-contrib/DatabaseTemplateLang/test/example.pp.sdb	Sat Jun  4 16:36:18 2011	(r22995)
+++ spoofax-contrib/DatabaseTemplateLang/test/example.pp.sdb	Sat Jun  4 16:49:49 2011	(r22996)
@@ -1,15 +1,27 @@
-SCHEMA test  
-CREATE TABLE Person(  
-		ID uniqueidentifier
-		,name varchar
-		,firstname varchar
-		,bithdate datetime
-		,CONSTRAINT test FOREIGN KEY (a) REFERENCES Person(ID)
-		,CONSTRAINT test PRIMARY KEY (ID)
-		
-)
-CREATE TABLE Person(  
-		ID uniqueidentifier
-		
-)
-
+SCHEMA test
+CREATE TABLE Person (
+  ID uniqueidentifier,
+  CONSTRAINT te__st FOREIGN KEY (a) REFERENCES Person (ID),
+  name varchar,
+  firstname varchar,
+  bithdate datetime,
+  CONSTRAINT test PRIMARY KEY (ID)
+);
+CREATE TABLE Person (
+  ID uniqueidentifier
+);
+CREATE TABLE Person (
+  _ID uniqueidentifier,
+  CONSTRAINT PKID PRIMARY KEY (_ID),
+  name varchar,
+  firstname varchar,
+  bithdate datetime,
+  ownedCar uniqueidentifier,
+  CONSTRAINT FKownedCarCarID FOREIGN KEY (ownedCar) REFERENCES Car (_ID)
+);
+CREATE TABLE Car (
+  _ID uniqueidentifier,
+  CONSTRAINT PK__ID PRIMARY KEY (_ID),
+  make varchar,
+  mode varchar
+);
\ No newline at end of file

From tobivollebregt at gmail.com  Sun Jun  5 15:08:31 2011
From: tobivollebregt at gmail.com (Tobi Vollebregt)
Date: Sun, 05 Jun 2011 13:08:31 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r22997 - in
	spoofax-contrib/EntityTemplateLang: . .externalToolBuilders
	META-INF editor editor/java editor/java/EntityTemplateLang
	editor/java/EntityTemplateLang/strategies...
Message-ID: <20110605130831.4686D2B8005@mx2.tudelft.nl>

Author: tvo
Date: Sun Jun  5 13:08:25 2011
New Revision: 22997
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=22997&sc=1

Log:
EntityTemplateLang (reincarnation of org.strategoxt.imp.editors.template.test)

Added:
   spoofax-contrib/EntityTemplateLang/
   spoofax-contrib/EntityTemplateLang/.classpath
   spoofax-contrib/EntityTemplateLang/.externalToolBuilders/
   spoofax-contrib/EntityTemplateLang/.externalToolBuilders/EntityTemplateLang build.spx.packages.xml [Builder].launch
   spoofax-contrib/EntityTemplateLang/.externalToolBuilders/EntityTemplateLang build.spx.packages.xml.launch
   spoofax-contrib/EntityTemplateLang/.project
   spoofax-contrib/EntityTemplateLang/META-INF/
   spoofax-contrib/EntityTemplateLang/META-INF/MANIFEST.MF
   spoofax-contrib/EntityTemplateLang/build.properties
   spoofax-contrib/EntityTemplateLang/build.spx.packages.generated.xml
   spoofax-contrib/EntityTemplateLang/build.spx.packages.xml
   spoofax-contrib/EntityTemplateLang/editor/
   spoofax-contrib/EntityTemplateLang/editor/java/
   spoofax-contrib/EntityTemplateLang/editor/java/EntityTemplateLang/
   spoofax-contrib/EntityTemplateLang/editor/java/EntityTemplateLang/Activator.java
   spoofax-contrib/EntityTemplateLang/editor/java/EntityTemplateLang/EntityTemplateLangParseController.java
   spoofax-contrib/EntityTemplateLang/editor/java/EntityTemplateLang/EntityTemplateLangParseControllerGenerated.java
   spoofax-contrib/EntityTemplateLang/editor/java/EntityTemplateLang/EntityTemplateLangValidator.java
   spoofax-contrib/EntityTemplateLang/editor/java/EntityTemplateLang/strategies/
   spoofax-contrib/EntityTemplateLang/editor/java/EntityTemplateLang/strategies/InteropRegisterer.java
   spoofax-contrib/EntityTemplateLang/editor/java/EntityTemplateLang/strategies/Main.java
   spoofax-contrib/EntityTemplateLang/editor/java/EntityTemplateLang/strategies/java_strategy_0_0.java
   spoofax-contrib/EntityTemplateLang/plugin.xml
   spoofax-contrib/EntityTemplateLang/spx.config
   spoofax-contrib/EntityTemplateLang/src/
   spoofax-contrib/EntityTemplateLang/src/EntityTemplateLang.spx
   spoofax-contrib/EntityTemplateLang/src/lib/
   spoofax-contrib/EntityTemplateLang/src/lib/editor-common.generated.spx
   spoofax-contrib/EntityTemplateLang/src/services/
   spoofax-contrib/EntityTemplateLang/src/services/check.spx
   spoofax-contrib/EntityTemplateLang/src/services/editorservices-dynamic.spx
   spoofax-contrib/EntityTemplateLang/src/services/editorservices-static.spx
   spoofax-contrib/EntityTemplateLang/src/services/generate.spx
   spoofax-contrib/EntityTemplateLang/src/syn/
   spoofax-contrib/EntityTemplateLang/src/syn/Common.spx
   spoofax-contrib/EntityTemplateLang/src/syn/Layout.spx
   spoofax-contrib/EntityTemplateLang/src/syn/Syntax.spx
   spoofax-contrib/EntityTemplateLang/test/
   spoofax-contrib/EntityTemplateLang/test/example.ent-template
   spoofax-contrib/EntityTemplateLang/test/test-example.spt

Added: spoofax-contrib/EntityTemplateLang/.classpath
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/EntityTemplateLang/.classpath	Sun Jun  5 13:08:25 2011	(r22997)
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+
+<classpath>
+	<classpathentry kind="src" excluding="trans/**" path="editor/java"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/J2SE-1.5"/>
+	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
\ No newline at end of file

Added: spoofax-contrib/EntityTemplateLang/.externalToolBuilders/EntityTemplateLang build.spx.packages.xml [Builder].launch
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/EntityTemplateLang/.externalToolBuilders/EntityTemplateLang build.spx.packages.xml [Builder].launch	Sun Jun  5 13:08:25 2011	(r22997)
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<launchConfiguration type="org.eclipse.ant.AntBuilderLaunchConfigurationType">
+<booleanAttribute key="org.eclipse.ant.ui.DEFAULT_VM_INSTALL" value="false"/>
+<listAttribute key="org.eclipse.debug.core.MAPPED_RESOURCE_PATHS">
+<listEntry value="/EntityTemplateLang/build.spx.packages.xml"/>
+</listAttribute>
+<listAttribute key="org.eclipse.debug.core.MAPPED_RESOURCE_TYPES">
+<listEntry value="1"/>
+</listAttribute>
+<booleanAttribute key="org.eclipse.debug.ui.ATTR_LAUNCH_IN_BACKGROUND" value="false"/>
+<stringAttribute key="org.eclipse.jdt.launching.CLASSPATH_PROVIDER" value="org.eclipse.ant.ui.AntClasspathProvider"/>
+<stringAttribute key="org.eclipse.jdt.launching.PROJECT_ATTR" value="EntityTemplateLang"/>
+<stringAttribute key="org.eclipse.jdt.launching.SOURCE_PATH_PROVIDER" value="org.eclipse.ant.ui.AntClasspathProvider"/>
+<stringAttribute key="org.eclipse.ui.externaltools.ATTR_LAUNCH_CONFIGURATION_BUILD_SCOPE" value="${none}"/>
+<stringAttribute key="org.eclipse.ui.externaltools.ATTR_LOCATION" value="${workspace_loc:/EntityTemplateLang/build.spx.packages.xml}"/>
+<booleanAttribute key="org.eclipse.ui.externaltools.ATTR_TRIGGERS_CONFIGURED" value="true"/>
+<stringAttribute key="org.eclipse.ui.externaltools.ATTR_WORKING_DIRECTORY" value="${workspace_loc:/EntityTemplateLang}"/>
+<stringAttribute key="process_factory_id" value="org.eclipse.ant.ui.remoteAntProcessFactory"/>
+</launchConfiguration>

Added: spoofax-contrib/EntityTemplateLang/.externalToolBuilders/EntityTemplateLang build.spx.packages.xml.launch
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/EntityTemplateLang/.externalToolBuilders/EntityTemplateLang build.spx.packages.xml.launch	Sun Jun  5 13:08:25 2011	(r22997)
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<launchConfiguration type="org.eclipse.ant.AntLaunchConfigurationType">
+<booleanAttribute key="org.eclipse.ant.ui.DEFAULT_VM_INSTALL" value="false"/>
+<listAttribute key="org.eclipse.debug.core.MAPPED_RESOURCE_PATHS">
+<listEntry value="/EntityTemplateLang/build.spx.packages.xml"/>
+</listAttribute>
+<listAttribute key="org.eclipse.debug.core.MAPPED_RESOURCE_TYPES">
+<listEntry value="1"/>
+</listAttribute>
+<booleanAttribute key="org.eclipse.debug.ui.ATTR_LAUNCH_IN_BACKGROUND" value="false"/>
+<stringAttribute key="org.eclipse.jdt.launching.CLASSPATH_PROVIDER" value="org.eclipse.ant.ui.AntClasspathProvider"/>
+<stringAttribute key="org.eclipse.jdt.launching.PROJECT_ATTR" value="EntityTemplateLang"/>
+<stringAttribute key="org.eclipse.jdt.launching.SOURCE_PATH_PROVIDER" value="org.eclipse.ant.ui.AntClasspathProvider"/>
+<stringAttribute key="org.eclipse.ui.externaltools.ATTR_LAUNCH_CONFIGURATION_BUILD_SCOPE" value="${none}"/>
+<stringAttribute key="org.eclipse.ui.externaltools.ATTR_LOCATION" value="${workspace_loc:/EntityTemplateLang/build.spx.packages.xml}"/>
+<stringAttribute key="org.eclipse.ui.externaltools.ATTR_WORKING_DIRECTORY" value="${workspace_loc:/EntityTemplateLang}"/>
+<stringAttribute key="process_factory_id" value="org.eclipse.ant.ui.remoteAntProcessFactory"/>
+</launchConfiguration>

Added: spoofax-contrib/EntityTemplateLang/.project
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/EntityTemplateLang/.project	Sun Jun  5 13:08:25 2011	(r22997)
@@ -0,0 +1,38 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>EntityTemplateLang</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.ui.externaltools.ExternalToolBuilder</name>
+			<triggers>full,incremental,</triggers>
+			<arguments>
+				<dictionary>
+					<key>LaunchConfigHandle</key>
+					<value>&lt;project&gt;/.externalToolBuilders/EntityTemplateLang build.spx.packages.xml [Builder].launch</value>
+				</dictionary>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.pde.ManifestBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.pde.SchemaBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.pde.PluginNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>

Added: spoofax-contrib/EntityTemplateLang/META-INF/MANIFEST.MF
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/EntityTemplateLang/META-INF/MANIFEST.MF	Sun Jun  5 13:08:25 2011	(r22997)
@@ -0,0 +1,21 @@
+Manifest-Version: 1.0
+Bundle-ManifestVersion: 2
+Bundle-Name: EntityTemplateLang Plug-in
+Bundle-SymbolicName: EntityTemplateLang; singleton:=true
+Bundle-Version: 1.0.0
+Bundle-Activator: EntityTemplateLang.Activator
+Import-Package: org.osgi.framework;version="1.3.0"
+Require-Bundle: org.eclipse.core.runtime,
+  org.eclipse.core.resources,
+  org.eclipse.imp.runtime,
+  org.eclipse.ui,
+  lpg.runtime,
+  org.eclipse.jface.text,
+  org.eclipse.ui.editors,
+  org.eclipse.ui.workbench.texteditor,
+  org.strategoxt.imp.runtime,
+  org.spoofax.jsglr,
+  org.strategoxt.strj
+Bundle-RequiredExecutionEnvironment: J2SE-1.5
+Bundle-ActivationPolicy: lazy
+Export-Package: EntityTemplateLang

Added: spoofax-contrib/EntityTemplateLang/build.properties
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/EntityTemplateLang/build.properties	Sun Jun  5 13:08:25 2011	(r22997)
@@ -0,0 +1,8 @@
+source.. = editor/java/
+output.. = bin/
+bin.includes = META-INF/,\
+               plugin.xml,\
+               include/,\
+               bin/,\
+               lib/,\
+               .

Added: spoofax-contrib/EntityTemplateLang/build.spx.packages.generated.xml
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/EntityTemplateLang/build.spx.packages.generated.xml	Sun Jun  5 13:08:25 2011	(r22997)
@@ -0,0 +1,446 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+
+<project name="build.spx.generated">
+	<target name="spx.default" depends="spx.default.ctree"/>
+  <target name="spx.default.ctree" depends="check-classpath,init,sdf2table,meta-sdf2table, ppgen,pppack,stratego.aster,stratego.ctree,java.jar,sdf2imp, refresh"/>
+	<target name="spx.default.jar"   depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.jar,java.jar,sdf2imp,refresh"/>
+
+  <!-- Initialization -->
+  <available file="${build}/${lang.id.specific.directoy}/strategies/Main.class" property="java.jar.enabled"/>
+  <condition property="java.jar.import" value="-la org.strategoxt.imp.editors.spoofax.strategies" else="">
+      <isset property="java.jar.enabled"/>
+  </condition>
+  <condition property="java.jar.classpath" value=":${include}/${package.main.str.module}-java.jar" else="">
+      <isset property="java.jar.enabled"/>
+  </condition>
+  <available file="${packages.root}/${package.main.str.module}.rtree" property="build.stratego.enabled"/>
+  <dirname property="externaldefdir" file="${externaldef}"/>
+  <condition property="externaldefimport" value="-I ${externaldefdir}" else="">
+      <isset property="externaldef"/>
+  </condition>
+  <condition property="externaljarimport" value=":${externaljar}" else="">
+      <isset property="externaljar"/>
+  </condition>
+  <condition property="build.compiler" value="org.eclipse.jdt.core.JDTCompilerAdapter">
+      <isset property="eclipse.running"/>
+  </condition>
+  <condition property="externaljarflags" value="${externaljarflags}" else="">
+      <isset property="externaljarflags"/>
+  </condition>
+  <condition property="metasdfmodule.available" value="1">
+      <available file="${packages.root}/${metasdfmodule}.sdf"/>
+  </condition>
+
+	<fail unless="build" message="Please use build.spx.main.xml to build this project or configure the required properties manually"/>
+  <mkdir dir="${build}"/>
+  <mkdir dir="${src-gen}"/>
+  <mkdir dir="${dist}"/>
+  <mkdir dir="${include}"/>
+  <mkdir dir="${lib}"/>
+  <mkdir dir="${syntax}"/>
+
+	<target name="init" if="eclipse.running">
+	  <!-- refresh one file/dir in the project to trigger an Ant rebuild with the next build command -->
+	  <java classname="org.strategoxt.imp.metatooling.building.AntForceRefreshScheduler" failonerror="false">
+	      <arg value="${include}"/>
+	  </java>
+	</target>
+
+		<target name="check-classpath">
+        <available classname="org.strategoxt.imp.generator.sdf2imp" property="check-classpath.available"/>
+        <antcall target="check-classpath.helper"/>
+		</target>
+
+		<target name="java.jar" if="java.jar.enabled">
+    		<jar basedir="${build}" excludes="{packages.root}/**" update="true" destfile="${include}/${package.name}-java.jar"/>
+ 		</target>
+
+		<target name="check-classpath.helper" unless="check-classpath.available">
+	        <echo level="error" message="Could not load the Spoofax plugin loading classes."/>
+	        <echo level="error" message="Make sure it is on the class path."/>
+	        <echo level="error" message=""/>
+	        <echo level="error" message="In Eclipse, make sure the Ant builder is configured properly:"/>
+	        <echo level="error" message="right-click on build.main.xml, go to Run as, Ant build..., JRE tab,"/>
+	        <echo level="error" message="and ensure Run in the same JRE as the workspace is selected"/>
+	        <echo level="error" message="alternatively, build the project using Build Project in the Project menu"/>
+	        <fail/>
+	    </target>
+
+		<!--lots of redundant steps. TODO : remove the redundant build steps-->
+		<target name="refresh" if="eclipse.running">
+    		<eclipse.convertPath fileSystemPath="${basedir}" property="projectdir"/>
+        <eclipse.convertPath fileSystemPath="${packages.root}" property="packagesroot.dir"/>
+        <eclipse.convertPath fileSystemPath="${lib}" property="libdir"/>
+				<eclipse.convertPath fileSystemPath="${include}" property="includedir"/>
+				<eclipse.convertPath fileSystemPath="${src-gen}" property="eclipse.path.src-gen"/>
+				<eclipse.convertPath fileSystemPath="${build}" property="eclipse.path.build"/>
+
+				<eclipse.refreshLocal resource="${libdir}" depth="infinite"/>
+				<eclipse.refreshLocal resource="${libdir}/editor-common.generated.str" depth="infinite"/>
+
+				<eclipse.refreshLocal resource="${package.path}" depth="infinite"/>
+				<eclipse.refreshLocal resource="${packages.root}" depth="infinite"/>
+
+				<eclipse.refreshLocal resource="${projectdir}/build.spx.autogenerated.xml" depth="infinite"/>
+				<eclipse.refreshLocal resource="${packagesroot.dir}" depth="infinite"/>
+				<eclipse.refreshLocal resource="${includedir}" depth="infinite"/>
+
+        <eclipse.refreshLocal resource="${eclipse.path.src-gen}" depth="infinite"/>
+        <eclipse.refreshLocal resource="${eclipse.path.build}" depth="infinite"/>
+    </target>
+
+		<target name="utils-files"> <!-- only useful for builds outside of Eclipse -->
+        <mkdir dir="utils"/>
+        <copy file="${eclipse.spoofaximp.jars}/make_permissive.jar" todir="utils" failonerror="false"/>
+        <copy file="${eclipse.spoofaximp.jars}/sdf2imp.jar" todir="utils" failonerror="false"/>
+        <copy file="${eclipse.spoofaximp.jars}/aster.jar" todir="utils" failonerror="false"/>
+        <copy file="${eclipse.spoofaximp.strategojar}" todir="utils" failonerror="false"/>
+  	</target>
+
+	  <!-- Pack SDF -->
+	  <target name="pack-sdf" unless="externaldef">
+        <dependset>
+            <srcfileset dir="${packages.root}">
+                <include name="**/*.sdf"/>
+            </srcfileset>
+            <srcfileset dir="${lib}">
+                <include name="**/*.def"/>
+            </srcfileset>
+            <targetfileset file="${include}/${package.name}.def"/>
+        </dependset>
+        <available file="${include}/${package.name}.def" property="pack-sdf.available"/>
+        <antcall target="pack-sdf.helper"/>
+    </target>
+
+    <target name="pack-sdf.helper" unless="pack-sdf.available">
+        <condition property="utils-include" value="-I ${utils}" else="">
+            <available file="${utils}"/>
+        </condition>
+        <java classname="run" failonerror="true">
+            <arg value="org.strategoxt.tools.main-pack-sdf"/>
+            <arg value="-i"/>
+            <arg value="${packages.root}/${package.main.sdf.module}.sdf"/>
+            <arg value="-o"/>
+            <arg value="${include}/${package.name}.def"/>
+            <arg value="-I"/>
+            <arg value="${packages.root}"/>
+            <arg value="-I"/>
+            <arg value="${package.path}"/>
+            <arg value="-I"/>
+            <arg value="${lib}"/>
+            <arg line="${utils-include}"/>
+            <arg line="${build.sdf.imports}"/>
+            <!--<arg line="${language-sdf-specific-params}"/>-->
+        </java>
+    </target>
+
+	<target name="copy-sdf" if="externaldef">
+		  <copy file="${externaldef}" tofile="${include}/${package.name}.def" preservelastmodified="true"/>
+	  </target>
+
+	<!-- SDF-To-Table -->
+	<target name="meta-sdf2table" if="metasdfmodule.available">
+		<fail unless="eclipse.spoofaximp.jars" message="Property eclipse.spoofaximp.jars must point to the directory containing StrategoMix.def"/>
+		<antcall target="sdf2table">
+			<param name="sdfmodule" value="${metasdfmodule}"/>
+			<param name="build.sdf.imports" value="-Idef &quot;${eclipse.spoofaximp.jars}/StrategoMix.def&quot; ${build.sdf.imports}"/>
+		</antcall>
+		<antcall target="meta-sdf2table.helper"/>
+    </target>
+
+	<target name="meta-sdf2table.helper" if="eclipse.running">
+	   <eclipse.convertPath fileSystemPath="${include}" property="includeresource"/>
+	   <eclipse.refreshLocal resource="${includeresource}/${metasdfmodule}.tbl" depth="infinite"/>
+    </target>
+
+	<target name="sdf2table" depends="make-permissive">
+		<apply executable="${build.strategoxt.sdf}sdf2table" dest="${include}" failonerror="true">
+			<arg value="-i"/>
+			<srcfile/>
+			<arg value="-o"/>
+			<targetfile/>
+			<arg value="-m"/>
+			<arg value="${package.name}"/>
+
+			<fileset file="${include}/${package.name}-Permissive.def"/>
+			<mapper type="glob" from="*-Permissive.def" to="*.tbl"/>
+		</apply>
+   </target>
+
+	<target name="make-permissive" depends="pack-sdf,copy-sdf">
+		<dependset>
+			<srcfileset file="${include}/${package.name}.def"/>
+			<targetfileset file="${include}/${package.name}-Permissive.def"/>
+    </dependset>
+		<available file="${include}/${package.name}-Permissive.def" property="permissive-grammar.available"/>
+    <antcall target="make-permissive.helper"/>
+  </target>
+
+	<target name="make-permissive.helper" unless="permissive-grammar.available">
+		<java classname="org.strategoxt.permissivegrammars.make_permissive" failonerror="true">
+			<arg value="-i"/>
+			<arg value="${include}/${package.name}.def"/>
+			<arg value="-o"/>
+			<arg value="${include}/${package.name}-Permissive.def"/>
+			<arg line="--optimize on"/>
+        </java>
+    </target>
+
+
+	<!-- PP Generation -->
+	<target name="ppgen" if="build.stratego.enabled" depends="pack-sdf">
+	  <dependset>
+	      <srcfileset    file="${include}/${package.name}.def"/>
+	      <targetfileset file="${syntax}/${package.name}.generated.pp"/>
+	      <targetfileset file="${include}/${package.name}.generated.pp.af"/>
+	  </dependset>
+	  <available file="${include}/${package.name}.generated.pp.af" property="ppgen.available"/>
+	  <antcall target="ppgen.helper"/>
+	  <available file="${include}/${package.name}.generated.pp.af" property="ppgen.available"/>
+	  <antcall target="ppgen.helper.fallback"/>
+	</target>
+
+  <target name="ppgen.helper" unless="ppgen.available">
+      <!-- Any failures here are ignored; they are only a problem when imported from Stratego -->
+      <java classname="run" failonerror="false">
+          <arg value="org.strategoxt.tools.main-ppgen"/>
+          <arg value="-i"/>
+          <arg value="${include}/${package.name}.def"/>
+          <arg value="-o"/>
+          <arg value="${include}/${package.name}.generated.pp.af"/>
+          <arg value="-t"/>
+      </java>
+
+      <java classname="run" failonerror="false">
+          <arg value="org.strategoxt.tools.main-pp-pp-table"/>
+          <arg value="-i"/>
+          <arg value="${include}/${package.name}.generated.pp.af"/>
+          <arg value="-o"/>
+          <arg value="${package.path}/${package.name}.generated.pp"/>
+      </java>
+  </target>
+
+  <target name="ppgen.helper.fallback" unless="ppgen.available">
+  	<echo file="${include}/${package.name}.generated.pp.af" message="PP-Table([ ])"/>
+  </target>
+
+
+	<!-- PP Packing -->
+  <target name="pppack" if="build.stratego.enabled" depends="pack-sdf">
+      <dependset>
+          <srcfileset file="${package.path}/${package.name}.pp"/>
+          <targetfileset file="${include}/${package.name}.pp.af"/>
+      </dependset>
+      <available file="${package.path}/${package.name}.pp" property="pppack.source-available"/>
+      <available file="${include}/${package.name}.pp.af" property="pppack.available"/>
+      <antcall target="pppack.helper"/>
+      <available file="${include}/${package.name}.pp.af" property="pppack.available"/>
+      <antcall target="pppack.helper.fallback"/>
+  </target>
+
+	 <target name="pppack.helper" unless="pppack.available" if="pppack.source-available">
+	 	<java classname="run" failonerror="true">
+	  	<arg value="org.strategoxt.tools.main-parse-pp-table"/>
+	    <arg value="-i"/>
+	    <arg value="${package.path}/${package.name}.pp"/>
+	    <arg value="-o"/>
+	    <arg value="${include}/${package.name}.pp.af"/>
+	  </java>
+	</target>
+
+	<target name="pppack.helper.fallback" unless="pppack.available">
+      <echo file="${include}/${package.name}.pp.af" message="PP-Table([ ])"/>
+  </target>
+
+	<target name="copy-jar" if="externaljar">
+  	<copy file="${externaljar}" todir="${include}" preservelastmodified="true"/>
+  </target>
+
+	<!-- Generates Signature file  *.STR from RTG file -->
+	<target name="rtg2sig" if="build.stratego.enabled" depends="sdf2rtg">
+		<dependset>
+	  	<srcfileset file="${include}/${package.name}.rtg"/>
+	   	<targetfileset file="${include}/${package.name}.str"/>
+	  </dependset>
+	  <available file="${include}/${package.name}.str" property="rtg2sig.available"/>
+	  <antcall target="rtg2sig.helper"/>
+	</target>
+
+	<target name="rtg2sig.helper" unless="rtg2sig.available">
+		<java classname="run" failonerror="true">
+	  	<arg value="org.strategoxt.tools.main-rtg2sig"/>
+    	<arg value="-i"/>
+	    <arg value="${include}/${package.name}.rtg"/>
+	    <arg value="-o"/>
+	    <arg value="${include}/${package.name}.str"/>
+	    <arg value="--module"/>
+	    <arg value="${sdfmodule}"/>
+	 	</java>
+	</target>
+
+
+	<!-- Generates *.RTG file from SDF *def files  -->
+	<target name="sdf2rtg" depends="pack-sdf,copy-sdf">
+		<dependset>
+	  	<srcfileset file="${include}/${package.name}.def"/>
+	    <targetfileset file="${include}/${package.name}.rtg"/>
+	  </dependset>
+	  <available file="${include}/${package.name}.rtg" property="sdf2rtg.available"/>
+	  <antcall target="sdf2rtg.helper"/>
+	</target>
+
+	<target name="sdf2rtg.helper" unless="sdf2rtg.available">
+		<java classname="run" failonerror="true">
+	  	<arg value="org.strategoxt.tools.main-sdf2rtg"/>
+	    <arg value="-i"/>
+	    <arg value="${include}/${package.name}.def"/>
+	    <arg value="-m"/>
+	    <arg value="${sdfmodule}"/>
+			<arg value="-o"/>
+	    <arg value="${include}/${package.name}.rtg"/>
+	    <arg value="--ignore-missing-cons"/>
+	    <arg value="-Xnativepath"/>
+	    <arg value="${build.strategoxt.sdf}"/>
+	 </java>
+	</target>
+
+
+  <!-- Aster to Stratego -->
+   <target name="stratego.aster">
+       <available file="${packages.root}/${package.main.str.module}.rtree" property="aster-output.available"/>
+       <pathconvert property="aster-input" setonempty="false" pathsep=" ">
+           <path><fileset dir="${basedir}" includes="*.astr"/></path>
+       </pathconvert>
+       <dependset>
+           <srcfileset dir="${basedir}">
+               <include name="**/*.astr"/>
+           </srcfileset>
+           <targetfileset file="${packages.root}/${package.main.str.module}.rtree"/>
+       </dependset>
+       <condition property="aster-output.uptodate">
+           <and>
+               <isset property="aster-output.available"/>
+               <available file="${packages.root}/${package.main.str.module}.rtree"/>
+           </and>
+       </condition>
+       <available file="${packages.root}/${package.main.str.module}.rtree" property="aster-output.uptodate"/>
+       <antcall target="stratego.aster.helper"/>
+   </target>
+
+   <target name="stratego.aster.helper" if="aster-input" unless="aster-output.uptodate">
+       <java classname="org.strategoxt.aster.Main" failonerror="true">
+           <arg value="-i"/>
+           <fileset dir="${packages.root}">
+               <include name="**/*.astr"/>
+           </fileset>
+       </java>
+   </target>
+
+   <!-- Stratego to Java compiler -->
+   <target name="stratego.jar" depends="rtg2sig,utils-files">
+   	<dependset>
+    	<srcfileset dir="${package.path}">
+      	<include name="**/*.str"/>
+        <include name="**/*.astr"/>
+        <exclude name="lib/editor-common.generated.str"/>
+			</srcfileset>
+    	<targetfileset file="${src-gen}/trans/Main.java"/>
+         </dependset>
+         <available file="${src-gen}/trans/Main.java" property="strc-java.available"/>
+         <antcall target="copy-jar"/>
+         <antcall target="stratego.jar.deletehelper"/>
+         <antcall target="stratego.jvm.helper">
+         		<param name="build.stratego.outputfile" value="${src-gen}/trans/Main.java"/>
+            <param name="build.stratego.extraargs" value="-la java-front ${java.jar.import}"/>
+         </antcall>
+         <javac classpath="utils/strategoxt.jar:${src-gen}${externaljarimport}${java.jar.classpath}" srcdir="${src-gen}" includes="trans/**" destdir="${build}" source="1.5" target="1.5" debug="on"/>
+         <!-- copy imported terms -->
+         <copy todir="${build}/trans">
+             <fileset dir="${src-gen}/trans" excludes="**/*.java"/>
+         </copy>
+         <jar basedir="${build}" includes="trans/**" destfile="${include}/${package.name}.tmp.jar"/>
+         <move file="${include}/${package.name}.tmp.jar" tofile="${include}/${package.name}.jar"/>
+         <delete><fileset dir="${build}" includes="trans/**"/></delete>
+     </target>
+
+
+		<!-- Stratego to Java interpreter -->
+    <target name="stratego.ctree" >
+    	<dependset>
+      		<srcfileset dir="${packages.root}">
+          	<include name="**/*.rtree"/>
+      			<include name="**/*.str"/>
+          </srcfileset>
+    			<srcfileset dir="${lib}">
+    	    	<include name="**/*.str"/>
+    				<exclude name="lib/editor-common.generated.str"/>
+    	    </srcfileset>
+    	    <targetfileset file="${include}/${package.name}.ctree"/>
+      </dependset>
+      <available file="${include}/${package.name}.ctree" property="strc-java.available"/>
+      <antcall target="copy-jar"/>
+      <antcall target="stratego.jvm.helper">
+      	<param name="build.stratego.outputfile" value="${include}/${package.name}.ctree"/>
+      	<param name="build.stratego.extraargs" value="-F"/>
+      </antcall>
+    </target>
+
+    <target name="stratego.jar.deletehelper" unless="strc-java.available">
+	    <delete>
+	      <fileset dir="${src-gen}" includes="trans/**"/>
+        <fileset dir="${build}" includes="trans/**"/>
+      </delete>
+	  </target>
+
+  <target name="stratego.jvm.helper" unless="strc-java.available" if="build.stratego.enabled">
+  	<delete file="${include}/${package.name}.rtree" failonerror="false"/>
+  	<java classname="org.strategoxt.strj.Main" failonerror="true">
+  		<arg value="-I"/>
+    	<arg value="${package.path}"/>
+  		<arg value="-i"/>
+      <arg value="${packages.root}/${package.main.str.module}.str"/>
+      <arg value="-o"/>
+      <arg value="${build.stratego.outputfile}"/>
+  		<arg value="-p"/>
+  	  <arg value="${package.qname}"/>  <!-- Note : added this extra parameter since, java package name does not allow dash unlike the ID is defined-->
+      <arg value="--library"/>
+      <arg value="--clean"/>
+  		<arg line="${build.stratego.args}"/>
+      <arg line="${build.stratego.extraargs}"/>
+      <arg line="${externaljarflags}"/>
+      <arg line="${externaldefimport}"/>
+      <arg line="-I &quot;${lib}&quot; -I &quot;${include}&quot; --cache-dir &quot;${basedir}/.cache&quot;"/>
+      <!--<arg line="${language-str-specific-params}"/>-->
+  </java>
+  <delete file="${include}/${package.name}.rtree" failonerror="false"/>
+  <mkdir dir="${build}/trans"/>
+</target>
+
+		<target name="clean" description="clean up">
+      <delete dir="${build}"/>
+      <delete file="${include}/${package.main.sdf.module}.def"/>
+      <delete dir="${src-gen}/trans"/>
+		</target>
+
+	  <!-- <target name="sdf2imp" depends="sdf2table,sdf2imp.eclipse,sdf2imp.standalone"/> -->
+
+	  <target name="sdf2imp" depends="sdf2table,sdf2imp.eclipse"/>
+
+		<target name="sdf2imp.eclipse" if="eclipse.running" >
+			<copy file="${packages.root}/${package.main.esv.module}.esv" tofile="${include}/${package.name}.packed.esv" preservelastmodified="true"/>
+			<copy file="${packages.root}/${package.main.esv.module}.esv" tofile="${include}/${package.name}.main.esv" preservelastmodified="true"/>
+			<antcall target = "refresh"/>
+			<java classname="org.strategoxt.imp.metatooling.building.AntSpxDescriptorBuilder" failonerror="true">
+				<arg value="${include}/${package.name}.packed.esv"/> <!-- esv main file-->
+			</java>
+		</target>
+
+  <target name="sdf2imp.standalone" unless="eclipse.running" depends="sdf2table,sdf2rtg">
+		<java classname="org.strategoxt.imp.generator.sdf2imp" failonerror="true">
+			<arg value="-i"/>
+      <arg value="${packages.root}/${package.main.esv.module}.packed.esv"/>
+      <arg value="-p"/>
+      <arg value="${include}/${package.name}.tbl"/>
+    </java>
+  </target>
+</project>

Added: spoofax-contrib/EntityTemplateLang/build.spx.packages.xml
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/EntityTemplateLang/build.spx.packages.xml	Sun Jun  5 13:08:25 2011	(r22997)
@@ -0,0 +1,60 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+
+		<project name="build.spx.packages" default="build-spx-packages">
+  <!-- autogenerated artifacts relative directory path -->
+		<property name="packages.root" location=".shadowdir"/>
+
+		<!-- prject directories -->
+  <property name="trans" location="trans"/>
+  <property name="src-gen" location="editor/java"/>
+  <property name="syntax" location="syntax"/>
+  <property name="include" location="include"/>
+  <property name="lib" location="lib"/>
+  <property name="build" location="bin"/>
+  <property name="dist" location="bin/dist"/>
+
+		<!-- Environment configuration for command-line builds -->
+  <property name="build.sdf.imports" value= "-I &quot;${basedir}&quot; "/>
+  <property name="build.stratego.args" value="
+                  --library
+                  -I &quot;${packages.root}&quot;
+                  -I &quot;${basedir}&quot;
+                  -la stratego-lib -la stratego-sglr -la stratego-gpp -la stratego-xtc -la stratego-aterm  -la strc -la stratego-sdf"/>
+
+		<condition property="build.strategoxt.sdf" value="${eclipse.spoofaximp.nativeprefix}" else="">
+      <isset property="eclipse.spoofaximp.nativeprefix"/>
+  </condition>
+  <property name="build.strategoxt.stratego" location="${user.home}/.nix-profile/bin"/>
+
+	  <import file="build.spx.packages.generated.xml"/>
+	  
+	  <target name="build.package.languages.EntityTemplateLang">
+	  	<property name="package.path" location=".shadowdir/languages/EntityTemplateLang"/>
+	  	<property name="lang.id.specific.directoy" value="EntityTemplateLang"/>
+	  	<property name="package.name" value="EntityTemplateLang"/>
+	  	<property name="package.qname" value="languages.EntityTemplateLang"/>
+	  	<property name="package.main.sdf.module" value="EntityTemplateLang"/>
+	  	<property name="package.main.str.module" value="EntityTemplateLang"/>
+	  	<property name="package.main.esv.module" value="EntityTemplateLang.main"/>
+	  	<property name="metasdfmodule" value="Stratego-EntityTemplateLang"/>
+	  	<property name="lang.sdf.specific.params" value=""/>
+	  	<property name="lang.str.specific.params" value=""/>
+	  
+	  	<antcall target = "spx.default">
+	  	  <param name = "package.name"  value = "${package.name}"/>
+	  	  <param name = "package.qname"  value = "${package.qname}"/>
+	  	  <param name = "package.path"  value = "${package.path}"/>
+	  	  <param name = "lang.id.specific.directoy"  value = "${lang.id.specific.directoy}"/>
+	  	 	<param name = "package.main.sdf.module" value = "${package.main.sdf.module}"/>
+	  		<param name = "package.main.str.module" value = "${package.main.str.module}"/>
+	  	 	<param name = "package.main.esv.module" value = "${package.main.esv.module}"/>
+	  		<param name = "metasdfmodule" value = "${metasdfmodule}"/>
+	  		<param name="lang.sdf.specific.params" value="${lang.sdf.specific.params}"/>
+	  		<param name="lang.str.specific.params" value="${lang.str.specific.params}"/>
+	  	</antcall>
+	  </target>
+	  
+
+		<!-- Main target -->
+	<target name="build-spx-packages" depends="build.package.languages.EntityTemplateLang"/>
+</project>
\ No newline at end of file

Added: spoofax-contrib/EntityTemplateLang/editor/java/EntityTemplateLang/Activator.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/EntityTemplateLang/editor/java/EntityTemplateLang/Activator.java	Sun Jun  5 13:08:25 2011	(r22997)
@@ -0,0 +1,44 @@
+package EntityTemplateLang;
+
+import org.eclipse.imp.preferences.PreferencesService;
+import org.eclipse.imp.runtime.PluginBase;
+import org.osgi.framework.BundleContext;
+
+public class Activator extends PluginBase 
+{ 
+  public static final String kPluginID = "EntityTemplateLang";
+
+  public static final String kLanguageName = "EntityTemplateLang";
+
+  protected static Activator sPlugin;
+
+  public static Activator getInstance()
+  { 
+    if(sPlugin == null)
+      return new Activator();
+    return sPlugin;
+  }
+
+  public Activator () 
+  { 
+    super();
+    sPlugin = this;
+  }
+
+  @Override public void start(BundleContext context) throws Exception
+  { 
+    super.start(context);
+  }
+
+  @Override public String getID()
+  { 
+    return kPluginID;
+  }
+
+  @Override public String getLanguageID()
+  { 
+    return kLanguageName;
+  }
+
+  protected static PreferencesService preferencesService = null;
+}
\ No newline at end of file

Added: spoofax-contrib/EntityTemplateLang/editor/java/EntityTemplateLang/EntityTemplateLangParseController.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/EntityTemplateLang/editor/java/EntityTemplateLang/EntityTemplateLangParseController.java	Sun Jun  5 13:08:25 2011	(r22997)
@@ -0,0 +1,4 @@
+package EntityTemplateLang;
+
+public class EntityTemplateLangParseController extends EntityTemplateLangParseControllerGenerated 
+{ }
\ No newline at end of file

Added: spoofax-contrib/EntityTemplateLang/editor/java/EntityTemplateLang/EntityTemplateLangParseControllerGenerated.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/EntityTemplateLang/editor/java/EntityTemplateLang/EntityTemplateLangParseControllerGenerated.java	Sun Jun  5 13:08:25 2011	(r22997)
@@ -0,0 +1,108 @@
+package EntityTemplateLang;
+
+import java.io.InputStream;
+import java.io.IOException;
+import java.io.File;
+import java.io.FileInputStream;
+import org.eclipse.core.runtime.Path;
+import org.eclipse.imp.parser.IParseController;
+import org.strategoxt.imp.runtime.Environment;
+import org.strategoxt.imp.runtime.dynamicloading.BadDescriptorException;
+import org.strategoxt.imp.runtime.dynamicloading.Descriptor;
+import org.strategoxt.imp.runtime.dynamicloading.DescriptorFactory;
+import org.strategoxt.imp.runtime.dynamicloading.DynamicParseController;
+
+public class EntityTemplateLangParseControllerGenerated extends DynamicParseController 
+{ 
+  public static final String LANGUAGE = new String("EntityTemplateLang");
+
+  private static final String TABLE = "/include/" + LANGUAGE + ".tbl";
+
+  private static final String DESCRIPTOR = "/include/" + LANGUAGE + ".packed.esv";
+
+  private static volatile Descriptor descriptor;
+
+  private static Throwable notLoadingCause;
+
+  public static synchronized Descriptor getDescriptor()
+  { 
+    if(notLoadingCause != null)
+      throw new RuntimeException(notLoadingCause);
+    if(descriptor == null)
+      createDescriptor();
+    return descriptor;
+  }
+
+  protected static synchronized void setDescriptor(Descriptor descriptor)
+  { 
+    EntityTemplateLangParseControllerGenerated.descriptor = descriptor;
+  }
+
+  protected static void createDescriptor()
+  { 
+    try
+    { 
+      InputStream descriptorStream = EntityTemplateLangParseControllerGenerated.class.getResourceAsStream(DESCRIPTOR);
+      InputStream table = EntityTemplateLangParseControllerGenerated.class.getResourceAsStream(TABLE);
+      boolean filesystem = false;
+      if(descriptorStream == null && new File("./" + DESCRIPTOR).exists())
+      { 
+        descriptorStream = new FileInputStream("./" + DESCRIPTOR);
+        filesystem = true;
+      }
+      if(table == null && new File("./" + TABLE).exists())
+      { 
+        table = new FileInputStream("./" + TABLE);
+        filesystem = true;
+      }
+      if(descriptorStream == null)
+        throw new BadDescriptorException("Could not load descriptor file from " + DESCRIPTOR + " (not found in plugin: " + getPluginLocation() + ")");
+      if(table == null)
+        throw new BadDescriptorException("Could not load parse table from " + TABLE + " (not found in plugin: " + getPluginLocation() + ")");
+      descriptor = DescriptorFactory.load(descriptorStream, table, filesystem ? Path.fromPortableString("./") : null);
+      descriptor.setAttachmentProvider(EntityTemplateLangParseControllerGenerated.class);
+    }
+    catch(BadDescriptorException exc)
+    { 
+      notLoadingCause = exc;
+      Environment.logException("Bad descriptor for " + LANGUAGE + " plugin", exc);
+      throw new RuntimeException("Bad descriptor for " + LANGUAGE + " plugin", exc);
+    }
+    catch(IOException exc)
+    { 
+      notLoadingCause = exc;
+      Environment.logException("I/O problem loading descriptor for " + LANGUAGE + " plugin", exc);
+      throw new RuntimeException("I/O problem loading descriptor for " + LANGUAGE + " plugin", exc);
+    }
+  }
+
+  private static String getPluginLocation()
+  { 
+    return EntityTemplateLangParseController.class.getProtectionDomain().getCodeSource().getLocation().getFile();
+  }
+
+  @Override public IParseController getWrapped()
+  { 
+    if(!isInitialized())
+    { 
+      if(notLoadingCause != null)
+        throw new RuntimeException(notLoadingCause);
+      try
+      { 
+        initialize(this, getDescriptor().getLanguage());
+      }
+      catch(BadDescriptorException exc)
+      { 
+        notLoadingCause = exc;
+        throw new RuntimeException(exc);
+      }
+    }
+    return super.getWrapped();
+  }
+
+  @Override protected void setNotLoadingCause(Throwable value)
+  { 
+    notLoadingCause = value;
+    super.setNotLoadingCause(value);
+  }
+}
\ No newline at end of file

Added: spoofax-contrib/EntityTemplateLang/editor/java/EntityTemplateLang/EntityTemplateLangValidator.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/EntityTemplateLang/editor/java/EntityTemplateLang/EntityTemplateLangValidator.java	Sun Jun  5 13:08:25 2011	(r22997)
@@ -0,0 +1,12 @@
+package EntityTemplateLang;
+
+import org.strategoxt.imp.runtime.dynamicloading.Descriptor;
+import org.strategoxt.imp.runtime.services.MetaFileLanguageValidator;
+
+public class EntityTemplateLangValidator extends MetaFileLanguageValidator 
+{ 
+  @Override public Descriptor getDescriptor()
+  { 
+    return EntityTemplateLangParseController.getDescriptor();
+  }
+}
\ No newline at end of file

Added: spoofax-contrib/EntityTemplateLang/editor/java/EntityTemplateLang/strategies/InteropRegisterer.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/EntityTemplateLang/editor/java/EntityTemplateLang/strategies/InteropRegisterer.java	Sun Jun  5 13:08:25 2011	(r22997)
@@ -0,0 +1,14 @@
+package EntityTemplateLang.strategies;
+
+import org.strategoxt.lang.JavaInteropRegisterer;
+import org.strategoxt.lang.Strategy;
+
+/**
+ * Helper class for {@link java_strategy_0_0}.
+ */
+public class InteropRegisterer extends JavaInteropRegisterer {
+
+  public InteropRegisterer() {
+    super(new Strategy[] { java_strategy_0_0.instance });
+  }
+}

Added: spoofax-contrib/EntityTemplateLang/editor/java/EntityTemplateLang/strategies/Main.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/EntityTemplateLang/editor/java/EntityTemplateLang/strategies/Main.java	Sun Jun  5 13:08:25 2011	(r22997)
@@ -0,0 +1,11 @@
+package EntityTemplateLang.strategies;
+
+import org.strategoxt.lang.Context;
+
+public class Main {
+  
+  public static void init(Context context) {
+    // Called when the editor is being initialized
+  }
+
+}

Added: spoofax-contrib/EntityTemplateLang/editor/java/EntityTemplateLang/strategies/java_strategy_0_0.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/EntityTemplateLang/editor/java/EntityTemplateLang/strategies/java_strategy_0_0.java	Sun Jun  5 13:08:25 2011	(r22997)
@@ -0,0 +1,32 @@
+package EntityTemplateLang.strategies;
+
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.ITermFactory;
+import org.strategoxt.lang.Context;
+import org.strategoxt.lang.Strategy;
+
+/**
+ * Example Java strategy implementation.
+ *
+ * This strategy can be used by editor services and can be called
+ * in Stratego modules by declaring it as an external strategy
+ * as follows:
+ *
+ * <code>
+ *  external java-strategy(|)
+ * </code>
+ *
+ * @see InteropRegisterer  This class registers java_strategy_0_0 for use.
+ */
+public class java_strategy_0_0 extends Strategy {
+  
+  public static java_strategy_0_0 instance = new java_strategy_0_0();
+
+  @Override
+  public IStrategoTerm invoke(Context context, IStrategoTerm current) {
+    context.getIOAgent().printError("Input for java-strategy: " + current);
+    ITermFactory factory = context.getFactory();
+    return factory.makeString("Regards from java-strategy");
+  }
+
+}

Added: spoofax-contrib/EntityTemplateLang/plugin.xml
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/EntityTemplateLang/plugin.xml	Sun Jun  5 13:08:25 2011	(r22997)
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+<?eclipse version="3.0"?>
+
+<plugin>
+       <extension point="org.eclipse.imp.runtime.languageDescription">
+          <language extensions="ent-template" description="EntityTemplateLang" language="EntityTemplateLang" derivedFrom="DynamicRoot" validator="EntityTemplateLang.EntityTemplateLangValidator" validatorClass="EntityTemplateLang.EntityTemplateLangValidator"></language>
+       </extension>
+       <extension id="EntityTemplateLang.parser" name="EntityTemplateLang Parser" point="org.eclipse.imp.runtime.parser">
+          <parser class="EntityTemplateLang.EntityTemplateLangParseController" language="EntityTemplateLang">
+          </parser>
+       </extension>    
+    </plugin>
\ No newline at end of file

Added: spoofax-contrib/EntityTemplateLang/spx.config
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/EntityTemplateLang/spx.config	Sun Jun  5 13:08:25 2011	(r22997)
@@ -0,0 +1,7 @@
+Configuration
+	Includes
+		AllDirectories src
+
+
+	CodeGeneration
+		OutputDirectory		.shadowdir

Added: spoofax-contrib/EntityTemplateLang/src/EntityTemplateLang.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/EntityTemplateLang/src/EntityTemplateLang.spx	Sun Jun  5 13:08:25 2011	(r22997)
@@ -0,0 +1,21 @@
+package languages.EntityTemplateLang
+
+module EntityTemplateLang
+
+language General properties
+
+  name          : EntityTemplateLang
+  id            : EntityTemplateLang
+  extends       : Root
+
+  description   : "Spoofax/IMP-generated editor for the EntityTemplateLang language"
+  url           : http://strategoxt.org
+
+  extensions    : ent-template
+  table         : include/EntityTemplateLang.tbl
+  start symbols : Start
+
+builders
+
+  provider : include/entitytemplatelang.ctree
+  provider : include/entitytemplatelang-java.jar

Added: spoofax-contrib/EntityTemplateLang/src/lib/editor-common.generated.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/EntityTemplateLang/src/lib/editor-common.generated.spx	Sun Jun  5 13:08:25 2011	(r22997)
@@ -0,0 +1,259 @@
+package editor.generated  
+
+module common 
+
+imports
+  libstratego-lib
+  libstratego-sglr
+  libstratego-gpp 
+  
+
+
+strategies
+
+  parse-file = parse-test-file
+  parse-test-file =
+    parse-file(
+      strsglr-perror, strsglr-report-parse-error
+    | <import-term(include/Test.tbl)>
+    )
+
+  parse-string = parse-test-string 
+  parse-test-string = 
+    parse-string( 
+      strsglr-report-parse-error
+    | <import-term(include/Test.tbl)>
+    )
+  
+  parse-stream = parse-test-stream
+  parse-test-stream =
+    parse-stream(
+      strsglr-report-parse-error
+    | <import-term(include/Test.tbl)>
+    )
+
+  pp-test-string =
+    ast2abox(|[<import-term(include/Test.generated.pp.af)>,
+               <import-term(include/Test.pp.af)>]); 
+    box2text-string(|100)
+
+strategies
+  
+  /**
+   * Processes an import during semantic analysis.
+   * Ensures proper caching of files and prevents
+   * processing duplicate imports more than once.
+   *
+   * @param resolve-path  Resolves the filesystem path of this import
+   * @param parse-file    Parses a file (optionally removing definition bodies
+   *                      so only signatures are stored in the cache)
+   * @param record-declarations
+   *                      Performs semantic analysis on a tree
+   */
+  open-import(resolve-path, parse-file, record-declarations):
+    import -> import
+    where
+      if not(!import => COMPLETION(_)) then
+        path       := <resolve-path> import;
+        cache-path := <import-cache-path> path;
+        if not(<IsImported> path) then
+          rules(
+            IsImported: path
+          );
+          ( <is-newer> (cache-path, path);
+            file := <ReadFromFile> cache-path
+          <+
+            file := <parse-file> path;
+            if <file-exists> path then
+              // Only cache if on filesystem (e.g., ignore libstratego-lib)
+              <WriteToBinaryFile> (cache-path, file)
+            end        
+          ); 
+          {| CurrentFile:
+            rules(CurrentFile := path)
+          	;<record-declarations> file    
+          |}
+        end
+      end  
+
+  open-wildcard-import(resolve-path, parse-file, record-declarations, is-source-file):
+    import -> import
+    where
+      if not(!import => COMPLETION(_)) then
+        path := <resolve-path> import;
+        readdir;
+        list-loop(
+          if is-source-file then
+            <open-import(id, parse-file, record-declarations)>
+              $[[path]/[<id>]]
+          <+
+            try(?one-failed)
+          end
+        );
+        not(!one-failed)
+      end
+  
+  import-cache-path:
+    full-path -> cache-path
+    with
+      project-path := <project-path>;
+      cache-dir    := <file-exists <+ mkdir> $[[project-path]/.cache];
+      full-path'   := <string-replace(|"/", "+"); string-replace(|"\\", "+"); string-replace(|":", "+")> full-path;
+      cache-path   := $[[cache-dir]/[full-path'].sig]
+
+  project-path = prim("SSL_EXT_projectpath")
+  
+  plugin-path = prim("SSL_EXT_pluginpath")
+  
+  candidate-sorts = prim("SSL_EXT_candidatesorts")
+
+  is-newer:
+    (file1, file2) -> <id>
+    where
+      <gt> (<file-exists; modification-time> file1, <file-exists; modification-time> file2) 
+
+strategies
+  
+  editor-init =
+    // Ensure all dynamic rules are properly scoped
+    try(dr-scope-all-end);
+    dr-scope-all-start
+  
+  refresh-workspace-file:
+    path -> <prim("SSL_EXT_refreshresource", path)>
+  
+  string-starts-with-capital =
+    explode-string; Hd; is-upper 
+
+strategies
+  
+  origin-term      = prim("SSL_EXT_origin_term", <id>)
+  origin-text      = prim("SSL_EXT_origin_text", <id>)
+  origin-location  = prim("SSL_EXT_origin_location", <id>)
+  origin-line      = origin-location => (<id>, _, _, _)
+  origin-column    = origin-location => (_, <id>, _, _)
+  origin-strip     = prim("SSL_EXT_origin_strip", <id>)
+  origin-equal(|t) = prim("SSL_EXT_origin_equal", <id>, t)
+  
+  origin-surrounding-comments =
+    prim("SSL_EXT_origin_surrounding_comments", "Test", <id>)
+    
+  origin-documentation-comment =
+    origin-surrounding-comments;
+    filter(string-as-chars(documentation-comment-chars));
+    concat-strings
+  
+  documentation-comment-chars:
+    ['*' | c*] -> <ltrim(' ' + '\t' + '\n' + '\r')> c*
+  
+  origin-track-forced(s) =
+    ![<id>]; all(s); ?[<id>]
+
+strategies
+
+  desugar-position(desugar|ast): 
+    position -> position'
+    where
+      ast'  := <at-position(!<id>{MARKER()}|position)> ast;
+      ast'' := <topdown(repeat(preserve-annos({?x; desugar; not(?x)})))> ast';
+      position' := <position-of-term({?_{a*}; <one(?MARKER())> a*})> ast''
+   
+  at-position(s|position):
+    c#(t*) -> t'
+    where
+      !position => [i | position']
+    where
+      t' := c#(<at-index(at-position(s|position'))> (i, t*))
+
+  at-position(s|position):
+    t -> t'
+    where
+      !position => [];
+      t' := <s> t
+
+  position-of-term(is-term):
+    t -> []
+    where
+      is-term
+  
+  position-of-term(is-term):
+    _#(t*) -> <position-of-term(is-term|0)> t*
+  
+  position-of-term(is-term|start-index):
+    [t | t*] -> position  
+    where
+      if i* := <position-of-term(is-term)> t then
+        position := [start-index | i*]
+      else
+        position := <position-of-term(is-term | <inc> start-index)> t*
+      end
+
+  term-at-position(|position):
+    t -> t'
+    where 
+      at-position(?t'|position) 
+
+  parent-at-position(|position):
+    t -> t'
+    where
+      !position => [i, _];
+      t' := <subterm-at(|i)> t
+  
+  parent-at-position(|position):
+    t -> <parent-at-position(|position')> t'
+    where
+      !position => [i | position' @ [_, _ | _]];
+      t' := <subterm-at(|i)> t
+
+  subterm-at(|index):
+    _#(t*) -> <index(|<inc> index)> t*
+  
+
+strategies
+  
+  // Set markers for a given file. Use when checking files from a queued strategy.
+  // Current term: (ast-desugared, errors, warnings, notes) tuple
+  // ast: the root node of the file to set markers on 
+  set-markers(|ast) = prim("SSL_EXT_set_markers", ast)
+
+  // Indicate that one or more files need analysis. 
+  // Current term: ss a list of absolute file paths, or a single absolute file path to analyze
+  queue-analysis = 
+       (is-list; list-loop(queue-analysis))
+    <+ prim("SSL_EXT_queue_analysis") 
+
+  // Set the total number of work units to complete. Can be called multiple times. 
+  // Current term: number of work units (int).
+  set-total-work-units = prim("SSL_EXT_set_total_work_units")
+  
+  // Complete one work unit and update progress monitors.
+  // Current term: ignored
+  complete-work-unit = prim("SSL_EXT_complete_work_unit")
+  
+  // Queue a strategy for background processing with a progress indicator.
+  // Current term: the term to pass to the background strategy
+  // s: the strategy, as string
+  // description: name of the task (will be shown in progress view)
+  queue-strategy(|s,description) = prim("SSL_EXT_queue_strategy", s, description)
+  
+  // Return the result of this strategy to indicate a non-completed (backgrounded) analysis.
+  // Editor services (hover, resolve) will be delayed until a complete analysis is performed. 
+  set-analysis-backgrounded = !"BACKGROUNDED"
+
+signature constructors
+
+  COMPLETION : String -> Term
+  NOCONTEXT  : Term   -> Term
+  MARKER     : Term
+
+  // Below are copies of the signatures of the terms used in example
+  // trans/test.str file. These definitions should also be automatically 
+  // generated in the imported include/Test.str module. However,
+  // to ensure that the example transformation doesn't break when the
+  // syntax is changed, we also hard-coded them here.
+          
+  Module   : ID * List(Entity)   -> Module
+  Entity   : ID * List(Property) -> Entity
+  Property : ID * Type           -> Property
+  Type     : ID                  -> Type   
+   

Added: spoofax-contrib/EntityTemplateLang/src/services/check.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/EntityTemplateLang/src/services/check.spx	Sun Jun  5 13:08:25 2011	(r22997)
@@ -0,0 +1,52 @@
+package languages.EntityTemplateLang
+
+module check
+
+imports
+  libstratego-lib
+  editor.generated
+
+rules
+
+  // Analysis: does a topdown traversal of the tree,
+  // and tries to apply the record-entity rule.
+  analyze:
+    t -> t
+    with
+      <topdown(try(record-entity))> t
+
+  // Records the definition of an entity in a dynamic rule GetEntity.
+  record-entity:
+    Entity(x, body) -> Entity(x, body)
+    with
+      // For a name 'x', GetEntity will return the original 'x' tree node
+      rules(
+        GetEntity :+ x -> x
+      )
+rules
+
+  // Reports an error if a property type is undefined.
+  // This error is reported on the type name 'type'.
+  constraint-error:
+    Property(x, Type(type)) -> (type, $[Type [type] is not defined])
+    where
+      not(!type => "String"); // String and Int are built-in types
+      not(!type => "Int");
+      not(<GetEntity> type) // no entity for this type
+
+  // Reports an error if an entity is defined more than once.
+  // This constraint is implemented by testing if the "bag" of
+  // all entities x is not a singleton list.
+  constraint-error:
+    Entity(x, _) -> (x, $[Duplicate entity name])
+    where
+      not(<bagof-GetEntity> x => [_])
+
+  constraint-warning:
+    Entity(x, _) -> (x, $[Entity names must start with a capital])
+    where
+      not(<string-starts-with-capital> x)
+
+  constraint-note:
+    Module(x @ "example", _) -> (x, $[This is just an example program in the "entities" language
+                                      (this note is defined in trans/check.str) ])

Added: spoofax-contrib/EntityTemplateLang/src/services/editorservices-dynamic.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/EntityTemplateLang/src/services/editorservices-dynamic.spx	Sun Jun  5 13:08:25 2011	(r22997)
@@ -0,0 +1,91 @@
+package languages.EntityTemplateLang
+
+module editorservices-dynamic
+
+completions
+  // Semantic (identifier) completion:
+
+  completion trigger  : ":"
+  completion proposer : editor-complete
+
+builders
+
+  observer : editor-analyze
+
+  builder  : "Generate Java code (for selection)"   = generate-java (openeditor) (realtime)
+  builder  : "Show abstract syntax (for selection)" = generate-aterm (openeditor) (realtime) (meta) (source)
+
+references
+
+  reference _ : editor-resolve
+  hover _     : editor-hover
+
+imports
+  libstratego-lib
+  libstratego-gpp
+  libstratego-aterm
+  editor.generated
+
+rules // Main editor interface
+
+  // Analyzes the current program, returning a tuple with errors, warnings, and notes;
+  // each a list of (term, message) tuples or simply (message) terms.
+  editor-analyze:
+    (ast, path, project-path) -> (ast, errors, warnings, notes)
+    with
+      editor-init;
+      analyze;
+      errors   := <collect-all(constraint-error, conc)> ast;
+      warnings := <collect-all(constraint-warning, conc)> ast;
+      notes    := <collect-all(constraint-note, conc)> ast
+
+  // Transforms a selection to Java
+  generate-java:
+    (selected, position, ast, path, project-path) -> (filename, result)
+    with
+      filename := <guarantee-extension(|"java")> path;
+      result   := <to-java> selected
+
+  // Prints the abstract syntax ATerm of a selection.
+  generate-aterm:
+    (selected, position, ast, path, project-path) -> (filename, result)
+    with
+      filename := <guarantee-extension(|"aterm")> path;
+      result   := selected // we just return the input term
+
+  generate-pretty:
+    (selected, position, ast, path, project-path) -> (filename, result)
+    with
+      filename := <guarantee-extension(|"pp.ent-template")> path;
+      result   := <prettyprint> selected
+
+  prettyprint = prettyprint-Start <+ prettyprint-Definition <+ prettyprint-Property
+
+  // FIXME
+  prettyprint-Start = fail
+  prettyprint-Definition = fail
+  prettyprint-Property = fail
+
+  // Resolves a reference when the user control-clicks or presses F3 in the editor.
+  // Only succeeds for nodes of the form Type(_) for which GetEntity is defined.
+  editor-resolve:
+    (node, position, ast, path, project-path) -> target
+    where
+      <debug(!"Resolve: ")> node;
+      Type(type) := node;
+      target     := <GetEntity> type
+
+  // Returns "hover help" information for a particular node in the editor.
+  // For references, this rule is invoked using the resolved term.
+  editor-hover:
+    (target, position, ast, path, project-path) -> $[Hover help: [<write-to-string> target]]
+
+  // Completes an identifier when the user presses control-space
+  // (the completion identifier in the AST provides additional context information)
+  editor-complete:
+    (node, position, ast, path, project-path) ->
+    ["String", "Int" | proposals]
+    where
+      if !node => Type(COMPLETION(prefix)) then
+        proposals := <all-keys-GetEntity>
+      end

Added: spoofax-contrib/EntityTemplateLang/src/services/editorservices-static.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/EntityTemplateLang/src/services/editorservices-static.spx	Sun Jun  5 13:08:25 2011	(r22997)
@@ -0,0 +1,66 @@
+package languages.EntityTemplateLang
+
+module editorservices-static
+
+colorer Default, token-based highlighting
+
+  keyword    : 127 0 85 bold
+  identifier : default
+  string     : blue
+  number     : darkgreen
+  var        : 255 0 100 italic
+  operator   : 0 0 128
+  layout     : 63 127 95 italic
+
+colorer System colors
+
+  darkred   = 128 0 0
+  red       = 255 0 0
+  darkgreen = 0 128 0
+  green     = 0 255 0
+  darkblue  = 0 0 128
+  blue      = 0 0 255
+  cyan      = 0 255 255
+  magenta   = 255 0 255
+  yellow    = 255 255 0
+  white     = 255 255 255
+  black     = 0 0 0
+  gray      = 128 128 128
+  grey      = gray
+  orange    = 255 165 0
+  pink      = 255 105 180
+  brown     = 139 69 19
+  default   = _
+
+
+folding Default folding definitions
+
+  Start.Module
+  Definition.Entity
+
+
+outliner Default outliner
+
+  Start.Module
+  Definition.Entity
+
+
+language Syntax properties (static defaults)
+
+  // Comment constructs:
+  line comment                           : "//"
+  block comment                          : "/*" * "*/"
+
+  // Fences (used for matching,
+  // inserting, indenting brackets):
+  fences                                 : [ ]
+                                           ( )
+                                           { }
+
+  // Automatic indent hints
+  // (indent after these tokens):
+  indent after                           : "="
+                                           ":"
+
+  // Regular expression for identifiers:
+  identifier lexical                     : "[A-Za-z0-9_]+"

Added: spoofax-contrib/EntityTemplateLang/src/services/generate.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/EntityTemplateLang/src/services/generate.spx	Sun Jun  5 13:08:25 2011	(r22997)
@@ -0,0 +1,48 @@
+package languages.EntityTemplateLang
+
+module generate
+
+imports
+  libstratego-lib
+  libstratego-gpp
+  libstratego-aterm
+  editor.generated
+
+rules
+
+  to-java:
+    Module(x, d*) ->
+    $[ package [x];
+
+       [d'*]
+     ]
+    with
+      d'* := <to-java> d*
+
+  to-java:
+    Entity(x, p*) ->
+    $[ class [x] {
+           [p'*]
+       }
+     ]
+    with
+      p'* := <to-java> p*
+
+  to-java:
+    Property(x, Type(t)) -> $[
+      private [t] [x];
+
+      public [t] get_[x] {
+          return [x];
+      }
+
+      public void set_[x] ([t] [x]) {
+          this.[x] = [x];
+      }
+  ]
+
+  to-java:
+    Type(t) -> t
+
+  to-java:
+    t* -> <map(to-java)> t*

Added: spoofax-contrib/EntityTemplateLang/src/syn/Common.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/EntityTemplateLang/src/syn/Common.spx	Sun Jun  5 13:08:25 2011	(r22997)
@@ -0,0 +1,25 @@
+package languages.EntityTemplateLang
+
+module Common
+
+lexical syntax
+
+  [a-zA-Z][a-zA-Z0-9]* -> ID
+  "-"? [0-9]+          -> INT
+
+  "\"" StringChar* "\"" -> STRING
+  ~[\"\n]               -> StringChar
+  "\\\""                -> StringChar
+  BackSlashChar         -> StringChar
+  "\\"                  -> BackSlashChar
+
+lexical restrictions
+
+  %% Ensure greedy matching for lexicals
+
+  INT           -/- [0-9]
+  ID            -/- [a-zA-Z0-9\_]
+
+  %% Backslash chars in strings may not be followed by "
+
+  BackSlashChar -/- [\"]

Added: spoofax-contrib/EntityTemplateLang/src/syn/Layout.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/EntityTemplateLang/src/syn/Layout.spx	Sun Jun  5 13:08:25 2011	(r22997)
@@ -0,0 +1,74 @@
+/*
+This file implements \n as LAYOUT, but still allows it to be used as e.g.
+statement separator in other productions, without resulting in ambiguities.
+
+This is done by declaring all whitespace characters except \n as LAYOUT, and
+allowing \n as LAYOUT _only_ as part of the special "LineBreak" sort, which
+greedily eats all layout (including any subsequent \n) after the initial \n.
+
+As such, whitespace at the end of a line is parsed as typical LAYOUT.
+When the \n is encountered the only valid parse is to treat all subsequent
+whitespace (including empty lines) as a LineBreak, which has an injection
+into LAYOUT.
+
+If there is a \n required by a production, then the first \n _must_ be
+parsed as the \n required by the production (and the second \n, if any,
+starts a LineBreak sort), as there is no way to "escape" from the greedy
+LineBreak sort otherwise.
+
+Unfortunately this does not always work. Because LAYOUT? may be followed by
+a \n there WILL be an ambiguity everytime the LAYOUT token is to be injected
+in one of multiple LAYOUT?-"holes" in the CF grammar. There is no way to
+constrain which "hole" is used apart from forbidding LAYOUT? to be followed
+by a \n. But then semantic \n will always be eaten by any preceding LAYOUT?,
+nullifying the entire point of this file...
+
+Since this ambiguity appears to always be of a simple amb([x, x]) form,
+a Stratego-based disambiguator has been employed in this project to remove
+those ambiguities: amb([x, x]) -> x
+*/
+
+package languages.EntityTemplateLang
+
+module Layout
+
+lexical syntax
+  [\ \t\r] -> LayoutChar
+  LayoutChar -> LAYOUT
+
+  [\n] ([\n] | LayoutChar)* -> LineBreak
+  LineBreak -> LAYOUT
+
+  "//" ~[\n]* -> Comment
+  Comment -> LayoutChar
+
+  "/*" (~[\*] | Asterisk)* "*/" -> Comment
+  "*" -> Asterisk
+
+lexical restrictions
+  LineBreak -/- [\ \t\n\r]
+  LineBreak -/- [\/].[\/]
+  LineBreak -/- [\/].[\*]
+  Comment   -/- ~[\n]
+  Asterisk  -/- [\/]
+
+context-free restrictions
+  LAYOUT? -/- [\ \t\r]
+  LAYOUT? -/- [\/].[\/]
+  LAYOUT? -/- [\/].[\*]
+
+language Disambiguator
+
+  disambiguator : editor-disambiguate
+
+signature
+  constructors
+    amb : List(X) -> X
+
+rules
+
+  editor-disambiguate:
+    (ast, path, project-path) -> <alltd(disambiguate)> ast
+
+  disambiguate:
+    amb([x, x]) -> x

Added: spoofax-contrib/EntityTemplateLang/src/syn/Syntax.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/EntityTemplateLang/src/syn/Syntax.spx	Sun Jun  5 13:08:25 2011	(r22997)
@@ -0,0 +1,55 @@
+package languages.EntityTemplateLang
+
+module Syntax
+
+template options
+  // When changing to leading or trailing, remove one "\n" separator below.
+  newlines : none // none, leading or trailing
+
+context-free start-symbols
+  Start
+
+templates
+
+  Start.Module = <<
+    module <modulename:ID>
+
+    <Definition*; separator="\n\n">
+  >>
+
+  Definition.Entity = <<
+    entity <ID> {
+      <Property*
+        ; separator="\n" // (no newlines)
+        // ; separator=""   // (leading/trailing newlines)
+        >
+    }
+  >>
+
+  Property.Property = [[
+    [x:ID] : [T:Type]
+  ]]
+
+  Type.Type = <<<Type:ID>>>
+
+/*
+  Definition.Expression = <<
+    expression <ID> {
+      <Expression>
+    }
+  >>
+
+  Expression.Plus  = <<<Expression> + <Expression>>> {left}
+  Expression.Minus = <<<Expression> - <Expression>>> {left}
+  Expression.Times = <<<Expression> * <Expression>>> {left}
+  Expression.Over  = <<<Expression> / <Expression>>> {left}
+  Expression.Power = <<<Expression>^<Expression>>> {right}
+  Expression.Value = <<<INT>>>
+  Expression = <<(<Expression>)>> {bracket}
+
+context-free priorities
+
+  Expression.Power >
+  {left: Expression.Times Expression.Over } >
+  {left: Expression.Plus  Expression.Minus}
+*/

Added: spoofax-contrib/EntityTemplateLang/test/example.ent-template
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/EntityTemplateLang/test/example.ent-template	Sun Jun  5 13:08:25 2011	(r22997)
@@ -0,0 +1,19 @@
+/**
+ * Example EntityTemplateLang program.
+ */
+module example
+
+entity User {
+  name     : String
+  password : String
+  homepage : URL
+}
+
+entity BlogPosting {
+  poster : User
+  body   : String
+}
+
+entity URL {
+  location : String
+}

Added: spoofax-contrib/EntityTemplateLang/test/test-example.spt
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/EntityTemplateLang/test/test-example.spt	Sun Jun  5 13:08:25 2011	(r22997)
@@ -0,0 +1,22 @@
+/**
+* Unit tests for the EntityTemplateLang language.
+*/
+module test-example
+
+language EntityTemplateLang
+
+setup Common [[
+  module example
+]]
+
+test Simple entity [[
+  entity User {
+    name : String
+  }
+]] 0 errors
+
+test Entity with reference to non-existing entity [[
+  entity User {
+    name : Strin
+  }
+]] 1 error

From tobivollebregt at gmail.com  Sun Jun  5 15:11:37 2011
From: tobivollebregt at gmail.com (Tobi Vollebregt)
Date: Sun, 05 Jun 2011 13:11:37 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r22998 - in
	spoofax-contrib/EntityTemplateLang: src/services test
Message-ID: <20110605131137.832F57F8080@mx1.tudelft.nl>

Author: tvo
Date: Sun Jun  5 13:11:36 2011
New Revision: 22998
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=22998&sc=1

Log:
EntityTemplateLang: prettyprint builder, extra example code (which doesn't work yet)

Modified:
   spoofax-contrib/EntityTemplateLang/src/services/editorservices-dynamic.spx
   spoofax-contrib/EntityTemplateLang/test/example.ent-template

Modified: spoofax-contrib/EntityTemplateLang/src/services/editorservices-dynamic.spx
==============================================================================
--- spoofax-contrib/EntityTemplateLang/src/services/editorservices-dynamic.spx	Sun Jun  5 13:08:25 2011	(r22997)
+++ spoofax-contrib/EntityTemplateLang/src/services/editorservices-dynamic.spx	Sun Jun  5 13:11:36 2011	(r22998)
@@ -14,6 +14,7 @@
 
   builder  : "Generate Java code (for selection)"   = generate-java (openeditor) (realtime)
   builder  : "Show abstract syntax (for selection)" = generate-aterm (openeditor) (realtime) (meta) (source)
+  builder  : "Prettyprint (selection)"              = generate-pretty (openeditor) (realtime)
 
 references
 

Modified: spoofax-contrib/EntityTemplateLang/test/example.ent-template
==============================================================================
--- spoofax-contrib/EntityTemplateLang/test/example.ent-template	Sun Jun  5 13:08:25 2011	(r22997)
+++ spoofax-contrib/EntityTemplateLang/test/example.ent-template	Sun Jun  5 13:11:36 2011	(r22998)
@@ -17,3 +17,29 @@
 entity URL {
   location : String
 }
+
+entity Empty {
+
+}
+
+/*
+expression LeftAssociative {
+  1 * 2 * 3
+}
+
+expression RightAssociative {
+  2^2^2
+}
+
+expression Priorities {
+  1 - 2 / 3
+}
+
+expression Priorities {
+  1 / 2 * 3
+}
+
+expression Parentheses {
+  (7 - 5)^((1 + 1) * (2 + 2))
+}
+*/

From tobivollebregt at gmail.com  Sun Jun  5 15:14:07 2011
From: tobivollebregt at gmail.com (Tobi Vollebregt)
Date: Sun, 05 Jun 2011 13:14:07 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r22999 - in
	spoofax-imp/trunk: org.strategoxt.imp.editors.template
	org.strategoxt.imp.editors.template.test
Message-ID: <20110605131407.620EF7F801E@mx1.tudelft.nl>

Author: tvo
Date: Sun Jun  5 13:14:06 2011
New Revision: 22999
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=22999&sc=1

Log:
Remove standalone TemplateLang

Deleted:
   spoofax-imp/trunk/org.strategoxt.imp.editors.template/
   spoofax-imp/trunk/org.strategoxt.imp.editors.template.test/

From tobivollebregt at gmail.com  Sun Jun  5 17:46:08 2011
From: tobivollebregt at gmail.com (Tobi Vollebregt)
Date: Sun, 05 Jun 2011 15:46:08 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23000 - in
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax: lib
	trans/codegen/sdf trans/codegen/str trans/codegen/template
Message-ID: <20110605154608.DD8D52B80AC@mx2.tudelft.nl>

Author: tvo
Date: Sun Jun  5 15:45:56 2011
New Revision: 23000
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23000&sc=1

Log:
SpoofaxLang/Template:
* collect subterm conflicts at the proper place, fixes prettyprinter generation
* readded `Sort.Cons' shortcut for entering a (template) production in a priority section

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/EditorService.def
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/sdf/to-sdf.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/str/to-stratego.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/template/to-sdf.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/EditorService.def
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/EditorService.def	Sun Jun  5 13:14:06 2011	(r22999)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/EditorService.def	Sun Jun  5 15:45:56 2011	(r23000)
@@ -79,7 +79,7 @@
     "completion" "template" ":" Id CompletionPart+ OptCompletionAnno -> SemanticRule {cons("CompletionTemplate"), avoid, deprecated("Add quotes to the starting literal")}
 
     %% Deprecated: replaced by CompletionTemplateEx
-    "completion" "template" ":" Sort "=" CompletionPart CompletionPart* OptCompletionAnno -> SemanticRule {cons("CompletionTemplateWithSort"), avoid, deprecated("Move the sort before ':' and remove '='")}
+    "completion" "template" ":" Sort "=" CompletionPart CompletionPart* OptCompletionAnno -> SemanticRule {cons("CompletionTemplateWithSort"), avoid} %% deprecated("Move the sort before ':' and remove '='")
 
     %% Used as content completion triggers
     %% "completion" "template" PropertyValue CompletionPart* OptCompletionAnno -> SemanticRule {cons("CompletionTemplate"), recover, avoid}
@@ -356,6 +356,7 @@
     "extends"         ":" PropertyValues -> LanguageProperty {cons("Extends")}
     "aliases"         ":" PropertyValues -> LanguageProperty {cons("Aliases")} %% deprecated
     "unmanaged" "table" ":" Id "*"       -> LanguageProperty {cons("UnmanagedTablePrefix")}
+    "disambiguator"   ":" StrategoCall   -> LanguageProperty {cons("Disambiguator")}
    
      %% Syntax properties
      
@@ -379,6 +380,7 @@
      "fences"     -> PropertyValue {reject}
      "line"       -> PropertyValue {reject}
      "block"      -> PropertyValue {reject}
+     "unmanaged"  -> Sort {reject}
 
 module Common
 

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/sdf/to-sdf.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/sdf/to-sdf.str	Sun Jun  5 13:14:06 2011	(r22999)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/sdf/to-sdf.str	Sun Jun  5 15:45:56 2011	(r23000)
@@ -28,6 +28,7 @@
 	codegen/generate
 	codegen/template/to-sdf
 	utils/contract
+	utils/sdf2conflicts
 
 rules
 
@@ -47,7 +48,8 @@
    		;output-path     := <get-output-path(|"sdf")>(root-directory , module-untyped-qname)
     	;<debug-compiler>$[ Codegen | SDF | Found Section + Imports for the following module [<pp-aterm> module-untyped-qname].]
     where
-    	sdf-string       := <pp-sdf-string'> 'module(<qname-to-path>module-untyped-qname, <to-sdf-imports-block>section* , <to-sdf-section-block>section* )
+      // sdf2conflicts here collects information for the parenthesation in the prettyprinter
+    	sdf-string       := <pp-sdf-string'> 'module(<qname-to-path>module-untyped-qname, <to-sdf-imports-block>section* , <to-sdf-section-block;sdf2conflicts>section* )
     	;<debug-compiler>$[ Codegen | SDF | Saving the artifacts of [<pp-aterm> module-untyped-qname].]
 		where
 			<save-artifact(| package-untyped-qname , root-directory, output-path)>sdf-string;
@@ -193,3 +195,24 @@
 		where
 				result := $[[<qname-to-path >q]
 									 ]
+rules
+
+  // (from TemplateLang)
+
+  // Allows one to write `Sort.Cons' where a production is expected.
+  // (i.e. in priority sections)
+
+  desugar-sdf-redux:
+    simple-ref-group(ref) -> simple-group(<SortCons-to-prod> ref)
+
+  desugar-sdf-redux:
+    prods-ref-group(ref*) -> prods-group(<map(SortCons-to-prod)> ref*)
+
+  desugar-sdf-redux:
+    assoc-ref-group(a, ref*) -> assoc-group(a, <map(SortCons-to-prod)> ref*)
+
+  // FIXME: Declaration contains scoped names ((Package(QName(...)), Module(QName(...))), consOrSort)
+  SortCons-to-prod:
+    SortCons(sort, cons) -> t
+    with t := <( Declaration <+ debug(!"Undeclared SortCons"); <debug(!"all-keys-Declaration: ")> <all-keys-Declaration>; fail )
+               ; try(template-production-to-sdf-no-attrs)> (<to-scoped-symbol>sort, <to-scoped-symbol>cons)

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/str/to-stratego.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/str/to-stratego.str	Sun Jun  5 13:14:06 2011	(r22999)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/str/to-stratego.str	Sun Jun  5 15:45:56 2011	(r23000)
@@ -24,7 +24,6 @@
 imports
 	normalize/signatures
 	utils/contract
-	utils/sdf2conflicts
 
 
 
@@ -97,7 +96,7 @@
 			<debug-compiler>$[ Codegen | STR | Generation of Main STR Module for package : [<pp-aterm> package-qname] is done.]
 	  with
 	    <debug-compiler>$[ Codegen | STR | Generating prettyprinter from package-name: [<pp-aterm>package-qname]];
-	    {|DeclaredModule, GetEnclosingModuleName, SubtermConflicts:
+	    {|DeclaredModule, GetEnclosingModuleName:
 	      // HACK: this lacks any sanity wrt the original modules in which the SDF was placed ...
 	      rules(
 	        DeclaredModule :+ "__prettyprinter" -> "__prettyprinter"
@@ -105,7 +104,8 @@
 	      );
         section* := <map(get-original-module-declaration; ?Module(_, _, <id>)); concat> module-qname*;
         section'* := <filter(?SDFSection(_) + ?SDFSectionEH(_, _) + ?TemplateSection(_))> section*;
-        pp-aterm := <sdf2conflicts;template-sections-to-stratego> section'*
+        // this uses information collected by sdf2conflicts
+        pp-aterm := <template-sections-to-stratego> section'*
 	    |};
       pp-string := <pp-stratego-string> <parenthesize-Stratego> pp-aterm;
       pp-qname := <QName(at-last([<conc-strings>(<id>, "-prettyprinter")]))> package-qname;

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/template/to-sdf.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/template/to-sdf.str	Sun Jun  5 13:14:06 2011	(r22999)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/template/to-sdf.str	Sun Jun  5 15:45:56 2011	(r23000)
@@ -64,6 +64,7 @@
         end
       end
 
+  // Used when rewriting `Sort.Cons' in priority sections to a production.
   template-production-to-sdf-no-attrs:
     TemplateProduction(S', t, _) -> p|[ A* -> S' ]|
     with

From tobivollebregt at gmail.com  Sun Jun  5 17:48:37 2011
From: tobivollebregt at gmail.com (Tobi Vollebregt)
Date: Sun, 05 Jun 2011 15:48:37 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23001 - in
	spoofax-contrib/EntityTemplateLang: src/syn test
Message-ID: <20110605154837.4154D108C088@mx3.tudelft.nl>

Author: tvo
Date: Sun Jun  5 15:48:36 2011
New Revision: 23001
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23001&sc=1

Log:
EntityTemplateLang: enable the syntax/example that demonstrates parenthesation in the prettyprinter

Modified:
   spoofax-contrib/EntityTemplateLang/src/syn/Syntax.spx
   spoofax-contrib/EntityTemplateLang/test/example.ent-template

Modified: spoofax-contrib/EntityTemplateLang/src/syn/Syntax.spx
==============================================================================
--- spoofax-contrib/EntityTemplateLang/src/syn/Syntax.spx	Sun Jun  5 15:45:56 2011	(r23000)
+++ spoofax-contrib/EntityTemplateLang/src/syn/Syntax.spx	Sun Jun  5 15:48:36 2011	(r23001)
@@ -31,8 +31,7 @@
   ]]
 
   Type.Type = <<<Type:ID>>>
-
-/*
+
   Definition.Expression = <<
     expression <ID> {
       <Expression>
@@ -52,4 +51,3 @@
   Expression.Power >
   {left: Expression.Times Expression.Over } >
   {left: Expression.Plus  Expression.Minus}
-*/

Modified: spoofax-contrib/EntityTemplateLang/test/example.ent-template
==============================================================================
--- spoofax-contrib/EntityTemplateLang/test/example.ent-template	Sun Jun  5 15:45:56 2011	(r23000)
+++ spoofax-contrib/EntityTemplateLang/test/example.ent-template	Sun Jun  5 15:48:36 2011	(r23001)
@@ -22,7 +22,6 @@
 
 }
 
-/*
 expression LeftAssociative {
   1 * 2 * 3
 }
@@ -42,4 +41,3 @@
 expression Parentheses {
   (7 - 5)^((1 + 1) * (2 + 2))
 }
-*/

From seba at informatik.uni-marburg.de  Sun Jun  5 19:22:31 2011
From: seba at informatik.uni-marburg.de (Sebastian Erdweg)
Date: Sun, 05 Jun 2011 17:22:31 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23002 - in
	sugarj/trunk: compiler compiler/.settings compiler/META-INF
	compiler/org/sugarj/driver compiler/org/sugarj/driver/caching
	compiler/org/sugarj/driver/path editor...
Message-ID: <20110605172231.4C847108C06D@mx3.tudelft.nl>

Author: SebastianErdweg
Date: Sun Jun  5 17:22:30 2011
New Revision: 23002
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23002&sc=1

Log:
represent file locations as instances of org.sugarj.driver.path.Path instead of String. In particular, this representation supports relative paths that do not break file dependencies, which again enables the deployment of SugarJ projects including binaries and caches.

Added:
   sugarj/trunk/compiler/org/sugarj/driver/path/
   sugarj/trunk/compiler/org/sugarj/driver/path/AbsolutePath.java
   sugarj/trunk/compiler/org/sugarj/driver/path/Path.java
   sugarj/trunk/compiler/org/sugarj/driver/path/RelativePath.java
   sugarj/trunk/compiler/org/sugarj/driver/path/RelativePathBin.java
   sugarj/trunk/compiler/org/sugarj/driver/path/RelativePathCache.java
Modified:
   sugarj/trunk/compiler/.classpath
   sugarj/trunk/compiler/.settings/org.eclipse.jdt.core.prefs
   sugarj/trunk/compiler/META-INF/MANIFEST.MF
   sugarj/trunk/compiler/make_permissive.jar
   sugarj/trunk/compiler/org/sugarj/driver/ATermCommands.java
   sugarj/trunk/compiler/org/sugarj/driver/Driver.java
   sugarj/trunk/compiler/org/sugarj/driver/DriverCLI.java
   sugarj/trunk/compiler/org/sugarj/driver/Environment.java
   sugarj/trunk/compiler/org/sugarj/driver/FileCommands.java
   sugarj/trunk/compiler/org/sugarj/driver/JavaCommands.java
   sugarj/trunk/compiler/org/sugarj/driver/ModuleSystemCommands.java
   sugarj/trunk/compiler/org/sugarj/driver/Result.java
   sugarj/trunk/compiler/org/sugarj/driver/SDFCommands.java
   sugarj/trunk/compiler/org/sugarj/driver/STRCommands.java
   sugarj/trunk/compiler/org/sugarj/driver/caching/Cache.java
   sugarj/trunk/compiler/org/sugarj/driver/caching/ModuleKey.java
   sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParser.java

Modified: sugarj/trunk/compiler/.classpath
==============================================================================
--- sugarj/trunk/compiler/.classpath	Sun Jun  5 15:48:36 2011	(r23001)
+++ sugarj/trunk/compiler/.classpath	Sun Jun  5 17:22:30 2011	(r23002)
@@ -6,5 +6,6 @@
 	<classpathentry exported="true" kind="lib" path="make_permissive.jar"/>
 	<classpathentry exported="true" kind="lib" path="commons-cli-1.2.jar"/>
 	<classpathentry kind="lib" path="commons-collections-3.2.1.jar"/>
+	<classpathentry kind="lib" path="/Users/seba/Library/eclipse/plugins/org.strategoxt.imp.nativebundle_0.1.1.201105211714"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>

Modified: sugarj/trunk/compiler/.settings/org.eclipse.jdt.core.prefs
==============================================================================
--- sugarj/trunk/compiler/.settings/org.eclipse.jdt.core.prefs	Sun Jun  5 15:48:36 2011	(r23001)
+++ sugarj/trunk/compiler/.settings/org.eclipse.jdt.core.prefs	Sun Jun  5 17:22:30 2011	(r23002)
@@ -1,4 +1,4 @@
-#Wed Feb 23 11:35:15 CET 2011
+#Tue May 31 15:06:18 CEST 2011
 eclipse.preferences.version=1
 org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
 org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.6
@@ -8,6 +8,7 @@
 org.eclipse.jdt.core.compiler.source=1.6
 org.eclipse.jdt.core.formatter.align_type_members_on_columns=false
 org.eclipse.jdt.core.formatter.alignment_for_arguments_in_allocation_expression=16
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_annotation=0
 org.eclipse.jdt.core.formatter.alignment_for_arguments_in_enum_constant=16
 org.eclipse.jdt.core.formatter.alignment_for_arguments_in_explicit_constructor_call=16
 org.eclipse.jdt.core.formatter.alignment_for_arguments_in_method_invocation=16
@@ -18,6 +19,7 @@
 org.eclipse.jdt.core.formatter.alignment_for_conditional_expression=80
 org.eclipse.jdt.core.formatter.alignment_for_enum_constants=0
 org.eclipse.jdt.core.formatter.alignment_for_expressions_in_array_initializer=16
+org.eclipse.jdt.core.formatter.alignment_for_method_declaration=0
 org.eclipse.jdt.core.formatter.alignment_for_multiple_fields=16
 org.eclipse.jdt.core.formatter.alignment_for_parameters_in_constructor_declaration=16
 org.eclipse.jdt.core.formatter.alignment_for_parameters_in_method_declaration=16
@@ -62,10 +64,15 @@
 org.eclipse.jdt.core.formatter.comment.insert_new_line_before_root_tags=insert
 org.eclipse.jdt.core.formatter.comment.insert_new_line_for_parameter=insert
 org.eclipse.jdt.core.formatter.comment.line_length=80
+org.eclipse.jdt.core.formatter.comment.new_lines_at_block_boundaries=true
+org.eclipse.jdt.core.formatter.comment.new_lines_at_javadoc_boundaries=true
 org.eclipse.jdt.core.formatter.compact_else_if=true
 org.eclipse.jdt.core.formatter.continuation_indentation=2
 org.eclipse.jdt.core.formatter.continuation_indentation_for_array_initializer=2
+org.eclipse.jdt.core.formatter.disabling_tag=@formatter\:off
+org.eclipse.jdt.core.formatter.enabling_tag=@formatter\:on
 org.eclipse.jdt.core.formatter.format_guardian_clause_on_one_line=false
+org.eclipse.jdt.core.formatter.format_line_comment_starting_on_first_column=true
 org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_annotation_declaration_header=true
 org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_constant_header=true
 org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_declaration_header=true
@@ -80,6 +87,7 @@
 org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_local_variable=insert
 org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_member=insert
 org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_parameter=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_label=do not insert
 org.eclipse.jdt.core.formatter.insert_new_line_after_opening_brace_in_array_initializer=do not insert
 org.eclipse.jdt.core.formatter.insert_new_line_at_end_of_file_if_missing=do not insert
 org.eclipse.jdt.core.formatter.insert_new_line_before_catch_in_try_statement=do not insert
@@ -262,5 +270,7 @@
 org.eclipse.jdt.core.formatter.put_empty_statement_on_new_line=true
 org.eclipse.jdt.core.formatter.tabulation.char=space
 org.eclipse.jdt.core.formatter.tabulation.size=2
+org.eclipse.jdt.core.formatter.use_on_off_tags=false
 org.eclipse.jdt.core.formatter.use_tabs_only_for_leading_indentations=false
 org.eclipse.jdt.core.formatter.wrap_before_binary_operator=true
+org.eclipse.jdt.core.formatter.wrap_outer_expressions_when_nested=true

Modified: sugarj/trunk/compiler/META-INF/MANIFEST.MF
==============================================================================
--- sugarj/trunk/compiler/META-INF/MANIFEST.MF	Sun Jun  5 15:48:36 2011	(r23001)
+++ sugarj/trunk/compiler/META-INF/MANIFEST.MF	Sun Jun  5 17:22:30 2011	(r23002)
@@ -15,9 +15,10 @@
  org.strategoxt.imp.nativebundle
 Bundle-ActivationPolicy: lazy
 Bundle-RequiredExecutionEnvironment: JavaSE-1.6
-Export-Package: org.sugarj, 
+Export-Package: org.sugarj,
  org.sugarj.driver,
  org.sugarj.driver.caching,
+ org.sugarj.driver.path,
  org.sugarj.driver.transformations
 Bundle-ClassPath: make_permissive.jar,
  .,

Modified: sugarj/trunk/compiler/make_permissive.jar
==============================================================================
Binary file (source and/or target). No diff available.

Modified: sugarj/trunk/compiler/org/sugarj/driver/ATermCommands.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/ATermCommands.java	Sun Jun  5 15:48:36 2011	(r23001)
+++ sugarj/trunk/compiler/org/sugarj/driver/ATermCommands.java	Sun Jun  5 17:22:30 2011	(r23002)
@@ -29,6 +29,7 @@
 import org.strategoxt.lang.Context;
 import org.strategoxt.lang.StrategoExit;
 import org.strategoxt.tools.sdf_desugar_0_0;
+import org.sugarj.driver.path.Path;
 import org.sugarj.driver.transformations.extraction.extract_sdf_0_0;
 import org.sugarj.driver.transformations.extraction.extract_str_0_0;
 
@@ -87,13 +88,13 @@
     return new TAFTermReader(factory).parseFromString(s);
   }
 
-  public static String atermToFile(IStrategoTerm aterm) throws IOException {
-    String file = FileCommands.newTempFile("ast");
+  public static Path atermToFile(IStrategoTerm aterm) throws IOException {
+    Path file = FileCommands.newTempFile("ast");
     atermToFile(aterm, file);
     return file;
   }
   
-  public static void atermToFile(IStrategoTerm aterm, String filename)
+  public static void atermToFile(IStrategoTerm aterm, Path filename)
       throws IOException {
     Environment.terms.put(filename, aterm);
     FileCommands.writeToFile(filename, atermToString(aterm));
@@ -294,8 +295,8 @@
     return result;
   }
   
-  public static List<IStrategoTerm> registerSemanticProvider(Collection<IStrategoTerm> editorServices, String jarfile) throws IOException {
-    String jarfilePath = jarfile.replace("\\", "\\\\").replace("\"", "\\\"");
+  public static List<IStrategoTerm> registerSemanticProvider(Collection<IStrategoTerm> editorServices, Path jarfile) throws IOException {
+    String jarfilePath = jarfile.getAbsolutePath().replace("\\", "\\\\").replace("\"", "\\\"");
     IStrategoTerm semanticProvider = atermFromString("SemanticProvider(\"" + jarfilePath + "\")");
     
     List<IStrategoTerm> newServices = new ArrayList<IStrategoTerm>();
@@ -325,7 +326,7 @@
     IToken left = ImploderAttachment.getLeftToken(toplevelDecl);
     IToken right = ImploderAttachment.getRightToken(toplevelDecl);
     
-    String file = "no file";
+    Path file = null;
     try {
       file = atermToFile(toplevelDecl);
     } catch (IOException e) {

Modified: sugarj/trunk/compiler/org/sugarj/driver/Driver.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/Driver.java	Sun Jun  5 15:48:36 2011	(r23001)
+++ sugarj/trunk/compiler/org/sugarj/driver/Driver.java	Sun Jun  5 17:22:30 2011	(r23002)
@@ -11,18 +11,13 @@
 import static org.sugarj.driver.Environment.sep;
 import static org.sugarj.driver.Log.log;
 
-import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
-import java.io.FileReader;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
-import java.net.URI;
-import java.net.URL;
-import java.net.URLClassLoader;
 import java.text.ParseException;
 import java.util.AbstractMap;
 import java.util.ArrayList;
@@ -54,6 +49,11 @@
 import org.strategoxt.permissivegrammars.make_permissive;
 import org.strategoxt.tools.tools;
 import org.sugarj.driver.caching.ModuleKeyCache;
+import org.sugarj.driver.path.AbsolutePath;
+import org.sugarj.driver.path.Path;
+import org.sugarj.driver.path.RelativePath;
+import org.sugarj.driver.path.RelativePathBin;
+import org.sugarj.driver.path.RelativePathCache;
 import org.sugarj.driver.transformations.extraction.extraction;
 import org.sugarj.stdlib.StdLib;
 
@@ -66,44 +66,44 @@
   
   private static class Key {
     private String source;
-    private String moduleName;
+    private Path file;
     
-    private Key(String source, String moduleName) {
+    private Key(String source, Path file) {
       this.source = source;
-      this.moduleName = moduleName;
+      this.file = file;
     }
     
     public int hashCode() {
-      return source.hashCode() + moduleName.hashCode();
+      return source.hashCode() + file.hashCode();
     }
     
     public boolean equals(Object o) {
       return o instanceof Key 
           && ((Key) o).source.equals(source)
-          && ((Key) o).moduleName.equals(moduleName);
+          && ((Key) o).file.equals(file);
     }
   }
 
   private final static int PENDING_TIMEOUT = 120000;
 
   private static LRUMap resultCache = new LRUMap(50);
-  private static Map<String, Entry<String, Driver>> pendingRuns = new HashMap<String, Map.Entry<String,Driver>>();
+  private static Map<Path, Entry<String, Driver>> pendingRuns = new HashMap<Path, Map.Entry<String,Driver>>();
 
-  private static List<URI> allInputFiles;
-  private static List<URI> pendingInputFiles;
-  private static List<URI> currentlyProcessing;
+  private static List<RelativePath> allInputFiles;
+  private static List<Path> pendingInputFiles;
+  private static List<Path> currentlyProcessing;
 
   private IProgressMonitor monitor;
   
   private Result driverResult = new Result();
   
-  private String javaOutFile;
+  private Path javaOutFile;
   private String relPackageName;
-  private String relativePath;
+  private RelativePath sourceFile;
 
-  private String currentGrammarSDF;
+  private Path currentGrammarSDF;
   private String currentGrammarModule;
-  private String currentTransSTR;
+  private Path currentTransSTR;
   private String currentTransModule;
   private String remainingInput;
   
@@ -129,7 +129,7 @@
   private Context extractionContext;
   private Context strjContext;
   
-  private String currentTransProg;
+  private Path currentTransProg;
   
   private boolean interrupt = false;
   
@@ -138,7 +138,7 @@
    */
   private boolean skipCache = false;
   
-  private List<String> generatedJavaClasses = new ArrayList<String>();
+  private List<Path> generatedJavaClasses = new ArrayList<Path>();
   
   
   
@@ -147,37 +147,37 @@
       Environment.init();
       
       if (Environment.cacheDir != null)
-        FileCommands.createDir(Environment.cacheDir);
+        FileCommands.createDir(new AbsolutePath(Environment.cacheDir));
       
-      FileCommands.createDir(Environment.bin);
+      FileCommands.createDir(new AbsolutePath(Environment.bin));
       
       initializeCaches();
     } catch (IOException e) {
       throw new RuntimeException("error while initializin driver", e);
     }
     
-    allInputFiles = new ArrayList<URI>();
-    pendingInputFiles = new ArrayList<URI>();
-    currentlyProcessing = new ArrayList<URI>();
+    allInputFiles = new ArrayList<RelativePath>();
+    pendingInputFiles = new ArrayList<Path>();
+    currentlyProcessing = new ArrayList<Path>();
   }
   
   
   
   
   
-  private static synchronized Result getResult(String source, String moduleName) {
-    return (Result) resultCache.get(new Key(source, moduleName));
+  private static synchronized Result getResult(String source, Path file) {
+    return (Result) resultCache.get(new Key(source, file));
   }
   
-  private static synchronized Entry<String, Driver> getPendingRun(String file) {
+  private static synchronized Entry<String, Driver> getPendingRun(Path file) {
     return pendingRuns.get(file);
   }
   
-  private static synchronized void putPendingRun(String file, String source, Driver driver) {
+  private static synchronized void putPendingRun(Path file, String source, Driver driver) {
     pendingRuns.put(file, new AbstractMap.SimpleImmutableEntry<String, Driver>(source, driver));
   }
   
-  private static void waitForPending(String file) {
+  private static void waitForPending(Path file) {
     int count = 0;
     Object lock = new Object();
     synchronized (lock) {
@@ -199,12 +199,12 @@
     }
   }
 
-  private static synchronized void putResult(String source, String moduleName, Result result) {
-    resultCache.put(new Key(source, moduleName), result);
+  private static synchronized void putResult(String source, Path file, Result result) {
+    resultCache.put(new Key(source, file), result);
     Log.log.log(resultCache.size());
   }
   
-  public static Result compile(URI sourceFile, String relativePath, IProgressMonitor monitor) throws IOException, TokenExpectedException, BadTokenException, ParseException, InvalidParseTableException, SGLRException, InterruptedException {
+  public static Result compile(RelativePath sourceFile, IProgressMonitor monitor) throws IOException, TokenExpectedException, BadTokenException, ParseException, InvalidParseTableException, SGLRException, InterruptedException {
     synchronized (currentlyProcessing) {
       // TODO we need better circular dependency handling
       if (currentlyProcessing.contains(sourceFile))
@@ -215,8 +215,8 @@
     Result res;
     
     try {
-      String source = FileCommands.readFileAsString(sourceFile.getPath());
-      res = compile(source, relativePath, sourceFile.getPath(), monitor);
+      String source = FileCommands.readFileAsString(sourceFile);
+      res = compile(source, sourceFile, monitor);
     } finally {
       synchronized (currentlyProcessing) {
         currentlyProcessing.remove(sourceFile);
@@ -228,38 +228,38 @@
     return res;
   }
   
-  public static Result compile(String source, String relativePath, String file, IProgressMonitor monitor) throws IOException, TokenExpectedException, BadTokenException, ParseException, InvalidParseTableException, SGLRException, InterruptedException {
+  public static Result compile(String source, RelativePath sourceFile, IProgressMonitor monitor) throws IOException, TokenExpectedException, BadTokenException, ParseException, InvalidParseTableException, SGLRException, InterruptedException {
     Driver driver = new Driver();
     Entry<String, Driver> pending = null;
     
     synchronized (Driver.class) {
-      pending = getPendingRun(file);
+      pending = getPendingRun(sourceFile);
       if (pending != null && !pending.getKey().equals(source)) {
-        log.log("interrupting " + relativePath);
+        log.log("interrupting " + sourceFile);
         pending.getValue().interrupt();
       }
 
       if (pending == null) {
-        Result result = getResult(source, file);
+        Result result = getResult(source, sourceFile);
         if (result != null && result.isUpToDate(source.hashCode()))
           return result;
       }
       
       if (pending == null)
-        putPendingRun(file, source, driver);
+        putPendingRun(sourceFile, source, driver);
     }
     
     if (pending != null) {
-      waitForPending(file);
-      return compile(source, relativePath, file, monitor);
+      waitForPending(sourceFile);
+      return compile(source, sourceFile, monitor);
     }
     
     try {
-      driver.process(source, relativePath, file, monitor);
+      driver.process(source, sourceFile, monitor);
       storeCaches();
     } finally {
-        pendingRuns.remove(file);
-        putResult(source, file, driver.driverResult.getSugaredSyntaxTree() == null ? null : driver.driverResult);
+        pendingRuns.remove(sourceFile);
+        putResult(source, sourceFile, driver.driverResult.getSugaredSyntaxTree() == null ? null : driver.driverResult);
     }
     
     return driver.driverResult;
@@ -276,18 +276,17 @@
    * @throws TokenExpectedException 
    * @throws InterruptedException 
    */
-  private void process(String source, String relativePath, String file, IProgressMonitor monitor) throws IOException, TokenExpectedException, BadTokenException, ParseException, InvalidParseTableException, SGLRException, InterruptedException {
+  private void process(String source, RelativePath sourceFile, IProgressMonitor monitor) throws IOException, TokenExpectedException, BadTokenException, ParseException, InvalidParseTableException, SGLRException, InterruptedException {
     this.monitor = monitor;
-    log.beginTask("processing", "BEGIN PROCESSING " + relativePath);
+    log.beginTask("processing", "BEGIN PROCESSING " + sourceFile.getRelativePath());
     boolean success = false;
     try {
-      relativePath = FileCommands.dropExtension(relativePath);
-      init(relativePath);
-      driverResult.setSourceFile(file, source.hashCode());
-      
-      if (relativePath != null) {
-        javaOutFile = Environment.bin + sep + relativePath + ".java";
-        driverResult.setGenerationLog(Environment.bin + sep + relativePath + ".gen");
+      init(sourceFile);
+      driverResult.setSourceFile(sourceFile, source.hashCode());
+      
+      if (sourceFile != null) {
+        javaOutFile = new RelativePathBin(sourceFile + ".java");
+        driverResult.setGenerationLog(new RelativePathBin(sourceFile + ".gen"));
         clearGeneratedStuff();
       }
 
@@ -353,7 +352,7 @@
       success = false;
     }
     finally {
-      log.endTask(success, "done processing " + relativePath, "failed processing " + relativePath);
+      log.endTask(success, "done processing " + sourceFile, "failed processing " + sourceFile);
       driverResult.setFailed(!success);
     }
   }
@@ -365,7 +364,7 @@
       path.add(StdLib.stdLibDir.getPath());
       path.add(Environment.bin);
       
-      driverResult.compileJava(javaOutFile, bin, path, generatedJavaClasses);
+      driverResult.compileJava(javaOutFile, new AbsolutePath(bin), path, generatedJavaClasses);
     } finally {
       log.endTask();
     }
@@ -417,7 +416,7 @@
                 + remainingInputTerm.toString(),
             -1);
       
-      String tmpFile = FileCommands.newTempFile("aterm");
+      Path tmpFile = FileCommands.newTempFile("aterm");
       FileCommands.writeToFile(tmpFile, toplevelDecl.toString());
       log.log("next toplevel declaration parsed: " + tmpFile);
 
@@ -502,8 +501,8 @@
         // XXX if (currentTransProg != null)
         editorServices = ATermCommands.registerSemanticProvider(editorServices, currentTransProg);
   
-        String editorServicesFile = bin + sep + relPackageNameSep() + extName + ".serv";
-        String depFile = bin + sep + relPackageNameSep() + extName + ".dep";
+        Path editorServicesFile = new RelativePathBin(relPackageNameSep() + extName + ".serv");
+        Path depFile = new RelativePathBin(relPackageNameSep() + extName + ".dep");
         FileCommands.createFile(editorServicesFile);
   
         log.log("writing editor services to " + editorServicesFile);
@@ -578,8 +577,9 @@
       
         String plainContent = Term.asJavaString(ATermCommands.getApplicationSubterm(body, "PlainBody", 0));
         
-        String plainFile = bin + sep + relPackageNameSep() + extName + (extension == null ? "" : ("." + extension));
-        String depFile = bin + sep + relPackageNameSep() + extName + ".dep";
+        String ext = extension == null ? "" : ("." + extension);
+        Path plainFile = new RelativePathBin(relPackageNameSep() + extName + ext);
+        Path depFile = new RelativePathBin(relPackageNameSep() + extName + ".dep");
         FileCommands.createFile(plainFile);
   
         log.log("writing plain content to " + plainFile);
@@ -602,7 +602,7 @@
       if (relPackageName == null)
         checkPackageName(toplevelDecl);
       if (javaOutFile == null)
-        javaOutFile = Environment.bin + sep + relPackageNameSep() + FileCommands.fileName(driverResult.getSourceFile()) + ".java";
+        javaOutFile = new RelativePathBin(relPackageNameSep() + FileCommands.fileName(driverResult.getSourceFile()) + ".java");
       try {
         if (isApplication(toplevelDecl, "TypeImportDec") || isApplication(toplevelDecl, "TypeImportOnDemandDec")) {
           if (!Environment.atomicImportParsing)
@@ -654,9 +654,9 @@
   private IStrategoTerm currentParse(String remainingInput, boolean recovery) throws IOException,
       InvalidParseTableException, TokenExpectedException, BadTokenException, SGLRException {
     // recompile the current grammar definition
-    String currentGrammarTBL = SDFCommands.compile(currentGrammarSDF, currentGrammarModule, driverResult.getFileDependencies(), sdfParser, sdfContext, makePermissiveContext);
+    Path currentGrammarTBL = SDFCommands.compile(currentGrammarSDF, currentGrammarModule, driverResult.getFileDependencies(), sdfParser, sdfContext, makePermissiveContext);
     driverResult.setLastParseTable(currentGrammarTBL);
-    ParseTable table = org.strategoxt.imp.runtime.Environment.loadParseTable(currentGrammarTBL);
+    ParseTable table = org.strategoxt.imp.runtime.Environment.loadParseTable(currentGrammarTBL.getAbsolutePath());
     
     IStrategoTerm parseResult = null;
 
@@ -723,7 +723,7 @@
       checkPackageName(toplevelDecl);
       
       if (javaOutFile == null)
-        javaOutFile = Environment.bin + sep + relPackageNameSep() + FileCommands.fileName(driverResult.getSourceFile()) + ".java";
+        javaOutFile = new RelativePathBin(relPackageNameSep() + FileCommands.fileName(driverResult.getSourceFile()) + ".java");
       driverResult.generateFile(javaOutFile, SDFCommands.prettyPrintJava(toplevelDecl, interp) + "\n");
     } finally {
       log.endTask();
@@ -731,11 +731,12 @@
   }
   
   private void checkPackageName(IStrategoTerm toplevelDecl) {
-    if (relativePath != null) {
+    if (sourceFile != null) {
       String packageName = relPackageName == null ? "" : relPackageName.replace('/', '.');
       
-      int i = relativePath.lastIndexOf('/');
-      String expectedPackage = i >= 0 ? relativePath.substring(0, i) : relativePath;
+      String rel = FileCommands.dropExtension(sourceFile.getRelativePath());
+      int i = rel.lastIndexOf('/');
+      String expectedPackage = i >= 0 ? rel.substring(0, i) : rel;
       expectedPackage = expectedPackage.replace('/', '.');
       if (!packageName.equals(expectedPackage))
         ATermCommands.setErrorMessage(
@@ -799,39 +800,39 @@
       String modulePath = FileCommands.getRelativeModulePath(importModule);
   
       if (!modulePath.startsWith("org/sugarj")) {
-        URI depUri = ModuleSystemCommands.searchFile(modulePath, ".dep");
+        Path dep = ModuleSystemCommands.searchFile(modulePath, ".dep");
         Result res = null;
-        URI sourceUri = null;
+        RelativePath sourceFile = null;
         
-        if (depUri != null) {
-          res = Result.readDependencyFile(depUri.getPath());
+        if (dep != null) {
+          res = Result.readDependencyFile(dep);
           
           if (res != null && res.getSourceFile() != null)
-            sourceUri = new File(res.getSourceFile()).toURI();
+            sourceFile = res.getSourceFile();
         }
         
-        if (sourceUri == null)
-          sourceUri = ModuleSystemCommands.locateSourceFile(modulePath);
+        if (sourceFile == null)
+          sourceFile = ModuleSystemCommands.locateSourceFile(modulePath);
 
-        if (sourceUri != null && (res == null || pendingInputFiles.contains(res.getSourceFile()) || !res.isUpToDate(res.getSourceFile()))) {
+        if (sourceFile != null && (res == null || pendingInputFiles.contains(res.getSourceFile()) || !res.isUpToDate(res.getSourceFile()))) {
           log.log("Need to compile the imported module first ; processing it now.");
           
           try {
-            Result importResult = compile(sourceUri, modulePath, monitor);
+            Result importResult = compile(sourceFile, monitor);
             if (importResult.hasFailed())
               ATermCommands.setErrorMessage(toplevelDecl, "problems while compiling " + importModule);
           } catch (Exception e) {
             ATermCommands.setErrorMessage(toplevelDecl, "problems while compiling " + importModule);
           }
             
-          log.log("CONTINUE PROCESSING'" + relativePath + "'.");
+          log.log("CONTINUE PROCESSING'" + sourceFile + "'.");
         }
         
-        if (depUri == null)
-          depUri = ModuleSystemCommands.searchFile(modulePath, ".dep");
+        if (dep == null)
+          dep = ModuleSystemCommands.searchFile(modulePath, ".dep");
         
-        if (depUri != null)
-          driverResult.addDependency(depUri.getPath());
+        if (dep != null)
+          driverResult.addDependency(dep);
       }
       
       boolean success = processImport(modulePath, toplevelDecl);
@@ -856,15 +857,15 @@
         interp, 
         driverResult);
 
-    URI grammarModule = ModuleSystemCommands.importSdf(modulePath);
-    if (grammarModule != null) {
+    Path sdf = ModuleSystemCommands.importSdf(modulePath);
+    if (sdf != null) {
       success = true;
       availableSDFImports.add(modulePath);
       buildCompoundSdfModule();
     }
     
-    URI strModule = ModuleSystemCommands.importStratego(modulePath);
-    if (strModule != null) {
+    Path str = ModuleSystemCommands.importStratego(modulePath);
+    if (str != null) {
       success = true;
       availableSTRImports.add(modulePath);
       buildCompoundStrModule();
@@ -891,11 +892,12 @@
         
         String decName = Term.asJavaString(dec.getSubterm(0).getSubterm(1).getSubterm(0));
         
-        String outName = bin + sep + relPackageNameSep() + decName;
+        Path clazz = new RelativePathBin(relPackageNameSep() + decName + ".class");
+        Path dep = new RelativePathBin(relPackageNameSep() + decName + ".dep");
         
-        generatedJavaClasses.add(outName + ".class");
+        generatedJavaClasses.add(clazz);
         driverResult.appendToFile(javaOutFile, SDFCommands.prettyPrintJava(dec, interp) + "\n");
-        driverResult.writeDependencyFile(outName + ".dep");
+        driverResult.writeDependencyFile(dep);
       } finally {
         log.endTask();
       }
@@ -977,9 +979,9 @@
         log.endTask();
       }
       
-      String sdfExtension = bin + sep + relPackageNameSep() + extName + ".sdf";
-      String strExtension = bin + sep + relPackageNameSep() + extName + ".str";
-      String depFile = bin + sep + relPackageNameSep() + extName + ".dep";
+      Path sdfExtension = new RelativePathBin(relPackageNameSep() + extName + ".sdf");
+      Path strExtension = new RelativePathBin(relPackageNameSep() + extName + ".str");;
+      Path depFile = new RelativePathBin(relPackageNameSep() + extName + ".dep");;
       
       FileCommands.delete(sdfExtension);
       FileCommands.delete(strExtension);
@@ -1033,7 +1035,7 @@
         availableSDFImports.add(fullExtName);
         
         if (CommandExecution.FULL_COMMAND_LINE)
-          log.log("Wrote SDF file to '" + new File(sdfExtension).getAbsolutePath() + "'.");
+          log.log("Wrote SDF file to '" + sdfExtension.getAbsolutePath() + "'.");
         
         String strExtensionTerm = 
             "Module(" + "\"" + fullExtName+ "\"" + ", " 
@@ -1055,7 +1057,7 @@
         availableSTRImports.add(fullExtName);
         
         if (CommandExecution.FULL_COMMAND_LINE)
-          log.log("Wrote Stratego file to '" + new File(strExtension).getAbsolutePath() + "'.");
+          log.log("Wrote Stratego file to '" + strExtension.getAbsolutePath() + "'.");
       }
       
       driverResult.writeDependencyFile(depFile);
@@ -1138,16 +1140,16 @@
       driverResult.addEditorService(service);
   }
   
-  private void init(String relativePath) throws FileNotFoundException, IOException, InvalidParseTableException {
+  private void init(RelativePath sourceFile) throws FileNotFoundException, IOException, InvalidParseTableException {
     javaOutFile = null; 
     // FileCommands.createFile(tmpOutdir, relModulePath + ".java");
 
-    this.relativePath = relativePath;
+    this.sourceFile = sourceFile;
 
-    currentGrammarSDF = StdLib.initGrammar.getPath();
+    currentGrammarSDF = new AbsolutePath(StdLib.initGrammar.getPath());
     currentGrammarModule = StdLib.initGrammarModule;
 
-    currentTransSTR = StdLib.initTrans.getPath();
+    currentTransSTR = new AbsolutePath(StdLib.initTrans.getPath());
     currentTransModule = StdLib.initTransModule;
 
     // list of imports that contain SDF extensions
@@ -1186,33 +1188,21 @@
       if (Environment.sourcePath.isEmpty())
         Environment.sourcePath.add(".");
       
-      URL[] urls = new URL[Environment.sourcePath.size()];
-      int i = 0;
-      for (String path : Environment.sourcePath)
-        urls[i++] = new File(path).toURI().toURL();
-      
-      ClassLoader loader = new URLClassLoader(urls);
-      
       for (String source : sources)
       {
-        URL url = loader.getResource(source);
+        RelativePath p = ModuleSystemCommands.locateSourceFile(FileCommands.dropExtension(source));
         
-        if (url == null)
-          throw new FileNotFoundException(source);
-        
-        URI uri = url.toURI();
-        
-        allInputFiles.add(uri);
-        pendingInputFiles.add(uri);
+        allInputFiles.add(p);
+        pendingInputFiles.add(p);
       }
       
       IProgressMonitor monitor = new PrintProgressMonitor(System.out);
       
-      for (final URI source : allInputFiles) {
-        monitor.beginTask("compile " + source.getPath(), IProgressMonitor.UNKNOWN);
-        Result res = compile(source, null, monitor);
-        if (!DriverCLI.processResultCLI(res, source.getPath(), new File(".").getAbsolutePath()))
-          throw new RuntimeException("compilation of " + source.getPath() + " failed");
+      for (final RelativePath sourceFile : allInputFiles) {
+        monitor.beginTask("compile " + sourceFile, IProgressMonitor.UNKNOWN);
+        Result res = compile(sourceFile, monitor);
+        if (!DriverCLI.processResultCLI(res, sourceFile, new File(".").getAbsolutePath()))
+          throw new RuntimeException("compilation of " + sourceFile + " failed");
       }
       
     } catch (Exception e) {
@@ -1452,48 +1442,45 @@
     if (Environment.cacheDir == null)
       return;
     
-    String cacheVersion = FileCommands.findFile("version", Environment.cacheDir);
+    Path cacheVersion = new RelativePathCache("version");
     
-    if (cacheVersion == null || !FileCommands.readFileAsString(cacheVersion).equals(CACHE_VERSION)) {
-      if (cacheVersion == null)
-        cacheVersion = Environment.cacheDir + Environment.sep + "version";
-      
+    if (!cacheVersion.getFile().exists() ||
+        !FileCommands.readFileAsString(cacheVersion).equals(CACHE_VERSION)) {
+
       for (File f : new File(Environment.cacheDir).listFiles())
         f.delete();
       
       FileCommands.writeToFile(cacheVersion, CACHE_VERSION);
     }
     
-    String sdfCache = FileCommands.findFile("sdfCache", Environment.cacheDir);
-    String strCache = FileCommands.findFile("strCache", Environment.cacheDir);
+    Path sdfCache = new RelativePathCache("sdfCache");
+    Path strCache = new RelativePathCache("strCache");
     
     if (SDFCommands.sdfCache == null && sdfCache != null)
       try {
         log.log("load sdf cache from " + sdfCache);
           SDFCommands.sdfCache =
-              (ModuleKeyCache<String>) new ObjectInputStream(new FileInputStream(
-                  sdfCache)).readObject();
+              (ModuleKeyCache<Path>) new ObjectInputStream(new FileInputStream(sdfCache.getFile())).readObject();
       } 
       catch (Exception e) {
-        SDFCommands.sdfCache = new ModuleKeyCache<String>();
+        SDFCommands.sdfCache = new ModuleKeyCache<Path>();
         e.printStackTrace();
       }
     else if (SDFCommands.sdfCache == null)
-      SDFCommands.sdfCache = new ModuleKeyCache<String>();
+      SDFCommands.sdfCache = new ModuleKeyCache<Path>();
     
     if (STRCommands.strCache == null && strCache != null)
       try {
         log.log("load str cache from " + strCache);
         STRCommands.strCache =
-            (ModuleKeyCache<String>) new ObjectInputStream(new FileInputStream(
-                strCache)).readObject();
+            (ModuleKeyCache<Path>) new ObjectInputStream(new FileInputStream(strCache.getFile())).readObject();
       } 
       catch (Exception e) {
-        STRCommands.strCache = new ModuleKeyCache<String>();
+        STRCommands.strCache = new ModuleKeyCache<Path>();
         e.printStackTrace();
       }
     else if (STRCommands.strCache == null)
-      STRCommands.strCache = new ModuleKeyCache<String>();
+      STRCommands.strCache = new ModuleKeyCache<Path>();
   }
 
   
@@ -1501,37 +1488,28 @@
     if (Environment.cacheDir == null || Environment.rocache)
       return;
     
-    String cacheVersion = FileCommands.findFile("version", Environment.cacheDir);
-    if (cacheVersion == null || !FileCommands.readFileAsString(cacheVersion).equals(CACHE_VERSION)) {
-      if (cacheVersion == null)
-        cacheVersion = Environment.cacheDir + Environment.sep + "version";
-      FileCommands.writeToFile(cacheVersion, CACHE_VERSION);
-    }
+    Path cacheVersion = new RelativePathCache("version");
+    FileCommands.writeToFile(cacheVersion, CACHE_VERSION);
     
-    String sdfCache = FileCommands.findFile("sdfCache", Environment.cacheDir);
-    String strCache = FileCommands.findFile("strCache", Environment.cacheDir);
+    Path sdfCache = new RelativePathCache("sdfCache");
+    Path strCache = new RelativePathCache("strCache");
 
-    if (sdfCache == null) {
-      sdfCache = Environment.cacheDir + sep + "sdfCache";
+    if (!sdfCache.getFile().exists())
       FileCommands.createFile(sdfCache);
-    }
 
-    if (strCache == null) {
-      strCache = Environment.cacheDir + sep + "strCache";
+    if (!strCache.getFile().exists())
       FileCommands.createFile(strCache);
-    }
-    
     
     if (SDFCommands.sdfCache != null) {
       log.log("store sdf cache in " + sdfCache);
       log.log("sdf cache size: " + SDFCommands.sdfCache.size());
-      new ObjectOutputStream(new FileOutputStream(sdfCache)).writeObject(SDFCommands.sdfCache);
+      new ObjectOutputStream(new FileOutputStream(sdfCache.getFile())).writeObject(SDFCommands.sdfCache);
     }
     
     if (STRCommands.strCache != null) {
       log.log("store str cache in " + strCache);
       log.log("str cache size: " + STRCommands.strCache.size());
-      new ObjectOutputStream(new FileOutputStream(strCache)).writeObject(STRCommands.strCache);
+      new ObjectOutputStream(new FileOutputStream(strCache.getFile())).writeObject(STRCommands.strCache);
     }
   }
 
@@ -1573,7 +1551,7 @@
   private synchronized void stopIfInterrupted() throws InterruptedException {
     if (interrupt || monitor.isCanceled()) {
       monitor.setCanceled(true);
-      log.log("interrupted " + relativePath);
+      log.log("interrupted " + sourceFile);
       throw new InterruptedException();
     }
   }
@@ -1585,11 +1563,21 @@
   
   private void clearGeneratedStuff() throws IOException {
     if (driverResult.getGenerationLog() != null && FileCommands.exists(driverResult.getGenerationLog())) {
-      BufferedReader br = new BufferedReader(new FileReader(driverResult.getGenerationLog()));
-      String line;
-      while ((line = br.readLine()) != null)
-        FileCommands.delete(line);
-      br.close();
+      ObjectInputStream ois = new ObjectInputStream(new FileInputStream(driverResult.getGenerationLog().getFile()));
+      
+      try {
+        while (true) {
+          try {
+            Path p = (Path) ois.readObject();
+            FileCommands.delete(p);
+          } catch (ClassNotFoundException e) { 
+          }
+        }
+      } catch (Exception e) {
+      } finally {
+        ois.close();
+      }
+
       FileCommands.writeToFile(driverResult.getGenerationLog(), "");
     }
   }

Modified: sugarj/trunk/compiler/org/sugarj/driver/DriverCLI.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/DriverCLI.java	Sun Jun  5 15:48:36 2011	(r23001)
+++ sugarj/trunk/compiler/org/sugarj/driver/DriverCLI.java	Sun Jun  5 17:22:30 2011	(r23002)
@@ -26,6 +26,7 @@
 import org.spoofax.terms.TermVisitor;
 import org.strategoxt.HybridInterpreter;
 import org.strategoxt.imp.runtime.Environment;
+import org.sugarj.driver.path.Path;
 
 /**
  * @author Sebastian Erdweg <seba at informatik uni-marburg de>
@@ -62,7 +63,7 @@
     }
   }
   
-  static boolean processResultCLI(Result res, String file, String project) throws IOException {
+  static boolean processResultCLI(Result res, Path file, String project) throws IOException {
     log.log("");
     
     boolean success = res.getCollectedErrors().isEmpty();
@@ -76,7 +77,7 @@
     IStrategoTerm tuple = ATermCommands.makeTuple(
         tok,
         res.getSugaredSyntaxTree(), 
-        ATermCommands.makeString(file, tok), 
+        ATermCommands.makeString(file.getAbsolutePath(), tok), 
         ATermCommands.makeString(project, tok));
     
     List<Error> errors = gatherNonFatalErrors(res.getSugaredSyntaxTree());

Modified: sugarj/trunk/compiler/org/sugarj/driver/Environment.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/Environment.java	Sun Jun  5 15:48:36 2011	(r23001)
+++ sugarj/trunk/compiler/org/sugarj/driver/Environment.java	Sun Jun  5 17:22:30 2011	(r23002)
@@ -10,6 +10,8 @@
 import java.util.WeakHashMap;
 
 import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.sugarj.driver.path.Path;
+import org.sugarj.stdlib.StdLib;
 
 
 /**
@@ -19,11 +21,13 @@
  */
 public class Environment {
   
-  public static Map<String, IStrategoTerm> terms = new WeakHashMap<String, IStrategoTerm>();
+  public static Map<Path, IStrategoTerm> terms = new WeakHashMap<Path, IStrategoTerm>();
   
   public static String sep = "/";
   public static String classpathsep = File.pathSeparator;
   
+  public static String root = ".";
+  
   public static Set<String> sourcePath = new HashSet<String>();
   
   public static String bin = ".";
@@ -56,6 +60,7 @@
   
   public static void init() throws IOException {
     includePath.add(bin);
+    includePath.add(StdLib.stdLibDir.getPath());
   }
 
   private static Long tick;

Modified: sugarj/trunk/compiler/org/sugarj/driver/FileCommands.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/FileCommands.java	Sun Jun  5 15:48:36 2011	(r23001)
+++ sugarj/trunk/compiler/org/sugarj/driver/FileCommands.java	Sun Jun  5 17:22:30 2011	(r23002)
@@ -14,6 +14,10 @@
 import java.net.URL;
 import java.util.List;
 
+import org.sugarj.driver.path.AbsolutePath;
+import org.sugarj.driver.path.Path;
+import org.sugarj.driver.path.RelativePath;
+
 /**
  * Provides methods for doing stuff with files.
  * 
@@ -23,7 +27,7 @@
 
   private final static boolean DO_DELETE = false;
 
-  public static String newTempFile(String suffix) throws IOException {
+  public static Path newTempFile(String suffix) throws IOException {
     File f =
         File.createTempFile(
             "sugarj",
@@ -32,17 +36,17 @@
     if (DO_DELETE)
       f.deleteOnExit();
 
-    return f.getAbsolutePath();
+    return new AbsolutePath(f.getAbsolutePath());
   }
 
-  public static void delete(String file) throws IOException {
+  public static void delete(Path file) throws IOException {
     if (file != null)
-      new File(file).delete();
+      file.getFile().delete();
   }
 
-  public static void copyFile(String from, String to) throws IOException {
-    FileInputStream fis = new FileInputStream(from);
-    FileOutputStream fos = new FileOutputStream(to);
+  public static void copyFile(Path from, Path to) throws IOException {
+    FileInputStream fis = new FileInputStream(from.getFile());
+    FileOutputStream fos = new FileOutputStream(to.getFile());
     copyFile(fis, fos);
     fis.close();
     fos.close();
@@ -65,17 +69,17 @@
    * @param content
    * @throws IOException
    */
-  public static void writeToFile(String file, String content)
+  public static void writeToFile(Path file, String content)
       throws IOException {
     FileCommands.createFile(file);
-    FileOutputStream fos = new FileOutputStream(file);
+    FileOutputStream fos = new FileOutputStream(file.getFile());
     fos.write(content.getBytes());
     fos.close();
   }
 
-  public static void appendToFile(String file, String content)
+  public static void appendToFile(Path file, String content)
       throws IOException {
-    FileOutputStream fos = new FileOutputStream(file, true);
+    FileOutputStream fos = new FileOutputStream(file.getFile(), true);
     fos.write(content.getBytes());
     fos.close();
   }
@@ -84,9 +88,9 @@
   // Author: http://snippets.dzone.com/user/daph2001
   //
   // TODO fix legal issues
-  public static String readFileAsString(String filePath) throws IOException {
+  public static String readFileAsString(Path filePath) throws IOException {
     StringBuffer fileData = new StringBuffer(1000);
-    BufferedReader reader = new BufferedReader(new FileReader(filePath));
+    BufferedReader reader = new BufferedReader(new FileReader(filePath.getFile()));
     char[] buf = new char[1024];
     int numRead = 0;
     while ((numRead = reader.read(buf)) != -1) {
@@ -98,16 +102,16 @@
 
   
   public static String fileName(URL url) {
-    return fileName(url.getPath());
+    return fileName(new AbsolutePath(url.getPath()));
   }
   
   
   public static String fileName(URI uri) {
-    return fileName(uri.getPath());
+    return fileName(new AbsolutePath(uri.getPath()));
   }
   
-  public static String fileName(String file_doof) {
-    String file = toCygwinPath(file_doof);
+  public static String fileName(Path file_doof) {
+    String file = toCygwinPath(file_doof.getAbsolutePath());
     int index = file.lastIndexOf(sep);
 
     if (index >= 0)
@@ -130,6 +134,7 @@
    *        list of possible paths to filename
    * @return full file path to filename or null
    */
+  @Deprecated
   public static String findFile(String filename, List<String> paths) {
     return findFile(filename, paths.toArray(new String[] {}));
   }
@@ -143,6 +148,7 @@
    *        list of possible paths to filename
    * @return full file path to filename or null
    */
+  @Deprecated
   public static String findFile(String filename, String... paths) {
     for (String path : paths) {
       File f = new File(path + sep + filename);
@@ -153,7 +159,7 @@
     return null;
   }
 
-  public static String newTempDir() throws IOException {
+  public static Path newTempDir() throws IOException {
     File f = File.createTempFile("SugarJ", "");
     // need to delete the file, but want to reuse the filename
     f.delete();
@@ -162,15 +168,15 @@
     // TODO add shutdownHook to recursively delete this temporary
     // directory
 
-    return f.getAbsolutePath();
+    return new AbsolutePath(f.getAbsolutePath());
   }
 
-  public static void prependToFile(String file, String head) throws IOException {
-    File tmp = new File(newTempFile(""));
-    new File(file).renameTo(tmp);
+  public static void prependToFile(Path file, String head) throws IOException {
+    Path tmp = newTempFile("");
+    file.getFile().renameTo(tmp.getFile());
 
-    FileInputStream in = new FileInputStream(tmp);
-    FileOutputStream out = new FileOutputStream(file);
+    FileInputStream in = new FileInputStream(tmp.getFile());
+    FileOutputStream out = new FileOutputStream(file.getFile());
 
     out.write(head.getBytes());
 
@@ -182,11 +188,11 @@
 
     in.close();
     out.close();
-    delete(tmp.getAbsolutePath());
+    delete(tmp);
   }
 
-  public static void createFile(String file) throws IOException {
-    File f = new File(file);
+  public static void createFile(Path file) throws IOException {
+    File f = file.getFile();
     if (f.getParentFile().exists() || f.getParentFile().mkdirs())
       f.createNewFile();
   }
@@ -199,15 +205,14 @@
    * @return
    * @throws IOException
    */
-  public static String createFile(String dir, int hash) throws IOException {
-    String s = dir + sep + hashFileName("sugarj", hash);
-    createFile(s);
-    return s;
+  public static Path createFile(Path dir, int hash) throws IOException {
+    Path p = new RelativePath(dir, hashFileName("sugarj", hash));
+    createFile(p);
+    return p;
   }
 
-  public static void createDir(String dir) throws IOException {
-    File f = new File(dir);
-    f.mkdirs();
+  public static void createDir(Path dir) throws IOException {
+    dir.getFile().mkdirs();
   }
 
   /**
@@ -218,10 +223,10 @@
    * @return
    * @throws IOException
    */
-  public static String createDir(String dir, int hash) throws IOException {
-    String s = dir + sep + hashFileName("SugarJ", hash);
-    createDir(s);
-    return s;
+  public static Path createDir(Path dir, int hash) throws IOException {
+    Path p = new RelativePath(dir, hashFileName("SugarJ", hash));
+    createDir(p);
+    return p;
   }
 
   /**
@@ -259,43 +264,12 @@
    * 
    * @return true iff f1 was modified after f2.
    */
-  public static boolean isModifiedLater(String f1, String f2) {
-    return new File(f1).lastModified() > new File(f2).lastModified();
-  }
-
-  /**
-   * Inserts string s into the given file as the given line
-   * number.
-   * 
-   * @param s
-   * @param file
-   * @param line
-   * @throws IOException
-   */
-  public static void insert(String s, String file, int line) throws IOException {
-    StringBuilder b = new StringBuilder();
-    BufferedReader br = new BufferedReader(new FileReader(file));
-
-    String in;
-    int i = 0;
-
-    while ((in = br.readLine()) != null) {
-      i++;
-      if (i == line)
-        b.append(s).append('\n');
-
-      b.append(in).append('\n');
-    }
-
-    if (i < line)
-      b.append(s);
-
-    br.close();
-    writeToFile(file, b.toString());
+  public static boolean isModifiedLater(Path f1, Path f2) {
+    return f1.getFile().lastModified() > f2.getFile().lastModified();
   }
 
-  public static boolean exists(String file) {
-    return new File(file).exists();
+  public static boolean exists(Path file) {
+    return file.getFile().exists();
   }
   
   public static boolean exists(URI file) {
@@ -328,23 +302,11 @@
     return file;
   }
 
-  public static void trimQuotes(String file) throws IOException {
-    String s = readFileAsString(file);
-    s = s.trim();
-    
-    Log.log.log("trim: " + s);
-    
-    if (s.startsWith("\"") && s.endsWith("\"")) {
-      s = s.substring(1, s.length() - 1);
-      writeToFile(file, s);
-    }
-  }
-
   public static String getRelativeModulePath(String module) {
     return module.replace(".", sep);
   }
 
-  public static int fileHash(String file) throws IOException {
+  public static int fileHash(Path file) throws IOException {
     if (exists(file))
       return readFileAsString(file).hashCode();
     

Modified: sugarj/trunk/compiler/org/sugarj/driver/JavaCommands.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/JavaCommands.java	Sun Jun  5 15:48:36 2011	(r23001)
+++ sugarj/trunk/compiler/org/sugarj/driver/JavaCommands.java	Sun Jun  5 17:22:30 2011	(r23002)
@@ -5,6 +5,7 @@
 import java.util.Collection;
 
 import org.eclipse.jdt.core.compiler.batch.BatchCompiler;
+import org.sugarj.driver.path.Path;
 
 /**
  * 
@@ -16,11 +17,11 @@
  */
 public class JavaCommands {
 
-  public static boolean javac(String java, String dir, Collection<String> cp) throws IOException {
+  public static boolean javac(Path java, Path dir, Collection<String> cp) throws IOException {
     return javac(java, dir, cp.toArray(new String[] {}));
   }
 
-  public static boolean javac(String java, String dir, String... cp) throws IOException {
+  public static boolean javac(Path java, Path dir, String... cp) throws IOException {
     StringBuilder cpBuilder = new StringBuilder();
     
     for (int i = 0; i < cp.length; i++) {
@@ -37,10 +38,10 @@
     
     String[] cmd = new String[] {
         "-cp", cpBuilder.toString(),
-        "-d", FileCommands.toWindowsPath(dir),
+        "-d", FileCommands.toWindowsPath(dir.getAbsolutePath()),
         "-source", "1.5",
         "-nowarn",
-        FileCommands.toWindowsPath(java)
+        FileCommands.toWindowsPath(java.getAbsolutePath())
     };
     
     // this is ECJ
@@ -55,9 +56,9 @@
    * Runs a compiled java program, linking against  {@code strategoxt.jar},
    * and providing a bunch of parameters. 
    */
-  public static void java(String dir, String main, String... args) throws IOException {
+  public static void java(Path dir, String main, String... args) throws IOException {
     StringBuilder classpath = new StringBuilder();
-    classpath.append(FileCommands.toWindowsPath(dir));
+    classpath.append(FileCommands.toWindowsPath(dir.getAbsolutePath()));
     classpath.append(Environment.classpathsep);
     
     for (String path : Environment.includePath)
@@ -77,12 +78,12 @@
   }
   
   
-  public static void jar(String dir, String output) {
+  public static void jar(Path dir, Path output) {
     String[] cmd = {
         "jar",
         "cf",
-        output,
-        "-C", dir,
+        output.getAbsolutePath(),
+        "-C", dir.getAbsolutePath(),
         "."
         };
     

Modified: sugarj/trunk/compiler/org/sugarj/driver/ModuleSystemCommands.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/ModuleSystemCommands.java	Sun Jun  5 15:48:36 2011	(r23001)
+++ sugarj/trunk/compiler/org/sugarj/driver/ModuleSystemCommands.java	Sun Jun  5 17:22:30 2011	(r23002)
@@ -5,20 +5,16 @@
 import static org.sugarj.driver.Log.log;
 
 import java.io.BufferedReader;
-import java.io.File;
 import java.io.FileReader;
 import java.io.IOException;
-import java.net.MalformedURLException;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.net.URL;
-import java.net.URLClassLoader;
-import java.util.Collection;
 import java.util.Set;
 
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.strategoxt.HybridInterpreter;
-import org.sugarj.stdlib.StdLib;
+import org.sugarj.driver.path.AbsolutePath;
+import org.sugarj.driver.path.Path;
+import org.sugarj.driver.path.RelativePath;
+import org.sugarj.driver.path.RelativePathBin;
 
 /**
  * @author Sebastian Erdweg <seba at informatik uni-marburg de>
@@ -35,8 +31,8 @@
    * @return true iff a class file existed.
    * @throws IOException
    */
-  public static boolean importClass(String modulePath, IStrategoTerm importTerm, String javaOutFile, HybridInterpreter interp, Result driverResult) throws IOException {
-    URI classUri = searchFile(modulePath, ".class");
+  public static boolean importClass(String modulePath, IStrategoTerm importTerm, Path javaOutFile, HybridInterpreter interp, Result driverResult) throws IOException {
+    RelativePath classUri = searchFile(modulePath, ".class");
     if (classUri == null)
       return false;
     
@@ -59,14 +55,14 @@
    * @return path to new grammar or null if no sdf file existed.
    * @throws IOException 
    */
-  public static URI importSdf(String modulePath) throws IOException {
-    URI sdfUri = searchFile(modulePath, ".sdf");
+  public static RelativePath importSdf(String modulePath) throws IOException {
+    RelativePath sdf = searchFile(modulePath, ".sdf");
     
-    if (sdfUri == null)
+    if (sdf == null)
       return null;
     
     log.log("Found syntax definition for " + modulePath);
-    return sdfUri;
+    return sdf;
   }
   
   /**
@@ -78,14 +74,14 @@
    * @return path to new Stratego module or null of no str file existed
    * @throws IOException 
    */
-  public static URI importStratego(String modulePath) throws IOException {
-    URI strUri = searchFile(modulePath, ".str");
+  public static RelativePath importStratego(String modulePath) throws IOException {
+    RelativePath str = searchFile(modulePath, ".str");
     
-    if (strUri == null)
+    if (str == null)
       return null;
 
     log.log("Found desugaring for " + modulePath);
-    return strUri;
+    return str;
   }
   
   /**
@@ -96,14 +92,14 @@
    * @throws IOException
    */
   public static boolean importEditorServices(String modulePath, Result driverResult) throws IOException {
-    URI servUri = searchFile(modulePath, ".serv");
+    RelativePath serv = searchFile(modulePath, ".serv");
     
-    if (servUri == null)
+    if (serv == null)
       return false;
     
     log.beginTask("Incorporation", "Incorporate the imported editor services " + modulePath);
     try {
-      BufferedReader reader = new BufferedReader(new FileReader(new File(servUri)));
+      BufferedReader reader = new BufferedReader(new FileReader(serv.getFile()));
       String line;
       
       while ((line = reader.readLine()) != null)
@@ -115,11 +111,11 @@
     }
   }
   
-  public static URI locateSourceFile(String modulePath) {
+  public static RelativePath locateSourceFile(String modulePath) {
     if (modulePath.startsWith("org/sugarj"))
       return null;
     
-    URI result = searchFile(modulePath, ".sugj", Environment.sourcePath);
+    RelativePath result = searchFile(modulePath, ".sugj", Environment.sourcePath);
     
     if (result == null)
       result = searchFile(modulePath, ".java", Environment.sourcePath);
@@ -145,52 +141,35 @@
   }
 
   
-  
   /**
    * 
    * @param relativePath
    * @param fileExtension including leading "."
    * @return URI or null.
    */
-  public static URI searchFile(String relativePath, String fileExtension) {
+  public static RelativePath searchFile(String relativePath, String fileExtension) {
+    RelativePath p = searchBinFile(relativePath, fileExtension);
+    if (p != null)
+      return p;
+    
     return searchFile(relativePath, fileExtension, includePath);
   }
 
-  private static URI searchFile(String relativePath, String extension, Set<String> searchPath) {
-    URI result = null;
-    try {
-      ClassLoader cl;
-      try {
-        cl = createClassLoader(searchPath);
-      } catch (MalformedURLException e) {
-        throw new IllegalStateException("could not create class loader", e);
-      }
-      URL url = cl.getResource(relativePath + extension);
-      if (url != null)
-        result = url.toURI();
-    } catch (URISyntaxException e) {
-      e.printStackTrace();
-    }
-    
-    return result;
+  private static RelativePath searchBinFile(String relativePath, String extension) {
+    RelativePath result = new RelativePathBin(relativePath + extension);
+    if (result.getFile().exists())
+      return result;
+    
+    return null;
   }
   
-  private static ClassLoader createClassLoader(Collection<String> path) throws MalformedURLException {
-    try {
-      URL[] urls = new URL[path.size() + 1];
-      
-      int i = 0;
-      for (String include : path)
-        urls[i++] = new File(include).toURI().toURL();
-
-      urls[urls.length - 1] = new File(StdLib.stdLibDir.getPath()).toURI().toURL();
-      
-      /*
-       * we use 'null' as the parent class loader purposely, so
-       * that only the given urls are searched.
-       */
-      return new URLClassLoader(urls, null);
-    } finally {
+  private static RelativePath searchFile(String relativePath, String extension, Set<String> searchPath) {
+    for (String base : searchPath) {
+      RelativePath p = new RelativePath(new AbsolutePath(base), relativePath + extension);
+      if (p.getFile().exists())
+        return p;
     }
+    
+    return null;
   }
 }

Modified: sugarj/trunk/compiler/org/sugarj/driver/Result.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/Result.java	Sun Jun  5 15:48:36 2011	(r23001)
+++ sugarj/trunk/compiler/org/sugarj/driver/Result.java	Sun Jun  5 17:22:30 2011	(r23002)
@@ -1,11 +1,11 @@
 package org.sugarj.driver;
 
-import java.io.BufferedOutputStream;
-import java.io.BufferedReader;
+import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
-import java.io.FileReader;
 import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -16,25 +16,29 @@
 
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.jsglr.shared.BadTokenException;
+import org.sugarj.driver.path.Path;
+import org.sugarj.driver.path.RelativePath;
 
+/**
+ * @author Sebastian Erdweg <seba at informatik uni-marburg de>
+ */
 public class Result {
-  // private Map<String, Integer> fileDependencyHashes = new HashMap<String, Integer>();
-  private Map<String, Integer> dependencies = new HashMap<String, Integer>();
-  private Map<String, Integer> generatedFileHashes = new HashMap<String, Integer>();
+  private Map<Path, Integer> dependencies = new HashMap<Path, Integer>();
+  private Map<Path, Integer> generatedFileHashes = new HashMap<Path, Integer>();
   private Set<IStrategoTerm> editorServices = new HashSet<IStrategoTerm>();
   private Set<BadTokenException> collectedErrors = new HashSet<BadTokenException>();
   private IStrategoTerm sugaredSyntaxTree = null;
-  private String desugaringsFile;
-  private String sourceFile;
+  private Path desugaringsFile;
+  private RelativePath sourceFile;
   private Integer sourceFileHash;
-  private Set<String> allDependentFiles = new HashSet<String>();
+  private Set<Path> allDependentFiles = new HashSet<Path>();
   private boolean failed = false;
-  private String lastParseTable;
-  private String generationLog;
+  private Path lastParseTable;
+  private Path generationLog;
 
   private final static Result OUTDATED_RESULT = new Result() {
     @Override
-    public boolean isUpToDate(String file) {
+    public boolean isUpToDate(Path file) {
       return false;
     }
 
@@ -44,39 +48,49 @@
     }
   };
   
-  void addDependency(String depFile) throws IOException {
+  void addDependency(Path depFile) throws IOException {
     dependencies.put(depFile, FileCommands.fileHash(depFile));
     allDependentFiles.addAll(readDependencyFile(depFile).getFileDependencies());
   }
   
-  public Collection<String> getFileDependencies() throws IOException {
+  public Collection<Path> getFileDependencies() throws IOException {
     if (allDependentFiles == null) {
-      allDependentFiles = new HashSet<String>(generatedFileHashes.keySet());
-      for (String depFile : dependencies.keySet())
+      allDependentFiles = new HashSet<Path>(generatedFileHashes.keySet());
+      for (Path depFile : dependencies.keySet())
         allDependentFiles.addAll(readDependencyFile(depFile).getFileDependencies());
     }
     
     return allDependentFiles;
   }
   
-  void setGenerationLog(String file) {
+  void setGenerationLog(Path file) {
     this.generationLog = file;
   }
   
-  String getGenerationLog() {
+  Path getGenerationLog() {
     return generationLog;
   }
   
-  void generateFile(String file, String content) throws IOException {
+  void generateFile(Path file, String content) throws IOException {
     FileCommands.writeToFile(file, content);
     generatedFileHashes.put(file, FileCommands.fileHash(file));
     allDependentFiles.add(file);
     
-    if (generationLog != null)
-      FileCommands.appendToFile(generationLog, file + "\n");
+    logGeneration(file);
   }
   
-  void appendToFile(String file, String content) throws IOException {
+  private void logGeneration(Object o) throws IOException {
+    if (generationLog != null) {
+      ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(generationLog.getFile(), true));
+      try {
+        oos.writeObject(o);
+      } finally {
+        oos.close();
+      }
+    }
+  }
+  
+  void appendToFile(Path file, String content) throws IOException {
     FileCommands.appendToFile(file, content);
     generatedFileHashes.put(file, FileCommands.fileHash(file));
   }
@@ -89,7 +103,7 @@
     return editorServices;
   }
   
-  public boolean isUpToDate(String inputFile) throws IOException {
+  public boolean isUpToDate(Path inputFile) throws IOException {
     return isUpToDate(FileCommands.fileHash(inputFile));
   }
   
@@ -97,11 +111,11 @@
     if (inputHash != sourceFileHash)
       return false;
     
-    for (Entry<String, Integer> entry : generatedFileHashes.entrySet())
+    for (Entry<Path, Integer> entry : generatedFileHashes.entrySet())
       if (FileCommands.fileHash(entry.getKey()) != entry.getValue())
         return false;
 
-    for (Entry<String, Integer> entry : dependencies.entrySet()) {
+    for (Entry<Path, Integer> entry : dependencies.entrySet()) {
       if (FileCommands.fileHash(entry.getKey()) != entry.getValue())
         return false;
       
@@ -129,93 +143,94 @@
     return sugaredSyntaxTree;
   }
 
-  void compileJava(String javaOutFile, String bin, List<String> path, List<String> generatedJavaClasses) throws IOException {
+  void compileJava(Path javaOutFile, Path bin, List<String> path, List<Path> generatedJavaClasses) throws IOException {
     JavaCommands.javac(javaOutFile, bin, path);
-    for (String cl : generatedJavaClasses)
+    for (Path cl : generatedJavaClasses)
       generatedFileHashes.put(cl, FileCommands.fileHash(cl));
   }
   
-  void registerEditorDesugarings(String jarfile) throws IOException {
+  void registerEditorDesugarings(Path jarfile) throws IOException {
     desugaringsFile = jarfile;
     editorServices = new HashSet<IStrategoTerm>(ATermCommands.registerSemanticProvider(editorServices, jarfile));
   }
   
-  String getDesugaringsFile() {
+  Path getDesugaringsFile() {
     return desugaringsFile;
   }
   
-  void writeDependencyFile(String dep) throws IOException {
-    if (generationLog != null)
-      FileCommands.appendToFile(generationLog, dep + "\n");
+  void writeDependencyFile(Path dep) throws IOException {
+    logGeneration(dep);
 
-    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(dep));
+    ObjectOutputStream oos = null;
     
     try {
-      byte[] newline = "\n".getBytes();
+      oos = new ObjectOutputStream(new FileOutputStream(dep.getFile()));
+
+      oos.writeObject(sourceFile);
+      oos.writeInt(sourceFileHash);
       
-      out.write(sourceFile.getBytes());
-      out.write(newline);
-      out.write(Integer.toString(sourceFileHash).getBytes());
-      out.write(newline);
-      
-      for (Entry<String, Integer> entry : dependencies.entrySet()) {
-        out.write(entry.getKey().getBytes());
-        out.write(newline);
-        out.write(Integer.toString(entry.getValue()).getBytes());
-        out.write(newline);
+      oos.writeInt(dependencies.size());
+      for (Entry<Path, Integer> e : dependencies.entrySet()) {
+        oos.writeObject(e.getKey());
+        oos.writeInt(e.getValue());
       }
       
-      out.write(newline);
-      
-      for (Entry<String, Integer> e : generatedFileHashes.entrySet()) {
-        out.write(e.getKey().getBytes());
-        out.write(newline);
-        out.write(e.getValue().toString().getBytes());
-        out.write(newline);
+      oos.writeInt(generatedFileHashes.size());
+      for (Entry<Path, Integer> e : generatedFileHashes.entrySet()) {
+        oos.writeObject(e.getKey());
+        oos.writeInt(e.getValue());
       }
     } finally {
-      out.close();
+      if (oos != null)
+        oos.close();
     }
   }
   
-  static Result readDependencyFile(String dep) throws IOException {
+  static Result readDependencyFile(Path dep) throws IOException {
     Result result = new Result();
     result.allDependentFiles = null;
+    ObjectInputStream ois = null;
     
     try {
-      BufferedReader in = new BufferedReader(new FileReader(dep));
+      ois = new ObjectInputStream(new FileInputStream(dep.getFile()));
       
-      result.sourceFile = in.readLine();
-      result.sourceFileHash = Integer.parseInt(in.readLine());
+      result.sourceFile = (RelativePath) ois.readObject();
+      result.sourceFileHash = ois.readInt();
       
-      String line;
-      while ((line = in.readLine()) != null && !line.isEmpty()) {
-        String file = line;
-        Integer hash = Integer.parseInt(in.readLine());
+      int numDependencies = ois.readInt();
+      for (int i = 0; i < numDependencies; i++) {
+        Path file = (Path) ois.readObject();
+        int hash = ois.readInt();
         result.dependencies.put(file, hash);
       }
       
-      while ((line = in.readLine()) != null && !line.isEmpty()) {
-        String file = line;
-        Integer hash = Integer.parseInt(in.readLine());
+      int numGeneratedFiles = ois.readInt();
+      for (int i = 0; i< numGeneratedFiles; i++) {
+        Path file = (Path) ois.readObject();
+        int hash = ois.readInt();
         result.generatedFileHashes.put(file, hash);
       }
     } catch (FileNotFoundException e) {
       return OUTDATED_RESULT;
+    } catch (ClassNotFoundException e) {
+      throw new IllegalStateException(e);
     } catch (Exception e) {
       e.printStackTrace();
       return OUTDATED_RESULT;
+    } finally {
+      if (ois != null)
+        ois.close();
     }
     
     return result;
   }
   
-  void setSourceFile(String sourceFile, int sourceFileHash) {
+  void setSourceFile(RelativePath sourceFile, int sourceFileHash) {
     this.sourceFile = sourceFile;
     this.sourceFileHash = sourceFileHash;
   }
 
-  public String getSourceFile() {
+  public RelativePath getSourceFile() {
     return sourceFile;
   }
   
@@ -227,11 +242,11 @@
     this.failed = hasFailed;
   }
   
-  public void setLastParseTable(String parseTable) {
+  public void setLastParseTable(Path parseTable) {
     this.lastParseTable = parseTable;
   }
   
-  public String getLastParseTable() {
+  public Path getLastParseTable() {
     return lastParseTable;
   }
 }
\ No newline at end of file

Modified: sugarj/trunk/compiler/org/sugarj/driver/SDFCommands.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/SDFCommands.java	Sun Jun  5 15:48:36 2011	(r23001)
+++ sugarj/trunk/compiler/org/sugarj/driver/SDFCommands.java	Sun Jun  5 17:22:30 2011	(r23002)
@@ -38,6 +38,8 @@
 import org.strategoxt.tools.main_pack_sdf_0_0;
 import org.sugarj.driver.caching.ModuleKey;
 import org.sugarj.driver.caching.ModuleKeyCache;
+import org.sugarj.driver.path.Path;
+import org.sugarj.driver.path.RelativePathCache;
 import org.sugarj.stdlib.StdLib;
 
 /**
@@ -64,9 +66,9 @@
     }
   }
   
-  public static ModuleKeyCache<String> sdfCache = null;
+  public static ModuleKeyCache<Path> sdfCache = null;
   
-  private static void packSdf(String sdf, String def, Context sdfContext) throws IOException {
+  private static void packSdf(Path sdf, Path def, Context sdfContext) throws IOException {
     
     /*
      * We can include as many paths as we want here, checking the
@@ -74,8 +76,8 @@
      */
     List<String> cmd = new ArrayList<String>(Arrays.asList(new String[] {
 //      PACK_SDF,
-      "-i", sdf,
-      "-o", def,
+      "-i", sdf.getAbsolutePath(),
+      "-o", def.getAbsolutePath(),
       "-Idef", StdLib.sugarjDef.getPath(),
       "-Idef", StdLib.javaDef.getPath(),
       "-Idef", StdLib.sdfDef.getPath(),
@@ -99,27 +101,27 @@
       }
     }
     
-    if (!new File(def).exists())
+    if (!def.getFile().exists())
       throw new RuntimeException("execution of pack-sdf failed");
   }
   
-  private static void sdf2Table(String def, String tbl, String module) throws IOException {
+  private static void sdf2Table(Path def, Path tbl, String module) throws IOException {
     sdf2Table(def, tbl, module, false);
   }
   
-  private static void sdf2Table(String def, String tbl, String module, boolean normalize) throws IOException {
+  private static void sdf2Table(Path def, Path tbl, String module, boolean normalize) throws IOException {
     String[] cmd; 
     
     if (!normalize)
       cmd = new String[] {
-        "-i", toCygwinPath(def),
-        "-o", toCygwinPath(tbl),
+        "-i", toCygwinPath(def.getAbsolutePath()),
+        "-o", toCygwinPath(tbl.getAbsolutePath()),
         "-m", module
       };
     else
       cmd = new String[] {
-        "-i", toCygwinPath(def),
-        "-o", toCygwinPath(tbl),
+        "-i", toCygwinPath(def.getAbsolutePath()),
+        "-o", toCygwinPath(tbl.getAbsolutePath()),
         "-m", module,
         "-n"
       };
@@ -132,16 +134,16 @@
     SDFBundleCommand.getInstance().init();
     SDFBundleCommand.getInstance().invoke(context, "sdf2table", termArgs);
     
-    if (!new File(tbl).exists())
+    if (!tbl.getFile().exists())
       throw new RuntimeException("execution of sdf2table failed");
   }
 
-  private static void normalizeTable(String def, String module) throws IOException {
+  private static void normalizeTable(Path def, String module) throws IOException {
     sdf2Table(def, FileCommands.newTempFile("tbl"), module, true);
   }
   
-  public static void check(String sdf, String module, Context sdfContext) throws IOException {
-    String def = FileCommands.newTempFile("def");
+  public static void check(Path sdf, String module, Context sdfContext) throws IOException {
+    Path def = FileCommands.newTempFile("def");
     packSdf(sdf, def, sdfContext);
     normalizeTable(def, module);
   }
@@ -155,10 +157,10 @@
    * @throws BadTokenException 
    * @throws TokenExpectedException 
    */
-  public static String compile(String sdf, String module, Collection<String> dependentFiles, JSGLRI sdfParser, Context sdfContext, Context makePermissiveContext) throws IOException,
+  public static Path compile(Path sdf, String module, Collection<Path> dependentFiles, JSGLRI sdfParser, Context sdfContext, Context makePermissiveContext) throws IOException,
       InvalidParseTableException, TokenExpectedException, BadTokenException, SGLRException {
     ModuleKey key = getModuleKeyForGrammar(sdf, module, dependentFiles, sdfParser);
-    String tbl = lookupGrammarInCache(key);
+    Path tbl = lookupGrammarInCache(key);
     if (tbl == null) {
       tbl = generateParseTable(key, sdf, module, sdfContext, makePermissiveContext);
       cacheParseTable(key, tbl);
@@ -171,15 +173,15 @@
   }
   
   
-  private static void cacheParseTable(ModuleKey key, String tbl) throws IOException {
+  private static void cacheParseTable(ModuleKey key, Path tbl) throws IOException {
     if (sdfCache == null || Environment.cacheDir == null)
       return;
     
     log.beginTask("Caching", "Cache parse table");
     try {
-      String cacheTbl = Environment.cacheDir + Environment.sep + new File(tbl).getName();
+      Path cacheTbl = new RelativePathCache(tbl.getFile().getName());
       FileCommands.copyFile(tbl, cacheTbl);
-      String oldTbl = sdfCache.putGet(key, cacheTbl);
+      Path oldTbl = sdfCache.putGet(key, cacheTbl);
       FileCommands.delete(oldTbl);
 
       if (CommandExecution.CACHE_INFO)
@@ -189,17 +191,17 @@
     }
   }
 
-  private static String lookupGrammarInCache(ModuleKey key) {
+  private static Path lookupGrammarInCache(ModuleKey key) {
     if (sdfCache == null)
       return null;
     
-    String result = null;
+    Path result = null;
     
     log.beginTask("Searching", "Search parse table in cache");
     try {
       result = sdfCache.get(key);
       
-      if (result == null || !new File(result).exists())
+      if (result == null || !result.getFile().exists())
         return null;
 
       if (CommandExecution.CACHE_INFO)
@@ -211,18 +213,18 @@
     }
   }
   
-  private static ModuleKey getModuleKeyForGrammar(String sdf, String module, Collection<String> dependentFiles, JSGLRI parser) throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, SGLRException {
+  private static ModuleKey getModuleKeyForGrammar(Path sdf, String module, Collection<Path> dependentFiles, JSGLRI parser) throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, SGLRException {
     log.beginTask("Generating", "Generate module key for current grammar");
     try {
-      IStrategoTerm aterm = parser.parse(new FileInputStream(sdf), sdf);
+      IStrategoTerm aterm = parser.parse(new FileInputStream(sdf.getFile()), sdf.getAbsolutePath());
 
       IStrategoTerm imports = ATermCommands.getApplicationSubterm(aterm, "module", 1);
       IStrategoTerm body = ATermCommands.getApplicationSubterm(aterm, "module", 2);
       IStrategoTerm term = ATermCommands.makeTuple(imports, body);
 
-      LinkedList<String> depList = new LinkedList<String>();
-      for (String file : dependentFiles)
-        if (SDF_FILE_PATTERN.matcher(file).matches())
+      LinkedList<Path> depList = new LinkedList<Path>();
+      for (Path file : dependentFiles)
+        if (SDF_FILE_PATTERN.matcher(file.getAbsolutePath()).matches())
           depList.add(file);
       
       return new ModuleKey(depList, term);
@@ -233,19 +235,19 @@
     }
   }
 
-  private static String generateParseTable(ModuleKey key,
-                                           String sdf,
-                                           String module,
-                                           Context sdfContext,
-                                           Context makePermissiveContext)
+  private static Path generateParseTable(ModuleKey key,
+                                         Path sdf,
+                                         String module,
+                                         Context sdfContext,
+                                         Context makePermissiveContext)
       throws IOException, InvalidParseTableException {
     log.beginTask("Generating", "Generate the parse table");
     try {
-      String tblFile = null;
+      Path tblFile = null;
       
       tblFile = FileCommands.newTempFile("tbl");
 
-      String def = FileCommands.newTempFile("def");
+      Path def = FileCommands.newTempFile("def");
       packSdf(sdf, def, sdfContext);
       sdf2Table(def, tblFile, module);
       return tblFile;
@@ -255,8 +257,8 @@
   }
   
   public static String makePermissiveSdf(String source, Context context) throws IOException {
-    String def = FileCommands.newTempFile("def");
-    String permissiveDef = FileCommands.newTempFile("def-permissive");
+    Path def = FileCommands.newTempFile("def");
+    Path permissiveDef = FileCommands.newTempFile("def-permissive");
     
     FileCommands.writeToFile(def, sdfToDef(source));
     makePermissive(def, permissiveDef, context);
@@ -264,10 +266,10 @@
     return defToSdf(FileCommands.readFileAsString(permissiveDef)); // drop "definition\n"
   }
   
-  private static void makePermissive(String def, String permissiveDef, Context context) throws IOException {
-    log.beginExecution("make permissive", "-i", def, "-o", permissiveDef);
+  private static void makePermissive(Path def, Path permissiveDef, Context context) throws IOException {
+    log.beginExecution("make permissive", "-i", def.getAbsolutePath(), "-o", permissiveDef.getAbsolutePath());
     try {
-      make_permissive.mainNoExit(context, "-i", def, "-o", permissiveDef);
+      make_permissive.mainNoExit(context, "-i", def.getAbsolutePath(), "-o", permissiveDef.getAbsolutePath());
     }
     catch (StrategoExit e) {
       if (e.getValue() != 0) {
@@ -343,10 +345,10 @@
 //  }
   
   public static IStrategoTerm parseImplode(ParseTable table, String source, String start, boolean binary, ITreeBuilder treeBuilder, JSGLRI parser) throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, SGLRException {
-    return parseImplode(table, "unknown", source, start, binary, treeBuilder, parser);
+    return parseImplode(table, null, source, start, binary, treeBuilder, parser);
   }
   
-  private static IStrategoTerm parseImplode(ParseTable table, String tbl, String source, String start, boolean binary, ITreeBuilder treeBuilder, JSGLRI parser) throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, SGLRException {
+  private static IStrategoTerm parseImplode(ParseTable table, Path tbl, String source, String start, boolean binary, ITreeBuilder treeBuilder, JSGLRI parser) throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, SGLRException {
     log.beginExecution("parsing", "parsing source using table " + tbl);
 
     IStrategoTerm result = null;
@@ -357,10 +359,10 @@
       if (result != null)
         log.endTask();
       else {
-        String sourceFile = FileCommands.newTempFile("");
+        Path sourceFile = FileCommands.newTempFile("");
         FileCommands.writeToFile(sourceFile, source.toString());
         log.endTask("failed: " + 
-            log.commandLineAsString(new String[] {"jsglri", "-p", tbl, "-i " + sourceFile + "-s", start}));
+            log.commandLineAsString(new String[] {"jsglri", "-p", tbl.getAbsolutePath(), "-i " + sourceFile + "-s", start}));
       }
     }
     

Modified: sugarj/trunk/compiler/org/sugarj/driver/STRCommands.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/STRCommands.java	Sun Jun  5 15:48:36 2011	(r23001)
+++ sugarj/trunk/compiler/org/sugarj/driver/STRCommands.java	Sun Jun  5 17:22:30 2011	(r23002)
@@ -28,6 +28,9 @@
 import org.strategoxt.strj.main_strj_0_0;
 import org.sugarj.driver.caching.ModuleKey;
 import org.sugarj.driver.caching.ModuleKeyCache;
+import org.sugarj.driver.path.Path;
+import org.sugarj.driver.path.RelativePath;
+import org.sugarj.driver.path.RelativePathCache;
 import org.sugarj.stdlib.StdLib;
 
 /**
@@ -40,14 +43,14 @@
 public class STRCommands {
   
   
-  public static ModuleKeyCache<String> strCache = null;
+  public static ModuleKeyCache<Path> strCache = null;
   
   private final static Pattern STR_FILE_PATTERN = Pattern.compile(".*\\.str");
 
   /**
    *  Compiles a {@code *.str} file to a single {@code *.java} file. 
    */
-  private static void strj(String str, String java, String main, Context strjContext) throws IOException {
+  private static void strj(Path str, Path java, String main, Context strjContext) throws IOException {
     
     /*
      * We can include as many paths as we want here, checking the
@@ -56,8 +59,8 @@
     
     
     List<String> cmd = new ArrayList<String>(Arrays.asList(new String[] {
-        "-i", toWindowsPath(str),
-        "-o", toWindowsPath(java),
+        "-i", toWindowsPath(str.getAbsolutePath()),
+        "-o", toWindowsPath(java.getAbsolutePath()),
         "-m", main,
         "-I", StdLib.stdLibDir.getPath(),
         "-p", "sugarj",
@@ -87,9 +90,9 @@
   }
   
   
-  public static String compile(String str, String main, Collection<String> dependentFiles, JSGLRI strParser, Context strjContext) throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, SGLRException {
+  public static Path compile(Path str, String main, Collection<Path> dependentFiles, JSGLRI strParser, Context strjContext) throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, SGLRException {
     ModuleKey key = getModuleKeyForAssimilation(str, main, dependentFiles, strParser);
-    String prog = lookupAssimilationInCache(key);
+    Path prog = lookupAssimilationInCache(key);
     
     if (prog == null) {
       prog = generateAssimilator(key, str, main, strjContext);
@@ -98,22 +101,22 @@
     return prog;
   }
     
-  private static String generateAssimilator(ModuleKey key,
-                                            String str,
-                                            String main,
-                                            Context strjContext) throws IOException {
+  private static Path generateAssimilator(ModuleKey key,
+                                          Path str,
+                                          String main,
+                                          Context strjContext) throws IOException {
     log.beginTask("Generating", "Generate the assimilator");
     try {
-      String dir = FileCommands.newTempDir();
-      FileCommands.createDir(dir + sep + "sugarj");
+      Path dir = FileCommands.newTempDir();
+      FileCommands.createDir(new RelativePath(dir, "sugarj"));
       String javaFilename = FileCommands.fileName(str).replace("-", "_");
-      String java = dir + sep + "sugarj" + sep + javaFilename + ".java";
+      Path java = new RelativePath(dir, "sugarj" + sep + javaFilename + ".java");
       strj(str, java, main, strjContext);
       
       if (!JavaCommands.javac(java, dir, Environment.includePath))
         throw new RuntimeException("java compilation failed");
         
-      String jarfile = FileCommands.newTempFile("jar");
+      Path jarfile = FileCommands.newTempFile("jar");
       JavaCommands.jar(dir, jarfile);
 
       FileCommands.delete(java);
@@ -124,16 +127,16 @@
     }
   }
     
-  private static void cacheAssimilator(ModuleKey key, String prog) throws IOException {
+  private static void cacheAssimilator(ModuleKey key, Path prog) throws IOException {
     if (strCache == null || Environment.cacheDir == null)
       return;
     
 
     log.beginTask("Caching", "Cache assimilator");
     try {
-      String cacheProg = Environment.cacheDir + Environment.sep + new File(prog).getName();
+      Path cacheProg = new RelativePathCache(prog.getFile().getName());
       FileCommands.copyFile(prog, cacheProg);
-      String oldProg = strCache.putGet(key, cacheProg);
+      Path oldProg = strCache.putGet(key, cacheProg);
       FileCommands.delete(oldProg);
 
       if (CommandExecution.CACHE_INFO)
@@ -143,17 +146,17 @@
     }
   }
   
-  private static String lookupAssimilationInCache(ModuleKey key) {
+  private static Path lookupAssimilationInCache(ModuleKey key) {
     if (strCache == null)
       return null;
     
-    String result = null;
+    Path result = null;
     
     log.beginTask("Searching", "Search assimilator in cache");
     try {
       result = strCache.get(key);
       
-      if (result == null || !new File(result).exists())
+      if (result == null || !result.getFile().exists())
         return null;
 
       if (CommandExecution.CACHE_INFO)
@@ -166,16 +169,16 @@
   }
 
 
-  private static ModuleKey getModuleKeyForAssimilation(String str, String main, Collection<String> dependentFiles, JSGLRI strParser) throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, SGLRException {
+  private static ModuleKey getModuleKeyForAssimilation(Path str, String main, Collection<Path> dependentFiles, JSGLRI strParser) throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, SGLRException {
     log.beginTask("Generating", "Generate module key for current assimilation");
     try {
-      IStrategoTerm aterm = strParser.parse(new BufferedInputStream(new FileInputStream(str)), str);
+      IStrategoTerm aterm = strParser.parse(new BufferedInputStream(new FileInputStream(str.getFile())), str.getAbsolutePath());
 
       aterm = ATermCommands.getApplicationSubterm(aterm, "Module", 1);
 
-      LinkedList<String> depList = new LinkedList<String>();
-      for (String file : dependentFiles)
-        if (STR_FILE_PATTERN.matcher(file).matches())
+      LinkedList<Path> depList = new LinkedList<Path>();
+      for (Path file : dependentFiles)
+        if (STR_FILE_PATTERN.matcher(file.getAbsolutePath()).matches())
           depList.add(file);
       
       return new ModuleKey(depList, aterm);
@@ -187,14 +190,14 @@
     
   }
 
-  public static IStrategoTerm assimilate(String jarfile, IStrategoTerm in, HybridInterpreter interp) throws IOException {
+  public static IStrategoTerm assimilate(Path jarfile, IStrategoTerm in, HybridInterpreter interp) throws IOException {
     return assimilate("internal-main", jarfile, in, interp);
   }
   
-  public static IStrategoTerm assimilate(String strategy, String jarfile, IStrategoTerm in, HybridInterpreter interp) throws IOException {
+  public static IStrategoTerm assimilate(String strategy, Path jarfile, IStrategoTerm in, HybridInterpreter interp) throws IOException {
     try {
       HybridInterpreter newInterp = new HybridInterpreter(interp);
-      newInterp.loadJars(new File(jarfile).toURI().toURL());
+      newInterp.loadJars(jarfile.getFile().toURI().toURL());
       newInterp.setCurrent(in);
       
       if (newInterp.invoke(strategy)) {

Modified: sugarj/trunk/compiler/org/sugarj/driver/caching/Cache.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/caching/Cache.java	Sun Jun  5 15:48:36 2011	(r23001)
+++ sugarj/trunk/compiler/org/sugarj/driver/caching/Cache.java	Sun Jun  5 17:22:30 2011	(r23002)
@@ -2,6 +2,8 @@
 
 import java.io.Serializable;
 import java.util.HashMap;
+import java.util.Map.Entry;
+import java.util.Set;
 
 import org.sugarj.driver.Environment;
 
@@ -41,4 +43,8 @@
   public int size() {
     return cache.size();
   }
+  
+  public Set<Entry<K, V>> entrySet() {
+    return cache.entrySet();
+  }
 }

Modified: sugarj/trunk/compiler/org/sugarj/driver/caching/ModuleKey.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/caching/ModuleKey.java	Sun Jun  5 15:48:36 2011	(r23001)
+++ sugarj/trunk/compiler/org/sugarj/driver/caching/ModuleKey.java	Sun Jun  5 17:22:30 2011	(r23002)
@@ -11,6 +11,7 @@
 
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.sugarj.driver.FileCommands;
+import org.sugarj.driver.path.Path;
 
 /**
  * The key of some SDF module as needed for caching.
@@ -25,7 +26,7 @@
 public class ModuleKey implements Externalizable {
 
   private boolean checkGet;
-  public Map<String, Integer> imports;
+  public Map<Path, Integer> imports;
   public String body;
   
   /**
@@ -33,14 +34,14 @@
    */
   public ModuleKey() {}
   
-  public ModuleKey(Collection<String> dependentFiles, IStrategoTerm module) throws IOException {
-    this.imports = new HashMap<String, Integer>();
+  public ModuleKey(Collection<Path> dependentFiles, IStrategoTerm module) throws IOException {
+    this.imports = new HashMap<Path, Integer>();
     
     StringBuffer buf = new StringBuffer();
     module.writeAsString(buf, Integer.MAX_VALUE);
     this.body = buf.toString();
     
-    for (String file : dependentFiles)
+    for (Path file : dependentFiles)
       imports.put(file, FileCommands.fileHash(file));
   }
   
@@ -59,10 +60,10 @@
 
   @Override
   public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
-    imports = new HashMap<String, Integer>();
+    imports = new HashMap<Path, Integer>();
     int entries = in.readInt();
     for (int i = 0; i < entries; i++) {
-      imports.put((String) in.readObject(), in.readInt());
+      imports.put((Path) in.readObject(), in.readInt());
     }
     
     body = (String) in.readObject();
@@ -71,7 +72,7 @@
   @Override
   public void writeExternal(ObjectOutput out) throws IOException {
     out.writeInt(imports.size());
-    for (Entry<String, Integer> entry : imports.entrySet()) {
+    for (Entry<Path, Integer> entry : imports.entrySet()) {
       out.writeObject(entry.getKey());
       out.writeInt(entry.getValue());
     }

Added: sugarj/trunk/compiler/org/sugarj/driver/path/AbsolutePath.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sugarj/trunk/compiler/org/sugarj/driver/path/AbsolutePath.java	Sun Jun  5 17:22:30 2011	(r23002)
@@ -0,0 +1,24 @@
+package org.sugarj.driver.path;
+
+import org.sugarj.driver.Environment;
+
+/**
+ * @author Sebastian Erdweg <seba at informatik uni-marburg de>
+ */
+public class AbsolutePath extends Path {
+  private static final long serialVersionUID = 5295721717436544187L;
+
+  private String path;
+  
+  public AbsolutePath(String path) {
+    while (path.endsWith(Environment.sep))
+      path = path.substring(0, path.length() - 1);
+    
+    this.path = path;
+  }
+  
+  @Override
+  public String getAbsolutePath() {
+    return path;
+  }
+}

Added: sugarj/trunk/compiler/org/sugarj/driver/path/Path.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sugarj/trunk/compiler/org/sugarj/driver/path/Path.java	Sun Jun  5 17:22:30 2011	(r23002)
@@ -0,0 +1,29 @@
+package org.sugarj.driver.path;
+
+import java.io.File;
+import java.io.Serializable;
+
+/**
+ * @author Sebastian Erdweg <seba at informatik uni-marburg de>
+ */
+public abstract class Path implements Serializable {
+  private static final long serialVersionUID = -5782096855791671291L;
+
+  public abstract String getAbsolutePath();
+  
+  public File getFile() {
+    return new File(getAbsolutePath());
+  }
+  
+  public String toString() {
+    return getAbsolutePath();
+  }
+  
+  public int hashCode() {
+    return getAbsolutePath().hashCode();
+  }
+  
+  public boolean equals(Object o) {
+    return o instanceof Path && ((Path) o).getAbsolutePath().equals(getAbsolutePath());
+  }
+}

Added: sugarj/trunk/compiler/org/sugarj/driver/path/RelativePath.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sugarj/trunk/compiler/org/sugarj/driver/path/RelativePath.java	Sun Jun  5 17:22:30 2011	(r23002)
@@ -0,0 +1,42 @@
+package org.sugarj.driver.path;
+
+import org.sugarj.driver.Environment;
+
+/**
+ * @author Sebastian Erdweg <seba at informatik uni-marburg de>
+ */
+public class RelativePath extends Path {
+  private static final long serialVersionUID = -3853468843909929534L;
+  
+  private final String relativePath;
+  private Path base;
+    
+  public RelativePath(String relativePath) {
+    this.relativePath = relativePath;
+  }
+  
+  public RelativePath(Path base, String relativePath) {
+    this.relativePath = relativePath;
+    this.base = base;
+  }
+  
+  public String getRelativePath() {
+    return relativePath;
+  }
+  
+  public void setBasePath(Path base) {
+    this.base = base;
+  }
+  
+  public Path getBasePath() {
+    return base;
+  }
+
+  @Override
+  public String getAbsolutePath() {
+    if (getBasePath() == null)
+      throw new IllegalStateException("Base of relative path is still open; cannot construct absolute path yet.");
+      
+    return getBasePath() + Environment.sep + getRelativePath();
+  }
+}

Added: sugarj/trunk/compiler/org/sugarj/driver/path/RelativePathBin.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sugarj/trunk/compiler/org/sugarj/driver/path/RelativePathBin.java	Sun Jun  5 17:22:30 2011	(r23002)
@@ -0,0 +1,20 @@
+package org.sugarj.driver.path;
+
+import org.sugarj.driver.Environment;
+
+/**
+ * @author Sebastian Erdweg <seba at informatik uni-marburg de>
+ */
+public class RelativePathBin extends RelativePath {
+  private static final long serialVersionUID = -58074597968703177L;
+
+  public RelativePathBin(String relativePath) {
+    super(relativePath);
+  }
+  
+  @Override
+  public Path getBasePath() {
+    return new AbsolutePath(Environment.bin);
+  }
+
+}

Added: sugarj/trunk/compiler/org/sugarj/driver/path/RelativePathCache.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sugarj/trunk/compiler/org/sugarj/driver/path/RelativePathCache.java	Sun Jun  5 17:22:30 2011	(r23002)
@@ -0,0 +1,19 @@
+package org.sugarj.driver.path;
+
+import org.sugarj.driver.Environment;
+
+/**
+ * @author Sebastian Erdweg <seba at informatik uni-marburg de>
+ */
+public class RelativePathCache extends RelativePath {
+  private static final long serialVersionUID = -6512026699902719579L;
+
+  public RelativePathCache(String relativePath) {
+    super(relativePath);
+  }
+  
+  @Override
+  public Path getBasePath() {
+    return new AbsolutePath(Environment.cacheDir);
+  }
+}

Modified: sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParser.java
==============================================================================
--- sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParser.java	Sun Jun  5 15:48:36 2011	(r23001)
+++ sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParser.java	Sun Jun  5 17:22:30 2011	(r23002)
@@ -29,6 +29,9 @@
 import org.sugarj.driver.FileCommands;
 import org.sugarj.driver.Log;
 import org.sugarj.driver.Result;
+import org.sugarj.driver.path.AbsolutePath;
+import org.sugarj.driver.path.Path;
+import org.sugarj.driver.path.RelativePath;
 
 /**
  * @author Sebastian Erdweg <seba at informatik uni-marburg de>
@@ -39,12 +42,11 @@
   private String outputPath;
   private List<String> includePath;
   private List<String> sourcePath;
-  private boolean justReturn;
   
   private static Map<String, Result> results = new HashMap<String, Result>();
   private Result result;
   private JSGLRI parser;
-  private String parserTable;
+  private Path parserTable;
   
   public SugarJParser(JSGLRI parser) {
     super(parser.getParseTable(), parser.getStartSymbol(), parser.getController());
@@ -57,19 +59,15 @@
     
     result = getResult(filename);
 
-    if (result instanceof PendingResult)
-      setJustReturn(false);
-    else if (doJustReturn() && result.isUpToDate(input.hashCode())) {
-      setJustReturn(false);
+    if (result != null && result.isUpToDate(input.hashCode()))
       return result.getSugaredSyntaxTree();
-    }
-    else 
+    else if (result == null || !(result instanceof PendingResult)) 
       scheduleParse(input, filename);
         
     if (result == null)
       return null;
     
-    String lastParseTable;
+    Path lastParseTable;
     
     if (result instanceof PendingResult)
       lastParseTable = ((PendingResult) result).getResult().getLastParseTable();
@@ -81,7 +79,7 @@
     
     if (lastParseTable != null) {
       try {
-        ParseTable parseTable = org.strategoxt.imp.runtime.Environment.loadParseTable(lastParseTable);
+        ParseTable parseTable = org.strategoxt.imp.runtime.Environment.loadParseTable(lastParseTable.getAbsolutePath());
         ITreeBuilder builder = new TreeBuilder(new TermTreeFactory(ATermCommands.factory));
         
         parser = new JSGLRI(parseTable, "SugarCompilationUnit");
@@ -116,10 +114,8 @@
           org.strategoxt.imp.runtime.Environment.logException(e);
         } finally {
           monitor.done();
-          if (result != null) {
-            setJustReturn(true);
+          if (result != null)
             getController().scheduleParserUpdate(0, false);
-          } 
           else
             putResult(filename, oldResult);
         }
@@ -140,6 +136,7 @@
     Environment.sourcePath.addAll(sourcePath);
     
     assert projectPath != null;
+    Environment.root = projectPath;
     Environment.bin = outputPath != null ? outputPath : projectPath;
 
     if (Environment.cacheDir == null)
@@ -162,12 +159,12 @@
     SugarJConsole.activateConsoleOnce();
     
     try {
-      return Driver.compile(input, projectRelativePath(filename), filename, monitor);
+      return Driver.compile(input, projectRelativePath(filename), monitor);
     } catch (InterruptedException e) {
       throw e;
     } catch (Exception e) {
       e.printStackTrace();
-      throw new RuntimeException("parsing " + FileCommands.fileName(filename) + " failed", e);
+      throw new RuntimeException("parsing " + FileCommands.fileName(new AbsolutePath(filename)) + " failed", e);
     }
   }
   
@@ -199,14 +196,6 @@
     final List<IStrategoTerm> empty = Collections.emptyList();
     return result == null ? empty : new ArrayList<IStrategoTerm>(result.getEditorServices());
   }
-  
-  private synchronized boolean doJustReturn() {
-    return justReturn;
-  }
-  
-  private synchronized void setJustReturn(boolean justReturn) {
-    this.justReturn = justReturn;
-  }
 
   private static synchronized Result getResult(String file) {
     return results.get(file);
@@ -216,12 +205,12 @@
     results.put(file, result);
   }
   
-  private String projectRelativePath(String filename) {
-    String path = null;
+  private RelativePath projectRelativePath(String filename) {
+    RelativePath path = null;
     for (String s : sourcePath)
       if (filename.startsWith(s)) {
-        String newPath = filename.substring(s.length() + 1);
-        if (path == null || newPath.length() < path.length())
+        RelativePath newPath = new RelativePath(new AbsolutePath(s), filename.substring(s.length()));
+        if (path == null || newPath.getBasePath().getAbsolutePath().length() < path.getBasePath().getAbsolutePath().length())
           path = newPath;
       }
     

From emma at cs.lth.se  Sun Jun  5 19:29:31 2011
From: emma at cs.lth.se (Emma Nilsson-Nyman)
Date: Sun, 05 Jun 2011 17:29:31 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23003 -
	sglr-recovery/trunk/bridge-definitions/grammars/java
Message-ID: <20110605172931.3FEE22B8085@mx2.tudelft.nl>

Author: EmmaNilssonNyman
Date: Sun Jun  5 17:29:29 2011
New Revision: 23003
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23003&sc=1

Log:
Bridge parser for java15

Added:
   sglr-recovery/trunk/bridge-definitions/grammars/java/Layout.bp
   sglr-recovery/trunk/bridge-definitions/grammars/java/bridget   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/bridget.jar   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/gen-java15.sh   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15bp.jar   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/run-bp-java15.sh   (contents, props changed)
Modified:
   sglr-recovery/trunk/bridge-definitions/grammars/java/Java-15.bp

Modified: sglr-recovery/trunk/bridge-definitions/grammars/java/Java-15.bp
==============================================================================
--- sglr-recovery/trunk/bridge-definitions/grammars/java/Java-15.bp	Sun Jun  5 17:22:30 2011	(r23002)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/Java-15.bp	Sun Jun  5 17:29:29 2011	(r23003)
@@ -2,179 +2,93 @@
 
 import Layout ;
 
+
 // Islands and bridges
-island island0 : SimpleStartIsland = "{" for-sglr ( "EnumBody" ) ;
-island island1 : SimpleEndIsland = "}" for-sglr ( "EnumBody" ) ;
-bridge from island0 to island1 ;
-island island0 : SimpleStartIsland = "{" for-sglr ( "EnumBody" ) ;
-island island1 : SimpleEndIsland = "}" for-sglr ( "EnumBody" ) ;
-bridge from island0 to island1 ;
-island island0 : SimpleStartIsland = "{" for-sglr ( "ConstrBody" ) ;
-island island1 : SimpleEndIsland = "}" for-sglr ( "ConstrBody" ) ;
-bridge from island0 to island1 ;
-island startassert0 : SimpleStartIsland = "assert" for-sglr ( "AssertStm" ) ;
-island endassert0 : SimpleEndIsland = ";" for-sglr ( "AssertStm" ) ;
-bridge from startassert0 to endassert0 ;
-island startassert0 : SimpleStartIsland = "assert" for-sglr ( "AssertStm" ) ;
-island endassert0 : SimpleEndIsland = ";" for-sglr ( "AssertStm" ) ;
-bridge from startassert0 to endassert0 ;
-island island0 : SimpleStartIsland = "{" for-sglr ( "SwitchBlock" ) ;
-island island1 : SimpleEndIsland = "}" for-sglr ( "SwitchBlock" ) ;
-bridge from island0 to island1 ;
-island startcase0 : SimpleStartIsland = "case" for-sglr ( "Case" ) ;
-island endcase0 : SimpleEndIsland = ":" for-sglr ( "Case" ) ;
-bridge from startcase0 to endcase0 ;
-island startdo0 : SimpleStartIsland = "do" for-sglr ( "DoWhile" ) ;
-island enddo0 : SimpleEndIsland = ";" for-sglr ( "DoWhile" ) ;
-bridge from startdo0 to enddo0 ;
-island startreturn0 : SimpleStartIsland = "return" for-sglr ( "Return" ) ;
-island endreturn0 : SimpleEndIsland = ";" for-sglr ( "Return" ) ;
-bridge from startreturn0 to endreturn0 ;
-island startthrow0 : SimpleStartIsland = "throw" for-sglr ( "Throw" ) ;
-island endthrow0 : SimpleEndIsland = ";" for-sglr ( "Throw" ) ;
-bridge from startthrow0 to endthrow0 ;
-island island0 : SimpleStartIsland = "{" for-sglr ( "Block" ) ;
-island island1 : SimpleEndIsland = "}" for-sglr ( "Block" ) ;
-bridge from island0 to island1 ;
-island island0 : SimpleStartIsland = "{" for-sglr ( "ArrayInit" ) ;
-island island1 : SimpleEndIsland = "}" for-sglr ( "ArrayInit" ) ;
-bridge from island0 to island1 ;
-island island0 : SimpleStartIsland = "{" for-sglr ( "ArrayInit" ) ;
-island island1 : SimpleEndIsland = "}" for-sglr ( "ArrayInit" ) ;
-bridge from island0 to island1 ;
-island island2 : SimpleStartIsland = "@" for-sglr ( "Anno" ) ;
-island island3 : SimpleEndIsland = ")" for-sglr ( "Anno" ) ;
-bridge from island2 to island3 ;
-island island2 : SimpleStartIsland = "@" for-sglr ( "SingleElemAnno" ) ;
-island island3 : SimpleEndIsland = ")" for-sglr ( "SingleElemAnno" ) ;
-bridge from island2 to island3 ;
-island island0 : SimpleStartIsland = "{" for-sglr ( "ElemValArrayInit" ) ;
-island island1 : SimpleEndIsland = "}" for-sglr ( "ElemValArrayInit" ) ;
-bridge from island0 to island1 ;
-island island0 : SimpleStartIsland = "{" for-sglr ( "ElemValArrayInit" ) ;
-island island1 : SimpleEndIsland = "}" for-sglr ( "ElemValArrayInit" ) ;
-bridge from island0 to island1 ;
-island island0 : SimpleStartIsland = "{" for-sglr ( "ClassBody" ) ;
-island island1 : SimpleEndIsland = "}" for-sglr ( "ClassBody" ) ;
-bridge from island0 to island1 ;
-island island4 : SimpleStartIsland = "<" for-sglr ( "TypeArgs" ) ;
-island island5 : SimpleEndIsland = ">" for-sglr ( "TypeArgs" ) ;
-bridge from island4 to island5 ;
+
+island LBrace : LayoutStartIsland = "{" ;
+island RBrace : LayoutEndIsland = "}"  ;
+bridge from LBrace to RBrace ;
+
+island LBrack : SimpleStartIsland = "[" ;
+island RBrack : SimpleEndIsland = "]" ;
+bridge from LBrack to RBrack ;
+
+island LParen : SimpleStartIsland = "(" ; 
+island RParen : SimpleEndIsland = ")" ;
+bridge from LParen to RParen ;
+
 
 // Reefs
-reef instanceof0 : Keyword = "instanceof" for-sglr ( "InstanceOf" ) ;
-reef separator0 : Keyword = "," for-sglr ( "Invoke" ) ;
-reef super0 : Keyword = "super" for-sglr ( "SuperMethod" ) ;
-reef super1 : Keyword = "super" for-sglr ( "QSuperMethod" ) ;
-reef super2 : Keyword = "super" for-sglr ( "SuperField" ) ;
-reef super3 : Keyword = "super" for-sglr ( "QSuperField" ) ;
-reef new0 : Keyword = "new" for-sglr ( "NewArray" ) ;
-reef new1 : Keyword = "new" for-sglr ( "NewArray" ) ;
-reef new2 : Keyword = "new" for-sglr ( "NewInstance" ) ;
-reef separator1 : Keyword = "," for-sglr ( "NewInstance" ) ;
-reef new3 : Keyword = "new" for-sglr ( "QNewInstance" ) ;
-reef separator2 : Keyword = "," for-sglr ( "QNewInstance" ) ;
-reef class0 : Keyword = "class" for-sglr ( "Class" ) ;
-reef void0 : Keyword = "void" for-sglr ( "VoidClass" ) ;
-reef class1 : Keyword = "class" for-sglr ( "VoidClass" ) ;
-reef this0 : Keyword = "this" for-sglr ( "This" ) ;
-reef this1 : Keyword = "this" for-sglr ( "QThis" ) ;
-reef package0 : Keyword = "package" for-sglr ( "PackageDec" ) ;
-reef import0 : Keyword = "import" for-sglr ( "TypeImportDec" ) ;
-reef import1 : Keyword = "import" for-sglr ( "TypeImportOnDemandDec" ) ;
-reef import2 : Keyword = "import" for-sglr ( "StaticImportDec" ) ;
-reef static0 : Keyword = "static" for-sglr ( "StaticImportDec" ) ;
-reef import3 : Keyword = "import" for-sglr ( "StaticImportOnDemandDec" ) ;
-reef static1 : Keyword = "static" for-sglr ( "StaticImportOnDemandDec" ) ;
-reef interface0 : Keyword = "interface" for-sglr ( "AnnoDecHead" ) ;
-reef default0 : Keyword = "default" for-sglr ( "DefaultVal" ) ;
-reef separator3 : Keyword = "," for-sglr ( "AbstractMethodDec" ) ;
-reef separator4 : Keyword = "," for-sglr ( "DeprAbstractMethodDec" ) ;
-reef separator5 : Keyword = "," for-sglr ( "ConstantDec" ) ;
-reef interface1 : Keyword = "interface" for-sglr ( "InterfaceDecHead" ) ;
-reef extends0 : Keyword = "extends" for-sglr ( "ExtendsInterfaces" ) ;
-reef separator6 : Keyword = "," for-sglr ( "ExtendsInterfaces" ) ;
-reef enum0 : Keyword = "enum" for-sglr ( "EnumDecHead" ) ;
-reef separator7 : Keyword = "," for-sglr ( "EnumBody" ) ;
-reef separator8 : Keyword = "," for-sglr ( "EnumBody" ) ;
-reef separator9 : Keyword = "," for-sglr ( "ConstrDecHead" ) ;
-reef this2 : Keyword = "this" for-sglr ( "AltConstrInv" ) ;
-reef separator10 : Keyword = "," for-sglr ( "AltConstrInv" ) ;
-reef super4 : Keyword = "super" for-sglr ( "SuperConstrInv" ) ;
-reef separator11 : Keyword = "," for-sglr ( "SuperConstrInv" ) ;
-reef super5 : Keyword = "super" for-sglr ( "QSuperConstrInv" ) ;
-reef separator12 : Keyword = "," for-sglr ( "QSuperConstrInv" ) ;
-reef static2 : Keyword = "static" for-sglr ( "StaticInit" ) ;
-reef if0 : Keyword = "if" for-sglr ( "If" ) ;
-reef if1 : Keyword = "if" for-sglr ( "If" ) ;
-reef else0 : Keyword = "else" for-sglr ( "If" ) ;
-reef assert0 : Keyword = "assert" for-sglr ( "AssertStm" ) ;
-reef assert1 : Keyword = "assert" for-sglr ( "AssertStm" ) ;
-reef switch0 : Keyword = "switch" for-sglr ( "Switch" ) ;
-reef case0 : Keyword = "case" for-sglr ( "Case" ) ;
-reef default1 : Keyword = "default" for-sglr ( "Default" ) ;
-reef while0 : Keyword = "while" for-sglr ( "While" ) ;
-reef do0 : Keyword = "do" for-sglr ( "DoWhile" ) ;
-reef while1 : Keyword = "while" for-sglr ( "DoWhile" ) ;
-reef for0 : Keyword = "for" for-sglr ( "For" ) ;
-reef separator13 : Keyword = "," for-sglr ( "For" ) ;
-reef for1 : Keyword = "for" for-sglr ( "For" ) ;
-reef separator14 : Keyword = "," for-sglr ( "For" ) ;
-reef separator15 : Keyword = "," for-sglr ( "For" ) ;
-reef for2 : Keyword = "for" for-sglr ( "ForEach" ) ;
-reef break0 : Keyword = "break" for-sglr ( "Break" ) ;
-reef continue0 : Keyword = "continue" for-sglr ( "Continue" ) ;
-reef return0 : Keyword = "return" for-sglr ( "Return" ) ;
-reef throw0 : Keyword = "throw" for-sglr ( "Throw" ) ;
-reef synchronized0 : Keyword = "synchronized" for-sglr ( "Synchronized" ) ;
-reef try0 : Keyword = "try" for-sglr ( "Try" ) ;
-reef try1 : Keyword = "try" for-sglr ( "Try" ) ;
-reef finally0 : Keyword = "finally" for-sglr ( "Try" ) ;
-reef catch0 : Keyword = "catch" for-sglr ( "Catch" ) ;
-reef separator16 : Keyword = "," for-sglr ( "LocalVarDec" ) ;
-reef separator17 : Keyword = "," for-sglr ( "MethodDecHead" ) ;
-reef separator18 : Keyword = "," for-sglr ( "DeprMethodDecHead" ) ;
-reef void1 : Keyword = "void" for-sglr ( "Void" ) ;
-reef throws0 : Keyword = "throws" for-sglr ( "ThrowsDec" ) ;
-reef separator19 : Keyword = "," for-sglr ( "ThrowsDec" ) ;
-reef separator20 : Keyword = "," for-sglr ( "ArrayInit" ) ;
-reef separator21 : Keyword = "," for-sglr ( "ArrayInit" ) ;
-reef separator22 : Keyword = "," for-sglr ( "Anno" ) ;
-reef separator23 : Keyword = "," for-sglr ( "ElemValArrayInit" ) ;
-reef separator24 : Keyword = "," for-sglr ( "ElemValArrayInit" ) ;
-reef separator25 : Keyword = "," for-sglr ( "FieldDec" ) ;
-reef class2 : Keyword = "class" for-sglr ( "ClassDecHead" ) ;
-reef extends1 : Keyword = "extends" for-sglr ( "SuperDec" ) ;
-reef implements0 : Keyword = "implements" for-sglr ( "ImplementsDec" ) ;
-reef separator26 : Keyword = "," for-sglr ( "ImplementsDec" ) ;
-reef separator27 : Keyword = "." for-sglr ( "PackageName" ) ;
-reef separator28 : Keyword = "," for-sglr ( "TypeArgs" ) ;
-reef extends2 : Keyword = "extends" for-sglr ( "WildcardUpperBound" ) ;
-reef super6 : Keyword = "super" for-sglr ( "WildcardLowerBound" ) ;
-reef extends3 : Keyword = "extends" for-sglr ( "TypeBound" ) ;
-reef separator29 : Keyword = "&" for-sglr ( "TypeBound" ) ;
-reef separator30 : Keyword = "," for-sglr ( "TypeParams" ) ;
-reef boolean0 : Keyword = "boolean" for-sglr ( "Boolean" ) ;
-reef byte0 : Keyword = "byte" for-sglr ( "Byte" ) ;
-reef short0 : Keyword = "short" for-sglr ( "Short" ) ;
-reef int0 : Keyword = "int" for-sglr ( "Int" ) ;
-reef long0 : Keyword = "long" for-sglr ( "Long" ) ;
-reef char0 : Keyword = "char" for-sglr ( "Char" ) ;
-reef float0 : Keyword = "float" for-sglr ( "Float" ) ;
-reef double0 : Keyword = "double" for-sglr ( "Double" ) ;
-reef public0 : Keyword = "public" for-sglr ( "Public" ) ;
-reef private0 : Keyword = "private" for-sglr ( "Private" ) ;
-reef protected0 : Keyword = "protected" for-sglr ( "Protected" ) ;
-reef abstract0 : Keyword = "abstract" for-sglr ( "Abstract" ) ;
-reef final0 : Keyword = "final" for-sglr ( "Final" ) ;
-reef static3 : Keyword = "static" for-sglr ( "Static" ) ;
-reef native0 : Keyword = "native" for-sglr ( "Native" ) ;
-reef transient0 : Keyword = "transient" for-sglr ( "Transient" ) ;
-reef volatile0 : Keyword = "volatile" for-sglr ( "Volatile" ) ;
-reef synchronized1 : Keyword = "synchronized" for-sglr ( "Synchronized" ) ;
-reef strictfp0 : Keyword = "strictfp" for-sglr ( "StrictFP" ) ;
+
+reef Layout : LayoutReef = NEWLINE (TAB|WS)* ;
+
+
+reef ClassKeyword = "class" ;
+reef PackageKeyword = "package" ;
+reef ImportKeyword = "import" ;
+reef StaticKeyword = "static" ;
+reef InterfaceKeyword = "interface" ;
+reef DefaultKeyword = "default" ;
+reef ExtendsKeyword = "extends" ;
+reef EnumKeyword = "enum" ;
+reef IfKeyword = "if" ;
+reef ElseKeyword = "else" ;
+reef AssertKeyword = "assert" ;
+reef SwitchKeyword = "switch" ;
+reef CaseKeyword = "case" ;
+reef WhileKeyword = "while" ;
+reef DoKeyword = "do" ;
+reef ForKeyword = "for" ;
+reef BreakKeyword = "break" ;
+reef ContinueKeyword = "continue" ;
+reef ReturnKeyword = "return" ;
+reef ThrowKeyword = "throw" ;
+reef SynchronizedKeyword = "synchronized" ;
+reef TryKeyword = "try" ;
+reef FinallyKeyword = "finally" ;
+reef CatchKeyword = "catch" ;
+reef ThrowsKeyword = "throws" ;
+reef ImplementsKeyword = "implements" ;
+reef PublicKeyword = "public" ;
+reef PrivateKeyword = "private" ;
+reef ProtectedKeyword = "protected" ;
+reef AbstractKeyword = "abstract" ;
+reef FinalKeyword = "final" ;
+reef NativeKeyword = "native" ;
+reef TransientKeyword = "transient" ;
+reef VolatileKeyword = "volatile" ;
+reef StrictfpKeyword = "strictfp" ;
+
 
 // Ignores
-ignore "//" to NEWLINE ;
-ignore "/*" to "*/" ;
-ignore "\" to "\" ;
\ No newline at end of file
+
+ignore LineComment "//" to NEWLINE ;
+ignore MultiComment "/*" to "*/" ;
+ignore String "\"" to "\"" ;
+
+
+//reef VoidKeyword = "void" ;
+//reef ThisKeyword = "this" ;
+//reef NewKeyword = "new" ;
+//reef InstanceofKeyword = "instanceof" ;
+//reef SeparatorKeyword = "," ;
+//reef SuperKeyword = "super" ;
+//reef DotKeyword = "." ;
+//reef AndKeyword = "&" ;
+//reef BooleanKeyword = "boolean" ;
+//reef ByteKeyword = "byte" ;
+//reef ShortKeyword = "short" ;
+//reef IntKeyword = "int" ;
+//reef LongKeyword = "long" ;
+//reef CharKeyword = "char" ;
+//reef FloatKeyword = "float" ;
+//reef DoubleKeyword = "double" ;
+
+// These may occure are operators in which case this will cause an unwanted repair
+// island LABrack : SimpleStartIsland = "<" ;
+// island RABrack : SimpleEndIsland = ">" ;
+// bridge from LABrack to RABrack ;
+
+
+
+

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/Layout.bp
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/Layout.bp	Sun Jun  5 17:29:29 2011	(r23003)
@@ -0,0 +1,85 @@
+grammar Layout;
+
+/*
+ * Layout recovery for structural islands
+ */
+
+abstract island LayoutStartIsland;
+abstract island LayoutEndIsland;
+
+abstract reef LayoutReef;
+
+java-attr int LayoutReef.pos = 
+@@
+	int pos = 0;
+	char[] chars = value.toCharArray();
+	for (int i = chars.length-1; i >= 0; i--) {
+		switch(chars[i]) {
+			case ' '  : pos++; break;
+			case '\t' : pos += 4; break; // TAB_SIZE=4
+		}
+		if (chars[i] == '\n') {
+			break;
+		}
+	}
+	return pos;
+@@
+
+attr LayoutReef LayoutStartIsland.indent = [first left LayoutReef];
+attr LayoutReef LayoutEndIsland.indent = [first left LayoutReef];
+
+attr LexicalNode LayoutReef.rightNeighbour = [first right LexicalNode];
+
+java-attr boolean LayoutReef.startOfEmptyLine =
+@@
+    return rightNeighbour() != null && rightNeighbour() instanceof LayoutReef;
+@@
+
+
+bridge from LayoutStartIsland to LayoutEndIsland 
+	when ((start.indent == null && 0 == end.indent.pos) ||
+        (start.indent != null && start.indent.pos == end.indent.pos));
+
+recover LayoutStartIsland 
+	find [a:LayoutReef] 
+		where (a.startOfEmptyLine != true && a.pos <= this.indent.pos)
+		insert bridge-end before a;
+	find [b:LayoutEndIsland]
+		where (!(b.hasBridge) && b.indent.pos < this.indent.pos)
+		insert bridge-end before b;
+
+recover LayoutEndIsland
+	// Make sure to jump over the indentation of this node otherwise
+	// it will always match its own indentation reef.
+	find [a:LayoutReef b:LayoutReef]
+		where (a.startOfEmptyLine != true && b.startOfEmptyLine != true &&
+            a != this.indent && a.pos <= this.indent.pos)
+		insert bridge-start before b;
+	find [b:LayoutStartIsland]
+		where (!(b.hasBridge) && this.indent.pos < b.indent.pos)
+		insert bridge-start after b; 		
+
+/* 
+ * Simple recovery for non-structural islands 
+ */ 
+
+abstract island SimpleStartIsland : LayoutStartIsland;
+abstract island SimpleEndIsland : LayoutEndIsland;
+
+java-attr boolean LayoutStartIsland.isStructural = @@ return true; @@
+java-attr boolean LayoutEndIsland.isStructural = @@ return true; @@
+java-attr boolean SimpleStartIsland.isStructural = @@ return false; @@
+java-attr boolean SimpleEndIsland.isStructural = @@ return false; @@
+
+bridge from SimpleStartIsland to SimpleEndIsland when (true);
+
+recover SimpleStartIsland 
+	find [a:Reef] where (true) insert bridge-end before a;
+	find [a:LayoutStartIsland] where (a.isStructural) insert bridge-end before a;
+	use-super;
+
+recover SimpleEndIsland
+	find [a:Reef] where (true) insert bridge-start after a;
+	find [a:LayoutEndIsland] where (a.isStructural) insert bridge-start after a;
+	use-super;
+		

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/bridget
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/bridget	Sun Jun  5 17:29:29 2011	(r23003)
@@ -0,0 +1,5 @@
+#!/bin/sh
+
+java -jar bridget.jar $@
+
+exit

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/bridget.jar
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/gen-java15.sh
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/gen-java15.sh	Sun Jun  5 17:29:29 2011	(r23003)
@@ -0,0 +1,14 @@
+#!/bin/sh
+
+
+./bridget --output-dir=java15 --grammar-path=. --package=java15 Java-15.bp
+
+echo -n 'Compiling generated classes ... '
+javac -cp .:bridget.jar java15/*.java
+echo 'done.'
+
+echo -n 'Creating bridge parser jar file ... '
+jar cfe java15bp.jar java15/*.class java15/*.java
+echo 'done.'
+
+exit

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15bp.jar
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/run-bp-java15.sh
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/run-bp-java15.sh	Sun Jun  5 17:29:29 2011	(r23003)
@@ -0,0 +1,3 @@
+#!/bin/sh
+
+java -cp .:bridget.jar:java15bp.jar java15.MainBridgeParser

From M.A.Akhter at student.tudelft.nl  Mon Jun  6 04:06:06 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Mon, 06 Jun 2011 02:06:06 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23004 - in
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans:
	analyze/sdf codegen context/sdf context/str utils
Message-ID: <20110606020606.6A9CD108C033@mx3.tudelft.nl>

Author: MdAdilAkhter
Date: Mon Jun  6 02:05:58 2011
New Revision: 23004
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23004&sc=1

Log:
Added checks to warn about duplicate definition of SDF productions

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/analyze/sdf/check.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/compile.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/sdf/declare-signature.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/sdf/declare.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/str/declare.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/debug.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/analyze/sdf/check.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/analyze/sdf/check.str	Sun Jun  5 17:29:29 2011	(r23003)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/analyze/sdf/check.str	Mon Jun  6 02:05:58 2011	(r23004)
@@ -3,7 +3,8 @@
 imports
  	common
  	utils/debug
-  context/sdf/declare
+ 	utils/attributes
+  context/sdf/-
   context/-
   include/SpoofaxLang
   utils/attributes
@@ -27,9 +28,9 @@
 			<debug-analysis>$[ErrorChecking | SDF  : [<pp-aterm>]]
 		with
 	    // We only collect-om since we don't want inner warning dupes
-	    error*   := <collect-om(?context-free-syntax(<collect-om(context-free-syntax-error)>)
+	    error*   := <collect-om( ?context-free-syntax(<collect-om(context-free-syntax-error)>)
 	                           + ?TemplateSection(<collect-om(context-free-templates-error)>), conc)> ast;
-	    warning* := <collect-om(?context-free-syntax(<collect-om(context-free-syntax-warning)>)
+	    warning* := <collect-om( ?context-free-syntax(<collect-om(context-free-syntax-warning)>)
 	                           + ?TemplateSection(<collect-om(context-free-templates-warning)>), conc)> ast;
 	    if <file-exists> $[[<get-project-path>]/.disable-global-analysis] then
 	      serror* := []
@@ -39,11 +40,18 @@
 	    error'*   := <conc;flatten-list> (serror*, error*);
 	    warning'* := <flatten-list> warning*
 
-
+	
 strategies
-  /**
-   * Tests if something is a non-terminal in terms of the AST produced.
-   */
+	
+	//checks whether constructor rhs-sort is marked for having declared multiple times 
+	has-duplicate-sdf-definitions(|constructor-name) =
+		?rhs-sort-name;
+		declarations := <resolve-symbol-declarations(all-keys-has-duplicate-opeartion-definition, bagof-has-duplicate-opeartion-definition)><to-scoped-symbol>rhs-sort-name;
+ 		filter(? (constructor-name,_ ,rhs-sort-name));
+ 		is-not-empty-list
+ 	
+ 
+  // Tests if something is a non-terminal in terms of the AST produced.
   is-non-terminal =
     ?sort(_) + ?opt(_) + is-iter
   + namespacedef(id, is-non-terminal) + namespaceref(is-non-terminal)
@@ -67,7 +75,18 @@
   context-free-syntax-sort-error:
     'sorts(_) -> [] // ignored
 
-
+	context-free-syntax-warning:
+    p at prod(p*, s, a*) -> (p, $[Possibly multiple definitions are encountered for "[x]" [msg-to-append].])
+    where
+    	x := <get-rhs-sort-name>s;
+    	if op-name := <!a*; ?attrs(<id>);getfirst(fetch-cons-name)> then 
+    		msg-to-append := $[with "[op-name]" constructor]
+    	else
+    		op-name := "";
+    		msg-to-append := ""
+    	end;
+    	<has-duplicate-sdf-definitions(|op-name)>x 	 
+	
 rules // Local checks
    context-free-syntax-warning:
     prod(p*, s, a*) -> (target, $[Missing {"Label"} attribute to label the abstract syntax])

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/compile.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/compile.str	Sun Jun  5 17:29:29 2011	(r23003)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/compile.str	Mon Jun  6 02:05:58 2011	(r23004)
@@ -188,7 +188,7 @@
 				|};
 
 				// Making this package as compiled.
-				// TODO : consider keeping only 1 DR as a marker if compiled package.
+				// TODO : consider keeping only 1 DR as a marker for compiled package.
 				where(
 					rules(
 						CompiledPackage : package-typed-qname -> package-typed-qname

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/sdf/declare-signature.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/sdf/declare-signature.str	Sun Jun  5 17:29:29 2011	(r23003)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/sdf/declare-signature.str	Mon Jun  6 02:05:58 2011	(r23004)
@@ -15,22 +15,26 @@
 
 
 // TODO : refactor common functionily in seperate rules/strategy
-// DON'T like several things about this implementation. Need to refactor/re-implement.
-
-
-//TODO : write a pretty printer to convert Get-Operation-Declaration to Signatures' Aterm
+// FIXME: DON'T like several things about this implementation. Need to refactor/re-implement.
+// TODO : write a pretty printer to convert Get-Operation-Declaration to Signatures' Aterm
 
 rules
 	getOperationSignatures =
 		?opname;
  		<resolve-symbol-declarations(all-keys-Get-Operation-Signature, bagof-Get-Operation-Signature)><to-scoped-symbol>opname
  	<+
- 		<debug-declaration> $[Waring | Failed to retrive OperationSignatures for opname[<pp-aterm>]. Returning  empty list . ];
+ 		<debug-declaration(|"Signature" , "Warning")> $[Failed to retrive OperationSignatures for opname[<pp-aterm>]. Returning  empty list . ];
  		![]
-
+ 	
+ 	get-operation-declarations =
+		?opname;
+ 		<resolve-symbol-declarations(all-keys-Get-Operation-Declaration, bagof-Get-Operation-Declaration)><to-scoped-symbol>opname
+ 	<+
+ 		<debug-declaration(|"Signature" , "Warning")> $[Failed to retrive OperationDeclarations for opname[<pp-aterm>]. Returning  empty list . ];
+ 		![]
+ 			
 strategies
-	// Returns right hand side of the production. In case of A -> B, it
-	// retunrs B.
+	// Returns right hand side of the production. In case of A -> B, it retunrs B.
 	get-rhs-sort-name =
 			try(
 					?cf(<id>)
@@ -49,28 +53,23 @@
 
 	mark-as-lexical-syntax-block =	with(	rules (IsInsideLexicalSyntaxBlock :_) )
 
-
-
-
 rules
 
 	//Stores operation name and operation declarations
-
-	/**
-  * Gets the operation name from the Production. It actually search all the attributes
-  * in the attribute list and create  a dynamic rule that stores operation name.
-  */
+	
+  // Gets the operation name from the Production. It actually searches all the attributes
+  // in the attribute list and creates a dynamic rule that stores operation name.
   get-opration-name = where(getfirst(fetch-cons-name) ; store-operation-name)
 
-  /**
-  *	Store operation name from the RHS of the Production, i.e. from fun constructors.
-  * It creates a dynamic rule to store the operation name.
-  */
-  store-operation-name : opname-> opname
-  with
-		rules (get-op-name: _ -> opname)
-  where
-  		<debug-declaration> $[Operation Name :  [opname]]
+  
+  // Stores operation name from RHS of the Production, i.e. from fun constructors.
+  // It creates a dynamic rule to store the operation name.
+  store-operation-name : 
+  	opname-> opname
+  	with
+			rules (get-op-name: _ -> opname)
+  	where
+  		<debug-declaration(|"Signature" , "Info")> $[Operation Name :  [opname]]
 
 
 	store-operation-declaration:
@@ -96,7 +95,7 @@
       <store-operation-declaration-internal> (t, lhs, rhs-sort, attrs)
 
 	store-operation-declaration-internal
-  	=  ?(p, lhs , rhs-sort, attrs(attribute-list))
+  	= ?(p, lhs , rhs-sort, attrs(attribute-list))
   		;rhs-sort-name := <get-rhs-sort-name>rhs-sort
   		;{|lhs-sort, get-op-name:
   		 			<find-sorts>lhs
@@ -105,18 +104,18 @@
   						lhs-operands-types := <reverse><bagof-lhs-sort>
   						;create-opname2opdecl-mapping(|operation-name , lhs-operands-types, rhs-sort-name , p)
   					else
-  						<debug-declaration> $[DeclareSignature | Failed to retrive Operation Name . Hence Ignoring : [<pp-aterm> p].]
+  						<debug-declaration(|"Signature" , "Warning")> $[Failed to retrive Operation Name . Hence Ignoring : [<pp-aterm> p].]
   					end
   		  |}
 
 	store-operation-declaration-internal
-  	=  ?(p, lhs, rhs-sort, no-attrs())
+  	= ?(p, lhs, rhs-sort, no-attrs())
   		;rhs-sort-name := <get-rhs-sort-name>rhs-sort
   	  ; {|lhs-sort :
 	  				if (IsInsideLexicalSyntaxBlock<+ (!rhs-sort; ?lex(sort(rhs-sort-name))))then
 							 rules ( lhs-sort :+ _ -> $[String] )
 						else
-							<find-sorts>lhs //TODO : consider ignorig :ID->ID-Prime operation decl
+							<find-sorts>lhs //TODO : consider ignoring :ID->ID-Prime operation decl
 						end
 	  				;lhs-operands-types := <reverse><bagof-lhs-sort>
 	  				;operation-name := ""
@@ -149,6 +148,7 @@
 					;	inner-sort* := <bagof-lhs-sort;reverse>
 					;	intermediate-resultant-sort-type :=<string-replace(|"(", "_Of_");string-replace(|")", "")> <separate-by(|"_"); concat-strings>inner-sort*
 			|}
+			// storing intermediate operation declarations    
 			; <map(create-opname2opdecl-mapping(|"", intermediate-resultant-sort-type, "[N/A]" ))>inner-sort*
 			; rules( lhs-sort :+ _ -> intermediate-resultant-sort-type)
 
@@ -252,8 +252,8 @@
 				)
 
 	/**
-	* Create a dynamic rule that mapes operation name to the operation declaration.
-	*	Addinationally, Arity of Operation Decl. has also been stored.
+	* Creates a dynamic rule that mapes operation name to the operation declaration.
+	*	In addition, Arity of Operation Decl. has also been stored.
 	*
 	* @Param operation-name.
 	* @param Sort or Operand Types involve in the operation.
@@ -262,50 +262,60 @@
 	*
 	*/
 	create-opname2opdecl-mapping(|operation-name, opernand-sorts*, resultant-sort , production) =
-		where (<debug-declaration> $[DeclareSDF | Storing Signature for following production: [<pp-aterm> production]])
-		;available-opdecl*     := <getOperationSignatures>operation-name
+		where (<debug-declaration(|"DeclareSignature" , "Info")> $[Storing Signature for following production: [<pp-aterm> production]])
+		;available-opdecl* := <get-operation-declarations>operation-name
 		;scoped-operation-name := <to-scoped-symbol>operation-name
-		;if(
-		 		(!available-opdecl* => [])
-				<+
-				not (<assert-equal-signature(|operation-name, opernand-sorts*, resultant-sort)>available-opdecl*)
-			)
-			then
-				record-operation-declaration(|scoped-operation-name  , operation-name  , opernand-sorts* , resultant-sort) // storing this operation declaration
+		;if( (!available-opdecl* => []) <+ not(<assert-equal-signature(|operation-name, opernand-sorts*, resultant-sort)>available-opdecl*) )then
+			record-operation-definition(|scoped-operation-name  , operation-name  , opernand-sorts* , resultant-sort) 
  		else
- 		 		<debug-declaration>
+ 			//enable-declaration-debugging;
+ 		 	record-duplicate-operation-definition(|scoped-operation-name  , operation-name  , opernand-sorts* , resultant-sort); 
+ 		 	<debug-declaration(|"Signature" , "Warning")>
  		 			$[
- 		 				DeclareSignature | Waring | There is an existing operation declration of production: [<pp-aterm> production] as the following : [<pp-aterm>(operation-name, opernand-sorts* , resultant-sort)]
- 		 				DeclareSignature | Debug-info: scoped-op-name [<pp-aterm>scoped-operation-name].
+ 		 				There is an existing operation declration of production: [<pp-aterm> production] as the following : [<pp-aterm>(operation-name, opernand-sorts* , resultant-sort)]
+ 		 				--scoped-op-name [<pp-aterm>scoped-operation-name].
  		 			 ]
+ 		 	//;disable-declaration-debugging	 
 		end
-
+		
 
 	create-opname2opdecl-mapping(|operation-name, resultant-sort , production): alt-sort -> alt-sort
 		where
 			  alt-srt-lst := [alt-sort]
 			  ;create-opname2opdecl-mapping(|operation-name, alt-srt-lst, resultant-sort , production)
 
-	record-operation-declaration ( |scoped-op-name ,  opname , operand-sort* ,  resultant-sort) =
+	
+	record-operation-definition ( |scoped-op-name ,  opname , operand-sort* ,  resultant-sort) =
 		where (
 			arg-length := <length>operand-sort*;
 			rules(
 					Get-Operation-Signature  :+  scoped-op-name   -> (opname  , arg-length )
 				 	Get-Operation-Declaration:+  scoped-op-name   -> (opname  , operand-sort* , resultant-sort)
 				)
-			; <debug-declaration> $[DeclareSignature | Stored operation declration : [<pp-aterm> ( opname , operand-sort* ,  resultant-sort) ].]
-			; <debug-declaration> $[DeclareSignature | Stored operation signature  : [<pp-aterm> scoped-op-name] -> [<pp-aterm> (opname, <length>operand-sort*)].]
+				
+			;<debug-declaration(|"Signature" , "Info")> $[Stored operation declration : [<pp-aterm> ( opname , operand-sort* ,  resultant-sort) ].]
+			;<debug-declaration(|"Signature" , "Info")> $[Stored operation signature  : [<pp-aterm> scoped-op-name] -> [<pp-aterm> (opname, <length>operand-sort*)].]
 	)
 
-	record-operation-declaration-at-global-scope ( | opname , operand-sort* ,  resultant-sort) =
+	record-operation-definition-at-global-scope ( | opname , operand-sort* ,  resultant-sort) =
 		where ( <to-global-symbol> opname => scoped-op-name);
-		record-operation-declaration( |scoped-op-name ,  opname , operand-sort* ,  resultant-sort)
-
+		record-operation-definition( |scoped-op-name ,  opname , operand-sort* ,  resultant-sort)
 
+	
+	record-duplicate-operation-definition( |scoped-op-name ,  opname , operand-sort* ,  resultant-sort) =
+		where(
+			scoped-rhs-sort := <to-scoped-symbol>resultant-sort;
+			arg-length := <length>operand-sort*;
+			rules(
+					has-duplicate-opeartion-definition:+ scoped-rhs-sort   -> (opname  , arg-length, resultant-sort)
+			)
+			;<debug-declaration(|"Signature" , "Info")> $[Stored duplicate  operation signature  : [<pp-aterm> scoped-op-name].]
+		)	
+		
 rules
 	init-record-signatures =
-			record-operation-declaration-at-global-scope ( |"None", [] 		,"Option(a)");
-			record-operation-declaration-at-global-scope ( |"Some", ["a"] ,"Option(a)");
-			record-operation-declaration-at-global-scope ( |"Cons", ["a","List(a)"] ,"List(a)");
-			record-operation-declaration-at-global-scope ( |"Nil", [] ,"List(a)");
-			record-operation-declaration-at-global-scope ( |"Conc", ["List(a)" , "List(a)"] ,"List(a)")
+			record-operation-definition-at-global-scope ( |"None", [] 		,"Option(a)");
+			record-operation-definition-at-global-scope ( |"Some", ["a"] ,"Option(a)");
+			record-operation-definition-at-global-scope ( |"Cons", ["a","List(a)"] ,"List(a)");
+			record-operation-definition-at-global-scope ( |"Nil", [] ,"List(a)");
+			record-operation-definition-at-global-scope ( |"Conc", ["List(a)" , "List(a)"] ,"List(a)")

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/sdf/declare.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/sdf/declare.str	Sun Jun  5 17:29:29 2011	(r23003)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/sdf/declare.str	Mon Jun  6 02:05:58 2011	(r23004)
@@ -52,8 +52,6 @@
     	alltd(declare-sdf-definition)
 
 rules
-
-
 	declare-sdf-definition:
     renamings(y) -> <id>
     where
@@ -103,7 +101,7 @@
         	SortDeclaration  :  qualified-sort-name -> x
        		SortProductionLHS:+ qualified-sort-name -> lhs
       	);
-      	<debug-declaration> $[DeclareSDF | Storing Declaration : [<pp-aterm>qualified-sort-name]  -> [<pp-aterm>prod]]
+      	<debug-declaration(| "SDF" , "Info" )> $[Storing Declaration : [<pp-aterm>qualified-sort-name]  -> [<pp-aterm>prod]]
       )
     with
       <alltd(declare-sdf-usage)> lhs
@@ -157,7 +155,7 @@
 	  	scoped-x:= <to-scoped-symbol>x;
 	  	rules(Declaration: scoped-x -> x)
 		where
-			<debug-declaration>$[DeclareSDF | Storing Declaration [<pp-aterm>scoped-x] -> [<pp-aterm>x]]
+			<debug-declaration(| "SDF" , "Info" )>$[Storing Declaration [<pp-aterm>scoped-x] -> [<pp-aterm>x]]
 
 rules
 

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/str/declare.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/str/declare.str	Sun Jun  5 17:29:29 2011	(r23003)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/str/declare.str	Mon Jun  6 02:05:58 2011	(r23004)
@@ -27,14 +27,14 @@
  		?cookie; 
  		<to-scoped-symbol;resolve-symbol-declarations(all-keys-STRDeclaration, bagof-STRDeclaration);last>cookie 
  	<+
- 		<debug-declaration> $[DeclareSTR | Failed to retrive STRDeclaration for cookie [<pp-aterm-forced><to-scoped-symbol>]];
+ 		<debug-declaration(| "STR" , "Warning" )> $[Failed to retrive STRDeclaration for cookie [<pp-aterm-forced><to-scoped-symbol>]];
  		fail
 	
 	getCookie =
 			?sig; 
  			<to-scoped-symbol;resolve-symbol-declarations(all-keys-DeclareCookie, bagof-DeclareCookie);last>sig
  		<+
- 			<debug-declaration> $[DeclareSTR | Failed to retrive DeclareCookie for signature [<pp-aterm>]];
+ 			<debug-declaration(| "STR" , "Warning" )> $[Failed to retrive DeclareCookie for signature [<pp-aterm>]];
  			fail
 	 
 rules 
@@ -69,8 +69,8 @@
           DeclareCookie:  scoped-sig  -> cookie
           STRDeclaration: scoped-cookie  -> def
         )
-        ;<debug-declaration>$[DeclareSTR | declare-definition | Storing DeclareCookie : [<pp-aterm>scoped-sig] -> [<pp-aterm>cookie]]
-				;<debug-declaration>$[DeclareSTR | declare-definition | Storing STRDeclaration : [<pp-aterm>scoped-cookie] -> [<pp-aterm>def]]      
+        ;<debug-declaration(| "STR|declare-definition" , "Info" )> $[Storing DeclareCookie : [<pp-aterm>scoped-sig] -> [<pp-aterm>cookie]]
+				;<debug-declaration(| "STR|declare-definition" , "Info" )> $[Storing STRDeclaration : [<pp-aterm>scoped-cookie] -> [<pp-aterm>def]]      
       else
        	cookie := <getCookie> sig 
       end
@@ -88,8 +88,8 @@
         STRDeclaration: scoped-cookie -> def
       )
 		where
-			<debug-declaration>$[DeclareSTR | redeclare-definition | Storing DeclareCookie : [<pp-aterm>scoped-sig] -> [<pp-aterm>cookie]];
-			<debug-declaration>$[DeclareSTR | redeclare-definition | Storing STRDeclaration : [<pp-aterm>scoped-cookie] -> [<pp-aterm>def]]      
+			<debug-declaration(| "STR|redeclare-definition" , "Info" )> $[Storing DeclareCookie : [<pp-aterm>scoped-sig] -> [<pp-aterm>cookie]]
+			;<debug-declaration(| "STR|redeclare-definition" , "Info" ) >$[Storing STRDeclaration : [<pp-aterm>scoped-cookie] -> [<pp-aterm>def]]      
   
   external SRTS-EXT-newint(|)
   
@@ -123,7 +123,7 @@
         DeclareCookie: scoped-sig' -> cookie
       )
     where
-    	<debug-declaration>$[DeclareSTR | declare-str-definition [<pp-aterm>]| Storing DeclareCookie : [<pp-aterm>scoped-sig'] -> [<pp-aterm>cookie]]  
+    	<debug-declaration(| "STR" , "Info" )>$[declare-str-definition [<pp-aterm>]| Storing DeclareCookie : [<pp-aterm>scoped-sig'] -> [<pp-aterm>cookie]]  
   
    declare-str-definition:
     ExtSDef(x, s*, t*) -> <id>
@@ -149,7 +149,7 @@
         DeclareCookie: scoped-sig'   -> cookie
       )
     where
-    	<debug-declaration>$[DeclareSTR | declare-str-definition [<pp-aterm>] | Storing DeclareCookie : [<pp-aterm>scoped-sig'] -> [<pp-aterm>cookie]]  
+    	<debug-declaration(| "STR" , "Info" )>$[declare-str-definition [<pp-aterm>] | Storing DeclareCookie : [<pp-aterm>scoped-sig'] -> [<pp-aterm>cookie]]  
     
     
   declare-dynrule:
@@ -191,7 +191,7 @@
     sig := ($[[prefix]-[x]], s, t);
     scoped-sig := <to-scoped-symbol> sig;
     rules(DeclareCookie: scoped-sig -> cookie);
-		where(<debug-declaration>$[DeclareSTR | declare-dr-rule [<pp-aterm>prefix]| Storing DeclareCookie : [<pp-aterm>scoped-sig] -> [<pp-aterm>cookie]])  
+		where(<debug-declaration(| "STR" , "Info" )>$[declare-dr-rule [<pp-aterm>prefix]| Storing DeclareCookie : [<pp-aterm>scoped-sig] -> [<pp-aterm>cookie]])  
   
 
   dr-scope-declare-cookies(defs, s):

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/debug.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/debug.str	Sun Jun  5 17:29:29 2011	(r23003)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/debug.str	Mon Jun  6 02:05:58 2011	(r23004)
@@ -27,7 +27,7 @@
 
 	disable-declaration-debugging = rules(DebugDeclaration:- _ )
 
-	debug-declaration = not(DebugDeclaration <+ DebugAll)  <+ debug(!"--- Declaration | ")
+	debug-declaration(| site, type) = not(DebugDeclaration <+ DebugAll)  <+ <debug>$[ $[$ Declaration | [site] | [type] $]$ [<id>]]
 
 
 
@@ -36,7 +36,7 @@
 
 	disable-symboltable-debugging = rules(DebugSymbolTable:- _ )
 
-	debug-symboltable = not(DebugSymbolTable <+ DebugAll)  <+ debug(!"--- SymbolTable | ")
+	debug-symboltable = not(DebugSymbolTable <+ DebugAll)  <+ debug(!"[ SymbolTable | ")
 
 
   // Debug switches for semantic analysis
@@ -44,7 +44,7 @@
 
 	disable-semantic-analysis-debugging = rules(DebugSemanticAnalysis:- _ )
 
-	debug-analysis = not(DebugSemanticAnalysis <+ DebugAll)  <+ debug(!"--- SemanticAnalysis | ")
+	debug-analysis = not(DebugSemanticAnalysis <+ DebugAll)  <+ debug(!"[ SemanticAnalysis | ")
 
 
  	// Debug switches for compile
@@ -52,11 +52,11 @@
 
 	disable-compiler-debugging = rules(DebugCompiler:- _ )
 
-	debug-compiler = not(DebugCompiler <+ DebugAll)  <+ debug(!"--- Compiler | ")
+	debug-compiler = not(DebugCompiler <+ DebugAll)  <+ debug(!"[ Compiler | ")
 
 
   // Debug switches for TemplateLang
-  debug-templatelang = debug(!"--- TemplateLang | ")
+  debug-templatelang = debug(!"[ TemplateLang | ")
 
  rules
 

From M.A.Akhter at student.tudelft.nl  Mon Jun  6 05:49:06 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Mon, 06 Jun 2011 03:49:06 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23005 - in
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans:
	analyze/esv analyze/sdf context normalize
Message-ID: <20110606034906.A66B0108C003@mx3.tudelft.nl>

Author: MdAdilAkhter
Date: Mon Jun  6 03:49:05 2011
New Revision: 23005
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23005&sc=1

Log:
Added ESV check "Undefined Start Symbol"

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/analyze/esv/check.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/analyze/sdf/check.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/resolve-declarations.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/scope-tree.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/normalize/main.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/analyze/esv/check.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/analyze/esv/check.str	Mon Jun  6 02:05:58 2011	(r23004)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/analyze/esv/check.str	Mon Jun  6 03:49:05 2011	(r23005)
@@ -21,12 +21,9 @@
   	where
   		<debug-analysis>$[ErrorChecking | ESV Section : [<pp-aterm>]]
 		where
-  		error-esv*   := <collect-all(constraint-esv-error, conc)> ast;
+  		error-esv*   := <flatten-list><collect-all(constraint-esv-error, conc)> ast;
   		warning-esv* := <collect-all(constraint-esv-warning, conc)> ast
 
-
-	
-
 rules 
 	resolve-sdf-sort-declaration = 
  		?symbol; 
@@ -35,9 +32,8 @@
  		<debug-analysis> $[ErrorChecking|Failed to retrive SDF Sort for symbol [<pp-aterm>]];
  		fail
 
-
-
 rules
+
 	constraint-esv-error:
     Sort(x) -> (x, $[Unknown sort [x]])
     where
@@ -49,12 +45,28 @@
       not(<string-ends-with(|".jar") + string-ends-with(|".ctree")> x)
    		
   constraint-esv-error: 
-   	LanguageName( name ) -> (name, $[ Duplicate declaration of language name. Declared in following packages : [<pp-aterm>packages*]])
+   	LanguageName( name ) -> (name, $[ Multiple declarations of language name. Declared in following packages : [<pp-aterm>packages*]])
    	where
    			<get-languagename-declaration-sites> name =>packages*;
    			is-not-empty-list;
    			make-set;
 				not(ensure-is-unique)
+	
+	constraint-esv-error: 
+		StartSymbols(sorts*) -> err-messages*
+		where
+			s* := <get-start-symbols> <GetEnclosingPackageName>; // getting all the context-free-start-symbols for the package   	
+			<filter(unknown-start-symbol-error(|s*))>sorts* => err-messages*;
+			if !err-messages* => [] then 
+				fail
+			end
+	
+	unknown-start-symbol-error(|start-symbols-found-in-sdf-def) : 
+		s at Sort(x) -> (s, $[Undefined Start Symbol :  "[x]".])
+		where 
+			<not(fetch-elem(?sort(x)))>start-symbols-found-in-sdf-def
+			
+					
 rules
 	   		
   constraint-esv-warning: 

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/analyze/sdf/check.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/analyze/sdf/check.str	Mon Jun  6 02:05:58 2011	(r23004)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/analyze/sdf/check.str	Mon Jun  6 03:49:05 2011	(r23005)
@@ -76,7 +76,7 @@
     'sorts(_) -> [] // ignored
 
 	context-free-syntax-warning:
-    p at prod(p*, s, a*) -> (p, $[Possibly multiple definitions are encountered for "[x]" [msg-to-append].])
+    p at prod(p*, s, a*) -> (p, $[Possibly multiple definitions of "[x]" [msg-to-append].])
     where
     	x := <get-rhs-sort-name>s;
     	if op-name := <!a*; ?attrs(<id>);getfirst(fetch-cons-name)> then 

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/resolve-declarations.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/resolve-declarations.str	Mon Jun  6 02:05:58 2011	(r23004)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/resolve-declarations.str	Mon Jun  6 03:49:05 2011	(r23005)
@@ -22,7 +22,15 @@
 	utils/contract
 	
 rules 
-	
+	get-start-symbols =
+		contracts(
+			contract-requires(
+				?Package(QName(_))
+			)
+		);
+		bagof-DeclaredContextFreeStartSymbols;
+		flatten-list 
+
 	get-language-id = 
 		contracts(
 			contract-requires(

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/scope-tree.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/scope-tree.str	Mon Jun  6 02:05:58 2011	(r23004)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/scope-tree.str	Mon Jun  6 03:49:05 2011	(r23005)
@@ -82,6 +82,11 @@
 		LanguageId(id-string) -> <id> 
 		with 
 			rules( DeclaredLangaugeId :+ package-typed-qname -> id-string)
-		where
-			<debug-symboltable> $[ ScopeTree| [<pp-aterm>package-typed-qname] storing  following language Id : [<pp-aterm>id-string]]
+			;<debug-symboltable> $[ ScopeTree| [<pp-aterm>package-typed-qname] storing  following language Id : [<pp-aterm>id-string]]
+	 
+	store-context-free-start-symbols(|package-typed-qname) : 
+	 	context-free-start-symbols(sorts*) -> <id>
+	 	with 
+			rules( DeclaredContextFreeStartSymbols :+ package-typed-qname -> sorts*)
+			;<debug-symboltable> $[ ScopeTree| [<pp-aterm>package-typed-qname] storing  following start symbols : [<pp-aterm>sorts*]]
 	 		 		
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/normalize/main.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/normalize/main.str	Mon Jun  6 02:05:58 2011	(r23004)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/normalize/main.str	Mon Jun  6 03:49:05 2011	(r23005)
@@ -124,29 +124,40 @@
 rules
 
 	//Desugaring SDF Sections
-	desugar-spx : SDFSection ( sectionDef ) -> <add-annotation(|<EnclosingNamespace>)> SDFSection( sectionDef' )
-	with
-		<templatelang-desugar-sdf-top> sectionDef => sectionDef'
-
+	desugar-spx : 
+		SDFSection ( sectionDef ) -> <add-annotation(|<EnclosingNamespace>)> SDFSection( sectionDef' )
+		with
+			<templatelang-desugar-sdf-top> sectionDef => sectionDef'
+		with 
+			<alltd(store-context-free-start-symbols(|<EnclosingParentNamespace>))>sectionDef
+		
+		
   // TODO: Maybe SDFSectionEH can be desugared into SDFSection.
-	desugar-spx : SDFSectionEH ( eh, sectionDef ) -> <add-annotation(|<EnclosingNamespace>)> SDFSectionEH( eh, sectionDef' )
-	with
-    <templatelang-desugar-sdf-top> sectionDef => sectionDef'
+	desugar-spx : 
+		SDFSectionEH ( eh, sectionDef ) -> <add-annotation(|<EnclosingNamespace>)> SDFSectionEH( eh, sectionDef' )
+		with
+    	<templatelang-desugar-sdf-top> sectionDef => sectionDef'
+  	with 
+			<alltd(store-context-free-start-symbols(|<EnclosingParentNamespace>))>sectionDef
 
 rules
 	//Desugaring STR sections
-	desugar-spx : STRSection ( sectionDef ) -> <add-annotation(|<EnclosingNamespace>)> STRSection ( sectionDef' )
+	desugar-spx : 
+		STRSection ( sectionDef ) -> <add-annotation(|<EnclosingNamespace>)> STRSection ( sectionDef' )
 		with
 			<basic-stratego-desugar-top> sectionDef => sectionDef'
-
+			
+				
 rules
 	//Desugaring ESV Sections
-	desugar-spx : ESVSection ( sectionDef ) -> <add-annotation(|<EnclosingNamespace>)> <id>
+	desugar-spx : 
+		ESVSection ( sectionDef ) -> <add-annotation(|<EnclosingNamespace>)> <id>
 		with
 			<alltd(store-langauge-properties(|<EnclosingParentNamespace>))>sectionDef
 
 rules
 	//Desugaring template sections
-  desugar-spx : TemplateSection( sectionDef ) -> <add-annotation(|<EnclosingNamespace>)> TemplateSection( sectionDef' )
-  with
-  	<templatelang-desugar-top> sectionDef => sectionDef'
\ No newline at end of file
+  desugar-spx : 
+  	TemplateSection( sectionDef ) -> <add-annotation(|<EnclosingNamespace>)> TemplateSection( sectionDef' )
+  	with
+  		<templatelang-desugar-top> sectionDef => sectionDef'
\ No newline at end of file

From R.B.Vermaas at tudelft.nl  Mon Jun  6 11:37:18 2011
From: R.B.Vermaas at tudelft.nl (Rob Vermaas)
Date: Mon, 06 Jun 2011 09:37:18 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23006 - hydra/jobs
Message-ID: <20110606093718.919112B8023@mx2.tudelft.nl>

Author: rob
Date: Mon Jun  6 09:37:17 2011
New Revision: 23006
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23006&sc=1

Log:
do not use utils/... use generator/strj locations in stead

Modified:
   hydra/jobs/spoofax-imp.nix

Modified: hydra/jobs/spoofax-imp.nix
==============================================================================
--- hydra/jobs/spoofax-imp.nix	Mon Jun  6 03:49:05 2011	(r23005)
+++ hydra/jobs/spoofax-imp.nix	Mon Jun  6 09:37:17 2011	(r23006)
@@ -176,28 +176,28 @@
             <artifactId>aster</artifactId>
             <version>1.0</version>
             <scope>system</scope>
-            <systemPath>''${basedir}/utils/aster.jar</systemPath>
+            <systemPath>''${basedir}/../org.strategoxt.imp.generator/lib/aster.jar</systemPath>
         </dependency>
         <dependency>
             <groupId>local</groupId>
             <artifactId>strategoxt</artifactId>
             <version>1.0</version>
             <scope>system</scope>
-            <systemPath>''${basedir}/utils/strategoxt.jar</systemPath>
+            <systemPath>''${basedir}/../org.strategoxt.strj/java/strategoxt.jar</systemPath>
         </dependency>
         <dependency>
             <groupId>local</groupId>
             <artifactId>sdf2imp</artifactId>
             <version>1.0</version>
             <scope>system</scope>
-            <systemPath>''${basedir}/utils/sdf2imp.jar</systemPath>
+            <systemPath>''${basedir}/../org.strategoxt.imp.generator/lib/sdf2imp.jar</systemPath>
         </dependency>
         <dependency>
             <groupId>local</groupId>
             <artifactId>make_permissive.jar</artifactId>
             <version>1.0</version>
             <scope>system</scope>
-            <systemPath>''${basedir}/utils/make_permissive.jar</systemPath>
+            <systemPath>''${basedir}/../org.strategoxt.imp.generator/lib/make_permissive.jar</systemPath>
         </dependency>
         <dependency>
            <groupId>com.sun</groupId>
@@ -222,8 +222,8 @@
                   <tasks>
                           <echo>Running ant script</echo>
                           <property name="externaljarx" refid="maven.compile.classpath"/>
-                          <property name="eclipse.spoofaximp.jars" value="utils/"/>
-                          <property name="eclipse.spoofaximp.strategojar" value="utils/strategoxt.jar"/>
+                          <property name="eclipse.spoofaximp.jars" value="../org.strategoxt.imp.generator/lib/"/>
+                          <property name="eclipse.spoofaximp.strategojar" value="../org.strategoxt.strj/java/strategoxt.jar"/>
                           <property name="eclipse.home" value="${eclipse}/eclipse"/>
                           <property name="build.compiler" value="org.eclipse.jdt.core.JDTCompilerAdapter"/>
                           <ant antfile="build.main.xml" inheritRefs="true">
@@ -240,8 +240,8 @@
                <configuration>
                   <tasks>
                           <echo>Running ant script</echo>
-                          <property name="eclipse.spoofaximp.jars" value="utils/"/>
-                          <property name="eclipse.spoofaximp.strategojar" value="utils/strategoxt.jar"/>
+                          <property name="eclipse.spoofaximp.jars" value="../org.strategoxt.imp.generator/lib/"/>
+                          <property name="eclipse.spoofaximp.strategojar" value="../org.strategoxt.strj/java/strategoxt.jar"/>
                           <property name="eclipse.home" value="${eclipse}/eclipse"/>
                           <property name="build.compiler" value="org.eclipse.jdt.core.JDTCompilerAdapter"/>
                           <ant antfile="build.main.xml" inheritRefs="true">
@@ -258,9 +258,6 @@
     </plugins>
 </build></project>' >>$POM
           fi
-          mkdir -p `dirname $e`/utils/
-          cp -v org.strategoxt.imp.generator/lib/*.jar `dirname $e`/utils/
-          cp -v org.strategoxt.strj/java/strategoxt.jar `dirname $e`/utils/
         done
 
         mvn package ${mvnFlags} -e

From R.B.Vermaas at tudelft.nl  Mon Jun  6 11:50:49 2011
From: R.B.Vermaas at tudelft.nl (Rob Vermaas)
Date: Mon, 06 Jun 2011 09:50:49 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23007 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.aster
Message-ID: <20110606095049.660002B8025@mx2.tudelft.nl>

Author: rob
Date: Mon Jun  6 09:50:48 2011
New Revision: 23007
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23007&sc=1

Log:
use aster.jar from eclipse.spoofaximp.jars

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.aster/build.main.xml

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.aster/build.main.xml
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.aster/build.main.xml	Mon Jun  6 09:37:17 2011	(r23006)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.aster/build.main.xml	Mon Jun  6 09:50:48 2011	(r23007)
@@ -23,7 +23,7 @@
                         -la stratego-lib -la stratego-sglr -la stratego-gpp -la stratego-xtc -la stratego-aterm"/>
         
         <property name="externaldef" location="syntax/${sdfmodule}.def"/>
-        <property name="externaljar" value="utils/aster.jar"/>
+        <property name="externaljar" value="${eclipse.spoofaximp.jars}/aster.jar"/>
         <property name="externaljarflags" value="-la org.strategoxt.aster"/>
     
         <!-- Environment configuration for command-line builds -->

From R.B.Vermaas at tudelft.nl  Mon Jun  6 12:09:22 2011
From: R.B.Vermaas at tudelft.nl (Rob Vermaas)
Date: Mon, 06 Jun 2011 10:09:22 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23008 - hydra/jobs
Message-ID: <20110606100922.C8FFFCC141@mx4.tudelft.nl>

Author: rob
Date: Mon Jun  6 10:09:21 2011
New Revision: 23008
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23008&sc=1

Log:


Modified:
   hydra/jobs/spoofax-imp.nix

Modified: hydra/jobs/spoofax-imp.nix
==============================================================================
--- hydra/jobs/spoofax-imp.nix	Mon Jun  6 09:50:48 2011	(r23007)
+++ hydra/jobs/spoofax-imp.nix	Mon Jun  6 10:09:21 2011	(r23008)
@@ -1,8 +1,8 @@
 { nixpkgs ? ../../nixpkgs
-, spoofax ? { outPath = ../../spoofax-new-terms ; rev = 1234; }
-, spoofaxImp ? { outPath = ../../spoofax-imp-new-terms ; rev = 1234; }
+, spoofax ? { outPath = ../../spoofax ; rev = 1234; }
+, spoofaxImp ? { outPath = ../../spoofax-imp ; rev = 1234; }
 , lpgRuntime ? { outPath = ../../lpg.runtime.java ; rev = 1234; }
-, strategoxtJavaBackend ? { outPath = ../../strategoxt-java-backend-new-terms ; rev = 1234; } 
+, strategoxtJavaBackend ? { outPath = ../../strategoxt-java-backend ; rev = 1234; } 
 , hydraConfig ? { outPath = ../.; rev = 1234; }
 }:
 let 
@@ -222,8 +222,8 @@
                   <tasks>
                           <echo>Running ant script</echo>
                           <property name="externaljarx" refid="maven.compile.classpath"/>
-                          <property name="eclipse.spoofaximp.jars" value="../org.strategoxt.imp.generator/lib/"/>
-                          <property name="eclipse.spoofaximp.strategojar" value="../org.strategoxt.strj/java/strategoxt.jar"/>
+                          <property name="eclipse.spoofaximp.jars" value="''${basedir}/../org.strategoxt.imp.generator/lib/"/>
+                          <property name="eclipse.spoofaximp.strategojar" value="''${basedir}/../org.strategoxt.strj/java/strategoxt.jar"/>
                           <property name="eclipse.home" value="${eclipse}/eclipse"/>
                           <property name="build.compiler" value="org.eclipse.jdt.core.JDTCompilerAdapter"/>
                           <ant antfile="build.main.xml" inheritRefs="true">
@@ -240,8 +240,8 @@
                <configuration>
                   <tasks>
                           <echo>Running ant script</echo>
-                          <property name="eclipse.spoofaximp.jars" value="../org.strategoxt.imp.generator/lib/"/>
-                          <property name="eclipse.spoofaximp.strategojar" value="../org.strategoxt.strj/java/strategoxt.jar"/>
+                          <property name="eclipse.spoofaximp.jars" value="''${basedir}/../org.strategoxt.imp.generator/lib/"/>
+                          <property name="eclipse.spoofaximp.strategojar" value="''${basedir}/../org.strategoxt.strj/java/strategoxt.jar"/>
                           <property name="eclipse.home" value="${eclipse}/eclipse"/>
                           <property name="build.compiler" value="org.eclipse.jdt.core.JDTCompilerAdapter"/>
                           <ant antfile="build.main.xml" inheritRefs="true">

From tobivollebregt at gmail.com  Mon Jun  6 13:41:24 2011
From: tobivollebregt at gmail.com (Tobi Vollebregt)
Date: Mon, 06 Jun 2011 11:41:24 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23009 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/sdf
Message-ID: <20110606114124.F278B2B8023@mx2.tudelft.nl>

Author: tvo
Date: Mon Jun  6 11:41:19 2011
New Revision: 23009
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23009&sc=1

Log:
SpoofaxLang/Template: fix TemplateLang SDF sugar

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/sdf/to-sdf.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/sdf/to-sdf.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/sdf/to-sdf.str	Mon Jun  6 10:09:21 2011	(r23008)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/sdf/to-sdf.str	Mon Jun  6 11:41:19 2011	(r23009)
@@ -16,6 +16,7 @@
 imports
   normalize/main
 	normalize/signatures
+	normalize/templatelang
 imports
 	common
 	config
@@ -216,3 +217,6 @@
     SortCons(sort, cons) -> t
     with t := <( Declaration <+ debug(!"Undeclared SortCons"); <debug(!"all-keys-Declaration: ")> <all-keys-Declaration>; fail )
                ; try(template-production-to-sdf-no-attrs)> (<to-scoped-symbol>sort, <to-scoped-symbol>cons)
+
+  // Hook desugar-sdf-redux to templatelang-desugar-sdf
+  desugar-sdf-redux = templatelang-desugar-sdf

From emma at cs.lth.se  Mon Jun  6 14:40:37 2011
From: emma at cs.lth.se (Emma Nilsson-Nyman)
Date: Mon, 06 Jun 2011 12:40:37 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23010 - in
	sglr-recovery/trunk/bridge-definitions/grammars/generated: .
	javasql strategojava
Message-ID: <20110606124038.0366ACC134@mx4.tudelft.nl>

Author: EmmaNilssonNyman
Date: Mon Jun  6 12:40:36 2011
New Revision: 23010
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23010&sc=1

Log:
bridge parsers for Java, Java-SQL, Stratego-Java and WebDSL

Added:
   sglr-recovery/trunk/bridge-definitions/grammars/generated/
   sglr-recovery/trunk/bridge-definitions/grammars/generated/Java-SQL.bp
   sglr-recovery/trunk/bridge-definitions/grammars/generated/Java.bp
   sglr-recovery/trunk/bridge-definitions/grammars/generated/Layout.bp
   sglr-recovery/trunk/bridge-definitions/grammars/generated/Stratego-Java.bp
   sglr-recovery/trunk/bridge-definitions/grammars/generated/WebDSL.bp
   sglr-recovery/trunk/bridge-definitions/grammars/generated/bridget   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/bridget.jar   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-java-sql.sh   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-java.sh   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-stratego-java.sh   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-webdsl.sh   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java.jar   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql.jar   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/run-java-sql.sh   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/run-java.sh   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/run-stratego-java.sh   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/run-webdsl.sh   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava.jar   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl.jar   (contents, props changed)

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/Java-SQL.bp
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/Java-SQL.bp	Mon Jun  6 12:40:36 2011	(r23010)
@@ -0,0 +1,11 @@
+grammar Main;
+
+import Java ;
+
+// Islands and bridges
+
+island LSQL : SimpleStartIsland = "<|" ; 
+island RSQL : SimpleEndIsland = "|>" ;
+bridge from LSQL to RSQL ;
+
+

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/Java.bp
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/Java.bp	Mon Jun  6 12:40:36 2011	(r23010)
@@ -0,0 +1,34 @@
+grammar Main;
+
+import Layout ;
+
+
+// Islands and bridges
+
+island LBrace : LayoutStartIsland = "{" ;
+island RBrace : LayoutEndIsland = "}"  ;
+bridge from LBrace to RBrace ;
+
+island LBrack : SimpleStartIsland = "[" ;
+island RBrack : SimpleEndIsland = "]" ;
+bridge from LBrack to RBrack ;
+
+island LParen : SimpleStartIsland = "(" ; 
+island RParen : SimpleEndIsland = ")" ;
+bridge from LParen to RParen ;
+
+
+// Reefs
+
+reef Layout : LayoutReef = NEWLINE (TAB|WS)* ;
+
+
+// Ignores
+
+ignore LineComment "//" to NEWLINE ;
+ignore MultiComment "/*" to "*/" ;
+ignore String "\"" to "\"" ;
+
+
+
+

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/Layout.bp
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/Layout.bp	Mon Jun  6 12:40:36 2011	(r23010)
@@ -0,0 +1,85 @@
+grammar Layout;
+
+/*
+ * Layout recovery for structural islands
+ */
+
+abstract island LayoutStartIsland;
+abstract island LayoutEndIsland;
+
+abstract reef LayoutReef;
+
+java-attr int LayoutReef.pos = 
+@@
+	int pos = 0;
+	char[] chars = value.toCharArray();
+	for (int i = chars.length-1; i >= 0; i--) {
+		switch(chars[i]) {
+			case ' '  : pos++; break;
+			case '\t' : pos += 4; break; // TAB_SIZE=4
+		}
+		if (chars[i] == '\n') {
+			break;
+		}
+	}
+	return pos;
+@@
+
+attr LayoutReef LayoutStartIsland.indent = [first left LayoutReef];
+attr LayoutReef LayoutEndIsland.indent = [first left LayoutReef];
+
+attr LexicalNode LayoutReef.rightNeighbour = [first right LexicalNode];
+
+java-attr boolean LayoutReef.startOfEmptyLine =
+@@
+    return rightNeighbour() != null && rightNeighbour() instanceof LayoutReef;
+@@
+
+
+bridge from LayoutStartIsland to LayoutEndIsland 
+	when ((start.indent == null && 0 == end.indent.pos) ||
+        (start.indent != null && start.indent.pos == end.indent.pos));
+
+recover LayoutStartIsland 
+	find [a:LayoutReef] 
+		where (a.startOfEmptyLine != true && a.pos <= this.indent.pos)
+		insert bridge-end before a;
+	find [b:LayoutEndIsland]
+		where (!(b.hasBridge) && b.indent.pos < this.indent.pos)
+		insert bridge-end before b;
+
+recover LayoutEndIsland
+	// Make sure to jump over the indentation of this node otherwise
+	// it will always match its own indentation reef.
+	find [a:LayoutReef b:LayoutReef]
+		where (a.startOfEmptyLine != true && b.startOfEmptyLine != true &&
+            a != this.indent && a.pos <= this.indent.pos)
+		insert bridge-start before b;
+	find [b:LayoutStartIsland]
+		where (!(b.hasBridge) && this.indent.pos < b.indent.pos)
+		insert bridge-start after b; 		
+
+/* 
+ * Simple recovery for non-structural islands 
+ */ 
+
+abstract island SimpleStartIsland : LayoutStartIsland;
+abstract island SimpleEndIsland : LayoutEndIsland;
+
+java-attr boolean LayoutStartIsland.isStructural = @@ return true; @@
+java-attr boolean LayoutEndIsland.isStructural = @@ return true; @@
+java-attr boolean SimpleStartIsland.isStructural = @@ return false; @@
+java-attr boolean SimpleEndIsland.isStructural = @@ return false; @@
+
+bridge from SimpleStartIsland to SimpleEndIsland when (true);
+
+recover SimpleStartIsland 
+	find [a:Reef] where (true) insert bridge-end before a;
+	find [a:LayoutStartIsland] where (a.isStructural) insert bridge-end before a;
+	use-super;
+
+recover SimpleEndIsland
+	find [a:Reef] where (true) insert bridge-start after a;
+	find [a:LayoutEndIsland] where (a.isStructural) insert bridge-start after a;
+	use-super;
+		

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/Stratego-Java.bp
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/Stratego-Java.bp	Mon Jun  6 12:40:36 2011	(r23010)
@@ -0,0 +1,13 @@
+grammar Main;
+
+import Java ;
+
+
+// Islands and bridges
+
+island LStratego : SimpleStartIsland = "|[" ;
+island RStratego : SimpleEndIsland = "]|" ;
+bridge from LStratego to RStratego ;
+
+
+

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/WebDSL.bp
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/WebDSL.bp	Mon Jun  6 12:40:36 2011	(r23010)
@@ -0,0 +1,9 @@
+grammar Main;
+
+import Java ;
+
+// Ignores
+
+ignore Script "<script>" to "</script>" ;
+
+

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/bridget
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/bridget	Mon Jun  6 12:40:36 2011	(r23010)
@@ -0,0 +1,5 @@
+#!/bin/sh
+
+java -jar bridget.jar $@
+
+exit

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/bridget.jar
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-java-sql.sh
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-java-sql.sh	Mon Jun  6 12:40:36 2011	(r23010)
@@ -0,0 +1,15 @@
+#!/bin/sh
+
+
+./bridget --output-dir=javasql --grammar-path=. --package=javasql Java-SQL.bp
+
+echo -n 'Compiling generated classes ... '
+javac -cp .:bridget.jar javasql/*.java
+echo 'done.'
+
+echo -n 'Creating bridge parser jar file ... '
+jar cfe javasql.jar javasql/*.class javasql/*.java
+echo 'done.'
+
+
+exit

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-java.sh
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-java.sh	Mon Jun  6 12:40:36 2011	(r23010)
@@ -0,0 +1,14 @@
+#!/bin/sh
+
+
+./bridget --output-dir=java --grammar-path=. --package=java Java.bp
+
+echo -n 'Compiling generated classes ... '
+javac -cp .:bridget.jar java/*.java
+echo 'done.'
+
+echo -n 'Creating bridge parser jar file ... '
+jar cfe java.jar java/*.class java/*.java
+echo 'done.'
+
+exit

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-stratego-java.sh
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-stratego-java.sh	Mon Jun  6 12:40:36 2011	(r23010)
@@ -0,0 +1,14 @@
+#!/bin/sh
+
+
+./bridget --output-dir=strategojava --grammar-path=. --package=strategojava Stratego-Java-15.bp
+
+echo -n 'Compiling generated classes ... '
+javac -cp .:bridget.jar strategojava/*.java
+echo 'done.'
+
+echo -n 'Creating bridge parser jar file ... '
+jar cfe strageojava.jar strategojava/*.class strategojava/*.java
+echo 'done.'
+
+exit

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-webdsl.sh
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-webdsl.sh	Mon Jun  6 12:40:36 2011	(r23010)
@@ -0,0 +1,14 @@
+#!/bin/sh
+
+
+./bridget --output-dir=webdsl --grammar-path=. --package=webdsl WebDSL.bp
+
+echo -n 'Compiling generated classes ... '
+javac -cp .:bridget.jar webdsl/*.java
+echo 'done.'
+
+echo -n 'Creating bridge parser jar file ... '
+jar cfe webdsl.jar webdsl/*.class webdsl/*.java
+echo 'done.'
+
+exit

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/java.jar
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql.jar
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/run-java-sql.sh
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/run-java-sql.sh	Mon Jun  6 12:40:36 2011	(r23010)
@@ -0,0 +1,6 @@
+#!/bin/sh
+
+
+java -cp .:bridget.jar:javasql.jar javasql.MainBridgeParser
+
+exit

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/run-java.sh
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/run-java.sh	Mon Jun  6 12:40:36 2011	(r23010)
@@ -0,0 +1,6 @@
+#!/bin/sh
+
+
+java -cp .:bridget.jar:java.jar java.MainBridgeParser
+
+exit

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/run-stratego-java.sh
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/run-stratego-java.sh	Mon Jun  6 12:40:36 2011	(r23010)
@@ -0,0 +1,6 @@
+#!/bin/sh
+
+
+java -cp .:bridget.jar:stategojava.jar strategojava.MainBridgeParser
+
+exit

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/run-webdsl.sh
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/run-webdsl.sh	Mon Jun  6 12:40:36 2011	(r23010)
@@ -0,0 +1,6 @@
+#!/bin/sh
+
+
+java -cp .:bridget.jar:webdsl.jar webdsl.MainBridgeParser
+
+exit

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava.jar
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl.jar
==============================================================================
Binary file. No diff available.

From emma at cs.lth.se  Mon Jun  6 14:43:05 2011
From: emma at cs.lth.se (Emma Nilsson-Nyman)
Date: Mon, 06 Jun 2011 12:43:05 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23011 - in
	sglr-recovery/trunk/bridge-definitions/grammars/generated: .
	java webdsl
Message-ID: <20110606124305.F2192CC134@mx4.tudelft.nl>

Author: EmmaNilssonNyman
Date: Mon Jun  6 12:43:05 2011
New Revision: 23011
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23011&sc=1

Log:
some build fixes

Added:
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java/
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/
Modified:
   sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-stratego-java.sh
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java.jar
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql.jar
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl.jar

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-stratego-java.sh
==============================================================================
--- sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-stratego-java.sh	Mon Jun  6 12:40:36 2011	(r23010)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-stratego-java.sh	Mon Jun  6 12:43:05 2011	(r23011)
@@ -1,7 +1,7 @@
 #!/bin/sh
 
 
-./bridget --output-dir=strategojava --grammar-path=. --package=strategojava Stratego-Java-15.bp
+./bridget --output-dir=strategojava --grammar-path=. --package=strategojava Stratego-Java.bp
 
 echo -n 'Compiling generated classes ... '
 javac -cp .:bridget.jar strategojava/*.java

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/java.jar
==============================================================================
Binary file (source and/or target). No diff available.

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql.jar
==============================================================================
Binary file (source and/or target). No diff available.

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl.jar
==============================================================================
Binary file (source and/or target). No diff available.

From emma at cs.lth.se  Mon Jun  6 14:45:19 2011
From: emma at cs.lth.se (Emma Nilsson-Nyman)
Date: Mon, 06 Jun 2011 12:45:19 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23012 - in
	sglr-recovery/trunk/bridge-definitions/grammars/generated: . java
Message-ID: <20110606124520.10C147F802D@mx1.tudelft.nl>

Author: EmmaNilssonNyman
Date: Mon Jun  6 12:45:19 2011
New Revision: 23012
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23012&sc=1

Log:
build fixes

Added:
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java15.jar   (contents, props changed)
Deleted:
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java/
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java.jar
Modified:
   sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-java.sh
   sglr-recovery/trunk/bridge-definitions/grammars/generated/run-java.sh

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-java.sh
==============================================================================
--- sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-java.sh	Mon Jun  6 12:43:05 2011	(r23011)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-java.sh	Mon Jun  6 12:45:19 2011	(r23012)
@@ -1,14 +1,14 @@
 #!/bin/sh
 
 
-./bridget --output-dir=java --grammar-path=. --package=java Java.bp
+./bridget --output-dir=java15 --grammar-path=. --package=java15 Java.bp
 
 echo -n 'Compiling generated classes ... '
-javac -cp .:bridget.jar java/*.java
+javac -cp .:bridget.jar java15/*.java
 echo 'done.'
 
 echo -n 'Creating bridge parser jar file ... '
-jar cfe java.jar java/*.class java/*.java
+jar cfe java15.jar java15/*.class java15/*.java
 echo 'done.'
 
 exit

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/java15.jar
==============================================================================
Binary file. No diff available.

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/run-java.sh
==============================================================================
--- sglr-recovery/trunk/bridge-definitions/grammars/generated/run-java.sh	Mon Jun  6 12:43:05 2011	(r23011)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/run-java.sh	Mon Jun  6 12:45:19 2011	(r23012)
@@ -1,6 +1,6 @@
 #!/bin/sh
 
 
-java -cp .:bridget.jar:java.jar java.MainBridgeParser
+java -cp .:bridget.jar:java15.jar java15.MainBridgeParser
 
 exit

From emma at cs.lth.se  Mon Jun  6 14:46:32 2011
From: emma at cs.lth.se (Emma Nilsson-Nyman)
Date: Mon, 06 Jun 2011 12:46:32 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23013 -
	sglr-recovery/trunk/bridge-definitions/grammars/generated
Message-ID: <20110606124632.B3E37CC041@mx4.tudelft.nl>

Author: EmmaNilssonNyman
Date: Mon Jun  6 12:46:31 2011
New Revision: 23013
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23013&sc=1

Log:
Build fix

Modified:
   sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-stratego-java.sh
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava.jar

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-stratego-java.sh
==============================================================================
--- sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-stratego-java.sh	Mon Jun  6 12:45:19 2011	(r23012)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-stratego-java.sh	Mon Jun  6 12:46:31 2011	(r23013)
@@ -8,7 +8,7 @@
 echo 'done.'
 
 echo -n 'Creating bridge parser jar file ... '
-jar cfe strageojava.jar strategojava/*.class strategojava/*.java
+jar cfe strategojava.jar strategojava/*.class strategojava/*.java
 echo 'done.'
 
 exit

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava.jar
==============================================================================
Binary file (source and/or target). No diff available.

From tobivollebregt at gmail.com  Mon Jun  6 16:46:17 2011
From: tobivollebregt at gmail.com (Tobi Vollebregt)
Date: Mon, 06 Jun 2011 14:46:17 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23014 -
	spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services
Message-ID: <20110606144617.583947F802C@mx1.tudelft.nl>

Author: tvo
Date: Mon Jun  6 14:46:16 2011
New Revision: 23014
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23014&sc=1

Log:
fix NPE

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/ContentProposal.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/ContentProposal.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/ContentProposal.java	Mon Jun  6 12:46:31 2011	(r23013)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/ContentProposal.java	Mon Jun  6 14:46:16 2011	(r23014)
@@ -84,6 +84,7 @@
 	}
 	
 	private String escapeHtml(String input) {
+		if (input == null) return null;
 		return input.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;");
 	}
 

From m.dejonge at tudelft.nl  Tue Jun  7 10:24:24 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Tue, 07 Jun 2011 08:24:24 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23015 - in
	spoofax-imp/trunk: org.strategoxt.imp.generator/src/sdf2imp/project
	org.strategoxt.imp.runtime org.strategoxt.imp.runtime/META-INF
	org.strategoxt.imp.runtime/sr...
Message-ID: <20110607082424.C2B007F8068@mx1.tudelft.nl>

Author: MaartjeDeJonge
Date: Tue Jun  7 08:24:23 2011
New Revision: 23015
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23015&sc=1

Log:
support for (Rename) refactoring:
- user interaction handled in eclipse (ltk)
- Refactoring button in toolbar (TODO: should be context menu)
- transformation rule: (input, ....) -> (ast-changes, errors, warnings)

Added:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/RefactoringFactory.java   (contents, props changed)
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/IRefactoring.java   (contents, props changed)
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/IRefactoringMap.java   (contents, props changed)
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/RefactoringButtonDelegate.java   (contents, props changed)
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/RefactoringMap.java   (contents, props changed)
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/RefactoringPageTextField.java   (contents, props changed)
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoRefactoringWizard.java   (contents, props changed)
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/ToolbarButtonDelegate.java   (contents, props changed)
Modified:
   spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-example-trans.str
   spoofax-imp/trunk/org.strategoxt.imp.runtime/META-INF/MANIFEST.MF
   spoofax-imp/trunk/org.strategoxt.imp.runtime/plugin.xml
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/BuilderFactory.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/Descriptor.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/BuilderButtonDelegate.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/InputTermBuilder.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoRefactoring.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-example-trans.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-example-trans.str	Mon Jun  6 14:46:16 2011	(r23014)
+++ spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-example-trans.str	Tue Jun  7 08:24:23 2011	(r23015)
@@ -198,20 +198,26 @@
   lib/refactor-common.generated
   include/{sdf-name}
   lib/editor-common.generated  
+  entitiesrefactorings
 
 rules
  
   rename-entity:
-    (selected-name, position, ast, path, project-path) -> [(ast, new-ast)]
+    (newname, selected-name, position, ast, path, project-path) -> ([(ast, new-ast)], warnings, errors)
     with
-      new-name := <input-dialog> ("{<get-sdf-main-module>}", "rename", "Rename entity:", ""); 
-      new-ast  := <topdown(try(rename-type(|selected-name, new-name)))> ast
+      new-ast  := <topdown(try(rename-type(|selected-name, newname)))> ast; 
+      (warnings, errors) := <semantic-constraint-issues> (ast, new-ast)
 
   rename-type(|old-name, new-name):
     Entity(old-name, y) -> Entity(new-name, y)
 
   rename-type(|old-name, new-name):
     Type(old-name) -> Type(new-name)
-
+    
+  semantic-constraint-issues:
+    (ast, new-ast) -> (<diff>(new-warnings, warnings), <diff>(new-errors, errors))
+    where
+    	(_, errors, warnings, _) := <editor-analyze> (ast, "", "");
+    	(_, new-errors, new-warnings, _) := <editor-analyze> (new-ast, "", "")
 }
 end

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/META-INF/MANIFEST.MF
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/META-INF/MANIFEST.MF	Mon Jun  6 14:46:16 2011	(r23014)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/META-INF/MANIFEST.MF	Tue Jun  7 08:24:23 2011	(r23015)
@@ -35,3 +35,5 @@
 Bundle-Vendor: Spoofax.org
 Bundle-ActivationPolicy: lazy
 Bundle-Activator: org.strategoxt.imp.runtime.RuntimeActivator
+Import-Package: org.eclipse.ltk.core.refactoring,
+ org.eclipse.ltk.ui.refactoring

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/plugin.xml
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/plugin.xml	Mon Jun  6 14:46:16 2011	(r23014)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/plugin.xml	Tue Jun  7 08:24:23 2011	(r23015)
@@ -275,6 +275,13 @@
                toolbarPath="spoofax"
                tooltip="Apply transformation to file in current editor"/>
                <!-- TODO: icon="icons/builder.png" -->
+         <action
+               class="org.strategoxt.imp.runtime.services.RefactoringButtonDelegate"
+               id="org.strategoxt.imp.runtime.stratego.refactoring"
+               label="Refactor"
+               style="pulldown"
+               toolbarPath="spoofax"
+               tooltip="Apply refactoring to file in current editor"/>
       </actionSet>
    </extension>
    <extension

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/BuilderFactory.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/BuilderFactory.java	Mon Jun  6 14:46:16 2011	(r23014)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/BuilderFactory.java	Tue Jun  7 08:24:23 2011	(r23015)
@@ -20,11 +20,9 @@
 import org.strategoxt.imp.runtime.services.DebugModeBuilder;
 import org.strategoxt.imp.runtime.services.IBuilder;
 import org.strategoxt.imp.runtime.services.IBuilderMap;
-import org.strategoxt.imp.runtime.services.InputTermBuilder;
 import org.strategoxt.imp.runtime.services.StrategoBuilder;
 import org.strategoxt.imp.runtime.services.StrategoBuilderListener;
 import org.strategoxt.imp.runtime.services.StrategoObserver;
-import org.strategoxt.imp.runtime.services.StrategoRefactoring;
 
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
@@ -46,12 +44,6 @@
 
 		addBuilders(d, controller, builders, null);
 		addCustomStrategyBuilder(d, controller, builders, derivedFromEditor);
-		try {
-			if (EditorState.isUIThread()) // don't show for background (realtime) builders; not threadsafe
-				addRefactorings(d, controller, builders);
-		} catch (RuntimeException e) { // defensive coding...
-			Environment.logException("Could not determine possible refactorings", e);
-		}
 		if (Environment.allowsDebugging(d)) // Descriptor allows debugging)
 		{
 			addDebugModeBuilder(d, controller, builders, derivedFromEditor);
@@ -99,72 +91,6 @@
 		}
 	}
 	
-	private static void addRefactorings(Descriptor d, SGLRParseController controller, Set<IBuilder> builders) throws BadDescriptorException {
-				
-		StrategoObserver feedback = d.createService(StrategoObserver.class, controller);
-		
-		IStrategoAppl ppTableTerm = TermReader.findTerm(d.getDocument(), "PPTable");
-		String ppTable=null;
-		if (ppTableTerm !=null)
-			ppTable=termContents(termAt(ppTableTerm, 0));
-		IStrategoAppl ppStrategyTerm = TermReader.findTerm(d.getDocument(), "PrettyPrint");
-		String ppStrategy=null;
-		if(ppStrategyTerm!=null)
-			ppStrategy=termContents(termAt(ppStrategyTerm, 0));
-		
-		IStrategoTerm node = controller.getEditor().getSelectionAst(false);
-		for (IStrategoAppl builder : collectTerms(d.getDocument(), "Refactoring")) {
-			IStrategoTerm[] semanticNodes = termAt(builder,0).getAllSubterms();
-			if(getMatchingSelectionNode(semanticNodes, node) != null){
-				String caption = termContents(termAt(builder, 1));
-				String strategy = termContents(termAt(builder, 2));
-				IStrategoList options = termAt(builder, 3);			
-				boolean cursor = false;
-				boolean source = false;
-				boolean meta = false;
-				for (IStrategoTerm option : options.getAllSubterms()) {
-					String type = cons(option);
-					if (type.equals("Cursor")) {
-						cursor = true;
-					} else if (type.equals("Source")) {
-						source = true;
-					} else if (type.equals("Meta")) {
-						meta = true;
-					} else if (
-							type.equals("OpenEditor") ||
-							type.equals("RealTime") ||
-							type.equals("Persistent")
-						){
-						Environment.logWarning("Unused builder annotation '"+ type + "' in '" + caption +"'");
-					}
-					else {
-						throw new BadDescriptorException("Unknown builder annotation: " + type);
-					}
-				}
-				if (!meta || d.isDynamicallyLoaded()){			
-					builders.add(
-						new StrategoRefactoring(
-							feedback, 
-							caption, 
-							strategy,
-							cursor, 
-							source, 
-							ppTable,
-							ppStrategy,
-							controller.getResource(), 
-							semanticNodes
-						)
-					);
-				}
-			}
-		}
-	}
-
-	private static IStrategoTerm getMatchingSelectionNode(IStrategoTerm[] semanticNodes, IStrategoTerm node)
-			throws BadDescriptorException {
-		return InputTermBuilder.getMatchingNode(semanticNodes, node, false);
-	}
-
 	private static void addDerivedBuilders(EditorState derivedFromEditor, Set<IBuilder> builders)
 			throws BadDescriptorException {		
 		if (derivedFromEditor != null){

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/Descriptor.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/Descriptor.java	Mon Jun  6 14:46:16 2011	(r23014)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/Descriptor.java	Tue Jun  7 08:24:23 2011	(r23015)
@@ -36,6 +36,7 @@
 import org.strategoxt.imp.runtime.Environment;
 import org.strategoxt.imp.runtime.RuntimeActivator;
 import org.strategoxt.imp.runtime.parser.SGLRParseController;
+import org.strategoxt.imp.runtime.services.IRefactoringMap;
 import org.strategoxt.imp.runtime.services.MetaFileLanguageValidator;
 import org.strategoxt.lang.WeakValueHashMap;
 
@@ -115,6 +116,7 @@
 		serviceFactories.add(new SyntaxPropertiesFactory());
 		serviceFactories.add(new TokenColorerFactory());
 		serviceFactories.add(new BuilderFactory());
+		serviceFactories.add(new RefactoringFactory());
 		serviceFactories.add(new ContentProposerFactory());
 		serviceFactories.add(new LabelProviderFactory());
 		serviceFactories.add(new AutoEditStrategyFactory());

Added: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/RefactoringFactory.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/RefactoringFactory.java	Tue Jun  7 08:24:23 2011	(r23015)
@@ -0,0 +1,106 @@
+package org.strategoxt.imp.runtime.dynamicloading;
+
+
+import static org.spoofax.interpreter.core.Tools.termAt;
+import static org.strategoxt.imp.runtime.dynamicloading.TermReader.collectTerms;
+import static org.strategoxt.imp.runtime.dynamicloading.TermReader.cons;
+import static org.strategoxt.imp.runtime.dynamicloading.TermReader.termContents;
+import java.util.LinkedHashSet;
+import java.util.Set;
+
+import org.eclipse.jface.action.Action;
+import org.eclipse.jface.action.IAction;
+import org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation;
+import org.eclipse.swt.widgets.Shell;
+import org.spoofax.interpreter.terms.IStrategoAppl;
+import org.spoofax.interpreter.terms.IStrategoList;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.strategoxt.imp.runtime.EditorState;
+import org.strategoxt.imp.runtime.Environment;
+import org.strategoxt.imp.runtime.parser.SGLRParseController;
+import org.strategoxt.imp.runtime.services.IRefactoring;
+import org.strategoxt.imp.runtime.services.IRefactoringMap;
+import org.strategoxt.imp.runtime.services.InputTermBuilder;
+import org.strategoxt.imp.runtime.services.RefactoringMap;
+import org.strategoxt.imp.runtime.services.StrategoObserver;
+import org.strategoxt.imp.runtime.services.StrategoRefactoring;
+import org.strategoxt.imp.runtime.services.StrategoRefactoringWizard;
+
+public class RefactoringFactory extends AbstractServiceFactory<IRefactoringMap> {
+
+	public RefactoringFactory() {
+		super(IRefactoringMap.class, false); // not cached; depends on derived editor relation
+	}
+
+	@Override
+	public IRefactoringMap create(Descriptor descriptor, SGLRParseController controller)
+			throws BadDescriptorException {
+		Set<IRefactoring> refactorings = collectRefactorings(descriptor, controller);
+		return new RefactoringMap(refactorings);
+	}
+
+	private static Set<IRefactoring> collectRefactorings(Descriptor d, SGLRParseController controller) throws BadDescriptorException {
+		Set<IRefactoring> refactorings = new LinkedHashSet<IRefactoring>();
+		StrategoObserver feedback = d.createService(StrategoObserver.class, controller);
+		IStrategoAppl ppTableTerm = TermReader.findTerm(d.getDocument(), "PPTable");
+		String ppTable=null;
+		if (ppTableTerm !=null)
+			ppTable=termContents(termAt(ppTableTerm, 0));
+		IStrategoAppl ppStrategyTerm = TermReader.findTerm(d.getDocument(), "PrettyPrint");
+		String ppStrategy=null;
+		if(ppStrategyTerm!=null)
+			ppStrategy=termContents(termAt(ppStrategyTerm, 0));		
+		IStrategoTerm node = controller.getEditor().getSelectionAst(false);
+		for (IStrategoAppl builder : collectTerms(d.getDocument(), "Refactoring")) {
+			IStrategoTerm[] semanticNodes = termAt(builder,0).getAllSubterms();
+			if(getMatchingSelectionNode(semanticNodes, node) != null){
+				String caption = termContents(termAt(builder, 1));
+				String strategy = termContents(termAt(builder, 2));
+				IStrategoList options = termAt(builder, 3);			
+				boolean cursor = false;
+				boolean source = false;
+				boolean meta = false;
+				for (IStrategoTerm option : options.getAllSubterms()) {
+					String type = cons(option);
+					if (type.equals("Cursor")) {
+						cursor = true;
+					} else if (type.equals("Source")) {
+						source = true;
+					} else if (type.equals("Meta")) {
+						meta = true;
+					} else if (
+							type.equals("OpenEditor") ||
+							type.equals("RealTime") ||
+							type.equals("Persistent")
+						){
+						Environment.logWarning("Unused builder annotation '"+ type + "' in '" + caption +"'");
+					}
+					else {
+						throw new BadDescriptorException("Unknown builder annotation: " + type);
+					}
+				}
+				if (!meta || d.isDynamicallyLoaded()){			
+					refactorings.add(
+						new StrategoRefactoring(
+							feedback, 
+							caption, 
+							strategy,
+							cursor, 
+							source, 
+							ppTable,
+							ppStrategy,
+							semanticNodes
+						)
+					);
+				}
+			}
+		}
+		return refactorings;
+	}
+
+	private static IStrategoTerm getMatchingSelectionNode(IStrategoTerm[] semanticNodes,
+			IStrategoTerm node) throws BadDescriptorException {
+		return InputTermBuilder.getMatchingNode(semanticNodes, node, false);
+	}
+
+}

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/BuilderButtonDelegate.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/BuilderButtonDelegate.java	Mon Jun  6 14:46:16 2011	(r23014)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/BuilderButtonDelegate.java	Tue Jun  7 08:24:23 2011	(r23015)
@@ -1,8 +1,5 @@
 package org.strategoxt.imp.runtime.services;
 
-import org.eclipse.core.commands.AbstractHandler;
-import org.eclipse.core.commands.ExecutionEvent;
-import org.eclipse.core.commands.ExecutionException;
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.core.runtime.Status;
 import org.eclipse.imp.ui.DefaultPartListener;
@@ -10,9 +7,7 @@
 import org.eclipse.jface.action.ActionContributionItem;
 import org.eclipse.jface.action.IAction;
 import org.eclipse.jface.dialogs.ErrorDialog;
-import org.eclipse.jface.viewers.ISelection;
 import org.eclipse.swt.SWT;
-import org.eclipse.swt.widgets.Control;
 import org.eclipse.swt.widgets.Menu;
 import org.eclipse.swt.widgets.MenuItem;
 import org.eclipse.ui.IWorkbenchPart;
@@ -29,12 +24,9 @@
  * 
  * @author Lennart Kats <lennart add lclnet.nl>
  */
-public class BuilderButtonDelegate extends AbstractHandler implements IWorkbenchWindowPulldownDelegate {
+public class BuilderButtonDelegate extends ToolbarButtonDelegate implements IWorkbenchWindowPulldownDelegate {
 	
-	private static String lastAction;
-	
-	private Menu menu;
-
+	@Override
 	public void init(IWorkbenchWindow window) {
 		// Initialized using getMenu()
 		window.getPartService().addPartListener(new DefaultPartListener() {
@@ -55,13 +47,13 @@
 		});
 	}
 
-	public void run(IAction action) {
+	@Override
+	public void run(IAction action) {		
 		EditorState editor = EditorState.getActiveEditor();
 		if (editor == null) {
 			openError("No builders defined for this editor");
 			return;
 		}
-		
 		IBuilderMap builders = getBuilders(editor);
 		IBuilder builder = builders.get(lastAction);
 		if (builder == null && builders.getAll().size() > 0) {
@@ -74,16 +66,8 @@
 		}
 	}
 
-	public Object execute(ExecutionEvent event) throws ExecutionException {
-		run(null);
-		return null;
-	}
-	
-	public void selectionChanged(IAction action, ISelection selection) {
-		// Unused
-	}
-		
-	private void populateMenu(Menu menu) {
+	@Override
+	protected void populateMenu(Menu menu) {
 		MenuItem dummy = new MenuItem(menu, SWT.PUSH);
 		dummy.setText("No builders defined for this editor");
 		
@@ -122,28 +106,4 @@
 		}
 		return builders;
 	}
-
-	private void openError(String message) {
-		Status status = new Status(IStatus.ERROR, RuntimeActivator.PLUGIN_ID, message);
-		ErrorDialog.openError(null, "Spoofax/IMP builder", null, status);
-	}
-		
-	@Override
-	public void dispose() {
-		if (menu != null) {
-			menu.dispose();
-			menu = null;
-		}
-		super.dispose();
-	}
-
-	public Menu getMenu(Control parent) {
-		if (menu != null) {
-			menu.dispose();
-		}
-		menu = new Menu(parent);
-		populateMenu(menu);
-		return menu;
-	}
-
 }

Added: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/IRefactoring.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/IRefactoring.java	Tue Jun  7 08:24:23 2011	(r23015)
@@ -0,0 +1,18 @@
+package org.strategoxt.imp.runtime.services;
+
+import org.strategoxt.imp.runtime.EditorState;
+
+/**
+ * @author Maartje de Jonge
+ */
+public interface IRefactoring {
+
+	String getCaption();
+	
+	String getActionDefinitionId();
+	
+	String getName();
+
+	void prepareExecute(EditorState editor);
+
+}

Added: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/IRefactoringMap.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/IRefactoringMap.java	Tue Jun  7 08:24:23 2011	(r23015)
@@ -0,0 +1,15 @@
+package org.strategoxt.imp.runtime.services;
+
+import java.util.Set;
+
+import org.eclipse.imp.language.ILanguageService;
+
+/**
+ * @author Maartje de Jonge
+ */
+public interface IRefactoringMap extends ILanguageService {
+	
+	Set<IRefactoring> getAll();
+	
+	IRefactoring get(String name);
+}

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/InputTermBuilder.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/InputTermBuilder.java	Mon Jun  6 14:46:16 2011	(r23014)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/InputTermBuilder.java	Tue Jun  7 08:24:23 2011	(r23015)
@@ -66,7 +66,7 @@
 	public IStrategoTuple makeInputTerm(IStrategoTerm node, boolean includeSubNode) {
 		return makeInputTerm(node, includeSubNode, false);
 	}
-	
+
 	/**
 	 * Create an input term for a control rule.
 	 */
@@ -112,6 +112,15 @@
 		}
 	}
 
+	public IStrategoTerm makeInputTermRefactoring(IStrategoTerm userInput, IStrategoTerm node, boolean includeSubNode, boolean source) {
+		IStrategoTuple tuple = makeInputTerm(node, includeSubNode, source);
+		ITermFactory factory = Environment.getTermFactory();
+		IStrategoTerm[] inputParts = new IStrategoTerm[tuple.getSubtermCount() + 1];
+		inputParts[0] = userInput;
+		System.arraycopy(tuple.getAllSubterms(), 0, inputParts, 1, tuple.getSubtermCount());
+		return factory.makeTuple(inputParts); 
+	}
+
 	protected String tryGetProjectPath(IResource resource) {
 		return resource.getProject() != null && resource.getProject().exists()
 				? resource.getProject().getLocation().toString()

Added: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/RefactoringButtonDelegate.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/RefactoringButtonDelegate.java	Tue Jun  7 08:24:23 2011	(r23015)
@@ -0,0 +1,93 @@
+package org.strategoxt.imp.runtime.services;
+
+import org.eclipse.jface.action.Action;
+import org.eclipse.jface.action.ActionContributionItem;
+import org.eclipse.jface.action.IAction;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.widgets.Menu;
+import org.eclipse.swt.widgets.MenuItem;
+import org.eclipse.swt.widgets.Shell;
+import org.eclipse.ui.IKeyBindingService;
+import org.eclipse.ui.IWorkbenchWindowPulldownDelegate;
+import org.eclipse.ui.internal.KeyBindingService;
+import org.strategoxt.imp.runtime.EditorState;
+import org.strategoxt.imp.runtime.Environment;
+import org.strategoxt.imp.runtime.dynamicloading.BadDescriptorException;
+import org.eclipse.ltk.core.refactoring.Refactoring;
+import org.eclipse.ltk.ui.refactoring.RefactoringWizard;
+import org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation;
+
+public class RefactoringButtonDelegate extends ToolbarButtonDelegate implements IWorkbenchWindowPulldownDelegate {
+
+	@Override
+	public void run(IAction action) {
+		EditorState editor = EditorState.getActiveEditor();
+		if (editor == null) {
+			openError("No refactorings defined for this editor");
+			return;
+		}
+		IRefactoringMap refactorings = getRefactorings(editor);
+		IRefactoring refactoring = refactorings.get(lastAction);
+		if (refactoring == null && refactorings.getAll().size() > 0) {
+			refactoring = refactorings.getAll().iterator().next();
+		}
+		if (refactoring == null) {
+			openError("No Refactorings defined for the current selection");
+		} else {
+			executeRefactoring(editor, refactoring);
+		}
+	}
+
+	private void executeRefactoring(EditorState editor, IRefactoring refactoring) {
+		refactoring.prepareExecute(editor);
+		StrategoRefactoringWizard wizard = new StrategoRefactoringWizard((StrategoRefactoring) refactoring, refactoring.getCaption()); 
+		RefactoringWizardOpenOperation operation= new RefactoringWizardOpenOperation(wizard);
+		Shell shell = editor.getEditor().getSite().getShell();
+		try {
+			operation.run(shell, refactoring.getCaption());
+		} catch (InterruptedException exception) {
+			// Do nothing
+		}
+	}
+
+	@Override
+	protected void populateMenu(Menu menu) {
+		System.out.println("last action: "+lastAction);
+		MenuItem dummy = new MenuItem(menu, SWT.PUSH);
+		dummy.setText("No refactorings defined for the current selection");
+		
+		final EditorState editor = EditorState.getActiveEditor();
+		if (editor == null) return;
+		IRefactoringMap refactorings = getRefactorings(editor);
+		if (refactorings.getAll().size() == 0) return;
+		
+		for (final IRefactoring refactoring : refactorings.getAll()) {
+			IAction action = new Action(refactoring.getCaption()) {
+				@Override
+				public void run() {
+					lastAction = refactoring.getCaption();
+					executeRefactoring(editor, refactoring);
+				}
+			};
+			//FIXME: keybindings now only work after the user has pressed the refactoring button once.
+			action.setActionDefinitionId(refactoring.getActionDefinitionId());
+			editor.getEditor().getSite().getKeyBindingService().registerAction(action);
+			ActionContributionItem item = new ActionContributionItem(action);
+			item.fill(menu, menu.getItemCount());
+		}		
+		dummy.dispose();
+	}
+
+	private IRefactoringMap getRefactorings(EditorState editor) {
+		IRefactoringMap refactorings;
+		try {
+			refactorings = editor.getDescriptor().createService(IRefactoringMap.class, editor.getParseController());
+		} catch (BadDescriptorException e) {
+			Environment.logException("Could not load refactorings", e);
+			openError("Could not load refactorings");
+			throw new RuntimeException(e);
+		}
+		return refactorings;
+	}
+
+}

Added: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/RefactoringMap.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/RefactoringMap.java	Tue Jun  7 08:24:23 2011	(r23015)
@@ -0,0 +1,29 @@
+package org.strategoxt.imp.runtime.services;
+
+import java.util.Set;
+
+import org.eclipse.imp.language.ILanguageService;
+
+/**
+ * @author Maartje de Jonge
+ */
+public class RefactoringMap implements IRefactoringMap, ILanguageService {
+	
+	private final Set<IRefactoring> Refactorings;
+	
+	public RefactoringMap(Set<IRefactoring> Refactorings) {
+		this.Refactorings = Refactorings;
+	}
+	
+	public Set<IRefactoring> getAll() {
+		return Refactorings;
+	}
+	
+	public IRefactoring get(String name) {
+		for (IRefactoring Refactoring : getAll()) {
+			if (Refactoring.getCaption().equals(name))
+				return Refactoring;
+		}
+		return null;
+	}
+}

Added: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/RefactoringPageTextField.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/RefactoringPageTextField.java	Tue Jun  7 08:24:23 2011	(r23015)
@@ -0,0 +1,73 @@
+package org.strategoxt.imp.runtime.services;
+
+import org.eclipse.ltk.core.refactoring.RefactoringStatus;
+import org.eclipse.ltk.ui.refactoring.UserInputWizardPage;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.ModifyEvent;
+import org.eclipse.swt.events.ModifyListener;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Label;
+import org.eclipse.swt.widgets.Text;
+import org.spoofax.interpreter.terms.ITermFactory;
+import org.strategoxt.imp.runtime.Environment;
+
+public class RefactoringPageTextField extends UserInputWizardPage {
+
+	private Text fNameField;
+	private String labelText = "&New name:";
+	String defaultName = "<newname>";
+
+	public RefactoringPageTextField(String name) {
+		super(name);
+	}
+
+	public void createControl(Composite parent) {
+		Composite result= new Composite(parent, SWT.NONE);
+		setControl(result);
+		GridLayout layout= new GridLayout();
+		layout.numColumns= 2;
+		result.setLayout(layout);
+		Label label= new Label(result, SWT.NONE);
+		label.setText(labelText);
+
+		fNameField= createNameField(result);
+		fNameField.setText(defaultName);
+		fNameField.addModifyListener(new ModifyListener() {
+			public void modifyText(ModifyEvent event) {
+				handleInputChanged();
+			}
+		});
+		fNameField.setFocus();
+		fNameField.selectAll();
+		handleInputChanged();
+	}
+
+	private Text createNameField(Composite result) {
+		Text field= new Text(result, SWT.SINGLE | SWT.LEFT | SWT.BORDER);
+		field.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+		return field;
+	}
+
+	private StrategoRefactoring getStrategoRefactoring() {
+		return (StrategoRefactoring) getRefactoring();
+	}
+
+	void handleInputChanged() {
+		RefactoringStatus status= new RefactoringStatus();
+		StrategoRefactoring refactoring = getStrategoRefactoring();
+
+		ITermFactory factory = Environment.getTermFactory();
+		refactoring.setUserInputTerm(factory.makeString(fNameField.getText()));
+		//check all input fields
+		setPageComplete(!status.hasError());
+		int severity= status.getSeverity();
+		String message= status.getMessageMatchingSeverity(severity);
+		if (severity >= RefactoringStatus.INFO) {
+			setMessage(message, severity);
+		} else {
+			setMessage("", NONE); //$NON-NLS-1$
+		}
+	}
+}

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoRefactoring.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoRefactoring.java	Mon Jun  6 14:46:16 2011	(r23014)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoRefactoring.java	Tue Jun  7 08:24:23 2011	(r23015)
@@ -1,62 +1,42 @@
 package org.strategoxt.imp.runtime.services;
 
-import static org.spoofax.interpreter.core.Tools.asJavaString;
-import static org.spoofax.interpreter.core.Tools.isTermAppl;
 import static org.spoofax.interpreter.core.Tools.isTermList;
 import static org.spoofax.interpreter.core.Tools.isTermTuple;
 import static org.spoofax.interpreter.core.Tools.termAt;
 import static org.spoofax.jsglr.client.imploder.ImploderAttachment.hasImploderOrigin;
-import static org.strategoxt.imp.runtime.stratego.SourceAttachment.getResource;
+import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getLeftToken;
+
+import java.util.Collection;
+import java.util.HashSet;
 
-import java.io.PrintWriter;
-import java.io.Writer;
-import java.util.Map;
-import java.util.WeakHashMap;
-import java.util.concurrent.CancellationException;
-
-import org.eclipse.core.filebuffers.FileBuffers;
-import org.eclipse.core.filebuffers.ITextFileBuffer;
-import org.eclipse.core.filebuffers.ITextFileBufferManager;
-import org.eclipse.core.filebuffers.LocationKind;
 import org.eclipse.core.resources.IFile;
 import org.eclipse.core.resources.IResource;
 import org.eclipse.core.runtime.CoreException;
-import org.eclipse.core.runtime.IPath;
 import org.eclipse.core.runtime.IProgressMonitor;
-import org.eclipse.core.runtime.IStatus;
-import org.eclipse.core.runtime.Status;
-import org.eclipse.core.runtime.jobs.Job;
-import org.eclipse.jface.dialogs.ErrorDialog;
-import org.eclipse.jface.text.BadLocationException;
-import org.eclipse.jface.text.IDocument;
-import org.eclipse.ui.progress.UIJob;
+import org.eclipse.core.runtime.OperationCanceledException;
+import org.eclipse.ltk.core.refactoring.Change;
+import org.eclipse.ltk.core.refactoring.CompositeChange;
+import org.eclipse.ltk.core.refactoring.Refactoring;
+import org.eclipse.ltk.core.refactoring.RefactoringStatus;
+import org.eclipse.ltk.core.refactoring.TextFileChange;
+import org.eclipse.text.edits.MultiTextEdit;
+import org.eclipse.text.edits.ReplaceEdit;
 import org.spoofax.interpreter.core.InterpreterErrorExit;
 import org.spoofax.interpreter.core.InterpreterException;
 import org.spoofax.interpreter.core.InterpreterExit;
 import org.spoofax.interpreter.core.Tools;
 import org.spoofax.interpreter.core.UndefinedStrategyException;
-import org.spoofax.interpreter.library.IOAgent;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.terms.attachments.OriginAttachment;
 import org.strategoxt.imp.generator.construct_textual_change_1_1;
 import org.strategoxt.imp.runtime.EditorState;
 import org.strategoxt.imp.runtime.Environment;
-import org.strategoxt.imp.runtime.MonitorStateWatchDog;
-import org.strategoxt.imp.runtime.RuntimeActivator;
 import org.strategoxt.imp.runtime.dynamicloading.BadDescriptorException;
-import org.strategoxt.imp.runtime.dynamicloading.TermReader;
 import org.strategoxt.imp.runtime.stratego.SourceAttachment;
-import org.strategoxt.imp.runtime.stratego.StrategoConsole;
 import org.strategoxt.lang.Context;
 import org.strategoxt.lang.Strategy;
 
-/**
- * @author Maartje
- */
-public class StrategoRefactoring implements IBuilder {
-	
-	// TODO extract "AbstractStrategoBuilder"
-	//      this is code duplication hell :(
+public class StrategoRefactoring extends Refactoring implements IRefactoring {
 	
 	private final String ppTable;
 	
@@ -66,27 +46,42 @@
 
 	private final String caption;
 	
-	private String builderRule;
+	private final String builderRule;
 			
-	private final IResource resource;
-	
-	// Since StrategoRefactorings are not persistent (per constructor of BuilderFactory)
-	// we maintain a map with running jobs in a static field
-	private static Map<String, Job> activeJobs = new WeakHashMap<String, Job>();
-	
 	private final boolean cursor;
 	
 	private final boolean source;
 	
 	private final IStrategoTerm[] semanticNodes;
+		
+	protected IStrategoTerm userInput;
+
+	private IStrategoTerm node;
 	
-	/**
-	 * Creates a new Stratego refactoring.
-	 */
+	private Collection<TextFileChange> fileChanges;
+
+	public String getCaption() {
+		return caption;
+	}
+
+	public String getActionDefinitionId() {
+		// TODO 
+		return "org.eclipse.jdt.ui.edit.text.java.rename.element";
+	}
+
+	public void setUserInputTerm(IStrategoTerm inputTerm) {
+		userInput = inputTerm;
+	}
+	
+	public void prepareExecute(EditorState editor) {
+		this.node = getSelectionNode(editor);
+		fileChanges.clear();
+		userInput = null;
+	}
+
 	public StrategoRefactoring(StrategoObserver observer, String caption, String builderRule,
-			boolean cursor, boolean source,
-			String ppTable, String ppStrategy,
-			IResource resource, IStrategoTerm[] semanticNodes) { //TODO Check if the refactoring is defined for the given Sort-Constructor
+			boolean cursor, boolean source, String ppTable, String ppStrategy,
+			IStrategoTerm[] semanticNodes) {
 		this.cursor=cursor;
 		this.source=source;
 		this.ppTable=ppTable;
@@ -94,200 +89,188 @@
 		this.observer = observer;
 		this.caption = caption;
 		this.builderRule = builderRule;
-		this.resource=resource;
 		this.semanticNodes = semanticNodes;
+		fileChanges = new HashSet<TextFileChange>();
 	}
 	
-	public String getCaption() {
+	@Override
+	public String getName() {
 		return caption;
 	}
 	
-	public Object getData() {
-		// Data not used for normal builders
-		return null;
+	@Override
+	public RefactoringStatus checkInitialConditions(IProgressMonitor pm) throws CoreException, OperationCanceledException {
+		RefactoringStatus status = new RefactoringStatus();
+		if(node == null)
+			status.merge(RefactoringStatus.createFatalErrorStatus("Editor is still analyzing"));	
+		return status;
 	}
-	
-	public void setData(Object data) {
-		// Data not used for normal builders
+
+	@Override
+	public RefactoringStatus checkFinalConditions(IProgressMonitor pm)
+			throws CoreException, OperationCanceledException {
+		final RefactoringStatus status= new RefactoringStatus();
+		observer.getLock().lock();		
+		pm.beginTask("Checking postconditions...", 2);
+		IStrategoTerm builderResult = null;
+		IStrategoTerm astChanges = null;
+		IStrategoTerm textReplaceTerm = null;
+		IStrategoTerm warnings = null;
+		IStrategoTerm errors = null;
+		try {
+			builderResult = getBuilderResult();
+			if(builderResult == null){
+				observer.reportRewritingFailed();
+				String errorMessage = "Refactoring application failed: '" + caption + "'";
+				Environment.logException(errorMessage);
+				return RefactoringStatus.createFatalErrorStatus(errorMessage);					
+			}	
+			if (!isValidResultTerm(builderResult)) {
+				String errorMessage = "Illegal refactoring result. Expected: '([(original-node, newnode), ... ], warnings, errors, fatal-errors)'";
+				Environment.logException(errorMessage);
+				return RefactoringStatus.createFatalErrorStatus(errorMessage);
+			}
+			astChanges = builderResult.getSubterm(0);
+			warnings = builderResult.getSubterm(1);
+			errors = builderResult.getSubterm(2);
+			updateStatus(status, errors, RefactoringStatus.ERROR);
+			updateStatus(status, warnings, RefactoringStatus.WARNING);
+			textReplaceTerm = getTextReplacement(astChanges);
+			if (textReplaceTerm == null) {
+				observer.reportRewritingFailed();
+				String errorMessage = "Text-reconstruction unexpectedly fails, did you specify a valid pp-table?: \n"+ observer.getLog();
+				Environment.logException(errorMessage);
+				return RefactoringStatus.createFatalErrorStatus(errorMessage);
+			}
+			assert(textReplaceTerm.getSubtermCount() == astChanges.getSubtermCount());
+			for (int i = 0; i < astChanges.getSubtermCount(); i++) {
+				TextFileChange fChange = createTextChange(termAt(astChanges.getSubterm(i),0), textReplaceTerm.getSubterm(i));	
+				fileChanges.add(fChange);
+			}
+		} finally { 
+			observer.getLock().unlock();
+			pm.done();
+		}
+		return status;
 	}
-	
-	public String getBuilderRule() {
-		return builderRule;
+
+	private void updateStatus(RefactoringStatus status, IStrategoTerm errors, int severity) {
+		for (int i = 0; i < errors.getSubtermCount(); i++) {
+			IStrategoTerm error = errors.getSubterm(i);
+			String message = formatErrorMessage(error);
+			switch (severity) {
+				case RefactoringStatus.WARNING:
+					status.merge(RefactoringStatus.createWarningStatus(message));		
+					break;
+				case RefactoringStatus.ERROR:
+					status.merge(RefactoringStatus.createErrorStatus(message));		
+					break;
+				default:
+					assert(false);
+					break;
+			}			
+		}
 	}
-	
-	protected StrategoObserver getObserver() {
-		return observer;
+
+	private String formatErrorMessage(IStrategoTerm error) {
+		if(Tools.isTermString(error))
+			return Tools.asJavaString(error);
+		String message = Tools.asJavaString(error.getSubterm(1));
+		if(hasImploderOrigin(error)){
+			IStrategoTerm origin = OriginAttachment.getOrigin(error.getSubterm(0));
+			int line = getLeftToken(origin).getLine();
+			int column = getLeftToken(origin).getColumn();
+			String fileName = SourceAttachment.getResource(origin).getName(); //project-relative-path?
+			return fileName +" ("+ line +"," + column +"): "+ message;
+		}
+		return message;
 	}
-		
-	protected void setBuilderRule(String builderRule) {
-		this.builderRule = builderRule;
+
+	@Override
+	public Change createChange(IProgressMonitor monitor) throws CoreException, OperationCanceledException {
+		try {
+			monitor.beginTask("Creating change...", 1);
+			CompositeChange change= new CompositeChange(getName(), fileChanges.toArray(new Change[fileChanges.size()])); 			
+			return change;
+		} finally {
+			monitor.done();
+		}
 	}
 	
-	public Job scheduleExecute(final EditorState editor, IStrategoTerm node,
-			final IFile errorReportFile, final boolean isRebuild) {
-		
-		String displayCaption = caption.endsWith("...")
-			? caption.substring(caption.length() - 3)
-			: caption;
-		
-		Job lastJob = activeJobs.get(caption);
-		if (lastJob != null && lastJob.getState() != Job.NONE) {
-			if (!isRebuild)
-				openError(editor, "Already running: " + displayCaption);
-			return null;
-		}
-		
-		if (node == null) {
-			node = editor.getSelectionAst(!cursor);
-			if (node == null) node = editor.getParseController().getCurrentAst();
+	private IStrategoTerm getSelectionNode(EditorState editor) {
+		IStrategoTerm node = editor.getSelectionAst(!cursor);
+		if (node == null) node = editor.getParseController().getCurrentAst();
+		try {
+			node = InputTermBuilder.getMatchingNode(semanticNodes, node, false);
+		} catch (BadDescriptorException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
 		}
-		
-		final IStrategoTerm node2 = node;
-			
-		Job job = new Job("Executing " + displayCaption) {
-			@Override
-			protected IStatus run(IProgressMonitor monitor) {
-				MonitorStateWatchDog protector = new MonitorStateWatchDog(this, monitor, observer);
-				try {
-					execute(editor, node2, errorReportFile, isRebuild);
-					return monitor.isCanceled() ? Status.CANCEL_STATUS : Status.OK_STATUS;
-				} finally {
-					protector.endProtect();
-				}
-			}
-		};
-		//job.setUser(true);
-		job.schedule();
-		activeJobs.put(caption, job);
-		return job;
+		return node;
 	}
 	
-	private void execute(EditorState editor, IStrategoTerm node, IFile errorReportFile, boolean isRebuild) {
-		IStrategoTerm builderResult=null;
-		IStrategoTerm textReplaceTerm=null;
-		//IFile file = null;
-
-		observer.getLock().lock();
+	private IStrategoTerm getBuilderResult() {
+		IStrategoTerm inputTerm = observer.getInputBuilder().makeInputTermRefactoring(userInput, node, true, source);
+		IStrategoTerm result = null;
 		try {
-			try {
-				builderResult = getBuilderResult(editor, node);
-				if(builderResult!=null){	
-					if (!isValidResultTerm(builderResult)) {
-						Environment.logException("Illegal refactoring result (must be a list with tuples '(original-node, newnode)')");
-						openError(editor, "Illegal refactoring result (must be a list with tuples '(original-node, newnode)': )" + builderResult);
-						return;
-					}
-					textReplaceTerm=getTextReplacement(builderResult);
-					if(textReplaceTerm==null){
-						observer.reportRewritingFailed();
-						Environment.logException("Text-reconstruction unexpectedly fails, did you specify a valid pp-table?: \n"+ observer.getLog());
-						if (!observer.isUpdateScheduled())
-							observer.scheduleUpdate(editor.getParseController());
-						return;
-					}
-					assert(textReplaceTerm.getSubtermCount() == builderResult.getSubtermCount());
-					//TODO: check locations to make sure that all changes can be applied (or none)
-					for (int i = 0; i < builderResult.getSubtermCount(); i++) {
-						applyTextChange(termAt(builderResult.getSubterm(i),0), textReplaceTerm.getSubterm(i));							
-					}					
-				}					
-			} catch (InterpreterErrorExit e) {
-				reportGenericException(editor, e);
-			} catch (UndefinedStrategyException e) {
-				reportGenericException(editor, e);
-			} catch (InterpreterExit e) {
-				reportGenericException(editor, e);
-			} catch (InterpreterException e) {
-				reportGenericException(editor, e);
-			} catch (CancellationException e) {
-				return;
-			} catch (RuntimeException e) {
-				reportGenericException(editor, e);
-			} catch (Error e) {
-				reportGenericException(editor, e);
-			}			
-			
-		} finally {
-			observer.getLock().unlock();
-		}		
+			result = observer.invoke(builderRule, inputTerm, getResource());
+		} catch (InterpreterErrorExit e) {
+			Environment.logException("Builder failed", e);
+			e.printStackTrace();
+		} catch (UndefinedStrategyException e) {
+			Environment.logException("Builder failed", e);
+			e.printStackTrace();
+		} catch (InterpreterExit e) {
+			Environment.logException("Builder failed", e);
+			e.printStackTrace();
+		} catch (InterpreterException e) {
+			Environment.logException("Builder failed", e);
+			e.printStackTrace();
+		}
+		return result;
+	}
+
+	private IResource getResource() {
+		return SourceAttachment.getResource(node);
 	}
 	
-	private void applyTextChange(IStrategoTerm originalTerm, IStrategoTerm textReplaceTerm) {
-		final int startLocation=Tools.asJavaInt(termAt(textReplaceTerm, 0));
-		final int endLocation=Tools.asJavaInt(termAt(textReplaceTerm, 1));
-		final String resultText = asJavaString(termAt(textReplaceTerm, 2));
-		final IStrategoTerm originTerm = OriginAttachment.tryGetOrigin(originalTerm);
-		final IPath wsPath = SourceAttachment.getResource(originTerm).getFullPath();
-		
-		Job job = new UIJob("apply textchange") {
-			
-			@Override
-			public IStatus runInUIThread(IProgressMonitor monitor) {
-				ITextFileBufferManager manager= FileBuffers.getTextFileBufferManager();
-				try {
-					manager.connect(wsPath, LocationKind.IFILE, monitor);
-					ITextFileBuffer buffer= manager.getTextFileBuffer(wsPath, LocationKind.IFILE);
-					IDocument doc = buffer.getDocument();
-					doc.replace(startLocation, endLocation - startLocation, resultText);
-					buffer.commit(monitor, true); 
-				} catch (BadLocationException e) {
-					Environment.logException("Bad location of the replaced fragment", e);
-				} catch (CoreException e) {
-					Environment.logException("Exception occurred while updating filecontents", e);
-				} finally {
-					try {
-						manager.disconnect(wsPath, LocationKind.IFILE, monitor);
-					} catch (CoreException e) {
-						Environment.logException("Exception occurred while updating filecontents", e);
-					}
-				}
-				return Status.OK_STATUS;
-			}
-		};
-		job.setSystem(true);
-		job.schedule();		
+	private boolean isValidResultTerm(IStrategoTerm resultTerm) {
+		for (int i = 1; i < resultTerm.getSubtermCount(); i++) {
+			if(!isErrorTermList(resultTerm.getSubterm(i)))
+				return false;
+		}
+		return isTermTuple(resultTerm) 
+			&& resultTerm.getSubtermCount() == 3 
+			&& isValidAstChangeList(resultTerm.getSubterm(0));
 	}
 
-	private IStrategoTerm getBuilderResult(EditorState editor, IStrategoTerm node)
-			throws UndefinedStrategyException, InterpreterErrorExit, InterpreterExit,
-			InterpreterException {
-		IStrategoTerm resultTerm;
-		if (node == null) {
-			openError(editor, "Editor is still analyzing");
-			return null;
-		}
-		resultTerm = invokeObserver(node);
-		if (resultTerm == null) {
-			observer.reportRewritingFailed();
-			Environment.logException("Builder failed:\n" + observer.getLog());
-			if (!observer.isUpdateScheduled())
-				observer.scheduleUpdate(editor.getParseController());
-			openError(editor, "Builder failed (see error log)");
-			return null;
+	private boolean isErrorTermList(IStrategoTerm errorMessages) {
+		for (int i = 0; i < errorMessages.getSubtermCount(); i++) {
+			if(!isErrorTerm(errorMessages.getSubterm(i)))
+				return false;
 		}
-		if (isTermAppl(resultTerm) && "None".equals(TermReader.cons(resultTerm))) {
-			return null;
-		} 
-		return resultTerm;
+		return Tools.isTermList(errorMessages);
 	}
 
-	private boolean isValidResultTerm(IStrategoTerm resultTerm) {
-		if(isTermList(resultTerm)){
-			for (int i = 0; i < resultTerm.getSubtermCount(); i++) {
-				if(!isAstChangeTuple(resultTerm.getSubterm(i))){
-					return false;
-				}
+	private boolean isErrorTerm(IStrategoTerm errorMessage) {
+		return Tools.isTermString(errorMessage) 
+		|| (isTermTuple(errorMessage) && errorMessage.getSubtermCount() == 2);
+	}
+
+	private boolean isValidAstChangeList(IStrategoTerm astChanges) {
+		for (int i = 0; i < astChanges.getSubtermCount(); i++) {
+			if(!isTupleWithOrigin(astChanges.getSubterm(i))){
+				return false;
 			}
-			return true;
 		}
-		return false;
+		return isTermList(astChanges);
 	}
-	
-	private boolean isAstChangeTuple(IStrategoTerm resultTerm) {
+
+	private boolean isTupleWithOrigin(IStrategoTerm resultTerm) {
 		return 
 			isTermTuple(resultTerm) && 
-			hasImploderOrigin(termAt(resultTerm, 0)) &&
-			resultTerm.getSubtermCount()==2;
+			resultTerm.getSubtermCount()==2 &&
+			hasImploderOrigin(termAt(resultTerm, 0));
 	}
 	
 	private IStrategoTerm getTextReplacement(IStrategoTerm resultTuple) {
@@ -295,7 +278,7 @@
 		if (ppTable == null)
 			ppTableTerm=observer.getRuntime().getCompiledContext().getFactory().makeString("");
 		else {
-			ppTableTerm = observer.invokeSilent(ppTable, null, resource);
+			ppTableTerm = observer.invokeSilent(ppTable, null, getResource());
 		}
 		IStrategoTerm textreplace=construct_textual_change_1_1.instance.invoke(
 				observer.getRuntime().getCompiledContext(), 
@@ -304,7 +287,7 @@
 					@Override
 					public IStrategoTerm invoke(Context context, IStrategoTerm current) {
 						if (ppStrategy!=null)
-							return observer.invokeSilent(ppStrategy, current, resource);
+							return observer.invokeSilent(ppStrategy, current, getResource());
 						return null;
 					}
 				},
@@ -312,56 +295,19 @@
 			);
 		return textreplace;
 	}
-
-	protected IStrategoTerm invokeObserver(IStrategoTerm node) throws UndefinedStrategyException,
-			InterpreterErrorExit, InterpreterExit, InterpreterException {
-		//node = InputTermBuilder.getMatchingAncestor(node, false);
-		try {
-			node = InputTermBuilder.getMatchingNode(semanticNodes, node, false);
-		} catch (BadDescriptorException e) {
-			// TODO Auto-generated catch block
-			e.printStackTrace();
-		}
-		IStrategoTerm inputTerm = observer.getInputBuilder().makeInputTerm(node, true, source);
-		IStrategoTerm result = observer.invoke(builderRule, inputTerm, getResource(node));
-		return result;
-	}
-
-	private void reportGenericException(EditorState editor, Throwable e) {
-		boolean isDynamic = editor.getDescriptor().isDynamicallyLoaded();
-		Environment.logException("Builder failed for " + (isDynamic ? "" : "non-") + "dynamically loaded editor", e);
-		if (isDynamic) {
-			Writer writer = observer.getRuntime().getIOAgent().getWriter(IOAgent.CONST_STDERR);
-			PrintWriter printWriter = new PrintWriter(writer);
-			e.printStackTrace(printWriter);
-			printWriter.flush();
-			StrategoConsole.activateConsole();
-		}
-		
-		if (EditorState.isUIThread()) {
-			// Only show if builder runs interactively (and not from the StrategoBuilderListener background builder)
-			String message = e.getLocalizedMessage() == null ? e.getMessage() : e.getLocalizedMessage();
-			Status status = new Status(IStatus.ERROR, RuntimeActivator.PLUGIN_ID, message, e);
-			ErrorDialog.openError(editor.getEditor().getSite().getShell(), caption, null, status);
-		}
-	}
 	
-	private void openError(final EditorState editor, final String message) {
-		Job job = new UIJob("Reporting error") {
-			@Override
-			public IStatus runInUIThread(IProgressMonitor monitor) {
-				Status status = new Status(IStatus.ERROR, RuntimeActivator.PLUGIN_ID, message);
-				ErrorDialog.openError(editor.getEditor().getSite().getShell(),
-						caption, null, status);
-				return Status.OK_STATUS;
-			}
-		};
-		job.setSystem(true);
-		job.schedule();
-	}
-	
-	@Override
-	public String toString() {
-		return "Refactoring: " + builderRule + " - " + caption; 
+	private TextFileChange createTextChange(IStrategoTerm originalTerm, IStrategoTerm textReplaceTerm) {
+		final int startLocation=Tools.asJavaInt(termAt(textReplaceTerm, 0));
+		final int endLocation=Tools.asJavaInt(termAt(textReplaceTerm, 1));
+		final String resultText = Tools.asJavaString(termAt(textReplaceTerm, 2));
+		final IStrategoTerm originTerm = OriginAttachment.tryGetOrigin(originalTerm);
+		final IFile file = (IFile)SourceAttachment.getResource(originTerm);
+
+		TextFileChange textChange = new TextFileChange("", file); 
+		textChange.setTextType(file.getFileExtension());
+		MultiTextEdit edit= new MultiTextEdit();
+		edit.addChild(new ReplaceEdit(startLocation, endLocation - startLocation, resultText));
+		textChange.setEdit(edit);
+		return textChange;
 	}
 }

Added: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoRefactoringWizard.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoRefactoringWizard.java	Tue Jun  7 08:24:23 2011	(r23015)
@@ -0,0 +1,19 @@
+package org.strategoxt.imp.runtime.services;
+
+import org.eclipse.ltk.ui.refactoring.RefactoringWizard;
+
+
+public class StrategoRefactoringWizard extends RefactoringWizard {
+	
+	public StrategoRefactoringWizard(StrategoRefactoring refactoring, String pageTitle) {
+		super(refactoring, DIALOG_BASED_USER_INTERFACE | PREVIEW_EXPAND_FIRST_NODE);
+		setDefaultPageTitle(pageTitle);
+	}
+
+	@Override
+	protected void addUserInputPages() {
+		addPage(new RefactoringPageTextField("SpoofaxRenameInputPage"));
+	}
+
+
+}

Added: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/ToolbarButtonDelegate.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/ToolbarButtonDelegate.java	Tue Jun  7 08:24:23 2011	(r23015)
@@ -0,0 +1,64 @@
+package org.strategoxt.imp.runtime.services;
+
+import org.eclipse.core.commands.AbstractHandler;
+import org.eclipse.core.commands.ExecutionEvent;
+import org.eclipse.core.commands.ExecutionException;
+import org.eclipse.core.runtime.IStatus;
+import org.eclipse.core.runtime.Status;
+import org.eclipse.jface.action.IAction;
+import org.eclipse.jface.dialogs.ErrorDialog;
+import org.eclipse.jface.viewers.ISelection;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Menu;
+import org.eclipse.ui.IWorkbenchWindow;
+import org.strategoxt.imp.runtime.RuntimeActivator;
+
+public abstract class ToolbarButtonDelegate extends AbstractHandler {
+
+	protected static String lastAction;
+	private Menu menu;
+
+	public ToolbarButtonDelegate() {
+		super();
+	}
+	
+	public void init(IWorkbenchWindow window) {
+		// TODO Auto-generated method stub		
+	}
+
+	public Object execute(ExecutionEvent event) throws ExecutionException {
+		run(null);
+		return null;
+	}
+
+	protected abstract void run(IAction action);
+
+	protected abstract void populateMenu(Menu menu);
+
+	public void selectionChanged(IAction action, ISelection selection) {
+		// Unused
+	}
+
+	@Override
+	public void dispose() {
+		if (menu != null) {
+			menu.dispose();
+			menu = null;
+		}
+		super.dispose();
+	}
+
+	public Menu getMenu(Control parent) {
+		if (menu != null) {
+			menu.dispose();
+		}
+		menu = new Menu(parent);
+		populateMenu(menu);
+		return menu;
+	}
+	
+	protected void openError(String message) {
+		Status status = new Status(IStatus.ERROR, RuntimeActivator.PLUGIN_ID, message);
+		ErrorDialog.openError(null, "Spoofax/IMP builder", null, status);
+	}
+}
\ No newline at end of file

From seba at informatik.uni-marburg.de  Tue Jun  7 17:13:32 2011
From: seba at informatik.uni-marburg.de (Sebastian Erdweg)
Date: Tue, 07 Jun 2011 15:13:32 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23016 - in
	sugarj/trunk: compiler/org/sugarj/driver
	editor/editor/java/org/sugarj/editor
Message-ID: <20110607151333.07EFF108C048@mx3.tudelft.nl>

Author: SebastianErdweg
Date: Tue Jun  7 15:13:31 2011
New Revision: 23016
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23016&sc=1

Log:
bugfixing paths

Modified:
   sugarj/trunk/compiler/org/sugarj/driver/Driver.java
   sugarj/trunk/compiler/org/sugarj/driver/FileCommands.java
   sugarj/trunk/compiler/org/sugarj/driver/ModuleSystemCommands.java
   sugarj/trunk/compiler/org/sugarj/driver/Result.java
   sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParseController.java
   sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParser.java

Modified: sugarj/trunk/compiler/org/sugarj/driver/Driver.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/Driver.java	Tue Jun  7 08:24:23 2011	(r23015)
+++ sugarj/trunk/compiler/org/sugarj/driver/Driver.java	Tue Jun  7 15:13:31 2011	(r23016)
@@ -62,28 +62,8 @@
  */
 public class Driver{
   
-  public final static String CACHE_VERSION = "editor-base-0.12";
+  public final static String CACHE_VERSION = "editor-base-0.13";
   
-  private static class Key {
-    private String source;
-    private Path file;
-    
-    private Key(String source, Path file) {
-      this.source = source;
-      this.file = file;
-    }
-    
-    public int hashCode() {
-      return source.hashCode() + file.hashCode();
-    }
-    
-    public boolean equals(Object o) {
-      return o instanceof Key 
-          && ((Key) o).source.equals(source)
-          && ((Key) o).file.equals(file);
-    }
-  }
-
   private final static int PENDING_TIMEOUT = 120000;
 
   private static LRUMap resultCache = new LRUMap(50);
@@ -165,8 +145,8 @@
   
   
   
-  private static synchronized Result getResult(String source, Path file) {
-    return (Result) resultCache.get(new Key(source, file));
+  private static synchronized Result getResult(Path file) {
+    return (Result) resultCache.get(file);
   }
   
   private static synchronized Entry<String, Driver> getPendingRun(Path file) {
@@ -199,8 +179,8 @@
     }
   }
 
-  private static synchronized void putResult(String source, Path file, Result result) {
-    resultCache.put(new Key(source, file), result);
+  private static synchronized void putResult(Path file, Result result) {
+    resultCache.put(file, result);
     Log.log.log(resultCache.size());
   }
   
@@ -240,7 +220,7 @@
       }
 
       if (pending == null) {
-        Result result = getResult(source, sourceFile);
+        Result result = getResult(sourceFile);
         if (result != null && result.isUpToDate(source.hashCode()))
           return result;
       }
@@ -259,7 +239,7 @@
       storeCaches();
     } finally {
         pendingRuns.remove(sourceFile);
-        putResult(source, sourceFile, driver.driverResult.getSugaredSyntaxTree() == null ? null : driver.driverResult);
+        putResult(sourceFile, driver.driverResult.getSugaredSyntaxTree() == null ? null : driver.driverResult);
     }
     
     return driver.driverResult;
@@ -285,8 +265,8 @@
       driverResult.setSourceFile(sourceFile, source.hashCode());
       
       if (sourceFile != null) {
-        javaOutFile = new RelativePathBin(sourceFile + ".java");
-        driverResult.setGenerationLog(new RelativePathBin(sourceFile + ".gen"));
+        javaOutFile = new RelativePathBin(FileCommands.dropExtension(sourceFile.getRelativePath()) + ".java");
+        driverResult.setGenerationLog(new RelativePathBin(FileCommands.dropExtension(sourceFile.getRelativePath()) + ".gen"));
         clearGeneratedStuff();
       }
 
@@ -741,8 +721,8 @@
       if (!packageName.equals(expectedPackage))
         ATermCommands.setErrorMessage(
             toplevelDecl,
-            "The declared package " + packageName +
-            " does not match the expected package " + expectedPackage + ".");
+            "The declared package '" + packageName + "'" +
+            " does not match the expected package '" + expectedPackage + "'.");
     }
   }
   
@@ -1503,13 +1483,24 @@
     if (SDFCommands.sdfCache != null) {
       log.log("store sdf cache in " + sdfCache);
       log.log("sdf cache size: " + SDFCommands.sdfCache.size());
-      new ObjectOutputStream(new FileOutputStream(sdfCache.getFile())).writeObject(SDFCommands.sdfCache);
+      FileCommands.createFile(sdfCache);
+      ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(sdfCache.getFile()));
+      try {
+        oos.writeObject(SDFCommands.sdfCache);
+      } finally {
+        oos.close();
+      }
     }
     
     if (STRCommands.strCache != null) {
       log.log("store str cache in " + strCache);
       log.log("str cache size: " + STRCommands.strCache.size());
-      new ObjectOutputStream(new FileOutputStream(strCache.getFile())).writeObject(STRCommands.strCache);
+      ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(strCache.getFile()));
+      try {
+        oos.writeObject(STRCommands.strCache);
+      } finally {
+        oos.close();
+      }
     }
   }
 

Modified: sugarj/trunk/compiler/org/sugarj/driver/FileCommands.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/FileCommands.java	Tue Jun  7 08:24:23 2011	(r23015)
+++ sugarj/trunk/compiler/org/sugarj/driver/FileCommands.java	Tue Jun  7 15:13:31 2011	(r23016)
@@ -25,27 +25,43 @@
  */
 public class FileCommands {
 
-  private final static boolean DO_DELETE = false;
+  private final static boolean DO_DELETE = true;
 
   public static Path newTempFile(String suffix) throws IOException {
     File f =
         File.createTempFile(
             "sugarj",
             suffix == null || suffix.isEmpty() ? suffix : "." + suffix);
-
+    final Path p = new AbsolutePath(f.getAbsolutePath());
+    
     if (DO_DELETE)
-      f.deleteOnExit();
+      Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {
+        @Override
+        public void run() {
+          try {
+            FileCommands.delete(p);
+          } catch (IOException e) {
+          }
+        }
+      }));
 
-    return new AbsolutePath(f.getAbsolutePath());
+    return p;
   }
 
   public static void delete(Path file) throws IOException {
-    if (file != null)
-      file.getFile().delete();
+    if (file == null)
+      return;
+    
+    if (file.getFile().listFiles() != null)
+      for (File f : file.getFile().listFiles())
+        FileCommands.delete(new AbsolutePath(f.getPath()));
+    
+    file.getFile().delete();
   }
 
   public static void copyFile(Path from, Path to) throws IOException {
     FileInputStream fis = new FileInputStream(from.getFile());
+    createFile(to);
     FileOutputStream fos = new FileOutputStream(to.getFile());
     copyFile(fis, fos);
     fis.close();
@@ -79,6 +95,7 @@
 
   public static void appendToFile(Path file, String content)
       throws IOException {
+    createFile(file);
     FileOutputStream fos = new FileOutputStream(file.getFile(), true);
     fos.write(content.getBytes());
     fos.close();
@@ -86,16 +103,14 @@
 
   // from http://snippets.dzone.com/posts/show/1335
   // Author: http://snippets.dzone.com/user/daph2001
-  //
-  // TODO fix legal issues
   public static String readFileAsString(Path filePath) throws IOException {
-    StringBuffer fileData = new StringBuffer(1000);
+    StringBuilder fileData = new StringBuilder(1000);
     BufferedReader reader = new BufferedReader(new FileReader(filePath.getFile()));
     char[] buf = new char[1024];
     int numRead = 0;
-    while ((numRead = reader.read(buf)) != -1) {
+    while ((numRead = reader.read(buf)) != -1)
       fileData.append(buf, 0, numRead);
-    }
+
     reader.close();
     return fileData.toString();
   }
@@ -160,15 +175,24 @@
   }
 
   public static Path newTempDir() throws IOException {
-    File f = File.createTempFile("SugarJ", "");
+    final File f = File.createTempFile("SugarJ", "");
     // need to delete the file, but want to reuse the filename
     f.delete();
     f.mkdir();
+    final Path p = new AbsolutePath(f.getAbsolutePath());
+    
+    if (DO_DELETE)
+      Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {
+        @Override
+        public void run() {
+          try {
+            FileCommands.delete(p);
+          } catch (IOException e) {
+          }
+        }
+      }));
 
-    // TODO add shutdownHook to recursively delete this temporary
-    // directory
-
-    return new AbsolutePath(f.getAbsolutePath());
+    return p;
   }
 
   public static void prependToFile(Path file, String head) throws IOException {

Modified: sugarj/trunk/compiler/org/sugarj/driver/ModuleSystemCommands.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/ModuleSystemCommands.java	Tue Jun  7 08:24:23 2011	(r23015)
+++ sugarj/trunk/compiler/org/sugarj/driver/ModuleSystemCommands.java	Tue Jun  7 15:13:31 2011	(r23016)
@@ -5,8 +5,12 @@
 import static org.sugarj.driver.Log.log;
 
 import java.io.BufferedReader;
+import java.io.File;
 import java.io.FileReader;
 import java.io.IOException;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.net.URLClassLoader;
 import java.util.Set;
 
 import org.spoofax.interpreter.terms.IStrategoTerm;
@@ -32,8 +36,8 @@
    * @throws IOException
    */
   public static boolean importClass(String modulePath, IStrategoTerm importTerm, Path javaOutFile, HybridInterpreter interp, Result driverResult) throws IOException {
-    RelativePath classUri = searchFile(modulePath, ".class");
-    if (classUri == null)
+    RelativePath clazz = searchFile(modulePath, ".class");
+    if (clazz == null)
       return false;
     
     log.beginTask("Generate Java code");
@@ -168,6 +172,14 @@
       RelativePath p = new RelativePath(new AbsolutePath(base), relativePath + extension);
       if (p.getFile().exists())
         return p;
+      
+      try {
+        ClassLoader cl = new URLClassLoader(new URL[] {new File(base).toURI().toURL()}, null);
+        if (cl.getResource(relativePath + extension) != null)
+          return new RelativePath(new AbsolutePath(base), relativePath + extension);
+      } catch (MalformedURLException e) {
+        e.printStackTrace();
+      }
     }
     
     return null;

Modified: sugarj/trunk/compiler/org/sugarj/driver/Result.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/Result.java	Tue Jun  7 08:24:23 2011	(r23015)
+++ sugarj/trunk/compiler/org/sugarj/driver/Result.java	Tue Jun  7 15:13:31 2011	(r23016)
@@ -81,6 +81,7 @@
   
   private void logGeneration(Object o) throws IOException {
     if (generationLog != null) {
+      FileCommands.createFile(generationLog);
       ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(generationLog.getFile(), true));
       try {
         oos.writeObject(o);
@@ -135,7 +136,7 @@
     return collectedErrors;
   }
   
-  void setSugaredSyntaxTree(IStrategoTerm sugaredSyntaxTree) {
+  public void setSugaredSyntaxTree(IStrategoTerm sugaredSyntaxTree) {
     this.sugaredSyntaxTree = sugaredSyntaxTree;
   }
   
@@ -164,6 +165,7 @@
     ObjectOutputStream oos = null;
     
     try {
+      FileCommands.createFile(dep);
       oos = new ObjectOutputStream(new FileOutputStream(dep.getFile()));
 
       oos.writeObject(sourceFile);

Modified: sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParseController.java
==============================================================================
--- sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParseController.java	Tue Jun  7 08:24:23 2011	(r23015)
+++ sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParseController.java	Tue Jun  7 15:13:31 2011	(r23016)
@@ -83,7 +83,7 @@
           for (IPackageFragmentRoot root : javaProject.getAllPackageFragmentRoots()) {
             IPath path = root.getPath();
             boolean externalPath = root.getResource() == null;
-            String p = externalPath ? path.toString() : projectPath + File.separator + path.makeRelativeTo(project.getRawProject().getFullPath());
+            String p = externalPath ? path.toString() : projectPath + "/" + path.makeRelativeTo(project.getRawProject().getFullPath());
             if (root.getKind() == IPackageFragmentRoot.K_SOURCE)
               sourcePath.add(p);
             else if (root.getKind() == IPackageFragmentRoot.K_BINARY)
@@ -94,7 +94,7 @@
             IJavaProject reqJavaProject = JavaCore.create(project.getRawProject().getWorkspace().getRoot().getProject(reqProject));
             IPath reqProjectPath = reqJavaProject.getProject().getLocation().makeAbsolute();
             if (reqJavaProject != null)
-              includePath.add(reqProjectPath + File.separator  + reqJavaProject.getOutputLocation().makeRelativeTo(reqJavaProject.getProject().getFullPath()).toPortableString());
+              includePath.add(reqProjectPath + "/" + reqJavaProject.getOutputLocation().makeRelativeTo(reqJavaProject.getProject().getFullPath()).toPortableString());
           }
         } catch (JavaModelException e) { 
           outputPath = null; 

Modified: sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParser.java
==============================================================================
--- sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParser.java	Tue Jun  7 08:24:23 2011	(r23015)
+++ sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParser.java	Tue Jun  7 15:13:31 2011	(r23016)
@@ -14,8 +14,13 @@
 import org.eclipse.core.runtime.jobs.Job;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.jsglr.client.ITreeBuilder;
+import org.spoofax.jsglr.client.KeywordRecognizer;
 import org.spoofax.jsglr.client.ParseTable;
+import org.spoofax.jsglr.client.imploder.IToken;
+import org.spoofax.jsglr.client.imploder.ImploderAttachment;
 import org.spoofax.jsglr.client.imploder.TermTreeFactory;
+import org.spoofax.jsglr.client.imploder.Token;
+import org.spoofax.jsglr.client.imploder.Tokenizer;
 import org.spoofax.jsglr.client.imploder.TreeBuilder;
 import org.spoofax.jsglr.shared.BadTokenException;
 import org.spoofax.jsglr.shared.SGLRException;
@@ -58,15 +63,16 @@
       throws TokenExpectedException, BadTokenException, SGLRException, IOException {
     
     result = getResult(filename);
+    if (result == null) {
+      result = parseFailureResult();
+      putResult(filename, result);
+    }
 
     if (result != null && result.isUpToDate(input.hashCode()))
       return result.getSugaredSyntaxTree();
     else if (result == null || !(result instanceof PendingResult)) 
       scheduleParse(input, filename);
         
-    if (result == null)
-      return null;
-    
     Path lastParseTable;
     
     if (result instanceof PendingResult)
@@ -100,10 +106,10 @@
     final Result oldResult = getResult(filename);
     putResult(filename, new PendingResult(oldResult));
     
-    Job parseJob = new Job("SugarJ parser: " + projectRelativePath(filename)) {
+    Job parseJob = new Job("SugarJ parser: " + projectRelativePath(filename).getRelativePath()) {
       @Override
       protected IStatus run(IProgressMonitor monitor) {
-        monitor.beginTask("parse " + projectRelativePath(filename), IProgressMonitor.UNKNOWN);
+        monitor.beginTask("parse " + projectRelativePath(filename).getRelativePath(), IProgressMonitor.UNKNOWN);
         Result result = null;
         try {
           result = runParser(input, filename, monitor);
@@ -207,16 +213,30 @@
   
   private RelativePath projectRelativePath(String filename) {
     RelativePath path = null;
-    for (String s : sourcePath)
+    for (String s : sourcePath) {
       if (filename.startsWith(s)) {
-        RelativePath newPath = new RelativePath(new AbsolutePath(s), filename.substring(s.length()));
+        RelativePath newPath = new RelativePath(new AbsolutePath(s), filename.substring(s.length() + 1));
         if (path == null || newPath.getBasePath().getAbsolutePath().length() < path.getBasePath().getAbsolutePath().length())
           path = newPath;
       }
+    }
     
     if (path != null)
       return path;
     
     throw new IllegalStateException("Ressource " + filename + " not inside any source folder.");
   }
+  
+  private Result parseFailureResult() {
+    IStrategoTerm term = ATermCommands.makeList("SugarCompilationUnit");
+    Tokenizer tokenizer = new Tokenizer(" ", " ", new KeywordRecognizer(null) {});
+    Token tok = tokenizer.makeToken(0, IToken.TK_UNKNOWN, true);
+    ImploderAttachment.putImploderAttachment(term, true, "SugarCompilationUnit", tok, tok);
+    
+    Result r = new Result() {
+      public boolean isUpToDate(int h) { return false; }
+    };
+    r.setSugaredSyntaxTree(term);
+    return r;
+  }
 }

From seba at informatik.uni-marburg.de  Tue Jun  7 17:17:12 2011
From: seba at informatik.uni-marburg.de (Sebastian Erdweg)
Date: Tue, 07 Jun 2011 15:17:12 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23017 - in
	sugarj/trunk: compiler/org/sugarj/driver
	editor/editor/java/org/sugarj/editor
Message-ID: <20110607151713.074D87F8039@mx1.tudelft.nl>

Author: SebastianErdweg
Date: Tue Jun  7 15:17:07 2011
New Revision: 23017
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23017&sc=1

Log:
missing files

Added:
   sugarj/trunk/compiler/org/sugarj/driver/PrintProgressMonitor.java
   sugarj/trunk/editor/editor/java/org/sugarj/editor/PendingResult.java

Added: sugarj/trunk/compiler/org/sugarj/driver/PrintProgressMonitor.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sugarj/trunk/compiler/org/sugarj/driver/PrintProgressMonitor.java	Tue Jun  7 15:17:07 2011	(r23017)
@@ -0,0 +1,70 @@
+package org.sugarj.driver;
+
+import java.io.PrintStream;
+import java.util.Stack;
+
+import org.eclipse.core.runtime.IProgressMonitor;
+
+/**
+ * @author Sebastian Erdweg <seba at informatik uni-marburg de>
+ */
+public class PrintProgressMonitor implements IProgressMonitor {
+
+  private PrintStream out;
+  private Stack<String> tasks;
+  private boolean canceled;
+  
+  public PrintProgressMonitor(PrintStream out) {
+    this.out = out;
+  }
+  
+  @Override
+  public void beginTask(String name, int totalWork) {
+    tasks.push(name);
+    out.print(indent() + "begin " + name);
+  }
+
+  @Override
+  public void done() {
+    out.println("...done " + tasks.pop());
+    out.println(indent());
+  }
+
+  @Override
+  public void internalWorked(double work) {
+  }
+
+  @Override
+  public boolean isCanceled() {
+    return canceled;
+  }
+
+  @Override
+  public void setCanceled(boolean canceled) {
+    this.canceled = canceled;
+  }
+
+  @Override
+  public void setTaskName(String name) {
+    tasks.pop();
+    tasks.push(name);
+  }
+
+  @Override
+  public void subTask(String name) {
+    out.println(indent() + "begin " + name);
+    tasks.push(name);
+  }
+
+  @Override
+  public void worked(int work) {
+    out.println('.');
+  }
+
+  private String indent() {
+    StringBuilder builder = new StringBuilder();
+    for (int i = 0; i < tasks.size(); i++)
+      builder.append("  ");
+    return builder.toString();
+  }
+}

Added: sugarj/trunk/editor/editor/java/org/sugarj/editor/PendingResult.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sugarj/trunk/editor/editor/java/org/sugarj/editor/PendingResult.java	Tue Jun  7 15:17:07 2011	(r23017)
@@ -0,0 +1,25 @@
+/**
+ * 
+ */
+package org.sugarj.editor;
+
+import org.sugarj.driver.Result;
+
+/**
+ * @author Sebastian Erdweg <seba at informatik uni-marburg de>
+ */
+public class PendingResult extends Result {
+  private Result result;
+  
+  public PendingResult(Result result) {
+    this.result = result;
+  }
+  
+  public Result getResult() {
+    return result;
+  }
+  
+  public boolean isUpToDate(int hash) {
+    return false;
+  }
+}

From M.A.Akhter at student.tudelft.nl  Wed Jun  8 00:40:20 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Tue, 07 Jun 2011 22:40:20 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23018 - in
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans:
	analyze/esv codegen context context/esv context/sdf normalize
Message-ID: <20110607224020.1690C108C00E@mx3.tudelft.nl>

Author: MdAdilAkhter
Date: Tue Jun  7 22:40:18 2011
New Revision: 23018
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23018&sc=1

Log:
* more refactoring on Declare SDF+ESV. added STR module to declare esv. 
* changed "inconsistent start symbol" error to warning
* making context-free start symbol a deprecated(+optional) construct . Now end-users will only have to specify Start Symbols once in Language Description (In-progress)...

Added:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/esv/
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/esv/declare.str
Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/analyze/esv/check.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/compile.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/declare.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/scope-tree.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/sdf/declare.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/normalize/main.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/analyze/esv/check.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/analyze/esv/check.str	Tue Jun  7 15:17:07 2011	(r23017)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/analyze/esv/check.str	Tue Jun  7 22:40:18 2011	(r23018)
@@ -2,10 +2,9 @@
 
 imports
 	common
-	context/sdf/declare
-
+	context/esv/declare	
 imports 
-	utils/debug
+	utils/debug 
 	context/-
 imports
   include/SpoofaxLang
@@ -13,27 +12,18 @@
 // TODO: warn about multi-char highlighted brackets
 // TODO: check if provider/imported/etc. files exist
 // TODO: check if there is _any_ provider for observer etc.
- 
+
 rules
-  
-  analyze-section: 
+	analyze-section: 
 		ESVSection(ast) -> (error-esv*, warning-esv* , [])
   	where
   		<debug-analysis>$[ErrorChecking | ESV Section : [<pp-aterm>]]
 		where
-  		error-esv*   := <flatten-list><collect-all(constraint-esv-error, conc)> ast;
-  		warning-esv* := <collect-all(constraint-esv-warning, conc)> ast
+  		error-esv*   := <collect-all(constraint-esv-error, conc)> ast;
+  		warning-esv* := <flatten-list><collect-all(constraint-esv-warning, conc)> ast
 
-rules 
-	resolve-sdf-sort-declaration = 
- 		?symbol; 
- 		<resolve-symbol-unique-declaration(all-keys-SortDeclaration , bagof-SortDeclaration)><to-scoped-symbol>symbol 
- 	<+
- 		<debug-analysis> $[ErrorChecking|Failed to retrive SDF Sort for symbol [<pp-aterm>]];
- 		fail
 
 rules
-
 	constraint-esv-error:
     Sort(x) -> (x, $[Unknown sort [x]])
     where
@@ -51,8 +41,9 @@
    			is-not-empty-list;
    			make-set;
 				not(ensure-is-unique)
-	
-	constraint-esv-error: 
+					
+rules
+	constraint-esv-warning: 
 		StartSymbols(sorts*) -> err-messages*
 		where
 			s* := <get-start-symbols> <GetEnclosingPackageName>; // getting all the context-free-start-symbols for the package   	
@@ -65,10 +56,7 @@
 		s at Sort(x) -> (s, $[Undefined Start Symbol :  "[x]".])
 		where 
 			<not(fetch-elem(?sort(x)))>start-symbols-found-in-sdf-def
-			
-					
-rules
-	   		
+			   		
   constraint-esv-warning: 
    	LanguageName( name ) -> (name, $[Same Language name is declared multiple times in this package.])
    	where

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/compile.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/compile.str	Tue Jun  7 15:17:07 2011	(r23017)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/compile.str	Tue Jun  7 22:40:18 2011	(r23018)
@@ -234,7 +234,7 @@
 				module-decl := <get-module-declaration>module-typed-qname;
 				{|GetEnclosingModuleName:
 						<declare-current-module-scope> module-typed-qname;
-						<declare-module(declare-all)>module-decl
+						<delcare-module>module-decl
 				|};
 				where(rules(CompiledModule: module-typed-qname -> module-typed-qname))
 			else

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/declare.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/declare.str	Tue Jun  7 15:17:07 2011	(r23017)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/declare.str	Tue Jun  7 22:40:18 2011	(r23018)
@@ -2,9 +2,10 @@
 
 imports
 	context/sdf/declare
-	context/sdf/declare-signature
 	context/str/declare
+	context/esv/declare
 	context/template/declare
+	context/sdf/declare-signature
 	context/-
 	normalize/signatures
 imports
@@ -26,32 +27,26 @@
 		);
 		get-enclosed-modules;
 		map(get-module-declaration);
-		list-loop(declare-module(declare-global-symbol))
-
-	declare-module(s) = origin-track-forced(s)
-
-	declare-all = declare-spxmodules-all(declare-section); update-modified-module-declaration
-
-	declare-global-symbol = declare-global ;  update-modified-module-declaration
+		list-loop(declare-internal(declare-global-symbols-main))
 
-	init-declaration = init-record-signatures ; init-template-options
-
-
-rules
-
-	declare-legacy-artifact(|resolved-path) : legacy-content -> legacy-content
-	where
-		<has-extension(|"sdf") + has-extension(|"def")>resolved-path;
-		<alltd(declare-sdf-definition-main)>legacy-content
-
-	declare-legacy-artifact(|resolved-path) : legacy-content -> legacy-content
-	where
-		<has-extension(|"str") + has-extension(|"rtree")>resolved-path;
-		<alltd(declare-str-definition-main)>legacy-content
-
-rules
-
-	declare-global = declare-spxmodules-all(declare-global-section)
+	
+	delcare-module =  
+		declare-internal(declare-local-symbols-main)
+	
+	declare-local-symbols-main = 
+		declare-spxmodules-all(declare-local-symbols); 
+		update-modified-module-declaration
+
+	declare-global-symbols-main = 
+		declare-spxmodules-all(declare-global-symbols) ;  
+		update-modified-module-declaration
+
+	declare-internal(s) = 
+		origin-track-forced(s)
+	
+	init-declaration = 
+		init-record-signatures ; 
+		init-template-options
 
 
 rules
@@ -69,49 +64,53 @@
 			<store-declaration(|Modules())>(<get-module-untyped-qname>(package-qname, modname),  m)
 
 rules
-	declare-section:
-		SDFSection(definition*) ->SDFSection(declared-definition*)
+	declare-local-symbols:
+		SDFSection(definition*) -> SDFSection(declared-definition*)
 		where
 			declared-definition* := <declare-sdf-definition-main>definition*
 
-	declare-section:
-		SDFSectionEH(_,definition*) -><declare-section>SDFSection(definition*)
+	declare-local-symbols:
+		SDFSectionEH(_,definition*) -><declare-local-symbols>SDFSection(definition*)
 
-	declare-section:
+	declare-local-symbols:
 	  STRSection(def*) -> STRSection(m-definition*)
     where
       m-definition* := <declare-str-definition-main>def*
 
-  declare-section: ESVSection(def*) -> <id>
+  declare-local-symbols: ESVSection(def*) -> <id>
 
   // TemplateLang
-  declare-section:
+  declare-local-symbols:
     TemplateSection(definition*) -> TemplateSection(declared-definition*)
     with
       declared-definition* := <declare-template-definition-main> definition*
 
   // TemplateLang
   // FIXME: move to spoofax.configuration?
-  declare-section:
+  declare-local-symbols:
   	TemplateOptions(option*) -> TemplateOptions(declared-option*)
   	with
   	  declared-option* := <declare-template-options-main> option*
 
 rules
 
-	declare-global-section: SDFSection(def*) -> <id>
+	declare-global-symbols: SDFSection(def*) -> <id>
 
-	declare-global-section: SDFSectionEH(_,def*) -> <id>
+	declare-global-symbols: SDFSectionEH(_,def*) -> <id>
 
-	declare-global-section: s at STRSection(def*) -> STRSection(m-definition*)
+	declare-global-symbols: s at STRSection(def*) -> STRSection(m-definition*)
 	where
 		m-definition* := <declare-stratego-globals-top>def*
 
+	declare-global-symbols: ESVSection(def*) -> ESVSection(declared-definition*)
+	where 
+		declared-definition* := <declare-esv-globals-top>def*
+	
   // TemplateLang
-  declare-global-section: TemplateSection(def*) -> <id>
+  declare-global-symbols: TemplateSection(def*) -> <id>
 
   // TemplateLang
-  declare-global-section: TemplateOptions(opt*) -> <id>
+  declare-global-symbols: TemplateOptions(opt*) -> <id>
 
 rules
 
@@ -131,3 +130,15 @@
 			module-typed-qname -> <id>
 			with
 				rules ( GetEnclosingModuleName      := module-typed-qname)
+
+rules
+
+	declare-legacy-artifact(|resolved-path) : legacy-content -> legacy-content
+	where
+		<has-extension(|"sdf") + has-extension(|"def")>resolved-path;
+		<alltd(declare-sdf-definition-main)>legacy-content
+
+	declare-legacy-artifact(|resolved-path) : legacy-content -> legacy-content
+	where
+		<has-extension(|"str") + has-extension(|"rtree")>resolved-path;
+		<alltd(declare-str-definition-main)>legacy-content

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/esv/declare.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/esv/declare.str	Tue Jun  7 22:40:18 2011	(r23018)
@@ -0,0 +1,32 @@
+module context/esv/declare
+
+imports
+	include/SpoofaxLang
+	context/-
+	context/sdf/-
+	utils/debug
+	common
+
+rules 
+	resolve-sdf-sort-declaration = 
+ 		?symbol; 
+ 		<resolve-symbol-unique-declaration(all-keys-SortDeclaration , bagof-SortDeclaration)><to-scoped-symbol>symbol 
+ 	<+
+ 		<debug-analysis> $[ErrorChecking|Failed to retrive SDF Sort for symbol [<pp-aterm>]];
+ 		fail
+
+
+rules
+	declare-esv-globals-top = 
+		alltd(declare-esv-definition)
+		
+	declare-esv-definition : 
+		LanguageName(name)  -> <id>
+		with 
+			store-langauge-properties(|<GetEnclosingPackageName>)
+	 
+	 declare-esv-definition : 
+		LanguageId(id-string)  -> <id>
+		with 
+			store-langauge-properties(|<GetEnclosingPackageName>)
+	 	
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/scope-tree.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/scope-tree.str	Tue Jun  7 15:17:07 2011	(r23017)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/scope-tree.str	Tue Jun  7 22:40:18 2011	(r23018)
@@ -69,7 +69,7 @@
 	// extended dynamic rules are used to verify that language name is not declare multple times 
 	// in a package scope. Additional checks will be added to verify a language-name is unique 
 	// in a project scope. 
-	store-langauge-properties (| package-typed-qname ) : 
+	store-langauge-properties(|package-typed-qname) : 
 		LanguageName(name) -> <id>
 		with 
 			rules( DeclaredLangaugeName :+ package-typed-qname -> name);
@@ -78,7 +78,7 @@
 			<debug-symboltable> $[ ScopeTree| [<pp-aterm>package-typed-qname] storing  following language name : [<pp-aterm>name]]
 	
 	// Stores Language ID. 
-	store-langauge-properties (| package-typed-qname ) : 
+	store-langauge-properties(|package-typed-qname) : 
 		LanguageId(id-string) -> <id> 
 		with 
 			rules( DeclaredLangaugeId :+ package-typed-qname -> id-string)

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/sdf/declare.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/sdf/declare.str	Tue Jun  7 15:17:07 2011	(r23017)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/sdf/declare.str	Tue Jun  7 22:40:18 2011	(r23018)
@@ -51,6 +51,14 @@
  declare-sdf-definition-main=
     	alltd(declare-sdf-definition)
 
+rules 
+	declare-sdf-definition : 
+		context-free-start-symbols(s*) -> <id>
+		with 
+			<declare-sdf-definition-main>s*
+		with
+			store-context-free-start-symbols(|<GetEnclosingPackageName>) 	
+		 
 rules
 	declare-sdf-definition:
     renamings(y) -> <id>

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/normalize/main.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/normalize/main.str	Tue Jun  7 15:17:07 2011	(r23017)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/normalize/main.str	Tue Jun  7 22:40:18 2011	(r23018)
@@ -128,33 +128,26 @@
 		SDFSection ( sectionDef ) -> <add-annotation(|<EnclosingNamespace>)> SDFSection( sectionDef' )
 		with
 			<templatelang-desugar-sdf-top> sectionDef => sectionDef'
-		with 
-			<alltd(store-context-free-start-symbols(|<EnclosingParentNamespace>))>sectionDef
-		
+	
 		
   // TODO: Maybe SDFSectionEH can be desugared into SDFSection.
 	desugar-spx : 
 		SDFSectionEH ( eh, sectionDef ) -> <add-annotation(|<EnclosingNamespace>)> SDFSectionEH( eh, sectionDef' )
 		with
     	<templatelang-desugar-sdf-top> sectionDef => sectionDef'
-  	with 
-			<alltd(store-context-free-start-symbols(|<EnclosingParentNamespace>))>sectionDef
-
+  
 rules
 	//Desugaring STR sections
 	desugar-spx : 
 		STRSection ( sectionDef ) -> <add-annotation(|<EnclosingNamespace>)> STRSection ( sectionDef' )
 		with
 			<basic-stratego-desugar-top> sectionDef => sectionDef'
-			
 				
 rules
 	//Desugaring ESV Sections
 	desugar-spx : 
 		ESVSection ( sectionDef ) -> <add-annotation(|<EnclosingNamespace>)> <id>
-		with
-			<alltd(store-langauge-properties(|<EnclosingParentNamespace>))>sectionDef
-
+		
 rules
 	//Desugaring template sections
   desugar-spx : 

From m.dejonge at tudelft.nl  Wed Jun  8 01:09:34 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Tue, 07 Jun 2011 23:09:34 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23019 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/editor
Message-ID: <20110607230934.1258BCC182@mx4.tudelft.nl>

Author: MaartjeDeJonge
Date: Tue Jun  7 23:09:32 2011
New Revision: 23019
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23019&sc=1

Log:
TODO: aanpassen aan nieuwe Spoofax implementatie

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/editor/Stratego-Sugar-Builders.esv

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/editor/Stratego-Sugar-Builders.esv
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/editor/Stratego-Sugar-Builders.esv	Tue Jun  7 22:40:18 2011	(r23018)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/editor/Stratego-Sugar-Builders.esv	Tue Jun  7 23:09:32 2011	(r23019)
@@ -16,7 +16,7 @@
   	rename-builder (source)(meta)
   
   refactoring Id: "Rename (refactoring)" = 
-  	rename-refactoring (source)
+  	rename-refactoring (source)(meta) 
 
   builder : "Show analysed AST" =
     generate-analysed-aterm (realtime) (meta) (openeditor) (source)

From emma at cs.lth.se  Wed Jun  8 11:12:56 2011
From: emma at cs.lth.se (Emma Nilsson-Nyman)
Date: Wed, 08 Jun 2011 09:12:56 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23020 - in
	sglr-recovery/trunk/Evaluate: . src/compare src/fileprocessing
Message-ID: <20110608091256.95F2A7F8025@mx1.tudelft.nl>

Author: EmmaNilssonNyman
Date: Wed Jun  8 09:12:55 2011
New Revision: 23020
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23020&sc=1

Log:
Preparing for tree edit distance check

Added:
   sglr-recovery/trunk/Evaluate/src/compare/
   sglr-recovery/trunk/Evaluate/src/compare/StrategoCostFunction.java
   sglr-recovery/trunk/Evaluate/src/compare/StrategoTranslator.java
Modified:
   sglr-recovery/trunk/Evaluate/.classpath
   sglr-recovery/trunk/Evaluate/src/fileprocessing/TestFile.java

Modified: sglr-recovery/trunk/Evaluate/.classpath
==============================================================================
--- sglr-recovery/trunk/Evaluate/.classpath	Tue Jun  7 23:09:32 2011	(r23019)
+++ sglr-recovery/trunk/Evaluate/.classpath	Wed Jun  8 09:12:55 2011	(r23020)
@@ -8,5 +8,6 @@
 	<classpathentry kind="src" path="/org.bripgen"/>
 	<classpathentry kind="lib" path="/org.bripgen/tools/lpg.runtime_2.0.16.jar"/>
 	<classpathentry kind="lib" path="strategoxt.jar"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/org.briplib"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>

Added: sglr-recovery/trunk/Evaluate/src/compare/StrategoCostFunction.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/Evaluate/src/compare/StrategoCostFunction.java	Wed Jun  8 09:12:55 2011	(r23020)
@@ -0,0 +1,47 @@
+package compare;
+
+import org.briplib.compare.CostFunction;
+import org.briplib.compare.Label;
+import org.briplib.compare.Label.Empty;
+
+/**
+ * Cost function for comparison of Stratego trees
+ * 
+ * @author Emma Soderberg <emma at cs.lth.se>
+ *
+ */
+public class StrategoCostFunction implements CostFunction {
+
+	public int cost(Label l1, Empty empty) {
+		return 1;
+	}
+
+	public int cost(Empty empty, Label l2) {
+		return 1;
+	}
+
+	public int cost(Label l1, Label l2) {
+		if (l1.data() == null && l2.data() == null) {
+			return 0;
+		} 
+		if (l1.data() == null && l2.data() != null) {
+			return 1;
+		}
+		if (l1.data() != null && l2.data() == null) {
+			return 1;
+		}
+		String s1 = l1.data().toString();
+		String s2 = l2.data().toString();
+		if (s1 == null) {
+			if (s2 == null) {
+				return 0;
+			}
+			return 1;
+		}
+		if (s1.equals(s2)) {
+			return 0;
+		}
+		return 1;
+	}
+
+}

Added: sglr-recovery/trunk/Evaluate/src/compare/StrategoTranslator.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/Evaluate/src/compare/StrategoTranslator.java	Wed Jun  8 09:12:55 2011	(r23020)
@@ -0,0 +1,59 @@
+package compare;
+
+import java.util.ArrayList;
+
+import org.briplib.compare.Forest;
+import org.briplib.compare.Label;
+import org.briplib.compare.Tree;
+import org.spoofax.interpreter.terms.IStrategoAppl;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+//import org.strategoxt.imp.runtime.stratego.adapter.IStrategoAstNode;
+import static org.spoofax.interpreter.terms.IStrategoTerm.*;
+
+/**
+ * Translates a stratego term into a compare tree with forests
+ * 
+ * @author Emma Soderberg <emma add cs.lth.se>
+ *
+ */
+public class StrategoTranslator {
+	/*
+	public static Tree translateToTree(IStrategoAstNode ast, String prefix) {
+		Forest forest = translateToForest(ast.getTerm(), prefix);
+		Label label = translateToLabel(ast.getTerm(), prefix);
+		return Tree.create(forest, label);
+	}
+	*/
+	
+	public static Tree translateToTree(IStrategoTerm ast, String prefix) {
+		Forest forest = translateToForest(ast, prefix);
+		Label label = translateToLabel(ast, prefix);
+		return Tree.create(forest, label);
+	}
+
+	private static Forest translateToForest(IStrategoTerm ast, String prefix) {
+		ArrayList<Tree> treeList = new ArrayList<Tree>();
+		for (int i = 0; i < ast.getSubtermCount(); i++) {
+			Tree tree = translateToTree(ast.getSubterm(i), prefix);
+			treeList.add(tree);
+		}
+		return Forest.create(treeList);
+	}
+
+	private static Label translateToLabel(IStrategoTerm ast, String prefix) {
+		String data;
+		switch (ast.getTermType()) {
+			case APPL:
+				data = ((IStrategoAppl) ast).getConstructor().getName();
+				break;
+			case STRING:
+			case INT:
+				data = ast.toString();
+				break;
+			default: 
+				data = ast.getClass().getName(); 
+		}
+		return Label.create(data, prefix);
+	}
+
+}

Modified: sglr-recovery/trunk/Evaluate/src/fileprocessing/TestFile.java
==============================================================================
--- sglr-recovery/trunk/Evaluate/src/fileprocessing/TestFile.java	Tue Jun  7 23:09:32 2011	(r23019)
+++ sglr-recovery/trunk/Evaluate/src/fileprocessing/TestFile.java	Wed Jun  8 09:12:55 2011	(r23020)
@@ -2,6 +2,8 @@
 
 import java.io.File;
 
+import org.spoofax.interpreter.terms.IStrategoTerm;
+
 public class TestFile {
 	
 	public static final int PARSE_FAILURE = -10;
@@ -9,6 +11,10 @@
 	private String pathToIntendedFile;
 	private String pathToErrorFile;
 	
+	// ASTs
+	private IStrategoTerm recoveredAST;
+	private IStrategoTerm intendedAST;
+	
 	//results
 	private int treeDistance;
 	private int astDiffLines;

From emma at cs.lth.se  Wed Jun  8 11:28:27 2011
From: emma at cs.lth.se (Emma Nilsson-Nyman)
Date: Wed, 08 Jun 2011 09:28:27 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23021 -
	sglr-recovery/trunk/Evaluate/src/fileprocessing
Message-ID: <20110608092827.31868CC1B2@mx4.tudelft.nl>

Author: EmmaNilssonNyman
Date: Wed Jun  8 09:28:25 2011
New Revision: 23021
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23021&sc=1

Log:
More tree edit distance code

Modified:
   sglr-recovery/trunk/Evaluate/src/fileprocessing/FileProcessing.java
   sglr-recovery/trunk/Evaluate/src/fileprocessing/TestFile.java

Modified: sglr-recovery/trunk/Evaluate/src/fileprocessing/FileProcessing.java
==============================================================================
--- sglr-recovery/trunk/Evaluate/src/fileprocessing/FileProcessing.java	Wed Jun  8 09:12:55 2011	(r23020)
+++ sglr-recovery/trunk/Evaluate/src/fileprocessing/FileProcessing.java	Wed Jun  8 09:28:25 2011	(r23021)
@@ -11,6 +11,9 @@
 import java.io.Writer;
 
 import org.bripgen.sglr.java.JavaSGLRBridgeParser;
+import org.briplib.compare.CostFunction;
+import org.briplib.compare.Tree;
+import org.briplib.compare.TreeAlignment;
 //import org.spoofax.jsglr.client;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.jsglr.client.Asfix2TreeBuilder;
@@ -28,6 +31,9 @@
 import org.spoofax.terms.io.binary.TermReader;
 import org.strategoxt.lang.compat.NativeCallHelper;
 
+import compare.StrategoCostFunction;
+import compare.StrategoTranslator;
+
 public class FileProcessing {
 	private SGLR sglr;
 		
@@ -83,7 +89,8 @@
 			InvalidParseTableException,
 			InterruptedException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
 		String tempFilePath=Directories.TEMP_DIR+ File.separator+test.getFilename();
-		writeParseTree(test.getPathToErrorFile(), tempFilePath+".err.ast");
+		IStrategoTerm recoveredAST = writeParseTree(test.getPathToErrorFile(), tempFilePath+".err.ast");
+		test.setRecoveredAST(recoveredAST);
 		test.setParsetimeError(sglr.getPerformanceMeasuring().getParseTime());
 		test.setRecoverySucceeded(sglr.getPerformanceMeasuring().isParseSucceeded());
 		try {
@@ -93,10 +100,13 @@
 			System.err.println("Error during implode: "+test.getPathToErrorFile());
 			e.printStackTrace();
 		}	
-		if (!new File(test.getPathToIntendedAST()).exists())
-			writeParseTree(test.getPathToIntendedFile(), tempFilePath + ".intended.ast");
-		else
+		if (!new File(test.getPathToIntendedAST()).exists()) {
+			IStrategoTerm intendedAST = writeParseTree(test.getPathToIntendedFile(), tempFilePath + ".intended.ast");
+			test.setIntendedAST(intendedAST);
+		} else {
+			// TODO: get the intended AST for the test here 
 			parseNoOutput(test, test.getPathToIntendedFile());
+		}
 		test.setParsetimeIntended(sglr.getPerformanceMeasuring().getParseTime());
 		try {
 			//implodeAsfix(tempFilePath+".intended.pt", tempFilePath+".intended.ast");
@@ -108,6 +118,7 @@
 		
 		if(test.isRecoverySucceeded() && new File(test.getPathToErrorAST()).exists()){
 			diff(test.getPathToErrorAST(), test.getPathToIntendedAST(), test.getPathToASTDiff());
+			int treeDistance = compareTrees(test.getIntendedAST(), test.getRecoveredAST());
 			test.setTreeDistance(-1);
 			test.setAstDiffLines(Results.getLineCount(test.getPathToASTDiff()));
 			if(ppTable!=null && new File(ppTable).exists()){
@@ -118,6 +129,13 @@
 		}
 	}
 	
+	protected CostFunction costFunction = new StrategoCostFunction();
+	protected int compareTrees(IStrategoTerm org, IStrategoTerm broken) {
+		Tree orgTree = StrategoTranslator.translateToTree(org, "");
+		Tree brokenTree = StrategoTranslator.translateToTree(broken, "");
+		return TreeAlignment.distance(orgTree, brokenTree, costFunction);
+	}
+	
 	public void parseNoOutput(TestFile test, String fname) throws FileNotFoundException, IOException, TokenExpectedException, BadTokenException, ParseException, SGLRException{
 		String inputChars = FileTools.loadFileAsString(new BufferedReader(new FileReader(fname)));
 		try{
@@ -129,7 +147,7 @@
 		test.setRecoverySucceeded(sglr.getPerformanceMeasuring().isParseSucceeded());
 	}
 	
-	private void writeParseTree(String testFile, String parseTreeFile) throws FileNotFoundException,
+	private IStrategoTerm writeParseTree(String testFile, String parseTreeFile) throws FileNotFoundException,
 			IOException, InvalidParseTableException
 			 {
 		String inputChars = FileTools.loadFileAsString(new BufferedReader(new FileReader(testFile)));
@@ -140,11 +158,13 @@
 				TermReader termIO = new TermReader(sglr.getParseTable().getFactory());
 				termIO.unparseToFile((IStrategoTerm) t, out);
 				out.close();
+				return (IStrategoTerm) t;
 			}
 		} catch (Exception e) {
 			System.err.println(e.getMessage());
 			e.printStackTrace();
 		}
+		return null;
 	}
 	
 	private void implodeAsfix(String inputFile, String outputFile) throws InterruptedException, IOException {

Modified: sglr-recovery/trunk/Evaluate/src/fileprocessing/TestFile.java
==============================================================================
--- sglr-recovery/trunk/Evaluate/src/fileprocessing/TestFile.java	Wed Jun  8 09:12:55 2011	(r23020)
+++ sglr-recovery/trunk/Evaluate/src/fileprocessing/TestFile.java	Wed Jun  8 09:28:25 2011	(r23021)
@@ -119,7 +119,19 @@
 		parsetimeError=PARSE_FAILURE;
 		recoverySucceeded=false;
 	}
-	
 
+	public void setRecoveredAST(IStrategoTerm ast) {
+		recoveredAST = ast;
+	}
+	public IStrategoTerm getRecoveredAST() {
+		return recoveredAST;
+	}
+	
+	public void setIntendedAST(IStrategoTerm ast) {
+		intendedAST = ast;
+	}
+	public IStrategoTerm getIntendedAST() {
+		return intendedAST;
+	}
 
 }

From m.dejonge at tudelft.nl  Wed Jun  8 11:50:28 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Wed, 08 Jun 2011 09:50:28 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23022 -
	sglr-recovery/trunk/Evaluate/src/fileprocessing
Message-ID: <20110608095028.1EEC1108C068@mx3.tudelft.nl>

Author: MaartjeDeJonge
Date: Wed Jun  8 09:50:26 2011
New Revision: 23022
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23022&sc=1

Log:
intendedAST

Modified:
   sglr-recovery/trunk/Evaluate/src/fileprocessing/FileProcessing.java

Modified: sglr-recovery/trunk/Evaluate/src/fileprocessing/FileProcessing.java
==============================================================================
--- sglr-recovery/trunk/Evaluate/src/fileprocessing/FileProcessing.java	Wed Jun  8 09:28:25 2011	(r23021)
+++ sglr-recovery/trunk/Evaluate/src/fileprocessing/FileProcessing.java	Wed Jun  8 09:50:26 2011	(r23022)
@@ -104,8 +104,8 @@
 			IStrategoTerm intendedAST = writeParseTree(test.getPathToIntendedFile(), tempFilePath + ".intended.ast");
 			test.setIntendedAST(intendedAST);
 		} else {
-			// TODO: get the intended AST for the test here 
-			parseNoOutput(test, test.getPathToIntendedFile());
+			IStrategoTerm intendedAST = parseNoOutput(test, test.getPathToIntendedFile());
+			test.setIntendedAST(intendedAST);
 		}
 		test.setParsetimeIntended(sglr.getPerformanceMeasuring().getParseTime());
 		try {
@@ -136,15 +136,18 @@
 		return TreeAlignment.distance(orgTree, brokenTree, costFunction);
 	}
 	
-	public void parseNoOutput(TestFile test, String fname) throws FileNotFoundException, IOException, TokenExpectedException, BadTokenException, ParseException, SGLRException{
+	public IStrategoTerm parseNoOutput(TestFile test, String fname) throws FileNotFoundException, IOException, TokenExpectedException, BadTokenException, ParseException, SGLRException{
 		String inputChars = FileTools.loadFileAsString(new BufferedReader(new FileReader(fname)));
 		try{
-			sglr.parse(inputChars, fname, null);
+			Object t = sglr.parse(inputChars, fname, null);
+			test.setRecoverySucceeded(sglr.getPerformanceMeasuring().isParseSucceeded());
+			return (IStrategoTerm) t;
 		}
 		catch(Exception e){
 			System.out.println("parse failure: "+fname);
+			test.setRecoverySucceeded(false);
+			return null;
 		}
-		test.setRecoverySucceeded(sglr.getPerformanceMeasuring().isParseSucceeded());
 	}
 	
 	private IStrategoTerm writeParseTree(String testFile, String parseTreeFile) throws FileNotFoundException,

From emma at cs.lth.se  Wed Jun  8 15:05:04 2011
From: emma at cs.lth.se (Emma Nilsson-Nyman)
Date: Wed, 08 Jun 2011 13:05:04 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23023 - in
	sglr-recovery/trunk/Evaluate/src: evaluation_runs fileprocessing
Message-ID: <20110608130505.00B9B2B80A3@mx2.tudelft.nl>

Author: EmmaNilssonNyman
Date: Wed Jun  8 13:05:03 2011
New Revision: 23023
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23023&sc=1

Log:
what I'm trying to run

Modified:
   sglr-recovery/trunk/Evaluate/src/evaluation_runs/Testing.java
   sglr-recovery/trunk/Evaluate/src/fileprocessing/FileProcessing.java

Modified: sglr-recovery/trunk/Evaluate/src/evaluation_runs/Testing.java
==============================================================================
--- sglr-recovery/trunk/Evaluate/src/evaluation_runs/Testing.java	Wed Jun  8 09:50:26 2011	(r23022)
+++ sglr-recovery/trunk/Evaluate/src/evaluation_runs/Testing.java	Wed Jun  8 13:05:03 2011	(r23023)
@@ -20,9 +20,9 @@
 public class Testing {
 	
 	private static final String TESTRUN_NAME = null; //name of result files, default is <technique>_<grammar>
-	private static final String TESTSUITE = "webdsl";
+	private static final String TESTSUITE = "webdsl"; //"stratego-java-test";
 	private static final Permissive GRAMMAR = Permissive.WC;
-	private static final Technique TECHNIQUE = Technique.RS_BP_FG;
+	private static final Technique TECHNIQUE = Technique.RS_BP_FG; //Technique.RS_BP; 
 
 	@Test
 	public void test_StrategoJava() throws FileNotFoundException, IOException, InvalidParseTableException, InterruptedException, TokenExpectedException, BadTokenException, ParseException, org.spoofax.jsglr.shared.SGLRException {

Modified: sglr-recovery/trunk/Evaluate/src/fileprocessing/FileProcessing.java
==============================================================================
--- sglr-recovery/trunk/Evaluate/src/fileprocessing/FileProcessing.java	Wed Jun  8 09:50:26 2011	(r23022)
+++ sglr-recovery/trunk/Evaluate/src/fileprocessing/FileProcessing.java	Wed Jun  8 13:05:03 2011	(r23023)
@@ -118,8 +118,8 @@
 		
 		if(test.isRecoverySucceeded() && new File(test.getPathToErrorAST()).exists()){
 			diff(test.getPathToErrorAST(), test.getPathToIntendedAST(), test.getPathToASTDiff());
-			int treeDistance = compareTrees(test.getIntendedAST(), test.getRecoveredAST());
-			test.setTreeDistance(-1);
+			int treeDistance = -1; //compareTrees(test.getIntendedAST(), test.getRecoveredAST());
+			test.setTreeDistance(treeDistance);
 			test.setAstDiffLines(Results.getLineCount(test.getPathToASTDiff()));
 			if(ppTable!=null && new File(ppTable).exists()){
 				prettyPrint(test.getPathToErrorAST(), test.getPathToErrorPP(), ppTable);

From fehrenbach at informatik.uni-marburg.de  Wed Jun  8 15:49:23 2011
From: fehrenbach at informatik.uni-marburg.de (Stefan Fehrenbach)
Date: Wed, 08 Jun 2011 13:49:23 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23024 -
	sugarj/trunk/compiler/org/sugarj/driver
Message-ID: <20110608134923.90CD4108C002@mx3.tudelft.nl>

Author: StefanFehrenbach
Date: Wed Jun  8 13:49:17 2011
New Revision: 23024
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23024&sc=1

Log:
Fix NPE if Path is null.

Modified:
   sugarj/trunk/compiler/org/sugarj/driver/SDFCommands.java

Modified: sugarj/trunk/compiler/org/sugarj/driver/SDFCommands.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/SDFCommands.java	Wed Jun  8 13:05:03 2011	(r23023)
+++ sugarj/trunk/compiler/org/sugarj/driver/SDFCommands.java	Wed Jun  8 13:49:17 2011	(r23024)
@@ -362,7 +362,7 @@
         Path sourceFile = FileCommands.newTempFile("");
         FileCommands.writeToFile(sourceFile, source.toString());
         log.endTask("failed: " + 
-            log.commandLineAsString(new String[] {"jsglri", "-p", tbl.getAbsolutePath(), "-i " + sourceFile + "-s", start}));
+            log.commandLineAsString(new String[] {"jsglri", "-p", tbl == null ? "unknown" : tbl.getAbsolutePath(), "-i " + sourceFile + "-s", start}));
       }
     }
     

From emma at cs.lth.se  Wed Jun  8 16:14:17 2011
From: emma at cs.lth.se (Emma Nilsson-Nyman)
Date: Wed, 08 Jun 2011 14:14:17 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23025 - in
	sglr-recovery/trunk/Evaluate: . src/compare
	src/evaluation_runs src/fileprocessing
Message-ID: <20110608141418.026207F80BE@mx1.tudelft.nl>

Author: EmmaNilssonNyman
Date: Wed Jun  8 14:14:16 2011
New Revision: 23025
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23025&sc=1

Log:
Switch to new BP generator/library

Modified:
   sglr-recovery/trunk/Evaluate/.classpath
   sglr-recovery/trunk/Evaluate/src/compare/StrategoCostFunction.java
   sglr-recovery/trunk/Evaluate/src/compare/StrategoTranslator.java
   sglr-recovery/trunk/Evaluate/src/evaluation_runs/Testing.java
   sglr-recovery/trunk/Evaluate/src/fileprocessing/FileProcessing.java

Modified: sglr-recovery/trunk/Evaluate/.classpath
==============================================================================
--- sglr-recovery/trunk/Evaluate/.classpath	Wed Jun  8 13:49:17 2011	(r23024)
+++ sglr-recovery/trunk/Evaluate/.classpath	Wed Jun  8 14:14:16 2011	(r23025)
@@ -5,9 +5,8 @@
 	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
 	<classpathentry combineaccessrules="false" kind="src" path="/org.spoofax.terms"/>
 	<classpathentry combineaccessrules="false" kind="src" path="/org.spoofax.jsglr"/>
-	<classpathentry kind="src" path="/org.bripgen"/>
 	<classpathentry kind="lib" path="/org.bripgen/tools/lpg.runtime_2.0.16.jar"/>
 	<classpathentry kind="lib" path="strategoxt.jar"/>
-	<classpathentry combineaccessrules="false" kind="src" path="/org.briplib"/>
+	<classpathentry kind="lib" path="/bridge-definitions/grammars/generated/bridget.jar"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>

Modified: sglr-recovery/trunk/Evaluate/src/compare/StrategoCostFunction.java
==============================================================================
--- sglr-recovery/trunk/Evaluate/src/compare/StrategoCostFunction.java	Wed Jun  8 13:49:17 2011	(r23024)
+++ sglr-recovery/trunk/Evaluate/src/compare/StrategoCostFunction.java	Wed Jun  8 14:14:16 2011	(r23025)
@@ -1,8 +1,8 @@
 package compare;
 
-import org.briplib.compare.CostFunction;
-import org.briplib.compare.Label;
-import org.briplib.compare.Label.Empty;
+import org.bridget.compare.CostFunction;
+import org.bridget.compare.Label;
+import org.bridget.compare.Label.Empty;
 
 /**
  * Cost function for comparison of Stratego trees

Modified: sglr-recovery/trunk/Evaluate/src/compare/StrategoTranslator.java
==============================================================================
--- sglr-recovery/trunk/Evaluate/src/compare/StrategoTranslator.java	Wed Jun  8 13:49:17 2011	(r23024)
+++ sglr-recovery/trunk/Evaluate/src/compare/StrategoTranslator.java	Wed Jun  8 14:14:16 2011	(r23025)
@@ -2,9 +2,9 @@
 
 import java.util.ArrayList;
 
-import org.briplib.compare.Forest;
-import org.briplib.compare.Label;
-import org.briplib.compare.Tree;
+import org.bridget.compare.Forest;
+import org.bridget.compare.Label;
+import org.bridget.compare.Tree;
 import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 //import org.strategoxt.imp.runtime.stratego.adapter.IStrategoAstNode;

Modified: sglr-recovery/trunk/Evaluate/src/evaluation_runs/Testing.java
==============================================================================
--- sglr-recovery/trunk/Evaluate/src/evaluation_runs/Testing.java	Wed Jun  8 13:49:17 2011	(r23024)
+++ sglr-recovery/trunk/Evaluate/src/evaluation_runs/Testing.java	Wed Jun  8 14:14:16 2011	(r23025)
@@ -22,7 +22,7 @@
 	private static final String TESTRUN_NAME = null; //name of result files, default is <technique>_<grammar>
 	private static final String TESTSUITE = "webdsl"; //"stratego-java-test";
 	private static final Permissive GRAMMAR = Permissive.WC;
-	private static final Technique TECHNIQUE = Technique.RS_BP_FG; //Technique.RS_BP; 
+	private static final Technique TECHNIQUE = Technique.RS_FG; // Technique.RS_BP; // Technique.RS_BP_FG;  
 
 	@Test
 	public void test_StrategoJava() throws FileNotFoundException, IOException, InvalidParseTableException, InterruptedException, TokenExpectedException, BadTokenException, ParseException, org.spoofax.jsglr.shared.SGLRException {

Modified: sglr-recovery/trunk/Evaluate/src/fileprocessing/FileProcessing.java
==============================================================================
--- sglr-recovery/trunk/Evaluate/src/fileprocessing/FileProcessing.java	Wed Jun  8 13:49:17 2011	(r23024)
+++ sglr-recovery/trunk/Evaluate/src/fileprocessing/FileProcessing.java	Wed Jun  8 14:14:16 2011	(r23025)
@@ -10,10 +10,10 @@
 import java.io.PrintStream;
 import java.io.Writer;
 
-import org.bripgen.sglr.java.JavaSGLRBridgeParser;
-import org.briplib.compare.CostFunction;
-import org.briplib.compare.Tree;
-import org.briplib.compare.TreeAlignment;
+//import org.bripgen.sglr.java.JavaSGLRBridgeParser;
+import org.bridget.compare.CostFunction;
+import org.bridget.compare.Tree;
+import org.bridget.compare.TreeAlignment;
 //import org.spoofax.jsglr.client;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.jsglr.client.Asfix2TreeBuilder;
@@ -65,8 +65,9 @@
 			SGLR tokenParser = new SGLR(new TreeBuilder(true), tokenTable);
 			tokenParser.setTreeBuilder(new TreeBuilder(true));
 			//tokenParser.setKeepAmbiguities(true);
-			IRecoveryParser recoveryParser = new JavaSGLRBridgeParser(tokenParser); // TODO: Properly select/load appropriate bridge parser
-	        sglr.setUseStructureRecovery(true, recoveryParser);
+			// TODO: Change to generated BPs
+			//IRecoveryParser recoveryParser = new JavaSGLRBridgeParser(tokenParser); // TODO: Properly select/load appropriate bridge parser
+	        //sglr.setUseStructureRecovery(true, recoveryParser);
 		}
 		else
 			sglr.setUseStructureRecovery(true);

From emma at cs.lth.se  Wed Jun  8 16:38:20 2011
From: emma at cs.lth.se (Emma Nilsson-Nyman)
Date: Wed, 08 Jun 2011 14:38:20 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23026 -
	sglr-recovery/trunk/Evaluate/src/fileprocessing
Message-ID: <20110608143820.B95EA2B809E@mx2.tudelft.nl>

Author: EmmaNilssonNyman
Date: Wed Jun  8 14:38:19 2011
New Revision: 23026
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23026&sc=1

Log:


Modified:
   sglr-recovery/trunk/Evaluate/src/fileprocessing/Results.java
   sglr-recovery/trunk/Evaluate/src/fileprocessing/TestRun.java

Modified: sglr-recovery/trunk/Evaluate/src/fileprocessing/Results.java
==============================================================================
--- sglr-recovery/trunk/Evaluate/src/fileprocessing/Results.java	Wed Jun  8 14:14:16 2011	(r23025)
+++ sglr-recovery/trunk/Evaluate/src/fileprocessing/Results.java	Wed Jun  8 14:38:19 2011	(r23026)
@@ -71,6 +71,14 @@
 		writeStatistics(lineCounts, "Ast-Diffs (line count)", prs, RANGE_DIFF_DATA, UPPERBOUND_DIFF_DATA);
 	}
 
+	public static void writeDistanceStats(ArrayList<TestFile> testfiles, PrintStream prs) {
+		ArrayList<Integer> lineCounts=new ArrayList<Integer>();
+        for (TestFile test : testfiles) {
+			lineCounts.add(test.getTreeDistance());
+		}
+		writeStatistics(lineCounts, "Tree-dist. (tree edit)", prs, 0, 0); // TODO: What should go at the end here? (last two arguments)
+	}
+
 
 	public static void removeEmptyDiffFiles(String diffDir) throws IOException{
 		File dir=new File(diffDir);

Modified: sglr-recovery/trunk/Evaluate/src/fileprocessing/TestRun.java
==============================================================================
--- sglr-recovery/trunk/Evaluate/src/fileprocessing/TestRun.java	Wed Jun  8 14:14:16 2011	(r23025)
+++ sglr-recovery/trunk/Evaluate/src/fileprocessing/TestRun.java	Wed Jun  8 14:38:19 2011	(r23026)
@@ -230,6 +230,7 @@
 			}
 		PrintStream prsDiff=new PrintStream(getDirSuite()+"results" +File.separator+"quality"+File.separator+getTestRunName());
 		Results.writeDiffStats(testcases, prsDiff);
+		Results.writeDistanceStats(testcases, prsDiff);
 		PrintStream prsTime=new PrintStream(getDirSuite()+"results" +File.separator+"performance"+File.separator+getTestRunName());
 		Results.writeTimeStats(testcases, prsTime);
 		

From m.dejonge at tudelft.nl  Wed Jun  8 18:24:51 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Wed, 08 Jun 2011 16:24:51 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23027 - in
	spoofax-imp/trunk: org.strategoxt.imp.generator/src/sdf2imp/project
	org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services
Message-ID: <20110608162451.62F58108C021@mx3.tudelft.nl>

Author: MaartjeDeJonge
Date: Wed Jun  8 16:24:45 2011
New Revision: 23027
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23027&sc=1

Log:
fatal errors (for example for wrong selection)

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-example-trans.str
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/RefactoringPageTextField.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoRefactoring.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-example-trans.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-example-trans.str	Wed Jun  8 14:38:19 2011	(r23026)
+++ spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-example-trans.str	Wed Jun  8 16:24:45 2011	(r23027)
@@ -203,10 +203,11 @@
 rules
  
   rename-entity:
-    (newname, selected-name, position, ast, path, project-path) -> ([(ast, new-ast)], warnings, errors)
+    (newname, selected-name, position, ast, path, project-path) -> ([(ast, new-ast)], fatal-errors, errors, warnings)
     with
       new-ast  := <topdown(try(rename-type(|selected-name, newname)))> ast; 
-      (warnings, errors) := <semantic-constraint-issues> (ast, new-ast)
+      (errors, warnings) := <semantic-constraint-issues> (ast, new-ast);
+      fatal-errors := []
 
   rename-type(|old-name, new-name):
     Entity(old-name, y) -> Entity(new-name, y)
@@ -215,7 +216,7 @@
     Type(old-name) -> Type(new-name)
     
   semantic-constraint-issues:
-    (ast, new-ast) -> (<diff>(new-warnings, warnings), <diff>(new-errors, errors))
+    (ast, new-ast) -> (<diff>(new-errors, errors), <diff>(new-warnings, warnings))
     where
     	(_, errors, warnings, _) := <editor-analyze> (ast, "", "");
     	(_, new-errors, new-warnings, _) := <editor-analyze> (new-ast, "", "")

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/RefactoringPageTextField.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/RefactoringPageTextField.java	Wed Jun  8 14:38:19 2011	(r23026)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/RefactoringPageTextField.java	Wed Jun  8 16:24:45 2011	(r23027)
@@ -17,7 +17,7 @@
 
 	private Text fNameField;
 	private String labelText = "&New name:";
-	String defaultName = "<newname>";
+	String defaultName = "";
 
 	public RefactoringPageTextField(String name) {
 		super(name);

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoRefactoring.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoRefactoring.java	Wed Jun  8 14:38:19 2011	(r23026)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoRefactoring.java	Wed Jun  8 16:24:45 2011	(r23027)
@@ -115,8 +115,9 @@
 		IStrategoTerm builderResult = null;
 		IStrategoTerm astChanges = null;
 		IStrategoTerm textReplaceTerm = null;
-		IStrategoTerm warnings = null;
+		IStrategoTerm fatalErrors = null;
 		IStrategoTerm errors = null;
+		IStrategoTerm warnings = null;
 		try {
 			builderResult = getBuilderResult();
 			if(builderResult == null){
@@ -126,13 +127,15 @@
 				return RefactoringStatus.createFatalErrorStatus(errorMessage);					
 			}	
 			if (!isValidResultTerm(builderResult)) {
-				String errorMessage = "Illegal refactoring result. Expected: '([(original-node, newnode), ... ], warnings, errors, fatal-errors)'";
+				String errorMessage = "Illegal refactoring result. Expected: '([(original-node, newnode), ... ], fatal-errors, errors, warnings)'";
 				Environment.logException(errorMessage);
 				return RefactoringStatus.createFatalErrorStatus(errorMessage);
 			}
 			astChanges = builderResult.getSubterm(0);
-			warnings = builderResult.getSubterm(1);
+			fatalErrors = builderResult.getSubterm(1);
 			errors = builderResult.getSubterm(2);
+			warnings = builderResult.getSubterm(3);
+			updateStatus(status, fatalErrors, RefactoringStatus.FATAL);
 			updateStatus(status, errors, RefactoringStatus.ERROR);
 			updateStatus(status, warnings, RefactoringStatus.WARNING);
 			textReplaceTerm = getTextReplacement(astChanges);
@@ -165,6 +168,9 @@
 				case RefactoringStatus.ERROR:
 					status.merge(RefactoringStatus.createErrorStatus(message));		
 					break;
+				case RefactoringStatus.FATAL:
+					status.merge(RefactoringStatus.createFatalErrorStatus(message));		
+					break;
 				default:
 					assert(false);
 					break;
@@ -240,7 +246,7 @@
 				return false;
 		}
 		return isTermTuple(resultTerm) 
-			&& resultTerm.getSubtermCount() == 3 
+			&& resultTerm.getSubtermCount() == 4 
 			&& isValidAstChangeList(resultTerm.getSubterm(0));
 	}
 

From m.dejonge at tudelft.nl  Wed Jun  8 18:27:32 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Wed, 08 Jun 2011 16:27:32 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23028 -
	spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services
Message-ID: <20110608162732.C8139108C00C@mx3.tudelft.nl>

Author: MaartjeDeJonge
Date: Wed Jun  8 16:27:31 2011
New Revision: 23028
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23028&sc=1

Log:


Modified:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoRefactoring.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoRefactoring.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoRefactoring.java	Wed Jun  8 16:24:45 2011	(r23027)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoRefactoring.java	Wed Jun  8 16:27:31 2011	(r23028)
@@ -138,6 +138,8 @@
 			updateStatus(status, fatalErrors, RefactoringStatus.FATAL);
 			updateStatus(status, errors, RefactoringStatus.ERROR);
 			updateStatus(status, warnings, RefactoringStatus.WARNING);
+			if(status.hasFatalError())
+				return status; //no need to calculate text changes
 			textReplaceTerm = getTextReplacement(astChanges);
 			if (textReplaceTerm == null) {
 				observer.reportRewritingFailed();

From m.dejonge at tudelft.nl  Wed Jun  8 20:02:05 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Wed, 08 Jun 2011 18:02:05 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23029 -
	spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services
Message-ID: <20110608180205.614EDCC1AC@mx4.tudelft.nl>

Author: MaartjeDeJonge
Date: Wed Jun  8 18:02:00 2011
New Revision: 23029
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23029&sc=1

Log:


Modified:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoRefactoring.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoRefactoring.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoRefactoring.java	Wed Jun  8 16:27:31 2011	(r23028)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoRefactoring.java	Wed Jun  8 18:02:00 2011	(r23029)
@@ -184,7 +184,7 @@
 		if(Tools.isTermString(error))
 			return Tools.asJavaString(error);
 		String message = Tools.asJavaString(error.getSubterm(1));
-		if(hasImploderOrigin(error)){
+		if(hasImploderOrigin(error.getSubterm(0))){
 			IStrategoTerm origin = OriginAttachment.getOrigin(error.getSubterm(0));
 			int line = getLeftToken(origin).getLine();
 			int column = getLeftToken(origin).getColumn();

From M.A.Akhter at student.tudelft.nl  Thu Jun  9 01:19:48 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Wed, 08 Jun 2011 23:19:48 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23030 - in
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax: .
	syntax test/TestLanguage trans/analyze/esv trans/analyze/sdf
	trans/codegen trans/codegen/sdf trans/conte...
Message-ID: <20110608231948.1C451CC1EF@mx4.tudelft.nl>

Author: MdAdilAkhter
Date: Wed Jun  8 23:19:41 2011
New Revision: 23030
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23030&sc=1

Log:
* added more checks on start symbols (both error/warning). 
* automatically syncing start symbols from esv -> sdf during code generation
* making  context-free/karnel/lexical start-symbols ... construct obsolete/deprecated. only in esv section , start symbols will be defined.(right now - this feature is commented out to have a further discussion on it)

Deleted:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/test/TestLanguage/
Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/spx.config
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/syntax/SpoofaxLang.sdf
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/analyze/esv/check.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/analyze/sdf/check.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/generate.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/sdf/to-sdf.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/esv/declare.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/resolve-declarations.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/resolve-symbols.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/scope-tree.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/spx.config
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/spx.config	Wed Jun  8 18:02:00 2011	(r23029)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/spx.config	Wed Jun  8 23:19:41 2011	(r23030)
@@ -1,7 +1,7 @@
 Configuration
 	Includes
-		AllDirectories
-			.		//include the whole project directory
+		AllDirectories Test
 			
 	CodeGeneration 
-		OutputDirectory		.shadowdir  
\ No newline at end of file
+		OutputDirectory		.shadowdir  
+	
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/syntax/SpoofaxLang.sdf
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/syntax/SpoofaxLang.sdf	Wed Jun  8 18:02:00 2011	(r23029)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/syntax/SpoofaxLang.sdf	Wed Jun  8 23:19:41 2011	(r23030)
@@ -38,7 +38,7 @@
 	  Module* 																				-> Start{cons("CompilationUnit") , prefer}
 
     "package" QName Module*                         -> PackageDefinition {cons("Package")}
-    MainID? "module" SPXModuleName Section*         				-> Module {cons("Module")}
+    MainID? "module" SPXModuleName Section*         -> Module {cons("Module")}
 
     Grammar[[SDF]] -> Section {cons("SDFSection")}
     Decl[[STR]]    -> Section {cons("STRSection")}
@@ -50,15 +50,22 @@
     "exports"                       -> ExportsOrHiddens {cons("Exports"), deprecated}
     "hiddens"                       -> ExportsOrHiddens {cons("Hiddens"), deprecated}
 
+	 context-free syntax
+	 	
+%% 		TODO : Depreciate context-free start symbols after discussing with lennart   
+%%    "start-symbols" Symbols[[SDF]]                -> Grammar[[SDF]]  {cons("kernel-start-symbols"),deprecated} 
+%%    "lexical" "start-symbols" Symbols[[SDF]]      -> Grammar[[SDF]]  {cons("lexical-start-symbols"),deprecated}
+%%    "context-free" "start-symbols" Symbols[[SDF]] -> Grammar[[SDF]]  {cons("context-free-start-symbols"),deprecated}
+
 
     %% TODO: Support SDF .def "definitions"?
     %% TODO: Mark deprecated, ast, and maybe other attrs as keyword using a {prefer, ast} production
 
   context-free syntax
     QID "[" Symbols[[SDF]] "]" -> QName  {cons("ParamName")}
-    QID		  				   -> LegacyImportName {cons("Name")}
-    {ID "." }+				   -> QName	 {cons("QName")}
-	ID	 					   -> QName	 {cons("Name"),prefer}
+    QID		  				           -> LegacyImportName {cons("Name")}
+    {ID "." }+			 -> QName	 {cons("QName")}
+	  ID	 					   -> QName	 {cons("Name"),prefer}
     ID  					   -> SPXModuleName	 {cons("SPXModuleName")}
 
 	context-free syntax %% Imports

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/analyze/esv/check.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/analyze/esv/check.str	Wed Jun  8 18:02:00 2011	(r23029)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/analyze/esv/check.str	Wed Jun  8 23:19:41 2011	(r23030)
@@ -15,12 +15,13 @@
 
 rules
 	analyze-section: 
-		ESVSection(ast) -> (error-esv*, warning-esv* , [])
+		ESVSection(ast) -> (error-esv*, warning-esv* , info-esv*)
   	where
   		<debug-analysis>$[ErrorChecking | ESV Section : [<pp-aterm>]]
 		where
   		error-esv*   := <collect-all(constraint-esv-error, conc)> ast;
-  		warning-esv* := <flatten-list><collect-all(constraint-esv-warning, conc)> ast
+  		warning-esv* := <flatten-list><collect-all(constraint-esv-warning, conc)> ast;
+  		info-esv*    := []
 
 
 rules
@@ -43,10 +44,10 @@
 				not(ensure-is-unique)
 					
 rules
-	constraint-esv-warning: 
+	constraint-esv-warning:  
 		StartSymbols(sorts*) -> err-messages*
 		where
-			s* := <get-start-symbols> <GetEnclosingPackageName>; // getting all the context-free-start-symbols for the package   	
+			s* := <get-sdf-start-symbols> <GetEnclosingPackageName>; // getting all the context-free-start-symbols for the package   	
 			<filter(unknown-start-symbol-error(|s*))>sorts* => err-messages*;
 			if !err-messages* => [] then 
 				fail

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/analyze/sdf/check.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/analyze/sdf/check.str	Wed Jun  8 18:02:00 2011	(r23029)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/analyze/sdf/check.str	Wed Jun  8 23:19:41 2011	(r23030)
@@ -28,10 +28,15 @@
 			<debug-analysis>$[ErrorChecking | SDF  : [<pp-aterm>]]
 		with
 	    // We only collect-om since we don't want inner warning dupes
-	    error*   := <collect-om( ?context-free-syntax(<collect-om(context-free-syntax-error)>)
-	                           + ?TemplateSection(<collect-om(context-free-templates-error)>), conc)> ast;
-	    warning* := <collect-om( ?context-free-syntax(<collect-om(context-free-syntax-warning)>)
-	                           + ?TemplateSection(<collect-om(context-free-templates-warning)>), conc)> ast;
+	    error*   := <flatten-list><collect-om( ?context-free-syntax       (<collect-om(context-free-syntax-error)>)
+	    																		 + ?context-free-start-symbols(<collect-om(context-free-start-symbols-error)>)
+	    																		 + ?kernel-start-symbols      (<collect-om(context-free-start-symbols-error)>)
+	    																		 + ?lexical-start-symbols     (<collect-om(context-free-start-symbols-error)>)		
+	                                         + ?TemplateSection           (<collect-om(context-free-templates-error)>), conc)
+	                              > ast;
+	    warning* := <collect-om( ?context-free-syntax (<collect-om(context-free-syntax-warning)>)
+	    											 + ?TemplateSection     (<collect-om(context-free-templates-warning)>), conc)
+	    						> ast;
 	    if <file-exists> $[[<get-project-path>]/.disable-global-analysis] then
 	      serror* := []
 	    else
@@ -86,9 +91,24 @@
     		msg-to-append := ""
     	end;
     	<has-duplicate-sdf-definitions(|op-name)>x 	 
+
+	context-free-start-symbols-error:	
+   	sorts* -> err-messages*
+   	where
+  		s* := <get-esv-start-symbols> <GetEnclosingPackageName>; // getting all the esv start symbols defined in this package   	
+			<filter(unknown-start-symbol-error(|s*))>sorts* => err-messages*;
+			if !err-messages* => [] then 
+				fail
+			end
 	
+	unknown-start-symbol-error(|start-symbols-found-in-esv-def) : 
+		s at sort(x) -> (s, $[Unknown Start Symbol :  "[x]". Please specify it as a Start Symbol in Language Description(esv)])
+		where 
+			<not(fetch-elem(?Sort(x)))>start-symbols-found-in-esv-def 	
+   
 rules // Local checks
-   context-free-syntax-warning:
+	
+	 context-free-syntax-warning: 
     prod(p*, s, a*) -> (target, $[Missing {"Label"} attribute to label the abstract syntax])
     where
       (

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/generate.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/generate.str	Wed Jun  8 18:02:00 2011	(r23029)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/generate.str	Wed Jun  8 23:19:41 2011	(r23030)
@@ -98,6 +98,8 @@
 							// languages.
 							
 							{| GetLanguageName : 
+										<debug>$[-------------------------Generating Main Artifacts ---------------------];
+										<debug>$[------------------------------------------------------------------------];
 										rules( GetLanguageName  := language-name);
 										<emit-package-signature-main>();
 										<generate-main> enclosed-module-typed-qnames 

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/sdf/to-sdf.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/sdf/to-sdf.str	Wed Jun  8 18:02:00 2011	(r23029)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/sdf/to-sdf.str	Wed Jun  8 23:19:41 2011	(r23030)
@@ -66,17 +66,26 @@
 			 main-sdf-module-name :=<get-main-file-name>();
 			 output-path := <get-main-output-path(|main-sdf-module-name, "sdf")>(root-directory, package-qname);
 			<debug-compiler>$[ Codegen | SDF | Generating main for the following package : [<pp-aterm> package-qname].]
+ 		with
+ 			resultant-sorts := <get-sdf-start-symbols-to-sync ; is-not-empty-list <+ ![]>;
+ 			if not(!resultant-sorts => []) then
+ 				start-symbol-syntax := [exports(context-free-start-symbols(resultant-sorts))]	 
+ 			else
+ 				start-symbol-syntax := [exports(resultant-sorts)]
+ 			end	  
  		where
-			sdf-string :=
-	    $[module [main-sdf-module-name]
-	         imports
-		      	[<map(pp-sdf-import)>module-qname*]
-	     ]
+ 			sdf-string := 
+				<pp-sdf-string'>
+				'module(
+  				unparameterized(main-sdf-module-name)
+					, [imports(<map(pp-sdf-import;!'module(unparameterized(<id>)))>module-qname*)]
+					, start-symbol-syntax
+					)
 	  where
-	  	<debug-compiler>$[ codegen | SDF | Content of the main SDF is generated for the package : [<pp-aterm> package-qname].]
+	  	<debug-compiler>$[Codegen | SDF | Content of the main SDF is generated for the package : [<pp-aterm> package-qname].]
 		where
 			<save-artifact(| package-qname , root-directory, output-path)>sdf-string;
-			<debug-compiler>$[ Codegen | SDF | Finishing generation of Main SDF Module of package : [<pp-aterm> package-qname].]
+			<debug-compiler>$[Codegen | SDF | Finishing generation of Main SDF Module of package : [<pp-aterm> package-qname].]
 
 rules
 
@@ -120,7 +129,6 @@
 	// Basically anything Unresolved is not added as a import statment in
 	// generated SDF definition.
  	sdf-import-adapter : legacy-artifact at Name(name)  -> 	result
- 	where debug
  	where
  		if <has-extension(|"sdf")+has-extension(|"def")><UsedLegacyArtifacts>(<GetEnclosingPackageName> , name)then
 				// Importing Legacy artifact only if it is a SDF or DEF file

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/esv/declare.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/esv/declare.str	Wed Jun  8 18:02:00 2011	(r23029)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/esv/declare.str	Wed Jun  8 23:19:41 2011	(r23030)
@@ -25,8 +25,12 @@
 		with 
 			store-langauge-properties(|<GetEnclosingPackageName>)
 	 
-	 declare-esv-definition : 
+	declare-esv-definition : 
 		LanguageId(id-string)  -> <id>
 		with 
 			store-langauge-properties(|<GetEnclosingPackageName>)
-	 	
\ No newline at end of file
+	 
+	declare-esv-definition : 
+		StartSymbols(sorts*)  -> <id>
+		with 
+			store-context-free-start-symbols(|<GetEnclosingPackageName>)

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/resolve-declarations.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/resolve-declarations.str	Wed Jun  8 18:02:00 2011	(r23029)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/resolve-declarations.str	Wed Jun  8 23:19:41 2011	(r23030)
@@ -20,15 +20,39 @@
 	utils/path
 	utils/debug 
 	utils/contract
+
+
+rules 
+	get-sdf-start-symbols-to-sync = 
+		where ( 
+			<get-esv-start-symbols;debug><GetEnclosingPackageName> => esv-start-symbols; 
+			<get-sdf-start-symbols;debug><GetEnclosingPackageName> => sdf-start-symbols
+		)
+		;<diff(is-eq-sorts)>(esv-start-symbols,sdf-start-symbols)
+		; make-set
+		; map(\Sort(x) -> sort(x)\)  
+		
+	is-eq-sorts : (Sort(y),sort(x)) -> <eq>(x,y)
 	
 rules 
-	get-start-symbols =
+	
+	get-esv-start-symbols =
 		contracts(
 			contract-requires(
 				?Package(QName(_))
 			)
 		);
-		bagof-DeclaredContextFreeStartSymbols;
+		bagof-DeclaredESVStartSymbols;
+		flatten-list 
+
+
+	get-sdf-start-symbols =
+		contracts(
+			contract-requires(
+				?Package(QName(_))
+			)
+		); 
+		bagof-DeclaredSDFStartSymbols;
 		flatten-list 
 
 	get-language-id = 

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/resolve-symbols.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/resolve-symbols.str	Wed Jun  8 18:02:00 2011	(r23029)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/resolve-symbols.str	Wed Jun  8 23:19:41 2011	(r23030)
@@ -13,7 +13,7 @@
 imports 	 
 	common
 	config 
-	utils/annotations
+	utils/annotations 
 	utils/path
 	utils/debug
 

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/scope-tree.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/scope-tree.str	Wed Jun  8 18:02:00 2011	(r23029)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/scope-tree.str	Wed Jun  8 23:19:41 2011	(r23030)
@@ -84,9 +84,17 @@
 			rules( DeclaredLangaugeId :+ package-typed-qname -> id-string)
 			;<debug-symboltable> $[ ScopeTree| [<pp-aterm>package-typed-qname] storing  following language Id : [<pp-aterm>id-string]]
 	 
+	 
+	store-context-free-start-symbols(|package-typed-qname) : 
+	 	StartSymbols(sorts*) -> <id>
+	 	with 
+			rules( DeclaredESVStartSymbols :+ package-typed-qname -> sorts*)
+			;<debug-symboltable> $[ ScopeTree| [<pp-aterm>package-typed-qname] storing  following start symbols found from ESV language description: [<pp-aterm>sorts*]]
+	 	
+	 	 
 	store-context-free-start-symbols(|package-typed-qname) : 
 	 	context-free-start-symbols(sorts*) -> <id>
 	 	with 
-			rules( DeclaredContextFreeStartSymbols :+ package-typed-qname -> sorts*)
+			rules( DeclaredSDFStartSymbols :+ package-typed-qname -> sorts*)
 			;<debug-symboltable> $[ ScopeTree| [<pp-aterm>package-typed-qname] storing  following start symbols : [<pp-aterm>sorts*]]
 	 		 		
\ No newline at end of file

From emma at cs.lth.se  Thu Jun  9 10:06:20 2011
From: emma at cs.lth.se (Emma Nilsson-Nyman)
Date: Thu, 09 Jun 2011 08:06:20 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23031 -
	sglr-recovery/trunk/bridge-definitions/grammars/generated
Message-ID: <20110609080620.7B7927F8012@mx1.tudelft.nl>

Author: EmmaNilssonNyman
Date: Thu Jun  9 08:06:19 2011
New Revision: 23031
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23031&sc=1

Log:
updated bridge parser library

Modified:
   sglr-recovery/trunk/bridge-definitions/grammars/generated/bridget.jar

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/bridget.jar
==============================================================================
Binary file (source and/or target). No diff available.

From emma at cs.lth.se  Thu Jun  9 10:23:58 2011
From: emma at cs.lth.se (Emma Nilsson-Nyman)
Date: Thu, 09 Jun 2011 08:23:58 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23032 - in
	sglr-recovery/trunk/Evaluate: . src/bridgeparser src/fileprocessing
Message-ID: <20110609082358.566407F800F@mx1.tudelft.nl>

Author: EmmaNilssonNyman
Date: Thu Jun  9 08:23:57 2011
New Revision: 23032
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23032&sc=1

Log:
New bridge parser integration

Added:
   sglr-recovery/trunk/Evaluate/src/bridgeparser/
   sglr-recovery/trunk/Evaluate/src/bridgeparser/SGLRBridgeParser.java
   sglr-recovery/trunk/Evaluate/src/bridgeparser/SGLRRecoveryResult.java
Modified:
   sglr-recovery/trunk/Evaluate/.classpath
   sglr-recovery/trunk/Evaluate/src/fileprocessing/FileProcessing.java
   sglr-recovery/trunk/Evaluate/src/fileprocessing/TestRun.java

Modified: sglr-recovery/trunk/Evaluate/.classpath
==============================================================================
--- sglr-recovery/trunk/Evaluate/.classpath	Thu Jun  9 08:06:19 2011	(r23031)
+++ sglr-recovery/trunk/Evaluate/.classpath	Thu Jun  9 08:23:57 2011	(r23032)
@@ -7,6 +7,10 @@
 	<classpathentry combineaccessrules="false" kind="src" path="/org.spoofax.jsglr"/>
 	<classpathentry kind="lib" path="/org.bripgen/tools/lpg.runtime_2.0.16.jar"/>
 	<classpathentry kind="lib" path="strategoxt.jar"/>
-	<classpathentry kind="lib" path="/bridge-definitions/grammars/generated/bridget.jar"/>
+	<classpathentry kind="lib" path="/bridge-definitions/grammars/generated/bridget.jar" sourcepath="/home/emma/svn/emma/projects/bridge-parsing/bridget/generator/src"/>
+	<classpathentry kind="lib" path="/bridge-definitions/grammars/generated/java15.jar"/>
+	<classpathentry kind="lib" path="/bridge-definitions/grammars/generated/javasql.jar"/>
+	<classpathentry kind="lib" path="/bridge-definitions/grammars/generated/strategojava.jar"/>
+	<classpathentry kind="lib" path="/bridge-definitions/grammars/generated/webdsl.jar"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>

Added: sglr-recovery/trunk/Evaluate/src/bridgeparser/SGLRBridgeParser.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/Evaluate/src/bridgeparser/SGLRBridgeParser.java	Thu Jun  9 08:23:57 2011	(r23032)
@@ -0,0 +1,30 @@
+package bridgeparser;
+
+import org.bridget.rt.IBridgeParser;
+import org.bridget.rt.log.RecoveryLog;
+import org.bridget.rt.recovery.RecoveryResult;
+import org.spoofax.jsglr.client.IRecoveryParser;
+import org.spoofax.jsglr.client.IRecoveryResult;
+
+public class SGLRBridgeParser implements IRecoveryParser {
+
+	private IBridgeParser parser;
+	
+	public SGLRBridgeParser(IBridgeParser parser) {
+		this.parser = parser;
+	}
+	
+	@Override
+	public IRecoveryResult recover(String text) throws Exception {
+		RecoveryLog log = new RecoveryLog();	
+		RecoveryResult result = parser.recover(text, log);
+		return new SGLRRecoveryResult(result);
+	}
+	
+	@Override
+	public IRecoveryResult recover(String text, String startSymbol)
+			throws Exception {
+		return recover(text);
+	}
+
+}

Added: sglr-recovery/trunk/Evaluate/src/bridgeparser/SGLRRecoveryResult.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/Evaluate/src/bridgeparser/SGLRRecoveryResult.java	Thu Jun  9 08:23:57 2011	(r23032)
@@ -0,0 +1,16 @@
+package bridgeparser;
+
+import org.bridget.rt.recovery.RecoveryResult;
+import org.spoofax.jsglr.client.IRecoveryResult;
+
+public class SGLRRecoveryResult extends RecoveryResult implements IRecoveryResult {
+
+	public SGLRRecoveryResult(RecoveryResult result) {
+		super(result);
+	}
+
+	public String getResult() {
+		return getResultAsString();
+	}
+
+}

Modified: sglr-recovery/trunk/Evaluate/src/fileprocessing/FileProcessing.java
==============================================================================
--- sglr-recovery/trunk/Evaluate/src/fileprocessing/FileProcessing.java	Thu Jun  9 08:06:19 2011	(r23031)
+++ sglr-recovery/trunk/Evaluate/src/fileprocessing/FileProcessing.java	Thu Jun  9 08:23:57 2011	(r23032)
@@ -37,8 +37,8 @@
 public class FileProcessing {
 	private SGLR sglr;
 		
-	public FileProcessing(String parseTableLocation, String tokenParseTable) throws FileNotFoundException, IOException, InvalidParseTableException{
-		setSGLR(parseTableLocation, tokenParseTable);
+	public FileProcessing(String parseTableLocation, String tokenParseTable, IRecoveryParser recoveryParser) throws FileNotFoundException, IOException, InvalidParseTableException{
+		setSGLR(parseTableLocation, tokenParseTable, recoveryParser);
 	}
 	
 	public void setCombinedRecovery(boolean bp, boolean fg, boolean only_fg){
@@ -50,7 +50,7 @@
 	}
 	
 	
-	public void setSGLR(String parseTableLocation, String tokenParseTable) throws FileNotFoundException, IOException, InvalidParseTableException{		
+	public void setSGLR(String parseTableLocation, String tokenParseTable, IRecoveryParser recoveryParser) throws FileNotFoundException, IOException, InvalidParseTableException{		
 		final TermFactory factory = new TermFactory();
 		final IStrategoTerm tableTerm = new TermReader(factory).parseFromFile(parseTableLocation);
 		final ParseTable pt = new ParseTable(tableTerm, factory);
@@ -58,6 +58,14 @@
 		sglr.getDisambiguator().setDefaultFilters();
 		sglr.getDisambiguator().setHeuristicFilters(true);
 		sglr.setTreeBuilder(new TreeBuilder(true));
+		
+		if (recoveryParser != null) {
+			sglr.setUseStructureRecovery(true, recoveryParser);
+		} else {
+			sglr.setUseStructureRecovery(true);
+		}
+		
+		/*
 		if (tokenParseTable != null) {		
 			TermFactory pfb = new TermFactory();
 			final IStrategoTerm resultBP = new TermReader(pfb).parseFromFile(tokenParseTable);
@@ -71,6 +79,7 @@
 		}
 		else
 			sglr.setUseStructureRecovery(true);
+		*/
 	}
 
 	
@@ -117,9 +126,12 @@
 			e.printStackTrace();
 		}
 		
+		
 		if(test.isRecoverySucceeded() && new File(test.getPathToErrorAST()).exists()){
 			diff(test.getPathToErrorAST(), test.getPathToIntendedAST(), test.getPathToASTDiff());
-			int treeDistance = -1; //compareTrees(test.getIntendedAST(), test.getRecoveredAST());
+			/* EMMA*/System.out.println("Starting tree distance check");
+			int treeDistance = compareTrees(test.getIntendedAST(), test.getRecoveredAST());
+			/* EMMA*/System.out.println("Tree edit distance: " + treeDistance);
 			test.setTreeDistance(treeDistance);
 			test.setAstDiffLines(Results.getLineCount(test.getPathToASTDiff()));
 			if(ppTable!=null && new File(ppTable).exists()){
@@ -133,7 +145,9 @@
 	protected CostFunction costFunction = new StrategoCostFunction();
 	protected int compareTrees(IStrategoTerm org, IStrategoTerm broken) {
 		Tree orgTree = StrategoTranslator.translateToTree(org, "");
+		System.out.println("Translated tree intended");
 		Tree brokenTree = StrategoTranslator.translateToTree(broken, "");
+		System.out.println("Translated tree recovered");
 		return TreeAlignment.distance(orgTree, brokenTree, costFunction);
 	}
 	

Modified: sglr-recovery/trunk/Evaluate/src/fileprocessing/TestRun.java
==============================================================================
--- sglr-recovery/trunk/Evaluate/src/fileprocessing/TestRun.java	Thu Jun  9 08:06:19 2011	(r23031)
+++ sglr-recovery/trunk/Evaluate/src/fileprocessing/TestRun.java	Thu Jun  9 08:23:57 2011	(r23032)
@@ -9,12 +9,15 @@
 import java.util.HashMap;
 import java.util.Map;
 
+import org.spoofax.jsglr.client.IRecoveryParser;
 import org.spoofax.jsglr.client.InvalidParseTableException;
 import org.spoofax.jsglr.client.ParseException;
 import org.spoofax.jsglr.shared.BadTokenException;
 import org.spoofax.jsglr.shared.SGLRException;
 import org.spoofax.jsglr.shared.TokenExpectedException;
 
+import bridgeparser.SGLRBridgeParser;
+
 public class TestRun {
 	
 	public enum Technique{
@@ -154,6 +157,22 @@
 			return null;
 	}	
 	
+	public IRecoveryParser getRecoveryParser() {
+		IRecoveryParser parser = null;
+		if (technique.equals(Technique.RS_BP_FG)|| technique.equals(Technique.RS_BP)) {
+			if (suite.equals("java")) {
+				parser = new SGLRBridgeParser(new java15.MainBridgeParser());
+			} else if (suite.equals("webdsl")) {
+				parser = new SGLRBridgeParser(new webdsl.MainBridgeParser());
+			} else if (suite.equals("java-sql")) {
+				parser = new SGLRBridgeParser(new javasql.MainBridgeParser());
+			} else if (suite.startsWith("stratego-java")) {
+				parser = new SGLRBridgeParser(new strategojava.MainBridgeParser());
+			}
+		}
+		return parser;
+	}
+	
 	public ArrayList<TestFile> getErrorFileList() throws IOException{
 		ArrayList<TestFile> testcases=new ArrayList<TestFile>();
 		File dir = new File(getDirErrorFiles());
@@ -182,7 +201,7 @@
 		ArrayList<TestFile> testcases=getErrorFileList();
 		setFilenameFilter(FilenameFilters.getFilterAll());	
 		String nonErrorParsetable=getDirSuite()+"grammars-gen"+File.separator+parseTableBaseNames.get(suite)+".tbl";
-		FileProcessing fp = new FileProcessing(nonErrorParsetable, null);
+		FileProcessing fp = new FileProcessing(nonErrorParsetable, null, null);
 		fp.setNoRecovery();
 		for (TestFile test : testcases) {
 			fp.parseNoOutput(test, test.getPathToErrorFile());
@@ -244,7 +263,7 @@
 
 	private FileProcessing getFileProcessing() throws FileNotFoundException,
 			IOException, InvalidParseTableException {
-		FileProcessing fp=new FileProcessing(getParseTable(), getTokenTable());
+		FileProcessing fp=new FileProcessing(getParseTable(), getTokenTable(), getRecoveryParser());
 		switch (technique) {
 		case FG:
 			fp.setCombinedRecovery(false, true, true);

From emma at cs.lth.se  Thu Jun  9 11:04:44 2011
From: emma at cs.lth.se (Emma Nilsson-Nyman)
Date: Thu, 09 Jun 2011 09:04:44 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23033 - in
	sglr-recovery/trunk/bridge-definitions/grammars: generated
	generated/java15 generated/javasql generated/strategojava
	generated/webdsl java/java15
Message-ID: <20110609090444.ABDA7CC0D4@mx4.tudelft.nl>

Author: EmmaNilssonNyman
Date: Thu Jun  9 09:04:38 2011
New Revision: 23033
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23033&sc=1

Log:
Updated generated bridge parsers

Added:
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/IgnoreLineComment.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/IgnoreLineComment.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/IgnoreMultiComment.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/IgnoreMultiComment.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/IgnoreString.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/IgnoreString.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/LBrace.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/LBrace.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/LBrack.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/LBrack.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/LParen.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/LParen.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/Layout.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/Layout.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/LayoutEndIsland.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/LayoutEndIsland.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/LayoutReef.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/LayoutReef.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/LayoutStartIsland.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/LayoutStartIsland.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/MainBridgeParser.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/MainBridgeParser.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/RBrace.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/RBrace.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/RBrack.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/RBrack.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/RParen.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/RParen.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/SimpleEndIsland.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/SimpleEndIsland.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/SimpleStartIsland.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/SimpleStartIsland.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/IgnoreLineComment.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/IgnoreLineComment.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/IgnoreMultiComment.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/IgnoreMultiComment.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/IgnoreString.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/IgnoreString.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LBrace.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LBrace.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LBrack.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LBrack.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LParen.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LParen.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LSQL.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LSQL.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/Layout.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/Layout.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LayoutEndIsland.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LayoutEndIsland.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LayoutReef.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LayoutReef.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LayoutStartIsland.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LayoutStartIsland.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/MainBridgeParser.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/MainBridgeParser.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/RBrace.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/RBrace.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/RBrack.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/RBrack.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/RParen.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/RParen.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/RSQL.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/RSQL.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/SimpleEndIsland.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/SimpleEndIsland.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/SimpleStartIsland.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/SimpleStartIsland.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/IgnoreLineComment.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/IgnoreLineComment.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/IgnoreMultiComment.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/IgnoreMultiComment.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/IgnoreString.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/IgnoreString.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/LBrace.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/LBrace.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/LBrack.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/LBrack.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/LParen.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/LParen.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/LStratego.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/LStratego.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/Layout.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/Layout.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/LayoutEndIsland.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/LayoutEndIsland.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/LayoutReef.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/LayoutReef.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/LayoutStartIsland.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/LayoutStartIsland.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/MainBridgeParser.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/MainBridgeParser.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/RBrace.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/RBrace.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/RBrack.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/RBrack.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/RParen.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/RParen.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/RStratego.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/RStratego.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/SimpleEndIsland.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/SimpleEndIsland.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/SimpleStartIsland.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/SimpleStartIsland.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/IgnoreLineComment.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/IgnoreLineComment.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/IgnoreMultiComment.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/IgnoreMultiComment.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/IgnoreScript.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/IgnoreScript.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/IgnoreString.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/IgnoreString.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LBrace.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LBrace.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LBrack.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LBrack.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LParen.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LParen.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/Layout.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/Layout.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LayoutEndIsland.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LayoutEndIsland.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LayoutReef.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LayoutReef.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LayoutStartIsland.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LayoutStartIsland.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/MainBridgeParser.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/MainBridgeParser.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/RBrace.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/RBrace.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/RBrack.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/RBrack.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/RParen.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/RParen.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/SimpleEndIsland.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/SimpleEndIsland.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/SimpleStartIsland.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/SimpleStartIsland.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/AbstractKeyword.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/AbstractKeyword.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/AssertKeyword.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/AssertKeyword.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/BreakKeyword.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/BreakKeyword.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/CaseKeyword.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/CaseKeyword.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/CatchKeyword.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/CatchKeyword.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ClassKeyword.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ClassKeyword.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ContinueKeyword.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ContinueKeyword.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/DefaultKeyword.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/DefaultKeyword.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/DoKeyword.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/DoKeyword.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ElseKeyword.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ElseKeyword.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/EnumKeyword.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/EnumKeyword.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ExtendsKeyword.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ExtendsKeyword.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/FinalKeyword.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/FinalKeyword.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/FinallyKeyword.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/FinallyKeyword.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ForKeyword.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ForKeyword.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/IfKeyword.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/IfKeyword.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/IgnoreLineComment.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/IgnoreLineComment.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/IgnoreMultiComment.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/IgnoreMultiComment.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/IgnoreString.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/IgnoreString.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ImplementsKeyword.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ImplementsKeyword.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ImportKeyword.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ImportKeyword.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/InterfaceKeyword.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/InterfaceKeyword.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/LBrace.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/LBrace.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/LBrack.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/LBrack.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/LParen.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/LParen.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/Layout.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/Layout.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/LayoutEndIsland.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/LayoutEndIsland.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/LayoutReef.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/LayoutReef.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/LayoutStartIsland.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/LayoutStartIsland.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/MainBridgeParser.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/MainBridgeParser.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/NativeKeyword.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/NativeKeyword.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/PackageKeyword.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/PackageKeyword.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/PrivateKeyword.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/PrivateKeyword.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ProtectedKeyword.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ProtectedKeyword.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/PublicKeyword.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/PublicKeyword.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/RBrace.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/RBrace.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/RBrack.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/RBrack.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/RParen.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/RParen.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ReturnKeyword.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ReturnKeyword.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/SimpleEndIsland.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/SimpleEndIsland.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/SimpleStartIsland.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/SimpleStartIsland.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/StaticKeyword.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/StaticKeyword.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/StrictfpKeyword.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/StrictfpKeyword.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/SwitchKeyword.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/SwitchKeyword.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/SynchronizedKeyword.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/SynchronizedKeyword.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ThrowKeyword.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ThrowKeyword.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ThrowsKeyword.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ThrowsKeyword.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/TransientKeyword.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/TransientKeyword.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/TryKeyword.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/TryKeyword.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/VolatileKeyword.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/VolatileKeyword.java
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/WhileKeyword.class   (contents, props changed)
   sglr-recovery/trunk/bridge-definitions/grammars/java/java15/WhileKeyword.java
Modified:
   sglr-recovery/trunk/bridge-definitions/grammars/generated/bridget.jar
   sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-java-sql.sh
   sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-java.sh
   sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-stratego-java.sh
   sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-webdsl.sh
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java15.jar
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql.jar
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava.jar
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl.jar

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/bridget.jar
==============================================================================
Binary file (source and/or target). No diff available.

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-java-sql.sh
==============================================================================
--- sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-java-sql.sh	Thu Jun  9 08:23:57 2011	(r23032)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-java-sql.sh	Thu Jun  9 09:04:38 2011	(r23033)
@@ -8,7 +8,7 @@
 echo 'done.'
 
 echo -n 'Creating bridge parser jar file ... '
-jar cfe javasql.jar javasql/*.class javasql/*.java
+jar cf javasql.jar javasql/*.class javasql/*.java
 echo 'done.'
 
 

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-java.sh
==============================================================================
--- sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-java.sh	Thu Jun  9 08:23:57 2011	(r23032)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-java.sh	Thu Jun  9 09:04:38 2011	(r23033)
@@ -8,7 +8,7 @@
 echo 'done.'
 
 echo -n 'Creating bridge parser jar file ... '
-jar cfe java15.jar java15/*.class java15/*.java
+jar cf java15.jar java15/*.class java15/*.java
 echo 'done.'
 
 exit

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-stratego-java.sh
==============================================================================
--- sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-stratego-java.sh	Thu Jun  9 08:23:57 2011	(r23032)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-stratego-java.sh	Thu Jun  9 09:04:38 2011	(r23033)
@@ -8,7 +8,7 @@
 echo 'done.'
 
 echo -n 'Creating bridge parser jar file ... '
-jar cfe strategojava.jar strategojava/*.class strategojava/*.java
+jar cf strategojava.jar strategojava/*.class strategojava/*.java
 echo 'done.'
 
 exit

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-webdsl.sh
==============================================================================
--- sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-webdsl.sh	Thu Jun  9 08:23:57 2011	(r23032)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/gen-webdsl.sh	Thu Jun  9 09:04:38 2011	(r23033)
@@ -8,7 +8,7 @@
 echo 'done.'
 
 echo -n 'Creating bridge parser jar file ... '
-jar cfe webdsl.jar webdsl/*.class webdsl/*.java
+jar cf webdsl.jar webdsl/*.class webdsl/*.java
 echo 'done.'
 
 exit

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/java15.jar
==============================================================================
Binary file (source and/or target). No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/IgnoreLineComment.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/IgnoreLineComment.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/IgnoreLineComment.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class IgnoreLineComment extends Ignore {
+
+	public static final String START_VALUE = "//";
+	public static final String END_VALUE = "\n";
+	public IgnoreLineComment(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new IgnoreLineComment(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/IgnoreMultiComment.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/IgnoreMultiComment.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/IgnoreMultiComment.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class IgnoreMultiComment extends Ignore {
+
+	public static final String START_VALUE = "/*";
+	public static final String END_VALUE = "*/";
+	public IgnoreMultiComment(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new IgnoreMultiComment(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/IgnoreString.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/IgnoreString.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/IgnoreString.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class IgnoreString extends Ignore {
+
+	public static final String START_VALUE = "\"";
+	public static final String END_VALUE = "\"";
+	public IgnoreString(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new IgnoreString(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/LBrace.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/LBrace.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/LBrace.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,37 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class LBrace extends LayoutStartIsland {
+
+	public static final String START_VALUE = "{";
+	public static final String MATCH_REG_EXP = "\\{";
+	public static final String VALUE = "{";
+	public LBrace(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new LBrace(previous, getInterval().clone(), value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isEndIsland(island)) {
+			RBrace end = (RBrace)island;
+			LBrace start = this;
+			return super.bridgeMatch(island, tol);
+		}
+		return false;
+	}
+
+	public boolean isEndIsland(LexicalNode node) {
+		return node instanceof RBrace;
+	}
+	public EndIsland createEndIsland(Interval interval) {
+		RBrace node = new RBrace(null, interval, RBrace.VALUE);
+		return node;
+	}
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/LBrack.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/LBrack.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/LBrack.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,37 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class LBrack extends SimpleStartIsland {
+
+	public static final String START_VALUE = "[";
+	public static final String MATCH_REG_EXP = "\\[";
+	public static final String VALUE = "[";
+	public LBrack(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new LBrack(previous, getInterval().clone(), value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isEndIsland(island)) {
+			RBrack end = (RBrack)island;
+			LBrack start = this;
+			return super.bridgeMatch(island, tol);
+		}
+		return false;
+	}
+
+	public boolean isEndIsland(LexicalNode node) {
+		return node instanceof RBrack;
+	}
+	public EndIsland createEndIsland(Interval interval) {
+		RBrack node = new RBrack(null, interval, RBrack.VALUE);
+		return node;
+	}
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/LParen.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/LParen.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/LParen.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,37 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class LParen extends SimpleStartIsland {
+
+	public static final String START_VALUE = "(";
+	public static final String MATCH_REG_EXP = "\\(";
+	public static final String VALUE = "(";
+	public LParen(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new LParen(previous, getInterval().clone(), value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isEndIsland(island)) {
+			RParen end = (RParen)island;
+			LParen start = this;
+			return super.bridgeMatch(island, tol);
+		}
+		return false;
+	}
+
+	public boolean isEndIsland(LexicalNode node) {
+		return node instanceof RParen;
+	}
+	public EndIsland createEndIsland(Interval interval) {
+		RParen node = new RParen(null, interval, RParen.VALUE);
+		return node;
+	}
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/Layout.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/Layout.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/Layout.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class Layout extends LayoutReef {
+
+	public static final String START_VALUE = "\n";
+	public static final String MATCH_REG_EXP = "\n(\t| )*";
+	public Layout(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new Layout(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/LayoutEndIsland.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/LayoutEndIsland.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/LayoutEndIsland.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,98 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public abstract class LayoutEndIsland extends EndIsland {
+
+	public LayoutEndIsland(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isStartIsland(island)) {
+			LayoutStartIsland start = (LayoutStartIsland)island;
+			LayoutEndIsland end = this;
+			return 
+			((start.indent() == null && 0 == end.indent().pos()) || (start.indent() != null && start.indent().pos() == end.indent().pos()));
+		}
+		return false;
+	}
+
+	public boolean possibleConstructionSite(LexicalNode node) {
+		{
+			LayoutReef a = (node instanceof LayoutReef) ? (LayoutReef)node : null;
+			LayoutReef b = (a != null && a.getNext() != null) ? (LayoutReef)a.getNext().getNextOfType(LayoutReef.class) : null;
+			if (a != null && b != null && 
+			  (this.indent() != null && 
+			  (a.startOfEmptyLine() != true && b.startOfEmptyLine() != true && a != this.indent() && a.pos() <= this.indent().pos()))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertBefore(newIsland, b);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		{
+			LayoutStartIsland b = (node instanceof LayoutStartIsland) ? (LayoutStartIsland)node : null;
+			if (b != null && 
+			  (b.indent() != null && this.indent() != null && 
+			  (b.hasBridge() && this.indent().pos() < b.indent().pos()))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertAfter(newIsland, b);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		return false;
+	}
+
+	public boolean isStartIsland(LexicalNode node) {
+		return node instanceof LayoutStartIsland;
+	}
+	// LayoutEndIsland.indent
+	protected LayoutReef indent_value;
+	protected boolean indent_hasValue = false;
+	public LayoutReef indent() {
+		if (!indent_hasValue) {
+			indent_value = indent_compute();
+			indent_hasValue = true;
+		}
+		return indent_value;
+	}
+	protected LayoutReef indent_compute() {
+		LexicalNode pos = getPrevious();
+		int order = 1;
+		int hits = 1;
+		while (pos != null && hits <= order) {
+			Object find = pos.getPreviousOfType(LayoutReef.class);
+			if (find == null) {
+					pos = null;
+			} else if (hits == order) {
+				return (LayoutReef)find;
+			} else {
+				hits++;
+				pos = ((LayoutReef)find).getPrevious();
+			}
+		}
+		return null;
+	}
+
+	// LayoutEndIsland.isStructural
+	protected boolean isStructural_value;
+	protected boolean isStructural_hasValue = false;
+	public boolean isStructural() {
+		if (!isStructural_hasValue) {
+			isStructural_value = isStructural_compute();
+			isStructural_hasValue = true;
+		}
+		return isStructural_value;
+	}
+	protected boolean isStructural_compute() {
+		// Non-generated code start
+		 return true; 
+		// Non-generated code end
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/LayoutReef.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/LayoutReef.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/LayoutReef.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,89 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public abstract class LayoutReef extends Reef {
+
+	public LayoutReef(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	// LayoutReef.rightNeighbour
+	protected LexicalNode rightNeighbour_value;
+	protected boolean rightNeighbour_hasValue = false;
+	public LexicalNode rightNeighbour() {
+		if (!rightNeighbour_hasValue) {
+			rightNeighbour_value = rightNeighbour_compute();
+			rightNeighbour_hasValue = true;
+		}
+		return rightNeighbour_value;
+	}
+	protected LexicalNode rightNeighbour_compute() {
+		LexicalNode pos = getNext();
+		int order = 1;
+		int hits = 1;
+		while (pos != null && hits <= order) {
+			Object find = pos.getNextOfType(LexicalNode.class);
+			if (find == null) {
+					pos = null;
+			} else if (hits == order) {
+				return (LexicalNode)find;
+			} else {
+				hits++;
+				pos = ((LexicalNode)find).getNext();
+			}
+		}
+		return null;
+	}
+
+	// LayoutReef.startOfEmptyLine
+	protected boolean startOfEmptyLine_value;
+	protected boolean startOfEmptyLine_hasValue = false;
+	public boolean startOfEmptyLine() {
+		if (!startOfEmptyLine_hasValue) {
+			startOfEmptyLine_value = startOfEmptyLine_compute();
+			startOfEmptyLine_hasValue = true;
+		}
+		return startOfEmptyLine_value;
+	}
+	protected boolean startOfEmptyLine_compute() {
+		// Non-generated code start
+		
+    return rightNeighbour() != null && rightNeighbour() instanceof LayoutReef;
+
+		// Non-generated code end
+	}
+
+	// LayoutReef.pos
+	protected int pos_value;
+	protected boolean pos_hasValue = false;
+	public int pos() {
+		if (!pos_hasValue) {
+			pos_value = pos_compute();
+			pos_hasValue = true;
+		}
+		return pos_value;
+	}
+	protected int pos_compute() {
+		// Non-generated code start
+		
+	int pos = 0;
+	char[] chars = value.toCharArray();
+	for (int i = chars.length-1; i >= 0; i--) {
+		switch(chars[i]) {
+			case ' '  : pos++; break;
+			case '\t' : pos += 4; break; // TAB_SIZE=4
+		}
+		if (chars[i] == '\n') {
+			break;
+		}
+	}
+	return pos;
+
+		// Non-generated code end
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/LayoutStartIsland.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/LayoutStartIsland.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/LayoutStartIsland.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,97 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public abstract class LayoutStartIsland extends StartIsland {
+
+	public LayoutStartIsland(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isEndIsland(island)) {
+			LayoutEndIsland end = (LayoutEndIsland)island;
+			LayoutStartIsland start = this;
+			return 
+			((start.indent() == null && 0 == end.indent().pos()) || (start.indent() != null && start.indent().pos() == end.indent().pos()));
+		}
+		return false;
+	}
+
+	public boolean possibleConstructionSite(LexicalNode node) {
+		{
+			LayoutReef a = (node instanceof LayoutReef) ? (LayoutReef)node : null;
+			if (a != null && 
+			  (this.indent() != null && 
+			  (a.startOfEmptyLine() != true && a.pos() <= this.indent().pos()))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertBefore(newIsland, a);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		{
+			LayoutEndIsland b = (node instanceof LayoutEndIsland) ? (LayoutEndIsland)node : null;
+			if (b != null && 
+			  (b.indent() != null && this.indent() != null && 
+			  (b.hasBridge() && b.indent().pos() < this.indent().pos()))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertBefore(newIsland, b);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		return false;
+	}
+
+	public boolean isEndIsland(LexicalNode node) {
+		return node instanceof LayoutEndIsland;
+	}
+	// LayoutStartIsland.indent
+	protected LayoutReef indent_value;
+	protected boolean indent_hasValue = false;
+	public LayoutReef indent() {
+		if (!indent_hasValue) {
+			indent_value = indent_compute();
+			indent_hasValue = true;
+		}
+		return indent_value;
+	}
+	protected LayoutReef indent_compute() {
+		LexicalNode pos = getPrevious();
+		int order = 1;
+		int hits = 1;
+		while (pos != null && hits <= order) {
+			Object find = pos.getPreviousOfType(LayoutReef.class);
+			if (find == null) {
+					pos = null;
+			} else if (hits == order) {
+				return (LayoutReef)find;
+			} else {
+				hits++;
+				pos = ((LayoutReef)find).getPrevious();
+			}
+		}
+		return null;
+	}
+
+	// LayoutStartIsland.isStructural
+	protected boolean isStructural_value;
+	protected boolean isStructural_hasValue = false;
+	public boolean isStructural() {
+		if (!isStructural_hasValue) {
+			isStructural_value = isStructural_compute();
+			isStructural_hasValue = true;
+		}
+		return isStructural_value;
+	}
+	protected boolean isStructural_compute() {
+		// Non-generated code start
+		 return true; 
+		// Non-generated code end
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/MainBridgeParser.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/MainBridgeParser.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/MainBridgeParser.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,129 @@
+package java15;
+
+import java.io.*;
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class MainBridgeParser extends AbstractBridgeParser {
+
+	protected LexicalNode matchNode(char[] content, int curPos, int lastMatchPos, LexicalNode previous) {
+		// RBrace
+		if (matchForward(content, curPos, RBrace.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				RBrace.START_VALUE.length(), RBrace.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new RBrace(previous, interval, value);
+		}
+		// RBrack
+		if (matchForward(content, curPos, RBrack.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				RBrack.START_VALUE.length(), RBrack.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new RBrack(previous, interval, value);
+		}
+		// LParen
+		if (matchForward(content, curPos, LParen.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				LParen.START_VALUE.length(), LParen.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new LParen(previous, interval, value);
+		}
+		// Layout
+		if (matchForward(content, curPos, Layout.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				Layout.START_VALUE.length(), Layout.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new Layout(previous, interval, value);
+		}
+		// RParen
+		if (matchForward(content, curPos, RParen.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				RParen.START_VALUE.length(), RParen.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new RParen(previous, interval, value);
+		}
+		// LBrack
+		if (matchForward(content, curPos, LBrack.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				LBrack.START_VALUE.length(), LBrack.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new LBrack(previous, interval, value);
+		}
+		// LBrace
+		if (matchForward(content, curPos, LBrace.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				LBrace.START_VALUE.length(), LBrace.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new LBrace(previous, interval, value);
+		}
+		return null;
+	}
+
+	protected LexicalNode matchIgnore(char[] content, int curPos, int lastMatchPos, LexicalNode previous) {
+		// LineComment
+		if (matchForward(content, curPos, IgnoreLineComment.START_VALUE)) {
+			int endPos = ignoreUntil(content, curPos + IgnoreLineComment.START_VALUE.length(), IgnoreLineComment.END_VALUE);
+			if (IgnoreLineComment.END_VALUE.equals("\n")) {
+				endPos--;
+			}
+			Interval interval = new Interval(curPos, endPos);
+			return new IgnoreLineComment(previous, interval, new String(content, curPos, 
+				(endPos < content.length - 1) ? interval.getLength() + 1 : interval.getLength()));
+		}
+		// String
+		if (matchForward(content, curPos, IgnoreString.START_VALUE)) {
+			int endPos = ignoreUntil(content, curPos + IgnoreString.START_VALUE.length(), IgnoreString.END_VALUE);
+			if (IgnoreString.END_VALUE.equals("\n")) {
+				endPos--;
+			}
+			Interval interval = new Interval(curPos, endPos);
+			return new IgnoreString(previous, interval, new String(content, curPos, 
+				(endPos < content.length - 1) ? interval.getLength() + 1 : interval.getLength()));
+		}
+		// MultiComment
+		if (matchForward(content, curPos, IgnoreMultiComment.START_VALUE)) {
+			int endPos = ignoreUntil(content, curPos + IgnoreMultiComment.START_VALUE.length(), IgnoreMultiComment.END_VALUE);
+			if (IgnoreMultiComment.END_VALUE.equals("\n")) {
+				endPos--;
+			}
+			Interval interval = new Interval(curPos, endPos);
+			return new IgnoreMultiComment(previous, interval, new String(content, curPos, 
+				(endPos < content.length - 1) ? interval.getLength() + 1 : interval.getLength()));
+		}
+		return null;
+	}
+
+	public static void main(String[] args) {
+		if (args.length != 1) {
+			System.err.println("usage: MainBridgeParser input-file");
+			System.exit(1);
+		}
+		
+		String filePath = args[0];
+		File file = new File(filePath);
+		if (!file.exists()) {
+			System.err.println("error: file does not exist [" + filePath + "]");
+			System.exit(2);
+		}
+		
+		StringBuffer buf = new StringBuffer();
+		try {
+			BufferedReader reader = new BufferedReader(new FileReader(file));
+			String line = null;
+			while ((line = reader.readLine()) != null) {
+				buf.append(line);
+			}
+			reader.close();
+		} catch (IOException e) {
+			System.err.println("error: problem reading from file [" + filePath + "]");
+			System.exit(3);
+		}
+		
+		IBridgeParser bp = new MainBridgeParser();
+		String result = bp.recover(buf.toString());
+		System.out.println("\nResult:\n[" + result + "]\n");
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/RBrace.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/RBrace.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/RBrace.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,37 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class RBrace extends LayoutEndIsland {
+
+	public static final String START_VALUE = "}";
+	public static final String MATCH_REG_EXP = "\\}";
+	public static final String VALUE = "}";
+	public RBrace(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new RBrace(previous, getInterval().clone(), value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isStartIsland(island)) {
+			LBrace start = (LBrace)island;
+			RBrace end = this;
+			return super.bridgeMatch(island, tol);
+		}
+		return false;
+	}
+
+	public boolean isStartIsland(LexicalNode node) {
+		return node instanceof LBrace;
+	}
+	public StartIsland createStartIsland(Interval interval) {
+		LBrace node = new LBrace(null, interval, LBrace.VALUE);
+		return node;
+	}
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/RBrack.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/RBrack.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/RBrack.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,37 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class RBrack extends SimpleEndIsland {
+
+	public static final String START_VALUE = "]";
+	public static final String MATCH_REG_EXP = "\\]";
+	public static final String VALUE = "]";
+	public RBrack(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new RBrack(previous, getInterval().clone(), value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isStartIsland(island)) {
+			LBrack start = (LBrack)island;
+			RBrack end = this;
+			return super.bridgeMatch(island, tol);
+		}
+		return false;
+	}
+
+	public boolean isStartIsland(LexicalNode node) {
+		return node instanceof LBrack;
+	}
+	public StartIsland createStartIsland(Interval interval) {
+		LBrack node = new LBrack(null, interval, LBrack.VALUE);
+		return node;
+	}
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/RParen.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/RParen.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/RParen.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,37 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class RParen extends SimpleEndIsland {
+
+	public static final String START_VALUE = ")";
+	public static final String MATCH_REG_EXP = "\\)";
+	public static final String VALUE = ")";
+	public RParen(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new RParen(previous, getInterval().clone(), value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isStartIsland(island)) {
+			LParen start = (LParen)island;
+			RParen end = this;
+			return super.bridgeMatch(island, tol);
+		}
+		return false;
+	}
+
+	public boolean isStartIsland(LexicalNode node) {
+		return node instanceof LParen;
+	}
+	public StartIsland createStartIsland(Interval interval) {
+		LParen node = new LParen(null, interval, LParen.VALUE);
+		return node;
+	}
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/SimpleEndIsland.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/SimpleEndIsland.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/SimpleEndIsland.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,72 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public abstract class SimpleEndIsland extends LayoutEndIsland {
+
+	public SimpleEndIsland(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isStartIsland(island)) {
+			SimpleStartIsland start = (SimpleStartIsland)island;
+			SimpleEndIsland end = this;
+			return 
+			(true);
+		}
+		return false;
+	}
+
+	public boolean possibleConstructionSite(LexicalNode node) {
+		{
+			Reef a = (node instanceof Reef) ? (Reef)node : null;
+			if (a != null && 
+			  (
+			  (true))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertAfter(newIsland, a);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		{
+			LayoutEndIsland a = (node instanceof LayoutEndIsland) ? (LayoutEndIsland)node : null;
+			if (a != null && 
+			  (
+			  (a.isStructural()))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertAfter(newIsland, a);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		if (super.possibleConstructionSite(node)) {
+			return true;
+		}
+		return false;
+	}
+
+	public boolean isStartIsland(LexicalNode node) {
+		return node instanceof SimpleStartIsland;
+	}
+	// SimpleEndIsland.isStructural
+	protected boolean isStructural_value;
+	protected boolean isStructural_hasValue = false;
+	public boolean isStructural() {
+		if (!isStructural_hasValue) {
+			isStructural_value = isStructural_compute();
+			isStructural_hasValue = true;
+		}
+		return isStructural_value;
+	}
+	protected boolean isStructural_compute() {
+		// Non-generated code start
+		 return false; 
+		// Non-generated code end
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/SimpleStartIsland.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/SimpleStartIsland.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/SimpleStartIsland.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,72 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public abstract class SimpleStartIsland extends LayoutStartIsland {
+
+	public SimpleStartIsland(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isEndIsland(island)) {
+			SimpleEndIsland end = (SimpleEndIsland)island;
+			SimpleStartIsland start = this;
+			return 
+			(true);
+		}
+		return false;
+	}
+
+	public boolean possibleConstructionSite(LexicalNode node) {
+		{
+			Reef a = (node instanceof Reef) ? (Reef)node : null;
+			if (a != null && 
+			  (
+			  (true))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertBefore(newIsland, a);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		{
+			LayoutStartIsland a = (node instanceof LayoutStartIsland) ? (LayoutStartIsland)node : null;
+			if (a != null && 
+			  (
+			  (a.isStructural()))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertBefore(newIsland, a);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		if (super.possibleConstructionSite(node)) {
+			return true;
+		}
+		return false;
+	}
+
+	public boolean isEndIsland(LexicalNode node) {
+		return node instanceof SimpleEndIsland;
+	}
+	// SimpleStartIsland.isStructural
+	protected boolean isStructural_value;
+	protected boolean isStructural_hasValue = false;
+	public boolean isStructural() {
+		if (!isStructural_hasValue) {
+			isStructural_value = isStructural_compute();
+			isStructural_hasValue = true;
+		}
+		return isStructural_value;
+	}
+	protected boolean isStructural_compute() {
+		// Non-generated code start
+		 return false; 
+		// Non-generated code end
+	}
+
+}

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql.jar
==============================================================================
Binary file (source and/or target). No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/IgnoreLineComment.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/IgnoreLineComment.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/IgnoreLineComment.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package javasql;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class IgnoreLineComment extends Ignore {
+
+	public static final String START_VALUE = "//";
+	public static final String END_VALUE = "\n";
+	public IgnoreLineComment(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new IgnoreLineComment(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/IgnoreMultiComment.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/IgnoreMultiComment.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/IgnoreMultiComment.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package javasql;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class IgnoreMultiComment extends Ignore {
+
+	public static final String START_VALUE = "/*";
+	public static final String END_VALUE = "*/";
+	public IgnoreMultiComment(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new IgnoreMultiComment(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/IgnoreString.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/IgnoreString.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/IgnoreString.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package javasql;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class IgnoreString extends Ignore {
+
+	public static final String START_VALUE = "\"";
+	public static final String END_VALUE = "\"";
+	public IgnoreString(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new IgnoreString(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LBrace.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LBrace.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LBrace.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,37 @@
+package javasql;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class LBrace extends LayoutStartIsland {
+
+	public static final String START_VALUE = "{";
+	public static final String MATCH_REG_EXP = "\\{";
+	public static final String VALUE = "{";
+	public LBrace(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new LBrace(previous, getInterval().clone(), value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isEndIsland(island)) {
+			RBrace end = (RBrace)island;
+			LBrace start = this;
+			return super.bridgeMatch(island, tol);
+		}
+		return false;
+	}
+
+	public boolean isEndIsland(LexicalNode node) {
+		return node instanceof RBrace;
+	}
+	public EndIsland createEndIsland(Interval interval) {
+		RBrace node = new RBrace(null, interval, RBrace.VALUE);
+		return node;
+	}
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LBrack.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LBrack.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LBrack.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,37 @@
+package javasql;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class LBrack extends SimpleStartIsland {
+
+	public static final String START_VALUE = "[";
+	public static final String MATCH_REG_EXP = "\\[";
+	public static final String VALUE = "[";
+	public LBrack(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new LBrack(previous, getInterval().clone(), value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isEndIsland(island)) {
+			RBrack end = (RBrack)island;
+			LBrack start = this;
+			return super.bridgeMatch(island, tol);
+		}
+		return false;
+	}
+
+	public boolean isEndIsland(LexicalNode node) {
+		return node instanceof RBrack;
+	}
+	public EndIsland createEndIsland(Interval interval) {
+		RBrack node = new RBrack(null, interval, RBrack.VALUE);
+		return node;
+	}
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LParen.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LParen.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LParen.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,37 @@
+package javasql;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class LParen extends SimpleStartIsland {
+
+	public static final String START_VALUE = "(";
+	public static final String MATCH_REG_EXP = "\\(";
+	public static final String VALUE = "(";
+	public LParen(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new LParen(previous, getInterval().clone(), value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isEndIsland(island)) {
+			RParen end = (RParen)island;
+			LParen start = this;
+			return super.bridgeMatch(island, tol);
+		}
+		return false;
+	}
+
+	public boolean isEndIsland(LexicalNode node) {
+		return node instanceof RParen;
+	}
+	public EndIsland createEndIsland(Interval interval) {
+		RParen node = new RParen(null, interval, RParen.VALUE);
+		return node;
+	}
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LSQL.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LSQL.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LSQL.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,37 @@
+package javasql;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class LSQL extends SimpleStartIsland {
+
+	public static final String START_VALUE = "<|";
+	public static final String MATCH_REG_EXP = "<\\|";
+	public static final String VALUE = "<|";
+	public LSQL(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new LSQL(previous, getInterval().clone(), value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isEndIsland(island)) {
+			RSQL end = (RSQL)island;
+			LSQL start = this;
+			return super.bridgeMatch(island, tol);
+		}
+		return false;
+	}
+
+	public boolean isEndIsland(LexicalNode node) {
+		return node instanceof RSQL;
+	}
+	public EndIsland createEndIsland(Interval interval) {
+		RSQL node = new RSQL(null, interval, RSQL.VALUE);
+		return node;
+	}
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/Layout.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/Layout.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/Layout.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package javasql;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class Layout extends LayoutReef {
+
+	public static final String START_VALUE = "\n";
+	public static final String MATCH_REG_EXP = "\n(\t| )*";
+	public Layout(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new Layout(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LayoutEndIsland.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LayoutEndIsland.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LayoutEndIsland.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,98 @@
+package javasql;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public abstract class LayoutEndIsland extends EndIsland {
+
+	public LayoutEndIsland(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isStartIsland(island)) {
+			LayoutStartIsland start = (LayoutStartIsland)island;
+			LayoutEndIsland end = this;
+			return 
+			((start.indent() == null && 0 == end.indent().pos()) || (start.indent() != null && start.indent().pos() == end.indent().pos()));
+		}
+		return false;
+	}
+
+	public boolean possibleConstructionSite(LexicalNode node) {
+		{
+			LayoutReef a = (node instanceof LayoutReef) ? (LayoutReef)node : null;
+			LayoutReef b = (a != null && a.getNext() != null) ? (LayoutReef)a.getNext().getNextOfType(LayoutReef.class) : null;
+			if (a != null && b != null && 
+			  (this.indent() != null && 
+			  (a.startOfEmptyLine() != true && b.startOfEmptyLine() != true && a != this.indent() && a.pos() <= this.indent().pos()))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertBefore(newIsland, b);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		{
+			LayoutStartIsland b = (node instanceof LayoutStartIsland) ? (LayoutStartIsland)node : null;
+			if (b != null && 
+			  (b.indent() != null && this.indent() != null && 
+			  (b.hasBridge() && this.indent().pos() < b.indent().pos()))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertAfter(newIsland, b);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		return false;
+	}
+
+	public boolean isStartIsland(LexicalNode node) {
+		return node instanceof LayoutStartIsland;
+	}
+	// LayoutEndIsland.isStructural
+	protected boolean isStructural_value;
+	protected boolean isStructural_hasValue = false;
+	public boolean isStructural() {
+		if (!isStructural_hasValue) {
+			isStructural_value = isStructural_compute();
+			isStructural_hasValue = true;
+		}
+		return isStructural_value;
+	}
+	protected boolean isStructural_compute() {
+		// Non-generated code start
+		 return true; 
+		// Non-generated code end
+	}
+
+	// LayoutEndIsland.indent
+	protected LayoutReef indent_value;
+	protected boolean indent_hasValue = false;
+	public LayoutReef indent() {
+		if (!indent_hasValue) {
+			indent_value = indent_compute();
+			indent_hasValue = true;
+		}
+		return indent_value;
+	}
+	protected LayoutReef indent_compute() {
+		LexicalNode pos = getPrevious();
+		int order = 1;
+		int hits = 1;
+		while (pos != null && hits <= order) {
+			Object find = pos.getPreviousOfType(LayoutReef.class);
+			if (find == null) {
+					pos = null;
+			} else if (hits == order) {
+				return (LayoutReef)find;
+			} else {
+				hits++;
+				pos = ((LayoutReef)find).getPrevious();
+			}
+		}
+		return null;
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LayoutReef.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LayoutReef.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LayoutReef.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,89 @@
+package javasql;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public abstract class LayoutReef extends Reef {
+
+	public LayoutReef(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	// LayoutReef.pos
+	protected int pos_value;
+	protected boolean pos_hasValue = false;
+	public int pos() {
+		if (!pos_hasValue) {
+			pos_value = pos_compute();
+			pos_hasValue = true;
+		}
+		return pos_value;
+	}
+	protected int pos_compute() {
+		// Non-generated code start
+		
+	int pos = 0;
+	char[] chars = value.toCharArray();
+	for (int i = chars.length-1; i >= 0; i--) {
+		switch(chars[i]) {
+			case ' '  : pos++; break;
+			case '\t' : pos += 4; break; // TAB_SIZE=4
+		}
+		if (chars[i] == '\n') {
+			break;
+		}
+	}
+	return pos;
+
+		// Non-generated code end
+	}
+
+	// LayoutReef.startOfEmptyLine
+	protected boolean startOfEmptyLine_value;
+	protected boolean startOfEmptyLine_hasValue = false;
+	public boolean startOfEmptyLine() {
+		if (!startOfEmptyLine_hasValue) {
+			startOfEmptyLine_value = startOfEmptyLine_compute();
+			startOfEmptyLine_hasValue = true;
+		}
+		return startOfEmptyLine_value;
+	}
+	protected boolean startOfEmptyLine_compute() {
+		// Non-generated code start
+		
+    return rightNeighbour() != null && rightNeighbour() instanceof LayoutReef;
+
+		// Non-generated code end
+	}
+
+	// LayoutReef.rightNeighbour
+	protected LexicalNode rightNeighbour_value;
+	protected boolean rightNeighbour_hasValue = false;
+	public LexicalNode rightNeighbour() {
+		if (!rightNeighbour_hasValue) {
+			rightNeighbour_value = rightNeighbour_compute();
+			rightNeighbour_hasValue = true;
+		}
+		return rightNeighbour_value;
+	}
+	protected LexicalNode rightNeighbour_compute() {
+		LexicalNode pos = getNext();
+		int order = 1;
+		int hits = 1;
+		while (pos != null && hits <= order) {
+			Object find = pos.getNextOfType(LexicalNode.class);
+			if (find == null) {
+					pos = null;
+			} else if (hits == order) {
+				return (LexicalNode)find;
+			} else {
+				hits++;
+				pos = ((LexicalNode)find).getNext();
+			}
+		}
+		return null;
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LayoutStartIsland.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LayoutStartIsland.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LayoutStartIsland.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,97 @@
+package javasql;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public abstract class LayoutStartIsland extends StartIsland {
+
+	public LayoutStartIsland(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isEndIsland(island)) {
+			LayoutEndIsland end = (LayoutEndIsland)island;
+			LayoutStartIsland start = this;
+			return 
+			((start.indent() == null && 0 == end.indent().pos()) || (start.indent() != null && start.indent().pos() == end.indent().pos()));
+		}
+		return false;
+	}
+
+	public boolean possibleConstructionSite(LexicalNode node) {
+		{
+			LayoutReef a = (node instanceof LayoutReef) ? (LayoutReef)node : null;
+			if (a != null && 
+			  (this.indent() != null && 
+			  (a.startOfEmptyLine() != true && a.pos() <= this.indent().pos()))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertBefore(newIsland, a);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		{
+			LayoutEndIsland b = (node instanceof LayoutEndIsland) ? (LayoutEndIsland)node : null;
+			if (b != null && 
+			  (b.indent() != null && this.indent() != null && 
+			  (b.hasBridge() && b.indent().pos() < this.indent().pos()))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertBefore(newIsland, b);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		return false;
+	}
+
+	public boolean isEndIsland(LexicalNode node) {
+		return node instanceof LayoutEndIsland;
+	}
+	// LayoutStartIsland.isStructural
+	protected boolean isStructural_value;
+	protected boolean isStructural_hasValue = false;
+	public boolean isStructural() {
+		if (!isStructural_hasValue) {
+			isStructural_value = isStructural_compute();
+			isStructural_hasValue = true;
+		}
+		return isStructural_value;
+	}
+	protected boolean isStructural_compute() {
+		// Non-generated code start
+		 return true; 
+		// Non-generated code end
+	}
+
+	// LayoutStartIsland.indent
+	protected LayoutReef indent_value;
+	protected boolean indent_hasValue = false;
+	public LayoutReef indent() {
+		if (!indent_hasValue) {
+			indent_value = indent_compute();
+			indent_hasValue = true;
+		}
+		return indent_value;
+	}
+	protected LayoutReef indent_compute() {
+		LexicalNode pos = getPrevious();
+		int order = 1;
+		int hits = 1;
+		while (pos != null && hits <= order) {
+			Object find = pos.getPreviousOfType(LayoutReef.class);
+			if (find == null) {
+					pos = null;
+			} else if (hits == order) {
+				return (LayoutReef)find;
+			} else {
+				hits++;
+				pos = ((LayoutReef)find).getPrevious();
+			}
+		}
+		return null;
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/MainBridgeParser.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/MainBridgeParser.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/MainBridgeParser.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,143 @@
+package javasql;
+
+import java.io.*;
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class MainBridgeParser extends AbstractBridgeParser {
+
+	protected LexicalNode matchNode(char[] content, int curPos, int lastMatchPos, LexicalNode previous) {
+		// RSQL
+		if (matchForward(content, curPos, RSQL.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				RSQL.START_VALUE.length(), RSQL.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new RSQL(previous, interval, value);
+		}
+		// LSQL
+		if (matchForward(content, curPos, LSQL.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				LSQL.START_VALUE.length(), LSQL.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new LSQL(previous, interval, value);
+		}
+		// Layout
+		if (matchForward(content, curPos, Layout.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				Layout.START_VALUE.length(), Layout.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new Layout(previous, interval, value);
+		}
+		// LParen
+		if (matchForward(content, curPos, LParen.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				LParen.START_VALUE.length(), LParen.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new LParen(previous, interval, value);
+		}
+		// LBrace
+		if (matchForward(content, curPos, LBrace.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				LBrace.START_VALUE.length(), LBrace.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new LBrace(previous, interval, value);
+		}
+		// RParen
+		if (matchForward(content, curPos, RParen.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				RParen.START_VALUE.length(), RParen.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new RParen(previous, interval, value);
+		}
+		// LBrack
+		if (matchForward(content, curPos, LBrack.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				LBrack.START_VALUE.length(), LBrack.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new LBrack(previous, interval, value);
+		}
+		// RBrace
+		if (matchForward(content, curPos, RBrace.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				RBrace.START_VALUE.length(), RBrace.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new RBrace(previous, interval, value);
+		}
+		// RBrack
+		if (matchForward(content, curPos, RBrack.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				RBrack.START_VALUE.length(), RBrack.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new RBrack(previous, interval, value);
+		}
+		return null;
+	}
+
+	protected LexicalNode matchIgnore(char[] content, int curPos, int lastMatchPos, LexicalNode previous) {
+		// MultiComment
+		if (matchForward(content, curPos, IgnoreMultiComment.START_VALUE)) {
+			int endPos = ignoreUntil(content, curPos + IgnoreMultiComment.START_VALUE.length(), IgnoreMultiComment.END_VALUE);
+			if (IgnoreMultiComment.END_VALUE.equals("\n")) {
+				endPos--;
+			}
+			Interval interval = new Interval(curPos, endPos);
+			return new IgnoreMultiComment(previous, interval, new String(content, curPos, 
+				(endPos < content.length - 1) ? interval.getLength() + 1 : interval.getLength()));
+		}
+		// LineComment
+		if (matchForward(content, curPos, IgnoreLineComment.START_VALUE)) {
+			int endPos = ignoreUntil(content, curPos + IgnoreLineComment.START_VALUE.length(), IgnoreLineComment.END_VALUE);
+			if (IgnoreLineComment.END_VALUE.equals("\n")) {
+				endPos--;
+			}
+			Interval interval = new Interval(curPos, endPos);
+			return new IgnoreLineComment(previous, interval, new String(content, curPos, 
+				(endPos < content.length - 1) ? interval.getLength() + 1 : interval.getLength()));
+		}
+		// String
+		if (matchForward(content, curPos, IgnoreString.START_VALUE)) {
+			int endPos = ignoreUntil(content, curPos + IgnoreString.START_VALUE.length(), IgnoreString.END_VALUE);
+			if (IgnoreString.END_VALUE.equals("\n")) {
+				endPos--;
+			}
+			Interval interval = new Interval(curPos, endPos);
+			return new IgnoreString(previous, interval, new String(content, curPos, 
+				(endPos < content.length - 1) ? interval.getLength() + 1 : interval.getLength()));
+		}
+		return null;
+	}
+
+	public static void main(String[] args) {
+		if (args.length != 1) {
+			System.err.println("usage: MainBridgeParser input-file");
+			System.exit(1);
+		}
+		
+		String filePath = args[0];
+		File file = new File(filePath);
+		if (!file.exists()) {
+			System.err.println("error: file does not exist [" + filePath + "]");
+			System.exit(2);
+		}
+		
+		StringBuffer buf = new StringBuffer();
+		try {
+			BufferedReader reader = new BufferedReader(new FileReader(file));
+			String line = null;
+			while ((line = reader.readLine()) != null) {
+				buf.append(line);
+			}
+			reader.close();
+		} catch (IOException e) {
+			System.err.println("error: problem reading from file [" + filePath + "]");
+			System.exit(3);
+		}
+		
+		IBridgeParser bp = new MainBridgeParser();
+		String result = bp.recover(buf.toString());
+		System.out.println("\nResult:\n[" + result + "]\n");
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/RBrace.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/RBrace.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/RBrace.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,37 @@
+package javasql;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class RBrace extends LayoutEndIsland {
+
+	public static final String START_VALUE = "}";
+	public static final String MATCH_REG_EXP = "\\}";
+	public static final String VALUE = "}";
+	public RBrace(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new RBrace(previous, getInterval().clone(), value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isStartIsland(island)) {
+			LBrace start = (LBrace)island;
+			RBrace end = this;
+			return super.bridgeMatch(island, tol);
+		}
+		return false;
+	}
+
+	public boolean isStartIsland(LexicalNode node) {
+		return node instanceof LBrace;
+	}
+	public StartIsland createStartIsland(Interval interval) {
+		LBrace node = new LBrace(null, interval, LBrace.VALUE);
+		return node;
+	}
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/RBrack.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/RBrack.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/RBrack.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,37 @@
+package javasql;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class RBrack extends SimpleEndIsland {
+
+	public static final String START_VALUE = "]";
+	public static final String MATCH_REG_EXP = "\\]";
+	public static final String VALUE = "]";
+	public RBrack(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new RBrack(previous, getInterval().clone(), value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isStartIsland(island)) {
+			LBrack start = (LBrack)island;
+			RBrack end = this;
+			return super.bridgeMatch(island, tol);
+		}
+		return false;
+	}
+
+	public boolean isStartIsland(LexicalNode node) {
+		return node instanceof LBrack;
+	}
+	public StartIsland createStartIsland(Interval interval) {
+		LBrack node = new LBrack(null, interval, LBrack.VALUE);
+		return node;
+	}
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/RParen.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/RParen.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/RParen.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,37 @@
+package javasql;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class RParen extends SimpleEndIsland {
+
+	public static final String START_VALUE = ")";
+	public static final String MATCH_REG_EXP = "\\)";
+	public static final String VALUE = ")";
+	public RParen(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new RParen(previous, getInterval().clone(), value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isStartIsland(island)) {
+			LParen start = (LParen)island;
+			RParen end = this;
+			return super.bridgeMatch(island, tol);
+		}
+		return false;
+	}
+
+	public boolean isStartIsland(LexicalNode node) {
+		return node instanceof LParen;
+	}
+	public StartIsland createStartIsland(Interval interval) {
+		LParen node = new LParen(null, interval, LParen.VALUE);
+		return node;
+	}
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/RSQL.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/RSQL.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/RSQL.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,37 @@
+package javasql;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class RSQL extends SimpleEndIsland {
+
+	public static final String START_VALUE = "|>";
+	public static final String MATCH_REG_EXP = "\\|>";
+	public static final String VALUE = "|>";
+	public RSQL(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new RSQL(previous, getInterval().clone(), value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isStartIsland(island)) {
+			LSQL start = (LSQL)island;
+			RSQL end = this;
+			return super.bridgeMatch(island, tol);
+		}
+		return false;
+	}
+
+	public boolean isStartIsland(LexicalNode node) {
+		return node instanceof LSQL;
+	}
+	public StartIsland createStartIsland(Interval interval) {
+		LSQL node = new LSQL(null, interval, LSQL.VALUE);
+		return node;
+	}
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/SimpleEndIsland.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/SimpleEndIsland.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/SimpleEndIsland.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,72 @@
+package javasql;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public abstract class SimpleEndIsland extends LayoutEndIsland {
+
+	public SimpleEndIsland(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isStartIsland(island)) {
+			SimpleStartIsland start = (SimpleStartIsland)island;
+			SimpleEndIsland end = this;
+			return 
+			(true);
+		}
+		return false;
+	}
+
+	public boolean possibleConstructionSite(LexicalNode node) {
+		{
+			Reef a = (node instanceof Reef) ? (Reef)node : null;
+			if (a != null && 
+			  (
+			  (true))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertAfter(newIsland, a);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		{
+			LayoutEndIsland a = (node instanceof LayoutEndIsland) ? (LayoutEndIsland)node : null;
+			if (a != null && 
+			  (
+			  (a.isStructural()))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertAfter(newIsland, a);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		if (super.possibleConstructionSite(node)) {
+			return true;
+		}
+		return false;
+	}
+
+	public boolean isStartIsland(LexicalNode node) {
+		return node instanceof SimpleStartIsland;
+	}
+	// SimpleEndIsland.isStructural
+	protected boolean isStructural_value;
+	protected boolean isStructural_hasValue = false;
+	public boolean isStructural() {
+		if (!isStructural_hasValue) {
+			isStructural_value = isStructural_compute();
+			isStructural_hasValue = true;
+		}
+		return isStructural_value;
+	}
+	protected boolean isStructural_compute() {
+		// Non-generated code start
+		 return false; 
+		// Non-generated code end
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/SimpleStartIsland.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/SimpleStartIsland.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/SimpleStartIsland.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,72 @@
+package javasql;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public abstract class SimpleStartIsland extends LayoutStartIsland {
+
+	public SimpleStartIsland(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isEndIsland(island)) {
+			SimpleEndIsland end = (SimpleEndIsland)island;
+			SimpleStartIsland start = this;
+			return 
+			(true);
+		}
+		return false;
+	}
+
+	public boolean possibleConstructionSite(LexicalNode node) {
+		{
+			Reef a = (node instanceof Reef) ? (Reef)node : null;
+			if (a != null && 
+			  (
+			  (true))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertBefore(newIsland, a);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		{
+			LayoutStartIsland a = (node instanceof LayoutStartIsland) ? (LayoutStartIsland)node : null;
+			if (a != null && 
+			  (
+			  (a.isStructural()))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertBefore(newIsland, a);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		if (super.possibleConstructionSite(node)) {
+			return true;
+		}
+		return false;
+	}
+
+	public boolean isEndIsland(LexicalNode node) {
+		return node instanceof SimpleEndIsland;
+	}
+	// SimpleStartIsland.isStructural
+	protected boolean isStructural_value;
+	protected boolean isStructural_hasValue = false;
+	public boolean isStructural() {
+		if (!isStructural_hasValue) {
+			isStructural_value = isStructural_compute();
+			isStructural_hasValue = true;
+		}
+		return isStructural_value;
+	}
+	protected boolean isStructural_compute() {
+		// Non-generated code start
+		 return false; 
+		// Non-generated code end
+	}
+
+}

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava.jar
==============================================================================
Binary file (source and/or target). No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/IgnoreLineComment.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/IgnoreLineComment.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/IgnoreLineComment.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package strategojava;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class IgnoreLineComment extends Ignore {
+
+	public static final String START_VALUE = "//";
+	public static final String END_VALUE = "\n";
+	public IgnoreLineComment(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new IgnoreLineComment(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/IgnoreMultiComment.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/IgnoreMultiComment.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/IgnoreMultiComment.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package strategojava;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class IgnoreMultiComment extends Ignore {
+
+	public static final String START_VALUE = "/*";
+	public static final String END_VALUE = "*/";
+	public IgnoreMultiComment(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new IgnoreMultiComment(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/IgnoreString.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/IgnoreString.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/IgnoreString.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package strategojava;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class IgnoreString extends Ignore {
+
+	public static final String START_VALUE = "\"";
+	public static final String END_VALUE = "\"";
+	public IgnoreString(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new IgnoreString(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/LBrace.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/LBrace.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/LBrace.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,37 @@
+package strategojava;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class LBrace extends LayoutStartIsland {
+
+	public static final String START_VALUE = "{";
+	public static final String MATCH_REG_EXP = "\\{";
+	public static final String VALUE = "{";
+	public LBrace(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new LBrace(previous, getInterval().clone(), value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isEndIsland(island)) {
+			RBrace end = (RBrace)island;
+			LBrace start = this;
+			return super.bridgeMatch(island, tol);
+		}
+		return false;
+	}
+
+	public boolean isEndIsland(LexicalNode node) {
+		return node instanceof RBrace;
+	}
+	public EndIsland createEndIsland(Interval interval) {
+		RBrace node = new RBrace(null, interval, RBrace.VALUE);
+		return node;
+	}
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/LBrack.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/LBrack.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/LBrack.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,37 @@
+package strategojava;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class LBrack extends SimpleStartIsland {
+
+	public static final String START_VALUE = "[";
+	public static final String MATCH_REG_EXP = "\\[";
+	public static final String VALUE = "[";
+	public LBrack(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new LBrack(previous, getInterval().clone(), value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isEndIsland(island)) {
+			RBrack end = (RBrack)island;
+			LBrack start = this;
+			return super.bridgeMatch(island, tol);
+		}
+		return false;
+	}
+
+	public boolean isEndIsland(LexicalNode node) {
+		return node instanceof RBrack;
+	}
+	public EndIsland createEndIsland(Interval interval) {
+		RBrack node = new RBrack(null, interval, RBrack.VALUE);
+		return node;
+	}
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/LParen.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/LParen.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/LParen.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,37 @@
+package strategojava;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class LParen extends SimpleStartIsland {
+
+	public static final String START_VALUE = "(";
+	public static final String MATCH_REG_EXP = "\\(";
+	public static final String VALUE = "(";
+	public LParen(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new LParen(previous, getInterval().clone(), value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isEndIsland(island)) {
+			RParen end = (RParen)island;
+			LParen start = this;
+			return super.bridgeMatch(island, tol);
+		}
+		return false;
+	}
+
+	public boolean isEndIsland(LexicalNode node) {
+		return node instanceof RParen;
+	}
+	public EndIsland createEndIsland(Interval interval) {
+		RParen node = new RParen(null, interval, RParen.VALUE);
+		return node;
+	}
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/LStratego.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/LStratego.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/LStratego.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,37 @@
+package strategojava;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class LStratego extends SimpleStartIsland {
+
+	public static final String START_VALUE = "|[";
+	public static final String MATCH_REG_EXP = "\\|\\[";
+	public static final String VALUE = "|[";
+	public LStratego(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new LStratego(previous, getInterval().clone(), value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isEndIsland(island)) {
+			RStratego end = (RStratego)island;
+			LStratego start = this;
+			return super.bridgeMatch(island, tol);
+		}
+		return false;
+	}
+
+	public boolean isEndIsland(LexicalNode node) {
+		return node instanceof RStratego;
+	}
+	public EndIsland createEndIsland(Interval interval) {
+		RStratego node = new RStratego(null, interval, RStratego.VALUE);
+		return node;
+	}
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/Layout.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/Layout.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/Layout.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package strategojava;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class Layout extends LayoutReef {
+
+	public static final String START_VALUE = "\n";
+	public static final String MATCH_REG_EXP = "\n(\t| )*";
+	public Layout(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new Layout(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/LayoutEndIsland.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/LayoutEndIsland.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/LayoutEndIsland.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,98 @@
+package strategojava;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public abstract class LayoutEndIsland extends EndIsland {
+
+	public LayoutEndIsland(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isStartIsland(island)) {
+			LayoutStartIsland start = (LayoutStartIsland)island;
+			LayoutEndIsland end = this;
+			return 
+			((start.indent() == null && 0 == end.indent().pos()) || (start.indent() != null && start.indent().pos() == end.indent().pos()));
+		}
+		return false;
+	}
+
+	public boolean possibleConstructionSite(LexicalNode node) {
+		{
+			LayoutReef a = (node instanceof LayoutReef) ? (LayoutReef)node : null;
+			LayoutReef b = (a != null && a.getNext() != null) ? (LayoutReef)a.getNext().getNextOfType(LayoutReef.class) : null;
+			if (a != null && b != null && 
+			  (this.indent() != null && 
+			  (a.startOfEmptyLine() != true && b.startOfEmptyLine() != true && a != this.indent() && a.pos() <= this.indent().pos()))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertBefore(newIsland, b);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		{
+			LayoutStartIsland b = (node instanceof LayoutStartIsland) ? (LayoutStartIsland)node : null;
+			if (b != null && 
+			  (b.indent() != null && this.indent() != null && 
+			  (b.hasBridge() && this.indent().pos() < b.indent().pos()))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertAfter(newIsland, b);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		return false;
+	}
+
+	public boolean isStartIsland(LexicalNode node) {
+		return node instanceof LayoutStartIsland;
+	}
+	// LayoutEndIsland.isStructural
+	protected boolean isStructural_value;
+	protected boolean isStructural_hasValue = false;
+	public boolean isStructural() {
+		if (!isStructural_hasValue) {
+			isStructural_value = isStructural_compute();
+			isStructural_hasValue = true;
+		}
+		return isStructural_value;
+	}
+	protected boolean isStructural_compute() {
+		// Non-generated code start
+		 return true; 
+		// Non-generated code end
+	}
+
+	// LayoutEndIsland.indent
+	protected LayoutReef indent_value;
+	protected boolean indent_hasValue = false;
+	public LayoutReef indent() {
+		if (!indent_hasValue) {
+			indent_value = indent_compute();
+			indent_hasValue = true;
+		}
+		return indent_value;
+	}
+	protected LayoutReef indent_compute() {
+		LexicalNode pos = getPrevious();
+		int order = 1;
+		int hits = 1;
+		while (pos != null && hits <= order) {
+			Object find = pos.getPreviousOfType(LayoutReef.class);
+			if (find == null) {
+					pos = null;
+			} else if (hits == order) {
+				return (LayoutReef)find;
+			} else {
+				hits++;
+				pos = ((LayoutReef)find).getPrevious();
+			}
+		}
+		return null;
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/LayoutReef.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/LayoutReef.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/LayoutReef.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,89 @@
+package strategojava;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public abstract class LayoutReef extends Reef {
+
+	public LayoutReef(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	// LayoutReef.pos
+	protected int pos_value;
+	protected boolean pos_hasValue = false;
+	public int pos() {
+		if (!pos_hasValue) {
+			pos_value = pos_compute();
+			pos_hasValue = true;
+		}
+		return pos_value;
+	}
+	protected int pos_compute() {
+		// Non-generated code start
+		
+	int pos = 0;
+	char[] chars = value.toCharArray();
+	for (int i = chars.length-1; i >= 0; i--) {
+		switch(chars[i]) {
+			case ' '  : pos++; break;
+			case '\t' : pos += 4; break; // TAB_SIZE=4
+		}
+		if (chars[i] == '\n') {
+			break;
+		}
+	}
+	return pos;
+
+		// Non-generated code end
+	}
+
+	// LayoutReef.rightNeighbour
+	protected LexicalNode rightNeighbour_value;
+	protected boolean rightNeighbour_hasValue = false;
+	public LexicalNode rightNeighbour() {
+		if (!rightNeighbour_hasValue) {
+			rightNeighbour_value = rightNeighbour_compute();
+			rightNeighbour_hasValue = true;
+		}
+		return rightNeighbour_value;
+	}
+	protected LexicalNode rightNeighbour_compute() {
+		LexicalNode pos = getNext();
+		int order = 1;
+		int hits = 1;
+		while (pos != null && hits <= order) {
+			Object find = pos.getNextOfType(LexicalNode.class);
+			if (find == null) {
+					pos = null;
+			} else if (hits == order) {
+				return (LexicalNode)find;
+			} else {
+				hits++;
+				pos = ((LexicalNode)find).getNext();
+			}
+		}
+		return null;
+	}
+
+	// LayoutReef.startOfEmptyLine
+	protected boolean startOfEmptyLine_value;
+	protected boolean startOfEmptyLine_hasValue = false;
+	public boolean startOfEmptyLine() {
+		if (!startOfEmptyLine_hasValue) {
+			startOfEmptyLine_value = startOfEmptyLine_compute();
+			startOfEmptyLine_hasValue = true;
+		}
+		return startOfEmptyLine_value;
+	}
+	protected boolean startOfEmptyLine_compute() {
+		// Non-generated code start
+		
+    return rightNeighbour() != null && rightNeighbour() instanceof LayoutReef;
+
+		// Non-generated code end
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/LayoutStartIsland.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/LayoutStartIsland.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/LayoutStartIsland.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,97 @@
+package strategojava;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public abstract class LayoutStartIsland extends StartIsland {
+
+	public LayoutStartIsland(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isEndIsland(island)) {
+			LayoutEndIsland end = (LayoutEndIsland)island;
+			LayoutStartIsland start = this;
+			return 
+			((start.indent() == null && 0 == end.indent().pos()) || (start.indent() != null && start.indent().pos() == end.indent().pos()));
+		}
+		return false;
+	}
+
+	public boolean possibleConstructionSite(LexicalNode node) {
+		{
+			LayoutReef a = (node instanceof LayoutReef) ? (LayoutReef)node : null;
+			if (a != null && 
+			  (this.indent() != null && 
+			  (a.startOfEmptyLine() != true && a.pos() <= this.indent().pos()))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertBefore(newIsland, a);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		{
+			LayoutEndIsland b = (node instanceof LayoutEndIsland) ? (LayoutEndIsland)node : null;
+			if (b != null && 
+			  (b.indent() != null && this.indent() != null && 
+			  (b.hasBridge() && b.indent().pos() < this.indent().pos()))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertBefore(newIsland, b);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		return false;
+	}
+
+	public boolean isEndIsland(LexicalNode node) {
+		return node instanceof LayoutEndIsland;
+	}
+	// LayoutStartIsland.indent
+	protected LayoutReef indent_value;
+	protected boolean indent_hasValue = false;
+	public LayoutReef indent() {
+		if (!indent_hasValue) {
+			indent_value = indent_compute();
+			indent_hasValue = true;
+		}
+		return indent_value;
+	}
+	protected LayoutReef indent_compute() {
+		LexicalNode pos = getPrevious();
+		int order = 1;
+		int hits = 1;
+		while (pos != null && hits <= order) {
+			Object find = pos.getPreviousOfType(LayoutReef.class);
+			if (find == null) {
+					pos = null;
+			} else if (hits == order) {
+				return (LayoutReef)find;
+			} else {
+				hits++;
+				pos = ((LayoutReef)find).getPrevious();
+			}
+		}
+		return null;
+	}
+
+	// LayoutStartIsland.isStructural
+	protected boolean isStructural_value;
+	protected boolean isStructural_hasValue = false;
+	public boolean isStructural() {
+		if (!isStructural_hasValue) {
+			isStructural_value = isStructural_compute();
+			isStructural_hasValue = true;
+		}
+		return isStructural_value;
+	}
+	protected boolean isStructural_compute() {
+		// Non-generated code start
+		 return true; 
+		// Non-generated code end
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/MainBridgeParser.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/MainBridgeParser.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/MainBridgeParser.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,143 @@
+package strategojava;
+
+import java.io.*;
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class MainBridgeParser extends AbstractBridgeParser {
+
+	protected LexicalNode matchNode(char[] content, int curPos, int lastMatchPos, LexicalNode previous) {
+		// RStratego
+		if (matchForward(content, curPos, RStratego.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				RStratego.START_VALUE.length(), RStratego.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new RStratego(previous, interval, value);
+		}
+		// LStratego
+		if (matchForward(content, curPos, LStratego.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				LStratego.START_VALUE.length(), LStratego.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new LStratego(previous, interval, value);
+		}
+		// Layout
+		if (matchForward(content, curPos, Layout.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				Layout.START_VALUE.length(), Layout.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new Layout(previous, interval, value);
+		}
+		// LParen
+		if (matchForward(content, curPos, LParen.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				LParen.START_VALUE.length(), LParen.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new LParen(previous, interval, value);
+		}
+		// LBrace
+		if (matchForward(content, curPos, LBrace.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				LBrace.START_VALUE.length(), LBrace.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new LBrace(previous, interval, value);
+		}
+		// RParen
+		if (matchForward(content, curPos, RParen.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				RParen.START_VALUE.length(), RParen.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new RParen(previous, interval, value);
+		}
+		// LBrack
+		if (matchForward(content, curPos, LBrack.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				LBrack.START_VALUE.length(), LBrack.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new LBrack(previous, interval, value);
+		}
+		// RBrace
+		if (matchForward(content, curPos, RBrace.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				RBrace.START_VALUE.length(), RBrace.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new RBrace(previous, interval, value);
+		}
+		// RBrack
+		if (matchForward(content, curPos, RBrack.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				RBrack.START_VALUE.length(), RBrack.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new RBrack(previous, interval, value);
+		}
+		return null;
+	}
+
+	protected LexicalNode matchIgnore(char[] content, int curPos, int lastMatchPos, LexicalNode previous) {
+		// MultiComment
+		if (matchForward(content, curPos, IgnoreMultiComment.START_VALUE)) {
+			int endPos = ignoreUntil(content, curPos + IgnoreMultiComment.START_VALUE.length(), IgnoreMultiComment.END_VALUE);
+			if (IgnoreMultiComment.END_VALUE.equals("\n")) {
+				endPos--;
+			}
+			Interval interval = new Interval(curPos, endPos);
+			return new IgnoreMultiComment(previous, interval, new String(content, curPos, 
+				(endPos < content.length - 1) ? interval.getLength() + 1 : interval.getLength()));
+		}
+		// LineComment
+		if (matchForward(content, curPos, IgnoreLineComment.START_VALUE)) {
+			int endPos = ignoreUntil(content, curPos + IgnoreLineComment.START_VALUE.length(), IgnoreLineComment.END_VALUE);
+			if (IgnoreLineComment.END_VALUE.equals("\n")) {
+				endPos--;
+			}
+			Interval interval = new Interval(curPos, endPos);
+			return new IgnoreLineComment(previous, interval, new String(content, curPos, 
+				(endPos < content.length - 1) ? interval.getLength() + 1 : interval.getLength()));
+		}
+		// String
+		if (matchForward(content, curPos, IgnoreString.START_VALUE)) {
+			int endPos = ignoreUntil(content, curPos + IgnoreString.START_VALUE.length(), IgnoreString.END_VALUE);
+			if (IgnoreString.END_VALUE.equals("\n")) {
+				endPos--;
+			}
+			Interval interval = new Interval(curPos, endPos);
+			return new IgnoreString(previous, interval, new String(content, curPos, 
+				(endPos < content.length - 1) ? interval.getLength() + 1 : interval.getLength()));
+		}
+		return null;
+	}
+
+	public static void main(String[] args) {
+		if (args.length != 1) {
+			System.err.println("usage: MainBridgeParser input-file");
+			System.exit(1);
+		}
+		
+		String filePath = args[0];
+		File file = new File(filePath);
+		if (!file.exists()) {
+			System.err.println("error: file does not exist [" + filePath + "]");
+			System.exit(2);
+		}
+		
+		StringBuffer buf = new StringBuffer();
+		try {
+			BufferedReader reader = new BufferedReader(new FileReader(file));
+			String line = null;
+			while ((line = reader.readLine()) != null) {
+				buf.append(line);
+			}
+			reader.close();
+		} catch (IOException e) {
+			System.err.println("error: problem reading from file [" + filePath + "]");
+			System.exit(3);
+		}
+		
+		IBridgeParser bp = new MainBridgeParser();
+		String result = bp.recover(buf.toString());
+		System.out.println("\nResult:\n[" + result + "]\n");
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/RBrace.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/RBrace.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/RBrace.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,37 @@
+package strategojava;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class RBrace extends LayoutEndIsland {
+
+	public static final String START_VALUE = "}";
+	public static final String MATCH_REG_EXP = "\\}";
+	public static final String VALUE = "}";
+	public RBrace(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new RBrace(previous, getInterval().clone(), value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isStartIsland(island)) {
+			LBrace start = (LBrace)island;
+			RBrace end = this;
+			return super.bridgeMatch(island, tol);
+		}
+		return false;
+	}
+
+	public boolean isStartIsland(LexicalNode node) {
+		return node instanceof LBrace;
+	}
+	public StartIsland createStartIsland(Interval interval) {
+		LBrace node = new LBrace(null, interval, LBrace.VALUE);
+		return node;
+	}
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/RBrack.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/RBrack.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/RBrack.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,37 @@
+package strategojava;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class RBrack extends SimpleEndIsland {
+
+	public static final String START_VALUE = "]";
+	public static final String MATCH_REG_EXP = "\\]";
+	public static final String VALUE = "]";
+	public RBrack(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new RBrack(previous, getInterval().clone(), value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isStartIsland(island)) {
+			LBrack start = (LBrack)island;
+			RBrack end = this;
+			return super.bridgeMatch(island, tol);
+		}
+		return false;
+	}
+
+	public boolean isStartIsland(LexicalNode node) {
+		return node instanceof LBrack;
+	}
+	public StartIsland createStartIsland(Interval interval) {
+		LBrack node = new LBrack(null, interval, LBrack.VALUE);
+		return node;
+	}
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/RParen.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/RParen.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/RParen.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,37 @@
+package strategojava;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class RParen extends SimpleEndIsland {
+
+	public static final String START_VALUE = ")";
+	public static final String MATCH_REG_EXP = "\\)";
+	public static final String VALUE = ")";
+	public RParen(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new RParen(previous, getInterval().clone(), value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isStartIsland(island)) {
+			LParen start = (LParen)island;
+			RParen end = this;
+			return super.bridgeMatch(island, tol);
+		}
+		return false;
+	}
+
+	public boolean isStartIsland(LexicalNode node) {
+		return node instanceof LParen;
+	}
+	public StartIsland createStartIsland(Interval interval) {
+		LParen node = new LParen(null, interval, LParen.VALUE);
+		return node;
+	}
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/RStratego.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/RStratego.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/RStratego.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,37 @@
+package strategojava;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class RStratego extends SimpleEndIsland {
+
+	public static final String START_VALUE = "]|";
+	public static final String MATCH_REG_EXP = "\\]\\|";
+	public static final String VALUE = "]|";
+	public RStratego(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new RStratego(previous, getInterval().clone(), value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isStartIsland(island)) {
+			LStratego start = (LStratego)island;
+			RStratego end = this;
+			return super.bridgeMatch(island, tol);
+		}
+		return false;
+	}
+
+	public boolean isStartIsland(LexicalNode node) {
+		return node instanceof LStratego;
+	}
+	public StartIsland createStartIsland(Interval interval) {
+		LStratego node = new LStratego(null, interval, LStratego.VALUE);
+		return node;
+	}
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/SimpleEndIsland.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/SimpleEndIsland.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/SimpleEndIsland.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,72 @@
+package strategojava;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public abstract class SimpleEndIsland extends LayoutEndIsland {
+
+	public SimpleEndIsland(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isStartIsland(island)) {
+			SimpleStartIsland start = (SimpleStartIsland)island;
+			SimpleEndIsland end = this;
+			return 
+			(true);
+		}
+		return false;
+	}
+
+	public boolean possibleConstructionSite(LexicalNode node) {
+		{
+			Reef a = (node instanceof Reef) ? (Reef)node : null;
+			if (a != null && 
+			  (
+			  (true))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertAfter(newIsland, a);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		{
+			LayoutEndIsland a = (node instanceof LayoutEndIsland) ? (LayoutEndIsland)node : null;
+			if (a != null && 
+			  (
+			  (a.isStructural()))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertAfter(newIsland, a);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		if (super.possibleConstructionSite(node)) {
+			return true;
+		}
+		return false;
+	}
+
+	public boolean isStartIsland(LexicalNode node) {
+		return node instanceof SimpleStartIsland;
+	}
+	// SimpleEndIsland.isStructural
+	protected boolean isStructural_value;
+	protected boolean isStructural_hasValue = false;
+	public boolean isStructural() {
+		if (!isStructural_hasValue) {
+			isStructural_value = isStructural_compute();
+			isStructural_hasValue = true;
+		}
+		return isStructural_value;
+	}
+	protected boolean isStructural_compute() {
+		// Non-generated code start
+		 return false; 
+		// Non-generated code end
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/SimpleStartIsland.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/SimpleStartIsland.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/SimpleStartIsland.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,72 @@
+package strategojava;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public abstract class SimpleStartIsland extends LayoutStartIsland {
+
+	public SimpleStartIsland(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isEndIsland(island)) {
+			SimpleEndIsland end = (SimpleEndIsland)island;
+			SimpleStartIsland start = this;
+			return 
+			(true);
+		}
+		return false;
+	}
+
+	public boolean possibleConstructionSite(LexicalNode node) {
+		{
+			Reef a = (node instanceof Reef) ? (Reef)node : null;
+			if (a != null && 
+			  (
+			  (true))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertBefore(newIsland, a);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		{
+			LayoutStartIsland a = (node instanceof LayoutStartIsland) ? (LayoutStartIsland)node : null;
+			if (a != null && 
+			  (
+			  (a.isStructural()))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertBefore(newIsland, a);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		if (super.possibleConstructionSite(node)) {
+			return true;
+		}
+		return false;
+	}
+
+	public boolean isEndIsland(LexicalNode node) {
+		return node instanceof SimpleEndIsland;
+	}
+	// SimpleStartIsland.isStructural
+	protected boolean isStructural_value;
+	protected boolean isStructural_hasValue = false;
+	public boolean isStructural() {
+		if (!isStructural_hasValue) {
+			isStructural_value = isStructural_compute();
+			isStructural_hasValue = true;
+		}
+		return isStructural_value;
+	}
+	protected boolean isStructural_compute() {
+		// Non-generated code start
+		 return false; 
+		// Non-generated code end
+	}
+
+}

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl.jar
==============================================================================
Binary file (source and/or target). No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/IgnoreLineComment.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/IgnoreLineComment.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/IgnoreLineComment.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package webdsl;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class IgnoreLineComment extends Ignore {
+
+	public static final String START_VALUE = "//";
+	public static final String END_VALUE = "\n";
+	public IgnoreLineComment(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new IgnoreLineComment(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/IgnoreMultiComment.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/IgnoreMultiComment.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/IgnoreMultiComment.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package webdsl;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class IgnoreMultiComment extends Ignore {
+
+	public static final String START_VALUE = "/*";
+	public static final String END_VALUE = "*/";
+	public IgnoreMultiComment(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new IgnoreMultiComment(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/IgnoreScript.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/IgnoreScript.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/IgnoreScript.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package webdsl;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class IgnoreScript extends Ignore {
+
+	public static final String START_VALUE = "<script>";
+	public static final String END_VALUE = "</script>";
+	public IgnoreScript(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new IgnoreScript(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/IgnoreString.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/IgnoreString.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/IgnoreString.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package webdsl;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class IgnoreString extends Ignore {
+
+	public static final String START_VALUE = "\"";
+	public static final String END_VALUE = "\"";
+	public IgnoreString(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new IgnoreString(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LBrace.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LBrace.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LBrace.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,37 @@
+package webdsl;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class LBrace extends LayoutStartIsland {
+
+	public static final String START_VALUE = "{";
+	public static final String MATCH_REG_EXP = "\\{";
+	public static final String VALUE = "{";
+	public LBrace(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new LBrace(previous, getInterval().clone(), value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isEndIsland(island)) {
+			RBrace end = (RBrace)island;
+			LBrace start = this;
+			return super.bridgeMatch(island, tol);
+		}
+		return false;
+	}
+
+	public boolean isEndIsland(LexicalNode node) {
+		return node instanceof RBrace;
+	}
+	public EndIsland createEndIsland(Interval interval) {
+		RBrace node = new RBrace(null, interval, RBrace.VALUE);
+		return node;
+	}
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LBrack.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LBrack.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LBrack.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,37 @@
+package webdsl;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class LBrack extends SimpleStartIsland {
+
+	public static final String START_VALUE = "[";
+	public static final String MATCH_REG_EXP = "\\[";
+	public static final String VALUE = "[";
+	public LBrack(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new LBrack(previous, getInterval().clone(), value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isEndIsland(island)) {
+			RBrack end = (RBrack)island;
+			LBrack start = this;
+			return super.bridgeMatch(island, tol);
+		}
+		return false;
+	}
+
+	public boolean isEndIsland(LexicalNode node) {
+		return node instanceof RBrack;
+	}
+	public EndIsland createEndIsland(Interval interval) {
+		RBrack node = new RBrack(null, interval, RBrack.VALUE);
+		return node;
+	}
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LParen.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LParen.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LParen.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,37 @@
+package webdsl;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class LParen extends SimpleStartIsland {
+
+	public static final String START_VALUE = "(";
+	public static final String MATCH_REG_EXP = "\\(";
+	public static final String VALUE = "(";
+	public LParen(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new LParen(previous, getInterval().clone(), value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isEndIsland(island)) {
+			RParen end = (RParen)island;
+			LParen start = this;
+			return super.bridgeMatch(island, tol);
+		}
+		return false;
+	}
+
+	public boolean isEndIsland(LexicalNode node) {
+		return node instanceof RParen;
+	}
+	public EndIsland createEndIsland(Interval interval) {
+		RParen node = new RParen(null, interval, RParen.VALUE);
+		return node;
+	}
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/Layout.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/Layout.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/Layout.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package webdsl;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class Layout extends LayoutReef {
+
+	public static final String START_VALUE = "\n";
+	public static final String MATCH_REG_EXP = "\n(\t| )*";
+	public Layout(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new Layout(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LayoutEndIsland.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LayoutEndIsland.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LayoutEndIsland.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,98 @@
+package webdsl;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public abstract class LayoutEndIsland extends EndIsland {
+
+	public LayoutEndIsland(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isStartIsland(island)) {
+			LayoutStartIsland start = (LayoutStartIsland)island;
+			LayoutEndIsland end = this;
+			return 
+			((start.indent() == null && 0 == end.indent().pos()) || (start.indent() != null && start.indent().pos() == end.indent().pos()));
+		}
+		return false;
+	}
+
+	public boolean possibleConstructionSite(LexicalNode node) {
+		{
+			LayoutReef a = (node instanceof LayoutReef) ? (LayoutReef)node : null;
+			LayoutReef b = (a != null && a.getNext() != null) ? (LayoutReef)a.getNext().getNextOfType(LayoutReef.class) : null;
+			if (a != null && b != null && 
+			  (this.indent() != null && 
+			  (a.startOfEmptyLine() != true && b.startOfEmptyLine() != true && a != this.indent() && a.pos() <= this.indent().pos()))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertBefore(newIsland, b);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		{
+			LayoutStartIsland b = (node instanceof LayoutStartIsland) ? (LayoutStartIsland)node : null;
+			if (b != null && 
+			  (b.indent() != null && this.indent() != null && 
+			  (b.hasBridge() && this.indent().pos() < b.indent().pos()))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertAfter(newIsland, b);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		return false;
+	}
+
+	public boolean isStartIsland(LexicalNode node) {
+		return node instanceof LayoutStartIsland;
+	}
+	// LayoutEndIsland.indent
+	protected LayoutReef indent_value;
+	protected boolean indent_hasValue = false;
+	public LayoutReef indent() {
+		if (!indent_hasValue) {
+			indent_value = indent_compute();
+			indent_hasValue = true;
+		}
+		return indent_value;
+	}
+	protected LayoutReef indent_compute() {
+		LexicalNode pos = getPrevious();
+		int order = 1;
+		int hits = 1;
+		while (pos != null && hits <= order) {
+			Object find = pos.getPreviousOfType(LayoutReef.class);
+			if (find == null) {
+					pos = null;
+			} else if (hits == order) {
+				return (LayoutReef)find;
+			} else {
+				hits++;
+				pos = ((LayoutReef)find).getPrevious();
+			}
+		}
+		return null;
+	}
+
+	// LayoutEndIsland.isStructural
+	protected boolean isStructural_value;
+	protected boolean isStructural_hasValue = false;
+	public boolean isStructural() {
+		if (!isStructural_hasValue) {
+			isStructural_value = isStructural_compute();
+			isStructural_hasValue = true;
+		}
+		return isStructural_value;
+	}
+	protected boolean isStructural_compute() {
+		// Non-generated code start
+		 return true; 
+		// Non-generated code end
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LayoutReef.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LayoutReef.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LayoutReef.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,89 @@
+package webdsl;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public abstract class LayoutReef extends Reef {
+
+	public LayoutReef(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	// LayoutReef.rightNeighbour
+	protected LexicalNode rightNeighbour_value;
+	protected boolean rightNeighbour_hasValue = false;
+	public LexicalNode rightNeighbour() {
+		if (!rightNeighbour_hasValue) {
+			rightNeighbour_value = rightNeighbour_compute();
+			rightNeighbour_hasValue = true;
+		}
+		return rightNeighbour_value;
+	}
+	protected LexicalNode rightNeighbour_compute() {
+		LexicalNode pos = getNext();
+		int order = 1;
+		int hits = 1;
+		while (pos != null && hits <= order) {
+			Object find = pos.getNextOfType(LexicalNode.class);
+			if (find == null) {
+					pos = null;
+			} else if (hits == order) {
+				return (LexicalNode)find;
+			} else {
+				hits++;
+				pos = ((LexicalNode)find).getNext();
+			}
+		}
+		return null;
+	}
+
+	// LayoutReef.startOfEmptyLine
+	protected boolean startOfEmptyLine_value;
+	protected boolean startOfEmptyLine_hasValue = false;
+	public boolean startOfEmptyLine() {
+		if (!startOfEmptyLine_hasValue) {
+			startOfEmptyLine_value = startOfEmptyLine_compute();
+			startOfEmptyLine_hasValue = true;
+		}
+		return startOfEmptyLine_value;
+	}
+	protected boolean startOfEmptyLine_compute() {
+		// Non-generated code start
+		
+    return rightNeighbour() != null && rightNeighbour() instanceof LayoutReef;
+
+		// Non-generated code end
+	}
+
+	// LayoutReef.pos
+	protected int pos_value;
+	protected boolean pos_hasValue = false;
+	public int pos() {
+		if (!pos_hasValue) {
+			pos_value = pos_compute();
+			pos_hasValue = true;
+		}
+		return pos_value;
+	}
+	protected int pos_compute() {
+		// Non-generated code start
+		
+	int pos = 0;
+	char[] chars = value.toCharArray();
+	for (int i = chars.length-1; i >= 0; i--) {
+		switch(chars[i]) {
+			case ' '  : pos++; break;
+			case '\t' : pos += 4; break; // TAB_SIZE=4
+		}
+		if (chars[i] == '\n') {
+			break;
+		}
+	}
+	return pos;
+
+		// Non-generated code end
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LayoutStartIsland.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LayoutStartIsland.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LayoutStartIsland.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,97 @@
+package webdsl;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public abstract class LayoutStartIsland extends StartIsland {
+
+	public LayoutStartIsland(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isEndIsland(island)) {
+			LayoutEndIsland end = (LayoutEndIsland)island;
+			LayoutStartIsland start = this;
+			return 
+			((start.indent() == null && 0 == end.indent().pos()) || (start.indent() != null && start.indent().pos() == end.indent().pos()));
+		}
+		return false;
+	}
+
+	public boolean possibleConstructionSite(LexicalNode node) {
+		{
+			LayoutReef a = (node instanceof LayoutReef) ? (LayoutReef)node : null;
+			if (a != null && 
+			  (this.indent() != null && 
+			  (a.startOfEmptyLine() != true && a.pos() <= this.indent().pos()))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertBefore(newIsland, a);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		{
+			LayoutEndIsland b = (node instanceof LayoutEndIsland) ? (LayoutEndIsland)node : null;
+			if (b != null && 
+			  (b.indent() != null && this.indent() != null && 
+			  (b.hasBridge() && b.indent().pos() < this.indent().pos()))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertBefore(newIsland, b);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		return false;
+	}
+
+	public boolean isEndIsland(LexicalNode node) {
+		return node instanceof LayoutEndIsland;
+	}
+	// LayoutStartIsland.indent
+	protected LayoutReef indent_value;
+	protected boolean indent_hasValue = false;
+	public LayoutReef indent() {
+		if (!indent_hasValue) {
+			indent_value = indent_compute();
+			indent_hasValue = true;
+		}
+		return indent_value;
+	}
+	protected LayoutReef indent_compute() {
+		LexicalNode pos = getPrevious();
+		int order = 1;
+		int hits = 1;
+		while (pos != null && hits <= order) {
+			Object find = pos.getPreviousOfType(LayoutReef.class);
+			if (find == null) {
+					pos = null;
+			} else if (hits == order) {
+				return (LayoutReef)find;
+			} else {
+				hits++;
+				pos = ((LayoutReef)find).getPrevious();
+			}
+		}
+		return null;
+	}
+
+	// LayoutStartIsland.isStructural
+	protected boolean isStructural_value;
+	protected boolean isStructural_hasValue = false;
+	public boolean isStructural() {
+		if (!isStructural_hasValue) {
+			isStructural_value = isStructural_compute();
+			isStructural_hasValue = true;
+		}
+		return isStructural_value;
+	}
+	protected boolean isStructural_compute() {
+		// Non-generated code start
+		 return true; 
+		// Non-generated code end
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/MainBridgeParser.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/MainBridgeParser.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/MainBridgeParser.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,139 @@
+package webdsl;
+
+import java.io.*;
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class MainBridgeParser extends AbstractBridgeParser {
+
+	protected LexicalNode matchNode(char[] content, int curPos, int lastMatchPos, LexicalNode previous) {
+		// RBrace
+		if (matchForward(content, curPos, RBrace.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				RBrace.START_VALUE.length(), RBrace.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new RBrace(previous, interval, value);
+		}
+		// RBrack
+		if (matchForward(content, curPos, RBrack.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				RBrack.START_VALUE.length(), RBrack.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new RBrack(previous, interval, value);
+		}
+		// LParen
+		if (matchForward(content, curPos, LParen.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				LParen.START_VALUE.length(), LParen.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new LParen(previous, interval, value);
+		}
+		// Layout
+		if (matchForward(content, curPos, Layout.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				Layout.START_VALUE.length(), Layout.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new Layout(previous, interval, value);
+		}
+		// RParen
+		if (matchForward(content, curPos, RParen.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				RParen.START_VALUE.length(), RParen.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new RParen(previous, interval, value);
+		}
+		// LBrack
+		if (matchForward(content, curPos, LBrack.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				LBrack.START_VALUE.length(), LBrack.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new LBrack(previous, interval, value);
+		}
+		// LBrace
+		if (matchForward(content, curPos, LBrace.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				LBrace.START_VALUE.length(), LBrace.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new LBrace(previous, interval, value);
+		}
+		return null;
+	}
+
+	protected LexicalNode matchIgnore(char[] content, int curPos, int lastMatchPos, LexicalNode previous) {
+		// Script
+		if (matchForward(content, curPos, IgnoreScript.START_VALUE)) {
+			int endPos = ignoreUntil(content, curPos + IgnoreScript.START_VALUE.length(), IgnoreScript.END_VALUE);
+			if (IgnoreScript.END_VALUE.equals("\n")) {
+				endPos--;
+			}
+			Interval interval = new Interval(curPos, endPos);
+			return new IgnoreScript(previous, interval, new String(content, curPos, 
+				(endPos < content.length - 1) ? interval.getLength() + 1 : interval.getLength()));
+		}
+		// MultiComment
+		if (matchForward(content, curPos, IgnoreMultiComment.START_VALUE)) {
+			int endPos = ignoreUntil(content, curPos + IgnoreMultiComment.START_VALUE.length(), IgnoreMultiComment.END_VALUE);
+			if (IgnoreMultiComment.END_VALUE.equals("\n")) {
+				endPos--;
+			}
+			Interval interval = new Interval(curPos, endPos);
+			return new IgnoreMultiComment(previous, interval, new String(content, curPos, 
+				(endPos < content.length - 1) ? interval.getLength() + 1 : interval.getLength()));
+		}
+		// String
+		if (matchForward(content, curPos, IgnoreString.START_VALUE)) {
+			int endPos = ignoreUntil(content, curPos + IgnoreString.START_VALUE.length(), IgnoreString.END_VALUE);
+			if (IgnoreString.END_VALUE.equals("\n")) {
+				endPos--;
+			}
+			Interval interval = new Interval(curPos, endPos);
+			return new IgnoreString(previous, interval, new String(content, curPos, 
+				(endPos < content.length - 1) ? interval.getLength() + 1 : interval.getLength()));
+		}
+		// LineComment
+		if (matchForward(content, curPos, IgnoreLineComment.START_VALUE)) {
+			int endPos = ignoreUntil(content, curPos + IgnoreLineComment.START_VALUE.length(), IgnoreLineComment.END_VALUE);
+			if (IgnoreLineComment.END_VALUE.equals("\n")) {
+				endPos--;
+			}
+			Interval interval = new Interval(curPos, endPos);
+			return new IgnoreLineComment(previous, interval, new String(content, curPos, 
+				(endPos < content.length - 1) ? interval.getLength() + 1 : interval.getLength()));
+		}
+		return null;
+	}
+
+	public static void main(String[] args) {
+		if (args.length != 1) {
+			System.err.println("usage: MainBridgeParser input-file");
+			System.exit(1);
+		}
+		
+		String filePath = args[0];
+		File file = new File(filePath);
+		if (!file.exists()) {
+			System.err.println("error: file does not exist [" + filePath + "]");
+			System.exit(2);
+		}
+		
+		StringBuffer buf = new StringBuffer();
+		try {
+			BufferedReader reader = new BufferedReader(new FileReader(file));
+			String line = null;
+			while ((line = reader.readLine()) != null) {
+				buf.append(line);
+			}
+			reader.close();
+		} catch (IOException e) {
+			System.err.println("error: problem reading from file [" + filePath + "]");
+			System.exit(3);
+		}
+		
+		IBridgeParser bp = new MainBridgeParser();
+		String result = bp.recover(buf.toString());
+		System.out.println("\nResult:\n[" + result + "]\n");
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/RBrace.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/RBrace.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/RBrace.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,37 @@
+package webdsl;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class RBrace extends LayoutEndIsland {
+
+	public static final String START_VALUE = "}";
+	public static final String MATCH_REG_EXP = "\\}";
+	public static final String VALUE = "}";
+	public RBrace(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new RBrace(previous, getInterval().clone(), value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isStartIsland(island)) {
+			LBrace start = (LBrace)island;
+			RBrace end = this;
+			return super.bridgeMatch(island, tol);
+		}
+		return false;
+	}
+
+	public boolean isStartIsland(LexicalNode node) {
+		return node instanceof LBrace;
+	}
+	public StartIsland createStartIsland(Interval interval) {
+		LBrace node = new LBrace(null, interval, LBrace.VALUE);
+		return node;
+	}
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/RBrack.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/RBrack.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/RBrack.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,37 @@
+package webdsl;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class RBrack extends SimpleEndIsland {
+
+	public static final String START_VALUE = "]";
+	public static final String MATCH_REG_EXP = "\\]";
+	public static final String VALUE = "]";
+	public RBrack(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new RBrack(previous, getInterval().clone(), value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isStartIsland(island)) {
+			LBrack start = (LBrack)island;
+			RBrack end = this;
+			return super.bridgeMatch(island, tol);
+		}
+		return false;
+	}
+
+	public boolean isStartIsland(LexicalNode node) {
+		return node instanceof LBrack;
+	}
+	public StartIsland createStartIsland(Interval interval) {
+		LBrack node = new LBrack(null, interval, LBrack.VALUE);
+		return node;
+	}
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/RParen.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/RParen.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/RParen.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,37 @@
+package webdsl;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class RParen extends SimpleEndIsland {
+
+	public static final String START_VALUE = ")";
+	public static final String MATCH_REG_EXP = "\\)";
+	public static final String VALUE = ")";
+	public RParen(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new RParen(previous, getInterval().clone(), value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isStartIsland(island)) {
+			LParen start = (LParen)island;
+			RParen end = this;
+			return super.bridgeMatch(island, tol);
+		}
+		return false;
+	}
+
+	public boolean isStartIsland(LexicalNode node) {
+		return node instanceof LParen;
+	}
+	public StartIsland createStartIsland(Interval interval) {
+		LParen node = new LParen(null, interval, LParen.VALUE);
+		return node;
+	}
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/SimpleEndIsland.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/SimpleEndIsland.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/SimpleEndIsland.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,72 @@
+package webdsl;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public abstract class SimpleEndIsland extends LayoutEndIsland {
+
+	public SimpleEndIsland(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isStartIsland(island)) {
+			SimpleStartIsland start = (SimpleStartIsland)island;
+			SimpleEndIsland end = this;
+			return 
+			(true);
+		}
+		return false;
+	}
+
+	public boolean possibleConstructionSite(LexicalNode node) {
+		{
+			Reef a = (node instanceof Reef) ? (Reef)node : null;
+			if (a != null && 
+			  (
+			  (true))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertAfter(newIsland, a);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		{
+			LayoutEndIsland a = (node instanceof LayoutEndIsland) ? (LayoutEndIsland)node : null;
+			if (a != null && 
+			  (
+			  (a.isStructural()))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertAfter(newIsland, a);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		if (super.possibleConstructionSite(node)) {
+			return true;
+		}
+		return false;
+	}
+
+	public boolean isStartIsland(LexicalNode node) {
+		return node instanceof SimpleStartIsland;
+	}
+	// SimpleEndIsland.isStructural
+	protected boolean isStructural_value;
+	protected boolean isStructural_hasValue = false;
+	public boolean isStructural() {
+		if (!isStructural_hasValue) {
+			isStructural_value = isStructural_compute();
+			isStructural_hasValue = true;
+		}
+		return isStructural_value;
+	}
+	protected boolean isStructural_compute() {
+		// Non-generated code start
+		 return false; 
+		// Non-generated code end
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/SimpleStartIsland.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/SimpleStartIsland.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/SimpleStartIsland.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,72 @@
+package webdsl;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public abstract class SimpleStartIsland extends LayoutStartIsland {
+
+	public SimpleStartIsland(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isEndIsland(island)) {
+			SimpleEndIsland end = (SimpleEndIsland)island;
+			SimpleStartIsland start = this;
+			return 
+			(true);
+		}
+		return false;
+	}
+
+	public boolean possibleConstructionSite(LexicalNode node) {
+		{
+			Reef a = (node instanceof Reef) ? (Reef)node : null;
+			if (a != null && 
+			  (
+			  (true))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertBefore(newIsland, a);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		{
+			LayoutStartIsland a = (node instanceof LayoutStartIsland) ? (LayoutStartIsland)node : null;
+			if (a != null && 
+			  (
+			  (a.isStructural()))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertBefore(newIsland, a);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		if (super.possibleConstructionSite(node)) {
+			return true;
+		}
+		return false;
+	}
+
+	public boolean isEndIsland(LexicalNode node) {
+		return node instanceof SimpleEndIsland;
+	}
+	// SimpleStartIsland.isStructural
+	protected boolean isStructural_value;
+	protected boolean isStructural_hasValue = false;
+	public boolean isStructural() {
+		if (!isStructural_hasValue) {
+			isStructural_value = isStructural_compute();
+			isStructural_hasValue = true;
+		}
+		return isStructural_value;
+	}
+	protected boolean isStructural_compute() {
+		// Non-generated code start
+		 return false; 
+		// Non-generated code end
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/AbstractKeyword.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/AbstractKeyword.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/AbstractKeyword.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class AbstractKeyword extends Reef {
+
+	public static final String START_VALUE = "abstract";
+	public static final String MATCH_REG_EXP = "abstract";
+	public AbstractKeyword(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new AbstractKeyword(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/AssertKeyword.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/AssertKeyword.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/AssertKeyword.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class AssertKeyword extends Reef {
+
+	public static final String START_VALUE = "assert";
+	public static final String MATCH_REG_EXP = "assert";
+	public AssertKeyword(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new AssertKeyword(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/BreakKeyword.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/BreakKeyword.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/BreakKeyword.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class BreakKeyword extends Reef {
+
+	public static final String START_VALUE = "break";
+	public static final String MATCH_REG_EXP = "break";
+	public BreakKeyword(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new BreakKeyword(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/CaseKeyword.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/CaseKeyword.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/CaseKeyword.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class CaseKeyword extends Reef {
+
+	public static final String START_VALUE = "case";
+	public static final String MATCH_REG_EXP = "case";
+	public CaseKeyword(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new CaseKeyword(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/CatchKeyword.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/CatchKeyword.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/CatchKeyword.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class CatchKeyword extends Reef {
+
+	public static final String START_VALUE = "catch";
+	public static final String MATCH_REG_EXP = "catch";
+	public CatchKeyword(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new CatchKeyword(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ClassKeyword.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ClassKeyword.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ClassKeyword.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class ClassKeyword extends Reef {
+
+	public static final String START_VALUE = "class";
+	public static final String MATCH_REG_EXP = "class";
+	public ClassKeyword(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new ClassKeyword(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ContinueKeyword.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ContinueKeyword.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ContinueKeyword.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class ContinueKeyword extends Reef {
+
+	public static final String START_VALUE = "continue";
+	public static final String MATCH_REG_EXP = "continue";
+	public ContinueKeyword(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new ContinueKeyword(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/DefaultKeyword.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/DefaultKeyword.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/DefaultKeyword.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class DefaultKeyword extends Reef {
+
+	public static final String START_VALUE = "default";
+	public static final String MATCH_REG_EXP = "default";
+	public DefaultKeyword(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new DefaultKeyword(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/DoKeyword.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/DoKeyword.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/DoKeyword.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class DoKeyword extends Reef {
+
+	public static final String START_VALUE = "do";
+	public static final String MATCH_REG_EXP = "do";
+	public DoKeyword(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new DoKeyword(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ElseKeyword.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ElseKeyword.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ElseKeyword.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class ElseKeyword extends Reef {
+
+	public static final String START_VALUE = "else";
+	public static final String MATCH_REG_EXP = "else";
+	public ElseKeyword(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new ElseKeyword(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/EnumKeyword.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/EnumKeyword.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/EnumKeyword.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class EnumKeyword extends Reef {
+
+	public static final String START_VALUE = "enum";
+	public static final String MATCH_REG_EXP = "enum";
+	public EnumKeyword(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new EnumKeyword(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ExtendsKeyword.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ExtendsKeyword.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ExtendsKeyword.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class ExtendsKeyword extends Reef {
+
+	public static final String START_VALUE = "extends";
+	public static final String MATCH_REG_EXP = "extends";
+	public ExtendsKeyword(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new ExtendsKeyword(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/FinalKeyword.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/FinalKeyword.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/FinalKeyword.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class FinalKeyword extends Reef {
+
+	public static final String START_VALUE = "final";
+	public static final String MATCH_REG_EXP = "final";
+	public FinalKeyword(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new FinalKeyword(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/FinallyKeyword.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/FinallyKeyword.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/FinallyKeyword.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class FinallyKeyword extends Reef {
+
+	public static final String START_VALUE = "finally";
+	public static final String MATCH_REG_EXP = "finally";
+	public FinallyKeyword(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new FinallyKeyword(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ForKeyword.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ForKeyword.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ForKeyword.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class ForKeyword extends Reef {
+
+	public static final String START_VALUE = "for";
+	public static final String MATCH_REG_EXP = "for";
+	public ForKeyword(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new ForKeyword(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/IfKeyword.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/IfKeyword.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/IfKeyword.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class IfKeyword extends Reef {
+
+	public static final String START_VALUE = "if";
+	public static final String MATCH_REG_EXP = "if";
+	public IfKeyword(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new IfKeyword(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/IgnoreLineComment.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/IgnoreLineComment.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/IgnoreLineComment.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class IgnoreLineComment extends Ignore {
+
+	public static final String START_VALUE = "//";
+	public static final String END_VALUE = "\n";
+	public IgnoreLineComment(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new IgnoreLineComment(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/IgnoreMultiComment.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/IgnoreMultiComment.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/IgnoreMultiComment.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class IgnoreMultiComment extends Ignore {
+
+	public static final String START_VALUE = "/*";
+	public static final String END_VALUE = "*/";
+	public IgnoreMultiComment(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new IgnoreMultiComment(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/IgnoreString.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/IgnoreString.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/IgnoreString.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class IgnoreString extends Ignore {
+
+	public static final String START_VALUE = "\"";
+	public static final String END_VALUE = "\"";
+	public IgnoreString(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new IgnoreString(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ImplementsKeyword.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ImplementsKeyword.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ImplementsKeyword.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class ImplementsKeyword extends Reef {
+
+	public static final String START_VALUE = "implements";
+	public static final String MATCH_REG_EXP = "implements";
+	public ImplementsKeyword(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new ImplementsKeyword(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ImportKeyword.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ImportKeyword.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ImportKeyword.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class ImportKeyword extends Reef {
+
+	public static final String START_VALUE = "import";
+	public static final String MATCH_REG_EXP = "import";
+	public ImportKeyword(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new ImportKeyword(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/InterfaceKeyword.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/InterfaceKeyword.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/InterfaceKeyword.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class InterfaceKeyword extends Reef {
+
+	public static final String START_VALUE = "interface";
+	public static final String MATCH_REG_EXP = "interface";
+	public InterfaceKeyword(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new InterfaceKeyword(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/LBrace.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/LBrace.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/LBrace.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,37 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class LBrace extends LayoutStartIsland {
+
+	public static final String START_VALUE = "{";
+	public static final String MATCH_REG_EXP = "\\{";
+	public static final String VALUE = "{";
+	public LBrace(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new LBrace(previous, getInterval().clone(), value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isEndIsland(island)) {
+			RBrace end = (RBrace)island;
+			LBrace start = this;
+			return super.bridgeMatch(island, tol);
+		}
+		return false;
+	}
+
+	public boolean isEndIsland(LexicalNode node) {
+		return node instanceof RBrace;
+	}
+	public EndIsland createEndIsland(Interval interval) {
+		RBrace node = new RBrace(null, interval, RBrace.VALUE);
+		return node;
+	}
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/LBrack.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/LBrack.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/LBrack.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,37 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class LBrack extends SimpleStartIsland {
+
+	public static final String START_VALUE = "[";
+	public static final String MATCH_REG_EXP = "\\[";
+	public static final String VALUE = "[";
+	public LBrack(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new LBrack(previous, getInterval().clone(), value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isEndIsland(island)) {
+			RBrack end = (RBrack)island;
+			LBrack start = this;
+			return super.bridgeMatch(island, tol);
+		}
+		return false;
+	}
+
+	public boolean isEndIsland(LexicalNode node) {
+		return node instanceof RBrack;
+	}
+	public EndIsland createEndIsland(Interval interval) {
+		RBrack node = new RBrack(null, interval, RBrack.VALUE);
+		return node;
+	}
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/LParen.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/LParen.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/LParen.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,37 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class LParen extends SimpleStartIsland {
+
+	public static final String START_VALUE = "(";
+	public static final String MATCH_REG_EXP = "\\(";
+	public static final String VALUE = "(";
+	public LParen(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new LParen(previous, getInterval().clone(), value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isEndIsland(island)) {
+			RParen end = (RParen)island;
+			LParen start = this;
+			return super.bridgeMatch(island, tol);
+		}
+		return false;
+	}
+
+	public boolean isEndIsland(LexicalNode node) {
+		return node instanceof RParen;
+	}
+	public EndIsland createEndIsland(Interval interval) {
+		RParen node = new RParen(null, interval, RParen.VALUE);
+		return node;
+	}
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/Layout.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/Layout.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/Layout.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class Layout extends LayoutReef {
+
+	public static final String START_VALUE = "\n";
+	public static final String MATCH_REG_EXP = "\n(\t| )*";
+	public Layout(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new Layout(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/LayoutEndIsland.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/LayoutEndIsland.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/LayoutEndIsland.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,98 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public abstract class LayoutEndIsland extends EndIsland {
+
+	public LayoutEndIsland(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isStartIsland(island)) {
+			LayoutStartIsland start = (LayoutStartIsland)island;
+			LayoutEndIsland end = this;
+			return 
+			((start.indent() == null && 0 == end.indent().pos()) || (start.indent() != null && start.indent().pos() == end.indent().pos()));
+		}
+		return false;
+	}
+
+	public boolean possibleConstructionSite(LexicalNode node) {
+		{
+			LayoutReef a = (node instanceof LayoutReef) ? (LayoutReef)node : null;
+			LayoutReef b = (a != null && a.getNext() != null) ? (LayoutReef)a.getNext().getNextOfType(LayoutReef.class) : null;
+			if (a != null && b != null && 
+			  (this.indent() != null && 
+			  (a.startOfEmptyLine() != true && b.startOfEmptyLine() != true && a != this.indent() && a.pos() <= this.indent().pos()))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertBefore(newIsland, b);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		{
+			LayoutStartIsland b = (node instanceof LayoutStartIsland) ? (LayoutStartIsland)node : null;
+			if (b != null && 
+			  (b.indent() != null && this.indent() != null && 
+			  (b.hasBridge() && this.indent().pos() < b.indent().pos()))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertAfter(newIsland, b);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		return false;
+	}
+
+	public boolean isStartIsland(LexicalNode node) {
+		return node instanceof LayoutStartIsland;
+	}
+	// LayoutEndIsland.isStructural
+	protected boolean isStructural_value;
+	protected boolean isStructural_hasValue = false;
+	public boolean isStructural() {
+		if (!isStructural_hasValue) {
+			isStructural_value = isStructural_compute();
+			isStructural_hasValue = true;
+		}
+		return isStructural_value;
+	}
+	protected boolean isStructural_compute() {
+		// Non-generated code start
+		 return true; 
+		// Non-generated code end
+	}
+
+	// LayoutEndIsland.indent
+	protected LayoutReef indent_value;
+	protected boolean indent_hasValue = false;
+	public LayoutReef indent() {
+		if (!indent_hasValue) {
+			indent_value = indent_compute();
+			indent_hasValue = true;
+		}
+		return indent_value;
+	}
+	protected LayoutReef indent_compute() {
+		LexicalNode pos = getPrevious();
+		int order = 1;
+		int hits = 1;
+		while (pos != null && hits <= order) {
+			Object find = pos.getPreviousOfType(LayoutReef.class);
+			if (find == null) {
+					pos = null;
+			} else if (hits == order) {
+				return (LayoutReef)find;
+			} else {
+				hits++;
+				pos = ((LayoutReef)find).getPrevious();
+			}
+		}
+		return null;
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/LayoutReef.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/LayoutReef.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/LayoutReef.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,89 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public abstract class LayoutReef extends Reef {
+
+	public LayoutReef(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	// LayoutReef.pos
+	protected int pos_value;
+	protected boolean pos_hasValue = false;
+	public int pos() {
+		if (!pos_hasValue) {
+			pos_value = pos_compute();
+			pos_hasValue = true;
+		}
+		return pos_value;
+	}
+	protected int pos_compute() {
+		// Non-generated code start
+		
+	int pos = 0;
+	char[] chars = value.toCharArray();
+	for (int i = chars.length-1; i >= 0; i--) {
+		switch(chars[i]) {
+			case ' '  : pos++; break;
+			case '\t' : pos += 4; break; // TAB_SIZE=4
+		}
+		if (chars[i] == '\n') {
+			break;
+		}
+	}
+	return pos;
+
+		// Non-generated code end
+	}
+
+	// LayoutReef.startOfEmptyLine
+	protected boolean startOfEmptyLine_value;
+	protected boolean startOfEmptyLine_hasValue = false;
+	public boolean startOfEmptyLine() {
+		if (!startOfEmptyLine_hasValue) {
+			startOfEmptyLine_value = startOfEmptyLine_compute();
+			startOfEmptyLine_hasValue = true;
+		}
+		return startOfEmptyLine_value;
+	}
+	protected boolean startOfEmptyLine_compute() {
+		// Non-generated code start
+		
+    return rightNeighbour() != null && rightNeighbour() instanceof LayoutReef;
+
+		// Non-generated code end
+	}
+
+	// LayoutReef.rightNeighbour
+	protected LexicalNode rightNeighbour_value;
+	protected boolean rightNeighbour_hasValue = false;
+	public LexicalNode rightNeighbour() {
+		if (!rightNeighbour_hasValue) {
+			rightNeighbour_value = rightNeighbour_compute();
+			rightNeighbour_hasValue = true;
+		}
+		return rightNeighbour_value;
+	}
+	protected LexicalNode rightNeighbour_compute() {
+		LexicalNode pos = getNext();
+		int order = 1;
+		int hits = 1;
+		while (pos != null && hits <= order) {
+			Object find = pos.getNextOfType(LexicalNode.class);
+			if (find == null) {
+					pos = null;
+			} else if (hits == order) {
+				return (LexicalNode)find;
+			} else {
+				hits++;
+				pos = ((LexicalNode)find).getNext();
+			}
+		}
+		return null;
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/LayoutStartIsland.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/LayoutStartIsland.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/LayoutStartIsland.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,97 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public abstract class LayoutStartIsland extends StartIsland {
+
+	public LayoutStartIsland(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isEndIsland(island)) {
+			LayoutEndIsland end = (LayoutEndIsland)island;
+			LayoutStartIsland start = this;
+			return 
+			((start.indent() == null && 0 == end.indent().pos()) || (start.indent() != null && start.indent().pos() == end.indent().pos()));
+		}
+		return false;
+	}
+
+	public boolean possibleConstructionSite(LexicalNode node) {
+		{
+			LayoutReef a = (node instanceof LayoutReef) ? (LayoutReef)node : null;
+			if (a != null && 
+			  (this.indent() != null && 
+			  (a.startOfEmptyLine() != true && a.pos() <= this.indent().pos()))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertBefore(newIsland, a);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		{
+			LayoutEndIsland b = (node instanceof LayoutEndIsland) ? (LayoutEndIsland)node : null;
+			if (b != null && 
+			  (b.indent() != null && this.indent() != null && 
+			  (b.hasBridge() && b.indent().pos() < this.indent().pos()))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertBefore(newIsland, b);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		return false;
+	}
+
+	public boolean isEndIsland(LexicalNode node) {
+		return node instanceof LayoutEndIsland;
+	}
+	// LayoutStartIsland.isStructural
+	protected boolean isStructural_value;
+	protected boolean isStructural_hasValue = false;
+	public boolean isStructural() {
+		if (!isStructural_hasValue) {
+			isStructural_value = isStructural_compute();
+			isStructural_hasValue = true;
+		}
+		return isStructural_value;
+	}
+	protected boolean isStructural_compute() {
+		// Non-generated code start
+		 return true; 
+		// Non-generated code end
+	}
+
+	// LayoutStartIsland.indent
+	protected LayoutReef indent_value;
+	protected boolean indent_hasValue = false;
+	public LayoutReef indent() {
+		if (!indent_hasValue) {
+			indent_value = indent_compute();
+			indent_hasValue = true;
+		}
+		return indent_value;
+	}
+	protected LayoutReef indent_compute() {
+		LexicalNode pos = getPrevious();
+		int order = 1;
+		int hits = 1;
+		while (pos != null && hits <= order) {
+			Object find = pos.getPreviousOfType(LayoutReef.class);
+			if (find == null) {
+					pos = null;
+			} else if (hits == order) {
+				return (LayoutReef)find;
+			} else {
+				hits++;
+				pos = ((LayoutReef)find).getPrevious();
+			}
+		}
+		return null;
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/MainBridgeParser.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/MainBridgeParser.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/MainBridgeParser.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,365 @@
+package java15;
+
+import java.io.*;
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class MainBridgeParser extends AbstractBridgeParser {
+
+	protected LexicalNode matchNode(char[] content, int curPos, int lastMatchPos, LexicalNode previous) {
+		// SwitchKeyword
+		if (matchForward(content, curPos, SwitchKeyword.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				SwitchKeyword.START_VALUE.length(), SwitchKeyword.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new SwitchKeyword(previous, interval, value);
+		}
+		// RBrace
+		if (matchForward(content, curPos, RBrace.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				RBrace.START_VALUE.length(), RBrace.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new RBrace(previous, interval, value);
+		}
+		// IfKeyword
+		if (matchForward(content, curPos, IfKeyword.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				IfKeyword.START_VALUE.length(), IfKeyword.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new IfKeyword(previous, interval, value);
+		}
+		// ImplementsKeyword
+		if (matchForward(content, curPos, ImplementsKeyword.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				ImplementsKeyword.START_VALUE.length(), ImplementsKeyword.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new ImplementsKeyword(previous, interval, value);
+		}
+		// CaseKeyword
+		if (matchForward(content, curPos, CaseKeyword.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				CaseKeyword.START_VALUE.length(), CaseKeyword.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new CaseKeyword(previous, interval, value);
+		}
+		// DoKeyword
+		if (matchForward(content, curPos, DoKeyword.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				DoKeyword.START_VALUE.length(), DoKeyword.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new DoKeyword(previous, interval, value);
+		}
+		// AssertKeyword
+		if (matchForward(content, curPos, AssertKeyword.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				AssertKeyword.START_VALUE.length(), AssertKeyword.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new AssertKeyword(previous, interval, value);
+		}
+		// SynchronizedKeyword
+		if (matchForward(content, curPos, SynchronizedKeyword.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				SynchronizedKeyword.START_VALUE.length(), SynchronizedKeyword.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new SynchronizedKeyword(previous, interval, value);
+		}
+		// VolatileKeyword
+		if (matchForward(content, curPos, VolatileKeyword.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				VolatileKeyword.START_VALUE.length(), VolatileKeyword.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new VolatileKeyword(previous, interval, value);
+		}
+		// PrivateKeyword
+		if (matchForward(content, curPos, PrivateKeyword.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				PrivateKeyword.START_VALUE.length(), PrivateKeyword.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new PrivateKeyword(previous, interval, value);
+		}
+		// LBrack
+		if (matchForward(content, curPos, LBrack.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				LBrack.START_VALUE.length(), LBrack.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new LBrack(previous, interval, value);
+		}
+		// LParen
+		if (matchForward(content, curPos, LParen.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				LParen.START_VALUE.length(), LParen.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new LParen(previous, interval, value);
+		}
+		// CatchKeyword
+		if (matchForward(content, curPos, CatchKeyword.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				CatchKeyword.START_VALUE.length(), CatchKeyword.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new CatchKeyword(previous, interval, value);
+		}
+		// ImportKeyword
+		if (matchForward(content, curPos, ImportKeyword.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				ImportKeyword.START_VALUE.length(), ImportKeyword.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new ImportKeyword(previous, interval, value);
+		}
+		// ClassKeyword
+		if (matchForward(content, curPos, ClassKeyword.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				ClassKeyword.START_VALUE.length(), ClassKeyword.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new ClassKeyword(previous, interval, value);
+		}
+		// ThrowsKeyword
+		if (matchForward(content, curPos, ThrowsKeyword.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				ThrowsKeyword.START_VALUE.length(), ThrowsKeyword.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new ThrowsKeyword(previous, interval, value);
+		}
+		// ReturnKeyword
+		if (matchForward(content, curPos, ReturnKeyword.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				ReturnKeyword.START_VALUE.length(), ReturnKeyword.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new ReturnKeyword(previous, interval, value);
+		}
+		// StaticKeyword
+		if (matchForward(content, curPos, StaticKeyword.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				StaticKeyword.START_VALUE.length(), StaticKeyword.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new StaticKeyword(previous, interval, value);
+		}
+		// ProtectedKeyword
+		if (matchForward(content, curPos, ProtectedKeyword.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				ProtectedKeyword.START_VALUE.length(), ProtectedKeyword.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new ProtectedKeyword(previous, interval, value);
+		}
+		// Layout
+		if (matchForward(content, curPos, Layout.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				Layout.START_VALUE.length(), Layout.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new Layout(previous, interval, value);
+		}
+		// RBrack
+		if (matchForward(content, curPos, RBrack.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				RBrack.START_VALUE.length(), RBrack.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new RBrack(previous, interval, value);
+		}
+		// PackageKeyword
+		if (matchForward(content, curPos, PackageKeyword.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				PackageKeyword.START_VALUE.length(), PackageKeyword.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new PackageKeyword(previous, interval, value);
+		}
+		// LBrace
+		if (matchForward(content, curPos, LBrace.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				LBrace.START_VALUE.length(), LBrace.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new LBrace(previous, interval, value);
+		}
+		// DefaultKeyword
+		if (matchForward(content, curPos, DefaultKeyword.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				DefaultKeyword.START_VALUE.length(), DefaultKeyword.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new DefaultKeyword(previous, interval, value);
+		}
+		// BreakKeyword
+		if (matchForward(content, curPos, BreakKeyword.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				BreakKeyword.START_VALUE.length(), BreakKeyword.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new BreakKeyword(previous, interval, value);
+		}
+		// ThrowKeyword
+		if (matchForward(content, curPos, ThrowKeyword.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				ThrowKeyword.START_VALUE.length(), ThrowKeyword.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new ThrowKeyword(previous, interval, value);
+		}
+		// ExtendsKeyword
+		if (matchForward(content, curPos, ExtendsKeyword.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				ExtendsKeyword.START_VALUE.length(), ExtendsKeyword.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new ExtendsKeyword(previous, interval, value);
+		}
+		// StrictfpKeyword
+		if (matchForward(content, curPos, StrictfpKeyword.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				StrictfpKeyword.START_VALUE.length(), StrictfpKeyword.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new StrictfpKeyword(previous, interval, value);
+		}
+		// ContinueKeyword
+		if (matchForward(content, curPos, ContinueKeyword.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				ContinueKeyword.START_VALUE.length(), ContinueKeyword.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new ContinueKeyword(previous, interval, value);
+		}
+		// TryKeyword
+		if (matchForward(content, curPos, TryKeyword.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				TryKeyword.START_VALUE.length(), TryKeyword.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new TryKeyword(previous, interval, value);
+		}
+		// FinallyKeyword
+		if (matchForward(content, curPos, FinallyKeyword.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				FinallyKeyword.START_VALUE.length(), FinallyKeyword.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new FinallyKeyword(previous, interval, value);
+		}
+		// InterfaceKeyword
+		if (matchForward(content, curPos, InterfaceKeyword.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				InterfaceKeyword.START_VALUE.length(), InterfaceKeyword.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new InterfaceKeyword(previous, interval, value);
+		}
+		// WhileKeyword
+		if (matchForward(content, curPos, WhileKeyword.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				WhileKeyword.START_VALUE.length(), WhileKeyword.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new WhileKeyword(previous, interval, value);
+		}
+		// PublicKeyword
+		if (matchForward(content, curPos, PublicKeyword.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				PublicKeyword.START_VALUE.length(), PublicKeyword.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new PublicKeyword(previous, interval, value);
+		}
+		// ForKeyword
+		if (matchForward(content, curPos, ForKeyword.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				ForKeyword.START_VALUE.length(), ForKeyword.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new ForKeyword(previous, interval, value);
+		}
+		// FinalKeyword
+		if (matchForward(content, curPos, FinalKeyword.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				FinalKeyword.START_VALUE.length(), FinalKeyword.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new FinalKeyword(previous, interval, value);
+		}
+		// NativeKeyword
+		if (matchForward(content, curPos, NativeKeyword.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				NativeKeyword.START_VALUE.length(), NativeKeyword.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new NativeKeyword(previous, interval, value);
+		}
+		// AbstractKeyword
+		if (matchForward(content, curPos, AbstractKeyword.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				AbstractKeyword.START_VALUE.length(), AbstractKeyword.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new AbstractKeyword(previous, interval, value);
+		}
+		// RParen
+		if (matchForward(content, curPos, RParen.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				RParen.START_VALUE.length(), RParen.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new RParen(previous, interval, value);
+		}
+		// ElseKeyword
+		if (matchForward(content, curPos, ElseKeyword.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				ElseKeyword.START_VALUE.length(), ElseKeyword.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new ElseKeyword(previous, interval, value);
+		}
+		// TransientKeyword
+		if (matchForward(content, curPos, TransientKeyword.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				TransientKeyword.START_VALUE.length(), TransientKeyword.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new TransientKeyword(previous, interval, value);
+		}
+		// EnumKeyword
+		if (matchForward(content, curPos, EnumKeyword.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				EnumKeyword.START_VALUE.length(), EnumKeyword.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new EnumKeyword(previous, interval, value);
+		}
+		return null;
+	}
+
+	protected LexicalNode matchIgnore(char[] content, int curPos, int lastMatchPos, LexicalNode previous) {
+		// String
+		if (matchForward(content, curPos, IgnoreString.START_VALUE)) {
+			int endPos = ignoreUntil(content, curPos + IgnoreString.START_VALUE.length(), IgnoreString.END_VALUE);
+			Interval interval = new Interval(curPos, endPos);
+			return new IgnoreString(previous, interval, new String(content, curPos, 
+				(endPos < content.length - 1) ? interval.getLength() + 1 : interval.getLength()));
+		}
+		// LineComment
+		if (matchForward(content, curPos, IgnoreLineComment.START_VALUE)) {
+			int endPos = ignoreUntil(content, curPos + IgnoreLineComment.START_VALUE.length(), IgnoreLineComment.END_VALUE);
+			Interval interval = new Interval(curPos, endPos);
+			return new IgnoreLineComment(previous, interval, new String(content, curPos, 
+				(endPos < content.length - 1) ? interval.getLength() + 1 : interval.getLength()));
+		}
+		// MultiComment
+		if (matchForward(content, curPos, IgnoreMultiComment.START_VALUE)) {
+			int endPos = ignoreUntil(content, curPos + IgnoreMultiComment.START_VALUE.length(), IgnoreMultiComment.END_VALUE);
+			Interval interval = new Interval(curPos, endPos);
+			return new IgnoreMultiComment(previous, interval, new String(content, curPos, 
+				(endPos < content.length - 1) ? interval.getLength() + 1 : interval.getLength()));
+		}
+		return null;
+	}
+
+	public static void main(String[] args) {
+		if (args.length != 1) {
+			System.err.println("usage: MainBridgeParser input-file");
+			System.exit(1);
+		}
+		
+		String filePath = args[0];
+		File file = new File(filePath);
+		if (!file.exists()) {
+			System.err.println("error: file does not exist [" + filePath + "]");
+			System.exit(2);
+		}
+		
+		StringBuffer buf = new StringBuffer();
+		try {
+			BufferedReader reader = new BufferedReader(new FileReader(file));
+			String line = null;
+			while ((line = reader.readLine()) != null) {
+				buf.append(line);
+			}
+			reader.close();
+		} catch (IOException e) {
+			System.err.println("error: problem reading from file [" + filePath + "]");
+			System.exit(3);
+		}
+		
+		IBridgeParser bp = new MainBridgeParser();
+		String result = bp.recover(buf.toString());
+		System.out.println("\nResult:\n[" + result + "]\n");
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/NativeKeyword.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/NativeKeyword.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/NativeKeyword.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class NativeKeyword extends Reef {
+
+	public static final String START_VALUE = "native";
+	public static final String MATCH_REG_EXP = "native";
+	public NativeKeyword(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new NativeKeyword(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/PackageKeyword.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/PackageKeyword.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/PackageKeyword.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class PackageKeyword extends Reef {
+
+	public static final String START_VALUE = "package";
+	public static final String MATCH_REG_EXP = "package";
+	public PackageKeyword(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new PackageKeyword(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/PrivateKeyword.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/PrivateKeyword.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/PrivateKeyword.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class PrivateKeyword extends Reef {
+
+	public static final String START_VALUE = "private";
+	public static final String MATCH_REG_EXP = "private";
+	public PrivateKeyword(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new PrivateKeyword(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ProtectedKeyword.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ProtectedKeyword.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ProtectedKeyword.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class ProtectedKeyword extends Reef {
+
+	public static final String START_VALUE = "protected";
+	public static final String MATCH_REG_EXP = "protected";
+	public ProtectedKeyword(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new ProtectedKeyword(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/PublicKeyword.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/PublicKeyword.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/PublicKeyword.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class PublicKeyword extends Reef {
+
+	public static final String START_VALUE = "public";
+	public static final String MATCH_REG_EXP = "public";
+	public PublicKeyword(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new PublicKeyword(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/RBrace.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/RBrace.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/RBrace.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,37 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class RBrace extends LayoutEndIsland {
+
+	public static final String START_VALUE = "}";
+	public static final String MATCH_REG_EXP = "\\}";
+	public static final String VALUE = "}";
+	public RBrace(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new RBrace(previous, getInterval().clone(), value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isStartIsland(island)) {
+			LBrace start = (LBrace)island;
+			RBrace end = this;
+			return super.bridgeMatch(island, tol);
+		}
+		return false;
+	}
+
+	public boolean isStartIsland(LexicalNode node) {
+		return node instanceof LBrace;
+	}
+	public StartIsland createStartIsland(Interval interval) {
+		LBrace node = new LBrace(null, interval, LBrace.VALUE);
+		return node;
+	}
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/RBrack.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/RBrack.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/RBrack.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,37 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class RBrack extends SimpleEndIsland {
+
+	public static final String START_VALUE = "]";
+	public static final String MATCH_REG_EXP = "\\]";
+	public static final String VALUE = "]";
+	public RBrack(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new RBrack(previous, getInterval().clone(), value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isStartIsland(island)) {
+			LBrack start = (LBrack)island;
+			RBrack end = this;
+			return super.bridgeMatch(island, tol);
+		}
+		return false;
+	}
+
+	public boolean isStartIsland(LexicalNode node) {
+		return node instanceof LBrack;
+	}
+	public StartIsland createStartIsland(Interval interval) {
+		LBrack node = new LBrack(null, interval, LBrack.VALUE);
+		return node;
+	}
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/RParen.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/RParen.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/RParen.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,37 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class RParen extends SimpleEndIsland {
+
+	public static final String START_VALUE = ")";
+	public static final String MATCH_REG_EXP = "\\)";
+	public static final String VALUE = ")";
+	public RParen(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new RParen(previous, getInterval().clone(), value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isStartIsland(island)) {
+			LParen start = (LParen)island;
+			RParen end = this;
+			return super.bridgeMatch(island, tol);
+		}
+		return false;
+	}
+
+	public boolean isStartIsland(LexicalNode node) {
+		return node instanceof LParen;
+	}
+	public StartIsland createStartIsland(Interval interval) {
+		LParen node = new LParen(null, interval, LParen.VALUE);
+		return node;
+	}
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ReturnKeyword.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ReturnKeyword.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ReturnKeyword.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class ReturnKeyword extends Reef {
+
+	public static final String START_VALUE = "return";
+	public static final String MATCH_REG_EXP = "return";
+	public ReturnKeyword(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new ReturnKeyword(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/SimpleEndIsland.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/SimpleEndIsland.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/SimpleEndIsland.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,72 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public abstract class SimpleEndIsland extends LayoutEndIsland {
+
+	public SimpleEndIsland(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isStartIsland(island)) {
+			SimpleStartIsland start = (SimpleStartIsland)island;
+			SimpleEndIsland end = this;
+			return 
+			(true);
+		}
+		return false;
+	}
+
+	public boolean possibleConstructionSite(LexicalNode node) {
+		{
+			Reef a = (node instanceof Reef) ? (Reef)node : null;
+			if (a != null && 
+			  (
+			  (true))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertAfter(newIsland, a);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		{
+			LayoutEndIsland a = (node instanceof LayoutEndIsland) ? (LayoutEndIsland)node : null;
+			if (a != null && 
+			  (
+			  (a.isStructural()))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertAfter(newIsland, a);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		if (super.possibleConstructionSite(node)) {
+			return true;
+		}
+		return false;
+	}
+
+	public boolean isStartIsland(LexicalNode node) {
+		return node instanceof SimpleStartIsland;
+	}
+	// SimpleEndIsland.isStructural
+	protected boolean isStructural_value;
+	protected boolean isStructural_hasValue = false;
+	public boolean isStructural() {
+		if (!isStructural_hasValue) {
+			isStructural_value = isStructural_compute();
+			isStructural_hasValue = true;
+		}
+		return isStructural_value;
+	}
+	protected boolean isStructural_compute() {
+		// Non-generated code start
+		 return false; 
+		// Non-generated code end
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/SimpleStartIsland.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/SimpleStartIsland.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/SimpleStartIsland.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,72 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public abstract class SimpleStartIsland extends LayoutStartIsland {
+
+	public SimpleStartIsland(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public boolean bridgeMatch(Island island, int tol) {
+		if (isEndIsland(island)) {
+			SimpleEndIsland end = (SimpleEndIsland)island;
+			SimpleStartIsland start = this;
+			return 
+			(true);
+		}
+		return false;
+	}
+
+	public boolean possibleConstructionSite(LexicalNode node) {
+		{
+			Reef a = (node instanceof Reef) ? (Reef)node : null;
+			if (a != null && 
+			  (
+			  (true))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertBefore(newIsland, a);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		{
+			LayoutStartIsland a = (node instanceof LayoutStartIsland) ? (LayoutStartIsland)node : null;
+			if (a != null && 
+			  (
+			  (a.isStructural()))) {
+				Island newIsland = constructFakeIsland(node, false);
+				RecoveryHelper.insertBefore(newIsland, a);
+				newIsland.buildBridge(this, -1);
+				return true;
+			}
+		}
+		if (super.possibleConstructionSite(node)) {
+			return true;
+		}
+		return false;
+	}
+
+	public boolean isEndIsland(LexicalNode node) {
+		return node instanceof SimpleEndIsland;
+	}
+	// SimpleStartIsland.isStructural
+	protected boolean isStructural_value;
+	protected boolean isStructural_hasValue = false;
+	public boolean isStructural() {
+		if (!isStructural_hasValue) {
+			isStructural_value = isStructural_compute();
+			isStructural_hasValue = true;
+		}
+		return isStructural_value;
+	}
+	protected boolean isStructural_compute() {
+		// Non-generated code start
+		 return false; 
+		// Non-generated code end
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/StaticKeyword.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/StaticKeyword.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/StaticKeyword.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class StaticKeyword extends Reef {
+
+	public static final String START_VALUE = "static";
+	public static final String MATCH_REG_EXP = "static";
+	public StaticKeyword(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new StaticKeyword(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/StrictfpKeyword.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/StrictfpKeyword.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/StrictfpKeyword.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class StrictfpKeyword extends Reef {
+
+	public static final String START_VALUE = "strictfp";
+	public static final String MATCH_REG_EXP = "strictfp";
+	public StrictfpKeyword(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new StrictfpKeyword(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/SwitchKeyword.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/SwitchKeyword.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/SwitchKeyword.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class SwitchKeyword extends Reef {
+
+	public static final String START_VALUE = "switch";
+	public static final String MATCH_REG_EXP = "switch";
+	public SwitchKeyword(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new SwitchKeyword(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/SynchronizedKeyword.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/SynchronizedKeyword.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/SynchronizedKeyword.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class SynchronizedKeyword extends Reef {
+
+	public static final String START_VALUE = "synchronized";
+	public static final String MATCH_REG_EXP = "synchronized";
+	public SynchronizedKeyword(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new SynchronizedKeyword(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ThrowKeyword.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ThrowKeyword.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ThrowKeyword.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class ThrowKeyword extends Reef {
+
+	public static final String START_VALUE = "throw";
+	public static final String MATCH_REG_EXP = "throw";
+	public ThrowKeyword(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new ThrowKeyword(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ThrowsKeyword.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ThrowsKeyword.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/ThrowsKeyword.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class ThrowsKeyword extends Reef {
+
+	public static final String START_VALUE = "throws";
+	public static final String MATCH_REG_EXP = "throws";
+	public ThrowsKeyword(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new ThrowsKeyword(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/TransientKeyword.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/TransientKeyword.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/TransientKeyword.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class TransientKeyword extends Reef {
+
+	public static final String START_VALUE = "transient";
+	public static final String MATCH_REG_EXP = "transient";
+	public TransientKeyword(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new TransientKeyword(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/TryKeyword.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/TryKeyword.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/TryKeyword.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class TryKeyword extends Reef {
+
+	public static final String START_VALUE = "try";
+	public static final String MATCH_REG_EXP = "try";
+	public TryKeyword(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new TryKeyword(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/VolatileKeyword.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/VolatileKeyword.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/VolatileKeyword.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class VolatileKeyword extends Reef {
+
+	public static final String START_VALUE = "volatile";
+	public static final String MATCH_REG_EXP = "volatile";
+	public VolatileKeyword(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new VolatileKeyword(previous, getInterval().clone(), value);
+	}
+
+}

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/WhileKeyword.class
==============================================================================
Binary file. No diff available.

Added: sglr-recovery/trunk/bridge-definitions/grammars/java/java15/WhileKeyword.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/java15/WhileKeyword.java	Thu Jun  9 09:04:38 2011	(r23033)
@@ -0,0 +1,20 @@
+package java15;
+
+import org.bridget.rt.*;
+import org.bridget.rt.log.*;
+import org.bridget.rt.model.*;
+import org.bridget.rt.recovery.*;
+
+public class WhileKeyword extends Reef {
+
+	public static final String START_VALUE = "while";
+	public static final String MATCH_REG_EXP = "while";
+	public WhileKeyword(LexicalNode previous, Interval interval, String value) {
+		super(previous, interval, value);
+	}
+
+	public LexicalNode clone(LexicalNode previous) {
+		return new WhileKeyword(previous, getInterval().clone(), value);
+	}
+
+}

From emma at cs.lth.se  Thu Jun  9 14:35:44 2011
From: emma at cs.lth.se (Emma Nilsson-Nyman)
Date: Thu, 09 Jun 2011 12:35:44 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23034 - in
	sglr-recovery/trunk/bridge-definitions/grammars/generated: .
	java15 javasql strategojava webdsl
Message-ID: <20110609123544.AD0162B800B@mx2.tudelft.nl>

Author: EmmaNilssonNyman
Date: Thu Jun  9 12:35:38 2011
New Revision: 23034
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23034&sc=1

Log:
bug fix

Modified:
   sglr-recovery/trunk/bridge-definitions/grammars/generated/bridget.jar
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java15.jar
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/MainBridgeParser.class
   sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/MainBridgeParser.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql.jar
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LayoutReef.class
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LayoutReef.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LayoutStartIsland.class
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LayoutStartIsland.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/MainBridgeParser.class
   sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/MainBridgeParser.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava.jar
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/MainBridgeParser.class
   sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/MainBridgeParser.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl.jar
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LayoutEndIsland.class
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LayoutEndIsland.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LayoutReef.class
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LayoutReef.java
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/MainBridgeParser.class
   sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/MainBridgeParser.java

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/bridget.jar
==============================================================================
Binary file (source and/or target). No diff available.

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/java15.jar
==============================================================================
Binary file (source and/or target). No diff available.

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/MainBridgeParser.class
==============================================================================
Binary file (source and/or target). No diff available.

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/MainBridgeParser.java
==============================================================================
--- sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/MainBridgeParser.java	Thu Jun  9 09:04:38 2011	(r23033)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/java15/MainBridgeParser.java	Thu Jun  9 12:35:38 2011	(r23034)
@@ -62,14 +62,14 @@
 	}
 
 	protected LexicalNode matchIgnore(char[] content, int curPos, int lastMatchPos, LexicalNode previous) {
-		// LineComment
-		if (matchForward(content, curPos, IgnoreLineComment.START_VALUE)) {
-			int endPos = ignoreUntil(content, curPos + IgnoreLineComment.START_VALUE.length(), IgnoreLineComment.END_VALUE);
-			if (IgnoreLineComment.END_VALUE.equals("\n")) {
+		// MultiComment
+		if (matchForward(content, curPos, IgnoreMultiComment.START_VALUE)) {
+			int endPos = ignoreUntil(content, curPos + IgnoreMultiComment.START_VALUE.length(), IgnoreMultiComment.END_VALUE);
+			if (IgnoreMultiComment.END_VALUE.equals("\n")) {
 				endPos--;
 			}
 			Interval interval = new Interval(curPos, endPos);
-			return new IgnoreLineComment(previous, interval, new String(content, curPos, 
+			return new IgnoreMultiComment(previous, interval, new String(content, curPos, 
 				(endPos < content.length - 1) ? interval.getLength() + 1 : interval.getLength()));
 		}
 		// String
@@ -82,14 +82,14 @@
 			return new IgnoreString(previous, interval, new String(content, curPos, 
 				(endPos < content.length - 1) ? interval.getLength() + 1 : interval.getLength()));
 		}
-		// MultiComment
-		if (matchForward(content, curPos, IgnoreMultiComment.START_VALUE)) {
-			int endPos = ignoreUntil(content, curPos + IgnoreMultiComment.START_VALUE.length(), IgnoreMultiComment.END_VALUE);
-			if (IgnoreMultiComment.END_VALUE.equals("\n")) {
+		// LineComment
+		if (matchForward(content, curPos, IgnoreLineComment.START_VALUE)) {
+			int endPos = ignoreUntil(content, curPos + IgnoreLineComment.START_VALUE.length(), IgnoreLineComment.END_VALUE);
+			if (IgnoreLineComment.END_VALUE.equals("\n")) {
 				endPos--;
 			}
 			Interval interval = new Interval(curPos, endPos);
-			return new IgnoreMultiComment(previous, interval, new String(content, curPos, 
+			return new IgnoreLineComment(previous, interval, new String(content, curPos, 
 				(endPos < content.length - 1) ? interval.getLength() + 1 : interval.getLength()));
 		}
 		return null;

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql.jar
==============================================================================
Binary file (source and/or target). No diff available.

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LayoutReef.class
==============================================================================
Binary file (source and/or target). No diff available.

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LayoutReef.java
==============================================================================
--- sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LayoutReef.java	Thu Jun  9 09:04:38 2011	(r23033)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LayoutReef.java	Thu Jun  9 12:35:38 2011	(r23034)
@@ -40,24 +40,6 @@
 		// Non-generated code end
 	}
 
-	// LayoutReef.startOfEmptyLine
-	protected boolean startOfEmptyLine_value;
-	protected boolean startOfEmptyLine_hasValue = false;
-	public boolean startOfEmptyLine() {
-		if (!startOfEmptyLine_hasValue) {
-			startOfEmptyLine_value = startOfEmptyLine_compute();
-			startOfEmptyLine_hasValue = true;
-		}
-		return startOfEmptyLine_value;
-	}
-	protected boolean startOfEmptyLine_compute() {
-		// Non-generated code start
-		
-    return rightNeighbour() != null && rightNeighbour() instanceof LayoutReef;
-
-		// Non-generated code end
-	}
-
 	// LayoutReef.rightNeighbour
 	protected LexicalNode rightNeighbour_value;
 	protected boolean rightNeighbour_hasValue = false;
@@ -86,4 +68,22 @@
 		return null;
 	}
 
+	// LayoutReef.startOfEmptyLine
+	protected boolean startOfEmptyLine_value;
+	protected boolean startOfEmptyLine_hasValue = false;
+	public boolean startOfEmptyLine() {
+		if (!startOfEmptyLine_hasValue) {
+			startOfEmptyLine_value = startOfEmptyLine_compute();
+			startOfEmptyLine_hasValue = true;
+		}
+		return startOfEmptyLine_value;
+	}
+	protected boolean startOfEmptyLine_compute() {
+		// Non-generated code start
+		
+    return rightNeighbour() != null && rightNeighbour() instanceof LayoutReef;
+
+		// Non-generated code end
+	}
+
 }

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LayoutStartIsland.class
==============================================================================
Binary file (source and/or target). No diff available.

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LayoutStartIsland.java
==============================================================================
--- sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LayoutStartIsland.java	Thu Jun  9 09:04:38 2011	(r23033)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/LayoutStartIsland.java	Thu Jun  9 12:35:38 2011	(r23034)
@@ -50,22 +50,6 @@
 	public boolean isEndIsland(LexicalNode node) {
 		return node instanceof LayoutEndIsland;
 	}
-	// LayoutStartIsland.isStructural
-	protected boolean isStructural_value;
-	protected boolean isStructural_hasValue = false;
-	public boolean isStructural() {
-		if (!isStructural_hasValue) {
-			isStructural_value = isStructural_compute();
-			isStructural_hasValue = true;
-		}
-		return isStructural_value;
-	}
-	protected boolean isStructural_compute() {
-		// Non-generated code start
-		 return true; 
-		// Non-generated code end
-	}
-
 	// LayoutStartIsland.indent
 	protected LayoutReef indent_value;
 	protected boolean indent_hasValue = false;
@@ -94,4 +78,20 @@
 		return null;
 	}
 
+	// LayoutStartIsland.isStructural
+	protected boolean isStructural_value;
+	protected boolean isStructural_hasValue = false;
+	public boolean isStructural() {
+		if (!isStructural_hasValue) {
+			isStructural_value = isStructural_compute();
+			isStructural_hasValue = true;
+		}
+		return isStructural_value;
+	}
+	protected boolean isStructural_compute() {
+		// Non-generated code start
+		 return true; 
+		// Non-generated code end
+	}
+
 }

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/MainBridgeParser.class
==============================================================================
Binary file (source and/or target). No diff available.

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/MainBridgeParser.java
==============================================================================
--- sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/MainBridgeParser.java	Thu Jun  9 09:04:38 2011	(r23033)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/javasql/MainBridgeParser.java	Thu Jun  9 12:35:38 2011	(r23034)
@@ -9,13 +9,6 @@
 public class MainBridgeParser extends AbstractBridgeParser {
 
 	protected LexicalNode matchNode(char[] content, int curPos, int lastMatchPos, LexicalNode previous) {
-		// RSQL
-		if (matchForward(content, curPos, RSQL.START_VALUE)) {
-			String value = extendMatch(content, curPos, 
-				RSQL.START_VALUE.length(), RSQL.MATCH_REG_EXP);
-			Interval interval = new Interval(curPos, curPos + value.length() - 1);
-			return new RSQL(previous, interval, value);
-		}
 		// LSQL
 		if (matchForward(content, curPos, LSQL.START_VALUE)) {
 			String value = extendMatch(content, curPos, 
@@ -23,19 +16,12 @@
 			Interval interval = new Interval(curPos, curPos + value.length() - 1);
 			return new LSQL(previous, interval, value);
 		}
-		// Layout
-		if (matchForward(content, curPos, Layout.START_VALUE)) {
-			String value = extendMatch(content, curPos, 
-				Layout.START_VALUE.length(), Layout.MATCH_REG_EXP);
-			Interval interval = new Interval(curPos, curPos + value.length() - 1);
-			return new Layout(previous, interval, value);
-		}
-		// LParen
-		if (matchForward(content, curPos, LParen.START_VALUE)) {
+		// RSQL
+		if (matchForward(content, curPos, RSQL.START_VALUE)) {
 			String value = extendMatch(content, curPos, 
-				LParen.START_VALUE.length(), LParen.MATCH_REG_EXP);
+				RSQL.START_VALUE.length(), RSQL.MATCH_REG_EXP);
 			Interval interval = new Interval(curPos, curPos + value.length() - 1);
-			return new LParen(previous, interval, value);
+			return new RSQL(previous, interval, value);
 		}
 		// LBrace
 		if (matchForward(content, curPos, LBrace.START_VALUE)) {
@@ -51,13 +37,6 @@
 			Interval interval = new Interval(curPos, curPos + value.length() - 1);
 			return new RParen(previous, interval, value);
 		}
-		// LBrack
-		if (matchForward(content, curPos, LBrack.START_VALUE)) {
-			String value = extendMatch(content, curPos, 
-				LBrack.START_VALUE.length(), LBrack.MATCH_REG_EXP);
-			Interval interval = new Interval(curPos, curPos + value.length() - 1);
-			return new LBrack(previous, interval, value);
-		}
 		// RBrace
 		if (matchForward(content, curPos, RBrace.START_VALUE)) {
 			String value = extendMatch(content, curPos, 
@@ -65,6 +44,13 @@
 			Interval interval = new Interval(curPos, curPos + value.length() - 1);
 			return new RBrace(previous, interval, value);
 		}
+		// Layout
+		if (matchForward(content, curPos, Layout.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				Layout.START_VALUE.length(), Layout.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new Layout(previous, interval, value);
+		}
 		// RBrack
 		if (matchForward(content, curPos, RBrack.START_VALUE)) {
 			String value = extendMatch(content, curPos, 
@@ -72,20 +58,24 @@
 			Interval interval = new Interval(curPos, curPos + value.length() - 1);
 			return new RBrack(previous, interval, value);
 		}
+		// LBrack
+		if (matchForward(content, curPos, LBrack.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				LBrack.START_VALUE.length(), LBrack.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new LBrack(previous, interval, value);
+		}
+		// LParen
+		if (matchForward(content, curPos, LParen.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				LParen.START_VALUE.length(), LParen.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new LParen(previous, interval, value);
+		}
 		return null;
 	}
 
 	protected LexicalNode matchIgnore(char[] content, int curPos, int lastMatchPos, LexicalNode previous) {
-		// MultiComment
-		if (matchForward(content, curPos, IgnoreMultiComment.START_VALUE)) {
-			int endPos = ignoreUntil(content, curPos + IgnoreMultiComment.START_VALUE.length(), IgnoreMultiComment.END_VALUE);
-			if (IgnoreMultiComment.END_VALUE.equals("\n")) {
-				endPos--;
-			}
-			Interval interval = new Interval(curPos, endPos);
-			return new IgnoreMultiComment(previous, interval, new String(content, curPos, 
-				(endPos < content.length - 1) ? interval.getLength() + 1 : interval.getLength()));
-		}
 		// LineComment
 		if (matchForward(content, curPos, IgnoreLineComment.START_VALUE)) {
 			int endPos = ignoreUntil(content, curPos + IgnoreLineComment.START_VALUE.length(), IgnoreLineComment.END_VALUE);
@@ -106,6 +96,16 @@
 			return new IgnoreString(previous, interval, new String(content, curPos, 
 				(endPos < content.length - 1) ? interval.getLength() + 1 : interval.getLength()));
 		}
+		// MultiComment
+		if (matchForward(content, curPos, IgnoreMultiComment.START_VALUE)) {
+			int endPos = ignoreUntil(content, curPos + IgnoreMultiComment.START_VALUE.length(), IgnoreMultiComment.END_VALUE);
+			if (IgnoreMultiComment.END_VALUE.equals("\n")) {
+				endPos--;
+			}
+			Interval interval = new Interval(curPos, endPos);
+			return new IgnoreMultiComment(previous, interval, new String(content, curPos, 
+				(endPos < content.length - 1) ? interval.getLength() + 1 : interval.getLength()));
+		}
 		return null;
 	}
 

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava.jar
==============================================================================
Binary file (source and/or target). No diff available.

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/MainBridgeParser.class
==============================================================================
Binary file (source and/or target). No diff available.

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/MainBridgeParser.java
==============================================================================
--- sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/MainBridgeParser.java	Thu Jun  9 09:04:38 2011	(r23033)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/strategojava/MainBridgeParser.java	Thu Jun  9 12:35:38 2011	(r23034)
@@ -76,16 +76,6 @@
 	}
 
 	protected LexicalNode matchIgnore(char[] content, int curPos, int lastMatchPos, LexicalNode previous) {
-		// MultiComment
-		if (matchForward(content, curPos, IgnoreMultiComment.START_VALUE)) {
-			int endPos = ignoreUntil(content, curPos + IgnoreMultiComment.START_VALUE.length(), IgnoreMultiComment.END_VALUE);
-			if (IgnoreMultiComment.END_VALUE.equals("\n")) {
-				endPos--;
-			}
-			Interval interval = new Interval(curPos, endPos);
-			return new IgnoreMultiComment(previous, interval, new String(content, curPos, 
-				(endPos < content.length - 1) ? interval.getLength() + 1 : interval.getLength()));
-		}
 		// LineComment
 		if (matchForward(content, curPos, IgnoreLineComment.START_VALUE)) {
 			int endPos = ignoreUntil(content, curPos + IgnoreLineComment.START_VALUE.length(), IgnoreLineComment.END_VALUE);
@@ -106,6 +96,16 @@
 			return new IgnoreString(previous, interval, new String(content, curPos, 
 				(endPos < content.length - 1) ? interval.getLength() + 1 : interval.getLength()));
 		}
+		// MultiComment
+		if (matchForward(content, curPos, IgnoreMultiComment.START_VALUE)) {
+			int endPos = ignoreUntil(content, curPos + IgnoreMultiComment.START_VALUE.length(), IgnoreMultiComment.END_VALUE);
+			if (IgnoreMultiComment.END_VALUE.equals("\n")) {
+				endPos--;
+			}
+			Interval interval = new Interval(curPos, endPos);
+			return new IgnoreMultiComment(previous, interval, new String(content, curPos, 
+				(endPos < content.length - 1) ? interval.getLength() + 1 : interval.getLength()));
+		}
 		return null;
 	}
 

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl.jar
==============================================================================
Binary file (source and/or target). No diff available.

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LayoutEndIsland.class
==============================================================================
Binary file (source and/or target). No diff available.

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LayoutEndIsland.java
==============================================================================
--- sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LayoutEndIsland.java	Thu Jun  9 09:04:38 2011	(r23033)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LayoutEndIsland.java	Thu Jun  9 12:35:38 2011	(r23034)
@@ -51,6 +51,22 @@
 	public boolean isStartIsland(LexicalNode node) {
 		return node instanceof LayoutStartIsland;
 	}
+	// LayoutEndIsland.isStructural
+	protected boolean isStructural_value;
+	protected boolean isStructural_hasValue = false;
+	public boolean isStructural() {
+		if (!isStructural_hasValue) {
+			isStructural_value = isStructural_compute();
+			isStructural_hasValue = true;
+		}
+		return isStructural_value;
+	}
+	protected boolean isStructural_compute() {
+		// Non-generated code start
+		 return true; 
+		// Non-generated code end
+	}
+
 	// LayoutEndIsland.indent
 	protected LayoutReef indent_value;
 	protected boolean indent_hasValue = false;
@@ -79,20 +95,4 @@
 		return null;
 	}
 
-	// LayoutEndIsland.isStructural
-	protected boolean isStructural_value;
-	protected boolean isStructural_hasValue = false;
-	public boolean isStructural() {
-		if (!isStructural_hasValue) {
-			isStructural_value = isStructural_compute();
-			isStructural_hasValue = true;
-		}
-		return isStructural_value;
-	}
-	protected boolean isStructural_compute() {
-		// Non-generated code start
-		 return true; 
-		// Non-generated code end
-	}
-
 }

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LayoutReef.class
==============================================================================
Binary file (source and/or target). No diff available.

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LayoutReef.java
==============================================================================
--- sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LayoutReef.java	Thu Jun  9 09:04:38 2011	(r23033)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/LayoutReef.java	Thu Jun  9 12:35:38 2011	(r23034)
@@ -11,6 +11,35 @@
 		super(previous, interval, value);
 	}
 
+	// LayoutReef.pos
+	protected int pos_value;
+	protected boolean pos_hasValue = false;
+	public int pos() {
+		if (!pos_hasValue) {
+			pos_value = pos_compute();
+			pos_hasValue = true;
+		}
+		return pos_value;
+	}
+	protected int pos_compute() {
+		// Non-generated code start
+		
+	int pos = 0;
+	char[] chars = value.toCharArray();
+	for (int i = chars.length-1; i >= 0; i--) {
+		switch(chars[i]) {
+			case ' '  : pos++; break;
+			case '\t' : pos += 4; break; // TAB_SIZE=4
+		}
+		if (chars[i] == '\n') {
+			break;
+		}
+	}
+	return pos;
+
+		// Non-generated code end
+	}
+
 	// LayoutReef.rightNeighbour
 	protected LexicalNode rightNeighbour_value;
 	protected boolean rightNeighbour_hasValue = false;
@@ -56,34 +85,5 @@
 
 		// Non-generated code end
 	}
-
-	// LayoutReef.pos
-	protected int pos_value;
-	protected boolean pos_hasValue = false;
-	public int pos() {
-		if (!pos_hasValue) {
-			pos_value = pos_compute();
-			pos_hasValue = true;
-		}
-		return pos_value;
-	}
-	protected int pos_compute() {
-		// Non-generated code start
-		
-	int pos = 0;
-	char[] chars = value.toCharArray();
-	for (int i = chars.length-1; i >= 0; i--) {
-		switch(chars[i]) {
-			case ' '  : pos++; break;
-			case '\t' : pos += 4; break; // TAB_SIZE=4
-		}
-		if (chars[i] == '\n') {
-			break;
-		}
-	}
-	return pos;
-
-		// Non-generated code end
-	}
 
 }

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/MainBridgeParser.class
==============================================================================
Binary file (source and/or target). No diff available.

Modified: sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/MainBridgeParser.java
==============================================================================
--- sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/MainBridgeParser.java	Thu Jun  9 09:04:38 2011	(r23033)
+++ sglr-recovery/trunk/bridge-definitions/grammars/generated/webdsl/MainBridgeParser.java	Thu Jun  9 12:35:38 2011	(r23034)
@@ -9,12 +9,19 @@
 public class MainBridgeParser extends AbstractBridgeParser {
 
 	protected LexicalNode matchNode(char[] content, int curPos, int lastMatchPos, LexicalNode previous) {
-		// RBrace
-		if (matchForward(content, curPos, RBrace.START_VALUE)) {
+		// LBrace
+		if (matchForward(content, curPos, LBrace.START_VALUE)) {
 			String value = extendMatch(content, curPos, 
-				RBrace.START_VALUE.length(), RBrace.MATCH_REG_EXP);
+				LBrace.START_VALUE.length(), LBrace.MATCH_REG_EXP);
 			Interval interval = new Interval(curPos, curPos + value.length() - 1);
-			return new RBrace(previous, interval, value);
+			return new LBrace(previous, interval, value);
+		}
+		// LBrack
+		if (matchForward(content, curPos, LBrack.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				LBrack.START_VALUE.length(), LBrack.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new LBrack(previous, interval, value);
 		}
 		// RBrack
 		if (matchForward(content, curPos, RBrack.START_VALUE)) {
@@ -23,6 +30,13 @@
 			Interval interval = new Interval(curPos, curPos + value.length() - 1);
 			return new RBrack(previous, interval, value);
 		}
+		// RParen
+		if (matchForward(content, curPos, RParen.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				RParen.START_VALUE.length(), RParen.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new RParen(previous, interval, value);
+		}
 		// LParen
 		if (matchForward(content, curPos, LParen.START_VALUE)) {
 			String value = extendMatch(content, curPos, 
@@ -30,6 +44,13 @@
 			Interval interval = new Interval(curPos, curPos + value.length() - 1);
 			return new LParen(previous, interval, value);
 		}
+		// RBrace
+		if (matchForward(content, curPos, RBrace.START_VALUE)) {
+			String value = extendMatch(content, curPos, 
+				RBrace.START_VALUE.length(), RBrace.MATCH_REG_EXP);
+			Interval interval = new Interval(curPos, curPos + value.length() - 1);
+			return new RBrace(previous, interval, value);
+		}
 		// Layout
 		if (matchForward(content, curPos, Layout.START_VALUE)) {
 			String value = extendMatch(content, curPos, 
@@ -37,27 +58,6 @@
 			Interval interval = new Interval(curPos, curPos + value.length() - 1);
 			return new Layout(previous, interval, value);
 		}
-		// RParen
-		if (matchForward(content, curPos, RParen.START_VALUE)) {
-			String value = extendMatch(content, curPos, 
-				RParen.START_VALUE.length(), RParen.MATCH_REG_EXP);
-			Interval interval = new Interval(curPos, curPos + value.length() - 1);
-			return new RParen(previous, interval, value);
-		}
-		// LBrack
-		if (matchForward(content, curPos, LBrack.START_VALUE)) {
-			String value = extendMatch(content, curPos, 
-				LBrack.START_VALUE.length(), LBrack.MATCH_REG_EXP);
-			Interval interval = new Interval(curPos, curPos + value.length() - 1);
-			return new LBrack(previous, interval, value);
-		}
-		// LBrace
-		if (matchForward(content, curPos, LBrace.START_VALUE)) {
-			String value = extendMatch(content, curPos, 
-				LBrace.START_VALUE.length(), LBrace.MATCH_REG_EXP);
-			Interval interval = new Interval(curPos, curPos + value.length() - 1);
-			return new LBrace(previous, interval, value);
-		}
 		return null;
 	}
 
@@ -72,16 +72,6 @@
 			return new IgnoreScript(previous, interval, new String(content, curPos, 
 				(endPos < content.length - 1) ? interval.getLength() + 1 : interval.getLength()));
 		}
-		// MultiComment
-		if (matchForward(content, curPos, IgnoreMultiComment.START_VALUE)) {
-			int endPos = ignoreUntil(content, curPos + IgnoreMultiComment.START_VALUE.length(), IgnoreMultiComment.END_VALUE);
-			if (IgnoreMultiComment.END_VALUE.equals("\n")) {
-				endPos--;
-			}
-			Interval interval = new Interval(curPos, endPos);
-			return new IgnoreMultiComment(previous, interval, new String(content, curPos, 
-				(endPos < content.length - 1) ? interval.getLength() + 1 : interval.getLength()));
-		}
 		// String
 		if (matchForward(content, curPos, IgnoreString.START_VALUE)) {
 			int endPos = ignoreUntil(content, curPos + IgnoreString.START_VALUE.length(), IgnoreString.END_VALUE);
@@ -102,6 +92,16 @@
 			return new IgnoreLineComment(previous, interval, new String(content, curPos, 
 				(endPos < content.length - 1) ? interval.getLength() + 1 : interval.getLength()));
 		}
+		// MultiComment
+		if (matchForward(content, curPos, IgnoreMultiComment.START_VALUE)) {
+			int endPos = ignoreUntil(content, curPos + IgnoreMultiComment.START_VALUE.length(), IgnoreMultiComment.END_VALUE);
+			if (IgnoreMultiComment.END_VALUE.equals("\n")) {
+				endPos--;
+			}
+			Interval interval = new Interval(curPos, endPos);
+			return new IgnoreMultiComment(previous, interval, new String(content, curPos, 
+				(endPos < content.length - 1) ? interval.getLength() + 1 : interval.getLength()));
+		}
 		return null;
 	}
 

From m.dejonge at tudelft.nl  Fri Jun 10 10:55:25 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Fri, 10 Jun 2011 08:55:25 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23035 - in
	spoofax-imp/trunk/org.strategoxt.imp.editors.stratego:
	lib-refactoring trans
Message-ID: <20110610085525.6D9A6CC167@mx4.tudelft.nl>

Author: MaartjeDeJonge
Date: Fri Jun 10 08:55:24 2011
New Revision: 23035
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23035&sc=1

Log:
support for (rename) refactoring new style:
(userinput, selected, ...)  -> (ast-changes, fatal-errors, errors, warnings)

Added:
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/consistency-preservation.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/generic-rename.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/namebinding-preservation.str
Deleted:
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/language-description.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/rename-generic.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/user-interaction.str
Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/fetch.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/files.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/rename.str

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/consistency-preservation.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/consistency-preservation.str	Fri Jun 10 08:55:24 2011	(r23035)
@@ -0,0 +1,35 @@
+module consistency-preservation
+
+rules
+
+/**
+ * Collects consistency changes by comparing the semantic errors and warnings  
+ * of the (re)analyzed tree before and after transformation
+ * @example input:
+ * ast := <annotate> tree
+ * ast-t := <annotate; transform; re-annotate> tree
+ * collect-constraint-errors = !(<collect-all(constraint-error), conc>, <collect-all(constraint-warning), conc>) 
+ * @param AST -> (errors, warnings)
+ * @type (AST, AST) -> (errors, warnings)
+ */
+introduced-constraint-errors(collect-constraint-errors):
+  (ast, ast-t) -> (introduced-errors, introduced-warnings)
+  where
+    (errors-before, warnings-before) := <collect-constraint-errors; topdown(strip-annos)> ast;
+    (errors-after, warnings-after)   := <collect-constraint-errors; topdown(strip-annos)> ast-t;
+    introduced-errors   := <diff> (errors-after, errors-before); 
+    introduced-warnings := <diff> (warnings-after, warnings-before) //TODO: when equal? 
+
+/**
+ * Collects consistency changes by comparing the semantic errors and warnings  
+ * of the (re)analyzed trees before and after transformation
+ * @param AST -> (errors, warnings)
+ * @type (List(AST), List(AST)) -> (errors, warnings)
+ */	
+introduced-constraint-errors(collect-constraint-errors):
+  (asts, asts-t) -> (introduced-errors, introduced-warnings)
+  where
+    (errors-before, warnings-before) := <map(collect-constraint-errors); unzip; topdown(strip-annos)> asts;
+    (errors-after, warnings-after)   := <map(collect-constraint-errors); unzip; topdown(strip-annos)> asts-t;
+    introduced-errors   := <diff> (errors-after, errors-before); 
+    introduced-warnings := <diff> (warnings-after, warnings-before) //TODO: when equal? 

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/fetch.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/fetch.str	Thu Jun  9 12:35:38 2011	(r23034)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/fetch.str	Fri Jun 10 08:55:24 2011	(r23035)
@@ -3,7 +3,20 @@
 imports
   lib/editor-common.generated
   
-rules //strategies for fetching subterms in an ast
+rules //strategies for fetching terms in the ast
+
+    /**
+	 * Annotates AST with reference names (analyse),
+	 * and fetches the annotated selected string in the result AST 
+	 * @type (String, T) -> (String{T}, T)
+	 * @param T -> T (or: List(T) -> T)
+	 */
+  annotated-terms(analyse):
+    (selected, ast) -> (ref-name, ast')
+    where
+      ast' := <analyse <+ (![<id>]; analyse; Hd)> ast;
+      ref-name := <fetch-annotated-term(|<fetch-down(is-string)> selected)> ast'
+
   
   fetch-annotated-term(|selected):
   	analysed-ast -> selected-ref

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/files.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/files.str	Thu Jun  9 12:35:38 2011	(r23034)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/files.str	Fri Jun 10 08:55:24 2011	(r23035)
@@ -1,23 +1,21 @@
 module lib-refactoring/files
 
 imports
-  lib-refactoring/user-interaction
-  
+  lib/editor-common.generated
+
 rules //strategies for collecting files
 
   get-source-asts(parse|extensions, source-dirs) =
     get-source-asts(parse, check-extension(|extensions), elem-of(|source-dirs))
 
   get-source-asts(parse, is-source-file, is-source-dir) =
-  	save-all-resources;
     get-source-files(is-source-file, is-source-dir);
     parse-source-files(parse)
   
   parse-source-files(parse) :
-  	filenames -> asts
+  	filenames -> (asts, parse-failures)
   	where
-      (asts, parse-failures) := <partition(parse)> filenames;
-      <report-parse-failures> parse-failures
+      (asts, parse-failures) := <partition(parse)> filenames
   	
   get-source-files(|extensions, source-dirs) =
     get-source-files(check-extension(|extensions), elem-of(|source-dirs))
@@ -36,7 +34,7 @@
       ![]
     end
 	
-  save-all-resources = where(prim("SSL_EXT_saveresources", ""))
+  //save-all-resources = where(prim("SSL_EXT_saveresources", ""))
   
   check-extension(|ext) =
   	has-extension(|ext)
@@ -47,5 +45,39 @@
   	  <fetch(equal(|ext))> extensions 
   	)
   	
-  elem-of(|source-dirs) =
-  	!(<id>, source-dirs); elem
\ No newline at end of file
+  elem-of(|lst) =
+  	!(<id>, lst); elem
+  	
+  is-spoofax-dir:
+    dir -> dir
+    where 
+  	  spoofax-dirs := ["bin", "editor", "icons", "include", "META-INF", "syntax",
+        "utils", ".cache", ".externalToolBuilders", ".settings", ".svn", "trans"];
+      <map(!$[[<project-path>]/[<id>]]); fetch(equal(|dir))> spoofax-dirs
+
+  get-affected-asts(affected, get-cache-path):
+    fnames -> (affected-asts, unparsable-files)
+    where
+      (collected-asts, unparsable-files) := <partition(get-affected-ast-or-none(affected, get-cache-path))> fnames;
+      affected-asts := <filter(not(equal(|None())))> collected-asts //filter irrelevant
+      
+  get-affected-ast-or-none(affected, get-cache-path) =
+    reject-ast-from-cache(affected, get-cache-path) <+ //cache can not be used to get the AST since origin info is required
+    reject-or-get-ast-from-parsing(affected)
+  
+  reject-ast-from-cache(affected, get-cache-path):
+    fname -> None()
+    where
+  	  cached-ast := <get-cache-path; ReadFromFile> fname;
+  	  <not(affected)> cached-ast
+
+  reject-or-get-ast-from-parsing(affected):
+    fname -> ast
+    where
+  	  parsed-ast := <parse-file> fname;
+  	  if <not(affected)> parsed-ast then
+  	    ast := None()
+  	  else
+  	    ast := parsed-ast
+  	  end
+

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/generic-rename.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/generic-rename.str	Fri Jun 10 08:55:24 2011	(r23035)
@@ -0,0 +1,50 @@
+module generic-rename
+
+imports
+  lib-refactoring/consistency-preservation
+  lib-refactoring/namebinding-preservation
+  
+rules
+	
+apply-rename-refactoring(annotate-names, collect-constraint-errors|oldname, newname):
+  asts-analyzed -> (ast-changes, errors, warnings)
+  where
+  	(ast-changes, errors, warnings) := <apply-rename-refactoring(annotate-names, collect-constraint-errors|[(oldname, newname)])> asts-analyzed
+
+apply-rename-refactoring(annotate-names, collect-constraint-errors|renamings):
+  asts-analyzed -> (ast-changes, errors, warnings)
+  where  
+  	asts-transformed := <topdown(try(apply-rename(|renamings)))> asts-analyzed;
+  	asts-reanalyzed := <annotate-names> asts-transformed;
+    (constraint-errors, warnings) := 
+      <introduced-constraint-errors(collect-constraint-errors)> (asts-analyzed, asts-reanalyzed);
+    binding-violations := 
+      <namebinding-error-messages(is-endangered-name(|renamings))> (asts-transformed, asts-reanalyzed);
+    errors := <conc>(binding-violations, constraint-errors);
+    ast-changes := <get-changed-asts> (asts-analyzed, asts-transformed)
+
+apply-rename(|renamings):
+  trm -> <apply-rename(|old, new) <+ apply-rename(|tail)> trm
+  where
+    <?[(old, new)|tail]> renamings
+
+apply-rename(|old, new): 
+  old -> new{ref} 
+  where 
+  	<?_{ref}> old
+
+is-endangered-name(|renamings):
+  trm -> <is-endangered-name(|old, new) <+ is-endangered-name(|tail)> trm
+  where
+    <?[(old, new)|tail]> renamings  
+	
+is-endangered-name(|old, new) =
+  where(strip-annos; (equal(|old{}) <+ equal(|new{})))
+
+get-changed-asts:
+  (asts-before, asts-after) -> changed-asts
+  where
+    changed-asts := <zip; filter(not(equal))> (
+      <topdown(strip-annos)> asts-before, 
+      <topdown(strip-annos)> asts-after
+    )

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/namebinding-preservation.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/namebinding-preservation.str	Fri Jun 10 08:55:24 2011	(r23035)
@@ -0,0 +1,47 @@
+module namebinding-preservation
+
+rules
+
+/**
+ * Collects name binding violation messages by comparing the name annotations 
+ * in the transformed tree before and after re-analysis.
+ * @example input:
+ * ast-t := <annotate; transform> ast
+ * ast-t-reanalyzed := <annotate; transform; re-annotate> ast
+ * is-name = ?oldname <+ ?newname
+ * @param matches endangered names
+ * @type (Term, Term) -> List((Term, String)) 
+ */
+namebinding-error-messages(is-name):
+  (ast-t, ast-t-reanalyzed) -> violation-messages
+  where
+    violations := <collect-binding-violations(is-name)> (ast-t, ast-t-reanalyzed);
+    violation-messages := <map(mk-binding-violation-message)> violations
+
+collect-binding-violations(is-name):
+  (ast-t, ast-t-reanalyzed) -> violations
+  where
+    old-names  := <collect-all(where(is-name), conc)> ast-t; 
+    new-names  := <collect-all(where(is-name), conc)> ast-t-reanalyzed;
+    violations := <zip; binding-violations> (old-names, new-names)
+	
+binding-violations: 
+  [(x,y)|tl] -> violations
+  where
+    (hd-violations, rest) := <binding-violations(|x,y)> tl;
+    rec-violations := <binding-violations <+ ?[]> rest;
+    violations := <conc> (hd-violations, rec-violations)
+
+binding-violations(|x,y):
+  lst -> (<make-set> violations, remaining)
+  where
+    (violations, remaining) := <
+       filter(not(?(x,y)));
+       partition(is-binding-violation(|x,y))
+    > lst
+
+is-binding-violation(|x,y) =
+  where((?(_,y) <+ ?(x,_)); not(?(x,y)))
+
+mk-binding-violation-message:
+  (name, _) -> (name, <!$[Variabele captures detected for '[<strip-annos> name]']>)
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/rename.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/rename.str	Thu Jun  9 12:35:38 2011	(r23034)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/rename.str	Fri Jun 10 08:55:24 2011	(r23035)
@@ -6,171 +6,142 @@
   desugar
   sourcedir
   lib/editor-common.generated
-  lib-refactoring/rename-generic
+  lib-refactoring/generic-rename
   lib-refactoring/files
-  lib-refactoring/language-description
+  lib-refactoring/fetch
 
-rules //rename refactoring, builder
-  
-  rename-builder:
-  (selected, position, ast, path, project-path) -> (filename, resulting-asts)
-  where
-  	resulting-asts := <rename-refactoring; map(Snd)>;
-    filename := <guarantee-extension(|"aterm")> path  
+rules //rename refactoring
 
   rename-refactoring:
-    (selected, position, ast, path, project-path) -> ast-change-tuples
+    (newname, selected, position, ast, path, project-path) -> 
+    (ast-changes, [], <conc> (pre-condition-errors, semantic-errors), warnings)
+    where 
+      (renamings, asts, pre-condition-errors)  := <prepare-renaming> (newname, selected, ast, path);
+      (ast-changes, semantic-errors, warnings) := <apply-rename-refactoring(
+        re-analyse-names, 
+        collect-semantic-issues |
+        renamings
+      )> asts;
+      editor-init //analysis must be redone in case refactoring is canceled
+
+  prepare-renaming:
+    (newname, selected, ast, path) -> (renamings, asts, <conc>(parse-errors, ext-def-errors))
     where
-      init-analysis;
-      save-all-resources;
-      (ref-name, ast') := <get-analysed-terms(analyse-names)> (selected, ast);
-      newname := <dialog-newname(|<get-language-name> path)>;
-      asts := <collect-affected-asts>(ref-name, newname, ast', $[[<project-path>]/[path]]);
-      report-precondition-issues(!asts; precondition-error(|ref-name));
-      ast-change-tuples := <apply-rename-refactoring(
-      	re-analyse-names, 
-      	collect-sem-errors |
-      	<get-renamings> (ref-name, newname)
-      )> asts
-  
-  get-renamings:
-  	r@(refname, newname) -> renamings
-  	where
-  	  <?_{ref}> refname;
+      (name{ref}, ast') := <annotated-terms(analyze-names-ensure-imports)> (selected, ast); 
+      renamings := <get-dependend-renamings> (name{ref}, newname);
+      (asts, unparsable-files) := <collect-affected-asts>(ref, renamings, ast', $[[<project-path>]/[path]]);
+      parse-errors := <map(!$[parsing failed for: '[<id>]'])> unparsable-files;
+      ext-def-errors := <external-declaration-error> ref 
+      
+rules //dependent names
+    
+  get-dependend-renamings:
+    r@(refname, newname) -> renamings
+    where
+      <?_{ref}> refname;
       if <Declaration; ?RDecT(oldname, _, _)> ref then 
-      	old-names := <prefixes-dynrules; map(!$[[<id>]-[oldname]]{ref})>;
-      	new-names := <prefixes-dynrules; map(!$[[<id>]-[newname]])>;
-      	renamings := [(oldname{ref}, newname)|<zip>(old-names, new-names)]
+        old-names := <prefixes-dynrules; map(!$[[<id>]-[oldname]]{ref})>;
+        new-names := <prefixes-dynrules; map(!$[[<id>]-[newname]]{ref})>;
+        renamings := [(oldname{ref}, newname)|<zip>(old-names, new-names)]
       else
-      	renamings := [r]
+        renamings := [r]
       end
 
   prefixes-dynrules =
-  	!["once", "bagof", "bigbagof", "all-keys", "innermost-scope", "break", "break-bp", 
-  	  "continue", "chain", "bigchain", "new", "undefine", "aux", "reverse-bagof", "innermost-scope",
-  	  "break-to-label","continue-to-label", "throw", "fold", "bigfold"]
-
-rules //precondition checks
-
-//TODO: better solution
-//FIXME: no declaration outside asts (lib or generated), since these files are not changed
-//NOW: a declaration in asts exists
-precondition-error(|ref-name):
-	asts -> ([$[Declaration can not be found in [<project-path>]/trans]],[])
-	where
-	  <?_{ref}> ref-name; 
-	  <is-global-ref> ref; 
-	  decl := <Declaration> ref;
-	  decl-cons := <get-constructor> decl;
-	  <not(oncetd(
-	  	if <equal> (<get-constructor>, decl-cons) then 
-	  		topdown(strip-annos) 
-	  	end; 
-	  	equal(|decl)))> asts
-
+    !["once", "bagof", "bigbagof", "all-keys", "innermost-scope", "break", "break-bp", 
+      "continue", "chain", "bigchain", "new", "undefine", "aux", "reverse-bagof", "innermost-scope",
+      "break-to-label","continue-to-label", "throw", "fold", "bigfold"]
+  
 rules //name analysis
     
-  analyse-names:
-  	asts -> <analyse-names-asts> desugared-asts
+  analyze-names-ensure-imports:
+    asts -> <analyze-names> desugared-asts
     where
-       desugared-asts := <map(basic-desugar-top)> asts;
-       <declare-globals> Import("libstratego-lib"); //Import external strategy definitions
-       <map( //Import strategy definitions from files that are not in the list
-           alltd(
-           	 is-not-imported-from-list(|asts);
-             declare-globals
-           )
-       )> desugared-asts
+      rules(CurrentFile := "" ProjectDir  := <project-path>);
+      try(get-source-base-dir);
+      desugared-asts := <map(basic-desugar-top)> asts;
+      <declare-globals> Import("libstratego-lib");
+      <map(alltd(is-not-imported-from-asts(|asts); declare-globals))> desugared-asts
   
-  is-not-imported-from-list(|asts) =
+  is-not-imported-from-asts(|asts) =
     where(?Import(mod) <+ ?ImportWildcard(mod)); 
     where(not(<fetch(?Module(mod, _))> asts))
-  
+    
+  analyze-names:
+    asts -> asts'
+    where
+      asts' := < //re-analyze affected asts
+        map(alltd(where(not(?Import(_) <+ ?ImportWildcard(_))); declare-globals)); //external imports already done 
+        map(declare-bodies-top)
+      > asts
+
   re-analyse-names =
     topdown(strip-annos);
     topdown(try(resugar-Let)); //TODO: better solution?
-    analyse-names-asts
-  
-  analyse-names-asts:
-    asts -> asts'
-    where
-       asts' := < //re-analyze affected asts
-         map(alltd(where(not(?Import(_) <+ ?ImportWildcard(_))); declare-globals)); //external imports already done 
-         map(declare-bodies-top)
-       > asts
+    analyze-names
 
   resugar-Let:
-  	Rec(x, y) -> Let(x,y)
-  	where 
-  	  origin-term; 
-  	  ?Let(_, _)
-
-  init-analysis =
-       rules(
-          CurrentFile := "" //TODO: primitive for file path?
-          ProjectDir  := <project-path>
-       );
-       try(get-source-base-dir)
+    Rec(x, y) -> Let(x,y) where origin-term; ?Let(_, _)
 
 rules //semantic constraint check
 
-  collect-sem-errors = 
-    where (errors :=<collect-all(global-constraint-error + constraint-error, conc)>);
-    where (warnings :=<collect-all(constraint-warning, conc)>);
-    <conc>(errors, warnings);
-    flatten-list
-	
+  collect-semantic-issues:
+    ast -> (errors, warnings)
+    where 
+      errors := <collect-all(global-constraint-error + constraint-error, conc)> ast;
+      warnings := <collect-all(constraint-warning, conc)> ast
+  
 rules //collect asts that are possibly affected by renaming, efficient implementation using cache
-
-//1. do not collect files when selected var is local ##
-//2. for global vars: 
-//2a. keep editor ast to be more robust in case of syntax errors ##
-//2b. collect only the files that are relevant ## 
-//2c. use cache to reject files before analyzing ##
-//2d. parallel with user input dialog
-//2e. (?) collect files in loop instead of by map(parse)?
-//3. re-analyzes: keep lookup tables, no normalization, no external import ##
  
-collect-affected-asts:
-	(oldname{ref}, newname, ast, path-to-ast) -> [ast|<analyse-names> affected-asts]
-	where
-  	  if <is-global-ref> ref then //files are only collected if the selected var is global 
-  	  	//save-all-resources;
-	    fnames := <get-source-files(
-		  has-extension(|"str"); not(equal(|path-to-ast)), //exclude current ast which is obtained from the editor (allowing parse errors) 
-		  not(fail)
-	    )> $[[<project-path>]/trans]; 
-	    (fnames-cache, fnames-no-cache) := <partition-by-cache(|oldname)> fnames;
-	    asts-no-cache := <parse-source-files(parse-file)> fnames-no-cache; //TODO: parallel with rename dialog?!
-	    asts-filtered-no-cache := <filter(
-	    	oncetd(equal(|newname) <+ equal(|<strip-annos> oldname))
-	    )> asts-no-cache;
-	    asts-filtered-cache := <filter(ReadFromFile; oncetd(equal(|newname)))> fnames-cache; 
-	    affected-asts := <conc>(asts-filtered-no-cache, asts-filtered-cache)
+  collect-affected-asts:
+    (ref-anno, renamings, ast, path-to-ast) -> ([ast|<analyze-names-ensure-imports> affected-asts], unparsable-files)
+    where
+      if <is-global-ref> ref-anno then //files are only collected if the selected var is global 
+        fnames := <get-stratego-files; filter(is-editable; not(equal(|path-to-ast)))>; 
+        (affected-asts, unparsable-files) := 
+          <get-affected-asts(oncetd(is-endangered-name(|renamings)), get-cache-path)> fnames
       else
-      	affected-asts := []
+        affected-asts := [];
+        unparsable-files := []
       end
 
-is-global-ref =
-	where(
-		?ref;
-		<Declaration; signature-of; DeclareCookie; equal(|ref)> ref
-	)
-
-partition-by-cache(|refname):
-	fnames -> 
-		<partition(
-			get-cache-path;
-			where(
-				ReadFromFile; 
-				not(oncetd(equal(|<strip-annos> refname))) //exclude files that will change
-			)
-		)> fnames
-		
-	
-get-cache-path: //asts without endangered names can be ignored
-	path -> cache-path
-	where(
-  	  cache-path := <import-cache-path; string-replace(|".str.sig", ".rtree")> path; 
-  	  <is-newer> (cache-path, path)
-  	)
+  is-global-ref =
+    where(?ref; <Declaration; signature-of; DeclareCookie; equal(|ref)> ref)    
+
+  get-stratego-files =
+    project-path;
+    get-source-files(
+      has-extension(|"str"), 
+      not(is-spoofax-dir) <+ equal(|$[[<project-path>]/trans]) <+ equal(|$[[<project-path>]/include])
+    ) 
+
+  is-editable = 
+    not(string-ends-with(|".generated.str"));
+    not(dirname; string-ends-with(|"include"))
+
+  get-cache-path: 
+    path -> cache-path
+    where
+      cache-path := <import-cache-path; string-replace(|".str.sig", ".rtree")> path; 
+      <is-newer> (cache-path, path)
+    
+rules //precondition checks on imported files
+
+  external-declaration-error:
+    ref -> <conc> (generated-file-errors, lib-errors)
+    where 
+      generated-file-errors := <get-stratego-files; filter(declared-in-generated-file(|ref))>; 
+      lib-errors := <![<declared-in-lib>] <+ ![]> ref
+
+  declared-in-generated-file(|ref):
+    fname -> $[Name in [<base-filename>] can not be edited]
+    where
+  	  not(is-editable);
+      (((import-cache-path <+ get-cache-path); ReadFromFile) <+ parse-file);
+      declare-globals-top; 
+      oncetd(?_{ref})
+
+  declared-in-lib:
+    ref -> $[External declaration can not be edited]
+    where
+      <Declaration; get-constructor; string-starts-with(|"Ext")> ref
\ No newline at end of file

From m.dejonge at tudelft.nl  Fri Jun 10 10:58:15 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Fri, 10 Jun 2011 08:58:15 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23036 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/editor
Message-ID: <20110610085815.4AD7A108C040@mx3.tudelft.nl>

Author: MaartjeDeJonge
Date: Fri Jun 10 08:58:07 2011
New Revision: 23036
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23036&sc=1

Log:
Rename refactoring enabled

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/editor/Stratego-Sugar-Builders.esv

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/editor/Stratego-Sugar-Builders.esv
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/editor/Stratego-Sugar-Builders.esv	Fri Jun 10 08:55:24 2011	(r23035)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/editor/Stratego-Sugar-Builders.esv	Fri Jun 10 08:58:07 2011	(r23036)
@@ -11,15 +11,12 @@
   provider : include/stratego_sugar.jar
 
   observer : editor-analyze
-
-  builder     : "Rename (builder)" = 
-  	rename-builder (source)(meta)
   
   refactoring Id: "Rename (refactoring)" = 
-  	rename-refactoring (source)(meta) 
+  	rename-refactoring (source)
 
   builder : "Show analysed AST" =
-    generate-analysed-aterm (realtime) (meta) (openeditor) (source)
+    generate-aterm (realtime) (meta) (openeditor) 
 
   builder : "Show desugared AST (selection)" =
     generate-desugared-aterm (realtime) (meta) (openeditor) (source)

From m.dejonge at tudelft.nl  Fri Jun 10 11:15:54 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Fri, 10 Jun 2011 09:15:54 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23037 -
	spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services
Message-ID: <20110610091554.74208108C003@mx3.tudelft.nl>

Author: MaartjeDeJonge
Date: Fri Jun 10 09:15:53 2011
New Revision: 23037
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23037&sc=1

Log:
null check

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/InputTermBuilder.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/InputTermBuilder.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/InputTermBuilder.java	Fri Jun 10 08:58:07 2011	(r23036)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/InputTermBuilder.java	Fri Jun 10 09:15:53 2011	(r23037)
@@ -224,7 +224,7 @@
 							 // chain
 		}
 		boolean isMatch = isMatchOnConstructorOrSort(mappings, selectionNode);
-		while (!isMatch && selectionNode != getParent(ancestor)) {
+		while (!isMatch && selectionNode != null && selectionNode != getParent(ancestor)) {
 			selectionNode = getParent(selectionNode);
 			isMatch = isMatchOnConstructorOrSort(mappings, selectionNode);
 		}
@@ -244,8 +244,8 @@
 
 	private static boolean isMatchOnConstructorOrSort(ArrayList<NodeMapping<String>> mappings,
 			IStrategoTerm selectionNode) {
-		return NodeMapping.getFirstAttribute(mappings, tryGetName(selectionNode),
-				getSort(selectionNode), 0) != null;
+		return selectionNode != null &&
+			NodeMapping.getFirstAttribute(mappings, tryGetName(selectionNode), getSort(selectionNode), 0) != null;
 	}
 
 	private static String tryGetName(IStrategoTerm term) {

From m.dejonge at tudelft.nl  Fri Jun 10 11:34:33 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Fri, 10 Jun 2011 09:34:33 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23038 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client
Message-ID: <20110610093433.A13207F8041@mx1.tudelft.nl>

Author: MaartjeDeJonge
Date: Fri Jun 10 09:34:32 2011
New Revision: 23038
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23038&sc=1

Log:
currentToken: getter/setter method

Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/FineGrainedOnRegion.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/IndentTokenizer.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/NewStructureSkipper.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ParserHistory.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/RecoveryConnector.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/RegionRecovery.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/SGLR.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/FineGrainedOnRegion.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/FineGrainedOnRegion.java	Fri Jun 10 09:15:53 2011	(r23037)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/FineGrainedOnRegion.java	Fri Jun 10 09:34:32 2011	(r23038)
@@ -126,7 +126,7 @@
             mySGLR.doParseStep();
             newCandidates.addAll(collectNewRecoverCandidates(curTokIndex));
             mySGLR.getRecoverStacks().clear();
-        } while(getHistory().getTokenIndex()<= endRecoverSearchPos && mySGLR.acceptingStack==null && mySGLR.currentToken!=SGLR.EOF);
+        } while(getHistory().getTokenIndex()<= endRecoverSearchPos && mySGLR.acceptingStack==null && mySGLR.getCurrentToken()!=SGLR.EOF);
     	mySGLR.setFineGrainedOnRegion(false);
         return newCandidates;
     }

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/IndentTokenizer.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/IndentTokenizer.java	Fri Jun 10 09:15:53 2011	(r23037)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/IndentTokenizer.java	Fri Jun 10 09:34:32 2011	(r23038)
@@ -60,12 +60,12 @@
      */
     public void handleIndentShifts(SGLR parser) throws IOException, ParseException
     {
-        int curTok=parser.currentToken;
+        int curTok=parser.getCurrentToken();
         if(myIndentHandler.lineMarginEnded()){
             updateIndentFields();
             parseIndentation(parser);
             resetForNextLine();
-            parser.currentToken=curTok;
+            parser.setCurrentToken(curTok);
         }
     }    
 
@@ -78,11 +78,11 @@
                 throw new ParseException(parser, "Indentation inconsistent");
         }        
         for (int i = 0; i < dedentCount; i++) {
-            parser.currentToken = DEDENT_TOK;                         
+            parser.setCurrentToken(DEDENT_TOK);                         
             parser.doParseStep();
         }
         if(indentShift){
-            parser.currentToken = INDENT_TOK;                         
+            parser.setCurrentToken(INDENT_TOK);                         
             parser.doParseStep();
         }
         if(parser.activeStacks.size()==0)//if indent and dedent tokens are not expected, ignore them as layout 

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/NewStructureSkipper.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/NewStructureSkipper.java	Fri Jun 10 09:15:53 2011	(r23037)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/NewStructureSkipper.java	Fri Jun 10 09:34:32 2011	(r23038)
@@ -332,7 +332,7 @@
         boolean isSecondLine=true;
         ArrayList<Integer> endLocations=new ArrayList<Integer>();
         int indexNextLine=skipLine(indexStartLine);        
-        while(myParser.currentToken!=SGLR.EOF && 0<=indexNextLine && indexNextLine<=getHistory().getIndexLastLine()){            
+        while(myParser.getCurrentToken()!=SGLR.EOF && 0<=indexNextLine && indexNextLine<=getHistory().getIndexLastLine()){            
             IndentInfo nextLine = getHistory().getLine(indexNextLine);
             // FIXME: get nextLine may be null 
             int indentSkipPosition=nextLine.getIndentValue();
@@ -452,7 +452,7 @@
     }
 
     private String readLine(int index) {
-        while(getHistory().getIndexLastLine()<=index && myParser.currentToken!=SGLR.EOF)
+        while(getHistory().getIndexLastLine()<=index && myParser.getCurrentToken()!=SGLR.EOF)
             getHistory().readRecoverToken(myParser, false);
         if(index<=getHistory().getIndexLastLine()){
             IndentInfo line=getHistory().getLine(index);
@@ -482,9 +482,9 @@
         getHistory().setTokenIndex(Math.max(0, line.getTokensSeen()-1));        
         skipIndentHandler.setInLeftMargin(false);
         getHistory().readRecoverToken(myParser, false);
-        while(myParser.currentToken!=SGLR.EOF){
+        while(myParser.getCurrentToken()!=SGLR.EOF){
             getHistory().readRecoverToken(myParser, false);            
-            skipIndentHandler.updateIndentation(myParser.currentToken);
+            skipIndentHandler.updateIndentation(myParser.getCurrentToken());
             if(skipIndentHandler.lineMarginEnded()){
                 return indexLine+=1;
             }            

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ParserHistory.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ParserHistory.java	Fri Jun 10 09:15:53 2011	(r23037)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ParserHistory.java	Fri Jun 10 09:34:32 2011	(r23038)
@@ -48,24 +48,24 @@
      */
     public void readRecoverToken(SGLR myParser, boolean keepRecoveredLines) {  
         if (hasFinishedRecoverTokens()) {             
-            if(myParser.currentToken!=SGLR.EOF){                
+            if(myParser.getCurrentToken()!=SGLR.EOF){                
                 if(getIndexLastToken()>=0){
                     myParser.readNextToken();
-                    indentHandler.updateIndentation(myParser.currentToken);
+                    indentHandler.updateIndentation(myParser.getCurrentToken());
                     recoverTokenCount++;   
-                    if(indentHandler.lineMarginEnded() || myParser.currentToken==SGLR.EOF)
+                    if(indentHandler.lineMarginEnded() || myParser.getCurrentToken()==SGLR.EOF)
                         keepNewLinePoint(myParser, myParser.tokensSeen-1, true, indentHandler);
                 }
             }
         }
         else{
-            myParser.currentToken = readCharAt(tokenIndex, myParser.currentInputStream);
-            if(myParser.currentToken == -1) {
-            	myParser.currentToken=SGLR.EOF;
+            myParser.setCurrentToken(readCharAt(tokenIndex, myParser.currentInputStream));
+            if(myParser.getCurrentToken() == -1) {
+            	myParser.setCurrentToken(SGLR.EOF);
     		}
             if(keepRecoveredLines){
-                recoveryIndentHandler.updateIndentation(myParser.currentToken);
-                if(recoveryIndentHandler.lineMarginEnded() || myParser.currentToken==SGLR.EOF)
+                recoveryIndentHandler.updateIndentation(myParser.getCurrentToken());
+                if(recoveryIndentHandler.lineMarginEnded() || myParser.getCurrentToken()==SGLR.EOF)
                     keepNewLinePoint(myParser, tokenIndex, false, recoveryIndentHandler);
             }    
         }
@@ -91,10 +91,10 @@
     }
 
     public void keepTokenAndState(SGLR myParser) {
-        indentHandler.updateIndentation(myParser.currentToken);
+        indentHandler.updateIndentation(myParser.getCurrentToken());
         recoverTokenCount++;
         tokenIndex++;
-        if(indentHandler.lineMarginEnded() || myParser.currentToken==SGLR.EOF || tokenIndex == 1)
+        if(indentHandler.lineMarginEnded() || myParser.getCurrentToken()==SGLR.EOF || tokenIndex == 1)
             keepNewLinePoint(myParser, myParser.tokensSeen-1, false, indentHandler);
     }
     

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/RecoveryConnector.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/RecoveryConnector.java	Fri Jun 10 09:15:53 2011	(r23037)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/RecoveryConnector.java	Fri Jun 10 09:34:32 2011	(r23038)
@@ -170,7 +170,7 @@
         // Skip any leading whitespace, since we already parsed up to that point
         int indexFragment = findFirstNonLayoutToken(fragment);
         while(indexFragment<fragment.length() && mySGLR.activeStacks.size()>0) {                        
-            mySGLR.currentToken=fragment.charAt(indexFragment);
+            mySGLR.setCurrentToken(fragment.charAt(indexFragment));
             indexFragment++;
             if(!asLayout)
                 mySGLR.doParseStep();
@@ -212,8 +212,8 @@
     }
     
     private void parseAsLayout() {
-        if(!isLayoutCharacter((char)mySGLR.currentToken) && mySGLR.currentToken!=SGLR.EOF){
-            mySGLR.currentToken=' ';
+        if(!isLayoutCharacter((char)mySGLR.getCurrentToken()) && mySGLR.getCurrentToken()!=SGLR.EOF){
+            mySGLR.setCurrentToken(' ');
         }
         mySGLR.doParseStep();
     }

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/RegionRecovery.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/RegionRecovery.java	Fri Jun 10 09:15:53 2011	(r23037)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/RegionRecovery.java	Fri Jun 10 09:34:32 2011	(r23038)
@@ -78,7 +78,7 @@
      * Selects erroneous region based on layout 
      */
     public boolean selectErroneousFragment() { 
-        boolean eofReached=myParser.currentToken==SGLR.EOF;
+        boolean eofReached=myParser.getCurrentToken()==SGLR.EOF;
         acceptPosition=-1;
         NewStructureSkipper newRegionSelector=new NewStructureSkipper(myParser);
         int failureIndex=getHistory().getIndexLastLine();
@@ -193,7 +193,7 @@
         //System.out.println("-------------------------");
         while((myParser.activeStacks.size() > 0 && nrOfParsedLines<NR_OF_LINES_TILL_SUCCESS)) {//|| !getHistory().hasFinishedRecoverTokens() 
             getHistory().readRecoverToken(myParser,false); 
-            indentHandler.updateIndentation(myParser.currentToken);           
+            indentHandler.updateIndentation(myParser.getCurrentToken());           
             //System.out.print((char)myParser.currentToken);
             myParser.doParseStep();
             if(getHistory().getTokenIndex()>errorDetectionLocation && indentHandler.lineMarginEnded())
@@ -209,7 +209,7 @@
     private void parseAdditionalTokens(
             StructureSkipSuggestion aSkip) {
         for (char aChar : aSkip.getAdditionalTokens()) {
-            myParser.currentToken=aChar;           
+            myParser.setCurrentToken(aChar);           
             myParser.doParseStep();
         }
         if(aSkip.getAdditionalTokens().length>0){            

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/SGLR.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/SGLR.java	Fri Jun 10 09:15:53 2011	(r23037)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/SGLR.java	Fri Jun 10 09:34:32 2011	(r23038)
@@ -49,7 +49,7 @@
 
 	private ParseTable parseTable;
 
-	protected int currentToken;
+	private int currentToken;
 
 	protected int tokensSeen;
 
@@ -276,7 +276,7 @@
 				//System.out.print((char)currentToken);
 				history.keepTokenAndState(this);
 				doParseStep();
-			} while (currentToken != SGLR.EOF && activeStacks.size() > 0);
+			} while (getCurrentToken() != SGLR.EOF && activeStacks.size() > 0);
 
 			if (acceptingStack == null) {
 				collectedErrors.add(createBadTokenException());
@@ -290,7 +290,7 @@
 			}
 			getPerformanceMeasuring().endParse(acceptingStack!=null);
 		} catch (final TaskCancellationException e) {
-			throw new ParseTimeoutException(this, currentToken, tokensSeen - 1, lineNumber,
+			throw new ParseTimeoutException(this, getCurrentToken(), tokensSeen - 1, lineNumber,
 					columnNumber, collectedErrors);
 		} finally {
 			activeStacks.clear();
@@ -321,7 +321,7 @@
 
 	void readNextToken() {
 		logCurrentToken();
-		currentToken = getNextToken();
+		setCurrentToken(getNextToken());
 	}
 
 	protected void doParseStep() {
@@ -387,20 +387,20 @@
 				} while (action != null);
 
 				if (expected.length() > 0) {
-					return new TokenExpectedException(this, expected.toString(), currentToken,
+					return new TokenExpectedException(this, expected.toString(), getCurrentToken(),
 							tokensSeen + startOffset - 1, lineNumber, columnNumber);
 				}
 			}
 		}
 
-		return new BadTokenException(this, currentToken, tokensSeen + startOffset - 1, lineNumber,
+		return new BadTokenException(this, getCurrentToken(), tokensSeen + startOffset - 1, lineNumber,
 				columnNumber);
 	}
 
 	private void shifter() {
 		logBeforeShifter();
 		activeStacks.clear();
-		final AbstractParseNode prod = parseTable.lookupProduction(currentToken);
+		final AbstractParseNode prod = parseTable.lookupProduction(getCurrentToken());
 
 		while (forShifter.size() > 0) {
 			final ActionState as = forShifter.remove();
@@ -481,13 +481,13 @@
 		logBeforeActor(st, s);
 
 		for (final Action action : s.getActions()) {
-			if (action.accepts(currentToken)) {
+			if (action.accepts(getCurrentToken())) {
 				for (final ActionItem ai : action.getActionItems()) {
 					switch (ai.type) {
 					case ActionItem.SHIFT: {
 						final Shift sh = (Shift) ai;
 						final ActionState actState = new ActionState(st, parseTable.getState(sh.nextState));
-						actState.currentToken = currentToken;
+						actState.currentToken = getCurrentToken();
 						addShiftPair(actState); //Adds StackNode to forshifter
 						statsRecordParsers(); //sets some values un current parse state
 						break;
@@ -565,7 +565,7 @@
 	private void statsRecordParsers() {
 		if (forShifter.size() > maxBranches) {
 			maxBranches = forShifter.size();
-			maxToken = currentToken;
+			maxToken = getCurrentToken();
 			maxColumn = columnNumber;
 			maxLine = lineNumber;
 			maxTokenNumber = tokensSeen;
@@ -764,7 +764,7 @@
 			}
 
 			for (final Action action : st2.peek().getActions()) {
-				if (action.accepts(currentToken)) {
+				if (action.accepts(getCurrentToken())) {
 					for (final ActionItem ai : action.getActionItems()) {
 						switch(ai.type) {
 						case ActionItem.REDUCE:
@@ -1033,7 +1033,7 @@
 
 	private void logCurrentToken() {
 		if (isLogging()) {
-			Tools.logger("Current token (#", tokensSeen, "): ", logCharify(currentToken));
+			Tools.logger("Current token (#", tokensSeen, "): ", logCharify(getCurrentToken()));
 		}
 	}
 
@@ -1052,13 +1052,13 @@
 
 		if (Tools.logging) {
 			Tools.logger("#", tokensSeen, ": shifting ", forShifter.size(), " parser(s) -- token ",
-					logCharify(currentToken), ", line ", lineNumber, ", column ", columnNumber);
+					logCharify(getCurrentToken()), ", line ", lineNumber, ", column ", columnNumber);
 		}
 
 		if (Tools.debugging) {
 			Tools.debug("shifter() - " + dumpActiveStacks());
 
-			Tools.debug(" token   : " + currentToken);
+			Tools.debug(" token   : " + getCurrentToken());
 			Tools.debug(" parsers : " + forShifter.size());
 		}
 	}
@@ -1100,7 +1100,7 @@
 		List<ActionItem> actionItems = null;
 
 		if (Tools.debugging || Tools.tracing) {
-			actionItems = s.getActionItems(currentToken);
+			actionItems = s.getActionItems(getCurrentToken());
 		}
 
 		if(Tools.tracing) {
@@ -1114,7 +1114,7 @@
 
 		if (Tools.debugging) {
 			Tools.debug(" state   : ", s.stateNumber);
-			Tools.debug(" token   : ", currentToken);
+			Tools.debug(" token   : ", getCurrentToken());
 		}
 
 		if (Tools.debugging) {
@@ -1179,7 +1179,7 @@
 
 	private void logReductionInfo(Frame st, Production prod) {
 		Tools.debug(" state : ", st.peek().stateNumber);
-		Tools.debug(" token : ", currentToken);
+		Tools.debug(" token : ", getCurrentToken());
 		Tools.debug(" label : ", prod.label);
 		Tools.debug(" arity : ", prod.arity);
 		Tools.debug(" stack : ", st.dumpStack());
@@ -1203,7 +1203,7 @@
 		}
 
 		if (Tools.logging) {
-			Tools.logger("Reducing; state ", s.stateNumber, ", token: ", logCharify(currentToken),
+			Tools.logger("Reducing; state ", s.stateNumber, ", token: ", logCharify(getCurrentToken()),
 					", production: ", prod.label);
 		}
 
@@ -1211,7 +1211,7 @@
 			Tools.debug("reducer() - ", dumpActiveStacks());
 
 			Tools.debug(" state      : ", s.stateNumber);
-			Tools.debug(" token      : ", logCharify(currentToken) + " (" + currentToken + ")");
+			Tools.debug(" token      : ", logCharify(getCurrentToken()) + " (" + getCurrentToken() + ")");
 			Tools.debug(" production : ", prod.label);
 		}
 	}
@@ -1238,4 +1238,13 @@
 					nl.getLength());
 		}
 	}
+
+	protected void setCurrentToken(int currentToken) {
+		this.currentToken = currentToken;
+	}
+
+	protected int getCurrentToken() {
+		assert(currentToken >= 0);
+		return currentToken;
+	}
 }

From m.dejonge at tudelft.nl  Fri Jun 10 13:18:12 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Fri, 10 Jun 2011 11:18:12 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23039 -
	spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services
Message-ID: <20110610111812.C5A6B108C077@mx3.tudelft.nl>

Author: MaartjeDeJonge
Date: Fri Jun 10 11:18:11 2011
New Revision: 23039
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23039&sc=1

Log:
identifier pattern validation in InputWizard

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/RefactoringButtonDelegate.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/RefactoringPageTextField.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoRefactoringWizard.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/RefactoringButtonDelegate.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/RefactoringButtonDelegate.java	Fri Jun 10 09:34:32 2011	(r23038)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/RefactoringButtonDelegate.java	Fri Jun 10 11:18:11 2011	(r23039)
@@ -1,5 +1,10 @@
 package org.strategoxt.imp.runtime.services;
 
+import java.util.regex.Pattern;
+
+import org.eclipse.imp.language.Language;
+import org.eclipse.imp.language.ServiceFactory;
+import org.eclipse.imp.services.ILanguageSyntaxProperties;
 import org.eclipse.jface.action.Action;
 import org.eclipse.jface.action.ActionContributionItem;
 import org.eclipse.jface.action.IAction;
@@ -13,6 +18,7 @@
 import org.strategoxt.imp.runtime.EditorState;
 import org.strategoxt.imp.runtime.Environment;
 import org.strategoxt.imp.runtime.dynamicloading.BadDescriptorException;
+import org.strategoxt.imp.runtime.dynamicloading.Descriptor;
 import org.eclipse.ltk.core.refactoring.Refactoring;
 import org.eclipse.ltk.ui.refactoring.RefactoringWizard;
 import org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation;
@@ -40,7 +46,11 @@
 
 	private void executeRefactoring(EditorState editor, IRefactoring refactoring) {
 		refactoring.prepareExecute(editor);
-		StrategoRefactoringWizard wizard = new StrategoRefactoringWizard((StrategoRefactoring) refactoring, refactoring.getCaption()); 
+		StrategoRefactoringWizard wizard = new StrategoRefactoringWizard(
+			(StrategoRefactoring) refactoring, 
+			refactoring.getCaption(),
+			getIdPattern(editor.getDescriptor())
+		);
 		RefactoringWizardOpenOperation operation= new RefactoringWizardOpenOperation(wizard);
 		Shell shell = editor.getEditor().getSite().getShell();
 		try {
@@ -49,6 +59,20 @@
 			// Do nothing
 		}
 	}
+	
+	private static Pattern getIdPattern(Descriptor descriptor) {
+		SyntaxProperties syntax = null;
+		if (descriptor != null) {
+			try {
+				syntax = (SyntaxProperties) descriptor.createService(ILanguageSyntaxProperties.class, null);
+			} catch (BadDescriptorException e) {
+				Environment.logException("Could not read syntax properties", e);
+				e.printStackTrace();
+			}
+		} 
+		return syntax != null ? syntax.getIdentifierLexical() : null;
+	}
+
 
 	@Override
 	protected void populateMenu(Menu menu) {

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/RefactoringPageTextField.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/RefactoringPageTextField.java	Fri Jun 10 09:34:32 2011	(r23038)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/RefactoringPageTextField.java	Fri Jun 10 11:18:11 2011	(r23039)
@@ -1,5 +1,8 @@
 package org.strategoxt.imp.runtime.services;
 
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
 import org.eclipse.ltk.core.refactoring.RefactoringStatus;
 import org.eclipse.ltk.ui.refactoring.UserInputWizardPage;
 import org.eclipse.swt.SWT;
@@ -15,12 +18,15 @@
 
 public class RefactoringPageTextField extends UserInputWizardPage {
 
-	private Text fNameField;
+	private final Pattern idPattern;
+	
+	private Text identifierField;
 	private String labelText = "&New name:";
-	String defaultName = "";
+	private String defaultName = "";
 
-	public RefactoringPageTextField(String name) {
-		super(name);
+	public RefactoringPageTextField(Pattern idPattern) {
+		super("SpoofaxRefactoringInputPage");
+		this.idPattern = idPattern; 
 	}
 
 	public void createControl(Composite parent) {
@@ -32,15 +38,15 @@
 		Label label= new Label(result, SWT.NONE);
 		label.setText(labelText);
 
-		fNameField= createNameField(result);
-		fNameField.setText(defaultName);
-		fNameField.addModifyListener(new ModifyListener() {
+		identifierField= createNameField(result);
+		identifierField.setText(defaultName);
+		identifierField.addModifyListener(new ModifyListener() {
 			public void modifyText(ModifyEvent event) {
 				handleInputChanged();
 			}
 		});
-		fNameField.setFocus();
-		fNameField.selectAll();
+		identifierField.setFocus();
+		identifierField.selectAll();
 		handleInputChanged();
 	}
 
@@ -55,19 +61,37 @@
 	}
 
 	void handleInputChanged() {
-		RefactoringStatus status= new RefactoringStatus();
-		StrategoRefactoring refactoring = getStrategoRefactoring();
-
-		ITermFactory factory = Environment.getTermFactory();
-		refactoring.setUserInputTerm(factory.makeString(fNameField.getText()));
-		//check all input fields
-		setPageComplete(!status.hasError());
+		RefactoringStatus status = validateUserInput();
+		//set message
 		int severity= status.getSeverity();
 		String message= status.getMessageMatchingSeverity(severity);
-		if (severity >= RefactoringStatus.INFO) {
+		if (severity >= RefactoringStatus.INFO && message != "") {
 			setMessage(message, severity);
 		} else {
-			setMessage("", NONE); //$NON-NLS-1$
+			setMessage("", NONE);
+		}
+		setPageComplete(!status.hasError());
+		
+		//set userinput value
+		StrategoRefactoring refactoring = getStrategoRefactoring();
+		ITermFactory factory = Environment.getTermFactory();
+		refactoring.setUserInputTerm(factory.makeString(identifierField.getText()));
+	}
+
+	private RefactoringStatus validateUserInput() {
+		String inputString = identifierField.getText();
+		if (idPattern != null){
+			Matcher matcher = idPattern.matcher(inputString);
+			if(!(matcher.matches())){
+				if(inputString.trim().equals("")){
+					return RefactoringStatus.createErrorStatus(""); //suppress error messages for empty fields
+				}
+				String errorMessage = "Error: name should match identifier pattern '" + 
+				idPattern.pattern() + "', defined in <myLanguage>-Syntax.esv file."; 
+				return RefactoringStatus.createErrorStatus(errorMessage);
+			}
 		}
+		//todo: warnings for all empty fields?
+		return new RefactoringStatus();
 	}
 }

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoRefactoringWizard.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoRefactoringWizard.java	Fri Jun 10 09:34:32 2011	(r23038)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoRefactoringWizard.java	Fri Jun 10 11:18:11 2011	(r23039)
@@ -1,19 +1,22 @@
 package org.strategoxt.imp.runtime.services;
 
+import java.util.regex.Pattern;
+
 import org.eclipse.ltk.ui.refactoring.RefactoringWizard;
 
 
 public class StrategoRefactoringWizard extends RefactoringWizard {
 	
-	public StrategoRefactoringWizard(StrategoRefactoring refactoring, String pageTitle) {
+	RefactoringPageTextField inputPage;
+	
+	public StrategoRefactoringWizard(StrategoRefactoring refactoring, String pageTitle, Pattern idPattern) {
 		super(refactoring, DIALOG_BASED_USER_INTERFACE | PREVIEW_EXPAND_FIRST_NODE);
 		setDefaultPageTitle(pageTitle);
+		inputPage = new RefactoringPageTextField(idPattern);
 	}
 
 	@Override
 	protected void addUserInputPages() {
-		addPage(new RefactoringPageTextField("SpoofaxRenameInputPage"));
+		addPage(inputPage);
 	}
-
-
 }

From m.dejonge at tudelft.nl  Fri Jun 10 13:34:56 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Fri, 10 Jun 2011 11:34:56 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23040 -
	spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services
Message-ID: <20110610113456.701AB7F8096@mx1.tudelft.nl>

Author: MaartjeDeJonge
Date: Fri Jun 10 11:34:55 2011
New Revision: 23040
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23040&sc=1

Log:
keyword validation in InputWizard

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/RefactoringButtonDelegate.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/RefactoringPageTextField.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoRefactoringWizard.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/RefactoringButtonDelegate.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/RefactoringButtonDelegate.java	Fri Jun 10 11:18:11 2011	(r23039)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/RefactoringButtonDelegate.java	Fri Jun 10 11:34:55 2011	(r23040)
@@ -15,6 +15,7 @@
 import org.eclipse.ui.IKeyBindingService;
 import org.eclipse.ui.IWorkbenchWindowPulldownDelegate;
 import org.eclipse.ui.internal.KeyBindingService;
+import org.spoofax.jsglr.client.KeywordRecognizer;
 import org.strategoxt.imp.runtime.EditorState;
 import org.strategoxt.imp.runtime.Environment;
 import org.strategoxt.imp.runtime.dynamicloading.BadDescriptorException;
@@ -49,7 +50,8 @@
 		StrategoRefactoringWizard wizard = new StrategoRefactoringWizard(
 			(StrategoRefactoring) refactoring, 
 			refactoring.getCaption(),
-			getIdPattern(editor.getDescriptor())
+			getIdPattern(editor),
+			getKeywordRecognizer(editor)
 		);
 		RefactoringWizardOpenOperation operation= new RefactoringWizardOpenOperation(wizard);
 		Shell shell = editor.getEditor().getSite().getShell();
@@ -60,7 +62,8 @@
 		}
 	}
 	
-	private static Pattern getIdPattern(Descriptor descriptor) {
+	private static Pattern getIdPattern(EditorState editor) {
+		Descriptor descriptor = editor.getDescriptor();
 		SyntaxProperties syntax = null;
 		if (descriptor != null) {
 			try {
@@ -73,6 +76,17 @@
 		return syntax != null ? syntax.getIdentifierLexical() : null;
 	}
 
+	private KeywordRecognizer getKeywordRecognizer(EditorState editor) {
+		try {
+			return editor.getParseController().getParser().getParseTable().getKeywordRecognizer();
+		}
+		catch (Exception e){
+			Environment.logException("Could not fetch keyword recognizer", e);
+			e.printStackTrace();
+			return null;
+		}
+	}
+
 
 	@Override
 	protected void populateMenu(Menu menu) {

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/RefactoringPageTextField.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/RefactoringPageTextField.java	Fri Jun 10 11:18:11 2011	(r23039)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/RefactoringPageTextField.java	Fri Jun 10 11:34:55 2011	(r23040)
@@ -14,19 +14,22 @@
 import org.eclipse.swt.widgets.Label;
 import org.eclipse.swt.widgets.Text;
 import org.spoofax.interpreter.terms.ITermFactory;
+import org.spoofax.jsglr.client.KeywordRecognizer;
 import org.strategoxt.imp.runtime.Environment;
 
 public class RefactoringPageTextField extends UserInputWizardPage {
 
 	private final Pattern idPattern;
+	private final KeywordRecognizer keywordRecognizer;
 	
 	private Text identifierField;
 	private String labelText = "&New name:";
 	private String defaultName = "";
 
-	public RefactoringPageTextField(Pattern idPattern) {
+	public RefactoringPageTextField(Pattern idPattern, KeywordRecognizer keywordRecognizer) {
 		super("SpoofaxRefactoringInputPage");
 		this.idPattern = idPattern; 
+		this.keywordRecognizer = keywordRecognizer;
 	}
 
 	public void createControl(Composite parent) {
@@ -86,11 +89,15 @@
 				if(inputString.trim().equals("")){
 					return RefactoringStatus.createErrorStatus(""); //suppress error messages for empty fields
 				}
-				String errorMessage = "Error: name should match identifier pattern '" + 
+				String errorMessage = "Name should match identifier pattern '" + 
 				idPattern.pattern() + "', defined in <myLanguage>-Syntax.esv file."; 
 				return RefactoringStatus.createErrorStatus(errorMessage);
 			}
 		}
+		if(keywordRecognizer !=null &&  keywordRecognizer.isKeyword(inputString)){
+			String errorMessage = "This name is used as a keyword.";					
+			return RefactoringStatus.createErrorStatus(errorMessage);
+		}
 		//todo: warnings for all empty fields?
 		return new RefactoringStatus();
 	}

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoRefactoringWizard.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoRefactoringWizard.java	Fri Jun 10 11:18:11 2011	(r23039)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoRefactoringWizard.java	Fri Jun 10 11:34:55 2011	(r23040)
@@ -3,16 +3,17 @@
 import java.util.regex.Pattern;
 
 import org.eclipse.ltk.ui.refactoring.RefactoringWizard;
+import org.spoofax.jsglr.client.KeywordRecognizer;
 
 
 public class StrategoRefactoringWizard extends RefactoringWizard {
 	
 	RefactoringPageTextField inputPage;
 	
-	public StrategoRefactoringWizard(StrategoRefactoring refactoring, String pageTitle, Pattern idPattern) {
+	public StrategoRefactoringWizard(StrategoRefactoring refactoring, String pageTitle, Pattern idPattern, KeywordRecognizer keywordRecognizer) {
 		super(refactoring, DIALOG_BASED_USER_INTERFACE | PREVIEW_EXPAND_FIRST_NODE);
 		setDefaultPageTitle(pageTitle);
-		inputPage = new RefactoringPageTextField(idPattern);
+		inputPage = new RefactoringPageTextField(idPattern, keywordRecognizer);
 	}
 
 	@Override

From R.B.Vermaas at tudelft.nl  Fri Jun 10 14:25:02 2011
From: R.B.Vermaas at tudelft.nl (Rob Vermaas)
Date: Fri, 10 Jun 2011 12:25:02 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23041 -
	strategoxt/branches/xml-front-java
Message-ID: <20110610122502.EACDA7F8026@mx1.tudelft.nl>

Author: rob
Date: Fri Jun 10 12:24:56 2011
New Revision: 23041
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23041&sc=1

Log:


Added:
   strategoxt/branches/xml-front-java/
      - copied from r23040, strategoxt/trunk/xml-front/

From R.B.Vermaas at tudelft.nl  Fri Jun 10 14:25:53 2011
From: R.B.Vermaas at tudelft.nl (Rob Vermaas)
Date: Fri, 10 Jun 2011 12:25:53 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23042 - in
	strategoxt/branches/xml-front-java: . lib pp pp/xml sig
	sig/xml sig/xml-info syn syn/xml tests tests/str-xml
	tests/str-xml-info tests/syn tests/syn/xml tests/sy...
Message-ID: <20110610122553.157A6CC222@mx4.tudelft.nl>

Author: rob
Date: Fri Jun 10 12:25:51 2011
New Revision: 23042
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23042&sc=1

Log:
remove autoconf/-make stuff

Deleted:
   strategoxt/branches/xml-front-java/Makefile.am
   strategoxt/branches/xml-front-java/configure.ac
   strategoxt/branches/xml-front-java/lib/Makefile.am
   strategoxt/branches/xml-front-java/pp/Makefile.am
   strategoxt/branches/xml-front-java/pp/xml/Makefile.am
   strategoxt/branches/xml-front-java/sig/Makefile.am
   strategoxt/branches/xml-front-java/sig/xml-info/Makefile.am
   strategoxt/branches/xml-front-java/sig/xml/Makefile.am
   strategoxt/branches/xml-front-java/syn/Makefile.am
   strategoxt/branches/xml-front-java/syn/xml/Makefile.am
   strategoxt/branches/xml-front-java/tests/Makefile.am
   strategoxt/branches/xml-front-java/tests/str-xml-info/Makefile.am
   strategoxt/branches/xml-front-java/tests/str-xml/Makefile.am
   strategoxt/branches/xml-front-java/tests/syn/Makefile.am
   strategoxt/branches/xml-front-java/tests/syn/xml/Document/Makefile.am
   strategoxt/branches/xml-front-java/tests/syn/xml/Makefile.am
   strategoxt/branches/xml-front-java/trans/Makefile.am
   strategoxt/branches/xml-front-java/trans/process/Makefile.am
   strategoxt/branches/xml-front-java/trans/str-xml-doc/Makefile.am
   strategoxt/branches/xml-front-java/trans/str-xml-info/Makefile.am
   strategoxt/branches/xml-front-java/xtc/Makefile.am

From R.B.Vermaas at tudelft.nl  Fri Jun 10 14:27:39 2011
From: R.B.Vermaas at tudelft.nl (Rob Vermaas)
Date: Fri, 10 Jun 2011 12:27:39 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23043 -
	strategoxt/branches/strategoxt-java
Message-ID: <20110610122739.1F2912B8003@mx2.tudelft.nl>

Author: rob
Date: Fri Jun 10 12:27:37 2011
New Revision: 23043
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23043&sc=1

Log:
add COPYING to jar

Modified:
   strategoxt/branches/strategoxt-java/build.xml

Modified: strategoxt/branches/strategoxt-java/build.xml
==============================================================================
--- strategoxt/branches/strategoxt-java/build.xml	Fri Jun 10 12:25:51 2011	(r23042)
+++ strategoxt/branches/strategoxt-java/build.xml	Fri Jun 10 12:27:37 2011	(r23043)
@@ -158,6 +158,7 @@
     <target name="jar">
         <jar destfile="strategoxt.jar" manifest="java-backend/java/META-INF/MANIFEST.MF">
             <fileset dir="." includes="strategoxt-build.xml"/>
+            <fileset dir="." includes="COPYING"/>
             <fileset dir="bin" includes="**/*.class"/>
             <fileset dir="lib" includes="**/*.rtree"/>
             <fileset dir="lib" includes="**/*.af"/>

From R.B.Vermaas at tudelft.nl  Fri Jun 10 14:31:04 2011
From: R.B.Vermaas at tudelft.nl (Rob Vermaas)
Date: Fri, 10 Jun 2011 12:31:04 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23044 - in
	strategoxt/branches/xml-front-java: syn/xml syntax
Message-ID: <20110610123104.898D52B802A@mx2.tudelft.nl>

Author: rob
Date: Fri Jun 10 12:31:03 2011
New Revision: 23044
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23044&sc=1

Log:
move syntax dir

Added:
   strategoxt/branches/xml-front-java/syntax/
      - copied from r23041, strategoxt/branches/xml-front-java/syn/xml/
Deleted:
   strategoxt/branches/xml-front-java/syn/xml/
   strategoxt/branches/xml-front-java/syntax/Makefile.am

From R.B.Vermaas at tudelft.nl  Fri Jun 10 14:31:27 2011
From: R.B.Vermaas at tudelft.nl (Rob Vermaas)
Date: Fri, 10 Jun 2011 12:31:27 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23045 -
	strategoxt/branches/xml-front-java/syn
Message-ID: <20110610123127.71DA92B8034@mx2.tudelft.nl>

Author: rob
Date: Fri Jun 10 12:31:26 2011
New Revision: 23045
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23045&sc=1

Log:
remove syn

Deleted:
   strategoxt/branches/xml-front-java/syn/

From R.B.Vermaas at tudelft.nl  Fri Jun 10 14:33:03 2011
From: R.B.Vermaas at tudelft.nl (Rob Vermaas)
Date: Fri, 10 Jun 2011 12:33:03 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23046 - in
	strategoxt/branches/xml-front-java: tools tools/process
	tools/str-xml-doc tools/str-xml-info trans xtc
Message-ID: <20110610123303.EFD812B8003@mx2.tudelft.nl>

Author: rob
Date: Fri Jun 10 12:33:02 2011
New Revision: 23046
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23046&sc=1

Log:
move all tools to same dir

Added:
   strategoxt/branches/xml-front-java/tools/
   strategoxt/branches/xml-front-java/tools/aterm2xml.str
      - copied unchanged from r23044, strategoxt/branches/xml-front-java/xtc/aterm2xml.str
   strategoxt/branches/xml-front-java/tools/data2xml-doc.meta
      - copied unchanged from r23044, strategoxt/branches/xml-front-java/trans/data2xml-doc.meta
   strategoxt/branches/xml-front-java/tools/data2xml-doc.str
      - copied unchanged from r23044, strategoxt/branches/xml-front-java/trans/data2xml-doc.str
   strategoxt/branches/xml-front-java/tools/parse-xml-doc.str
      - copied unchanged from r23044, strategoxt/branches/xml-front-java/xtc/parse-xml-doc.str
   strategoxt/branches/xml-front-java/tools/parse-xml-info.str
      - copied unchanged from r23044, strategoxt/branches/xml-front-java/xtc/parse-xml-info.str
   strategoxt/branches/xml-front-java/tools/pp-xml-doc.str
      - copied unchanged from r23044, strategoxt/branches/xml-front-java/xtc/pp-xml-doc.str
   strategoxt/branches/xml-front-java/tools/pp-xml-info.str
      - copied unchanged from r23044, strategoxt/branches/xml-front-java/xtc/pp-xml-info.str
   strategoxt/branches/xml-front-java/tools/process/
      - copied from r23044, strategoxt/branches/xml-front-java/trans/process/
   strategoxt/branches/xml-front-java/tools/str-xml-doc/
      - copied from r23044, strategoxt/branches/xml-front-java/trans/str-xml-doc/
   strategoxt/branches/xml-front-java/tools/str-xml-info/
      - copied from r23044, strategoxt/branches/xml-front-java/trans/str-xml-info/
   strategoxt/branches/xml-front-java/tools/xml-info2data.str
      - copied unchanged from r23044, strategoxt/branches/xml-front-java/trans/xml-info2data.str
   strategoxt/branches/xml-front-java/tools/xml-xtc-tools.str
      - copied unchanged from r23044, strategoxt/branches/xml-front-java/xtc/xml-xtc-tools.str
   strategoxt/branches/xml-front-java/tools/xml2aterm.str
      - copied unchanged from r23044, strategoxt/branches/xml-front-java/xtc/xml2aterm.str
Deleted:
   strategoxt/branches/xml-front-java/trans/
   strategoxt/branches/xml-front-java/xtc/

Copied: strategoxt/branches/xml-front-java/tools/aterm2xml.str (from r23044, strategoxt/branches/xml-front-java/xtc/aterm2xml.str)
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ strategoxt/branches/xml-front-java/tools/aterm2xml.str	Fri Jun 10 12:33:02 2011	(r23046, copy of r23044, strategoxt/branches/xml-front-java/xtc/aterm2xml.str)
@@ -0,0 +1,14 @@
+module aterm2xml
+imports
+  libstratego-lib
+  xml-front-options
+  libstratego-xtc
+
+strategies
+
+  main-aterm2xml =
+    xtc-io-wrap(explicit-mode-option,
+      xtc-transform(!"data2xml-doc", ![<pass-explicit-mode> | <pass-verbose>])
+    ; xtc-transform(!"pp-xml-doc", pass-verbose)
+    <+ <xtc-exit> 1
+    )

Copied: strategoxt/branches/xml-front-java/tools/data2xml-doc.meta (from r23044, strategoxt/branches/xml-front-java/trans/data2xml-doc.meta)
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ strategoxt/branches/xml-front-java/tools/data2xml-doc.meta	Fri Jun 10 12:33:02 2011	(r23046, copy of r23044, strategoxt/branches/xml-front-java/trans/data2xml-doc.meta)
@@ -0,0 +1,2 @@
+Meta([Syntax("Stratego-xml")])
+

Copied: strategoxt/branches/xml-front-java/tools/data2xml-doc.str (from r23044, strategoxt/branches/xml-front-java/trans/data2xml-doc.str)
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ strategoxt/branches/xml-front-java/tools/data2xml-doc.str	Fri Jun 10 12:33:02 2011	(r23046, copy of r23044, strategoxt/branches/xml-front-java/trans/data2xml-doc.str)
@@ -0,0 +1,179 @@
+module data2xml-doc
+imports
+  xml-doc
+  xml-info2xml-doc
+  xml-front-options
+  libstratego-lib 
+
+strategies
+
+  main-data2xml-doc =
+    io-wrap(explicit-mode-option,
+      dispatch-explicit-mode(
+        implicit-data2xml
+      , explicit-data2xml
+      , very-explicit-data2xml
+      )
+    ; data2xml-finish
+    )
+
+strategies
+
+  implicit-data2xml =
+    bottomup(
+      data2xml-doc-anno-wrap(implicit-data2xml, 
+        \ None() -> [] \
+      <+ ?Some(<id>)
+      <+ Explode-String
+      <+ Explode-Int
+      <+ Explode-List
+      <+ Explode-Tuple 
+      <+ Explode-Appl
+      )
+    )
+
+  explicit-data2xml =
+    bottomup(
+      data2xml-doc-anno-wrap(explicit-data2xml, 
+         ExplicitExplode-String
+      <+ ExplicitExplode-Int
+      <+ ExplicitExplode-List
+      <+ ExplicitExplode-Tuple
+      <+ Explode-Appl
+      )
+    )
+
+  very-explicit-data2xml =
+    bottomup(
+      data2xml-doc-anno-wrap(very-explicit-data2xml, 
+         ExplicitExplode-List
+      <+ ExplicitExplode-Tuple
+      <+ VeryExplicitExplode-Int
+      <+ VeryExplicitExplode-String
+      <+ VeryExplicitExplode-Appl
+      )
+    )
+
+strategies
+
+  data2xml-finish =
+      add-aterm-namespace
+    ; !%>
+        <?xml version="1.0"?>
+
+        <% id %>
+      <%
+    <+ say(!"error: resulting top-level is not an element")
+     ; <exit> 1
+
+
+  add-aterm-namespace :
+    EmptyElement(n, atts) -> EmptyElement(n, [ @> xmlns:at="http://aterm.org" <@ | atts])
+
+  add-aterm-namespace :
+    Element(n, atts, content, n) -> Element(n, [ @> xmlns:at="http://aterm.org" <@ | atts], content, n)
+
+/**
+ * Implicit mode
+ */
+strategies
+
+  Explode-Appl =
+    Explode-EmptyAppl <+ Explode-NotEmptyAppl
+
+  Explode-EmptyAppl :
+    s#([]) -> %>< ~n:s /><%
+
+  Explode-NotEmptyAppl :
+    s#(children) ->
+      %>< ~n:s ><% <flatten-list> children :: * %></ ~n:s ><%
+
+  Explode-Attr :
+    (s, v) -> @> ~n:s="<% <string2xml-attr-value> v %>" <@
+
+  Explode-String :
+    s -> %><% !s2 :: cdata %><%
+      where <is-string; xml-escape> s => s2
+
+  Explode-List :
+    xs -> %><% !xs :: * %><% :: *
+    where
+      <is-list> xs
+
+  Explode-Tuple :
+    "" # (xs) -> %><% !xs :: * %><% :: *
+
+  Explode-Int :
+    i ->  %><% !s :: cdata %><%
+    where
+      <is-int> i
+      ; <int-to-string> i => s
+
+/**
+ * Explicit mode
+ */
+rules
+
+  ExplicitExplode-List =
+    !%><at:list><% Explode-List :: * %></at:list><%
+
+  ExplicitExplode-Tuple =
+    !%><at:tuple><% Explode-Tuple :: * %></at:tuple><%
+
+  ExplicitExplode-Int =
+    !%><at:int><% Explode-Int %></at:int><%
+
+  ExplicitExplode-String =
+    !%><at:string><% Explode-String %></at:string><%
+
+/**
+ * Very explicit mode
+ */
+rules
+
+  VeryExplicitExplode-Int :
+    i -> %><at:int><at:value><% <Explode-Int> i %></at:value></at:int><%
+
+  VeryExplicitExplode-String :
+    s -> %><at:string><at:value><% <Explode-String> s %></at:value></at:string><%
+
+  VeryExplicitExplode-Appl :
+    s#(children) -> %><at:appl at:fun="<% !s %>"><% <flatten-list> children :: * %></at:appl><%
+
+strategies
+
+  data2xml-doc-anno-wrap(x, s) =
+    let /**
+         * Recursive call to an annotation. This might result in a single element
+         * or a list, which is normalized by flatten-list and list construction.
+         */
+        anno-rec =
+          x
+          ; if is-list then
+              flatten-list
+            else
+              ![<id>]
+            end
+     in 
+        ?_{anno*}
+      ; s
+      ; if ![anno*] => [_ | _] then
+          where(
+            <map(!%><at:anno><% anno-rec :: * %></at:anno><%)> [anno*] => anno-content
+          )
+        ; add-to-elem(|anno-content)
+        end
+   end
+
+  /**
+   * Add the specified annos represented in XML to an XML element.
+   */
+  add-to-elem(|annos) =
+    add-to-nonempty-elem(|annos)
+    <+ add-to-empty-elem(|annos)
+
+  add-to-nonempty-elem(|annos) :
+    Element(n, atts, content, n) -> Element(n, atts, <conc> (annos, content), n)
+
+  add-to-empty-elem(|annos) :
+    EmptyElement(n, atts) -> Element(n, atts, annos, n)

Copied: strategoxt/branches/xml-front-java/tools/parse-xml-doc.str (from r23044, strategoxt/branches/xml-front-java/xtc/parse-xml-doc.str)
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ strategoxt/branches/xml-front-java/tools/parse-xml-doc.str	Fri Jun 10 12:33:02 2011	(r23046, copy of r23044, strategoxt/branches/xml-front-java/xtc/parse-xml-doc.str)
@@ -0,0 +1,9 @@
+module parse-xml-doc
+imports 
+  libstratego-lib
+  libstratego-xtc xml-xtc-tools
+
+strategies
+  
+  main-parse-xml-doc =
+    xtc-io-wrap(xtc-parse-xml-doc)

Copied: strategoxt/branches/xml-front-java/tools/parse-xml-info.str (from r23044, strategoxt/branches/xml-front-java/xtc/parse-xml-info.str)
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ strategoxt/branches/xml-front-java/tools/parse-xml-info.str	Fri Jun 10 12:33:02 2011	(r23046, copy of r23044, strategoxt/branches/xml-front-java/xtc/parse-xml-info.str)
@@ -0,0 +1,37 @@
+module parse-xml-info
+imports 
+  libstratego-lib
+  libstratego-xtc xml-xtc-tools
+
+strategies
+  
+  main-parse-xml-info =
+    xtc-io-wrap(
+      xtc-parse-xml-info
+      <+ say(!"parse-xml-info:error: Parsing xml failed.")
+         ; <xtc-exit> 1
+    )
+
+/*
+Usage:
+  parse-xml-info [-h] [-i file] [-o file]
+
+Options:
+  -h       Displays usage information.
+  -i file  Specifies the xml file to parse.
+  -o file  Specifies the file name of the resulting tree.
+
+Description:
+   parse-xml-info takes an xml document and outputs a DOM like 
+   representation of this document in ATerm format. The output is 
+   according to the xml signature in Stratego. This can be checked 
+   with the fc-xml-info tool.
+
+Copying:
+   Copyright (C) 2001-2002 Martin Bravenboer <martin at mbravenboer.org>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+*/

Copied: strategoxt/branches/xml-front-java/tools/pp-xml-doc.str (from r23044, strategoxt/branches/xml-front-java/xtc/pp-xml-doc.str)
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ strategoxt/branches/xml-front-java/tools/pp-xml-doc.str	Fri Jun 10 12:33:02 2011	(r23046, copy of r23044, strategoxt/branches/xml-front-java/xtc/pp-xml-doc.str)
@@ -0,0 +1,32 @@
+module pp-xml-doc
+imports libstratego-xtc xml-xtc-tools libstratego-lib
+
+strategies
+
+  main-pp-xml-doc =
+    xtc-io-wrap(xtc-pp-xml-doc)
+
+/*
+Usage:
+  pp-not-xml [-h] [-i file] [-o file]
+
+Options:
+  -h         Displays usage information.
+  -i file    Specifies the XML concrete syntax tree to pretty-print.
+  -o file    Specifies the file name of the resulting text term.
+
+Description:
+   pp-not-xml pretty-prints an XML concrete syntax tree
+   in ATerm format to text.
+
+Copying:
+   Copyright (C) 2001-2002 Martin Bravenboer <martin at mbravenboer.org>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+ENDCAT
+}
+
+*/

Copied: strategoxt/branches/xml-front-java/tools/pp-xml-info.str (from r23044, strategoxt/branches/xml-front-java/xtc/pp-xml-info.str)
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ strategoxt/branches/xml-front-java/tools/pp-xml-info.str	Fri Jun 10 12:33:02 2011	(r23046, copy of r23044, strategoxt/branches/xml-front-java/xtc/pp-xml-info.str)
@@ -0,0 +1,38 @@
+module pp-xml-info
+
+imports 
+  libstratego-lib
+  libstratego-xtc
+
+strategies
+
+  main-pp-xml-info =
+    xtc-io-wrap(
+      xtc-transform(!"xml-info2xml-doc")
+    ; xtc-transform(!"pp-xml-doc")
+    )
+
+/*
+Usage:
+  pp-not-xml [-h] [-i file] [-o file]
+
+Options:
+  -h         Displays usage information.
+  -i file    Specifies the XML concrete syntax tree to pretty-print.
+  -o file    Specifies the file name of the resulting text term.
+
+Description:
+   pp-not-xml pretty-prints an XML concrete syntax tree
+   in ATerm format to text.
+
+Copying:
+   Copyright (C) 2001-2002 Martin Bravenboer <martin at mbravenboer.org>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+ENDCAT
+}
+
+*/

Copied: strategoxt/branches/xml-front-java/tools/xml-info2data.str (from r23044, strategoxt/branches/xml-front-java/trans/xml-info2data.str)
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ strategoxt/branches/xml-front-java/tools/xml-info2data.str	Fri Jun 10 12:33:02 2011	(r23046, copy of r23044, strategoxt/branches/xml-front-java/trans/xml-info2data.str)
@@ -0,0 +1,100 @@
+module xml-info2data
+imports
+  xml-info
+  libstratego-lib
+  xml-front-options
+
+strategies
+
+  main-xml-info2data =
+    io-wrap(explicit-mode-option,
+      xml-info2data
+    )
+
+strategies
+
+  xml-info2data =
+      ?Document(<id>)
+    ; rec x(
+        xml-info2data-anno-wrap(XmlImplode(x))
+      )
+
+  xml-info2data-anno-wrap(s) =
+    if ?Element(name, attrs, content) then
+      !content
+      ; partition(project-anno-element)
+      ; ?(anno1*, real-content)
+      ; <s> Element(name, attrs, real-content)
+      ; ?t{anno2*}
+      ; <conc> (<map(s)> [anno1*], [anno2*]) => [anno*]
+      ; !t{anno*}
+    else
+      s
+    end
+
+  is-anno-element =
+    ?Element(ATermName("anno"), _, _)
+
+  project-anno-element :
+    Element(ATermName("anno"), [], [e]) -> e
+
+/**
+ * Implicit implode rules
+ */
+rules
+
+  XmlImplode(x) :
+    Element(Name(None(), s), [atts1*], children) -> s#(<map(x)> children){atts2*}
+    where
+      <map(x)> atts1* => atts2*
+
+  XmlImplode(x) :
+    Text(s) -> s
+
+  XmlImplode(x) :
+    Attribute(Name(None(), s), value) -> (s, value)
+
+/**
+ * Explicit implode rules
+ */
+rules
+
+  XmlImplode(x) :
+    Element(ATermName("int"), _, [Text(s)]) -> <trim-chars('\n' + '\t' + '\r' + ' '); string-to-int> s
+
+  XmlImplode(x) :
+    Element(ATermName("string"), _, [Text(s)]) -> s
+
+/**
+ * Very explicit implode rules
+ */
+rules
+
+  XmlImplode(x) :
+    Element(ATermName("appl"), [Attribute(ATermName("fun"), name)], content) -> name#(<map(x)> children)
+    where
+      <filter(not(is-anno-element + ?Text(_)))> content => children
+
+  XmlImplode(x) :
+    Element(ATermName("int"), _, content) -> <trim-chars('\n' + '\t' + '\r' + ' '); string-to-int> s
+    where
+      <fetch(?Element(ATermName("value"), _, [Text(s)]))> content
+    
+  XmlImplode(x) :
+    Element(ATermName("string"), _, content) -> s
+    where
+      <fetch(?Element(ATermName("value"), _, [Text(s)]))> content 
+
+  XmlImplode(x) :
+    Element(ATermName("tuple"), _, content) -> ""#(<map(x)> children)
+    where
+      <filter(not(is-anno-element + ?Text(_)))> content => children
+
+  XmlImplode(x) :
+    Element(ATermName("list"), _, content) -> <map(x)> children
+    where
+      <filter(not(is-anno-element + ?Text(_)))> content => children
+
+overlays
+
+  ATermName(s) = Name(Some("http://aterm.org"), s)

Copied: strategoxt/branches/xml-front-java/tools/xml-xtc-tools.str (from r23044, strategoxt/branches/xml-front-java/xtc/xml-xtc-tools.str)
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ strategoxt/branches/xml-front-java/tools/xml-xtc-tools.str	Fri Jun 10 12:33:02 2011	(r23046, copy of r23044, strategoxt/branches/xml-front-java/xtc/xml-xtc-tools.str)
@@ -0,0 +1,46 @@
+/**
+ * xtc abstractions for invoking tools of xml-tools.
+ *
+ * @author  Martin Bravenboer
+ */
+module xml-xtc-tools
+imports strategoxt-xtc-tools
+
+strategies
+
+  /**
+   * Parses an XML document to an xml-doc term.
+   */
+  xtc-parse-xml-doc =
+      xtc-sglr(!"xml.tbl", !"Document")
+    ; xtc-implode-asfix
+
+  /**
+   * Parses an XML document to an xml-info term.
+   */
+  xtc-parse-xml-info =
+      xtc-parse-xml-doc
+    ; xtc-transform(!"xml-doc-strip-whitespace", pass-verbose)
+    ; xtc-xml-doc2xml-info
+
+  xtc-pp-xml-info =
+      xtc-xml-info2xml-doc
+    ; xtc-pp-xml-doc
+
+  xtc-pp-xml-doc =
+      xtc-transform(!"xml-doc2abox", pass-verbose)
+    ; xtc-abox2text
+
+strategies
+
+  /**
+   * Converts an xml-doc term to an xml-info term.
+   */
+  xtc-xml-doc2xml-info =
+    xtc-transform(!"xml-doc2xml-info", pass-verbose)
+
+  /**
+   * Converts an xml-info term to an xml-doc term.
+   */
+  xtc-xml-info2xml-doc =
+    xtc-transform(!"xml-info2xml-doc", pass-verbose)

Copied: strategoxt/branches/xml-front-java/tools/xml2aterm.str (from r23044, strategoxt/branches/xml-front-java/xtc/xml2aterm.str)
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ strategoxt/branches/xml-front-java/tools/xml2aterm.str	Fri Jun 10 12:33:02 2011	(r23046, copy of r23044, strategoxt/branches/xml-front-java/xtc/xml2aterm.str)
@@ -0,0 +1,14 @@
+module xml2aterm
+imports
+  libstratego-lib
+  libstratego-xtc
+  xml-front-options
+
+strategies
+
+  main-xml2aterm =
+    xtc-io-wrap(explicit-mode-option,
+      xtc-transform(!"parse-xml-info", pass-verbose)
+    ; xtc-transform(!"xml-info2data", ![<pass-explicit-mode> | <pass-verbose>])
+    <+ <xtc-exit> 1
+    )

From R.B.Vermaas at tudelft.nl  Fri Jun 10 14:33:31 2011
From: R.B.Vermaas at tudelft.nl (Rob Vermaas)
Date: Fri, 10 Jun 2011 12:33:31 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23047 - in
	strategoxt/branches/xml-front-java: lib tools
Message-ID: <20110610123331.80F91108C04A@mx3.tudelft.nl>

Author: rob
Date: Fri Jun 10 12:33:30 2011
New Revision: 23047
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23047&sc=1

Log:
move xml-front-options to tools as there is no real lib

Added:
   strategoxt/branches/xml-front-java/tools/xml-front-options.str
      - copied unchanged from r23044, strategoxt/branches/xml-front-java/lib/xml-front-options.str
Deleted:
   strategoxt/branches/xml-front-java/lib/

Copied: strategoxt/branches/xml-front-java/tools/xml-front-options.str (from r23044, strategoxt/branches/xml-front-java/lib/xml-front-options.str)
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ strategoxt/branches/xml-front-java/tools/xml-front-options.str	Fri Jun 10 12:33:30 2011	(r23047, copy of r23044, strategoxt/branches/xml-front-java/lib/xml-front-options.str)
@@ -0,0 +1,46 @@
+module xml-front-options
+strategies
+
+  dispatch-explicit-mode(implicit, explicit, very-explicit) =
+      if use-explicit-mode then
+        explicit
+      else
+        if use-very-explicit-mode then
+          very-explicit
+        else
+          implicit
+        end
+      end
+
+  use-explicit-mode =
+    if <get-config> "--explicit-mode" then
+      <get-config> "--explicit-mode" => "--explicit"
+    end
+
+  use-implicit-mode =
+    <get-config> "--explicit-mode" => "--implicit"
+
+  use-very-explicit-mode =
+    <get-config> "--explicit-mode" => "--very-explicit"
+
+
+strategies
+
+  explicit-mode-option =
+    Option("--explicit"
+    , <set-config> ("--explicit-mode", "--explicit")
+    , !"--explicit       Use explicit XML elements for strings, lists, integers, and tuples (default)"
+    )
+  <+ Option("--very-explicit"
+    , <set-config> ("--explicit-mode", "--very-explicit")
+    , !"--very-explicit  Use explicit XML elements for applications, strings, lists, integers, and tuples"
+    )
+  <+ Option("--implicit"
+    , <set-config> ("--explicit-mode", "--implicit")
+    , !"--implicit       Don't use any explicit XML elements. This results in the most attractive XML, but it lacks structure."
+    )
+
+strategies
+
+  pass-explicit-mode =
+    <get-config> "--explicit-mode" <+ !"--explicit"

From m.dejonge at tudelft.nl  Fri Jun 10 16:28:37 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Fri, 10 Jun 2011 14:28:37 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23048 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client
Message-ID: <20110610142837.646E42B802B@mx2.tudelft.nl>

Author: MaartjeDeJonge
Date: Fri Jun 10 14:28:36 2011
New Revision: 23048
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23048&sc=1

Log:
Bugfix: weird characters in BP fragment

Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ParserHistory.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ParserHistory.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ParserHistory.java	Fri Jun 10 12:33:30 2011	(r23047)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ParserHistory.java	Fri Jun 10 14:28:36 2011	(r23048)
@@ -117,9 +117,10 @@
     public String getFragment(int startTok, int endTok, PushbackStringIterator chars) {
         String fragment="";
         for (int i = startTok; i <= endTok; i++) {
-            if(i >= recoverTokenCount)
+        	int nextChar = readCharAt(i, chars);
+            if(i >= recoverTokenCount || nextChar == -1)
                 break;
-            fragment+= (char)readCharAt(i, chars);
+            fragment+= (char)nextChar;
         }        
         return fragment;
     }

From m.dejonge at tudelft.nl  Fri Jun 10 19:46:06 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Fri, 10 Jun 2011 17:46:06 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23049 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client
Message-ID: <20110610174606.D203F108C009@mx3.tudelft.nl>

Author: MaartjeDeJonge
Date: Fri Jun 10 17:45:59 2011
New Revision: 23049
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23049&sc=1

Log:


Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/SGLR.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/SGLR.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/SGLR.java	Fri Jun 10 14:28:36 2011	(r23048)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/SGLR.java	Fri Jun 10 17:45:59 2011	(r23049)
@@ -1241,6 +1241,8 @@
 
 	protected void setCurrentToken(int currentToken) {
 		this.currentToken = currentToken;
+		if(currentToken == -1)
+			this.currentToken=SGLR.EOF;
 	}
 
 	protected int getCurrentToken() {

From m.dejonge at tudelft.nl  Sat Jun 11 12:56:11 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Sat, 11 Jun 2011 10:56:11 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23050 -
	spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project
Message-ID: <20110611105611.96F0C108C005@mx3.tudelft.nl>

Author: MaartjeDeJonge
Date: Sat Jun 11 10:56:05 2011
New Revision: 23050
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23050&sc=1

Log:


Modified:
   spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-example-trans.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-example-trans.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-example-trans.str	Fri Jun 10 17:45:59 2011	(r23049)
+++ spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-example-trans.str	Sat Jun 11 10:56:05 2011	(r23050)
@@ -198,7 +198,7 @@
   lib/refactor-common.generated
   include/{sdf-name}
   lib/editor-common.generated  
-  entitiesrefactorings
+  {name}
 
 rules
  

From L.C.L.Kats at tudelft.nl  Tue Jun 14 12:49:11 2011
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Tue, 14 Jun 2011 10:49:11 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23051 -
	spoofax-imp/trunk/org.strategoxt.imp.testing/trans
Message-ID: <20110614104911.75A11108C048@mx3.tudelft.nl>

Author: LennartKats
Date: Tue Jun 14 10:49:10 2011
New Revision: 23051
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23051&sc=1

Log:
Spoofax/388: Testing language string comparison

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str	Sat Jun 11 10:56:05 2011	(r23050)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str	Tue Jun 14 10:49:10 2011	(r23051)
@@ -93,4 +93,5 @@
   check-builder-expectation(|result) :
     ATerm(p) -> $[Unexpected output: [<write-to-string> result]]
     where
-      not(<aterm-eq> (result, p))
+      result' := <explode-aterm> result;
+      not(<aterm-eq> (result', p))

From seba at informatik.uni-marburg.de  Tue Jun 14 14:19:10 2011
From: seba at informatik.uni-marburg.de (Sebastian Erdweg)
Date: Tue, 14 Jun 2011 12:19:10 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23052 - in
	sugarj/trunk: compiler/org/sugarj/driver
	editor/editor/java/org/sugarj/editor
Message-ID: <20110614121910.336577F8046@mx1.tudelft.nl>

Author: SebastianErdweg
Date: Tue Jun 14 12:19:08 2011
New Revision: 23052
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23052&sc=1

Log:
bugfix

Modified:
   sugarj/trunk/compiler/org/sugarj/driver/Driver.java
   sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParser.java

Modified: sugarj/trunk/compiler/org/sugarj/driver/Driver.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/Driver.java	Tue Jun 14 10:49:10 2011	(r23051)
+++ sugarj/trunk/compiler/org/sugarj/driver/Driver.java	Tue Jun 14 12:19:08 2011	(r23052)
@@ -1554,9 +1554,11 @@
   
   private void clearGeneratedStuff() throws IOException {
     if (driverResult.getGenerationLog() != null && FileCommands.exists(driverResult.getGenerationLog())) {
-      ObjectInputStream ois = new ObjectInputStream(new FileInputStream(driverResult.getGenerationLog().getFile()));
+
+      ObjectInputStream ois = null;
       
       try {
+        ois = new ObjectInputStream(new FileInputStream(driverResult.getGenerationLog().getFile()));
         while (true) {
           try {
             Path p = (Path) ois.readObject();
@@ -1566,7 +1568,8 @@
         }
       } catch (Exception e) {
       } finally {
-        ois.close();
+        if (ois != null)
+          ois.close();
       }
 
       FileCommands.writeToFile(driverResult.getGenerationLog(), "");

Modified: sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParser.java
==============================================================================
--- sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParser.java	Tue Jun 14 10:49:10 2011	(r23051)
+++ sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParser.java	Tue Jun 14 12:19:08 2011	(r23052)
@@ -215,7 +215,8 @@
     RelativePath path = null;
     for (String s : sourcePath) {
       if (filename.startsWith(s)) {
-        RelativePath newPath = new RelativePath(new AbsolutePath(s), filename.substring(s.length() + 1));
+        int sepOffset = s.endsWith(Environment.sep) ? 0 : 1;
+        RelativePath newPath = new RelativePath(new AbsolutePath(s), filename.substring(s.length() + sepOffset));
         if (path == null || newPath.getBasePath().getAbsolutePath().length() < path.getBasePath().getAbsolutePath().length())
           path = newPath;
       }

From M.A.Akhter at student.tudelft.nl  Tue Jun 14 16:10:17 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Tue, 14 Jun 2011 14:10:17 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23053 - in
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax: editor
	trans/normalize
Message-ID: <20110614141018.0207DCC050@mx4.tudelft.nl>

Author: MdAdilAkhter
Date: Tue Jun 14 14:10:11 2011
New Revision: 23053
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23053&sc=1

Log:
* added builder to view normalized AST

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/editor/SpoofaxLang-Builders.esv
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/normalize/main.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/editor/SpoofaxLang-Builders.esv
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/editor/SpoofaxLang-Builders.esv	Tue Jun 14 12:19:08 2011	(r23052)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/editor/SpoofaxLang-Builders.esv	Tue Jun 14 14:10:11 2011	(r23053)
@@ -18,6 +18,10 @@
   builder : "Show abstract syntax (for selection)" =
     generate-aterm (openeditor) (realtime) (meta) (source)
 
+  builder : "Normalize-all" =
+  		normalize(openeditor) (realtime) (meta) (source)
+  
+  
   builder : "Show name analysis (for selection)" =
     generate-name-analysis (openeditor) (realtime) (meta) (source)
 
@@ -36,9 +40,6 @@
 	builder : "Build-All" =
     build-all (openeditor) (realtime) (meta)
 
-  //builder : "test desugar" =
-  // generate-desugar (openeditor) (realtime) (meta)
-
   builder : "Compile-All" =
     compile-spx(openeditor) (realtime) (meta)
 

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/normalize/main.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/normalize/main.str	Tue Jun 14 12:19:08 2011	(r23052)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/normalize/main.str	Tue Jun 14 14:10:11 2011	(r23053)
@@ -19,13 +19,29 @@
 imports
 	context/-
 
+
+rules 
+
+	 normalize:
+    (selected, position, ast, path, project-path) -> (filename, result)
+    with 
+    {| currently-precompiling-spx-abspath :
+    			current-spx-file-path := <concat-strings> [project-path , "/" , path];
+    			rules( currently-precompiling-spx-abspath :=  current-spx-file-path );    		
+   				filename := <guarantee-extension(|"aterm.desugared")> path;
+    		  result   := <normalize-all> ast // returning desugared AST
+	  |}
+       
+
+	
+strategies
+
 //TODO FIX :
 // Design issues :
 //	1. Package Common Imports are only for the current spx file at this moment
 //		 It could be kept as it is or make it common in the whole package. 
 //	2. When done with fixing origin tracking , normalize Import Statements
-	
-strategies
+
 	normalize-all = desugar-compilation-unit
 
 rules
@@ -45,6 +61,8 @@
 						<alltd(desugar-spx-package)> package* => modified-packages
 			|}
 
+	// desugaring package-wide imports
+	// TODO Consider : Deprecate 
 	desugar-imports:
 		i at Imports(import*) -> i
 		with

From m.dejonge at tudelft.nl  Tue Jun 14 21:32:56 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Tue, 14 Jun 2011 19:32:56 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23054 -
	spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services
Message-ID: <20110614193256.7C1F7CC1C3@mx4.tudelft.nl>

Author: MaartjeDeJonge
Date: Tue Jun 14 19:32:54 2011
New Revision: 23054
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23054&sc=1

Log:
menu button: refactoring buttons are disabled instead of invisible when the refactoring is not defined on current selection

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/IRefactoring.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/RefactoringButtonDelegate.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoRefactoring.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/IRefactoring.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/IRefactoring.java	Tue Jun 14 14:10:11 2011	(r23053)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/IRefactoring.java	Tue Jun 14 19:32:54 2011	(r23054)
@@ -14,5 +14,7 @@
 	String getName();
 
 	void prepareExecute(EditorState editor);
+	
+	boolean isDefinedOnSelection(EditorState editor);
 
 }

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/RefactoringButtonDelegate.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/RefactoringButtonDelegate.java	Tue Jun 14 14:10:11 2011	(r23053)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/RefactoringButtonDelegate.java	Tue Jun 14 19:32:54 2011	(r23054)
@@ -111,6 +111,7 @@
 			action.setActionDefinitionId(refactoring.getActionDefinitionId());
 			editor.getEditor().getSite().getKeyBindingService().registerAction(action);
 			ActionContributionItem item = new ActionContributionItem(action);
+			item.getAction().setEnabled(refactoring.isDefinedOnSelection(editor));
 			item.fill(menu, menu.getItemCount());
 		}		
 		dummy.dispose();

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoRefactoring.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoRefactoring.java	Tue Jun 14 14:10:11 2011	(r23053)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoRefactoring.java	Tue Jun 14 19:32:54 2011	(r23054)
@@ -60,6 +60,11 @@
 	
 	private Collection<TextFileChange> fileChanges;
 
+	public boolean isDefinedOnSelection(EditorState editor) {
+		// TODO Auto-generated method stub
+		return getSelectionNode(editor) != null;
+	}
+
 	public String getCaption() {
 		return caption;
 	}
@@ -102,7 +107,7 @@
 	public RefactoringStatus checkInitialConditions(IProgressMonitor pm) throws CoreException, OperationCanceledException {
 		RefactoringStatus status = new RefactoringStatus();
 		if(node == null)
-			status.merge(RefactoringStatus.createFatalErrorStatus("Editor is still analyzing"));	
+			status.merge(RefactoringStatus.createFatalErrorStatus("Refactoring is not defined for the current selection."));	
 		return status;
 	}
 

From m.dejonge at tudelft.nl  Tue Jun 14 21:39:52 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Tue, 14 Jun 2011 19:39:52 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23055 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/editor
Message-ID: <20110614193952.05583CC1C7@mx4.tudelft.nl>

Author: MaartjeDeJonge
Date: Tue Jun 14 19:39:51 2011
New Revision: 23055
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23055&sc=1

Log:


Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/editor/Stratego-Sugar-Builders.esv

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/editor/Stratego-Sugar-Builders.esv
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/editor/Stratego-Sugar-Builders.esv	Tue Jun 14 19:32:54 2011	(r23054)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/editor/Stratego-Sugar-Builders.esv	Tue Jun 14 19:39:51 2011	(r23055)
@@ -12,7 +12,7 @@
 
   observer : editor-analyze
   
-  refactoring Id: "Rename (refactoring)" = 
+  refactoring Id: "Rename" = 
   	rename-refactoring (source)
 
   builder : "Show analysed AST" =

From m.dejonge at tudelft.nl  Wed Jun 15 13:40:53 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Wed, 15 Jun 2011 11:40:53 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23056 - in
	spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime:
	dynamicloading parser/ast
Message-ID: <20110615114053.C3761CC208@mx4.tudelft.nl>

Author: MaartjeDeJonge
Date: Wed Jun 15 11:40:53 2011
New Revision: 23056
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23056&sc=1

Log:


Modified:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/RefactoringFactory.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/StrategoSubList.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/RefactoringFactory.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/RefactoringFactory.java	Tue Jun 14 19:39:51 2011	(r23055)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/RefactoringFactory.java	Wed Jun 15 11:40:53 2011	(r23056)
@@ -50,57 +50,48 @@
 		String ppStrategy=null;
 		if(ppStrategyTerm!=null)
 			ppStrategy=termContents(termAt(ppStrategyTerm, 0));		
-		IStrategoTerm node = controller.getEditor().getSelectionAst(false);
 		for (IStrategoAppl builder : collectTerms(d.getDocument(), "Refactoring")) {
 			IStrategoTerm[] semanticNodes = termAt(builder,0).getAllSubterms();
-			if(getMatchingSelectionNode(semanticNodes, node) != null){
-				String caption = termContents(termAt(builder, 1));
-				String strategy = termContents(termAt(builder, 2));
-				IStrategoList options = termAt(builder, 3);			
-				boolean cursor = false;
-				boolean source = false;
-				boolean meta = false;
-				for (IStrategoTerm option : options.getAllSubterms()) {
-					String type = cons(option);
-					if (type.equals("Cursor")) {
-						cursor = true;
-					} else if (type.equals("Source")) {
-						source = true;
-					} else if (type.equals("Meta")) {
-						meta = true;
-					} else if (
-							type.equals("OpenEditor") ||
-							type.equals("RealTime") ||
-							type.equals("Persistent")
-						){
-						Environment.logWarning("Unused builder annotation '"+ type + "' in '" + caption +"'");
-					}
-					else {
-						throw new BadDescriptorException("Unknown builder annotation: " + type);
-					}
+			String caption = termContents(termAt(builder, 1));
+			String strategy = termContents(termAt(builder, 2));
+			IStrategoList options = termAt(builder, 3);			
+			boolean cursor = false;
+			boolean source = false;
+			boolean meta = false;
+			for (IStrategoTerm option : options.getAllSubterms()) {
+				String type = cons(option);
+				if (type.equals("Cursor")) {
+					cursor = true;
+				} else if (type.equals("Source")) {
+					source = true;
+				} else if (type.equals("Meta")) {
+					meta = true;
+				} else if (
+						type.equals("OpenEditor") ||
+						type.equals("RealTime") ||
+						type.equals("Persistent")
+					){
+					Environment.logWarning("Unused builder annotation '"+ type + "' in '" + caption +"'");
 				}
-				if (!meta || d.isDynamicallyLoaded()){			
-					refactorings.add(
-						new StrategoRefactoring(
-							feedback, 
-							caption, 
-							strategy,
-							cursor, 
-							source, 
-							ppTable,
-							ppStrategy,
-							semanticNodes
-						)
-					);
+				else {
+					throw new BadDescriptorException("Unknown builder annotation: " + type);
 				}
 			}
+			if (!meta || d.isDynamicallyLoaded()){			
+				refactorings.add(
+					new StrategoRefactoring(
+						feedback, 
+						caption, 
+						strategy,
+						cursor, 
+						source, 
+						ppTable,
+						ppStrategy,
+						semanticNodes
+					)
+				);
+			}
 		}
 		return refactorings;
 	}
-
-	private static IStrategoTerm getMatchingSelectionNode(IStrategoTerm[] semanticNodes,
-			IStrategoTerm node) throws BadDescriptorException {
-		return InputTermBuilder.getMatchingNode(semanticNodes, node, false);
-	}
-
 }

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/StrategoSubList.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/StrategoSubList.java	Tue Jun 14 19:39:51 2011	(r23055)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/StrategoSubList.java	Wed Jun 15 11:40:53 2011	(r23056)
@@ -31,12 +31,11 @@
 	public static StrategoSubList createSublist(IStrategoList list, IStrategoTerm firstChild, IStrategoTerm lastChild, boolean updateParents) {
 		ArrayList<IStrategoTerm> children = new ArrayList<IStrategoTerm>();
 		boolean isStartChildFound = false;
-		int indexStart = 0;
-		int indexEnd = 0;
+		int indexStart = -1;
+		int indexEnd = -1;
 
 		int i = 0;
 		for (IStrategoTerm child : StrategoListIterator.iterable(list)) {
-			i++;
 			if (child == firstChild) {
 				indexStart = i;
 				isStartChildFound = true;
@@ -48,8 +47,9 @@
 					break;
 				}
 			}
+			i++;
 		}
-		
+		assert(0 <+ indexStart && indexStart <= indexEnd);
 		IStrategoList wrapped = Environment.getTermFactory().makeList(children);
 		StrategoSubList result = new StrategoSubList(list, wrapped, indexStart, indexEnd);
 		
@@ -84,10 +84,10 @@
 	}
 
 	public IStrategoTerm getFirstChild() {
-		return getSubterm(indexStart);
+		return getSubterm(0);
 	}
 
 	public IStrategoTerm getLastChild() {
-		return getSubterm(indexEnd);
+		return getSubterm(getSubtermCount()-1);
 	}
 }

From v.vergu at gmail.com  Wed Jun 15 17:00:34 2011
From: v.vergu at gmail.com (Vlag Vergu)
Date: Wed, 15 Jun 2011 15:00:34 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23057 - in
	spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego:
	. trans trans/rules trans/signatures trans/solver trans/tests
	trans/utils
Message-ID: <20110615150035.011AECC1DE@mx4.tudelft.nl>

Author: VladVergu
Date: Wed Jun 15 15:00:34 2011
New Revision: 23057
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23057&sc=1

Log:
New approach signatures declaration + checking
Basic rule match term checking
Can be disabled (because it crashes) with a .disable-sort-analysis file in project root

Added:
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/.disable-sort-analysis
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/rules/
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/rules/check.str
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/rules/constructors.str
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/rules/map.str
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/rules/project.str
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/rules/rename.str
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/solver/
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/solver/constraints.str
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/tests/
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/tests/constraints-test.str
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/tests/map-signature-test.str
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/tests/project-rule-test.str
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/tests/project-signature-test.str
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/tests/test-all.str
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/tests/utils-test.str
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/utils/annotations.str
Deleted:
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/utils/test.str
Modified:
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/analysis.str
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/signatures/check.str
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/signatures/constructors.str
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/signatures/map.str
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/signatures/pp.str
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/signatures/project.str
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/stratego_sugar.str
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/utils/utils.str

Added: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/.disable-sort-analysis
==============================================================================

Modified: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/analysis.str
==============================================================================
--- spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/analysis.str	Wed Jun 15 11:40:53 2011	(r23056)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/analysis.str	Wed Jun 15 15:00:34 2011	(r23057)
@@ -8,6 +8,8 @@
   sourcedir
 	signatures/project
 	signatures/map
+	rules/rename
+	rules/map
 	
 strategies
 
@@ -25,6 +27,9 @@
       end;
       if <file-exists> $[[project-path]/.warn-global-analysis] then
         rules(WarnAnalysis: _)
+      end;
+      if <file-exists> $[[project-path]/.disable-sort-analysis] then
+      	rules(DisableSortAnalysis: _)
       end
     with
       <basic-desugar-top> ast;
@@ -145,7 +150,9 @@
   declare-globals-top =
     if not(NoAnalysis) then
       with(<declare-globals> Import("libstratego-lib"));
-      alltd(declare-globals)
+      alltd(declare-globals);
+      declare-var-constraints;
+      alltd(resolve-var-constraints)
     end
 
   declare-globals:
@@ -153,17 +160,20 @@
     with
       x' := x{<declare-definition>};
       s' := <topdown(try(declare-dynrule))> s
-
+      
+		
   declare-globals:
     ExtSDef(x, s*, t*) -> <id>
     with
       redeclare-definition
 
   declare-globals:
-    OpDecl(x, t) -> OpDecl(x', t')
+    w at OpDecl(x, t) -> OpDecl(x', t'){decl-id}
     with
       cookie := <redeclare-definition>;
-      x'     := x{cookie}
+      x'     := x{cookie};
+      // each declaration gets a unique identifier
+      decl-id := <newterm>
     with
       // Declare congruence
       (x'', n) := <signature-of>;
@@ -171,23 +181,26 @@
       rules(
         DeclareCookie: sig' -> cookie
       )
-    with try(
-    	rename-sort-vars => t';
-      poly-sort-signature-of;
-      infer-var-sorts;
-      where (debug(!"> "));
-     	store-sort-decl
-    )
+    with
+    	if(not(DisableSortAnalysis)) then
+	    	t':= <rename-sort-vars> t;
+	    	!OpDecl(x,t'){decl-id};
+	      	poly-sort-signature-of;
+	     	where (store-sort-decl)
+	     end
   
   declare-globals:
-  	w at OpDeclInj(_) -> w
+  	w at OpDeclInj(t) -> OpDeclInj(t'){decl-id}
   	with
-  		type-sig :=  <poly-sort-signature-of> w;
-  		sort := <signature-sort> type-sig;
-  		<store-sort-decl> type-sig;
-			rules(
-				SortDeclare: sort -> type-sig
-			)
+  		decl-id := <newterm>
+	with
+		if(not(DisableSortAnalysis)) then
+			!w{decl-id};
+	    	t' := <rename-sort-vars>;
+	      	poly-sort-signature-of;
+	     	where (store-sort-decl)
+	    end
+    
 			
   declare-globals:
     ExtOpDecl(x, t) -> <id>
@@ -335,12 +348,21 @@
     alltd(propose-completion <+ declare-bodies)
 
   declare-bodies:
-    SDefT(x, s*, t*, s) -> SDefT(x, s'*, t'*, s')
+    SDefT(x, s*, t*, s) -> res
     with
       {| DeclareCookie:
         s'* := <map(declare-svar)> s*;
         t'* := <map(declare-tvar)> t*;
-        s'  := <declare-bodies-top> s
+        s'  := <declare-bodies-top> s;
+        res := SDefT(x, <rename-sort-vars> s'*, <rename-sort-vars> t'*, s'){<newterm>};
+        if(not(DisableSortAnalysis)) then
+	        if(<?Rule(_,_,_)> s) then
+	        	try(
+			        <rename-rule-vars> res;
+			        <declare-rule> res
+		       	)
+		      end
+		end
       |}
 
   declare-bodies:
@@ -469,7 +491,7 @@
   declare-svar:
     dec @ VarDec(x, t) -> VarDec(x', t)
     with
-      cookie := <newterm>;
+      cookie := <newterm> x;
       x'     := x{cookie};
       rules(
         DeclareCookie: (x, _, _) -> cookie

Added: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/rules/check.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/rules/check.str	Wed Jun 15 15:00:34 2011	(r23057)
@@ -0,0 +1,29 @@
+module check
+
+imports
+	libstrc
+	rules/map
+	rules/constructors
+	solver/constraints
+	analysis
+rules
+	
+	constraint-warning:
+		rule at SDefT(_, _, _, _){decl-id} -> (rule,$[This rule never matches valid signatures])
+		where not(DisableSortAnalysis)
+		where
+			<get-rule-signature> decl-id;
+			?RuleSig(_, _, _, in-s, _, _, _);
+			<filter(not(?(_,FAIL())))> in-s;
+			?[]
+	
+	
+	constraint-warning:
+		rule at SDefT(_, _, _, _){decl-id} -> (rule,$[This rule can never succeed because of an invalid match.])
+		where not(DisableSortAnalysis)
+		where
+			<get-rule-signature> decl-id;
+			?RuleSig(_, _, _, [], _, _, _)
+			
+			
+			
\ No newline at end of file

Added: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/rules/constructors.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/rules/constructors.str	Wed Jun 15 15:00:34 2011	(r23057)
@@ -0,0 +1,32 @@
+module constructors
+
+/**
+* Defines constructors necessary for sorting (typing) Stratego rules 
+*/
+
+imports
+	signatures/constructors
+	solver/constraints
+
+signature
+	constructors
+	/**
+	* Signature of a rule:
+	*		1. name (string)
+	*		2. list of parameter strategy variables
+	*		3. list of parameter term variables
+	*		4. input term variable
+	*		5. list of plausible output sorts (unapplied)
+	*		6. set of constraints over the variables
+	*		7. unique identification matching to actual rule definition
+	*/
+	RuleSig: String * List(Var) * List(Var)	* Var * List(Sort) * ConstraintSet * String -> RuleSig
+	
+	/**
+	* Constructor to hold a rule call:
+	*		1. name/cookie of the rule called
+	*		2. list of cookies representing parameter strategies
+	*		3. list of sorts given as parameter terms (possibly lists of lists)
+	*		4. the sort of the input term for the called rule
+	*/
+	RuleCall: String * List(String) * List(Sort) * Sort -> RuleCall
\ No newline at end of file

Added: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/rules/map.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/rules/map.str	Wed Jun 15 15:00:34 2011	(r23057)
@@ -0,0 +1,150 @@
+module map
+
+imports
+	libstrc
+	signatures/constructors
+	solver/constraints
+	signatures/project
+	signatures/map
+	rules/constructors
+	rules/project
+	
+rules /* store our own version of rule declarations */
+	
+	/*
+	* the analysis already maps rules to cookies based on the number of arguments. which is very nice,
+	*	we will reuse.
+	*/
+	
+	declare-rule:
+		def at SDefT(name{cookie}, s-vars, t-vars, rule){decl-id} -> def
+		where
+			log(|Error()," Declaring ");
+			debug(!"D1 ");
+			// get the signatures of all of the strategy parameters
+			s-vars' := <map(declare-argument-s)> s-vars;
+			debug(!"D2 ");
+			// the strategy Var(cookie)'s
+			s-vars'' := <map(\ (c,_) -> c\)> s-vars';
+			debug(!"D3 ");
+			// the strategy declarations
+			s-vars-constraints := <map(\ (Var(c),sig) -> CSet([Constraint(c,sig)]) \);to-constraint-intersection> s-vars';
+			debug(!"D4 ");
+			// get the signatures of all the term parameters
+			t-vars' := <map(declare-argument-t)> t-vars;
+			debug(!"D5 ");
+			// the term Var(cookie)'s
+			t-vars'' := <map(\ (c,_) -> c \)> t-vars';
+			debug(!"D6 ");
+			// the sort constraints
+			t-vars-constraints := <map(\ (Var(c),sig) -> CSet([Constraint(c,sig)]) \);to-constraint-intersection> t-vars';
+			debug(!"D7 ");
+			(in-t,out-t,rule-constraints) := <declare-rule> rule;
+			// (in-t,out-t,rule-constraints) := (Var("xxx"),[<sort-any>],CSet([]));
+			debug(!"D8 ");
+			// build the signature
+			sig := RuleSig(name,s-vars'',t-vars'',in-t,out-t, <solve-top>  ISection(s-vars-constraints,ISection(t-vars-constraints,rule-constraints)),decl-id);
+			debug(!"D9 ");
+			// store the signature
+			<store-rule-signature(|cookie)> sig;
+			debug(!"D10 ")
+	
+	/**
+	* Processes a rule definition and returns information inferred to the caller in the form of a tuple. Used to build the RuleSig of rules
+	* @type Rule(..) -> (Sort,[Sort],ConstraintSet)
+	*/
+	declare-rule:
+		Rule(match, build, _) -> (in-sorts,[],CSet([]))
+		where
+			debug(!"DR 1");
+			in-sorts := <sort-of> match;
+			debug(!"DR 2")
+	
+		
+	/**
+	* Converts a match op into a variable and constraints
+	* @type: match -> (Var(v),ConstraintSet)
+	*/
+	// match-to-sort:
+	// 	match -> <fail>
+	// 
+	// match-to-sort:
+	// 	As(var,t) -> (in-sorts,out-sorts,constraints)
+	// 	with
+	// 		// we need to make constraints
+	
+	/**
+	* Produce a rule signature (RuleSig) for argument strategies.
+	* If the strategy does not provide any type information we will infer the default:
+	* ATerm -> ATerm
+	*
+	* @type VarDec(_{cookie},FunType(Sort,Sort)) -> (Var(cookie),RuleSig("",[],[],in-t,out-ts,constraints,_))
+	*/
+	declare-argument-s:
+		VarDec(_{cookie},FunType(s,t)) -> (Var(cookie),RuleSig("",[],[],in-ts,out-ts,in-ts-constraints,<newterm>))
+		with
+			/* --> input term processing  --> */
+			debug(!"S1 ");
+			// s is a list but we don't care because that doesn't actually mean anything in rule signatures
+			<sort-signature-of> s;
+			debug(!"S2 ");
+			last;
+			debug(!"S3 ");
+			// get all compatible declarations
+			get-compatible-sorts;
+			debug(!"S4 ");
+			// new variable for input term
+			where ( in-ts at Var(in-varname) := <new-var>);
+			debug(!"S5 ");
+			// unify to constraints
+			in-ts-constraints := <map(\ candidate -> CSet([Constraint(in-varname,candidate)]) \);to-constraint-union>;
+			debug(!"S6 ");
+			/* <-- input term processing <-- */
+			/* --> output term processing --> */
+			// get all compatible declarations
+			out-ts := <get-compatible-sorts> <sort-signature-of> t;
+			debug(!"S7 ")
+			/* <-- output term processing <-- */
+	
+	declare-argument-s:
+		VarDec(_{cookie},ConstType(s)) -> (Var(cookie),RuleSig("",[],[],in-var,outs,CSet([Constraint(in-var,<sort-any>)]),<newterm>))
+		with
+			<sort-signature-of> s;
+			outs := <get-compatible-sorts>;
+			in-var at Var(in-varname) := <new-var>
+	
+	/**
+	* Produce a sort signature for argument terms. If the term does not provide any information
+	* we will infer the default: ATerm
+	*
+	* @type VarDec(_{cookie},ConstType(Sort)) -> (Var(cookie),List(Sort))
+	*/
+	declare-argument-t:
+		VarDec(_{cookie},ConstType(s)) -> (Var(cookie),outs)
+		with
+			<sort-signature-of> s;
+			outs := <get-compatible-sorts>
+	
+rules /* rule signature storage */
+
+	store-rule-signature(|cookie):
+		sig at RuleSig(name{cookie},_,_,_,_,_,decl-id) -> sig
+		where <not(get-rule-signature)> decl-id
+		with
+			rules (
+				DeclaredRule:+ cookie -> decl-id
+				RuleSig: decl-id -> sig
+			)
+	
+	replace-rule-signature:
+		sig at RuleSig(_,_,_,_,_,_,decl-id) -> sig
+		where <get-rule-signature> decl-id
+		with rules (
+			RuleSig: decl-id -> sig
+		)
+		
+	get-rule-signatures:
+		_{cookie} -> <bagof-DeclaredRule;map(get-rule-signature)> cookie
+		
+	get-rule-signature:
+		decl-id -> <RuleSig> decl-id

Added: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/rules/project.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/rules/project.str	Wed Jun 15 15:00:34 2011	(r23057)
@@ -0,0 +1,388 @@
+module project
+
+imports
+	signatures/project
+	signatures/map
+	signatures/constructors
+	solver/constraints
+	utils/utils
+	libstrc
+
+rules
+	
+	/**
+	* projections of Stratego AST matchers to plausible sorts
+	* the sort-of rules follow the following type signature
+	* @type: ATerm -> List((Sort,ConstraintSet))
+	*/
+	
+	sort-of:
+		Explode(_, _) -> [(<sort-any>,CSet([]))]
+		with log(|Critical(),"Encountered Explode(_,_) in sort-of. NO SUPPORT.")
+	
+	sort-of:
+		AnnoList(t, _) -> <sort-of> t
+		with log(|Error(),"Ignoring annotation in sort-of. NO SUPPORT")
+	
+	sort-of:
+		Wld() -> [(<sort-any>,CSet([]))]
+	
+	sort-of:
+		Str(_) -> [(String(),CSet([]))] //,("ID"#([]),CSet([]))]
+	
+	sort-of:
+		Int(_) -> [(Int(),CSet([]))]
+	
+	sort-of:
+		Real(_) -> [(Double(),CSet([]))]
+	
+	sort-of:
+		Var(x{cookie}) -> [(Var(cookie),CSet([Constraint(cookie,<sort-any>)]))]
+	
+	sort-of:
+		Tuple(elems) -> result
+		where
+			// debug(!"SOC1 ");
+			elems-sorts := <map(sort-of)> elems; // [ [(Sort,ConstraintSet)] ]
+			// debug(!"SOC2 ");
+			// get the cartesian product with <solved> constraint intersection
+			map(\ x -> <map(\ (s,c) -> ([s],c) \)> x \);
+			// debug(!"SOC4 ");
+			long-cart(\ ((s1,c1),(s2,c2)) -> (<conc> (s1,s2),<solve-top> ISection(c1,c2)) \);
+			// debug(!"SOC5 ");
+			// remove the FAIL()-ed ones
+			filter(not(?(_,FAIL())));
+			// debug(!"SOC6 ");
+			// transform to (Tuple-x(elems),constraints)
+			map(\ (s,c) -> (<new-tuple-sort> s,c) \) => result
+			// debug(!"SOC7 ")
+	
+	sort-of:
+		NoAnnoList(t) -> res
+		where res := <sort-of> t
+	
+	sort-of:
+		List([]) -> [(List(),CSet([]))]
+	
+	// if not all elements of the list are compatible, then it's a list of ATerm()
+	sort-of:
+		List(elems) -> [(List(srt),<solve-top> constraints)]
+		where <not(?[])> elems
+		where
+			debug(!"SOLA1 ");
+			elems-sorts := <map(sort-of)> elems; // [ [(Sort,ConstraintSet)] ]
+			debug(!"SOLA2 ");
+			// attempt to combine all sort options for each of the elements. if they are not compatible replace with ATerm
+			if(?[_|_]) then
+				map(\ e-sort -> <reducel(\ ((s1,c1),(s2,c2)) -> (<sort-apply> (s1,s2), Union(c1,c2)) \)> e-sort \ <+
+						\ e-sort -> <reducel(\ ((_,c1),(_,c2)) -> (<sort-any>,Union(c1,c2)) \)> e-sort \)
+			end;
+			debug(!"SOLA3 ");
+			// temporarily replace the variables with their constraints
+			mapconcat(explode-sort); // [ [Sort] ]
+			debug(!"SOLA4 ");
+			// try to apply to get a sort. we can end up with either a sort, or ATerm
+			// srt := <foldll(!ATerm(), \ (l,r) -> <sort-apply <+ sort-any> (l,r) \)>;
+			srt := <reducel(\ (l,r) -> <sort-apply <+ sort-any> (l,r) \)>;
+			debug(!"SOLA5 ")
+		where
+			// make a list of all the constraint sets
+			// unify and intersect constraints
+			<map(\ e-sort -> <map(\ (_,b) -> b \);to-constraint-union> e-sort \)> elems-sorts;
+			debug(!"SOLA6 ");
+			constraints := <to-constraint-intersection>;
+			debug(!"SOLA7 ")
+	
+	sort-of:
+		ListTail(elems,rest) -> [result-tup]
+		where
+			debug(!"SOLB1 ");
+			[(List(elem-srts),elem-constraints)] := <sort-of> List(elems);
+			debug(!"SOLB2 ");
+			<sort-of> rest; // [ [(Sort,Constraint)] ]
+			// the common sorts of the elems must become the same as the common sorts of rest
+			if (?[_]) then
+				debug(!"SOLB3 ");
+				?[rest-sorts]; 
+				switch !rest-sorts
+					case ?(List(),rest-constraints):
+						debug(!"SOLB4 ");
+						result-tup := (List(elem-srts),<solve-top> ISection(elem-constraints,rest-constraints));
+						debug(!"SOLB5 ")
+					case ?(List(rest-sort),rest-constraints):
+						debug(!"SOLB6 ");
+						// relax the constraints
+						rest-sort' := <innermost(\ Var(v) -> <sort-any> \)> rest-sort;
+						debug(!"SOLB7 ");
+						// re-tighten constraints
+						result-tup := (List(<sort-apply <+ sort-any> (elem-srts,rest-sort')), <solve-top> ISection(elem-constraints,rest-constraints));
+						debug(!"SOLB8 ")
+					case ?(Var(v),rest-constraints):
+						debug(!"SOLB9 ");
+						result-tup := (List(elem-srts),<solve-top> ISection(CSet([Constraint(v,List(elem-srts))]),ISection(elem-constraints,rest-constraints)));
+						debug(!"SOLB10 ")
+					case ?(rest-sort,rest-constraints):
+						debug(!"SOLB11 ");
+						// if rest sort is not ATerm, it's likely that rest-tup is a user sort and not a list. then it cannot be the tail, and we really trully must fail this term
+						if(<is-sort-any> rest-sort) then
+							result-tup := (List(<sort-any>),<solve-top> ISection(elem-constraints,rest-constraints))
+						else
+							result-tup := (List(<sort-any>), FAIL())
+						end;
+						debug(!"SOLB12 ")
+				end
+			else
+				debug(!"SOLB13 ");
+				?[_,_|_];
+				debug(!"SOLB14 ");
+				// our assumption is that there can be nothing but Sorts here. let's enforce that
+				where (
+					debug(!"SOLB15 ");
+					filter(?(Var(_),_) + ?(List(),_) + ?(List(_),_));
+					debug(!"SOLB16 ");
+					if(not(?[])) then
+						fatal-err(|"Assumption regarding list tail sorts has failed. ")
+					end
+				);
+				debug(!"SOLB17 ");
+				// in that case we can fail the current list
+				result-tup := (List(<sort-any>),FAIL());
+				debug(!"SOLB18 ")
+			end;
+			debug(!"SOLB19 ")
+	
+	// FIXME: the As variable binding should be replaced with some sort of late binding.
+	sort-of:
+		As(Var(var{cookie}),y) -> result
+		where
+			// debug(!"SAS1 ");
+			<sort-of> y;
+			// debug(!"SAS2 ");
+			result := <map(\ (s,c) -> (s,<solve-top> ISection(c,<explode-sort(|c);map(\ s' -> CSet([Constraint(cookie,s')]) \);to-constraint-union> s)) \)>
+			// debug(!"SAS3 ")
+	
+	sort-of:
+		Op(conc{cookie},[]) -> result
+		where
+			debug(!"SNOARGS1 ");
+			// get all the declarations for this constructor
+			<get-signatures-for-constructor> $[[conc]];
+			debug(!"SNOARGS2 ");
+			// keep only those with zero arguments
+			filter(?ConstSig(_, [], _,_,_));
+			?[_|_];
+			debug(!"SNOARGS3 ");
+			map(\ ConstSig(_,_,s-out,_,_) -> (s-out,CSet([])) \) => result;
+			debug(!"SNOARGS4 ")
+
+	sort-of:
+		Op(conc{cookie},args) -> result
+		where <not(?[])> args
+		where
+			num-args := <length> args
+		where
+			// sorts and constraints plausible for each of the arguments
+			// [ [(Sort,ConstraintSet)] ]
+			debug(!"SO1 ");
+			<map(sort-of)> args;
+			debug(!"SO2 ");
+			?[ [(_,_)|_]|_]; // just to be sure
+			debug(!"SO3 ");
+			// transform to [ [([Sort],ConstraintSet)] ]
+			map(\ x -> <map(\ (s,c) -> ([s],c) \)> x \);
+			debug(!"SO4 ");
+			?[ [([_],_)|_]|_]; // just to be sure
+			debug(!"SO5 ");
+			if(not(?[_] + ?[])) then
+				// get cartesian product of the plausible sorts
+				// we need a list of lists. each of the sub-lists has the length equal to the number of arguments
+				long-cart(\ ((s1,c1),(s2,c2)) -> (<conc> (s1,s2),<solve-top> ISection(c1,c2)) \)
+			else
+				// just unpack the contents from the list
+				head
+			end;
+			debug(!"SO6 ");
+			?[ ([_|_],_)|_];
+			debug(!"SO7 ");
+			// remove anything which has failed contraints
+			filter(not(?(_,FAIL()))) => plausible-argument-sorts;
+			debug(!"SO8 ")
+		where
+			debug(!"SO9 ");
+			// get all the declarations for this constructor
+			( <get-signatures-for-constructor> $[[conc]] + <get-signatures-for-constructor> conc );
+			// keep only the ones that have the same number of arguments
+			filter(where(\ ConstSig(_,a,_,_,_) -> <eq> (<length> a, num-args) \));
+			debug(!"SO10 ");
+			// convert each signature to list of tuples of args and constraints
+			map(\ sig at ConstSig(_,_,_,c,_) -> (<signature-sort> sig,c) \);
+			debug(!"SO11 ");
+			// replace FAIL() constraints with new variables
+			map(try(\
+				(sig,FAIL()) -> (sig, <collect-all(\ Var(x) -> x\,union);new-configuration> sig)
+			\));
+			debug(!"SO12 ");
+			// explode each argument for the constraints
+			mapconcat(\ (sig,c) -> <explode-sort(|c)> sig \);
+			debug(!"SO13 ");
+			// try to apply the arguments of each sort to the arguments in plausible-argument-sorts and constrain the variables
+			// the result should be a list of tuples (Sort,ConstraintSet)
+			// if an application fails, just add FAIL() to the constraint set so that we can really fail the result later
+			map(\
+				// FIXME: the use-constraints must be interesected as well
+				s#(d-args) -> <	debug(!"S013- ");
+												map(\ (u-args,u-constraints) -> <debug(!"PREZIP ");zip(local-coerce(|u-constraints));debug(!"ZIP RES ")> (d-args,u-args) \);
+												debug(!"SO13A ");
+												map(reducel(\ ((s1,c1),(s2,c2)) -> (<conc> (s1,[s2]),<solve-top> ISection(c1,c2)) \ <+
+																\ ((s1,c1),(s2,c2)) -> (<conc> ([s1],[s2]),<solve-top> ISection(c1,c2)) \));
+												debug(!"SO13B ");
+												// all of the first element of each tuple must be a list
+												map(try(\
+													(s,c) -> ([s],c)
+													where <not(is-list)> s
+												\));
+												if(not(?[([_|_],_)|_] + ?[])) then
+													fatal-err(|"Even after forcing, the list is not a list. ")
+												end;
+												// try(where(not(?([_|_],_));debug(!"SO13B1 "));\ (a,b) -> ([a],b) \;where(debug(!"SO13B2 ")));
+												map(construct-solve(|s));
+												debug(!"SO13C ")
+											> plausible-argument-sorts
+			\);
+			try(concat);
+			// remove all the fails
+			debug(!"SO14- ");
+			filter(not(?(_,FAIL())));
+			debug(!"SO14+ ");
+			// attempt to reduce duplicates. the duplicates are likely to be adjacent, and if they are not, so be it
+			// TODO: instead of adjacent identical sorts, we can try sort-compatible adjacent sorts.
+			// only if the list is longer than 1
+			// if the result is empty
+			if (?[]) then
+				![(<sort-any>,FAIL())]
+			end;
+			if (?[_]) then
+				result := <id>
+				// id
+			else
+				result := <duplicate-union>
+				// duplicate-union
+			end;
+			// for each one of the possible sorts, we need to expand the sort for all of the Inj sorts (equivalent sorts)
+			debug(!"SO15 ")
+			// mapconcat( \
+			// 	t@(s#(args),c) -> [t|xs]
+			// 	where
+			// 		debug(!"X1 ");
+			// 		all-keys-SortSig;
+			// 		mapconcat(bagof-SortSig);
+			// 		debug(!"X2 ");
+			// 		filter(?ConstSig("",[s#([])],_,_,_));
+			// 		debug(!"X3 ");
+			// 		// keep only s-outs
+			// 		map(\ ConstSig(_,_,o#(_),_,_) -> (o#(args),c) \) => xs;
+			// 		debug(!"X4 ")
+			// \);
+			// result :=[];
+			// debug(!"SO16 ")
+			
+		
+		duplicate-union:
+			[a,b|xs] -> <duplicate-union> [a'|xs]
+			where
+				// a & b are the same in the sort positions
+				<?(s,ca)> a;
+				<?(s,cb)> b;
+				// then unify the constraints and produce only one tuple
+				a' := (s,<solve-top> Union(ca,cb))
+		
+		duplicate-union:
+			[a,b|xs] -> [a|<duplicate-union> [b|xs]]
+			where not(
+				<?(s,ca)> a;
+				<?(s,cb)> b
+			)
+		
+		duplicate-union:
+			[a] -> [a]
+				
+		
+		/**
+		* Local strategy to help us go from a tuple of sorts and constraints to a tuple of sort and solved constraints.
+		* The only reason this is required is to avoid the binding of variables in the caller's traversal
+		* @param String
+		* @type (List(Sort),ConstraintSet) -> (String#(List(Sort),ConstraintSet)
+		*/
+		construct-solve(|srt):
+			(args,constraints) -> out //(srt#(args),<solve-top> constraints)
+			with
+				debug(!"CSOLVE IN ");
+				s-out := srt#(args);
+				// debug(!"CS2 ");
+				constraints-out := <solve-top> constraints;
+				// debug(!"CS3 ");
+				out := (s-out,constraints-out);
+				debug(!"CSOLVE OUT ")
+		
+		
+		/**
+		* @type (Sort,Sort) -> (Sort,ConstraintSet)
+		*/ 
+		local-coerce(|constraints):
+			(source,target) -> (out-sort,out-constraints)
+			where {| ExtraConstraints:
+				debug(!"COERCE IN ");
+				// // get all the variable positions from target
+				// v-pos := <positions-of-term(?Var(_))> target;
+				// debug(!"LC2 ");
+				// // get the source positions at variable positions
+				// s-at-pos := <terms-at-positions(|v-pos)> source;
+				// debug(!"LC3 ");
+				// // get the actual variables
+				// v-at-pos := <terms-at-positions(|v-pos);map(\ Var(v) -> v \)> target;
+				// debug(!"LC4 ");
+				// // convert to constraints
+				// new-constraints := <zip(\ (v,s) -> CSet([Constraint(v,s)]) \);to-constraint-intersection> (v-at-pos,s-at-pos);
+				// debug(!"LC5 ");
+				// try to apply the sorts now
+				if(tmp-out-sort := <sort-apply> (source,target)) then
+					// alas, success!
+					// <debug(!"LC5A1 ")> tmp-out-sort;
+					switch !tmp-out-sort
+						case ?[_|_]:
+							// debug(!"LC5A1-1A ");
+							out-sort := <head> tmp-out-sort;
+							// out-constraints := ISection(constraints,<bagof-ExtraConstraints;to-constraint-intersection>)
+							out-constraints := ISection(constraints,<ExtraConstraints <+ !CSet([])>)
+							// debug(!"LC5A1-1B ")
+						case ?[]:
+							// debug(!"LC5A1-2A ");
+							out-sort := target;
+							out-constraints := FAIL()
+							// debug(!"LC5A1-2B ")
+						otherwise:
+							// debug(!"LC5A1-3A ");
+							out-sort := tmp-out-sort;
+							// out-constraints := ISection(constraints,<bagof-ExtraConstraints;to-constraint-intersection>)
+							out-constraints := ISection(constraints,<ExtraConstraints <+ !CSet([])>)
+							// debug(!"LC5A1-3B ")
+					end
+					// if(<?[_|_]> tmp-out-sort) then
+					// <debug(!"LC5A1 ")> out-sort;
+					// // out-constraints := new-constraints;
+					// out-constraints := <bagof-ExtraConstraints;to-constraint-intersection>;
+					// debug(!"LC5A2 ")
+				else
+					// darn
+					// debug(!"LC5B1 ");
+					out-sort := target;
+					// out-constraints := ISection(new-constraints,FAIL());
+					out-constraints := FAIL()
+					// debug(!"LC5B2 ")
+				end;
+				<debug(!"COERCE OUT ")> (out-sort,out-constraints)
+			|}
+
+
+		
+		
\ No newline at end of file

Added: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/rules/rename.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/rules/rename.str	Wed Jun 15 15:00:34 2011	(r23057)
@@ -0,0 +1,39 @@
+module rename
+
+imports libstrc
+imports signatures/map
+
+rules
+	// the renaming is already handled in the analysis, we just add our own wrapper on top
+
+	rename-rule-vars:
+		dec at SDefT(name, s-vars, t-vars, rule) -> dec
+		with
+			<alltd(rename-var)> s-vars;
+			<alltd(rename-var)> t-vars;
+			<alltd(rename-var)> rule
+	
+	rename-var:
+		dec at VarDec(v{cookie},t) -> dec
+		with <redeclare-cookie(|cookie)> v
+			
+	
+	rename-var:
+		call at SVar(v{cookie}) -> call
+		with <redeclare-cookie(|cookie)> v
+	
+	rename-var:
+		use at Var(v{cookie}) -> use
+		with <redeclare-cookie(|cookie)> v
+	
+	redeclare-cookie(|cookie):
+		target -> target
+		with
+			if(<not(RenamedVarCookie)> cookie) then
+				rules(
+					RenamedVarCookie: cookie -> target
+				)
+			end
+			
+			
+			
\ No newline at end of file

Modified: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/signatures/check.str
==============================================================================
--- spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/signatures/check.str	Wed Jun 15 11:40:53 2011	(r23056)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/signatures/check.str	Wed Jun 15 15:00:34 2011	(r23057)
@@ -2,73 +2,268 @@
 
 imports
 	libstrc
+	analysis
 	signatures/constructors
 	signatures/map
 	signatures/project
 	signatures/pp
+	solver/constraints
+	utils/utils
 
-rules // sort constraints
+rules 
 	
-	// not declared SortNoArgs or Sort
+	/* name checking */
+	
+	/* Warn about redeclaration of primitive sorts */
+	constraint-warning:
+		OpDecl(_,c at ConstType(_)) -> <constraint-warning-wrapped> c
+		
+	constraint-warning:
+		OpDecl(_,FunType(_,c)) -> <constraint-warning-wrapped> c
+	
+	constraint-warning:
+		OpDeclInj(ConstType(c)) -> <constraint-warning-wrapped> c
+	
+	constraint-warning:
+		OpDeclInj(FunType(_,c)) -> <constraint-warning-wrapped> c
+	
+	constraint-warning-wrapped:
+		use -> (use, $[Redeclares primitive sort [<pp-sort-signature-top> s-dec]])
+		where not(DisableSortAnalysis)
+		where
+			sort-signature-of => s-dec;
+			is-sort-prim
+	
+	/* error about undeclared Sorts */
 	global-constraint-error:
 		_ -> (s, $[The sort [<pp-sort-signature-top> s'] is not declared])
+		where not(DisableSortAnalysis)
+		where ?s at SortNoArgs(_) + ?s at Sort(_,_)
 		where
-			?s at SortNoArgs(_) + ?s at Sort(_,_)
-		where
+			// debug(!"B1 ");
 			sort-signature-of => s';
-			get-sort-decls;
+			// debug(!"B2 ");
+			get-sort-declarations;
 			?[]
-
-	// unknown generic sort vars on RHS of signature
+	
+	/* sort usage with incorrect number of parameters. unparameterized is allowed */
 	global-constraint-error:
-		d at OpDecl(_,_) -> msgs 
+		_ -> (s, $[The sort [s-name]/[num-args] is not declared])
+		where not(DisableSortAnalysis)
+		where ?s at SortNoArgs(s-name) + ?s at Sort(s-name,s-args@[_|_])
+		where <length + !0> s-args => num-args
+		where
+			// debug(!"A1 ");
+			sort-signature-of;
+			// debug(!"A2 ");
+			get-sort-declarations;
+			// keep only the ones that have the same num of args
+			?[_|_];
+			filter(\
+				d at ConstSig(_,args,_,_,_) -> <eq> (<length> args, num-args)
+			\);
+			?[]
+			
+	/* note that the RHS arguments are optional */
+	constraint-note:
+		_ -> <constraint-note-wrapped> s
+		where not(DisableSortAnalysis)
+		where
+			?OpDecl(_,ConstType(s)) +
+			?OpDecl(_,FunType(_,ConstType(s))) +
+			?OpDeclInj(ConstType(s)) +
+			?OpDeclInj(FunType(_,ConstType(s)))
+		
+	constraint-note-wrapped:
+		s at Sort(_,_) -> (s,$[Parameterization on the RHS is optional])
+		where not(DisableSortAnalysis)
+		
+	/* warning if the RHS arguments are not the same as the LHS arguments (although they are optional) */
+	constraint-warning:
+		_ -> (s,$[The RHS parameterization (optional) does not correspond to RHS arguments])
+		where not(DisableSortAnalysis)
 		where
-			poly-sort-signature-of => sig at ConstSig(_,[_|_],sort,_);
-			srtVars := <collect-all(?Var(_),union)> sort;
-			<filter(\
-				Var(v) -> v
-				where not( <is-freevar(|v)> sig )
-			\)> srtVars;
-			map(\
-				v -> (v, $[Unknown sort variable [<RenamedVarCookie> v]. It should be declared in left-hand-side])
-			\) => msgs@[_|_] // force fail if no errors
-	
-	constraint-warning:
-		d at OpDecl(_,_) -> msgs
-		where
-			poly-sort-signature-of => sig at ConstSig(_,[],sort,_);
-			srtVars := <collect-all(?Var(_),union)> sort;
-			map(\
-				Var(v) -> (v, $[Unknown sort variable [<RenamedVarCookie> v]. Either declare in left-hand-side or remove it from right-hand-side])
-			\) => msgs
+			?OpDecl(_,FunType(a,ConstType(s at Sort(_,a')))) +
+			?OpDeclInj(FunType(a,ConstType(s at Sort(_,a'))))
+		where not(
+			a'' := <map(\ ConstType(s) -> s \)> a;
+			<zip> (a'',a');
+			filter(not(eq));
+			?[]
+		)
 	
-	// incompatible sort application
-	global-constraint-error:
-		s at Sort(_,_) -> (s,$[The sort application [<pp-sort-signature-top> s'] is not compatible with any of its declarations:
-			 [<pp-list(pp-sort-signature-top|", ")> decl]])
-		where debug(!"Checking: ")
+	constraint-warning:
+		_ -> (s,$[The RHS parameterization (optional) does not correspond to LHS arguments])
+		where not(DisableSortAnalysis)
+		where
+			?OpDecl(_,ConstType(s at Sort(_,_))) +
+			?OpDeclInj(ConstType(s at Sort(_,_)))
+	
+	
+	global-constraints-error = non-global-constraint-error
+	
+	/**
+	* Check that the sort usages are applicable to their declarations
+	* This only checks sorts that have no variables. The idea is that if we have variables some other rule is going to explode them and wrap us
+	*/
+	non-global-constraint-error:
+		s at Sort(_,_) -> (s, $[The sort application [<pp-sort-signature-top> s'] is not compatible with any of its declarations: [<pp-list(pp-sort-signature-top|", ")> decls] ])
+		where not(DisableSortAnalysis)
 		where
+			// only if it has no variables
+			collect-all(?SortVar(_),conc);?[]
+		where
+			// get the sort declarations
+			// debug(!"1 ");
 			sort-signature-of => s';
-			get-sort-decls;
-			map(signature-sort) => decl;
-			<not(sort-apply)> (s',decl);
-			<innermost(\ Var(v) -> <get-var-sorts;not(?[])> v \);collect-all(?Var(_));?[]> decl
-			
-			
-	// Warn about sort variables that are constrained to a single Sort which is not Term or List or Option
-	constraint-warning:
-		d at OpDecl(_,_) -> messages
-		where
-			poly-sort-signature-of => ConstSig(_,_,_,freevars);
-			// for each variable get their possible sorts
-			// for all the variables that have only a single possible sort which is not Term, give a warning
-			<map(\
-				var -> (Var(var),$[Sort variable [<RenamedVarCookie> var] is not polymorphic ([<pp-sort-signature> srt])])
-				where
-					<get-var-sorts> var;
-					?[srt];
-					not(?[Term()])
-			\)> freevars => messages
+			// debug(!"2 ");
+			get-sort-declarations;
+			// debug(!"3 ");
+			// remove all the ones that have FAIL in the configuration (not plausible)
+			filter(not(?ConstSig(_,_,_,FAIL(),_))); // TODO: replace the ones with FAIL() with new-configuration with ATerm() such that we can continue checking
+			// debug(!"4 ");
+			map( \ csig at ConstSig(_,_,_,d-config,_) -> (<signature-sort> csig,d-config) \);
+			// debug(!"5 ");
+			// only continue if there are some declarations left;
+			?[_|_];
+			// debug(!"6 ");
+			// explode all the variable configurations in the declarations
+			// mapconcat(\
+			// 		(srt,constraints) -> <collect-all(?CSet(_),conc);map(\ cset -> <substitute(|cset)> srt \)> constraints
+			// \)  => decls;
+			mapconcat(explode-sort) => decls;
+			// debug(!"7 ");
+			// keep all the declarations that apply
+			filter(\ dec -> <sort-apply> (s',dec) \);
+			// debug(!"8 ");
+			?[]
+			// debug(!"9 ")
+			// decls := <map(\ (a,_) -> a \)> sort-constraint-declarations;
+			// debug(!"10 ")
+	
+	global-constraint-error:
+		c at ConstType(Sort(_,_)){FAIL()} -> (c,$[There's a failure (probably caused by variable sorts) in this sort. (TODO: better message => make constraints FAIL per variable and piggyback message on it)])
+		where not(DisableSortAnalysis) 
+		
+	/** 
+	* Error about overlapping signatures.
+	*
+	*	Overlapping signatures declarations are constructors declarations which:
+	* 1. have the same constructor name
+	* 2. have the same number of arguments
+	* 3. the declared sorts are or are not the same
+	* 4. each argument from one is compatible with the corresponding argument from the other
+	*/
+	constraint-warning: 
+		dec at OpDecl(cons{_}, _){decl-id} -> (dec,$[Constructor declaration overlaps with these declarations [<pp-list(pp-sort-signature-top|" <br /> ")> overlaps]])
+		where not(DisableSortAnalysis)
+		where
+			ConstSig(_, args', _, constraints, _) := <get-sort-declaration> decl-id;
+			// explode all the arg' that have constraints. If we have FAIL() we allow ourselves to crash hard, because that error has priority
+			args := <map(\ srt -> <explode-sort(|constraints);\ [x] ->  x \> srt \)> args';
+			num-args := <length> args
+		where
+			// get all declarations for this constructor
+			<get-signatures-for-constructor> $[[cons]];
+			// remove our own declaration, and ones that don't have the same number of arguments
+			filter(not(?ConstSig(_ , _, _, _, decl-id));where(\ ConstSig(_,a,_,_,_) -> <eq> (<length> a, num-args) \)) => candidates;
+			// explode all the variables in the arguments, and get rid of useles sigs
+			map(\ ConstSig(_, a, _, a-constraints, _) -> <map(explode-sort(|a-constraints);\ [x] ->  x \)> a \);
+			// associate each of the arguments list with our own arguments
+			map(\ a -> <zip> (args,a) \);
+			// keep only the lists where sort-apply doesn't fail. if it fails replace with empty list (to preserve positions)
+			map(\ tups -> <map(sort-apply <+ ![]);where(get-indices(?[]);?[])> tups \ <+ ![]);
+			// get indices of non-empty lists
+			get-indices(?[_|_]) => overlap-indices;
+			// continue only if non-empty
+			?[_|_];
+			// get the overlapping signatures
+			overlaps := <at-indices(|overlap-indices)> candidates
+			
+			
+			
+			
+			
+			 
+	
+	/**
+	* Checks that the sort usages are applicable to their declarations
+	* This only checks sorts that reference variables. The variables are exploded, and the non-global-constraint-error is called on the resulting sorts.
+	* if the called strategy reports errors, the sort in the returned tuple is replaced by the original (non-exploded) sort and returned and the resulting tuple returned as an error
+	*/
+	
+			
+		
+		
+		
+		
+	 	
+//	// not declared SortNoArgs or Sort
+// 	global-constraint-error:
+// 		_ -> (s, $[The sort [<pp-sort-signature-top> s'] is not declared])
+// 		where
+// 			?s at SortNoArgs(_) + ?s at Sort(_,_)
+// 		where
+// 			sort-signature-of => s';
+// 			get-sort-decls;
+// 			?[]
+// 
+// 	// unknown generic sort vars on RHS of signature
+// 	global-constraint-error:
+// 		d at OpDecl(_,_) -> msgs 
+// 		where
+// 			poly-sort-signature-of => sig at ConstSig(_,[_|_],sort,_);
+// 			srtVars := <collect-all(?Var(_),union)> sort;
+// 			<filter(\
+// 				Var(v) -> v
+// 				where not( <is-freevar(|v)> sig )
+// 			\)> srtVars;
+// 			map(\
+// 				v -> (v, $[Unknown sort variable [<RenamedVarCookie> v]. It should be declared in left-hand-side])
+// 			\) => msgs@[_|_] // force fail if no errors
+// 	
+// 	constraint-warning:
+// 		d at OpDecl(_,_) -> msgs
+// 		where
+// 			poly-sort-signature-of => sig at ConstSig(_,[],sort,_);
+// 			srtVars := <collect-all(?Var(_),union)> sort;
+// 			map(\
+// 				Var(v) -> (v, $[Unknown sort variable [<RenamedVarCookie> v]. Either declare in left-hand-side or remove it from right-hand-side])
+// 			\) => msgs
+// 	
+// 	// incompatible sort application
+// 	global-constraint-error:
+// 		s at Sort(_,_) -> (s,$[The sort application [<pp-sort-signature-top> s'] is not compatible with any of its declarations:
+// 			 [<pp-list(pp-sort-signature-top|", ")> decl]])
+// 		where debug(!"Checking: ")
+// 		where
+// 			debug(!"A ");
+// 			sort-signature-of => s';
+// 			debug(!"B ");
+// 			get-sort-decls;
+// 			debug(!"C ");
+// 			map(signature-sort) => decl;
+// 			<debug(!"D APPLY ")> (s', decl);
+// 			<not(sort-apply)> (s',decl);
+// 			debug(!"E ");
+// 			<innermost(\ Var(v) -> <get-var-sorts;not(?[])> v \);collect-all(?Var(_));?[]> decl;
+// 			debug(!"F ")
+// 			
+// 			
+// 	// Warn about sort variables that are constrained to a single Sort which is not Term or List or Option
+// 	constraint-warning:
+// 		d at OpDecl(_,_) -> messages
+// 		where
+// 			poly-sort-signature-of => ConstSig(_,_,_,freevars);
+// 			// for each variable get their possible sorts
+// 			// for all the variables that have only a single possible sort which is not Term, give a warning
+// 			<map(\
+// 				var -> (Var(var),$[Sort variable [<RenamedVarCookie> var] is not polymorphic ([<pp-sort-signature> srt])])
+// 				where
+// 					<get-var-sorts> var;
+// 					?[srt];
+// 					not(?[Term()])
+// 			\)> freevars => messages
 			
 			
 	

Modified: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/signatures/constructors.str
==============================================================================
--- spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/signatures/constructors.str	Wed Jun 15 11:40:53 2011	(r23056)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/signatures/constructors.str	Wed Jun 15 15:00:34 2011	(r23057)
@@ -3,25 +3,22 @@
 
 imports 
 	signatures/project
-/*
-* We might need the following annotations preceding a constructor declaration:
-*	@suppress -> don't display errors
-* @declare -> use the constructor as declaration. all sorts inside that have not been declared will be declared
-*/
+	solver/constraints
+
 
 signature
 	constructors
 		/* built-in primitive Sorts + Types */
-		Term: Sort
+		// Term: Sort
 		ATerm: Sort
 		Int: Sort
 		Double: Sort
 		String: Sort
 		List: a -> Sort
 		List: Sort
-		Option: a -> Sort
-		Option: Sort
-		// Tuple??
+		// Option: a -> Sort
+		// Option: Sort
+		// Tuple : List(Sort) -> Sort
 			
 signature
 	constructors // helpers
@@ -29,24 +26,28 @@
 				
 signature
 	constructors
-		/* signature type signatures */
-		
-		/*
-		 * Representation for a parametric polymorphic signature
-		 * arguments:
-			*1. constructor name
-			2. argument sorts
-			3. output sort
-			4. for All variables list
-		*/
-		ConstSig: String * List(Sort) * Sort * List(Var) -> ConstSig
 
-			
+		ConstSig: String * List(Sort) * Sort * ConstraintSet * String -> ConstSig
+
 
-		
+rules // accessors for Signatures
 	
+	sort-any = !ATerm()
 	
-		
+	is-sort-any = ?ATerm()
 	
+	signature-constructor:
+		ConstSig(c,_,_,_,_) -> c
 	
+	signature-arguments:
+		ConstSig(_,a,_,_,_) -> a
+
+	signature-sort:
+		ConstSig(_,args,s#(_),_,_) -> s#(args)
+	
+	signature-freevars:
+		ConstSig(_,_,_,v,_) -> v
 	
+	is-freevar(|var-name):
+		ConstSig(_,_,_,configurations,_) -> <constraint-contains-var(|var-name)> configurations
+			

Modified: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/signatures/map.str
==============================================================================
--- spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/signatures/map.str	Wed Jun 15 11:40:53 2011	(r23056)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/signatures/map.str	Wed Jun 15 15:00:34 2011	(r23057)
@@ -3,64 +3,152 @@
 imports
 	signatures/constructors
 	signatures/project
-	libstrc
 	utils/utils
+	libstrc
+
+rules // map signatures to their internal declarations
 	
-rules // store & retrieve sorts
+	poly-sort-signature-of =
+			sort-signature-of;
+			to-poly-signature
+
+	// normal signature with name and function	
+	sort-signature-of: 
+		OpDecl(name, FunType(args,srt)){decl-id} -> ConstSig(name,args',srt',[],decl-id)
+		with
+			args' := <map(sort-signature-of)> args;
+			srt' := <sort-signature-of> srt
+	
+	// signature with no arguments	
+	sort-signature-of:
+		OpDecl(name, ConstType(srt)){decl-id} -> ConstSig(name,[],srt',[],decl-id)
+		with
+			srt' := <sort-signature-of> srt			
 			
+	// signature with no name
+	sort-signature-of:
+		OpDeclInj(FunType(args,srt)){decl-id} -> ConstSig("",args',srt',[],decl-id)
+		with
+			args' := <map(sort-signature-of)> args;
+			srt' := <sort-signature-of> srt
+	
+	sort-signature-of:
+		OpDeclInj(ConstType(srt)){decl-id}-> ConstSig("",[],srt',[],decl-id)
+		with
+			srt' := <sort-signature-of> srt
+	
+	sort-signature-of:
+		ConstType(s) -> <sort-signature-of> s
+	
+	sort-signature-of:
+		SortVar(v){vnum} -> Var(vnum)
+	
+	sort-signature-of:
+		SortNoArgs(s) -> sort
+		with
+			srt := s#([]);
+			sort := srt{<get-sort-cookie> srt}
+	
+	sort-signature-of:
+		Sort(s,a) -> sort
+		with
+			srt := s#(<sort-signature-of> a);
+			sort := srt{<get-sort-cookie> srt}
+		
+	sort-signature-of:
+		SortTuple(sort-list) -> sort
+		with
+			srt := <map(sort-signature-of);new-tuple-sort> sort-list;
+			sort := srt{<get-sort-cookie> srt}
+		
+	sort-signature-of:
+		t -> <map(sort-signature-of)> t
+		where ?[_|_] //is-list
+	
+	sort-signature-of:
+		[] -> []
+	
+	// get all the variables from the LHS of constructor
+	to-poly-signature:
+		ConstSig(n,args,srt,_,decl-id) -> ConstSig(n,args,srt,<new-configuration> freevars,decl-id)
+		with
+			freevars := <collect-all(\ Var(a) -> a \,union)> args
+	
+rules // store & retrieve sorts
+		
 		store-sort-decl:
-			sig -> cookie
+			sig at ConstSig(_,_,_,_,decl-id) -> cookie
 			where
-				signature-sort;
-				not(is-prim)
-			with
 				signature-sort => sort;
-				get-sort-cookie => cookie;
-				not(
-					<elem> (sig,<bagof-DeclaredSort> cookie)
-				) <
-					rules (
-						DeclaredSort:+ cookie -> sig
-					)
-					+
-					id
+				not(is-sort-prim)
+			with
+				cookie := <get-sort-cookie> sort;
+				// (<elem> (sig,<bagof-DeclaredSort;mapconcat(SortSig)> cookie)
+				(<get-sort-declaration> decl-id
+				<+
+				rules (
+					DeclaredSort:+ cookie -> decl-id
+					SortSig: decl-id -> sig
+				))
 		
-		get-sort-decls:
-			sort -> decls
+		replace-sort-decl:
+			sig at ConstSig(_,_,_,_,decl-id) -> sig
 			where
-				?_{cookie};
-				decls := <bagof-DeclaredSort> cookie
-
-		// already has a cookie
+				<get-sort-declaration> decl-id
+			with rules (
+				SortSig: decl-id -> sig
+			)
+		
+		
+		get-sort-declarations:
+			// _{cookie} -> <bagof-DeclaredSort;mapconcat(bagof-SortSig)> cookie
+			_{cookie} -> <bagof-DeclaredSort;map(get-sort-declaration)> cookie
+			
+		get-sort-declarations:
+			s{} -> <get-sort-cookie => cookie;!s{cookie};get-sort-declarations> s
+		
+		get-sort-declaration:
+			decl-id -> <SortSig> decl-id 
+			// decl-id -> <all-keys-DeclaredSort;mapconcat(bagof-DeclaredSort);fetch-elem(?ConstSig(_, _, _, _, decl-id))>
+		
+		get-signatures-for-constructor:
+			c -> <all-keys-SortSig;mapconcat(bagof-SortSig);filter(?ConstSig(c, _, _, _, _))>
+		/* 
+		* get cookie for non-primitive sort (parameterized or not)
+		*/
+		
+		get-sort-cookie:
+			sort{cookie} -> cookie
+			// where debug(!"Getting sort cookie for declared sort which has a cookie-anno ")
+		
 		get-sort-cookie:
 			sort -> cookie
+			where not(?_{_})
 			where
-				?_{cookie} +
-				?s#(l at _);
-				all-keys-SortCookie;
-				filter(\
-				s'#(l'@_) -> <and(<eq> (s',s), <eq> (<length> l',<length> l))>
-				\);
-				mapconcat(bagof-SortCookie);
-				?[cookie|_]
+				?s#(_);
+				!s#([]);
+				SortCookie => cookie
+				// ;<debug(!"Getting cookie for declared sort which doesn't have an cookie-anno ")> sort
 
-		// no cookie yet		
+		// no cookie yet
+		/* we are ignoring any parameters that the sort has */		
 		get-sort-cookie:
 			sort -> cookie
-			where not(is-prim)
+			where not(is-sort-prim)
+			where not(?_{_})
+			where 
+				?s#(_);
+				!s#([]) => srt
 			where not(
-				?_{_} +
-				?s#(l at _);
-				all-keys-SortCookie;
-				filter(\
-				s'#(l'@_) -> <and(<eq> (s',s), <eq> (<length> l',<length> l))>
-				\);
-				?[_|_]
+				!srt;
+				SortCookie
 			)
+			// where debug(!"Storing cookie for non-primitive sort ")
 			with
 				cookie := <newterm>;
+				// store the cookie as unparameterised sort
 				rules (
-					SortCookie:+ sort -> cookie
+					SortCookie: srt -> cookie
 				)
 				
 rules // transparent auto-declarations for the primitive sorts
@@ -90,50 +178,60 @@
 			sig -> cookie
 			where
 				signature-sort;
-				is-prim;
+				is-sort-prim;
+				// debug(!"Storing declaration for primitive sort ");
 				get-sort-cookie => cookie
+				
 		
-		//normal sort
+		/* primitive sort (whether parameterized or not)
+		* If its parameterized it gets automatically declared with variables in the different parameter positions.
+		* Tuple is a special case:
+		* - Tuple-2(_,_) -> ConstSig("",[Var(a),Var(b)],Tuple-2(Var(a),Var(b)){cookie},[Var(a),Var(b)])
+		* - Tuple-3(_,_,_) -> ConstSig("",[Var(a),Var(b),Var(c)],Tuple-2(Var(a),Var(b),Var(c)){cookie},[Var(a),Var(b),Var(c)])
+		*/
 		get-sort-cookie:
 			sort -> cookie
 			where
-				is-prim;
-				?srt#([])
+				is-sort-prim
 			where not(
 				?_{_} + SortCookie
 			)
+			// where debug(!"Storing cookie for primitive sort ")
 			with
 				cookie := <newterm>;
-				sig := ConstSig(srt,[],srt#([]){cookie},[]);
+				// gen the list of arguments (variables)
+				var-args := <list-of(new-var|[],<arity> sort)>;
+				// sig := ConstSig("",var-args,sort{cookie},var-args);
+				decl-id := <newterm>;
+				sig := ConstSig("",var-args, <?s#(_);!s#(var-args){cookie}> sort,<new-configuration> var-args, decl-id);
+				srt := s#([]);
 				rules (
-					SortCookie:+ sort -> cookie
-					DeclaredSort:+ cookie -> sig
+					SortCookie: srt -> cookie
+					DeclaredSort:+ cookie -> decl-id
+					SortSig: decl-id -> sig
 				)
 		
-		//parameterized sort
-		get-sort-cookie:
-			sort -> cookie
-			where
-				is-prim;
-				?srt#([_|_])
-			where not(
-				?_{_} + SortCookie
-			)
-			with
-				cookie := <newterm>;
-				sig := ConstSig(srt,[Var("a")],srt#([Var("a")]),["a"]);
-				rules (
-					SortCookie:+ sort -> cookie
-					DeclaredSort:+ cookie -> sig
-				)
+		// TODO: move these two to a utilities module
+		
+		// generate a list of the given element
+		list-of(|acc,length):
+			k -> <list-of(!k|acc,length)>
 
+		// generates a list of the given element producing strategy
+		list-of(s|accumulator,length) =
+			if(<gt> (length,0)) then
+				list-of(s|[<s>|accumulator],<dec> length)
+			else
+				!accumulator
+			end
+		
 rules // rename variables
 	
 	rename-sort-vars = {| RenamedVar: alltd(rename-sort-var) |}
 	
 	rename-sort-var:
 		SortVar(v) -> SortVar(v){<rename> v}
-		where debug(!$[Renamed variable [v] to [<rename> v] ])
+		// where debug(!$[Renamed variable [v] to [<rename> v] ])
 		
 	rename:
 		v -> v'
@@ -147,88 +245,13 @@
 			is-string;
 			not(RenamedVar)
 		with
-			v' := <newterm>;
+			// v' := <newterm>;
+			v' := <newname> v;
 			rules (
 				RenamedVar : v -> v'
 				RenamedVarCookie: v' -> v
 			)
-	
+		
+		new-var = !Var(<newname> "var")
 
-rules // variable sort storage
-	
-	chain-proxy-varsort(|var,pos):
-		sig@(_#(use-args)) -> var
-		with
-			if(not(<VarToProxy> var => old_cookie)) then
-				old_cookie := -42
-			end;
-			cookie := <newterm>;
-			// verify that a var actually exists at the given position
-			var-positions := <get-indices(?Var(var))> use-args;
-			<elem> (pos,var-positions);
-			num_args := <length> use-args
-		with
-			if(<gt> (old_cookie,0)) then
-				// a rule already exists, cleanup
-				rules (
-					VarToProxy:- var
-					SortVar:- var
-				)
-			end;
-			rules (
-				VarToProxy: var -> cookie
-				DeferredApplication: cookie -> result
-					with
-						<get-sort-decls> sig;
-						// keep from the decls only those that have the right number of arguments
-						map(signature-sort);
-						filter(\
-							_#(decl-args) -> decl-args
-							where <eq> (<length> decl-args, num_args)
-							\);
-						// FIXME: keep from the remaining decls only those that apply in non-variable positions
-						// FIXME: this is loss of strictness
-						// keep only the positions at POS
-						map(elem-at-index(|pos)) => elems;
-						if(<gt> (old_cookie,0)) then
-							<sort-apply <+ ![]> (<DeferredApplication> old_cookie, elems) => result
-						else
-							<sort-apply <+ ![]> (Term(), elems) => result
-						end
-				SortVar: var -> <DeferredApplication> cookie
-			)
-	
-	
-	chain-proxy-varsort(|var):
-		sig@(_#(use-args)) -> var
-		with
-			var-positions := <get-indices(?Var(var))> use-args;
-			<map(\ 
-				pos -> <chain-proxy-varsort(|var,pos)> sig
-			\)> var-positions
-			
-	get-var-sorts:
-		var -> srts
-		where all-keys-SortVar;fetch(?var)
-		with {|Strace:
-			if(<Strace> var) then
-				<debug(!"Cyclic lookup detected on ")> Var(<RenamedVarCookie> var);
-				srts := [Term()]
-			else
-				rules (
-					Strace: var
-				);
-				<SortVar> var => srts
-			end
-		|}
 	
-	get-var-sorts:
-		var -> [Term()]
-		where all-keys-SortVar;not(fetch(?var))
-	
-	store-var-sorts(|var):
-		srts -> srts
-		where <is-list> srts
-		with rules (
-			SortVar: var -> srts
-		)
\ No newline at end of file

Modified: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/signatures/pp.str
==============================================================================
--- spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/signatures/pp.str	Wed Jun 15 11:40:53 2011	(r23056)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/signatures/pp.str	Wed Jun 15 15:00:34 2011	(r23057)
@@ -3,17 +3,18 @@
 imports
 	signatures/constructors
 	signatures/map
-
+	signatures/project
+	
 rules // pretty print for constructor signatures
 
 	pp-sort-signature-top =
 		pp-sort-signature
 	
 	pp-sort-signature:
-		ConstSig(name,args,srt,[]) -> $[[name] : [<pp-list(pp-sort-signature-top|" * ")> args] => [<pp-sort-signature-top> srt]]
+		ConstSig(name,args,srt,_,_) -> $[[name] : [<pp-list(pp-sort-signature-top|" * ")> args] => [<pp-sort-signature-top> srt]]
 	
-	pp-sort-signature:
-		ConstSig(name,args,srt,fvars@[_|_]) -> $[[name]([<pp-list(RenamedVarCookie|", ")> fvars]) : [<pp-list(pp-sort-signature-top|" * ")> args] => [<pp-sort-signature-top> srt]]
+	// pp-sort-signature:
+	// 	ConstSig(name,args,srt,fvars@[_|_],_) -> $[[name]([<pp-list(RenamedVarCookie|", ")> fvars]) : [<pp-list(pp-sort-signature-top|" * ")> args] => [<pp-sort-signature-top> srt]]
 	
 	pp-sort-signature:
 		x -> x
@@ -23,17 +24,22 @@
 		Var(a) -> <RenamedVarCookie;pp-sort-signature-top> a
 	
 	pp-sort-signature:
+		_#(t-args) -> $[([<pp-list(pp-sort-signature|", ")> t-args])]
+		where
+			is-sort-tuple
+	
+	pp-sort-signature:
 		c#([]) -> $[[c]]
 		where
 			not(
-				is-string + ?Var(_) + ?ConstSig(_,_,_,_)
+				is-string + ?Var(_) + ?ConstSig(_,_,_,_,_)
 			)
 	
 	pp-sort-signature:
 		e at c#(l) -> $[[c]([<pp-list(pp-sort-signature-top|", ")> l])]
 		where
 			not(
-				is-string + ?Var(_) + ?ConstSig(_,_,_,_)
+				is-string + ?Var(_) + ?ConstSig(_,_,_,_,_)
 			)
 	
 	pp-list(|sep) = pp-list(id|sep)

Modified: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/signatures/project.str
==============================================================================
--- spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/signatures/project.str	Wed Jun 15 11:40:53 2011	(r23056)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/signatures/project.str	Wed Jun 15 15:00:34 2011	(r23057)
@@ -3,91 +3,49 @@
 imports
 	signatures/constructors
 	signatures/map
+	solver/constraints
+	utils/annotations
+	utils/utils
+	lib/editor-common.generated
 	libstrc
 	
-rules // accessors for Signatures
-	
-	signature-constructor:
-		ConstSig(c,_,_,_) -> c
-	
-	signature-arguments:
-		ConstSig(_,a,_,_) -> a
-
-	signature-sort:
-		ConstSig(_,_,c,_) -> c
-	
-	signature-freevars:
-		ConstSig(_,_,_,v) -> v
-	
-	is-freevar(|var-name):
-		sig at ConstSig(_,_,_,freevars) -> <elem> (var-name,freevars)
-
 rules // primitive test helper rules
 		
-		is-prim:
+		is-sort-prim:
 			c -> c
+			// where ?Int() + ?Double() + ?String() + ?List(_) + ?List() + ?Option(_) + ?Option() + is-sort-any + is-sort-tuple
+			where ?Int() + ?Double() + ?String() + ?List(_) + ?List() + is-sort-any + is-sort-tuple
+		
+		is-sort-tuple:
+			s at c#(_) -> s
 			where
-				?Int() + ?Double() + ?String() + ?List(_) + ?List() + ?Option(_) + ?Option() + ?Term() +?ATerm()
-
-rules // Stage 1
+				
+				// where it starts with 'Tuple'
+				<string-starts-with(|"Tuple-")> c;
+				// and the last characters are integer
+				req-arity := <string-tokenize(|['-']);last;string-to-int> c;
+				<is-int> req-arity;
+				// and the declared arity is the same as the actual
+				<eq> (req-arity,<arity> s)
+				
+		// util to construct a tuple of arbitrary arity with the given sorts as arguments
+		new-tuple-sort:
+			(arity, arg-list) -> new-tup
+			where
+				<is-int> arity;
+				<?[_|_]> arg-list;
+				<eq> (arity, <length> arg-list);
+				s-name := <conc-strings> ("Tuple-",$[[arity]]);
+				new-tup := s-name#(arg-list)
+				
+		// util to construct a tuple sort with arity deduced from the length of the arguments
+		new-tuple-sort:
+			args -> new-tup
+			where ?[_|_];
+			<new-tuple-sort> (<length> args, args) => new-tup
 	
-	poly-sort-signature-of =
-			sort-signature-of;
-			to-poly-signature
+				
 
-	// normal signature with name and function	
-	sort-signature-of: 
-		OpDecl(name, FunType(args,srt)) -> ConstSig(name,args',srt',[])
-		with
-			args' := <map(sort-signature-of)> args;
-			srt' := <sort-signature-of> srt
-	
-	// signature with no arguments	
-	sort-signature-of:
-		OpDecl(name, ConstType(srt)) -> ConstSig(name,[],srt',[])
-		with
-			srt' := <sort-signature-of> srt			
-			
-	
-	// signature with no name
-	sort-signature-of:
-		OpDeclInj(FunType(args,srt)) -> ConstSig("",args',srt',[])
-		with
-			args' := <map(sort-signature-of)> args;
-			srt' := <sort-signature-of> srt
-	
-	sort-signature-of:
-		OpDeclInj(ConstType(srt)) -> ConstSig("",[],srt',[])
-		with
-			srt' := <sort-signature-of> srt
-	
-	sort-signature-of:
-		ConstType(s) -> <sort-signature-of> s
-	
-	sort-signature-of:
-		SortVar(v){vnum} -> Var(vnum)
-	
-	sort-signature-of:
-		SortNoArgs(s) -> sort
-		with
-			srt := s#([]);
-			sort := srt{<get-sort-cookie> srt}
-	
-	sort-signature-of:
-		Sort(s,a) -> sort
-		with
-			srt := s#(<sort-signature-of> a);
-			sort := srt{<get-sort-cookie> srt}
-		
-	sort-signature-of:
-		t -> <map(sort-signature-of)> t
-		where is-list
-	
-	// get all the variables from the LHS of constructor
-	to-poly-signature:
-		ConstSig(n,args,srt,_) -> ConstSig(n,args,srt,freevars)
-		with
-			freevars := <collect-all(\ Var(a) -> a \,union)> args
 
 rules // sort applications
 	
@@ -96,85 +54,183 @@
 	* sort-apply: (sig, applyTo) -> resulting sort signature OR fail
 	*/
 	
-	sort-apply:
-		(s,l@[_|_]) -> <filter(\ l' -> <sort-apply> (s,l') \);not(?[]);flatten-list;make-set> l
-		where <not(is-list)> s
+	// sort-apply:
+	// 	(s,l@[_|_]) -> <filter(\ l' -> <sort-apply> (s,l') \);not(?[]);flatten-list;make-set> l
+	// 	where <not(is-list)> s
+	// 
+	// sort-apply:
+	// 	(s@[_|_],l) -> <filter(\ s' -> <sort-apply> (s',l) \);not(?[]);flatten-list;make-set> s
 	
 	sort-apply:
-		(s@[_|_],l) -> <filter(\ s' -> <sort-apply> (s',l) \);not(?[]);flatten-list;make-set> s
+		(s,l@[_|_]) -> <sort-apply> (s',l)
+		where
+			<not(?[_|_])> s;
+			s' := [s]
 	
-	/* rules for primitive applications */
+	sort-apply:
+		(l@[_|_],s) -> <sort-apply> (l,s')
+		where
+			<not(?[_|_])> s;
+			s' := [s]
 	
 	sort-apply:
-		(s,Term()) -> s
-		where <not(is-list + ?Var(_))> s
-		
+		(s@[_|_],r@[_|_]) -> res
+		where
+			cart(id);
+			res := <filter(sort-apply-helper);make-set>;
+			if(<?[]> res) then
+				fail
+			end
+
+	sort-apply-helper:
+		(s,t) -> res
+		where
+				// current constraints
+				cur-constraints := <ExtraConstraints <+ !CSet([])>; // we could use once instead
+				// wipe all of the constraints
+				rules (
+					ExtraConstraints:- _ 
+				);
+				if(<not(?[])> <bagof-ExtraConstraints>) then
+					fatal-err(|"Failed to remove all ExtraConstraints dynamic rules")
+				end;
+				{|ExtraConstraints:
+						if(res := <sort-apply> (s,t)) then
+							new-constraints := <ExtraConstraints <+ !CSet([])>
+						else
+							res := []
+							// new-constraints := cur-constraints
+						end
+				|};
+				if(<?[]> res) then
+					// <map(\
+					// 	ex -> ex
+					// 	with rules(
+					// 		ExtraConstraints:+ _ -> ex
+					// 	) 
+					// \)> cur-constraints;
+					rules(
+						ExtraConstraints: _ -> cur-constraints
+					);
+					fail
+				else
+					// <conc> (cur-constraints,new-constraints);
+					// map(\
+					// 	ex -> ex
+					// 	with rules(
+					// 		ExtraConstraints:+ _ -> ex
+					// 	) 
+					// \)
+					rules (
+						ExtraConstraints: _ -> Union(cur-constraints,new-constraints)
+					)
+				end
+				
+
 	sort-apply:
-		(Term(),s) -> s
-		where 
-			<not(is-list + ?Var(_))> s
+		([l],r) -> <sort-apply> (l,r)
 	
 	sort-apply:
-		(Int(), Int()) -> Int()
+		(l,[r]) -> <sort-apply> (l,r)
+	
+	/* rules for primitive applications */
 	
 	sort-apply:
-		(Double(),Double()) -> Double()
+		(s,a) -> s
+		where <is-sort-any> a
+		where <not(is-list + ?Var(_))> s
+		
+	sort-apply:
+		(a,s) -> s
+		where <is-sort-any> a
+		where <not(is-list + ?Var(_))> s
 	
+	// Simple identity
 	sort-apply:
-		(Int(), Double()) -> []
+		(a,a) -> a
 	
+	// Forced identity
 	sort-apply:
-		(String(), String()) -> String()
+		(a,b) -> a
+		where
+			a' := <remove-all-annos> a;
+			b' := <remove-all-annos> b;
+			<?a'> b'
+	
+	// sort-apply:
+	// 	(Int(), Int()) -> Int()
+	// 
+	// sort-apply:
+	// 	(Double(),Double()) -> Double()
+	// 
+	// // sort-apply:
+	// // 	(Int(), Double()) -> <fail>
+	// 
+	// sort-apply:
+	// 	(String(), String()) -> String()
 	
 	// the sort application for collections propagates inside the sorts collected
 	sort-apply:
 		(List(s),List(k)) -> List(<sort-apply> (s,k))
 	
-	// empty lists collect the Nothing sort (which doesn't exist). On application to a List of sort a, the result is a list of sort a
-	sort-apply:
-		(List(),List()) -> List()
+	// // empty lists collect the Nothing sort (which doesn't exist). On application to a List of sort a, the result is a list of sort a
+	// sort-apply:
+	// 	(List(),List()) -> List()
 	
 	sort-apply:
-		(List(),List(_)) -> List()
+		(List(),List(s)) -> List(s)
 	
 	// TODO: is this true always?
 	sort-apply:
-		(List(_),List()) -> <fail>
+		(List(_),List()) -> List()
 		
-	sort-apply:
-		(Option(s),Option(k)) -> Option(<sort-apply> (s,k))
+	// sort-apply:
+	// 	(Option(s),Option(k)) -> Option(<sort-apply> (s,k))
 	
-	sort-apply:
-		(Option(),Option()) -> Option()
-	
-	sort-apply:
-		(Option(),Option(k)) -> Option()
+	// sort-apply:
+	// 	(Option(),Option(k)) -> Option()
 	
 	// TODO: is this true always?
-	sort-apply:
-		(Option(_),Option()) -> <fail>
+	// sort-apply:
+	// 	(Option(_),Option()) -> <fail>
 	
-	/* rules for sort variables */
-
+	/* tuples */	
 	sort-apply:
-		(s,Var(v)) -> <sort-apply> (s, <get-var-sorts> v)
-		where <not(?Var(_))> s
+		(l,r) -> <zip(sort-apply);new-tuple-sort> (args-l,args-r)
+		where
+			<is-sort-tuple> l;
+			<is-sort-tuple> r;
+			<eq> (<arity> l, <arity> r)
+		where
+			?(_#(args-l),_#(args-r))
+	
+	
+	/* variable target */
+	// FIXME: this is a total whack hack.
+	// sort-apply:
+	// 	(_,v at Var(_)) -> v
 	
 	sort-apply:
-		(Var(v),s) -> <sort-apply> (<get-var-sorts> v, s)
-		where not(<is-list> s)
-			
+		(s,t at Var(v)) -> t
+		where
+			res := <sort-apply> (s,<sort-any>);
+			if(constraints := <ExtraConstraints> ) then
+				rules (
+					ExtraConstraints: _ -> ISection(constraints,CSet([Constraint(v,s)]))
+				)
+			else
+				rules (
+					ExtraConstraints: _ -> CSet([Constraint(v,s)])
+				)
+			end
+	
 	/* rules for user-declared sorts */
 	
 	sort-apply:
-		(a,a) -> a
-		where not(<is-list> a)
-		
-	sort-apply:
 		(s,t) -> c#(<zip(sort-apply)> (p,p'))
 		where not(
-			<is-prim> s +
-			<is-prim> t +
+			<is-sort-prim> s +
+			<is-sort-prim> t +
 			<is-list> t
 		)
 		where
@@ -182,42 +238,394 @@
 			?c#(p);
 			!t;
 			?c#(p')
+	
+	sort-apply:
+		(l at s#(la),r at s#(ra)) -> <sort-apply> (l',r')
+		where not(
+			<is-sort-prim> l +
+			<is-sort-prim> r +
+			<is-list> r
+		)
+		where
+			debug(!"GENERAL APPLY? ");
+			// if at least one of them doesn't have any arguments and there's not argumentless declarations for it
+			(	<?[]> la;
+				<get-sort-declarations> l;
+				filter(?ConstSig(_,[],_,_,_));
+				?[]
+			+
+				<?[]> ra;
+				<get-sort-declarations> r;
+				filter(?ConstSig(_,[],_,_,_));
+				?[]
+			)
+		where
+			// expand those where the argument list is empty. unless the declaration actually contains zero arguments
+			if(<?[]> la ) then
+				decs-l := <get-sort-declarations> l;
+				filter(?ConstSig(_,[],_,_,_));
+				if(?[]) then
+		  		l' := <mapconcat(\ sig at ConstSig(_,_,_,c,_) -> <explode-sort(|c)> <signature-sort> sig \)> decs-l
+				else
+					l' := l
+				end
+			else
+				l' := l
+			end;
+			if(<?[]> ra ) then
+				decs-r := <get-sort-declarations> r;
+				filter(?ConstSig(_,[],_,_,_));
+				if(?[]) then
+		  		r' := <mapconcat(\ sig at ConstSig(_,_,_,c,_) -> <explode-sort(|c)> <signature-sort> sig \)> decs-r
+				else
+					r' := r
+				end
+			else
+				r' := r
+			end
+	
+	// sort-apply:
+	// 	(l at s#(la),r at s#(ra)) -> <sort-apply> (l',r')
+	// 	where not(
+	// 		<is-sort-prim> l +
+	// 		<is-sort-prim> r +
+	// 		<is-list> r
+	// 	)
+	// 	where
+	// 		// if at least one of them doesn't have any arguments
+	// 		(<?[]> la + <?[]> ra);
+	// 		<get-sort-declarations> l;
+	// 		srts := <map(signature-sort)>;
+	// 		filter(\ srt -> <eq> (<arity> srt,0) \);
+	// 		?[]
+	// 	where
+	// 		// expand those where the argument list is empty. unless the declaration actually contains zero arguments (OpDeclInj(ConstType))
+	// 		if(<?[]> la ) then
+	// 			l' := srts
+	// 		else
+	// 			l' := l
+	// 		end;
+	// 		if(<?[]> ra) then
+	// 			r' := srts
+	// 		else
+	// 			r' := r
+	// 		end
+	
+rules /* inferring the variable configurations */
+	
+	declare-var-constraints:
+		all-sigs -> all-sigs'
+		/*
+			for all the declarations, for each sort add an annotation that is
+			a placeholder for the constraint set
+		*/
+		with {| ConstraintQueue:
+			// debug(!"BUILDING QUEUE: ");
+			all-sigs' := <alltd(add-constraint-placeholder)> all-sigs;
+			queue := <bagof-ConstraintQueue>
+			|}
+			// ;log(|Error(),"Processing constraints resolution queue")
+			;<repeat(not(?[]);proc-q)> queue
+			// ;log(|Error(),"Queue processing completed")
+	
+	/**
+	* Add CSetProxy(cookie) (placeholder for the variable constraints) for each of the arguments of each signature declarations that contains freevars
+	*/
+	add-constraint-placeholder:
+		OpDecl(c-name, FunType(s-args,s-out)){decl-id} -> OpDecl(c-name,FunType(s-args',s-out')){decl-id}
+		where
+			//only if the constructor actually has free variables
+			sig := <get-sort-declaration> decl-id;
+			?ConstSig(_,_,_,conf,_);
+			not(<?CSet([])> conf)
+		with
+			s-args' := <map(\ c -> <add-anno(|CSetProxy(<newterm>))> c \)> s-args;
+			s-out' := <add-anno(|CSetProxy(<newterm>))> s-out;
+			proxies := <conc> (<collect-all(get-anno(?CSetProxy(_)), conc)> s-args', [<get-anno(?CSetProxy(_))> s-out']);
+			rules (
+				ConstraintQueue :+ _ -> (sig, proxies)
+			)
+	
+	add-constraint-placeholder:
+		OpDeclInj(FunType(s-args,s-out)){decl-id} -> OpDeclInj(FunType(s-args',s-out')){decl-id}
+		where
+			//only if the constructor actually has free variables
+			sig := <get-sort-declaration> decl-id;
+			?ConstSig(_,_,_,conf,_);
+			not(<?CSet([])> conf) 
+		with
+			s-args' := <map(\ c -> <add-anno(|CSetProxy(<newterm>))> c \)> s-args;
+			s-out' := <add-anno(|CSetProxy(<newterm>))> s-out;
+			// collect the CSetProxies so that we can use them later
+			proxies := <conc> (<collect-all(get-anno(?CSetProxy(_)), conc)> s-args', [<get-anno(?CSetProxy(_))> s-out']);
+			rules (
+				ConstraintQueue :+ _ -> (sig,proxies)
+			)
+	
+	proc-q :
+		queue -> queue'
+		with
+			// debug(!"A ");
+			// queue' := <map(dependencies-satisfied(|queue);proc-queued-item;![] <+ id);flatten-list> queue;
+			queue' := <map(dependencies-satisfied(|queue);proc-queued-item <+ id);flatten-list> queue;
+			// debug(!"B ");
+			if (<eq> (queue,queue')) then
+				fatal-err(|"DEADLOCK processing queue")
+			end
+			// debug(!"C ")
+	
+	/**
+	* Wrapper for infer sort variable constraints in the declaration.
+	* dispatches inference on each of the arguments
+	*
+	* @type: (ConstSig,List(CSetProxy)) ->? _
+	*/
+	
+	proc-queued-item:
+		(ConstSig(cons,args@[x|_],out,configuration,decl-id),proxies) -> []
+		with
+			arg-proxies := <take(|<length;dec> proxies)> proxies;
+			CSetProxy(out-proxy) := <last> proxies;
+			if (not(<eq> (<length> args,<length> arg-proxies))) then
+				fatal-err(|$[Length of proxies does not match number of arguments: |args| = [<length> args] |arg-proxies| = [<length> arg-proxies] ])
+			end
+		with {| LastCSet:
+			<map(do-something-3(|configuration))> args => configurations;
+			// debug(!"proc-queue 3 ");
+			// zip with the proxies
+			<zip> (configurations,arg-proxies);
+			// debug(!"proc-queue 4 ");
+			map(\
+				(config,CSetProxy(proxy)) -> (config,proxy)
+				with
+					// log(|Error(),$[Setting configuration for proxy [proxy] ]);
+					rules (
+						CSetProxy: proxy -> config
+				)
+			\);
+			// debug(!"proc-queue 5 ");
+			// set the out proxy
+			// log(|Error(),$[Setting configuration for last proxy [out-proxy] ]);
+			rules (
+				CSetProxy: out-proxy -> <last> configurations
+			);
+			<replace-sort-decl> ConstSig(cons,args,out,<last> configurations,decl-id)
+			// debug(!"proc-queue 6 ")
+		|}
+	
+	do-something-3(|configuration):
+		arg -> result
+	 	where
+	 		// debug(!"proc-queue 2A ");
+	 		solved := <proc-arg> arg;
+	 		// debug(!"proc-queue 2B ");
+	 		if(LastCSet) then
+	 			// debug(!"proc-queue 2BA ");
+	 			last := <LastCSet>
+	 		else
+	 			// debug(!"proc-queue 2BB ");
+	 			// log(|Error(),"LastCSet was not defined. Using supplied configuration ");
+	 			last := configuration
+	 		end;
+	 		// debug(!"proc-queue 2C ");
+	 		isection := ISection(last,solved);
+	 		// debug(!"proc-queue 2D ");
+	 		result := <solve-top> isection;
+	 		// result := <solve-top> ISection(<LastCSet>,<proc-arg> arg);
+	 		// debug(!"proc-queue 2E ");
+	 		rules (
+	 			LastCSet: _ -> result
+	 		)
+	 		// debug(!"proc-queue 2F ")
+	/**
+	* Process of an argument that contains no variables at all.
+	* This also applies to variables themselves
+	*/
+	proc-arg:
+		a -> CSet([])
+		where
+			// debug(!"proc-arg A1 ");
+			<collect-all(?Var(_),conc)> a;
+			?[]
+			// debug(!"proc-arg A2 ")
 			
+	/**
+	* 
+	* Process of an argument that contains no variables at the first level
+	*/
+	proc-arg:
+		a#(args) -> res
+		where
+			// debug(!"proc-arg B1 ");
+			<not(fetch(?Var(_)))> args
+			// debug(!"proc-arg B2 ")
+		with
+			res := <map(proc-arg);to-constraint-intersection> args
+			// debug(!"proc-arg B3 ")
 			
-rules // variable inference
-	infer-var-sorts:
-		sig at ConstSig(_,_,_,[]) -> sig
-	
-	infer-var-sorts:
-		sig at ConstSig(_, args, _, f) -> sig
-		where
-			<map(\
-				var -> <map(innermost(infer-proxies(|Var(var))))> args
-			\)> f
-	
-	infer-proxies(|var):
-		sig@(c#(args@[_|_])) -> <fail> // always fail so that can eventually get out of this loop
-		where
-			// only if there are actually uses of the variable at this level
-			<elem> (var,args)
-		with
-			Var(v) := var;
-			<debug(!"DEFERRING: ")> (var,sig);
-			<chain-proxy-varsort(|v)> sig
+	/**
+	* process of an argument that contains variables at the current level
+	* The argument may also contain variables at deeper levels, will do that first
+	*/
+	
+	proc-arg:
+		s@(a#(args)) -> result
+		with
+			arity := <length> args;
+			<get-sort-declarations> s;
+			map(\ sig at ConstSig(_,_,_,configuration,_) -> (<signature-sort> sig,configuration)\);
+			// keep only the ones that have the same number of arguments
+			filter(\
+					t@(s,_) -> t
+					where <eq> (<arity> s, arity)
+			\);
+			// replace the FAIL() configurations with a configuration of ATerms()
+			map(try(\
+				(sig,FAIL()) -> (sig, <collect-all(\ Var(x) -> x\,union);new-configuration> sig)
+			\));
+			// debug(!"VALID DECLS ARE: ");
+			// explode the declaration for each of the possible configurations
+			// mapconcat(\
+			// 	(srt,constraints) -> <collect-all(?CSet(_),conc);map(\ cset -> <substitute(|cset)> srt \)> constraints
+			// \);
+			mapconcat(explode-sort);
+			// TODO: this replacement may not be necessary, because substitute already replaces free variables with ATerm 
+			where (s' := <alltd(\ Var(_) -> <sort-any> \)> s);
+			filter(\ srt -> <sort-apply> (s',srt) \);
+			// now we have a list of sorts: [Sort(params),Sort(params)] that are possible
+			// take the types that correspond to variable positions as constraints for those variables
+			map(do-something-2(|s));
+			to-constraint-union;
+			solve-top => result
 				
-
+	do-something-2(|s):
+		srt -> result
+		with
+			// <debug(!"proc-arg C6A ")> s;
+			var-positions := <positions-of-term(?Var(_))> s;
+			// debug(!"proc-arg C6B ");
+			sources := <map(\ p -> <term-at-position(|p)> s \)> var-positions;
+			// debug(!"proc-arg C6C ");
+			// try to get all the sources that are in the target var positions (there won't be all of them)
+			<map(\ p -> <term-at-position(|p) <+ sort-any> srt \)> var-positions => targets;
+			// debug(!"proc-arg C6D ");
+			// check that the number of positions are equal to the number of variables
+			if (not(<eq> (<length> var-positions, <length> targets))) then
+				fatal-err(|"Inequal number of variables to the declaration")
+			end;
+			// <debug(!"proc-arg C6E ")> (sources, targets);
+			<zip(\ (Var(source),target) -> CSet([Constraint(source,target)]) \)> (sources,targets);
+			// debug(!"proc-arg C6F ");
+			// intersect them
+			to-constraint-intersection => result
+			// debug(!"proc-arg C6G ")
+			
+	/**
+	* Replace the CSetProxy annotations on the arguments and declared sort to the actual inferred constraints
+	*/
+	resolve-var-constraints:
+		arg{CSetProxy(proxy)} -> out
+		with
+			if(not(out := arg{<CSetProxy> proxy})) then
+				fatal-err(|$[Failed to resolve CSetProxy for [proxy]])
+			end
+	
+	/**
+	* Succeeds if there is a sort with this name and same number of arguments still in the queue.
+	* @param: List((ConstSig,List(CSetProxy)))
+	* @type: Sort ->? Sort
+	*/
+	in-queue(|queue):
+		t@(s#(a)) -> t
+		// where
+		// 	debug(!"in-queue: ")
+		where
+			l-a := <length> a;
+			<filter(\
+				t@(ConstSig(_,a',s'#(_),_,_),_) -> t 
+				// where debug(!"in-queue check: ")
+				where
+					<eq> (s,s');
+					<eq> (<length> a', l-a)
+			\)> queue;
+			?[_|_]
+	
+	/**
+	* Succeeds if none of the terms used in the arguments are still in the queue
+	* @param: List((ConstSig,List(CSetProxy)))
+	* @type: ConstSig ->? ConstSig
+	*/
+	dependencies-satisfied(|queue):
+		t@(ConstSig(_,args,_,_,_),_) -> t
+		where
+			// collect all the sorts (except for vars & primitives) used in the args
+			<collect-all(not(is-sort-prim + ?Var(_)),conc);flatten-list> args;
+			// where (debug(!"depends on: "));
+			// keep only the ones that are in the queue
+			filter(in-queue(|queue));
+			// where (debug(!"dependencies still queued: "));
+			?[]
+	
+	/**
+	* Constructs a new configuration for the variables that are given setting them to ATerm()
+	* @type: List(String) -> CSet()
+	*/
 	
-		
-		
+	new-configuration = map(\ var -> CSet([Constraint(var,<sort-any>)]) \);to-constraint-intersection;solve-top;clean-constraint-set
 
 
+rules /* extra projection rules to explode signatures against variable constraints */
 	
+	/**
+	* Given a sort (parameterized or not) computes the set of plausible sorts by checking the given sort against the declarations of that sort
+	*
+	* @type: Sort -> List(Sort)
+	*/
+	get-compatible-sorts:
+		srt -> res
+		with
+			// debug(!"COMPAT1 ");
+			// srt' := <sort-signature-of> srt;
+			// debug(!"COMPAT2 ");
+			// get all the declarations of this sort
+			get-sort-declarations;
+			// debug(!"COMPAT3 ");
+			// replace all the FAIL() configurations with new ATerm constraints
+			map(\ sig at ConstSig(n,a,o,FAIL(),did) -> ConstSig(n,a,o,<collect-all(\ Var(x) -> x\,union);new-configuration> a,did) \ + id);
+			// debug(!"COMPAT4 ");
+			// explode all the sorts for each of the variable constraint sets
+			mapconcat(\ sig at ConstSig(_,_,_,cs,_) -> <explode-sort(|cs)> <signature-sort> sig \);
+			// debug(!"COMPAT5 ");
+			// keep only the plausible declarations by filtering on sort-apply
+			res := <filter(\ candidate -> <sort-apply> (srt,candidate) \);flatten-list>
+			// debug(!"COMPAT6 ")
+	
+	/**
+	* Explodes the given Sort containing variables (or not) against the constraint sets given in the argument. A sort with variables substituted results for each of 
+	* constraint sets
+	* @param ConstraintSet
+	* @type Sort -> List(Sort)
+	*/	
+	explode-sort(|constraints) = ?srt;<collect-all(?CSet(_),conc);map(\ cset -> <substitute(|cset)> srt \)> constraints
+	
+	
+	explode-sort:
+		(srt,constraints) -> <explode-sort(|constraints)> srt
+	
+	/**
+	* Substitute each of the variable with the given values in the constraint set
+	* @param: ConstraintSet
+	* @type: (Sort,ConstraintSet) -> Sort
+	*/
+	substitute(|cset):
+		s -> <innermost(substitute-vars(|cset))> s
 		
-		
-				
-			
-			
-	
-	
+	substitute-vars(|cset):
+		Var(v) -> t 
+		with
+			if (not(t := <get-var-constraint(|v);get-constrained-var-sort> cset)) then
+				log(|Notice(),"Substitution failed for a free variable. Falling back to [<sort-any>]");
+				t := <sort-any>
+			end
 	
-		
\ No newline at end of file
+

Added: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/solver/constraints.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/solver/constraints.str	Wed Jun 15 15:00:34 2011	(r23057)
@@ -0,0 +1,267 @@
+module constraints
+
+imports
+	signatures/constructors
+	signatures/project
+	utils/utils
+	
+signature constructors
+	
+	
+	Constraint: String * Sort -> Constraint
+	CSet: List(Constraint) -> ConstraintSet
+	CSetProxy : String -> ConstraintProxy
+	FAIL: ConstraintSet
+	Union: ConstraintSet * ConstraintSet -> ConstraintSet
+	ISection: ConstraintSet * ConstraintSet -> ConstraintSet
+	
+rules
+	
+	solve-top = 
+		alltd(clean-constraint-set);
+		innermost(solve);
+		alltd(clean-constraint-set);
+		where (
+			if(collect-all(?ISection(_,_),conc);?[_|_]) then
+				fatal-err(|"Solved constraints still contain Intersections. ")
+			end
+		)
+	
+	/* identities */
+	
+	solve:
+		Union(l,l) -> l
+	
+	solve:
+		ISection(l,l) -> l
+	
+	/* FAILure cases */
+	
+	solve:
+		Union(l,FAIL()) -> l
+	
+	solve:
+		Union(FAIL(),r) -> r
+	
+	solve:
+		ISection(FAIL(),_) -> FAIL()
+	
+	solve:
+		ISection(_,FAIL()) -> FAIL()
+	
+	/* if we can unify the constraint sets do so */
+	solve:
+		Union(l at CSet(l-constraints),r at CSet(r-constraints)) -> unified
+		// this can fail and it's not a problem
+		where <constraint-unify> (l,r) => unified
+	
+	
+	/* intersect two constraint sets */
+	solve:
+		ISection(l at CSet(l-constraints),r at CSet(r-constraints)) -> intersected
+		// this should always succeed
+		// where debug(!"TRYING isect 1 ")
+		with <constraint-intersect> (l,r) => intersected
+		// where debug(!"TRYING isect 1 worked ")
+	
+	/* (a + b) * c = a * c + b * c */
+	solve:
+		ISection(Union(l1,l2),r at CSet(_)) -> Union(ISection(l1,r),ISection(l2,r))
+		// where debug(!"(a + b) * c = a * c + b * c ")
+	
+	/* c * (a + b) = a * c + b * c */
+	solve:
+		ISection(l at CSet(_),Union(r1,r2)) -> Union(ISection(r1,l),ISection(r2,l))
+		// where debug(!"c * (a + b) = a * c + b * c ")
+	
+	/* (a + b) * (c + d) = a * (c + d) + b * (c + d) */ 
+	solve:
+		ISection(Union(l1,l2),r at Union(_,_)) -> Union(ISection(l1,r),ISection(l2,r))
+		// where debug(!"(a + b) * (c + d) = a * (c + d) + b * (c + d) ")
+		
+	
+	/**
+	* Attempt to perform the unification of two constraint sets.
+	* This can only succeed in one of the following situations:
+	*	1. the constraint sets are disjoint
+	* 2. the conditions for all the variables in the intersection are equal
+	*
+	* In other words, unification of constraint sets can only succeed if the two 
+	* constraint-sets do not represent disjoint variable configurations
+	* @type: (ConstraintSet, ConstraintSet) ->? ConstraintSet
+	*/
+	constraint-unify:
+		(l at CSet(l-cset),r at CSet(r-cset)) -> unified 
+		where
+			<clean-constraint-set> l => l';
+			<clean-constraint-set> r => r';
+			unified := <constraint-intersect;clean-constraint-set> (l',r');
+			<not(?FAIL())> unified
+			
+	
+	/**
+	* Perform the intersection of two constraint sets. This will either suceeds and the result will be:
+	*	- a constraint-set, if the two sets are disjoint or the constraints in the intersection are equal
+	* - FAIL, if the two sets are not disjoint and the constraints in the intersection are not equal
+	* @type: ConstraintSet * ConstraintSet -> ConstraintSet | FAIL
+	*/
+	// if the sets are disjoint 
+	constraint-intersect:
+		(CSet(l-cset),CSet(r-cset)) -> <clean-constraint-set> CSet(<conc> (l-cset,r-cset))
+		where
+			// only succeed if the sets are disjoint
+			<filter(\ constraint -> <elem(eq-constraint-vars)> (constraint,r-cset) \)> l-cset;
+			?[]
+	
+	// if the sets are not disjoint but the intersections are equal
+	constraint-intersect:
+		(l-cset'@CSet(_),r-cset'@CSet(_)) -> result //<clean-constraint-set> CSet(<conc> (l-cset,r-cset))
+		where
+			// debug(!"1 ");
+			CSet(l-cset) := <clean-constraint-set> l-cset';
+			// debug(!"2 ");
+			CSet(r-cset) := <clean-constraint-set> r-cset';
+			// debug(!"3 ");
+			// only succeed if all the constraints in intersection are equal
+			in-l := <filter(\ constraint -> <elem(eq-constraint-vars)> (constraint,r-cset) \);length> l-cset;
+			// debug(!"4 ");
+			// but the intersection constraints are not equal
+			compatible-l := <filter(\ constraint -> <elem(compatible-constraints)> (constraint,r-cset) \);length> l-cset;
+			// debug(!"5 ");
+			<eq> (in-l,compatible-l)
+			// debug(!"6 ")
+		with
+			// the distinct parts are easy
+			diff-l := <diff(compatible-constraints)> (l-cset,r-cset);
+			diff-r := <diff(compatible-constraints)> (r-cset,l-cset);
+			// debug(!"7 ");
+			l-isection := <isect(compatible-constraints)> (l-cset,r-cset);
+			// debug(!"8 ");
+			r-isection := <isect(compatible-constraints)> (r-cset,l-cset);
+			// debug(!"9 ");
+			isect := <zip(\ (Constraint(a,sl),Constraint(a,sr)) -> Constraint(a,<sort-apply> (sl,sr)) \)> (l-isection,r-isection);
+			// debug(!"10 ");
+			cset := <conc> (diff-l,diff-r,isect);
+			// debug(!"11 ");
+			result := <clean-constraint-set> CSet(cset)
+			// debug(!"12 ")
+			
+	
+	// if something is in the intersection but they are not equal
+	constraint-intersect:
+		(CSet(l-cset),CSet(r-cset)) -> FAIL()
+		where
+			// only FAIL if the sets are not disjoint and the constraints in the intersection are not equal
+			in-l := <filter(\ constraint -> <elem(eq-constraint-vars)> (constraint,r-cset) \);length> l-cset;
+			// but the intersection constraints are not equal
+			eq-l := <filter(\ constraint -> <elem(compatible-constraints)> (constraint,r-cset) \);length> l-cset;
+			<not(eq)> (in-l,eq-l)
+	
+	/**
+	* Cleanup & sort a constraint set. Orders all constraints in the set in ascending alphabetic order of the name variable names.
+	* Removes all duplicate constraints.
+	* @type : ConstraintSet -> ConstraintSet
+	*/
+	clean-constraint-set:
+		CSet(constraints) -> CSet(sorted-constraints)
+		where <?[_,_|_]> constraints
+		with
+			<make-set> constraints;
+			qsort(\ (Constraint(v1,_), Constraint(v2,_)) -> <string-lt> (<int-to-string <+ id> v1, <int-to-string <+ id> v2) \) => sorted-constraints
+			// if we have two adjacent constraints to the same variable, it is likely that one is ATerm() and the other is something else.
+			// we should compact that stuff
+			
+	clean-constraint-set:
+		t at CSet(constraints) -> t
+		where <?[] <+ ?[_]> constraints
+		
+	/**
+	* Succeeds if the given constraint set is valid. A constraint set is not valid if either is true:
+	*	1. is empty
+	*	2. a variable appear more than once and the constrained sorts are not equal
+	* In case of success, the resulting term is in the unchanged initial constraint-set
+	* @typeL ConstraintSet ->? ConstraintSet
+	*/
+	is-valid-constraint-set:
+		c at CSet(constraints) -> c
+		where
+			<?[]> constraints +
+			<?[_]> constraints +
+			clean-constraint-set => CSet(clean);
+			remove-duplicate-constraints(eq-constraint-vars) => CSet(nodups);
+			<diff> (clean,nodups);
+			?[]
+			
+	/**
+	* Remove duplicate constraints from the constraint set, using the given argument strategy to determine equality
+	* @param: (Constraint,Constraint) ->?
+	* @type: ConstraintSet -> ConstraintSet
+	*/
+	remove-duplicate-constraints(eq-s) = ?CSet(constraints);!CSet(<remove-duplicate-constraints(eq-s|[])> constraints)
+	
+	remove-duplicate-constraints(eq-s|acc): [] -> acc
+	
+	remove-duplicate-constraints(eq-s|acc):
+		[x|xs] -> <remove-duplicate-constraints(eq-s|acc')> xs 
+		with
+			if(<elem(eq-s)> (x,acc)) then
+				// duplicate found
+				acc' := acc
+			else
+				// not a duplicate
+				acc' := <conc> (acc,[x])
+			end
+			
+	
+	eq-constraint-vars:
+		(l,r) -> <eq> (<constraint-var> l, <constraint-var> r) 
+	
+	eq-constraint-sorts:
+		(l,r) -> <eq> (<constraint-sort> l, <constraint-sort> r)
+	
+	compatible-constraints:
+		t@(l,r) -> t 
+		where
+			<eq> (<constraint-var> l, <constraint-var> r);
+			<sort-apply> (<constraint-sort> l, <constraint-sort> r)
+	
+	eq-constraints:
+		t@(l,l) -> t 
+
+rules /* some builders */
+	to-constraint-intersection = foldll(!CSet([]),\ (a,b) -> ISection(a,b) \)
+	// to-constraint-intersection = reducel(\ (a,b) -> ISection(a,b) \)
+	
+	to-constraint-union = foldll(!FAIL(), \ (a,b) -> Union(a,b) \)
+
+rules /* some accessors */
+
+	/**
+	* Retrieves the constraint pertaining to the given variable from the given constraintset
+	* @param String
+	* @type ConstraintSet ->? Constraint
+	*/
+	get-var-constraint(|var):
+		CSet(constraints) -> <fetch-elem(?Constraint(var,_))> constraints
+	
+	/**
+	* Given a constraint returns the sort that the variable is constrained to
+	* @type Constraint(String,Sort) -> Sort
+	*/
+	get-constrained-var-sort:
+		Constraint(_,s) -> s
+		
+	constraint-var:
+		Constraint(var,_) -> var
+	
+	constraint-sort:
+		Constraint(_,sort) -> sort
+		
+	constraint-contains-var(|var) =
+		(?CSet(_) + ?Union(_,_) + ?ISection(_,_));
+		collect-all(?var,conc);
+		?[_|_]
+		
+
+
+		
\ No newline at end of file

Modified: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/stratego_sugar.str
==============================================================================
--- spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/stratego_sugar.str	Wed Jun 15 11:40:53 2011	(r23056)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/stratego_sugar.str	Wed Jun 15 15:00:34 2011	(r23057)
@@ -15,14 +15,19 @@
   signatures/project
   signatures/map
   signatures/check
-	utils/test
+  signatures/constructors
+	solver/constraints
+	rules/map
+	rules/check
+	utils/utils
+	tests/test-all
 	
 strategies
 
 rules
 
   editor-analyze:
-    (ast, path, project-path) -> (ast', errors, warnings, [])
+    (ast, path, project-path) -> (ast', errors, warnings, notes)
     with
       // Ensure all dynamic rules are properly scoped
       try(dr-scope-all-end);
@@ -36,10 +41,12 @@
       else
         if WarnAnalysis then
           errors   := <collect-all(constraint-error, conc)> ast';
-          warnings := <collect-all(global-constraint-error + constraint-warning, conc)> ast'
+          warnings := <collect-all(global-constraint-error + constraint-warning, conc)> ast';
+          notes := <collect-all(constraint-note,conc)> ast'
         else
           errors   := <collect-all(global-constraint-error + constraint-error, conc)> ast';
-          warnings := <collect-all(constraint-warning, conc)> ast'
+          warnings := <collect-all(constraint-warning, conc)> ast';
+          notes := <collect-all(constraint-note,conc)> ast'
         end
       end
 
@@ -73,26 +80,41 @@
       target := <parse-stratego-file> <resolve-import-decl> x
 
   // hover info for constructors
-  editor-hover:
-    (node, position, ast, path, project-path) -> text
-    where
-			<signature-of> node; // only show definitions
-			text := <pp-stratego-string> node
+  // editor-hover:
+  //   (node, position, ast, path, project-path) -> text
+  //   where
+		// 	<signature-of> node; // only show definitions
+		// 	text := <pp-stratego-string> node
  	
- 	editor-hover:
-    (node, _, _, _, _) -> text
-    where
-    	<sort-signature-of> node;
-    	get-sort-decls;
-    	pp-list(pp-sort-signature-top|"<br/>") => text
+  editor-hover:
+  	(node,_,_,_,_) -> text
+  	where
+  		not(DisableSortAnalysis);
+  		<?OpDecl(_,_){decl-id} + ?OpDeclInj(_){decl-id}> node;
+  		srt at ConstSig(_,_,_,conf,decl-id) := <get-sort-declaration> decl-id;
+  		<collect-all(?CSet(_),conc);map(\ cset -> <substitute(|cset)> srt \)> conf;
+  		text := <pp-list(pp-sort-signature-top|"<br/>")>
   
   editor-hover:
-    (node at SortVar(v){cookie}, _, _, _, _) -> text
-    where
-    	// dr-debug-rule-set(|"SortVar");
-    	// dr-debug-rule-set(|"DeferredApplication");
-    	text := $[[v]: [<get-var-sorts;pp-list(pp-sort-signature-top|", ")> cookie]]
-    	
+  	(SortVar(_){cookie},position,ast,_,_) -> text
+  	where
+  		not(DisableSortAnalysis);
+  		position' := <desugar-position(basic-desugar|ast)> position;
+  		ast' := <DecoratedAst>;
+  		parent := <parent-at-position(?ConstType(_);has-annos + ?OpDecl(_,_) + ?OpDeclInj(_)|position')> ast'
+  	where
+  		!parent;
+  		(?OpDecl(_,_){decl-id} + ?OpDeclInj(_){decl-id}
+  		< 
+  			<get-sort-declaration> decl-id;
+  			?ConstSig(_,_,_,config,_)
+  		+
+  			?ConstType(_){config}
+  		);
+  		<not(?FAIL())> config;
+  		<collect-all(?Constraint(cookie,_);get-constrained-var-sort,union)> config;
+  		text := <pp-list(pp-sort-signature|" + ")>
+  	
   
   editor-hover:
     (node at ToMetaExpr(_), position, ast, path, project-path) -> text
@@ -119,16 +141,24 @@
       result   := <DecoratedAst> selected
   
   // FIXME: for debugging only
-  generate-sort-signatures:
+  generate-signatures:
   	(selected, position, ast, path, project-path) -> (filename, result)
     with
       filename := <guarantee-extension(|"sig.aterm")> path;
-      all-keys-DeclaredSort;
-      mapconcat(bagof-DeclaredSort) => signs;
-      collect-all(?Var(_)); make-set;
-      map(\ Var(x) -> $[Var([<RenamedVarCookie> x]) => [<get-var-sorts;pp-sort-signature-top> x]] \) => vars;
-      result := [signs,vars]
-	
-	run-tests = test-all
+      if(not(DisableSortAnalysis)) then
+	      all-keys-DeclaredSort;
+	      mapconcat(bagof-DeclaredSort);
+	      mapconcat(bagof-SortSig) => signatures;
+	      all-keys-SortCookie => cookies;
+	      all-keys-DeclaredRule;
+	      mapconcat(bagof-DeclaredRule);
+	      mapconcat(bagof-RuleSig) => rulez;
+	      result := [signatures,cookies,rulez]
+	  	else
+	  		result := "Sort analysis is disabled for this project (.disable-sort-analysis)"
+	  	end
+      
+  run-tests = test-all
+  	
 
 

Added: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/tests/constraints-test.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/tests/constraints-test.str	Wed Jun 15 15:00:34 2011	(r23057)
@@ -0,0 +1,263 @@
+module constraints-test
+
+imports
+	solver/constraints
+	signatures/constructors
+
+rules /* Tests for solver */
+
+	test-constraints-all = 
+		test-constraints-utils;
+		test-constraints-solvers;
+		debug(!"ALL constraints tests passed ")
+		
+	test-constraints-utils =
+		test-clean-constraint-set-1;
+		test-clean-constraint-set-2;
+		test-clean-constraint-set-3;
+		test-clean-constraint-set-4;
+		test-clean-constraint-set-5;
+		test-remove-duplicate-constraints-1;
+		test-remove-duplicate-constraints-2;
+		test-remove-duplicate-constraints-3;
+		test-is-valid-constraint-set-1;
+		test-is-valid-constraint-set-2;
+		test-is-valid-constraint-set-3;
+		test-get-var-constraint-1;
+		test-get-constrained-var-sort-1;
+		debug(!"Constraints utils test passed ")
+	
+	test-constraints-solvers = 
+		test-constraint-intersect-1;
+		test-constraint-intersect-2;
+		test-constraint-intersect-3;
+		test-constraint-intersect-4;
+		test-constraint-intersect-5;
+		test-constraint-intersect-6;
+		test-constraint-union-1;
+		test-constraint-union-2;
+		test-constraint-union-3;
+		test-solve-1;
+		test-solve-2;
+		test-solve-3;
+		test-solve-4;
+		test-solve-5;
+		test-solve-6;
+		debug(!"Constraint solvers test passed ")
+	
+	test-remove-duplicate-constraints-1 = 
+		<remove-duplicate-constraints(eq-constraint-vars)> CSet([Constraint("varA",Int()),Constraint("varB",Int()),Constraint("varA",Double())]) => nodups;
+		<eq> (nodups, CSet([Constraint("varA",Int()),Constraint("varB",Int())]))
+	
+	test-remove-duplicate-constraints-2 = 
+		<remove-duplicate-constraints(eq-constraints)> CSet([Constraint("varA",Int()),Constraint("varB",Int()),Constraint("varA",Double())]) => nodups;
+		<eq> (nodups, CSet([Constraint("varA",Int()),Constraint("varB",Int()),Constraint("varA",Double())]))
+		
+	test-remove-duplicate-constraints-3 = 
+		<remove-duplicate-constraints(eq-constraints)> CSet([Constraint("varA",Int()),Constraint("varB",Int()),Constraint("varA",Int())]) => nodups;
+		<eq> (nodups, CSet([Constraint("varA",Int()),Constraint("varB",Int())]))
+	
+	test-is-valid-constraint-set-1 = 
+		!CSet([]); is-valid-constraint-set
+	
+	test-is-valid-constraint-set-2 = 
+		!CSet([Constraint("varA",Int()),Constraint("varB",Int())]); is-valid-constraint-set
+	
+	test-is-valid-constraint-set-3 = 
+		!CSet([Constraint("varA",Int()),Constraint("varA",Double())]); not(is-valid-constraint-set)
+		
+	test-get-var-constraint-1 =
+		<get-var-constraint(|"varA")> CSet([Constraint("a",Int()),Constraint("varA",Double())]);
+		?Constraint("varA",Double())
+	
+	test-get-constrained-var-sort-1 =
+		<get-constrained-var-sort> Constraint("varZ",Int());
+		?Int()
+	
+	test-clean-constraint-set-1 =
+		origin := CSet([Constraint("varA",Int()),Constraint("varB",Double())]);
+		clean := <clean-constraint-set> origin;
+		<eq> (origin, clean)
+	
+	test-clean-constraint-set-2 =
+		origin := CSet([Constraint("varB",Int()),Constraint("varA",Double())]);
+		clean := <clean-constraint-set> origin;
+		exp := CSet([Constraint("varA",Double()),Constraint("varB",Int())]);
+		<eq> (exp,clean)
+			
+	test-clean-constraint-set-3 =
+		origin := CSet([Constraint("43",Int()),Constraint("42",Double()),Constraint("abc",Double())]);
+		clean := <clean-constraint-set> origin;
+		exp := CSet([Constraint("42",Double()),Constraint("43",Int()),Constraint("abc",Double())]);
+		<eq> (exp, clean)
+		
+	test-clean-constraint-set-4 =
+		!CSet([Constraint("a",<sort-any>)]);
+		clean-constraint-set;
+		?CSet([Constraint("a",<sort-any>)])
+	
+	test-clean-constraint-set-5 =
+		!CSet([Constraint("c",<sort-any>),Constraint("a",<sort-any>)]);
+		clean-constraint-set;
+		?CSet([Constraint("a",<sort-any>),Constraint("c",<sort-any>)])
+	
+	test-constraint-intersect-1 = 
+		// disjoint sets
+		lhs := CSet([Constraint("a",Double()),Constraint("b",Int())]);
+		rhs := CSet([Constraint("c",Int()),Constraint("d",Double())]);
+		intersected := <constraint-intersect> (lhs,rhs);
+		expected :=  CSet([Constraint("a",Double()),Constraint("b",Int()),Constraint("c",Int()),Constraint("d",Double())]);
+		<eq> (expected,intersected)
+	
+	test-constraint-intersect-2 = 
+		// non-disjoint sets with equal intersection constraints
+		lhs := CSet([Constraint("a",Double()),Constraint("b",Int())]);
+		rhs := CSet([Constraint("c",Int()),Constraint("b",Int())]);
+		intersected := <constraint-intersect> (lhs,rhs);
+		expected :=  CSet([Constraint("a",Double()),Constraint("b",Int()),Constraint("c",Int())]);
+		<eq> (expected,intersected)
+	
+	test-constraint-intersect-3 = 
+		// non-disjoint sets with equal intersection constraints
+		lhs := CSet([Constraint("f",String()),Constraint("a",Double()),Constraint("b",Int())]);
+		rhs := CSet([Constraint("c",Int()),Constraint("b",Int()),Constraint("f",String())]);
+		intersected := <constraint-intersect> (lhs,rhs);
+		expected :=  CSet([Constraint("a",Double()),Constraint("b",Int()),Constraint("c",Int()),Constraint("f",String())]);
+		<eq> (expected,intersected)
+	
+	test-constraint-intersect-4 = 
+		// non-disjoint sets with non-equal intersection constraints
+		lhs := CSet([Constraint("a",Double()),Constraint("b",Int())]);
+		rhs := CSet([Constraint("c",Int()),Constraint("b",Double()),Constraint("f",String())]);
+		intersected := <constraint-intersect> (lhs,rhs);
+		expected :=  FAIL();
+		<eq> (expected,intersected)
+	
+	test-constraint-intersect-5 = 
+		// non-disjoint sets with non-equal intersection constraints
+		lhs := CSet([Constraint("a",Double()),Constraint("b",Int()),Constraint("f",Double())]);
+		rhs := CSet([Constraint("c",Int()),Constraint("b",Int()),Constraint("f",String())]);
+		intersected := <constraint-intersect> (lhs,rhs);
+		expected :=  FAIL();
+		<eq> (expected,intersected)
+	
+	test-constraint-intersect-6 =
+		lhs := CSet([Constraint("a",<sort-any>)]);
+		rhs := CSet([Constraint("a",Int())]);
+		intersected := <constraint-intersect> (lhs,rhs);
+		expected := CSet([Constraint("a",Int())]);
+		<eq> (expected,intersected)
+		
+	test-constraint-union-1 =
+		// disjoint sets 
+		lhs := CSet([Constraint("a",Int()),Constraint("b",Double())]);
+		rhs := CSet([Constraint("c",Double()),Constraint("d", Int())]);
+		unified := <constraint-unify> (lhs,rhs);
+		expected := CSet([Constraint("a",Int()),Constraint("b",Double()),Constraint("c",Double()),Constraint("d", Int())]);
+		<eq> (expected, unified)
+	
+	test-constraint-union-2 =
+		// complementary sets
+		lhs := CSet([Constraint("a",Int()),Constraint("b",Double())]);
+		rhs := CSet([Constraint("b",Double()),Constraint("d", Int())]);
+		unified := <constraint-unify> (lhs,rhs);
+		expected := CSet([Constraint("a",Int()),Constraint("b",Double()),Constraint("d", Int())]);
+		<eq> (expected, unified)
+	
+	test-constraint-union-3 =
+		// parallel universes
+		lhs := CSet([Constraint("a",Int()),Constraint("b",Double())]);
+		rhs := CSet([Constraint("b",Int()),Constraint("d", Int())]);
+		<not(constraint-unify)> (lhs,rhs)
+	
+	
+	test-solve-1 = 
+		c := Union(
+								CSet([Constraint("a",String()),Constraint("c",Int())]),
+								CSet([Constraint("a",Int()),Constraint("c",String())])
+								);
+		exp := Union(
+								CSet([Constraint("a",String()),Constraint("c",Int())]),
+								CSet([Constraint("a",Int()),Constraint("c",String())])
+								);
+		solved := <solve-top> c;
+		<eq> (exp,solved)
+	
+	test-solve-2 = 
+		c := 			Union(
+								CSet([Constraint("a",Double())]),
+								Union(
+										CSet([Constraint("a",Int())]),
+										CSet([Constraint("a",String())])
+									)
+								);
+		exp := Union(
+								CSet([Constraint("a",Double())]),
+								Union(
+										CSet([Constraint("a",Int())]),
+										CSet([Constraint("a",String())])
+									)
+								);
+		solved := <solve-top> c;
+		<eq> (exp,solved)
+	
+	test-solve-3 = 
+		c := 			ISection(
+								CSet([Constraint("a",Double())]),
+								Union(
+										CSet([Constraint("a",Int())]),
+										CSet([Constraint("a",String())])
+									)
+								);
+		exp := FAIL();
+		solved := <solve-top> c;
+		<eq> (exp,solved)
+	
+	test-solve-4 = 
+		c := ISection(
+							Union(
+								CSet([Constraint("a",String()),Constraint("c",Int())]),
+								CSet([Constraint("a",Int()),Constraint("c",String())])
+								),
+							Union(
+								CSet([Constraint("a",Double())]),
+								Union(
+										CSet([Constraint("a",Int())]),
+										CSet([Constraint("a",String())])
+									)
+								)
+							);
+		exp1 := Union(CSet([Constraint("a",Int()),Constraint("c",String())]),CSet([Constraint("a",String()),Constraint("c",Int())]));
+		exp2 := Union(CSet([Constraint("a",String()),Constraint("c",Int())]),CSet([Constraint("a",Int()),Constraint("c",String())]));
+		solved := <solve-top> c;
+		(<eq> (exp1,solved) <+ <eq> (exp2,solved))
+	
+	test-solve-5 = 
+		c := ISection( 
+				ISection(
+							Union(
+								CSet([Constraint("a",String()),Constraint("c",Int())]),
+								CSet([Constraint("a",Int()),Constraint("c",String())])
+								),
+							Union(
+								CSet([Constraint("a",Double())]),
+								Union(
+										CSet([Constraint("a",Int())]),
+										CSet([Constraint("a",String())])
+									)
+								)
+							),
+					Union(CSet([Constraint("c",String())]),CSet([Constraint("c",String())])));
+		exp1 := CSet([Constraint("a",Int()),Constraint("c",String())]);
+		solved := <solve-top> c;
+		<eq> (exp1,solved)
+		
+	test-solve-6 =
+		c := Union(
+						ISection(CSet([Constraint("a",Int())]),CSet([Constraint("b",(Double(),Int()))])),
+						ISection(CSet([Constraint("a",String())]),CSet([Constraint("b",(Double(),Int()))])));
+		exp1 := Union(
+							CSet([Constraint("a",Int()),Constraint("b",(Double(),Int()))]),
+							CSet([Constraint("a",String()),Constraint("b",(Double(),Int()))]));
+		solved := <solve-top> c;
+		<eq> (exp1, solved)
\ No newline at end of file

Added: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/tests/map-signature-test.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/tests/map-signature-test.str	Wed Jun 15 15:00:34 2011	(r23057)
@@ -0,0 +1,65 @@
+module map-signature-test
+
+imports
+	signatures/map
+	signatures/constructors
+
+rules /* Tests for signature/map */
+
+	test-map = test-sort-storage
+
+	test-sort-storage = 
+		test-sort-storage-1;
+		test-sort-storage-2;
+		test-sort-storage-3;
+		test-sort-storage-4;
+		debug(!"All sort storage tests passed. ")
+		
+	test-sort-storage-1 = 
+		{|DeclaredSort,SortCookie,SortSig:
+			sig := ConstSig("a",["b"],"c",["d"],12345);
+			cookie := <store-sort-decl>;
+			!"d"{cookie};
+			get-sort-declarations;
+			?[sig];
+			<get-sort-declaration> 12345;
+			?sig
+		|}
+	
+	test-sort-storage-2 = 
+		{|DeclaredSort,SortCookie,SortSig:
+			sig1 := ConstSig("a",["b"],"c",["d"],12345);
+			sig2 := ConstSig("e",["f"],"c",["g"],12346);
+			<store-sort-decl> sig1 => cookie;
+			<store-sort-decl> sig2 => cookie;
+			<get-sort-declarations> "c"{cookie};
+			(?[sig1,sig2] + ?[sig2,sig1]);
+			<get-sort-declaration> 12345 => sig1;
+			<get-sort-declaration> 12346 => sig2 
+		|}
+	
+	test-sort-storage-3 = 
+		{|DeclaredSort,SortCookie,SortSig:
+			sig1 := ConstSig("a",["b"],"c",["d"],12345);
+			cookie := <store-sort-decl>;
+			sig2 := ConstSig("a",["b"],"c",["d","e"],12345);
+			<replace-sort-decl> sig2;
+			<get-sort-declaration> 12345;
+			?sig2
+		|}
+	
+	test-sort-storage-4 = 
+		{|DeclaredSort,SortCookie,SortSig:
+			sig1 := ConstSig("a",["b"],"c",["d"],12345);
+			sig2 := ConstSig("a",["b"],"c",["d","e"],12346);
+			sig3 := ConstSig("thisisaB",["b"],"c",["d","e"],12347);
+			<store-sort-decl> sig1;
+			<store-sort-decl> sig2;
+			<store-sort-decl> sig3;
+			<get-signatures-for-constructor> "a";
+			(?[sig1,sig2] + ?[sig2,sig1]);
+			<get-signatures-for-constructor> "thisisaB";
+			?[sig3]
+		|}
+	
+	
\ No newline at end of file

Added: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/tests/project-rule-test.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/tests/project-rule-test.str	Wed Jun 15 15:00:34 2011	(r23057)
@@ -0,0 +1,248 @@
+module project-rule-test
+
+imports
+	rules/project
+	libstrc
+	signatures/constructors
+	signatures/map
+	solver/constraints
+	signatures/project
+	
+rules /* Tests for rules/project */
+
+	test-rule-project = 
+		test-sort-of;
+		debug(!"All tests rule-project passed.")
+
+	test-sort-of = 
+		test-sort-of-1;
+		test-sort-of-2;
+		test-sort-of-3;
+		test-sort-of-4;
+		test-sort-of-5;
+		test-sort-of-6;
+		test-sort-of-7;
+		test-sort-of-8;
+		test-sort-of-9;
+		test-sort-of-10;
+		test-sort-of-11;
+		test-sort-of-12;
+		test-sort-of-13;
+		test-sort-of-14;
+		test-sort-of-15;
+		test-sort-of-16;
+		test-sort-of-17;
+		test-sort-of-18;
+		test-sort-of-19;
+		test-sort-of-20;
+		debug(!"All tests for sort-of are passed. ")
+		
+	test-sort-of-1 = 
+		ops := List([Real("42.22"),Real("3.14"),Wld()]);
+		srt := <sort-of> ops;
+		?[(List(Double()),_)]
+	
+	test-sort-of-2 = 
+		op := List([Str("hello"),Real("3.14"),Wld()]);
+		srt := <sort-of> op;
+		?[(List(<sort-any>),_)]
+
+	test-sort-of-3 = 
+		op := List([Var("a"{"a"}),Var("b"{"b"})]);
+		srt := <sort-of> op;
+		?[(List(<sort-any>),CSet([Constraint("a",<sort-any>),Constraint("b",<sort-any>)]))]
+	
+	test-sort-of-4 = 
+		op := List([Var("a"{"a"}),Var("b"{"b"}),Int("3")]);
+		srt := <sort-of> op;
+		?[(List(Int()),CSet([Constraint("a",<sort-any>),Constraint("b",<sort-any>)]))]
+	
+	test-sort-of-5 = 
+		op := List([Var("a"{"a"}),Var("b"{"b"}),Int("3"),Real("55.5")]);
+		srt := <sort-of> op;
+		?[(List(<sort-any>),CSet([Constraint("a",<sort-any>),Constraint("b",<sort-any>)]))]
+	
+	test-sort-of-6 =
+		{| DeclaredSort,SortSig,SortCookie:
+			sig1 := ConstSig("Sum",["Num"#([Var("x")]),"Num"#([Var("x")])],"BinOp"#([]),Union(CSet([Constraint("x",Int())]),CSet([Constraint("x",Double())])),1);
+			<store-sort-decl> sig1;
+			sig2 := ConstSig("Sum",["Number"#([Var("x")]),"Number"#([Var("x")])],"PlusOp"#([]),Union(CSet([Constraint("x",Int())]),CSet([Constraint("x",Double())])),2);
+			<store-sort-decl> sig2;
+			sig3 := ConstSig("Number",[Int()],"Number"#([]),CSet([]),3);
+			<store-sort-decl> sig3;
+			sig4 := ConstSig("Number",[Double()],"Number"#([]),CSet([]),4);
+			<store-sort-decl> sig4;
+			op := List([NoAnnoList(Op("Sum"{1147911}, [Var("l"{"l"}), Var("r"{"r"})])),NoAnnoList(Op("Sum"{1147911}, [Var("l"{"l"}), Var("r"{"r"})]))]);
+			<sort-of> op;
+			?[(List(<sort-any>),Union(Union(_,_),Union(_,_)))]
+		|}
+	
+	test-sort-of-7 =
+		{| DeclaredSort,SortSig,SortCookie:
+			sig3 := ConstSig("Number",[Int()],"Number"#([]),CSet([]),3);
+			<store-sort-decl> sig3;
+			sig4 := ConstSig("Number",[Double()],"Number"#([]),CSet([]),4);
+			<store-sort-decl> sig4;
+			op := List(
+                [ NoAnnoList(Op("Number"{4088499}, [Var("a"{"a"})]))
+                , NoAnnoList(Op("Number"{4088499}, [Var("b"{"b"})]))
+                ]
+              );
+			<sort-of> op;
+			?[(List(<sort-any>),Union(Union(_,_),Union(_,_)))]
+		|}
+	
+	test-sort-of-8 = 
+		op := As(Var("x"{"x"}),List([Var("a"{"a"}),Var("b"{"b"}),Int("3"),Int("55")]));
+		srt := <sort-of> op;
+		?[(List(Int()),CSet([Constraint("a",<sort-any>),Constraint("b",<sort-any>),Constraint("x",List(Int()))]))]
+
+	test-sort-of-9 = 
+		op := ListTail([Var("a"{"a"}),Var("b"{"b"}),Int("3")],Var("x"{"x"}));
+		srt := <sort-of> op;
+		?[(List(Int()),CSet([Constraint("a",<sort-any>),Constraint("b",<sort-any>),Constraint("x",List(Int()))]))]
+		
+	test-sort-of-10 =
+		op := ListTail([Var("a"{"a"}),Var("b"{"b"}),Int("3")],List([Int("42")]));
+		srt := <sort-of> op;
+		?[(List(Int()),_)]
+	
+	test-sort-of-11 =
+		op := ListTail([Var("a"{"a"}),Var("b"{"b"}),Int("3")],List([]));
+		srt := <sort-of> op;
+		?[(List(Int()),CSet(_))]
+	
+	test-sort-of-12 = 
+		{| DeclaredSort,SortSig,SortCookie:
+			sig3 := ConstSig("Number",[Int()],"Num"#([]),CSet([]),3);
+			<store-sort-decl> sig3;
+			op := ListTail(
+                [Var("a"{4795521}), Var("b"{4795522})]
+              , NoAnnoList(Op("Number"{4795505}, [Var("x"{4795523})]))
+              );
+      <sort-of> op;
+      ?[(List(ATerm()),FAIL())]
+     |}
+	
+	test-sort-of-13 = 
+		{| DeclaredSort,SortSig,SortCookie:
+			sig2 := ConstSig("Number",[Int()],"Number"#([]),CSet([]),1);
+			<store-sort-decl> sig2;
+			sig3 := ConstSig("Number",[Int()],"Num"#([]),CSet([]),2);
+			<store-sort-decl> sig3;
+			op := ListTail(
+                [Var("a"{4795521}), Var("b"{4795522})]
+              , NoAnnoList(Op("Number"{4795505}, [Var("x"{4795523})]))
+              );
+      <sort-of> op;
+      ?[(List(ATerm()),FAIL())]
+     |}
+		
+	
+	test-sort-of-14 =
+		op := Tuple([Var("op"{1194161}), NoAnnoList(Str("\"hello\"")), NoAnnoList(Str("\"world\""))]);
+		srt := <sort-of> op;
+		?[(<new-tuple-sort> [Var(1194161),String(),String()],CSet([Constraint(1194161,<sort-any>)]))]
+	
+	test-sort-of-15 =
+		{| DeclaredSort,SortSig,SortCookie:
+			sig1 := ConstSig("Sum",["Num"#([Var("x")]),"Num"#([Var("x")])],"BinOp"#([]),CSet([Constraint("x",Int())]),1);
+			<store-sort-decl> sig1;
+			sig2 := ConstSig("Sum",["Num"#([Var("x")]),"Num"#([Var("x")])],"PlusOp"#([]),CSet([Constraint("x",Int())]),2);
+			<store-sort-decl> sig2;
+			sig3 := ConstSig("Number",[Int()],"Num"#([]),CSet([]),3);
+			<store-sort-decl> sig3;
+			op := Tuple([ NoAnnoList(Op("Sum"{878442}, [Wld(), Wld()])), NoAnnoList(Op("Sum"{878442}, [Wld(), Wld()]))]);
+			debug(!"151 ");
+			<sort-of> op;
+			debug(!"152 ");
+			?[("Tuple-2"#(["BinOp"#(_),"BinOp"#(_)]),_),
+				("Tuple-2"#(["BinOp"#(_),"PlusOp"#(_)]),_),
+				("Tuple-2"#(["PlusOp"#(_),"BinOp"#(_)]),_),
+				("Tuple-2"#(["PlusOp"#(_),"PlusOp"#(_)]),_)]
+		|}
+
+	
+	test-sort-of-16 =
+		{| DeclaredSort,SortSig,SortCookie:
+			sig3 := ConstSig("Number",[Int()],"Num"#([]),CSet([]),3);
+			<store-sort-decl> sig3;
+			sig4 := ConstSig("Number",[Double()],"Num"#([]),CSet([]),4);
+			<store-sort-decl> sig4;
+			op := NoAnnoList(Op("Number"{4945430}, [Var("l"{"l"})]));
+			sort-of;
+			?[ ("Num"#([Var("l")]),Union(CSet([Constraint("l",Int())]),CSet([Constraint("l",Double())])))]
+		|}
+	
+	test-sort-of-17 = 
+		{| DeclaredSort,SortSig,SortCookie:
+			sig1 := ConstSig("Sum",["Num"#([Var("x")]),"Num"#([Var("x")])],"BinOp"#([]),Union(CSet([Constraint("x",Int())]),CSet([Constraint("x",Double())])),1);
+			<store-sort-decl> sig1;
+			sig2 := ConstSig("Sum",["Number"#([Var("x")]),"Number"#([Var("x")])],"PlusOp"#([]),Union(CSet([Constraint("x",Int())]),CSet([Constraint("x",Double())])),2);
+			<store-sort-decl> sig2;
+      op := NoAnnoList(Op("Sum"{1147911}, [Var("l"{"l"}), Var("r"{"r"})]));
+      sort-of;
+      ?[
+      	("BinOp"#([Var("l"),Var("r")]),Union(CSet([Constraint("l","Num"#([Int()])),Constraint("r","Num"#([Int()]))]),CSet([Constraint("l","Num"#([Double()])),Constraint("r","Num"#([Double()]))]))),
+      	("PlusOp"#([Var("l"),Var("r")]),Union(CSet([Constraint("l","Number"#([Int()])),Constraint("r","Number"#([Int()]))]),CSet([Constraint("l","Number"#([Double()])),Constraint("r","Number"#([Double()]))])))
+      ]
+		|}
+	
+	
+	test-sort-of-18 = 
+		{| DeclaredSort,SortSig,SortCookie:
+			sig1 := ConstSig("Sum",["Num"#([Var("x")]),"Num"#([Var("x")])],"BinOp"#([]),Union(CSet([Constraint("x",Int())]),CSet([Constraint("x",Double())])),1);
+			<store-sort-decl> sig1;
+			sig2 := ConstSig("Sum",["Number"#([Var("x")]),"Number"#([Var("x")])],"PlusOp"#([]),Union(CSet([Constraint("x",Int())]),CSet([Constraint("x",Double())])),2);
+			<store-sort-decl> sig2;
+			sig3 := ConstSig("Number",[Int()],"Number"#([]),CSet([]),3);
+			<store-sort-decl> sig3;
+			sig4 := ConstSig("Number",[Double()],"Number"#([]),CSet([]),4);
+			<store-sort-decl> sig4;
+      op := NoAnnoList(
+              Op(
+                "Sum"{4792220}
+              , [NoAnnoList(Op("Number"{4792216}, [Var("l"{"l"})])), Var("r"{"r"})]
+              )
+            );
+      sort-of;
+      ?[
+      	("PlusOp"#(["Number"#([Var("l")]),Var("r")]),Union(CSet([Constraint("l",Int()),Constraint("r","Number"#([Int()]))]),CSet([Constraint("l",Double()),Constraint("r","Number"#([Double()]))])))
+      ]
+		|}
+		
+	test-sort-of-19 = 
+		{| DeclaredSort,SortSig,SortCookie:
+			sig1 := ConstSig("Sum",["Num"#([Var("x")]),"Num"#([Var("x")])],"BinOp"#([]),Union(CSet([Constraint("x",Int())]),CSet([Constraint("x",Double())])),1);
+			<store-sort-decl> sig1;
+			sig2 := ConstSig("Sum",["Number"#([Var("x")]),"Number"#([Var("x")])],"PlusOp"#([]),Union(CSet([Constraint("x",Int())]),CSet([Constraint("x",Double())])),2);
+			<store-sort-decl> sig2;
+			sig3 := ConstSig("Number",[Int()],"Number"#([]),CSet([]),3);
+			<store-sort-decl> sig3;
+			sig4 := ConstSig("Number",[Double()],"Number"#([]),CSet([]),4);
+			<store-sort-decl> sig4;
+      op := NoAnnoList(
+              Op(
+                "Sum"{4792220}
+              , [NoAnnoList(Op("Number"{4792216}, [Var("l"{"l"})])), Var("r"{"r"})]
+              )
+            );
+      sort-of;
+      ?[
+      	("PlusOp"#(["Number"#([Var("l")]),Var("r")]),Union(CSet([Constraint("l",Int()),Constraint("r","Number"#([Int()]))]),CSet([Constraint("l",Double()),Constraint("r","Number"#([Double()]))])))
+      ]
+		|}
+		
+	test-sort-of-20 =
+		{| DeclaredSort,SortSig,SortCookie:
+			sig1 := ConstSig("Number",[Int()],"Num"#([]),CSet([]),1);
+			<store-sort-decl> sig1;
+			sig2 := ConstSig("Sum",[<new-tuple-sort> ["Num"#([Var("x")]),"Num"#([Var("x")])] ],"BinOp"#([]),CSet([Constraint("x",Int())]),2);
+			<store-sort-decl> sig2;
+			op := Op("Sum"{"1234"},[NoAnnoList(Tuple([Var("a"{"a"}), Var("b"{"b"})]))]);
+			<sort-of> op;
+			?[("BinOp"#([<new-tuple-sort> [Var("a"),Var("b")] ]),CSet([Constraint("a","Num"#([Int()])),Constraint("b","Num"#([Int()]))]))]
+		|}
+		
+		
+		
\ No newline at end of file

Added: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/tests/project-signature-test.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/tests/project-signature-test.str	Wed Jun 15 15:00:34 2011	(r23057)
@@ -0,0 +1,67 @@
+module project-signature-test
+
+imports
+	signatures/project
+	solver/constraints
+	signatures/constructors
+	signatures/map
+
+rules /* Tests for signatures/project */
+
+	test-signature-project =
+		test-new-configuration;
+		test-substitute;
+		test-sort-apply;
+		debug(!"Tests project passed. ")
+
+	test-new-configuration =
+		test-new-config-1;
+		test-new-config-2;
+		debug(!"Tests new-configuration passed. ")
+		
+	test-new-config-1 = 
+		!["a"];
+		new-configuration;
+		?CSet([Constraint("a",<sort-any>)])
+	
+	test-new-config-2 =
+		!["a","b","c"];
+		new-configuration;
+		?CSet([Constraint("a",<sort-any>),Constraint("b",<sort-any>),Constraint("c",<sort-any>)])
+	
+	
+	test-substitute = 
+		test-substitute-1;
+		debug(!"Tests substitute passed. ")
+	
+	test-substitute-1 = 
+		<substitute(|CSet([Constraint("a",Int()),Constraint("c",Double())]))> (Var("a"),Var("b"),Var("c"),Var("d"));
+		?(Int(),<sort-any>,Double(),<sort-any>)
+		
+	
+	test-sort-apply = 
+		test-sort-apply-1;
+		test-sort-apply-2;
+		test-sort-apply-3;
+		debug(!"Tests sort-apply passed. ")
+	
+	test-sort-apply-1 = 
+		<sort-apply> ("A"#([]),"A"#([]))
+	
+	test-sort-apply-2 = 
+		{| DeclaredSort,SortSig,SortCookie:
+			sig1 := ConstSig("A",[String(),Int()],"A"#([]),CSet([]),1234);
+			<store-sort-decl> sig1;
+			<sort-apply> ("A"#([]),"A"#([String(),Int()]));
+			<sort-apply> ("A"#([String(),Int()]),"A"#([]));
+			<sort-apply> ("A"#([]),"A"#([]))
+		|}
+	
+	test-sort-apply-3 = 
+		{| DeclaredSort,SortSig,SortCookie:
+			sig1 := ConstSig("A",[String(),Int()],"A"#([]),CSet([]),1234);
+			<store-sort-decl> sig1;
+			sig2 := ConstSig("A",[],"A"#([]),CSet([]),1235);
+			<store-sort-decl> sig2;
+			<not(sort-apply)> ("A"#([]),"A"#([String(),Int()]))
+		|}
\ No newline at end of file

Added: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/tests/test-all.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/tests/test-all.str	Wed Jun 15 15:00:34 2011	(r23057)
@@ -0,0 +1,18 @@
+module test-all
+
+imports
+	tests/constraints-test
+	tests/map-signature-test
+	tests/project-rule-test
+	tests/project-signature-test
+	tests/utils-test
+	
+rules
+	
+	test-all = 
+		test-utils;
+  	test-map;
+  	test-constraints-all;
+  	test-signature-project;
+  	test-rule-project;
+  	debug(!"All tests passed. ")
\ No newline at end of file

Added: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/tests/utils-test.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/tests/utils-test.str	Wed Jun 15 15:00:34 2011	(r23057)
@@ -0,0 +1,160 @@
+module utils-test
+
+
+imports
+	utils/utils
+	solver/constraints
+	signatures/constructors
+	lib/editor-common.generated
+	signatures/project
+
+
+signature
+	constructors
+		Test : a -> Test
+
+rules /* Test for utils/utils */
+
+	test-utils =
+		test-elem-at-index-1
+		;test-elem-at-index-2
+		;test-elem-at-index-3
+		;test-at-indices
+		;test-get-indices
+		;test-positions-of-term-1
+		;test-positions-of-term-2
+		;test-positions-of-term-3
+		;test-positions-of-term-4
+		;test-parent-at-position-1
+		;test-parent-at-position-2
+		;test-long-cart
+		;test-reducel
+		;debug(!"All utils tests succeeded")
+ 	
+ 	test-elem-at-index-1 =
+ 		<elem-at-index(|2)> [1,2,3,4,5] => out;
+ 		(?3 <+ <fatal-err(|"Test elem-at-index failed \n Expected 3 but got: ")> out)
+ 	
+ 	test-elem-at-index-2 =
+ 		<elem-at-index(|4)> [1,2,3,4,5] => out;
+ 		(?5 <+ <fatal-err(|"Test elem-at-index failed \n Expected 5 but got: ")> out)
+ 	
+ 	test-elem-at-index-3 = not(<elem-at-index(|6)> [1,2,3,4,5])
+ 	
+ 	test-at-indices =
+ 		list := [5,4,3,2,1];
+ 		pos := [0,2];
+ 		<at-indices(|pos)> list => out;
+ 		(?[5,3] <+ <fatal-err(|"Test test-list-at-indices failed \n Expected [5,3] but got: ")> out)
+ 	
+ 	test-get-indices = 
+ 		list := ["foo","bar","is", "foo", "and", "bar"];
+ 		<get-indices(?"foo")> list => out;
+ 		(?[0,3] <+ <fatal-err(|"Test test-get-indices failed \n Expected [0,3] but got: ")> out);
+ 		<get-indices(?"foo" + ?"bar")> list => out2;
+ 		(?[0,1,3,5] <+ <fatal-err(|"Test test-get-indices failed \n Expected [0,1,3,5] but got: ")> out2)
+ 	
+	test-positions-of-term-1 =
+		!(Test("a"),Test("b"),(Test("d"),(Test("e"),Test("f")))) => term;
+		positions-of-term(?Test("e"));
+		?[ position@[2,1,0] ];
+		<term-at-position(|position)> term;
+		?Test("e")
+	
+	test-positions-of-term-2 =
+		!(Test("a"),Test("b"),(Test("d"),(Test("e"),Test("f")))) => term;
+		positions-of-term(?Test("e"));
+		?[ position@[2,1,0] ];
+		<term-at-position(|position)> term;
+		?Test("e")
+	
+	test-positions-of-term-3 =
+		!(Test(1),Test(2),(Test(3),(Test(3),Test(4)))) => term;
+		positions-of-term(?Test(3));
+		?[ p1@[2,0],p2@[2,1,0] ];
+		<term-at-position(|p1)> term;
+		?Test(3);
+		<term-at-position(|p2)> term;
+		?Test(3)
+
+	test-positions-of-term-4 =
+		!(Test(1),Test(2),(Test(3),(Test(3),Test(4)))) => term;
+		positions-of-term(?Test(15));
+		?[]
+
+	test-parent-at-position-1 =
+		tree := Test(Test(Test(Test("a"))){"kkk"});
+		positions := <position-of-term(?Test("a"))> tree;
+		<parent-at-position(?Test(_){"kkk"}|positions)> tree;
+		?Test(_){"kkk"}
+	
+	test-parent-at-position-2 =
+		tree := Test(Test(Test(Test("a"))){"kkk"});
+		positions := <position-of-term(?Test("a"))> tree;
+		<not(parent-at-position(?Test(_){"xxx"}|positions))> tree
+	
+	test-long-cart = 
+		test-long-cart-1
+		;test-long-cart-2
+		;test-long-cart-3
+		;test-long-cart-4
+		;test-long-cart-5
+		;test-long-cart-6
+		;test-long-cart-7
+		;debug(!"All long-cart tests passed. ")
+	
+	test-long-cart-1 = 
+		![];
+		not(long-cart(id))
+	
+	test-long-cart-2 = 
+		![[1,2,3]];
+		not(long-cart(id))
+	
+	test-long-cart-3 =
+		![[1,2,3],[]];
+		long-cart(id);
+		?[]
+	
+	test-long-cart-4 = 
+		![[1],[2]];
+		long-cart(add);
+		?[3]
+	
+	test-long-cart-5 =
+		![ [1,2,3],[4,5]];
+		long-cart(add);
+		?[5,6,6,7,7,8]
+	
+	test-long-cart-6 =
+		![[1,2],[4,5],[6,7,8]];
+		long-cart(add);
+		?[11,12,13,12,13,14,12,13,14,13,14,15]
+	
+	test-long-cart-7 = 
+		![ 
+			[
+				(Int(),CSet([Constraint("a",Int())])),
+				(Double(),CSet([Constraint("a",Double())]))
+			],
+			[
+				(Int(),CSet([Constraint("b",String())])),
+				(List(),CSet([Constraint("a",String())]))
+			]
+		];
+		long-cart(\
+			((s1,c1),(s2,c2)) -> (<sort-apply <+ sort-any> (s1,s2),<solve-top> ISection(c1,c2)) 
+		\);
+		filter(not(?(_,FAIL())));
+		?[(Int(),CSet([Constraint("a",Int()),Constraint("b",String())])),(<sort-any>,CSet([Constraint("a",Double()),Constraint("b",String())]))]
+	
+	
+	test-reducel =
+		test-reducel-1
+		;debug(!"Reducell tests passed ")
+		 
+	test-reducel-1 = 
+		![42,1,2,3];
+		reducel(subti);
+		?36
+	
\ No newline at end of file

Added: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/utils/annotations.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/utils/annotations.str	Wed Jun 15 15:00:34 2011	(r23057)
@@ -0,0 +1,70 @@
+/*
+| $LastChangedBy: vlad $
+| $LastChangedDate: 2010-11-23 15:19:12 +0100 (Tue, 23 Nov 2010) $
+| $LastChangedRevision: 4401 $
+*/
+/* Based on copy from WebDSL revision 4115. 
+Modified version from revision 4115.
+*/
+module lib/annotations
+
+imports
+  libstrategolib
+	utils/utils
+	
+rules // annotation utilities
+    
+	// Add annotation to term
+	add-anno(|new-anno):
+		elem -> elem{new-anno, anno*}
+		where anno* := <get-annos> elem
+
+	add-annos(|new-annos):
+		elem -> out
+		where <is-list> new-annos
+		where <gt> (<length> new-annos,0)
+		with (
+			if <?[i]> new-annos
+			then 
+				// we are at the last item
+				out := <add-anno(|<last> new-annos)> elem
+			else
+				// we still have items to go
+				<?[i,ii*]> new-annos;
+				out := <add-annos(|ii*)> <add-anno(|i)> elem
+			end
+		)
+	
+	copy-annos(|copyFrom) =
+		?elem;
+		<get-annos> copyFrom => srcAnnos;
+		if <?[]> srcAnnos
+		then
+			!elem
+		else
+			 !<add-annos(|srcAnnos)> elem
+		end
+			
+	
+	copy-add-annos(|copyFrom,new-annos) :
+		elem -> <copy-annos(|copyFrom); (add-annos(|new-annos) <+ add-anno(|new-annos))> elem
+	
+	// Return given anno if found, fail otherwise
+	get-anno(|anno):
+		elem -> anno
+		where (?_{anno*}; !anno*; fetch-elem(?anno))
+
+	// Return anno for which the strategy succeeds, fail otherwise
+	get-anno(s) = ?_{anno*}; !anno*; fetch-elem(s)
+  
+	// Succeed if no anno matches
+	has-no-anno(s) = not(get-anno(s))
+  
+	// Add annotation if not present, fail otherwise
+	add-new-anno(|anno) =
+		where(has-no-anno(?anno)); add-anno(|anno)
+  
+  remove-all-annos = 
+  	topdown(try(has-annos;rm-annotations))
+  	
+  
\ No newline at end of file

Modified: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/utils/utils.str
==============================================================================
--- spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/utils/utils.str	Wed Jun 15 11:40:53 2011	(r23056)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/utils/utils.str	Wed Jun 15 15:00:34 2011	(r23057)
@@ -1,8 +1,13 @@
 module utils
 
-rules // utilities
-
+imports lib/editor-common.generated
 
+rules /* list utilities */
+	
+	
+	can-be-unique-value-term =
+		not(is-string + is-tuple + is-list + is-real);?c#(_);<?"">c
+	
 	/**
 	* returns a list containing the indices at which the given strategy succeeds
 	* List(a) -> List(Int)
@@ -19,7 +24,6 @@
 	// 
 	get-indices(s|index): [] -> []
 	
- 			
  	/**
  	* returns a sublist consisting of the elements at the given indices
  	* List(a) -> List(a)
@@ -37,13 +41,78 @@
 	at-indices(|indices,curindex):
 		[] -> []
  	
- 	elem-at-index(|index) = elem-at-index(|index,0)
- 	
- 	elem-at-index(|index,pos)=
- 		?[x|xs];
- 		if(<eq> (pos,index)) then
- 			!x
- 		else
- 			<elem-at-index(|index,<inc> pos)> xs
- 		end
- 	
+ 	// FIXME: this is not necessary. we can refactor to use the built in one.
+ 	elem-at-index(|index) = index(|<inc> index)
+
+	/**
+	* Wrapper for foldl to take the starting value as a strategy argument
+	* @param s1: _ -> b
+	* @param s2: (b,a) -> b
+	* @type: List(a) -> b
+	*/
+	foldll(s1,s2):
+		t -> <foldl(s2)> (t,<s1>) 
+	
+	/**
+	* Wrapper for fold-left to simulate left reduce. Fails if the list is empty.
+	*/
+	reducel(s):
+		[e1|xs] -> <foldl(\(a,b) -> (b,a)\;s)> (xs,e1)
+	
+	head = ?[x];!x
+	
+	/**
+	* A wrapper around cartesion product to process a list of lists.
+	*/		
+	// long-cart(s: (a,a) -> a):
+	long-cart(s):
+		[l1,l2] -> <cart(s)> (l1,l2)
+	
+	// long-cart(s: (a,a) -> a):
+	long-cart(s):
+		[l1,l2|xs@[_|_]] -> out
+		where
+			interim := <cart(s)> (l1,l2);
+			out := <long-cart(s)> [interim|xs]
+	
+rules /* tree utilities */
+	
+	// FIXME: this is not necessary. we can use subterm-at(|index) from editor-common
+	argument-at-position(|pos):
+		// _#(args) -> <take(|<inc> pos);last> args
+		_#(args) -> <index(|pos)> args
+
+	positions-of-term(s) = 
+		// first annotate the terms with their path
+		positions-of-term(s|[]);
+		collect-all(where(s);\ _{path} -> path \,conc)
+	
+	positions-of-term(s|path):
+		e at t#(t-args) -> result
+		with
+			t-args' := <add-indices;map(\ (i,e) -> <positions-of-term(s|<conc> (path,[<dec> i]))> e \)> t-args;
+			if(<s> e) then
+				result := t#(t-args'){path}
+			else
+				result := t#(t-args')
+			end
+	
+	terms-at-positions(|positions) = ?tree; <map(\ pos -> <term-at-position(|pos)> tree \)> positions
+	
+	parent-at-position(s|position) = parent-at-position(|position);where(s)
+	
+	parent-at-position(s|position):
+		p -> <parent-at-position(s|position')> p
+		where
+			<parent-at-position(|position)> p;
+			not(s)
+		where
+			// previous position
+			if(<not(?[])> position) then
+				position' := <take(|<dec> <length> position)> position
+			end
+	
+rules /* constructor utilities */
+	arity:
+		_#(a) -> <length> a
+			

From L.C.L.Kats at tudelft.nl  Wed Jun 15 17:59:09 2011
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Wed, 15 Jun 2011 15:59:09 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23058 - in
	spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime:
	services stratego
Message-ID: <20110615155909.656CDCC207@mx4.tudelft.nl>

Author: LennartKats
Date: Wed Jun 15 15:59:09 2011
New Revision: 23058
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23058&sc=1

Log:
cleanup

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoObserver.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoRefactoring.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/SaveAllResourcesPrimitive.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/TextChangePrimitive.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoObserver.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoObserver.java	Wed Jun 15 15:00:34 2011	(r23057)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoObserver.java	Wed Jun 15 15:59:09 2011	(r23058)
@@ -289,8 +289,7 @@
 						break;
 					}
 				} catch (IOException e) {
-					// TODO Auto-generated catch block
-					e.printStackTrace();
+					Environment.logException("Failed to determine debugger status", e);
 				}
 			}
 		}
@@ -328,26 +327,21 @@
 		//  provider : include/stratego-debug-runtime-java.jar
 		//  provider : include/stratego-debug-runtime.jar
 		boolean allowsDebugging = Environment.allowsDebugging(this.descriptor);
-		try {
-			System.out.println(this.descriptor.getLanguage().getName() + " " + allowsDebugging);
-			if (allowsDebugging)
+		
+		if (allowsDebugging)
+		{
+			IPath utilsPath = this.descriptor.getBasePath().append("utils");
+			boolean javajarExists = utilsPath.append("stratego-debug-runtime-java.jar").toFile().exists();
+			boolean jarExists = utilsPath.append("stratego-debug-runtime.jar").toFile().exists();
+			if (!javajarExists || !jarExists)
 			{
-				IPath utilsPath = this.descriptor.getBasePath().append("utils");
-				boolean javajarExists = utilsPath.append("stratego-debug-runtime-java.jar").toFile().exists();
-				boolean jarExists = utilsPath.append("stratego-debug-runtime.jar").toFile().exists();
-				if (!javajarExists || !jarExists)
-				{
-					// one of the required jars does not exist!
-					// make sure the project builds jars instead of ctree's!
-					System.err.println("Debug runtime jars not found! Please rebuild with jars instead of ctree's");
-				} else {
-					jars.add("utils/stratego-debug-runtime-java.jar");
-					jars.add("utils/stratego-debug-runtime.jar");
-				}
+				// one of the required jars does not exist!
+				// make sure the project builds jars instead of ctree's!
+				System.err.println("Debug runtime jars not found! Please rebuild with jars instead of ctree's");
+			} else {
+				jars.add("utils/stratego-debug-runtime-java.jar");
+				jars.add("utils/stratego-debug-runtime.jar");
 			}
-		} catch (BadDescriptorException e) {
-			// TODO Auto-generated catch block
-			e.printStackTrace();
 		}
 		
 		if (!jars.isEmpty()) loadJars(jars);

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoRefactoring.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoRefactoring.java	Wed Jun 15 15:00:34 2011	(r23057)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoRefactoring.java	Wed Jun 15 15:59:09 2011	(r23058)
@@ -216,8 +216,7 @@
 		try {
 			node = InputTermBuilder.getMatchingNode(semanticNodes, node, false);
 		} catch (BadDescriptorException e) {
-			// TODO Auto-generated catch block
-			e.printStackTrace();
+			Environment.logException("Failed to get selection", e);
 		}
 		return node;
 	}

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/SaveAllResourcesPrimitive.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/SaveAllResourcesPrimitive.java	Wed Jun 15 15:00:34 2011	(r23057)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/SaveAllResourcesPrimitive.java	Wed Jun 15 15:59:09 2011	(r23058)
@@ -14,6 +14,7 @@
 import org.spoofax.interpreter.library.AbstractPrimitive;
 import org.spoofax.interpreter.stratego.Strategy;
 import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.strategoxt.imp.runtime.Environment;
 
 /**
  * @author Maartje de Jonge
@@ -44,8 +45,7 @@
 		try {
 			job.join();
 		} catch (InterruptedException e) {
-			// TODO Auto-generated catch block
-			e.printStackTrace();
+			Environment.logException(e);
 		}
 		return job.getResult()==Status.OK_STATUS;
 	}

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/TextChangePrimitive.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/TextChangePrimitive.java	Wed Jun 15 15:00:34 2011	(r23057)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/TextChangePrimitive.java	Wed Jun 15 15:59:09 2011	(r23058)
@@ -64,10 +64,8 @@
 			IStrategoString result = env.getFactory().makeString(newContent);
 			env.setCurrent(result);
 			return true;
-		} 
-		catch (BadLocationException e) {
-			// TODO Auto-generated catch block
-			e.printStackTrace();
+		}  catch (BadLocationException e) {
+			Environment.logException("Text change primitive failed", e);
 			return false;
 		}
 	}
@@ -92,7 +90,6 @@
 				try {
 					doc.replace(position_start, position_end-position_start, text);
 				} catch (BadLocationException e) {
-					// TODO Auto-generated catch block
 					Environment.logException("Bad location of the replaced fragment", e);
 				}
 				return Status.OK_STATUS;

From L.C.L.Kats at tudelft.nl  Wed Jun 15 18:13:35 2011
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Wed, 15 Jun 2011 16:13:35 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23059 -
	spoofax-imp/trunk/org.strategoxt.imp.testing.test/test
Message-ID: <20110615161335.A1901108C05D@mx3.tudelft.nl>

Author: LennartKats
Date: Wed Jun 15 16:13:35 2011
New Revision: 23059
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23059&sc=1

Log:
- parse errors in fragments are only allowed for 'parse fails' tests
- fixed some example test cases

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.testing.test/test/basic-parse-tests.spt
   spoofax-imp/trunk/org.strategoxt.imp.testing.test/test/setup-test.spt

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing.test/test/basic-parse-tests.spt
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing.test/test/basic-parse-tests.spt	Wed Jun 15 15:59:09 2011	(r23058)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing.test/test/basic-parse-tests.spt	Wed Jun 15 16:13:35 2011	(r23059)
@@ -4,14 +4,14 @@
 language TestingTesting
 
 test parsing with AST matching
-  [[ module x entity Y {} ]] => Module(_, _)
+  [[ module x entity Y {} ]] parse to Module(_, _)
     
 test successful parsing
-  [[ module x entity X { a : B } ]] succeeds parsing
+  [[ module x entity X { a : B } ]] parse succeeds
     
 test failed parsing
-  [[ module x entity X { a : } ]] fails parsing
+  [[ module x entity X { a : } ]] parse fails
 
 test parsing with AST in file
-  [[ module x ]] => file ./empty-module.aterm
+  [[ module x ]] parse to file ./empty-module.aterm
   

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing.test/test/setup-test.spt
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing.test/test/setup-test.spt	Wed Jun 15 15:59:09 2011	(r23058)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing.test/test/setup-test.spt	Wed Jun 15 16:13:35 2011	(r23059)
@@ -15,10 +15,10 @@
   [[ entity x { a : x } ]] 1 warnings
 
 test reference resolving
-  [[ entity [[Y]] { y : [[Y]] } ]] resolves #2 to #1
+  [[ entity [[Y]] { y : [[Y]] } ]] resolve #2 to #1
 
 test reference resolving
-  [[ entity Y { y : [[Initial]] } ]] resolves #2
+  [[ entity Y { y : [[Initial]] } ]] resolve #2
 
 setup Footer [[
     entity Z {}

From L.C.L.Kats at tudelft.nl  Wed Jun 15 18:13:52 2011
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Wed, 15 Jun 2011 16:13:52 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23060 - in
	spoofax-imp/trunk/org.strategoxt.imp.testing: . editor
	editor/java/org/strategoxt/imp/testing trans
Message-ID: <20110615161352.ECD957F8044@mx1.tudelft.nl>

Author: LennartKats
Date: Wed Jun 15 16:13:52 2011
New Revision: 23060
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23060&sc=1

Log:
- parse errors in fragments are only allowed for 'parse fails' tests

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.testing/build.generated.xml
   spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Colorer.esv
   spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/FragmentParser.java
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/build.generated.xml
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/build.generated.xml	Wed Jun 15 16:13:35 2011	(r23059)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/build.generated.xml	Wed Jun 15 16:13:52 2011	(r23060)
@@ -7,7 +7,7 @@
         <target name="spoofaximp.default.jar" depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,java.jar,stratego.jar.helper,sdf2imp,refresh"/>
     
         <!-- Initialization -->
-        <available file="${src-gen}/org/strategoxt/imp/testing/strategies/Main.java" property="java.jar.enabled"/>
+        <available file="${build}/org/strategoxt/imp/testing/strategies/Main.class" property="java.jar.enabled"/>
         <condition property="java.jar.import" value="-la org.strategoxt.imp.testing.strategies" else="">
             <isset property="java.jar.enabled"/>
         </condition>
@@ -597,4 +597,4 @@
             <delete file="${include}/${sdfmodule}.def"/>
             <delete dir="${src-gen}/trans"/>
         </target>
-    </project>
+    </project>
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Colorer.esv
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Colorer.esv	Wed Jun 15 16:13:35 2011	(r23059)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Colorer.esv	Wed Jun 15 16:13:52 2011	(r23060)
@@ -6,7 +6,7 @@
   
   _.RegexPattern : darkgreen
   _.AtomLiteral  : darkgreen   
-  _.pattern      : darkblue   
+  //_.pattern      : darkblue   
   _.description  : 0 128 0 bold
   
   //_.Unnumbered : black

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/FragmentParser.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/FragmentParser.java	Wed Jun 15 16:13:35 2011	(r23059)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/FragmentParser.java	Wed Jun 15 16:13:52 2011	(r23060)
@@ -263,12 +263,12 @@
 	
 	private boolean isSuccessExpected(IStrategoTerm fragment) {
 		if (tryGetConstructor(fragment) == OUTPUT_4) return true;
-		IStrategoAppl test = (IStrategoAppl) getParent(getParent(getParent(fragment)));
+		IStrategoAppl test = (IStrategoAppl) getParent(fragment);
 		if (test.getConstructor() == SETUP_3) return true;
 		IStrategoList expectations = listAt(test, test.getSubtermCount() - 1);
 		for (IStrategoTerm expectation : StrategoListIterator.iterable(expectations)) {
 			IStrategoConstructor cons = tryGetConstructor(expectation);
-			if (cons == FAILS_0 || cons == FAILS_PARSING_0)
+			if (/*cons == FAILS_0 ||*/ cons == FAILS_PARSING_0)
 				return false;
 		}
 		return true;

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check.str	Wed Jun 15 16:13:35 2011	(r23059)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check.str	Wed Jun 15 16:13:52 2011	(r23060)
@@ -94,7 +94,7 @@
     ; parsed' := FailsParsing()
 
   check-expectation(|ast, selections, messages) :
-    <not(Fails + FailsParsing)> -> parse-failed
+    <not(FailsParsing)> -> parse-failed
     where
       if !ast => FailsParsing() + !ast => error(_, _) then
         parse-failed := <extract-parse-error>

From L.C.L.Kats at tudelft.nl  Wed Jun 15 18:42:53 2011
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Wed, 15 Jun 2011 16:42:53 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23061 - in
	spoofax-imp/trunk/org.strategoxt.imp.testing: editor syntax trans
Message-ID: <20110615164253.20B2E7F8016@mx1.tudelft.nl>

Author: LennartKats
Date: Wed Jun 15 16:42:52 2011
New Revision: 23061
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23061&sc=1

Log:
fixed testing language completion issues (Spoofax/390)

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Completions.esv
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing.sdf
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check.str
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/spoofax_testing.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Completions.esv
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Completions.esv	Wed Jun 15 16:13:52 2011	(r23060)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Completions.esv	Wed Jun 15 16:42:52 2011	(r23061)
@@ -24,17 +24,8 @@
   completion template : Header =
     "start symbol " <Start>
                                          
-  completion template : TestDecl =
-    "test" " " <description> "\n\t" "[[" <  > "]] succeeds" (blank)
-
-  completion template : TestDecl =
-    "test" " " <description> "\n\t" "[[" <  > "]] fails" (blank)
-    
-  completion template : TestDecl =
-    "test" " " <description> "\n\t" "[[" <  > "]] => file " <path> (blank)
-
-  completion template : TestDecl =
-    "test" " " <description> "\n\t" "[[" <  > "]] => " <pattern> (blank)
+  completion template Header TestDecl Result :
+    "test" " " <description> "\n\t" "[[" <  > "]] " <succeeds:Result> (blank)
     
   completion template : Result = "parse to file " <path>
   completion template : Result = "parse to " <term>
@@ -48,9 +39,9 @@
   completion template : Result = "resolve " <#2> " to  " <#1>
   completion template : Result = "complete " <#1>
   completion template : Result = "complete " <#1> " to " <\"name\">
-  completion template : Result = "build " <builder> "(" <> /*<OptArgument:>*/ ") to " <OptPattern:output>
-  completion template : Result = "refactor " <refactoring> "(" <> ") to " <OptPattern:output>
-  completion template : Result = "run " <builder> "(" <> ") " <OptPattern:to>
+  completion template : Result = "build " <builder> "(" <> /*<OptArgument:>*/ ") to " <output:OptPattern>
+  completion template : Result = "refactor " <refactoring> "(" <> ") to " <output:OptPattern>
+  completion template : Result = "run " <builder> "(" <> ") " <to:OptPattern>
   
 
   completion template : OptArgument = ""

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing.sdf
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing.sdf	Wed Jun 15 16:13:52 2011	(r23060)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing.sdf	Wed Jun 15 16:42:52 2011	(r23061)
@@ -15,7 +15,7 @@
   sorts TestSuite TopSort Test Input Result
   context-free syntax
     Header* TestDecl*   -> TestSuite {cons("testsuite")}
-    ID                  -> TestSuite {cons("EmptyFile"), recover}
+    "COMPLETION" ID     -> TestSuite {cons("CompletionHelper")}
     "testsuite" ID      -> Header {cons("Name"), deprecated("Use 'module' instead")}
     "module" ID         -> Header {cons("Name")}
     "package" ID        -> Header {cons("Package")}

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check.str	Wed Jun 15 16:13:52 2011	(r23060)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check.str	Wed Jun 15 16:42:52 2011	(r23061)
@@ -37,6 +37,9 @@
     TestEmpty(_, d) -> (<id>, "Empty test case")
   
   check-error:
+    CompletionHelper(_) -> (<id>, "Syntax error")
+  
+  check-error:
     Test(_, d, _, expectations) -> (d, $[No observer defined for [<Language>]])
     where
       not(spt-get-observer)

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/spoofax_testing.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/trans/spoofax_testing.str	Wed Jun 15 16:13:52 2011	(r23060)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/spoofax_testing.str	Wed Jun 15 16:42:52 2011	(r23061)
@@ -97,7 +97,7 @@
 strategies
   
   editor-complete:
-    (EmptyFile(_), _, _, path, _) ->
+    (CompletionHelper(_), _, _, path, _) ->
     [[$( module (<base-filename; remove-extension> path) 
        
        language (<spt-get-default-language>)

From M.A.Akhter at student.tudelft.nl  Thu Jun 16 02:59:16 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Thu, 16 Jun 2011 00:59:16 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23062 - in
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans: .
	analyze/esv context context/str unit-tests
Message-ID: <20110616005916.A245F2B808F@mx2.tudelft.nl>

Author: MdAdilAkhter
Date: Thu Jun 16 00:59:14 2011
New Revision: 23062
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23062&sc=1

Log:
* more cross-sub-languages ( e.g. , esv and stratego) consistency checking .

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/analyze/esv/check.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/declare.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/resolve-declarations.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/resolve-symbols.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/str/declare.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/spoofaxlang.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/resolve-symbol.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/analyze/esv/check.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/analyze/esv/check.str	Wed Jun 15 16:42:52 2011	(r23061)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/analyze/esv/check.str	Thu Jun 16 00:59:14 2011	(r23062)
@@ -2,11 +2,11 @@
 
 imports
 	common
-	context/esv/declare	
+	context/-
+	context/esv/-	
+	context/str/-
 imports 
 	utils/debug 
-	context/-
-imports
   include/SpoofaxLang
  
 // TODO: warn about multi-char highlighted brackets
@@ -26,14 +26,19 @@
 
 rules
 	constraint-esv-error:
-    Sort(x) -> (x, $[Unknown sort [x]])
+    Sort(x) -> (x, $[Unknown sort "[x]"])
     where
-      not(<resolve-sdf-sort-declaration> x)
+      require(<resolve-sdf-sort-declaration> x)
   
   constraint-esv-error:
+    Strategy(x) -> (x, $[Unknown strategy "[x]"])
+    where
+      require(<is-declared-stratego> x)
+      
+  constraint-esv-error:
     SemanticProvider(x) -> (x, $[Must be a generated .ctree or .jar file])
     where
-      not(<string-ends-with(|".jar") + string-ends-with(|".ctree")> x)
+      require(<string-ends-with(|".jar") + string-ends-with(|".ctree")> x)
    		
   constraint-esv-error: 
    	LanguageName( name ) -> (name, $[ Multiple declarations of language name. Declared in following packages : [<pp-aterm>packages*]])

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/declare.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/declare.str	Wed Jun 15 16:42:52 2011	(r23061)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/declare.str	Thu Jun 16 00:59:14 2011	(r23062)
@@ -26,8 +26,13 @@
 			)
 		);
 		get-enclosed-modules;
-		map(get-module-declaration);
-		list-loop(declare-internal(declare-global-symbols-main))
+		list-loop(
+			{|GetEnclosingModuleName:
+					declare-current-module-scope;
+					get-module-declaration;
+					declare-internal(declare-global-symbols-main)
+			|}	
+		)
 
 	
 	delcare-module =  

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/resolve-declarations.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/resolve-declarations.str	Wed Jun 15 16:42:52 2011	(r23061)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/resolve-declarations.str	Thu Jun 16 00:59:14 2011	(r23062)
@@ -4,12 +4,8 @@
 	include/SpoofaxLang 
 	lib/editor-common.generated
 imports 
-	context/signatures
-	context/scope-tree
-  context/resolve-symbols
-  context/store-imports
-  context/resolve-annotations
-  context/resolve-types
+	context/-
+	context/str/-
 imports  
   normalize/signatures
 	codegen/compile
@@ -124,3 +120,4 @@
 	where 
 		<bagof-Using>(package-untyped-qname , module-untyped-qname) => lstUsings* 			
 	
+	
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/resolve-symbols.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/resolve-symbols.str	Wed Jun 15 16:42:52 2011	(r23061)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/resolve-symbols.str	Thu Jun 16 00:59:14 2011	(r23062)
@@ -13,7 +13,7 @@
 imports 	 
 	common
 	config 
-	utils/annotations 
+	utils/annotations  
 	utils/path
 	utils/debug
 
@@ -158,18 +158,40 @@
 		)
 
 rules
-		
-	resolve-symbol-declarations-internal(key-resolver,value-resolver,namespace-filter) =
-		key-resolver;
-		filter(namespace-filter);
-		mapconcat(value-resolver)
-	  
-	<+     			 
-		<debug-symboltable>$[SymbolTable| FAIL | resolve-symbol-declarations | Failed to resolve following symbol [<pp-aterm>]]
-		;fail
-		 
-rules
+	//TODO : refactor 
 	
+	resolve-imported-symbol-declarations'(key-resolver,value-resolver , eq): scopes* -> resolved*
+	where
+		if !scopes* => [] then
+			fail
+		else
+			!scopes* => [currentscope|rest*]
+		end
+	where 
+			if !currentscope => Package(_) then 
+				internal_module_qname := <get_internal_module_qtname>currentscope;
+				resolved* := <is-not-empty-list>
+												<resolve-symbol-declarations-internal(
+														key-resolver, 
+														value-resolver,
+														( 
+															//Filter scopes to search in the imported scopes.
+															//In addition, skipping package's intenral scope. 
+															?(currentscope, _ , _) ; not(?(currentscope, internal_module_qname , _));eq
+														)
+												)>
+			else
+				if !currentscope => Module(_) then 
+					resolved* := <is-not-empty-list><resolve-symbol-declarations-internal(key-resolver, value-resolver,?(_ , currentscope , symbol))>symbol
+				end
+			end;
+			where(<debug-symboltable>$[SymbolResolver| Resoving Symbol in Imported Scopes. Result: [<pp-aterm>resolved*]. Found in :[<pp-aterm>currentscope] ])
+		<+
+			resolved* := <resolve-imported-symbol-declarations(key-resolver  , value-resolver)> rest*
+
+							 	
+
+	// Resolving Symbol in the imported scopes
 	resolve-imported-symbol-declarations(key-resolver,value-resolver):
 		(symbol, scopes*) -> resolved*
 		where 
@@ -199,4 +221,16 @@
 			end;
 			where(<debug-symboltable>$[SymbolResolver| Resoving Symbol in Imported Scopes. Result: [<pp-aterm>resolved*]. Found in :[<pp-aterm>currentscope] ])
 		<+
-			resolved* := <resolve-imported-symbol-declarations(key-resolver  , value-resolver)> ( symbol, rest*)
\ No newline at end of file
+			resolved* := <resolve-imported-symbol-declarations(key-resolver  , value-resolver)> ( symbol, rest*)
+
+rules
+	
+	// Internal strategy to resolve symbol using a matcher
+	resolve-symbol-declarations-internal(key-resolver,value-resolver,namespace-filter) =
+		key-resolver;
+		filter(namespace-filter);
+		mapconcat(value-resolver)
+	  
+	<+     			 
+		<debug-symboltable>$[SymbolTable| FAIL | resolve-symbol-declarations | Failed to resolve following symbol [<pp-aterm>]]
+		;fail
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/str/declare.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/str/declare.str	Wed Jun 15 16:42:52 2011	(r23061)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/str/declare.str	Thu Jun 16 00:59:14 2011	(r23062)
@@ -8,21 +8,38 @@
 imports
 	lib/editor-common.generated
 	include/SpoofaxLang
-imports  	
- 	normalize/stratego
 imports	
 	utils/sourcedir
  	utils/debug
  	common 
 	config 
 imports 
+	context/-
+	normalize/-
 	context/str/signature-generator
-	context/- 
 	spoofaxlang  
- 
 
+
+
+rules 
+	is-declared-stratego: x -> <id>
+	where
+		is-string; 
+		(x-signature-name,  _ , _) := <signature-of> x;
+		package-qt-name := <GetEnclosingPackageName>
+	where
+		resolve-symbol-declarations-internal(all-keys-DeclareCookie, 
+																				 bagof-DeclareCookie,
+																				 (?( package-qt-name  , _ , _) ;?(_, _ , (x-signature-name,_,_)) + (?(Globals() ,  _) ; ?(_, (x-signature-name,_,_)))) 
+																				)
+	  ;is-not-empty-list
+	<+
+		GetEnclosingPackageName => Package(untyped-package-qname);
+		GetEnclosingModuleName  => Module(untyped-module-qname);
+		<get-all-usings>( untyped-package-qname , untyped-module-qname) => imported-typedqname*;		
+		<resolve-imported-symbol-declarations'(all-keys-DeclareCookie  , bagof-DeclareCookie, ?(_, _ , (x-signature-name,_,_)))>imported-typedqname*
+		
 rules 
-	
 	getStrDeclaration = 
  		?cookie; 
  		<to-scoped-symbol;resolve-symbol-declarations(all-keys-STRDeclaration, bagof-STRDeclaration);last>cookie 

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/spoofaxlang.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/spoofaxlang.str	Wed Jun 15 16:42:52 2011	(r23061)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/spoofaxlang.str	Thu Jun 16 00:59:14 2011	(r23062)
@@ -64,12 +64,6 @@
       filename := <guarantee-extension(|"aterm")> path;
       result   := ast // we just return the input term
 
-	generate-desugar:
-    (selected, position, ast, path, project-path) -> (filename, result)
-    with
-      filename := <guarantee-extension(|"aterm.sugar")> path;
-      result   := <normalize-all>ast // we just return the input term
-
   run-templatelang-tests:
     (selected, position, ast, path, project-path) -> None()
     with
@@ -77,3 +71,4 @@
       test-templatelang-to-esv;
       test-templatelang-to-stratego;
       test-templatelang-desugar
+	
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/resolve-symbol.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/resolve-symbol.str	Wed Jun 15 16:42:52 2011	(r23061)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/resolve-symbol.str	Thu Jun 16 00:59:14 2011	(r23062)
@@ -83,7 +83,8 @@
 						<debug>$[ Resolve Successful. Test Successful . Resolved Symbol : [<pp-aterm>result]]
 					end	
 			 |}
-			 			
+	
+	
 	// Unit Test to check the resolve symbol is working as expected.	
 	test-resolving-symbol:
 		(selected, position, ast, path, project-path) -> None()

From v.vergu at gmail.com  Thu Jun 16 12:30:58 2011
From: v.vergu at gmail.com (Vlag Vergu)
Date: Thu, 16 Jun 2011 10:30:58 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23063 - in
	spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego:
	editor trans trans/signatures trans/tests trans/to-yuml
Message-ID: <20110616103058.B136ECC200@mx4.tudelft.nl>

Author: VladVergu
Date: Thu Jun 16 10:30:58 2011
New Revision: 23063
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23063&sc=1

Log:
Warn for signature violation for output term (no rule calls)
Depth first search for path between two sorts across declarations. (TODO: BFS search instead)
Generate yUML sort dependencies

Added:
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/to-yuml/
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/to-yuml/to-yuml.str
Modified:
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/editor/Stratego-Sugar-Builders.esv
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/analysis.str
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/signatures/check.str
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/signatures/map.str
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/signatures/pp.str
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/signatures/project.str
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/stratego_sugar.str
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/tests/project-signature-test.str

Modified: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/editor/Stratego-Sugar-Builders.esv
==============================================================================
--- spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/editor/Stratego-Sugar-Builders.esv	Thu Jun 16 00:59:14 2011	(r23062)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/editor/Stratego-Sugar-Builders.esv	Thu Jun 16 10:30:58 2011	(r23063)
@@ -27,8 +27,11 @@
   builder : "Show AST (selection)" =
     generate-aterm (realtime) (meta)(openeditor) (source)
     
- builder : "Show signatures & constraints" =
-     generate-sort-signatures (realtime) (meta)(openeditor) (source)
+ builder : "Show signatures and constraints" =
+    generate-signatures (realtime) (meta)(openeditor) (source)
  
- builder : "Run tests" = run-tests
+ builder : "Generate yUML signatures" = 
+ 		generate-yuml-signatures (realtime) (meta)(openeditor) (source)
+ 
+  builder : "Run tests" = run-tests
  
\ No newline at end of file

Modified: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/analysis.str
==============================================================================
--- spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/analysis.str	Thu Jun 16 00:59:14 2011	(r23062)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/analysis.str	Thu Jun 16 10:30:58 2011	(r23063)
@@ -151,8 +151,10 @@
     if not(NoAnalysis) then
       with(<declare-globals> Import("libstratego-lib"));
       alltd(declare-globals);
-      declare-var-constraints;
-      alltd(resolve-var-constraints)
+      if(not(DisableSortAnalysis)) then
+      	declare-var-constraints;
+      	alltd(resolve-var-constraints)
+      end
     end
 
   declare-globals:

Modified: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/signatures/check.str
==============================================================================
--- spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/signatures/check.str	Thu Jun 16 00:59:14 2011	(r23062)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/signatures/check.str	Thu Jun 16 10:30:58 2011	(r23063)
@@ -134,7 +134,7 @@
 			mapconcat(explode-sort) => decls;
 			// debug(!"7 ");
 			// keep all the declarations that apply
-			filter(\ dec -> <sort-apply> (s',dec) \);
+			filter(\ dec -> <sort-apply-top> (s',dec) \);
 			// debug(!"8 ");
 			?[]
 			// debug(!"9 ")
@@ -172,7 +172,7 @@
 			// associate each of the arguments list with our own arguments
 			map(\ a -> <zip> (args,a) \);
 			// keep only the lists where sort-apply doesn't fail. if it fails replace with empty list (to preserve positions)
-			map(\ tups -> <map(sort-apply <+ ![]);where(get-indices(?[]);?[])> tups \ <+ ![]);
+			map(\ tups -> <map(sort-apply-top <+ ![]);where(get-indices(?[]);?[])> tups \ <+ ![]);
 			// get indices of non-empty lists
 			get-indices(?[_|_]) => overlap-indices;
 			// continue only if non-empty

Modified: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/signatures/map.str
==============================================================================
--- spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/signatures/map.str	Thu Jun 16 00:59:14 2011	(r23062)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/signatures/map.str	Thu Jun 16 10:30:58 2011	(r23063)
@@ -3,7 +3,9 @@
 imports
 	signatures/constructors
 	signatures/project
+	solver/constraints
 	utils/utils
+	utils/annotations
 	libstrc
 
 rules // map signatures to their internal declarations
@@ -73,7 +75,56 @@
 		ConstSig(n,args,srt,_,decl-id) -> ConstSig(n,args,srt,<new-configuration> freevars,decl-id)
 		with
 			freevars := <collect-all(\ Var(a) -> a \,union)> args
+
+
+strategies /* Depth-First-Search search accross Injective signatures for a path between two sorts ! with no arguments ! */
+	
+	/**
+	* Returns the path between from-sort and to-sort if such a path across injective sort declarations exists
+	* given declarations such as:
+	* : ID -> String
+	* : String -> Name
+	* : Name -> QualifiedName
+	* then a search for the path (ID,QualifiedName) will produce the following path:
+	* [ID,STring,Name,QualifiedName]
+	*/
+	DFS-path-search:
+		(from-sort,to-sort) -> res 
+		where
+			// the sorts are ops with no arguments
+			<?_#([])> from-sort;
+			<?_#([])> to-sort
+		where
+			res := <DFS-path-search(|[from-sort])> (from-sort,to-sort)
+
+	// protects against loops by looking back at path
 	
+	DFS-path-search(|path):
+		(from-sort,to-sort) -> out-path
+		where
+			where (from-sort' := <remove-all-annos> from-sort);
+			// get all the declarations, keep only injective ones
+			get-all-sort-declarations;
+			// keep only ones that match the from-sort
+			// next-candidates := <filter(\ ConstSig("",[from-sort],next,CSet([]),_) -> next \)>;
+			filter( where (\ ConstSig("",[f-s],_,CSet([]),_) -> <remove-all-annos;?from-sort'> f-s \));
+			next-candidates := <map(\ ConstSig(_,_,next,_,_) -> next \)>;
+			// if any of the candidates is the to-sort, we have found a path
+			if(<elem(\ (a,b) -> <eq> (<remove-all-annos> a, <remove-all-annos> b) \)> (to-sort,next-candidates)) then
+				out-path := <conc> (path,[to-sort])
+			else
+				// otherwise we recurse
+				// filter any candidates that we have already visited
+				filter(not(\ x -> <elem> (x,path) \));
+				if(?[]) then
+					out-path := []
+				else
+					// find the first shallow path
+					out-path := <fetch-elem(\ new-from-sort -> <DFS-path-search(|<conc> (path,[new-from-sort]))> (new-from-sort,to-sort) \)>
+				end
+			end
+		
+
 rules // store & retrieve sorts
 		
 		store-sort-decl:
@@ -111,8 +162,10 @@
 			decl-id -> <SortSig> decl-id 
 			// decl-id -> <all-keys-DeclaredSort;mapconcat(bagof-DeclaredSort);fetch-elem(?ConstSig(_, _, _, _, decl-id))>
 		
+		get-all-sort-declarations = all-keys-SortSig; mapconcat(bagof-SortSig)
+		
 		get-signatures-for-constructor:
-			c -> <all-keys-SortSig;mapconcat(bagof-SortSig);filter(?ConstSig(c, _, _, _, _))>
+			c -> <get-all-sort-declarations;filter(?ConstSig(c, _, _, _, _))>
 		/* 
 		* get cookie for non-primitive sort (parameterized or not)
 		*/

Modified: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/signatures/pp.str
==============================================================================
--- spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/signatures/pp.str	Thu Jun 16 00:59:14 2011	(r23062)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/signatures/pp.str	Thu Jun 16 10:30:58 2011	(r23063)
@@ -21,7 +21,7 @@
 		where is-string
 		
 	pp-sort-signature:
-		Var(a) -> <RenamedVarCookie;pp-sort-signature-top> a
+		Var(a) -> <try(RenamedVarCookie);pp-sort-signature-top> a
 	
 	pp-sort-signature:
 		_#(t-args) -> $[([<pp-list(pp-sort-signature|", ")> t-args])]

Modified: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/signatures/project.str
==============================================================================
--- spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/signatures/project.str	Thu Jun 16 00:59:14 2011	(r23062)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/signatures/project.str	Thu Jun 16 10:30:58 2011	(r23063)
@@ -49,6 +49,28 @@
 
 rules // sort applications
 	
+	
+	sort-apply-top:
+		(s,t) -> res
+		where not(<?[_|_]> s + <?[_|_]> t)
+		where
+			if(not(res := <sort-apply> (s,t))) then
+				res := t;
+				<?s'#(_)> s;
+				<?t'#(_)> t;
+				(
+				<DFS-path-search;not(?[])> (t'#([]),s'#([])) <+
+				<DFS-path-search;not(?[])> (s'#([]),t'#([]))
+				)
+				
+			end
+	
+	
+	sort-apply-top:
+		(s,t) -> <sort-apply> (s,t)
+		where
+			<?[_|_]> s + <?[_|_]> t
+	
 	/*
 	* rules to implement application of sort signatures
 	* sort-apply: (sig, applyTo) -> resulting sort signature OR fail
@@ -62,13 +84,13 @@
 	// 	(s@[_|_],l) -> <filter(\ s' -> <sort-apply> (s',l) \);not(?[]);flatten-list;make-set> s
 	
 	sort-apply:
-		(s,l@[_|_]) -> <sort-apply> (s',l)
+		(s,l@[_|_]) -> <sort-apply-top> (s',l)
 		where
 			<not(?[_|_])> s;
 			s' := [s]
 	
 	sort-apply:
-		(l@[_|_],s) -> <sort-apply> (l,s')
+		(l@[_|_],s) -> <sort-apply-top> (l,s')
 		where
 			<not(?[_|_])> s;
 			s' := [s]
@@ -95,7 +117,7 @@
 					fatal-err(|"Failed to remove all ExtraConstraints dynamic rules")
 				end;
 				{|ExtraConstraints:
-						if(res := <sort-apply> (s,t)) then
+						if(res := <sort-apply-top> (s,t)) then
 							new-constraints := <ExtraConstraints <+ !CSet([])>
 						else
 							res := []
@@ -128,10 +150,10 @@
 				
 
 	sort-apply:
-		([l],r) -> <sort-apply> (l,r)
+		([l],r) -> <sort-apply-top> (l,r)
 	
 	sort-apply:
-		(l,[r]) -> <sort-apply> (l,r)
+		(l,[r]) -> <sort-apply-top> (l,r)
 	
 	/* rules for primitive applications */
 	
@@ -171,7 +193,7 @@
 	
 	// the sort application for collections propagates inside the sorts collected
 	sort-apply:
-		(List(s),List(k)) -> List(<sort-apply> (s,k))
+		(List(s),List(k)) -> List(<sort-apply-top> (s,k))
 	
 	// // empty lists collect the Nothing sort (which doesn't exist). On application to a List of sort a, the result is a list of sort a
 	// sort-apply:
@@ -196,7 +218,7 @@
 	
 	/* tuples */	
 	sort-apply:
-		(l,r) -> <zip(sort-apply);new-tuple-sort> (args-l,args-r)
+		(l,r) -> <zip(sort-apply-top);new-tuple-sort> (args-l,args-r)
 		where
 			<is-sort-tuple> l;
 			<is-sort-tuple> r;
@@ -213,7 +235,7 @@
 	sort-apply:
 		(s,t at Var(v)) -> t
 		where
-			res := <sort-apply> (s,<sort-any>);
+			res := <sort-apply-top> (s,<sort-any>);
 			if(constraints := <ExtraConstraints> ) then
 				rules (
 					ExtraConstraints: _ -> ISection(constraints,CSet([Constraint(v,s)]))
@@ -227,7 +249,7 @@
 	/* rules for user-declared sorts */
 	
 	sort-apply:
-		(s,t) -> c#(<zip(sort-apply)> (p,p'))
+		(s,t) -> c#(<zip(sort-apply-top)> (p,p'))
 		where not(
 			<is-sort-prim> s +
 			<is-sort-prim> t +
@@ -240,7 +262,7 @@
 			?c#(p')
 	
 	sort-apply:
-		(l at s#(la),r at s#(ra)) -> <sort-apply> (l',r')
+		(l at s#(la),r at s#(ra)) -> <sort-apply-top> (l',r')
 		where not(
 			<is-sort-prim> l +
 			<is-sort-prim> r +

Modified: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/stratego_sugar.str
==============================================================================
--- spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/stratego_sugar.str	Thu Jun 16 00:59:14 2011	(r23062)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/stratego_sugar.str	Thu Jun 16 10:30:58 2011	(r23063)
@@ -21,6 +21,7 @@
 	rules/check
 	utils/utils
 	tests/test-all
+	to-yuml/to-yuml
 	
 strategies
 
@@ -146,9 +147,10 @@
     with
       filename := <guarantee-extension(|"sig.aterm")> path;
       if(not(DisableSortAnalysis)) then
-	      all-keys-DeclaredSort;
-	      mapconcat(bagof-DeclaredSort);
-	      mapconcat(bagof-SortSig) => signatures;
+	      // all-keys-DeclaredSort;
+	      // mapconcat(bagof-DeclaredSort);
+	      // mapconcat(bagof-SortSig) => signatures;
+	      get-all-sort-declarations => signatures;
 	      all-keys-SortCookie => cookies;
 	      all-keys-DeclaredRule;
 	      mapconcat(bagof-DeclaredRule);
@@ -160,5 +162,15 @@
       
   run-tests = test-all
   	
-
+	generate-yuml-signatures:
+		(selected, _, _, path, _)  -> (filename,result)
+		with
+			filename := <guarantee-extension(|"yuml")> path;
+			<DecoratedAst> selected;
+			if(DisableSortAnalysis) then
+				result := "Sort analysis is required to generate yUML diagrams. It is currently disabled"
+			else
+				result := <generate-all-yuml>
+			end
+			 
 

Modified: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/tests/project-signature-test.str
==============================================================================
--- spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/tests/project-signature-test.str	Thu Jun 16 00:59:14 2011	(r23062)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/tests/project-signature-test.str	Thu Jun 16 10:30:58 2011	(r23063)
@@ -64,4 +64,25 @@
 			sig2 := ConstSig("A",[],"A"#([]),CSet([]),1235);
 			<store-sort-decl> sig2;
 			<not(sort-apply)> ("A"#([]),"A"#([String(),Int()]))
-		|}
\ No newline at end of file
+		|}
+		
+	test-bfs-path-search-1 =
+		{| DeclaredSort,SortSig,SortCookie:
+	  	<store-sort-decl> ConstSig("ClassType", [String(){2201525}], "ClassType"#([]){2201527}, CSet([]), 2201524);
+	  	<store-sort-decl> ConstSig("Reference", ["ClassName"#([]){2201530}], "Reference"#([]){2201531}, CSet([]), 2201529);
+		  <store-sort-decl> ConstSig("", ["QualifiedName"#([]){2201533}], "ClassName"#([]){2201530}, CSet([]), 2201532);
+		  <store-sort-decl> ConstSig("", [String(){2201525}], "QualifiedName"#([]){2201533}, CSet([]), 2201534);
+		  <store-sort-decl> ConstSig("", [String(){2201525}], "Hello"#([]){2201536}, CSet([]), 2201535);
+		  <store-sort-decl> ConstSig("", ["Hello"#([]){2201536}], "World"#([]){2201538}, CSet([]), 2201537);
+		  <store-sort-decl> ConstSig("", [String(){2201525}], "FourtyTwo"#([]){2201540}, CSet([]), 2201539);
+		  <store-sort-decl> ConstSig("", ["FourtyTwo"#([]){2201540}], "TheAnswer"#([]){2201542}, CSet([]), 2201541);
+		  <store-sort-decl> ConstSig("", ["TheAnswer"#([]){2201542}], "ClassName"#([]){2201530}, CSet([]), 2201543);
+		  // <store-sort-decl> ConstSig("", [], "QualifiedName"#([]){2201533}, CSet([]), 2201546);
+		  // <store-sort-decl> ConstSig("", [], "Hello"#([]){2201536}, CSet([]), 2201547);
+		  // <store-sort-decl> ConstSig("", [String(){2201525}], "World"#([]){2201538}, CSet([]), 2201548);
+		  // <store-sort-decl> ConstSig("", [], "FourtyTwo"#([]){2201540}, CSet([]), 2201549);
+		  // <store-sort-decl> ConstSig("", [String(){2201525}], "TheAnswer"#([]){2201542}, CSet([]), 2201550);
+		  // <store-sort-decl> ConstSig("", ["FourtyTwo"#([]){2201540}], "ClassName"#([]){2201530}, CSet([]), 2201551);
+		  debug(!"SEARCHING ");
+	  	<DFS-path-search> (String(),"ClassName"#([]))
+	  |}
\ No newline at end of file

Added: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/to-yuml/to-yuml.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/to-yuml/to-yuml.str	Thu Jun 16 10:30:58 2011	(r23063)
@@ -0,0 +1,30 @@
+module to-yuml
+
+imports
+	signatures/constructors
+	signatures/map
+	signatures/pp
+	utils/annotations
+	
+strategies
+	
+	generate-all-yuml =
+		get-all-sort-declarations;
+		remove-all-annos;
+		mapconcat(sig-to-yuml);
+		pp-list(|"\r")
+
+rules
+	sig-to-yuml:
+		ConstSig(cons, args, out-sort, _, _) -> result
+		with
+			<map(\ a -> (out-sort,a) \)> args;
+			result := <map(to-yuml-line(|cons))>
+	
+	to-yuml-line(|label):
+		(from,to) -> out
+		with
+			out := <concat-strings> ["[",$[ [<pp-sort-signature> from] ],"]-",label,">","[",$[ [<pp-sort-signature;debug(!"TO DONE ")> to] ],"]"]
+			
+			
+			
\ No newline at end of file

From m.dejonge at tudelft.nl  Fri Jun 17 00:19:14 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Thu, 16 Jun 2011 22:19:14 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23064 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring
Message-ID: <20110616221914.D4602CC17D@mx4.tudelft.nl>

Author: MaartjeDeJonge
Date: Thu Jun 16 22:19:14 2011
New Revision: 23064
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23064&sc=1

Log:


Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/fetch.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/fetch.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/fetch.str	Thu Jun 16 10:30:58 2011	(r23063)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/fetch.str	Thu Jun 16 22:19:14 2011	(r23064)
@@ -47,7 +47,7 @@
     where
       <not(match)> term;
       <not(stop)> term;
-      parent-tuple := (<parent-at-position(|term)> ast, <init> position);
+      parent-tuple := (<parent-at-position(|position)> ast, <init> position);
       (term', position') := <fetch-up-with-position(match, stop|ast)> parent-tuple
 
   fetch-up-with-position(match, stop|ast) =

From M.A.Akhter at student.tudelft.nl  Fri Jun 17 01:50:46 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Thu, 16 Jun 2011 23:50:46 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23065 - in
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans:
	codegen editor editor/resolve
Message-ID: <20110616235046.D2E237F808A@mx1.tudelft.nl>

Author: MdAdilAkhter
Date: Thu Jun 16 23:50:45 2011
New Revision: 23065
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23065&sc=1

Log:
editor-resolve v1

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/compile.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/editor/main.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/editor/resolve/imports.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/compile.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/compile.str	Thu Jun 16 22:19:14 2011	(r23064)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/compile.str	Thu Jun 16 23:50:45 2011	(r23065)
@@ -91,7 +91,7 @@
 
 	// compiles all the packages stored at the filepath specified
 	compile-packages-of: file-abs-path -> issues*
-	where
+	where 
 		<debug-compiler>$[Compiling packages of  [<pp-aterm-forced>file-abs-path]]
 	where
 			Enable-Caching;

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/editor/main.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/editor/main.str	Thu Jun 16 22:19:14 2011	(r23064)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/editor/main.str	Thu Jun 16 23:50:45 2011	(r23065)
@@ -2,19 +2,25 @@
 
 imports
 	lib/editor-common.generated
-
-imports 
 	codegen/compile
 imports 
+	common
 	config
 	utils/cache	
 	utils/debug
+	editor/resolve/-
+
 rules
 	// Resolves a reference when the user control-clicks or presses F3 in the editor.
   editor-resolve:
     (node, position, ast, path, project-path) -> elem
-    where 
-    	<id> node => elem
+    where
+    	{| cwd : 
+    			 d := <dirname><concat-strings>[project-path , "/", path]
+    			;rules(cwd  := d)
+    			;<resolve> node => elem	
+    	|} 
+    	
     		 
     	
   // Returns "hover help" information for a particular node in the editor.
@@ -34,13 +40,11 @@
  	editor-analyze: 
  		(ast, path, project-path) -> (ast, errors, warnings, infos) // TODO : ast -> get the analyzed AST 
     with 
-			editor-init
-		with
-			rules(ProjectPath := project-path)
+			 editor-init
+			;rules(ProjectPath := project-path)
 			;initialize-configuration
-			 
-		with 
-			abs-path := <concat-strings;string-replace(|"\\", "/")>[project-path, "/" ,path]  
+			;abs-path := <concat-strings;string-replace(|"\\", "/")>[project-path, "/" ,path]
+			;<debug>$[Compiling abs-path : [<pp-aterm>abs-path]]    
 		with 
 			<cache-currently-analyzing-ast>(abs-path  , ast)	 
 		with 

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/editor/resolve/imports.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/editor/resolve/imports.str	Thu Jun 16 22:19:14 2011	(r23064)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/editor/resolve/imports.str	Thu Jun 16 23:50:45 2011	(r23065)
@@ -1,7 +1,29 @@
 module editor/resolve/imports
-	
-	
+
+imports
+	common	
+	context/-
+	normalize/-
+	editor/main
+	utils/path
+	include/SpoofaxLang
 rules 
 	
+	resolve : ImportLegacyArtifact(Name(m at modulename)) -> r
+	with 
+		resolved-path := <resolve-legacy-import-path(|<cwd>)>modulename;
+	  if !resolved-path => 	Unresolved() then 
+	 		fail
+	 	else
+	 		r := <parse-legacy-artifact>resolved-path	
+	 	end		
+	 	
 	// resolves imports 
-		
\ No newline at end of file
+	resolve = 
+		where(
+			not(?ImportLegacyArtifact(_))
+		);
+		debug(!"Todo : Editor resolve: "); 
+		fail
+	
+ 
\ No newline at end of file

From M.A.Akhter at student.tudelft.nl  Fri Jun 17 02:34:48 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Fri, 17 Jun 2011 00:34:48 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23066 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/editor/resolve
Message-ID: <20110617003448.DDB532B8057@mx2.tudelft.nl>

Author: MdAdilAkhter
Date: Fri Jun 17 00:34:47 2011
New Revision: 23066
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23066&sc=1

Log:
editor-resolve v(2)

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/editor/resolve/imports.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/editor/resolve/imports.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/editor/resolve/imports.str	Thu Jun 16 23:50:45 2011	(r23065)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/editor/resolve/imports.str	Fri Jun 17 00:34:47 2011	(r23066)
@@ -7,8 +7,21 @@
 	editor/main
 	utils/path
 	include/SpoofaxLang
+	libstratego-lib
+	lib/editor-common.generated
+	
 rules 
 	
+	resolve : 
+		ImportPackage(qname at QName(package-qname-parts*)) -> <parse-file>x
+		with
+			[x|_] := <DeclaredPackage;debug>qname
+	
+	resolve : 
+		ImportPackage(Name(n)) -> <parse-file>x
+		with
+			[x|_] := <DeclaredPackage;debug>QName([n])
+	
 	resolve : ImportLegacyArtifact(Name(m at modulename)) -> r
 	with 
 		resolved-path := <resolve-legacy-import-path(|<cwd>)>modulename;
@@ -21,7 +34,10 @@
 	// resolves imports 
 	resolve = 
 		where(
-			not(?ImportLegacyArtifact(_))
+			not(
+				?ImportLegacyArtifact(_)
+			+ ?ImportPackage(_) 
+			)
 		);
 		debug(!"Todo : Editor resolve: "); 
 		fail

From M.A.Akhter at student.tudelft.nl  Fri Jun 17 03:24:13 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Fri, 17 Jun 2011 01:24:13 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23067 - in
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/editor:
	. resolve
Message-ID: <20110617012413.5822F7F8039@mx1.tudelft.nl>

Author: MdAdilAkhter
Date: Fri Jun 17 01:24:12 2011
New Revision: 23067
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23067&sc=1

Log:


Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/editor/main.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/editor/resolve/imports.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/editor/main.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/editor/main.str	Fri Jun 17 00:34:47 2011	(r23066)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/editor/main.str	Fri Jun 17 01:24:12 2011	(r23067)
@@ -15,11 +15,8 @@
   editor-resolve:
     (node, position, ast, path, project-path) -> elem
     where
-    	{| cwd : 
-    			 d := <dirname><concat-strings>[project-path , "/", path]
-    			;rules(cwd  := d)
-    			;<resolve> node => elem	
-    	|} 
+    	<editor-resolve> node => elem	
+    	 
     	
     		 
     	

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/editor/resolve/imports.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/editor/resolve/imports.str	Fri Jun 17 00:34:47 2011	(r23066)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/editor/resolve/imports.str	Fri Jun 17 01:24:12 2011	(r23067)
@@ -12,27 +12,29 @@
 	
 rules 
 	
-	resolve : 
-		ImportPackage(qname at QName(package-qname-parts*)) -> <parse-file>x
-		with
+	editor-resolve : 
+		(ImportPackage(qname at QName(package-qname-parts*)) , position, ast, path, project-path) -> <parse-file>x
+		where
 			[x|_] := <DeclaredPackage;debug>qname
 	
-	resolve : 
-		ImportPackage(Name(n)) -> <parse-file>x
-		with
+	editor-resolve : 
+		(ImportPackage(Name(n)) , position, ast, path, project-path)  -> <parse-file>x
+		where
 			[x|_] := <DeclaredPackage;debug>QName([n])
 	
-	resolve : ImportLegacyArtifact(Name(m at modulename)) -> r
-	with 
-		resolved-path := <resolve-legacy-import-path(|<cwd>)>modulename;
-	  if !resolved-path => 	Unresolved() then 
-	 		fail
-	 	else
-	 		r := <parse-legacy-artifact>resolved-path	
-	 	end		
-	 	
+	editor-resolve : 
+		(ImportLegacyArtifact(Name(m at modulename)), position, ast, path, project-path)  -> r
+		where
+			cwd := <dirname><concat-strings>[project-path , "/", path];
+			resolved-path := <resolve-legacy-import-path(|cwd)>modulename;
+		  if !resolved-path => 	Unresolved() then 
+		 		fail
+		 	else
+		 		r := <parse-legacy-artifact>resolved-path	
+		 	end		
+		 	
 	// resolves imports 
-	resolve = 
+	editor-resolve = 
 		where(
 			not(
 				?ImportLegacyArtifact(_)

From seba at informatik.uni-marburg.de  Fri Jun 17 07:58:23 2011
From: seba at informatik.uni-marburg.de (Sebastian Erdweg)
Date: Fri, 17 Jun 2011 05:58:23 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23068 - in
	sugarj/trunk: compiler/org/sugarj/driver
	compiler/org/sugarj/driver/caching compiler/org/sugarj/driver/path
	editor/editor/java/org/sugarj/editor
Message-ID: <20110617055823.AD05E2B8006@mx2.tudelft.nl>

Author: SebastianErdweg
Date: Fri Jun 17 05:58:22 2011
New Revision: 23068
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23068&sc=1

Log:
integrated Jonas's fix for issue 7

Deleted:
   sugarj/trunk/compiler/org/sugarj/driver/path/RelativePathBin.java
   sugarj/trunk/compiler/org/sugarj/driver/path/RelativePathCache.java
Modified:
   sugarj/trunk/compiler/org/sugarj/driver/Driver.java
   sugarj/trunk/compiler/org/sugarj/driver/Environment.java
   sugarj/trunk/compiler/org/sugarj/driver/FileCommands.java
   sugarj/trunk/compiler/org/sugarj/driver/JavaCommands.java
   sugarj/trunk/compiler/org/sugarj/driver/ModuleSystemCommands.java
   sugarj/trunk/compiler/org/sugarj/driver/Result.java
   sugarj/trunk/compiler/org/sugarj/driver/SDFCommands.java
   sugarj/trunk/compiler/org/sugarj/driver/STRCommands.java
   sugarj/trunk/compiler/org/sugarj/driver/caching/Cache.java
   sugarj/trunk/compiler/org/sugarj/driver/caching/ModuleKey.java
   sugarj/trunk/compiler/org/sugarj/driver/caching/ModuleKeyCache.java
   sugarj/trunk/compiler/org/sugarj/driver/path/Path.java
   sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParser.java

Modified: sugarj/trunk/compiler/org/sugarj/driver/Driver.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/Driver.java	Fri Jun 17 01:24:12 2011	(r23067)
+++ sugarj/trunk/compiler/org/sugarj/driver/Driver.java	Fri Jun 17 05:58:22 2011	(r23068)
@@ -7,7 +7,6 @@
 import static org.sugarj.driver.ATermCommands.getList;
 import static org.sugarj.driver.ATermCommands.getString;
 import static org.sugarj.driver.ATermCommands.isApplication;
-import static org.sugarj.driver.Environment.bin;
 import static org.sugarj.driver.Environment.sep;
 import static org.sugarj.driver.Log.log;
 
@@ -48,12 +47,11 @@
 import org.strategoxt.lang.StrategoException;
 import org.strategoxt.permissivegrammars.make_permissive;
 import org.strategoxt.tools.tools;
+import org.sugarj.driver.caching.ModuleKey;
 import org.sugarj.driver.caching.ModuleKeyCache;
 import org.sugarj.driver.path.AbsolutePath;
 import org.sugarj.driver.path.Path;
 import org.sugarj.driver.path.RelativePath;
-import org.sugarj.driver.path.RelativePathBin;
-import org.sugarj.driver.path.RelativePathCache;
 import org.sugarj.driver.transformations.extraction.extraction;
 import org.sugarj.stdlib.StdLib;
 
@@ -62,7 +60,7 @@
  */
 public class Driver{
   
-  public final static String CACHE_VERSION = "editor-base-0.13";
+  public final static String CACHE_VERSION = "editor-base-0.14";
   
   private final static int PENDING_TIMEOUT = 120000;
 
@@ -75,6 +73,8 @@
 
   private IProgressMonitor monitor;
   
+  private Environment environment = new Environment();
+  
   private Result driverResult = new Result();
   
   private Path javaOutFile;
@@ -113,36 +113,26 @@
   
   private boolean interrupt = false;
   
-  /**
-   * the next parsing and desugaring uses no cache lookup if skipCache.
-   */
-  private boolean skipCache = false;
-  
   private List<Path> generatedJavaClasses = new ArrayList<Path>();
   
-  
-  
-  static {
-    try {
-      Environment.init();
-      
-      if (Environment.cacheDir != null)
-        FileCommands.createDir(new AbsolutePath(Environment.cacheDir));
+  public Driver(Environment env) {
+    this.environment=env;
+    
+    try {      
+      if (environment.getCacheDir() != null)
+        FileCommands.createDir(new AbsolutePath(environment.getCacheDir()));
       
-      FileCommands.createDir(new AbsolutePath(Environment.bin));
+      FileCommands.createDir(new AbsolutePath(environment.getBin()));
       
-      initializeCaches();
+      initializeCaches(environment);
     } catch (IOException e) {
-      throw new RuntimeException("error while initializin driver", e);
+      throw new RuntimeException("error while initializing driver", e);
     }
     
     allInputFiles = new ArrayList<RelativePath>();
     pendingInputFiles = new ArrayList<Path>();
     currentlyProcessing = new ArrayList<Path>();
-  }
-  
-  
-  
+  }  
   
   
   private static synchronized Result getResult(Path file) {
@@ -184,7 +174,7 @@
     Log.log.log(resultCache.size());
   }
   
-  public static Result compile(RelativePath sourceFile, IProgressMonitor monitor) throws IOException, TokenExpectedException, BadTokenException, ParseException, InvalidParseTableException, SGLRException, InterruptedException {
+  public static Result compile(RelativePath sourceFile, IProgressMonitor monitor, Environment environment) throws IOException, TokenExpectedException, BadTokenException, ParseException, InvalidParseTableException, SGLRException, InterruptedException {
     synchronized (currentlyProcessing) {
       // TODO we need better circular dependency handling
       if (currentlyProcessing.contains(sourceFile))
@@ -196,7 +186,7 @@
     
     try {
       String source = FileCommands.readFileAsString(sourceFile);
-      res = compile(source, sourceFile, monitor);
+      res = compile(source, sourceFile, monitor, environment);
     } finally {
       synchronized (currentlyProcessing) {
         currentlyProcessing.remove(sourceFile);
@@ -208,8 +198,8 @@
     return res;
   }
   
-  public static Result compile(String source, RelativePath sourceFile, IProgressMonitor monitor) throws IOException, TokenExpectedException, BadTokenException, ParseException, InvalidParseTableException, SGLRException, InterruptedException {
-    Driver driver = new Driver();
+  public static Result compile(String source, RelativePath sourceFile, IProgressMonitor monitor, Environment environment) throws IOException, TokenExpectedException, BadTokenException, ParseException, InvalidParseTableException, SGLRException, InterruptedException {
+    Driver driver = new Driver(environment);
     Entry<String, Driver> pending = null;
     
     synchronized (Driver.class) {
@@ -221,7 +211,7 @@
 
       if (pending == null) {
         Result result = getResult(sourceFile);
-        if (result != null && result.isUpToDate(source.hashCode()))
+        if (result != null && result.isUpToDate(source.hashCode(), environment))
           return result;
       }
       
@@ -231,12 +221,13 @@
     
     if (pending != null) {
       waitForPending(sourceFile);
-      return compile(source, sourceFile, monitor);
+      return compile(source, sourceFile, monitor, environment);
     }
     
     try {
       driver.process(source, sourceFile, monitor);
-      storeCaches();
+      if (!Environment.rocache)
+        storeCaches(environment);
     } finally {
         pendingRuns.remove(sourceFile);
         putResult(sourceFile, driver.driverResult.getSugaredSyntaxTree() == null ? null : driver.driverResult);
@@ -265,8 +256,9 @@
       driverResult.setSourceFile(sourceFile, source.hashCode());
       
       if (sourceFile != null) {
-        javaOutFile = new RelativePathBin(FileCommands.dropExtension(sourceFile.getRelativePath()) + ".java");
-        driverResult.setGenerationLog(new RelativePathBin(FileCommands.dropExtension(sourceFile.getRelativePath()) + ".gen"));
+        javaOutFile = environment.new RelativePathBin(FileCommands.dropExtension(sourceFile.getRelativePath()) + ".java");
+        Path genLog= environment.new RelativePathBin(FileCommands.dropExtension(sourceFile.getRelativePath()) + ".gen");
+        driverResult.setGenerationLog(genLog);
         clearGeneratedStuff();
       }
 
@@ -276,9 +268,6 @@
 
       boolean done = false;
       while (!done) {
-        boolean wocache = Environment.wocache;
-        Environment.wocache |= skipCache;
-        
         stepped();
         
         // PARSE the next top-level declaration
@@ -292,9 +281,6 @@
         // DESUGAR the parsed top-level declaration
         IStrategoTerm desugared = currentDesugar(lastSugaredToplevelDecl);
         
-        // reset cache skipping
-        Environment.wocache = wocache;
-        
         stepped();
         
         // PROCESS the assimilated top-level declaration
@@ -306,7 +292,7 @@
       stepped();
             
       // check final grammar and transformation for errors
-      if (!Environment.noChecking) {
+      if (!environment.isNoChecking()) {
         checkCurrentGrammar();
       }
       
@@ -340,11 +326,11 @@
   private void compileGeneratedJavaFile() throws IOException {
     log.beginTask("compilation", "COMPILE the generated java file");
     try {
-      List<String> path = new ArrayList<String>(Environment.includePath);
+      List<String> path = new ArrayList<String>(environment.getIncludePath());
       path.add(StdLib.stdLibDir.getPath());
-      path.add(Environment.bin);
+      path.add(environment.getBin());
       
-      driverResult.compileJava(javaOutFile, new AbsolutePath(bin), path, generatedJavaClasses);
+      driverResult.compileJava(javaOutFile, new AbsolutePath(environment.getBin()), path, generatedJavaClasses);
     } finally {
       log.endTask();
     }
@@ -481,8 +467,8 @@
         // XXX if (currentTransProg != null)
         editorServices = ATermCommands.registerSemanticProvider(editorServices, currentTransProg);
   
-        Path editorServicesFile = new RelativePathBin(relPackageNameSep() + extName + ".serv");
-        Path depFile = new RelativePathBin(relPackageNameSep() + extName + ".dep");
+        Path editorServicesFile = environment.new RelativePathBin(relPackageNameSep() + extName + ".serv");
+        Path depFile = environment.new RelativePathBin(relPackageNameSep() + extName + ".dep");
         FileCommands.createFile(editorServicesFile);
   
         log.log("writing editor services to " + editorServicesFile);
@@ -558,8 +544,8 @@
         String plainContent = Term.asJavaString(ATermCommands.getApplicationSubterm(body, "PlainBody", 0));
         
         String ext = extension == null ? "" : ("." + extension);
-        Path plainFile = new RelativePathBin(relPackageNameSep() + extName + ext);
-        Path depFile = new RelativePathBin(relPackageNameSep() + extName + ".dep");
+        Path plainFile = environment.new RelativePathBin(relPackageNameSep() + extName + ext);
+        Path depFile = environment.new RelativePathBin(relPackageNameSep() + extName + ".dep");
         FileCommands.createFile(plainFile);
   
         log.log("writing plain content to " + plainFile);
@@ -582,10 +568,10 @@
       if (relPackageName == null)
         checkPackageName(toplevelDecl);
       if (javaOutFile == null)
-        javaOutFile = new RelativePathBin(relPackageNameSep() + FileCommands.fileName(driverResult.getSourceFile()) + ".java");
+        javaOutFile = environment.new RelativePathBin(relPackageNameSep() + FileCommands.fileName(driverResult.getSourceFile()) + ".java");
       try {
         if (isApplication(toplevelDecl, "TypeImportDec") || isApplication(toplevelDecl, "TypeImportOnDemandDec")) {
-          if (!Environment.atomicImportParsing)
+          if (!environment.isAtomicImportParsing())
             processImportDec(toplevelDecl);
           else 
             processImportDecs(toplevelDecl);
@@ -634,7 +620,8 @@
   private IStrategoTerm currentParse(String remainingInput, boolean recovery) throws IOException,
       InvalidParseTableException, TokenExpectedException, BadTokenException, SGLRException {
     // recompile the current grammar definition
-    Path currentGrammarTBL = SDFCommands.compile(currentGrammarSDF, currentGrammarModule, driverResult.getFileDependencies(), sdfParser, sdfContext, makePermissiveContext);
+    Path currentGrammarTBL = SDFCommands.compile(currentGrammarSDF, currentGrammarModule, driverResult.getFileDependencies(environment), sdfParser, sdfContext, makePermissiveContext, environment);
+    FileCommands.deleteTempFiles(driverResult.getLastParseTable());
     driverResult.setLastParseTable(currentGrammarTBL);
     ParseTable table = org.strategoxt.imp.runtime.Environment.loadParseTable(currentGrammarTBL.getAbsolutePath());
     
@@ -667,7 +654,8 @@
         "desugaring",
         "DESUGAR the current toplevel declaration.");
     try {
-      currentTransProg = STRCommands.compile(currentTransSTR, "main", driverResult.getFileDependencies(), strParser, strjContext);
+      FileCommands.deleteTempFiles(currentTransProg);
+      currentTransProg = STRCommands.compile(currentTransSTR, "main", driverResult.getFileDependencies(environment), strParser, strjContext, environment);
 
       return STRCommands.assimilate(currentTransProg, term, interp);
     } catch (RuntimeException e) {
@@ -703,7 +691,7 @@
       checkPackageName(toplevelDecl);
       
       if (javaOutFile == null)
-        javaOutFile = new RelativePathBin(relPackageNameSep() + FileCommands.fileName(driverResult.getSourceFile()) + ".java");
+        javaOutFile = environment.new RelativePathBin(relPackageNameSep() + FileCommands.fileName(driverResult.getSourceFile()) + ".java");
       driverResult.generateFile(javaOutFile, SDFCommands.prettyPrintJava(toplevelDecl, interp) + "\n");
     } finally {
       log.endTask();
@@ -780,25 +768,29 @@
       String modulePath = FileCommands.getRelativeModulePath(importModule);
   
       if (!modulePath.startsWith("org/sugarj")) {
-        Path dep = ModuleSystemCommands.searchFile(modulePath, ".dep");
+        Path dep = ModuleSystemCommands.searchFile(modulePath, ".dep", environment);
         Result res = null;
         RelativePath sourceFile = null;
         
         if (dep != null) {
-          res = Result.readDependencyFile(dep);
+          try {
+            res = Result.readDependencyFile(dep, environment);
+          } catch (IOException e) {
+            log.logErr("could not read dependency file " + dep);
+          }
           
           if (res != null && res.getSourceFile() != null)
             sourceFile = res.getSourceFile();
         }
         
         if (sourceFile == null)
-          sourceFile = ModuleSystemCommands.locateSourceFile(modulePath);
+          sourceFile = ModuleSystemCommands.locateSourceFile(modulePath, environment.getSourcePath());
 
-        if (sourceFile != null && (res == null || pendingInputFiles.contains(res.getSourceFile()) || !res.isUpToDate(res.getSourceFile()))) {
+        if (sourceFile != null && (res == null || pendingInputFiles.contains(res.getSourceFile()) || !res.isUpToDate(res.getSourceFile(), environment))) {
           log.log("Need to compile the imported module first ; processing it now.");
           
           try {
-            Result importResult = compile(sourceFile, monitor);
+            Result importResult = compile(sourceFile, monitor, environment);
             if (importResult.hasFailed())
               ATermCommands.setErrorMessage(toplevelDecl, "problems while compiling " + importModule);
           } catch (Exception e) {
@@ -809,10 +801,10 @@
         }
         
         if (dep == null)
-          dep = ModuleSystemCommands.searchFile(modulePath, ".dep");
+          dep = ModuleSystemCommands.searchFile(modulePath, ".dep", environment);
         
         if (dep != null)
-          driverResult.addDependency(dep);
+          driverResult.addDependency(dep, environment);
       }
       
       boolean success = processImport(modulePath, toplevelDecl);
@@ -835,23 +827,24 @@
         importTerm, 
         javaOutFile,
         interp, 
-        driverResult);
+        driverResult,
+        environment);
 
-    Path sdf = ModuleSystemCommands.importSdf(modulePath);
+    Path sdf = ModuleSystemCommands.importSdf(modulePath, environment);
     if (sdf != null) {
       success = true;
       availableSDFImports.add(modulePath);
       buildCompoundSdfModule();
     }
     
-    Path str = ModuleSystemCommands.importStratego(modulePath);
+    Path str = ModuleSystemCommands.importStratego(modulePath, environment);
     if (str != null) {
       success = true;
       availableSTRImports.add(modulePath);
       buildCompoundStrModule();
     }
     
-    success |= ModuleSystemCommands.importEditorServices(modulePath, driverResult);
+    success |= ModuleSystemCommands.importEditorServices(modulePath, driverResult, environment);
     
     return success;
   }
@@ -872,8 +865,8 @@
         
         String decName = Term.asJavaString(dec.getSubterm(0).getSubterm(1).getSubterm(0));
         
-        Path clazz = new RelativePathBin(relPackageNameSep() + decName + ".class");
-        Path dep = new RelativePathBin(relPackageNameSep() + decName + ".dep");
+        Path clazz = environment.new RelativePathBin(relPackageNameSep() + decName + ".class");
+        Path dep = environment.new RelativePathBin(relPackageNameSep() + decName + ".dep");
         
         generatedJavaClasses.add(clazz);
         driverResult.appendToFile(javaOutFile, SDFCommands.prettyPrintJava(dec, interp) + "\n");
@@ -959,10 +952,10 @@
         log.endTask();
       }
       
-      Path sdfExtension = new RelativePathBin(relPackageNameSep() + extName + ".sdf");
-      Path strExtension = new RelativePathBin(relPackageNameSep() + extName + ".str");;
-      Path depFile = new RelativePathBin(relPackageNameSep() + extName + ".dep");;
-      
+      Path sdfExtension = environment.new RelativePathBin(relPackageNameSep() + extName + ".sdf");
+      Path strExtension = environment.new RelativePathBin(relPackageNameSep() + extName + ".str");
+      Path depFile = environment.new RelativePathBin(relPackageNameSep() + extName + ".dep");
+
       FileCommands.delete(sdfExtension);
       FileCommands.delete(strExtension);
 
@@ -976,7 +969,7 @@
             // remove quotes
           nativeModule = nativeModule.substring(1, nativeModule.length() - 1);
           
-        if (FileCommands.exists(ModuleSystemCommands.searchFile(nativeModule, ".sdf"))) {
+        if (FileCommands.exists(ModuleSystemCommands.searchFile(nativeModule, ".sdf", environment))) {
           availableSDFImports.add(nativeModule);
           driverResult.generateFile(
               sdfExtension, 
@@ -985,7 +978,7 @@
               + "imports " + nativeModule);
         }
 
-        if (FileCommands.exists(ModuleSystemCommands.searchFile(nativeModule, ".str"))) {
+        if (FileCommands.exists(ModuleSystemCommands.searchFile(nativeModule, ".str", environment))) {
           availableSTRImports.add(nativeModule);
           driverResult.generateFile(
               strExtension, 
@@ -1061,6 +1054,7 @@
   }
   
   private void buildCompoundSdfModule() throws IOException {
+    FileCommands.deleteTempFiles(currentGrammarSDF);
     currentGrammarSDF = FileCommands.newTempFile("sdf");
     currentGrammarModule = FileCommands.fileName(currentGrammarSDF);
     StringBuilder builder = new StringBuilder();
@@ -1073,6 +1067,7 @@
   }
   
   private void buildCompoundStrModule() throws IOException {
+    FileCommands.deleteTempFiles(currentTransSTR);
     currentTransSTR = FileCommands.newTempFile("str");
     currentTransModule = FileCommands.fileName(currentTransSTR);
     StringBuilder builder = new StringBuilder();
@@ -1088,7 +1083,8 @@
     log.beginTask("checking grammar", "CHECK current grammar");
     
     try {
-      SDFCommands.compile(currentGrammarSDF, currentGrammarModule, driverResult.getFileDependencies(), sdfParser, sdfContext, makePermissiveContext);
+      Path p = SDFCommands.compile(currentGrammarSDF, currentGrammarModule, driverResult.getFileDependencies(environment), sdfParser, sdfContext, makePermissiveContext, environment);
+      FileCommands.deleteTempFiles(p);
     } finally {
       log.endTask();
     }
@@ -1098,7 +1094,8 @@
     log.beginTask("checking transformation", "CHECK current transformation");
     
     try {
-      currentTransProg = STRCommands.compile(currentTransSTR, "main", driverResult.getFileDependencies(), strParser, strjContext);
+      FileCommands.deleteTempFiles(currentTransProg);
+      currentTransProg = STRCommands.compile(currentTransSTR, "main", driverResult.getFileDependencies(environment), strParser, strjContext, environment);
     } finally {
       log.endTask();
     }
@@ -1162,15 +1159,17 @@
    */
   public static void main(String[] args) {
     // log.log("This is the extensible java compiler.");
+    Environment environment = new Environment();
+    
     try {
-      String[] sources = handleOptions(args);
+      String[] sources = handleOptions(args, environment);
 
-      if (Environment.sourcePath.isEmpty())
-        Environment.sourcePath.add(".");
+      if (environment.getSourcePath().isEmpty())
+        environment.getSourcePath().add(".");
       
       for (String source : sources)
       {
-        RelativePath p = ModuleSystemCommands.locateSourceFile(FileCommands.dropExtension(source));
+        RelativePath p = ModuleSystemCommands.locateSourceFile(FileCommands.dropExtension(source), environment.getSourcePath());
         
         allInputFiles.add(p);
         pendingInputFiles.add(p);
@@ -1180,7 +1179,7 @@
       
       for (final RelativePath sourceFile : allInputFiles) {
         monitor.beginTask("compile " + sourceFile, IProgressMonitor.UNKNOWN);
-        Result res = compile(sourceFile, monitor);
+        Result res = compile(sourceFile, monitor, environment);
         if (!DriverCLI.processResultCLI(res, sourceFile, new File(".").getAbsolutePath()))
           throw new RuntimeException("compilation of " + sourceFile + " failed");
       }
@@ -1231,12 +1230,12 @@
    * @throws CLIError
    *         when the command line is not correct
    */
-  private static String[] handleOptions(String[] args) {
+  private static String[] handleOptions(String[] args, Environment environment) {
     Options options = specifyOptions();
 
     try {
       CommandLine line = parseOptions(options, args);
-      return processOptions(options, line);
+      return processOptions(options, line, environment);
     } catch (org.apache.commons.cli.ParseException e) {
       throw new CLIError(e.getMessage(), options);
     }
@@ -1250,7 +1249,7 @@
         false);
   }
   
-  private static String[] processOptions(Options options, CommandLine line) throws org.apache.commons.cli.ParseException {
+  private static String[] processOptions(Options options, CommandLine line, Environment environment) throws org.apache.commons.cli.ParseException {
     if (line.hasOption("help")) {
       // TODO This is not exactly an error ...
       throw new CLIError("help requested", options);
@@ -1276,17 +1275,17 @@
 
     if (line.hasOption("buildpath"))
       for (String path : line.getOptionValue("buildpath").split(Environment.classpathsep))
-        Environment.includePath.add(path);
+        environment.getIncludePath().add(path);
 
     if (line.hasOption("sourcepath"))
       for (String path : line.getOptionValue("sourcepath").split(Environment.classpathsep))
-        Environment.sourcePath.add(path);
+        environment.getSourcePath().add(path);
  
     if (line.hasOption("d"))
-      Environment.bin = line.getOptionValue("d");
+      environment.setBin(line.getOptionValue("d"));
     
     if (line.hasOption("cache"))
-      Environment.cacheDir = line.getOptionValue("cache");
+      environment.setCacheDir(line.getOptionValue("cache"));
 
     if (line.hasOption("read-only-cache"))
       Environment.rocache = true;
@@ -1295,13 +1294,13 @@
       Environment.wocache = true;
     
     if (line.hasOption("gen-java"))
-      Environment.generateJavaFile = true;
+      environment.setGenerateJavaFile(true);
     
     if (line.hasOption("atomic-imports"))
-      Environment.atomicImportParsing = true;
+      environment.setAtomicImportParsing(true);
 
     if (line.hasOption("no-checking"))
-      Environment.noChecking = true;
+      environment.setNoChecking(true);
 
     String[] sources = line.getArgs();
     if (sources.length < 1)
@@ -1418,29 +1417,30 @@
   }
 
   @SuppressWarnings("unchecked")
-  private static synchronized void initializeCaches() throws IOException {
-    if (Environment.cacheDir == null)
+  private static synchronized void initializeCaches(Environment environment) throws IOException {
+    if (environment.getCacheDir() == null)
       return;
     
-    Path cacheVersion = new RelativePathCache("version");
+    Path cacheVersion = environment.new RelativePathCache("version");
     
     if (!cacheVersion.getFile().exists() ||
         !FileCommands.readFileAsString(cacheVersion).equals(CACHE_VERSION)) {
 
-      for (File f : new File(Environment.cacheDir).listFiles())
+      for (File f : new File(environment.getCacheDir()).listFiles())
         f.delete();
       
       FileCommands.writeToFile(cacheVersion, CACHE_VERSION);
     }
     
-    Path sdfCache = new RelativePathCache("sdfCache");
-    Path strCache = new RelativePathCache("strCache");
+    Path sdfCache = environment.new RelativePathCache("sdfCache");
+    Path strCache = environment.new RelativePathCache("strCache");
     
     if (SDFCommands.sdfCache == null && sdfCache != null)
       try {
         log.log("load sdf cache from " + sdfCache);
-          SDFCommands.sdfCache =
-              (ModuleKeyCache<Path>) new ObjectInputStream(new FileInputStream(sdfCache.getFile())).readObject();
+          SDFCommands.sdfCache = reallocate(
+              (ModuleKeyCache<Path>) new ObjectInputStream(new FileInputStream(sdfCache.getFile())).readObject(),
+              environment);
       } 
       catch (Exception e) {
         SDFCommands.sdfCache = new ModuleKeyCache<Path>();
@@ -1452,8 +1452,9 @@
     if (STRCommands.strCache == null && strCache != null)
       try {
         log.log("load str cache from " + strCache);
-        STRCommands.strCache =
-            (ModuleKeyCache<Path>) new ObjectInputStream(new FileInputStream(strCache.getFile())).readObject();
+        STRCommands.strCache = reallocate(
+            (ModuleKeyCache<Path>) new ObjectInputStream(new FileInputStream(strCache.getFile())).readObject(),
+            environment);
       } 
       catch (Exception e) {
         STRCommands.strCache = new ModuleKeyCache<Path>();
@@ -1464,15 +1465,30 @@
   }
 
   
-  private static synchronized void storeCaches() throws IOException {
-    if (Environment.cacheDir == null || Environment.rocache)
+  private static ModuleKeyCache<Path> reallocate(ModuleKeyCache<Path> cache, Environment env) {
+    ModuleKeyCache<Path> res = new ModuleKeyCache<Path>();
+    
+    for (Entry<ModuleKey, Path> e : cache.entrySet()) {
+      Map<Path, Integer> imports = new HashMap<Path, Integer>();
+      for (Entry<Path, Integer> e2 : e.getKey().imports.entrySet())
+        imports.put(Path.reallocate(e2.getKey(), env), e2.getValue());
+      
+      res.put(new ModuleKey(imports, e.getKey().body), Path.reallocate(e.getValue(), env));
+    }
+    
+    return res;
+  }
+
+
+  private static synchronized void storeCaches(Environment environment) throws IOException {
+    if (environment.getCacheDir() == null)
       return;
     
-    Path cacheVersion = new RelativePathCache("version");
+    Path cacheVersion = environment.new RelativePathCache("version");
     FileCommands.writeToFile(cacheVersion, CACHE_VERSION);
     
-    Path sdfCache = new RelativePathCache("sdfCache");
-    Path strCache = new RelativePathCache("strCache");
+    Path sdfCache = environment.new RelativePathCache("sdfCache");
+    Path strCache = environment.new RelativePathCache("strCache");
 
     if (!sdfCache.getFile().exists())
       FileCommands.createFile(sdfCache);
@@ -1561,7 +1577,7 @@
         ois = new ObjectInputStream(new FileInputStream(driverResult.getGenerationLog().getFile()));
         while (true) {
           try {
-            Path p = (Path) ois.readObject();
+            Path p = Path.readPath(ois, environment);
             FileCommands.delete(p);
           } catch (ClassNotFoundException e) { 
           }

Modified: sugarj/trunk/compiler/org/sugarj/driver/Environment.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/Environment.java	Fri Jun 17 01:24:12 2011	(r23067)
+++ sugarj/trunk/compiler/org/sugarj/driver/Environment.java	Fri Jun 17 05:58:22 2011	(r23068)
@@ -3,14 +3,16 @@
 import static org.sugarj.driver.Log.log;
 
 import java.io.File;
-import java.io.IOException;
+import java.io.Serializable;
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
 import java.util.WeakHashMap;
 
 import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.sugarj.driver.path.AbsolutePath;
 import org.sugarj.driver.path.Path;
+import org.sugarj.driver.path.RelativePath;
 import org.sugarj.stdlib.StdLib;
 
 
@@ -19,20 +21,47 @@
  * 
  * @author Sebastian Erdweg <seba at informatik uni-marburg de>
  */
-public class Environment {
+public class Environment implements Serializable {
   
+  private static final long serialVersionUID = -8403625415393122607L;
+
   public static Map<Path, IStrategoTerm> terms = new WeakHashMap<Path, IStrategoTerm>();
   
   public static String sep = "/";
   public static String classpathsep = File.pathSeparator;
+
+  /**
+   * @author Sebastian Erdweg <seba at informatik uni-marburg de>
+   */
+  public class RelativePathBin extends RelativePath {
+    private static final long serialVersionUID = -4418944917032203709L;
+
+    public RelativePathBin(String relativePath) {
+      super(relativePath);
+    }
+    
+    @Override
+    public Path getBasePath() {
+      return new AbsolutePath(bin);
+    }
+  }
   
-  public static String root = ".";
-  
-  public static Set<String> sourcePath = new HashSet<String>();
-  
-  public static String bin = ".";
-  public static String cacheDir = null;
-  
+  /**
+   * @author Sebastian Erdweg <seba at informatik uni-marburg de>
+   */
+  public class RelativePathCache extends RelativePath {
+    private static final long serialVersionUID = -6347244639940662095L;
+
+    public RelativePathCache(String relativePath) {
+      super(relativePath);
+    }
+    
+    @Override
+    public Path getBasePath() {
+      return new AbsolutePath(cacheDir);
+    }
+  }
+
   /*
    * read-only/write-only cache flags.
    */
@@ -40,40 +69,142 @@
   public static boolean wocache = false;
   
   
+  
+  private String cacheDir = null;
+  
+  private String root = ".";
+  
+  private Set<String> sourcePath = new HashSet<String>();
+  
+  private String bin = ".";
+  
+  
+  
   /* 
    * parse all imports simultaneously, i.e., not one after the other
    */
-  public static boolean atomicImportParsing = false;
+  private boolean atomicImportParsing = false;
   
   /*
    * don't check resulting sdf and stratego files after splitting
    */
-  public static boolean noChecking = false;
+  private boolean noChecking = false;
 
-  public static boolean generateJavaFile = false;
+  private boolean generateJavaFile = false;
   
-  public static String trans = "sugarj" + sep + "driver" + sep + "transformations";
-  public static String tmpDir = System.getProperty("java.io.tmpdir");
   
+  private String trans = "sugarj" + sep + "driver" + sep + "transformations";
+  private String tmpDir = System.getProperty("java.io.tmpdir");
   
-  public static Set<String> includePath = new HashSet<String>();
+  private Set<String> includePath = new HashSet<String>();
   
-  public static void init() throws IOException {
+  public Environment() {
     includePath.add(bin);
     includePath.add(StdLib.stdLibDir.getPath());
   }
+  
+  public String getRoot() {
+    return root;
+  }
+
+  public void setRoot(String root) {
+    this.root = root;
+  }
+
+  public Set<String> getSourcePath() {
+    return sourcePath;
+  }
+
+  public void setSourcePath(Set<String> sourcePath) {
+    this.sourcePath = sourcePath;
+  }
+
+  public String getBin() {
+    return bin;
+  }
+
+  public void setBin(String bin) {
+    if (this.bin!=null)
+      includePath.remove(this.bin);
+    this.bin = bin;
+    includePath.add(bin);
+  }
+
+  public String getCacheDir() {
+    return cacheDir;
+  }
+
+  public void setCacheDir(String cacheDir) {
+    this.cacheDir = cacheDir;
+  }
+
+  public boolean isAtomicImportParsing() {
+    return atomicImportParsing;
+  }
+
+  public void setAtomicImportParsing(boolean atomicImportParsing) {
+    this.atomicImportParsing = atomicImportParsing;
+  }
+
+  public boolean isNoChecking() {
+    return noChecking;
+  }
+
+  public void setNoChecking(boolean noChecking) {
+    this.noChecking = noChecking;
+  }
+
+  public boolean isGenerateJavaFile() {
+    return generateJavaFile;
+  }
+
+  public void setGenerateJavaFile(boolean generateJavaFile) {
+    this.generateJavaFile = generateJavaFile;
+  }
+
+  public String getTrans() {
+    return trans;
+  }
+
+  public void setTrans(String trans) {
+    this.trans = trans;
+  }
+
+  public String getTmpDir() {
+    return tmpDir;
+  }
+
+  public void setTmpDir(String tmpDir) {
+    this.tmpDir = tmpDir;
+  }
+
+  public Set<String> getIncludePath() {
+    return includePath;
+  }
+
+  public void setIncludePath(Set<String> includePath) {
+    this.includePath = includePath;
+  }
+
+  public Long getTick() {
+    return tick;
+  }
+
+  public void setTick(Long tick) {
+    this.tick = tick;
+  }
 
-  private static Long tick;
+  private Long tick;
   
-  public static void tick() {
+  public void tick() {
     tick = System.currentTimeMillis();
   }
   
-  public static void tack() {
+  public void tack() {
     tack("");
   }
   
-  public static void tack(String s) {
+  public void tack(String s) {
     log.log(s + " " + (System.currentTimeMillis() - tick) + "ms");
     tick();
   }

Modified: sugarj/trunk/compiler/org/sugarj/driver/FileCommands.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/FileCommands.java	Fri Jun 17 01:24:12 2011	(r23067)
+++ sugarj/trunk/compiler/org/sugarj/driver/FileCommands.java	Fri Jun 17 05:58:22 2011	(r23068)
@@ -25,8 +25,17 @@
  */
 public class FileCommands {
 
-  private final static boolean DO_DELETE = true;
+  public final static boolean DO_DELETE = true;
 
+  public final static String TMP_DIR;
+  static {
+    try {
+      TMP_DIR = File.createTempFile("tmp", "").getParent();
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    }
+  }
+  
   public static Path newTempFile(String suffix) throws IOException {
     File f =
         File.createTempFile(
@@ -34,20 +43,23 @@
             suffix == null || suffix.isEmpty() ? suffix : "." + suffix);
     final Path p = new AbsolutePath(f.getAbsolutePath());
     
-    if (DO_DELETE)
-      Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {
-        @Override
-        public void run() {
-          try {
-            FileCommands.delete(p);
-          } catch (IOException e) {
-          }
-        }
-      }));
-
     return p;
   }
 
+  public static void deleteTempFiles(Path file) throws IOException {
+    if (file == null)
+      return;
+    
+    String parent = file.getFile().getParent();
+    
+    if (parent == null)
+      return;
+    else if (parent.equals(TMP_DIR))
+      delete(file);
+    else 
+      deleteTempFiles(new AbsolutePath(parent));
+  }
+  
   public static void delete(Path file) throws IOException {
     if (file == null)
       return;
@@ -181,17 +193,6 @@
     f.mkdir();
     final Path p = new AbsolutePath(f.getAbsolutePath());
     
-    if (DO_DELETE)
-      Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {
-        @Override
-        public void run() {
-          try {
-            FileCommands.delete(p);
-          } catch (IOException e) {
-          }
-        }
-      }));
-
     return p;
   }
 

Modified: sugarj/trunk/compiler/org/sugarj/driver/JavaCommands.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/JavaCommands.java	Fri Jun 17 01:24:12 2011	(r23067)
+++ sugarj/trunk/compiler/org/sugarj/driver/JavaCommands.java	Fri Jun 17 05:58:22 2011	(r23068)
@@ -56,12 +56,12 @@
    * Runs a compiled java program, linking against  {@code strategoxt.jar},
    * and providing a bunch of parameters. 
    */
-  public static void java(Path dir, String main, String... args) throws IOException {
+  public static void java(Path dir, String main, Collection<String> paths, String... args) throws IOException {
     StringBuilder classpath = new StringBuilder();
     classpath.append(FileCommands.toWindowsPath(dir.getAbsolutePath()));
     classpath.append(Environment.classpathsep);
     
-    for (String path : Environment.includePath)
+    for (String path : paths)
       classpath.append(path).append(Environment.classpathsep);
     
     String[] cmd = new String[args.length + 5];

Modified: sugarj/trunk/compiler/org/sugarj/driver/ModuleSystemCommands.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/ModuleSystemCommands.java	Fri Jun 17 01:24:12 2011	(r23067)
+++ sugarj/trunk/compiler/org/sugarj/driver/ModuleSystemCommands.java	Fri Jun 17 05:58:22 2011	(r23068)
@@ -1,7 +1,6 @@
 package org.sugarj.driver;
 
 import static org.sugarj.driver.ATermCommands.isApplication;
-import static org.sugarj.driver.Environment.includePath;
 import static org.sugarj.driver.Log.log;
 
 import java.io.BufferedReader;
@@ -18,7 +17,6 @@
 import org.sugarj.driver.path.AbsolutePath;
 import org.sugarj.driver.path.Path;
 import org.sugarj.driver.path.RelativePath;
-import org.sugarj.driver.path.RelativePathBin;
 
 /**
  * @author Sebastian Erdweg <seba at informatik uni-marburg de>
@@ -35,8 +33,8 @@
    * @return true iff a class file existed.
    * @throws IOException
    */
-  public static boolean importClass(String modulePath, IStrategoTerm importTerm, Path javaOutFile, HybridInterpreter interp, Result driverResult) throws IOException {
-    RelativePath clazz = searchFile(modulePath, ".class");
+  public static boolean importClass(String modulePath, IStrategoTerm importTerm, Path javaOutFile, HybridInterpreter interp, Result driverResult, Environment environment) throws IOException {
+    RelativePath clazz = searchFile(modulePath, ".class", environment);
     if (clazz == null)
       return false;
     
@@ -59,8 +57,8 @@
    * @return path to new grammar or null if no sdf file existed.
    * @throws IOException 
    */
-  public static RelativePath importSdf(String modulePath) throws IOException {
-    RelativePath sdf = searchFile(modulePath, ".sdf");
+  public static RelativePath importSdf(String modulePath, Environment environment) throws IOException {
+    RelativePath sdf = searchFile(modulePath, ".sdf", environment);
     
     if (sdf == null)
       return null;
@@ -78,8 +76,8 @@
    * @return path to new Stratego module or null of no str file existed
    * @throws IOException 
    */
-  public static RelativePath importStratego(String modulePath) throws IOException {
-    RelativePath str = searchFile(modulePath, ".str");
+  public static RelativePath importStratego(String modulePath, Environment environment) throws IOException {
+    RelativePath str = searchFile(modulePath, ".str", environment);
     
     if (str == null)
       return null;
@@ -95,8 +93,8 @@
    * @return true iff a serv file existed.
    * @throws IOException
    */
-  public static boolean importEditorServices(String modulePath, Result driverResult) throws IOException {
-    RelativePath serv = searchFile(modulePath, ".serv");
+  public static boolean importEditorServices(String modulePath, Result driverResult, Environment environment) throws IOException {
+    RelativePath serv = searchFile(modulePath, ".serv", environment);
     
     if (serv == null)
       return false;
@@ -115,14 +113,14 @@
     }
   }
   
-  public static RelativePath locateSourceFile(String modulePath) {
+  public static RelativePath locateSourceFile(String modulePath, Set<String> sourcePath) {
     if (modulePath.startsWith("org/sugarj"))
       return null;
     
-    RelativePath result = searchFile(modulePath, ".sugj", Environment.sourcePath);
+    RelativePath result = searchFileInSearchPath(modulePath, ".sugj", sourcePath);
     
     if (result == null)
-      result = searchFile(modulePath, ".java", Environment.sourcePath);
+      result = searchFileInSearchPath(modulePath, ".java", sourcePath);
     
     return result;
   }
@@ -151,23 +149,23 @@
    * @param fileExtension including leading "."
    * @return URI or null.
    */
-  public static RelativePath searchFile(String relativePath, String fileExtension) {
-    RelativePath p = searchBinFile(relativePath, fileExtension);
+  public static RelativePath searchFile(String relativePath, String fileExtension, Environment environment) {
+    RelativePath p = searchBinFile(relativePath, fileExtension, environment);
     if (p != null)
       return p;
     
-    return searchFile(relativePath, fileExtension, includePath);
+    return searchFileInSearchPath(relativePath, fileExtension, environment.getIncludePath());
   }
 
-  private static RelativePath searchBinFile(String relativePath, String extension) {
-    RelativePath result = new RelativePathBin(relativePath + extension);
+  private static RelativePath searchBinFile(String relativePath, String extension, Environment environment) {
+    RelativePath result = environment.new RelativePathBin(relativePath + extension);
     if (result.getFile().exists())
       return result;
     
     return null;
   }
   
-  private static RelativePath searchFile(String relativePath, String extension, Set<String> searchPath) {
+  private static RelativePath searchFileInSearchPath(String relativePath, String extension, Set<String> searchPath) {
     for (String base : searchPath) {
       RelativePath p = new RelativePath(new AbsolutePath(base), relativePath + extension);
       if (p.getFile().exists())

Modified: sugarj/trunk/compiler/org/sugarj/driver/Result.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/Result.java	Fri Jun 17 01:24:12 2011	(r23067)
+++ sugarj/trunk/compiler/org/sugarj/driver/Result.java	Fri Jun 17 05:58:22 2011	(r23068)
@@ -38,26 +38,26 @@
 
   private final static Result OUTDATED_RESULT = new Result() {
     @Override
-    public boolean isUpToDate(Path file) {
+    public boolean isUpToDate(Path file, Environment env) {
       return false;
     }
 
     @Override
-    public boolean isUpToDate(int hash) {
+    public boolean isUpToDate(int hash, Environment env) {
       return false;
     }
   };
   
-  void addDependency(Path depFile) throws IOException {
+  void addDependency(Path depFile, Environment env) throws IOException {
     dependencies.put(depFile, FileCommands.fileHash(depFile));
-    allDependentFiles.addAll(readDependencyFile(depFile).getFileDependencies());
+    allDependentFiles.addAll(readDependencyFile(depFile, env).getFileDependencies(env));
   }
   
-  public Collection<Path> getFileDependencies() throws IOException {
+  public Collection<Path> getFileDependencies(Environment env) throws IOException {
     if (allDependentFiles == null) {
       allDependentFiles = new HashSet<Path>(generatedFileHashes.keySet());
       for (Path depFile : dependencies.keySet())
-        allDependentFiles.addAll(readDependencyFile(depFile).getFileDependencies());
+        allDependentFiles.addAll(readDependencyFile(depFile, env).getFileDependencies(env));
     }
     
     return allDependentFiles;
@@ -104,11 +104,11 @@
     return editorServices;
   }
   
-  public boolean isUpToDate(Path inputFile) throws IOException {
-    return isUpToDate(FileCommands.fileHash(inputFile));
+  public boolean isUpToDate(Path inputFile, Environment env) throws IOException {
+    return isUpToDate(FileCommands.fileHash(inputFile), env);
   }
   
-  public boolean isUpToDate(int inputHash) throws IOException {
+  public boolean isUpToDate(int inputHash, Environment env) throws IOException {
     if (inputHash != sourceFileHash)
       return false;
     
@@ -120,8 +120,8 @@
       if (FileCommands.fileHash(entry.getKey()) != entry.getValue())
         return false;
       
-      Result r = Result.readDependencyFile(entry.getKey());
-      if (r == null || !r.isUpToDate(r.getSourceFile()))
+      Result r = Result.readDependencyFile(entry.getKey(), env);
+      if (r == null || !r.isUpToDate(r.getSourceFile(), env))
         return false;
     }
 
@@ -188,7 +188,7 @@
     }
   }
   
-  static Result readDependencyFile(Path dep) throws IOException {
+  static Result readDependencyFile(Path dep, Environment env) throws IOException {
     Result result = new Result();
     result.allDependentFiles = null;
     ObjectInputStream ois = null;
@@ -196,26 +196,26 @@
     try {
       ois = new ObjectInputStream(new FileInputStream(dep.getFile()));
       
-      result.sourceFile = (RelativePath) ois.readObject();
+      result.sourceFile = (RelativePath) Path.readPath(ois, env);
       result.sourceFileHash = ois.readInt();
       
       int numDependencies = ois.readInt();
       for (int i = 0; i < numDependencies; i++) {
-        Path file = (Path) ois.readObject();
+        Path file = Path.readPath(ois, env);
         int hash = ois.readInt();
         result.dependencies.put(file, hash);
       }
       
       int numGeneratedFiles = ois.readInt();
       for (int i = 0; i< numGeneratedFiles; i++) {
-        Path file = (Path) ois.readObject();
+        Path file = Path.readPath(ois, env);
         int hash = ois.readInt();
         result.generatedFileHashes.put(file, hash);
       }
     } catch (FileNotFoundException e) {
       return OUTDATED_RESULT;
     } catch (ClassNotFoundException e) {
-      throw new IllegalStateException(e);
+      throw new IOException(e);
     } catch (Exception e) {
       e.printStackTrace();
       return OUTDATED_RESULT;

Modified: sugarj/trunk/compiler/org/sugarj/driver/SDFCommands.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/SDFCommands.java	Fri Jun 17 01:24:12 2011	(r23067)
+++ sugarj/trunk/compiler/org/sugarj/driver/SDFCommands.java	Fri Jun 17 05:58:22 2011	(r23068)
@@ -1,4 +1,5 @@
 package org.sugarj.driver;
+
 import static org.sugarj.driver.FileCommands.toCygwinPath;
 import static org.sugarj.driver.Log.log;
 
@@ -39,7 +40,6 @@
 import org.sugarj.driver.caching.ModuleKey;
 import org.sugarj.driver.caching.ModuleKeyCache;
 import org.sugarj.driver.path.Path;
-import org.sugarj.driver.path.RelativePathCache;
 import org.sugarj.stdlib.StdLib;
 
 /**
@@ -68,7 +68,7 @@
   
   public static ModuleKeyCache<Path> sdfCache = null;
   
-  private static void packSdf(Path sdf, Path def, Context sdfContext) throws IOException {
+  private static void packSdf(Path sdf, Path def, Context sdfContext, Collection<String> paths) throws IOException {
     
     /*
      * We can include as many paths as we want here, checking the
@@ -87,7 +87,7 @@
       "-I", StdLib.stdLibDir.getPath(),
     }));
     
-    for (String path : Environment.includePath) 
+    for (String path : paths) 
       if (new File(path).isDirectory()){
         cmd.add("-I");
         cmd.add(path);
@@ -139,13 +139,16 @@
   }
 
   private static void normalizeTable(Path def, String module) throws IOException {
-    sdf2Table(def, FileCommands.newTempFile("tbl"), module, true);
+    Path tbl = FileCommands.newTempFile("tbl");
+    sdf2Table(def, tbl, module, true);
+    FileCommands.deleteTempFiles(tbl);
   }
   
-  public static void check(Path sdf, String module, Context sdfContext) throws IOException {
+  public static void check(Path sdf, String module, Context sdfContext, Collection<String> paths) throws IOException {
     Path def = FileCommands.newTempFile("def");
-    packSdf(sdf, def, sdfContext);
+    packSdf(sdf, def, sdfContext, paths);
     normalizeTable(def, module);
+    FileCommands.deleteTempFiles(def);
   }
   
   /**
@@ -157,13 +160,13 @@
    * @throws BadTokenException 
    * @throws TokenExpectedException 
    */
-  public static Path compile(Path sdf, String module, Collection<Path> dependentFiles, JSGLRI sdfParser, Context sdfContext, Context makePermissiveContext) throws IOException,
+  public static Path compile(Path sdf, String module, Collection<Path> dependentFiles, JSGLRI sdfParser, Context sdfContext, Context makePermissiveContext, Environment environment) throws IOException,
       InvalidParseTableException, TokenExpectedException, BadTokenException, SGLRException {
     ModuleKey key = getModuleKeyForGrammar(sdf, module, dependentFiles, sdfParser);
     Path tbl = lookupGrammarInCache(key);
     if (tbl == null) {
-      tbl = generateParseTable(key, sdf, module, sdfContext, makePermissiveContext);
-      cacheParseTable(key, tbl);
+      tbl = generateParseTable(key, sdf, module, sdfContext, makePermissiveContext, environment.getIncludePath());
+      cacheParseTable(key, tbl, environment);
     }
     
     if (tbl != null)
@@ -173,16 +176,19 @@
   }
   
   
-  private static void cacheParseTable(ModuleKey key, Path tbl) throws IOException {
-    if (sdfCache == null || Environment.cacheDir == null)
+  private static void cacheParseTable(ModuleKey key, Path tbl, Environment environment) throws IOException {
+    if (sdfCache == null)
       return;
     
     log.beginTask("Caching", "Cache parse table");
     try {
-      Path cacheTbl = new RelativePathCache(tbl.getFile().getName());
+      Path cacheTbl = environment.new RelativePathCache(tbl.getFile().getName());
       FileCommands.copyFile(tbl, cacheTbl);
-      Path oldTbl = sdfCache.putGet(key, cacheTbl);
-      FileCommands.delete(oldTbl);
+      
+      if (!Environment.rocache) {
+        Path oldTbl = sdfCache.putGet(key, cacheTbl);
+        FileCommands.delete(oldTbl);
+      }
 
       if (CommandExecution.CACHE_INFO)
         log.log("Cache Location: " + cacheTbl);
@@ -199,7 +205,8 @@
     
     log.beginTask("Searching", "Search parse table in cache");
     try {
-      result = sdfCache.get(key);
+      if (!Environment.wocache)
+        result = sdfCache.get(key);
       
       if (result == null || !result.getFile().exists())
         return null;
@@ -239,7 +246,8 @@
                                          Path sdf,
                                          String module,
                                          Context sdfContext,
-                                         Context makePermissiveContext)
+                                         Context makePermissiveContext,
+                                         Collection<String> paths)
       throws IOException, InvalidParseTableException {
     log.beginTask("Generating", "Generate the parse table");
     try {
@@ -248,8 +256,9 @@
       tblFile = FileCommands.newTempFile("tbl");
 
       Path def = FileCommands.newTempFile("def");
-      packSdf(sdf, def, sdfContext);
+      packSdf(sdf, def, sdfContext, paths);
       sdf2Table(def, tblFile, module);
+      FileCommands.deleteTempFiles(def);
       return tblFile;
     } finally {
       log.endTask();
@@ -263,7 +272,10 @@
     FileCommands.writeToFile(def, sdfToDef(source));
     makePermissive(def, permissiveDef, context);
     
-    return defToSdf(FileCommands.readFileAsString(permissiveDef)); // drop "definition\n"
+    String s = defToSdf(FileCommands.readFileAsString(permissiveDef)); // drop "definition\n"
+    FileCommands.deleteTempFiles(def);
+    FileCommands.deleteTempFiles(permissiveDef);
+    return s;
   }
   
   private static void makePermissive(Path def, Path permissiveDef, Context context) throws IOException {

Modified: sugarj/trunk/compiler/org/sugarj/driver/STRCommands.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/STRCommands.java	Fri Jun 17 01:24:12 2011	(r23067)
+++ sugarj/trunk/compiler/org/sugarj/driver/STRCommands.java	Fri Jun 17 05:58:22 2011	(r23068)
@@ -30,7 +30,6 @@
 import org.sugarj.driver.caching.ModuleKeyCache;
 import org.sugarj.driver.path.Path;
 import org.sugarj.driver.path.RelativePath;
-import org.sugarj.driver.path.RelativePathCache;
 import org.sugarj.stdlib.StdLib;
 
 /**
@@ -50,7 +49,7 @@
   /**
    *  Compiles a {@code *.str} file to a single {@code *.java} file. 
    */
-  private static void strj(Path str, Path java, String main, Context strjContext) throws IOException {
+  private static void strj(Path str, Path java, String main, Context strjContext, Collection<String> paths) throws IOException {
     
     /*
      * We can include as many paths as we want here, checking the
@@ -68,7 +67,7 @@
         "-O", "0"
     }));
     
-    for (String path : Environment.includePath)
+    for (String path : paths)
       if (new File(path).isDirectory()){
         cmd.add("-I");
         cmd.add(path);
@@ -90,13 +89,13 @@
   }
   
   
-  public static Path compile(Path str, String main, Collection<Path> dependentFiles, JSGLRI strParser, Context strjContext) throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, SGLRException {
+  public static Path compile(Path str, String main, Collection<Path> dependentFiles, JSGLRI strParser, Context strjContext, Environment environment) throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, SGLRException {
     ModuleKey key = getModuleKeyForAssimilation(str, main, dependentFiles, strParser);
     Path prog = lookupAssimilationInCache(key);
     
     if (prog == null) {
-      prog = generateAssimilator(key, str, main, strjContext);
-      cacheAssimilator(key, prog);
+      prog = generateAssimilator(key, str, main, strjContext, environment.getIncludePath());
+      cacheAssimilator(key, prog, environment);
     }
     return prog;
   }
@@ -104,22 +103,24 @@
   private static Path generateAssimilator(ModuleKey key,
                                           Path str,
                                           String main,
-                                          Context strjContext) throws IOException {
+                                          Context strjContext,
+                                          Collection<String> paths) throws IOException {
     log.beginTask("Generating", "Generate the assimilator");
     try {
       Path dir = FileCommands.newTempDir();
       FileCommands.createDir(new RelativePath(dir, "sugarj"));
       String javaFilename = FileCommands.fileName(str).replace("-", "_");
       Path java = new RelativePath(dir, "sugarj" + sep + javaFilename + ".java");
-      strj(str, java, main, strjContext);
+      strj(str, java, main, strjContext, paths);
       
-      if (!JavaCommands.javac(java, dir, Environment.includePath))
+      if (!JavaCommands.javac(java, dir, paths))
         throw new RuntimeException("java compilation failed");
         
       Path jarfile = FileCommands.newTempFile("jar");
       JavaCommands.jar(dir, jarfile);
 
-      FileCommands.delete(java);
+      FileCommands.deleteTempFiles(dir);
+      FileCommands.deleteTempFiles(java);
 
       return jarfile;
     } finally {
@@ -127,17 +128,20 @@
     }
   }
     
-  private static void cacheAssimilator(ModuleKey key, Path prog) throws IOException {
-    if (strCache == null || Environment.cacheDir == null)
+  private static void cacheAssimilator(ModuleKey key, Path prog, Environment environment) throws IOException {
+    if (strCache == null)
       return;
     
 
     log.beginTask("Caching", "Cache assimilator");
     try {
-      Path cacheProg = new RelativePathCache(prog.getFile().getName());
+      Path cacheProg = environment.new RelativePathCache(prog.getFile().getName());
       FileCommands.copyFile(prog, cacheProg);
-      Path oldProg = strCache.putGet(key, cacheProg);
-      FileCommands.delete(oldProg);
+      
+      if (!Environment.rocache) {
+        Path oldProg = strCache.putGet(key, cacheProg);
+        FileCommands.delete(oldProg);
+      }
 
       if (CommandExecution.CACHE_INFO)
         log.log("Cache Location: " + cacheProg);
@@ -154,7 +158,8 @@
     
     log.beginTask("Searching", "Search assimilator in cache");
     try {
-      result = strCache.get(key);
+      if (!Environment.wocache)
+        result = strCache.get(key);
       
       if (result == null || !result.getFile().exists())
         return null;

Modified: sugarj/trunk/compiler/org/sugarj/driver/caching/Cache.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/caching/Cache.java	Fri Jun 17 01:24:12 2011	(r23067)
+++ sugarj/trunk/compiler/org/sugarj/driver/caching/Cache.java	Fri Jun 17 05:58:22 2011	(r23068)
@@ -5,8 +5,6 @@
 import java.util.Map.Entry;
 import java.util.Set;
 
-import org.sugarj.driver.Environment;
-
 
 /**
  * @author Sebastian Erdweg <seba at informatik uni-marburg de>
@@ -24,20 +22,15 @@
   }
 
   public void put(K k, V v) {
-    if (!Environment.rocache)
-      cache.put(k, v);
+    cache.put(k, v);
   }
 
   public V get(K k) {
-    if (Environment.wocache)
-      return null;
-    
     return cache.get(k);
   }
   
   public void remove(K k) {
-    if (!Environment.rocache)
-      cache.remove(k);
+    cache.remove(k);
   }
   
   public int size() {

Modified: sugarj/trunk/compiler/org/sugarj/driver/caching/ModuleKey.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/caching/ModuleKey.java	Fri Jun 17 01:24:12 2011	(r23067)
+++ sugarj/trunk/compiler/org/sugarj/driver/caching/ModuleKey.java	Fri Jun 17 05:58:22 2011	(r23068)
@@ -34,6 +34,11 @@
    */
   public ModuleKey() {}
   
+  public ModuleKey(Map<Path, Integer> imports, String body) {
+    this.imports = imports;
+    this.body = body;
+  }
+  
   public ModuleKey(Collection<Path> dependentFiles, IStrategoTerm module) throws IOException {
     this.imports = new HashMap<Path, Integer>();
     

Modified: sugarj/trunk/compiler/org/sugarj/driver/caching/ModuleKeyCache.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/caching/ModuleKeyCache.java	Fri Jun 17 01:24:12 2011	(r23067)
+++ sugarj/trunk/compiler/org/sugarj/driver/caching/ModuleKeyCache.java	Fri Jun 17 05:58:22 2011	(r23068)
@@ -25,7 +25,6 @@
 
   public V get(ModuleKey k) {
     k.doGet();
-    
     return super.get(k);
   }
 }

Modified: sugarj/trunk/compiler/org/sugarj/driver/path/Path.java
==============================================================================
--- sugarj/trunk/compiler/org/sugarj/driver/path/Path.java	Fri Jun 17 01:24:12 2011	(r23067)
+++ sugarj/trunk/compiler/org/sugarj/driver/path/Path.java	Fri Jun 17 05:58:22 2011	(r23068)
@@ -1,8 +1,14 @@
 package org.sugarj.driver.path;
 
 import java.io.File;
+import java.io.IOException;
+import java.io.ObjectInputStream;
 import java.io.Serializable;
 
+import org.sugarj.driver.Environment;
+import org.sugarj.driver.Environment.RelativePathBin;
+import org.sugarj.driver.Environment.RelativePathCache;
+
 /**
  * @author Sebastian Erdweg <seba at informatik uni-marburg de>
  */
@@ -26,4 +32,19 @@
   public boolean equals(Object o) {
     return o instanceof Path && ((Path) o).getAbsolutePath().equals(getAbsolutePath());
   }
+  
+  public static Path readPath(ObjectInputStream ois, Environment env) throws IOException, ClassNotFoundException {
+    Path p = (Path) ois.readObject();
+    return reallocate(p, env);
+  }
+  
+  public static Path reallocate(Path p, Environment env) {
+    if (p instanceof RelativePathBin)
+      return env.new RelativePathBin(((RelativePath) p).getRelativePath());
+    
+    if (p instanceof RelativePathCache)
+      return env.new RelativePathCache(((RelativePath) p).getRelativePath());
+    
+    return p;
+  }
 }

Modified: sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParser.java
==============================================================================
--- sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParser.java	Fri Jun 17 01:24:12 2011	(r23067)
+++ sugarj/trunk/editor/editor/java/org/sugarj/editor/SugarJParser.java	Fri Jun 17 05:58:22 2011	(r23068)
@@ -17,7 +17,6 @@
 import org.spoofax.jsglr.client.KeywordRecognizer;
 import org.spoofax.jsglr.client.ParseTable;
 import org.spoofax.jsglr.client.imploder.IToken;
-import org.spoofax.jsglr.client.imploder.ImploderAttachment;
 import org.spoofax.jsglr.client.imploder.TermTreeFactory;
 import org.spoofax.jsglr.client.imploder.Token;
 import org.spoofax.jsglr.client.imploder.Tokenizer;
@@ -62,16 +61,42 @@
   protected IStrategoTerm doParse(String input, String filename)
       throws TokenExpectedException, BadTokenException, SGLRException, IOException {
     
+    Environment environment = new Environment();
+    
+    Environment.wocache = false;
+
+    assert includePath != null;
+    environment.getIncludePath().addAll(includePath);
+    environment.getIncludePath().add(new StrategoJarAntPropertyProvider().getAntPropertyValue(""));
+    
+    assert sourcePath != null;
+    environment.getSourcePath().addAll(sourcePath);
+    
+    assert projectPath != null;
+    environment.setRoot(projectPath);
+    environment.setBin(outputPath != null ? outputPath : projectPath);
+
+    if (environment.getCacheDir() == null)
+      environment.setCacheDir(projectPath + "/.sugarjcache");
+    
+    environment.setAtomicImportParsing(true);
+    environment.setGenerateJavaFile(true);
+
+    // use this to temporarily deactivate caching
+    // Environment.wocache = true;
+    
+    environment.setNoChecking(true);
+
     result = getResult(filename);
     if (result == null) {
       result = parseFailureResult();
       putResult(filename, result);
     }
 
-    if (result != null && result.isUpToDate(input.hashCode()))
+    if (result != null && result.isUpToDate(input.hashCode(), environment))
       return result.getSugaredSyntaxTree();
     else if (result == null || !(result instanceof PendingResult)) 
-      scheduleParse(input, filename);
+      scheduleParse(input, filename, environment);
         
     Path lastParseTable;
     
@@ -102,7 +127,7 @@
     return result.getSugaredSyntaxTree();
   }
   
-  private synchronized void scheduleParse(final String input, final String filename) {
+  private synchronized void scheduleParse(final String input, final String filename, final Environment environment) {
     final Result oldResult = getResult(filename);
     putResult(filename, new PendingResult(oldResult));
     
@@ -112,7 +137,7 @@
         monitor.beginTask("parse " + projectRelativePath(filename).getRelativePath(), IProgressMonitor.UNKNOWN);
         Result result = null;
         try {
-          result = runParser(input, filename, monitor);
+          result = runParser(input, filename, monitor, environment);
           putResult(filename, result);
         } catch (InterruptedException e) {
           result = null;
@@ -131,31 +156,7 @@
     parseJob.schedule();
   }
   
-  private Result runParser(String input, String filename, IProgressMonitor monitor) throws InterruptedException {
-    Environment.wocache = false;
-
-    assert includePath != null;
-    Environment.includePath.addAll(includePath);
-    Environment.includePath.add(new StrategoJarAntPropertyProvider().getAntPropertyValue(""));
-    
-    assert sourcePath != null;
-    Environment.sourcePath.addAll(sourcePath);
-    
-    assert projectPath != null;
-    Environment.root = projectPath;
-    Environment.bin = outputPath != null ? outputPath : projectPath;
-
-    if (Environment.cacheDir == null)
-      Environment.cacheDir = projectPath + "/.sugarjcache";
-    
-    Environment.atomicImportParsing = true;
-    Environment.generateJavaFile = true;
-
-    // use this to temporarily deactivate caching
-    // Environment.wocache = true;
-    
-    Environment.noChecking = true;
-    
+  private Result runParser(String input, String filename, IProgressMonitor monitor, Environment environment) throws InterruptedException {
     CommandExecution.SILENT_EXECUTION = false;
     CommandExecution.SUB_SILENT_EXECUTION = false;
     CommandExecution.FULL_COMMAND_LINE = true;
@@ -165,7 +166,7 @@
     SugarJConsole.activateConsoleOnce();
     
     try {
-      return Driver.compile(input, projectRelativePath(filename), monitor);
+      return Driver.compile(input, projectRelativePath(filename), monitor, environment);
     } catch (InterruptedException e) {
       throw e;
     } catch (Exception e) {
@@ -229,13 +230,12 @@
   }
   
   private Result parseFailureResult() {
-    IStrategoTerm term = ATermCommands.makeList("SugarCompilationUnit");
     Tokenizer tokenizer = new Tokenizer(" ", " ", new KeywordRecognizer(null) {});
     Token tok = tokenizer.makeToken(0, IToken.TK_UNKNOWN, true);
-    ImploderAttachment.putImploderAttachment(term, true, "SugarCompilationUnit", tok, tok);
+    IStrategoTerm term = ATermCommands.makeList("SugarCompilationUnit", tok);
     
     Result r = new Result() {
-      public boolean isUpToDate(int h) { return false; }
+      public boolean isUpToDate(int h, Environment env) { return false; }
     };
     r.setSugaredSyntaxTree(term);
     return r;

From v.vergu at gmail.com  Fri Jun 17 13:39:08 2011
From: v.vergu at gmail.com (Vlag Vergu)
Date: Fri, 17 Jun 2011 11:39:08 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23069 - in
	spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego:
	. .externalToolBuilders editor
	editor/java/org/strategoxt/imp/editors/stratego lib-ref...
Message-ID: <20110617113908.E18C8108C018@mx3.tudelft.nl>

Author: VladVergu
Date: Fri Jun 17 11:39:08 2011
New Revision: 23069
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23069&sc=1

Log:
squeezed some more messages out the sort checking
added hover for variables in rules
merged upstream changes

Added:
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/lib-refactoring/consistency-preservation.str
      - copied unchanged from r23068, spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/consistency-preservation.str
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/lib-refactoring/generic-rename.str
      - copied unchanged from r23068, spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/generic-rename.str
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/lib-refactoring/namebinding-preservation.str
      - copied unchanged from r23068, spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/namebinding-preservation.str
Deleted:
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/lib-refactoring/language-description.str
Modified:
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/   (props changed)
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/.externalToolBuilders/Stratego-Sugar build.main.xml.launch   (props changed)
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/build.generated.xml   (props changed)
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/editor/Stratego-Sugar-Builders.esv
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/editor/java/org/strategoxt/imp/editors/stratego/StrategoSugarParseController.java   (props changed)
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/lib-refactoring/fetch.str
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/lib-refactoring/files.str
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/analysis.str
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/rename.str
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/rules/check.str
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/rules/map.str
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/rules/project.str
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/solver/constraints.str
   spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/stratego_sugar.str

Modified: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/editor/Stratego-Sugar-Builders.esv
==============================================================================
--- spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/editor/Stratego-Sugar-Builders.esv	Fri Jun 17 05:58:22 2011	(r23068)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/editor/Stratego-Sugar-Builders.esv	Fri Jun 17 11:39:08 2011	(r23069)
@@ -11,15 +11,12 @@
   provider : include/stratego_sugar.jar
 
   observer : editor-analyze
-
-  builder     : "Rename (builder)" = 
-  	rename-builder (source)(meta)
   
-  refactoring Id: "Rename (refactoring)" = 
+  refactoring Id: "Rename" = 
   	rename-refactoring (source)
 
   builder : "Show analysed AST" =
-    generate-analysed-aterm (realtime) (meta) (openeditor) (source)
+    generate-aterm (realtime) (meta) (openeditor) 
 
   builder : "Show desugared AST (selection)" =
     generate-desugared-aterm (realtime) (meta) (openeditor) (source)

Copied: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/lib-refactoring/consistency-preservation.str (from r23068, spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/consistency-preservation.str)
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/lib-refactoring/consistency-preservation.str	Fri Jun 17 11:39:08 2011	(r23069, copy of r23068, spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/consistency-preservation.str)
@@ -0,0 +1,35 @@
+module consistency-preservation
+
+rules
+
+/**
+ * Collects consistency changes by comparing the semantic errors and warnings  
+ * of the (re)analyzed tree before and after transformation
+ * @example input:
+ * ast := <annotate> tree
+ * ast-t := <annotate; transform; re-annotate> tree
+ * collect-constraint-errors = !(<collect-all(constraint-error), conc>, <collect-all(constraint-warning), conc>) 
+ * @param AST -> (errors, warnings)
+ * @type (AST, AST) -> (errors, warnings)
+ */
+introduced-constraint-errors(collect-constraint-errors):
+  (ast, ast-t) -> (introduced-errors, introduced-warnings)
+  where
+    (errors-before, warnings-before) := <collect-constraint-errors; topdown(strip-annos)> ast;
+    (errors-after, warnings-after)   := <collect-constraint-errors; topdown(strip-annos)> ast-t;
+    introduced-errors   := <diff> (errors-after, errors-before); 
+    introduced-warnings := <diff> (warnings-after, warnings-before) //TODO: when equal? 
+
+/**
+ * Collects consistency changes by comparing the semantic errors and warnings  
+ * of the (re)analyzed trees before and after transformation
+ * @param AST -> (errors, warnings)
+ * @type (List(AST), List(AST)) -> (errors, warnings)
+ */	
+introduced-constraint-errors(collect-constraint-errors):
+  (asts, asts-t) -> (introduced-errors, introduced-warnings)
+  where
+    (errors-before, warnings-before) := <map(collect-constraint-errors); unzip; topdown(strip-annos)> asts;
+    (errors-after, warnings-after)   := <map(collect-constraint-errors); unzip; topdown(strip-annos)> asts-t;
+    introduced-errors   := <diff> (errors-after, errors-before); 
+    introduced-warnings := <diff> (warnings-after, warnings-before) //TODO: when equal? 

Modified: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/lib-refactoring/fetch.str
==============================================================================
--- spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/lib-refactoring/fetch.str	Fri Jun 17 05:58:22 2011	(r23068)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/lib-refactoring/fetch.str	Fri Jun 17 11:39:08 2011	(r23069)
@@ -3,7 +3,20 @@
 imports
   lib/editor-common.generated
   
-rules //strategies for fetching subterms in an ast
+rules //strategies for fetching terms in the ast
+
+    /**
+	 * Annotates AST with reference names (analyse),
+	 * and fetches the annotated selected string in the result AST 
+	 * @type (String, T) -> (String{T}, T)
+	 * @param T -> T (or: List(T) -> T)
+	 */
+  annotated-terms(analyse):
+    (selected, ast) -> (ref-name, ast')
+    where
+      ast' := <analyse <+ (![<id>]; analyse; Hd)> ast;
+      ref-name := <fetch-annotated-term(|<fetch-down(is-string)> selected)> ast'
+
   
   fetch-annotated-term(|selected):
   	analysed-ast -> selected-ref
@@ -34,7 +47,7 @@
     where
       <not(match)> term;
       <not(stop)> term;
-      parent-tuple := (<parent-at-position(|term)> ast, <init> position);
+      parent-tuple := (<parent-at-position(|position)> ast, <init> position);
       (term', position') := <fetch-up-with-position(match, stop|ast)> parent-tuple
 
   fetch-up-with-position(match, stop|ast) =

Modified: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/lib-refactoring/files.str
==============================================================================
--- spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/lib-refactoring/files.str	Fri Jun 17 05:58:22 2011	(r23068)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/lib-refactoring/files.str	Fri Jun 17 11:39:08 2011	(r23069)
@@ -1,23 +1,21 @@
 module lib-refactoring/files
 
 imports
-  lib-refactoring/user-interaction
-  
+  lib/editor-common.generated
+
 rules //strategies for collecting files
 
   get-source-asts(parse|extensions, source-dirs) =
     get-source-asts(parse, check-extension(|extensions), elem-of(|source-dirs))
 
   get-source-asts(parse, is-source-file, is-source-dir) =
-  	save-all-resources;
     get-source-files(is-source-file, is-source-dir);
     parse-source-files(parse)
   
   parse-source-files(parse) :
-  	filenames -> asts
+  	filenames -> (asts, parse-failures)
   	where
-      (asts, parse-failures) := <partition(parse)> filenames;
-      <report-parse-failures> parse-failures
+      (asts, parse-failures) := <partition(parse)> filenames
   	
   get-source-files(|extensions, source-dirs) =
     get-source-files(check-extension(|extensions), elem-of(|source-dirs))
@@ -36,7 +34,7 @@
       ![]
     end
 	
-  save-all-resources = where(prim("SSL_EXT_saveresources", ""))
+  //save-all-resources = where(prim("SSL_EXT_saveresources", ""))
   
   check-extension(|ext) =
   	has-extension(|ext)
@@ -47,5 +45,39 @@
   	  <fetch(equal(|ext))> extensions 
   	)
   	
-  elem-of(|source-dirs) =
-  	!(<id>, source-dirs); elem
\ No newline at end of file
+  elem-of(|lst) =
+  	!(<id>, lst); elem
+  	
+  is-spoofax-dir:
+    dir -> dir
+    where 
+  	  spoofax-dirs := ["bin", "editor", "icons", "include", "META-INF", "syntax",
+        "utils", ".cache", ".externalToolBuilders", ".settings", ".svn", "trans"];
+      <map(!$[[<project-path>]/[<id>]]); fetch(equal(|dir))> spoofax-dirs
+
+  get-affected-asts(affected, get-cache-path):
+    fnames -> (affected-asts, unparsable-files)
+    where
+      (collected-asts, unparsable-files) := <partition(get-affected-ast-or-none(affected, get-cache-path))> fnames;
+      affected-asts := <filter(not(equal(|None())))> collected-asts //filter irrelevant
+      
+  get-affected-ast-or-none(affected, get-cache-path) =
+    reject-ast-from-cache(affected, get-cache-path) <+ //cache can not be used to get the AST since origin info is required
+    reject-or-get-ast-from-parsing(affected)
+  
+  reject-ast-from-cache(affected, get-cache-path):
+    fname -> None()
+    where
+  	  cached-ast := <get-cache-path; ReadFromFile> fname;
+  	  <not(affected)> cached-ast
+
+  reject-or-get-ast-from-parsing(affected):
+    fname -> ast
+    where
+  	  parsed-ast := <parse-file> fname;
+  	  if <not(affected)> parsed-ast then
+  	    ast := None()
+  	  else
+  	    ast := parsed-ast
+  	  end
+

Copied: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/lib-refactoring/generic-rename.str (from r23068, spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/generic-rename.str)
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/lib-refactoring/generic-rename.str	Fri Jun 17 11:39:08 2011	(r23069, copy of r23068, spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/generic-rename.str)
@@ -0,0 +1,50 @@
+module generic-rename
+
+imports
+  lib-refactoring/consistency-preservation
+  lib-refactoring/namebinding-preservation
+  
+rules
+	
+apply-rename-refactoring(annotate-names, collect-constraint-errors|oldname, newname):
+  asts-analyzed -> (ast-changes, errors, warnings)
+  where
+  	(ast-changes, errors, warnings) := <apply-rename-refactoring(annotate-names, collect-constraint-errors|[(oldname, newname)])> asts-analyzed
+
+apply-rename-refactoring(annotate-names, collect-constraint-errors|renamings):
+  asts-analyzed -> (ast-changes, errors, warnings)
+  where  
+  	asts-transformed := <topdown(try(apply-rename(|renamings)))> asts-analyzed;
+  	asts-reanalyzed := <annotate-names> asts-transformed;
+    (constraint-errors, warnings) := 
+      <introduced-constraint-errors(collect-constraint-errors)> (asts-analyzed, asts-reanalyzed);
+    binding-violations := 
+      <namebinding-error-messages(is-endangered-name(|renamings))> (asts-transformed, asts-reanalyzed);
+    errors := <conc>(binding-violations, constraint-errors);
+    ast-changes := <get-changed-asts> (asts-analyzed, asts-transformed)
+
+apply-rename(|renamings):
+  trm -> <apply-rename(|old, new) <+ apply-rename(|tail)> trm
+  where
+    <?[(old, new)|tail]> renamings
+
+apply-rename(|old, new): 
+  old -> new{ref} 
+  where 
+  	<?_{ref}> old
+
+is-endangered-name(|renamings):
+  trm -> <is-endangered-name(|old, new) <+ is-endangered-name(|tail)> trm
+  where
+    <?[(old, new)|tail]> renamings  
+	
+is-endangered-name(|old, new) =
+  where(strip-annos; (equal(|old{}) <+ equal(|new{})))
+
+get-changed-asts:
+  (asts-before, asts-after) -> changed-asts
+  where
+    changed-asts := <zip; filter(not(equal))> (
+      <topdown(strip-annos)> asts-before, 
+      <topdown(strip-annos)> asts-after
+    )

Copied: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/lib-refactoring/namebinding-preservation.str (from r23068, spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/namebinding-preservation.str)
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/lib-refactoring/namebinding-preservation.str	Fri Jun 17 11:39:08 2011	(r23069, copy of r23068, spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/namebinding-preservation.str)
@@ -0,0 +1,47 @@
+module namebinding-preservation
+
+rules
+
+/**
+ * Collects name binding violation messages by comparing the name annotations 
+ * in the transformed tree before and after re-analysis.
+ * @example input:
+ * ast-t := <annotate; transform> ast
+ * ast-t-reanalyzed := <annotate; transform; re-annotate> ast
+ * is-name = ?oldname <+ ?newname
+ * @param matches endangered names
+ * @type (Term, Term) -> List((Term, String)) 
+ */
+namebinding-error-messages(is-name):
+  (ast-t, ast-t-reanalyzed) -> violation-messages
+  where
+    violations := <collect-binding-violations(is-name)> (ast-t, ast-t-reanalyzed);
+    violation-messages := <map(mk-binding-violation-message)> violations
+
+collect-binding-violations(is-name):
+  (ast-t, ast-t-reanalyzed) -> violations
+  where
+    old-names  := <collect-all(where(is-name), conc)> ast-t; 
+    new-names  := <collect-all(where(is-name), conc)> ast-t-reanalyzed;
+    violations := <zip; binding-violations> (old-names, new-names)
+	
+binding-violations: 
+  [(x,y)|tl] -> violations
+  where
+    (hd-violations, rest) := <binding-violations(|x,y)> tl;
+    rec-violations := <binding-violations <+ ?[]> rest;
+    violations := <conc> (hd-violations, rec-violations)
+
+binding-violations(|x,y):
+  lst -> (<make-set> violations, remaining)
+  where
+    (violations, remaining) := <
+       filter(not(?(x,y)));
+       partition(is-binding-violation(|x,y))
+    > lst
+
+is-binding-violation(|x,y) =
+  where((?(_,y) <+ ?(x,_)); not(?(x,y)))
+
+mk-binding-violation-message:
+  (name, _) -> (name, <!$[Variabele captures detected for '[<strip-annos> name]']>)
\ No newline at end of file

Modified: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/analysis.str
==============================================================================
--- spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/analysis.str	Fri Jun 17 05:58:22 2011	(r23068)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/analysis.str	Fri Jun 17 11:39:08 2011	(r23069)
@@ -539,8 +539,15 @@
     where
       x' := x{<declare-cookie-of>}
     <+
-      fail // TODO: special exception for higher-order args
-
+      // HACK: a higher-order strategy can be passed as an argument, 
+      // as in s1(s2), where s2 has arguments. We can only check if there
+      // is a strategy called s2, independent of the number of
+      // (strategy/term) arguments to s2.
+      signature-of => sig;
+      all-keys-DeclareCookie;
+      fetch-elem(\key@(x, s*, t*) -> <?sig; !key; DeclareCookie> (x, 0, 0)\);
+      x' := x{<id>}
+  
   declare-bodies:
     Op(x, t*) -> Op(x', t'*)
     where
@@ -740,12 +747,15 @@
       map(!(<id>, "Build symbol in match pattern")) => builds;
       require([])
 
-  constraint-warning:
-    Assign(v @ Var(x), _) -> (x, $[Variable '[x]' may be bound already])
-    where
-      Var(x') := <declaration-of> v;
-      require(<origin-equal(|x)> x')
-
+  constraint-warning: elem -> (x, $[Variable '[x]' may be bound already]) 
+    where v at Var(x) := <get-assign-var> elem; 
+          Var(x') := <declaration-of> v;
+          require(<origin-equal(|x)> x')
+        
+  get-assign-var =
+    ?Assign(<id>, _)
+    <+ ?AM(_, <id>)
+        
   constraint-warning:
     Var(x) -> (x, $[Unparenthesized constructor: use '[x]()' instead])
     where

Modified: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/rename.str
==============================================================================
--- spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/rename.str	Fri Jun 17 05:58:22 2011	(r23068)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/rename.str	Fri Jun 17 11:39:08 2011	(r23069)
@@ -6,171 +6,142 @@
   desugar
   sourcedir
   lib/editor-common.generated
-  lib-refactoring/rename-generic
+  lib-refactoring/generic-rename
   lib-refactoring/files
-  lib-refactoring/language-description
+  lib-refactoring/fetch
 
-rules //rename refactoring, builder
-  
-  rename-builder:
-  (selected, position, ast, path, project-path) -> (filename, resulting-asts)
-  where
-  	resulting-asts := <rename-refactoring; map(Snd)>;
-    filename := <guarantee-extension(|"aterm")> path  
+rules //rename refactoring
 
   rename-refactoring:
-    (selected, position, ast, path, project-path) -> ast-change-tuples
+    (newname, selected, position, ast, path, project-path) -> 
+    (ast-changes, [], <conc> (pre-condition-errors, semantic-errors), warnings)
+    where 
+      (renamings, asts, pre-condition-errors)  := <prepare-renaming> (newname, selected, ast, path);
+      (ast-changes, semantic-errors, warnings) := <apply-rename-refactoring(
+        re-analyse-names, 
+        collect-semantic-issues |
+        renamings
+      )> asts;
+      editor-init //analysis must be redone in case refactoring is canceled
+
+  prepare-renaming:
+    (newname, selected, ast, path) -> (renamings, asts, <conc>(parse-errors, ext-def-errors))
     where
-      init-analysis;
-      save-all-resources;
-      (ref-name, ast') := <get-analysed-terms(analyse-names)> (selected, ast);
-      newname := <dialog-newname(|<get-language-name> path)>;
-      asts := <collect-affected-asts>(ref-name, newname, ast', $[[<project-path>]/[path]]);
-      report-precondition-issues(!asts; precondition-error(|ref-name));
-      ast-change-tuples := <apply-rename-refactoring(
-      	re-analyse-names, 
-      	collect-sem-errors |
-      	<get-renamings> (ref-name, newname)
-      )> asts
-  
-  get-renamings:
-  	r@(refname, newname) -> renamings
-  	where
-  	  <?_{ref}> refname;
+      (name{ref}, ast') := <annotated-terms(analyze-names-ensure-imports)> (selected, ast); 
+      renamings := <get-dependend-renamings> (name{ref}, newname);
+      (asts, unparsable-files) := <collect-affected-asts>(ref, renamings, ast', $[[<project-path>]/[path]]);
+      parse-errors := <map(!$[parsing failed for: '[<id>]'])> unparsable-files;
+      ext-def-errors := <external-declaration-error> ref 
+      
+rules //dependent names
+    
+  get-dependend-renamings:
+    r@(refname, newname) -> renamings
+    where
+      <?_{ref}> refname;
       if <Declaration; ?RDecT(oldname, _, _)> ref then 
-      	old-names := <prefixes-dynrules; map(!$[[<id>]-[oldname]]{ref})>;
-      	new-names := <prefixes-dynrules; map(!$[[<id>]-[newname]])>;
-      	renamings := [(oldname{ref}, newname)|<zip>(old-names, new-names)]
+        old-names := <prefixes-dynrules; map(!$[[<id>]-[oldname]]{ref})>;
+        new-names := <prefixes-dynrules; map(!$[[<id>]-[newname]]{ref})>;
+        renamings := [(oldname{ref}, newname)|<zip>(old-names, new-names)]
       else
-      	renamings := [r]
+        renamings := [r]
       end
 
   prefixes-dynrules =
-  	!["once", "bagof", "bigbagof", "all-keys", "innermost-scope", "break", "break-bp", 
-  	  "continue", "chain", "bigchain", "new", "undefine", "aux", "reverse-bagof", "innermost-scope",
-  	  "break-to-label","continue-to-label", "throw", "fold", "bigfold"]
-
-rules //precondition checks
-
-//TODO: better solution
-//FIXME: no declaration outside asts (lib or generated), since these files are not changed
-//NOW: a declaration in asts exists
-precondition-error(|ref-name):
-	asts -> ([$[Declaration can not be found in [<project-path>]/trans]],[])
-	where
-	  <?_{ref}> ref-name; 
-	  <is-global-ref> ref; 
-	  decl := <Declaration> ref;
-	  decl-cons := <get-constructor> decl;
-	  <not(oncetd(
-	  	if <equal> (<get-constructor>, decl-cons) then 
-	  		topdown(strip-annos) 
-	  	end; 
-	  	equal(|decl)))> asts
-
+    !["once", "bagof", "bigbagof", "all-keys", "innermost-scope", "break", "break-bp", 
+      "continue", "chain", "bigchain", "new", "undefine", "aux", "reverse-bagof", "innermost-scope",
+      "break-to-label","continue-to-label", "throw", "fold", "bigfold"]
+  
 rules //name analysis
     
-  analyse-names:
-  	asts -> <analyse-names-asts> desugared-asts
+  analyze-names-ensure-imports:
+    asts -> <analyze-names> desugared-asts
     where
-       desugared-asts := <map(basic-desugar-top)> asts;
-       <declare-globals> Import("libstratego-lib"); //Import external strategy definitions
-       <map( //Import strategy definitions from files that are not in the list
-           alltd(
-           	 is-not-imported-from-list(|asts);
-             declare-globals
-           )
-       )> desugared-asts
+      rules(CurrentFile := "" ProjectDir  := <project-path>);
+      try(get-source-base-dir);
+      desugared-asts := <map(basic-desugar-top)> asts;
+      <declare-globals> Import("libstratego-lib");
+      <map(alltd(is-not-imported-from-asts(|asts); declare-globals))> desugared-asts
   
-  is-not-imported-from-list(|asts) =
+  is-not-imported-from-asts(|asts) =
     where(?Import(mod) <+ ?ImportWildcard(mod)); 
     where(not(<fetch(?Module(mod, _))> asts))
-  
+    
+  analyze-names:
+    asts -> asts'
+    where
+      asts' := < //re-analyze affected asts
+        map(alltd(where(not(?Import(_) <+ ?ImportWildcard(_))); declare-globals)); //external imports already done 
+        map(declare-bodies-top)
+      > asts
+
   re-analyse-names =
     topdown(strip-annos);
     topdown(try(resugar-Let)); //TODO: better solution?
-    analyse-names-asts
-  
-  analyse-names-asts:
-    asts -> asts'
-    where
-       asts' := < //re-analyze affected asts
-         map(alltd(where(not(?Import(_) <+ ?ImportWildcard(_))); declare-globals)); //external imports already done 
-         map(declare-bodies-top)
-       > asts
+    analyze-names
 
   resugar-Let:
-  	Rec(x, y) -> Let(x,y)
-  	where 
-  	  origin-term; 
-  	  ?Let(_, _)
-
-  init-analysis =
-       rules(
-          CurrentFile := "" //TODO: primitive for file path?
-          ProjectDir  := <project-path>
-       );
-       try(get-source-base-dir)
+    Rec(x, y) -> Let(x,y) where origin-term; ?Let(_, _)
 
 rules //semantic constraint check
 
-  collect-sem-errors = 
-    where (errors :=<collect-all(global-constraint-error + constraint-error, conc)>);
-    where (warnings :=<collect-all(constraint-warning, conc)>);
-    <conc>(errors, warnings);
-    flatten-list
-	
+  collect-semantic-issues:
+    ast -> (errors, warnings)
+    where 
+      errors := <collect-all(global-constraint-error + constraint-error, conc)> ast;
+      warnings := <collect-all(constraint-warning, conc)> ast
+  
 rules //collect asts that are possibly affected by renaming, efficient implementation using cache
-
-//1. do not collect files when selected var is local ##
-//2. for global vars: 
-//2a. keep editor ast to be more robust in case of syntax errors ##
-//2b. collect only the files that are relevant ## 
-//2c. use cache to reject files before analyzing ##
-//2d. parallel with user input dialog
-//2e. (?) collect files in loop instead of by map(parse)?
-//3. re-analyzes: keep lookup tables, no normalization, no external import ##
  
-collect-affected-asts:
-	(oldname{ref}, newname, ast, path-to-ast) -> [ast|<analyse-names> affected-asts]
-	where
-  	  if <is-global-ref> ref then //files are only collected if the selected var is global 
-  	  	//save-all-resources;
-	    fnames := <get-source-files(
-		  has-extension(|"str"); not(equal(|path-to-ast)), //exclude current ast which is obtained from the editor (allowing parse errors) 
-		  not(fail)
-	    )> $[[<project-path>]/trans]; 
-	    (fnames-cache, fnames-no-cache) := <partition-by-cache(|oldname)> fnames;
-	    asts-no-cache := <parse-source-files(parse-file)> fnames-no-cache; //TODO: parallel with rename dialog?!
-	    asts-filtered-no-cache := <filter(
-	    	oncetd(equal(|newname) <+ equal(|<strip-annos> oldname))
-	    )> asts-no-cache;
-	    asts-filtered-cache := <filter(ReadFromFile; oncetd(equal(|newname)))> fnames-cache; 
-	    affected-asts := <conc>(asts-filtered-no-cache, asts-filtered-cache)
+  collect-affected-asts:
+    (ref-anno, renamings, ast, path-to-ast) -> ([ast|<analyze-names-ensure-imports> affected-asts], unparsable-files)
+    where
+      if <is-global-ref> ref-anno then //files are only collected if the selected var is global 
+        fnames := <get-stratego-files; filter(is-editable; not(equal(|path-to-ast)))>; 
+        (affected-asts, unparsable-files) := 
+          <get-affected-asts(oncetd(is-endangered-name(|renamings)), get-cache-path)> fnames
       else
-      	affected-asts := []
+        affected-asts := [];
+        unparsable-files := []
       end
 
-is-global-ref =
-	where(
-		?ref;
-		<Declaration; signature-of; DeclareCookie; equal(|ref)> ref
-	)
-
-partition-by-cache(|refname):
-	fnames -> 
-		<partition(
-			get-cache-path;
-			where(
-				ReadFromFile; 
-				not(oncetd(equal(|<strip-annos> refname))) //exclude files that will change
-			)
-		)> fnames
-		
-	
-get-cache-path: //asts without endangered names can be ignored
-	path -> cache-path
-	where(
-  	  cache-path := <import-cache-path; string-replace(|".str.sig", ".rtree")> path; 
-  	  <is-newer> (cache-path, path)
-  	)
+  is-global-ref =
+    where(?ref; <Declaration; signature-of; DeclareCookie; equal(|ref)> ref)    
+
+  get-stratego-files =
+    project-path;
+    get-source-files(
+      has-extension(|"str"), 
+      not(is-spoofax-dir) <+ equal(|$[[<project-path>]/trans]) <+ equal(|$[[<project-path>]/include])
+    ) 
+
+  is-editable = 
+    not(string-ends-with(|".generated.str"));
+    not(dirname; string-ends-with(|"include"))
+
+  get-cache-path: 
+    path -> cache-path
+    where
+      cache-path := <import-cache-path; string-replace(|".str.sig", ".rtree")> path; 
+      <is-newer> (cache-path, path)
+    
+rules //precondition checks on imported files
+
+  external-declaration-error:
+    ref -> <conc> (generated-file-errors, lib-errors)
+    where 
+      generated-file-errors := <get-stratego-files; filter(declared-in-generated-file(|ref))>; 
+      lib-errors := <![<declared-in-lib>] <+ ![]> ref
+
+  declared-in-generated-file(|ref):
+    fname -> $[Name in [<base-filename>] can not be edited]
+    where
+  	  not(is-editable);
+      (((import-cache-path <+ get-cache-path); ReadFromFile) <+ parse-file);
+      declare-globals-top; 
+      oncetd(?_{ref})
+
+  declared-in-lib:
+    ref -> $[External declaration can not be edited]
+    where
+      <Declaration; get-constructor; string-starts-with(|"Ext")> ref
\ No newline at end of file

Modified: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/rules/check.str
==============================================================================
--- spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/rules/check.str	Fri Jun 17 05:58:22 2011	(r23068)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/rules/check.str	Fri Jun 17 11:39:08 2011	(r23069)
@@ -4,7 +4,9 @@
 	libstrc
 	rules/map
 	rules/constructors
+	signatures/constructors
 	solver/constraints
+	utils/utils
 	analysis
 rules
 	
@@ -17,13 +19,73 @@
 			<filter(not(?(_,FAIL())))> in-s;
 			?[]
 	
+	constraint-warning:
+		rule at SDefT(_, _, _, _){decl-id} -> (rule,$[Rule never matches valid signatures. (Because of the rule's term parameters)])
+		where not(DisableSortAnalysis)
+		where
+			<get-rule-signature> decl-id;
+			?RuleSig(_, _, _, in-s, _, local-constraints, _);
+			<filter(not(?(_,FAIL())))> in-s;
+			?[_|_];
+			where (<not(FAIL())> local-constraints );
+			map(\ (_,c) -> <solve-top> ISection(local-constraints,c) \);
+			filter(not(?FAIL()));
+			?[]
+			
+	constraint-warning:
+		rule at SDefT(_, _, _, _){decl-id} -> (rule,$[Sort incompatibility in term parameters])
+		where not(DisableSortAnalysis)
+		where
+			<get-rule-signature> decl-id;
+			?RuleSig(_, _, _, _, _, FAIL(), _)
 	
 	constraint-warning:
-		rule at SDefT(_, _, _, _){decl-id} -> (rule,$[This rule can never succeed because of an invalid match.])
+		rule at SDefT(_, _, _, _){decl-id} -> (rule,$[Rule violates signatures on output term. (Because of variables from match)])
 		where not(DisableSortAnalysis)
 		where
+			// if there's at least one successful input term
 			<get-rule-signature> decl-id;
-			?RuleSig(_, _, _, [], _, _, _)
+			?RuleSig(_, _, _, in-s@[_|_], out-s@[_|_], _, _);
+			<filter(not(?(_,FAIL())))> in-s;
+			?[_|_]
+		where
+			in-constraint := <map(\ (_,b) -> b \);to-constraint-union> in-s;
+			out-constraint := <map(\ (_,b) -> b \);to-constraint-union> out-s;
+			<solve-top> ISection(in-constraint,out-constraint);
+			?FAIL()
+	
+	constraint-warning:
+		rule at SDefT(_, _, _, _){decl-id} -> (rule,$[Rule violates signatures on output term. (Because of term parameters)])
+		where not(DisableSortAnalysis)
+		where
+			// if there's at least one successful input term
+			<get-rule-signature> decl-id;
+			?RuleSig(_, _, _, _, out-s@[_|_], local-constraints, _);
+			// remove all failed terms
+			<filter(not(?(_,FAIL())))> out-s;
+			?[_|_];
+			map(\ (_,c) -> <solve-top> ISection(local-constraints,c) \);
+			filter(not(?FAIL()));
+			?[]
+	
+	constraint-warning:
+		rule at SDefT(_, _, _, _){decl-id} -> (rule,$[Rule violates signatures on output term. (3-way sort incompatibility between match, build and term parameters)])
+		where not(DisableSortAnalysis)
+		where
+			<get-rule-signature> decl-id;
+			?RuleSig(_, _, in-s@[_|_], _, out-s@[_|_], local-constraints, _);
+			out-s' := <map(\ (_,b) -> b \);to-constraint-union;solve-top;not(?FAIL())> out-s;
+			in-s' := <map(\ (_,b) -> b \);to-constraint-union;solve-top;not(?FAIL())> in-s
+		where
+			// local to match
+			<solve-top> ISection(local-constraints,in-s') => loc-to-match;
+			not(?FAIL());
+			// local to build
+			<solve-top> ISection(local-constraints,out-s') => loc-to-build;
+			not(?FAIL());
+			// but fail at all three
+			<solve-top> ISection(loc-to-match,loc-to-build);
+			?FAIL()
 			
 			
-			
\ No newline at end of file
+			 
\ No newline at end of file

Modified: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/rules/map.str
==============================================================================
--- spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/rules/map.str	Fri Jun 17 05:58:22 2011	(r23068)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/rules/map.str	Fri Jun 17 11:39:08 2011	(r23069)
@@ -8,6 +8,7 @@
 	signatures/map
 	rules/constructors
 	rules/project
+	utils/utils
 	
 rules /* store our own version of rule declarations */
 	
@@ -31,19 +32,22 @@
 			s-vars-constraints := <map(\ (Var(c),sig) -> CSet([Constraint(c,sig)]) \);to-constraint-intersection> s-vars';
 			debug(!"D4 ");
 			// get the signatures of all the term parameters
-			t-vars' := <map(declare-argument-t)> t-vars;
+			// t-vars' := <map(declare-argument-t)> t-vars;
 			debug(!"D5 ");
 			// the term Var(cookie)'s
-			t-vars'' := <map(\ (c,_) -> c \)> t-vars';
+			// t-vars'' := <map(\ (c,_) -> c \)> t-vars';
 			debug(!"D6 ");
 			// the sort constraints
-			t-vars-constraints := <map(\ (Var(c),sig) -> CSet([Constraint(c,sig)]) \);to-constraint-intersection> t-vars';
+			// t-vars-constraints := <map(\ (Var(c),sig) -> CSet([Constraint(c,sig)]) \);to-constraint-intersection> t-vars';
+			t-arguments := <map(declare-argument-t)> t-vars; // [ (Var(.),ConstraintSet) ]
+			t-vars' := <map(\ (v,_) -> v \)> t-arguments;
+			t-vars-constraints := <map(\ (_,c) -> c \);to-constraint-intersection> t-arguments;
 			debug(!"D7 ");
 			(in-t,out-t,rule-constraints) := <declare-rule> rule;
 			// (in-t,out-t,rule-constraints) := (Var("xxx"),[<sort-any>],CSet([]));
 			debug(!"D8 ");
 			// build the signature
-			sig := RuleSig(name,s-vars'',t-vars'',in-t,out-t, <solve-top>  ISection(s-vars-constraints,ISection(t-vars-constraints,rule-constraints)),decl-id);
+			sig := RuleSig(name,s-vars'',t-vars',in-t,out-t, <solve-top>  ISection(s-vars-constraints,ISection(t-vars-constraints,rule-constraints)),decl-id);
 			debug(!"D9 ");
 			// store the signature
 			<store-rule-signature(|cookie)> sig;
@@ -54,11 +58,20 @@
 	* @type Rule(..) -> (Sort,[Sort],ConstraintSet)
 	*/
 	declare-rule:
-		Rule(match, build, _) -> (in-sorts,[],CSet([]))
+		Rule(match, build, _) -> (in-sorts,out-sorts,CSet([]))
 		where
 			debug(!"DR 1");
-			in-sorts := <sort-of> match;
+			in-sorts := <sort-of <+ ![]> match;
 			debug(!"DR 2")
+		where
+			// if the build does not have any applications, go through it and infer sorts
+			<positions-of-term(?RootApp(_) + ?App(_,_))> build;
+			if(?[]) then
+				out-sorts := <sort-of <+ ![]> build
+			else
+				out-sorts := []
+			end;
+			debug(!"DR 3")
 	
 		
 	/**
@@ -120,10 +133,14 @@
 	* @type VarDec(_{cookie},ConstType(Sort)) -> (Var(cookie),List(Sort))
 	*/
 	declare-argument-t:
-		VarDec(_{cookie},ConstType(s)) -> (Var(cookie),outs)
+		VarDec(_{cookie},ConstType(s)) -> (Var(cookie),constraint-set)
 		with
 			<sort-signature-of> s;
-			outs := <get-compatible-sorts>
+			get-compatible-sorts;
+			map(\ s -> CSet([Constraint(cookie,s)])\);
+			to-constraint-union => constraint-set
+			
+			
 	
 rules /* rule signature storage */
 

Modified: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/rules/project.str
==============================================================================
--- spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/rules/project.str	Fri Jun 17 05:58:22 2011	(r23068)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/rules/project.str	Fri Jun 17 11:39:08 2011	(r23069)
@@ -25,6 +25,10 @@
 		with log(|Error(),"Ignoring annotation in sort-of. NO SUPPORT")
 	
 	sort-of:
+		StringQuotation1(_, _) -> <sort-of> Str(" ")
+		with log(|Critical(), "Encountered StringQuotation1 in sort-of. NO SUPPORT.")
+	
+	sort-of:
 		Wld() -> [(<sort-any>,CSet([]))]
 	
 	sort-of:
@@ -74,7 +78,7 @@
 			debug(!"SOLA2 ");
 			// attempt to combine all sort options for each of the elements. if they are not compatible replace with ATerm
 			if(?[_|_]) then
-				map(\ e-sort -> <reducel(\ ((s1,c1),(s2,c2)) -> (<sort-apply> (s1,s2), Union(c1,c2)) \)> e-sort \ <+
+				map(\ e-sort -> <reducel(\ ((s1,c1),(s2,c2)) -> (<sort-apply-top> (s1,s2), Union(c1,c2)) \)> e-sort \ <+
 						\ e-sort -> <reducel(\ ((_,c1),(_,c2)) -> (<sort-any>,Union(c1,c2)) \)> e-sort \)
 			end;
 			debug(!"SOLA3 ");
@@ -83,7 +87,7 @@
 			debug(!"SOLA4 ");
 			// try to apply to get a sort. we can end up with either a sort, or ATerm
 			// srt := <foldll(!ATerm(), \ (l,r) -> <sort-apply <+ sort-any> (l,r) \)>;
-			srt := <reducel(\ (l,r) -> <sort-apply <+ sort-any> (l,r) \)>;
+			srt := <reducel(\ (l,r) -> <sort-apply-top <+ sort-any> (l,r) \)>;
 			debug(!"SOLA5 ")
 		where
 			// make a list of all the constraint sets
@@ -115,7 +119,7 @@
 						rest-sort' := <innermost(\ Var(v) -> <sort-any> \)> rest-sort;
 						debug(!"SOLB7 ");
 						// re-tighten constraints
-						result-tup := (List(<sort-apply <+ sort-any> (elem-srts,rest-sort')), <solve-top> ISection(elem-constraints,rest-constraints));
+						result-tup := (List(<sort-apply-top <+ sort-any> (elem-srts,rest-sort')), <solve-top> ISection(elem-constraints,rest-constraints));
 						debug(!"SOLB8 ")
 					case ?(Var(v),rest-constraints):
 						debug(!"SOLB9 ");
@@ -345,7 +349,7 @@
 				// new-constraints := <zip(\ (v,s) -> CSet([Constraint(v,s)]) \);to-constraint-intersection> (v-at-pos,s-at-pos);
 				// debug(!"LC5 ");
 				// try to apply the sorts now
-				if(tmp-out-sort := <sort-apply> (source,target)) then
+				if(tmp-out-sort := <sort-apply-top> (source,target)) then
 					// alas, success!
 					// <debug(!"LC5A1 ")> tmp-out-sort;
 					switch !tmp-out-sort

Modified: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/solver/constraints.str
==============================================================================
--- spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/solver/constraints.str	Fri Jun 17 05:58:22 2011	(r23068)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/solver/constraints.str	Fri Jun 17 11:39:08 2011	(r23069)
@@ -139,7 +139,7 @@
 			// debug(!"8 ");
 			r-isection := <isect(compatible-constraints)> (r-cset,l-cset);
 			// debug(!"9 ");
-			isect := <zip(\ (Constraint(a,sl),Constraint(a,sr)) -> Constraint(a,<sort-apply> (sl,sr)) \)> (l-isection,r-isection);
+			isect := <zip(\ (Constraint(a,sl),Constraint(a,sr)) -> Constraint(a,<sort-apply-top> (sl,sr)) \)> (l-isection,r-isection);
 			// debug(!"10 ");
 			cset := <conc> (diff-l,diff-r,isect);
 			// debug(!"11 ");
@@ -223,7 +223,7 @@
 		t@(l,r) -> t 
 		where
 			<eq> (<constraint-var> l, <constraint-var> r);
-			<sort-apply> (<constraint-sort> l, <constraint-sort> r)
+			<sort-apply-top> (<constraint-sort> l, <constraint-sort> r)
 	
 	eq-constraints:
 		t@(l,l) -> t 

Modified: spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/stratego_sugar.str
==============================================================================
--- spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/stratego_sugar.str	Fri Jun 17 05:58:22 2011	(r23068)
+++ spoofax-imp/branches/stratego-editor/org.strategoxt.imp.editors.stratego/trans/stratego_sugar.str	Fri Jun 17 11:39:08 2011	(r23069)
@@ -19,6 +19,7 @@
 	solver/constraints
 	rules/map
 	rules/check
+	rules/constructors
 	utils/utils
 	tests/test-all
 	to-yuml/to-yuml
@@ -115,7 +116,45 @@
   		<not(?FAIL())> config;
   		<collect-all(?Constraint(cookie,_);get-constrained-var-sort,union)> config;
   		text := <pp-list(pp-sort-signature|" + ")>
-  	
+  
+  editor-hover:
+  	(Var(_{cookie}),position,ast,_,_) -> text
+  	where
+  		not(DisableSortAnalysis);
+  		debug(!" HOVER MATCH ");
+  		position' := <desugar-position(basic-desugar|ast)> position;
+  		ast' := <DecoratedAst>;
+  		debug(!" AST' ");
+  		<parent-at-position(?SDefT(_, _, _, _){decl-id}|position')> ast';
+  		debug(!"H1 ");
+  		<get-rule-signature> decl-id;
+  		debug(!"H2 ");
+  		?RuleSig(_, _, _, in-s, out-s, local-constraints, _);
+  		debug(!"H3 ");
+  		if(<?[_|_]> local-constraints) then
+	  		!ISection(
+	  			local-constraints,
+	  			ISection(
+	  				<map(\ (_,b) -> b \);to-constraint-union;solve-top;not(?FAIL())> in-s,
+	  				<map(\ (_,b) -> b \);to-constraint-union;solve-top;not(?FAIL())> out-s
+	  			))
+	  	else
+	  		!ISection(local-constraints,<map(\ (_,b) -> b \);to-constraint-union;solve-top;not(?FAIL())> in-s)
+	  	end;
+  		debug(!"H5 ");
+  		solve-top;
+  		debug(!"H6 ");
+  		if(?FAIL()) then
+  			text := "Failure";
+  			debug(!"H7 ")
+  		else
+  			collect-all(?Constraint(cookie,_);get-constrained-var-sort,union);
+  			debug(!"H8 ");
+  			text := <pp-list(pp-sort-signature|" + ")>;
+  			debug(!"H9 ")
+  		end;
+  		debug(!"H10 ")
+  		
   
   editor-hover:
     (node at ToMetaExpr(_), position, ast, path, project-path) -> text

From M.A.Akhter at student.tudelft.nl  Mon Jun 20 14:23:42 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Mon, 20 Jun 2011 12:23:42 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23070 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/editor/resolve
Message-ID: <20110620122342.644207F807B@mx1.tudelft.nl>

Author: MdAdilAkhter
Date: Mon Jun 20 12:23:42 2011
New Revision: 23070
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23070&sc=1

Log:
turning off editor-resolve debug info for unresolved constructs

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/editor/resolve/imports.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/editor/resolve/imports.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/editor/resolve/imports.str	Fri Jun 17 11:39:08 2011	(r23069)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/editor/resolve/imports.str	Mon Jun 20 12:23:42 2011	(r23070)
@@ -41,7 +41,7 @@
 			+ ?ImportPackage(_) 
 			)
 		);
-		debug(!"Todo : Editor resolve: "); 
+		//debug(!"Todo : Editor resolve: "); 
 		fail
 	
  
\ No newline at end of file

From M.A.Akhter at student.tudelft.nl  Tue Jun 21 02:30:28 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Tue, 21 Jun 2011 00:30:28 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23071 - in
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax: editor
	trans/codegen
Message-ID: <20110621003028.2D75D108C037@mx3.tudelft.nl>

Author: MdAdilAkhter
Date: Tue Jun 21 00:30:26 2011
New Revision: 23071
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23071&sc=1

Log:


Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/editor/SpoofaxLang-Builders.esv
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/buildscripts.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/editor/SpoofaxLang-Builders.esv
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/editor/SpoofaxLang-Builders.esv	Mon Jun 20 12:23:42 2011	(r23070)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/editor/SpoofaxLang-Builders.esv	Tue Jun 21 00:30:26 2011	(r23071)
@@ -15,36 +15,24 @@
 
 	observer                  : editor-analyze
 
-  builder : "Show abstract syntax (for selection)" =
-    generate-aterm (openeditor) (realtime) (meta) (source)
+	builder : "Build-All" =
+    build-all (openeditor) (realtime) (meta)
+
+  builder : "Abstract Syntax" =
+    generate-aterm (openeditor) (realtime) (meta) (source)  
 
-  builder : "Normalize-all" =
+  builder : "Normalize-All" =
   		normalize(openeditor) (realtime) (meta) (source)
   
   
-  builder : "Show name analysis (for selection)" =
+  builder : "Name Analysis (for selection)" =
     generate-name-analysis (openeditor) (realtime) (meta) (source)
-
-  //builder : "Show SDF (for selection)" =
-  //  generate-sdf (openeditor) (realtime)
-
-  //builder : "Show Stratego (for selection)" =
-  //  generate-str (openeditor) (realtime)
-
- // builder : "Show Editor Descriptor (for selection)" =
-  //  generate-esv (openeditor) (realtime)
-
-  //builder: "generate signatures" =
-	//	generate-signatures-from-SDF (realtime) (openeditor) (meta)
-
-	builder : "Build-All" =
-    build-all (openeditor) (realtime) (meta)
-
+  
   builder : "Compile-All" =
     compile-spx(openeditor) (realtime) (meta)
 
 
-  builder : "Show Configuration" =
+  builder : "Show-Config" =
     show-configuration(openeditor) (realtime) (meta)
 
   /*

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/buildscripts.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/buildscripts.str	Mon Jun 20 12:23:42 2011	(r23070)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/buildscripts.str	Tue Jun 21 00:30:26 2011	(r23071)
@@ -264,7 +264,7 @@
             <arg value="${lib}"/>
             <arg line="${utils-include}"/>
             <arg line="${build.sdf.imports}"/>
-            <arg line="${language-sdf-specific-params}"/>
+            <arg line="${lang.sdf.specific.params}"/>
         </java>
     </target>
 	
@@ -544,7 +544,7 @@
       <arg line="${externaljarflags}"/>
       <arg line="${externaldefimport}"/>
       <arg line="-I &quot;${lib}&quot; -I &quot;${include}&quot; --cache-dir &quot;${basedir}/.cache&quot;"/>
-      <arg line="${language-str-specific-params}"/>
+      <arg line="${lang.str.specific.params}"/>
   </java>
   <delete file="${include}/${package.name}.rtree" failonerror="false"/>
   <mkdir dir="${build}/trans"/>

From M.A.Akhter at student.tudelft.nl  Tue Jun 21 02:36:03 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Tue, 21 Jun 2011 00:36:03 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23072 - in
	spoofax-contrib/LwcSPXLang: . .externalToolBuilders META-INF
	editor editor/java editor/java/LwcSPXLang
	editor/java/LwcSPXLang/strategies src src/langdef src/lib...
Message-ID: <20110621003603.0E11E7F804D@mx1.tudelft.nl>

Author: MdAdilAkhter
Date: Tue Jun 21 00:36:02 2011
New Revision: 23072
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23072&sc=1

Log:
lwc-lang (defined using SPX) [in-progress]

Added:
   spoofax-contrib/LwcSPXLang/
   spoofax-contrib/LwcSPXLang/.classpath
   spoofax-contrib/LwcSPXLang/.externalToolBuilders/
   spoofax-contrib/LwcSPXLang/.externalToolBuilders/LwcSPXLang build.main.xml.launch
   spoofax-contrib/LwcSPXLang/.project
   spoofax-contrib/LwcSPXLang/META-INF/
   spoofax-contrib/LwcSPXLang/META-INF/MANIFEST.MF
   spoofax-contrib/LwcSPXLang/build.properties
   spoofax-contrib/LwcSPXLang/editor/
   spoofax-contrib/LwcSPXLang/editor/java/
   spoofax-contrib/LwcSPXLang/editor/java/LwcSPXLang/
   spoofax-contrib/LwcSPXLang/editor/java/LwcSPXLang/Activator.java
   spoofax-contrib/LwcSPXLang/editor/java/LwcSPXLang/LwcSPXLangParseController.java
   spoofax-contrib/LwcSPXLang/editor/java/LwcSPXLang/LwcSPXLangParseControllerGenerated.java
   spoofax-contrib/LwcSPXLang/editor/java/LwcSPXLang/LwcSPXLangValidator.java
   spoofax-contrib/LwcSPXLang/editor/java/LwcSPXLang/strategies/
   spoofax-contrib/LwcSPXLang/editor/java/LwcSPXLang/strategies/InteropRegisterer.java
   spoofax-contrib/LwcSPXLang/editor/java/LwcSPXLang/strategies/Main.java
   spoofax-contrib/LwcSPXLang/editor/java/LwcSPXLang/strategies/java_strategy_0_0.java
   spoofax-contrib/LwcSPXLang/plugin.xml
   spoofax-contrib/LwcSPXLang/spx.config
   spoofax-contrib/LwcSPXLang/src/
   spoofax-contrib/LwcSPXLang/src/langdef/
   spoofax-contrib/LwcSPXLang/src/langdef/entities.spx
   spoofax-contrib/LwcSPXLang/src/langdef/expression.spx
   spoofax-contrib/LwcSPXLang/src/langdef/function.spx
   spoofax-contrib/LwcSPXLang/src/langdef/method.spx
   spoofax-contrib/LwcSPXLang/src/langdef/module.spx
   spoofax-contrib/LwcSPXLang/src/langdef/properties.spx
   spoofax-contrib/LwcSPXLang/src/langdef/statement.spx
   spoofax-contrib/LwcSPXLang/src/languagedescription.spx
   spoofax-contrib/LwcSPXLang/src/lib/
   spoofax-contrib/LwcSPXLang/src/lib/common-syntax.aterm
   spoofax-contrib/LwcSPXLang/src/lib/common-syntax.spx
   spoofax-contrib/LwcSPXLang/src/lib/editor-common.spx
   spoofax-contrib/LwcSPXLang/src/lib/lwc-common.spx
   spoofax-contrib/LwcSPXLang/src/lib/namespace.spx
   spoofax-contrib/LwcSPXLang/src/lib/refactor-common.spx
   spoofax-contrib/LwcSPXLang/src/main.spx
   spoofax-contrib/LwcSPXLang/src/services/
   spoofax-contrib/LwcSPXLang/src/services/editor/
   spoofax-contrib/LwcSPXLang/src/services/editor/analyze.spx
   spoofax-contrib/LwcSPXLang/src/services/editor/coloring.spx
   spoofax-contrib/LwcSPXLang/src/services/editor/hover.spx
   spoofax-contrib/LwcSPXLang/src/services/editor/outliner.spx
   spoofax-contrib/LwcSPXLang/src/services/editor/proposer.spx
   spoofax-contrib/LwcSPXLang/src/services/editor/resolver.spx
   spoofax-contrib/LwcSPXLang/src/services/syntax-prop.spx
   spoofax-contrib/LwcSPXLang/test/
   spoofax-contrib/LwcSPXLang/test/example.lwx

Added: spoofax-contrib/LwcSPXLang/.classpath
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/.classpath	Tue Jun 21 00:36:02 2011	(r23072)
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+
+<classpath>
+	<classpathentry kind="src" excluding="trans/**" path="editor/java"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/J2SE-1.5"/>
+	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
\ No newline at end of file

Added: spoofax-contrib/LwcSPXLang/.externalToolBuilders/LwcSPXLang build.main.xml.launch
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/.externalToolBuilders/LwcSPXLang build.main.xml.launch	Tue Jun 21 00:36:02 2011	(r23072)
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<launchConfiguration type="org.eclipse.ant.AntLaunchConfigurationType">
+<stringAttribute key="bad_container_name" value=".externalToolBuilders"/>
+<booleanAttribute key="org.eclipse.ant.ui.DEFAULT_VM_INSTALL" value="false"/>
+<listAttribute key="org.eclipse.debug.core.MAPPED_RESOURCE_PATHS"/>
+<listAttribute key="org.eclipse.debug.core.MAPPED_RESOURCE_TYPES"/>
+<booleanAttribute key="org.eclipse.debug.ui.ATTR_LAUNCH_IN_BACKGROUND" value="false"/>
+<listAttribute key="org.eclipse.jdt.launching.CLASSPATH">
+<listEntry value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&#10;&lt;runtimeClasspathEntry containerPath=&quot;org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/java-1.5.0-sun-1.5.0.18&quot; path=&quot;1&quot; type=&quot;4&quot;/&gt;&#10;"/>
+<listEntry value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&#10;&lt;runtimeClasspathEntry id=&quot;org.eclipse.ant.ui.classpathentry.antHome&quot;&gt;&#10;&lt;memento default=&quot;true&quot;/&gt;&#10;&lt;/runtimeClasspathEntry&gt;&#10;"/>
+<listEntry value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&#10;&lt;runtimeClasspathEntry id=&quot;org.eclipse.ant.ui.classpathentry.extraClasspathEntries&quot;&gt;&#10;&lt;memento/&gt;&#10;&lt;/runtimeClasspathEntry&gt;&#10;"/>
+</listAttribute>
+<stringAttribute key="org.eclipse.jdt.launching.CLASSPATH_PROVIDER" value="org.eclipse.ant.ui.AntClasspathProvider"/>
+<booleanAttribute key="org.eclipse.jdt.launching.DEFAULT_CLASSPATH" value="false"/>
+<stringAttribute key="org.eclipse.jdt.launching.PROJECT_ATTR" value=""/>
+<stringAttribute key="org.eclipse.jdt.launching.SOURCE_PATH_PROVIDER" value="org.eclipse.ant.ui.AntClasspathProvider"/>
+<stringAttribute key="org.eclipse.ui.externaltools.ATTR_ANT_TARGETS" value="build-spx-packages,"/>
+<stringAttribute key="org.eclipse.ui.externaltools.ATTR_LAUNCH_CONFIGURATION_BUILD_SCOPE" value="${none}"/>
+<stringAttribute key="org.eclipse.ui.externaltools.ATTR_LOCATION" value="${workspace_loc:/LwcSPXLang/build.spx.packages.xml}"/>
+<booleanAttribute key="org.eclipse.ui.externaltools.ATTR_TRIGGERS_CONFIGURED" value="true"/>
+<stringAttribute key="org.eclipse.ui.externaltools.ATTR_WORKING_DIRECTORY" value="${workspace_loc:/LwcSPXLang}"/>
+<stringAttribute key="process_factory_id" value="org.eclipse.ant.ui.remoteAntProcessFactory"/>
+</launchConfiguration>

Added: spoofax-contrib/LwcSPXLang/.project
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/.project	Tue Jun 21 00:36:02 2011	(r23072)
@@ -0,0 +1,37 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+
+<projectDescription>
+      <name>LwcSPXLang</name>
+      <comment></comment>
+      <buildSpec>
+        <buildCommand>
+          <name>org.eclipse.jdt.core.javabuilder</name>
+          <arguments>
+          </arguments>
+        </buildCommand>
+        <buildCommand>
+            <name>org.eclipse.ui.externaltools.ExternalToolBuilder</name>
+            <triggers>full,incremental,</triggers>
+            <arguments>
+                <dictionary>
+                    <key>LaunchConfigHandle</key>
+                    <value>&lt;project&gt;/.externalToolBuilders/LwcSPXLang build.main.xml.launch</value>
+                </dictionary>
+            </arguments>
+        </buildCommand>
+        <buildCommand>
+          <name>org.eclipse.pde.ManifestBuilder</name>
+          <arguments>
+          </arguments>
+        </buildCommand>
+        <buildCommand>
+          <name>org.eclipse.pde.SchemaBuilder</name>
+          <arguments>
+          </arguments>
+        </buildCommand>
+      </buildSpec>
+      <natures>
+        <nature>org.eclipse.pde.PluginNature</nature>
+        <nature>org.eclipse.jdt.core.javanature</nature>
+      </natures>
+    </projectDescription>
\ No newline at end of file

Added: spoofax-contrib/LwcSPXLang/META-INF/MANIFEST.MF
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/META-INF/MANIFEST.MF	Tue Jun 21 00:36:02 2011	(r23072)
@@ -0,0 +1,22 @@
+Manifest-Version: 1.0
+Bundle-ManifestVersion: 2
+Bundle-Name: LwcSPXLang Plug-in
+Bundle-SymbolicName: LwcSPXLang; singleton:=true
+Bundle-Version: 1.0.0
+Bundle-Activator: LwcSPXLang.Activator
+Import-Package: org.osgi.framework;version="1.3.0"
+Require-Bundle: org.eclipse.core.runtime,
+  org.eclipse.core.resources,
+  org.eclipse.imp.runtime,
+  org.eclipse.ui,
+  lpg.runtime,
+  org.eclipse.jface.text,
+  org.eclipse.ui.editors,
+  org.eclipse.ui.workbench.texteditor,
+  org.strategoxt.imp.runtime,
+  org.spoofax.aterm,
+  org.spoofax.jsglr,
+  org.strategoxt.strj
+Bundle-RequiredExecutionEnvironment: J2SE-1.5
+Bundle-ActivationPolicy: lazy
+Export-Package: LwcSPXLang

Added: spoofax-contrib/LwcSPXLang/build.properties
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/build.properties	Tue Jun 21 00:36:02 2011	(r23072)
@@ -0,0 +1,8 @@
+source.. = editor/java/
+output.. = bin/
+bin.includes = META-INF/,\
+               plugin.xml,\
+               include/,\
+               bin/,\
+               lib/,\
+               .

Added: spoofax-contrib/LwcSPXLang/editor/java/LwcSPXLang/Activator.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/editor/java/LwcSPXLang/Activator.java	Tue Jun 21 00:36:02 2011	(r23072)
@@ -0,0 +1,44 @@
+package LwcSPXLang;
+
+import org.eclipse.imp.preferences.PreferencesService;
+import org.eclipse.imp.runtime.PluginBase;
+import org.osgi.framework.BundleContext;
+
+public class Activator extends PluginBase 
+{ 
+  public static final String kPluginID = "LwcSPXLang";
+
+  public static final String kLanguageName = "LwcSPXLang";
+
+  protected static Activator sPlugin;
+
+  public static Activator getInstance()
+  { 
+    if(sPlugin == null)
+      return new Activator();
+    return sPlugin;
+  }
+
+  public Activator () 
+  { 
+    super();
+    sPlugin = this;
+  }
+
+  @Override public void start(BundleContext context) throws Exception
+  { 
+    super.start(context);
+  }
+
+  @Override public String getID()
+  { 
+    return kPluginID;
+  }
+
+  @Override public String getLanguageID()
+  { 
+    return kLanguageName;
+  }
+
+  protected static PreferencesService preferencesService = null;
+}
\ No newline at end of file

Added: spoofax-contrib/LwcSPXLang/editor/java/LwcSPXLang/LwcSPXLangParseController.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/editor/java/LwcSPXLang/LwcSPXLangParseController.java	Tue Jun 21 00:36:02 2011	(r23072)
@@ -0,0 +1,4 @@
+package LwcSPXLang;
+
+public class LwcSPXLangParseController extends LwcSPXLangParseControllerGenerated 
+{ }
\ No newline at end of file

Added: spoofax-contrib/LwcSPXLang/editor/java/LwcSPXLang/LwcSPXLangParseControllerGenerated.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/editor/java/LwcSPXLang/LwcSPXLangParseControllerGenerated.java	Tue Jun 21 00:36:02 2011	(r23072)
@@ -0,0 +1,89 @@
+package LwcSPXLang;
+
+import java.io.InputStream;
+import java.io.IOException;
+import org.eclipse.imp.parser.IParseController;
+import org.strategoxt.imp.runtime.Environment;
+import org.strategoxt.imp.runtime.dynamicloading.BadDescriptorException;
+import org.strategoxt.imp.runtime.dynamicloading.Descriptor;
+import org.strategoxt.imp.runtime.dynamicloading.DescriptorFactory;
+import org.strategoxt.imp.runtime.dynamicloading.DynamicParseController;
+
+public class LwcSPXLangParseControllerGenerated extends DynamicParseController 
+{ 
+  public static final String LANGUAGE = new String("LwcSPXLang");
+
+  private static final String TABLE = "/include/" + LANGUAGE + ".tbl";
+
+  private static final String DESCRIPTOR = "/include/" + LANGUAGE + ".packed.esv";
+
+  private static volatile Descriptor descriptor;
+
+  private static Throwable notLoadingCause;
+
+  public static synchronized Descriptor getDescriptor()
+  { 
+    if(notLoadingCause != null)
+      throw new RuntimeException(notLoadingCause);
+    if(descriptor == null)
+      createDescriptor();
+    return descriptor;
+  }
+
+  private static void createDescriptor()
+  { 
+    try
+    { 
+      InputStream descriptorStream = LwcSPXLangParseController.class.getResourceAsStream(DESCRIPTOR);
+      InputStream table = LwcSPXLangParseController.class.getResourceAsStream(TABLE);
+      if(descriptorStream == null)
+        throw new BadDescriptorException("Could not load descriptor file from " + DESCRIPTOR + " (not found in plugin: " + getPluginLocation() + ")");
+      if(table == null)
+        throw new BadDescriptorException("Could not load parse table from " + TABLE + " (not found in plugin: " + getPluginLocation() + ")");
+      descriptor = DescriptorFactory.load(descriptorStream, table, null);
+      descriptor.setAttachmentProvider(LwcSPXLangParseController.class);
+    }
+    catch(BadDescriptorException exc)
+    { 
+      notLoadingCause = exc;
+      Environment.logException("Bad descriptor for " + LANGUAGE + " plugin", exc);
+      throw new RuntimeException("Bad descriptor for " + LANGUAGE + " plugin", exc);
+    }
+    catch(IOException exc)
+    { 
+      notLoadingCause = exc;
+      Environment.logException("I/O problem loading descriptor for " + LANGUAGE + " plugin", exc);
+      throw new RuntimeException("I/O problem loading descriptor for " + LANGUAGE + " plugin", exc);
+    }
+  }
+
+  private static String getPluginLocation()
+  { 
+    return LwcSPXLangParseController.class.getProtectionDomain().getCodeSource().getLocation().getFile();
+  }
+
+  @Override public IParseController getWrapped()
+  { 
+    if(!isInitialized())
+    { 
+      if(notLoadingCause != null)
+        throw new RuntimeException(notLoadingCause);
+      try
+      { 
+        initialize(this, getDescriptor().getLanguage());
+      }
+      catch(BadDescriptorException exc)
+      { 
+        notLoadingCause = exc;
+        throw new RuntimeException(exc);
+      }
+    }
+    return super.getWrapped();
+  }
+
+  @Override protected void setNotLoadingCause(Throwable value)
+  { 
+    notLoadingCause = value;
+    super.setNotLoadingCause(value);
+  }
+}
\ No newline at end of file

Added: spoofax-contrib/LwcSPXLang/editor/java/LwcSPXLang/LwcSPXLangValidator.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/editor/java/LwcSPXLang/LwcSPXLangValidator.java	Tue Jun 21 00:36:02 2011	(r23072)
@@ -0,0 +1,12 @@
+package LwcSPXLang;
+
+import org.strategoxt.imp.runtime.dynamicloading.Descriptor;
+import org.strategoxt.imp.runtime.services.MetaFileLanguageValidator;
+
+public class LwcSPXLangValidator extends MetaFileLanguageValidator 
+{ 
+  @Override public Descriptor getDescriptor()
+  { 
+    return LwcSPXLangParseController.getDescriptor();
+  }
+}
\ No newline at end of file

Added: spoofax-contrib/LwcSPXLang/editor/java/LwcSPXLang/strategies/InteropRegisterer.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/editor/java/LwcSPXLang/strategies/InteropRegisterer.java	Tue Jun 21 00:36:02 2011	(r23072)
@@ -0,0 +1,14 @@
+package LwcSPXLang.strategies;
+
+       import org.strategoxt.lang.JavaInteropRegisterer;
+       import org.strategoxt.lang.Strategy;
+
+       /**
+        * Helper class for {@link java_strategy_0_0}.
+        */
+       public class InteropRegisterer extends JavaInteropRegisterer {
+
+         public InteropRegisterer() {
+           super(new Strategy[] { java_strategy_0_0.instance });
+         }
+       }

Added: spoofax-contrib/LwcSPXLang/editor/java/LwcSPXLang/strategies/Main.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/editor/java/LwcSPXLang/strategies/Main.java	Tue Jun 21 00:36:02 2011	(r23072)
@@ -0,0 +1,11 @@
+package LwcSPXLang.strategies;
+
+       import org.strategoxt.lang.Context;
+       
+       public class Main {
+         
+         public static void init(Context context) {
+           // Called when the editor is being initialized
+         }
+       
+       }

Added: spoofax-contrib/LwcSPXLang/editor/java/LwcSPXLang/strategies/java_strategy_0_0.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/editor/java/LwcSPXLang/strategies/java_strategy_0_0.java	Tue Jun 21 00:36:02 2011	(r23072)
@@ -0,0 +1,32 @@
+package LwcSPXLang.strategies;
+
+       import org.spoofax.interpreter.terms.IStrategoTerm;
+       import org.spoofax.interpreter.terms.ITermFactory;
+       import org.strategoxt.lang.Context;
+       import org.strategoxt.lang.Strategy;
+       
+       /**
+        * Example Java strategy implementation.
+        *
+        * This strategy can be used by editor services and can be called
+        * in Stratego modules by declaring it as an external strategy
+        * as follows:
+        *
+        * <code>
+        *  external java-strategy(|)
+        * </code>
+        *
+        * @see InteropRegisterer  This class registers java_strategy_0_0 for use.
+        */
+       public class java_strategy_0_0 extends Strategy {
+         
+         public static java_strategy_0_0 instance = new java_strategy_0_0();
+       
+         @Override
+         public IStrategoTerm invoke(Context context, IStrategoTerm current) {
+           context.getIOAgent().printError("Input for java-strategy: " + current);
+           ITermFactory factory = context.getFactory();
+           return factory.makeString("Regards from java-strategy");
+         }
+       
+       }

Added: spoofax-contrib/LwcSPXLang/plugin.xml
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/plugin.xml	Tue Jun 21 00:36:02 2011	(r23072)
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+<?eclipse version="3.0"?>
+
+<plugin>
+       <extension point="org.eclipse.imp.runtime.languageDescription">
+          <language extensions="lwx" description="LwcSPXLang" language="LwcSPXLang" derivedFrom="DynamicRoot" validator="LwcSPXLang.LwcSPXLangValidator" validatorClass="LwcSPXLang.LwcSPXLangValidator"></language>
+       </extension>
+       <extension id="LwcSPXLang.parser" name="LwcSPXLang Parser" point="org.eclipse.imp.runtime.parser">
+          <parser class="LwcSPXLang.LwcSPXLangParseController" language="LwcSPXLang">
+          </parser>
+       </extension>    
+    </plugin>
\ No newline at end of file

Added: spoofax-contrib/LwcSPXLang/spx.config
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/spx.config	Tue Jun 21 00:36:02 2011	(r23072)
@@ -0,0 +1,7 @@
+Configuration
+	Includes
+		AllDirectories src
+		
+				
+	CodeGeneration 
+		OutputDirectory		.shadowdir
\ No newline at end of file

Added: spoofax-contrib/LwcSPXLang/src/langdef/entities.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/src/langdef/entities.spx	Tue Jun 21 00:36:02 2011	(r23072)
@@ -0,0 +1,14 @@
+package languages.spx.lwc
+
+module entity-definition
+	imports languages.commonLang
+	
+	 context-free syntax 
+  	Entity                          -> Definition
+    "entity" ID "{" EntityElem* "}" -> Entity {cons("Entity")}
+    ID                              -> Type {cons("Type")}
+    
+    "this"                          -> Exp {cons("This")}
+  	"this"                          -> ID {reject}
+
+	
\ No newline at end of file

Added: spoofax-contrib/LwcSPXLang/src/langdef/expression.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/src/langdef/expression.spx	Tue Jun 21 00:36:02 2011	(r23072)
@@ -0,0 +1,14 @@
+package languages.spx.lwc
+
+module expression-definition
+	imports languages.commonLang
+	
+	context-free syntax
+  	"var" ID ":" Type ";" -> VarDecl {cons("VarDecl")}
+  	
+	context-free syntax
+  	ID          -> Exp {cons("VarRef")}
+  	"(" Exp ")" -> Exp {bracket}
+
+    Exp "<" Exp -> Exp {cons("LT"),non-assoc}
+	
\ No newline at end of file

Added: spoofax-contrib/LwcSPXLang/src/langdef/function.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/src/langdef/function.spx	Tue Jun 21 00:36:02 2011	(r23072)
@@ -0,0 +1,24 @@
+package languages.spx.lwc
+
+module function-definition
+	imports languages.commonLang
+	
+	context-free syntax
+  	ID "(" {Param ","}* ")" ReturnType? Block -> FunctionDef {cons("FunctionDef")}
+  	ID "(" {Exp ","}* ")"                     -> FunctionCall {cons("FunctionCall")}
+    FunctionDef                               -> Definition 
+  	FunctionCall                              -> Exp
+  
+  context-free syntax 	
+  	ID ":" Type      -> Param {cons("Param")}
+  	
+  	":" Type         -> ReturnType {cons("ReturnType")}
+  	"return" Exp ";" -> Statement {cons("Return")}
+  
+  context-free syntax
+  	"<" ID ">" XmlElem* "</" ID ">" -> XmlElem {cons("XML")}
+  	
+  	XmlElem -> Exp 
+  
+   
+	 
\ No newline at end of file

Added: spoofax-contrib/LwcSPXLang/src/langdef/method.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/src/langdef/method.spx	Tue Jun 21 00:36:02 2011	(r23072)
@@ -0,0 +1,11 @@
+package languages.spx.lwc
+
+module method-definition
+	imports languages.commonLang
+	 context-free syntax
+  	ID "(" {Param ","}* ")" ReturnType? Block -> MethodDef {cons("MethodDef")}
+  	Exp "." ID "(" {Exp ","}* ")"             -> MethodCall {cons("MethodCall")}
+    MethodDef                                 -> EntityElem
+  	MethodCall                                -> Exp
+
+	 
\ No newline at end of file

Added: spoofax-contrib/LwcSPXLang/src/langdef/module.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/src/langdef/module.spx	Tue Jun 21 00:36:02 2011	(r23072)
@@ -0,0 +1,64 @@
+package languages.spx.lwc
+
+module module-definition
+  
+  imports 
+  	languages.commonLang       
+  
+  context-free syntax
+    "module" ID Definition* -> Module {cons("Module")}
+    "imports" FILENAME      -> Definition {cons("Imports")}
+ 
+
+module module-signatures
+	signature
+  	constructors
+  	Module : Namespace 
+
+  	
+module module-trans
+	 imports 
+  	languages.commonLang       
+
+	rules // modules
+		rename :
+	  	Module(name, defs) -> Module(name, defs')
+	  	where <rename-all> defs => defs' 
+		   
+	  store :
+	   	mod at Module(name, defs) -> mod
+	   	where <map-declaration(|Module())> (name, (<CurrentFile>, mod))
+	   	   
+	   editor-error :
+	   	Module(name, defs) -> (name, $[Filename does not correspond to module name])
+	   	where <get-declaration(|Module())> name => (file, mod)
+	    where not( <base-filename; remove-extension> file => name ; <has-extension(|"lwc")> file )
+	
+	   	   
+	rules // imports
+		
+	  get-module :
+	  	Imports(name) -> ast
+	  	where <parse-lwc-file(|<CurrentFile>)> name => ast
+	  	
+	  rename :
+	  	imp at Imports(name) -> imp 
+	  	where  <get-module; rename-all> imp 
+	  	
+	  store :
+	  	imp at Imports(name) -> imp
+	  	where  <get-module; store-all> imp 
+	
+	  desugar :
+	  	imp at Imports(name) -> imp
+	  	where <get-module; desugar-all> imp
+	  	    
+	  resolve :
+	    Imports(name) -> <get-module>
+	      	  
+	  editor-error :
+	  	imp at Imports(name) -> (name, $[Module does not exist])
+	  	where not( <get-module> imp )
+	
+ 
+         
\ No newline at end of file

Added: spoofax-contrib/LwcSPXLang/src/langdef/properties.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/src/langdef/properties.spx	Tue Jun 21 00:36:02 2011	(r23072)
@@ -0,0 +1,10 @@
+package languages.spx.lwc
+
+module property-definition
+	imports languages.commonLang
+	
+	context-free syntax
+	  Property    -> EntityElem 
+    ID ":" Type -> Property {cons("Property")}
+  	Exp "." ID  -> Exp {cons("PropertyAccess")}
+	
\ No newline at end of file

Added: spoofax-contrib/LwcSPXLang/src/langdef/statement.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/src/langdef/statement.spx	Tue Jun 21 00:36:02 2011	(r23072)
@@ -0,0 +1,15 @@
+package languages.spx.lwc
+
+
+module statement-definition
+	
+	imports languages.commonLang
+	context-free syntax
+  	Exp ":=" Exp ";"   -> Statement {cons("Assign")}
+  	"{" Statement* "}" -> Block {cons("Block")}
+  	Block              -> Statement
+  	VarDecl            -> Statement
+  	Exp ";"            -> Statement {cons("Statement")} 
+	context-free syntax
+  	"if" "(" Exp ")" Block "else" Block -> Statement {cons("If")}
+  	"while" "(" Exp ")" Block           -> Statement {cons("While")} 
\ No newline at end of file

Added: spoofax-contrib/LwcSPXLang/src/languagedescription.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/src/languagedescription.spx	Tue Jun 21 00:36:02 2011	(r23072)
@@ -0,0 +1,27 @@
+package languages.spx.lwc
+
+module languagedescription
+	
+	imports languages.commonLang
+	
+	language General properties
+    
+		name          : LwcSPXLang 
+  	id            : LwcSPXLang
+  	extends       : Root
+                  
+  	description   : "Spoofax/IMP-generated editor for the LwcSPXLang language"
+  	url           : http://strategoxt.org
+                  
+  	extensions    : lwx
+	  start symbols : Start             
+   
+
+		builders
+	  	provider : include/LwcSPXLang-java.jar      
+	  	
+	  	builder : "Show abstract syntax (for selection)"   = generate-aterm (openeditor) (realtime) (meta) (source)  
+ 
+  		builder  : "Analysis"  = analyze-builder (openeditor) (realtime) (meta) (source)  
+ 
+	    

Added: spoofax-contrib/LwcSPXLang/src/lib/common-syntax.aterm
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/src/lib/common-syntax.aterm	Tue Jun 21 00:36:02 2011	(r23072)
@@ -0,0 +1,228 @@
+CompilationUnit(
+  []
+, [ Package(
+      QName(["languages", "commonLang"])
+    , [ Module(
+          None()
+        , SPXModuleName("common-syntax")
+        , [ SDFSection(
+              lexical-syntax(
+                [ prod(
+                    [ char-class(
+                        simple-charclass(
+                          present(
+                            conc(
+                              range(short("a"), short("z"))
+                            , range(short("A"), short("Z"))
+                            )
+                          )
+                        )
+                      )
+                    , iter-star(
+                        char-class(
+                          simple-charclass(
+                            present(
+                              conc(
+                                range(short("a"), short("z"))
+                              , conc(
+                                  range(short("A"), short("Z"))
+                                , conc(range(short("0"), short("9")), short("\\_"))
+                                )
+                              )
+                            )
+                          )
+                        )
+                      )
+                    ]
+                  , sort("ID")
+                  , no-attrs()
+                  )
+                ]
+              )
+            )
+          , SDFSection(
+              lexical-restrictions(
+                [ follow(
+                    [sort("ID")]
+                  , single(
+                      char-class(
+                        simple-charclass(
+                          present(
+                            conc(
+                              range(short("a"), short("z"))
+                            , conc(
+                                range(short("A"), short("Z"))
+                              , conc(range(short("0"), short("9")), short("\\_"))
+                              )
+                            )
+                          )
+                        )
+                      )
+                    )
+                  )
+                ]
+              )
+            )
+          , SDFSection(
+              lexical-syntax(
+                [ prod(
+                    [ opt(lit("\"-\""))
+                    , iter(
+                        char-class(simple-charclass(present(range(short("0"), short("9")))))
+                      )
+                    ]
+                  , sort("INT")
+                  , no-attrs()
+                  )
+                , prod(
+                    [lit("\"\\\"\""), iter-star(sort("StringChar")), lit("\"\\\"\"")]
+                  , sort("STRING")
+                  , no-attrs()
+                  )
+                , prod(
+                    [char-class(
+                       comp(simple-charclass(present(conc(short("\\\""), short("\\n")))))
+                     )]
+                  , sort("StringChar")
+                  , no-attrs()
+                  )
+                , prod([lit("\"\\\\\\\"\"")], sort("StringChar"), no-attrs())
+                , prod([sort("BackSlashChar")], sort("StringChar"), no-attrs())
+                , prod([lit("\"\\\\\"")], sort("BackSlashChar"), no-attrs())
+                , prod(
+                    [ char-class(
+                        simple-charclass(
+                          present(
+                            conc(
+                              short("\\ ")
+                            , conc(short("\\t"), conc(short("\\n"), short("\\r")))
+                            )
+                          )
+                        )
+                      )
+                    ]
+                  , layout()
+                  , no-attrs()
+                  )
+                , prod(
+                    [char-class(simple-charclass(present(short("\\*"))))]
+                  , sort("CommentChar")
+                  , no-attrs()
+                  )
+                , prod(
+                    [ lit("\"/*\"")
+                    , iter-star(
+                        alt(
+                          char-class(comp(simple-charclass(present(short("\\*")))))
+                        , sort("CommentChar")
+                        )
+                      )
+                    , lit("\"*/\"")
+                    ]
+                  , layout()
+                  , no-attrs()
+                  )
+                , prod(
+                    [ lit("\"//\"")
+                    , iter-star(
+                        char-class(
+                          comp(simple-charclass(present(conc(short("\\n"), short("\\r")))))
+                        )
+                      )
+                    , alt(
+                        char-class(simple-charclass(present(conc(short("\\n"), short("\\r")))))
+                      , sort("EOF")
+                      )
+                    ]
+                  , layout()
+                  , no-attrs()
+                  )
+                , prod([], sort("EOF"), no-attrs())
+                ]
+              )
+            )
+          , SDFSection(
+              lexical-restrictions(
+                [ follow(
+                    [sort("CommentChar")]
+                  , single(char-class(simple-charclass(present(short("\\/")))))
+                  )
+                , follow(
+                    [sort("INT")]
+                  , single(
+                      char-class(simple-charclass(present(range(short("0"), short("9")))))
+                    )
+                  )
+                , follow(
+                    [sort("ID")]
+                  , single(
+                      char-class(
+                        simple-charclass(
+                          present(
+                            conc(
+                              range(short("a"), short("z"))
+                            , conc(
+                                range(short("A"), short("Z"))
+                              , conc(range(short("0"), short("9")), short("\\_"))
+                              )
+                            )
+                          )
+                        )
+                      )
+                    )
+                  )
+                , follow(
+                    [sort("EOF")]
+                  , single(char-class(comp(simple-charclass(absent()))))
+                  )
+                , follow(
+                    [sort("BackSlashChar")]
+                  , single(char-class(simple-charclass(present(short("\\\"")))))
+                  )
+                ]
+              )
+            )
+          , SDFSection(
+              context-free-restrictions(
+                [ follow(
+                    [opt(layout())]
+                  , single(
+                      char-class(
+                        simple-charclass(
+                          present(
+                            conc(
+                              short("\\ ")
+                            , conc(short("\\t"), conc(short("\\n"), short("\\r")))
+                            )
+                          )
+                        )
+                      )
+                    )
+                  )
+                , follow(
+                    [opt(layout())]
+                  , single(
+                      seq(
+                        simple-charclass(present(short("\\/")))
+                      , single(char-class(simple-charclass(present(short("\\/")))))
+                      )
+                    )
+                  )
+                , follow(
+                    [opt(layout())]
+                  , single(
+                      seq(
+                        simple-charclass(present(short("\\/")))
+                      , single(char-class(simple-charclass(present(short("\\*")))))
+                      )
+                    )
+                  )
+                ]
+              )
+            )
+          ]
+        )
+      ]
+    )
+  ]
+)
\ No newline at end of file

Added: spoofax-contrib/LwcSPXLang/src/lib/common-syntax.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/src/lib/common-syntax.spx	Tue Jun 21 00:36:02 2011	(r23072)
@@ -0,0 +1,50 @@
+package languages.commonLang    
+
+module common-syntax
+	
+	context-free syntax
+  	ID         -> QID
+    QID "." ID -> QID {cons("QId")}
+  
+	lexical syntax
+		[a-zA-Z][a-zA-Z0-9\_]* -> ID
+    "-"? [0-9]+          -> INT
+    {ID "/"}+ 					 -> FILENAME
+    "\"" StringChar* "\"" -> STRING
+    ~[\"\n]               -> StringChar
+    "\\\""                -> StringChar
+    BackSlashChar         -> StringChar
+    "\\"                  -> BackSlashChar
+    
+    [\ \t\n\r] -> LAYOUT
+    
+    [\*]                             -> CommentChar
+    "/*" (~[\*] | CommentChar)* "*/" -> LAYOUT 
+    "//" ~[\n\r]* ([\n\r] | EOF)     -> LAYOUT
+    
+    -> EOF
+  
+  	
+  lexical restrictions
+  
+    %% Ensure greedy matching for lexicals
+    ID -/- [a-zA-Z0-9\_]
+    CommentChar   -/- [\/]
+    INT           -/- [0-9]
+    ID            -/- [a-zA-Z0-9\_]
+   
+    %% EOF may not be followed by any char
+    
+    EOF           -/- ~[]
+
+    %% Backslash chars in strings may not be followed by " 
+    
+    BackSlashChar -/- [\"]
+
+  context-free restrictions
+  
+    %% Ensure greedy matching for comments
+
+    LAYOUT? -/- [\ \t\n\r]
+    LAYOUT? -/- [\/].[\/]
+    LAYOUT? -/- [\/].[\*]

Added: spoofax-contrib/LwcSPXLang/src/lib/editor-common.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/src/lib/editor-common.spx	Tue Jun 21 00:36:02 2011	(r23072)
@@ -0,0 +1,257 @@
+package languages.commonLang
+
+module autogenerated 
+	imports
+	  libstratego-lib
+	  libstratego-sglr
+	  libstratego-gpp 
+	strategies
+
+		// TODO FIX SPX : lib strategies have to be more generic so that they
+		// can be used from  multiple languages simulateously 
+	  parse-file =  parse-lwc-file
+	  parse-lwc-file =
+	    parse-file(
+	      strsglr-perror, strsglr-report-parse-error
+	    | <import-term(include/LWC.tbl)>
+	    )
+	
+	  parse-string = parse-lwc-string 
+	  parse-lwc-string = 
+	    parse-string( 
+	      strsglr-report-parse-error
+	    | <import-term(include/LWC.tbl)>
+	    )
+	  
+	  parse-stream = parse-test-stream
+	  parse-test-stream =
+	    parse-stream(
+	      strsglr-report-parse-error
+	    | <import-term(include/Test.tbl)>
+	    )
+	
+	  pp-test-string =
+	    ast2abox(|[<import-term(include/Test.generated.pp.af)>,
+	               <import-term(include/Test.pp.af)>]); 
+	    box2text-string(|100)
+
+	strategies
+	  
+	  /**
+	   * Processes an import during semantic analysis.
+	   * Ensures proper caching of files and prevents
+	   * processing duplicate imports more than once.
+	   *
+	   * @param resolve-path  Resolves the filesystem path of this import
+	   * @param parse-file    Parses a file (optionally removing definition bodies
+	   *                      so only signatures are stored in the cache)
+	   * @param record-declarations
+	   *                      Performs semantic analysis on a tree
+	   */
+	  open-import(resolve-path, parse-file, record-declarations):
+	    import -> import
+	    where
+	      if not(!import => COMPLETION(_)) then
+	        path       := <resolve-path> import;
+	        cache-path := <import-cache-path> path;
+	        if not(<IsImported> path) then
+	          rules(
+	            IsImported: path
+	          );
+	          ( <is-newer> (cache-path, path);
+	            file := <ReadFromFile> cache-path
+	          <+
+	            file := <parse-file> path;
+	            if <file-exists> path then
+	              // Only cache if on filesystem (e.g., ignore libstratego-lib)
+	              <WriteToBinaryFile> (cache-path, file)
+	            end        
+	          ); 
+	          {| CurrentFile:
+	            rules(CurrentFile := path)
+	          	;<record-declarations> file    
+	          |}
+	        end
+	      end  
+	
+	  open-wildcard-import(resolve-path, parse-file, record-declarations, is-source-file):
+	    import -> import
+	    where
+	      if not(!import => COMPLETION(_)) then
+	        path := <resolve-path> import;
+	        readdir;
+	        list-loop(
+	          if is-source-file then
+	            <open-import(id, parse-file, record-declarations)>
+	              $[[path]/[<id>]]
+	          <+
+	            try(?one-failed)
+	          end
+	        );
+	        not(!one-failed)
+	      end
+	  
+	  import-cache-path:
+	    full-path -> cache-path
+	    with
+	      project-path := <project-path>;
+	      cache-dir    := <file-exists <+ mkdir> $[[project-path]/.cache];
+	      full-path'   := <string-replace(|"/", "+"); string-replace(|"\\", "+"); string-replace(|":", "+")> full-path;
+	      cache-path   := $[[cache-dir]/[full-path'].sig]
+	
+	  project-path = prim("SSL_EXT_projectpath")
+	  
+	  plugin-path = prim("SSL_EXT_pluginpath")
+	  
+	  candidate-sorts = prim("SSL_EXT_candidatesorts")
+	
+	  is-newer:
+	    (file1, file2) -> <id>
+	    where
+	      <gt> (<file-exists; modification-time> file1, <file-exists; modification-time> file2) 
+	
+	strategies
+	  
+	  editor-init =
+	    // Ensure all dynamic rules are properly scoped
+	    try(dr-scope-all-end);
+	    dr-scope-all-start
+	  
+	  refresh-workspace-file:
+	    path -> <prim("SSL_EXT_refreshresource", path)>
+	  
+	  string-starts-with-capital =
+	    explode-string; Hd; is-upper 
+	
+	strategies
+	  
+	  origin-term      = prim("SSL_EXT_origin_term", <id>)
+	  origin-text      = prim("SSL_EXT_origin_text", <id>)
+	  origin-location  = prim("SSL_EXT_origin_location", <id>)
+	  origin-line      = origin-location => (<id>, _, _, _)
+	  origin-column    = origin-location => (_, <id>, _, _)
+	  origin-strip     = prim("SSL_EXT_origin_strip", <id>)
+	  origin-equal(|t) = prim("SSL_EXT_origin_equal", <id>, t)
+	  
+	  origin-surrounding-comments =
+	    prim("SSL_EXT_origin_surrounding_comments", "Test", <id>)
+	    
+	  origin-documentation-comment =
+	    origin-surrounding-comments;
+	    filter(string-as-chars(documentation-comment-chars));
+	    concat-strings
+	  
+	  documentation-comment-chars:
+	    ['*' | c*] -> <ltrim(' ' + '\t' + '\n' + '\r')> c*
+	  
+	  origin-track-forced(s) =
+	    ![<id>]; all(s); ?[<id>]
+	
+	strategies
+	
+	  desugar-position(desugar|ast): 
+	    position -> position'
+	    where
+	      ast'  := <at-position(!<id>{MARKER()}|position)> ast;
+	      ast'' := <topdown(repeat(preserve-annos({?x; desugar; not(?x)})))> ast';
+	      position' := <position-of-term({?_{a*}; <one(?MARKER())> a*})> ast''
+	   
+	  at-position(s|position):
+	    c#(t*) -> t'
+	    where
+	      !position => [i | position']
+	    where
+	      t' := c#(<at-index(at-position(s|position'))> (i, t*))
+	
+	  at-position(s|position):
+	    t -> t'
+	    where
+	      !position => [];
+	      t' := <s> t
+	
+	  position-of-term(is-term):
+	    t -> []
+	    where
+	      is-term
+	  
+	  position-of-term(is-term):
+	    _#(t*) -> <position-of-term(is-term|0)> t*
+	  
+	  position-of-term(is-term|start-index):
+	    [t | t*] -> position  
+	    where
+	      if i* := <position-of-term(is-term)> t then
+	        position := [start-index | i*]
+	      else
+	        position := <position-of-term(is-term | <inc> start-index)> t*
+	      end
+	
+	  term-at-position(|position):
+	    t -> t'
+	    where 
+	      at-position(?t'|position) 
+	
+	  parent-at-position(|position):
+	    t -> t'
+	    where
+	      !position => [i, _];
+	      t' := <subterm-at(|i)> t
+	  
+	  parent-at-position(|position):
+	    t -> <parent-at-position(|position')> t'
+	    where
+	      !position => [i | position' @ [_, _ | _]];
+	      t' := <subterm-at(|i)> t
+	
+	  subterm-at(|index):
+	    _#(t*) -> <index(|<inc> index)> t*
+	  
+	
+	strategies
+	  
+	  // Set markers for a given file. Use when checking files from a queued strategy.
+	  // Current term: (ast-desugared, errors, warnings, notes) tuple
+	  // ast: the root node of the file to set markers on 
+	  set-markers(|ast) = prim("SSL_EXT_set_markers", ast)
+	
+	  // Indicate that one or more files need analysis. 
+	  // Current term: ss a list of absolute file paths, or a single absolute file path to analyze
+	  queue-analysis = 
+	       (is-list; list-loop(queue-analysis))
+	    <+ prim("SSL_EXT_queue_analysis") 
+	
+	  // Set the total number of work units to complete. Can be called multiple times. 
+	  // Current term: number of work units (int).
+	  set-total-work-units = prim("SSL_EXT_set_total_work_units")
+	  
+	  // Complete one work unit and update progress monitors.
+	  // Current term: ignored
+	  complete-work-unit = prim("SSL_EXT_complete_work_unit")
+	  
+	  // Queue a strategy for background processing with a progress indicator.
+	  // Current term: the term to pass to the background strategy
+	  // s: the strategy, as string
+	  // description: name of the task (will be shown in progress view)
+	  queue-strategy(|s,description) = prim("SSL_EXT_queue_strategy", s, description)
+	  
+	  // Return the result of this strategy to indicate a non-completed (backgrounded) analysis.
+	  // Editor services (hover, resolve) will be delayed until a complete analysis is performed. 
+	  set-analysis-backgrounded = !"BACKGROUNDED"
+	
+	signature constructors
+	
+	  COMPLETION : String -> Term
+	  NOCONTEXT  : Term   -> Term
+	  MARKER     : Term
+	
+	  // Below are copies of the signatures of the terms used in example
+	  // trans/test.str file. These definitions should also be automatically 
+	  // generated in the imported include/Test.str module. However,
+	  // to ensure that the example transformation doesn't break when the
+	  // syntax is changed, we also hard-coded them here.
+	          
+	  Module   : ID * List(Entity)   -> Module
+	  Entity   : ID * List(Property) -> Entity
+	  Property : ID * Type           -> Property
+	  Type     : ID                  -> Type   
+	   

Added: spoofax-contrib/LwcSPXLang/src/lib/lwc-common.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/src/lib/lwc-common.spx	Tue Jun 21 00:36:02 2011	(r23072)
@@ -0,0 +1,66 @@
+package languages.spx.lwc
+
+module common-strategies
+	imports 
+		languages.commonLang 
+
+	rules 
+		// Prints the abstract syntax ATerm of a selection.
+  	generate-aterm:
+    	(selected, position, ast, path, project-path) -> (filename, result)
+   	  with
+      	filename := <guarantee-extension(|"aterm")> path;
+      	result   := selected // we just return the input term
+      
+  	// todo: reusable resolve strategy for imports
+       
+  	// todo: factor out parse caching strategy
+  
+		parse-lwc-file(|path) =
+  		resolve-import(|path); parse-lwc-file 
+
+ 		parse-lwc-file-cached =
+   		 parse-lwc-file-cached(|<CurrentFile>)
+  	  	
+  	parse-lwc-file-cached(|path) =
+  			parse-file-cached(resolve-import(|path), parse-lwc-file)
+
+  	resolve-import(|modpath) :
+  			x -> $[[<project-path>]/[<dirname> modpath]/[x].lwc]
+  	
+  	// lookup module in same module as importing module
+  	// todo: this can be more sophisticated involving search paths
+  	  
+  	parse-file-cached(resolve-path, parse-file) :
+  		name -> ast
+  		where
+  	  	path       := <resolve-path> name;
+      	cache-path := <import-cache-path> path;
+      	debug(!"  cache-path: ");
+      	if <is-newer> (cache-path, path) then
+	        ast := <ReadFromFile> cache-path
+      	else
+        	ast := <parse-file> path;
+        	if <file-exists> path then
+          	// Only cache if on filesystem (e.g., ignore libstratego-lib)
+          	<WriteToBinaryFile> (cache-path, ast)
+        	end
+      	end
+
+  	open-import-lwc(resolve-path, parse-file, record-declarations):
+    	import -> import
+    	where
+      	if not(!import => COMPLETION(_)) then
+      		path := <resolve-path> import;
+        	if not(<IsImported> path) then
+          	debug(!"  not imported: ");
+          	rules( IsImported: path );
+          	ast := <parse-file-cached(resolve-path, parse-file)> import;
+          	{| CurrentFile:
+            	rules(CurrentFile := path);
+            	<record-declarations> ast
+          	|}
+        	else
+          	debug(!"  already imported: ")
+        	end
+      	end

Added: spoofax-contrib/LwcSPXLang/src/lib/namespace.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/src/lib/namespace.spx	Tue Jun 21 00:36:02 2011	(r23072)
@@ -0,0 +1,295 @@
+package languages.commonLang
+	
+	module namespacelib 
+	
+		signature constructors
+			name:  String -> Annotation
+			scope: String -> Annotation
+			
+			IncludedBy: Namespace -> Namespace
+			Including:  Namespace -> Namespace
+			
+		rules // scoped renaming
+			
+			// todo: new-scope should have namespace as parameter
+			
+			/**
+			* executes the renaming strategy s in a new scope
+			* 
+			* declarations inside the new scope will hide existing declarations outside the new scope
+			* multiple declarations with the same name inside the new scope will be renamed to the same name
+			*
+			* @param renaming strategy s: a -> b
+			* @type a -> b
+			*/
+			new-scope(s) :
+				x -> y
+				where
+					<newname> x => scope ;
+					{| Renamed, RenamedInScope, CurrentScope, Scope:
+						rules (
+							CurrentScope: () -> scope
+							Scope:+ x -> scope
+						) ;
+						<s> x => y
+					|}
+					
+			/**
+			* annotates the current term with a fresh name
+			* can distinguish different namespaces
+			* remembers the renaming by storing two dynamic rules
+			* 
+			* multiple calls on the same term inside the same scope will give identical results
+			* calls inside a new scope will hide the results of calls to the same term from outer scopes
+			*
+			* @param namespace 
+			* @type a -> a
+			*/
+			rename-declaration(|namespace) : 
+				x -> x'
+				where 
+					<CurrentScope> () => scope ;
+					(
+						<RenamedInScope> (namespace, scope, x) => x' <+
+						x' := x{name(<newname> x)}
+					)
+				where rules(
+					RenamedInScope: (namespace, scope, x) -> x' 
+					Renamed: (namespace, x) -> x'
+				)
+			
+			/**
+			* annotates the current term with a new name
+			* succeeds only if rename-declaration was called before on the same term
+			* will use the same name as rename-declaration (by calling the dynamic rule stored by rename-declaration)
+			*
+			* @param namespace 
+			* @type a -> b
+			*/
+			rename-reference(|namespace) :
+				x -> x'
+				where
+					<Renamed> (namespace, x) => x'
+		
+		rules // annotate scope
+			
+			annotate-scope(s) : x -> x{scope(scope)} where project-scope(s) => scope
+			
+		rules // store declarations and references
+			
+			new-analysis(s) = {| Declared, Referred, Including, IncludedBy: s |}
+			
+			//CurrentFile = fail
+				
+			/**
+			* stores a mapping from a name to a declaration
+			* can distinguish different namespaces
+			* remembers the mapping by storing a dynamic rule
+			*
+			* @param namespace
+			* @type (a, b) -> b
+			*/
+			map-declaration(|namespace) :
+				(x, d) -> d
+				where 
+				  //file := <CurrentFile>;
+				  rules(
+					//Declared :+ (namespace, x) -> (file, d)
+					Declared :+ (namespace, x) -> d
+				  )
+				
+			map-declaration = map-declaration(|<get-annotated-scope>)
+			
+			/**
+			* stores the usage of a reference
+			* can distinguish different namespaces
+			* remembers the reference by storing a dynamic rule
+			*
+			* @param namespace
+			* @type a -> a
+			*/
+			store-reference(|namespace) :
+				x -> x
+				where rules (
+					Referred:+ (namespace, x) -> x
+				)
+		
+			store-reference = store-reference(|<get-annotated-scope>)
+			
+		rules // include namespaces
+			
+			/**
+			*
+			* example: 
+			*     store: Class(c, Parent(p), _, _) -> <id> 
+			*         where 
+			*             <store-declaration(|Classes())> c ; 
+			*             <namespace-inclusion(|Fields(c))> Fields(p) ;
+			*             <namespace-inclusion(|Methods(c))> Methods(p) 
+			*/
+			namespace-inclusion(|namespace) : 
+				included -> included
+				where rules (
+					IncludedBy:+ included -> namespace
+					Including:+ namespace -> included
+				)
+						
+		strategies // access scopes
+			
+			get-scopes = all-keys-Scope  // efficiency?
+			
+			get-scopes(s) = get-scopes ; filter(where(s))
+			
+			get-scope(s) = get-scopes ; fetch-elem(where(s))
+			
+			project-scopes(s) = get-scopes ; filter(s)
+			
+			project-scope(s) = get-scopes ; fetch-elem(s)
+			
+			in-scope(s) = where(get-scope(s))
+			
+			get-annotated-scope = get-annos ; fetch-elem(?scope(<id>))
+			
+		strategies // access inclusions
+			
+			get-included-namespaces  = get-inclusions(bagof-Including)
+			
+			get-including-namespaces = get-inclusions(bagof-IncludedBy)
+			
+			get-inclusions(s) = ![<id>] ; get-inclusions(s|[]) ; reverse 
+			
+			get-inclusions(s|temps): [] -> temps
+			 
+			get-inclusions(s|temps): 
+				[space|spaces] -> <get-inclusions(s|temps)> spaces
+				where <elem> (space, temps)
+				
+			get-inclusions(s|temps):  
+				[space|spaces] -> <get-inclusions(s|temps')> spaces
+				where
+					<s> space ;
+					get-inclusions(s|[space|temps]) => temps'
+		
+			resolve-included = ?IncludedBy(<get-included-namespaces>) <+ ?Including(<get-including-namespaces>) <+ ![<id>]
+				
+		strategies // access declarations
+			
+			/**
+			* maps a name to its declarations
+			* can distinguish different namespaces
+			* remembers the mapping by calling a dynamic rule
+			*
+			* @param namespace
+			* 
+			* @type a -> List(b)
+			*/
+			get-declarations(|namespace) = ?x ; <resolve-included> namespace ; mapconcat(!(<id>, x) ; bagof-Declared)
+			
+			/**
+			* succeeds if the current term can be mapped to a declaration
+			* can distinguish different namespaces
+			* 
+			* @param namespace
+			* 
+			* @type a -> a
+			*/
+			is-declared(|namespace) = where(get-declarations(|namespace) ; ?[_|_])
+			
+			/**
+			* maps a name to its only declaration
+			* can distinguish different namespaces
+			* 
+			* @param namespace
+			*/
+			get-unique-declaration(|namespace) = get-declarations(|namespace) ; ?[<id>]
+			
+			/**
+			* maps a name to its first declaration
+			* can distinguish different namespaces
+			* 
+			* @param namespace
+			*/
+			get-declaration(|namespace) = project-declaration(id|namespace) 
+			
+			/**
+			* maps a name to its first declaration for which strategy s holds
+			* can distinguish different namespaces
+			* 
+			* @param s: b -> c
+			* @param namespace
+			* 
+			* @type a -> b
+			*/
+			get-declaration(s|namespace) = project-declaration(where(s)|namespace)
+			
+			/**
+			* maps a name to its declarations for which strategy s holds
+			* can distinguish different namespaces
+			* 
+			* @param s: b -> c
+			* @param namespace
+			* 
+			* @type a -> List(b)
+			*/
+			get-declarations(s|namespace) = project-declarations(where(s)|namespace)
+		
+		strategies // project declarations
+			
+			/**
+			* maps a name to the first projection of its declarations
+			* can distinguish different namespaces
+			* 
+			* @param s: b -> c
+			* @param namespace
+			* 
+			* @type a -> c
+			*/
+			project-declaration(s|namespace) = debug(!"project-declarations: ");
+			  get-declarations(|namespace) ; debug(!" declarations: ") ;
+			  fetch-elem(s) 
+		
+			/**
+			* maps a name to the projections of its declarations
+			* can distinguish different namespaces
+			* 
+			* @param s: b -> c
+			* @param namespace
+			* 
+			* @type a -> List(c)
+			*/
+			project-declarations(s|namespace) = get-declarations(|namespace) ; filter(s) 
+			
+		strategies // access all declarations
+			
+			get-all-declarations(|namespace) = 
+				<resolve-included> namespace => spaces ; 
+				all-keys-Declared ; 
+				filter(where( (id, !spaces) ; elem )) ;
+				mapconcat(bagof-Declared)
+			
+			get-all-declarations(s|namespace) = project-all-declarations(where(s)|namespace) 
+		
+			project-all-declarations(s|namespace) = get-all-declarations(|namespace) ; filter(s) 
+			 
+		strategies // access references
+		
+			get-references(|namespace) = ?x ; <resolve-included> namespace ; mapconcat(!(<id>, x) ; bagof-Referred)
+			
+			is-referred(|namespace) = get-references(|namespace) ; ?[_|_]
+		
+		strategies	
+			
+			get-proposal-candidates(|namespace) = all-keys-Renamed ; filter(?(namespace, _) ; Renamed)
+			
+			store-proposal-candidates(|namespace) = get-proposal-candidates(|namespace) ; store-proposals
+			
+			store-proposals = ?x ; where (rules ( Propose : () -> x ))
+			
+			get-proposals = ( <Propose> () ; map(rm-annotations) ) <+ ![]
+			
+			get-proposals(s|namespace) = 
+				( 
+					<Propose> () ; 
+					filter(where( get-declaration(s|namespace) )) ; 
+					map(rm-annotations) 
+				) <+ ![]

Added: spoofax-contrib/LwcSPXLang/src/lib/refactor-common.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/src/lib/refactor-common.spx	Tue Jun 21 00:36:02 2011	(r23072)
@@ -0,0 +1,62 @@
+package languages.commonLang
+	module refactor-common
+		strategies //transformation
+		
+		/**
+		 * Replaces elements in a list (once, starting from the right)
+		 * @param match strategy for partial list
+		 * @param new elements List(b)
+		 * @type List(a) -> List(a,b)
+		 */
+		replace-sublist(match-sublist|new-elems): 
+		  list -> <
+		    at-suffix(match-sublist;!new-elems) <+
+		    (
+		      init; 
+		      replace-sublist(match-sublist|new-elems);
+		      at-end(![<last> list])
+		    )
+		  > list 
+		
+		/**
+		 * Inserts an element at a given AST position
+		 * @param List(Int), denoting an AST position
+		 * @param inserted list element 
+		 * @type Term -> Term
+		 */
+		insert-elem(|pos, elem)=
+		  insert-sublist(|pos, [elem])
+		
+		/**
+		 * Inserts a list of elements at a given AST position
+		 * @param List(Int), denoting an AST position
+		 * @param inserted list elements 
+		 * @type Term -> Term
+		 */	
+		insert-sublist(|pos, elems)=
+		  at-position(
+		    split-at(|<last> pos);
+		    ?(prefix, suffix);
+		    <concat>[prefix, elems, suffix]
+		    |<init> pos
+		  )
+		
+		
+		strategies //user-input
+		
+		/**
+		 * Opens an input dialog for one string value that represents an identifier
+		 * The language is used to check if the input value matches the identifier pattern
+		 * @type (String, String, String, String) -> String
+		 */
+		input-dialog:
+		  (language, title, label, default-value) -> <prim("SSL_EXT_newnamedialog", language, title, label, default-value)>
+		  
+		input-dialog:
+		  (title, label, default-value) -> <input-dialog>("", title, label, default-value)
+		
+		strategies //pp-table
+			
+		get-pp-table=
+		  import-term(include/LWC.generated.pp.af)
+			

Added: spoofax-contrib/LwcSPXLang/src/main.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/src/main.spx	Tue Jun 21 00:36:02 2011	(r23072)
@@ -0,0 +1,55 @@
+package languages.spx.lwc
+
+module main-definition
+  context-free syntax
+    Module  -> Start
+         
+
+module main-trans
+	imports 
+  	languages.commonLang
+  
+  strategies 
+	  pp = fail	       
+	
+	strategies // analysis
+
+	  analyze     = desugar-all; rename-all; store-all 
+	  desugar-all = innermost(desugar)
+	  rename-all  = alltd(propose <+ rename)
+	  store-all   = topdown(try(store)) ; topdown(try(store-ref))
+	   
+	  desugar   = fail
+	  rename    = fail
+	  propose   = fail
+	  store     = fail
+	  store-ref = fail
+	  
+	  type-of = fail
+	  type-compatible = fail
+	 
+	rules // editor
+	  
+  	importing(|imp) = /*{| Imported : */ rules(Imported : imp) /* ; s |} */
+	
+	  when-not-imported(s) :
+	  	imp -> imp
+	  	where {| Imported : if not( <Imported> imp ) then rules(Imported : imp) else debug(!"already imported: ") end |} 
+		
+		analyze-builder :
+	    (selected, position, ast, path, project-path) -> (filename, result)
+	    with
+	      editor-init;
+	      rules( CurrentFile := path);
+	      importing(|Imports(<base-filename; remove-extension> path));
+	      <analyze> ast => ast';
+	      filename := <guarantee-extension(|"aterm")> path;
+	      result   := ast' // we just return the input term
+		
+rules	 			
+	  editor-error   = fail  
+	  editor-warning = fail
+	  editor-note    = fail
+		resolve = fail
+  	hover = fail
+  	propose = fail
\ No newline at end of file

Added: spoofax-contrib/LwcSPXLang/src/services/editor/analyze.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/src/services/editor/analyze.spx	Tue Jun 21 00:36:02 2011	(r23072)
@@ -0,0 +1,18 @@
+package languages.spx.lwc
+
+module analyze-service
+	imports 
+  	languages.commonLang
+ 
+	rules
+		editor-analyze:
+	    (ast, path, project-path) -> (ast', errors, warnings, notes)
+	    with
+	      editor-init;
+	      rules( CurrentFile := path );
+		  <analyze> ast => ast';
+	      <collect-all(editor-error,   conc)> ast' => errors;
+	      <collect-all(editor-warning, conc)> ast' => warnings;
+	      <collect-all(editor-note,    conc)> ast' => notes
+
+ 
\ No newline at end of file

Added: spoofax-contrib/LwcSPXLang/src/services/editor/coloring.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/src/services/editor/coloring.spx	Tue Jun 21 00:36:02 2011	(r23072)
@@ -0,0 +1,39 @@
+
+package languages.spx.lwc
+
+module codecolorer-service
+
+	colorer 
+		ID :  85 85 85 italic 
+		
+	colorer Default, token-based highlighting
+	                                  
+	  keyword    : 127 0 85 bold      
+	  identifier : default            
+	  string     : blue               
+	  number     : darkgreen          
+	  var        : 255 0 100 italic   
+	  operator   : 0 0 128            
+	  layout     : 63 127 95 italic   
+
+	colorer System colors
+	                            
+	  darkred   = 128 0 0       
+	  red       = 255 0 0       
+	  darkgreen = 0 128 0       
+	  green     = 0 255 0       
+	  darkblue  = 0 0 128       
+	  blue      = 0 0 255       
+	  cyan      = 0 255 255     
+	  magenta   = 255 0 255     
+	  yellow    = 255 255 0     
+	  white     = 255 255 255   
+	  black     = 0 0 0         
+	  gray      = 128 128 128   
+	  grey      = gray          
+	  orange    = 255 165 0      
+	  pink      = 255 105 180   
+	  brown     = 139 69 19     
+	  default   = _            
+  
+	
\ No newline at end of file

Added: spoofax-contrib/LwcSPXLang/src/services/editor/hover.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/src/services/editor/hover.spx	Tue Jun 21 00:36:02 2011	(r23072)
@@ -0,0 +1,7 @@
+package languages.spx.lwc
+
+module hover-service 
+	rules
+  	editor-hover: 
+  		(node, position, ast, path, project-path) -> str
+    		where <hover> node => str

Added: spoofax-contrib/LwcSPXLang/src/services/editor/outliner.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/src/services/editor/outliner.spx	Tue Jun 21 00:36:02 2011	(r23072)
@@ -0,0 +1,3 @@
+package languages.spx.lwc
+
+module outline-service
\ No newline at end of file

Added: spoofax-contrib/LwcSPXLang/src/services/editor/proposer.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/src/services/editor/proposer.spx	Tue Jun 21 00:36:02 2011	(r23072)
@@ -0,0 +1,18 @@
+package languages.spx.lwc 
+
+module codecompletion-service 
+	imports languages.commonLang
+	
+	rules 
+		editor-complete:
+			(node, position, ast, path, project-path) -> proposals
+    	where
+      	editor-init ; 
+      	rules( CurrentFile := path );
+      	<analyze> ast => ast' ;
+	  		<oncetd(where(propose => proposals))> ast' <+
+	  		<debug> ast ; ![] => proposals  	
+
+	completions
+	  completion proposer                  : editor-complete
+	  completion trigger                   : ":"

Added: spoofax-contrib/LwcSPXLang/src/services/editor/resolver.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/src/services/editor/resolver.spx	Tue Jun 21 00:36:02 2011	(r23072)
@@ -0,0 +1,9 @@
+package languages.spx.lwc
+
+module resolve-service
+	rules
+			editor-resolve: 
+    	(node, position, ast, path, project-path) -> target
+    	where 
+      	<resolve> node => target 
+ 
\ No newline at end of file

Added: spoofax-contrib/LwcSPXLang/src/services/syntax-prop.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/src/services/syntax-prop.spx	Tue Jun 21 00:36:02 2011	(r23072)
@@ -0,0 +1,26 @@
+package languages.spx.lwc 
+
+
+module commonsyntax  
+	
+	language Syntax properties (static defaults)
+	                                           
+	  // Comment constructs:                   
+	  line comment                           : "//"
+	  block comment                          : "/*" * "*/"
+	                                           
+	  // Fences (used for matching,            
+	  // inserting, indenting brackets):       
+	  fences                                 : [ ]
+	                                           ( )
+	                                           { }
+	                                           
+	  // Automatic indent hints                
+	  // (indent after these tokens):          
+	  indent after                           : "="
+	                                           ":"
+	                                           
+	  // Regular expression for identifiers:   
+	  identifier lexical                     : "[A-Za-z0-9_]+"
+  
+

Added: spoofax-contrib/LwcSPXLang/test/example.lwx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/test/example.lwx	Tue Jun 21 00:36:02 2011	(r23072)
@@ -0,0 +1,8 @@
+module example
+
+
+entity C {
+  a : A
+  b : C 
+} 
+             
\ No newline at end of file

From M.A.Akhter at student.tudelft.nl  Tue Jun 21 02:38:43 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Tue, 21 Jun 2011 00:38:43 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23073 -
	spoofax-contrib/LwcSPXLang
Message-ID: <20110621003843.563137F8007@mx1.tudelft.nl>

Author: MdAdilAkhter
Date: Tue Jun 21 00:38:43 2011
New Revision: 23073
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23073&sc=1

Log:


Added:
   spoofax-contrib/LwcSPXLang/readme.txt

Added: spoofax-contrib/LwcSPXLang/readme.txt
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/readme.txt	Tue Jun 21 00:38:43 2011	(r23073)
@@ -0,0 +1 @@
+Note : Please invoke the "Build-all" builder to generate all the artifacts before starting ant build.
\ No newline at end of file

From M.A.Akhter at student.tudelft.nl  Tue Jun 21 02:51:15 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Tue, 21 Jun 2011 00:51:15 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23074 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen
Message-ID: <20110621005115.0EC4C2B8043@mx2.tudelft.nl>

Author: MdAdilAkhter
Date: Tue Jun 21 00:51:14 2011
New Revision: 23074
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23074&sc=1

Log:


Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/buildscripts.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/buildscripts.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/buildscripts.str	Tue Jun 21 00:38:43 2011	(r23073)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/buildscripts.str	Tue Jun 21 00:51:14 2011	(r23074)
@@ -42,7 +42,6 @@
 		<!-- prject directories -->
     <property name="trans" location="trans"/>
     <property name="src-gen" location="editor/java"/>
-    <property name="syntax" location="syntax"/>
     <property name="include" location="include"/>
     <property name="lib" location="lib"/>
     <property name="build" location="bin"/> 
@@ -171,9 +170,8 @@
   <mkdir dir="${dist}"/>
   <mkdir dir="${include}"/>
   <mkdir dir="${lib}"/>
-  <mkdir dir="${syntax}"/>
-
-	<target name="init" if="eclipse.running">
+  
+  <target name="init" if="eclipse.running">
 	  <!-- refresh one file/dir in the project to trigger an Ant rebuild with the next build command -->
 	  <java classname="org.strategoxt.imp.metatooling.building.AntForceRefreshScheduler" failonerror="false">
 	      <arg value="${include}"/>
@@ -325,7 +323,7 @@
 	<target name="ppgen" if="build.stratego.enabled" depends="pack-sdf">
 	  <dependset>
 	      <srcfileset    file="${include}/${package.name}.def"/>
-	      <targetfileset file="${syntax}/${package.name}.generated.pp"/>
+	      <targetfileset file="${include}/${package.name}.generated.pp"/>
 	      <targetfileset file="${include}/${package.name}.generated.pp.af"/>
 	  </dependset>
 	  <available file="${include}/${package.name}.generated.pp.af" property="ppgen.available"/>

From M.A.Akhter at student.tudelft.nl  Tue Jun 21 03:13:42 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Tue, 21 Jun 2011 01:13:42 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23075 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/esv
Message-ID: <20110621011342.C7C8B2B803C@mx2.tudelft.nl>

Author: MdAdilAkhter
Date: Tue Jun 21 01:13:42 2011
New Revision: 23075
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23075&sc=1

Log:
FIXed issue reported by Tvo

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/esv/declare.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/esv/declare.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/esv/declare.str	Tue Jun 21 00:51:14 2011	(r23074)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/esv/declare.str	Tue Jun 21 01:13:42 2011	(r23075)
@@ -10,7 +10,7 @@
 rules 
 	resolve-sdf-sort-declaration = 
  		?symbol; 
- 		<resolve-symbol-unique-declaration(all-keys-SortDeclaration , bagof-SortDeclaration)><to-scoped-symbol>symbol 
+ 		<resolve-symbol-declarations(all-keys-SortDeclaration , bagof-SortDeclaration)><to-scoped-symbol>symbol 
  	<+
  		<debug-analysis> $[ErrorChecking|Failed to retrive SDF Sort for symbol [<pp-aterm>]];
  		fail

From M.A.Akhter at student.tudelft.nl  Tue Jun 21 04:06:27 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Tue, 21 Jun 2011 02:06:27 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23076 -
	spoofax-contrib/LwcSPXLang/src/langdef
Message-ID: <20110621020627.3F319CC218@mx4.tudelft.nl>

Author: MdAdilAkhter
Date: Tue Jun 21 02:06:26 2011
New Revision: 23076
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23076&sc=1

Log:


Modified:
   spoofax-contrib/LwcSPXLang/src/langdef/entities.spx
   spoofax-contrib/LwcSPXLang/src/langdef/properties.spx

Modified: spoofax-contrib/LwcSPXLang/src/langdef/entities.spx
==============================================================================
--- spoofax-contrib/LwcSPXLang/src/langdef/entities.spx	Tue Jun 21 01:13:42 2011	(r23075)
+++ spoofax-contrib/LwcSPXLang/src/langdef/entities.spx	Tue Jun 21 02:06:26 2011	(r23076)
@@ -1,9 +1,9 @@
 package languages.spx.lwc
-
+
 module entity-definition
 	imports languages.commonLang
 	
-	 context-free syntax 
+	context-free syntax 
   	Entity                          -> Definition
     "entity" ID "{" EntityElem* "}" -> Entity {cons("Entity")}
     ID                              -> Type {cons("Type")}
@@ -11,4 +11,73 @@
     "this"                          -> Exp {cons("This")}
   	"this"                          -> ID {reject}
 
+module entity-constructors
+	signature constructors 
+		Entities   : Namespace
+		
+			
+module entity-trans
+	imports languages.commonLang
+	
+	rules // entity declarations
+	
+ 		is-entity = ?Entity(_,_)
+
+	  name-of : 
+	  	Entity(name, elems) -> name
+
+	  type-of :
+	  	Entity(name, elems) -> Type(name)
+
+	  rename :
+	  	d at Entity(name, prop1*) -> d'
+	  	where new-scope( <all(rename-all)> d => d' )
+	  	
+	  store :
+	  	d at Entity(name, prop*) -> d
+	  	where <map-declaration(|Entities())> (name, d)
+	  	
+	  editor-error:
+	    Entity(name, _) -> (name, $[Multiple declarations for entity [name]])
+	    where not ( <get-unique-declaration(|Entities())> name )
+	    
+	  editor-warning:
+	  	Entity(name, _) -> (name, $[Entity [name] is never used])
+	  	where not( <is-referred(|Entities())> name )
+  	    
+	rules // types
+	
+	  store :
+	  	t at Type(name) -> t
+	  	where <store-reference(|Entities())> name
+	  	
+	  editor-error :
+	  	t at Type(name) -> (name, $[Type [name] is not declared.])
+	  	where not(<is-declared(|Entities())> name)
+	  	
+	  resolve :
+	  	Type(name) -> d
+	  	where <project-declaration(is-entity | Entities()); name-of> name => d
+	  	
+	  type-compatible :
+	  	p@(type, type) -> p
+	  	
+	  propose :
+	  	type at Type(COMPLETION(_)) -> proposals
+	  	where <project-all-declarations(?Entity(<id>,_)|Entities())> type => proposals
+	  		
+	rules // this
+		
+	  rename :
+	  	e at This() -> <annotate-scope(is-entity; name-of)> e
+		
+	  type-of :
+	  	This() -> Type(<get-annotated-scope>)
+  		
+	
+	
+
+	
+	
+	
 	
\ No newline at end of file

Modified: spoofax-contrib/LwcSPXLang/src/langdef/properties.spx
==============================================================================
--- spoofax-contrib/LwcSPXLang/src/langdef/properties.spx	Tue Jun 21 01:13:42 2011	(r23075)
+++ spoofax-contrib/LwcSPXLang/src/langdef/properties.spx	Tue Jun 21 02:06:26 2011	(r23076)
@@ -1,10 +1,51 @@
 package languages.spx.lwc
-
+
 module property-definition
 	imports languages.commonLang
-	
 	context-free syntax
 	  Property    -> EntityElem 
     ID ":" Type -> Property {cons("Property")}
   	Exp "." ID  -> Exp {cons("PropertyAccess")}
-	
\ No newline at end of file
+
+
+module property-constructors 
+	signature 
+  	constructors
+	  	Entities   : Namespace
+	  	Properties : String -> Namespace
+
+module property-trans
+	imports languages.commonLang
+	
+	rules // property declarations 
+	 
+	  name-of: 
+	  	Property(name, type) -> name
+	  	
+	  type-of :
+	  	Property(name, type) -> type
+	
+	  rename: 
+	  	d at Property(name, type) -> <annotate-scope(is-entity; name-of)> d 
+	  
+	  store:
+	  	d at Property(name, type) -> d
+	  	where <map-declaration(|Properties(<get-annotated-scope> d))> (name, d)
+	  
+	  editor-error:
+	    d at Property(name, _) -> (name, $[Multiple declarations for property [name]])
+	    where not ( <get-unique-declaration(|Properties(<get-annotated-scope> d))> name )
+
+	rules // property access
+	
+	   type-of :
+	   	 PropertyAccess(e, name) -> <type-of> d
+	   	 where debug(!"type-of property access: "); <type-of> e => type;  debug(!"  type of e:");
+	   	       <get-declaration(|Properties(<resolve; debug(!"resolved: ")> type))> name => d
+	   	       ; debug(!"  declaration: ")
+	   	 
+	   editor-error :
+	   	 e at PropertyAccess(e', name) -> (name, $[[<pp>type] does not have a property [name]])
+	   	 where <type-of> e' => type; not( <type-of> e )
+
+		
\ No newline at end of file

From M.A.Akhter at student.tudelft.nl  Tue Jun 21 04:11:04 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Tue, 21 Jun 2011 02:11:04 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23077 -
	spoofax-contrib/LwcSPXLang/src/langdef
Message-ID: <20110621021104.18156108C007@mx3.tudelft.nl>

Author: MdAdilAkhter
Date: Tue Jun 21 02:11:03 2011
New Revision: 23077
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23077&sc=1

Log:


Added:
   spoofax-contrib/LwcSPXLang/src/langdef/arithmetic.spx
Modified:
   spoofax-contrib/LwcSPXLang/src/langdef/entities.spx
   spoofax-contrib/LwcSPXLang/src/langdef/properties.spx

Added: spoofax-contrib/LwcSPXLang/src/langdef/arithmetic.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/src/langdef/arithmetic.spx	Tue Jun 21 02:11:03 2011	(r23077)
@@ -0,0 +1,41 @@
+package languages.spx.lwc
+
+module arithmetic-definition
+	imports languages.commonLang
+	
+	context-free syntax
+  	INT         -> Exp {cons("Int")}
+  	STRING      -> Exp {cons("String")}
+  	Exp "+" Exp -> Exp {cons("Plus"),assoc}
+  	Exp "*" Exp -> Exp {cons("Times"),assoc}
+  context-free priorities
+  	Exp "*" Exp -> Exp
+  	>
+  	Exp "+" Exp -> Exp
+
+module arithmetic-transformation
+	rules
+		type-of :
+	  	String(x) -> Type("String")
+	  	where debug(!"type-of string: ") 
+	  	
+	  type-of :
+	  	Int(x) -> Type("Int")
+	   
+	  type-of : 
+	  	Plus(e1, e2) -> Type("Int") 
+	  	where <type-of> e1 => Type("Int");
+	  	      <type-of> e2 => Type("Int")
+	  	      
+	  type-of : 
+	  	Times(e1, e2) -> Type("Int")
+	  	where <type-of> e1 => Type("Int");
+	  	      <type-of> e2 => Type("Int")
+	
+	  editor-error :
+	  	e at Plus(e1, e2) -> (e, $[Arguments should be of type Int])
+	  	where <type-of> e1; <type-of> e2; not(<type-of>e)
+	  	 	      
+	  editor-error :
+	  	e at Times(e1, e2) -> (e, $[Arguments should be of type Int])
+	  	where <type-of> e1; <type-of> e2; not(<type-of>e)

Modified: spoofax-contrib/LwcSPXLang/src/langdef/entities.spx
==============================================================================
--- spoofax-contrib/LwcSPXLang/src/langdef/entities.spx	Tue Jun 21 02:06:26 2011	(r23076)
+++ spoofax-contrib/LwcSPXLang/src/langdef/entities.spx	Tue Jun 21 02:11:03 2011	(r23077)
@@ -16,7 +16,7 @@
 		Entities   : Namespace
 		
 			
-module entity-trans
+module entity-transformations
 	imports languages.commonLang
 	
 	rules // entity declarations

Modified: spoofax-contrib/LwcSPXLang/src/langdef/properties.spx
==============================================================================
--- spoofax-contrib/LwcSPXLang/src/langdef/properties.spx	Tue Jun 21 02:06:26 2011	(r23076)
+++ spoofax-contrib/LwcSPXLang/src/langdef/properties.spx	Tue Jun 21 02:11:03 2011	(r23077)
@@ -14,7 +14,8 @@
 	  	Entities   : Namespace
 	  	Properties : String -> Namespace
 
-module property-trans
+module property-transformations
+
 	imports languages.commonLang
 	
 	rules // property declarations 

From M.A.Akhter at student.tudelft.nl  Tue Jun 21 04:14:12 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Tue, 21 Jun 2011 02:14:12 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23078 -
	spoofax-contrib/LwcSPXLang/src/langdef
Message-ID: <20110621021412.924E7108C007@mx3.tudelft.nl>

Author: MdAdilAkhter
Date: Tue Jun 21 02:14:12 2011
New Revision: 23078
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23078&sc=1

Log:


Modified:
   spoofax-contrib/LwcSPXLang/src/langdef/expression.spx

Modified: spoofax-contrib/LwcSPXLang/src/langdef/expression.spx
==============================================================================
--- spoofax-contrib/LwcSPXLang/src/langdef/expression.spx	Tue Jun 21 02:11:03 2011	(r23077)
+++ spoofax-contrib/LwcSPXLang/src/langdef/expression.spx	Tue Jun 21 02:14:12 2011	(r23078)
@@ -11,4 +11,52 @@
   	"(" Exp ")" -> Exp {bracket}
 
     Exp "<" Exp -> Exp {cons("LT"),non-assoc}
+
+module expression-constructors
+	
+	imports languages.commonLang
+	
+	signature
+  	constructors
+  		Variables : Namespace
+
+module expression-transformations
+	imports languages.commonLang
+	
+	rules // variable declaration
+		
+	  type-of:
+	  	VarDecl(name, type) -> type
+		
+	  rename:
+	  	d at VarDecl(name, type) -> VarDecl(name', type)
+	  	where <rename-declaration(|Variables())> name => name'
+		
+	  store:
+	  	d at VarDecl(name, type) -> d
+	  	where <map-declaration(|Variables())> (name, d)
+	  	  
+	rules // variable reference
+		
+	  hover:
+	  	e -> $[Type: [<type-of; pp>e]] 
+		
+	  rename:
+	  	VarRef(name) -> VarRef(<rename-reference(|Variables())>name)
+	  	
+	  resolve:
+	  	VarRef(name) -> <debug(!"resolve: "); get-declaration(|Variables()); debug(!" declaration: ")> name
+	  	
+	  store:
+	  	e at VarRef(name) -> e
+	  	where <store-reference(|Variables())> name
+	  	
+	  type-of:
+	  	VarRef(name) -> type
+	  	where debug(!"type-of: "); <get-declaration(|Variables()); debug(!" decls: "); type-of> name => type
+	  	;debug(!"  type:")
+	  	
+	  editor-error :
+	  	VarRef(name) -> (name, $[Variable [name] not declared])
+	  	where not( <is-declared(|Variables())> name )
 	
\ No newline at end of file

From M.A.Akhter at student.tudelft.nl  Tue Jun 21 04:33:26 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Tue, 21 Jun 2011 02:33:26 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23079 - in
	spoofax-contrib/LwcSPXLang/src: . langdef
Message-ID: <20110621023326.CCD48108C045@mx3.tudelft.nl>

Author: MdAdilAkhter
Date: Tue Jun 21 02:33:25 2011
New Revision: 23079
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23079&sc=1

Log:


Modified:
   spoofax-contrib/LwcSPXLang/src/langdef/function.spx
   spoofax-contrib/LwcSPXLang/src/main.spx

Modified: spoofax-contrib/LwcSPXLang/src/langdef/function.spx
==============================================================================
--- spoofax-contrib/LwcSPXLang/src/langdef/function.spx	Tue Jun 21 02:14:12 2011	(r23078)
+++ spoofax-contrib/LwcSPXLang/src/langdef/function.spx	Tue Jun 21 02:33:25 2011	(r23079)
@@ -21,4 +21,130 @@
   	XmlElem -> Exp 
   
    
-	 
\ No newline at end of file
+module function-constructors	
+	signature
+  	constructors
+  		Functions  : Namespace
+  		Returns    : Scope -> Namespace
+
+module function-transformations
+	imports languages.commonLang
+	rules
+		
+	  pp : Type(name) -> name
+		
+	  pp-sig : (name, types) -> $[[name]([<pp-types>types])]
+	  	
+	  pp-types : [] -> ""
+	  pp-types : [type] -> <pp> type
+	  pp-types : [type1,type2|types] -> $[[<pp>type1],[<pp-types>[type2|types]]]
+
+	rules // function definitions
+	
+	  type-of :
+	  	FunctionDef(name, params, Some(type), bl) -> type
+	  	
+	  type-of :
+	    FunctionDef(name, params, None(), bl) -> Type("Void")
+	  	
+	  is-function-def = 
+	  	?FunctionDef(_,_,_,_)
+	  
+	  name-of :
+	  	FunctionDef(name, params, rt, bl) -> name
+	  	
+	  arg-types :
+	  	FunctionDef(name, params, rt, bl) -> <map(?Param(_,<id>))> params
+	  	
+	  signature-of :
+	  	FunctionDef(name, params, rt, bl) -> (name, <arg-types>)
+	  	
+	  rename :
+	  	d at FunctionDef(name, params, rt, bl) -> d'
+	  	where new-scope(<all(rename-all)> d => d')
+	  	
+	  store :
+	  	d at FunctionDef(name, params, rt, bl) -> d
+	  	where <debug(!"store: "); map-declaration(|Functions())> (<signature-of>d, d)
+	  	
+	  editor-error :
+	    d at FunctionDef(name, params, rt, bl) -> (name, $[Multiple declarations for function [name]])
+	    where not(<get-unique-declaration(|Functions())> <signature-of> d)
+	    
+	rules // function call
+	
+	  signature-of :
+	  	FunctionCall(name, args) -> (name, <debug(!" args: "); map(debug(!" arg: "); type-of; debug(!" type-of: "))>args)
+			
+	  type-of :
+	    call at FunctionCall(name, args) -> type
+	    where <signature-of> call => sig;
+	      <get-declaration(|Functions())> sig => decl;
+	      <type-of> decl => type
+		
+	  editor-error :
+	  	call at FunctionCall(name, args) -> (name, $[No definition for function [<pp-sig>sig]])
+	  	where <signature-of> call => sig; not( <get-declaration(|Functions())> sig )
+	
+	  resolve :
+	  	call at FunctionCall(name, args) ->	d
+	  	where 
+	  		<signature-of;debug(!" sig: ");get-declaration(|Functions())> call => d
+	  			
+	rules // parameters
+	
+	  type-of:
+	  	Param(name, type) -> type
+		
+	  rename: 
+	  	Param(name, type) -> <annotate-scope(id)> Param(<rename-declaration(|Variables())> name, type)
+	  	
+	  store:
+	  	d at Param(name, type) -> d
+	  	where <map-declaration(|Variables())> (name, d)
+	  	
+		rules // return type
+		
+	  type-of :
+	  	ReturnType(type) -> type
+		
+	  rename :
+	  	d at ReturnType(type) -> <annotate-scope(is-function-def)> d
+	  
+	  store :
+	  	d at ReturnType(type) -> d
+	  	where <map-declaration(|Returns(<get-annotated-scope>d))> ((), d)
+	  	
+	  return-type :
+	  	scope -> <get-declaration(|Returns(scope))> ()
+	
+	  editor-error:
+	  	d at ReturnType(type) -> (type, $[Return statement missing])
+	  	where not( <is-referred(|Returns(<get-annotated-scope>d))> () )
+	  	  	 	  
+	rules // return statement 
+	
+	  rename :
+	  	stat at Return(e) -> <annotate-scope(is-function-def)> Return(e')
+	  	where <rename-all> e => e'
+	  	  
+	  store :
+	  	stat at Return(e) -> stat
+	  	where <store-reference(|Returns(<get-annotated-scope>stat))> ()
+	  	
+	  type-of :
+	  	Return(e) -> <resolve; type-of>
+	  	
+	  resolve :
+	  	Return(e) -> <get-annotated-scope; return-type>
+	
+	  editor-error :
+	  	stat at Return(e) -> (e, $[Return should have type [<pp>type'], not [<pp>type]])
+	  	where <type-of> e => type;
+	  	      <type-of> stat => type';
+	  		  not( <type-compatible> (type, type') )
+	  		  
+	  editor-error :
+	  	stat at Return(e) -> (stat, $[No return statement expected])
+	  	where not( <resolve> stat )
+		
\ No newline at end of file

Modified: spoofax-contrib/LwcSPXLang/src/main.spx
==============================================================================
--- spoofax-contrib/LwcSPXLang/src/main.spx	Tue Jun 21 02:14:12 2011	(r23078)
+++ spoofax-contrib/LwcSPXLang/src/main.spx	Tue Jun 21 02:33:25 2011	(r23079)
@@ -1,5 +1,7 @@
 package languages.spx.lwc
 
+//TODO FIX : more refactoring on stratego codes 
+
 module main-definition
   context-free syntax
     Module  -> Start

From seba at informatik.uni-marburg.de  Tue Jun 21 11:44:13 2011
From: seba at informatik.uni-marburg.de (Sebastian Erdweg)
Date: Tue, 21 Jun 2011 09:44:13 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23080 - in
	sugarj/trunk/case-studies: . check concretesyntax editor
	editor/test latex latex/math regex xml xml/schema
Message-ID: <20110621094413.2BB867F8009@mx1.tudelft.nl>

Author: SebastianErdweg
Date: Tue Jun 21 09:44:12 2011
New Revision: 23080
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23080&sc=1

Log:
integrated latex case studies; various pending case study changes

Added:
   sugarj/trunk/case-studies/check/NoSugar.sugj
   sugarj/trunk/case-studies/editor/Editor.sugj
   sugarj/trunk/case-studies/editor/SpellChecking.sugj
   sugarj/trunk/case-studies/editor/test/
   sugarj/trunk/case-studies/editor/test/Sugar.sugj
   sugarj/trunk/case-studies/editor/test/Test.sugj
   sugarj/trunk/case-studies/latex/
   sugarj/trunk/case-studies/latex/Bibtex.sugj
   sugarj/trunk/case-studies/latex/Citations.sugj
   sugarj/trunk/case-studies/latex/Core.sugj
   sugarj/trunk/case-studies/latex/CoreLib.sugj
   sugarj/trunk/case-studies/latex/Listings.sugj
   sugarj/trunk/case-studies/latex/SpellChecking.sugj
   sugarj/trunk/case-studies/latex/math/
   sugarj/trunk/case-studies/latex/math/Core.sugj
   sugarj/trunk/case-studies/latex/math/CoreLib.sugj
   sugarj/trunk/case-studies/regex/Editor.sugj
   sugarj/trunk/case-studies/regex/Sugar.sugj
   sugarj/trunk/case-studies/xml/CSSEditor.sugj
   sugarj/trunk/case-studies/xml/Checks.sugj
   sugarj/trunk/case-studies/xml/Editor.sugj
   sugarj/trunk/case-studies/xml/PrintingHandler.sugj
   sugarj/trunk/case-studies/xml/Sugar.sugj
   sugarj/trunk/case-studies/xml/schema/Editor.sugj
Modified:
   sugarj/trunk/case-studies/   (props changed)
   sugarj/trunk/case-studies/check/Naming.sugj
   sugarj/trunk/case-studies/check/test.sugj
   sugarj/trunk/case-studies/concretesyntax/EditorServices.sugj
   sugarj/trunk/case-studies/editor/Colors.sugj
   sugarj/trunk/case-studies/regex/Regex.sugj
   sugarj/trunk/case-studies/regex/RegexAsString.sugj
   sugarj/trunk/case-studies/regex/Test.sugj
   sugarj/trunk/case-studies/xml/AsSax.sugj
   sugarj/trunk/case-studies/xml/BookTest.sugj
   sugarj/trunk/case-studies/xml/CSS.sugj
   sugarj/trunk/case-studies/xml/Test.sugj
   sugarj/trunk/case-studies/xml/TestCSS.sugj
   sugarj/trunk/case-studies/xml/XmlEditor.sugj
   sugarj/trunk/case-studies/xml/XmlSyntax.sugj
   sugarj/trunk/case-studies/xml/schema/AsDesugaring.sugj
   sugarj/trunk/case-studies/xml/schema/AsEditorService.sugj
   sugarj/trunk/case-studies/xml/schema/BookSchema.sugj
   sugarj/trunk/case-studies/xml/schema/BookSchemaTest.sugj
   sugarj/trunk/case-studies/xml/schema/XmlSchema.sugj
   sugarj/trunk/case-studies/xml/schema/XmlSchemaJavaSyntax.sugj

Modified: sugarj/trunk/case-studies/check/Naming.sugj
==============================================================================
--- sugarj/trunk/case-studies/check/Naming.sugj	Tue Jun 21 02:33:25 2011	(r23079)
+++ sugarj/trunk/case-studies/check/Naming.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -3,10 +3,9 @@
 import org.sugarj.languages.Java;
 import util.Strategies;
 
-public editor services Naming {
-  checking
-    warnings:
-      ClassDecHead(mods, Id(name), params, super, interfaces) =
-      [(name, "class name should start with upper-case character")]
-      where <first-char; not(is-upper)> name
+public checks Naming {
+  warnings
+    ClassDecHead(mods, Id(name), params, super, interfaces) =
+    [(name, "class name should start with upper-case character")]
+    where <first-char; not(is-upper)> name
 }
\ No newline at end of file

Added: sugarj/trunk/case-studies/check/NoSugar.sugj
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sugarj/trunk/case-studies/check/NoSugar.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -0,0 +1,7 @@
+package check;
+
+public checks NoSugar {
+  errors
+    s at SugarDec(_, _) =
+    [(s, "Sugar declarations not allowed.")]
+}
\ No newline at end of file

Modified: sugarj/trunk/case-studies/check/test.sugj
==============================================================================
--- sugarj/trunk/case-studies/check/test.sugj	Tue Jun 21 02:33:25 2011	(r23079)
+++ sugarj/trunk/case-studies/check/test.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -2,8 +2,5 @@
 
 import check.Naming;
 
-
-
 public class test {
-  
 }
\ No newline at end of file

Modified: sugarj/trunk/case-studies/concretesyntax/EditorServices.sugj
==============================================================================
--- sugarj/trunk/case-studies/concretesyntax/EditorServices.sugj	Tue Jun 21 02:33:25 2011	(r23079)
+++ sugarj/trunk/case-studies/concretesyntax/EditorServices.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -13,7 +13,10 @@
   context-free syntax
     "~" StrategoTerm -> EditorServiceNode {cons("FromMetaExpr")}
     "node~" StrategoTerm -> EditorServiceNode {cons("FromMetaExpr")}
-    "~" StrategoTerm -> EditorServiceSemanticRule {cons("FromMetaExpr")}
+    "~" StrategoTerm -> EditorServiceRefactoringRule {cons("FromMetaExpr")}
+    "~" StrategoTerm -> EditorServiceBuilderRule {cons("FromMetaExpr")}
+    "~" StrategoTerm -> EditorServiceCompletionRule {cons("FromMetaExpr")}
+    "~" StrategoTerm -> EditorServiceReferenceRule {cons("FromMetaExpr")}
     "~" StrategoTerm -> EditorServicePropertyValue {cons("FromMetaExpr")} 
     "~" StrategoTerm -> EditorServiceCompletionPart {cons("FromMetaExpr")} 
     "~" StrategoTerm -> EditorServiceStrategoCall {cons("FromMetaExpr")}
@@ -21,4 +24,4 @@
     "~" StrategoTerm -> EditorServiceCompletionPart {cons("FromMetaExpr")}
     "~" StrategoTerm -> EditorServiceAttribute {cons("FromMetaExpr")} 
     "string~" StrategoTerm -> EditorServiceString {cons("FromMetaExpr")}
-}  
+}  
\ No newline at end of file

Modified: sugarj/trunk/case-studies/editor/Colors.sugj
==============================================================================
--- sugarj/trunk/case-studies/editor/Colors.sugj	Tue Jun 21 02:33:25 2011	(r23079)
+++ sugarj/trunk/case-studies/editor/Colors.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -22,4 +22,5 @@
 
   colorer More colors
     darkorange = 200 100 0
+    keyword = 127 0 85 bold
 }
\ No newline at end of file

Added: sugarj/trunk/case-studies/editor/Editor.sugj
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sugarj/trunk/case-studies/editor/Editor.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -0,0 +1,285 @@
+package editor;
+
+public editor services Editor {
+  completions SDF
+    completion template : SugarDefElem =
+      "context-free syntax" "\n\t" (blank)
+  
+    completion template : SugarDefElem =
+      "lexical syntax" "\n\t" (blank)
+  
+    completion template : SugarDefElem =
+      "syntax" "\n\t" (blank)
+  
+    completion template : SugarDefElem =
+      "context-free restrictions" "\n\t" (blank)
+  
+    completion template : SugarDefElem =
+      "lexical restrictions" "\n\t" (blank)
+  
+    completion template : SugarDefElem =
+      "restrictions" "\n\t" (blank)
+  
+    completion template : SugarDefElem =
+      "sorts" "\n\t" (blank)
+  
+    completion template : SugarDefElem =
+      "variables" "\n\t" (blank)
+  
+    completion template : SugarDefElem =
+      "aliases" "\n\t" (blank)
+  
+    completion template : SugarDefElem =
+      "priorities" "\n\t" (blank)
+  
+    completion template : SugarDefElem = 
+      "lexical variables" "\n\t" (blank)
+  
+    completion template : Sdf2Attribute =
+      "cons" "(\"" <Name> "\")"
+  
+    completion template : Sdf2Attribute =
+      "deprecated" "(\"" <explanation> "\")"
+  
+    completion template : Sdf2Attribute =
+      "reject"
+  
+    completion template : Sdf2Attribute =
+      "left"
+  
+    completion template : Sdf2Attribute =
+      "right"
+  
+    completion template : Sdf2Attribute =
+      "non-assoc"
+  
+    completion template : Sdf2Attribute =
+      "avoid"
+  
+    completion template : Sdf2Attribute =
+      "prefer"
+  
+    completion template : Sdf2Attribute =
+      "bracket"
+  
+    completion template : Sdf2Attribute =
+      "recover"
+
+  
+  
+  folding Stratego
+    _.SDefNoArgs
+    _.SDefT
+    _.SDef
+    _.RDefNoArgs
+    _.RDefT
+    _.RDef
+  
+  colorer Stratego
+    // StrategyDef: 0 128 128 bold
+    // RuleDef:     0 128 128 bold
+    
+    // White background for variables and escapes
+    environment _.StringEscape1 : _ 255 255 255
+    environment _.StringEscape2 : _ 255 255 255
+    environment _.StringEscape3 : _ 255 255 255
+    environment _.StringEscape4 : _ 255 255 255
+    _.Wld     : _ 255 255 255
+  
+    _.StringEscape1 : gray  
+    _.StringEscape2 : gray  
+    _.StringEscape3 : gray 
+    _.StringEscape4 : gray
+    
+    _.Str     : blue
+    _.StrCong : blue
+    _.QStr    : blue
+    _.QDollar : blue
+    _.QBr     : gray
+    
+    StrategoRuleDef     : 0 64 128 bold
+    StrategoRuleDec     : 0 64 128 bold
+    StrategoStrategyDef : 0 64 128 bold
+    StrategoOverlay     : 0 64 128 bold
+    
+    //strategies    = 0    0    0
+    strategycalls = 0   64  128
+    terms         = 0    0    0
+    vars          = 0    0    0   255 255 255
+    sdefault      = 0    0    0
+    
+    _.RootApp : strategycalls
+    _.App     : strategycalls
+    
+    //Strategy  : strategies
+    StrategoSVar      : strategycalls
+    StrategoTerm      : terms
+    StrategoPreTerm   : terms
+    StrategoVar       : vars
+    _.Var     : vars
+    _.ListVar : vars
+    _.Assign  : sdefault
+    _.AM      : sdefault
+  
+    StrategoQuotedBracket1 : blue
+    StrategoQuotedBracket2 : blue
+    StrategoQuotedBracket3 : blue
+    StrategoQuotedBracket4 : blue
+
+  completions Stratego
+    completion template : StrategoStrategy =
+    "if" " " <e> " then\n\t" <s> "\nend"
+        
+    completion template : StrategoStrategy = 
+      "switch" " " <s> "\n\tcase " <c> ":" " " <s> "\n\totherwise: " <id> "\nend"
+  
+    completion template : StrategoStrategy =
+      "let" "\n\t" <x> " = " <s> "\nin\n\t" <s> "\nend"
+  
+    completion template : StrategoDef =
+      "where" "\n\t" (blank)
+      
+    completion template : StrategoDef =
+      "with" "\n\t" (blank)
+    
+    completion template : SugarDefElem =
+      "strategies" "\n\t" (blank)
+    
+    completion template : SugarDefElem =
+      "rules" "\n\t" (blank)
+
+  
+  
+  folding Editor services
+    _.EditorServicesDec
+    EditorServiceSection
+  
+  outliner Editor services
+    _.EditorServicesDec
+    EditorServiceSection
+    EditorServiceRefactoringRule
+    EditorServiceBuilderRule
+    EditorServiceCompletionRule
+    EditorServiceReferenceRule
+
+  
+  completions Editor services
+    completion template : EditorServiceSection =
+      "builders" "\n\t" (blank)
+  
+    completion template : EditorServiceSection =
+      "colorer" "\n\t" (blank)
+  
+    completion template : EditorServiceSection =
+      "folding" "\n\t" (blank)
+  
+    completion template : EditorServiceSection =
+      "outliner" "\n\t" (blank)
+  
+    completion template : EditorServiceSection =
+      "completions" "\n\t" (blank)
+  
+    completion template : EditorServiceSection =
+      "language" "\n\t" (blank)
+  
+    completion template : EditorServiceSection =
+      "references" "\n\t" (blank)
+  
+    completion template : EditorServiceCompletionRule =
+      "completion template" " : " <Sort> " =\n\t"
+        "\"" <prefix>  "\" <" <placeholder> ">" (blank)
+  
+    completion template : EditorServiceCompletionRule =
+      "identifier lexical" ":\n\t" <regex> (blank)
+  
+    completion template : EditorServiceCompletionRule =
+      "completion proposer" ":\n\t" <s> (blank)
+  
+    completion template : EditorServiceCompletionRule =
+      "completion keyword" ":\n\t" <k> (blank)
+  
+    completion template : EditorServiceCompletionRule =
+      "completion trigger" ":\n\t" <regex> (blank)
+  
+    completion template : EditorServiceBuilderRule =
+      "observer" ": " <s> (blank)
+  
+    completion template : EditorServiceBuilderRule =
+      "builder" ": " <"caption"> " = " <s> (blank)
+  
+    completion template : EditorServiceBuilderRule =
+      "builder caption" ": " <"caption"> (blank)
+  
+    completion template : EditorServiceLanguageProperty =
+      "unmanaged table" ": " <prefix> "*" (blank)
+  
+    completion template : EditorServiceLanguageProperty =
+      "line comment" ": " <prefix> (blank)
+  
+    completion template : EditorServiceLanguageProperty =
+      "block comment" ":\n\t" <prefix> " " <middle> " " <end> (blank)
+  
+    completion template : LanguageProperty =
+      "fences" ":\n\t" <f> " " <g> (blank)
+  
+    completion template : EditorServiceLanguageProperty =
+      "indent after" ":\n\t" <keyword> (blank)
+  
+    completion template : EditorServiceLanguageProperty =
+      "name" ":\n\t" <Name> (blank)
+  
+    completion template : EditorServiceLanguageProperty =
+      "url" ":\n\thttp://" <url> (blank)
+  
+    completion template : EditorServiceLanguageProperty =
+      "id" ":\n\t" <id> (blank)
+  
+    completion template : EditorServiceLanguageProperty =
+      "extends" ":\n\t" <Language> (blank)
+  
+    completion template : EditorServiceLanguageProperty =
+      "extensions" ":\n\t" <ext> (blank)
+  
+    completion template : EditorServiceLanguageProperty =
+      "start symbols" ":\n\t" <Start> (blank)
+  
+    completion template : EditorServiceLanguageProperty =
+      "disambiguator" ":\n\t" <s> (blank)
+  
+    completion template : EditorServiceLanguageProperty =
+      "description" ":\n\t" <description> (blank)
+  
+    completion template : EditorServiceLanguageProperty =
+      "table" ":\n\t" <table> (blank)
+  
+    completion template : EditorServiceLanguageProperty =
+      "table provider" ":\n\t" <provider> (blank)
+  
+    completion template : EditorServiceReferenceRule =
+      "reference" " _ : " <s> (blank)
+  
+    completion template : EditorServiceReferenceRule =
+      "occurrence" " _ : " <s> (blank)
+  
+    completion template : EditorServiceReferenceRule =
+      "hover" " _ : " <s> (blank)
+ 
+ 
+    completion template : EditorServiceRefactoringRule =
+      "provider" ": " <provider.jar> (blank)
+    completion template : EditorServiceBuilderRule =
+      "provider" ": " <provider.jar> (blank)
+    completion template : EditorServiceCompletionRule =
+      "provider" ": " <provider.jar> (blank)
+    completion template : EditorServiceReferenceRule =
+      "provider" ": " <provider.jar> (blank)
+ 
+    completion template : EditorServiceRefactoringRule =
+      "on save" ": " <s> (blank)
+    completion template : EditorServiceBuilderRule =
+      "on save" ": " <s> (blank)
+    completion template : EditorServiceCompletionRule =
+      "on save" ": " <s> (blank)
+    completion template : EditorServiceReferenceRule =
+      "on save" ": " <s> (blank)
+}
\ No newline at end of file

Added: sugarj/trunk/case-studies/editor/SpellChecking.sugj
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sugarj/trunk/case-studies/editor/SpellChecking.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -0,0 +1,29 @@
+package editor;
+
+
+public sugar SpellChecking {
+  context-free syntax
+    AnnoOrSugarMod* "dictionary" JavaId DictBody -> ToplevelDeclaration{cons("DictDec")}
+    "{" DictEntry* "}" -> DictBody {cons("DictBody")}
+
+  syntax
+    <LAYOUT?-CF> <DictWord-LEX> "\n" -> <DictEntry-CF> {cons("DictWord")}
+  
+  lexical syntax
+    ~[\ \n\r\t\-]+ -> DictWord
+  
+  desugarings
+    compile-dict
+  
+  rules
+    compile-dict :
+      DictDec(mods, n, DictBody(entries))
+      ->
+      SugarDec(SugarDecHead(mods, n), SugarBody(<map(compile-dict-entry)> entries))
+    
+    spellcheck-word = fail
+
+    compile-dict-entry :
+      DictWord(w) ->
+      transformation-elem(Rules([SDefNoArgs("spellcheck-word", Match(NoAnnoList(Str(w))))]))
+}
\ No newline at end of file

Added: sugarj/trunk/case-studies/editor/test/Sugar.sugj
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sugarj/trunk/case-studies/editor/test/Sugar.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -0,0 +1,22 @@
+package editor.test;
+
+import concretesyntax.Java;
+
+public sugar Sugar {
+  context-free syntax
+    "public" "test" JavaId TestBody -> ToplevelDeclaration {cons("TestDec")}
+    "{" TestStm* "}" -> TestBody {cons("TestBody")}
+    
+    JavaExpr "is" JavaExpr ";" -> TestStm {cons("TestStm")}
+    "anything" -> JavaExpr {cons("AnyExpr")}
+  
+  desugarings
+    desugar-testdec
+  
+  rules
+    desugar-testdec :
+      TestDec(Id(n), b)
+      ->
+      java_tdec
+      |[ public class ~id:n {} ]|
+}
\ No newline at end of file

Added: sugarj/trunk/case-studies/editor/test/Test.sugj
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sugarj/trunk/case-studies/editor/test/Test.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -0,0 +1,31 @@
+package editor.test;
+
+import editor.test.Sugar;
+
+public editor services Test {
+  colorer
+     // would like to color the "test" keyword only
+     //   _.TestDec."test" : blue bold
+     // best approximation
+     _.TestDec : bluebold
+     bluebold = 0 0 255 bold
+     
+     // would like to color the "is" keyword only
+     //   _.TestDec."test" : darkorange bold italic
+     // best approximation
+     TestStm : darkorangebolditalic
+     darkorangebolditalic = 200 100 0 bold italic
+     
+     // would like to highlight failing test cases
+     // by setting a red background color
+}
+
+public test Test {
+  1 + 3 is 4;
+  
+  new String("abc") is "abc";
+  
+  this.getCurrent() is null;
+  
+  null is null;
+}
\ No newline at end of file

Added: sugarj/trunk/case-studies/latex/Bibtex.sugj
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sugarj/trunk/case-studies/latex/Bibtex.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -0,0 +1,188 @@
+package latex;
+
+import org.sugarj.languages.Plain;
+
+import concretesyntax.Stratego;
+import editor.Colors;
+import concretesyntax.EditorServices;
+
+public sugar Bibtex {
+  context-free syntax
+    AnnoOrSugarMod* "bibtex" JavaId BibtexBody -> ToplevelDeclaration{cons("BibtexDec")}
+    "{" BibtexStm* "}" -> BibtexBody {cons("BibtexBody")}
+    
+    BibtexStringKeyword "{" BibtexConstNameBinding "=" "{" BibtexValue "}" "}" -> BibtexStm {cons("BibtexStringStm")}
+    BibtexEntryKeyword "{" BibtexEntryName Commas {BibtexAttribute ","}* Commas "}" -> BibtexStm {cons("BibtexEntryStm")}
+    
+    BibtexID -> BibtexConstNameBinding {cons("BibtexConstName")}
+    BibtexID -> BibtexConstNameBound {cons("BibtexConstName")}
+    BibtexID -> BibtexEntryName {cons("BibtexEntryName")}
+    BibtexID -> BibtexAttributeName {cons("BibtexAttributeName")}
+    CitationID -> CitationName {cons("CitationName")}
+    
+    BibtexAttributeName "=" "{" BibtexValue "}" -> BibtexAttribute {cons("BibtexAttribute")}
+    BibtexAttributeName "=" BibtexConstNameBound -> BibtexAttribute {cons("BibtexAttributeUnwrapped")}
+
+  lexical syntax
+    [\@][sS][tT][rR][iI][nN][gG] -> BibtexStringKeyword
+    [\,]* -> Commas
+    [a-zA-Z\_\--\/0-9\:\.\&]+ -> BibtexID
+    ~[\,\}]+ -> CitationID 
+    
+    [\@][a-zA-Z]* -> BibtexEntryKeyword
+    [\@][sS][tT][rR][iI][nN][gG] -> BibtexEntryKeyword {reject}
+    
+    ~[\{\}]* -> BibtexValue
+    ~[\{\}]* "{" BibtexValue "}" BibtexValue -> BibtexValue
+  
+  lexical restrictions
+    BibtexValue -/- ~[\}]
+  
+  desugarings
+    desugar-bibtex 
+  
+  rules
+    desugar-bibtex :
+      BibtexDec(mods, n, BibtexBody(stms))
+      ->
+      [PlainDec(PlainDecHead(mods, n, Some("bib")), PlainBody(<map(pp-bibtex); concat-strings> stms)),
+       EditorServicesDec(EditorServicesDecHead(mods, n), EditorServicesBody(<filter(bibtex-to-service)> stms)),
+       SugarDec(SugarDecHead(mods, n), SugarBody(<filter(bibtex-to-sugar)> stms))]
+     
+    pp-bibtex :
+      BibtexStringStm(keyword, BibtexConstName(var), val)
+      -> 
+      <concat-strings> [keyword, "{", var, "=", "{", val, "}", "}", "\n"]
+    
+    pp-bibtex :
+      BibtexEntryStm(keyword, BibtexEntryName(n), _, attrs, _)
+      ->
+      <concat-strings> [keyword, "{", n, ",", "\n", attrs-string, "}\n"]
+      where
+        <map(pp-bibtex-attr); concat-strings> attrs => attrs-string
+      
+    
+    pp-bibtex-attr :
+      BibtexAttributeUnwrapped(BibtexAttributeName(attr), BibtexConstName(val))
+      ->
+      <concat-strings> ["  ", attr, " = ", val, ",\n"]
+    
+    pp-bibtex-attr :
+      BibtexAttribute(BibtexAttributeName(attr), val)
+      ->
+      <concat-strings> ["  ", attr, " = ", "{", val, "}", ",\n"]
+
+  rules
+    tooltip-bibtex :
+      BibtexStringStm(keyword, BibtexConstName(var), val)
+      -> 
+      <concat-strings> ["<p>", "<b>", keyword, "</b>", "{", var, " = ", "{", val, "}", "}", "</p>"]
+    
+    tooltip-bibtex :
+      BibtexEntryStm(keyword, BibtexEntryName(n), _, attrs, _)
+      ->
+      <concat-strings> ["<p>", "<b>", keyword, "</b>", "{", n, ",", "</p>", attrs-string, "<p>", "}", "</p>"]
+      where
+        <map(tooltip-bibtex-attr); concat-strings> attrs => attrs-string
+    
+    tooltip-bibtex-attr :
+      BibtexAttributeUnwrapped(BibtexAttributeName(attr), BibtexConstName(val))
+      ->
+      <concat-strings> ["<p>&nbsp;&nbsp;", attr, " = ", val, ",</p>"]
+    
+    tooltip-bibtex-attr :
+      BibtexAttribute(BibtexAttributeName(attr), val)
+      ->
+      <concat-strings> ["<p>&nbsp;&nbsp;", attr, " = ", "{", val, "}", ",</p>"]
+    
+    
+  rules
+    bibtex-to-service :
+      BibtexEntryStm(_, BibtexEntryName(n), _, attrs, _)
+      ->
+      |[
+        completions
+          completion template : CitationName = string~n
+      ]|
+      
+    bibtex-to-service :
+      BibtexStringStm(_, BibtexConstName(n), v)
+      ->
+      |[
+        completions
+          completion template : BibtexConstNameBound = string~n
+      ]| 
+
+   
+   
+  rules
+    bibtex-to-sugar :
+      s at BibtexEntryStm(_, BibtexEntryName(n), _, attrs, _)
+      ->
+      <!transformation-elem(<id>)> |[ rules bibtex-entry : string~n -> term~<trm-explode> s ]|
+      where <!NoAnnoList(<id>)> s => t
+    
+  rules
+    constraint-warning :
+      BibtexAttributeUnwrapped(_, BibtexConstName(n)) 
+      -> 
+      (n, <concat-strings> [n, " is not defined and will be interpreted literally."])
+      where
+        not(<resolve-BibtexConstName> n)
+  
+  strategies
+    // Should this be part of the SugarJ core? 
+    analyze =
+      ?(term, name, path);
+      !term;
+      topdown(try(analyze-node))
+    
+    analyze-node =
+      ?s at BibtexStringStm(_, BibtexConstName(n), _);
+      rules (
+      	resolve-BibtexConstName :+ n -> s
+      )
+
+    analyze-node =
+      ?e at BibtexEntryStm(_, BibtexEntryName(n), _, _, _);
+      rules (
+        resolve-BibtexEntryName :+ n -> e
+      )
+
+    resolve-bibtex :
+      (BibtexConstName(t),pos,ast,file,project) -> r
+      where <resolve-BibtexConstName; ?BibtexStringStm(_, <id>, _)> t => r
+
+    hover-bibtex :
+      (BibtexConstName(t),pos,ast,file,project) -> r
+      where <resolve-BibtexConstName; ?BibtexStringStm(_, _, <id>)> t => r
+    
+    hover-entry :
+      (BibtexEntryName(t),pos,ast,file,project) -> r
+      where <resolve-BibtexEntryName; write-to-string> t => r
+}
+
+public editor services Bibtex {
+  colorer
+    BibtexStringKeyword : blue
+    BibtexEntryKeyword : blue
+    BibtexAttributeName : darkorange
+    BibtexConstNameBound : turquoise
+    BibtexConstNameBinding : turquoise
+    BibtexEntryName : turquoise
+    BibtexValue : black
+    CitationName : turquoise
+    
+    turquoise = 24 150 150
+    
+  folding
+    BibtexStm
+   
+  outliner
+    BibtexConstNameBinding
+    BibtexEntryName
+  
+  references
+    reference BibtexConstNameBound : resolve-bibtex
+    hover _.BibtexConstName : hover-bibtex
+}
\ No newline at end of file

Added: sugarj/trunk/case-studies/latex/Citations.sugj
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sugarj/trunk/case-studies/latex/Citations.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -0,0 +1,54 @@
+package latex;
+
+import latex.Bibtex;
+import latex.Core;
+
+public sugar Citations {
+  syntax
+    "\\cite" "{" <CitationNames-CF> "}" -> InTextCommand {cons("CiteCommand")}
+  
+  rules
+    pp-latex-command :
+      CiteCommand([])
+      -> "\\cite{?}"
+
+    pp-latex-command :
+      CiteCommand(cites)
+      ->
+      <conc-strings> ("\\cite{", s , "}")
+      where
+        <map(?CitationName(<id>))> cites => names;
+        <intersperse(|","); concat-strings> names => s
+
+  context-free syntax
+    {CitationName ","}* -> CitationNames
+
+  rules
+    constraint-warning :
+      c at CiteCommand([])
+      -> [(c, "empty citation")]
+  
+    constraint-warning :
+      CiteCommand(cites)
+      -> <filter(citations-error)> cites
+    
+    bibtex-entry = fail
+    
+    citations-error :
+      t at CitationName(n) -> (t, <conc-strings> ("undefined citation: ", n))
+      where
+        <not(bibtex-entry)> n
+
+  rules
+    citations-hover :
+      (CitationName(t),pos,ast,file,project) -> r
+      where <bibtex-entry; tooltip-bibtex> t => r
+}
+
+public editor services Citations {
+  completions
+    completion template : LatexTextContentPart = "\cite{" <citations> "}"
+
+  references
+    hover _ : citations-hover
+}
\ No newline at end of file

Added: sugarj/trunk/case-studies/latex/Core.sugj
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sugarj/trunk/case-studies/latex/Core.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -0,0 +1,265 @@
+package latex;
+
+import editor.Colors;
+import editor.Editor;
+
+import util.Strategies;
+
+import org.sugarj.languages.Plain;
+
+public sugar Core {
+  context-free syntax
+    AnnoOrSugarMod* "latex" JavaId LatexBody -> ToplevelDeclaration{cons("LatexDec")}
+  
+  syntax
+    "{" LatexDocument "}" -> <LatexBody-CF> {cons("LatexBody")}
+    
+    <TextContent-LEX> -> LatexTextContentPart {cons("Text")}
+    "\n" -> LatexTextContentPart {cons("TextNewline")}
+    "{" LatexTextContent? "}" -> LatexTextContentPart {cons("TextBlock")}
+    InTextCommand -> LatexTextContentPart {cons("TextCommand")}
+    InTextEnvironment -> LatexTextContentPart {cons("TextEnvironment")}
+    "%" <LatexLineCommentText-LEX> -> LatexTextContentPart {cons("TextComment")}
+    "~" -> LatexTextContentPart {cons("UnbreakableSpace")}
+
+    
+    LatexTextContentPart+ -> LatexTextContent
+    
+    LatexTextContent -> LatexCommentText {cons("CommentText")}
+    
+    "\\part" "{" LatexHeader "}" LatexPartContent -> LatexPart {cons("Part")}
+    "\\chapter" "{" LatexHeader "}" LatexChapterContent -> LatexChapter {cons("Chapter")}
+    "\\section" "{" LatexHeader "}" LatexSectionContent -> LatexSection {cons("Section")}
+    "\\subsection" "{" LatexHeader "}" LatexSubsectionContent -> LatexSubsection {cons("Subsection")}
+    "\\subsubsection" "{" LatexHeader "}" LatexSubsubsectionContent -> LatexSubsubsection {cons("Subsubsection")}
+    "\\paragraph" "{" LatexHeader "}" LatexParagraphContent -> LatexParagraph {cons("Paragraph")}
+    
+    LatexPartContent LatexPart+ -> LatexDocument
+    LatexPartContent -> LatexDocument
+    
+    LatexChapterContent LatexChapter+ -> LatexPartContent
+    LatexChapterContent -> LatexPartContent
+    
+    LatexSectionContent LatexSection+ -> LatexChapterContent
+    LatexSectionContent -> LatexChapterContent
+    
+    LatexSubsectionContent LatexSubsection+ -> LatexSectionContent
+    LatexSubsectionContent -> LatexSectionContent
+    
+    LatexSubsubsectionContent LatexSubsubsection+ -> LatexSubsectionContent
+    LatexSubsubsectionContent -> LatexSubsectionContent
+    
+    LatexParagraphContent LatexParagraph+ -> LatexSubsubsectionContent
+    LatexParagraphContent -> LatexSubsubsectionContent
+    
+    LatexTextContent? -> LatexParagraphContent
+    
+    LatexTextContent -> LatexHeader {cons("Header")}
+
+  lexical syntax  
+    ~[\\\{\}\%\~\n\$\[\]]+ -> TextContent
+    ~[\n]* "\n" -> LatexLineCommentText
+    
+  lexical restrictions
+    TextContent -/- ~[\\\{\}\%\~\n\$\[\]]
+
+  syntax
+    "\\latex" "{" <PlainContent-LEX> "}" -> InTextCommand {cons("LatexEscape")}
+  
+    <NullaryTextCommand-LEX> -> InTextCommand {cons("InTextCommand")}
+    <UnaryTextCommand-LEX> <LAYOUT?-CF> OptionalArg? <LAYOUT?-CF> "{" LatexTextContent? "}" -> InTextCommand {cons("InTextCommand")}
+    <BinaryTextCommand-LEX> <LAYOUT?-CF> OptionalArg? <LAYOUT?-CF> "{" LatexTextContent? "}" <LAYOUT?-CF> "{" LatexTextContent? "}" -> InTextCommand {cons("InTextCommand")}
+    <TrenaryTextCommand-LEX> <LAYOUT?-CF> OptionalArg? <LAYOUT?-CF> "{" LatexTextContent? "}" <LAYOUT?-CF> "{" LatexTextContent? "}" <LAYOUT?-CF> "{" LatexTextContent? "}" -> InTextCommand {cons("InTextCommand")}
+    
+    "[" LatexTextContent? "]"-> OptionalArg {cons("LatexOptionalArg")}
+    
+  
+  lexical syntax
+    [a-zA-Z]+ -> LatexTextEnvironmentName
+  
+  syntax
+    <LatexTextEnvironmentName-LEX> -> LatexTextEnvironmentName {cons("LatexTextEnvironmentName")}
+    
+    "\\begin" "{" LatexTextEnvironmentName "}" OptionalArg?
+      LatexTextContent
+    "\\end" "{" LatexTextEnvironmentName "}" 
+    ->
+    InTextEnvironment {cons("StandardEnvironment")}
+  
+  
+  desugarings
+    desugar-latex
+  
+  rules
+    desugar-latex :
+      latex -> [<latex-to-plain> latex, <latex-to-sugar> latex, <latex-to-services> latex]
+  
+    latex-to-sugar :
+      LatexDec(mods, n, LatexBody(content))
+      ->
+      SugarDec(SugarDecHead(mods, n), SugarBody(<collect-all(latex-to-sugar)> content))
+  
+    latex-to-services :
+      LatexDec(mods, n, LatexBody(content))
+      ->
+      EditorServicesDec(EditorServicesDecHead(mods, n), EditorServicesBody(<collect-all(latex-to-services)> content))
+      
+    latex-to-plain :
+      LatexDec(mods, n, LatexBody(content))
+      ->
+      PlainDec(PlainDecHead(mods, n, Some("tex")), PlainBody(<pp-latex> content))
+    
+    pp-latex :
+      (a, b) -> <conc-strings> (s1, s2)
+      where <pp-latex> a => s1; 
+            <pp-latex> b => s2
+    
+    pp-latex :
+      l -> s
+      where <?[] + ?[_] + is-list> l;
+            <mapconcat-strings(pp-latex)> l => s
+
+    pp-latex :
+      None -> ""
+    
+    pp-latex :
+      s -> s
+      where <is-string> s
+    
+    pp-latex :
+      Some(t) -> <pp-latex> t
+    
+    pp-latex :
+      Text(s) -> s
+    
+    pp-latex :
+      TextNewline() -> "\n"
+      
+    pp-latex :
+      TextBlock(t) -> <conc-strings> ("{", s, "}")
+      where
+        <pp-latex> t => s
+    
+    pp-latex :
+      TextComment(comment) -> <conc-strings> ("%", comment)
+    
+    pp-latex :
+      CommentText(t) -> <pp-latex> t
+    
+    pp-latex :
+      UnbreakableSpace() -> "~"
+    
+    pp-latex :
+      TextCommand(c) -> <pp-latex-command> c
+    
+    pp-latex :
+      TextEnvironment(e) -> <pp-latex-environment> e
+    
+    pp-latex :
+      Header(h) -> <pp-latex> h
+
+    pp-latex-structure(|struct) :
+      (h, p) -> <conc-strings> ("\\", struct, "{", hs, "}", ps)
+      where
+        <pp-latex> h => hs;
+        <pp-latex> p => ps 
+    
+    pp-latex :
+      Part(h, p) -> <pp-latex-structure(|"part")> (h, p)
+    pp-latex :
+      Chapter(h, p) -> <pp-latex-structure(|"chapter")> (h, p)
+    pp-latex :
+      Section(h, p) -> <pp-latex-structure(|"section")> (h, p)
+    pp-latex :
+      Subsection(h, p) -> <pp-latex-structure(|"subsection")> (h, p)
+    pp-latex :
+      Subsubsection(h, p) -> <pp-latex-structure(|"subsubsection")> (h, p)
+    pp-latex :
+      Paragraph(h, p) -> <pp-latex-structure(|"paragraph")> (h, p)
+    
+    pp-latex :
+      LatexOptionalArg(a) -> <conc-strings> ("[", <pp-latex> a, "]")
+    
+    pp-latex-command :
+      LatexEscape(code) -> code
+    
+    pp-latex-command :
+      InTextCommand#([com]) -> com
+    pp-latex-command :
+      InTextCommand#([com,opt-arg|args]) -> <conc-strings> (com, <pp-latex> opt-arg, args-string)
+      where
+        <mapconcat-strings(\ a -> <conc-strings> ("{", <pp-latex> a, "}") \)> args => args-string
+
+    pp-latex-environment :
+      StandardEnvironment(lname, opt-arg, content, rname) ->
+      <conc-strings> ("\\begin{", <pp-latex> lname, "}", <pp-latex> opt-arg, 
+                        <pp-latex> content,
+                      "\\end{", <pp-latex> rname, "}")
+    
+    pp-latex :
+      LatexTextEnvironmentName(s) -> s
+  
+  rules
+    latex-text-environment = fail
+    
+    constraint-error :
+      e at LatexTextEnvironmentName(name) -> (<id>, <conc-strings> ("undefined environment: ", name))
+      where <not(latex-text-environment)> name
+    
+    constraint-error :
+      StandardEnvironment(lname, _, _, rname) -> [(lname, msg), (rname, msg)]
+      where
+        <not(equal)> (lname, rname); 
+        !"begin and end name must coincide" => msg
+}
+
+
+public editor services Core {
+  colorer
+    TextContent : black
+    LatexTextEnvironmentName : black
+ 
+    UnbreakableSpace : keyword
+    NullaryTextCommand : keyword
+    UnaryTextCommand : keyword
+    BinaryTextCommand : keyword
+    TrenaryTextCommand : keyword
+    
+    environment _.LatexEscape : black
+    environment LatexHeader : 0 0 255 bold
+    
+    darkgreenBold = 0 128 0 bold
+    
+    LatexLineCommentText : darkgreen
+    _.TextComment : darkgreenBold
+    environment LatexCommentText : darkgreen
+    
+  
+  outliner
+    LatexPart
+    LatexChapter
+    LatexSection
+    LatexSubsection
+    LatexSubsubsection
+    LatexParagraph
+  
+  folding
+    LatexPart
+    LatexChapter
+    LatexSection
+    LatexSubsection
+    LatexSubsubsection
+    LatexParagraph
+    
+    InTextEnvironment
+
+  completions
+    completion template : LatexTextContentPart = "\part{" <name> "}"
+    completion template : LatexTextContentPart = "\chapter{" <name> "}"
+    completion template : LatexTextContentPart = "\section{" <name> "}"
+    completion template : LatexTextContentPart = "\subsection{" <name> "}"
+    completion template : LatexTextContentPart = "\subsubsection{" <name> "}"
+    completion template : LatexTextContentPart = "\paragraph{" <name> "}"
+    
+    completion template : LatexTextContentPart = "\begin{" <name> "}\n" "  \n" "\end{" <name> "}"
+}
\ No newline at end of file

Added: sugarj/trunk/case-studies/latex/CoreLib.sugj
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sugarj/trunk/case-studies/latex/CoreLib.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -0,0 +1,234 @@
+package latex;
+
+import concretesyntax.Stratego;
+import concretesyntax.EditorServices;
+
+import latex.Core;
+
+import util.Strategies;
+
+public sugar CoreLib {
+  lexical syntax
+    "\\maketitle" -> NullaryTextCommand
+    "\\LaTeX" -> NullaryTextCommand
+    "\\TeX" -> NullaryTextCommand
+    "\\ " -> NullaryTextCommand
+    "\\\\" -> NullaryTextCommand
+    "\\and" -> NullaryTextCommand
+    "\\url" -> UnaryTextCommand
+    "\\small" -> NullaryTextCommand
+    "\\sf" -> NullaryTextCommand
+    "\\noindent" -> NullaryTextCommand
+    "\\footnote" -> UnaryTextCommand
+    "\\\"" -> UnaryTextCommand
+    "\\`" -> UnaryTextCommand
+    "\\?" -> UnaryTextCommand
+    "\\'" -> UnaryTextCommand
+    "\\#" -> NullaryTextCommand
+    "\\input" -> UnaryTextCommand
+    "\\documentclass" -> UnaryTextCommand
+    "\\usepackage" -> UnaryTextCommand
+    "\\hyphenation" -> UnaryTextCommand
+    
+    "\\bibliographystyle" -> UnaryTextCommand
+    "\\bibliography" -> UnaryTextCommand
+  
+  rules
+    latex-text-environment = ?"abstract"
+    latex-text-environment = ?"center"
+    
+  syntax
+    "\\emph" "{" LatexTextContent "}" -> InTextCommand {cons("EmphCommand")}
+    "\\title" "{" LatexTextContent "}" -> InTextCommand {cons("TitleCommand")}
+
+  rules
+    pp-latex-command :
+      EmphCommand(content)
+      ->
+      <conc-strings> ("\\emph{", <pp-latex> content, "}")
+
+    pp-latex-command :
+      TitleCommand(content)
+      ->
+      <conc-strings> ("\\title{", <pp-latex> content, "}") 
+    
+  
+
+  // document environment
+  lexical syntax
+    "document" -> LatexDocumentEnvironmentName
+    "document" -> LatexTextEnvironmentName {reject}
+
+  syntax
+    "\\begin" "{" <LatexDocumentEnvironmentName-LEX> "}"
+    LatexDocument
+    "\\end" "{" <LatexDocumentEnvironmentName-LEX> "}"
+    -> DocumentEnvironment {cons("DocumentEnvironment")}
+    
+    LatexTextContent? DocumentEnvironment <LAYOUT?-CF> -> LatexDocument
+
+  rules
+    pp-latex :
+    DocumentEnvironment(lname, doc, rname) ->
+    <conc-strings> ("\\begin{", lname, "}", 
+                        <pp-latex> doc,
+                      "\\end{", rname, "}")
+  
+  // list environment
+  lexical syntax
+    "itemize" -> LatexItemizeEnvironmentName
+    "itemize" -> LatexTextEnvironmentName {reject}
+  
+  syntax
+    "\\begin" "{" <LatexItemizeEnvironmentName-LEX> "}"
+    <LAYOUT?-CF>
+    LatexItem*
+    "\\end" "{" <LatexItemizeEnvironmentName-LEX> "}"
+    -> InTextEnvironment {cons("ItemizeEnvironment")}
+
+    "\\item" LatexTextContent? -> LatexItem {cons("Item")}
+
+  rules
+    pp-latex-environment :
+    ItemizeEnvironment(lname, items, rname) ->
+    <conc-strings> ("\\begin{", lname, "}\n", 
+                        <mapconcat-strings(pp-item)> items,
+                      "\\end{", rname, "}")
+    
+    pp-item :
+    Item(c) -> <conc-strings> ("\\item", <pp-latex> c)
+  
+  
+  // figure environment
+  lexical syntax
+    "figure" -> LatexFigureEnvironmentName
+    "figure*" -> LatexFigureEnvironmentName
+    "figure" -> LatexTextEnvironmentName {reject}
+    "figure*" -> LatexTextEnvironmentName {reject}
+  
+  syntax
+    "\\begin" "{" <LatexFigureEnvironmentName-LEX> "}" OptionalArg?
+    LatexTextContent?
+    "\\caption" "{" LatexTextContent? "}"
+      <LAYOUT?-CF>
+    "\\label" "{" <LabelID-LEX> "}"
+      <LAYOUT?-CF>
+    "\\end" "{" <LatexFigureEnvironmentName-LEX> "}"
+    -> InTextEnvironment {cons("FigureEnvironment")}
+
+  rules
+    constraint-error :
+      FigureEnvironment(lname, _, _, _, _, rname) ->
+      [(lname, msg), (rname, msg)]
+      where
+        <not(equal)> (lname, rname); 
+        !"begin and end name must coincide" => msg
+
+  
+    pp-latex-environment :
+	    FigureEnvironment(lname, opt-arg, content, caption, label, rname) ->
+	    <conc-strings> ("\\begin{", lname, "}", <pp-latex> opt-arg, "\n", 
+	                        <pp-latex> content, "\n",
+	                        "\\caption{", <pp-latex> caption, "}\n",
+	                        "\\label{", <pp-latex> label, "}\n",
+	                      "\\end{", rname, "}")
+
+    latex-to-sugar :
+      FigureEnvironment(_, _, _, _, label, _) ->
+      transformation-elem(Rules([SDefNoArgs("latex-label", Match(NoAnnoList(Str(label))))]))
+    
+    latex-to-services :
+      FigureEnvironment(_, _, _, _, label, _) ->
+      |[
+        completions
+          completion template : RefID = string~label
+      ]|
+
+
+  //dimensions
+  lexical syntax
+    [0-9][0-9]* -> LatexNat
+    LatexNat -> LatexFloat
+    LatexNat "." LatexNat -> LatexFloat
+
+  syntax
+    LatexDimension -> <LatexDimension-CF>
+    <LatexFloat-LEX> LatexUnit -> LatexDimension {cons("Dimension")}
+    "em" -> LatexUnit {cons("Em")}
+    "cm" -> LatexUnit {cons("Cm")}
+
+  rules
+    pp-latex-dimension :
+      Dimension(f, unit) -> <conc-strings> (f, <pp-latex-unit> unit)
+    
+    pp-latex-unit : Em() -> "em"
+    pp-latex-unit : Cm() -> "cm"
+
+  
+  // internal references
+  lexical syntax
+    [a-zA-Z\_\--\/0-9\:\.]+ -> LabelID
+    [a-zA-Z\_\--\/0-9\:\.]+ -> RefID
+  
+  syntax
+    "\\label" "{" <LabelID-LEX> "}" -> InTextCommand {cons("LabelCommand")}
+    "\\ref" "{" <RefID-LEX> "}" -> InTextCommand {cons("RefCommand")}
+  
+  rules
+    pp-latex-command :
+    LabelCommand(ref) -> <conc-strings> ("\\label{", ref, "}")
+    
+    pp-latex-command :
+    RefCommand(ref) -> <conc-strings> ("\\ref{", ref, "}")
+  
+  rules
+    latex-to-services :
+      LabelCommand(label)
+      ->
+      |[
+        completions
+          completion template : RefID = string~label
+      ]|
+  
+  rules 
+    latex-label = fail
+    
+    latex-to-sugar :
+      LabelCommand(label)
+      ->
+      transformation-elem(Rules([SDefNoArgs("latex-label", Match(NoAnnoList(Str(label))))]))
+    
+    constraint-warning :
+      RefCommand(ref) -> (ref, <conc-strings> ("undefined reference: ", ref))
+      where
+        <not(latex-label)> ref
+}
+
+public editor services CoreLib {
+  colorer
+    environment _.EmphCommand : 0 0 255 italic
+    environment _.TitleCommand : 0 128 0 bold
+    
+    RefID : 24 150 150
+    
+    LatexDocumentEnvironmentName : black
+    LatexItemizeEnvironmentName : black
+  
+  folding
+    DocumentEnvironment
+    ItemizeEnvironment
+  
+  completions
+    completion template : LatexTextEnvironmentName = "abstract"
+    completion template : LatexTextEnvironmentName = "document"
+    completion template : LatexTextEnvironmentName = "itemize"
+  
+    completion template : LatexTextContentPart = "\emph{" <text> "}"
+    completion template : LatexTextContentPart = "\label{" <ref> "}"
+    completion template : LatexTextContentPart = "\ref{" <ref> "}"
+    
+    completion template : LatexItem = "\item " <text>
+  
+  language
+    line comment : "%"
+}
\ No newline at end of file

Added: sugarj/trunk/case-studies/latex/Listings.sugj
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sugarj/trunk/case-studies/latex/Listings.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -0,0 +1,123 @@
+package latex;
+
+import editor.Editor;
+
+import latex.Core;
+import latex.CoreLib;
+import editor.Origin;
+
+import util.Strategies;
+
+public sugar Listings {
+  signature constructors CodeListing : code -> SugarJCode
+  
+  context-free syntax
+    ToplevelDeclaration* -> SugarJCode {ast("Locked(CodeListing(<1>))")}
+    SugarDefElem+ -> SugarJCode {ast("Locked(CodeListing(<1>))")}
+    JavaBlockStm+ -> SugarJCode {ast("Locked(CodeListing(<1>))")}
+    JavaExpr -> SugarJCode {ast("Locked(CodeListing(<1>))")}
+    EditorServiceSection+ -> SugarJCode {ast("Locked(CodeListing(<1>))")}
+    EditorServiceCompletionRule+ -> SugarJCode {ast("Locked(CodeListing(<1>))")}
+    StrategoRuleDef+ -> SugarJCode {ast("Locked(CodeListing(<1>))"), avoid}
+  
+    "..." -> StrategoTerm {cons("AbreviativeTerm")}
+  
+  syntax 
+    LatexDocument -> LatexCode {ast("Locked(CodeListing(<1>))")}
+  
+  syntax
+    "|>" LatexTextContent "<|" -> <JavaId-CF> {cons("LatexJavaId")}
+  
+  lexical syntax
+    ~[\!\n]* -> LstInlineExclContent
+  
+  syntax
+    "\\sugarjinline" "!" <LAYOUT?-CF> <SugarJCode-CF> <LAYOUT?-CF> "!" -> InTextCommand {cons("SugarJInlineCommandExclamation")}
+    "\\sugarjinline" "{" <LAYOUT?-CF> <SugarJCode-CF> <LAYOUT?-CF> "}" -> InTextCommand {cons("SugarJInlineCommandBrace")}
+    "\\latexinline" "!" LatexCode "!" -> InTextCommand {cons("LatexInlineCommandExclamation")}
+    "\\latexinline" "{" LatexCode "}" -> InTextCommand {cons("LatexInlineCommandBrace")}
+    "\\lstinline" "!" <LstInlineExclContent-LEX> "!" -> InTextCommand {cons("LstInlineCommandExclamation")}
+    "\\lstinline" "{" <PlainContent-LEX> "}" -> InTextCommand {cons("LstInlineCommandBrace")}
+  
+  lexical syntax
+    "lstlisting" -> LatexLstlistingEnvironmentName
+    "lstlisting" -> LatexTextEnvironmentName {reject}
+    "lstsugarj" -> LatexLstsugarjEnvironmentName
+    "lstsugarj" -> LatexTextEnvironmentName {reject}
+  
+  context-free syntax
+    "style" "=" ListingStyle -> ListingOption {cons("ListingStyleOption")}
+    "xleftmargin" "=" LatexDimension -> ListingOption {cons("ListingXLeftMargin")}
+    "figure" -> ListingStyle {cons("ListingStyleFigure")}
+    "[" {ListingOption ","}* "]" -> ListingOptions
+  
+  syntax
+    "\\begin" "{" <LatexLstlistingEnvironmentName-LEX> "}"
+    <PlainContent-LEX>
+    "\\end" "{" <LatexLstlistingEnvironmentName-LEX> "}"
+    -> InTextEnvironment {cons("LstlistingEnvironment")}
+
+    "\\begin" "{" <LatexLstsugarjEnvironmentName-LEX> "}"
+    <LAYOUT?-CF> <ListingOptions?-CF>
+    <LAYOUT?-CF> <SugarJCode-CF> <LAYOUT?-CF>
+    "\\end" "{" <LatexLstsugarjEnvironmentName-LEX> "}"
+    -> InTextEnvironment {cons("LstsugarjEnvironment")}
+    
+  rules
+    pp-listing-options : None -> ""
+    pp-listing-options : Some(opts) -> <conc-strings> (opts-string, sep)
+      where <map(pp-listing-option); intersperse(|","); concat-strings> opts => opts-string;
+            <(?[] < !"" + !",")> opts => sep
+    
+    pp-listing-option : ListingStyleOption(o) -> <conc-strings> ("style=", <pp-listing-option> o)
+    pp-listing-option : ListingXLeftMargin(o) -> <conc-strings> ("xleftmargin=", <pp-latex-dimension> o)
+    
+    pp-listing-option : ListingStyleFigure() -> "figure"
+
+    pp-latex-environment :
+      LstlistingEnvironment(lname, text, rname) ->
+      <conc-strings> ("\\begin{lstlisting}",
+                       "[escapeinside={|>}{<|}]", 
+                        text,
+                      "\\end{lstlisting}")
+  
+    pp-latex-environment :
+	    LstsugarjEnvironment(lname, opts, Locked(doc), rname) ->
+	    <conc-strings> ("\\begin{lstlisting}",
+	                     "[", 
+	                     <pp-listing-options> opts,
+	                     "language=SugarJ,escapeinside={|>}{<|}]\n", 
+	                      <origin-text> doc,
+	                    "\n\\end{lstlisting}")
+  
+  
+  
+  rules
+    pp-latex-command :
+      SugarJInlineCommandExclamation(Locked(t)) -> <conc-strings> ("\\lstinline[language=SugarJ,escapeinside={|>}{<|}]!", <origin-text> t, "!")
+      
+    pp-latex-command :
+      SugarJInlineCommandBrace(Locked(t)) -> <conc-strings> ("\\lstinline[language=SugarJ,escapeinside={|>}{<|}]{", <origin-text> t, "}")
+
+    pp-latex-command :
+      LatexInlineCommandExclamation(Locked(t)) -> <conc-strings> ("\\lstinline[language=LaTeX,escapeinside={|>}{<|}]!", <origin-text> t, "!")
+      
+    pp-latex-command :
+      LatexInlineCommandBrace(Locked(t)) -> <conc-strings> ("\\lstinline[language=LaTeX,escapeinside={|>}{<|}]{", <origin-text> t, "}")
+
+    pp-latex-command :
+      LstInlineCommandExclamation(s) -> <conc-strings> ("\\lstinline[language=SugarJ,escapeinside={|>}{<|}]!", s, "!")
+      
+    pp-latex-command :
+      LstInlineCommandBrace(s) -> <conc-strings> ("\\lstinline[language=SugarJ,escapeinside={|>}{<|}]{", s, "}")
+}
+
+
+public editor services Listings {
+  colorer
+    listings = _ 255 255 150
+    _.LstsugarjEnvironment : listings
+    _.LstlistingEnvironment : listings
+    ListingOption : black 
+    ListingStyle : black
+}
\ No newline at end of file

Added: sugarj/trunk/case-studies/latex/SpellChecking.sugj
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sugarj/trunk/case-studies/latex/SpellChecking.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -0,0 +1,25 @@
+package latex;
+
+import editor.SpellChecking;
+import latex.Core;
+
+public sugar SpellChecking {
+  rules
+    constraint-warning :
+      Text(s) -> warnings
+      where
+        <spellcheck-text> s => mispelled-words;
+        <?[] < ![] +
+         (?[x] < !(s, <concat-strings> ["unknown word: ", x]) + 
+                 !(s, <concat-strings> ["unknown words: " | <id; intersperse(|", ")>]))> mispelled-words => warnings
+    
+    spellcheck-text =
+      string-tokenize(|[' ', '\n', '\r', '\t', '.', ':', ';', ',', '?', '!', '`', '?', '"', '/', '&', '(', ')']);
+      filter(not(spellcheck-word); not(lower-case; spellcheck-word))
+    
+  rules
+    intersperse(|s) : [] -> []
+    intersperse(|s) : [x] -> [x]
+    intersperse(|s) : [x|y] -> [x,s| <intersperse(|s)> y]
+
+}
\ No newline at end of file

Added: sugarj/trunk/case-studies/latex/math/Core.sugj
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sugarj/trunk/case-studies/latex/math/Core.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -0,0 +1,79 @@
+package latex.math;
+
+import latex.Core;
+
+public sugar Core {
+  syntax
+    "$" LatexMathContent "$" -> LatexTextContentPart {cons("InTextMath")}
+    
+    <MathContent-LEX> -> LatexMathContentPart {cons("Text")}
+    "\n" -> LatexMathContentPart {cons("TextNewline")}
+    "{" LatexMathContentPart? "}" -> LatexMathContentPart {cons("TextBlock")}
+    InMathCommand -> LatexMathContentPart {cons("TextCommand")}
+    InMathEnvironment -> LatexMathContentPart {cons("TextEnvironment")}
+    "%" <LatexLineCommentText-LEX> -> LatexMathContentPart {cons("TextComment")}
+    LatexMathContentPart "^" LatexMathContentPart -> LatexMathContentPart {cons("Superscript")}
+    LatexMathContentPart "_" LatexMathContentPart -> LatexMathContentPart {cons("Subscript")}
+    
+    LatexMathContentPart+ -> LatexMathContent
+  
+  
+  syntax
+    "\\latex" "{" <PlainContent-LEX> "}" -> InMathCommand {cons("LatexEscape")}
+    
+    <NullaryMathCommand-LEX> -> InMathCommand {cons("InTextCommand")}
+    <UnaryMathCommand-LEX> <LAYOUT?-CF> "{" LatexMathContent? "}" -> InMathCommand {cons("InTextCommand")}
+    <BinaryMathCommand-LEX> <LAYOUT?-CF> "{" LatexMathContent? "}" <LAYOUT?-CF> "{" LatexMathContent? "}" -> InMathCommand {cons("InTextCommand")}
+    <TrenaryMathCommand-LEX> <LAYOUT?-CF> "{" LatexMathContent? "}" <LAYOUT?-CF> "{" LatexMathContent? "}" <LAYOUT?-CF> "{" LatexMathContent? "}" -> InMathCommand {cons("InTextCommand")}
+    
+  lexical syntax
+    [a-zA-Z]+ -> LatexMathEnvironmentName
+  
+  syntax
+    <LatexMathEnvironmentName-LEX> -> LatexMathEnvironmentName {cons("LatexMathEnvironmentName")}
+    
+    "\\begin" "{" LatexMathEnvironmentName "}"
+      LatexMathContent
+    "\\end" "{" LatexMathEnvironmentName "}" 
+    ->
+    InMathEnvironment {cons("StandardEnvironment")}
+
+
+  rules
+    pp-latex :
+      InTextMath(m) -> <conc-strings> ("$", <pp-latex> m, "$")
+      
+    pp-latex :
+      LatexMathEnvironmentName(s) -> s
+    
+    pp-latex :
+      Superscript(b,e) -> <conc-strings> (<pp-latex> b, "^", <pp-latex> e)
+
+    pp-latex :
+      Subscript(b,e) -> <conc-strings> (<pp-latex> b, "_", <pp-latex> e)
+
+  rules
+    latex-math-environment = fail
+    
+    constraint-error :
+      e at LatexMathEnvironmentName(name) -> (<id>, <conc-strings> ("undefined environment: ", name))
+      where <not(latex-math-environment)> name
+    
+  
+  lexical syntax
+    ~[\\\{\}\%\~\n\$\^\_]+ -> MathContent
+  
+  lexical restrictions
+    MathContent -/- ~[\\\{\}\%\~\n\$\^\_]
+}
+
+public editor services Core {
+  colorer
+    MathContent : blue
+    LatexMathEnvironmentName : black
+    
+    NullaryMathCommand : keyword
+    UnaryMathCommand : keyword
+    BinaryMathCommand : keyword
+    TrenaryMathCommand : keyword
+}
\ No newline at end of file

Added: sugarj/trunk/case-studies/latex/math/CoreLib.sugj
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sugarj/trunk/case-studies/latex/math/CoreLib.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -0,0 +1,14 @@
+package latex.math;
+
+public sugar CoreLib {
+  lexical syntax
+    "\\to" -> NullaryMathCommand
+    "\\dag" -> NullaryMathCommand
+}
+
+public editor services CoreLib {
+  completions
+    completion template : LatexMathContentPart = "\to"
+    completion template : LatexMathContentPart = "\dag"
+
+}
\ No newline at end of file

Added: sugarj/trunk/case-studies/regex/Editor.sugj
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sugarj/trunk/case-studies/regex/Editor.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -0,0 +1,33 @@
+package regex;
+
+import editor.Colors;
+import regex.Regex;
+import util.Strategies;
+
+public sugar Editor {
+  rules
+    regex-complete : 
+      (node, position, ast, path, project-path) 
+      -> [("\\s", "A whitespace character:<br/>[ \\t\\n\\x0B\\f\\r]."),
+          ("\\S", "A non-whitespace character: <br/>[^\\s]."),
+          ("\\w", "A word character: <br/>[a-zA-Z_0-9]."),
+          ("\\W", "A non-word character: <br/>[^\\w]."),
+          ("\\d", "A digit: <br/>[0-9]."),
+          ("\\D", "A non-digit: <br/>[^0-9]."),
+          (["[", Placeholder("<from>"), "-", Placeholder("<to>"), "]"], "A character class range.")]
+      where
+        <at-position(?regex-lit(_)|<butlast>position)> ast
+}
+
+public editor services Editor {
+  colorer
+    _.delimited-regex : 255 0 0 bold
+    _.regex-lit : darkgreen
+    _.regex-ccexp-predefined : 127 0 85 bold
+    _.ccexp-predefined : 200 50 100
+    _.ccexp-range : darkorange
+    _.ccexp-lit : darkorange
+  
+  completions
+    completion proposer : regex-complete
+}
\ No newline at end of file

Modified: sugarj/trunk/case-studies/regex/Regex.sugj
==============================================================================
--- sugarj/trunk/case-studies/regex/Regex.sugj	Tue Jun 21 02:33:25 2011	(r23079)
+++ sugarj/trunk/case-studies/regex/Regex.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -5,37 +5,56 @@
  */
 public sugar Regex {
   sorts Regex RegexLit CCExp CCExpLit CCExpRange
+
+  lexical syntax
+    [a-z] -> LCChar
+    [A-Z] -> UCChar
+    [0-9] -> Digit
+
+    "\\" [\\tnrfae\.\-\@\+] -> EscapedChar
+
   
   // character class literals and ranges
   lexical syntax
     [a-zA-Z0-9\ ]     -> CCExpLit
-    "\\" ~[\"\\\n\13] -> CCExpLit
-        
-    [a-z] "-" [a-z] -> CCExpRange
-    [A-Z] "-" [A-Z] -> CCExpRange
-    [0-9] "-" [0-9] -> CCExpRange
-
+    EscapedChar -> CCExpLit
+    
+    "."   -> CCPredefined
+    "\\s" -> CCPredefined
+    "\\S" -> CCPredefined
+    "\\d" -> CCPredefined
+    "\\D" -> CCPredefined
+    "\\w" -> CCPredefined
+    "\\W" -> CCPredefined
+    
   syntax
     <CCExpLit-LEX>    -> CCExp {cons("ccexp-lit")}
-    <CCExpRange-LEX>  -> CCExp {cons("ccexp-range")}
+    <LCChar-LEX> "-" <LCChar-LEX> -> CCExp {cons("ccexp-range")}
+    <UCChar-LEX> "-" <UCChar-LEX> -> CCExp {cons("ccexp-range")}
+    <Digit-LEX>  "-" <Digit-LEX>  -> CCExp {cons("ccexp-range")}
     "^" CCExp         -> CCExp {cons("ccexp-negation")}
     CCExp CCExp       -> CCExp {left, cons("ccexp-union")}
     CCExp "&&" CCExp  -> CCExp {left, cons("ccexp-intersection")}
     "[" CCExp "]"     -> CCExp {bracket}
+    <CCPredefined-LEX> -> CCExp {cons("ccexp-predefined")}
 
   priorities // of character class operators
     <CCExpLit-LEX>    -> CCExp {cons("ccexp-lit")}
   > "^" CCExp         -> CCExp {cons("ccexp-negation")}
   > "[" CCExp "]"     -> CCExp {bracket}
-  > CCExpRange        -> CCExp {cons("ccexp-range")}
+  > {
+     <LCChar-LEX> "-" <LCChar-LEX> -> CCExp {cons("ccexp-range")}
+     <UCChar-LEX> "-" <UCChar-LEX> -> CCExp {cons("ccexp-range")}
+     <Digit-LEX>  "-" <Digit-LEX>  -> CCExp {cons("ccexp-range")}
+    }
   > CCExp CCExp       -> CCExp {left, cons("ccexp-union")}
   > CCExp "&&" CCExp  -> CCExp {left, cons("ccexp-intersection")}
   
 
   // regex literals
   lexical syntax
-    [a-zA-Z0-9\.\ ]   -> RegexLit
-    "\\" ~[\"\\\n\13] -> RegexLit
+    [a-zA-Z0-9\ ]   -> RegexLit
+    EscapedChar -> RegexLit
     
   
   // regular expressions
@@ -44,6 +63,7 @@
   
 	  <RegexLit-LEX>  -> Regex {cons("regex-lit")}
 	  "[" CCExp "]"   -> Regex {bracket, cons("regex-ccexp")}
+	  <CCPredefined-LEX> -> Regex {bracket, cons("regex-ccexp-predefined")}
 	  Regex "?"       -> Regex {cons("regex-option")}
 	  Regex "*"       -> Regex {cons("regex-many")}
 	  Regex "+"       -> Regex {cons("regex-many1")}
@@ -61,22 +81,4 @@
   > Regex Regex     -> Regex {left, cons("regex-sequence")}
   > Regex "|" Regex -> Regex {left, cons("regex-alternative")}
   
-  
-  signature constructors
-    delimited-regex : Regex -> Regex
-    
-    regex-lit : RegexLit -> Regex
-    regex-ccexp : CCExp -> Regex
-    regex-option : Regex -> Regex
-    regex-many : Regex -> Regex
-    regex-many1 : Regex -> Regex
-    regex-sequence : Regex * Regex -> Regex
-    regex-alternative : Regex * Regex -> Regex
-    regex-group : Regex -> Regex
-    
-    ccexp-lit : CCExpLit -> CCExp
-    ccexp-range : CCExpRange -> CCExp
-    ccexp-negation : CCExp -> CCExp
-    ccexp-union : CCExp * CCExp -> CCExp
-    ccexp-intersection : CCExp * CCExp -> CCExp
 }

Modified: sugarj/trunk/case-studies/regex/RegexAsString.sugj
==============================================================================
--- sugarj/trunk/case-studies/regex/RegexAsString.sugj	Tue Jun 21 02:33:25 2011	(r23079)
+++ sugarj/trunk/case-studies/regex/RegexAsString.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -3,6 +3,8 @@
 import org.sugarj.languages.Java;
 import regex.Regex;
 
+import util.Strategies;
+
 public sugar RegexAsString {
   sorts Regex
   
@@ -16,8 +18,13 @@
    rules
      r2str : 
        regex-lit(lit)
-       -> escaped-lit
-     with escaped-lit := <string-replace(|"\\","\\\\")> lit
+       -> lit
+       where <elem> (lit, ["\\\\", "\\t", "\\n", "\\r", "\\f", "\\a", "\\e"])
+     
+     r2str : 
+       regex-lit(lit)
+       -> <string-replace(|"\\", "\\\\")> lit
+       where <not(elem)> (lit, ["\\\\", "\\t", "\\n", "\\r", "\\f", "\\a", "\\e"])
      
      r2str : 
        regex-ccexp(ce) 
@@ -46,6 +53,10 @@
      r2str :
        regex-group(e)
        -> <conc-strings> ("(", <r2str> e, ")")
+
+     r2str :
+       regex-ccexp-predefined(e)
+       -> <conc-strings> ("\\", e)
    
    rules
      ce2str :
@@ -53,8 +64,8 @@
        -> lit
      
      ce2str :
-       ccexp-range(range)
-       -> <bracket> range
+       ccexp-range(from, to)
+       -> <conc-strings; bracket> (from, "-", to)
      
      ce2str :
        ccexp-negation(ce)
@@ -67,6 +78,14 @@
      ce2str :
        ccexp-intersection(ce1, ce2)
        -> <conc-strings; bracket> (<ce2str> ce1, <ce2str> ce2) 
+
+     ce2str :
+       ccexp-predefined(".")
+       -> "."
+    
+     ce2str :
+       ccexp-predefined(e)
+       -> <conc-strings> ("\\", e)
      
    rules
      bracket : 

Added: sugarj/trunk/case-studies/regex/Sugar.sugj
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sugarj/trunk/case-studies/regex/Sugar.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -0,0 +1,7 @@
+package regex;
+
+import regex.Regex;
+import regex.RegexAsString;
+
+public sugar Sugar {
+}
\ No newline at end of file

Modified: sugarj/trunk/case-studies/regex/Test.sugj
==============================================================================
--- sugarj/trunk/case-studies/regex/Test.sugj	Tue Jun 21 02:33:25 2011	(r23079)
+++ sugarj/trunk/case-studies/regex/Test.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -2,10 +2,12 @@
 
 import regex.Regex;
 import regex.RegexAsString;
+import regex.Editor;
 
 public class Test {
   public static void main(String[] args) {
-    boolean b = args[0].matches(/a* \_[b-y]*\_ z*/);
+    boolean b = args[0].matches(/Sugar\S[A-Z]*/);
+    
     System.out.println(b);
   }
 }

Modified: sugarj/trunk/case-studies/xml/AsSax.sugj
==============================================================================
--- sugarj/trunk/case-studies/xml/AsSax.sugj	Tue Jun 21 02:33:25 2011	(r23079)
+++ sugarj/trunk/case-studies/xml/AsSax.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -10,6 +10,7 @@
 import xml.XmlSyntax;
 import xml.XmlTextTools;
 
+
 /*
  * https://svn.strategoxt.org/repos/StrategoXT/java-borg/trunk/trans/java-xml/meta-explode-sax.str
  */
@@ -121,6 +122,13 @@
 	    bottomup( try( \ Conc(l1, l2) -> <conc> (l1, l2) \ ))
     
     
+    content-to-stm(|java_x) :
+      Comment(_) ->
+        java_bstm* |[
+          ;
+        ]|
+
+
   rules
     java-string-prefix :
       None -> <java-string-expr> ""

Modified: sugarj/trunk/case-studies/xml/BookTest.sugj
==============================================================================
--- sugarj/trunk/case-studies/xml/BookTest.sugj	Tue Jun 21 02:33:25 2011	(r23079)
+++ sugarj/trunk/case-studies/xml/BookTest.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -3,21 +3,20 @@
 import org.xml.sax.ContentHandler;
 import org.xml.sax.SAXException;
 
-import xml.AsSax;
-import xml.Test;
-import xml.XmlJavaSyntax;
-import xml.XmlEditor;
+import xml.Sugar;
+import xml.Editor;
 
-import xml.XmlSyntax;
-
-public class BookTest extends xml.Test {
-  public static void main(String[] args) throws SAXException {
-    ContentHandler ch = new BookTest();
+public class BookTest {
+  public void appendBook(ContentHandler ch) throws SAXException {
     
     String title = "Sweetness and Power: The Place of Sugar in Modern History";
     
     ch.<book title="{new String(title)}">
          <author name="Sidney W. Mintz" />
+         <editions>
+           <edition year="1985" publisher="Viking Press" />
+           <edition year="1986" publisher="Penguin Books" />
+         </editions>
        </book>;   
   }
 }
\ No newline at end of file

Modified: sugarj/trunk/case-studies/xml/CSS.sugj
==============================================================================
--- sugarj/trunk/case-studies/xml/CSS.sugj	Tue Jun 21 02:33:25 2011	(r23079)
+++ sugarj/trunk/case-studies/xml/CSS.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -10,20 +10,27 @@
     
   context-free syntax
     Selector "{" {CSSRule ";"}* Semicolon? "}" -> CSSStm {cons("CSSStm")}
+//    StrategoTerm "{" {CheckingCSSRule ";"}* Semicolon? "}" -> CSSStm {cons("CheckingCSSStm")}
     EditorServiceNode -> Selector {cons("Selector")}
   
     "color" ":" CSSColor -> CSSRule {cons("ColorRule")}
     "background-color" ":" CSSColor -> CSSRule {cons("BackgroundColorRule")}
+    "rec-color" ":" CSSColor -> CSSRule {cons("ColorAllRule")}
     "environment-color" ":" CSSColor -> CSSRule {cons("ColorAllRule")}
-    "color-recursive" ":" CSSColor -> CSSRule {cons("ColorAllRule")}
+    "rec-background-color" ":" CSSColor -> CSSRule {cons("BackgroundColorAllRule")}
     "environment-background-color" ":" CSSColor -> CSSRule {cons("BackgroundColorAllRule")}
-    "background-color-recursive" ":" CSSColor -> CSSRule {cons("BackgroundColorAllRule")}
     "outlining" -> CSSRule {cons("OutliningRule")}
     "folding" -> CSSRule {cons("FoldingRule")}
     
     EditorServiceColor -> CSSColor
     EditorServiceAttributeId -> CSSColor {cons("AttributeRef")}
 
+//    "errors" ":" StrategoTerm -> CheckingCSSRule {cons("ErrorsRule")}
+//    "warnings" ":" StrategoTerm -> CheckingCSSRule {cons("WarningsRule")}
+//    "notes" ":" StrategoTerm -> CheckingCSSRule {cons("NotesRule")}
+//    "where" ":" StrategoStrategy -> CheckingCSSRule {cons("WhereRule")}
+
+
 
   lexical syntax
     ";" -> Semicolon
@@ -40,7 +47,6 @@
     compile-css :
       CSSStm(Selector(node), rs, _) -> <map(compile-css-rule(|node))> rs
 
-    
     compile-css-rule(|node) :
       ColorRule(color)
       ->
@@ -86,5 +92,4 @@
       |[ outliner
            ~node
        ]|
-
 }
\ No newline at end of file

Added: sugarj/trunk/case-studies/xml/CSSEditor.sugj
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sugarj/trunk/case-studies/xml/CSSEditor.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -0,0 +1,19 @@
+package xml;
+
+import editor.Colors;
+import xml.CSS;
+import xml.XmlSyntax;
+
+public css CSSEditor {
+  Element  { folding; outlining }
+  ElemName { rec-color : blue }
+  AttrName { rec-color : darkorange }
+  AttValue { rec-color : darkred }
+  CharData { rec-color : black }
+  
+  // Element(lname, attrs, content, rname) {
+  //   errors : [(lname, "element start and end tag need to coincide"),
+  //             (rname, "element start and end tag need to coincide")];
+  //   where : <not(equal)> (lname, rname)
+  // }
+}
\ No newline at end of file

Added: sugarj/trunk/case-studies/xml/Checks.sugj
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sugarj/trunk/case-studies/xml/Checks.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -0,0 +1,11 @@
+package xml;
+
+import xml.XmlSyntax;
+
+public checks Checks {
+  errors 
+    Element(lname, attrs, content, rname) = 
+    [(lname, "element start and end tag need to coincide"),
+     (rname, "element start and end tag need to coincide")]
+    where <not(equal)> (lname, rname)
+}

Added: sugarj/trunk/case-studies/xml/Editor.sugj
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sugarj/trunk/case-studies/xml/Editor.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -0,0 +1,19 @@
+package xml;
+
+import editor.Colors;
+import editor.Editor;
+import xml.XmlSyntax;
+
+public editor services Editor {
+  colorer
+    ElemName : blue       (recursive)
+    AttrName : darkorange (recursive)
+    AttValue : darkred    (recursive)
+    CharData : black      (recursive)
+
+  folding
+    Element
+    
+  outliner
+    Element
+}
\ No newline at end of file

Added: sugarj/trunk/case-studies/xml/PrintingHandler.sugj
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sugarj/trunk/case-studies/xml/PrintingHandler.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -0,0 +1,77 @@
+package xml;
+
+import java.util.StringTokenizer;
+
+import org.xml.sax.Attributes;
+import org.xml.sax.ContentHandler;
+import org.xml.sax.SAXException;
+import org.xml.sax.helpers.DefaultHandler;
+
+/*
+ * code for printing based on http://www.informit.com/articles/article.aspx?p=26351&seqNum=5
+ */
+public class PrintingHandler extends DefaultHandler {
+  private int indentation = 0;
+
+  /** When you see a start tag, print it out and then
+   *  increase indentation by two spaces. If the
+   *  element has attributes, place them in parens
+   *  after the element name.
+   */
+
+  public void startElement(String namespaceUri,
+                           String localName,
+                           String qualifiedName,
+                           Attributes attributes)
+      throws SAXException {
+    indent(indentation);
+    System.out.print("<" + qualifiedName);
+    int numAttributes = attributes.getLength();
+
+    if (numAttributes > 0) {
+      System.out.print(" ");
+      for(int i=0; i<numAttributes; i++) {
+        if (i>0) {
+          System.out.print(" ");
+        }
+        System.out.print(attributes.getQName(i) + "=\"" +
+                         attributes.getValue(i) + "\"");
+      }
+    }
+    System.out.println(">");
+    indentation = indentation + 2;
+  }
+  /** When you see the end tag, print it out and decrease
+   *  indentation level by 2.
+   */
+  
+  public void endElement(String namespaceUri,
+                         String localName,
+                         String qualifiedName)
+      throws SAXException {
+    indentation = indentation - 2;
+    indent(indentation);
+    System.out.println("</" + qualifiedName + ">");
+  }
+
+  /** Print out the first word of each tag body. */
+  
+  public void characters(char[] chars,
+                         int startIndex,
+                         int endIndex) {
+    String data = new String(chars, startIndex, endIndex);
+    
+    StringTokenizer st = new StringTokenizer(data, "\n");
+    
+    while (st.hasMoreTokens()) {
+      indent(indentation);
+      System.out.println(st.nextToken());
+    }
+  }
+
+  private void indent(int indentation) {
+    for(int i=0; i<indentation; i++) {
+      System.out.print(" ");
+    }
+  }
+}
\ No newline at end of file

Added: sugarj/trunk/case-studies/xml/Sugar.sugj
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sugarj/trunk/case-studies/xml/Sugar.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -0,0 +1,8 @@
+package xml;
+
+import xml.XmlJavaSyntax;
+import xml.Checks;
+import xml.AsSax;
+
+public sugar Sugar {
+}
\ No newline at end of file

Modified: sugarj/trunk/case-studies/xml/Test.sugj
==============================================================================
--- sugarj/trunk/case-studies/xml/Test.sugj	Tue Jun 21 02:33:25 2011	(r23079)
+++ sugarj/trunk/case-studies/xml/Test.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -7,9 +7,8 @@
 import org.xml.sax.SAXException;
 import org.xml.sax.helpers.DefaultHandler;
 
-import xml.AsSax;
-import xml.XmlJavaSyntax;
-import xml.XmlEditor;
+import xml.Sugar;
+import xml.Editor;
 
 /*
  * code for printing based on http://www.informit.com/articles/article.aspx?p=26351&seqNum=5
@@ -17,15 +16,14 @@
 public class Test extends DefaultHandler {
   public static void main(String[] args) throws SAXException {
     ContentHandler ch = new Test();
-     
+    
     ch.<xsd:schema
 		     targetNamespace="http://www.w3.org/2001/XMLSchema"
 		     blockDefault="#all"
 		     elementFormDefault="qualified"
-		     version="1.0">   
+		     version="1.0">
 		     <{http://www.w3.org/2001/XMLSchema}simpleType name="derivationSet">
 		       <annotation>
-		       
 		         <documentation>
 		           A utility type, not for public use
 		         </documentation> 

Modified: sugarj/trunk/case-studies/xml/TestCSS.sugj
==============================================================================
--- sugarj/trunk/case-studies/xml/TestCSS.sugj	Tue Jun 21 02:33:25 2011	(r23079)
+++ sugarj/trunk/case-studies/xml/TestCSS.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -7,9 +7,8 @@
 import org.xml.sax.SAXException;
 import org.xml.sax.helpers.DefaultHandler;
 
-import xml.AsSax;
-import xml.XmlJavaSyntax;
-import xml.CSSXmlEditor;
+import xml.Sugar;
+import xml.CSSEditor;
 
 /*
  * code for printing based on http://www.informit.com/articles/article.aspx?p=26351&seqNum=5
@@ -18,33 +17,11 @@
   public static void main(String[] args) throws SAXException {
     ContentHandler ch = new Test();
     
-    ch.<xsd:schema
-		     targetNamespace="http://www.w3.org/2001/XMLSchema"
-		     blockDefault="#all"
-		     elementFormDefault="qualified"
-		     version="1.0">   
-		     <{http://www.w3.org/2001/XMLSchema}simpleType name="derivationSet">
-		       <annotation>
-		       
-		         <documentation>
-		           A utility type, not for public use
-		         </documentation> 
-		         <documentation>
-		           #all or (possibly empty) subset of {extension, restriction}
-		         </documentation>
- 		      </annotation>
-	 	      <union>
-		         <simpleType>
-		           <restriction base="token">
-		             <enumeration value="#all"/>
-		           </restriction>
-		         </simpleType>
-		         <simpleType>
-		           <list itemType="reducedDerivationControl"/>
- 		        </simpleType>
-	 	      </union>
-		     </{http://www.w3.org/2001/XMLSchema}simpleType>  
-		   </xsd:schema>;
+    String title = "Sweetness and Power: The Place of Sugar in Modern History";
+    
+    ch.<book title="{new String(title)}">
+         <author name="Sidney W. Mintz" />
+       </book>;
   }
   	
 	private int indentation = 0;

Modified: sugarj/trunk/case-studies/xml/XmlEditor.sugj
==============================================================================
--- sugarj/trunk/case-studies/xml/XmlEditor.sugj	Tue Jun 21 02:33:25 2011	(r23079)
+++ sugarj/trunk/case-studies/xml/XmlEditor.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -15,10 +15,12 @@
     
   outliner XmlOutliner
     Element
-  
-  checking
-    errors: Element(lname, attrs, content, rname) = 
-            [(lname, "element start and end tag need to coincide"),
-             (rname, "element start and end tag need to coincide")]
-            where <not(equal)> (lname, rname) 
+}
+
+public checks XmlEditor {
+    errors
+      Element(lname, attrs, content, rname) = 
+        [(lname, "element start and end tag need to coincide"),
+         (rname, "element start and end tag need to coincide")]
+        where <not(equal)> (lname, rname) 
 }
\ No newline at end of file

Modified: sugarj/trunk/case-studies/xml/XmlSyntax.sugj
==============================================================================
--- sugarj/trunk/case-studies/xml/XmlSyntax.sugj	Tue Jun 21 02:33:25 2011	(r23079)
+++ sugarj/trunk/case-studies/xml/XmlSyntax.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -1,20 +1,13 @@
 package xml;
 
+import editor.Editor;
+
 /*
  * https://svn.strategoxt.org/repos/StrategoXT/strategoxt/trunk/xml-front/syn/xml/
  */
 public sugar XmlSyntax {
 
 
-  rules
-    constraint-error :
-      Element(lname, attrs, content, rname) -> 
-      [(lname, "element start and end tag need to coincide"),
-       (rname, "element start and end tag need to coincide")]
-      where <not(equal)> (lname, rname) 
-
- 
-
 %% module xml-attribute
   context-free syntax
     AttrName "=" AttValue -> Attribute {cons("Attribute")}
@@ -213,7 +206,11 @@
 %% module xml-comments
 
   lexical syntax
-    CommentLeft (~[\-] | Dash)* CommentRight -> Comment
+    "<!--" -> CommentLeft
+    "-->" -> CommentRight
+    CommentLeft CommentContent* CommentRight -> Comment
+    Dash -> CommentContent
+    ~[\-] -> CommentContent
     "-" -> Dash
 
   lexical restrictions

Modified: sugarj/trunk/case-studies/xml/schema/AsDesugaring.sugj
==============================================================================
--- sugarj/trunk/case-studies/xml/schema/AsDesugaring.sugj	Tue Jun 21 02:33:25 2011	(r23079)
+++ sugarj/trunk/case-studies/xml/schema/AsDesugaring.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -5,7 +5,7 @@
 import xml.ConcreteXml;
 import xml.XmlJavaSyntax;
 import xml.XmlTextTools;
-import xml.XmlEditor;
+import xml.Editor;
 
 import xml.schema.AsEditorService;
 import xml.schema.SharedStrategies;
@@ -156,13 +156,20 @@
             where
               <xml-attr-value2string> attr => attrstring ;
               <strategy~simplecheck> (attr,attrstring) => err
+          
+          // generate a warning instead (see below)
+          ~(<val-type-attval> typename) :
+            FromMetaExpr(e) -> []
       ]| ]
       where <xml-attr-value2string> attval => typename;
             <simpleType2stratego(|typename)> content => simplecheck
             
-   
-   
-   
+  constraint-warning :
+    ValWriteDoc(ch, doc) -> warns
+    where
+      !"skipping validation of quoted attribute value" => msg;
+      <collect-all(\ Attribute(_, e at FromMetaExpr(_)) -> [(e, msg)] \)> doc => warns
+    
     
    
   // complex types to stratego
@@ -328,24 +335,37 @@
           attributes,
           contents,
           ElemName(QName(Some(URIPrefix(string~namespace)), name2)))
+        +
+        ?EmptyElement(ElemName(QName(Some(URIPrefix(string~namespace)), name1)), attrbutes2)
         ]|
 
     match-element :
       (namespace,ncname,typename) -> 
       stratego |[
-        {err :
+        {err, doc, attributes, contents, name2 :
          \  doc @
               Element(
 				        ElemName(QName(Some(URIPrefix(string~namespace)), string~ncname)),
 				        attributes,
 				        contents,
-				        ElemName(QName(Some(URIPrefix(string~namespace)), string~ncname)))
+				        name2)
             -> err
             where
               <id~(<val-type> typename) <+ ![(doc, <concat-strings>["no type definition ", string~typename, " for element ", string~ncname, " found"])]> doc => err
          \
          }
-         <+ ![(<id>, <concat-strings> ["expected element: ", string~ncname, " of namespace: ", string~namespace])]  
+         <+
+         {err, edoc, doc, attributes, name :
+         \  edoc at EmptyElement(
+                name at ElemName(QName(Some(URIPrefix(string~namespace)), string~ncname)),
+                attributes)
+            -> err
+            where
+              !Element(name, attributes, [], name) => doc;
+              <id~(<val-type> typename) <+ ![(edoc, <concat-strings>["no type definition ", string~typename, " for element ", string~ncname, " found"])]> doc => err
+         \
+         }
+         <+ ![(<id>, <concat-strings> ["expected element ", string~ncname, " of namespace ", string~namespace])]  
         ]|
     
     match-attribute :
@@ -359,7 +379,7 @@
             <id~(<val-type-attval> atttypename) <+ ![(att, <concat-strings> ["no type definition for ", string~atttypename, " of attribute ", string~ncname, " found"])]> attval => err
         \
         }
-        <+ ![(<id>, <concat-strings> ["expected attribute: ", string~ncname])]
+        <+ ![(<id>, <concat-strings> ["expected attribute ", string~ncname])]
       ]|
   
     empty-check :

Modified: sugarj/trunk/case-studies/xml/schema/AsEditorService.sugj
==============================================================================
--- sugarj/trunk/case-studies/xml/schema/AsEditorService.sugj	Tue Jun 21 02:33:25 2011	(r23079)
+++ sugarj/trunk/case-studies/xml/schema/AsEditorService.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -6,7 +6,7 @@
 import xml.XmlTextTools;
 import xml.schema.XmlSchemaJavaSyntax;
 import xml.ConcreteXml;
-import xml.XmlEditor;
+import xml.Editor;
 
 public sugar AsEditorService {
   rules
@@ -51,6 +51,7 @@
       |[  completions
             completion trigger : "<"
             ~completion
+            ~completion2
        ]|
       where
         <xml-attr-value2string> attval1 => element;
@@ -63,11 +64,18 @@
         <lookup> (type, types) => attributes;
 
         !CompletionTemplateWithSort(
-           Sort("Content"),
+           Sort("Content"), 
            String(prefix),
            <conc> (attributes, [String(">"), String(content), String(suffix)]),
            None())
-        => completion
+        => completion;
+
+        !CompletionTemplateWithSort(
+           Sort("CharData"),  // HACK to fix SGLR's misleading candidate sorts
+           String(prefix),
+           <conc> (attributes, [String(">"), String(content), String(suffix)]),
+           None())
+        => completion2
 
     
     schema-editor-type-completion :

Modified: sugarj/trunk/case-studies/xml/schema/BookSchema.sugj
==============================================================================
--- sugarj/trunk/case-studies/xml/schema/BookSchema.sugj	Tue Jun 21 02:33:25 2011	(r23079)
+++ sugarj/trunk/case-studies/xml/schema/BookSchema.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -1,6 +1,7 @@
 package xml.schema;
-
+import xml.schema.AsDesugaring;
 import xml.schema.XmlSchema;
+import xml.schema.Editor;
 
 public xmlschema BookSchema {
   <{http://www.w3.org/2001/XMLSchema}schema targetNamespace="lib">
@@ -12,14 +13,15 @@
       <{http://www.w3.org/2001/XMLSchema}choice maxOccurs="unbounded">
         <{http://www.w3.org/2001/XMLSchema}element name="author" type="Person">
         </{http://www.w3.org/2001/XMLSchema}element>
-
-        <{http://www.w3.org/2001/XMLSchema}element name="editor" type="Person">
+        
+        <{http://www.w3.org/2001/XMLSchema}element name="editions" type="Editions">
         </{http://www.w3.org/2001/XMLSchema}element>
       </{http://www.w3.org/2001/XMLSchema}choice>
       
       <{http://www.w3.org/2001/XMLSchema}attribute name="title" type="string">
       </{http://www.w3.org/2001/XMLSchema}attribute>
     </{http://www.w3.org/2001/XMLSchema}complexType>
+
     
     <{http://www.w3.org/2001/XMLSchema}complexType name="Person">
       <{http://www.w3.org/2001/XMLSchema}sequence>
@@ -29,5 +31,24 @@
       </{http://www.w3.org/2001/XMLSchema}attribute>
     </{http://www.w3.org/2001/XMLSchema}complexType>
 
+
+    <{http://www.w3.org/2001/XMLSchema}complexType name="Editions">
+      <{http://www.w3.org/2001/XMLSchema}sequence maxOccurs="unbounded">
+        <{http://www.w3.org/2001/XMLSchema}element name="edition" type="Edition">
+        </{http://www.w3.org/2001/XMLSchema}element>
+      </{http://www.w3.org/2001/XMLSchema}sequence>
+    </{http://www.w3.org/2001/XMLSchema}complexType>
+
+
+    <{http://www.w3.org/2001/XMLSchema}complexType name="Edition">
+      <{http://www.w3.org/2001/XMLSchema}sequence>
+      </{http://www.w3.org/2001/XMLSchema}sequence>
+      
+      <{http://www.w3.org/2001/XMLSchema}attribute name="year" type="string">
+      </{http://www.w3.org/2001/XMLSchema}attribute>
+      <{http://www.w3.org/2001/XMLSchema}attribute name="publisher" type="string">
+      </{http://www.w3.org/2001/XMLSchema}attribute>
+    </{http://www.w3.org/2001/XMLSchema}complexType>
+
   </{http://www.w3.org/2001/XMLSchema}schema>
 }

Modified: sugarj/trunk/case-studies/xml/schema/BookSchemaTest.sugj
==============================================================================
--- sugarj/trunk/case-studies/xml/schema/BookSchemaTest.sugj	Tue Jun 21 02:33:25 2011	(r23079)
+++ sugarj/trunk/case-studies/xml/schema/BookSchemaTest.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -1,24 +1,27 @@
 package xml.schema;
- 
+
 import org.xml.sax.ContentHandler;
 import org.xml.sax.SAXException;
 
-import xml.AsSax;
-import xml.Test; 
-import xml.XmlJavaSyntax;
-
-import xml.XmlEditor;
-
+import xml.Sugar;
+import xml.Editor;
 import xml.schema.BookSchema;
 
-public class BookSchemaTest extends Test {
-  public static void main(String[] args) throws SAXException {
-    ContentHandler ch = new BookSchemaTest();
-    
+public class BookSchemaTest {
+  public void appendBook(ContentHandler ch) throws SAXException {
+    String title = "Sweetness and Power";
     @Validate
-    ch.<{lib}book title="Sweetness and Power: The Place of Sugar in Modern History">
-         <{lib}author name="Sidney W. Mintz">
-         </{lib}author>
-       </{lib}book>; 
+    ch.<{lib}book title="{new String(title)}">
+         <{lib}author name="Sidney W. Mintz" />
+         <{lib}editions>
+           <{lib}edition year="1985" publisher="Viking Press" />
+           <{lib}edit year="1986" publisher="Penguin Books" />
+         </{lib}editions>
+         
+       </{lib}book>;   
+  }
+  
+  public void appendProceedings(ContentHandler ch)  {
+    
   }
-} 
\ No newline at end of file
+}
\ No newline at end of file

Added: sugarj/trunk/case-studies/xml/schema/Editor.sugj
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sugarj/trunk/case-studies/xml/schema/Editor.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -0,0 +1,12 @@
+package xml.schema;
+
+import xml.Editor;
+import xml.schema.XmlSchemaJavaSyntax;
+
+public editor services Editor {
+  outliner
+    XsdSugarDec
+  
+  folding
+    XsdSugarDec
+}
\ No newline at end of file

Modified: sugarj/trunk/case-studies/xml/schema/XmlSchema.sugj
==============================================================================
--- sugarj/trunk/case-studies/xml/schema/XmlSchema.sugj	Tue Jun 21 02:33:25 2011	(r23079)
+++ sugarj/trunk/case-studies/xml/schema/XmlSchema.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -4,9 +4,10 @@
 import xml.schema.XmlSchemaJavaSyntax;
 
 import xml.schema.AsEditorService;
-
 import xml.schema.SharedStrategies;   
 
+import xml.schema.Editor;
+
 public xmlschema XmlSchema {
   <{http://www.w3.org/2001/XMLSchema}schema 
     targetNamespace="http://www.w3.org/2001/XMLSchema">

Modified: sugarj/trunk/case-studies/xml/schema/XmlSchemaJavaSyntax.sugj
==============================================================================
--- sugarj/trunk/case-studies/xml/schema/XmlSchemaJavaSyntax.sugj	Tue Jun 21 02:33:25 2011	(r23079)
+++ sugarj/trunk/case-studies/xml/schema/XmlSchemaJavaSyntax.sugj	Tue Jun 21 09:44:12 2011	(r23080)
@@ -43,4 +43,4 @@
     XsdSugarDec : XsdSugarDecHead * XsdSugarBody -> XsdSugarDec
     XsdSugarDecHead : list(AnnoOrSugarMod) * JavaId -> XsdSugarDecHead
     XsdSugarBody : XsdDefinition -> XsdSugarBody
-}
\ No newline at end of file
+}

From M.A.Akhter at student.tudelft.nl  Tue Jun 21 16:14:51 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Tue, 21 Jun 2011 14:14:51 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23081 - in
	spoofax-contrib/LwcSPXLang/src: . langdef
Message-ID: <20110621141451.09011108C054@mx3.tudelft.nl>

Author: MdAdilAkhter
Date: Tue Jun 21 14:14:50 2011
New Revision: 23081
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23081&sc=1

Log:
added language definitions and transformation rules for LWC SPXlang

Modified:
   spoofax-contrib/LwcSPXLang/src/langdef/entities.spx
   spoofax-contrib/LwcSPXLang/src/langdef/method.spx
   spoofax-contrib/LwcSPXLang/src/langdef/statement.spx
   spoofax-contrib/LwcSPXLang/src/languagedescription.spx
   spoofax-contrib/LwcSPXLang/src/main.spx

Modified: spoofax-contrib/LwcSPXLang/src/langdef/entities.spx
==============================================================================
--- spoofax-contrib/LwcSPXLang/src/langdef/entities.spx	Tue Jun 21 09:44:12 2011	(r23080)
+++ spoofax-contrib/LwcSPXLang/src/langdef/entities.spx	Tue Jun 21 14:14:50 2011	(r23081)
@@ -74,7 +74,45 @@
 	  type-of :
 	  	This() -> Type(<get-annotated-scope>)
   		
+module generate
+
+	rules
+	  to-java:
+	    Module(x, d*) ->
+	    $[ package [x];
+	       
+	       [d'*]
+	     ]
+	    with
+	      d'* := <collect(to-java)> d*
+	  
+	  to-java:
+	    Entity(x, p*) ->
+	    $[ class [x] {
+	           [p'*]
+	       }
+	     ]
+	    with
+	      p'* := <to-java> p*
+	
+	  to-java:
+	    Property(x, Type(t)) -> $[
+	      private [t] [x];
+	      
+	      public [t] get_[x] {
+	          return [x];
+	      }
+	      
+	      public void set_[x] ([t] [x]) {
+	          this.[x] = [x];    
+	      }
+	  ]
+	  
+	  to-java:
+	    Type(t) -> t
 	
+	  to-java:
+	    t* -> <map(to-java)> t*	
 	
 
 	

Modified: spoofax-contrib/LwcSPXLang/src/langdef/method.spx
==============================================================================
--- spoofax-contrib/LwcSPXLang/src/langdef/method.spx	Tue Jun 21 09:44:12 2011	(r23080)
+++ spoofax-contrib/LwcSPXLang/src/langdef/method.spx	Tue Jun 21 14:14:50 2011	(r23081)
@@ -8,4 +8,68 @@
     MethodDef                                 -> EntityElem
   	MethodCall                                -> Exp
 
-	 
\ No newline at end of file
+
+module method-signatures 
+	signature
+  	constructors
+  		Methods    : Scope -> Namespace
+  		
+module mehtod-transformations  		
+	 imports languages.commonLang
+	 
+	 rules
+	 		
+	  type-of: 
+	  	MethodDef(name, params, Some(type), bl) -> type
+  	
+	  is-function-def = 
+	  	?MethodDef(_,_,_,_) 
+  
+	  name-of: 
+	  	MethodDef(name, params, rt, bl) -> name
+  	
+	  arg-types :
+	  	MethodDef(name, params, rt, bl) -> <map(?Param(_,<id>))> params
+	  	
+	  signature-of :
+	  	MethodDef(name, params, rt, bl) -> (name, <arg-types>)
+	  	 
+	  rename:
+	  	d at MethodDef(name, params, rt, bl) -> <annotate-scope(is-entity; name-of)> d'
+	  	where 
+	  	  new-scope(<all(rename-all)> d => d')
+  	
+	  store: 
+	  	d at MethodDef(name, params, rt, bl) -> d
+	  	where 
+	  	  <map-declaration(|Methods(<get-annotated-scope>d))> (<signature-of>d, d)
+	  	
+	  editor-error:
+	    d at MethodDef(name, params, rt, bl) -> (name, $[Multiple declarations for function [name]])
+	    where 
+	      not(<signature-of; get-unique-declaration(|Methods(<get-annotated-scope> d))> d)
+	  	  	   		
+	rules // method calls
+	   
+	  namespace-of:
+	  	MethodCall(e, name, args) -> Methods(<type-of; name-of> e)
+	  	
+	  signature-of:
+	  	MethodCall(e, name, args) -> (name, <map(type-of)>args)
+		 
+	  type-of:
+	  	call at MethodCall(e, name, args) -> type
+	  	where 
+	  	  signature-of; get-declaration(|<namespace-of>call); debug(!"method call type: ") => type
+	  	  
+	  type-of:
+	  	e at MethodCall(e1, name, args) -> type
+	  	where <get-declaration(|Methods(<get-annotated-scope>e))> <signature-of> e => type
+	  	
+	  editor-error:
+	  	e at MethodCall(e1,name,args) -> (name, $[No method [<pp-sig>sig] declared for [<pp>type]])
+	  	where 
+	  	  <type-of> e1 => type;
+	  	  <signature-of> e => sig;
+	  	  not(<type-of>e)
+	
\ No newline at end of file

Modified: spoofax-contrib/LwcSPXLang/src/langdef/statement.spx
==============================================================================
--- spoofax-contrib/LwcSPXLang/src/langdef/statement.spx	Tue Jun 21 09:44:12 2011	(r23080)
+++ spoofax-contrib/LwcSPXLang/src/langdef/statement.spx	Tue Jun 21 14:14:50 2011	(r23081)
@@ -12,4 +12,22 @@
   	Exp ";"            -> Statement {cons("Statement")} 
 	context-free syntax
   	"if" "(" Exp ")" Block "else" Block -> Statement {cons("If")}
-  	"while" "(" Exp ")" Block           -> Statement {cons("While")} 
\ No newline at end of file
+  	"while" "(" Exp ")" Block           -> Statement {cons("While")}
+
+module statement-signatures
+
+
+module statement-transformations
+	imports languages.commonLang
+	rules
+		 rename:
+			Block(stats) -> Block(stats')
+			where new-scope(<rename-all>stats => stats')
+	
+		editor-error:
+			s at Assign(e1, e2) -> (s, $[Cannot assign [<pp>type2] to [<pp>type1]])
+			where 
+	  		type1 := <type-of> e1;
+	  		type2 := <type-of> e2;
+	  		not( <type-compatible>(type1, type2))  
+  	 
\ No newline at end of file

Modified: spoofax-contrib/LwcSPXLang/src/languagedescription.spx
==============================================================================
--- spoofax-contrib/LwcSPXLang/src/languagedescription.spx	Tue Jun 21 09:44:12 2011	(r23080)
+++ spoofax-contrib/LwcSPXLang/src/languagedescription.spx	Tue Jun 21 14:14:50 2011	(r23081)
@@ -24,4 +24,4 @@
  
   		builder  : "Analysis"  = analyze-builder (openeditor) (realtime) (meta) (source)  
  
-	    
+	    builder : "Generate Java code (for selection)"  = generate-java (openeditor) (realtime)

Modified: spoofax-contrib/LwcSPXLang/src/main.spx
==============================================================================
--- spoofax-contrib/LwcSPXLang/src/main.spx	Tue Jun 21 09:44:12 2011	(r23080)
+++ spoofax-contrib/LwcSPXLang/src/main.spx	Tue Jun 21 14:14:50 2011	(r23081)
@@ -1,21 +1,26 @@
 package languages.spx.lwc
-
+ 
 //TODO FIX : more refactoring on stratego codes 
-
 module main-definition
   context-free syntax
     Module  -> Start
          
 
+module main-generator
+	rules
+		 generate-java:
+	    (selected, position, ast, path, project-path) -> (filename, result)
+	    with
+	      filename := <guarantee-extension(|"java")> path;
+	      result   := <to-java> selected 
+	 
 module main-trans
 	imports 
   	languages.commonLang
-  
   strategies 
 	  pp = fail	       
 	
 	strategies // analysis
-
 	  analyze     = desugar-all; rename-all; store-all 
 	  desugar-all = innermost(desugar)
 	  rename-all  = alltd(propose <+ rename)
@@ -31,9 +36,7 @@
 	  type-compatible = fail
 	 
 	rules // editor
-	  
   	importing(|imp) = /*{| Imported : */ rules(Imported : imp) /* ; s |} */
-	
 	  when-not-imported(s) :
 	  	imp -> imp
 	  	where {| Imported : if not( <Imported> imp ) then rules(Imported : imp) else debug(!"already imported: ") end |} 
@@ -48,7 +51,7 @@
 	      filename := <guarantee-extension(|"aterm")> path;
 	      result   := ast' // we just return the input term
 		
-rules	 			
+	rules	 			
 	  editor-error   = fail  
 	  editor-warning = fail
 	  editor-note    = fail

From M.A.Akhter at student.tudelft.nl  Tue Jun 21 17:38:56 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Tue, 21 Jun 2011 15:38:56 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23082 - in
	spoofax-contrib/LwcSPXLang/src: langdef services/editor
Message-ID: <20110621153856.2B98C7F8149@mx1.tudelft.nl>

Author: MdAdilAkhter
Date: Tue Jun 21 15:38:55 2011
New Revision: 23082
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23082&sc=1

Log:
incorporated editor services in lwc spxlang. Conversion to SPX is done for LWC.

Added:
   spoofax-contrib/LwcSPXLang/src/services/editor/folding.spx
Modified:
   spoofax-contrib/LwcSPXLang/src/langdef/arithmetic.spx
   spoofax-contrib/LwcSPXLang/src/services/editor/analyze.spx
   spoofax-contrib/LwcSPXLang/src/services/editor/coloring.spx
   spoofax-contrib/LwcSPXLang/src/services/editor/hover.spx
   spoofax-contrib/LwcSPXLang/src/services/editor/outliner.spx
   spoofax-contrib/LwcSPXLang/src/services/editor/proposer.spx
   spoofax-contrib/LwcSPXLang/src/services/editor/resolver.spx

Modified: spoofax-contrib/LwcSPXLang/src/langdef/arithmetic.spx
==============================================================================
--- spoofax-contrib/LwcSPXLang/src/langdef/arithmetic.spx	Tue Jun 21 14:14:50 2011	(r23081)
+++ spoofax-contrib/LwcSPXLang/src/langdef/arithmetic.spx	Tue Jun 21 15:38:55 2011	(r23082)
@@ -13,6 +13,8 @@
   	>
   	Exp "+" Exp -> Exp
 
+//test
+
 module arithmetic-transformation
 	rules
 		type-of :

Modified: spoofax-contrib/LwcSPXLang/src/services/editor/analyze.spx
==============================================================================
--- spoofax-contrib/LwcSPXLang/src/services/editor/analyze.spx	Tue Jun 21 14:14:50 2011	(r23081)
+++ spoofax-contrib/LwcSPXLang/src/services/editor/analyze.spx	Tue Jun 21 15:38:55 2011	(r23082)
@@ -8,11 +8,14 @@
 		editor-analyze:
 	    (ast, path, project-path) -> (ast', errors, warnings, notes)
 	    with
+	      debug(!"Inside analyze: ");
 	      editor-init;
 	      rules( CurrentFile := path );
-		  <analyze> ast => ast';
+		  	<analyze> ast => ast';
 	      <collect-all(editor-error,   conc)> ast' => errors;
 	      <collect-all(editor-warning, conc)> ast' => warnings;
 	      <collect-all(editor-note,    conc)> ast' => notes
 
- 
\ No newline at end of file
+module analyze-observer 
+	builders
+		observer : editor-analyze         
\ No newline at end of file

Modified: spoofax-contrib/LwcSPXLang/src/services/editor/coloring.spx
==============================================================================
--- spoofax-contrib/LwcSPXLang/src/services/editor/coloring.spx	Tue Jun 21 14:14:50 2011	(r23081)
+++ spoofax-contrib/LwcSPXLang/src/services/editor/coloring.spx	Tue Jun 21 15:38:55 2011	(r23082)
@@ -3,37 +3,34 @@
 
 module codecolorer-service
 
-	colorer 
-		ID :  85 85 85 italic 
-		
 	colorer Default, token-based highlighting
-	                                  
-	  keyword    : 127 0 85 bold      
-	  identifier : default            
-	  string     : blue               
-	  number     : darkgreen          
-	  var        : 255 0 100 italic   
-	  operator   : 0 0 128            
-	  layout     : 63 127 95 italic   
+                                  
+  keyword    : 127 0 85 bold      
+  identifier : default            
+  string     : blue               
+  number     : darkgreen          
+  var        : 255 0 100 italic   
+  operator   : 0 0 128            
+  layout     : 63 127 95 italic   
 
-	colorer System colors
-	                            
-	  darkred   = 128 0 0       
-	  red       = 255 0 0       
-	  darkgreen = 0 128 0       
-	  green     = 0 255 0       
-	  darkblue  = 0 0 128       
-	  blue      = 0 0 255       
-	  cyan      = 0 255 255     
-	  magenta   = 255 0 255     
-	  yellow    = 255 255 0     
-	  white     = 255 255 255   
-	  black     = 0 0 0         
-	  gray      = 128 128 128   
-	  grey      = gray          
-	  orange    = 255 165 0      
-	  pink      = 255 105 180   
-	  brown     = 139 69 19     
-	  default   = _            
+colorer System colors
+                            
+  darkred   = 128 0 0       
+  red       = 255 0 0       
+  darkgreen = 0 128 0       
+  green     = 0 255 0       
+  darkblue  = 0 0 128       
+  blue      = 0 0 255       
+  cyan      = 0 255 255     
+  magenta   = 255 0 255     
+  yellow    = 255 255 0     
+  white     = 255 255 255   
+  black     = 0 0 0         
+  gray      = 128 128 128   
+  grey      = gray          
+  orange    = 255 165 0     
+  pink      = 255 105 180   
+  brown     = 139 69 19     
+  default   = _           
   
 	
\ No newline at end of file

Added: spoofax-contrib/LwcSPXLang/src/services/editor/folding.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/src/services/editor/folding.spx	Tue Jun 21 15:38:55 2011	(r23082)
@@ -0,0 +1,10 @@
+package languages.spx.lwc
+
+module codefolding-service
+	
+	folding 
+		Module.Module
+  	Entity.Entity
+  	FunctionDef.FunctionDef
+	  
+		
\ No newline at end of file

Modified: spoofax-contrib/LwcSPXLang/src/services/editor/hover.spx
==============================================================================
--- spoofax-contrib/LwcSPXLang/src/services/editor/hover.spx	Tue Jun 21 14:14:50 2011	(r23081)
+++ spoofax-contrib/LwcSPXLang/src/services/editor/hover.spx	Tue Jun 21 15:38:55 2011	(r23082)
@@ -5,3 +5,6 @@
   	editor-hover: 
   		(node, position, ast, path, project-path) -> str
     		where <hover> node => str
+	
+	references
+		hover _     : editor-hover
\ No newline at end of file

Modified: spoofax-contrib/LwcSPXLang/src/services/editor/outliner.spx
==============================================================================
--- spoofax-contrib/LwcSPXLang/src/services/editor/outliner.spx	Tue Jun 21 14:14:50 2011	(r23081)
+++ spoofax-contrib/LwcSPXLang/src/services/editor/outliner.spx	Tue Jun 21 15:38:55 2011	(r23082)
@@ -1,3 +1,12 @@
 package languages.spx.lwc
 
-module outline-service
\ No newline at end of file
+module outline-service
+
+	outliner 
+		Module.Module
+  	Entity.Entity
+ 		FunctionDef.FunctionDef
+  	FunctionCall.FunctionCall
+  	XmlElem.XML
+  	Statement.If
+  	Statement.While
\ No newline at end of file

Modified: spoofax-contrib/LwcSPXLang/src/services/editor/proposer.spx
==============================================================================
--- spoofax-contrib/LwcSPXLang/src/services/editor/proposer.spx	Tue Jun 21 14:14:50 2011	(r23081)
+++ spoofax-contrib/LwcSPXLang/src/services/editor/proposer.spx	Tue Jun 21 15:38:55 2011	(r23082)
@@ -13,6 +13,26 @@
 	  		<oncetd(where(propose => proposals))> ast' <+
 	  		<debug> ast ; ![] => proposals  	
 
+module codecompletion-triggers
+
 	completions
+	  // Semantic (identifier) completion:   
+	                                         
 	  completion proposer                  : editor-complete
-	  completion trigger                   : ":"
+	                                         
+	  completion trigger                   : ":"
+	  
+	  
+module codecompletion-templates	
+
+	completions
+                                                                 
+	  // Syntax completion:                                          
+	                                                                 
+	  completion template : Start =      "module " <m> (blank)       
+	                                                                 
+	  completion template : Definition = "entity " <e> " {}" (blank) 
+	                                                                 
+	  completion template : Property = "" <x> " : " <T> (blank)       
+	                                                                 
+

Modified: spoofax-contrib/LwcSPXLang/src/services/editor/resolver.spx
==============================================================================
--- spoofax-contrib/LwcSPXLang/src/services/editor/resolver.spx	Tue Jun 21 14:14:50 2011	(r23081)
+++ spoofax-contrib/LwcSPXLang/src/services/editor/resolver.spx	Tue Jun 21 15:38:55 2011	(r23082)
@@ -6,4 +6,10 @@
     	(node, position, ast, path, project-path) -> target
     	where 
       	<resolve> node => target 
- 
\ No newline at end of file
+ 
+ 	references
+	                
+	  reference _ : editor-resolve
+	  
+	  
+	 
\ No newline at end of file

From M.A.Akhter at student.tudelft.nl  Tue Jun 21 17:40:26 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Tue, 21 Jun 2011 15:40:26 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23083 -
	spoofax-contrib/LwcSPXLang/test
Message-ID: <20110621154026.B66987F8161@mx1.tudelft.nl>

Author: MdAdilAkhter
Date: Tue Jun 21 15:40:26 2011
New Revision: 23083
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23083&sc=1

Log:
Test *.lwx examples

Added:
   spoofax-contrib/LwcSPXLang/test/blog.lwx
   spoofax-contrib/LwcSPXLang/test/entities.lwx
   spoofax-contrib/LwcSPXLang/test/entitiesA.lwx
   spoofax-contrib/LwcSPXLang/test/entitiesB.lwx
   spoofax-contrib/LwcSPXLang/test/functions.lwx
   spoofax-contrib/LwcSPXLang/test/functionsProperties.lwx
   spoofax-contrib/LwcSPXLang/test/imports.lwx
   spoofax-contrib/LwcSPXLang/test/module.lwx
   spoofax-contrib/LwcSPXLang/test/moduleA.lwx
   spoofax-contrib/LwcSPXLang/test/moduleB.lwx
   spoofax-contrib/LwcSPXLang/test/moduleC.lwx
   spoofax-contrib/LwcSPXLang/test/primitives.lwx
   spoofax-contrib/LwcSPXLang/test/propertiesA.lwx
   spoofax-contrib/LwcSPXLang/test/return.lwx
   spoofax-contrib/LwcSPXLang/test/thistest.lwx
   spoofax-contrib/LwcSPXLang/test/users.lwx

Added: spoofax-contrib/LwcSPXLang/test/blog.lwx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/test/blog.lwx	Tue Jun 21 15:40:26 2011	(r23083)
@@ -0,0 +1,61 @@
+module blog 
+
+//imports users 
+
+entity User {
+  name : String  
+}
+         
+entity Blog {  
+  post     : BlogPost    
+  author   : User  
+  audience : User    
+  author   : User   
+   
+  comment(c : String) { 
+  	this.post.title; 
+  	this.post.comment(c); // method call on property
+  }
+}
+  
+comment(blog : Blog, c : String, d : String) { 
+  var x : Int; 
+  //var y : Int;
+  var z : String; // z is not used -> warning
+  { 
+  	var y : String; 
+    blog.comment(c); 
+    y + 1; // type error: local y is a String
+  }  
+  x := ""; // cannot assign String to Int
+  comment(blog, c, x + 0);  // resolve to function def
+  comment(blog, c, x + 0 + y);  // y not declared
+}
+
+comment2(blog : Blog, c : String, i : Int) {  
+  comment(blog,c,i);
+  comment(blog, c, "", 4) + 4; 
+}
+
+comment(blog : Blog, c : String, i : Int) { 
+  comment2(blog,c,i);
+}
+ 
+entity BlogPost {
+  blog    : Blog
+  title   : String
+  author  : User   
+  body    : String 
+  created : DateTime
+  
+  comment3(c : String) {}
+}
+
+entity String { }
+entity DateTime { }
+entity Int { }
+
+entity URL {
+  location : String
+}
+

Added: spoofax-contrib/LwcSPXLang/test/entities.lwx
==============================================================================

Added: spoofax-contrib/LwcSPXLang/test/entitiesA.lwx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/test/entitiesA.lwx	Tue Jun 21 15:40:26 2011	(r23083)
@@ -0,0 +1,12 @@
+module entitiesA
+
+imports entitiesB 
+imports example
+
+entity A { }
+
+entity A { }
+
+entity B { }
+
+entity C { }
\ No newline at end of file

Added: spoofax-contrib/LwcSPXLang/test/entitiesB.lwx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/test/entitiesB.lwx	Tue Jun 21 15:40:26 2011	(r23083)
@@ -0,0 +1,4 @@
+module entitiesB
+
+entity C {
+}

Added: spoofax-contrib/LwcSPXLang/test/functions.lwx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/test/functions.lwx	Tue Jun 21 15:40:26 2011	(r23083)
@@ -0,0 +1,18 @@
+module functions
+
+imports primitives
+
+foo(x : Int) {
+  return 3 + x; // function has no return type
+}
+
+bar(x : Int) : Int { // this is fine
+  return 3 + x;        
+} 
+ 
+baz(x : Int) : Int {
+  foo(x); 
+  x := bar(x + "") + "";  
+  // function should have return statement
+}
+ 
\ No newline at end of file

Added: spoofax-contrib/LwcSPXLang/test/functionsProperties.lwx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/test/functionsProperties.lwx	Tue Jun 21 15:40:26 2011	(r23083)
@@ -0,0 +1,11 @@
+module functionsProperties
+
+imports propertiesA
+
+comment(b : Blog, x : String) {
+  b.comment := x;
+}
+
+comment(b : Blog) {
+  comment(b, "3"); 
+}  
\ No newline at end of file

Added: spoofax-contrib/LwcSPXLang/test/imports.lwx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/test/imports.lwx	Tue Jun 21 15:40:26 2011	(r23083)
@@ -0,0 +1,14 @@
+module imports
+
+imports module  
+
+entity A{
+  b : B 
+  c : C 
+}      
+
+entity C {
+  a : A
+  b : C 
+} 
+             
\ No newline at end of file

Added: spoofax-contrib/LwcSPXLang/test/module.lwx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/test/module.lwx	Tue Jun 21 15:40:26 2011	(r23083)
@@ -0,0 +1,27 @@
+module module
+
+imports primitives
+
+entity B{
+  name : String
+  foo : Bla
+  //a : A 
+} 
+
+entity A{ 
+  b : B  
+  
+}   
+
+entity A {
+	
+}
+  
+       
+entity String{}  
+
+foo(x : String) : String {
+  x := 1;
+  return "aa";
+}   
+  
\ No newline at end of file

Added: spoofax-contrib/LwcSPXLang/test/moduleA.lwx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/test/moduleA.lwx	Tue Jun 21 15:40:26 2011	(r23083)
@@ -0,0 +1,10 @@
+module moduleA
+
+imports moduleB
+
+imports moduleC
+
+imprts Bla 
+
+
+   
\ No newline at end of file

Added: spoofax-contrib/LwcSPXLang/test/moduleB.lwx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/test/moduleB.lwx	Tue Jun 21 15:40:26 2011	(r23083)
@@ -0,0 +1,4 @@
+module moduleB
+
+imports moduleC 
+imports moduleD  
\ No newline at end of file

Added: spoofax-contrib/LwcSPXLang/test/moduleC.lwx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/test/moduleC.lwx	Tue Jun 21 15:40:26 2011	(r23083)
@@ -0,0 +1 @@
+module moduleD
\ No newline at end of file

Added: spoofax-contrib/LwcSPXLang/test/primitives.lwx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/test/primitives.lwx	Tue Jun 21 15:40:26 2011	(r23083)
@@ -0,0 +1,7 @@
+module primitives
+
+entity String{}
+
+entity Int{}
+
+entity Bool{}
\ No newline at end of file

Added: spoofax-contrib/LwcSPXLang/test/propertiesA.lwx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/test/propertiesA.lwx	Tue Jun 21 15:40:26 2011	(r23083)
@@ -0,0 +1,16 @@
+module propertiesA
+
+imports primitives
+
+entity Blog {
+  name    : String
+  author  : User 
+  posts   : BlogPosts
+  comment : String
+  foo : User
+}
+
+entity User {
+  name : String
+}
+

Added: spoofax-contrib/LwcSPXLang/test/return.lwx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/test/return.lwx	Tue Jun 21 15:40:26 2011	(r23083)
@@ -0,0 +1,20 @@
+module functions
+
+bar(x : Int) : Int { // this is fine
+  return 3 + x;  
+}
+
+foo(x : Int) {
+  return 3 + x; // should not have return statement
+}
+
+boo(x : Int) : String { 
+  return 3 + x; // return statement should be consistent with return type
+}
+
+baz(x : Int, y : Int) : Int {   
+  // return statement missing
+}  
+
+entity Int {}
+entity String {}

Added: spoofax-contrib/LwcSPXLang/test/thistest.lwx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/test/thistest.lwx	Tue Jun 21 15:40:26 2011	(r23083)
@@ -0,0 +1,19 @@
+module thistest
+
+entity A {
+  a : String
+  b : B
+  
+  test() {
+  	this.a := ""; 
+  }
+}
+
+entity B { 
+  a : A
+  test() {
+  	this.a.test();
+  }
+}
+
+entity String { }  
\ No newline at end of file

Added: spoofax-contrib/LwcSPXLang/test/users.lwx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-contrib/LwcSPXLang/test/users.lwx	Tue Jun 21 15:40:26 2011	(r23083)
@@ -0,0 +1,8 @@
+module users
+
+entity User {
+  name     : String
+  password : String 
+  homepage : URL
+}
+  
\ No newline at end of file

From M.A.Akhter at student.tudelft.nl  Tue Jun 21 17:42:02 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Tue, 21 Jun 2011 15:42:02 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23084 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/editor
Message-ID: <20110621154202.0B67F2B804E@mx2.tudelft.nl>

Author: MdAdilAkhter
Date: Tue Jun 21 15:42:01 2011
New Revision: 23084
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23084&sc=1

Log:


Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/editor/SpoofaxLang-Colorer.esv

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/editor/SpoofaxLang-Colorer.esv
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/editor/SpoofaxLang-Colorer.esv	Tue Jun 21 15:40:26 2011	(r23083)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/editor/SpoofaxLang-Colorer.esv	Tue Jun 21 15:42:01 2011	(r23084)
@@ -67,10 +67,10 @@
   StrategyDef : 0 64 128 bold
   Overlay     : 0 64 128 bold
 
-  //strategies    = 0    0    0
+  //strategies  = 0    0    0
   strategycalls = 0   64  128
   terms         = 0    0    0
-  vars          = 24 170 222 242 242 242
+  vars          = 0    0    0 bold
   sdefault      = 0    0    0
 
   _.RootApp : strategycalls

From tobivollebregt at gmail.com  Wed Jun 22 13:11:15 2011
From: tobivollebregt at gmail.com (Tobi Vollebregt)
Date: Wed, 22 Jun 2011 11:11:15 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23085 - in
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans: .
	codegen codegen/sdf codegen/str codegen/template
	unit-tests/templatelang unit-tests/utils utils
Message-ID: <20110622111115.F0E062B808A@mx2.tudelft.nl>

Author: tvo
Date: Wed Jun 22 11:11:15 2011
New Revision: 23085
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23085&sc=1

Log:
SpoofaxLang/TemplateLang:
* Add test for sdf2conflicts
* Collect all generated SDF sections and resolve priorities only at the end;
  with the old model an instance of a production in a priority section
  must be in the same file as the main instance of the production.
* Revert removal of double-quote in SDF generation, this broke equality
  between templates and equivalent productions.

Added:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/utils/   (props changed)
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/utils/sdf2conflicts.meta
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/utils/sdf2conflicts.str
Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/compile.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/sdf/to-sdf.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/str/to-stratego.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/template/to-sdf.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/spoofaxlang.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/templatelang/to-sdf.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/sdf2conflicts.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/compile.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/compile.str	Tue Jun 21 15:42:01 2011	(r23084)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/compile.str	Wed Jun 22 11:11:15 2011	(r23085)
@@ -41,7 +41,7 @@
 							);
 							compiler-init; // initializing compiler session
 							where(<debug-compiler>$[============Initialization is done  ==============]);
-							s;
+							(s <+ <debug-compiler>$[============Compile session FAILED ==============]; fail);
 				      ?x
 				    ); !x
 			|}
@@ -91,7 +91,7 @@
 
 	// compiles all the packages stored at the filepath specified
 	compile-packages-of: file-abs-path -> issues*
-	where 
+	where
 		<debug-compiler>$[Compiling packages of  [<pp-aterm-forced>file-abs-path]]
 	where
 			Enable-Caching;

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/sdf/to-sdf.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/sdf/to-sdf.str	Tue Jun 21 15:42:01 2011	(r23084)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/sdf/to-sdf.str	Wed Jun 22 11:11:15 2011	(r23085)
@@ -50,7 +50,7 @@
     	;<debug-compiler>$[ Codegen | SDF | Found Section + Imports for the following module [<pp-aterm> module-untyped-qname].]
     where
       // sdf2conflicts here collects information for the parenthesation in the prettyprinter
-    	sdf-string       := <pp-sdf-string'> 'module(<qname-to-path>module-untyped-qname, <to-sdf-imports-block>section* , <to-sdf-section-block;sdf2conflicts>section* )
+    	sdf-string       := <pp-sdf-string'> 'module(<qname-to-path>module-untyped-qname, <to-sdf-imports-block>section* , <to-sdf-section-block;sdf2conflicts-store-sdf>section* )
     	;<debug-compiler>$[ Codegen | SDF | Saving the artifacts of [<pp-aterm> module-untyped-qname].]
 		where
 			<save-artifact(| package-untyped-qname , root-directory, output-path)>sdf-string;
@@ -69,12 +69,12 @@
  		with
  			resultant-sorts := <get-sdf-start-symbols-to-sync ; is-not-empty-list <+ ![]>;
  			if not(!resultant-sorts => []) then
- 				start-symbol-syntax := [exports(context-free-start-symbols(resultant-sorts))]	 
+ 				start-symbol-syntax := [exports(context-free-start-symbols(resultant-sorts))]
  			else
  				start-symbol-syntax := [exports(resultant-sorts)]
- 			end	  
+ 			end
  		where
- 			sdf-string := 
+ 			sdf-string :=
 				<pp-sdf-string'>
 				'module(
   				unparameterized(main-sdf-module-name)

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/str/to-stratego.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/str/to-stratego.str	Tue Jun 21 15:42:01 2011	(r23084)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/str/to-stratego.str	Wed Jun 22 11:11:15 2011	(r23085)
@@ -24,6 +24,7 @@
 imports
 	normalize/signatures
 	utils/contract
+	utils/sdf2conflicts
 
 
 
@@ -96,7 +97,8 @@
 			<debug-compiler>$[ Codegen | STR | Generation of Main STR Module for package : [<pp-aterm> package-qname] is done.]
 	  with
 	    <debug-compiler>$[ Codegen | STR | Generating prettyprinter from package-name: [<pp-aterm>package-qname]];
-	    {|DeclaredModule, GetEnclosingModuleName:
+	    {|DeclaredModule, GetEnclosingModuleName, SubtermConflicts:
+	      <sdf2conflicts> [];
 	      // HACK: this lacks any sanity wrt the original modules in which the SDF was placed ...
 	      rules(
 	        DeclaredModule :+ "__prettyprinter" -> "__prettyprinter"

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/template/to-sdf.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/template/to-sdf.str	Tue Jun 21 15:42:01 2011	(r23084)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/template/to-sdf.str	Wed Jun 22 11:11:15 2011	(r23085)
@@ -50,7 +50,7 @@
       let ends-with-identifier-char =
             where(
               explode-string;
-              /*un-double-quote-chars;*/
+              un-double-quote-chars;
               // Must end with idenfifier character, may not be preceded by backslash.
               reverse; ?[<is-alphanum + '_' + '-'> | <not(?['\' | _])>]
             )
@@ -87,16 +87,16 @@
     Template([]) -> []
 
   template-element-to-sdf:
-    Newline(_){ /* neither Leading() nor Trailing() */ } -> A|[ "\\n" ]|
+    Newline(_){ /* neither Leading() nor Trailing() */ } -> A|[ "\"\\n\"" ]|
     where not(use-no-newlines)
 
   template-element-to-sdf:
-    Newline(_) -> A|[ "\\n" ]|
+    Newline(_) -> A|[ "\"\\n\"" ]|
     where use-leading-newlines
     where not(has-annotation(|Leading()))
 
   template-element-to-sdf:
-    Newline(_) -> A|[ "\\n" ]|
+    Newline(_) -> A|[ "\"\\n\"" ]|
     where use-trailing-newlines
     where not(has-annotation(|Trailing()))
 
@@ -176,7 +176,7 @@
   remove-whitespace = string-as-chars(filter(not(xxx-is-whitespace)))
 
   separator-to-literal =
-    collect-one(?Separator(<remove-whitespace>)); escape//; double-quote
+    collect-one(?Separator(<remove-whitespace>)); escape; double-quote
 
   placeholder-to-sdf:
     Placeholder(_, sort(S'), Option(), _) -> A|[ S'? ]|
@@ -202,7 +202,7 @@
     string-identifier-tokenize;
     // FIXME: Case insensitive literals need ci-lit/single-quote.
     map({raw, sdf:
-      ?raw; escape; !lit(</*double-quote*/ id >); ?sdf;
+      ?raw; escape; !lit(<double-quote>); ?sdf;
       if <explode-string; last; (is-alphanum + '_')> raw then
         rules(Restrictions :+= sdf)
       end

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/spoofaxlang.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/spoofaxlang.str	Tue Jun 21 15:42:01 2011	(r23084)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/spoofaxlang.str	Wed Jun 22 11:11:15 2011	(r23085)
@@ -21,6 +21,7 @@
 	codegen/compile
 	codegen/esv/to-esv
 	codegen/sdf/to-sdf
+	codegen/sdf/to-name-analysis
   codegen/sdf/to-signature
 imports
 	normalize/main
@@ -33,6 +34,7 @@
   config
 	unit-tests/-
 	unit-tests/templatelang/-
+	unit-tests/utils/-
 imports
 	 editor/main
 	 codegen/main
@@ -70,5 +72,5 @@
       test-templatelang-to-sdf;
       test-templatelang-to-esv;
       test-templatelang-to-stratego;
-      test-templatelang-desugar
-	
\ No newline at end of file
+      test-templatelang-desugar;
+      test-sdf2conflicts

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/templatelang/to-sdf.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/templatelang/to-sdf.str	Tue Jun 21 15:42:01 2011	(r23084)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/templatelang/to-sdf.str	Wed Jun 22 11:11:15 2011	(r23085)
@@ -34,7 +34,7 @@
 
         // Put quotes around literals, get rid of conc-grammars.
         prepare-output =
-          alltd(/*lit(double-quote) + ci-lit(single-quote) + */quoted(double-quote));
+          alltd(lit(double-quote) + ci-lit(single-quote) + quoted(double-quote));
           alltd(\conc-grammars(x, y) -> [x, y]\);
           flatten-list
 

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/utils/sdf2conflicts.meta
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/utils/sdf2conflicts.meta	Wed Jun 22 11:11:15 2011	(r23085)
@@ -0,0 +1 @@
+Meta([Syntax("Stratego-Sdf2")])

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/utils/sdf2conflicts.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/utils/sdf2conflicts.str	Wed Jun 22 11:11:15 2011	(r23085)
@@ -0,0 +1,43 @@
+module sdf2conflicts
+imports
+  libstratego-lib
+  libstratego-sglr
+  lib/sdf-desugar
+  utils/sdf2conflicts
+
+strategies
+  test-sdf2conflicts =
+    test-suite(!"test-sdf2conflicts",
+      apply-test(!"  Smoke test",
+        sdf2conflicts;
+        // Check the result
+        !Symbol("Times", 2); bagof-SubtermConflicts;
+        ?[(1,Symbol("Times",2)),(1,Symbol("Over",2)),(1,Symbol("Minus",2)),(0,Symbol("Minus",2)),(1,Symbol("Plus",2)),(0,Symbol("Plus",2))];
+        !Symbol("Over" , 2); bagof-SubtermConflicts;
+        ?[(1,Symbol("Over",2)),(1,Symbol("Times",2)),(1,Symbol("Minus",2)),(0,Symbol("Minus",2)),(1,Symbol("Plus",2)),(0,Symbol("Plus",2))];
+        !Symbol("Plus" , 2); bagof-SubtermConflicts;
+        ?[(1,Symbol("Plus",2)),(1,Symbol("Minus",2))];
+        !Symbol("Minus", 2); bagof-SubtermConflicts;
+        ?[(1,Symbol("Minus",2)),(1,Symbol("Plus",2))]
+        , !|[
+          context-free priorities
+            {left: Exp "*" Exp -> Exp
+                   Exp "/" Exp -> Exp} >
+            {left: Exp "+" Exp -> Exp
+                   Exp "-" Exp -> Exp}
+          context-free syntax
+            Exp "*" Exp -> Exp {left, cons("\"Times\"")}
+            Exp "/" Exp -> Exp {left, cons("\"Over\"")}
+            Exp "+" Exp -> Exp {left, cons("\"Plus\"")}
+            Exp "-" Exp -> Exp {left, cons("\"Minus\"")}
+        ]|
+      )
+      // ;apply-test(!"  Bug 1",
+      //   sdf2conflicts, !Bug1())
+    )
+
+overlays
+  Bug1 = |[
+    context-free priorities
+      {non-assoc: Exp "++" -> Exp Exp "--" -> Exp}
+  ]|

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/sdf2conflicts.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/sdf2conflicts.str	Tue Jun 21 15:42:01 2011	(r23084)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/sdf2conflicts.str	Wed Jun 22 11:11:15 2011	(r23085)
@@ -19,6 +19,13 @@
 
 strategies
 
+  sdf2conflicts-store-sdf:
+    ast -> ast
+    with
+    	rules(
+    		Sdf2Conflicts-SdfSection :+= ast
+    	)
+
   /*
    * sdf2conflicts: Calculate set of conflicts that are filtered out using
    * priorities, i.e. that need parenthesis when prettyprinting.
@@ -41,13 +48,13 @@
 
           // push the attributes of a production into prod-hash
           declare-prod =
-      	    \ p@ prod(sym*, sort, attrs(attr*)) -> p
-      	      with <hashtable-pushlist(|(sym*, sort), attr*)> prod-hash \
+            \ p@ prod(sym*, sort, attrs(attr*)) -> p
+              with <hashtable-pushlist(|(sym*, sort), attr*)> prod-hash \
 
           // add all attributes defined anywhere to a production
           lookup-prod = {attr*:
-          	\ p@ prod(sym*, sort, _) -> prod(sym*, sort, attrs(attr*))
-          	  with attr* := <hashtable-get(|(sym*, sort)) <+ ![]> prod-hash \
+            \ p@ prod(sym*, sort, _) -> prod(sym*, sort, attrs(attr*))
+              with attr* := <hashtable-get(|(sym*, sort)) <+ ![]> prod-hash \
           }
 
           priority-section =
@@ -159,12 +166,12 @@
           }
 
           add-group(match) = {first, second, indices, indices':
-          	?[]
+            ?[]
           + ?[_]
           + ?[first, second | _];
             if <match> first then
               if <?with-arguments(_, default(indices))> first then
-              	indices' := <map(string-to-int)> indices;
+                indices' := <map(string-to-int)> indices;
                 <for-each-prod-pair(add-arg-gtr-prio(|indices'))> (first, second)
               else
                 <for-each-prod-pair(add-gtr-prio)> (first, second)
@@ -245,7 +252,7 @@
             )
 
       in
-        !ast;
+      	![ast, <bagof-Sdf2Conflicts-SdfSection>];
         alltd(declare-prod);
         collect-om(priority-section); concat; // List(chain(_))
         alltd(normalize-group-and-add-attributes);

From tobivollebregt at gmail.com  Wed Jun 22 13:35:24 2011
From: tobivollebregt at gmail.com (Tobi Vollebregt)
Date: Wed, 22 Jun 2011 11:35:24 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23086 - in
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans:
	codegen/template unit-tests/templatelang
Message-ID: <20110622113524.4089CCC2F8@mx4.tudelft.nl>

Author: tvo
Date: Wed Jun 22 11:35:23 2011
New Revision: 23086
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23086&sc=1

Log:
SpoofaxLang/TemplateLang: fix empty template breaking ESV generation

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/template/to-esv.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/templatelang/to-esv.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/template/to-esv.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/template/to-esv.str	Wed Jun 22 11:11:15 2011	(r23085)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/template/to-esv.str	Wed Jun 22 11:35:23 2011	(r23086)
@@ -41,7 +41,7 @@
   	  )
   	with
   	  // FIXME: desugaring should have been performed before the current strategy is invoked.
-  	  completion* := <templatelang-desugar-top; map(template-to-completion-template)> prod*
+  	  completion* := <templatelang-desugar-top; filter(template-to-completion-template)> prod*
   	with
   	  contracts(
   	    contract-requires(ListOf(?CompletionTemplateEx(_, _, _, _)) | completion*)

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/templatelang/to-esv.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/templatelang/to-esv.str	Wed Jun 22 11:11:15 2011	(r23085)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/templatelang/to-esv.str	Wed Jun 22 11:35:23 2011	(r23086)
@@ -23,7 +23,7 @@
           !x
         }
 
-        prepare-output = ![<id>]
+        prepare-output = \() -> []\ <+ ![<id>]
 
         // Run a test on a tuple (input, expected-output).
         // Input is a string containing template productions.
@@ -66,7 +66,10 @@
           <test'> ($[X.Y = <<<A?> <B?>>>],
             |[ completion template X: "Y" = (cursor) (blank) ]|);
           <test'> ($[X.Y = <<<A?> <B?> <C?>>>],
-            |[ completion template X: "Y" = (cursor) (blank) ]|)
+            |[ completion template X: "Y" = (cursor) (blank) ]|);
+
+          // Empty template (should generate nothing)
+          <test'> ($[X.Y = <<>>], ())
 
         with-newlines(s) = {|Options: {x:
           ?x; rules( Options :+ Newlines() -> x ); s

From tobivollebregt at gmail.com  Wed Jun 22 14:23:03 2011
From: tobivollebregt at gmail.com (Tobi Vollebregt)
Date: Wed, 22 Jun 2011 12:23:03 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23087 -
	spoofax-contrib/DatabaseTemplateLang/.externalToolBuilders
Message-ID: <20110622122303.4DCE07F819D@mx1.tudelft.nl>

Author: tvo
Date: Wed Jun 22 12:23:02 2011
New Revision: 23087
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23087&sc=1

Log:
DatabaseTemplateLang: reference the correct ant build file

Modified:
   spoofax-contrib/DatabaseTemplateLang/.externalToolBuilders/DatabaseTemplateLang build.main.xml.launch

Modified: spoofax-contrib/DatabaseTemplateLang/.externalToolBuilders/DatabaseTemplateLang build.main.xml.launch
==============================================================================
--- spoofax-contrib/DatabaseTemplateLang/.externalToolBuilders/DatabaseTemplateLang build.main.xml.launch	Wed Jun 22 11:35:23 2011	(r23086)
+++ spoofax-contrib/DatabaseTemplateLang/.externalToolBuilders/DatabaseTemplateLang build.main.xml.launch	Wed Jun 22 12:23:02 2011	(r23087)
@@ -2,8 +2,12 @@
 <launchConfiguration type="org.eclipse.ant.AntLaunchConfigurationType">
 <stringAttribute key="bad_container_name" value=".externalToolBuilders"/>
 <booleanAttribute key="org.eclipse.ant.ui.DEFAULT_VM_INSTALL" value="false"/>
-<listAttribute key="org.eclipse.debug.core.MAPPED_RESOURCE_PATHS"/>
-<listAttribute key="org.eclipse.debug.core.MAPPED_RESOURCE_TYPES"/>
+<listAttribute key="org.eclipse.debug.core.MAPPED_RESOURCE_PATHS">
+<listEntry value="/DatabaseTemplateLang/build.spx.packages.xml"/>
+</listAttribute>
+<listAttribute key="org.eclipse.debug.core.MAPPED_RESOURCE_TYPES">
+<listEntry value="1"/>
+</listAttribute>
 <booleanAttribute key="org.eclipse.debug.ui.ATTR_LAUNCH_IN_BACKGROUND" value="false"/>
 <listAttribute key="org.eclipse.jdt.launching.CLASSPATH">
 <listEntry value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&#10;&lt;runtimeClasspathEntry containerPath=&quot;org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/java-1.5.0-sun-1.5.0.18&quot; path=&quot;1&quot; type=&quot;4&quot;/&gt;&#10;"/>
@@ -12,12 +16,11 @@
 </listAttribute>
 <stringAttribute key="org.eclipse.jdt.launching.CLASSPATH_PROVIDER" value="org.eclipse.ant.ui.AntClasspathProvider"/>
 <booleanAttribute key="org.eclipse.jdt.launching.DEFAULT_CLASSPATH" value="false"/>
-<stringAttribute key="org.eclipse.jdt.launching.PROJECT_ATTR" value=""/>
+<stringAttribute key="org.eclipse.jdt.launching.PROJECT_ATTR" value="DatabaseTemplateLang"/>
 <stringAttribute key="org.eclipse.jdt.launching.SOURCE_PATH_PROVIDER" value="org.eclipse.ant.ui.AntClasspathProvider"/>
-<stringAttribute key="org.eclipse.ui.externaltools.ATTR_ANT_TARGETS" value="build-spx-packages,"/>
 <stringAttribute key="org.eclipse.ui.externaltools.ATTR_LAUNCH_CONFIGURATION_BUILD_SCOPE" value="${none}"/>
-<stringAttribute key="org.eclipse.ui.externaltools.ATTR_LOCATION" value="${workspace_loc:/DatabaseSPXLang/build.spx.packages.xml}"/>
+<stringAttribute key="org.eclipse.ui.externaltools.ATTR_LOCATION" value="${workspace_loc:/DatabaseTemplateLang/build.spx.packages.xml}"/>
 <booleanAttribute key="org.eclipse.ui.externaltools.ATTR_TRIGGERS_CONFIGURED" value="true"/>
-<stringAttribute key="org.eclipse.ui.externaltools.ATTR_WORKING_DIRECTORY" value="${workspace_loc:/DatabaseSPXLang}"/>
+<stringAttribute key="org.eclipse.ui.externaltools.ATTR_WORKING_DIRECTORY" value="${workspace_loc:/DatabaseTemplateLang}"/>
 <stringAttribute key="process_factory_id" value="org.eclipse.ant.ui.remoteAntProcessFactory"/>
 </launchConfiguration>

From tobivollebregt at gmail.com  Wed Jun 22 14:41:22 2011
From: tobivollebregt at gmail.com (Tobi Vollebregt)
Date: Wed, 22 Jun 2011 12:41:22 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23088 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/sdf
Message-ID: <20110622124122.ABC6FCC3BE@mx4.tudelft.nl>

Author: tvo
Date: Wed Jun 22 12:41:22 2011
New Revision: 23088
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23088&sc=1

Log:
SpoofaxLang: fix main SDF module not being parseable sometimes

(due to an `exports' keyword without anything below it)

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/sdf/to-sdf.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/sdf/to-sdf.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/sdf/to-sdf.str	Wed Jun 22 12:23:02 2011	(r23087)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/sdf/to-sdf.str	Wed Jun 22 12:41:22 2011	(r23088)
@@ -71,7 +71,7 @@
  			if not(!resultant-sorts => []) then
  				start-symbol-syntax := [exports(context-free-start-symbols(resultant-sorts))]
  			else
- 				start-symbol-syntax := [exports(resultant-sorts)]
+ 				start-symbol-syntax := []
  			end
  		where
  			sdf-string :=

From tobivollebregt at gmail.com  Wed Jun 22 16:42:53 2011
From: tobivollebregt at gmail.com (Tobi Vollebregt)
Date: Wed, 22 Jun 2011 14:42:53 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23089 - in
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax: editor
	trans/context/sdf
Message-ID: <20110622144253.DA1E52B80C3@mx2.tudelft.nl>

Author: tvo
Date: Wed Jun 22 14:42:53 2011
New Revision: 23089
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23089&sc=1

Log:
SpoofaxLang:
* don't generate signatures for / fail on reject productions
* swap %% and // comment so // is used by Eclipse
* typos

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/editor/SpoofaxLang-Syntax.esv
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/sdf/declare-signature.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/sdf/declare.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/editor/SpoofaxLang-Syntax.esv
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/editor/SpoofaxLang-Syntax.esv	Wed Jun 22 12:41:22 2011	(r23088)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/editor/SpoofaxLang-Syntax.esv	Wed Jun 22 14:42:53 2011	(r23089)
@@ -2,24 +2,24 @@
 
 language Syntax properties for spoofax lang
 
-	 // Comment constructs:  
-  line comment  : "//"		
+	 // Comment constructs:
   line comment  : "%%"
+  line comment  : "//"
   block comment : "/*" * "*/"
   block comment: % % %
-  
-  // Regular expression for identifiers: 
+
+  // Regular expression for identifiers:
   identifier lexical : "[a-zA-Z\_][a-zA-Z0-9\'\-\_]*\*?"
-  
-  // Fences (used for matching,            
-  // inserting, indenting brackets): 
+
+  // Fences (used for matching,
+  // inserting, indenting brackets):
  	fences        : [ ]
                   ( )
                   { }
                   {| | // hack: interacts with { }
                   <% %>
                   |[ ]|
-                  (|[ "" // hack: interacts with |[ ]| 
+                  (|[ "" // hack: interacts with |[ ]|
                   $[ ]
                   ${ }
                   $< >
@@ -29,9 +29,9 @@
                   //"=<" > // hack: interacts with ->
                   //"(<" > // hack: interacts with ->
                   //"|<" > // hack: interacts with ->
-  
-  // Automatic indent hints                
-  // (indent after these tokens):  
+
+  // Automatic indent hints
+  // (indent after these tokens):
   indent after:
     then
     in
@@ -53,5 +53,4 @@
     restriction
     priorities
     hiddens
-    
-    
\ No newline at end of file
+

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/sdf/declare-signature.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/sdf/declare-signature.str	Wed Jun 22 12:41:22 2011	(r23088)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/sdf/declare-signature.str	Wed Jun 22 14:42:53 2011	(r23089)
@@ -25,14 +25,14 @@
  	<+
  		<debug-declaration(|"Signature" , "Warning")> $[Failed to retrive OperationSignatures for opname[<pp-aterm>]. Returning  empty list . ];
  		![]
- 	
+
  	get-operation-declarations =
 		?opname;
  		<resolve-symbol-declarations(all-keys-Get-Operation-Declaration, bagof-Get-Operation-Declaration)><to-scoped-symbol>opname
  	<+
  		<debug-declaration(|"Signature" , "Warning")> $[Failed to retrive OperationDeclarations for opname[<pp-aterm>]. Returning  empty list . ];
  		![]
- 			
+
 strategies
 	// Returns right hand side of the production. In case of A -> B, it retunrs B.
 	get-rhs-sort-name =
@@ -56,15 +56,15 @@
 rules
 
 	//Stores operation name and operation declarations
-	
+
   // Gets the operation name from the Production. It actually searches all the attributes
   // in the attribute list and creates a dynamic rule that stores operation name.
   get-opration-name = where(getfirst(fetch-cons-name) ; store-operation-name)
 
-  
+
   // Stores operation name from RHS of the Production, i.e. from fun constructors.
   // It creates a dynamic rule to store the operation name.
-  store-operation-name : 
+  store-operation-name :
   	opname-> opname
   	with
 			rules (get-op-name: _ -> opname)
@@ -148,7 +148,7 @@
 					;	inner-sort* := <bagof-lhs-sort;reverse>
 					;	intermediate-resultant-sort-type :=<string-replace(|"(", "_Of_");string-replace(|")", "")> <separate-by(|"_"); concat-strings>inner-sort*
 			|}
-			// storing intermediate operation declarations    
+			// storing intermediate operation declarations
 			; <map(create-opname2opdecl-mapping(|"", intermediate-resultant-sort-type, "[N/A]" ))>inner-sort*
 			; rules( lhs-sort :+ _ -> intermediate-resultant-sort-type)
 
@@ -266,25 +266,25 @@
 		;available-opdecl* := <get-operation-declarations>operation-name
 		;scoped-operation-name := <to-scoped-symbol>operation-name
 		;if( (!available-opdecl* => []) <+ not(<assert-equal-signature(|operation-name, opernand-sorts*, resultant-sort)>available-opdecl*) )then
-			record-operation-definition(|scoped-operation-name  , operation-name  , opernand-sorts* , resultant-sort) 
+			record-operation-definition(|scoped-operation-name  , operation-name  , opernand-sorts* , resultant-sort)
  		else
  			//enable-declaration-debugging;
- 		 	record-duplicate-operation-definition(|scoped-operation-name  , operation-name  , opernand-sorts* , resultant-sort); 
+ 		 	record-duplicate-operation-definition(|scoped-operation-name  , operation-name  , opernand-sorts* , resultant-sort);
  		 	<debug-declaration(|"Signature" , "Warning")>
  		 			$[
- 		 				There is an existing operation declration of production: [<pp-aterm> production] as the following : [<pp-aterm>(operation-name, opernand-sorts* , resultant-sort)]
+ 		 				There is an existing operation declaration of production: [<pp-aterm> production] as the following : [<pp-aterm>(operation-name, opernand-sorts* , resultant-sort)]
  		 				--scoped-op-name [<pp-aterm>scoped-operation-name].
  		 			 ]
- 		 	//;disable-declaration-debugging	 
+ 		 	//;disable-declaration-debugging
 		end
-		
+
 
 	create-opname2opdecl-mapping(|operation-name, resultant-sort , production): alt-sort -> alt-sort
 		where
 			  alt-srt-lst := [alt-sort]
 			  ;create-opname2opdecl-mapping(|operation-name, alt-srt-lst, resultant-sort , production)
 
-	
+
 	record-operation-definition ( |scoped-op-name ,  opname , operand-sort* ,  resultant-sort) =
 		where (
 			arg-length := <length>operand-sort*;
@@ -292,16 +292,16 @@
 					Get-Operation-Signature  :+  scoped-op-name   -> (opname  , arg-length )
 				 	Get-Operation-Declaration:+  scoped-op-name   -> (opname  , operand-sort* , resultant-sort)
 				)
-				
-			;<debug-declaration(|"Signature" , "Info")> $[Stored operation declration : [<pp-aterm> ( opname , operand-sort* ,  resultant-sort) ].]
-			;<debug-declaration(|"Signature" , "Info")> $[Stored operation signature  : [<pp-aterm> scoped-op-name] -> [<pp-aterm> (opname, <length>operand-sort*)].]
+
+			;<debug-declaration(|"Signature" , "Info")> $[Stored operation declaration : [<pp-aterm> ( opname , operand-sort* ,  resultant-sort) ].]
+			;<debug-declaration(|"Signature" , "Info")> $[Stored operation signature   : [<pp-aterm> scoped-op-name] -> [<pp-aterm> (opname, <length>operand-sort*)].]
 	)
 
 	record-operation-definition-at-global-scope ( | opname , operand-sort* ,  resultant-sort) =
 		where ( <to-global-symbol> opname => scoped-op-name);
 		record-operation-definition( |scoped-op-name ,  opname , operand-sort* ,  resultant-sort)
 
-	
+
 	record-duplicate-operation-definition( |scoped-op-name ,  opname , operand-sort* ,  resultant-sort) =
 		where(
 			scoped-rhs-sort := <to-scoped-symbol>resultant-sort;
@@ -310,8 +310,8 @@
 					has-duplicate-opeartion-definition:+ scoped-rhs-sort   -> (opname  , arg-length, resultant-sort)
 			)
 			;<debug-declaration(|"Signature" , "Info")> $[Stored duplicate  operation signature  : [<pp-aterm> scoped-op-name].]
-		)	
-		
+		)
+
 rules
 	init-record-signatures =
 			record-operation-definition-at-global-scope ( |"None", [] 		,"Option(a)");

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/sdf/declare.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/sdf/declare.str	Wed Jun 22 12:41:22 2011	(r23088)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/sdf/declare.str	Wed Jun 22 14:42:53 2011	(r23089)
@@ -51,14 +51,14 @@
  declare-sdf-definition-main=
     	alltd(declare-sdf-definition)
 
-rules 
-	declare-sdf-definition : 
+rules
+	declare-sdf-definition :
 		context-free-start-symbols(s*) -> <id>
-		with 
+		with
 			<declare-sdf-definition-main>s*
 		with
-			store-context-free-start-symbols(|<GetEnclosingPackageName>) 	
-		 
+			store-context-free-start-symbols(|<GetEnclosingPackageName>)
+
 rules
 	declare-sdf-definition:
     renamings(y) -> <id>
@@ -86,7 +86,10 @@
       qualified-sort-name := <to-scoped-symbol> x
    	with
    		// enable-declaration-debugging;
-   		<store-operation-declaration>prod
+      // reject productions shouldn't generate signatures ever
+      if not(<attrs(fetch(?reject()))> attrs) then
+        <store-operation-declaration>prod
+      end
   	with
       <topdown(try(store-namespace-def))> lhs
     with

From M.A.Akhter at student.tudelft.nl  Wed Jun 22 20:05:37 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Wed, 22 Jun 2011 18:05:37 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23090 - in
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans:
	codegen editor utils
Message-ID: <20110622180537.DCF092B80AF@mx2.tudelft.nl>

Author: MdAdilAkhter
Date: Wed Jun 22 18:05:36 2011
New Revision: 23090
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23090&sc=1

Log:
- Fixed caching issue of Currently Analyzing AST.

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/compile.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/generate.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/main.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/editor/main.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/cache.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/compile.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/compile.str	Wed Jun 22 14:42:53 2011	(r23089)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/compile.str	Wed Jun 22 18:05:36 2011	(r23090)
@@ -77,7 +77,6 @@
 	// Main compilation events
 	compile-all =
 		?current-term ;
-		enable-compiler-debugging;
 		new-compile-session(
 			list-of-package-qname := <get-package-list>
 			;<compile-internal>list-of-package-qname
@@ -85,7 +84,6 @@
 			;<get-all-analyzed-problems>()
 			;debug(!"Errors : " ) // Get all errors
 		)
-		;disable-compiler-debugging
 		;!current-term //restoring current term to avoid side effects
 
 

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/generate.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/generate.str	Wed Jun 22 14:42:53 2011	(r23089)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/generate.str	Wed Jun 22 18:05:36 2011	(r23090)
@@ -29,7 +29,6 @@
 rules 
 	
 	refresh-file = is-in-command-line-mode  < id + refresh-workspace-file 
-	
 
 //TODO: OPTIMIZE : get the imports and resue it in all the generation phase rather traversing to find it out each time. 
 //TODO: OPTIMIZE : DR can be used to construct this imports  
@@ -48,7 +47,6 @@
 strategies 
 	build-all = 
 		?current-term
-		;enable-compiler-debugging
 		;new-compile-session(
 			list-of-package-qname* := <get-package-list> 
 			;<compile-internal>list-of-package-qname*
@@ -67,7 +65,6 @@
 				<debug>$[Please fix the errors before building the artifacts:  [<pp-aterm-forced>problems]]
 			end		 
 		)
-		;disable-compiler-debugging
 		;!current-term //restoring current term to avoid side effects  
 		
 rules

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/main.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/main.str	Wed Jun 22 14:42:53 2011	(r23089)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/main.str	Wed Jun 22 18:05:36 2011	(r23090)
@@ -15,6 +15,7 @@
   normalize/signatures  
 	include/SpoofaxLang
 	utils/path
+	utils/debug
 imports 	
 	libstratego-gpp
 	libstratego-xtc 
@@ -52,25 +53,29 @@
 	build-all:
 		(selected, position, ast, path, project-path) -> None()
 		where
-			<debug>$[.................starting compile + build all ..........................]
-		with 
-			editor-init
+			 <debug>$[.................starting compile + build all ..........................]
+		with
+			editor-init	
 		 ;rules(ProjectPath := project-path)
 		 ;initialize-configuration
 		with
-	  	<build-all>()
+	  	 enable-compiler-debugging
+	  	;<cache-currently-analyzing-ast>(<concat-strings>[project-path, "/" ,path] , ast)	 
+	  	;<build-all>()
+	  	;disable-compiler-debugging
 		
 rules
 	//Intregation Test of the compile-all is working as expected 
 	compile-spx:
 		(selected, position, ast, path, project-path) -> None()
-		with 
-			editor-init;
-		  initialize-configuration
 		where
-			<cache-currently-analyzing-ast>(<concat-strings>[project-path, "/" ,path] , ast)	 
-		with
-			rules(ProjectPath := project-path)
+			<debug>$[.................starting compile-all ..........................]
+		with 
+			 editor-init
+			;rules(ProjectPath := project-path)
+		  ;initialize-configuration
 		with 
-			<debug>$[.................starting compile-all ..........................];
-			<compile-all>()
+			 enable-compiler-debugging
+	  	;<cache-currently-analyzing-ast>(<concat-strings>[project-path, "/" ,path] , ast)	 
+			;<compile-all>()
+	  	;disable-compiler-debugging

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/editor/main.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/editor/main.str	Wed Jun 22 14:42:53 2011	(r23089)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/editor/main.str	Wed Jun 22 18:05:36 2011	(r23090)
@@ -41,7 +41,7 @@
 			;rules(ProjectPath := project-path)
 			;initialize-configuration
 			;abs-path := <concat-strings;string-replace(|"\\", "/")>[project-path, "/" ,path]
-			;<debug>$[Compiling abs-path : [<pp-aterm>abs-path]]    
+			;<debug>$[Compiling following SPX file: [<pp-aterm>abs-path]]    
 		with 
 			<cache-currently-analyzing-ast>(abs-path  , ast)	 
 		with 

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/cache.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/cache.str	Wed Jun 22 14:42:53 2011	(r23089)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/cache.str	Wed Jun 22 18:05:36 2011	(r23090)
@@ -13,10 +13,8 @@
     	full-path := <resolve-spx-path>path;
     	cache-path := <resolve-cache-path> full-path;
 			if not(<CachedCompilationUnit> full-path) then
-      	if <CachedParseAst> full-path then
-					spx-compilation-unit:= <CachedParseAst>full-path
-				else
-        	if <is-newer> (cache-path, path) then
+      	if not( spx-compilation-unit:=  <CachedParseAst> <string-replace(|"\\", "/")>full-path) then
+					if <is-newer> (cache-path, path) then
           	spx-compilation-unit := <ReadFromFile> cache-path
           else
           	spx-compilation-unit := <parse-file> full-path;
@@ -89,12 +87,14 @@
 		
 	    
 rules
+	// caching currently analyzing AST so that we don't have to read it again from the file and to use it later on. 
 	cache-currently-analyzing-ast = 
 		(?(path, compilation-unit-ast) <+ throw-invalid-argument-exception(|"utils.cache.cache-currently-analyzing-ast")); 
 		path' := <string-replace(|"\\", "/")>path;
 		rules(
 	      CachedParseAst: path' -> compilation-unit-ast
-	  ) 
+	  );
+	  where ( <debug-compiler> $[Cache| storing currently analyzing AST in the cache with following key :  [<pp-aterm> path']] ) 
 
 
 	

From tobivollebregt at gmail.com  Thu Jun 23 14:27:07 2011
From: tobivollebregt at gmail.com (Tobi Vollebregt)
Date: Thu, 23 Jun 2011 12:27:07 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23091 - in
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax: syntax
	trans/codegen/template trans/context/template
	trans/unit-tests/templatelang
Message-ID: <20110623122707.34377CC127@mx4.tudelft.nl>

Author: tvo
Date: Thu Jun 23 12:27:06 2011
New Revision: 23091
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23091&sc=1

Log:
TemplateLang: add possibility to configure the follow restriction that is generated for keywords

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/syntax/TemplateLang.sdf
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/template/to-sdf.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/template/declare.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/templatelang/to-sdf.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/syntax/TemplateLang.sdf
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/syntax/TemplateLang.sdf	Wed Jun 22 18:05:36 2011	(r23090)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/syntax/TemplateLang.sdf	Thu Jun 23 12:27:06 2011	(r23091)
@@ -19,6 +19,8 @@
     "leading"  -> NewlineOptionValue {cons("Leading")}
     "trailing" -> NewlineOptionValue {cons("Trailing")}
 
+    "keyword" "-/-" Lookaheads[[SDF]] -> TemplateOption {cons("KeywordFollowRestriction")}
+
   context-free syntax
     %% references to productions using sort.cons notation in priority specification
     SortCons                                   -> Group[[SDF]]  {cons("simple-ref-group")}

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/template/to-sdf.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/template/to-sdf.str	Wed Jun 22 18:05:36 2011	(r23090)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/template/to-sdf.str	Thu Jun 23 12:27:06 2011	(r23091)
@@ -56,11 +56,11 @@
             )
       in
         A* := <collect-om(lit(ends-with-identifier-char)); nub; string-sort-ex> sdf-section*;
-        if !A* => [] then
+        r  := <get-keyword-follow-restriction>;
+        if (!A* => []) + (!r => None()) then
           restrictions* := []
         else
-          restrictions* := [|[ lexical restrictions
-                                 A* -/- [A-Za-z0-9\_\-] ]|]
+          restrictions* := [lexical-restrictions([follow(A*, r)])]
         end
       end
 

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/template/declare.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/template/declare.str	Wed Jun 22 18:05:36 2011	(r23090)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/template/declare.str	Thu Jun 23 12:27:06 2011	(r23091)
@@ -9,6 +9,7 @@
   constructors
     // Options
     Newlines : X
+    KeywordFollowRestriction : X
 
 strategies
 
@@ -22,6 +23,7 @@
     // defaults
     rules(
       Options :+ Newlines() -> None()
+      Options :+ KeywordFollowRestriction() -> None()
     )
 
 rules
@@ -71,6 +73,11 @@
     with
       rules(Options :+ Newlines() -> t)
 
+  declare-template-option:
+  	KeywordFollowRestriction(t) -> <id>
+  	with
+  		rules(Options :+ KeywordFollowRestriction() -> t)
+
 strategies
 
   use-no-newlines       = <Options> Newlines() => None()
@@ -83,3 +90,5 @@
       case ?Leading(): leading
       case ?Trailing(): trailing
     end
+
+  get-keyword-follow-restriction = <Options> KeywordFollowRestriction()

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/templatelang/to-sdf.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/templatelang/to-sdf.str	Wed Jun 22 18:05:36 2011	(r23090)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/templatelang/to-sdf.str	Thu Jun 23 12:27:06 2011	(r23091)
@@ -9,14 +9,10 @@
   include/SpoofaxLang
 imports
   codegen/template/to-sdf
+  context/template/declare
   normalize/signatures
   utils/attributes
 
-// FIXME: don't be lazy, get this from some import!
-signature
-  constructors
-    Newlines : Unknown
-
 strategies
 
   test-templatelang-to-sdf =
@@ -81,6 +77,7 @@
         DeclaredModule :+ "__test" -> "__test"
         GetEnclosingModuleName := Module("__test")
         Options :+ Newlines() -> None()
+        Options :+ KeywordFollowRestriction() -> single(|[ [A-Za-z0-9\_\-] ]|)
       );
       newlines := [None(), Leading(), Trailing()];
 

From m.dejonge at tudelft.nl  Thu Jun 23 17:55:12 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Thu, 23 Jun 2011 15:55:12 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23092 -
	spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/util
Message-ID: <20110623155512.A4FFC2B801C@mx2.tudelft.nl>

Author: MaartjeDeJonge
Date: Thu Jun 23 15:55:12 2011
New Revision: 23092
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23092&sc=1

Log:
improved implementation:
- support for aterm/stratego coding style (separator at start of line)
- better handling of line comments (\n at end is treated as layout when possible)
- better separation between layout adjustment and text-construction/tree-diff
- some support (?) for desugaring (must be extended to support moved and nested fragments)
- using reimplemented origin strategies

Added:
   spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/util/layout-adaption.str
Modified:
   spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/util/construct-text.str
   spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/util/origin-tracking.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/util/construct-text.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/util/construct-text.str	Thu Jun 23 12:27:06 2011	(r23091)
+++ spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/util/construct-text.str	Thu Jun 23 15:55:12 2011	(r23092)
@@ -1,545 +1,284 @@
 module sdf2imp/util/construct-text
 
-imports 
-  libstratego-lib 
-  libstratego-gpp
-  sdf2imp/util/origin-tracking 
-
-rules //API for text reconstruction
+imports
+	libstratego-lib 
+	libstratego-gpp
+	sdf2imp/util/layout-adaption
+	sdf2imp/util/origin-tracking
+
+rules //interface
+
+// backwards compatibility
+//TODO: change refactoring esv, geen pp-table meer
+construct-textual-change(pp|pp-table)=
+	construct-textual-change(pp <+ (ast2abox(|[pp-table]); box2text-string(|100)))
 
 /*
  * Constructs the textual change associated with 
- * the transformation that replaces a (sub)term (oldnode) with a new (sub)term (newnode).
+ * the transformation that replaces a (sub)term 'oldnode' with a new (sub)term 'newnode'.
  * @param custom pp strategy used to construct the text fragment for nodes that miss origin information
- * @param pp-table used to get separator information (and as backup for text construction)
- * @type (original-node, new-node) -> ((Int,Int), String)
+ * pp strategy is assumed to be homomorphic (except for lists separators that require parent node information)
+ * @type (original-node, new-node) -> (Int,Int, String)
  */	
-construct-textual-change(pp|pp-table):
-	(oldnode, newnode) -> (start-offset, end-offset, newText)
+construct-textual-change(pp):
+	t@(oldnode, newnode) -> (start-offset, end-offset, newText)
 	where
-		if <origin-term> newnode then
-			origin-tracked-node:=newnode
-		else
-			origin-tracked-node:=<origin-set-relation(|oldnode)> newnode
-		end
-	where
-		((start-offset, end-offset), newText):=
-	<
-		ast-change-to-text-change(
-			pp <+ (ast2abox(|[pp-table]); box2text-string(|100))|
-			pp-table
-		)
-	> REPLACEMENT(oldnode, <construct-text-by-compare(
-		pp <+ (ast2abox(|[pp-table]); box2text-string(|100))|
-		pp-table)> (oldnode, newnode)) //TODO: refactor
+		<is-tuple> t;
+		<has-origin-term> oldnode		
+	with
+		reconstructed-text := <construct-text-from-old(pp)> (oldnode, newnode); 
+		(start-offset, end-offset, newText) := <ast-change-to-text-change(pp)> REPLACEMENT(oldnode, reconstructed-text)
+
+construct-textual-change(pp):
+	t@(oldnode, newnode) -> (0, 0, "")
+	where
+		<is-tuple> t;
+		<equal> (oldnode, newnode)
+
+construct-textual-change(pp) =
+	map(construct-textual-change(pp))
+
+//treat olnode as a candidate origin term to protect against loss of origin (and to preserve sugar in first diff)
+construct-text-from-old(pp):
+	(oldnode, newnode) -> reconstructed-text
+	where
+		reconstructed-text := <construct-text-from-origin(pp)> (oldnode, newnode) <+ //possible desugared
+		reconstructed-text := <construct-text-from-origin(pp)> (<where(not(is-origin-term)); origin-term> oldnode, newnode) <+
+		reconstructed-text := <construct-text(pp)> newnode
+
+rules //text-reconstruction
+
+construct-text(pp) = 
+	is-string <+
+	int-to-string <+
+	construct-text-from-origin-desugared(pp) <+
+	construct-text-from-origin(pp) <+
+	construct-text-by-pp(pp) <+
+	pp
+
+construct-text-from-origin-desugared(pp) = 
+	fail //TODO: (<origin term; desugar>, <id>) resugar?
+
+construct-text-from-origin(pp):
+	node -> <construct-text-from-origin(pp)> (origin-node, node)
+	where
+		origin-node := <origin-term> node
+
+//list must be constructed with comments that preceed the first element or succeed the last element
+//(otherwise insert-at-end gives problems)
+construct-text-from-origin(pp):
+	lst -> <construct-text-with-comments(pp|"")> (origin-lst, lst)
+	where
+		origin-lst := <find-origin-sublist> lst
+
+construct-text-from-origin(pp):
+	t@(origin-node, node) -> text
+	where //guarantees that node can be formatted from the origin node, preventing non-termination
+		<is-tuple> t; 
+		<has-origin-term> origin-node;
+		ast-changes := <collect-ast-changes(in-parent-context(|origin-node))> (origin-node, node); debug(!"ast-changes: ");
+		<is-terminating-diff(|node)> ast-changes //prevent non termination
+	with
+		text-changes := <map(ast-change-to-text-change(pp))> ast-changes; debug(!"txt-changes: ");
+		text := <apply-text-changes>(text-changes, <origin-text> origin-node, <origin-start-offset> origin-node)		
 
-construct-textual-change(pp|pp-table):
-	(oldnode, newnode) -> (0, 0, "")
+construct-text-by-pp(pp):
+	node -> text
 	where
-		<eq> (oldnode, newnode)
+		text := <all(alltd(construct-text-with-comments(pp|<DEFAULT-INDENT>))); pp> node
+		//text := <alltd(construct-text-with-comments(pp|<DEFAULT-INDENT>)); pp> node
 
-construct-textual-change(pp|pp-table) =
-	map(construct-textual-change(pp|pp-table))
-	
-rules //text reconstruction for AST nodes
+construct-text-with-comments-desugared = 
+	fail //TODO: first try text reconstruction on desugared, then try on origin (list)
 
-/**
- * Constructs the (dedented) textfragment for a node, using source fragments when possible.
- * The textfragment includes (surrounding) comments, 
- * and the start indentation is removed from all lines.
- * @param pretty-print strategy
- * @param pretty-print table
- * @type node -> String
- */
-construct-text(pp|pp-table) = 
-	construct-text-from-origin(pp|pp-table) <+
-	construct-text-for-primitive <+
-	construct-text-base-list(pp|pp-table) <+
-	construct-text-by-pp-rec(pp|pp-table) <+
-	construct-text-by-pp(pp|pp-table)
-
-construct-text-for-primitive=
-	?node;
-	(is-string <+ 
-	int-to-string);
-	add-origin-comments(|node)  
-	 
-construct-text-from-origin(pp|pp-table):
-	node -> text
+construct-text-with-comments(pp|default-indent):
+	node -> <construct-text-with-comments(pp|default-indent)> (origin-node, node)
 	where
-		origin-node:=<origin-term> node; 
-		<same-signature <+ unmodified-list> (node, origin-node);
-		text := <construct-text-by-compare(pp|pp-table)> (origin-node, node)
+		origin-node := <origin-term <+ find-origin-sublist> node
+
+construct-text-with-comments(pp|default-indent):
+	t@(origin-node, node) -> node-text
+	where 
+		<is-tuple> t;
+		<has-origin-term> origin-node
+	with //termination check is not needed (we need to Replace to keep comments), since it is called on a subterm in construct-text-by-pp
+		ast-changes := <collect-ast-changes(in-parent-context(|origin-node))> (origin-node, node); debug(!"--ast-changes: ");
+		text-changes := <map(ast-change-to-text-change(pp))> ast-changes; debug(!"--txt-changes: ");
+		full-text := <origin-text-with-layout> origin-node; 
+		full-text-start-offset := <origin-layout-prefix-start-offset> origin-node; 
+		modified-full-text := <apply-text-changes>(text-changes, full-text, full-text-start-offset);
+		node-text := <replace-indentation(|default-indent, <origin-indent <+ !""> origin-node)> modified-full-text
+
+signature constructors //signatures for AST changes
+	DELETION      : OldList -> AST_CHANGE
+	REPLACEMENT   : OldNode * NewNode -> AST_CHANGE //TODO: REPLACEMENT_IN_LIST, REPLACEMENT + bracket insertion for REPLACEMENT
+	INSERT_BEFORE : OldNode * NewList -> AST_CHANGE
+	INSERT_AT_END : OldNode * NewList -> AST_CHANGE
+
+rules //ast-diff
+
+collect-ast-changes(in-local-context) = 
+	where(is-tuple); 
+	(collect-ast-changes-eq <+
+	collect-ast-changes-rec-node(in-local-context) <+
+	collect-ast-changes-rec-list(in-local-context) <+
+	collect-ast-changes-replace(in-local-context))
+	
+collect-ast-changes-eq:
+	(origin-node, node) -> []
+	where
+		<equal> (origin-node, node)
+
+collect-ast-changes-rec-node(in-local-context):
+	(origin-node, node) -> ast-changes
+	where
+		<same-signature <+ ?([_],[_])> (origin-node, node);
+		arg-tuples := <zip>(<get-arguments> origin-node, <get-arguments> node); 
+		ast-changes := <map(collect-ast-changes(in-local-context)); flatten-list> arg-tuples 
+	where
+		<map(in-local-context)> ast-changes
+ 
+collect-ast-changes-rec-list(in-local-context):
+	(origin-lst, lst) -> ast-changes
+	where 
+		<is-list> lst;
+		<is-list> origin-lst;
+		<not(violates-homomorphism-list)> (origin-lst, lst)
+	where
+		ast-changes := <
+			list-diff(in-local-context|origin-lst);
+			filter(not(?INSERT_BEFORE(_, [])));
+			filter(not(?INSERT_AT_END(_, [])))
+		> (origin-lst, lst)
+	where
+		<map(in-local-context)> ast-changes
+
+collect-ast-changes-replace(in-local-context):
+	(origin-node, node) -> [REPLACEMENT(origin-node, node)]
+	where
+		<has-origin-term> origin-node;
+		<not(is-list)> node; //list-text can only be constructed in a context  
+		<in-local-context> REPLACEMENT(origin-node, node)
+
+rules //validity
+
+//desugaring: changes must fall inside region of original text
+//issue: is it correct if we simply filter context sensitive changes?
+in-parent-context(|origin-parent):
+	ast-change -> ast-change
+	where 
+		start-offset-node := <origin-deletion-start-offset> origin-parent; 
+		end-offset-node := <origin-deletion-end-offset> origin-parent; 
+		start-offset-change := <get-arguments; Hd; origin-start-offset> ast-change; 
+		end-offset-change := <get-arguments; Hd; origin-end-offset> ast-change; 
+		<leq> (start-offset-node, start-offset-change); 
+		<leq> (end-offset-change, end-offset-node) 
 		
-construct-text-by-compare(pp|pp-table): (origin-node, node) -> text
-	where
-		ast-changes:=<collect-ast-changes> (origin-node, node); //debug(!"ast-changes: ");
-		text-changes:=<map(ast-change-to-text-change(pp|pp-table)); flatten-list> ast-changes; //debug(!"txt-changes: ");
-		text:=<
-			apply-text-changes; //debug(!"applied: ");
-			remove-indentation(|<origin-indent-value-node> node) //;debug(!"indent-corr: ")
-		>(text-changes, <origin-text-with-comments> node, <origin-offset-with-comments> node)					
-
-construct-text-base-list(pp|pp-table)=
-	construct-list-fragments-base(pp|pp-table) <+ 
-	(?[h|[]]; !h)
 	
-construct-text-by-pp-rec(pp|pp-table):
-	node -> text
-	where
-	text:=<
-		all(try(
-			(is-list; construct-list-fragments(pp|pp-table); map(trim-chars(is-whitespace-char))) <+
-			(not(is-list); construct-text(pp|pp-table); trim-chars(is-whitespace-char))
-		)); 
-		pp;
-		trim-chars(is-whitespace-char <+?'\n');
-		add-origin-comments(|node)
-	> node
-
-construct-text-by-pp(pp|pp-table):
-	node -> <
-		pp; 
-		trim-chars(is-whitespace-char <+?'\n');
-		add-origin-comments(|node)
-	> node
-	
-add-origin-comments(|node): 
-	text -> commented-text
-	where 
-		if
-			<origin-has-comments> node
-		then
-			commented-text:=<
-				apply-text-changes; 
-				remove-indentation(|<origin-indent-value-node> node)
-			>(
-				[(
-					<origin-offset> node, 
-					<prefix-lines(|<origin-indent-node> node); trim-leading-whitespace>text
-				)], 
-				<origin-text-with-comments> node, 
-				<origin-offset-with-comments> node
-			)					
-		else
-			commented-text:=text
-		end
-
-rules //text reconstruction for AST Lists
-
-/**
- * Constructs the textfragment for a list term consisting of a mix of elements with/without origin info.
- * Sublist textfragments are constructed from origin or by pp and separated by the given separation.
- * @param pretty-print strategy
- * @param pretty-print table
- * @param separation between the textual representation of the elements
- * @type List -> String
- */
-construct-list-text(pp|pp-table, sep):
-	lst -> <
-		construct-list-fragments(pp|pp-table);
-		map(trim-leading-whitespace);
-		concat-fragments(|sep)
-	> lst
-
-/**
- * Constructs a list with textfragments that represent sublists of the original list
- * @type List(Node)[lenth n] -> List(String)[length <= n]
- */
-construct-list-fragments(pp|pp-table)=
- 	at-suffix(
- 		where(origin-sublist-term<+<eq>(<length>, 1)); 
- 		![<id>]
- 	); 
- 	(init,last):=<split-init-last>;
- 	![
- 		<	if ?[] <+ ?[_] <+ origin-sublist-term then 
- 				construct-list-fragments-base(pp|pp-table) 
- 			else
- 				construct-list-fragments(pp|pp-table)
- 			end
- 		> init,
- 		<construct-list-fragments-base(pp|pp-table)> last
- 	];
- 	flatten-list 
+rules //list diff
 
-construct-list-fragments-base(pp|pp-table):
-	[] -> []
+list-diff(in-local-context|origin-lst) =
+	list-diff-fuzzy(in-local-context|origin-lst) <+
+	list-diff-origin-related(in-local-context|origin-lst) 
 	
-construct-list-fragments-base(pp|pp-table):
-	lst -> [<construct-text-from-origin(pp|pp-table)> lst]
+list-diff-fuzzy(in-local-context|origin-lst):
+	([origin-elem|origin-rest], [new-elem|new-rest]) -> ast-changes
 	where
-		<is-list> lst
+		<is-deletion(|new-rest)> origin-elem;
+		<is-insertion(|origin-rest)> new-elem;
+		<is-related-to-fuzzy(|origin-elem)> new-elem //fuzzy to prevent deletion + insertion
+	with
+		ast-changes := <flatten-list>[
+			<collect-ast-changes(in-local-context)>(origin-elem, new-elem)|
+			<list-diff(in-local-context|origin-lst)> (origin-rest, new-rest)
+		]
 
-construct-list-fragments-base(pp|pp-table):
-	[h|[]] -> [<construct-text(pp|pp-table)> h]
+list-diff-origin-related(in-local-context|origin-lst): 
+	(origin-elems, new-elems) -> ast-changes
+	where
+		deleted-elems := <take-while(is-deletion(|new-elems))> origin-elems; 
+		origin-rest := <drop-while(is-deletion(|new-elems))>;
+		<not(?[])> deleted-elems 
+	with
+		ast-changes := <flatten-list>[DELETION(deleted-elems)|<list-diff(in-local-context|origin-lst)> (origin-rest, new-elems)]
 
-rules //helpers text reconstruction
-concat-fragments(|seperation)= 
-	separate-by(|seperation); 
-	concat-strings
-	
-is-whitespace-char=
-	?'\t' <+' '
 
-remove-indentation(|n)=
-	all-lines(string-as-chars(dedent-line-chars(|n)));
-	trim-chars(?' ' <+ ?'\t')//<+ ?'\n'
-		
-dedent-line-chars(|n):
-	chars -> dedented-chars
+list-diff-origin-related(in-local-context|origin-lst):
+	([origin-elem|origin-rest], new-elems) -> ast-changes
 	where
-		(
-			<lt> (n,0); 
-			indent:=<copy-char; explode-string> (<abs>n, ' '); 
-			dedented-chars:=<conc>(indent,chars)
-		)<+
-		(
-			<gt> (n,0);
-			<?[' '|tail]> chars;
-			dedented-chars:=<dedent-line-chars(|<dec> n)> tail
-		)<+
-		(
-			<gt> (n,0);
-			<?['\t'|tail]> chars; 
-			dedented-chars:=<dedent-line-chars(|<subt> (n, <tabsize>))> tail				
-		)<+
-		dedented-chars:=chars
+		(inserted, elem, rest) := <split-fetch-keep(is-related-to(|origin-elem))> new-elems
+	with
+		ast-changes := <flatten-list>[
+			INSERT_BEFORE(origin-elem, inserted), 
+			<collect-ast-changes(in-local-context)>(origin-elem, elem)|
+			<list-diff(in-local-context|origin-lst)> (origin-rest, rest)
+		]
 
-rules // ast-diff
+list-diff-origin-related(in-local-context|origin-lst):
+	([], new-elems) -> [INSERT_AT_END(origin-lst, new-elems)]
 
-signature constructors //signatures for AST changes
-	INSERT_AT_END : OldList * NewSubList -> AST_CHANGE
-	INSERT_BEFORE : OldNode * NewSubList -> AST_CHANGE
-	DETETION : OldNode -> AST_CHANGE
-	REPLACEMENT : OldNode * NewNode -> AST_CHANGE
-
-	//with parent path to lookup separator for list elements
-	INSERT_AT_END : ParentPath * OldList * NewSubList -> AST_CHANGE
-	INSERT_BEFORE : ParentPath * OldNode * NewSubList -> AST_CHANGE
-	REPLACEMENT : ParentPath * OldNode * NewNode -> AST_CHANGE
-
-
-rules //collecting ast changes
-
-/**
- * Constructs the diff between two AST nodes in terms of replacements, list insertions and list deletions.
- * List elements are matched based on origin-relation or identity
- * @type (Node1, Node2) -> List(AST_CHANGE)
- */
-collect-ast-changes:
-	(oldTrm, newTrm) -> ast-changes
-	where
-		if <eq> (oldTrm, newTrm) then //stop for equal nodes
-			ast-changes:=[]			
-		else if <same-signature <+ unmodified-list> (oldTrm, newTrm) then //recursively compare child nodes
-			ast-changes:=<
-				zip;
-				map-with-index(collect-ast-changes-keep-parent-path(|oldTrm)); 
-				flatten-list
-			>(<get-arguments> oldTrm, <get-arguments> newTrm)  
-		else if <is-list> oldTrm; <is-list> newTrm then //compare lists
-			ast-changes:=<collect-ast-changes-in-list> (oldTrm, newTrm) 
-		else
-			ast-changes:=[REPLACEMENT(oldTrm, newTrm)] //AST node replacement 
-		end
-		end
-		end
-
-/**
- * Constructs the diff between two AST nodes in terms of replacements, list insertions and list deletions.
- * Parent path (constructor of parent node + index) is preserved 
- * in case the separator must be looked up in the pp-table.
- * @param parent node
- * @type (Node1, Node2) -> List(AST_CHANGE)
- */		
-collect-ast-changes-keep-parent-path(|parent):
-	(index, (old-child, new-child)) -> result
-	where
-		parent-path:=(<get-constructor> parent, index);
-		if 
-			<lt>(<length> old-child,2); 
-			<gt>(<length> new-child,1) 
-		then  //separator can not be looked up in the original list
-			result:=<
-				collect-ast-changes-in-list;
-				map(try(
-					\INSERT_BEFORE(v, w) -> INSERT_BEFORE(parent-path, v, w)\ <+
-					\INSERT_AT_END(x, y) -> INSERT_AT_END(parent-path, x, y)\ <+
-					\REPLACEMENT(t, u) -> REPLACEMENT(parent-path, t, u)\
-				))
-			> (old-child, new-child)
-		else if 
-			<not(is-list)> old-child;
-			<gt>(<length> new-child,1)
-		then //separator can not be looked up in the original list
-			result:=[REPLACEMENT(parent-path, old-child, new-child)]
-		else 
-			result:=<collect-ast-changes> (old-child, new-child)
-		end
-		end
-
-collect-ast-changes-in-list=
-	?(oldlist,newlist);
-	collect-ast-changes-in-list(|oldlist); 
-	where(
-		<at-least-one-match>(oldlist, newlist) //deleting old elements + inserting new elements gives a separation problem
-	)
 
-collect-ast-changes-in-list=
-	?(oldlist,newlist);
-	![REPLACEMENT(oldlist, newlist)];
-	where(
-		<is-list> oldlist; 
-		<is-list> newlist;
-		<not(at-least-one-match)> (oldlist, newlist)
-	)
-	
-at-least-one-match=
-	?([h|tail], newlist);
-	(<fetch(
-		where(equal(|h)<+origin-equivalent(|h))
-	)> newlist <+ 
-	<at-least-one-match> (tail, newlist))
+rules //helper rules text construction
 
-/*
- * Compare lists and return insertions, deletions and replacements of elements
- */		
-collect-ast-changes-in-list(|oldlist)=
-	collect-ast-changes-in-list-insert-at-end(|oldlist) <+
-	collect-ast-changes-in-list-match-header(|oldlist) <+
-	collect-ast-changes-in-list-no-header-match(|oldlist)
-
-//header element old elems exists in new elems
-//ex. ([a,b,c], [x,y,a',b']) -> [InsertBefore([x,y]), <collext-ast-changes>(a,a'), <collect-ast-changes-in-list>([b,c], [b'])]
-collect-ast-changes-in-list-match-header(|oldlist)=
-	?([old-h|old-tail], new-elems);
-	(before, new-h, after):=<split-fetch-keep(
-		where(equal(|old-h) <+ origin-equivalent(|old-h))
-	)> new-elems;
-	ast-changes:=<flatten-list>[
-		<collect-ast-changes>(old-h, new-h),
-		<collect-ast-changes-in-list(|oldlist)>(old-tail, after)
-	];
-	if <not(?[])> before then
-		![INSERT_BEFORE(old-h, before)|ast-changes]
-	end
-
-collect-ast-changes-in-list-match-header(|oldlist, new-elems):
-	old-elems -> <collect-ast-changes-in-list-match-header(|oldlist)> (old-elems, new-elems)
-
-//header element old elems is deleted
-//ex. ([a,b,c,d,e], [x,y,c',d']) -> [D([a,b]), <coll-l>([c,d,e],[x,y,c'd'])]
-collect-ast-changes-in-list-no-header-match(|oldlist)=
-	?(old-elems, new-elems);
-	resolved-suffix:=<at-suffix(collect-ast-changes-in-list-match-header(|oldlist, new-elems); ![<id>])> old-elems;
-	![DETETION(<init> resolved-suffix), <last> resolved-suffix];
-	flatten-list
-
-//all-old-elems-deleted
-//ex. ([a,b,c], [x,y,z]) -> [Del(a,b,c), <coll-ch> ([], [x,y,z])]
-collect-ast-changes-in-list-no-header-match(|oldlist)=
-	?(old-elems, new-elems);
-	where(not(at-least-one-match()));
-	![DETETION(old-elems), <collect-ast-changes-in-list-insert-at-end(|oldlist)> ([], new-elems)];
-	flatten-list
-
-//collects remaining new elems as insertions
-//ex. ([], [x,y]) -> Iend([x,y])
-collect-ast-changes-in-list-insert-at-end(|oldlist)= 
-	?([], new-elems); 
-	if <?[_|_]> new-elems then
-		![INSERT_AT_END(oldlist, new-elems)]
-	else
-		![]
-	end
+find-origin-sublist:
+	lst -> sublst
+	where
+		at-suffix(sublst := <origin-sublist-term; ?[_,_|_]>) <+
+		sublst := <init; find-origin-sublist> lst
+
+is-terminating-diff(|newnode):
+	ast-changes -> ast-changes
+	where
+		<not(fetch(?REPLACEMENT(_, newnode)))> ast-changes 
+		//lists are constructed from their elements, so non-termination is not a problem for insertion
 
-rules //helpers compare nodes
+rules //helper rules diff
 	
-same-signature =
-	?(trm1, trm2);
+same-signature:
+	t@(trm1, trm2) -> (trm1, trm2)
 	where(
+		<is-tuple> t;
 		<eq>(<get-constructor> trm1, <get-constructor> trm2);
 		<eq>(<get-arguments; length> trm1, <get-arguments; length> trm2);
-		<not(is-list)> trm1; <not(is-list)> trm2
+		<not(is-list)> trm1
 	)
-	
-unmodified-list=
-	?(lst1, lst2);
-	<zip; map(equal <+ origin-equivalent)> (lst1, lst2)
-
-origin-equivalent=
-	?(t1,t2);
-	where(
-		<eq>(<origin-term> t1, <origin-term> t2) <+
-		<same-signature; all(not(origin-term))> (t1,t2)
-	) 
-	
-origin-equivalent(|t1):
-	t2 -> <origin-equivalent> (t1,t2)
-	
-rules //translating ast-changes to text changes
-
-rules //Replacement
-	
-ast-change-to-text-change(pp|pp-table):
-	REPLACEMENT(parent-path, old-trm, new-trm) -> <ast-change-to-text-change(pp|pp-table, separator)> REPLACEMENT(old-trm, new-trm)
-	where 
-		separator:=<get-separator-from-table(|pp-table) <+ !""> parent-path
 
-ast-change-to-text-change(pp|pp-table):
-	REPLACEMENT(old-trm, new-trm) -> <ast-change-to-text-change(pp|pp-table, sep)> REPLACEMENT(old-trm, new-trm)
-	where
-		 sep:=<last; origin-separator-text> old-trm <+
-		 sep:=<fetch-elem(origin-term); origin-separator-text> new-trm <+
-		 sep:= ""
-
-ast-change-to-text-change(pp|pp-table, sep):
-	REPLACEMENT(old-trm, new-trm) -> (offset, txt)
-	where
-		if <origin-has-comments> new-trm then
-			offset:=<origin-offset-with-comments> old-trm
-		else
-			offset:=<origin-offset> old-trm
-		end;
-		ws-sep:=<origin-separating-ws <+ !" "> new-trm;
-		txt:=<
-			(construct-list-text(pp|pp-table, <conc-strings>(sep, ws-sep)) <+ construct-text(pp|pp-table));
-			prefix-lines(|<origin-indent-node> old-trm);
-			trim-leading-whitespace 
-		> new-trm 
+violates-homomorphism-list =
+	?([],[_,_|_]) <+ 
+	?([_],[_,_|_]) <+
+	(?([ortrm],[newtrm]); where(not(<is-related-to-fuzzy(|ortrm)> newtrm)))  //insertion constructs list with 2 elements from list with one element 
 
-rules //Deletion
-	
-ast-change-to-text-change(pp|pp-table):
-	DETETION(old-trm) -> deletions
-	where
-		offset:=<origin-offset-with-layout> old-trm;
-		txt:="";
-		if 
-			separator-offset:=<origin-separator-offset-with-lo> old-trm
-		then
-			deletions:=[(offset, txt), (separator-offset,"")]
-		else
-			deletions:=(offset, txt)
-		end
-		
-rules //Insert Before
-	
-ast-change-to-text-change(pp|pp-table):
-	INSERT_BEFORE(old-node, new-sublist) -> <ast-change-to-text-change(pp|pp-table, sep)> INSERT_BEFORE(old-node, new-sublist)
+is-insertion(|origin-elems):
+	new-elem -> new-elem
 	where
-		sep:= <origin-separator-text <+ !""> old-node
+		<?[or-elem|tail]> origin-elems;
+		<not(is-related-to(|or-elem))> new-elem;
+		<is-insertion(|tail)> new-elem
 
-ast-change-to-text-change(pp|pp-table):
-	INSERT_BEFORE(parent-path, old-list, new-sublist) -> 
-		<ast-change-to-text-change(pp|pp-table, separator)> INSERT_BEFORE(old-list, new-sublist)
-		where
-			separator:=<get-separator-from-table(|pp-table) <+ !""> parent-path
-
-ast-change-to-text-change(pp|pp-table, sep):
-	INSERT_BEFORE(old-node, new-sublist) -> (insert-offset, new-text)
-	where
-		indent:=<origin-indent-node> old-node; 
-		seperation := <conc-strings>(
-			sep, 
-			<origin-separating-ws <+ !" "> old-node
-		); 
-		constructed-text := <
-			construct-list-text(pp|pp-table, seperation);
-			prefix-lines(|indent);
-			trim-leading-whitespace
-		> new-sublist;
-		new-text:=<concat-strings> [constructed-text, seperation, indent]; 
-		start-offset-oldnode:=<origin-offset-with-comments; Fst> old-node; 
-		insert-offset:=(start-offset-oldnode, start-offset-oldnode)
-
-rules //Insert At End
-
-ast-change-to-text-change(pp|pp-table):
-	INSERT_AT_END(old-list, new-sublist) -> <ast-change-to-text-change(pp|pp-table, sep)> INSERT_AT_END(old-list, new-sublist)
-	where
-		sep:=<try(last); (origin-separator-text <+ !"")> old-list
-
-ast-change-to-text-change(pp|pp-table):
-	INSERT_AT_END(parent-path, old-list, new-sublist) -> 
-		<ast-change-to-text-change(pp|pp-table, separator)> INSERT_AT_END(old-list, new-sublist)
-		where
-			separator:=<get-separator-from-table(|pp-table) <+ !""> parent-path
-	
-ast-change-to-text-change(pp|pp-table, sep):
-	INSERT_AT_END(old-list, new-sublist) -> (insert-offset, new-text)
-	where 
-		indent := <try(last); origin-indent-node> old-list; 
-		seperation := <conc-strings>(
-			sep, 
-			<try(last); origin-separating-ws<+!" "> old-list
-		); 
-		constructed-text := <
-			construct-list-text(pp|pp-table, seperation);
-			prefix-lines(|indent)
-		> new-sublist;
-		if <not(?[])> old-list then  
-			new-text := <conc-strings> (seperation, constructed-text)
-		else
-			new-text :=constructed-text
-		end;
-		offset-end-list := <try(last); origin-offset-with-comments; Snd> old-list; 
-		insert-offset := (offset-end-list, offset-end-list)
-
-rules //helpers ast-change-to-text-change
-
-get-separator-from-table(|tbl):
- 	(cons-name, argnr) -> separator
- 	where 
- 	arg-nr-string:=<int-to-string> argnr;
- 	separator:=<
- 		<collect-one(?PP-Entry(Path(cons-name,[selector(arg-nr-string, "iter-star-sep")]),x))> tbl;
- 		!x;
- 		filter(not(Arg("1")));
- 		box2text-string(|100);
- 		un-double-quote; 
- 		trim-whitespace
- 	>
+is-insertion(|origin-elems) =
+	<?[]> origin-elems
 
+is-deletion(|new-elems) = 
+	?origin-elem;
+	<not(fetch(is-related-to(|origin-elem)))> new-elems
 
-rules //Applying the textual modifications
+is-related-to(|origin-node):
+	node -> node
+	where
+		<equal> (origin-node, node) <+
+		<equal> (<origin-term> origin-node, node) <+
+		<equal>(<origin-term> origin-node, <origin-term> node)
 
-/*
- * Applies textchanges (src-offset, text) to a textfragment with a given src-offset  
- * @type (List(((Int,Int), String)), String, Int) -> String
- */
-apply-text-changes:
-	(text-changes, text, offset) -> changed-text
-	where 
-		start-offset:=<Fst> offset;
-		ordered-text-changes:=<make-set; filter(is-modification); sort-list(LSort(compare-text-change))> text-changes;
-		changed-text:= <foldr(!(start-offset, text), apply-textual-change); Snd> ordered-text-changes
+is-related-to:
+	(origin-node, node) -> (origin-node, node)
+	where
+		<is-related-to(|origin-node)> node
 
-apply-textual-change:
-	(change, text-info) -> (char-pos, result-text)
+//related via child
+is-related-to-fuzzy(|origin-node):
+	node -> node
 	where 
-		<?(char-pos, text-fragment)> text-info; 
-		<?((change-start, change-end), change-text)> change; 
-		pos-start:=<subt>(change-start, char-pos); 
-		pos-end:=<subt>(change-end, char-pos); 
-		result-text:=<replace-in-text>
-			(text-fragment, change-text, pos-start, pos-end) 
-
-replace-in-text:
-	(old-text, text-change, pos-start, pos-end) -> result-text
-	where
-		old-chars:=<explode-string> old-text; 
-		(prefix, tail):=<split-at(|pos-start)> old-chars; 
-		(heads, suffix):=<split-at(|pos-end)> old-chars; 
-		result-text:=<conc-strings> (<implode-string> prefix, text-change, <implode-string> suffix) 
-		
-compare-text-change = 
-		?(((start-x, end-x),x), ((start-y, end-y),y));
-		not(
-			<lt> (start-x, start-y) <+ 
-			<eq> (start-x, start-y); <lt> (end-x, end-y)
-		)
-
-is-modification =
-	not(?((t, t),"")) 
+		<not(has-origin-term)> node;
+		arg-tuples := <zip>(<get-arguments> origin-node, <get-arguments> node);
+		<map(is-related-to <+ (Snd; not(has-origin-term)))> arg-tuples;
+		<fetch(is-related-to)> arg-tuples

Added: spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/util/layout-adaption.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/util/layout-adaption.str	Thu Jun 23 15:55:12 2011	(r23092)
@@ -0,0 +1,256 @@
+module sdf2imp/util/layout-adaption
+
+imports
+	sdf2imp/util/construct-text
+	sdf2imp/util/origin-strategies
+		
+rules //rules that translate AST-changes to Textual changes
+
+ast-change-to-text-change(pp):
+	DELETION(origin-lst) -> tc-deletion
+	with 
+		tc-deletion := <create-textchange-delete> origin-lst
+
+ast-change-to-text-change(pp):
+	REPLACEMENT(origin-node, new-node) -> tc-replacement 
+	with 
+		tc-replacement := <create-textchange-replace(pp)> (origin-node, new-node) 
+
+ast-change-to-text-change(pp):
+	INSERT_BEFORE(origin-elem, new-elems) -> tc-insert-before
+	with
+		tc-insert-before := <create-textchange-insert-before(pp)> (origin-elem, new-elems)
+
+ast-change-to-text-change(pp):
+	INSERT_AT_END(origin-elem, new-elems) -> tc-insert-at-end
+	with
+		tc-insert-at-end := <create-textchange-insert-at-end(pp)> (origin-elem, new-elems)
+	
+create-textchange-delete:
+	origin-elems -> (start-offset, end-offset, "")
+	where
+		start-offset := <origin-deletion-start-offset> origin-elems; 
+		end-offset   := <origin-deletion-end-offset> origin-elems
+		
+create-textchange-replace(pp):
+	(origin-node, new-node) -> (start-offset, end, indented-text)
+	where
+		start-offset := <origin-start-offset> origin-node;
+		end   := <origin-end-offset> origin-node;
+		text  := <construct-text(pp)> new-node; //TODO: comments new node?
+		indented-text := <adapt-indentation(|origin-node, new-node)> text
+
+create-textchange-insert-before(pp):
+	(origin-node, new-elems) -> (offset, offset, insert-text)
+	where
+		offset := <origin-insert-before-offset> origin-node;
+		new-elems-text := <map(construct-text-list-element(pp|origin-node))> new-elems;
+		insert-text := <concat-strings> new-elems-text
+
+create-textchange-insert-at-end(pp):
+	(origin-node, new-elems) -> (offset, offset, insert-text)
+	where
+		offset := <origin-insert-at-end-offset> origin-node;
+		new-elems-text := <at-init(
+			construct-text-list-element(pp|origin-node), 
+			construct-text-list-element-last(pp|origin-node))
+		> new-elems;
+		insert-text := <add-separation-before> (origin-node, <concat-strings> new-elems-text)
+
+rules //helper rules layout
+
+construct-text-list-element(pp|origin-node):
+	elem -> elem-text
+	where
+		text := <construct-text(pp)> elem; 
+		layout-before := <layout-prefix> elem; 
+		indented-prefix-text := <conc-strings; adapt-indentation(|origin-node, elem)> (layout-before, text); 
+		comments-after := <comments-after; adapt-indentation(|origin-node, elem)> elem; 
+		separation := <origin-separation> origin-node; 
+		layout-after := <create-separation-after> (separation, comments-after); 
+		elem-text := <conc-strings> (indented-prefix-text, layout-after) 
+
+construct-text-list-element-last(pp|origin-node):
+	elem -> elem-text
+	where
+		text := <construct-text(pp)> elem;
+		layout-before := <layout-prefix> elem;
+		indented-prefix-text := <conc-strings; adapt-indentation(|origin-node, elem)> (layout-before, text);
+		comments-after := <comments-after; adapt-indentation(|origin-node, elem)> elem;
+		elem-text := <concat-strings> [indented-prefix-text, " ", comments-after]
+
+
+rules //helper rules indentation
+
+/*
+ * replaces indent of the new constructed text (retrieved from new-node)
+ * with indent appropriate for insertion position (retrieved from origin-node) 
+ */
+adapt-indentation(|origin-node, new-node):
+	text -> indented-text
+	where 
+		indent-string-new := <origin-indent> origin-node; 
+		indent-string-old := <origin-indent <+ !""> new-node;
+		indented-text := <replace-indentation(|indent-string-new, indent-string-old)> text
+		
+replace-indentation(|new-indent, old-indent):
+	text -> indented-text
+	where
+		indent-value-old := <indent-value> old-indent;
+		indented-text := <
+			remove-indentation(|indent-value-old); 
+			prefix-lines(|new-indent);
+			trim-chars(?' ' <+ ?'\t'); //first line is not indented
+			ltrim-chars(?'\n') //do not remove line comment end
+		> text
+
+/**
+ * Returns the value of the indentation of the startline 
+ * @type ATerm -> Int
+ */
+indent-value:
+	indent-string -> indent-value
+	where
+		indent-value := <explode-string;
+		take-while(?' '<+?'\t');
+		foldr(!0, add, (?' ';!1) <+ (?'\t'; TABSIZE))> indent-string
+	
+remove-indentation(|n):
+	txt -> dedented-txt
+	where
+		dedented-txt := <all-lines(string-as-chars(dedent-line-chars(|n)))> txt
+		
+dedent-line-chars(|n):
+	chars -> dedented-chars
+	where
+		(
+			<lt> (n,0); 
+			indent := <copy-char; explode-string> (<abs>n, ' '); 
+			dedented-chars := <conc>(indent,chars)
+		)<+
+		(
+			<gt> (n,0);
+			<?[' '|tail]> chars;
+			dedented-chars := <dedent-line-chars(|<dec> n)> tail
+		)<+
+		(
+			<gt> (n,0);
+			<?['\t'|tail]> chars; 
+			dedented-chars := <dedent-line-chars(|<subt> (n, <TABSIZE>))> tail				
+		)<+
+		dedented-chars := chars
+
+
+rules // helper rules separation	
+
+add-separation-before =
+	add-separation-before-1 <+ //correct line comment
+	add-separation-before-2
+	
+add-separation-before-1: //corrects for newline in case the text is inserted after a line comment
+	(origin-node, text-inserted-after) -> txt-with-separation
+	where
+		<origin-text-with-layout; string-ends-with(|"\n")> origin-node;
+		(start-separation, end-separation) := <split-before>(<origin-separation> origin-node, "\n");
+		<string-as-chars(map(is-whitespace))> start-separation;
+		txt-with-separation := <concat-strings> [<string-as-chars(Tl)> end-separation, text-inserted-after, "\n"]
+
+add-separation-before-2:
+	(origin-node, text-inserted-after) -> txt-with-separation
+	where
+		txt-with-separation := <conc-strings> (<origin-separation> origin-node, text-inserted-after)
+
+//("/n  ,  ", "//bla /n") -> " //bla /n  ,  "
+//(",/n  ", "//bla /n") -> " , //bla /n  "
+//("/n  ", "//bla /n") -> " //bla /n  "
+create-separation-after:
+	(separation, comments-after) -> txt-between
+	where 
+		<string-ends-with(|"\n")> comments-after;
+		(start-separation, end-separation) := <split-before>(separation, "\n");
+		txt-between := <concat-strings> [start-separation, " ", comments-after, <string-as-chars(Tl)> end-separation]
+		
+
+//("/n  ,  ", "/*bla*/") -> " /*bla*/ /n  ,  "
+//(",/n  ", "/*bla*/") -> " , /*bla*/ /n  "
+//("/n  ", "/*bla*/") -> " /*bla*/ /n  "
+create-separation-after:
+	(separation, comments-after) -> txt-between
+	where
+		<not(string-ends-with(|"\n"))> comments-after;
+		(start-separation, end-separation) := <split-before>(separation, "\n");
+		txt-between := <concat-strings> [start-separation, comments-after, end-separation]
+
+//("  ", "/*bla*/") -> " /*bla*/  "
+//(",  ", "/*bla*/") -> " /*bla*/,  "
+//("  ", "//bla /n") -> " //bla /n  "
+//(",  ", "//bla /n") -> " //bla /n,  "
+create-separation-after:
+	(separation, comments-after) -> txt-between
+	where 
+		<not(is-substring(!"\n"))> separation;
+		txt-between := <concat-strings> [" ", comments-after, separation]
+
+
+rules //Applying the textual modifications
+
+/*
+ * Applies textchanges (src-offset, text) to a textfragment with a given src-offset  
+ * @type (List(((Int,Int), String)), String, Int) -> String
+ */
+apply-text-changes:
+	(text-changes, text, start-offset) -> changed-text
+	where 
+		ordered-text-changes := <make-set; filter(is-modification); sort-list(LSort(compare-text-change))> text-changes;
+		<assert-valid-textual-changes> ordered-text-changes;
+		changed-text := <foldr(!(start-offset, text), apply-textual-change); Snd> ordered-text-changes
+
+apply-textual-change:
+	(change, text-info) -> (char-pos, result-text)
+	where 
+		<?(char-pos, text-fragment)> text-info; 
+		<?(change-start, change-end, change-text)> change; 
+		pos-start := <subt>(change-start, char-pos);
+		pos-end := <subt>(change-end, char-pos); <string-length> text-fragment;
+		result-text:=<replace-in-text>
+			(text-fragment, change-text, pos-start, pos-end) 
+
+replace-in-text:
+	(old-text, text-change, pos-start, pos-end) -> result-text
+	where 
+		old-chars := <explode-string> old-text; 
+		(prefix, tail) := <split-at(|pos-start)> old-chars; 
+		(heads, suffix) := <split-at(|pos-end)> old-chars; 
+		result-text := <conc-strings> (<implode-string> prefix, text-change, <implode-string> suffix) 
+		
+compare-text-change = 
+		?(((start-x, end-x),x), ((start-y, end-y),y));
+		not(
+			<lt> (start-x, start-y) <+ 
+			<eq> (start-x, start-y); <lt> (end-x, end-y)
+		)
+
+is-modification =
+	not(?(t, t,""))
+
+rules //assert wellformedness of textual change list (unwellformed lists lead to unexpected text modifications)
+
+assert-valid-textual-changes =
+	assert-no-overlap;
+	assert-valid-offset
+	
+assert-no-overlap:
+	txt-changes@[(_, end-offset, _), (start-offset, _, _)|_] -> txt-changes
+	with
+		<leq> (end-offset, start-offset);
+		<at-tail(assert-no-overlap)> txt-changes
+		
+assert-no-overlap =
+	?[(_, _, _)] <+ ?[]
+
+assert-valid-offset =
+	map(assert-valid-offset)
+
+assert-valid-offset =
+	?(s,e,_);
+	with(<leq>(s,e))
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/util/origin-tracking.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/util/origin-tracking.str	Thu Jun 23 12:27:06 2011	(r23091)
+++ spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/util/origin-tracking.str	Thu Jun 23 15:55:12 2011	(r23092)
@@ -1,211 +1,55 @@
 module sdf2imp/util/origin-tracking
 
-strategies //origin tracking strategies
-
-/* origin strategies from lib-editor extended with sublist support*/
-origin-term      = support-sublist(prim("SSL_EXT_origin_term", <id>))
-origin-text      = support-sublist(prim("SSL_EXT_origin_text", <id>))
-origin-equal(|t) = support-sublist(prim("SSL_EXT_origin_equal", <id>, t))
-
-origin-equal=
-	?(t1,t2);
-	<origin-equal(|t1)> t2
-	
-origin-set-relation(|or-node) =
-	?node;
-	!Some(or-node); 
-	all(!node); 
-	?Some(<id>)
-
-/**
- * Returns the origin-term of a sublist
- * @type List(Aterm) -> List(Aterm)
- */
-origin-sublist-term = 
-	prim("SSL_EXT_origin_sublist_term","", <id>)
-
-/**
- * Returns the start- and end- offset of the AST node
- * @type ATerm -> (Int, Int)
- */
-origin-offset = 
-	support-sublist(prim-origin-offset)
-
-/**
- * Returns the start- and end- offset of the AST node, 
- * including comments, indentation and separating whitespace
- * @type ATerm -> (Int, Int)
- */
-origin-offset-with-layout = 
-	support-sublist(prim-origin-offset-with-layout)
-
-/**
- * Returns the start- and end- offset of the AST node,
- * including comments
- * @type ATerm -> (Int, Int)
- */
-origin-offset-with-comments:
-	node -> (start-offset, end-offset)
-	where
-		start-offset:=<(origin-offset-comment-before <+ origin-offset); Fst> node;
-		end-offset:=<(origin-offset-comment-after <+ origin-offset); Snd> node	
+rules //origin primitives 
 	
-/**
- * Returns the start- and end- offset of the preceding comments
- * that refer to the AST node (or sublist)
- * Fails if comment does not exist
- * @type ATerm -> (Int, Int)
- */
-origin-offset-comment-before = 
-	support-sublist(prim-origin-offset-comment-before)
-
-/**
- * Returns the start- and end- offset of the succeeding comments
- * that refer to the AST node (or sublist)
- * Fails if comment does not exist
- * @type ATerm -> (Int, Int)
- */
-origin-offset-comment-after = 
-	support-sublist(prim-origin-offset-comment-after)
-
-/**
- * succeeds if the origin term of the node has associated comments
- */
-origin-has-comments =
-	origin-offset-comment-before <+
-	origin-offset-comment-after
-
-/**
- * Returns the indentation (string) of the start-line of the node. 
- * For empty lists, the parent indentation + an additional tab is returned
- * @type ATerm -> String
- */
-origin-indent-node = 
-	try(Hd); //first element of (sub)list
-	prim-origin-indent-node
-
-/**
- * Returns the value of the indentation of the startline 
- * @type ATerm -> Int
- */
-origin-indent-value-node=
-	origin-indent-node;
-	explode-string;
-	take-while(?' '<+?'\t');
-	foldr(!0, add, (?' ';!1) <+ (?'\t';tabsize))
-
-/**
- * Returns the whitespace preceding the node (without the indentation). 
- * @type ATerm -> String
- */
-origin-separating-ws = 
-	support-sublist(prim-origin-separating-ws)
-
-/**
- * Returns the separator location connected to list element or sublist
- * @type ATerm -> (Int, Int)
- */
-origin-separator-offset =  
-	origin-separator;
-	!(<Fst>, <Snd>)
-
-/**
- * Returns the separator location + nearby ws and comments
- * connected to list element or sublist
- * @type ATerm -> (Int, Int)
- */
- origin-separator-offset-with-lo =
-	origin-separator-with-lo;
-	!(<Fst>, <Snd>)
-	
-/**
- * Returns the separator connected to list element or sublist
- * @type ATerm -> String
- */
-origin-separator-text = 
-	origin-separator; 
-	Third
-
-/**
- * Returns the separator text + nearby ws and comments 
- * connected to list element or sublist
- * @type ATerm -> String
- */
-origin-separator-text-with-lo = 
-	origin-separator-with-lo; 
-	Third
-
-origin-separator-with-lo=
-	support-sublist(prim-origin-separator-with-lo)
-
-origin-separator=
-	support-sublist(prim-origin-separator)
-
-/**
- * Returns the textfragment of the AST node,
- * including comments
- * @type ATerm -> (Int, Int)
- */
-origin-text-with-comments=
-	?node;
-	offset := <origin-offset-with-comments> node;
-	<origin-textfragment> (<Fst> offset, <Snd> offset, node)
-
-/**
- * Returns the textfragment from (inclusive) start- to (exclusive) end- offset. 
- * Fails if the offsets do not correspond to a valid location in the source text
- * @type (Int, Int, node) -> String
- */
-origin-textfragment=
-	?(x,y, node);
-	!(x,y,<origin-term> node);
-	prim-origin-textfragment
-
-prim-origin-textfragment= prim("SSL_EXT_origin_textfragment","", <id>)
-
-/**
- * Returns the text of the source file 
- * @type Term -> String
- */
-origin-sourcetext= prim("SSL_EXT_origin_sourcetext", <id>)
-
-strategies //primitives
-
-prim-origin-offset= prim("SSL_EXT_origin_offset", <id>)
-
-prim-origin-offset-with-layout= prim("SSL_EXT_origin_offset_with_layout", <id>) 
-
-prim-origin-offset-comment-before = prim("SSL_EXT_origin_comment_before", <id>) 
+origin-sublist-term = prim("SSL_EXT_origin_sublist_term", <id>)
 
-prim-origin-offset-comment-after= prim("SSL_EXT_origin_comment_after", <id>) 
+origin-term = 
+	prim("SSL_EXT_origin_term", <id>) <+ 
+	origin-sublist-term
+
+origin-text   = origin-support-sublist(prim("SSL_EXT_origin_text", <id>))
+origin-offset = origin-support-sublist(prim("SSL_EXT_origin_offset", <id>)) //exclusive already in Spoofax. TODO: inclusive in Spoofax
+origin-indent = origin-support-sublist(prim("SSL_EXT_origin_indentation", <id>))
+origin-separation = origin-support-sublist(prim("SSL_EXT_origin_separation", <id>)) //only succeeds if list >=2 elems
+origin-layout-prefix = origin-support-sublist(prim("SSL_EXT_origin_layout_prefix", <id>))
+
+origin-deletion-offset = 
+	origin-support-sublist(prim("SSL_EXT_origin_deletion_offset", <id>)); 
+	!(<Fst>, <Snd; inc>) //exclusive end
+
+origin-comments-after = origin-support-sublist(prim("SSL_EXT_origin_comments_after", <id>))
+origin-insert-before-offset = origin-support-sublist(prim("SSL_EXT_origin_insert_before_offset", <id>))
+origin-insert-at-end-offset = origin-support-sublist(prim("SSL_EXT_origin_insert_at_end_offset", <id>))
+origin-text-with-layout = origin-support-sublist(prim("SSL_EXT_origin_text_with_layout", <id>))
+
+rules //origin strategies
+
+origin-start-offset = origin-offset; Fst
+origin-end-offset = origin-offset; Snd
+origin-deletion-start-offset = origin-deletion-offset; Fst 
+origin-deletion-end-offset = origin-deletion-offset; Snd
+origin-layout-prefix-start-offset = origin-insert-before-offset
+
+is-origin-term = <equal> (<origin-term>, <id>)
+has-origin-term = where(origin-term)
+has-origin-sublist-term = where(origin-sublist-term)
+is-origin-sublist-term = <equal> (<origin-sublist-term>, <id>)
+
+origin-support-sublist(s) =
+	(origin-sublist-term; s) <+ 
+	(?[h|[]]; <s> h) <+
+	s
 
-prim-origin-indent-node= prim("SSL_EXT_origin_indentation", <id>)
-//todo? implement (indent empty list: parent + tab)
-
-prim-origin-separating-ws= prim("SSL_EXT_origin_separating_whitespace", <id>)
-	
-prim-origin-separator=
-	prim("SSL_EXT_origin_separator", <id>)
-
-prim-origin-separator-with-lo=
-	prim("SSL_EXT_origin_separator_with_lo", <id>)
+origin-set-relation:
+	(origin-node, new-node) -> origin-tracked-node
+	where
+		origin-tracked-node := <!Some(<id>); all(!new-node); ?Some(<id>)> origin-node
 
-strategies //editor settings
+rules //support default values for non-origin elements
+			
+TABSIZE = !4
+DEFAULT-INDENT = !"  "
 
-/**
- * Returns the tabsize used in the editor. 
- * @type  -> Int
- */
-tabsize=!4 //TODO: use spoofax editor settings
-
-
-strategies //helpers
-
-/**
- * Treats sublists as origin terms
- * @param strategy to apply on an origin term 
- * @type ATerm -> ATerm
- */
-support-sublist(s)=
-	try(?[h|[]]; !h); 
-	((origin-sublist-term; s) <+s)
\ No newline at end of file
+layout-prefix = origin-layout-prefix <+ !""
+comments-after = origin-comments-after <+ !""

From m.dejonge at tudelft.nl  Thu Jun 23 18:00:25 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Thu, 23 Jun 2011 16:00:25 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23093 -
	spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego
Message-ID: <20110623160025.A7B7F2B800D@mx2.tudelft.nl>

Author: MaartjeDeJonge
Date: Thu Jun 23 16:00:25 2011
New Revision: 23093
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23093&sc=1

Log:
layout analysis, origin functions

Added:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/LayoutStructure.java   (contents, props changed)
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginCommentsAfterPrimitive.java   (contents, props changed)
      - copied, changed from r23026, spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginCommentAfterPrimitive.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginCommentsBeforePrimitive.java   (contents, props changed)
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginDeletionOffsetPrimitive.java   (contents, props changed)
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginInsertAtEndOffsetPrimitive.java   (contents, props changed)
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginInsertBeforeOffsetPrimitive.java   (contents, props changed)
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginLayoutPrefixPrimitive.java   (contents, props changed)
      - copied, changed from r23026, spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginCommentBeforePrimitive.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginSeparationPrimitive.java   (contents, props changed)
      - copied, changed from r23026, spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginSeparatingWhitespacePrimitive.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginTextWithLayoutPrimitive.java   (contents, props changed)

Added: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/LayoutStructure.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/LayoutStructure.java	Thu Jun 23 16:00:25 2011	(r23093)
@@ -0,0 +1,518 @@
+package org.strategoxt.imp.runtime.stratego;
+
+import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getLeftToken;
+import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getRightToken;
+import static org.spoofax.terms.attachments.ParentAttachment.getParent;
+
+import org.spoofax.interpreter.terms.ISimpleTerm;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.jsglr.client.imploder.IToken;
+import org.spoofax.jsglr.client.imploder.ITokenizer;
+import org.spoofax.jsglr.client.imploder.ImploderAttachment;
+import org.spoofax.jsglr.client.imploder.Token;
+import org.strategoxt.imp.runtime.parser.ast.StrategoSubList;
+
+/**
+ * Provides access to the layout structure (text fragments and offsets) surrounding a node
+ * Offers support for text reconstruction algorithm
+ * 
+ * @author Maartje de Jonge
+ */
+public class LayoutStructure {
+	
+	private final ISimpleTerm node;
+	private final ISimpleTerm listParent;
+	private final ITokenizer tokens;
+	
+	//suffix data
+	private int suffixStartIndex; //possible invalid index (if node contains rightmost token)
+	private int commentsAfterExclEndIndex; //possible invalid index (if node contains rightmost token)
+	private int suffixSeparationExclEndIndex; //possible invalid (if node contains rightmost token)
+	
+	//prefix data
+	private int prefixEndIndex; //possible invalid index (if node contains leftmost token)
+	private int commentsBeforeStartIndex; //valid index (0 if node contains leftmost token)
+	private int prefixSeparationStartIndex; //valid index (0 if node contains leftmost token)
+
+	public LayoutStructure(IStrategoTerm node) {
+		this.node = node;
+		tokens = getLeftToken(node).getTokenizer();
+		listParent = getParentList(); //could be null
+		analyzeSuffix();
+		analyzePrefix();
+		//logAnalysisResults();
+	}
+
+	/**
+	 * Comments preceding and associated with the node
+	 */
+	public String getCommentsBefore() {
+		String layoutPrefix = getLayoutPrefix();
+		return trimWsPreservingLastNewline(layoutPrefix);
+	}
+
+	/**
+	 * Comments succeeding and associated with the node 
+	 * whereby the suffix separator (if any) is changed by spaces
+	 */
+	public String getCommentsAfter() {
+		String layoutSuffix = getLayoutSuffix();
+		return trimWsPreservingLastNewline(layoutSuffix);
+	}
+
+	/**
+	 * Text fragment preceeding the node that starts from comment(s) before
+	 */
+	public String getLayoutPrefix() {
+		return layoutFragmentWithOutSeparator(this.commentsBeforeStartIndex, this.prefixEndIndex);
+		//assert: Separator not in fragment
+	}
+
+	/**
+	 * Text fragment succeeding the node that ends with comment(s) after
+	 * whereby the suffix separator (if any) is changed by spaces
+	 */
+	public String getLayoutSuffix() {
+		return layoutFragmentWithOutSeparator(this.suffixStartIndex, this.commentsAfterExclEndIndex-1);
+	}
+
+	/**
+	 * Text fragment between comment(s) before start offset and comments after end offset,
+	 * whereby the suffix separator (if any) is changed by spaces
+	 */
+	public String getTextWithLayout() {
+		return getTokenString(commentsBeforeStartIndex, getRightToken(node).getIndex())+getLayoutSuffix();
+	}
+
+	/**
+	 * Indentation of the start line of the node, consist of spaces and tabs.
+	 * In case other tokens precede the node, an extra TAB is added
+	 */
+	public String getIndentation() {
+		String indent = getIndentString();
+		assert(indent.replaceAll("[ \t]", "").equals(""));
+		return indent;
+	}
+
+	/**
+	 * Separation between first and second (TODO: average) list element:
+	 * - consists of newlines, spaces, tabs and separator (if any)
+	 * - null in case (parent) element is not a list, or is a list with 0 or 1 element
+	 */
+	public String getSeparation() {
+		return getSeparationString();
+	}
+
+	/**
+	 * For elements in the middle of a list: 
+	 * - start offset of preceding comment (if any), or node (otherwise)
+	 * - equal to "insert before offset/layout prefix/text with layout" start offset
+	 * For last list element: 
+	 * - min. start offset of node/comm before/prefix-separator + preceding ws
+	 */
+	public int getDeletionStartOffset() {
+		if(isLastListElement()){
+			assert(isValidTokenIndex(prefixSeparationStartIndex));
+			return getTokenAt(prefixSeparationStartIndex).getStartOffset();
+		}
+		return getInsertBeforeOffset();
+	}
+
+	/**
+	 * For elements in the middle of a list: 
+	 * - max. end offset of node/comment after/suffix-separator + succeeding ws
+	 * For last list element: 
+	 * - end offset comment after (or node)
+	 * - equal to insert-at-end offset (minus \n for line comments)
+	 * - do not delete \n of a line comment (this is used as vertical layout)
+	 */
+	public int getDeletionEndOffset() {
+		if(isLastListElement()){
+			int deletionEndOffset = getInsertAtEndOffset()-1;
+			return keepNewlineOfLineComment(deletionEndOffset);
+		}
+		if(isValidTokenIndex(suffixSeparationExclEndIndex)){
+			int deletionEndOffset = getTokenAt(suffixSeparationExclEndIndex).getStartOffset()-1;
+			return deletionEndOffset;
+		}
+		assert(getRightToken(node).getIndex() == tokens.getTokenCount()-1);
+		return getRightToken(node).getEndOffset();
+	}
+
+	/**
+	 * Start offset of preceding comment (if any) or node
+	 */
+	public int getInsertBeforeOffset() {
+		assert this.commentsBeforeStartIndex <= getLeftToken(node).getStartOffset();
+		return getTokenAt(this.commentsBeforeStartIndex).getStartOffset();
+	}
+
+	/**
+	 * End offset+1 of succeeding comment (if any) or node
+	 */
+	public int getInsertAtEndOffset() {
+		if(isValidTokenIndex(commentsAfterExclEndIndex))
+			return getTokenAt(this.commentsAfterExclEndIndex).getStartOffset();
+		assert(getRightToken(node).getIndex() == tokens.getTokenCount()-1);
+		return getRightToken(node).getEndOffset()+1;
+	}	
+	
+	/**
+	 * Layout fragment with separator replaced by spaces
+	 * @param loIndexStart token index of start layout fragment (inclusive)
+	 * @param loIndexEnd token index of end layout fragment (inclusive)
+	 */
+	private String layoutFragmentWithOutSeparator(int loIndexStart, int loIndexEnd){
+		String result = "";
+		for (int i = loIndexStart; i <= loIndexEnd; i++) {
+			if(!isValidTokenIndex(i)){ break;}
+			if(isLayout(i))
+				result += getTokenString(i);
+			else { //separator expected
+				assert(isSeparatorToken(i));
+				result += createSpaces(getTokenAt(i).getLength());
+			}
+		}
+		return result;
+	}
+
+	private String createSpaces(int length) {
+		String spaces="";
+		for (int i = 0; i < length; i++) {
+			spaces +=" ";
+		}
+		return spaces;
+	}
+
+	private int keepNewlineOfLineComment(int deletionEndOffset) {
+		while (Character.isWhitespace(getCharAt(deletionEndOffset))){ //newline at the end of line comment
+			deletionEndOffset --;
+		}
+		return deletionEndOffset;
+	}
+
+	/**
+	 * a) Always after separator, always after ast characters before node
+	 * b) No empty line between end of comment string and start of node
+	 * c) if comment is on the same line, then there is no preceding sibling on the same line except when (d)
+	 * d) "separator" - "comment - node" on the same line, then comment associated to node
+	 * e) if comment starts on same line as preceding ast token, then comment NOT associated to node 
+	 * f) grouping???
+	 */
+	private void analyzePrefix() {
+		prefixEndIndex = getLeftToken(node).getIndex()-1; //possible invalid index
+		final int prefixStartIndex = getPrefixIndexStart(prefixEndIndex); //possible invalid index
+		commentsBeforeStartIndex = getLeftToken(node).getIndex();
+		int tokenIndex = commentsBeforeStartIndex - 1;
+		int lastNonEmptyLine = getLeftToken(node).getLine();
+		int preceedingAstLine = -1;
+		if(isValidTokenIndex(prefixStartIndex-1)){
+			preceedingAstLine=getTokenAt(prefixStartIndex-1).getEndLine();
+		}
+		final boolean sameLineSiblings = preceedingSibEndLine()  == getLeftToken(node).getLine();
+		while(isValidTokenIndex(tokenIndex) && tokenIndex >= prefixStartIndex){
+			if(isComment(tokenIndex)){
+				int commentEndLine = getTokenAt(tokenIndex).getEndLine();
+				int commentStartLine = getTokenAt(tokenIndex).getLine();
+				if(lastNonEmptyLine - commentEndLine > 1)
+					break; //line between (b)
+				else if ((preceedingAstLine == commentStartLine) && !sameLineSiblings) {
+					break; //e comment associated to preceding astnode
+				}
+				else {
+					commentsBeforeStartIndex = tokenIndex;
+					lastNonEmptyLine = getTokenAt(tokenIndex).getLine();
+				}
+			}
+			if(isSeparatorToken(tokenIndex-1)){
+				break; //a) only comments after separator are included
+			}
+			if(tokenIndex == prefixStartIndex && sameLineSiblings){
+				commentsBeforeStartIndex = getLeftToken(node).getIndex(); //(c,d) comments fall between siblings
+				break;
+			}
+			tokenIndex --;
+		}
+		final int prefixSeparatorIndex = getIndexSeparator(prefixStartIndex, prefixEndIndex);//-1 in case not exists
+		
+		prefixSeparationStartIndex = prefixSeparatorIndex ==-1? commentsBeforeStartIndex : prefixSeparatorIndex;
+		while (isWhitespace(prefixSeparationStartIndex-1)) {
+			prefixSeparationStartIndex --; //start of next node fragment
+		}
+	}
+
+	/**
+	 * a) Always on the same line as node
+	 * b) If succeeding sibling on the same line, then: comments after separator are excluded
+	 * c) If succeeding sibling on the same line, then: comments only included if they are in front of separator 
+	 * d) If no succeeding sibling on the same line, then comment attaches to node (even when separator between node and comment) 
+	 */
+	private void analyzeSuffix() {
+		suffixStartIndex = getRightToken(node).getIndex() + 1; //possible invalid index
+		final int suffixEndIndex = getSuffixIndexEnd(suffixStartIndex); //possible invalid index
+		final boolean sameLineSiblings = 
+			tokensOnSameLine(suffixStartIndex -1, suffixEndIndex + 1) &&
+			!isLastListElement();
+		commentsAfterExclEndIndex = suffixStartIndex;
+		int tokenIndex = commentsAfterExclEndIndex;
+		//sets comment after end index
+		while(isValidTokenIndex(tokenIndex) && tokenIndex <= suffixEndIndex + 1){
+			if(getTokenAt(tokenIndex).getLine() != getRightToken(node).getEndLine()){
+				break; //a) comment not on same line
+			}
+			if(sameLineSiblings && tokenIndex == suffixEndIndex + 1){
+				//(c) same line, no separator: 
+				//comments is not associated to preceeding or succeeding sibling
+				commentsAfterExclEndIndex = suffixStartIndex; 
+				break;
+			}
+			if(sameLineSiblings && isSeparatorToken(tokenIndex)){
+				break; //b) exclude comments after separator between siblings on same line
+			}
+			if(isComment(tokenIndex)){
+				commentsAfterExclEndIndex = tokenIndex + 1; //d) consume comments
+			}
+			tokenIndex ++;
+		}
+		final int suffixSeparatorIndex = getIndexSeparator(suffixStartIndex, suffixEndIndex);//-1 in case not exists
+		suffixSeparationExclEndIndex = Math.max(commentsAfterExclEndIndex, suffixSeparatorIndex + 1);
+		while (isWhitespace(suffixSeparationExclEndIndex)) {
+			suffixSeparationExclEndIndex ++; //start of next node fragment
+		}
+	}
+
+	private boolean isFirstListElement() {
+		if(listParent == null)
+			return false;
+		if(node instanceof StrategoSubList){
+			return ((StrategoSubList)node).getIndexStart() == 0;
+		}
+		return listParent.getSubterm(0) == node;
+	}
+	
+	private int preceedingSibEndLine() {
+		if(isFirstListElement())
+			return -1;
+		if(listParent == null)
+			return -1;
+		int indexPreceedingSib = -1;
+		if(node instanceof StrategoSubList){
+			indexPreceedingSib = ((StrategoSubList)node).getIndexStart() - 1;
+			assert(listParent == ((StrategoSubList)node).getCompleteList());
+		}
+		else{
+			for (int i = 1; i < listParent.getSubtermCount(); i++) {
+				if(listParent.getSubterm(i)==node)
+					indexPreceedingSib = i-1;
+			}
+		}
+		assert(indexPreceedingSib >= 0 && indexPreceedingSib < listParent.getSubtermCount());
+		ISimpleTerm preceedingNode = listParent.getSubterm(indexPreceedingSib);
+		if(!ImploderAttachment.hasImploderOrigin(preceedingNode))
+			return -1;
+		return getRightToken(preceedingNode).getEndLine();
+	}
+
+	private boolean isLastListElement() {
+		if(listParent == null)
+			return false;
+		if(node instanceof StrategoSubList){
+			return ((StrategoSubList)node).getIndexEnd() == listParent.getSubtermCount()-1;
+		}
+		return listParent.getSubterm(listParent.getSubtermCount()-1) == node;
+	}
+	
+	
+	private boolean tokensOnSameLine(int i, int j) {
+		if(isValidTokenIndex(i) && isValidTokenIndex(j)){
+			return getTokenAt(i).getLine() == getTokenAt(j).getLine();
+		}
+		return false;
+	}
+
+	private IToken getTokenAt(int i) {
+		assert(isValidTokenIndex(i));
+		return tokens.getTokenAt(i);
+	}
+
+	private char getCharAt(int offset) {
+		assert(offset < tokens.getInput().length());
+		return tokens.getInput().charAt(offset);
+	}
+
+	private boolean isValidTokenIndex(int j){
+		return j>=0 && j < tokens.getTokenCount();
+	}
+
+	private int getSuffixIndexEnd(int suffixStartIndex) {
+		int suffixEndIndex = suffixStartIndex;
+		while (notAssociatedToAstNode(suffixEndIndex + 1)) {
+			assert(isValidTokenIndex(suffixEndIndex));
+			suffixEndIndex ++;
+		}
+		return suffixEndIndex;
+	}
+
+	private int getPrefixIndexStart(int prefixEndTokenIndex) {
+		int prefixStartIndex = prefixEndTokenIndex;
+		while (notAssociatedToAstNode(prefixStartIndex-1)) {
+			assert(isValidTokenIndex(prefixStartIndex));
+			prefixStartIndex--;
+		}
+		return prefixStartIndex;
+	}
+
+	private int getIndexSeparator(int suffixStartIndex, int suffixEndIndex) {
+		for (int i = suffixEndIndex; i >= suffixStartIndex; i--) {
+			if(isSeparatorToken(i))
+				return i;
+		}
+		return -1;
+	}
+
+
+	private boolean isSeparatorToken(int i) {
+		return isAssociatedToListParent(i) && !isLayout(i);
+	}
+
+	private boolean notAssociatedToAstNode(int tokenIndex){
+		return 
+			(isLayout(tokenIndex) || isAssociatedToListParent(tokenIndex));
+	}
+	
+	private boolean isWhitespace(int tokenIndex) {
+		return isLayout(tokenIndex) && !isComment(tokenIndex);
+	}
+
+	private boolean isComment(int tokenIndex) {
+		return 
+			isValidTokenIndex(tokenIndex) && 
+			isLayout(tokenIndex) && 
+			!Token.isWhiteSpace(getTokenAt(tokenIndex));
+	}
+
+	private boolean isLayout(int tokenIndex) {
+		return
+			isValidTokenIndex(tokenIndex) &&
+			getTokenAt(tokenIndex).getKind() == IToken.TK_LAYOUT;
+	}
+
+	private boolean isAssociatedToListParent(int tokenIndex) {
+		return 
+			isValidTokenIndex(tokenIndex) &&
+			listParent != null && 
+			getTokenAt(tokenIndex).getAstNode() == listParent;
+	}
+
+
+	private IStrategoTerm getParentList() {
+		if(node instanceof StrategoSubList){
+			return ((StrategoSubList)node).getCompleteList();
+		}
+		if (node.isList() && node.getSubtermCount() > 0)
+			return (IStrategoTerm) node;
+		if (getParent(node) == null)
+			return null;
+		return  getParent(node).isList()? getParent(node) : null;
+	}
+	
+	private String trimWsPreservingLastNewline(String layoutSuffix) {
+		String commentEnd = "";
+		if(layoutSuffix.endsWith("\n"))
+			commentEnd = "\n";
+		return layoutSuffix.trim() + commentEnd; //preserve line comment end
+	}
+
+	private String getIndentString() {
+		int offset = getLeftToken(node).getStartOffset();
+		String input = tokens.getInput();
+		String indentation = "";
+		for (int i = offset-1; i >= 0; i--) {
+			char character = input.charAt(i);
+			if(character == '\n')
+				return indentation;
+			else if(character == ' ' || character == '\t')
+				indentation = character + indentation;
+			else
+				indentation = "\t"; //node does not start on line, next line has more indent
+		}
+		return indentation;
+	}
+	
+	public String getSeparationString() { //TODO: find average separation?
+		if(listParent != null && listParent.getSubtermCount() > 1){
+			IToken startToken = getRightToken(listParent.getSubterm(0));
+			IToken endToken = getLeftToken(listParent.getSubterm(1));
+			return getSeparationString(startToken.getIndex(), endToken.getIndex());
+		}
+		return null;
+	}
+	
+	private String getSeparationString(int tokenIndexStart, int tokenIndexEnd) {
+		String separation="";
+		String layoutText="";
+		boolean commentSeen = false;
+		boolean commentLine = false;
+		for (int i = tokenIndexStart +1; i < tokenIndexEnd; i++) {
+			IToken token = tokens.getTokenAt(i);
+			String tokenText = getTokenString(i);
+			if(!isComment(i)){
+				if(!commentSeen)
+					separation += tokenText;
+				else
+					layoutText += tokenText;
+			}
+			else { 
+				commentSeen = true;
+				layoutText = ""; //layout between comments is not part of separation
+				if(tokenText.endsWith("\n"))
+					layoutText = "\n";
+				if(token.getLine() != getTokenAt(tokenIndexStart).getEndLine() && token.getEndLine() != getTokenAt(tokenIndexEnd).getLine())
+					commentLine = true;
+			}
+		}
+		if(commentLine){
+			separation = separation.replaceFirst("\n[ \t]*", "");
+		}
+		return separation + layoutText;
+	}
+	
+	private String getTokenString(int tokenIndex){
+		assert(isValidTokenIndex(tokenIndex));
+		IToken t = getTokenAt(tokenIndex);
+		int startOffset = t.getStartOffset();
+		int endOffset = t.getEndOffset();
+		return tokens.toString(startOffset, endOffset); 
+	}
+
+	private String getTokenString(int tokenIndexStart, int tokenIndexEnd){
+		assert(isValidTokenIndex(tokenIndexStart));
+		assert(isValidTokenIndex(tokenIndexEnd));
+		int startOffset = getTokenAt(tokenIndexStart).getStartOffset();
+		int endOffset = getTokenAt(tokenIndexEnd).getEndOffset();
+		return tokens.toString(startOffset, endOffset); 
+	}
+	
+	/*
+	private void logAnalysisResults() {
+		System.out.println("comm before:" + this.getCommentsBefore() + "#");
+		System.out.println("comm after:" + this.getCommentsAfter() + "#");
+		System.out.println("lo prefix:" + this.getLayoutPrefix() + "#");
+		System.out.println("lo suffix:" + this.getLayoutSuffix() + "#");
+		System.out.println("full text:" + this.getTextWithLayout() + "#");
+
+		System.out.println("indent:" + this.getIndentation() + "#");
+		System.out.println("separation:" + this.getSeparation() + "#");
+
+		System.out.println("del-start:" + this.getDeletionStartOffset());
+		System.out.println("del-end:" + this.getDeletionEndOffset());
+		System.out.println(tokens.toString(getDeletionStartOffset(), getDeletionEndOffset())+"#");
+		System.out.println("insert-before:" + this.getInsertBeforeOffset());
+		System.out.println("insert-at-end:" + this.getInsertAtEndOffset());
+		System.out.println(tokens.toString(getInsertBeforeOffset(), getInsertAtEndOffset())+"#");
+		System.out.println(tokens.toString(5,5) + "#--------------------");
+	}
+	*/
+
+}
+

Copied and modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginCommentsAfterPrimitive.java (from r23026, spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginCommentAfterPrimitive.java)
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginCommentAfterPrimitive.java	Wed Jun  8 14:38:19 2011	(r23026, copy source)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginCommentsAfterPrimitive.java	Thu Jun 23 16:00:25 2011	(r23093)
@@ -1,34 +1,25 @@
 package org.strategoxt.imp.runtime.stratego;
 
-import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getLeftToken;
-
 import org.spoofax.interpreter.core.IContext;
 import org.spoofax.interpreter.library.jsglr.origin.AbstractOriginPrimitive;
 import org.spoofax.interpreter.terms.IStrategoTerm;
-import org.strategoxt.imp.runtime.stratego.DocumentStructure.TextFragment;
+import org.spoofax.interpreter.terms.ITermFactory;
 
 /**
- * Extracts all comment lines directly after the current node on the same line
+ * Comments directly after (and associated with) the current node on the same line
  * @author Maartje de Jonge
  */
-public class OriginCommentAfterPrimitive extends AbstractOriginPrimitive {
+public class OriginCommentsAfterPrimitive extends AbstractOriginPrimitive {
 	
-	public OriginCommentAfterPrimitive() {
-		super("SSL_EXT_origin_comment_after");
+	public OriginCommentsAfterPrimitive() {
+		super("SSL_EXT_origin_comments_after");
 	}
 
 	@Override
 	protected IStrategoTerm call(IContext env, IStrategoTerm origin) {
-		DocumentStructure loStructure=new DocumentStructure(origin);
-		TextFragment commentBlock=loStructure.getCommentsAfter();
-		if(commentBlock==null)
-			return null;
-		
-		String lexStream=getLeftToken(origin).getTokenizer().getInput();
-		return env.getFactory().makeTuple(
-				env.getFactory().makeInt(commentBlock.getStart()),
-				env.getFactory().makeInt(commentBlock.getEnd()),
-				env.getFactory().makeString(commentBlock.getText(lexStream))
-		);
+		LayoutStructure docStructure = new LayoutStructure(origin);
+		String argumentsAfter = docStructure.getCommentsAfter();
+		ITermFactory factory = env.getFactory();		
+		return 	factory.makeString(argumentsAfter);
 	}
 }

Added: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginCommentsBeforePrimitive.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginCommentsBeforePrimitive.java	Thu Jun 23 16:00:25 2011	(r23093)
@@ -0,0 +1,25 @@
+package org.strategoxt.imp.runtime.stratego;
+
+import org.spoofax.interpreter.core.IContext;
+import org.spoofax.interpreter.library.jsglr.origin.AbstractOriginPrimitive;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.ITermFactory;
+
+/**
+ * Comments directly before and associated with the current node
+ * @author Maartje de Jonge
+ */
+public class OriginCommentsBeforePrimitive extends AbstractOriginPrimitive {
+	
+	public OriginCommentsBeforePrimitive() {
+		super("SSL_EXT_origin_comments_before");
+	}
+
+	@Override
+	protected IStrategoTerm call(IContext env, IStrategoTerm origin) {
+		LayoutStructure docStructure = new LayoutStructure(origin);
+		String layoutPrefix = docStructure.getLayoutPrefix();
+		ITermFactory factory = env.getFactory();		
+		return 	factory.makeString(layoutPrefix.trim());
+	}
+}

Added: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginDeletionOffsetPrimitive.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginDeletionOffsetPrimitive.java	Thu Jun 23 16:00:25 2011	(r23093)
@@ -0,0 +1,29 @@
+package org.strategoxt.imp.runtime.stratego;
+
+import org.spoofax.interpreter.core.IContext;
+import org.spoofax.interpreter.library.jsglr.origin.AbstractOriginPrimitive;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.ITermFactory;
+
+/**
+ * Returns (startOffset, endOffset) of the node text, 
+ * inclusive layout: comments before and after + separation
+ * @author Maartje de Jonge
+ */
+public class OriginDeletionOffsetPrimitive extends AbstractOriginPrimitive {
+	
+	public OriginDeletionOffsetPrimitive() {
+		super("SSL_EXT_origin_deletion_offset");
+	}
+
+	@Override
+	protected IStrategoTerm call(IContext env, IStrategoTerm origin) {		
+		LayoutStructure docStructure = new LayoutStructure(origin);
+
+		ITermFactory factory = env.getFactory();		
+		return factory.makeTuple(
+				factory.makeInt(docStructure.getDeletionStartOffset()),
+				factory.makeInt(docStructure.getDeletionEndOffset())
+		);
+	}
+}

Added: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginInsertAtEndOffsetPrimitive.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginInsertAtEndOffsetPrimitive.java	Thu Jun 23 16:00:25 2011	(r23093)
@@ -0,0 +1,22 @@
+package org.strategoxt.imp.runtime.stratego;
+
+import org.spoofax.interpreter.core.IContext;
+import org.spoofax.interpreter.library.jsglr.origin.AbstractOriginPrimitive;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+
+/**
+ * Offset for text insertions at the end of a list
+ * @author Maartje de Jonge
+ */
+public class OriginInsertAtEndOffsetPrimitive extends AbstractOriginPrimitive {
+	
+	public OriginInsertAtEndOffsetPrimitive() {
+		super("SSL_EXT_origin_insert_at_end_offset");
+	}
+
+	@Override
+	protected IStrategoTerm call(IContext env, IStrategoTerm origin) {
+		LayoutStructure docStructure = new LayoutStructure(origin);
+		return	env.getFactory().makeInt(docStructure.getInsertAtEndOffset());
+	}
+}

Added: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginInsertBeforeOffsetPrimitive.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginInsertBeforeOffsetPrimitive.java	Thu Jun 23 16:00:25 2011	(r23093)
@@ -0,0 +1,24 @@
+package org.strategoxt.imp.runtime.stratego;
+
+import org.spoofax.interpreter.core.IContext;
+import org.spoofax.interpreter.library.jsglr.origin.AbstractOriginPrimitive;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.ITermFactory;
+
+/**
+ * Offset for text insertions before a list element
+ * @author Maartje de Jonge
+ */
+public class OriginInsertBeforeOffsetPrimitive extends AbstractOriginPrimitive {
+	
+	public OriginInsertBeforeOffsetPrimitive() {
+		super("SSL_EXT_origin_insert_before_offset");
+	}
+
+	@Override
+	protected IStrategoTerm call(IContext env, IStrategoTerm origin) {
+		LayoutStructure docStructure = new LayoutStructure(origin);
+		ITermFactory factory = env.getFactory();		
+		return	factory.makeInt(docStructure.getInsertBeforeOffset());
+	}
+}

Copied and modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginLayoutPrefixPrimitive.java (from r23026, spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginCommentBeforePrimitive.java)
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginCommentBeforePrimitive.java	Wed Jun  8 14:38:19 2011	(r23026, copy source)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginLayoutPrefixPrimitive.java	Thu Jun 23 16:00:25 2011	(r23093)
@@ -1,33 +1,25 @@
 package org.strategoxt.imp.runtime.stratego;
 
-import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getTokenizer;
-
 import org.spoofax.interpreter.core.IContext;
 import org.spoofax.interpreter.library.jsglr.origin.AbstractOriginPrimitive;
 import org.spoofax.interpreter.terms.IStrategoTerm;
-import org.strategoxt.imp.runtime.stratego.DocumentStructure.TextFragment;
+import org.spoofax.interpreter.terms.ITermFactory;
 
 /**
- * Extracts all comment lines directly in front of the current node
+ * Returns all layout directly in front of and associated with the node
  * @author Maartje de Jonge
  */
-public class OriginCommentBeforePrimitive extends AbstractOriginPrimitive {
+public class OriginLayoutPrefixPrimitive extends AbstractOriginPrimitive {
 	
-	public OriginCommentBeforePrimitive() {
-		super("SSL_EXT_origin_comment_before");
+	public OriginLayoutPrefixPrimitive() {
+		super("SSL_EXT_origin_layout_prefix");
 	}
 
 	@Override
 	protected IStrategoTerm call(IContext env, IStrategoTerm origin) {
-		DocumentStructure loStructure=new DocumentStructure(origin);
-		TextFragment commentBlock=loStructure.getCommentsBefore();
-		if(commentBlock==null)
-			return null;
-		String lexStream=getTokenizer(origin).getInput();
-		return env.getFactory().makeTuple(
-				env.getFactory().makeInt(commentBlock.getStart()),
-				env.getFactory().makeInt(commentBlock.getEnd()),
-				env.getFactory().makeString(commentBlock.getText(lexStream))
-		);
+		LayoutStructure docStructure = new LayoutStructure(origin);
+		String layoutPrefix = docStructure.getLayoutPrefix();
+		ITermFactory factory = env.getFactory();		
+		return 	factory.makeString(layoutPrefix);
 	}
 }

Copied and modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginSeparationPrimitive.java (from r23026, spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginSeparatingWhitespacePrimitive.java)
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginSeparatingWhitespacePrimitive.java	Wed Jun  8 14:38:19 2011	(r23026, copy source)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginSeparationPrimitive.java	Thu Jun 23 16:00:25 2011	(r23093)
@@ -6,18 +6,21 @@
 import org.spoofax.interpreter.terms.ITermFactory;
 
 /**
+ * Returns separation between first and second element of the (parent) list.
+ * Returns null in case node is not a list fragment or parent list has fewer then 2 elements
  * @author Maartje de Jonge
  */
-public class OriginSeparatingWhitespacePrimitive extends AbstractOriginPrimitive {
+public class OriginSeparationPrimitive extends AbstractOriginPrimitive {
 
-	public OriginSeparatingWhitespacePrimitive() {
-		super("SSL_EXT_origin_separating_whitespace");
+	public OriginSeparationPrimitive() {
+		super("SSL_EXT_origin_separation");
 	}
 
 	@Override
 	protected IStrategoTerm call(IContext env, IStrategoTerm origin) {
-		DocumentStructure loStructure=new DocumentStructure(origin);
-		ITermFactory factory = env.getFactory();
-		return factory.makeString(loStructure.getSeperatingWhitespace());
+		LayoutStructure docStructure = new LayoutStructure(origin);
+		String separation = docStructure.getSeparation();
+		ITermFactory factory = env.getFactory();		
+		return factory.makeString(separation);
 	}
 }

Added: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginTextWithLayoutPrimitive.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginTextWithLayoutPrimitive.java	Thu Jun 23 16:00:25 2011	(r23093)
@@ -0,0 +1,25 @@
+package org.strategoxt.imp.runtime.stratego;
+
+import org.spoofax.interpreter.core.IContext;
+import org.spoofax.interpreter.library.jsglr.origin.AbstractOriginPrimitive;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.ITermFactory;
+
+/**
+ * Returns text of the node with associated comments (separator between node and comm after is replaced with whitespace)
+ * @author Maartje de Jonge
+ */
+public class OriginTextWithLayoutPrimitive extends AbstractOriginPrimitive {
+	
+	public OriginTextWithLayoutPrimitive() {
+		super("SSL_EXT_origin_text_with_layout");
+	}
+
+	@Override
+	protected IStrategoTerm call(IContext env, IStrategoTerm origin) {
+		LayoutStructure docStructure = new LayoutStructure(origin);
+		String text = docStructure.getTextWithLayout(); 
+		ITermFactory factory = env.getFactory();		
+		return 	factory.makeString(text);
+	}
+}

From m.dejonge at tudelft.nl  Thu Jun 23 18:05:46 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Thu, 23 Jun 2011 16:05:46 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23094 -
	spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego
Message-ID: <20110623160546.45958CC07E@mx4.tudelft.nl>

Author: MaartjeDeJonge
Date: Thu Jun 23 16:05:46 2011
New Revision: 23094
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23094&sc=1

Log:


Deleted:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginCommentAfterPrimitive.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginCommentBeforePrimitive.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginOffsetWithLayoutPrimitive.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginPositionPrimitive.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginSeparatingWhitespacePrimitive.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginSeparatorPrimitive.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginSeparatorWithLayoutPrimitive.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginTextFragmentPrimitive.java
Modified:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/IMPLibrary.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginIndentationPrimitive.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginSublistTermPrimitive.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/IMPLibrary.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/IMPLibrary.java	Thu Jun 23 16:00:25 2011	(r23093)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/IMPLibrary.java	Thu Jun 23 16:05:46 2011	(r23094)
@@ -15,14 +15,6 @@
 		add(new ProjectPathPrimitive());
 		add(new PluginPathPrimitive());
 		add(new RefreshResourcePrimitive());
-		add(new OriginSublistTermPrimitive());
-		add(new OriginTextFragmentPrimitive());
-		add(new OriginSurroundingCommentsPrimitive());
-		add(new OriginCommentBeforePrimitive());
-		add(new OriginCommentAfterPrimitive());
-		add(new TextChangePrimitive());
-		add(new OriginPositionPrimitive());
-		add(new OriginOffsetWithLayoutPrimitive());
 		add(new QueueAnalysisPrimitive());
 		add(new QueueStrategyPrimitive());
 		add(new SetMarkersPrimitive());
@@ -30,14 +22,22 @@
 		
 		add(new SetTotalWorkUnitsPrimitive());
 		add(new CompleteWorkUnitPrimitive());
-		add(new OriginIndentationPrimitive());
-		add(new OriginSeparatingWhitespacePrimitive());
-		add(new OriginSeparatorPrimitive());
-		add(new OriginSeparatorWithLayoutPrimitive());
 		add(new SaveAllResourcesPrimitive());
 		add(new MessageDialogPrimitive());
 		add(new LanguageDescriptionPrimitive());
 		add(new OverrideInputPrimitive());
+
+		add(new OriginSublistTermPrimitive());
+		add(new OriginSurroundingCommentsPrimitive());
+		add(new OriginLayoutPrefixPrimitive());
+		add(new OriginCommentsAfterPrimitive());
+		add(new OriginCommentsBeforePrimitive());
+		add(new OriginIndentationPrimitive());
+		add(new OriginSeparationPrimitive());
+		add(new OriginDeletionOffsetPrimitive());
+		add(new OriginInsertBeforeOffsetPrimitive());
+		add(new OriginInsertAtEndOffsetPrimitive());
+		add(new OriginTextWithLayoutPrimitive());
 	}
 
 	public String getOperatorRegistryName() {

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginIndentationPrimitive.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginIndentationPrimitive.java	Thu Jun 23 16:00:25 2011	(r23093)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginIndentationPrimitive.java	Thu Jun 23 16:05:46 2011	(r23094)
@@ -6,6 +6,7 @@
 import org.spoofax.interpreter.terms.ITermFactory;
 
 /**
+ * Returns indentation of the line where the node starts 
  * @author Maartje de Jonge
  */
 public class OriginIndentationPrimitive extends AbstractOriginPrimitive {
@@ -16,9 +17,9 @@
 
 	@Override
 	protected IStrategoTerm call(IContext env, IStrategoTerm origin) {
-		DocumentStructure loStructure=new DocumentStructure(origin);
+		LayoutStructure loStructure = new LayoutStructure(origin);
 		ITermFactory factory = env.getFactory();
-		return factory.makeString(loStructure.getIndentNode());
+		return factory.makeString(loStructure.getIndentation());
 	}
 
 }

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginSublistTermPrimitive.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginSublistTermPrimitive.java	Thu Jun 23 16:00:25 2011	(r23093)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/OriginSublistTermPrimitive.java	Thu Jun 23 16:05:46 2011	(r23094)
@@ -1,6 +1,5 @@
 package org.strategoxt.imp.runtime.stratego;
 
-import static org.spoofax.interpreter.core.Tools.isTermString;
 import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getImploderOrigin;
 import static org.spoofax.jsglr.client.imploder.ImploderAttachment.hasImploderOrigin;
 import static org.spoofax.terms.Term.isTermList;
@@ -27,16 +26,16 @@
 	private static final String NAME = "SSL_EXT_origin_sublist_term";
 
 	public OriginSublistTermPrimitive() {
-		super(NAME, 0, 2);
+		super(NAME, 0, 1);
 	}
 	
 	@Override
 	public final boolean call(IContext env, Strategy[] svars, IStrategoTerm[] tvars) {
-		if (!isTermString(tvars[0]) || !isTermList(tvars[1]))//|| (tvars[1].getTermType()!= IStrategoTerm.LIST)
+		if (!isTermList(tvars[0]))
 			return false;
-		if(tvars[1].getTermType()!= IStrategoTerm.LIST)
+		if(tvars[0].getTermType() != IStrategoTerm.LIST)
 			return false;
-		IStrategoList list=(IStrategoList)tvars[1];
+		IStrategoList list=(IStrategoList)tvars[0];
 		if(list.isEmpty())
 			return false;
 		for (IStrategoTerm child : list.getAllSubterms()) {
@@ -45,11 +44,9 @@
 		}
 		IStrategoTerm firstChildNode= tryGetOrigin(list.getSubterm(0));
 		IStrategoTerm commonParentList=getParent(firstChildNode);
-		if(commonParentList == null)
+		if(commonParentList == null || !(isTermList(commonParentList)))
 			return false;
 		List<IStrategoTerm> childNodes= Arrays.asList(commonParentList.getAllSubterms());
-		if(!(isTermList(commonParentList)))
-			return false;
 		int startIndex=-1;
 		for (int i = 0; i < childNodes.size(); i++) {
 			if(childNodes.get(i)==firstChildNode){
@@ -57,10 +54,6 @@
 				break;
 			}
 		}
-		// XXX: Maartje - many of these primitives don't check hasImploderOrigin() before getting the origin...
-		//      What if a term has no origin?!
-		//      Before, this could result in a ClassCastException. now, with tryGetOrigin, you just get a non-origin term.
-		//      Or with getOrigin()/getImploderOrigin(), you get null
 		for (int i = 0; i < list.size(); i++) {
 			if(childNodes.size()<=i+startIndex)
 				return false;

From m.dejonge at tudelft.nl  Thu Jun 23 18:08:10 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Thu, 23 Jun 2011 16:08:10 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23095 -
	spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego
Message-ID: <20110623160810.7293F7F801E@mx1.tudelft.nl>

Author: MaartjeDeJonge
Date: Thu Jun 23 16:08:10 2011
New Revision: 23095
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23095&sc=1

Log:


Deleted:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/TextChangePrimitive.java

From m.dejonge at tudelft.nl  Thu Jun 23 18:09:11 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Thu, 23 Jun 2011 16:09:11 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23096 -
	spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast
Message-ID: <20110623160911.861AA7F8055@mx1.tudelft.nl>

Author: MaartjeDeJonge
Date: Thu Jun 23 16:09:11 2011
New Revision: 23096
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23096&sc=1

Log:


Modified:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/StrategoSubList.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/StrategoSubList.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/StrategoSubList.java	Thu Jun 23 16:08:10 2011	(r23095)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/StrategoSubList.java	Thu Jun 23 16:09:11 2011	(r23096)
@@ -49,7 +49,7 @@
 			}
 			i++;
 		}
-		assert(0 <+ indexStart && indexStart <= indexEnd);
+		assert(0 <= indexStart && indexStart <= indexEnd);
 		IStrategoList wrapped = Environment.getTermFactory().makeList(children);
 		StrategoSubList result = new StrategoSubList(list, wrapped, indexStart, indexEnd);
 		

From m.dejonge at tudelft.nl  Thu Jun 23 18:14:05 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Thu, 23 Jun 2011 16:14:05 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23097 -
	spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/util
Message-ID: <20110623161405.5F7D17F8088@mx1.tudelft.nl>

Author: MaartjeDeJonge
Date: Thu Jun 23 16:14:05 2011
New Revision: 23097
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23097&sc=1

Log:


Modified:
   spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/util/construct-text.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/util/construct-text.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/util/construct-text.str	Thu Jun 23 16:09:11 2011	(r23096)
+++ spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/util/construct-text.str	Thu Jun 23 16:14:05 2011	(r23097)
@@ -76,10 +76,10 @@
 	where //guarantees that node can be formatted from the origin node, preventing non-termination
 		<is-tuple> t; 
 		<has-origin-term> origin-node;
-		ast-changes := <collect-ast-changes(in-parent-context(|origin-node))> (origin-node, node); debug(!"ast-changes: ");
+		ast-changes := <collect-ast-changes(in-parent-context(|origin-node))> (origin-node, node); //debug(!"ast-changes: ");
 		<is-terminating-diff(|node)> ast-changes //prevent non termination
 	with
-		text-changes := <map(ast-change-to-text-change(pp))> ast-changes; debug(!"txt-changes: ");
+		text-changes := <map(ast-change-to-text-change(pp))> ast-changes; //debug(!"txt-changes: ");
 		text := <apply-text-changes>(text-changes, <origin-text> origin-node, <origin-start-offset> origin-node)		
 
 construct-text-by-pp(pp):
@@ -102,8 +102,8 @@
 		<is-tuple> t;
 		<has-origin-term> origin-node
 	with //termination check is not needed (we need to Replace to keep comments), since it is called on a subterm in construct-text-by-pp
-		ast-changes := <collect-ast-changes(in-parent-context(|origin-node))> (origin-node, node); debug(!"--ast-changes: ");
-		text-changes := <map(ast-change-to-text-change(pp))> ast-changes; debug(!"--txt-changes: ");
+		ast-changes := <collect-ast-changes(in-parent-context(|origin-node))> (origin-node, node); //debug(!"--ast-changes: ");
+		text-changes := <map(ast-change-to-text-change(pp))> ast-changes; //debug(!"--txt-changes: ");
 		full-text := <origin-text-with-layout> origin-node; 
 		full-text-start-offset := <origin-layout-prefix-start-offset> origin-node; 
 		modified-full-text := <apply-text-changes>(text-changes, full-text, full-text-start-offset);

From n.bruning at student.tudelft.nl  Sun Jun 26 19:05:48 2011
From: n.bruning at student.tudelft.nl (Nathan Bruning)
Date: Sun, 26 Jun 2011 17:05:48 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23098 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans
Message-ID: <20110626170548.70A16108C061@mx3.tudelft.nl>

Author: NathanBruning
Date: Sun Jun 26 17:05:48 2011
New Revision: 23098
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23098&sc=1

Log:
Expose declaration of variables inside scope to outer environment

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/analysis.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/analysis.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/analysis.str	Thu Jun 23 16:14:05 2011	(r23097)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/analysis.str	Sun Jun 26 17:05:48 2011	(r23098)
@@ -367,22 +367,25 @@
   declare-bodies:
     ScopeDefault(s) -> ScopeDefault(s')
     with
-      {| DeclareCookie:
-        with(
-          tvars;
-          list-loop({
-            sig := (<id>, 0); rules(DeclareCookie :- sig)
-          })
-        );
-        s' := <declare-bodies-top> s
-      |}
+      s' := <scope-variables(declare-bodies-top | <tvars>)> s
 
   declare-bodies:
     Scope(v*, s) -> Scope(v*, s')
     with
-      {| DeclareCookie:
-        <list-loop({ sig := (<id>, 0); rules(DeclareCookie :- sig)})> v*;
-        s' := <declare-bodies-top> s
+      s' := <scope-variables(declare-bodies-top | v*)> s
+      
+  scope-variables(s | vars): x -> x'
+    with
+      // Temporarely undeclare vars for redeclaration errors
+      {| OuterCookie:
+        // Undeclare
+        <list-loop({
+          sig := (<id>, 0);
+          try(DeclareCookie; rules(OuterCookie : sig -> <id>));
+          rules(DeclareCookie :- sig)})> vars;
+        x' := <declare-bodies-top> x;
+        // Re-declare
+        all-keys-OuterCookie; map(\key -> <rules(DeclareCookie : key -> <OuterCookie> key)> \)
       |}
 
   declare-bodies:

From n.bruning at student.tudelft.nl  Sun Jun 26 19:26:06 2011
From: n.bruning at student.tudelft.nl (Nathan Bruning)
Date: Sun, 26 Jun 2011 17:26:06 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23099 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans
Message-ID: <20110626172606.B9F69108C061@mx3.tudelft.nl>

Author: NathanBruning
Date: Sun Jun 26 17:26:06 2011
New Revision: 23099
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23099&sc=1

Log:
Fix previous commit: no more rule applications in right hand sides

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/analysis.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/analysis.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/analysis.str	Sun Jun 26 17:05:48 2011	(r23098)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/analysis.str	Sun Jun 26 17:26:06 2011	(r23099)
@@ -381,11 +381,11 @@
         // Undeclare
         <list-loop({
           sig := (<id>, 0);
-          try(DeclareCookie; rules(OuterCookie : sig -> <id>));
+          try({cookie: DeclareCookie; ?cookie; rules(OuterCookie : sig -> cookie)});
           rules(DeclareCookie :- sig)})> vars;
         x' := <declare-bodies-top> x;
         // Re-declare
-        all-keys-OuterCookie; map(\key -> <rules(DeclareCookie : key -> <OuterCookie> key)> \)
+        all-keys-OuterCookie; map({cookie: \key -> <OuterCookie; ?cookie; rules(DeclareCookie : key -> cookie)> \})
       |}
 
   declare-bodies:

From seba at informatik.uni-marburg.de  Tue Jun 28 10:00:36 2011
From: seba at informatik.uni-marburg.de (Sebastian Erdweg)
Date: Tue, 28 Jun 2011 08:00:36 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23100 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client
Message-ID: <20110628080036.4AF17CC124@mx4.tudelft.nl>

Author: SebastianErdweg
Date: Tue Jun 28 08:00:34 2011
New Revision: 23100
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23100&sc=1

Log:
fixed bug in parsing priorities from parse table

Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ParseTable.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ParseTable.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ParseTable.java	Sun Jun 26 17:26:06 2011	(r23099)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ParseTable.java	Tue Jun 28 08:00:34 2011	(r23100)
@@ -172,7 +172,7 @@
                     ret.add(new Priority(Priority.GTR, left, right));
             } else if (a.getName().equals("arg-gtr-prio")) {
             	int arg = right;
-            	right = intAt(a, 1);
+            	right = intAt(a, 2);
                 if(left != right)
                     ret.add(new Priority(Priority.GTR, left, right, arg));
             } else {

From tobivollebregt at gmail.com  Tue Jun 28 17:46:56 2011
From: tobivollebregt at gmail.com (Tobi Vollebregt)
Date: Tue, 28 Jun 2011 15:46:56 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23101 -
	spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl
Message-ID: <20110628154656.24370108C03F@mx3.tudelft.nl>

Author: tvo
Date: Tue Jun 28 15:46:55 2011
New Revision: 23101
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23101&sc=1

Log:
Fix SSL_int and SSL_real

Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_int.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_real.java

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_int.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_int.java	Tue Jun 28 08:00:34 2011	(r23100)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_int.java	Tue Jun 28 15:46:55 2011	(r23101)
@@ -19,6 +19,7 @@
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
  * @author Sander Vermolen <sandervermolen near gmail.com>
+ * @author Tobi Vollebregt
  */
 public class SSL_int extends AbstractPrimitive {
 
@@ -34,7 +35,7 @@
 
         if(Tools.isTermReal(tvars[0])) {
             IStrategoReal a = (IStrategoReal) tvars[0];
-            env.setCurrent(env.getFactory().makeReal(a.realValue()));
+            env.setCurrent(env.getFactory().makeInt((int) a.realValue()));
             return true;
         }
         

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_real.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_real.java	Tue Jun 28 08:00:34 2011	(r23100)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/library/ssl/SSL_real.java	Tue Jun 28 15:46:55 2011	(r23101)
@@ -18,6 +18,7 @@
 /**
  * @author Sander Vermolen <sandervermolen near gmail.com>
  * @author Lennart Kats <lennart add lclnet.nl>
+ * @author Tobi Vollebregt
  */
 public class SSL_real extends AbstractPrimitive {
 
@@ -33,7 +34,7 @@
 
         if(Tools.isTermInt(tvars[0])) {
             IStrategoInt a = (IStrategoInt) tvars[0];
-            env.setCurrent(env.getFactory().makeInt(a.intValue()));
+            env.setCurrent(env.getFactory().makeReal(a.intValue()));
             return true;
         }
         

From tobivollebregt at gmail.com  Tue Jun 28 17:48:37 2011
From: tobivollebregt at gmail.com (Tobi Vollebregt)
Date: Tue, 28 Jun 2011 15:48:37 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23102 -
	strategoxt/trunk/stratego-libraries/lib/tests
Message-ID: <20110628154837.7940C7F80A6@mx1.tudelft.nl>

Author: tvo
Date: Tue Jun 28 15:48:37 2011
New Revision: 23102
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23102&sc=1

Log:
tests for the previous commit and for Spoofax/312 (negative integers in ATerm format)

Modified:
   strategoxt/trunk/stratego-libraries/lib/tests/integers-test.str
   strategoxt/trunk/stratego-libraries/lib/tests/reals-test.str
   strategoxt/trunk/stratego-libraries/lib/tests/system-io-file-test.str

Modified: strategoxt/trunk/stratego-libraries/lib/tests/integers-test.str
==============================================================================
--- strategoxt/trunk/stratego-libraries/lib/tests/integers-test.str	Tue Jun 28 15:46:55 2011	(r23101)
+++ strategoxt/trunk/stratego-libraries/lib/tests/integers-test.str	Tue Jun 28 15:48:37 2011	(r23102)
@@ -2,11 +2,12 @@
 imports libstratego-lib
 strategies
 
-  main = 
+  main =
     test-suite(!"integers-test",
       test1
     ; test2
     ; test3
+    ; int-test
     ; lt-lt-test
     ; string-to-int-tests
     ; mod-tests
@@ -17,38 +18,42 @@
 
   test1 =
     apply-test(!"test1"
-	, leq
-	, !(5,5)
-	, !(5,5)
-	)
+  , leq
+  , !(5,5)
+  , !(5,5)
+  )
 
   test2 =
     apply-test(!"test2a"
-	, !(<divi>(<id>, 2), <mod; ?0>(<id>, 2))
-	, !16
-	, !(8,0)
-	);
+  , !(<divi>(<id>, 2), <mod; ?0>(<id>, 2))
+  , !16
+  , !(8,0)
+  );
     apply-test(!"test2b"
-	, log2
-	, !16
-	, !4
-	);
+  , log2
+  , !16
+  , !4
+  );
     apply-and-fail(!"test2c"
-	, log2
-	, !6
-	)
+  , log2
+  , !6
+  )
 
   test3 =
     apply-test(!"test3"
-	, addS
-	, !("5","3")
-	, !"8"
-	);
+  , addS
+  , !("5","3")
+  , !"8"
+  );
     apply-test(!"test3"
-	, ltS
-	, !("3","5")
-	, !("3","5")
-	)
+  , ltS
+  , !("3","5")
+  , !("3","5")
+  )
+
+  int-test =
+    apply-test(!"int-test pos", int, !1.9, !1);
+    apply-test(!"int-test neg", int, !-1.9, !-2)
 
 strategies
 
@@ -177,4 +182,3 @@
     ; apply-test(!"bin-string-test-c", bin-string-to-int, !"10110000", !176)
     ; apply-test(!"bin-string-test-b", bin-string-to-int, !"111100011", !483)
     ; apply-test(!"bin-string-test-d", bin-string-to-int, !"101010101", !341)
-

Modified: strategoxt/trunk/stratego-libraries/lib/tests/reals-test.str
==============================================================================
--- strategoxt/trunk/stratego-libraries/lib/tests/reals-test.str	Tue Jun 28 15:46:55 2011	(r23101)
+++ strategoxt/trunk/stratego-libraries/lib/tests/reals-test.str	Tue Jun 28 15:48:37 2011	(r23102)
@@ -1,29 +1,29 @@
 module reals-test
 imports libstratego-lib
-strategies 
+strategies
 
-  main = 
+  main =
     test-suite(!"reals-test",
-	id-test;
-	cos-test;
-	sin-test;
-	sqrt-test;
-	real-to-string-test;
-	string-to-real-test//;
-	//real-test
+      id-test
+    ; cos-test
+    ; sin-test
+    ; sqrt-test
+    ; real-to-string-test
+    ; string-to-real-test
+    ; real-test
     )
 
-  id-test = 
-	apply-and-show(!"id-test", id, !10.8)
-  
-  cos-test =  
-	apply-and-show(!"cos-test", cos, !10.8)
+  id-test =
+    apply-and-show(!"id-test", id, !10.8)
 
-  sin-test = 
-	apply-and-show(!"sin-test", sin, !1.6)
+  cos-test =
+    apply-and-show(!"cos-test", cos, !10.8)
 
-  sqrt-test = 
-	apply-and-show(!"sqrt-test", sqrt, !1.6)
+  sin-test =
+    apply-and-show(!"sin-test", sin, !1.6)
+
+  sqrt-test =
+    apply-and-show(!"sqrt-test", sqrt, !1.6)
 
   real-to-string-test =
     apply-and-show(!"real-to-string-test", real-to-string, !12345678901234567.0)
@@ -36,4 +36,5 @@
     apply-and-show(!"string-to-real-test", string-to-real, !"1.2345678901234567e307")
 
   real-test =
-    apply-and-show(!"real-test", real, !1)
+    apply-test(!"real-test pos", real, !1, !1.0);
+    apply-test(!"real-test neg", real, !-1, !-1.0)

Modified: strategoxt/trunk/stratego-libraries/lib/tests/system-io-file-test.str
==============================================================================
--- strategoxt/trunk/stratego-libraries/lib/tests/system-io-file-test.str	Tue Jun 28 15:46:55 2011	(r23101)
+++ strategoxt/trunk/stratego-libraries/lib/tests/system-io-file-test.str	Tue Jun 28 15:48:37 2011	(r23102)
@@ -234,9 +234,10 @@
 
   aterm-io-tests(writer) =
       apply-test(!"ATerm IO -- 1", write-read-term(writer), !"Bla Bla Bla", !"Bla Bla Bla")
-    // ; apply-test(!"ATerm IO -- 2", write-read-term(writer), !(), !()) TODO: fails ON TAF!
+    ; apply-test(!"ATerm IO -- 2", write-read-term(writer), !(), !())
     ; apply-test(!"ATerm IO -- 3", write-read-term(writer), !1, !1)
     ; apply-test(!"ATerm IO -- 4", write-read-term(writer), !None(), !None())
+    ; apply-test(!"ATerm IO -- 5", write-read-term(writer), !-1, !-1) // Spoofax/312
 
   write-read-term(writer) =
     ?t

From tobivollebregt at gmail.com  Tue Jun 28 18:33:05 2011
From: tobivollebregt at gmail.com (Tobi Vollebregt)
Date: Tue, 28 Jun 2011 16:33:05 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23103 -
	strategoxt/trunk/stratego-libraries/lib/tests
Message-ID: <20110628163305.30657108C09D@mx3.tudelft.nl>

Author: tvo
Date: Tue Jun 28 16:33:04 2011
New Revision: 23103
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23103&sc=1

Log:
oops, it's round towards zero, not round down

Modified:
   strategoxt/trunk/stratego-libraries/lib/tests/integers-test.str

Modified: strategoxt/trunk/stratego-libraries/lib/tests/integers-test.str
==============================================================================
--- strategoxt/trunk/stratego-libraries/lib/tests/integers-test.str	Tue Jun 28 15:48:37 2011	(r23102)
+++ strategoxt/trunk/stratego-libraries/lib/tests/integers-test.str	Tue Jun 28 16:33:04 2011	(r23103)
@@ -53,7 +53,7 @@
 
   int-test =
     apply-test(!"int-test pos", int, !1.9, !1);
-    apply-test(!"int-test neg", int, !-1.9, !-2)
+    apply-test(!"int-test neg", int, !-1.9, !-1)
 
 strategies
 

