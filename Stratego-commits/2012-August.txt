From m.dejonge at tudelft.nl  Wed Aug  1 15:07:09 2012
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Wed, 01 Aug 2012 13:07:09 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25243 - in
	spoofax/trunk/spoofax/org.spoofax.jsglr:
	src/org/spoofax/jsglr/client/editregion
	src/org/spoofax/jsglr/client/editregion/detection
	test/org/spoofax/jsglr/client...
Message-ID: <20120801130709.0E98F7F803C@mx1.tudelft.nl>

Author: MaartjeDeJonge
Date: Wed Aug  1 13:07:07 2012
New Revision: 25243
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25243&sc=1

Log:
detection of (discardable) edit region.
intended usecases:
- (non-correcting) recovery technique
- region detection technique as preprocessor for correcting technique
- analysis of edit scenarios
- oracle for error locations (?)
- incremental parsing(?)

Added:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DamagedTokenAnalyzer.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DiscardableRegion.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/HelperFunctions.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/LCS.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/LCSCommand.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/LayoutEditsAnalyzer.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/NonTerminalEditsAnalyzer.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TerminalEditsAnalyzer.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/
   spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/
   spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/
   spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/AbstractTestRegionDetection.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionBasic.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionInsertonsInToken.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionLayout.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionMisc.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionNestedListElems.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionOperators.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionSeparators.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/basic/
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/basic/base.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/basic/del-ins-nesting.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/basic/deletion-and-insertion.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/basic/deletion.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/basic/insertion.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/basic/multiple-deletions.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/basic/nested-deletions.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/basic/replacement.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/insertions/
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/insertions/base.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/insertions/ins-in-comment-opening.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/insertions/ins-in-terminal1.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/insertions/ins-in-terminal2.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/insertions/ins-in-terminal3.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/insertions/ins-in-terminal4.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/layout/
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/layout/base.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/layout/delete-block-comment-ending1.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/layout/delete-block-comment-ending2.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/layout/delete-block-comment-ending3.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/layout/delete-block-comment1.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/layout/delete-block-comment2.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/layout/delete-layout-inbetween.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/layout/delete-line-comment-ending.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/layout/delete-some-layout-inbetween1.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/layout/delete-some-layout-inbetween2.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/misc/
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/misc/base.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/misc/copy-paste.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/misc/del-required-list-elem.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/misc/tricky.base.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/misc/tricky.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/nested-list-elems/
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/nested-list-elems/base.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/nested-list-elems/deletion-in-parent-and-child-elem.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/nested-list-elems/deletion-in-parent-elem1.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/nested-list-elems/deletion-in-parent-elem2.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/nested-list-elems/deletion-in-parent-elem3.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/nested-list-elems/deletion-in-parent-elem4.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/operators/
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/operators/base.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/operators/delete-multiple-operands.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/operators/delete-multiple-operators1.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/operators/delete-multiple-operators2.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/operators/delete-multiple-operators3.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/operators/delete-operand-1.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/operators/delete-operand-2.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/operators/delete-operator-1.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/operators/delete-operator-2.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/operators/delete-operator-3.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/separators/
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/separators/base.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/separators/del-separated-elem-first.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/separators/del-separated-elem-last.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/separators/del-separated-elem-mid.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/separators/del-separator-and-next-elem.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/separators/del-separator.java   (contents, props changed)

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DamagedTokenAnalyzer.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DamagedTokenAnalyzer.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,139 @@
+package org.spoofax.jsglr.client.editregion.detection;
+
+import java.util.ArrayList;
+import org.spoofax.jsglr.client.editregion.detection.LCS;
+import org.spoofax.jsglr.client.imploder.IToken;
+import org.spoofax.jsglr.client.imploder.ITokenizer;
+import org.spoofax.jsglr.client.imploder.Token;
+
+/**
+ * Determines the tokens in the correct term that are (possible) damaged
+ * by either the deletion of characters that form the token,
+ * or the insertion of characters between the start and end character of the token.   
+ * Example insertion: private => priva$te 
+ * Example deletion: private => privte 
+ * @author Maartje de Jonge
+ *
+ */
+public class DamagedTokenAnalyzer {
+
+	private final ITokenizer tokens;
+	private final LCS<Character> lcs;
+	
+	//filled in the token stream analysis
+	private final ArrayList<IToken> tokensDamagedByInsertion;
+	private final ArrayList<IToken> tokensDamagedByDeletion;
+
+	/**
+	 * Returns all tokens in the correct term that are (possible) damaged by
+	 * the insertion of characters between the start and end character of the token.   
+	 * Example: private => priva$te 
+	 */
+	public ArrayList<IToken> getTokensDamagedByInsertion() {
+		ArrayList<IToken> result = new ArrayList<IToken>();
+		result.addAll(tokensDamagedByInsertion);
+		return result;
+	}
+
+	/**
+	 * Returns all tokens in the correct term that are (possible) damaged by
+	 * the deletion of characters that form the token.   
+	 * Example: private => privte 
+	 */
+	public ArrayList<IToken> getTokensDamagedByDeletion() {
+		ArrayList<IToken> result = new ArrayList<IToken>();
+		result.addAll(tokensDamagedByDeletion);
+		return result;
+	}
+	
+	/**
+	 * Determines the tokens in the correct term that are (possible) damaged
+	 * by edit operations.
+	 */
+	public DamagedTokenAnalyzer(ITokenizer tokens, LCS<Character> lcs){
+		this.tokens = tokens;
+		this.lcs = lcs;
+		this.tokensDamagedByInsertion = new ArrayList<IToken>();
+		this.tokensDamagedByDeletion = new ArrayList<IToken>();
+		analyzeDamagedTokens();
+	}
+
+	private void analyzeDamagedTokens() {
+		for (int i = 0; i < tokens.getTokenCount(); i++) {
+			IToken t = tokens.getTokenAt(i);
+			if (isDamagedByDeletion(t)){
+				tokensDamagedByDeletion.add(t);
+			}
+			if (isDamagedByInsertion(t)){
+				tokensDamagedByInsertion.add(t);
+			}
+		}
+	}
+
+	public boolean isDamagedByDeletion(IToken t) {
+		ArrayList<Integer> deletions = getOffsetsDeletions(t);
+		return !deletions.isEmpty();
+	}
+
+	public ArrayList<Integer> getOffsetsDeletions(IToken t) {
+		int startOffset = t.getStartOffset();
+		int endOffset = t.getEndOffset();
+		ArrayList<Integer> deletions = new ArrayList<Integer>();
+		for (int j = startOffset; j <= endOffset; j++) {
+			if(lcs.getMatchIndexInElems2(j) == -1){
+				deletions.add(j);
+			}
+		}
+		return deletions;
+	}
+	
+	public boolean isDamagedByInsertion(IToken t) {
+		int startOffset = t.getStartOffset();
+		int endOffset = t.getEndOffset();
+		int offsetPreviousMatch = -1;
+		for (int j = startOffset; j <= endOffset; j++) {
+			int matchIndexInElems2 = lcs.getMatchIndexInElems2(j);
+			if(offsetPreviousMatch != -1 && matchIndexInElems2 > offsetPreviousMatch + 1){
+				return true;
+			}
+			offsetPreviousMatch = matchIndexInElems2;
+		}
+		return false;
+	}
+	
+	public boolean isDamagingLayoutDeletion(IToken tokenWithDeletions) {
+		int numberOfDeletions = getOffsetsDeletions(tokenWithDeletions).size();
+		int startOffset = tokenWithDeletions.getStartOffset();
+		int endOffset = tokenWithDeletions.getEndOffset();
+		if (numberOfDeletions == endOffset - startOffset + 1){ //full deletion
+			int firstMatchedOffsetInPrefix = -1;
+			int firstMatchedOffsetInSuffix = -1;
+			for (int offsetInPrefix = startOffset -1; offsetInPrefix >= 0; offsetInPrefix--) {
+				if(lcs.getMatchIndexInElems2(offsetInPrefix) != -1){
+					firstMatchedOffsetInPrefix = offsetInPrefix;
+					break;
+				}
+			}
+			for (int offsetInSuffix = endOffset + 1; offsetInSuffix < lcs.getElems1().size(); offsetInSuffix++) {
+				if(lcs.getMatchIndexInElems2(offsetInSuffix) != -1){
+					firstMatchedOffsetInSuffix = offsetInSuffix;
+					break;
+				}
+			}
+			int firstMatchedOffsetInPrefix_2 = lcs.getMatchIndexInElems2(firstMatchedOffsetInPrefix);
+			int firstMatchedOffsetInSuffix_2 = lcs.getMatchIndexInElems2(firstMatchedOffsetInSuffix);
+			return //checks if all layout is deleted between the surrounding tokens in elems2
+				firstMatchedOffsetInSuffix_2 == firstMatchedOffsetInPrefix_2 + 1 && //no insertions that are discarded as whitespace
+				firstMatchedOffsetInPrefix_2 != -1 &&
+				firstMatchedOffsetInSuffix_2 != -1 &&
+				!isOffsetOfLayoutChar(tokenWithDeletions.getTokenizer(), firstMatchedOffsetInPrefix) &&
+				!isOffsetOfLayoutChar(tokenWithDeletions.getTokenizer(), firstMatchedOffsetInSuffix);
+		}
+		return false;
+	}
+
+	private boolean isOffsetOfLayoutChar(ITokenizer tokens, int offset) {
+		boolean precedingLayout = tokens.getTokenAtOffset(offset).getKind() == Token.TK_LAYOUT;
+		return precedingLayout;
+	}
+}

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DiscardableRegion.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DiscardableRegion.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,52 @@
+package org.spoofax.jsglr.client.editregion.detection;
+
+import org.spoofax.interpreter.terms.IStrategoTerm;
+
+/**
+ * Fragment in the source code that represents a (possibly broken) construct
+ * that (presumably) can be discarded safely, e.g., without invalidating the parse input.
+ * @author maartje
+ */
+public class DiscardableRegion{
+	private final int startOffset;
+	private final int endOffset;
+	private final IStrategoTerm affectedTerm;
+	
+
+	/**
+	 * Fragment in the source code that represents a (possibly broken) construct
+	 * that can be discarded safely, e.g., without invalidating the parse input.
+	 */
+	public DiscardableRegion(int startOffset, int endOffset, IStrategoTerm affectedTerm){
+		this.startOffset = startOffset;
+		this.endOffset = endOffset;
+		this.affectedTerm = affectedTerm;
+		assert startOffset <= endOffset;
+	}
+
+	/**
+	 * Returns the start offset of the discardable code fragment
+	 * @return start offset
+	 */
+	public int getStartOffset() {
+		return startOffset;
+	}
+
+	/**
+	 * Returns the end offset of the discardable code fragment
+	 * @return end offset
+	 */
+	public int getEndOffset() {
+		return endOffset;
+	}
+
+	/**
+	 * Returns the term associated to the discardable code fragment.
+	 * Can be null in case the discarded region is a comment, or in case the abstract representation is not known.
+	 * @return term
+	 */
+	public IStrategoTerm getAffectedTerm() {
+		assert(!affectedTerm.isList()): "Individual list elements are prefered over full lists";
+		return affectedTerm;
+	}
+}

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,335 @@
+package org.spoofax.jsglr.client.editregion.detection;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import org.spoofax.jsglr.client.editregion.detection.LCS;
+import org.spoofax.jsglr.client.editregion.detection.LCSCommand;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.jsglr.client.imploder.ITokenizer;
+import org.spoofax.jsglr.client.imploder.ImploderAttachment;
+
+/**
+ * Detects possible erroneous code constructs and comments
+ * by comparing a possibly erroneous input string with a (similar) correctly parsed input string.
+ * The correctly parsed input string is typically a prior, non-erroneous snapshot of the program being edited.
+ * The discardable, erroneous code constructs can be used to construct a non-correcting recovery and to 
+ * locate parse errors prior to applying a correcting recovery technique.
+ * @author maartje
+ */
+public class EditRegionDetector {
+
+	private final LCS<Character> lcs;
+	private final String erroneousInput;
+	private final IStrategoTerm correctAST;
+	
+	//edit regions found after analyzing the correct AST/input and its deleted characters
+	private ArrayList<DiscardableRegion> discardableRegions;
+	private ArrayList<DiscardableRegion> discardableCommentRegions;
+
+
+//methods that access the correct parse input string
+
+	/**
+	 * Returns the input string of the correctly parsed AST
+	 * @return Correct input string used for comparison
+	 */
+	public String getCorrectInput(){
+		return ImploderAttachment.getTokenizer(correctAST).getInput();
+	}
+
+	/**
+	 * Returns the offsets of the characters that are deleted from the correct input (found by an LCS diff algorithm)
+	 * @return offsets of deleted characters
+	 */
+	public ArrayList<Integer> getDeletionOffsets(){
+		return lcs.getUnMatchedIndices1();		
+	}
+
+	/**
+	 * Returns the substrings that are deleted from the correct input
+	 * @return deleted substrings
+	 */
+	public ArrayList<String> getDeletedSubstrings(){
+		return constructSubstringsFromOffsets(getDeletionOffsets(), getCorrectInput());
+	}
+
+	/**
+	 * Returns the discarded regions of code that were edited, from the correct input 
+	 * @return discarded edit regions from the correct input
+	 */
+	public ArrayList<DiscardableRegion> getEditedRegionsCorrect(){
+		return mergeRegions(discardableRegions, discardableCommentRegions);
+	}
+	
+	/**
+	 * Returns the offsets of the chars that together form the discardable text fragments, from the correct input 
+	 * @return offsets of characters in discarded regions
+	 */
+	public ArrayList<Integer> getDiscardOffsetsCorrectInput() {
+		return getEditOffsets(getEditedRegionsCorrect());
+	}
+	
+	/**
+	 * Returns the (discardable) terms that were edited, from the correct input 
+	 * @return discarded terms
+	 */
+	public ArrayList<IStrategoTerm> getEditedTerms(){
+		ArrayList<IStrategoTerm> discardableTerms = new ArrayList<IStrategoTerm>();
+		for (DiscardableRegion region : getEditedRegionsCorrect()) {
+			if(!HelperFunctions.contains(discardableTerms, region.getAffectedTerm()))
+				discardableTerms.add(region.getAffectedTerm());
+		}
+		return discardableTerms;
+	}	
+
+
+//methods that access the erroneous parse input string
+
+	/**
+	 * Returns the (possible) erroneous input string 
+	 * @return Erroneous input
+	 */
+	public String getErroneousInput(){
+		return erroneousInput;
+	}
+
+	/**
+	 * Returns the offsets of the characters that are inserted in the erroneous input (found by an LCS diff algorithm)
+	 * @return offsets of inserted characters
+	 */
+	public ArrayList<Integer> getInsertionOffsets(){
+		return lcs.getUnMatchedIndices2();
+	}
+
+	/**
+	 * Returns the substrings that are inserted in the erroneous input
+	 * @return inserted substrings
+	 */
+	public ArrayList<String> getInsertedSubstrings(){
+		return constructSubstringsFromOffsets(getInsertionOffsets(), getErroneousInput());
+	}
+
+	/**
+	 * Returns the discardable regions of code that were edited in the erroneous input
+	 * These regions may contain syntax errors. 
+	 * @return edited regions from erroneous input
+	 */
+	public ArrayList<DiscardableRegion> getEditedRegionsErroneous(){
+		ArrayList<DiscardableRegion> editsFromDeletions = mapRegions(getEditedRegionsCorrect(), true);
+		ArrayList<DiscardableRegion> editsFromInsertions = this.constructRegionsFromOffsets(getInsertionOffsets(), getErroneousInput());
+		return mergeRegions(editsFromDeletions, editsFromInsertions);
+	}
+
+	/**
+	 * Returns the offsets of the chars that together form the edited text fragments, 
+	 * from the erroneous input 
+	 * @return offsets of edit regions from erroneous input
+	 */
+	public ArrayList<Integer> getDiscardOffsetsErroneousInput() {
+		return getEditOffsets(getEditedRegionsErroneous());
+	}
+
+// method for accessing the recovered input
+	
+	/**
+	 * Returns a (presumably) correct parse input based on the LCS of a correct and incorrect program.
+	 * The constructed parse input forms a (non-correcting) recovery of the erroneous input. 
+	 * The constructed parse input is obtained by replacing the characters in the erroneous regions by whitespaces.
+	 * @return recovered program
+	 */
+	public String getRecoveredInput(){
+		String recoveredProgram = replaceAllRegionByWhitespace(getEditedRegionsErroneous(), getErroneousInput());
+		//assert recoveredProgram.equals(replaceAllRegionByWhitespace(getEditedRegionsCorrect(), correctInput)); //modulo comments and layout
+		assert recoveredProgram.length() == getErroneousInput().length(): "whitespaces are inserted for characters in the edit regions";
+		return recoveredProgram;
+	}
+
+	
+	/**
+	 * Detects possible erroneous code constructs and comments
+	 * by comparing an input string with a very similar, correctly parsed, input string.
+	 * The correctly parsed input string is typically a prior (non-erroneous) snapshot of the program being edited.
+	 */	
+	public EditRegionDetector(IStrategoTerm correctAST, String erroneousInput){
+		this.correctAST = correctAST;
+		this.erroneousInput = erroneousInput;
+		lcs = new LCS<Character>(new LCSCommand<Character>() {
+			public boolean isMatch(Character c1, Character c2) {
+				return c1.charValue() == c2.charValue();
+			}});
+		detectEditRegions();
+	}
+	
+	private void detectEditRegions() {
+		ITokenizer tokens = ImploderAttachment.getTokenizer(correctAST);
+
+		// calculates offsets deleted characters (correct input), and offsets inserted characters (erroneous input)
+		constructCharacterMatching();
+		ArrayList<Integer> offsetsDeletedChars = lcs.getUnMatchedIndices1();
+
+		//removes from deletion offsets, all offsets of layout characters that are irrelevant for the parse result.
+		//detects all edited comment regions, since these may affect the parse result if they are broken.
+		LayoutEditsAnalyzer loAnalyzer = new LayoutEditsAnalyzer(tokens, lcs);
+		this.discardableCommentRegions = loAnalyzer.getDamagedCommentRegions();
+		loAnalyzer.filterNonLayoutOffsets(offsetsDeletedChars);
+		
+		//extends deletion offsets so that all possible damaged tokens are covered
+		TerminalEditsAnalyzer terminalAnalyzer = new TerminalEditsAnalyzer(tokens, lcs);
+		terminalAnalyzer.addDamagedTokensStartOffsets(offsetsDeletedChars);
+
+		//detects discardable regions that correspond to edited terms.
+		NonTerminalEditsAnalyzer brokenConstructDetector = new NonTerminalEditsAnalyzer(correctAST, offsetsDeletedChars);
+		this.discardableRegions = brokenConstructDetector.getDamagedTermRegions();
+	}
+	
+
+
+// helper functions
+	private void constructCharacterMatching() {
+		ArrayList<Character> correctChars = asCharacterList(getCorrectInput());
+		ArrayList<Character> erroneousChars = asCharacterList(getErroneousInput());
+		//long startTime = System.currentTimeMillis();
+		lcs.createLCSResultsOptimized(correctChars, erroneousChars);
+		//System.out.println("duration lcs: " + (System.currentTimeMillis() - startTime));
+	}
+	
+	
+	private static ArrayList<Character> asCharacterList(String correctInput) {
+		ArrayList<Character> correctChars = new ArrayList<Character>();
+		for (int i = 0; i < correctInput.length(); i++) {
+			correctChars.add(correctInput.charAt(i));
+		}
+		return correctChars;
+	}
+
+	private DiscardableRegion mapRegion(DiscardableRegion region, boolean isInCorrectInputString){
+		int startOffset = -1;
+		int endOffset = -1;
+		for (int offset = region.getStartOffset(); offset <= region.getEndOffset(); offset++) {
+			int correspondingOffset = lcs.getMatchIndex(offset, isInCorrectInputString);
+			if(correspondingOffset != -1){
+				if(startOffset == -1)
+					startOffset = correspondingOffset;
+				endOffset = correspondingOffset;
+			}
+		}
+		if(startOffset >= 0){
+			return new DiscardableRegion(startOffset, endOffset, null);
+		}
+		return null;
+	}
+
+	private ArrayList<DiscardableRegion> mapRegions(ArrayList<DiscardableRegion> regions, boolean isInCorrectInputString){
+		ArrayList<DiscardableRegion> result = new ArrayList<DiscardableRegion>();		
+		for (DiscardableRegion region : regions) {
+			DiscardableRegion mappedRegion = mapRegion(region, isInCorrectInputString);
+			if(mappedRegion != null)
+				result.add(mappedRegion);
+		}
+		return result;
+	}
+	
+	private ArrayList<DiscardableRegion> mergeRegions(ArrayList<DiscardableRegion> regions1, ArrayList<DiscardableRegion> regions2){
+		ArrayList<DiscardableRegion> merged = new ArrayList<DiscardableRegion>();
+		int index_r1 = 0;
+		int index_r2 = 0;
+		while (index_r1 < regions1.size() && index_r2 < regions2.size()) {
+			DiscardableRegion r1 = regions1.get(index_r1);			
+			DiscardableRegion r2 = regions2.get(index_r2);
+			if(r1.getEndOffset() < r2.getStartOffset()){
+				merged.add(r1);
+				index_r1 ++;
+			}
+			else if(r2.getEndOffset() < r1.getStartOffset()){
+				merged.add(r2);
+				index_r2 ++;
+			}
+			else {
+				int startOffset = Math.min(r1.getStartOffset(), r2.getStartOffset());
+				int endOffset = Math.max(r1.getEndOffset(), r2.getEndOffset());
+				DiscardableRegion mergedRegion = new DiscardableRegion(startOffset, endOffset, null);
+				merged.add(mergedRegion);
+				index_r1++;
+				index_r2++;
+			}
+		}
+		while (index_r1 < regions1.size()) {
+			DiscardableRegion r1 = regions1.get(index_r1);
+			merged.add(r1);
+			index_r1 ++;
+		}
+		while (index_r2 < regions2.size()) {
+			DiscardableRegion r2 = regions2.get(index_r2);
+			merged.add(r2);
+			index_r2++;
+		}
+		return merged;
+	}
+
+	private ArrayList<DiscardableRegion> constructRegionsFromOffsets(ArrayList<Integer> offsets, String inputString){
+		ArrayList<DiscardableRegion> result = new ArrayList<DiscardableRegion>();
+		int startOffset = -1;
+		for (int i = 0; i < offsets.size(); i++) {
+			int offset = offsets.get(i);
+			if(i==0){
+				startOffset = offsets.get(i);
+			}
+			else if (offset != offsets.get(i-1) + 1){
+				DiscardableRegion region = new DiscardableRegion(startOffset, offsets.get(i-1), null);
+				result.add(region);
+				startOffset = offsets.get(i);
+			}
+		}
+		if(startOffset != -1){
+			DiscardableRegion region = new DiscardableRegion(startOffset, offsets.get(offsets.size()-1), null);
+			result.add(region);
+		}
+		return result;		
+	}
+
+	private ArrayList<String> constructSubstringsFromOffsets(ArrayList<Integer> offsets, String inputString){
+		ArrayList<DiscardableRegion> regions = constructRegionsFromOffsets(offsets, inputString);
+		ArrayList<String> result = new ArrayList<String>();
+		for (DiscardableRegion region : regions) {
+			String fragment = inputString.substring(region.getStartOffset(), region.getEndOffset() + 1);
+			result.add(fragment);
+		}
+		return result;
+	}
+	
+	private String replaceRegionByWhitespace(DiscardableRegion region, String input) {
+		char[] chars = input.toCharArray();
+		for (int offset = region.getStartOffset(); offset <= region.getEndOffset(); offset++) {
+			char charAtOffset = chars[offset];
+			if(!Character.isWhitespace(charAtOffset)){
+				chars[offset] = ' ';
+			}
+		}
+		return String.valueOf(chars);
+	}
+
+	private String replaceAllRegionByWhitespace(ArrayList<DiscardableRegion> regions, String input) {
+		String result = input;
+		for (DiscardableRegion region : regions) {
+			result = replaceRegionByWhitespace(region, result);
+		}
+		return result;
+	}
+		
+	private ArrayList<Integer> getEditOffsets(ArrayList<DiscardableRegion> editRegions) {
+		ArrayList<Integer> result = new ArrayList<Integer>();
+		for (DiscardableRegion region : editRegions) {
+			int startOffset = region.getStartOffset();
+			int endOffset = region.getEndOffset();
+			for (int offset = startOffset; offset <= endOffset; offset++) {
+				// "regions can overlap, for example: term + separation and comment in separation";
+				if(!result.contains(offset))
+					result.add(offset);
+			}
+		}
+		Collections.sort(result);
+		return result;
+	}
+
+	
+}

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/HelperFunctions.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/HelperFunctions.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,27 @@
+package org.spoofax.jsglr.client.editregion.detection;
+
+import java.util.List;
+
+/**
+ * Helper functions
+ * @author maartje
+ */
+public class HelperFunctions {
+	
+	/**
+	 * Returns true if this collection contains the specified element. 
+	 * More formally, returns true if and only if this collection contains at least one element e 
+	 * such that (o==null ? e==null : elem == e).
+	 * @param lst List
+	 * @param elem Element
+	 * @return true iff for some element E in List, E == elem 
+	 */
+	public static <T> boolean contains(List<T> lst, T elem) {
+		for (T lstElem : lst) {
+			if(lstElem == elem){
+				return true;
+			}
+		}
+		return false;
+	}
+}

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/LCS.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/LCS.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,373 @@
+package org.spoofax.jsglr.client.editregion.detection;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Implements a Longest Common Subsequence algorithm
+ * @author maartje
+ *
+ * @param <T>
+ */
+public class LCS<T> {
+	
+	private final LCSCommand<T> lcsCommand;
+	private List<T> elems1;
+	private List<T> elems2;
+	private ArrayList<Integer> matchedIndices1;
+	private ArrayList<Integer> matchedIndices2;
+
+	/**
+	 * Returns the elements of the first input list
+	 * @return 
+	 */
+	public ArrayList<T> getElems1() {
+		ArrayList<T> result = new ArrayList<T>();
+		result.addAll(elems1);
+		return result;
+	}
+
+	/**
+	 * Returns the elements of the second input list
+	 * @return
+	 */
+	public ArrayList<T> getElems2() {
+		ArrayList<T> result = new ArrayList<T>();
+		result.addAll(elems2);
+		return result;
+	}
+	
+	/**
+	 * Returns the index of the corresponding element in input2 (isInCorrectInputString == true), or input1 (isInCorrectInputString == false).
+	 * Returns -1 in case the element is not matched.
+	 * @param index of element
+	 * @param isInCorrectInputString
+	 * @return
+	 */
+	public int getMatchIndex(int index, boolean isInCorrectInputString) {
+		if(isInCorrectInputString){
+			return getMatchIndexInElems2(index);
+		}
+		return getMatchIndexInElems1(index);
+	}
+
+	/**
+	 * Returns the index of the corresponding element in elems2 for the element at elems1[indexElems1].
+	 * Returns -1 in case the element is not matched.
+	 * @param indexElems1 index of element in input1
+	 * @return
+	 */
+	public int getMatchIndexInElems2(int indexElems1){
+		int lcsIndex = matchedIndices1.indexOf(indexElems1);
+		if(lcsIndex >= 0){
+			return matchedIndices2.get(lcsIndex);
+		}
+		return -1;
+	}
+
+	/**
+	 * Returns the index of the corresponding element in elems1 for the element at elems2[indexElems2].
+	 * Returns -1 in case the element is not matched.
+	 * @param indexElems2 index of element in input2
+	 * @return
+	 */
+	public int getMatchIndexInElems1(int indexElems2){
+		int lcsIndex = matchedIndices2.indexOf(indexElems2);
+		if(lcsIndex > 0){
+			return matchedIndices1.get(lcsIndex);
+		}
+		return -1;
+	}
+
+	/**
+	 * Returns the indexes of the matched elements in input1
+	 * @return
+	 */
+	public ArrayList<Integer> getMatchedIndices1() {
+		return matchedIndices1;
+	}
+
+	/**
+	 * Returns the indexes of the matched elements in input2
+	 * @return
+	 */
+	public ArrayList<Integer> getMatchedIndices2() {
+		return matchedIndices2;
+	}
+
+	/**
+	 * Returns the indexes of the unmatched elements in input1
+	 * @return
+	 */
+	public ArrayList<Integer> getUnMatchedIndices1() {
+		return getUnmatchedIndices(elems1, matchedIndices1);
+	}
+
+	/**
+	 * Returns the indexes of the unmatched elements in input2
+	 * @return
+	 */
+	public ArrayList<Integer> getUnMatchedIndices2() {
+		return getUnmatchedIndices(elems2, matchedIndices2);
+	}
+
+	/**
+	 * LCS result for input 1
+	 * (empty before algorithm is applied)
+	 * @return LCS elements for input 1
+	 */
+	public ArrayList<T> getResultLCS1() {
+		return getIncludedElems(elems1, matchedIndices1);
+	}
+
+	/**
+	 * LCS result for input 2
+	 * (empty before algorithm is applied)
+	 * @return LCS elements for input 2
+	 */
+	public ArrayList<T> getResultLCS2() {
+		return getIncludedElems(elems2, matchedIndices2);
+	}
+
+	/**
+	 * Elements of input 1 that are not part of the LCS
+	 * (empty before algorithm is applied)
+	 * @return non-LCS elements for input 1
+	 */
+	public ArrayList<T> getResultUnmatched1() {
+		return getIncludedElems(elems1, getUnMatchedIndices1());
+	}
+
+	/**
+	 * Elements of input 2 that are not part of the LCS
+	 * (empty before algorithm is applied)
+	 * @return non-LCS elements for input 2
+	 */
+	public ArrayList<T> getResultUnmatched2() {
+		return getIncludedElems(elems2, getUnMatchedIndices2());
+	}
+	
+	/**
+	 * Size of the LCS
+	 * @return Size of the LCS
+	 */
+	public int getLCSSize(){
+		return matchedIndices1.size();
+	}
+
+	/**
+	 * Finds the Longest Common Subsequence of two lists with elements
+	 * @param lcsCommand Implements the matching criterion
+	 */
+	public LCS(LCSCommand<T> lcsCommand){
+		elems1 = new ArrayList<T>();
+		elems2 = new ArrayList<T>();
+		matchedIndices1 = new ArrayList<Integer>();
+		matchedIndices2 = new ArrayList<Integer>();
+		this.lcsCommand = lcsCommand;
+	}
+			
+	/**
+	 * Fills the LCS results: LCS (longest common subsequence), unmatched elems1, unmatched elems2.
+	 * As an optimization, the algorithm starts with matching elements at the prefix and suffix.
+	 * @param elems1
+	 * @param elems2
+	 */
+	public LCS<T> createLCSResultsOptimized(List<T> elems1, List<T> elems2) {
+		clearResults();
+		this.elems1 = elems1;
+		this.elems2 = elems2;
+		return createLCSResultsOptimized();
+	}
+	
+	/**
+	 * Fills the LCS results: LCS (longest common subsequence), unmatched elems1, unmatched elems2.
+	 * @param elems1
+	 * @param elems2
+	 */
+	public LCS<T> createLCSResults(List<T> elems1, List<T> elems2) {
+		clearResults();
+		this.elems1 = elems1;
+		this.elems2 = elems2;
+		lcs(elems1, elems2, 0);
+		checkAssertions(elems1, elems2);
+		return this;
+	}
+
+	
+// helper functions
+
+	private void clearResults(){
+		matchedIndices1.clear();
+		matchedIndices2.clear();
+	}
+
+	private ArrayList<Integer> getUnmatchedIndices(List<T> elems, ArrayList<Integer> indices) {
+		assert elems.size() >= indices.size();
+		ArrayList<Integer> unmatchedIndices = new ArrayList<Integer>();
+		int indexIndices = 0;
+		int nextIncludedIndex = -1;
+		if(indexIndices < indices.size())
+			nextIncludedIndex = indices.get(indexIndices).intValue();
+		for (int elems_index = 0; elems_index < elems.size(); elems_index++) {
+			if(elems_index == nextIncludedIndex){				
+				//set next included index
+				indexIndices += 1;
+				nextIncludedIndex = -1;
+				if(indexIndices < indices.size())
+					nextIncludedIndex = indices.get(indexIndices).intValue();
+			}
+			else{
+				//no match at elems_index!
+				unmatchedIndices.add(elems_index);
+			}
+		}
+		assert unmatchedIndices.size() + indices.size() == elems.size();
+		return unmatchedIndices;
+	}
+
+	private ArrayList<T> getIncludedElems(List<T> elems, ArrayList<Integer> indices) {
+		assert elems.size() >= indices.size();
+		ArrayList<T> includedElems = new ArrayList<T>();
+		int indexIndices = 0;
+		int nextIncludedIndex = -1;
+		if(indexIndices < indices.size())
+			nextIncludedIndex = indices.get(indexIndices).intValue();
+		for (int elems_index = 0; elems_index < elems.size(); elems_index++) {
+			if(elems_index == nextIncludedIndex){
+				//matched at elems_index!
+				includedElems.add(elems.get(elems_index));
+				
+				//set next included index
+				indexIndices += 1;
+				nextIncludedIndex = -1;
+				if(indexIndices < indices.size())
+					nextIncludedIndex = indices.get(indexIndices).intValue();
+			}
+		}
+		assert includedElems.size() == indices.size();
+		return includedElems;
+	}
+	
+	private LCS<T> createLCSResultsOptimized() {
+		int commonPrefixLength = commonPrefixLength();
+		int commonSuffixLength = commonSuffixLength(commonPrefixLength);
+		addPrefixIndices(commonPrefixLength);
+		addMidIndices(commonPrefixLength, commonSuffixLength);
+		addSuffixIndices(commonSuffixLength);		
+		checkAssertions(elems1, elems2);
+		return this;
+	}
+
+	private void addMidIndices(int commonPrefixLength, int commonSuffixLength) {
+		List<T> elems1_mid = elems1.subList(commonPrefixLength, elems1.size() - commonSuffixLength);
+		List<T> elems2_mid = elems2.subList(commonPrefixLength, elems2.size() - commonSuffixLength);
+		lcs(
+			elems1_mid, 
+			elems2_mid,
+			commonPrefixLength
+		);
+	}
+
+	private void addSuffixIndices(int commonSuffixLength) {
+		for (int suffixIndex = commonSuffixLength - 1; suffixIndex >= 0 ; suffixIndex--) {
+			int el1_index = elems1.size() - 1 - suffixIndex;
+			int el2_index = elems2.size() - 1 - suffixIndex;
+			assert lcsCommand.isMatch(elems1.get(el1_index), elems2.get(el2_index)): "elements should match since they are in the common suffix"; 
+			matchedIndices1.add(el1_index); 
+			matchedIndices2.add(el2_index);			
+		}
+	}
+
+	private void addPrefixIndices(int commonPrefixLength) {
+		for (int prefixIndex = 0; prefixIndex < commonPrefixLength; prefixIndex++) {
+			assert lcsCommand.isMatch(elems1.get(prefixIndex), elems2.get(prefixIndex)): "elements should match since they are in the common prefix"; 
+			matchedIndices1.add(prefixIndex);
+			matchedIndices2.add(prefixIndex);			
+		}
+	}
+
+	private int commonPrefixLength() {
+		int minLength = Math.min(elems1.size(), elems2.size()); 
+		int commonPrefixLength = 0;
+		while (commonPrefixLength < minLength) {
+			T el1 = elems1.get(commonPrefixLength);
+			T el2 = elems2.get(commonPrefixLength);
+			if(lcsCommand.isMatch(el1, el2)){
+				commonPrefixLength++;
+			}
+			else
+				break;
+		}
+		return commonPrefixLength;
+	}
+
+	private int commonSuffixLength(int commonPrefixLength) {
+		int minLength = Math.min(elems1.size(), elems2.size()); 
+		int commonSuffixLength = 0;
+		while (commonSuffixLength < minLength - commonPrefixLength) {
+			int el1_index = elems1.size() - commonSuffixLength -1;
+			int el2_index = elems2.size() - commonSuffixLength - 1;
+			T el1 = elems1.get(el1_index);
+			T el2 = elems2.get(el2_index);
+			if(lcsCommand.isMatch(el1, el2)){
+				commonSuffixLength++;
+			}
+			else
+				break;
+		}
+		return commonSuffixLength;
+	}
+
+	private void lcs(List<T> elems1, List<T> elems2, int startIndex) {
+		int lengthElems1 = elems1.size();
+        int lengthElems2 = elems2.size();
+
+        // opt[i][j] = length of LCS of x[i..M] and y[j..N]
+        int[][] opt = new int[lengthElems1+1][lengthElems2+1];
+
+        // compute length of LCS and all subproblems via dynamic programming
+        for (int i = lengthElems1-1; i >= 0; i--) {
+            for (int j = lengthElems2-1; j >= 0; j--) {
+                if (lcsCommand.isMatch(elems1.get(i), elems2.get(j)))
+                    opt[i][j] = opt[i+1][j+1] + 1;
+                else 
+                    opt[i][j] = Math.max(opt[i+1][j], opt[i][j+1]);
+            }
+        }
+
+        // recover LCS itself
+        int i = 0, j = 0;
+		while(i < lengthElems1 && j < lengthElems2) {
+	        T el1 = elems1.get(i);
+			T el2 = elems2.get(j);
+            if (lcsCommand.isMatch(el1, el2)) {
+				matchedIndices1.add(i + startIndex);
+				matchedIndices2.add(j + startIndex);
+                i++;
+                j++;
+            }
+            else if (opt[i+1][j] >= opt[i][j+1]){
+            	i++;
+            }
+            else { 
+            	j++;
+            }
+        }
+	}
+
+	private void checkAssertions(List<T> elems1, List<T> elems2) {
+		assert matchedIndices1.size() == matchedIndices2.size();
+		assert matchedIndices1.size() <= elems1.size();
+		assert matchedIndices2.size() <=  elems2.size();
+		for (int i = 0; i < matchedIndices1.size(); i++) {
+			T el1 = elems1.get(matchedIndices1.get(i).intValue());
+			T el2 = elems2.get(matchedIndices2.get(i).intValue());
+			assert lcsCommand.isMatch(el1, el2);
+		}
+		for (int i = 1; i < matchedIndices1.size(); i++) {
+			assert matchedIndices1.get(i).intValue() > matchedIndices1.get(i-1).intValue();
+			assert matchedIndices2.get(i).intValue() > matchedIndices2.get(i-1).intValue();
+		}
+	}
+}

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/LCSCommand.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/LCSCommand.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,19 @@
+package org.spoofax.jsglr.client.editregion.detection;
+
+/**
+ * Implements the matching criteron applied by the LCS algorithm
+ * @author maartje
+ *
+ * @param <T>
+ */
+public interface LCSCommand<T> {
+	/**
+	 * Returns true in case t1 and t2 can be matched.
+	 * This function implements the criteria for matching in a Longest Common Subsequence procedure. 
+	 * @param t1 element in input list 1
+	 * @param t2 element in input list 2
+	 * @return True in case t1 and t2 can be matched
+	 */
+	abstract boolean isMatch(T t1, T t2);
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/LayoutEditsAnalyzer.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/LayoutEditsAnalyzer.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,76 @@
+package org.spoofax.jsglr.client.editregion.detection;
+
+import java.util.ArrayList;
+
+import org.spoofax.jsglr.client.editregion.detection.LCS;
+import org.spoofax.jsglr.client.imploder.IToken;
+import org.spoofax.jsglr.client.imploder.ITokenizer;
+import org.spoofax.jsglr.client.imploder.Token;
+import org.spoofax.jsglr.client.editregion.detection.DiscardableRegion;
+
+/**
+ * Determines the comment regions that are edited and therefore (possible) damaged.
+ * Filters the offsets of the deleted characters, removing comment and whitespace offsets 
+ * that are either irrelevant (not affecting the parse result) or allready processed (block comment damage)
+ * Example damaged comment: '/* comment * /'
+ * Example harmful layout deletion: 'int  i' => 'inti' 
+ * @author Maartje de Jonge
+ *
+ */
+public class LayoutEditsAnalyzer {
+		
+	private final DamagedTokenAnalyzer tokenEdits;
+
+	//filled in the analysis
+	private final ArrayList<DiscardableRegion> damagedCommentRegions;
+	private final ArrayList<Integer> offsetsDeletedLayoutChars;
+	
+	/**
+	 * Returns the comment regions that are edited and therefore (possible) damaged.
+	 */
+	public ArrayList<DiscardableRegion> getDamagedCommentRegions() {
+		return damagedCommentRegions;
+	}
+
+	/**
+	 * Filters the list of deletion-offsets,
+	 * removing all layout-deletion-offsets that are in fact harmless, e.g. do not affect the parse result.
+	 */
+	public void filterNonLayoutOffsets(ArrayList<Integer> deletedOffsets) {
+		deletedOffsets.removeAll(offsetsDeletedLayoutChars);
+	}
+	
+	/**
+	 * Determines the comment regions that are edited and therefore (possible) damaged.
+	 * Filters the offsets of the deleted characters, removing comment and whitespace offsets 
+	 * that are either irrelevant (not affecting the parse result) or allready processed (block comment damage)
+	 */
+	public LayoutEditsAnalyzer(ITokenizer tokens, LCS<Character> lcs){
+		this.offsetsDeletedLayoutChars = new ArrayList<Integer>();
+		this.damagedCommentRegions = new ArrayList<DiscardableRegion>();
+		tokenEdits = new DamagedTokenAnalyzer(tokens, lcs);
+		analyze();
+	}
+	
+	private void analyze() {
+		for (IToken tokenWithDeletions : tokenEdits.getTokensDamagedByDeletion()) {
+			if(tokenWithDeletions.getKind() == Token.TK_LAYOUT){
+				if(!tokenEdits.isDamagingLayoutDeletion(tokenWithDeletions)){
+					this.offsetsDeletedLayoutChars.addAll(tokenEdits.getOffsetsDeletions(tokenWithDeletions));						
+				}
+				if(!Token.isWhiteSpace(tokenWithDeletions)){
+					DiscardableRegion commentRegion = new DiscardableRegion(tokenWithDeletions.getStartOffset(), tokenWithDeletions.getEndOffset(), null);
+					damagedCommentRegions.add(commentRegion);
+					assert !HelperFunctions.contains(damagedCommentRegions, commentRegion);
+				}
+			}
+		}
+		for (IToken tokenWithInsertions : tokenEdits.getTokensDamagedByInsertion()) {
+			if(tokenWithInsertions.getKind() == Token.TK_LAYOUT && !Token.isWhiteSpace(tokenWithInsertions)){
+				DiscardableRegion commentRegion = new DiscardableRegion(tokenWithInsertions.getStartOffset(), tokenWithInsertions.getEndOffset(), null);
+				if(!HelperFunctions.contains(damagedCommentRegions, commentRegion))
+					damagedCommentRegions.add(commentRegion);
+			}
+		}
+	}
+}

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/NonTerminalEditsAnalyzer.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/NonTerminalEditsAnalyzer.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,258 @@
+package org.spoofax.jsglr.client.editregion.detection;
+
+import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getLeftToken;
+import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getRightToken;
+
+import java.util.ArrayList;
+
+import org.spoofax.interpreter.terms.IStrategoAppl;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.jsglr.client.imploder.ImploderAttachment;
+
+/**
+ * Detects edited code constructs in a (correctly parsed) AST,
+ * by analyzing the offsets of the deleted characters.
+ * The edited constructs are returned as damaged regions, e.g.
+ * fragments in the source code that represent constructs
+ * that can be discarded safely, e.g., without invalidating the parse input.
+ * @author maartje
+ *
+ */
+public class NonTerminalEditsAnalyzer {
+		
+	private final IStrategoTerm term;
+	private final ArrayList<Integer> offsetsDeletedChars;
+	
+	/**
+	 * Detects edited (discardable) code constructs in a (correctly parsed) AST,
+	 * by analyzing the offsets of the deleted characters.
+	 */
+	public NonTerminalEditsAnalyzer(IStrategoTerm term, ArrayList<Integer> offsetsDeletedChars){
+		this.term = term;
+		this.offsetsDeletedChars = offsetsDeletedChars;
+	}
+
+
+	/**
+	 * Returns discardable regions that are edited 
+	 */
+	public ArrayList<DiscardableRegion> getDamagedTermRegions(){
+		return getAffectedDiscardableRegions(term, null, null, false);
+	}
+
+	//TODO: what if incomplete?
+	//TODO: may be better to return incomplete elems that are resonable small than one big area	
+	private ArrayList<DiscardableRegion> getAffectedDiscardableRegions(
+			IStrategoTerm trm, 
+			IStrategoTerm prevSibTrm, 
+			IStrategoTerm nextSibTrm, 
+			boolean hasListParent) {
+		DiscardableRegion regionOfTerm = getRegionOfTerm(trm, nextSibTrm, hasListParent);
+		ImploderAttachment.getElementSort(trm);
+		ImploderAttachment.getSort(trm);
+		if(offsetsOutsideFragment(offsetsDeletedChars, regionOfTerm) ){
+			return new ArrayList<DiscardableRegion>(); //no need to traverse subterms 
+		}		
+		ArrayList<DiscardableRegion> candidatesFromSubterms = getCandidateRegionsFromSubterms(trm, offsetsDeletedChars);
+		ArrayList<Integer> uncoveredOffsets = getUncoveredOffsets(offsetsDeletedChars, candidatesFromSubterms);
+		ArrayList<Integer> offsetsCoveredByTerm = getCoveredOffsets(uncoveredOffsets, regionOfTerm);
+		/*parent overwrites child results because it covers more deletions*/
+		/*example: while(c){int i; int j;} whereby 'j' and '}' are deleted*/
+		if(!offsetsCoveredByTerm.isEmpty()){ //term associated to some deleted (unmatched) characters 
+			assert (nextSibTrm != null): "last list element should be correct after removal procedure";
+			if(hasListParent){
+				String sort = ImploderAttachment.getElementSort(trm);
+				ArrayList<IStrategoTerm> replacementCandidates = getUnaffectedSubtermsOfSameSort(trm, sort, offsetsDeletedChars); 
+				return splitRegion(regionOfTerm, replacementCandidates); //example: erroneous while statement, keep all non-erroneous sub statements  
+				
+				//TODO: separators??
+//				ArrayList<DiscardableRegion> result = new ArrayList<DiscardableRegion>();
+//				result.add(regionOfTerm);
+//				return result; 				
+			}
+			else if(isSomeNode(trm)){
+				ArrayList<DiscardableRegion> result = new ArrayList<DiscardableRegion>();
+				result.add(regionOfTerm);
+				return result;				
+			}
+			else {
+				String sort = ImploderAttachment.getElementSort(trm);
+				ArrayList<IStrategoTerm> replacementCandidates = getUnaffectedSubtermsOfSameSort(trm, sort, offsetsDeletedChars); 
+				IStrategoTerm replacement = getTermWithLargestFragment(replacementCandidates);
+				if(replacement != null){
+					ArrayList<IStrategoTerm> subTerms = new ArrayList<IStrategoTerm>();
+					subTerms.add(replacement);
+					return splitRegion(regionOfTerm, subTerms);
+				}
+			}
+		}
+		return candidatesFromSubterms;
+	}
+	
+	private ArrayList<DiscardableRegion> getCandidateRegionsFromSubterms(IStrategoTerm trm, ArrayList<Integer> offsetsDeletedChars) {
+		//to deal with separators: first remove damaged elements at suffix including their separation
+		int indexLastAffectedSubterm = getLastEffectedListElementIndex(trm, offsetsDeletedChars);		
+		ArrayList<DiscardableRegion> candidatesFromSubterms = new ArrayList<DiscardableRegion>();
+		for (int i = 0; i < indexLastAffectedSubterm; i++) {
+			IStrategoTerm nextSib = null;
+			IStrategoTerm prevSib = null;
+			if(i > 0){
+				prevSib = trm.getSubterm(i-1);
+			}
+			if(i < indexLastAffectedSubterm - 1){
+				nextSib = trm.getSubterm(i+1);
+			}
+			ArrayList<DiscardableRegion> candidates_subtrm_i = 
+					getAffectedDiscardableRegions(trm.getSubterm(i), prevSib, nextSib, trm.isList()); 
+			candidatesFromSubterms.addAll(candidates_subtrm_i);
+		}
+		for (int i = indexLastAffectedSubterm; i < trm.getSubtermCount(); i++) {
+			IStrategoTerm subterm = trm.getSubterm(indexLastAffectedSubterm);
+			IStrategoTerm subterm_prev = trm.getSubterm(indexLastAffectedSubterm-1);
+			int endOffset = getEndOffset(subterm);
+			int startOffset = getRightToken(subterm_prev).getEndOffset() + 1;
+			candidatesFromSubterms.add(new DiscardableRegion(startOffset, endOffset, subterm));			
+		}
+		return candidatesFromSubterms;
+	}
+
+	private int getLastEffectedListElementIndex(IStrategoTerm trm, ArrayList<Integer> offsetsDeletedChars) {
+		int indexLastAffectedSubterm = trm.getSubtermCount();
+		while (trm.isList() && indexLastAffectedSubterm > 1) {
+			IStrategoTerm subterm = trm.getSubterm(indexLastAffectedSubterm-1);
+			ArrayList<DiscardableRegion> subterm_candidates = 
+				getAffectedDiscardableRegions(subterm, null, null, true); 
+			if(subterm_candidates.size() == 1 && subterm_candidates.get(0).getAffectedTerm() == subterm){
+				indexLastAffectedSubterm -= 1;
+			}
+			else
+				break;
+		}
+		return indexLastAffectedSubterm;
+	}
+
+	
+	private ArrayList<IStrategoTerm> getUnaffectedSubtermsOfSameSort(IStrategoTerm trm, String sort, ArrayList<Integer> offsetsDeletedChars) {
+		ArrayList<IStrategoTerm> candidateSubterms = new ArrayList<IStrategoTerm>();
+		if(sort == null)
+			return null;
+		for (int i = 0; i < trm.getSubtermCount(); i++) {
+			IStrategoTerm subterm = trm.getSubterm(i);
+			String subtermSort = ImploderAttachment.getSort(subterm);
+			ArrayList<Integer> offsetsCoveredByTerm = getCoveredOffsets(offsetsDeletedChars, new DiscardableRegion(getStartOffset(subterm), getEndOffset(subterm), subterm));
+			if(sort == subtermSort && offsetsCoveredByTerm.isEmpty()){
+				candidateSubterms.add(subterm);
+			}
+			else{
+				ArrayList<IStrategoTerm> candidates = getUnaffectedSubtermsOfSameSort(subterm, sort, offsetsDeletedChars);
+				candidateSubterms.addAll(candidates);
+			}
+		}
+		return candidateSubterms;
+	}
+
+	private IStrategoTerm getTermWithLargestFragment(ArrayList<IStrategoTerm> terms) {
+		IStrategoTerm bestCandidate = null;
+		int bestSize = -1;
+		for (int i = 0; i < terms.size(); i++) {
+			IStrategoTerm alternativeCandidate = terms.get(i);
+			int startOffset = getLeftToken(alternativeCandidate).getStartOffset();
+			int endOffset = getEndOffset(alternativeCandidate);
+			int size = endOffset - startOffset;
+			if(size > bestSize){
+				bestCandidate = alternativeCandidate;
+				bestSize = size;
+			}
+		}
+		return bestCandidate;
+	}
+
+	private DiscardableRegion getRegionOfTerm(IStrategoTerm trm, IStrategoTerm nextSibTrm, boolean hasListParent) {
+		int startOffset = getLeftToken(trm).getStartOffset();
+		int endOffset; 
+		if(hasListParent && nextSibTrm != null)
+			endOffset = getLeftToken(nextSibTrm).getStartOffset() - 1;
+		else
+			endOffset = getRightToken(trm).getEndOffset();
+		DiscardableRegion regionOfTerm = new DiscardableRegion(startOffset, endOffset, trm);
+		return regionOfTerm;
+	}
+
+	private boolean isSomeNode(IStrategoTerm trm) {
+		if(trm.getTermType() == IStrategoTerm.APPL){
+			return trm.getSubtermCount() == 1 && ((IStrategoAppl)trm).getConstructor().getName().equals("Some");
+		}
+		return false;
+	}
+
+	private boolean offsetsOutsideFragment(ArrayList<Integer> offsets, DiscardableRegion region) {
+		int startOffset = region.getStartOffset();
+		int endOffset = region.getEndOffset();
+		return offsets.isEmpty() || endOffset < offsets.get(0) || startOffset > offsets.get(offsets.size()-1);
+	}
+
+	private ArrayList<DiscardableRegion> splitRegion(DiscardableRegion regionOfTerm, ArrayList<IStrategoTerm> subTerms) {
+		ArrayList<DiscardableRegion> result = new ArrayList<DiscardableRegion>();
+		int regionStartOffset = regionOfTerm.getStartOffset();
+		for (int i = 0; i < subTerms.size(); i++) {
+			IStrategoTerm subTerm = subTerms.get(i);
+			assert subTerm != null;
+			if(regionStartOffset < getStartOffset(subTerm)){
+				DiscardableRegion discard = new DiscardableRegion(regionStartOffset, getStartOffset(subTerm) - 1, regionOfTerm.getAffectedTerm());
+				result.add(discard);
+			}
+			regionStartOffset = getEndOffset(subTerm) + 1;
+		}
+		if(regionStartOffset <= regionOfTerm.getEndOffset()){
+			DiscardableRegion discard = new DiscardableRegion(regionStartOffset, regionOfTerm.getEndOffset(), regionOfTerm.getAffectedTerm());
+			result.add(discard);
+		}
+		return result;
+	}
+
+
+	private ArrayList<Integer> getCoveredOffsets(ArrayList<Integer> offsets, DiscardableRegion region) {
+		ArrayList<Integer> coveredOffsets = new ArrayList<Integer>();
+		int startOffset = region.getStartOffset();
+		int endOffset = region.getEndOffset();
+		for (int i = 0; i < offsets.size(); i++) {
+			int offset = offsets.get(i); 
+			if(startOffset <= offset && offset <= endOffset){
+				//covered
+				coveredOffsets.add(offset);
+			}
+		}
+		return coveredOffsets;
+	}
+
+	private ArrayList<Integer> getUncoveredOffsets(ArrayList<Integer> offsetsDeletedChars, ArrayList<DiscardableRegion> candidatesFromSubterms) {
+		ArrayList<Integer> uncoveredIndices = new ArrayList<Integer>();
+		for (int i = 0; i < offsetsDeletedChars.size(); i++) {
+			int deletedIndex = offsetsDeletedChars.get(i);
+			boolean isCovered = false;
+			for (DiscardableRegion candidate : candidatesFromSubterms) {
+				if(candidate.getStartOffset() <= deletedIndex && deletedIndex <= candidate.getEndOffset()){
+					isCovered = true;
+					break;
+				}
+			}
+			if(!isCovered){
+				uncoveredIndices.add(deletedIndex);
+			}
+		}
+		return uncoveredIndices;
+	}
+
+	private int getEndOffset(IStrategoTerm trm) {
+		int endOffset = getRightToken(trm).getEndOffset();
+		return endOffset;
+	}
+	
+	private int getStartOffset(IStrategoTerm trm) {
+		int startOffset = getLeftToken(trm).getStartOffset();
+		return startOffset;
+	}
+
+
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TerminalEditsAnalyzer.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TerminalEditsAnalyzer.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,53 @@
+package org.spoofax.jsglr.client.editregion.detection;
+
+import java.util.ArrayList;
+import java.util.Collections;
+
+import org.spoofax.jsglr.client.editregion.detection.LCS;
+import org.spoofax.jsglr.client.imploder.IToken;
+import org.spoofax.jsglr.client.imploder.ITokenizer;
+import org.spoofax.jsglr.client.imploder.Token;
+
+/**
+ * Adds to the deletion offsets the (start)offset of non-layout tokens that are damaged by an insertion only 
+ * (and therefore not already covered by the deletion offsets).
+ * The reason is that a "parse-as-whitespace" recovery may not repair the problem.
+ * Example damaged token: 'priva at te'
+ * @author Maartje de Jonge
+ */
+public class TerminalEditsAnalyzer {
+		
+	private final DamagedTokenAnalyzer tokenEdits;
+
+	//filled in the analysis
+	private final ArrayList<Integer> startOffsetsTokensDamagedByInsertions;
+	
+	/**
+	 * Extends the list of deletion-offsets,
+	 * adding all start offsets of damaged tokens that were not yet covered (e.g. only affected by insertion)
+	 */
+	public void addDamagedTokensStartOffsets(ArrayList<Integer> deletedOffsets) {
+		deletedOffsets.addAll(startOffsetsTokensDamagedByInsertions);
+		Collections.sort(deletedOffsets);
+	}
+	
+	/**
+	 * Adds to the deletion offsets the (start)offset of non-layout tokens that are damaged by an insertion only 
+	 * (and therefore not already covered by the deletion offsets).
+	 * The reason is that a "parse-as-whitespace" recovery may not repair the problem.
+	 * Example damaged token: 'priva at te'
+	 */
+	public TerminalEditsAnalyzer(ITokenizer tokens, LCS<Character> lcs){
+		this.startOffsetsTokensDamagedByInsertions = new ArrayList<Integer>();
+		tokenEdits = new DamagedTokenAnalyzer(tokens, lcs);
+		analyze();
+	}
+	
+	private void analyze() {
+		for (IToken tokenWithInsertions : tokenEdits.getTokensDamagedByInsertion()) {
+			if(tokenWithInsertions.getKind() != Token.TK_LAYOUT && !tokenEdits.isDamagedByDeletion(tokenWithInsertions)){ //non layout, insertions only, damaged token
+				this.startOffsetsTokensDamagedByInsertions.add(tokenWithInsertions.getStartOffset());
+			}
+		}
+	}
+}

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/AbstractTestRegionDetection.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/AbstractTestRegionDetection.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,101 @@
+package org.spoofax.jsglr.client.editregion.test;
+
+import java.io.BufferedReader;
+import java.io.FileNotFoundException;
+import java.io.FileReader;
+import java.io.IOException;
+import java.util.ArrayList;
+
+import junit.framework.Assert;
+
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParseException;
+import org.spoofax.jsglr.client.ParseTable;
+import org.spoofax.jsglr.client.SGLR;
+import org.spoofax.jsglr.client.imploder.TermTreeFactory;
+import org.spoofax.jsglr.client.imploder.TreeBuilder;
+import org.spoofax.jsglr.io.FileTools;
+import org.spoofax.jsglr.shared.BadTokenException;
+import org.spoofax.jsglr.shared.SGLRException;
+import org.spoofax.jsglr.shared.TokenExpectedException;
+import org.spoofax.terms.TermFactory;
+import org.spoofax.terms.attachments.ParentTermFactory;
+import org.spoofax.terms.io.binary.TermReader;
+
+import org.spoofax.jsglr.client.editregion.detection.EditRegionDetector;
+
+public class AbstractTestRegionDetection {
+
+	private SGLR sglr;
+	protected EditRegionDetector editRegionRecovery;
+	protected String pathToCorrectFile;
+	protected IStrategoTerm lastErr0AST;
+	protected String pathToJavaTestInputs;
+
+	public AbstractTestRegionDetection() {
+		super();
+	}
+
+	protected IStrategoTerm parseFile(String fname) throws IOException, FileNotFoundException, BadTokenException, TokenExpectedException, ParseException,
+			SGLRException {
+				String inputChars = loadAsString(fname);
+				IStrategoTerm trm1 = parseString(inputChars);
+				return trm1;
+			}
+
+	public IStrategoTerm parseString(String inputChars) throws BadTokenException, TokenExpectedException, ParseException, SGLRException {
+		IStrategoTerm trm1 = (IStrategoTerm) sglr.parse(inputChars, null, null);
+		return trm1;
+	}
+
+	protected String loadAsString(String fname) throws IOException, FileNotFoundException {
+		String inputChars = FileTools.loadFileAsString(new BufferedReader(new FileReader(fname)));
+		return inputChars;
+	}
+
+	protected void setSGLR(String pathToParseTable) throws IOException, InvalidParseTableException {
+		final TermFactory factory = new TermFactory();
+		final IStrategoTerm tableTerm = new TermReader(factory).parseFromFile(pathToParseTable);
+		final ParseTable pt = new ParseTable(tableTerm, factory);
+		TermTreeFactory parentFactory = new TermTreeFactory(new ParentTermFactory(new TermFactory()));
+		sglr = new SGLR(new TreeBuilder(parentFactory), pt);
+		// sglr = new SGLR(new TreeBuilder(true), pt);
+		sglr.getDisambiguator().setDefaultFilters();
+		sglr.getDisambiguator().setHeuristicFilters(true);
+		sglr.setUseStructureRecovery(false);
+	}
+
+	protected String concatenatedDiscardChars(String erroneousInput, ArrayList<Integer> discards_err) {
+	//		System.out.println("discards_erroneous: " + discards_err);
+			char[] discards_err_char = new char[discards_err.size()];
+			for (int i = 0; i < discards_err_char.length; i++) {
+				discards_err_char[i] = erroneousInput.charAt(discards_err.get(i));
+			}
+			System.out.println("discards_erroneous: " + String.copyValueOf(discards_err_char));
+			return String.copyValueOf(discards_err_char);
+		}
+
+	protected void testDiscardedCharacters(String expectedConcatenatedDiscards, String pathToErroneousFile) throws IOException, FileNotFoundException {
+		String erroneousInput = loadAsString(pathToErroneousFile);
+		ArrayList<Integer> discardOffsets = getDiscardOffsets(lastErr0AST, erroneousInput);
+		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
+		Assert.assertEquals(expectedConcatenatedDiscards, concatenated);
+	}
+
+	protected ArrayList<Integer> getDiscardOffsets(IStrategoTerm lastErr0AST, String erroneousInput) {
+		editRegionRecovery = new EditRegionDetector(lastErr0AST, erroneousInput);		
+		return editRegionRecovery.getDiscardOffsetsErroneousInput();
+	}
+
+	protected void setJavaParser() throws IOException,
+			InvalidParseTableException, FileNotFoundException,
+			BadTokenException, TokenExpectedException, ParseException,
+			SGLRException {
+				String pathToParseTable = "tests/grammars/Java-15.tbl";
+				setSGLR(pathToParseTable);
+				pathToCorrectFile = pathToJavaTestInputs + "/base.java";
+				lastErr0AST = parseFile(pathToCorrectFile);
+			}
+
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionBasic.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionBasic.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,96 @@
+package org.spoofax.jsglr.client.editregion.test;
+
+import junit.framework.Assert;
+import java.io.IOException;
+import java.util.ArrayList;
+
+import org.junit.Test;
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParseException;
+import org.spoofax.jsglr.shared.BadTokenException;
+import org.spoofax.jsglr.shared.SGLRException;
+import org.spoofax.jsglr.shared.TokenExpectedException;
+
+public class TestEditRegionBasic extends AbstractTestRegionDetection {
+	public TestEditRegionBasic() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException{
+		pathToJavaTestInputs = "tests-editregions/java/basic"; 
+		setJavaParser();
+	} 
+
+	@Test
+	public void testInsertedRegion() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String pathToErroneousFile = pathToJavaTestInputs + "/insertion.java";
+		String erroneousInput = loadAsString(pathToErroneousFile);
+		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
+		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
+		Assert.assertEquals("if(v > 5){\n\t\t", concatenated);
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+
+	@Test
+	public void testDeletedRegion() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String pathToErroneousFile = pathToJavaTestInputs + "/deletion.java";
+		String erroneousInput = loadAsString(pathToErroneousFile);
+		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
+		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
+		Assert.assertEquals("v+=\n\t\t", concatenated);
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+
+	@Test
+	public void testMultipleDeletedRegions() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String pathToErroneousFile = pathToJavaTestInputs + "/multiple-deletions.java";
+		String erroneousInput = loadAsString(pathToErroneousFile);
+		//System.out.println(lastErr0AST);
+		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
+		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
+		//Assert.assertEquals("package \n\t\t= 10;\n\t\tSystem..println(v);", concatenated);
+		Assert.assertEquals("package = .", concatenated);
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+
+	@Test
+	public void testNestedDeletedRegions() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String pathToErroneousFile = pathToJavaTestInputs + "/nested-deletions.java";
+		String erroneousInput = loadAsString(pathToErroneousFile);
+		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
+		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
+		Assert.assertEquals("private void m(int x, int y, int z{\n		int v = 10;\n		v+= \n		System.out.println(v);\n	}", concatenated);
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+
+	@Test
+	public void testDeletionAndInsertion() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String pathToErroneousFile = pathToJavaTestInputs + "/deletion-and-insertion.java";
+		String erroneousInput = loadAsString(pathToErroneousFile);
+		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
+		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
+		Assert.assertEquals(" + 5 +\n\t\tSystem.out.println(v", concatenated);
+		//System.out.println(editRegionRecovery.getRecoveredInput());
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+
+	@Test
+	public void testReplacement() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String pathToErroneousFile = pathToJavaTestInputs + "/replacement.java";
+		String erroneousInput = loadAsString(pathToErroneousFile);
+		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
+		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
+		Assert.assertEquals("v = v +;\n\t\t", concatenated);
+		Assert.assertEquals(127, editRegionRecovery.getCorrectInput().length());
+		Assert.assertEquals(128, editRegionRecovery.getErroneousInput().length());
+		Assert.assertEquals(128, editRegionRecovery.getRecoveredInput().length());
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+
+	@Test
+	public void testDelInsNesting() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String pathToErroneousFile = pathToJavaTestInputs + "/del-ins-nesting.java";
+		String erroneousInput = loadAsString(pathToErroneousFile);
+		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
+		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
+		Assert.assertEquals("private void m(int x, int y, int z{\n		int v = 10;\n		v+= 10;\n		print(\n		System.out.println(v);\n	}", concatenated);
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionInsertonsInToken.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionInsertonsInToken.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,70 @@
+package org.spoofax.jsglr.client.editregion.test;
+
+import java.io.IOException;
+import java.util.ArrayList;
+
+import junit.framework.Assert;
+
+import org.junit.Test;
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParseException;
+import org.spoofax.jsglr.shared.BadTokenException;
+import org.spoofax.jsglr.shared.SGLRException;
+import org.spoofax.jsglr.shared.TokenExpectedException;
+
+public class TestEditRegionInsertonsInToken extends AbstractTestRegionDetection {
+	public TestEditRegionInsertonsInToken() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException{
+		pathToJavaTestInputs = "tests-editregions/java/insertions";
+		setJavaParser();
+	}
+
+	@Test
+	public void testInsertionInTerminal1() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String pathToErroneousFile = pathToJavaTestInputs + "/ins-in-terminal1.java";
+		String erroneousInput = loadAsString(pathToErroneousFile);
+		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
+		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
+		Assert.assertEquals("\n\t\tSys tem.out.println(v);", concatenated); 
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+
+	@Test
+	public void testInsertionInTerminal2() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String pathToErroneousFile = pathToJavaTestInputs + "/ins-in-terminal2.java";
+		String erroneousInput = loadAsString(pathToErroneousFile);
+		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
+		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
+		Assert.assertEquals("\n\t\tSysttem.out.println(v);", concatenated); 
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+
+	@Test
+	public void testInsertionInTerminal3() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String pathToErroneousFile = pathToJavaTestInputs + "/ins-in-terminal3.java";
+		String erroneousInput = loadAsString(pathToErroneousFile);
+		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
+		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
+		Assert.assertEquals("x", concatenated); 
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+
+	@Test
+	public void testInsertionInTerminal4() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String pathToErroneousFile = pathToJavaTestInputs + "/ins-in-terminal4.java";
+		String erroneousInput = loadAsString(pathToErroneousFile);
+		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
+		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
+		Assert.assertEquals("\n\t\tSys-tem.out.println(v);", concatenated); 
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+
+	@Test
+	public void testInsertionInCommentOpening() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String pathToErroneousFile = pathToJavaTestInputs + "/ins-in-comment-opening.java";
+		String erroneousInput = loadAsString(pathToErroneousFile);
+		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
+		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
+		Assert.assertEquals("/ *mmmm*/", concatenated); 
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+}

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionLayout.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionLayout.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,93 @@
+package org.spoofax.jsglr.client.editregion.test;
+
+
+import java.io.IOException;
+
+import org.junit.Test;
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParseException;
+import org.spoofax.jsglr.shared.BadTokenException;
+import org.spoofax.jsglr.shared.SGLRException;
+import org.spoofax.jsglr.shared.TokenExpectedException;
+
+public class TestEditRegionLayout extends AbstractTestRegionDetection {
+	
+	public TestEditRegionLayout() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException{
+		pathToJavaTestInputs = "tests-editregions/java/layout";
+		setJavaParser();
+	}
+
+	@Test
+	public void testDeletedBlockCommentEnding1() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String expectedConcatenatedDiscards = "/*vv";
+		String pathToErroneousFile = pathToJavaTestInputs + "/delete-block-comment-ending1.java";
+		testDiscardedCharacters(expectedConcatenatedDiscards, pathToErroneousFile);
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+
+	@Test
+	public void testDeletedBlockCommentEnding2() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String expectedConcatenatedDiscards = "/*vv";
+		String pathToErroneousFile = pathToJavaTestInputs + "/delete-block-comment-ending2.java";
+		testDiscardedCharacters(expectedConcatenatedDiscards, pathToErroneousFile);
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+
+	@Test
+	public void testDeletedBlockCommentEnding3() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String expectedConcatenatedDiscards = "/*uu";
+		String pathToErroneousFile = pathToJavaTestInputs + "/delete-block-comment-ending3.java";
+		testDiscardedCharacters(expectedConcatenatedDiscards, pathToErroneousFile);
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+
+	@Test
+	public void testDeletedLayoutInbetween() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String expectedConcatenatedDiscards = "inti;\n\t\t";
+		String pathToErroneousFile = pathToJavaTestInputs + "/delete-layout-inbetween.java";
+		testDiscardedCharacters(expectedConcatenatedDiscards, pathToErroneousFile);
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+
+	@Test
+	public void testDeletedLineCommentEnding() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String expectedConcatenatedDiscards = "//www"; 
+				//"private void m(int x, int y, int z){\n\t\tint v = 10;\n\t\t/*uuu*/\n\t\tv+= 10;\n\t\tint      i;\n\t\tint/*vvv*/  j;\n\t\tSystem.out.println(v); //www	}";
+		String pathToErroneousFile = pathToJavaTestInputs + "/delete-line-comment-ending.java";
+		testDiscardedCharacters(expectedConcatenatedDiscards, pathToErroneousFile);
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+
+	@Test
+	public void testDeletedSomeLOInbetween1() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String expectedConcatenatedDiscards = "";
+		String pathToErroneousFile = pathToJavaTestInputs + "/delete-some-layout-inbetween1.java";
+		testDiscardedCharacters(expectedConcatenatedDiscards, pathToErroneousFile);
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+
+	@Test
+	public void testDeletedSomeLOInbetween2() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String expectedConcatenatedDiscards = "";
+		String pathToErroneousFile = pathToJavaTestInputs + "/delete-some-layout-inbetween2.java";
+		testDiscardedCharacters(expectedConcatenatedDiscards, pathToErroneousFile);
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+
+	@Test 
+	public void testDeletedBlockComment1() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String expectedConcatenatedDiscards = "";
+		String pathToErroneousFile = pathToJavaTestInputs + "/delete-block-comment1.java";
+		testDiscardedCharacters(expectedConcatenatedDiscards, pathToErroneousFile);
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+
+	@Test
+	public void testDeletedBlockComment2() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String expectedConcatenatedDiscards = "intj;\n\t\t";
+		String pathToErroneousFile = pathToJavaTestInputs + "/delete-block-comment2.java";
+		testDiscardedCharacters(expectedConcatenatedDiscards, pathToErroneousFile);
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionMisc.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionMisc.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,62 @@
+package org.spoofax.jsglr.client.editregion.test;
+
+import java.io.IOException;
+import java.util.ArrayList;
+
+import junit.framework.Assert;
+
+import org.junit.Test;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParseException;
+import org.spoofax.jsglr.shared.BadTokenException;
+import org.spoofax.jsglr.shared.SGLRException;
+import org.spoofax.jsglr.shared.TokenExpectedException;
+
+public class TestEditRegionMisc extends AbstractTestRegionDetection {
+	public TestEditRegionMisc() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException{
+		pathToJavaTestInputs = "tests-editregions/java/misc";
+		setJavaParser();
+	}
+
+	@Test
+	public void testCopyPaste() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String pathToErroneousFile = pathToJavaTestInputs + "/copy-paste.java";
+		String erroneousInput = loadAsString(pathToErroneousFile);
+		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
+		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
+		Assert.assertEquals(88, concatenated.length());
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+
+	@Test
+	public void testRequiredListElem() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String pathToErroneousFile = pathToJavaTestInputs + "/del-required-list-elem.java";
+		String erroneousInput = loadAsString(pathToErroneousFile);
+		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
+		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
+		Assert.assertEquals("tx", concatenated); //REMARk: does not solve the syntax error
+		//super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+
+	@Test
+	public void testLargeRegion() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+
+		String pathToCorrectFile = pathToJavaTestInputs + "/tricky.base.java";
+		IStrategoTerm lastErr0AST = parseFile(pathToCorrectFile);
+
+		String pathToErroneousFile = pathToJavaTestInputs + "/tricky.java";
+		String erroneousInput = loadAsString(pathToErroneousFile);
+		ArrayList<Integer> discardOffsets = getDiscardOffsets(lastErr0AST, erroneousInput);
+		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
+		Assert.assertEquals(4142, concatenated.length()); 
+		//System.out.println(editRegionRecovery.getRecoveredInput());
+		//super.parseString(editRegionRecovery.getRecoveredInput());
+		
+		//REMARk: probably better to return a small erroneous region that does not contain all errors
+		//than a very big unuseful region
+		//REMARK: lcs (current implementation) takes too much time for large regions
+		//TODOT
+	}
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionNestedListElems.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionNestedListElems.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,52 @@
+package org.spoofax.jsglr.client.editregion.test;
+
+
+import java.io.IOException;
+
+import org.junit.Ignore;
+import org.junit.Test;
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParseException;
+import org.spoofax.jsglr.shared.BadTokenException;
+import org.spoofax.jsglr.shared.SGLRException;
+import org.spoofax.jsglr.shared.TokenExpectedException;
+
+public class TestEditRegionNestedListElems extends AbstractTestRegionDetection {
+	
+	public TestEditRegionNestedListElems() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException{
+		pathToJavaTestInputs = "tests-editregions/java/nested-list-elems";
+		setJavaParser();
+	}
+
+	@Ignore @Test
+	public void testDeletionInParentElem1() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String expectedConcatenatedDiscards = "@@";
+		String pathToErroneousFile = pathToJavaTestInputs + "/deletion-in-parent-elem1.java";
+		testDiscardedCharacters(expectedConcatenatedDiscards, pathToErroneousFile);
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+
+	@Ignore @Test
+	public void testDeletionInParentElem2() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String expectedConcatenatedDiscards = "@@";
+		String pathToErroneousFile = pathToJavaTestInputs + "/deletion-in-parent-elem2.java";
+		testDiscardedCharacters(expectedConcatenatedDiscards, pathToErroneousFile);
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+
+	@Ignore @Test
+	public void testDeletionInParentElem3() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String expectedConcatenatedDiscards = "@@";
+		String pathToErroneousFile = pathToJavaTestInputs + "/deletion-in-parent-elem3.java";
+		testDiscardedCharacters(expectedConcatenatedDiscards, pathToErroneousFile);
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+
+	@Ignore @Test
+	public void testDeletionInParentElem4() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String expectedConcatenatedDiscards = "@@";
+		String pathToErroneousFile = pathToJavaTestInputs + "/deletion-in-parent-elem4.java";
+		testDiscardedCharacters(expectedConcatenatedDiscards, pathToErroneousFile);
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+}

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionOperators.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionOperators.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,96 @@
+package org.spoofax.jsglr.client.editregion.test;
+
+
+import java.io.IOException;
+import java.util.ArrayList;
+
+import org.junit.Assert;
+import org.junit.Test;
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParseException;
+import org.spoofax.jsglr.shared.BadTokenException;
+import org.spoofax.jsglr.shared.SGLRException;
+import org.spoofax.jsglr.shared.TokenExpectedException;
+
+public class TestEditRegionOperators extends AbstractTestRegionDetection {
+	
+	public TestEditRegionOperators() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException{
+		pathToJavaTestInputs = "tests-editregions/java/operators";
+		setJavaParser();
+	}
+
+	@Test
+	public void testDeletedOperator1() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String expectedConcatenatedDiscards = "3  ";
+		String pathToErroneousFile = pathToJavaTestInputs + "/delete-operator-1.java";
+		testDiscardedCharacters(expectedConcatenatedDiscards, pathToErroneousFile);
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+
+	@Test
+	public void testDeletedOperator2() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String expectedConcatenatedDiscards = "  5";
+		String pathToErroneousFile = pathToJavaTestInputs + "/delete-operator-2.java";
+		testDiscardedCharacters(expectedConcatenatedDiscards, pathToErroneousFile);
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+
+	@Test
+	public void testDeletedOperator3() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String expectedConcatenatedDiscards = "  8";
+		String pathToErroneousFile = pathToJavaTestInputs + "/delete-operator-3.java";
+		testDiscardedCharacters(expectedConcatenatedDiscards, pathToErroneousFile);
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+
+	@Test
+	public void testDeletedOperand1() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String expectedConcatenatedDiscards = " + ";
+		String pathToErroneousFile = pathToJavaTestInputs + "/delete-operand-1.java";
+		testDiscardedCharacters(expectedConcatenatedDiscards, pathToErroneousFile);
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+
+	@Test
+	public void testDeletedOperand2() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String expectedConcatenatedDiscards = " * ";
+		String pathToErroneousFile = pathToJavaTestInputs + "/delete-operand-2.java";
+		testDiscardedCharacters(expectedConcatenatedDiscards, pathToErroneousFile);
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+	
+	@Test
+	public void testDeletedMultipleOperators1() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String expectedConcatenatedDiscards = "  4  5";
+		String pathToErroneousFile = pathToJavaTestInputs + "/delete-multiple-operators1.java";
+		testDiscardedCharacters(expectedConcatenatedDiscards, pathToErroneousFile);
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+
+	@Test
+	public void testDeletedMultipleOperators2() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String expectedConcatenatedDiscards = "  7  8";
+		String pathToErroneousFile = pathToJavaTestInputs + "/delete-multiple-operators2.java";
+		testDiscardedCharacters(expectedConcatenatedDiscards, pathToErroneousFile);
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+
+	@Test
+	public void testDeletedMultipleOperators3() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String pathToErroneousFile = pathToJavaTestInputs + "/delete-multiple-operators3.java";
+		String erroneousInput = loadAsString(pathToErroneousFile);
+		ArrayList<Integer> discardOffsets = getDiscardOffsets(lastErr0AST, erroneousInput);
+		Assert.assertTrue(discardOffsets.size() < 20);
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+
+	@Test
+	public void testDeletedMultipleOperands() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String pathToErroneousFile = pathToJavaTestInputs + "/delete-multiple-operands.java";
+		String erroneousInput = loadAsString(pathToErroneousFile);
+		ArrayList<Integer> discardOffsets = getDiscardOffsets(lastErr0AST, erroneousInput);
+		Assert.assertTrue(discardOffsets.size() < 20);
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionSeparators.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionSeparators.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,72 @@
+package org.spoofax.jsglr.client.editregion.test;
+
+import java.io.IOException;
+import java.util.ArrayList;
+
+import junit.framework.Assert;
+
+import org.junit.Test;
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParseException;
+import org.spoofax.jsglr.shared.BadTokenException;
+import org.spoofax.jsglr.shared.SGLRException;
+import org.spoofax.jsglr.shared.TokenExpectedException;
+
+public class TestEditRegionSeparators extends AbstractTestRegionDetection {
+	public TestEditRegionSeparators() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException{
+		pathToJavaTestInputs = "tests-editregions/java/separators";
+		setJavaParser();
+	}
+
+	@Test
+	public void testDelSeparator() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String pathToErroneousFile = pathToJavaTestInputs + "/del-separator.java";
+		String erroneousInput = loadAsString(pathToErroneousFile);
+		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
+		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
+		Assert.assertEquals("int y ", concatenated);
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+	
+	@Test
+	public void testDelSeparatedElemFirst() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String pathToErroneousFile = pathToJavaTestInputs + "/del-separated-elem-first.java";
+		String erroneousInput = loadAsString(pathToErroneousFile);
+		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
+		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
+		Assert.assertEquals(", ", concatenated);
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+	
+	@Test
+	public void testDelSeparatedElemMid() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String pathToErroneousFile = pathToJavaTestInputs + "/del-separated-elem-mid.java";
+		String erroneousInput = loadAsString(pathToErroneousFile);
+		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
+		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
+		Assert.assertEquals(", ", concatenated);
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+
+	@Test
+	public void testDelSeparatedElemLast() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String pathToErroneousFile = pathToJavaTestInputs + "/del-separated-elem-last.java";
+		String erroneousInput = loadAsString(pathToErroneousFile);
+		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
+		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
+		Assert.assertEquals(", z", concatenated);
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+
+	@Test
+	public void testDelSeparatorAndNextElem() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String pathToErroneousFile = pathToJavaTestInputs + "/del-separator-and-next-elem.java";
+		String erroneousInput = loadAsString(pathToErroneousFile);
+		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
+		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
+		Assert.assertEquals(" z", concatenated); //TODO: not needed to remove 'int y' if ', int z' is affected.
+		System.out.println(editRegionRecovery.getRecoveredInput());
+		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/basic/base.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/basic/base.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,9 @@
+package tt;
+
+public class Example {
+	private void m(int x, int y, int z){
+		int v = 10;
+		v+= 10;
+		System.out.println(v);
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/basic/del-ins-nesting.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/basic/del-ins-nesting.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,10 @@
+package tt;
+
+public class Example {
+	private void m(int x, int y, int z{
+		int v = 10;
+		v+= 10;
+		print(
+		System.out.println(v);
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/basic/deletion-and-insertion.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/basic/deletion-and-insertion.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,9 @@
+package tt;
+
+public class Example {
+	private void m(int x, int y, int z){
+		int v = 10;
+		v+= 10 + 5 +;
+		System.out.println(v
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/basic/deletion.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/basic/deletion.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,9 @@
+package tt;
+
+public class Example {
+	private void m(int x, int y, int z){
+		int v = 10;
+		v+=
+		System.out.println(v);
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/basic/insertion.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/basic/insertion.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,10 @@
+package tt;
+
+public class Example {
+	private void m(int x, int y, int z){
+		int v = 10;
+		if(v > 5){
+		v+= 10;
+		System.out.println(v);
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/basic/multiple-deletions.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/basic/multiple-deletions.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,9 @@
+package 
+
+public class Example {
+	private void m(int x, int y, int z){
+		int v = 10;
+		= 10;
+		System..println(v);
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/basic/nested-deletions.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/basic/nested-deletions.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,9 @@
+package tt;
+
+public class Example {
+	private void m(int x, int y, int z{
+		int v = 10;
+		v+= 
+		System.out.println(v);
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/basic/replacement.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/basic/replacement.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,9 @@
+package tt;
+
+public class Example {
+	private void m(int x, int y, int z){
+		int v = 10;
+		v = v +;
+		System.out.println(v);
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/insertions/base.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/insertions/base.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,10 @@
+package tt;
+
+/*mmmm*/
+public class Example {
+	private void m(int x, int y, int z){
+		int v = 10;
+		v+= 10;
+		System.out.println(v);
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/insertions/ins-in-comment-opening.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/insertions/ins-in-comment-opening.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,10 @@
+package tt;
+
+/ *mmmm*/
+public class Example {
+	private void m(int x, int y, int z){
+		int v = 10;
+		v+= 10;
+		System.out.println(v);
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/insertions/ins-in-terminal1.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/insertions/ins-in-terminal1.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,10 @@
+package tt;
+
+/*mmmm*/
+public class Example {
+	private void m(int x, int y, int z){
+		int v = 10;
+		v+= 10;
+		Sys tem.out.println(v);
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/insertions/ins-in-terminal2.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/insertions/ins-in-terminal2.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,10 @@
+package tt;
+
+/*mmmm*/
+public class Example {
+	private void m(int x, int y, int z){
+		int v = 10;
+		v+= 10;
+		Systtem.out.println(v);
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/insertions/ins-in-terminal3.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/insertions/ins-in-terminal3.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,10 @@
+package tt;
+
+/*mmmm*/
+public class Example {
+	privatex void m(int x, int y, int z){
+		int v = 10;
+		v+= 10;
+		System.out.println(v);
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/insertions/ins-in-terminal4.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/insertions/ins-in-terminal4.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,10 @@
+package tt;
+
+/*mmmm*/
+public class Example {
+	private void m(int x, int y, int z){
+		int v = 10;
+		v+= 10;
+		Sys-tem.out.println(v);
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/layout/base.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/layout/base.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,12 @@
+package tt;
+
+public class Example {
+	private void m(int x, int y, int z){
+		int v = 10;
+		/*uuu*/
+		v+= 10;
+		int      i;
+		int/*vvv*/  j;
+		System.out.println(v); //www
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/layout/delete-block-comment-ending1.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/layout/delete-block-comment-ending1.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,12 @@
+package tt;
+
+public class Example {
+	private void m(int x, int y, int z){
+		int v = 10;
+		/*uuu*/
+		v+= 10;
+		int      i;
+		int/*vv  j;
+		System.out.println(v); //www
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/layout/delete-block-comment-ending2.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/layout/delete-block-comment-ending2.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,12 @@
+package tt;
+
+public class Example {
+	private void m(int x, int y, int z){
+		int v = 10;
+		/*uuu*/
+		v+= 10;
+		int      i;
+		int/*vvj;
+		System.out.println(v); //www
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/layout/delete-block-comment-ending3.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/layout/delete-block-comment-ending3.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,12 @@
+package tt;
+
+public class Example {
+	private void m(int x, int y, int z){
+		int v = 10;
+		/*uu
+		v+= 10;
+		int      i;
+		int/*vvv*/  j;
+		System.out.println(v); //www
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/layout/delete-block-comment1.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/layout/delete-block-comment1.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,12 @@
+package tt;
+
+public class Example {
+	private void m(int x, int y, int z){
+		int v = 10;
+		/*uuu*/
+		v+= 10;
+		int      i;
+		int  j;
+		System.out.println(v); //www
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/layout/delete-block-comment2.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/layout/delete-block-comment2.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,12 @@
+package tt;
+
+public class Example {
+	private void m(int x, int y, int z){
+		int v = 10;
+		/*uuu*/
+		v+= 10;
+		int      i;
+		intj;
+		System.out.println(v); //www
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/layout/delete-layout-inbetween.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/layout/delete-layout-inbetween.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,12 @@
+package tt;
+
+public class Example {
+	private void m(int x, int y, int z){
+		int v = 10;
+		/*uuu*/
+		v+= 10;
+		inti;
+		int/*vvv*/  j;
+		System.out.println(v); //www
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/layout/delete-line-comment-ending.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/layout/delete-line-comment-ending.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,11 @@
+package tt;
+
+public class Example {
+	private void m(int x, int y, int z){
+		int v = 10;
+		/*uuu*/
+		v+= 10;
+		int      i;
+		int/*vvv*/  j;
+		System.out.println(v); //www	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/layout/delete-some-layout-inbetween1.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/layout/delete-some-layout-inbetween1.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,12 @@
+package tt;
+
+public class Example {
+	private void m(int x, int y, int z){
+		int v = 10;
+		/*uuu*/
+		v+= 10;
+		int i;
+		int/*vvv*/  j;
+		System.out.println(v); //www
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/layout/delete-some-layout-inbetween2.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/layout/delete-some-layout-inbetween2.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,12 @@
+package tt;
+
+public class Example {
+	private void m(int x, int y, int z){
+		int v = 10;
+		/*uuu*/
+		v+= 10;
+		int      i;
+		int/*vvv*/j;
+		System.out.println(v); //www
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/misc/base.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/misc/base.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,9 @@
+package tt;
+
+public class Example {
+	private void m(int x, int y, int z){
+		int v = 10;
+		v+= 10;
+		System.out.println(v);
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/misc/copy-paste.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/misc/copy-paste.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,9 @@
+package tt;
+
+public class Example {
+	private void m(int x, int y, int z){
+	}
+		int v = 10;
+		v+= 10;
+		System.out.println(v);
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/misc/del-required-list-elem.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/misc/del-required-list-elem.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,9 @@
+package tx;
+
+public class Example {
+	private void m(int x, int y, int z){
+		int v = 10;
+		v+= 10;
+		System.out.println(v);
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/misc/tricky.base.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/misc/tricky.base.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,108 @@
+package detection;
+
+import static org.spoofax.jsglr.client.imploder.ImploderAttachment.*;
+
+import java.util.ArrayList;
+
+import org.spoofax.interpreter.library.treediff.algorithms.LCS;
+import org.spoofax.interpreter.library.treediff.algorithms.LCSCommand;
+import org.spoofax.interpreter.terms.ISimpleTerm;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.jsglr.client.imploder.ImploderAttachment;
+import org.spoofax.interpreter.core.Tools;
+
+public class EditRegionDetector {
+	public void detectEditRegions(IStrategoTerm lastErr0AST, String erroneousInput) {
+		String correctInput = ImploderAttachment.getTokenizer(lastErr0AST).getInput();
+		ArrayList<Character> correctChars = asCharacterList(correctInput);
+		ArrayList<Character> erroneousChars = asCharacterList(erroneousInput);
+		LCS<Character> lcs = new LCS<Character>(new LCSCommand<Character>() {
+			public boolean isMatch(Character c1, Character c2) {
+				return c1.charValue() == c2.charValue();
+			}});
+		lcs.createLCSResultsOptimized(correctChars, erroneousChars);
+		System.out.println("LCS size: " + lcs.getLCSSize());
+		System.out.println(" deleted: " + lcs.getResultUnmatched1());
+		System.out.println("inserted: " + lcs.getResultUnmatched2());
+		System.out.println("  unmatched_correct: " + lcs.getUnMatchedIndices1());
+		System.out.println("unmatched_erroneous: " + lcs.getUnMatchedIndices2());
+		ArrayList<IStrategoTerm> affectedListTerms = getAffectedListTerms(lastErr0AST, lcs.getUnMatchedIndices1(), false);
+		System.out.println("affected list terms: " + affectedListTerms);
+	}
+
+	//TODO: what if incomplete?
+	//TODO: may be better to return incomplete elems that are resonable small than one big area
+	private ArrayList<IStrategoTerm> getAffectedListTerms(IStrategoTerm trm, ArrayList<Integer> offsetsDeletedChars, boolean hasListParent) {
+		if(offsetsOutsideFragment(offsetsDeletedChars, trm) ){
+			return new ArrayList<IStrategoTerm>(); //no need to traverse subterms 
+		}
+		ArrayList<IStrategoTerm> candidatesFromSubterms = new ArrayList<IStrategoTerm>();
+		for (int i = 0; i < trm.getSubtermCount(); i++) {
+			ArrayList<IStrategoTerm> candidates_subtrm_i = getAffectedListTerms(trm.getSubterm(i), offsetsDeletedChars, Tools.isTermList(trm)); 
+			candidatesFromSubterms.addAll(candidates_subtrm_i);
+		}
+		if(hasListParent){
+			ArrayList<Integer> uncoveredOffsets = getUncoveredOffsets(offsetsDeletedChars, candidatesFromSubterms);
+			if(coversAtLeastOneOffset(uncoveredOffsets, trm)){
+				ArrayList<IStrategoTerm> result = new ArrayList<IStrategoTerm>();
+				result.add(trm);
+				return result; 
+			}
+		}
+		return candidatesFromSubterms;
+	}
+
+	private boolean offsetsOutsideFragment(ArrayList<Integer> offsets, IStrategoTerm trm) {
+		int startOffset = getLeftToken(trm).getStartOffset();
+		int endOffset = getRightToken(trm).getEndOffset();
+		return offsets.isEmpty() || endOffset < offsets.get(0) || startOffset > offsets.get(offsets.size()-1);
+	}
+
+	private boolean coversAtLeastOneOffset(ArrayList<Integer> uncoveredOffsets, IStrategoTerm trm) {
+		boolean coversExtraOffset = false;
+		if(!uncoveredOffsets.isEmpty()){
+			int startOffset = getLeftToken(trm).getStartOffset();
+			int endOffset = getRightToken(trm).getEndOffset();
+			for (int i = 0; i < uncoveredOffsets.size(); i++) {
+				int uncoveredIndex = uncoveredOffsets.get(i); 
+				if(startOffset <= uncoveredIndex && uncoveredIndex <= endOffset){
+					//covered
+					/*parent list overwrites child list results because it covers more deletions*/
+					/*example: while(c){int i; int j;} whereby 'j' and '}' are deleted*/
+					coversExtraOffset = true;
+					break;
+				}
+			}
+		}
+		return coversExtraOffset;
+	}
+
+	private ArrayList<Integer> getUncoveredOffsets(ArrayList<Integer> offsetsDeletedChars, ArrayList<IStrategoTerm> candidatesFromSubterms) {
+		ArrayList<Integer> uncoveredIndices = new ArrayList<Integer>();
+		for (int i = 0; i < offsetsDeletedChars.size(); i++) {
+			int deletedIndex = offsetsDeletedChars.get(i);
+			boolean isCovered = false;
+			for (IStrategoTerm candidate : candidatesFromSubterms) {
+				if(getLeftToken(candidate).getStartOffset() <= deletedIndex && deletedIndex <= getRightToken(candidate).getEndOffset()){
+					isCovered = true;
+					break;
+				}
+			}
+			if(!isCovered){
+				uncoveredIndices.add(deletedIndex);
+			}
+		}
+		return uncoveredIndices;
+	}
+
+
+
+	private static ArrayList<Character> asCharacterList(String correctInput) {
+		ArrayList<Character> correctChars = new ArrayList<Character>();
+		for (int i = 0; i < correctInput.length(); i++) {
+			correctChars.add(correctInput.charAt(i));
+		}
+		return correctChars;
+	}	
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/misc/tricky.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/misc/tricky.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,108 @@
+package detection;
+
+import static org.spoofax.jsglr.client.imploder.ImploderAttachment.*;
+
+import java.util.ArrayList;
+
+import org.spoofax.interpreter.library.treediff.algorithms.LCS;
+import org.spoofax.interpreter.library.treediff.algorithms.LCSCommand;
+import org.spoofax.interpreter.terms.ISimpleTerm;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.jsglr.client.imploder.ImploderAttachment;
+import org.spoofax.interpreter.core.Tools;
+
+public cla EditRegionDetector {
+	public void detectEditRegions(IStrategoTerm lastErr0AST, String erroneousInput) {
+		String correctInput = ImploderAttachment.getTokenizer(lastErr0AST).getInput();
+		ArrayList<Character> correctChars = asCharacterList(correctInput);
+		ArrayList<Character> erroneousChars = asCharacterList(erroneousInput);
+		LCS<Character> lcs = new LCS<Character>(new LCSCommand<Character>() {
+			public boolean isMatch(Character c1, Character c2) {
+				return c1.charValue() == c2.charValue();
+			}});
+		lcs.createLCSResultsOptimized(correctChars, erroneousChars);
+		System.out.println("LCS size: " + lcs.getLCSSize());
+		System.out.println(" deleted: " + lcs.getResultUnmatched1());
+		System.out.println("inserted: " + lcs.getResultUnmatched2());
+		System.out.println("  unmatched_correct: " + lcs.getUnMatchedIndices1());
+		System.out.println("unmatched_erroneous: " + lcs.getUnMatchedIndices2());
+		ArrayList<IStrategoTerm> affectedListTerms = getAffectedListTerms(lastErr0AST, lcs.getUnMatchedIndices1(), false);
+		System.out.println("affected list terms: " + affectedListTerms);
+	}
+
+	//TODO: what if incomplete?
+	//TODO: may be better to return incomplete elems that are resonable small than one big area
+	private ArrayList<IStrategoTerm> getAffectedListTerms(IStrategoTerm trm, ArrayList<Integer> offsetsDeletedChars, boolean hasListParent) {
+		if(offsetsOutsideFragment(offsetsDeletedChars, trm) ){
+			return new ArrayList<IStrategoTerm>(); //no need to traverse subterms 
+		}
+		ArrayList<IStrategoTerm> candidatesFromSubterms = new ArrayList<IStrategoTerm>();
+		for (int i = 0; i < trm.getSubtermCount(); i++) {
+			ArrayList<IStrategoTerm> candidates_subtrm_i = getAffectedListTerms(trm.getSubterm(i), offsetsDeletedChars, Tools.isTermList(trm)); 
+			candidatesFromSubterms.addAll(candidates_subtrm_i);
+		}
+		if(hasListParent){
+			ArrayList<Integer> uncoveredOffsets = getUncoveredOffsets(offsetsDeletedChars, candidatesFromSubterms);
+			if(coversAtLeastOneOffset(uncoveredOffsets, trm)){
+				ArrayList<IStrategoTerm> result = new ArrayList<IStrategoTerm>();
+				result.add(trm);
+				return result; 
+			}
+		}
+		return candidatesFromSubterms;
+	}
+
+	private boolean offsetsOutsideFragment(ArrayList<Integer> offsets, IStrategoTerm trm) {
+		int startOffset = getLeftToken(trm).getStartOffset();
+		int endOffset = getRightToken(trm).getEndOffset();
+		return offsets.isEmpty() || endOffset < offsets.get(0) || startOffset > offsets.get(offsets.size()-1);
+	}
+
+	private boolean coversAtLeastOneOffset(ArrayList<Integer> uncoveredOffsets, IStrategoTerm trm) {
+		boolean coversExtraOffset = false;
+		if(!uncoveredOffsets.isEmpty()){
+			int startOffset = getLeftToken(trm).getStartOffset();
+			int endOffset = getRightToken(trm).getEndOffset();
+			for (int i = 0; i < uncoveredOffsets.size(); i++) {
+				int uncoveredIndex = uncoveredOffsets.get(i); 
+				if(startOffset <= uncoveredIndex && uncoveredIndex <= endOffset){
+					//covered
+					/*parent list overwrites child list results because it covers more deletions*/
+					/*example: while(c){int i; int j;} whereby 'j' and '}' are deleted*/
+					coversExtraOffset = true;
+					break;
+				}
+			}
+		}
+		return coversExtraOffset;
+	}
+
+	private ArrayList<Integer> getUncoveredOffsets(ArrayList<Integer> offsetsDeletedChars, ArrayList<IStrategoTerm> candidatesFromSubterms) {
+		ArrayList<Integer> uncoveredIndices = new ArrayList<Integer>();
+		for (int i = 0; i < offsetsDeletedChars.size(); i++) {
+			int deletedIndex = offsetsDeletedChars.get(i);
+			boolean isCovered = false;
+			for (IStrategoTerm candidate : candidatesFromSubterms) {
+				if(getLeftToken(candidate).getStartOffset() <= deletedIndex && deletedIndex <= getRightToken(candidate).getEndOffset()){
+					isCovered = true;
+					break;
+				}
+			}
+			if(!isCovered){
+				uncoveredIndices.add(deletedIndex
+			}
+		}
+		return uncoveredIndices;
+	}
+
+
+
+	private static ArrayList<Character> asCharacterList(String correctInput) {
+		ArrayList<Character> correctChars = new ArrayList<Character>();
+		for (int i = 0; i < correctInput.length(); i++) {
+			correctChars.add(correctInput.charAt(i));
+		}
+		return correctChars;
+	}	
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/nested-list-elems/base.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/nested-list-elems/base.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,15 @@
+package tt;
+
+public class Example {
+	private void m(){
+		int i;
+		while(i > 5){
+			print(i);
+			if(i > 10){
+				i = i + 5;
+				break;
+			}
+			i++;
+		}
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/nested-list-elems/deletion-in-parent-and-child-elem.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/nested-list-elems/deletion-in-parent-and-child-elem.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,15 @@
+package tt;
+
+public class Example {
+	private void m(){
+		int i;
+		while(i > 5 {
+			print(i);
+			if(i > 10){
+				i = i + 
+				break;
+			}
+			i++;
+		}
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/nested-list-elems/deletion-in-parent-elem1.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/nested-list-elems/deletion-in-parent-elem1.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,15 @@
+package tt;
+
+public class Example {
+	private void m(){
+		int i;
+		while(i > 5)
+			print(i);
+			if(i > 10){
+				i = i + 5;
+				break;
+			}
+			i++;
+		}
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/nested-list-elems/deletion-in-parent-elem2.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/nested-list-elems/deletion-in-parent-elem2.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,15 @@
+package tt;
+
+public class Example {
+	private void m(){
+		int i;
+		while(i > 5
+			print(i);
+			if(i > 10){
+				i = i + 5;
+				break;
+			}
+			i++;
+		}
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/nested-list-elems/deletion-in-parent-elem3.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/nested-list-elems/deletion-in-parent-elem3.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,15 @@
+package tt;
+
+public class Example {
+	private void m(){
+		int i;
+		while(){
+			print(i);
+			if(i > 10){
+				i = i + 5;
+				break;
+			}
+			i++;
+		}
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/nested-list-elems/deletion-in-parent-elem4.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/nested-list-elems/deletion-in-parent-elem4.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,15 @@
+package tt;
+
+public class Example {
+	private void m(){
+		int i;
+		while(i > 5 {
+			print(i);
+			if(i > 10){
+				i = i + 5;
+				break;
+			}
+			i++;
+		}
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/operators/base.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/operators/base.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,8 @@
+package tt;
+
+public class Example {
+	private int m(){
+		int i = 3 + 4 + 5 + 5 + 7 + 8;
+		return 3 + 4 * 5;
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/operators/delete-multiple-operands.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/operators/delete-multiple-operands.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,8 @@
+package tt;
+
+public class Example {
+	private int m(){
+		int i = 3 +  + 5 + 5 +  + 8;
+		return 3 + 4 * 5;
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/operators/delete-multiple-operators1.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/operators/delete-multiple-operators1.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,8 @@
+package tt;
+
+public class Example {
+	private int m(){
+		int i = 3  4  5 + 5 + 7 + 8;
+		return 3 + 4 * 5;
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/operators/delete-multiple-operators2.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/operators/delete-multiple-operators2.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,8 @@
+package tt;
+
+public class Example {
+	private int m(){
+		int i = 3 + 4 + 5 + 5  7  8;
+		return 3 + 4 * 5;
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/operators/delete-multiple-operators3.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/operators/delete-multiple-operators3.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,8 @@
+package tt;
+
+public class Example {
+	private int m(){
+		int i = 3  4 + 5 + 5  7 + 8;
+		return 3 + 4 * 5;
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/operators/delete-operand-1.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/operators/delete-operand-1.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,8 @@
+package tt;
+
+public class Example {
+	private int m(){
+		int i = 3 + 4 + 5 + 5 + 7 + 8;
+		return  + 4 * 5;
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/operators/delete-operand-2.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/operators/delete-operand-2.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,8 @@
+package tt;
+
+public class Example {
+	private int m(){
+		int i = 3 + 4 + 5 + 5 + 7 + 8;
+		return 3 +  * 5;
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/operators/delete-operator-1.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/operators/delete-operator-1.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,8 @@
+package tt;
+
+public class Example {
+	private int m(){
+		int i = 3 + 4 + 5 + 5 + 7 + 8;
+		return 3  4 * 5;
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/operators/delete-operator-2.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/operators/delete-operator-2.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,8 @@
+package tt;
+
+public class Example {
+	private int m(){
+		int i = 3 + 4 + 5 + 5 + 7 + 8;
+		return 3 + 4  5;
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/operators/delete-operator-3.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/operators/delete-operator-3.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,8 @@
+package tt;
+
+public class Example {
+	private int m(){
+		int i = 3 + 4 + 5 + 5 + 7  8;
+		return 3 + 4 * 5;
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/separators/base.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/separators/base.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,9 @@
+package tt;
+
+public class Example {
+	private void m(int x, int y, int z){
+		int v = 10;
+		v+= 10;
+		System.out.println(v);
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/separators/del-separated-elem-first.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/separators/del-separated-elem-first.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,9 @@
+package tt;
+
+public class Example {
+	private void m(, int y, int z){
+		int v = 10;
+		v+= 10;
+		System.out.println(v);
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/separators/del-separated-elem-last.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/separators/del-separated-elem-last.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,9 @@
+package tt;
+
+public class Example {
+	private void m(int x, int y, z){
+		int v = 10;
+		v+= 10;
+		System.out.println(v);
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/separators/del-separated-elem-mid.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/separators/del-separated-elem-mid.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,9 @@
+package tt;
+
+public class Example {
+	private void m(int x, , int z){
+		int v = 10;
+		v+= 10;
+		System.out.println(v);
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/separators/del-separator-and-next-elem.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/separators/del-separator-and-next-elem.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,9 @@
+package tt;
+
+public class Example {
+	private void m(int x, int y z){
+		int v = 10;
+		v+= 10;
+		System.out.println(v);
+	}
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/separators/del-separator.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/java/separators/del-separator.java	Wed Aug  1 13:07:07 2012	(r25243)
@@ -0,0 +1,9 @@
+package tt;
+
+public class Example {
+	private void m(int x, int y int z){
+		int v = 10;
+		v+= 10;
+		System.out.println(v);
+	}
+}
\ No newline at end of file


From m.dejonge at tudelft.nl  Fri Aug  3 10:00:51 2012
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Fri, 03 Aug 2012 08:00:51 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25244 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection
Message-ID: <20120803080051.2BA76108C018@mx3.tudelft.nl>

Author: MaartjeDeJonge
Date: Fri Aug  3 08:00:49 2012
New Revision: 25244
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25244&sc=1

Log:


Added:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverAttachment.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java   (contents, props changed)

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverAttachment.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverAttachment.java	Fri Aug  3 08:00:49 2012	(r25244)
@@ -0,0 +1,138 @@
+package org.spoofax.jsglr.client.editregion.detection;
+
+import java.util.ArrayList;
+
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.jsglr.client.imploder.ITokenizer;
+import org.spoofax.jsglr.client.imploder.ImploderAttachment;
+import org.spoofax.jsglr.client.imploder.Token;
+import org.spoofax.terms.attachments.AbstractTermAttachment;
+import org.spoofax.terms.attachments.TermAttachmentType;
+import org.spoofax.terms.attachments.VolatileTermAttachmentType;
+
+/**
+ * @author maartje
+ */
+public class RecoverAttachment extends AbstractTermAttachment {
+
+//private fields
+	
+	private final ArrayList<IStrategoTerm> recoveredSubterms;
+	private final ArrayList<Integer> coveredDeletionOffsets;
+
+//creation of recover attachment 
+	
+	public static void putUndamagedRecoverAttachment(IStrategoTerm term, ArrayList<Integer> deletions){
+		ArrayList<IStrategoTerm> recoveredSubterms = new ArrayList<IStrategoTerm>();
+		recoveredSubterms.add(term); //term is its own recovery
+		ArrayList<Integer> coveredOffsets = getCoveredOffsets(term, deletions);
+		RecoverAttachment recovery = new RecoverAttachment(recoveredSubterms, coveredOffsets);
+		term.putAttachment(recovery);
+	}
+
+	public static void putFailedRecoverAttachment(IStrategoTerm term, ArrayList<Integer> deletions){
+		ArrayList<Integer> coveredOffsets = getCoveredOffsets(term, deletions);
+		RecoverAttachment recovery = new RecoverAttachment(null, coveredOffsets);
+		term.putAttachment(recovery);
+	}
+
+	public static void putDiscardRecoverAttachment(IStrategoTerm term, ArrayList<Integer> deletions){
+		ArrayList<Integer> coveredOffsets = getCoveredOffsets(term, deletions);
+		RecoverAttachment recovery = new RecoverAttachment(new ArrayList<IStrategoTerm>(), coveredOffsets);
+		term.putAttachment(recovery);
+	}
+
+	public static void putReplaceRecoverAttachment(IStrategoTerm term, IStrategoTerm recoveredSubterm, ArrayList<Integer> deletions){
+		ArrayList<IStrategoTerm> recoveredSubterms = new ArrayList<IStrategoTerm>();
+		recoveredSubterms.add(recoveredSubterm);
+		ArrayList<Integer> coveredOffsets = getCoveredOffsets(term, deletions);
+		RecoverAttachment recovery = new RecoverAttachment(recoveredSubterms, coveredOffsets);
+		term.putAttachment(recovery);
+	}
+
+	public static void putListReplaceRecoverAttachment(IStrategoTerm term, ArrayList<IStrategoTerm> recoveredSubterms, ArrayList<Integer> deletions){
+		ArrayList<Integer> coveredOffsets = getCoveredOffsets(term, deletions);
+		RecoverAttachment recovery = new RecoverAttachment(recoveredSubterms, coveredOffsets);
+		term.putAttachment(recovery);
+	}
+	
+	private RecoverAttachment(ArrayList<IStrategoTerm> recoveredSubterms, ArrayList<Integer> coveredDeletionOffsets) {
+		this.coveredDeletionOffsets = coveredDeletionOffsets;
+		this.recoveredSubterms = recoveredSubterms;
+	}
+	
+//access recover information 
+
+	public static boolean hasRecoverAttachment(IStrategoTerm term) {
+		return getRecoverAttachment(term) == null ? false : true;
+	}
+
+	public static ArrayList<IStrategoTerm> getRecoveredSubterms(IStrategoTerm term) {
+		RecoverAttachment ra = getRecoverAttachment(term);
+		return ra == null ? null : ra.recoveredSubterms;
+	}
+
+	public static int getNumberOfPreservedNonLayoutTokens(IStrategoTerm term){
+		RecoverAttachment ra = getRecoverAttachment(term);
+		return ra == null ? -1 : ra.getNumberOfPreservedNonLayoutTokens();		
+	}
+
+	public static ArrayList<Integer> getCoveredDeletionOffsets(IStrategoTerm term){
+		RecoverAttachment ra = getRecoverAttachment(term);
+		return ra == null ? new ArrayList<Integer>() : ra.coveredDeletionOffsets;		
+	}
+
+//private functions
+				
+	private static ArrayList<Integer> getCoveredOffsets(IStrategoTerm term, ArrayList<Integer> offsets) {
+		ArrayList<Integer> coveredOffsets = new ArrayList<Integer>();
+		int startOffset = ImploderAttachment.getLeftToken(term).getStartOffset();
+		int endOffset = ImploderAttachment.getRightToken(term).getEndOffset();
+		for (int i = 0; i < offsets.size(); i++) {
+			int offset = offsets.get(i); 
+			if(startOffset <= offset && offset <= endOffset){
+				//covered
+				coveredOffsets.add(offset);
+			}
+		}
+		return coveredOffsets;
+	}
+
+	private int getNumberOfPreservedNonLayoutTokens(){
+		int result = 0;
+		for (IStrategoTerm recoveredSubterm : this.recoveredSubterms) {
+			result += numberOfNonLayoutTokens(recoveredSubterm);
+		}
+		return result;
+	}
+
+	private static int numberOfNonLayoutTokens(IStrategoTerm term) {
+		ITokenizer tokens = ImploderAttachment.getTokenizer(term);
+		int leftTokenIndex = ImploderAttachment.getLeftToken(term).getIndex();
+		int rightTokenIndex = ImploderAttachment.getRightToken(term).getIndex();
+		int result = 0;
+		for (int i = leftTokenIndex; i <= rightTokenIndex; i++) {
+			if(tokens.getTokenAt(i).getKind() != Token.TK_LAYOUT){
+				result ++;
+			}				
+		}
+		return result;
+	}
+
+//standard attachment functions 
+	
+	private static final long serialVersionUID = -1224391165614342863L;
+
+	public static final TermAttachmentType<RecoverAttachment> TYPE =
+		new VolatileTermAttachmentType<RecoverAttachment>(RecoverAttachment.class);
+
+	public TermAttachmentType<RecoverAttachment> getAttachmentType() {
+		return TYPE;
+	}
+		
+	private static RecoverAttachment getRecoverAttachment(IStrategoTerm term) {
+		if(term == null)
+			return null;
+		return term.getAttachment(TYPE);
+	}
+}

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java	Fri Aug  3 08:00:49 2012	(r25244)
@@ -0,0 +1,100 @@
+package org.spoofax.jsglr.client.editregion.detection;
+
+import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getLeftToken;
+import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getRightToken;
+import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getTokenizer;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.jsglr.client.imploder.ITokenizer;
+import org.spoofax.jsglr.client.imploder.Token;
+
+public class RecoverInterpretation {
+
+//private fields
+
+	private final IStrategoTerm term;
+	private final boolean isRecovered;
+	private final ArrayList<RecoverInterpretation> recoveredSubterms;
+	
+
+	private final ArrayList<Integer> coveredDeletionOffsets;
+	private final int recoveryCosts;
+
+//public fields
+
+	public IStrategoTerm getTerm() {
+		return term;
+	}
+
+	public ArrayList<Integer> getCoveredDeletionOffsets() {
+		return coveredDeletionOffsets;
+	}
+
+	public int getRecoveryCosts() {
+		return recoveryCosts;
+	}
+
+// constructor
+	
+	public RecoverInterpretation(
+			IStrategoTerm term, 
+			ArrayList<RecoverInterpretation> recoveredSubterms, 
+			ArrayList<Integer> deletionOffsets
+	) {
+		this.term = term;
+		this.coveredDeletionOffsets = getCoveredOffsets(term, deletionOffsets);
+		this.recoveredSubterms = recoveredSubterms;
+		this.recoveryCosts = calculateRecoveryCosts(); 
+	}
+	
+//private functions
+
+	private static ArrayList<Integer> getCoveredOffsets(IStrategoTerm term, ArrayList<Integer> offsets) {
+		ArrayList<Integer> coveredOffsets = new ArrayList<Integer>();
+		int startOffset = getLeftToken(term).getStartOffset();
+		int endOffset = getRightToken(term).getEndOffset();
+		for (int i = 0; i < offsets.size(); i++) {
+			int offset = offsets.get(i); 
+			if(startOffset <= offset && offset <= endOffset){
+				//covered
+				coveredOffsets.add(offset);
+			}
+		}
+		return coveredOffsets;
+	}
+	
+	private int calculateRecoveryCosts(){
+		ArrayList<ArrayList<IStrategoTerm>>
+		int costs = numberOfNonLayoutTokens(this.getTerm()) - numberOfNonLayoutTokens(this.recoveredSubterms);
+		for (RecoverInterpretation subtermRecovery : recoveredSubterms) {
+			costs += subtermRecovery.getRecoveryCosts();
+		}
+		return costs;
+	}
+	
+	private int numberOfNonLayoutTokens(ArrayList<IStrategoTerm> terms) {
+		int result = 0;
+		for (IStrategoTerm recoveredTerm : terms) {
+			int nrOfNonLayoutTokens = numberOfNonLayoutTokens(recoveredTerm);
+			result += nrOfNonLayoutTokens;
+		}
+		return result;
+	}
+
+	private int numberOfNonLayoutTokens(IStrategoTerm term) {
+		ITokenizer tokens = getTokenizer(term);
+		int leftIndex =  getLeftToken(term).getIndex();
+		int rightIndex =  getRightToken(term).getIndex();
+		int nrOfNonLayoutTokens = 0;
+		for (int i = leftIndex; i <= rightIndex; i++) {
+			if(tokens.getTokenAt(i).getKind() != Token.TK_LAYOUT){
+				nrOfNonLayoutTokens ++;
+			}
+		}
+		return nrOfNonLayoutTokens;
+	}
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java	Fri Aug  3 08:00:49 2012	(r25244)
@@ -0,0 +1,143 @@
+package org.spoofax.jsglr.client.editregion.detection;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+
+import org.spoofax.interpreter.terms.IStrategoAppl;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.jsglr.client.imploder.ITokenizer;
+import org.spoofax.jsglr.client.imploder.Token;
+
+import static org.spoofax.jsglr.client.imploder.ImploderAttachment.*;
+import sun.security.action.GetLongAction;
+
+public class TermEditsAnalyzer {
+	private ArrayList<Integer> offsetsDeletedChars;
+	private HashMap<IStrategoTerm, RecoverInterpretation> recoveryLookup;
+
+	public TermEditsAnalyzer(){
+		offsetsDeletedChars = new ArrayList<Integer>(); //TODO
+		recoveryLookup = new HashMap<IStrategoTerm, RecoverInterpretation>();
+	}
+	
+	private ArrayList<IStrategoTerm> findRecoveryTerms(IStrategoTerm term, IStrategoTerm parent){
+		if(isSomeNode(term)){
+			return new ArrayList<IStrategoTerm>();	//discarding whole term			
+		}
+		String generalSort = getGeneralSort(term, parent); //more universal sort, example: Blockstm vs Exprstm
+		String sort = getSort(term);
+		if(parent.isList()){
+			ArrayList<IStrategoTerm> replacementCandidates = getRecoveryFromSubterms(term, parent, sort, generalSort); 
+			//TODO: separators??
+		}
+
+		
+		return null;
+	}
+	
+	private ArrayList<IStrategoTerm> getRecoveryFromSubterms(IStrategoTerm term, IStrategoTerm parent, String sort, String generalSort) {
+		ArrayList<IStrategoTerm> result = new ArrayList<IStrategoTerm>();
+
+		//determines if the term has a compatible sort, which is a required to be a recover candidate,
+		//and determines if it has the same sort, which means that the already found recovery (if any) 
+		//is optimal, e.g., no need to traverse the subterms.
+		String generalTermSort = getGeneralSort(term, parent);
+		String termSort = getElementSort(term);
+		boolean hasCompatibleSort = 
+				generalSort.equals(generalTermSort) ||
+				generalSort.replace("*", "").equals(generalTermSort) ||
+				sort.equals(termSort);
+		boolean hasSameSort = generalSort == generalTermSort && sort == termSort; 
+		
+		//terms of a compatible sort with a recover interpretation are candidates for recovery.
+		IStrategoTerm termCandidate = null;
+		if(hasCompatibleSort && hasRecoverInterpretation(term)){
+			termCandidate = term;
+		}
+		
+		//terms with the same sort (1), or terms that are not affected by editing (2) are not further inspected.
+		//1) already constructed recover interpretation is also the best interpretation for the current search, or
+		//2. we do not break interpretations that are not affected, e.g., outside the edit region. 
+		//thus, the candidate is the best recovery, or no recovery is found in this region.
+		if(hasSameSort || !hasDeletions(term)){
+			if(termCandidate != null){
+				result.add(termCandidate);
+				return result;
+			}
+			if(isSomeNode(term) || parent.isList()){
+				return new ArrayList<IStrategoTerm>(); //represents a full skip recovery, e.g., no sub-terms are preserved 
+			}
+			return null; //region of term does not provide a recovery 
+		}
+
+		//recursively look for recover interpretations in subterms
+		ArrayList<IStrategoTerm> subtermCandidate = new ArrayList<IStrategoTerm>();
+		for (int i = 0; i < term.getSubtermCount(); i++) {
+			IStrategoTerm subterm = term.getSubterm(i);
+			ArrayList<IStrategoTerm> subtermRecovery = getRecoveryFromSubterms(subterm, term, sort, generalSort);
+			if(isListSort(generalSort)){// pick all compatible sub terms for elements in a list (which can be recovered by multiple elements)
+				subtermCandidate.addAll(subtermRecovery);
+			}
+			else { //pick the best recovery for non list terms
+				subtermCandidate = getMinimumCostRecovery(subtermCandidate, subtermRecovery);
+			}
+		}
+		
+		
+	}
+
+	private ArrayList<IStrategoTerm> getMinimumCostRecovery(RecoverInterpretation recovery1, RecoverInterpretation recovery2) {
+		//TODO
+		int recoverCost1 = 0;
+		for (IStrategoTerm term : recovery1) {
+			ArrayList<IStrategoTerm> recoveredTerms = this.recoveryLookup.get(term);
+			int recoverCostTerm = getRecoverCost(recoveredTerms);
+		}
+		return null;
+	}
+
+
+	public boolean isListSort(String sort) {
+		return sort.endsWith("*");
+	}
+
+	public String getGeneralSort(IStrategoTerm term, IStrategoTerm parent) {
+		String termSort = ImploderAttachment.getElementSort(term);
+		if(parent.isList())
+			termSort = ImploderAttachment.getElementSort(parent);
+		assert (term.isList() || parent.isList())? termSort.endsWith("*") : !termSort.endsWith("*");
+		return termSort;
+	}
+
+	private boolean hasDeletions(IStrategoTerm term) {
+		return !getCoveredOffsets(term, this.offsetsDeletedChars).isEmpty();
+	}
+
+	private static ArrayList<Integer> getCoveredOffsets(IStrategoTerm term, ArrayList<Integer> offsets) {
+		ArrayList<Integer> coveredOffsets = new ArrayList<Integer>();
+		int startOffset = getLeftToken(term).getStartOffset();
+		int endOffset = getRightToken(term).getEndOffset();
+		for (int i = 0; i < offsets.size(); i++) {
+			int offset = offsets.get(i); 
+			if(startOffset <= offset && offset <= endOffset){
+				//covered
+				coveredOffsets.add(offset);
+			}
+		}
+		return coveredOffsets;
+	}
+
+
+	public boolean hasRecoverInterpretation(IStrategoTerm term) {
+		return recoveryLookup.containsKey(term);
+	}
+
+	private boolean isSomeNode(IStrategoTerm trm) {
+		if(trm.getTermType() == IStrategoTerm.APPL){
+			return trm.getSubtermCount() == 1 && ((IStrategoAppl)trm).getConstructor().getName().equals("Some");
+		}
+		return false;
+	}
+
+
+}

From m.dejonge at tudelft.nl  Fri Aug  3 17:07:46 2012
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Fri, 03 Aug 2012 15:07:46 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25245 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection
Message-ID: <20120803150746.D1583108C002@mx3.tudelft.nl>

Author: MaartjeDeJonge
Date: Fri Aug  3 15:07:44 2012
New Revision: 25245
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25245&sc=1

Log:


Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/HelperFunctions.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/HelperFunctions.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/HelperFunctions.java	Fri Aug  3 08:00:49 2012	(r25244)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/HelperFunctions.java	Fri Aug  3 15:07:44 2012	(r25245)
@@ -1,7 +1,12 @@
 package org.spoofax.jsglr.client.editregion.detection;
 
+import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getElementSort;
+
 import java.util.List;
 
+import org.spoofax.interpreter.terms.IStrategoAppl;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+
 /**
  * Helper functions
  * @author maartje
@@ -24,4 +29,22 @@
 		}
 		return false;
 	}
+
+	public static String getGeneralSort(IStrategoTerm term, IStrategoTerm parent) {
+		String termSort = getElementSort(term);
+		if(parent != null){
+			if(parent.isList())
+				termSort = getElementSort(parent);
+			assert (term.isList() || parent.isList())? termSort.endsWith("*") : !termSort.endsWith("*");
+		}
+		return termSort;
+	}
+	
+	public static boolean isSomeNode(IStrategoTerm trm) {
+		if(trm.getTermType() == IStrategoTerm.APPL){
+			return trm.getSubtermCount() == 1 && ((IStrategoAppl)trm).getConstructor().getName().equals("Some");
+		}
+		return false;
+	}
+
 }

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java	Fri Aug  3 08:00:49 2012	(r25244)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java	Fri Aug  3 15:07:44 2012	(r25245)
@@ -1,11 +1,11 @@
 package org.spoofax.jsglr.client.editregion.detection;
 
+import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getElementSort;
 import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getLeftToken;
 import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getRightToken;
 import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getTokenizer;
 
 import java.util.ArrayList;
-import java.util.HashMap;
 
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.jsglr.client.imploder.ITokenizer;
@@ -16,74 +16,127 @@
 //private fields
 
 	private final IStrategoTerm term;
+	private final IStrategoTerm parentTerm;
 	private final boolean isRecovered;
-	private final ArrayList<RecoverInterpretation> recoveredSubterms;
-	
+	private final ArrayList<RecoverInterpretation> subtermRecoveries;
 
-	private final ArrayList<Integer> coveredDeletionOffsets;
 	private final int recoveryCosts;
 
-//public fields
+//public field accessors 
 
 	public IStrategoTerm getTerm() {
 		return term;
 	}
-
-	public ArrayList<Integer> getCoveredDeletionOffsets() {
-		return coveredDeletionOffsets;
+	
+	public ArrayList<RecoverInterpretation> getSubtermRecoveries() {
+		return subtermRecoveries;
 	}
 
 	public int getRecoveryCosts() {
 		return recoveryCosts;
 	}
 
-// constructor
+//public methods
+		
+	//	public boolean isListSort(String sort) {
+	//		return sort.endsWith("*");
+	//	}
+	
+	public String getGeneralSort(){
+		return HelperFunctions.getGeneralSort(term, parentTerm);
+	}
+
+	public String getSort(){
+		return getElementSort(term);
+	}
 	
-	public RecoverInterpretation(
+	public boolean hasSameSort(IStrategoTerm term, IStrategoTerm parent) {
+		String generalSort = HelperFunctions.getGeneralSort(term, parent);
+		String sort = getElementSort(term);
+		String generalTermSort = this.getGeneralSort();
+		String termSort = this.getSort();		
+		return generalSort == generalTermSort && sort == termSort;
+	}
+
+	public boolean hasCompatibleSort(IStrategoTerm term, IStrategoTerm parent) {
+		String generalSort = HelperFunctions.getGeneralSort(term, parent);
+		String sort = getElementSort(term);
+		String generalTermSort = this.getGeneralSort();
+		String termSort = this.getSort();
+		boolean hasCompatibleSort = 
+				generalSort.equals(termSort) ||
+				generalSort.equals(generalTermSort.replace("*", "")) ||
+				generalSort.equals(generalTermSort) ||
+				sort.equals(termSort) ||
+				sort.equals(generalTermSort.replace("*", "")) ||
+				sort.equals(generalTermSort) ||
+				generalSort.replace("*", "").equals(termSort) ||
+				generalSort.replace("*", "").equals(generalTermSort.replace("*", "")) ||
+				generalSort.replace("*", "").equals(generalTermSort);
+				
+		return hasCompatibleSort;
+	}
+
+	
+// constructors
+	
+	public static RecoverInterpretation createOriginalTermInterpretation(IStrategoTerm term, IStrategoTerm parentTerm){
+		return new RecoverInterpretation(term, parentTerm, true, null);
+		//Remark: recursively constructing original term recoveries for subterms seems not needed. 
+	}
+
+	public static RecoverInterpretation createDiscardInterpretation(IStrategoTerm term, IStrategoTerm parentTerm){
+		assert parentTerm.isList() || HelperFunctions.isSomeNode(term);
+		return new RecoverInterpretation(term, parentTerm, false, new ArrayList<RecoverInterpretation>());
+	}
+
+	public static RecoverInterpretation createRepairSubtermsInterpretation(IStrategoTerm term, IStrategoTerm parentTerm, ArrayList<RecoverInterpretation> recoveredSubterms){
+		assert recoveredSubterms.size() == term.getSubtermCount() && !recoveredSubterms.contains(null);
+		return new RecoverInterpretation(term, parentTerm, true, recoveredSubterms);
+	}
+
+	public static RecoverInterpretation createReplaceBySubtermsInterpretation(IStrategoTerm term, IStrategoTerm parentTerm, RecoverInterpretation recoveredSubterm){
+		assert recoveredSubterm.hasCompatibleSort(term, parentTerm);
+		ArrayList<RecoverInterpretation> subRecoveries = new ArrayList<RecoverInterpretation>();
+		subRecoveries.add(recoveredSubterm);
+		return createReplaceBySubtermsInterpretation(term, parentTerm, subRecoveries);
+	}
+
+	public static RecoverInterpretation createReplaceBySubtermsInterpretation(IStrategoTerm term, IStrategoTerm parentTerm, ArrayList<RecoverInterpretation> recoveredSubterms){
+		assert parentTerm.isList() || recoveredSubterms.size() == 1;
+		return new RecoverInterpretation(term, parentTerm, false, recoveredSubterms);
+	}
+
+	private RecoverInterpretation(
 			IStrategoTerm term, 
-			ArrayList<RecoverInterpretation> recoveredSubterms, 
-			ArrayList<Integer> deletionOffsets
+			IStrategoTerm parentTerm,
+			boolean isRecovered,
+			ArrayList<RecoverInterpretation> recoveredSubterms
 	) {
 		this.term = term;
-		this.coveredDeletionOffsets = getCoveredOffsets(term, deletionOffsets);
-		this.recoveredSubterms = recoveredSubterms;
+		this.parentTerm = parentTerm;
+		this.isRecovered = isRecovered;
+		this.subtermRecoveries = recoveredSubterms;
 		this.recoveryCosts = calculateRecoveryCosts(); 
 	}
 	
 //private functions
-
-	private static ArrayList<Integer> getCoveredOffsets(IStrategoTerm term, ArrayList<Integer> offsets) {
-		ArrayList<Integer> coveredOffsets = new ArrayList<Integer>();
-		int startOffset = getLeftToken(term).getStartOffset();
-		int endOffset = getRightToken(term).getEndOffset();
-		for (int i = 0; i < offsets.size(); i++) {
-			int offset = offsets.get(i); 
-			if(startOffset <= offset && offset <= endOffset){
-				//covered
-				coveredOffsets.add(offset);
-			}
-		}
-		return coveredOffsets;
-	}
 	
 	private int calculateRecoveryCosts(){
-		ArrayList<ArrayList<IStrategoTerm>>
-		int costs = numberOfNonLayoutTokens(this.getTerm()) - numberOfNonLayoutTokens(this.recoveredSubterms);
-		for (RecoverInterpretation subtermRecovery : recoveredSubterms) {
+		int costs = 0;
+		if(!isRecovered){
+			int nrOfNonLayoutInSubterms = 0;
+			for (RecoverInterpretation subtermRecovery : this.subtermRecoveries) {
+				nrOfNonLayoutInSubterms += numberOfNonLayoutTokens(subtermRecovery.getTerm());
+			}
+			costs = numberOfNonLayoutTokens(this.getTerm()) - nrOfNonLayoutInSubterms;
+		}
+		for (RecoverInterpretation subtermRecovery : subtermRecoveries) {
 			costs += subtermRecovery.getRecoveryCosts();
 		}
 		return costs;
 	}
 	
-	private int numberOfNonLayoutTokens(ArrayList<IStrategoTerm> terms) {
-		int result = 0;
-		for (IStrategoTerm recoveredTerm : terms) {
-			int nrOfNonLayoutTokens = numberOfNonLayoutTokens(recoveredTerm);
-			result += nrOfNonLayoutTokens;
-		}
-		return result;
-	}
-
 	private int numberOfNonLayoutTokens(IStrategoTerm term) {
 		ITokenizer tokens = getTokenizer(term);
 		int leftIndex =  getLeftToken(term).getIndex();

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java	Fri Aug  3 08:00:49 2012	(r25244)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java	Fri Aug  3 15:07:44 2012	(r25245)
@@ -1,118 +1,157 @@
 package org.spoofax.jsglr.client.editregion.detection;
 
+import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getLeftToken;
+import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getRightToken;
+
 import java.util.ArrayList;
 import java.util.HashMap;
 
-import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoTerm;
-import org.spoofax.jsglr.client.imploder.ITokenizer;
-import org.spoofax.jsglr.client.imploder.Token;
-
-import static org.spoofax.jsglr.client.imploder.ImploderAttachment.*;
-import sun.security.action.GetLongAction;
 
 public class TermEditsAnalyzer {
 	private ArrayList<Integer> offsetsDeletedChars;
 	private HashMap<IStrategoTerm, RecoverInterpretation> recoveryLookup;
 
-	public TermEditsAnalyzer(){
-		offsetsDeletedChars = new ArrayList<Integer>(); //TODO
+	public TermEditsAnalyzer(ArrayList<Integer> offsetsDeletedChars, IStrategoTerm correctAST){
+		this.offsetsDeletedChars = offsetsDeletedChars;
 		recoveryLookup = new HashMap<IStrategoTerm, RecoverInterpretation>();
+		collectRecoveries(correctAST, null);
+		RecoverInterpretation discardRecovery = recoveryLookup.get(correctAST); //TODO: if null, alltd look for regions in subterms
 	}
 	
-	private ArrayList<IStrategoTerm> findRecoveryTerms(IStrategoTerm term, IStrategoTerm parent){
-		if(isSomeNode(term)){
-			return new ArrayList<IStrategoTerm>();	//discarding whole term			
-		}
-		String generalSort = getGeneralSort(term, parent); //more universal sort, example: Blockstm vs Exprstm
-		String sort = getSort(term);
-		if(parent.isList()){
-			ArrayList<IStrategoTerm> replacementCandidates = getRecoveryFromSubterms(term, parent, sort, generalSort); 
-			//TODO: separators??
+	private void collectRecoveries(IStrategoTerm term, IStrategoTerm parent){
+		if(!hasDeletions(term)){
+			RecoverInterpretation originalTermRecovery = RecoverInterpretation.createOriginalTermInterpretation(term, parent);
+			recoveryLookup.put(term, originalTermRecovery); //we do not discard in unaffected terms.
+			return;
 		}
-
-		
-		return null;
+		for (int i = 0; i < term.getSubtermCount(); i++) {
+			collectRecoveries(term.getSubterm(i), term);
+		}
+		RecoverInterpretation recovery = constructMinimalCostRecovery(term, parent);		
+		recoveryLookup.put(term, recovery);
+	}
+	
+	private RecoverInterpretation constructMinimalCostRecovery(IStrategoTerm term, IStrategoTerm parent) {
+		//candidates can be null
+		RecoverInterpretation candidate1 = constructRepairSubtermsRecovery(term, parent);
+		RecoverInterpretation candidate2 = constructReplaceBySubtermsRecovery(term, parent);
+		RecoverInterpretation candidate3 = constructDiscardRecovery(term, parent);
+		ArrayList<RecoverInterpretation> candidates = new ArrayList<RecoverInterpretation>();
+		candidates.add(candidate1);
+		candidates.add(candidate2);
+		candidates.add(candidate3);
+		return getMinimumCostRecovery(candidates);
+	}
+	
+	private RecoverInterpretation constructRepairSubtermsRecovery(IStrategoTerm term, IStrategoTerm parent) {
+		if(hasAssociatedDeletions(term))
+			return null; //term itself is broken thus it can not be recovered by repairing subterms
+		ArrayList<RecoverInterpretation> subtermRecoveries = new ArrayList<RecoverInterpretation>();
+		for (int i = 0; i < term.getSubtermCount(); i++) {
+			IStrategoTerm subterm = term.getSubterm(i);
+			RecoverInterpretation subtermRecovery = recoveryLookup.get(subterm);
+			if(subtermRecovery == null){
+				return null; //subterm can not be recovered, thus term can not be recovered from its subterms
+			}
+		}
+		return RecoverInterpretation.createRepairSubtermsInterpretation(term, parent, subtermRecoveries);
 	}
 	
-	private ArrayList<IStrategoTerm> getRecoveryFromSubterms(IStrategoTerm term, IStrategoTerm parent, String sort, String generalSort) {
-		ArrayList<IStrategoTerm> result = new ArrayList<IStrategoTerm>();
+	private RecoverInterpretation constructDiscardRecovery(IStrategoTerm term, IStrategoTerm parent) {
+		if(HelperFunctions.isSomeNode(term) || (parent != null && parent.isList())){
+			return RecoverInterpretation.createDiscardInterpretation(term, parent);
+		}
+		return null;
+	}
+
+	private RecoverInterpretation constructReplaceBySubtermsRecovery(IStrategoTerm term, IStrategoTerm parent) {
+		return getRecoveryFromSubterms(term, term, parent);
+	}
 
-		//determines if the term has a compatible sort, which is a required to be a recover candidate,
-		//and determines if it has the same sort, which means that the already found recovery (if any) 
-		//is optimal, e.g., no need to traverse the subterms.
-		String generalTermSort = getGeneralSort(term, parent);
-		String termSort = getElementSort(term);
-		boolean hasCompatibleSort = 
-				generalSort.equals(generalTermSort) ||
-				generalSort.replace("*", "").equals(generalTermSort) ||
-				sort.equals(termSort);
-		boolean hasSameSort = generalSort == generalTermSort && sort == termSort; 
+	private RecoverInterpretation getRecoveryFromSubterms(IStrategoTerm visitedTerm, IStrategoTerm term, IStrategoTerm parent) {
+
+		//visited term may provide a candidate recovery
+		RecoverInterpretation candidateFromVisited = recoveryLookup.get(visitedTerm);
+		if(candidateFromVisited != null && candidateFromVisited.hasSameSort(term, parent)){
+			//optimal interpretation for the fragment already found, no need to further traverse subterms 
+			return RecoverInterpretation.createReplaceBySubtermsInterpretation(term, parent, candidateFromVisited);
+		}
 		
-		//terms of a compatible sort with a recover interpretation are candidates for recovery.
-		IStrategoTerm termCandidate = null;
-		if(hasCompatibleSort && hasRecoverInterpretation(term)){
-			termCandidate = term;
+		//traverse subterms of subterm
+		ArrayList<RecoverInterpretation> candidatesFromSubterms = new ArrayList<RecoverInterpretation> ();
+		for (int i = 0; i < visitedTerm.getSubtermCount(); i++) {
+			IStrategoTerm subterm = term.getSubterm(i);
+			RecoverInterpretation subtermRecovery = getRecoveryFromSubterms(subterm, term, parent);
+			if(subtermRecovery != null){
+				candidatesFromSubterms.add(subtermRecovery);
+				assert subtermRecovery.hasCompatibleSort(term, parent);
+			}
 		}
 		
-		//terms with the same sort (1), or terms that are not affected by editing (2) are not further inspected.
-		//1) already constructed recover interpretation is also the best interpretation for the current search, or
-		//2. we do not break interpretations that are not affected, e.g., outside the edit region. 
-		//thus, the candidate is the best recovery, or no recovery is found in this region.
-		if(hasSameSort || !hasDeletions(term)){
-			if(termCandidate != null){
-				result.add(termCandidate);
-				return result;
+		//non-list elements: pick best
+		//TODO: what if term is list, what about separators
+		if(!parent.isList()){
+			ArrayList<RecoverInterpretation> candidates = new ArrayList<RecoverInterpretation>();
+			if(candidateFromVisited != null && candidateFromVisited.hasCompatibleSort(term, parent)){
+				candidates.add(RecoverInterpretation.createReplaceBySubtermsInterpretation(term, parent, candidateFromVisited));
 			}
-			if(isSomeNode(term) || parent.isList()){
-				return new ArrayList<IStrategoTerm>(); //represents a full skip recovery, e.g., no sub-terms are preserved 
+			for (RecoverInterpretation subRecovery : candidatesFromSubterms) {
+				candidates.add(RecoverInterpretation.createReplaceBySubtermsInterpretation(term, parent, subRecovery));
 			}
-			return null; //region of term does not provide a recovery 
+			RecoverInterpretation minimumCostRecovery = getMinimumCostRecovery(candidates);
+			return RecoverInterpretation.createReplaceBySubtermsInterpretation(term, parent, minimumCostRecovery);
 		}
-
-		//recursively look for recover interpretations in subterms
-		ArrayList<IStrategoTerm> subtermCandidate = new ArrayList<IStrategoTerm>();
-		for (int i = 0; i < term.getSubtermCount(); i++) {
-			IStrategoTerm subterm = term.getSubterm(i);
-			ArrayList<IStrategoTerm> subtermRecovery = getRecoveryFromSubterms(subterm, term, sort, generalSort);
-			if(isListSort(generalSort)){// pick all compatible sub terms for elements in a list (which can be recovered by multiple elements)
-				subtermCandidate.addAll(subtermRecovery);
-			}
-			else { //pick the best recovery for non list terms
-				subtermCandidate = getMinimumCostRecovery(subtermCandidate, subtermRecovery);
+		else { //parent is list
+			RecoverInterpretation fromSubtermsRecovery = RecoverInterpretation.createReplaceBySubtermsInterpretation(term, parent, candidatesFromSubterms);
+			if(candidateFromVisited != null && candidateFromVisited.hasCompatibleSort(term, parent)){
+				RecoverInterpretation fromVisistedRecovery = RecoverInterpretation.createReplaceBySubtermsInterpretation(term, parent, candidateFromVisited);
+				return this.getMinimumCostRecovery(fromSubtermsRecovery, fromVisistedRecovery);				
 			}
+			return fromSubtermsRecovery;
 		}
-		
-		
 	}
 
-	private ArrayList<IStrategoTerm> getMinimumCostRecovery(RecoverInterpretation recovery1, RecoverInterpretation recovery2) {
-		//TODO
-		int recoverCost1 = 0;
-		for (IStrategoTerm term : recovery1) {
-			ArrayList<IStrategoTerm> recoveredTerms = this.recoveryLookup.get(term);
-			int recoverCostTerm = getRecoverCost(recoveredTerms);
+	private RecoverInterpretation getMinimumCostRecovery(ArrayList<RecoverInterpretation> recoveries) {
+		RecoverInterpretation minimumCostInterpretation = null;
+		for (RecoverInterpretation recovery : recoveries) {
+			minimumCostInterpretation = getMinimumCostRecovery(minimumCostInterpretation, recovery);
 		}
-		return null;
+		return minimumCostInterpretation;
 	}
 
-
-	public boolean isListSort(String sort) {
-		return sort.endsWith("*");
+	private RecoverInterpretation getMinimumCostRecovery(RecoverInterpretation recovery1, RecoverInterpretation recovery2) {
+		if(recovery2 == null)
+			return recovery1;
+		if(recovery1 == null)
+			return recovery2;
+		if(recovery2.getRecoveryCosts() < recovery1.getRecoveryCosts()){
+			return recovery2;
+		}
+		return recovery1;
 	}
 
-	public String getGeneralSort(IStrategoTerm term, IStrategoTerm parent) {
-		String termSort = ImploderAttachment.getElementSort(term);
-		if(parent.isList())
-			termSort = ImploderAttachment.getElementSort(parent);
-		assert (term.isList() || parent.isList())? termSort.endsWith("*") : !termSort.endsWith("*");
-		return termSort;
-	}
+
 
 	private boolean hasDeletions(IStrategoTerm term) {
 		return !getCoveredOffsets(term, this.offsetsDeletedChars).isEmpty();
 	}
 
+	private boolean hasAssociatedDeletions(IStrategoTerm term) {
+		return !getAssociatedCoveredOffsets(term, this.offsetsDeletedChars).isEmpty();
+	}
+
+
+	private static ArrayList<Integer> getAssociatedCoveredOffsets(IStrategoTerm term, ArrayList<Integer> offsets) {
+		ArrayList<Integer> associatedCoveredOffsets = getCoveredOffsets(term, offsets);
+		for (int i = 0; i < term.getSubtermCount(); i++) {
+			IStrategoTerm subterm = term.getSubterm(i);
+			ArrayList<Integer> subtermOffsets = getCoveredOffsets(subterm, offsets);
+			associatedCoveredOffsets.removeAll(subtermOffsets);
+		}
+		return associatedCoveredOffsets;
+	}
+
 	private static ArrayList<Integer> getCoveredOffsets(IStrategoTerm term, ArrayList<Integer> offsets) {
 		ArrayList<Integer> coveredOffsets = new ArrayList<Integer>();
 		int startOffset = getLeftToken(term).getStartOffset();
@@ -126,18 +165,4 @@
 		}
 		return coveredOffsets;
 	}
-
-
-	public boolean hasRecoverInterpretation(IStrategoTerm term) {
-		return recoveryLookup.containsKey(term);
-	}
-
-	private boolean isSomeNode(IStrategoTerm trm) {
-		if(trm.getTermType() == IStrategoTerm.APPL){
-			return trm.getSubtermCount() == 1 && ((IStrategoAppl)trm).getConstructor().getName().equals("Some");
-		}
-		return false;
-	}
-
-
 }

From m.dejonge at tudelft.nl  Fri Aug  3 18:31:52 2012
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Fri, 03 Aug 2012 16:31:52 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25246 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection
Message-ID: <20120803163152.24EB02B8011@mx2.tudelft.nl>

Author: MaartjeDeJonge
Date: Fri Aug  3 16:31:50 2012
New Revision: 25246
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25246&sc=1

Log:


Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java	Fri Aug  3 15:07:44 2012	(r25245)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java	Fri Aug  3 16:31:50 2012	(r25246)
@@ -149,5 +149,49 @@
 		}
 		return nrOfNonLayoutTokens;
 	}
+	
+	public ArrayList<DiscardableRegion> getDamagedRegions(){		
+		if(this.getSubtermRecoveries() == null){ //trivial recovery (no damage)
+			return new ArrayList<DiscardableRegion>(); 
+		}
+		else if(isRecovered){ //only damage in tokens associated to subterms 
+			ArrayList<DiscardableRegion> damagedRegions = new ArrayList<DiscardableRegion>();
+			for (RecoverInterpretation subtermRecovery : getSubtermRecoveries()) {
+				damagedRegions.addAll(subtermRecovery.getDamagedRegions());
+			}
+			return damagedRegions; 
+		}
+		else { //damage in tokens associated to term
+			return getDamagedRegionsForAffectedTerm();
+		}
+	}
 
+	private ArrayList<DiscardableRegion> getDamagedRegionsForAffectedTerm() {
+		ArrayList<DiscardableRegion> damagedRegions = new ArrayList<DiscardableRegion>();
+		int startOffset = getLeftToken(term).getStartOffset();
+		for (int i = 0; i < getSubtermRecoveries().size(); i++) {
+			RecoverInterpretation subtermRecovery = getSubtermRecoveries().get(i);
+			int endOffset = getLeftToken(subtermRecovery.getTerm()).getStartOffset()-1;
+			if(startOffset <= endOffset){ //discard tokens associated to term
+				DiscardableRegion region = new DiscardableRegion(startOffset, endOffset, getTerm());
+				damagedRegions.add(region);
+			}
+			damagedRegions.addAll(subtermRecovery.getDamagedRegions()); //collect damaged regions in subterm
+			startOffset = getRightToken(subtermRecovery.getTerm()).getEndOffset() + 1;
+		}
+		int endOffset = getRightToken(term).getEndOffset();
+		if(startOffset <= endOffset){ //discard suffix tokens associated to term
+			DiscardableRegion damagedRegion = new DiscardableRegion(startOffset, endOffset, getTerm());
+			damagedRegions.add(damagedRegion);
+		}
+		return damagedRegions;
+	}
 }
+
+
+
+
+
+
+
+

From m.dejonge at tudelft.nl  Fri Aug  3 21:47:44 2012
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Fri, 03 Aug 2012 19:47:44 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25247 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection
Message-ID: <20120803194744.EA77A108C00C@mx3.tudelft.nl>

Author: MaartjeDeJonge
Date: Fri Aug  3 19:47:43 2012
New Revision: 25247
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25247&sc=1

Log:


Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/HelperFunctions.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java	Fri Aug  3 16:31:50 2012	(r25246)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java	Fri Aug  3 19:47:43 2012	(r25247)
@@ -178,8 +178,12 @@
 		terminalAnalyzer.addDamagedTokensStartOffsets(offsetsDeletedChars);
 
 		//detects discardable regions that correspond to edited terms.
-		NonTerminalEditsAnalyzer brokenConstructDetector = new NonTerminalEditsAnalyzer(correctAST, offsetsDeletedChars);
-		this.discardableRegions = brokenConstructDetector.getDamagedTermRegions();
+		//NonTerminalEditsAnalyzer brokenConstructDetector = new NonTerminalEditsAnalyzer(correctAST, offsetsDeletedChars);
+		//this.discardableRegions = brokenConstructDetector.getDamagedTermRegions();
+		
+		//detects discardable regions that correspond to edited terms.
+		TermEditsAnalyzer brokenConstructDetector = new TermEditsAnalyzer(offsetsDeletedChars, correctAST);
+		this.discardableRegions = brokenConstructDetector.getDamagedTermRegions();		
 	}
 	
 

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/HelperFunctions.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/HelperFunctions.java	Fri Aug  3 16:31:50 2012	(r25246)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/HelperFunctions.java	Fri Aug  3 19:47:43 2012	(r25247)
@@ -1,6 +1,6 @@
 package org.spoofax.jsglr.client.editregion.detection;
 
-import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getElementSort;
+import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getSort;
 
 import java.util.List;
 
@@ -31,10 +31,10 @@
 	}
 
 	public static String getGeneralSort(IStrategoTerm term, IStrategoTerm parent) {
-		String termSort = getElementSort(term);
+		String termSort = getSort(term);
 		if(parent != null){
 			if(parent.isList())
-				termSort = getElementSort(parent);
+				termSort = getSort(parent);
 			assert (term.isList() || parent.isList())? termSort.endsWith("*") : !termSort.endsWith("*");
 		}
 		return termSort;

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java	Fri Aug  3 16:31:50 2012	(r25246)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java	Fri Aug  3 19:47:43 2012	(r25247)
@@ -1,6 +1,5 @@
 package org.spoofax.jsglr.client.editregion.detection;
 
-import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getElementSort;
 import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getLeftToken;
 import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getRightToken;
 import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getTokenizer;
@@ -9,6 +8,7 @@
 
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.jsglr.client.imploder.ITokenizer;
+import org.spoofax.jsglr.client.imploder.ImploderAttachment;
 import org.spoofax.jsglr.client.imploder.Token;
 
 public class RecoverInterpretation {
@@ -47,12 +47,12 @@
 	}
 
 	public String getSort(){
-		return getElementSort(term);
+		return ImploderAttachment.getSort(term);
 	}
 	
 	public boolean hasSameSort(IStrategoTerm term, IStrategoTerm parent) {
 		String generalSort = HelperFunctions.getGeneralSort(term, parent);
-		String sort = getElementSort(term);
+		String sort = ImploderAttachment.getSort(term);
 		String generalTermSort = this.getGeneralSort();
 		String termSort = this.getSort();		
 		return generalSort == generalTermSort && sort == termSort;
@@ -60,7 +60,7 @@
 
 	public boolean hasCompatibleSort(IStrategoTerm term, IStrategoTerm parent) {
 		String generalSort = HelperFunctions.getGeneralSort(term, parent);
-		String sort = getElementSort(term);
+		String sort = ImploderAttachment.getSort(term);
 		String generalTermSort = this.getGeneralSort();
 		String termSort = this.getSort();
 		boolean hasCompatibleSort = 
@@ -117,13 +117,29 @@
 		this.parentTerm = parentTerm;
 		this.isRecovered = isRecovered;
 		this.subtermRecoveries = recoveredSubterms;
-		this.recoveryCosts = calculateRecoveryCosts(); 
+		this.recoveryCosts = calculateRecoveryCosts();
+		checkAssertions();
+	}
+
+	private void checkAssertions() {
+		assert subtermRecoveries == null? (isRecovered && this.recoveryCosts == 0) : recoveryCosts > 0;
+		int subtermCosts = 0;
+		if(this.subtermRecoveries != null){
+			for (RecoverInterpretation subtermRecovery : this.subtermRecoveries) {
+				assert subtermRecovery != null;	
+				subtermCosts += subtermRecovery.getRecoveryCosts();
+			}
+		}
+		assert isRecovered? recoveryCosts == subtermCosts : recoveryCosts > subtermCosts;
 	}
 	
 //private functions
 	
 	private int calculateRecoveryCosts(){
 		int costs = 0;
+		if(subtermRecoveries == null){
+			return 0;			
+		}
 		if(!isRecovered){
 			int nrOfNonLayoutInSubterms = 0;
 			for (RecoverInterpretation subtermRecovery : this.subtermRecoveries) {

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java	Fri Aug  3 16:31:50 2012	(r25246)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java	Fri Aug  3 19:47:43 2012	(r25247)
@@ -5,23 +5,37 @@
 
 import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.IdentityHashMap;
 
 import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.jsglr.client.imploder.ImploderAttachment;
 
 public class TermEditsAnalyzer {
-	private ArrayList<Integer> offsetsDeletedChars;
-	private HashMap<IStrategoTerm, RecoverInterpretation> recoveryLookup;
+	private final IStrategoTerm correctAST;
+	private final ArrayList<Integer> offsetsDeletedChars;
+	private final IdentityHashMap<IStrategoTerm, RecoverInterpretation> recoveryLookup;
 
 	public TermEditsAnalyzer(ArrayList<Integer> offsetsDeletedChars, IStrategoTerm correctAST){
 		this.offsetsDeletedChars = offsetsDeletedChars;
-		recoveryLookup = new HashMap<IStrategoTerm, RecoverInterpretation>();
+		this.recoveryLookup = new IdentityHashMap<IStrategoTerm, RecoverInterpretation>();
+		this.correctAST = correctAST;
+	}
+	
+	/**
+	 * Returns discardable regions that are edited 
+	 */
+	public ArrayList<DiscardableRegion> getDamagedTermRegions(){
+		recoveryLookup.clear();
 		collectRecoveries(correctAST, null);
 		RecoverInterpretation discardRecovery = recoveryLookup.get(correctAST); //TODO: if null, alltd look for regions in subterms
+		assert discardRecovery == null || discardRecovery.getTerm() == correctAST;
+		return discardRecovery.getDamagedRegions();
 	}
-	
+
 	private void collectRecoveries(IStrategoTerm term, IStrategoTerm parent){
 		if(!hasDeletions(term)){
 			RecoverInterpretation originalTermRecovery = RecoverInterpretation.createOriginalTermInterpretation(term, parent);
+			assert recoveryLookup.get(term) == null;
 			recoveryLookup.put(term, originalTermRecovery); //we do not discard in unaffected terms.
 			return;
 		}
@@ -54,6 +68,8 @@
 			if(subtermRecovery == null){
 				return null; //subterm can not be recovered, thus term can not be recovered from its subterms
 			}
+			assert subterm == subtermRecovery.getTerm();
+			subtermRecoveries.add(subtermRecovery);
 		}
 		return RecoverInterpretation.createRepairSubtermsInterpretation(term, parent, subtermRecoveries);
 	}
@@ -66,13 +82,16 @@
 	}
 
 	private RecoverInterpretation constructReplaceBySubtermsRecovery(IStrategoTerm term, IStrategoTerm parent) {
+		System.out.println("recover: " + term);
 		return getRecoveryFromSubterms(term, term, parent);
 	}
 
 	private RecoverInterpretation getRecoveryFromSubterms(IStrategoTerm visitedTerm, IStrategoTerm term, IStrategoTerm parent) {
+		System.out.println("    visited: " + visitedTerm);
 
 		//visited term may provide a candidate recovery
 		RecoverInterpretation candidateFromVisited = recoveryLookup.get(visitedTerm);
+		assert candidateFromVisited == null || candidateFromVisited.getTerm() == visitedTerm;
 		if(candidateFromVisited != null && candidateFromVisited.hasSameSort(term, parent)){
 			//optimal interpretation for the fragment already found, no need to further traverse subterms 
 			return RecoverInterpretation.createReplaceBySubtermsInterpretation(term, parent, candidateFromVisited);
@@ -81,7 +100,7 @@
 		//traverse subterms of subterm
 		ArrayList<RecoverInterpretation> candidatesFromSubterms = new ArrayList<RecoverInterpretation> ();
 		for (int i = 0; i < visitedTerm.getSubtermCount(); i++) {
-			IStrategoTerm subterm = term.getSubterm(i);
+			IStrategoTerm subterm = visitedTerm.getSubterm(i);
 			RecoverInterpretation subtermRecovery = getRecoveryFromSubterms(subterm, term, parent);
 			if(subtermRecovery != null){
 				candidatesFromSubterms.add(subtermRecovery);
@@ -100,10 +119,16 @@
 				candidates.add(RecoverInterpretation.createReplaceBySubtermsInterpretation(term, parent, subRecovery));
 			}
 			RecoverInterpretation minimumCostRecovery = getMinimumCostRecovery(candidates);
-			return RecoverInterpretation.createReplaceBySubtermsInterpretation(term, parent, minimumCostRecovery);
+			if(minimumCostRecovery != null)
+				return RecoverInterpretation.createReplaceBySubtermsInterpretation(term, parent, minimumCostRecovery);
+			return null;
 		}
 		else { //parent is list
-			RecoverInterpretation fromSubtermsRecovery = RecoverInterpretation.createReplaceBySubtermsInterpretation(term, parent, candidatesFromSubterms);
+			ArrayList<RecoverInterpretation> mergedSubtermRecoveries = new ArrayList<RecoverInterpretation>();
+			for (int i = 0; i < candidatesFromSubterms.size(); i++) {
+				mergedSubtermRecoveries.addAll(candidatesFromSubterms.get(i).getSubtermRecoveries());
+			}
+			RecoverInterpretation fromSubtermsRecovery = RecoverInterpretation.createReplaceBySubtermsInterpretation(term, parent, mergedSubtermRecoveries);
 			if(candidateFromVisited != null && candidateFromVisited.hasCompatibleSort(term, parent)){
 				RecoverInterpretation fromVisistedRecovery = RecoverInterpretation.createReplaceBySubtermsInterpretation(term, parent, candidateFromVisited);
 				return this.getMinimumCostRecovery(fromSubtermsRecovery, fromVisistedRecovery);				

From m.dejonge at tudelft.nl  Fri Aug  3 22:35:17 2012
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Fri, 03 Aug 2012 20:35:17 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25248 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection
Message-ID: <20120803203517.5DE67CC1AD@mx4.tudelft.nl>

Author: MaartjeDeJonge
Date: Fri Aug  3 20:35:17 2012
New Revision: 25248
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25248&sc=1

Log:


Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java	Fri Aug  3 19:47:43 2012	(r25247)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java	Fri Aug  3 20:35:17 2012	(r25248)
@@ -130,7 +130,7 @@
 				subtermCosts += subtermRecovery.getRecoveryCosts();
 			}
 		}
-		assert isRecovered? recoveryCosts == subtermCosts : recoveryCosts > subtermCosts;
+		assert isRecovered? recoveryCosts == subtermCosts : recoveryCosts >= subtermCosts;
 	}
 	
 //private functions
@@ -202,6 +202,10 @@
 		}
 		return damagedRegions;
 	}
+
+	public boolean isUndamagedTerm() {
+		return getSubtermRecoveries() == null;
+	}
 }
 
 

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java	Fri Aug  3 19:47:43 2012	(r25247)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java	Fri Aug  3 20:35:17 2012	(r25248)
@@ -96,6 +96,9 @@
 			//optimal interpretation for the fragment already found, no need to further traverse subterms 
 			return RecoverInterpretation.createReplaceBySubtermsInterpretation(term, parent, candidateFromVisited);
 		}
+		if(candidateFromVisited != null && candidateFromVisited.isUndamagedTerm()){
+			return null;
+		}
 		
 		//traverse subterms of subterm
 		ArrayList<RecoverInterpretation> candidatesFromSubterms = new ArrayList<RecoverInterpretation> ();
@@ -110,7 +113,7 @@
 		
 		//non-list elements: pick best
 		//TODO: what if term is list, what about separators
-		if(!parent.isList()){
+		if(parent == null || !parent.isList()){
 			ArrayList<RecoverInterpretation> candidates = new ArrayList<RecoverInterpretation>();
 			if(candidateFromVisited != null && candidateFromVisited.hasCompatibleSort(term, parent)){
 				candidates.add(RecoverInterpretation.createReplaceBySubtermsInterpretation(term, parent, candidateFromVisited));

From m.dejonge at tudelft.nl  Fri Aug  3 22:43:28 2012
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Fri, 03 Aug 2012 20:43:28 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25249 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test
Message-ID: <20120803204328.B642B2B8031@mx2.tudelft.nl>

Author: MaartjeDeJonge
Date: Fri Aug  3 20:43:28 2012
New Revision: 25249
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25249&sc=1

Log:


Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionBasic.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionInsertonsInToken.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionMisc.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionNestedListElems.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionOperators.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionSeparators.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionBasic.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionBasic.java	Fri Aug  3 20:35:17 2012	(r25248)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionBasic.java	Fri Aug  3 20:43:28 2012	(r25249)
@@ -1,9 +1,10 @@
 package org.spoofax.jsglr.client.editregion.test;
 
-import junit.framework.Assert;
 import java.io.IOException;
 import java.util.ArrayList;
 
+import junit.framework.Assert;
+
 import org.junit.Test;
 import org.spoofax.jsglr.client.InvalidParseTableException;
 import org.spoofax.jsglr.client.ParseException;
@@ -23,8 +24,8 @@
 		String erroneousInput = loadAsString(pathToErroneousFile);
 		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
 		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
-		Assert.assertEquals("if(v > 5){\n\t\t", concatenated);
 		super.parseString(editRegionRecovery.getRecoveredInput());
+		Assert.assertEquals("if(v > 5){\n\t\t", concatenated);
 	}
 
 	@Test
@@ -33,8 +34,8 @@
 		String erroneousInput = loadAsString(pathToErroneousFile);
 		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
 		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
-		Assert.assertEquals("v+=\n\t\t", concatenated);
 		super.parseString(editRegionRecovery.getRecoveredInput());
+		Assert.assertEquals("v+=\n\t\t", concatenated);
 	}
 
 	@Test
@@ -45,8 +46,8 @@
 		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
 		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
 		//Assert.assertEquals("package \n\t\t= 10;\n\t\tSystem..println(v);", concatenated);
-		Assert.assertEquals("package = .", concatenated);
 		super.parseString(editRegionRecovery.getRecoveredInput());
+		Assert.assertEquals("package = .", concatenated);
 	}
 
 	@Test
@@ -55,8 +56,8 @@
 		String erroneousInput = loadAsString(pathToErroneousFile);
 		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
 		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
-		Assert.assertEquals("private void m(int x, int y, int z{\n		int v = 10;\n		v+= \n		System.out.println(v);\n	}", concatenated);
 		super.parseString(editRegionRecovery.getRecoveredInput());
+		Assert.assertEquals("private void m(int x, int y, int z{\n		int v = 10;\n		v+= \n		System.out.println(v);\n	}", concatenated);
 	}
 
 	@Test
@@ -65,9 +66,9 @@
 		String erroneousInput = loadAsString(pathToErroneousFile);
 		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
 		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
+		super.parseString(editRegionRecovery.getRecoveredInput());
 		Assert.assertEquals(" + 5 +\n\t\tSystem.out.println(v", concatenated);
 		//System.out.println(editRegionRecovery.getRecoveredInput());
-		super.parseString(editRegionRecovery.getRecoveredInput());
 	}
 
 	@Test
@@ -76,11 +77,11 @@
 		String erroneousInput = loadAsString(pathToErroneousFile);
 		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
 		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
+		super.parseString(editRegionRecovery.getRecoveredInput());
 		Assert.assertEquals("v = v +;\n\t\t", concatenated);
 		Assert.assertEquals(127, editRegionRecovery.getCorrectInput().length());
 		Assert.assertEquals(128, editRegionRecovery.getErroneousInput().length());
 		Assert.assertEquals(128, editRegionRecovery.getRecoveredInput().length());
-		super.parseString(editRegionRecovery.getRecoveredInput());
 	}
 
 	@Test
@@ -89,8 +90,8 @@
 		String erroneousInput = loadAsString(pathToErroneousFile);
 		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
 		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
-		Assert.assertEquals("private void m(int x, int y, int z{\n		int v = 10;\n		v+= 10;\n		print(\n		System.out.println(v);\n	}", concatenated);
 		super.parseString(editRegionRecovery.getRecoveredInput());
+		Assert.assertEquals("private void m(int x, int y, int z{\n		int v = 10;\n		v+= 10;\n		print(\n		System.out.println(v);\n	}", concatenated);
 	}
 
 }

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionInsertonsInToken.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionInsertonsInToken.java	Fri Aug  3 20:35:17 2012	(r25248)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionInsertonsInToken.java	Fri Aug  3 20:43:28 2012	(r25249)
@@ -24,8 +24,8 @@
 		String erroneousInput = loadAsString(pathToErroneousFile);
 		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
 		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
-		Assert.assertEquals("\n\t\tSys tem.out.println(v);", concatenated); 
 		super.parseString(editRegionRecovery.getRecoveredInput());
+		Assert.assertEquals("\n\t\tSys tem.out.println(v);", concatenated); 
 	}
 
 	@Test
@@ -34,8 +34,8 @@
 		String erroneousInput = loadAsString(pathToErroneousFile);
 		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
 		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
-		Assert.assertEquals("\n\t\tSysttem.out.println(v);", concatenated); 
 		super.parseString(editRegionRecovery.getRecoveredInput());
+		Assert.assertEquals("\n\t\tSysttem.out.println(v);", concatenated); 
 	}
 
 	@Test
@@ -44,8 +44,8 @@
 		String erroneousInput = loadAsString(pathToErroneousFile);
 		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
 		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
-		Assert.assertEquals("x", concatenated); 
 		super.parseString(editRegionRecovery.getRecoveredInput());
+		Assert.assertEquals("x", concatenated); 
 	}
 
 	@Test
@@ -54,8 +54,8 @@
 		String erroneousInput = loadAsString(pathToErroneousFile);
 		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
 		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
-		Assert.assertEquals("\n\t\tSys-tem.out.println(v);", concatenated); 
 		super.parseString(editRegionRecovery.getRecoveredInput());
+		Assert.assertEquals("\n\t\tSys-tem.out.println(v);", concatenated); 
 	}
 
 	@Test
@@ -64,7 +64,7 @@
 		String erroneousInput = loadAsString(pathToErroneousFile);
 		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
 		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
-		Assert.assertEquals("/ *mmmm*/", concatenated); 
 		super.parseString(editRegionRecovery.getRecoveredInput());
+		Assert.assertEquals("/ *mmmm*/", concatenated); 
 	}
 }

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionMisc.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionMisc.java	Fri Aug  3 20:35:17 2012	(r25248)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionMisc.java	Fri Aug  3 20:43:28 2012	(r25249)
@@ -25,8 +25,8 @@
 		String erroneousInput = loadAsString(pathToErroneousFile);
 		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
 		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
-		Assert.assertEquals(88, concatenated.length());
 		super.parseString(editRegionRecovery.getRecoveredInput());
+		Assert.assertEquals(88, concatenated.length());
 	}
 
 	@Test

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionNestedListElems.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionNestedListElems.java	Fri Aug  3 20:35:17 2012	(r25248)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionNestedListElems.java	Fri Aug  3 20:43:28 2012	(r25249)
@@ -22,31 +22,31 @@
 	public void testDeletionInParentElem1() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
 		String expectedConcatenatedDiscards = "@@";
 		String pathToErroneousFile = pathToJavaTestInputs + "/deletion-in-parent-elem1.java";
-		testDiscardedCharacters(expectedConcatenatedDiscards, pathToErroneousFile);
 		super.parseString(editRegionRecovery.getRecoveredInput());
+		testDiscardedCharacters(expectedConcatenatedDiscards, pathToErroneousFile);
 	}
 
 	@Ignore @Test
 	public void testDeletionInParentElem2() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
 		String expectedConcatenatedDiscards = "@@";
 		String pathToErroneousFile = pathToJavaTestInputs + "/deletion-in-parent-elem2.java";
-		testDiscardedCharacters(expectedConcatenatedDiscards, pathToErroneousFile);
 		super.parseString(editRegionRecovery.getRecoveredInput());
+		testDiscardedCharacters(expectedConcatenatedDiscards, pathToErroneousFile);
 	}
 
 	@Ignore @Test
 	public void testDeletionInParentElem3() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
 		String expectedConcatenatedDiscards = "@@";
 		String pathToErroneousFile = pathToJavaTestInputs + "/deletion-in-parent-elem3.java";
-		testDiscardedCharacters(expectedConcatenatedDiscards, pathToErroneousFile);
 		super.parseString(editRegionRecovery.getRecoveredInput());
+		testDiscardedCharacters(expectedConcatenatedDiscards, pathToErroneousFile);
 	}
 
 	@Ignore @Test
 	public void testDeletionInParentElem4() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
 		String expectedConcatenatedDiscards = "@@";
 		String pathToErroneousFile = pathToJavaTestInputs + "/deletion-in-parent-elem4.java";
-		testDiscardedCharacters(expectedConcatenatedDiscards, pathToErroneousFile);
 		super.parseString(editRegionRecovery.getRecoveredInput());
+		testDiscardedCharacters(expectedConcatenatedDiscards, pathToErroneousFile);
 	}
 }

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionOperators.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionOperators.java	Fri Aug  3 20:35:17 2012	(r25248)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionOperators.java	Fri Aug  3 20:43:28 2012	(r25249)
@@ -89,8 +89,8 @@
 		String pathToErroneousFile = pathToJavaTestInputs + "/delete-multiple-operands.java";
 		String erroneousInput = loadAsString(pathToErroneousFile);
 		ArrayList<Integer> discardOffsets = getDiscardOffsets(lastErr0AST, erroneousInput);
-		Assert.assertTrue(discardOffsets.size() < 20);
 		super.parseString(editRegionRecovery.getRecoveredInput());
+		Assert.assertTrue(discardOffsets.size() < 20);
 	}
 
 }

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionSeparators.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionSeparators.java	Fri Aug  3 20:35:17 2012	(r25248)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionSeparators.java	Fri Aug  3 20:43:28 2012	(r25249)
@@ -24,8 +24,8 @@
 		String erroneousInput = loadAsString(pathToErroneousFile);
 		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
 		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
-		Assert.assertEquals("int y ", concatenated);
 		super.parseString(editRegionRecovery.getRecoveredInput());
+		Assert.assertEquals("int y ", concatenated);
 	}
 	
 	@Test
@@ -34,8 +34,8 @@
 		String erroneousInput = loadAsString(pathToErroneousFile);
 		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
 		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
-		Assert.assertEquals(", ", concatenated);
 		super.parseString(editRegionRecovery.getRecoveredInput());
+		Assert.assertEquals(", ", concatenated);
 	}
 	
 	@Test
@@ -44,8 +44,8 @@
 		String erroneousInput = loadAsString(pathToErroneousFile);
 		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
 		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
-		Assert.assertEquals(", ", concatenated);
 		super.parseString(editRegionRecovery.getRecoveredInput());
+		Assert.assertEquals(", ", concatenated);
 	}
 
 	@Test
@@ -54,8 +54,8 @@
 		String erroneousInput = loadAsString(pathToErroneousFile);
 		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
 		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
-		Assert.assertEquals(", z", concatenated);
 		super.parseString(editRegionRecovery.getRecoveredInput());
+		Assert.assertEquals(", z", concatenated);
 	}
 
 	@Test
@@ -64,9 +64,9 @@
 		String erroneousInput = loadAsString(pathToErroneousFile);
 		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
 		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
+		super.parseString(editRegionRecovery.getRecoveredInput());
 		Assert.assertEquals(" z", concatenated); //TODO: not needed to remove 'int y' if ', int z' is affected.
 		System.out.println(editRegionRecovery.getRecoveredInput());
-		super.parseString(editRegionRecovery.getRecoveredInput());
 	}
 
 }

From m.dejonge at tudelft.nl  Sat Aug  4 17:10:21 2012
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Sat, 04 Aug 2012 15:10:21 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25250 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection
Message-ID: <20120804151021.A68BA7F8003@mx1.tudelft.nl>

Author: MaartjeDeJonge
Date: Sat Aug  4 15:10:19 2012
New Revision: 25250
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25250&sc=1

Log:


Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java	Fri Aug  3 20:43:28 2012	(r25249)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java	Sat Aug  4 15:10:19 2012	(r25250)
@@ -49,6 +49,9 @@
 	private RecoverInterpretation constructMinimalCostRecovery(IStrategoTerm term, IStrategoTerm parent) {
 		//candidates can be null
 		RecoverInterpretation candidate1 = constructRepairSubtermsRecovery(term, parent);
+		if(!hasAssociatedDeletions(term) && term.isList()){
+			return candidate1;
+		}
 		RecoverInterpretation candidate2 = constructReplaceBySubtermsRecovery(term, parent);
 		RecoverInterpretation candidate3 = constructDiscardRecovery(term, parent);
 		ArrayList<RecoverInterpretation> candidates = new ArrayList<RecoverInterpretation>();
@@ -82,12 +85,12 @@
 	}
 
 	private RecoverInterpretation constructReplaceBySubtermsRecovery(IStrategoTerm term, IStrategoTerm parent) {
-		System.out.println("recover: " + term);
+		//System.out.println("recover: " + term);
 		return getRecoveryFromSubterms(term, term, parent);
 	}
 
 	private RecoverInterpretation getRecoveryFromSubterms(IStrategoTerm visitedTerm, IStrategoTerm term, IStrategoTerm parent) {
-		System.out.println("    visited: " + visitedTerm);
+		//System.out.println("    visited: " + visitedTerm);
 
 		//visited term may provide a candidate recovery
 		RecoverInterpretation candidateFromVisited = recoveryLookup.get(visitedTerm);
@@ -97,6 +100,9 @@
 			return RecoverInterpretation.createReplaceBySubtermsInterpretation(term, parent, candidateFromVisited);
 		}
 		if(candidateFromVisited != null && candidateFromVisited.isUndamagedTerm()){
+			if(candidateFromVisited.hasCompatibleSort(term, parent)){
+				return RecoverInterpretation.createReplaceBySubtermsInterpretation(term, parent, candidateFromVisited);
+			}
 			return null;
 		}
 		

From m.dejonge at tudelft.nl  Sat Aug  4 17:47:44 2012
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Sat, 04 Aug 2012 15:47:44 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25251 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection
Message-ID: <20120804154744.C7DB8108C003@mx3.tudelft.nl>

Author: MaartjeDeJonge
Date: Sat Aug  4 15:47:44 2012
New Revision: 25251
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25251&sc=1

Log:


Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DiscardableRegion.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DiscardableRegion.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DiscardableRegion.java	Sat Aug  4 15:10:19 2012	(r25250)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DiscardableRegion.java	Sat Aug  4 15:47:44 2012	(r25251)
@@ -1,5 +1,8 @@
 package org.spoofax.jsglr.client.editregion.detection;
 
+import java.util.ArrayList;
+import java.util.Collections;
+
 import org.spoofax.interpreter.terms.IStrategoTerm;
 
 /**
@@ -49,4 +52,60 @@
 		assert(!affectedTerm.isList()): "Individual list elements are prefered over full lists";
 		return affectedTerm;
 	}
+	
+	public static String replaceAllRegionsByWhitespace(ArrayList<DiscardableRegion> regions, String input) {
+		String result = input;
+		for (DiscardableRegion region : regions) {
+			result = replaceRegionByWhitespace(region, result);
+		}
+		return result;
+	}
+	
+	private static String replaceRegionByWhitespace(DiscardableRegion region, String input) {
+		char[] chars = input.toCharArray();
+		for (int offset = region.getStartOffset(); offset <= region.getEndOffset(); offset++) {
+			char charAtOffset = chars[offset];
+			if(!Character.isWhitespace(charAtOffset)){
+				chars[offset] = ' ';
+			}
+		}
+		return String.valueOf(chars);
+	}
+	
+	public static ArrayList<DiscardableRegion> constructRegionsFromOffsets(ArrayList<Integer> offsets){
+		ArrayList<DiscardableRegion> result = new ArrayList<DiscardableRegion>();
+		int startOffset = -1;
+		for (int i = 0; i < offsets.size(); i++) {
+			int offset = offsets.get(i);
+			if(i==0){
+				startOffset = offsets.get(i);
+			}
+			else if (offset != offsets.get(i-1) + 1){
+				DiscardableRegion region = new DiscardableRegion(startOffset, offsets.get(i-1), null);
+				result.add(region);
+				startOffset = offsets.get(i);
+			}
+		}
+		if(startOffset != -1){
+			DiscardableRegion region = new DiscardableRegion(startOffset, offsets.get(offsets.size()-1), null);
+			result.add(region);
+		}
+		return result;		
+	}
+	
+	public static ArrayList<Integer> getEditOffsets(ArrayList<DiscardableRegion> editRegions) {
+		ArrayList<Integer> result = new ArrayList<Integer>();
+		for (DiscardableRegion region : editRegions) {
+			int startOffset = region.getStartOffset();
+			int endOffset = region.getEndOffset();
+			for (int offset = startOffset; offset <= endOffset; offset++) {
+				// "regions can overlap, for example: term + separation and comment in separation";
+				if(!result.contains(offset))
+					result.add(offset);
+			}
+		}
+		Collections.sort(result);
+		return result;
+	}
+
 }

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java	Sat Aug  4 15:10:19 2012	(r25250)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java	Sat Aug  4 15:47:44 2012	(r25251)
@@ -66,7 +66,7 @@
 	 * @return offsets of characters in discarded regions
 	 */
 	public ArrayList<Integer> getDiscardOffsetsCorrectInput() {
-		return getEditOffsets(getEditedRegionsCorrect());
+		return DiscardableRegion.getEditOffsets(getEditedRegionsCorrect());
 	}
 	
 	/**
@@ -116,7 +116,7 @@
 	 */
 	public ArrayList<DiscardableRegion> getEditedRegionsErroneous(){
 		ArrayList<DiscardableRegion> editsFromDeletions = mapRegions(getEditedRegionsCorrect(), true);
-		ArrayList<DiscardableRegion> editsFromInsertions = this.constructRegionsFromOffsets(getInsertionOffsets(), getErroneousInput());
+		ArrayList<DiscardableRegion> editsFromInsertions = DiscardableRegion.constructRegionsFromOffsets(getInsertionOffsets());
 		return mergeRegions(editsFromDeletions, editsFromInsertions);
 	}
 
@@ -126,7 +126,7 @@
 	 * @return offsets of edit regions from erroneous input
 	 */
 	public ArrayList<Integer> getDiscardOffsetsErroneousInput() {
-		return getEditOffsets(getEditedRegionsErroneous());
+		return DiscardableRegion.getEditOffsets(getEditedRegionsErroneous());
 	}
 
 // method for accessing the recovered input
@@ -138,12 +138,11 @@
 	 * @return recovered program
 	 */
 	public String getRecoveredInput(){
-		String recoveredProgram = replaceAllRegionByWhitespace(getEditedRegionsErroneous(), getErroneousInput());
+		String recoveredProgram = DiscardableRegion.replaceAllRegionsByWhitespace(getEditedRegionsErroneous(), getErroneousInput());
 		//assert recoveredProgram.equals(replaceAllRegionByWhitespace(getEditedRegionsCorrect(), correctInput)); //modulo comments and layout
 		assert recoveredProgram.length() == getErroneousInput().length(): "whitespaces are inserted for characters in the edit regions";
 		return recoveredProgram;
 	}
-
 	
 	/**
 	 * Detects possible erroneous code constructs and comments
@@ -270,29 +269,8 @@
 		return merged;
 	}
 
-	private ArrayList<DiscardableRegion> constructRegionsFromOffsets(ArrayList<Integer> offsets, String inputString){
-		ArrayList<DiscardableRegion> result = new ArrayList<DiscardableRegion>();
-		int startOffset = -1;
-		for (int i = 0; i < offsets.size(); i++) {
-			int offset = offsets.get(i);
-			if(i==0){
-				startOffset = offsets.get(i);
-			}
-			else if (offset != offsets.get(i-1) + 1){
-				DiscardableRegion region = new DiscardableRegion(startOffset, offsets.get(i-1), null);
-				result.add(region);
-				startOffset = offsets.get(i);
-			}
-		}
-		if(startOffset != -1){
-			DiscardableRegion region = new DiscardableRegion(startOffset, offsets.get(offsets.size()-1), null);
-			result.add(region);
-		}
-		return result;		
-	}
-
 	private ArrayList<String> constructSubstringsFromOffsets(ArrayList<Integer> offsets, String inputString){
-		ArrayList<DiscardableRegion> regions = constructRegionsFromOffsets(offsets, inputString);
+		ArrayList<DiscardableRegion> regions = DiscardableRegion.constructRegionsFromOffsets(offsets);
 		ArrayList<String> result = new ArrayList<String>();
 		for (DiscardableRegion region : regions) {
 			String fragment = inputString.substring(region.getStartOffset(), region.getEndOffset() + 1);
@@ -300,40 +278,4 @@
 		}
 		return result;
 	}
-	
-	private String replaceRegionByWhitespace(DiscardableRegion region, String input) {
-		char[] chars = input.toCharArray();
-		for (int offset = region.getStartOffset(); offset <= region.getEndOffset(); offset++) {
-			char charAtOffset = chars[offset];
-			if(!Character.isWhitespace(charAtOffset)){
-				chars[offset] = ' ';
-			}
-		}
-		return String.valueOf(chars);
-	}
-
-	private String replaceAllRegionByWhitespace(ArrayList<DiscardableRegion> regions, String input) {
-		String result = input;
-		for (DiscardableRegion region : regions) {
-			result = replaceRegionByWhitespace(region, result);
-		}
-		return result;
-	}
-		
-	private ArrayList<Integer> getEditOffsets(ArrayList<DiscardableRegion> editRegions) {
-		ArrayList<Integer> result = new ArrayList<Integer>();
-		for (DiscardableRegion region : editRegions) {
-			int startOffset = region.getStartOffset();
-			int endOffset = region.getEndOffset();
-			for (int offset = startOffset; offset <= endOffset; offset++) {
-				// "regions can overlap, for example: term + separation and comment in separation";
-				if(!result.contains(offset))
-					result.add(offset);
-			}
-		}
-		Collections.sort(result);
-		return result;
-	}
-
-	
 }

From m.dejonge at tudelft.nl  Sun Aug  5 12:09:25 2012
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Sun, 05 Aug 2012 10:09:25 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25252 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection
Message-ID: <20120805100925.B6BA7CC207@mx4.tudelft.nl>

Author: MaartjeDeJonge
Date: Sun Aug  5 10:09:23 2012
New Revision: 25252
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25252&sc=1

Log:


Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DiscardableRegion.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DiscardableRegion.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DiscardableRegion.java	Sat Aug  4 15:47:44 2012	(r25251)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DiscardableRegion.java	Sun Aug  5 10:09:23 2012	(r25252)
@@ -107,5 +107,41 @@
 		Collections.sort(result);
 		return result;
 	}
-
+	
+	public static ArrayList<DiscardableRegion> mergeRegions(ArrayList<DiscardableRegion> regions1, ArrayList<DiscardableRegion> regions2){
+		ArrayList<DiscardableRegion> merged = new ArrayList<DiscardableRegion>();
+		int index_r1 = 0;
+		int index_r2 = 0;
+		while (index_r1 < regions1.size() && index_r2 < regions2.size()) {
+			DiscardableRegion r1 = regions1.get(index_r1);			
+			DiscardableRegion r2 = regions2.get(index_r2);
+			if(r1.getEndOffset() < r2.getStartOffset()){
+				merged.add(r1);
+				index_r1 ++;
+			}
+			else if(r2.getEndOffset() < r1.getStartOffset()){
+				merged.add(r2);
+				index_r2 ++;
+			}
+			else {
+				int startOffset = Math.min(r1.getStartOffset(), r2.getStartOffset());
+				int endOffset = Math.max(r1.getEndOffset(), r2.getEndOffset());
+				DiscardableRegion mergedRegion = new DiscardableRegion(startOffset, endOffset, null);
+				merged.add(mergedRegion);
+				index_r1++;
+				index_r2++;
+			}
+		}
+		while (index_r1 < regions1.size()) {
+			DiscardableRegion r1 = regions1.get(index_r1);
+			merged.add(r1);
+			index_r1 ++;
+		}
+		while (index_r2 < regions2.size()) {
+			DiscardableRegion r2 = regions2.get(index_r2);
+			merged.add(r2);
+			index_r2++;
+		}
+		return merged;
+	}
 }

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java	Sat Aug  4 15:47:44 2012	(r25251)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java	Sun Aug  5 10:09:23 2012	(r25252)
@@ -1,9 +1,7 @@
 package org.spoofax.jsglr.client.editregion.detection;
 
 import java.util.ArrayList;
-import java.util.Collections;
-import org.spoofax.jsglr.client.editregion.detection.LCS;
-import org.spoofax.jsglr.client.editregion.detection.LCSCommand;
+
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.jsglr.client.imploder.ITokenizer;
 import org.spoofax.jsglr.client.imploder.ImploderAttachment;
@@ -58,7 +56,7 @@
 	 * @return discarded edit regions from the correct input
 	 */
 	public ArrayList<DiscardableRegion> getEditedRegionsCorrect(){
-		return mergeRegions(discardableRegions, discardableCommentRegions);
+		return DiscardableRegion.mergeRegions(discardableRegions, discardableCommentRegions);
 	}
 	
 	/**
@@ -117,7 +115,7 @@
 	public ArrayList<DiscardableRegion> getEditedRegionsErroneous(){
 		ArrayList<DiscardableRegion> editsFromDeletions = mapRegions(getEditedRegionsCorrect(), true);
 		ArrayList<DiscardableRegion> editsFromInsertions = DiscardableRegion.constructRegionsFromOffsets(getInsertionOffsets());
-		return mergeRegions(editsFromDeletions, editsFromInsertions);
+		return DiscardableRegion.mergeRegions(editsFromDeletions, editsFromInsertions);
 	}
 
 	/**
@@ -232,50 +230,23 @@
 		return result;
 	}
 	
-	private ArrayList<DiscardableRegion> mergeRegions(ArrayList<DiscardableRegion> regions1, ArrayList<DiscardableRegion> regions2){
-		ArrayList<DiscardableRegion> merged = new ArrayList<DiscardableRegion>();
-		int index_r1 = 0;
-		int index_r2 = 0;
-		while (index_r1 < regions1.size() && index_r2 < regions2.size()) {
-			DiscardableRegion r1 = regions1.get(index_r1);			
-			DiscardableRegion r2 = regions2.get(index_r2);
-			if(r1.getEndOffset() < r2.getStartOffset()){
-				merged.add(r1);
-				index_r1 ++;
-			}
-			else if(r2.getEndOffset() < r1.getStartOffset()){
-				merged.add(r2);
-				index_r2 ++;
-			}
-			else {
-				int startOffset = Math.min(r1.getStartOffset(), r2.getStartOffset());
-				int endOffset = Math.max(r1.getEndOffset(), r2.getEndOffset());
-				DiscardableRegion mergedRegion = new DiscardableRegion(startOffset, endOffset, null);
-				merged.add(mergedRegion);
-				index_r1++;
-				index_r2++;
-			}
-		}
-		while (index_r1 < regions1.size()) {
-			DiscardableRegion r1 = regions1.get(index_r1);
-			merged.add(r1);
-			index_r1 ++;
-		}
-		while (index_r2 < regions2.size()) {
-			DiscardableRegion r2 = regions2.get(index_r2);
-			merged.add(r2);
-			index_r2++;
-		}
-		return merged;
-	}
 
 	private ArrayList<String> constructSubstringsFromOffsets(ArrayList<Integer> offsets, String inputString){
 		ArrayList<DiscardableRegion> regions = DiscardableRegion.constructRegionsFromOffsets(offsets);
+		return constructFragments(inputString, regions);
+	}
+
+	private ArrayList<String> constructFragments(String inputString, ArrayList<DiscardableRegion> regions) {
 		ArrayList<String> result = new ArrayList<String>();
 		for (DiscardableRegion region : regions) {
-			String fragment = inputString.substring(region.getStartOffset(), region.getEndOffset() + 1);
+			String fragment = constructFragment(inputString, region);
 			result.add(fragment);
 		}
 		return result;
 	}
+
+	private String constructFragment(String inputString, DiscardableRegion region) {
+		String fragment = inputString.substring(region.getStartOffset(), region.getEndOffset() + 1);
+		return fragment;
+	}
 }

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java	Sat Aug  4 15:47:44 2012	(r25251)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java	Sun Aug  5 10:09:23 2012	(r25252)
@@ -206,6 +206,8 @@
 	public boolean isUndamagedTerm() {
 		return getSubtermRecoveries() == null;
 	}
+	
+	//TODO: ToString
 }
 
 

From m.dejonge at tudelft.nl  Sun Aug  5 13:42:53 2012
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Sun, 05 Aug 2012 11:42:53 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25253 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection
Message-ID: <20120805114253.52ABB7F8011@mx1.tudelft.nl>

Author: MaartjeDeJonge
Date: Sun Aug  5 11:42:52 2012
New Revision: 25253
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25253&sc=1

Log:


Deleted:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/NonTerminalEditsAnalyzer.java
Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DamagedTokenAnalyzer.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DiscardableRegion.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/LayoutEditsAnalyzer.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DamagedTokenAnalyzer.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DamagedTokenAnalyzer.java	Sun Aug  5 10:09:23 2012	(r25252)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DamagedTokenAnalyzer.java	Sun Aug  5 11:42:52 2012	(r25253)
@@ -23,6 +23,10 @@
 	//filled in the token stream analysis
 	private final ArrayList<IToken> tokensDamagedByInsertion;
 	private final ArrayList<IToken> tokensDamagedByDeletion;
+	
+	public ITokenizer getTokens() {
+		return tokens;
+	}
 
 	/**
 	 * Returns all tokens in the correct term that are (possible) damaged by

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DiscardableRegion.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DiscardableRegion.java	Sun Aug  5 10:09:23 2012	(r25252)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DiscardableRegion.java	Sun Aug  5 11:42:52 2012	(r25253)
@@ -3,30 +3,35 @@
 import java.util.ArrayList;
 import java.util.Collections;
 
-import org.spoofax.interpreter.terms.IStrategoTerm;
-
 /**
  * Fragment in the source code that represents a (possibly broken) construct
  * that (presumably) can be discarded safely, e.g., without invalidating the parse input.
  * @author maartje
  */
 public class DiscardableRegion{
+	
+//private fields
+	
 	private final int startOffset;
 	private final int endOffset;
-	private final IStrategoTerm affectedTerm;
+	private final String inputString;
 	
 
+//constructor
+	
 	/**
 	 * Fragment in the source code that represents a (possibly broken) construct
 	 * that can be discarded safely, e.g., without invalidating the parse input.
 	 */
-	public DiscardableRegion(int startOffset, int endOffset, IStrategoTerm affectedTerm){
+	public DiscardableRegion(int startOffset, int endOffset, String inputString){
 		this.startOffset = startOffset;
 		this.endOffset = endOffset;
-		this.affectedTerm = affectedTerm;
+		this.inputString = inputString;
 		assert startOffset <= endOffset;
 	}
 
+//getters
+	
 	/**
 	 * Returns the start offset of the discardable code fragment
 	 * @return start offset
@@ -48,31 +53,22 @@
 	 * Can be null in case the discarded region is a comment, or in case the abstract representation is not known.
 	 * @return term
 	 */
-	public IStrategoTerm getAffectedTerm() {
-		assert(!affectedTerm.isList()): "Individual list elements are prefered over full lists";
-		return affectedTerm;
+	public String getInputString() {
+		return inputString;
 	}
 	
+//public functions
+	
 	public static String replaceAllRegionsByWhitespace(ArrayList<DiscardableRegion> regions, String input) {
 		String result = input;
 		for (DiscardableRegion region : regions) {
+			assert region.getInputString() == input;
 			result = replaceRegionByWhitespace(region, result);
 		}
 		return result;
 	}
-	
-	private static String replaceRegionByWhitespace(DiscardableRegion region, String input) {
-		char[] chars = input.toCharArray();
-		for (int offset = region.getStartOffset(); offset <= region.getEndOffset(); offset++) {
-			char charAtOffset = chars[offset];
-			if(!Character.isWhitespace(charAtOffset)){
-				chars[offset] = ' ';
-			}
-		}
-		return String.valueOf(chars);
-	}
-	
-	public static ArrayList<DiscardableRegion> constructRegionsFromOffsets(ArrayList<Integer> offsets){
+		
+	public static ArrayList<DiscardableRegion> constructRegionsFromOffsets(ArrayList<Integer> offsets, String inputString){
 		ArrayList<DiscardableRegion> result = new ArrayList<DiscardableRegion>();
 		int startOffset = -1;
 		for (int i = 0; i < offsets.size(); i++) {
@@ -81,7 +77,7 @@
 				startOffset = offsets.get(i);
 			}
 			else if (offset != offsets.get(i-1) + 1){
-				DiscardableRegion region = new DiscardableRegion(startOffset, offsets.get(i-1), null);
+				DiscardableRegion region = new DiscardableRegion(startOffset, offsets.get(i-1), inputString);
 				result.add(region);
 				startOffset = offsets.get(i);
 			}
@@ -93,7 +89,7 @@
 		return result;		
 	}
 	
-	public static ArrayList<Integer> getEditOffsets(ArrayList<DiscardableRegion> editRegions) {
+	public static ArrayList<Integer> getOffsets(ArrayList<DiscardableRegion> editRegions) {
 		ArrayList<Integer> result = new ArrayList<Integer>();
 		for (DiscardableRegion region : editRegions) {
 			int startOffset = region.getStartOffset();
@@ -126,7 +122,8 @@
 			else {
 				int startOffset = Math.min(r1.getStartOffset(), r2.getStartOffset());
 				int endOffset = Math.max(r1.getEndOffset(), r2.getEndOffset());
-				DiscardableRegion mergedRegion = new DiscardableRegion(startOffset, endOffset, null);
+				assert r1.getInputString() == r2.getInputString();
+				DiscardableRegion mergedRegion = new DiscardableRegion(startOffset, endOffset, r1.getInputString());
 				merged.add(mergedRegion);
 				index_r1++;
 				index_r2++;
@@ -144,4 +141,31 @@
 		}
 		return merged;
 	}
+	
+	public static ArrayList<String> constructFragments(ArrayList<DiscardableRegion> regions) {
+		ArrayList<String> result = new ArrayList<String>();
+		for (DiscardableRegion region : regions) {
+			String fragment = region.constructFragment();
+			result.add(fragment);
+		}
+		return result;
+	}
+
+	public String constructFragment() {
+		return inputString.substring(getStartOffset(), getEndOffset() + 1);
+	}
+
+//private functions
+	
+	private static String replaceRegionByWhitespace(DiscardableRegion region, String modifiedInput) {
+		assert modifiedInput.length() == region.getInputString().length();
+		char[] chars = modifiedInput.toCharArray();
+		for (int offset = region.getStartOffset(); offset <= region.getEndOffset(); offset++) {
+			char charAtOffset = chars[offset];
+			if(!Character.isWhitespace(charAtOffset)){
+				chars[offset] = ' ';
+			}
+		}
+		return String.valueOf(chars);
+	}
 }

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java	Sun Aug  5 10:09:23 2012	(r25252)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java	Sun Aug  5 11:42:52 2012	(r25253)
@@ -64,21 +64,21 @@
 	 * @return offsets of characters in discarded regions
 	 */
 	public ArrayList<Integer> getDiscardOffsetsCorrectInput() {
-		return DiscardableRegion.getEditOffsets(getEditedRegionsCorrect());
+		return DiscardableRegion.getOffsets(getEditedRegionsCorrect());
 	}
 	
-	/**
-	 * Returns the (discardable) terms that were edited, from the correct input 
-	 * @return discarded terms
-	 */
-	public ArrayList<IStrategoTerm> getEditedTerms(){
-		ArrayList<IStrategoTerm> discardableTerms = new ArrayList<IStrategoTerm>();
-		for (DiscardableRegion region : getEditedRegionsCorrect()) {
-			if(!HelperFunctions.contains(discardableTerms, region.getAffectedTerm()))
-				discardableTerms.add(region.getAffectedTerm());
-		}
-		return discardableTerms;
-	}	
+//	/**
+//	 * Returns the (discardable) terms that were edited, from the correct input 
+//	 * @return discarded terms
+//	 */
+//	public ArrayList<IStrategoTerm> getEditedTerms(){
+//		ArrayList<IStrategoTerm> discardableTerms = new ArrayList<IStrategoTerm>();
+//		for (DiscardableRegion region : getEditedRegionsCorrect()) {
+//			if(!HelperFunctions.contains(discardableTerms, region.getAffectedTerm()))
+//				discardableTerms.add(region.getAffectedTerm());
+//		}
+//		return discardableTerms;
+//	}	
 
 
 //methods that access the erroneous parse input string
@@ -114,7 +114,7 @@
 	 */
 	public ArrayList<DiscardableRegion> getEditedRegionsErroneous(){
 		ArrayList<DiscardableRegion> editsFromDeletions = mapRegions(getEditedRegionsCorrect(), true);
-		ArrayList<DiscardableRegion> editsFromInsertions = DiscardableRegion.constructRegionsFromOffsets(getInsertionOffsets());
+		ArrayList<DiscardableRegion> editsFromInsertions = DiscardableRegion.constructRegionsFromOffsets(getInsertionOffsets(), this.getErroneousInput());
 		return DiscardableRegion.mergeRegions(editsFromDeletions, editsFromInsertions);
 	}
 
@@ -124,7 +124,7 @@
 	 * @return offsets of edit regions from erroneous input
 	 */
 	public ArrayList<Integer> getDiscardOffsetsErroneousInput() {
-		return DiscardableRegion.getEditOffsets(getEditedRegionsErroneous());
+		return DiscardableRegion.getOffsets(getEditedRegionsErroneous());
 	}
 
 // method for accessing the recovered input
@@ -215,7 +215,11 @@
 			}
 		}
 		if(startOffset >= 0){
-			return new DiscardableRegion(startOffset, endOffset, null);
+			String input = this.getCorrectInput();
+			if(!isInCorrectInputString){
+				input = this.getErroneousInput();
+			}
+			return new DiscardableRegion(startOffset, endOffset, input);
 		}
 		return null;
 	}
@@ -232,21 +236,7 @@
 	
 
 	private ArrayList<String> constructSubstringsFromOffsets(ArrayList<Integer> offsets, String inputString){
-		ArrayList<DiscardableRegion> regions = DiscardableRegion.constructRegionsFromOffsets(offsets);
-		return constructFragments(inputString, regions);
-	}
-
-	private ArrayList<String> constructFragments(String inputString, ArrayList<DiscardableRegion> regions) {
-		ArrayList<String> result = new ArrayList<String>();
-		for (DiscardableRegion region : regions) {
-			String fragment = constructFragment(inputString, region);
-			result.add(fragment);
-		}
-		return result;
-	}
-
-	private String constructFragment(String inputString, DiscardableRegion region) {
-		String fragment = inputString.substring(region.getStartOffset(), region.getEndOffset() + 1);
-		return fragment;
+		ArrayList<DiscardableRegion> regions = DiscardableRegion.constructRegionsFromOffsets(offsets, inputString);
+		return DiscardableRegion.constructFragments(regions);
 	}
 }

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/LayoutEditsAnalyzer.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/LayoutEditsAnalyzer.java	Sun Aug  5 10:09:23 2012	(r25252)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/LayoutEditsAnalyzer.java	Sun Aug  5 11:42:52 2012	(r25253)
@@ -53,13 +53,14 @@
 	}
 	
 	private void analyze() {
+		String input = tokenEdits.getTokens().getInput();
 		for (IToken tokenWithDeletions : tokenEdits.getTokensDamagedByDeletion()) {
 			if(tokenWithDeletions.getKind() == Token.TK_LAYOUT){
 				if(!tokenEdits.isDamagingLayoutDeletion(tokenWithDeletions)){
 					this.offsetsDeletedLayoutChars.addAll(tokenEdits.getOffsetsDeletions(tokenWithDeletions));						
 				}
 				if(!Token.isWhiteSpace(tokenWithDeletions)){
-					DiscardableRegion commentRegion = new DiscardableRegion(tokenWithDeletions.getStartOffset(), tokenWithDeletions.getEndOffset(), null);
+					DiscardableRegion commentRegion = new DiscardableRegion(tokenWithDeletions.getStartOffset(), tokenWithDeletions.getEndOffset(), input);
 					damagedCommentRegions.add(commentRegion);
 					assert !HelperFunctions.contains(damagedCommentRegions, commentRegion);
 				}
@@ -67,7 +68,7 @@
 		}
 		for (IToken tokenWithInsertions : tokenEdits.getTokensDamagedByInsertion()) {
 			if(tokenWithInsertions.getKind() == Token.TK_LAYOUT && !Token.isWhiteSpace(tokenWithInsertions)){
-				DiscardableRegion commentRegion = new DiscardableRegion(tokenWithInsertions.getStartOffset(), tokenWithInsertions.getEndOffset(), null);
+				DiscardableRegion commentRegion = new DiscardableRegion(tokenWithInsertions.getStartOffset(), tokenWithInsertions.getEndOffset(), input);
 				if(!HelperFunctions.contains(damagedCommentRegions, commentRegion))
 					damagedCommentRegions.add(commentRegion);
 			}

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java	Sun Aug  5 10:09:23 2012	(r25252)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java	Sun Aug  5 11:42:52 2012	(r25253)
@@ -183,13 +183,14 @@
 	}
 
 	private ArrayList<DiscardableRegion> getDamagedRegionsForAffectedTerm() {
+		String input = ImploderAttachment.getTokenizer(getTerm()).getInput();
 		ArrayList<DiscardableRegion> damagedRegions = new ArrayList<DiscardableRegion>();
 		int startOffset = getLeftToken(term).getStartOffset();
 		for (int i = 0; i < getSubtermRecoveries().size(); i++) {
 			RecoverInterpretation subtermRecovery = getSubtermRecoveries().get(i);
 			int endOffset = getLeftToken(subtermRecovery.getTerm()).getStartOffset()-1;
 			if(startOffset <= endOffset){ //discard tokens associated to term
-				DiscardableRegion region = new DiscardableRegion(startOffset, endOffset, getTerm());
+				DiscardableRegion region = new DiscardableRegion(startOffset, endOffset, input);
 				damagedRegions.add(region);
 			}
 			damagedRegions.addAll(subtermRecovery.getDamagedRegions()); //collect damaged regions in subterm
@@ -197,7 +198,7 @@
 		}
 		int endOffset = getRightToken(term).getEndOffset();
 		if(startOffset <= endOffset){ //discard suffix tokens associated to term
-			DiscardableRegion damagedRegion = new DiscardableRegion(startOffset, endOffset, getTerm());
+			DiscardableRegion damagedRegion = new DiscardableRegion(startOffset, endOffset, input);
 			damagedRegions.add(damagedRegion);
 		}
 		return damagedRegions;
@@ -207,6 +208,7 @@
 		return getSubtermRecoveries() == null;
 	}
 	
+	//TODO: GetDamagedTerms
 	//TODO: ToString
 }
 

From m.dejonge at tudelft.nl  Sun Aug  5 15:24:10 2012
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Sun, 05 Aug 2012 13:24:10 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25254 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection
Message-ID: <20120805132410.794012B8012@mx2.tudelft.nl>

Author: MaartjeDeJonge
Date: Sun Aug  5 13:24:10 2012
New Revision: 25254
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25254&sc=1

Log:


Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/HelperFunctions.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java	Sun Aug  5 11:42:52 2012	(r25253)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java	Sun Aug  5 13:24:10 2012	(r25254)
@@ -21,7 +21,7 @@
 	private final IStrategoTerm correctAST;
 	
 	//edit regions found after analyzing the correct AST/input and its deleted characters
-	private ArrayList<DiscardableRegion> discardableRegions;
+	private RecoverInterpretation discardRecovery;
 	private ArrayList<DiscardableRegion> discardableCommentRegions;
 
 
@@ -56,7 +56,11 @@
 	 * @return discarded edit regions from the correct input
 	 */
 	public ArrayList<DiscardableRegion> getEditedRegionsCorrect(){
-		return DiscardableRegion.mergeRegions(discardableRegions, discardableCommentRegions);
+		if(discardRecovery == null){
+			RecoverInterpretation emptyRecovery = RecoverInterpretation.createDiscardInterpretation(correctAST, null);
+			return emptyRecovery.getDamagedRegions();
+		}
+		return DiscardableRegion.mergeRegions(discardRecovery.getDamagedRegions(), discardableCommentRegions);
 	}
 	
 	/**
@@ -67,18 +71,13 @@
 		return DiscardableRegion.getOffsets(getEditedRegionsCorrect());
 	}
 	
-//	/**
-//	 * Returns the (discardable) terms that were edited, from the correct input 
-//	 * @return discarded terms
-//	 */
-//	public ArrayList<IStrategoTerm> getEditedTerms(){
-//		ArrayList<IStrategoTerm> discardableTerms = new ArrayList<IStrategoTerm>();
-//		for (DiscardableRegion region : getEditedRegionsCorrect()) {
-//			if(!HelperFunctions.contains(discardableTerms, region.getAffectedTerm()))
-//				discardableTerms.add(region.getAffectedTerm());
-//		}
-//		return discardableTerms;
-//	}	
+	/**
+	 * Returns the (discardable) terms that were edited, from the correct input 
+	 * @return discarded terms
+	 */
+	public ArrayList<IStrategoTerm> getEditedTerms(){
+		return discardRecovery.getDamagedTerms();
+	}	
 
 
 //methods that access the erroneous parse input string
@@ -180,7 +179,7 @@
 		
 		//detects discardable regions that correspond to edited terms.
 		TermEditsAnalyzer brokenConstructDetector = new TermEditsAnalyzer(offsetsDeletedChars, correctAST);
-		this.discardableRegions = brokenConstructDetector.getDamagedTermRegions();		
+		this.discardRecovery = brokenConstructDetector.getDiscardRecovery();		
 	}
 	
 

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/HelperFunctions.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/HelperFunctions.java	Sun Aug  5 11:42:52 2012	(r25253)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/HelperFunctions.java	Sun Aug  5 13:24:10 2012	(r25254)
@@ -40,6 +40,11 @@
 		return termSort;
 	}
 	
+	public static boolean isListSort(String sort) {
+		return sort.endsWith("*");
+	}
+
+	
 	public static boolean isSomeNode(IStrategoTerm trm) {
 		if(trm.getTermType() == IStrategoTerm.APPL){
 			return trm.getSubtermCount() == 1 && ((IStrategoAppl)trm).getConstructor().getName().equals("Some");

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java	Sun Aug  5 11:42:52 2012	(r25253)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java	Sun Aug  5 13:24:10 2012	(r25254)
@@ -11,6 +11,8 @@
 import org.spoofax.jsglr.client.imploder.ImploderAttachment;
 import org.spoofax.jsglr.client.imploder.Token;
 
+import com.sun.xml.internal.bind.v2.runtime.RuntimeUtil.ToStringAdapter;
+
 public class RecoverInterpretation {
 
 //private fields
@@ -36,11 +38,7 @@
 		return recoveryCosts;
 	}
 
-//public methods
-		
-	//	public boolean isListSort(String sort) {
-	//		return sort.endsWith("*");
-	//	}
+//public methods	
 	
 	public String getGeneralSort(){
 		return HelperFunctions.getGeneralSort(term, parentTerm);
@@ -77,6 +75,48 @@
 		return hasCompatibleSort;
 	}
 
+	public boolean isUndamagedTerm() {
+		return getSubtermRecoveries() == null;
+	}
+	
+	public ArrayList<DiscardableRegion> getDamagedRegions(){
+		if(this.getSubtermRecoveries() == null){ //trivial recovery (no damage)
+			return new ArrayList<DiscardableRegion>(); 
+		}
+		else if(isRecovered){ //only damage in tokens associated to subterms 
+			return getDamagedRegionsForUnaffectedTerm(); 
+		}
+		else { //damage in tokens associated to term
+			return getDamagedRegionsForAffectedTerm();
+		}
+	}
+
+	public ArrayList<IStrategoTerm> getDamagedTerms(){
+		ArrayList<IStrategoTerm> damagedTerms = new ArrayList<IStrategoTerm>();
+		if(this.getSubtermRecoveries() == null){ //trivial recovery (no damage)
+			return new ArrayList<IStrategoTerm>();
+		}
+		if(!isRecovered){ 
+			damagedTerms.add(getTerm());
+		}
+		for (int i = 0; i < this.getSubtermRecoveries().size(); i++) {
+			damagedTerms.addAll(getSubtermRecoveries().get(i).getDamagedTerms());
+		}
+		return damagedTerms;
+	}
+	
+	@Override
+	public String toString(){
+		ArrayList<DiscardableRegion> damagedRegions = getDamagedRegions();
+		String inputString = getInputString();
+		String recoveredProgram = DiscardableRegion.replaceAllRegionsByWhitespace(damagedRegions, inputString);
+		int startOffset = ImploderAttachment.getLeftToken(term).getStartOffset();
+		int endOffset = ImploderAttachment.getRightToken(term).getEndOffset();
+		String recoveredTermFragment = recoveredProgram.substring(startOffset, endOffset + 1);
+		return recoveredTermFragment;
+	}
+
+
 	
 // constructors
 	
@@ -166,24 +206,8 @@
 		return nrOfNonLayoutTokens;
 	}
 	
-	public ArrayList<DiscardableRegion> getDamagedRegions(){		
-		if(this.getSubtermRecoveries() == null){ //trivial recovery (no damage)
-			return new ArrayList<DiscardableRegion>(); 
-		}
-		else if(isRecovered){ //only damage in tokens associated to subterms 
-			ArrayList<DiscardableRegion> damagedRegions = new ArrayList<DiscardableRegion>();
-			for (RecoverInterpretation subtermRecovery : getSubtermRecoveries()) {
-				damagedRegions.addAll(subtermRecovery.getDamagedRegions());
-			}
-			return damagedRegions; 
-		}
-		else { //damage in tokens associated to term
-			return getDamagedRegionsForAffectedTerm();
-		}
-	}
-
 	private ArrayList<DiscardableRegion> getDamagedRegionsForAffectedTerm() {
-		String input = ImploderAttachment.getTokenizer(getTerm()).getInput();
+		String input = getInputString();
 		ArrayList<DiscardableRegion> damagedRegions = new ArrayList<DiscardableRegion>();
 		int startOffset = getLeftToken(term).getStartOffset();
 		for (int i = 0; i < getSubtermRecoveries().size(); i++) {
@@ -203,13 +227,18 @@
 		}
 		return damagedRegions;
 	}
+	
+	private ArrayList<DiscardableRegion> getDamagedRegionsForUnaffectedTerm() {
+		ArrayList<DiscardableRegion> damagedRegions = new ArrayList<DiscardableRegion>();
+		for (RecoverInterpretation subtermRecovery : getSubtermRecoveries()) {
+			damagedRegions.addAll(subtermRecovery.getDamagedRegions());
+		}
+		return damagedRegions;
+	}
 
-	public boolean isUndamagedTerm() {
-		return getSubtermRecoveries() == null;
+	private String getInputString() {
+		return ImploderAttachment.getTokenizer(getTerm()).getInput();
 	}
-	
-	//TODO: GetDamagedTerms
-	//TODO: ToString
 }
 
 

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java	Sun Aug  5 11:42:52 2012	(r25253)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java	Sun Aug  5 13:24:10 2012	(r25254)
@@ -4,11 +4,9 @@
 import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getRightToken;
 
 import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.IdentityHashMap;
 
 import org.spoofax.interpreter.terms.IStrategoTerm;
-import org.spoofax.jsglr.client.imploder.ImploderAttachment;
 
 public class TermEditsAnalyzer {
 	private final IStrategoTerm correctAST;
@@ -24,12 +22,12 @@
 	/**
 	 * Returns discardable regions that are edited 
 	 */
-	public ArrayList<DiscardableRegion> getDamagedTermRegions(){
+	public RecoverInterpretation getDiscardRecovery(){
 		recoveryLookup.clear();
 		collectRecoveries(correctAST, null);
 		RecoverInterpretation discardRecovery = recoveryLookup.get(correctAST); //TODO: if null, alltd look for regions in subterms
 		assert discardRecovery == null || discardRecovery.getTerm() == correctAST;
-		return discardRecovery.getDamagedRegions();
+		return discardRecovery;
 	}
 
 	private void collectRecoveries(IStrategoTerm term, IStrategoTerm parent){

From m.dejonge at tudelft.nl  Sun Aug  5 16:14:01 2012
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Sun, 05 Aug 2012 14:14:01 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25255 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection
Message-ID: <20120805141401.CA5C77F800C@mx1.tudelft.nl>

Author: MaartjeDeJonge
Date: Sun Aug  5 14:14:01 2012
New Revision: 25255
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25255&sc=1

Log:


Deleted:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverAttachment.java
Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DamagedTokenAnalyzer.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DiscardableRegion.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/HelperFunctions.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/LayoutEditsAnalyzer.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DamagedTokenAnalyzer.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DamagedTokenAnalyzer.java	Sun Aug  5 13:24:10 2012	(r25254)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DamagedTokenAnalyzer.java	Sun Aug  5 14:14:01 2012	(r25255)
@@ -24,10 +24,6 @@
 	private final ArrayList<IToken> tokensDamagedByInsertion;
 	private final ArrayList<IToken> tokensDamagedByDeletion;
 	
-	public ITokenizer getTokens() {
-		return tokens;
-	}
-
 	/**
 	 * Returns all tokens in the correct term that are (possible) damaged by
 	 * the insertion of characters between the start and end character of the token.   
@@ -62,23 +58,21 @@
 		analyzeDamagedTokens();
 	}
 
-	private void analyzeDamagedTokens() {
-		for (int i = 0; i < tokens.getTokenCount(); i++) {
-			IToken t = tokens.getTokenAt(i);
-			if (isDamagedByDeletion(t)){
-				tokensDamagedByDeletion.add(t);
-			}
-			if (isDamagedByInsertion(t)){
-				tokensDamagedByInsertion.add(t);
-			}
-		}
-	}
-
+	/**
+	 * Says whether a token in the (correctly) parsed input has deleted characters in the (possible) erroneous input 
+	 * @param t
+	 * @return
+	 */
 	public boolean isDamagedByDeletion(IToken t) {
 		ArrayList<Integer> deletions = getOffsetsDeletions(t);
 		return !deletions.isEmpty();
 	}
 
+	/**
+	 * Returns the offsets of characters in the token that are deleted in the (possible) erroneous input 
+	 * @param t
+	 * @return
+	 */
 	public ArrayList<Integer> getOffsetsDeletions(IToken t) {
 		int startOffset = t.getStartOffset();
 		int endOffset = t.getEndOffset();
@@ -91,6 +85,11 @@
 		return deletions;
 	}
 	
+	/**
+	 * Says whether a token in the (correctly) parsed input has inserted characters in the (possible) erroneous input 
+	 * @param t
+	 * @return
+	 */
 	public boolean isDamagedByInsertion(IToken t) {
 		int startOffset = t.getStartOffset();
 		int endOffset = t.getEndOffset();
@@ -105,10 +104,16 @@
 		return false;
 	}
 	
-	public boolean isDamagingLayoutDeletion(IToken tokenWithDeletions) {
-		int numberOfDeletions = getOffsetsDeletions(tokenWithDeletions).size();
-		int startOffset = tokenWithDeletions.getStartOffset();
-		int endOffset = tokenWithDeletions.getEndOffset();
+	/**
+	 * Says whether a token is a layout token between two non-layout tokens that has been completely removed,
+	 * and therefore may affect the parse result.
+	 * @param token
+	 * @return
+	 */
+	public boolean isDamagingLayoutDeletion(IToken token) {
+		int numberOfDeletions = getOffsetsDeletions(token).size();
+		int startOffset = token.getStartOffset();
+		int endOffset = token.getEndOffset();
 		if (numberOfDeletions == endOffset - startOffset + 1){ //full deletion
 			int firstMatchedOffsetInPrefix = -1;
 			int firstMatchedOffsetInSuffix = -1;
@@ -130,8 +135,8 @@
 				firstMatchedOffsetInSuffix_2 == firstMatchedOffsetInPrefix_2 + 1 && //no insertions that are discarded as whitespace
 				firstMatchedOffsetInPrefix_2 != -1 &&
 				firstMatchedOffsetInSuffix_2 != -1 &&
-				!isOffsetOfLayoutChar(tokenWithDeletions.getTokenizer(), firstMatchedOffsetInPrefix) &&
-				!isOffsetOfLayoutChar(tokenWithDeletions.getTokenizer(), firstMatchedOffsetInSuffix);
+				!isOffsetOfLayoutChar(token.getTokenizer(), firstMatchedOffsetInPrefix) &&
+				!isOffsetOfLayoutChar(token.getTokenizer(), firstMatchedOffsetInSuffix);
 		}
 		return false;
 	}
@@ -140,4 +145,16 @@
 		boolean precedingLayout = tokens.getTokenAtOffset(offset).getKind() == Token.TK_LAYOUT;
 		return precedingLayout;
 	}
+	
+	private void analyzeDamagedTokens() {
+		for (int i = 0; i < tokens.getTokenCount(); i++) {
+			IToken t = tokens.getTokenAt(i);
+			if (isDamagedByDeletion(t)){
+				tokensDamagedByDeletion.add(t);
+			}
+			if (isDamagedByInsertion(t)){
+				tokensDamagedByInsertion.add(t);
+			}
+		}
+	}
 }

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DiscardableRegion.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DiscardableRegion.java	Sun Aug  5 13:24:10 2012	(r25254)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DiscardableRegion.java	Sun Aug  5 14:14:01 2012	(r25255)
@@ -59,6 +59,12 @@
 	
 //public functions
 	
+	/**
+	 * Returns a recovered input String by replacing erroneous regions by whitespaces
+	 * @param regions
+	 * @param input
+	 * @return
+	 */
 	public static String replaceAllRegionsByWhitespace(ArrayList<DiscardableRegion> regions, String input) {
 		String result = input;
 		for (DiscardableRegion region : regions) {
@@ -67,7 +73,13 @@
 		}
 		return result;
 	}
-		
+	
+	/**
+	 * Construct regions by grouping subsequent offsets
+	 * @param offsets
+	 * @param inputString
+	 * @return
+	 */
 	public static ArrayList<DiscardableRegion> constructRegionsFromOffsets(ArrayList<Integer> offsets, String inputString){
 		ArrayList<DiscardableRegion> result = new ArrayList<DiscardableRegion>();
 		int startOffset = -1;
@@ -89,6 +101,11 @@
 		return result;		
 	}
 	
+	/**
+	 * Returns all offsets covered by the regions
+	 * @param editRegions
+	 * @return
+	 */
 	public static ArrayList<Integer> getOffsets(ArrayList<DiscardableRegion> editRegions) {
 		ArrayList<Integer> result = new ArrayList<Integer>();
 		for (DiscardableRegion region : editRegions) {
@@ -104,6 +121,12 @@
 		return result;
 	}
 	
+	/**
+	 * Merges ordered region lists so that the resulting lists is ordered and merges overlapping regions
+	 * @param regions1
+	 * @param regions2
+	 * @return
+	 */
 	public static ArrayList<DiscardableRegion> mergeRegions(ArrayList<DiscardableRegion> regions1, ArrayList<DiscardableRegion> regions2){
 		ArrayList<DiscardableRegion> merged = new ArrayList<DiscardableRegion>();
 		int index_r1 = 0;
@@ -142,6 +165,11 @@
 		return merged;
 	}
 	
+	/**
+	 * Constructs the list of text fragments represented by the regions
+	 * @param regions
+	 * @return
+	 */
 	public static ArrayList<String> constructFragments(ArrayList<DiscardableRegion> regions) {
 		ArrayList<String> result = new ArrayList<String>();
 		for (DiscardableRegion region : regions) {

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java	Sun Aug  5 13:24:10 2012	(r25254)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java	Sun Aug  5 14:14:01 2012	(r25255)
@@ -20,7 +20,7 @@
 	private final String erroneousInput;
 	private final IStrategoTerm correctAST;
 	
-	//edit regions found after analyzing the correct AST/input and its deleted characters
+	//discard recovery found after analyzing the correct AST/input and its deleted characters
 	private RecoverInterpretation discardRecovery;
 	private ArrayList<DiscardableRegion> discardableCommentRegions;
 

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/HelperFunctions.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/HelperFunctions.java	Sun Aug  5 13:24:10 2012	(r25254)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/HelperFunctions.java	Sun Aug  5 14:14:01 2012	(r25255)
@@ -30,6 +30,12 @@
 		return false;
 	}
 
+	/**
+	 * Gets the sort or, for lists and list elements, the Elem* sort associated to the (parent)list 
+	 * @param term
+	 * @param parent
+	 * @return
+	 */
 	public static String getGeneralSort(IStrategoTerm term, IStrategoTerm parent) {
 		String termSort = getSort(term);
 		if(parent != null){
@@ -40,11 +46,20 @@
 		return termSort;
 	}
 	
+	/**
+	 * Returns true iff the sort represents a list sort, e.g., Elem*
+	 * @param sort
+	 * @return
+	 */
 	public static boolean isListSort(String sort) {
 		return sort.endsWith("*");
 	}
 
-	
+	/**
+	 * Says wether the given node is an optional Some(_) sort.
+	 * @param trm
+	 * @return
+	 */
 	public static boolean isSomeNode(IStrategoTerm trm) {
 		if(trm.getTermType() == IStrategoTerm.APPL){
 			return trm.getSubtermCount() == 1 && ((IStrategoAppl)trm).getConstructor().getName().equals("Some");

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/LayoutEditsAnalyzer.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/LayoutEditsAnalyzer.java	Sun Aug  5 13:24:10 2012	(r25254)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/LayoutEditsAnalyzer.java	Sun Aug  5 14:14:01 2012	(r25255)
@@ -24,6 +24,7 @@
 	//filled in the analysis
 	private final ArrayList<DiscardableRegion> damagedCommentRegions;
 	private final ArrayList<Integer> offsetsDeletedLayoutChars;
+	private final ITokenizer tokens;
 	
 	/**
 	 * Returns the comment regions that are edited and therefore (possible) damaged.
@@ -49,11 +50,12 @@
 		this.offsetsDeletedLayoutChars = new ArrayList<Integer>();
 		this.damagedCommentRegions = new ArrayList<DiscardableRegion>();
 		tokenEdits = new DamagedTokenAnalyzer(tokens, lcs);
+		this.tokens = tokens;
 		analyze();
 	}
 	
 	private void analyze() {
-		String input = tokenEdits.getTokens().getInput();
+		String input = tokens.getInput();
 		for (IToken tokenWithDeletions : tokenEdits.getTokensDamagedByDeletion()) {
 			if(tokenWithDeletions.getKind() == Token.TK_LAYOUT){
 				if(!tokenEdits.isDamagingLayoutDeletion(tokenWithDeletions)){

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java	Sun Aug  5 13:24:10 2012	(r25254)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java	Sun Aug  5 14:14:01 2012	(r25255)
@@ -11,8 +11,11 @@
 import org.spoofax.jsglr.client.imploder.ImploderAttachment;
 import org.spoofax.jsglr.client.imploder.Token;
 
-import com.sun.xml.internal.bind.v2.runtime.RuntimeUtil.ToStringAdapter;
-
+/**
+ * Represents a recovery based on discarding tokens associated to the term and/or its subterms.
+ * @author maartje
+ *
+ */
 public class RecoverInterpretation {
 
 //private fields
@@ -21,33 +24,59 @@
 	private final IStrategoTerm parentTerm;
 	private final boolean isRecovered;
 	private final ArrayList<RecoverInterpretation> subtermRecoveries;
-
 	private final int recoveryCosts;
 
 //public field accessors 
 
+	/**
+	 * Returns the recovered term
+	 * @return
+	 */
 	public IStrategoTerm getTerm() {
 		return term;
 	}
 	
+	/**
+	 * Returns the recoveries associated to the subterms
+	 * @return
+	 */
 	public ArrayList<RecoverInterpretation> getSubtermRecoveries() {
 		return subtermRecoveries;
 	}
 
+	/**
+	 * Returns the cost of the recovery calculated as the number of non-layout tokens that are discarded from the correct input
+	 * fragment associated to the recovered term 
+	 * @return
+	 */
 	public int getRecoveryCosts() {
 		return recoveryCosts;
 	}
 
 //public methods	
 	
+	/**
+	 * Gets the sort of the (parent) list for lists and list elems, and the sort of the term for other terms 
+	 * @return
+	 */
 	public String getGeneralSort(){
 		return HelperFunctions.getGeneralSort(term, parentTerm);
 	}
 
+	/**
+	 * Gets the sort of the term
+	 * @return
+	 */
 	public String getSort(){
 		return ImploderAttachment.getSort(term);
 	}
 	
+	/**
+	 * Says wether the recovered term has the same sort and general sort as the term given as parameter
+	 * @param term
+	 * @param parent, needed to determine the general sort of the term 
+	 * @return
+	 */
 	public boolean hasSameSort(IStrategoTerm term, IStrategoTerm parent) {
 		String generalSort = HelperFunctions.getGeneralSort(term, parent);
 		String sort = ImploderAttachment.getSort(term);
@@ -56,6 +85,13 @@
 		return generalSort == generalTermSort && sort == termSort;
 	}
 
+	/**
+	 * Says whether the recovery has a sort that is compatible with the sort of the input term,
+	 * e.g., the recovered term can be used as a recover interpretation for the input term 
+	 * @param term
+	 * @param parent
+	 * @return
+	 */
 	public boolean hasCompatibleSort(IStrategoTerm term, IStrategoTerm parent) {
 		String generalSort = HelperFunctions.getGeneralSort(term, parent);
 		String sort = ImploderAttachment.getSort(term);
@@ -75,10 +111,19 @@
 		return hasCompatibleSort;
 	}
 
+	/**
+	 * Says wether the recovery is a trivial recover interpretation,
+	 *  e.g. the original interpretation of an undamaged term. 
+	 * @return
+	 */
 	public boolean isUndamagedTerm() {
 		return getSubtermRecoveries() == null;
 	}
 	
+	/**
+	 * Returns a recursively constructed list of discarded regions that together form a recovery for the term 
+	 * @return
+	 */
 	public ArrayList<DiscardableRegion> getDamagedRegions(){
 		if(this.getSubtermRecoveries() == null){ //trivial recovery (no damage)
 			return new ArrayList<DiscardableRegion>(); 
@@ -91,6 +136,10 @@
 		}
 	}
 
+	/**
+	 * Returns a recursively constructed list of terms for which the associate tokens are discarded as a recovery 
+	 * @return
+	 */
 	public ArrayList<IStrategoTerm> getDamagedTerms(){
 		ArrayList<IStrategoTerm> damagedTerms = new ArrayList<IStrategoTerm>();
 		if(this.getSubtermRecoveries() == null){ //trivial recovery (no damage)
@@ -120,21 +169,52 @@
 	
 // constructors
 	
+	/**
+	 * Returns a trivial recover interpretation by taking the original interpretation.
+	 * Intended for undamaged terms. 
+	 * @param term
+	 * @param parentTerm
+	 * @return
+	 */
 	public static RecoverInterpretation createOriginalTermInterpretation(IStrategoTerm term, IStrategoTerm parentTerm){
 		return new RecoverInterpretation(term, parentTerm, true, null);
 		//Remark: recursively constructing original term recoveries for subterms seems not needed. 
 	}
 
+	/**
+	 * Returns a recover interpretation based on discarding the characters associated to the term and all its subterms.
+	 * Intended as fall back recovery for list elements and 'Some(_)' terms.  
+	 * @param term
+	 * @param parentTerm
+	 * @return
+	 */
 	public static RecoverInterpretation createDiscardInterpretation(IStrategoTerm term, IStrategoTerm parentTerm){
 		assert parentTerm.isList() || HelperFunctions.isSomeNode(term);
 		return new RecoverInterpretation(term, parentTerm, false, new ArrayList<RecoverInterpretation>());
 	}
 
+	/**
+	 * Returns a recover interpretation based on repairing the subterms
+	 * Intended for terms that are not affected themselves, but do have changes in their subterms,
+	 * whereby the child terms can be recovered.
+	 * @param term
+	 * @param parentTerm
+	 * @param recoveredSubterms
+	 * @return
+	 */
 	public static RecoverInterpretation createRepairSubtermsInterpretation(IStrategoTerm term, IStrategoTerm parentTerm, ArrayList<RecoverInterpretation> recoveredSubterms){
 		assert recoveredSubterms.size() == term.getSubtermCount() && !recoveredSubterms.contains(null);
 		return new RecoverInterpretation(term, parentTerm, true, recoveredSubterms);
 	}
 
+	/**
+	 * Returns a recover interpretation by replacing the term with a sub-term of the same sort.
+	 * Intended for terms that are affected themselves, or terms whereby the child terms can not be repaired.
+	 * @param term
+	 * @param parentTerm
+	 * @param recoveredSubterm
+	 * @return
+	 */
 	public static RecoverInterpretation createReplaceBySubtermsInterpretation(IStrategoTerm term, IStrategoTerm parentTerm, RecoverInterpretation recoveredSubterm){
 		assert recoveredSubterm.hasCompatibleSort(term, parentTerm);
 		ArrayList<RecoverInterpretation> subRecoveries = new ArrayList<RecoverInterpretation>();
@@ -142,6 +222,14 @@
 		return createReplaceBySubtermsInterpretation(term, parentTerm, subRecoveries);
 	}
 
+	/**
+	 * Returns a recover interpretation by replacing the terms with a list of sub terms of the same sort.
+	 * Intended for list elements that are affected themselves, or list elements whereby the child terms can not be repaired.
+	 * @param term
+	 * @param parentTerm
+	 * @param recoveredSubterms
+	 * @return
+	 */
 	public static RecoverInterpretation createReplaceBySubtermsInterpretation(IStrategoTerm term, IStrategoTerm parentTerm, ArrayList<RecoverInterpretation> recoveredSubterms){
 		assert parentTerm.isList() || recoveredSubterms.size() == 1;
 		return new RecoverInterpretation(term, parentTerm, false, recoveredSubterms);
@@ -240,11 +328,3 @@
 		return ImploderAttachment.getTokenizer(getTerm()).getInput();
 	}
 }
-
-
-
-
-
-
-
-

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java	Sun Aug  5 13:24:10 2012	(r25254)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java	Sun Aug  5 14:14:01 2012	(r25255)
@@ -8,11 +8,20 @@
 
 import org.spoofax.interpreter.terms.IStrategoTerm;
 
+/**
+ * Analyzes the terms in the correct AST that are affected during editing and therefore (possible) damaged.
+ * Constructs a recovery based on discarding tokens associated to erroneous (discardable) terms. 
+ * @author Maartje de Jonge
+ *
+ */
 public class TermEditsAnalyzer {
 	private final IStrategoTerm correctAST;
 	private final ArrayList<Integer> offsetsDeletedChars;
 	private final IdentityHashMap<IStrategoTerm, RecoverInterpretation> recoveryLookup;
 
+	/**
+	 * Constructs a recovery based on discarding tokens associated to erroneous (discardable) terms. 
+	 */
 	public TermEditsAnalyzer(ArrayList<Integer> offsetsDeletedChars, IStrategoTerm correctAST){
 		this.offsetsDeletedChars = offsetsDeletedChars;
 		this.recoveryLookup = new IdentityHashMap<IStrategoTerm, RecoverInterpretation>();

From m.dejonge at tudelft.nl  Sun Aug  5 21:32:47 2012
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Sun, 05 Aug 2012 19:32:47 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25256 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection
Message-ID: <20120805193247.20D5E108C011@mx3.tudelft.nl>

Author: MaartjeDeJonge
Date: Sun Aug  5 19:32:45 2012
New Revision: 25256
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25256&sc=1

Log:


Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java	Sun Aug  5 14:14:01 2012	(r25255)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java	Sun Aug  5 19:32:45 2012	(r25256)
@@ -32,9 +32,10 @@
 	 * Returns discardable regions that are edited 
 	 */
 	public RecoverInterpretation getDiscardRecovery(){
+		//System.out.println(correctAST);
 		recoveryLookup.clear();
 		collectRecoveries(correctAST, null);
-		RecoverInterpretation discardRecovery = recoveryLookup.get(correctAST); //TODO: if null, alltd look for regions in subterms
+		RecoverInterpretation discardRecovery = lookupRecovery(correctAST, null); //TODO: if null, alltd look for regions in subterms
 		assert discardRecovery == null || discardRecovery.getTerm() == correctAST;
 		return discardRecovery;
 	}
@@ -74,7 +75,7 @@
 		ArrayList<RecoverInterpretation> subtermRecoveries = new ArrayList<RecoverInterpretation>();
 		for (int i = 0; i < term.getSubtermCount(); i++) {
 			IStrategoTerm subterm = term.getSubterm(i);
-			RecoverInterpretation subtermRecovery = recoveryLookup.get(subterm);
+			RecoverInterpretation subtermRecovery = lookupRecovery(subterm, term);
 			if(subtermRecovery == null){
 				return null; //subterm can not be recovered, thus term can not be recovered from its subterms
 			}
@@ -93,14 +94,14 @@
 
 	private RecoverInterpretation constructReplaceBySubtermsRecovery(IStrategoTerm term, IStrategoTerm parent) {
 		//System.out.println("recover: " + term);
-		return getRecoveryFromSubterms(term, term, parent);
+		RecoverInterpretation recovery = getRecoveryFromSubterms(term, parent, term, parent);
+		//System.out.println("recovery: " + recovery);
+		return recovery;
 	}
 
-	private RecoverInterpretation getRecoveryFromSubterms(IStrategoTerm visitedTerm, IStrategoTerm term, IStrategoTerm parent) {
-		//System.out.println("    visited: " + visitedTerm);
-
+	private RecoverInterpretation getRecoveryFromSubterms(IStrategoTerm visitedTerm, IStrategoTerm visitedParent, IStrategoTerm term, IStrategoTerm parent) {
 		//visited term may provide a candidate recovery
-		RecoverInterpretation candidateFromVisited = recoveryLookup.get(visitedTerm);
+		RecoverInterpretation candidateFromVisited = lookupRecovery(visitedTerm, null);
 		assert candidateFromVisited == null || candidateFromVisited.getTerm() == visitedTerm;
 		if(candidateFromVisited != null && candidateFromVisited.hasSameSort(term, parent)){
 			//optimal interpretation for the fragment already found, no need to further traverse subterms 
@@ -110,14 +111,16 @@
 			if(candidateFromVisited.hasCompatibleSort(term, parent)){
 				return RecoverInterpretation.createReplaceBySubtermsInterpretation(term, parent, candidateFromVisited);
 			}
-			return null;
+			//return null;
 		}
 		
 		//traverse subterms of subterm
 		ArrayList<RecoverInterpretation> candidatesFromSubterms = new ArrayList<RecoverInterpretation> ();
 		for (int i = 0; i < visitedTerm.getSubtermCount(); i++) {
 			IStrategoTerm subterm = visitedTerm.getSubterm(i);
-			RecoverInterpretation subtermRecovery = getRecoveryFromSubterms(subterm, term, parent);
+			//System.out.println("visited: " + subterm);
+			RecoverInterpretation subtermRecovery = getRecoveryFromSubterms(subterm, visitedTerm, term, parent);
+			//System.out.println("recovery: " + subtermRecovery);
 			if(subtermRecovery != null){
 				candidatesFromSubterms.add(subtermRecovery);
 				assert subtermRecovery.hasCompatibleSort(term, parent);
@@ -144,7 +147,10 @@
 			for (int i = 0; i < candidatesFromSubterms.size(); i++) {
 				mergedSubtermRecoveries.addAll(candidatesFromSubterms.get(i).getSubtermRecoveries());
 			}
-			RecoverInterpretation fromSubtermsRecovery = RecoverInterpretation.createReplaceBySubtermsInterpretation(term, parent, mergedSubtermRecoveries);
+			RecoverInterpretation fromSubtermsRecovery = null;
+			if(!mergedSubtermRecoveries.isEmpty()){
+				fromSubtermsRecovery = RecoverInterpretation.createReplaceBySubtermsInterpretation(term, parent, mergedSubtermRecoveries);
+			}
 			if(candidateFromVisited != null && candidateFromVisited.hasCompatibleSort(term, parent)){
 				RecoverInterpretation fromVisistedRecovery = RecoverInterpretation.createReplaceBySubtermsInterpretation(term, parent, candidateFromVisited);
 				return this.getMinimumCostRecovery(fromSubtermsRecovery, fromVisistedRecovery);				
@@ -153,6 +159,14 @@
 		}
 	}
 
+	private RecoverInterpretation lookupRecovery(IStrategoTerm visitedTerm, IStrategoTerm parentTerm) {
+		if(recoveryLookup.containsKey(visitedTerm))
+			return recoveryLookup.get(visitedTerm);
+		if(!hasDeletions(visitedTerm))
+			return RecoverInterpretation.createOriginalTermInterpretation(visitedTerm, parentTerm);
+		return null;
+	}
+
 	private RecoverInterpretation getMinimumCostRecovery(ArrayList<RecoverInterpretation> recoveries) {
 		RecoverInterpretation minimumCostInterpretation = null;
 		for (RecoverInterpretation recovery : recoveries) {

From oskarvanrest at gmail.com  Mon Aug  6 04:36:40 2012
From: oskarvanrest at gmail.com (Oskar van Rest)
Date: Mon, 06 Aug 2012 02:36:40 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25257 - in
	experimental/graphical-editor/entitylang/org.spoofax.graphical.entitylang.textual:
	syntax test
Message-ID: <20120806023640.5C6287F8041@mx1.tudelft.nl>

Author: OskarVanRest
Date: Mon Aug  6 02:36:38 2012
New Revision: 25257
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25257&sc=1

Log:
Changed "primitive" into "datatype". Added example (for thesis)

Added:
   experimental/graphical-editor/entitylang/org.spoofax.graphical.entitylang.textual/test/library.analyzed.aterm
   experimental/graphical-editor/entitylang/org.spoofax.graphical.entitylang.textual/test/library.aterm
   experimental/graphical-editor/entitylang/org.spoofax.graphical.entitylang.textual/test/library.ent
Modified:
   experimental/graphical-editor/entitylang/org.spoofax.graphical.entitylang.textual/syntax/EntityLang.sdf
   experimental/graphical-editor/entitylang/org.spoofax.graphical.entitylang.textual/test/example.ent

Modified: experimental/graphical-editor/entitylang/org.spoofax.graphical.entitylang.textual/syntax/EntityLang.sdf
==============================================================================
--- experimental/graphical-editor/entitylang/org.spoofax.graphical.entitylang.textual/syntax/EntityLang.sdf	Sun Aug  5 19:32:45 2012	(r25256)
+++ experimental/graphical-editor/entitylang/org.spoofax.graphical.entitylang.textual/syntax/EntityLang.sdf	Mon Aug  6 02:36:38 2012	(r25257)
@@ -14,5 +14,5 @@
   
     "module" Module@=ID Type*				-> Start {"Module", scope(Type)}
     "entity" Type@=ID "{" Property* "}"		-> Type {"Entity", scope(Property)}
-	"primitive" Type@=ID					-> Type {"Primitive"}
+	"datatype" Type@=ID						-> Type {"DataType"}
     Property@=ID ":" Type at ID				-> Property {"Property"}
\ No newline at end of file

Modified: experimental/graphical-editor/entitylang/org.spoofax.graphical.entitylang.textual/test/example.ent
==============================================================================
--- experimental/graphical-editor/entitylang/org.spoofax.graphical.entitylang.textual/test/example.ent	Sun Aug  5 19:32:45 2012	(r25256)
+++ experimental/graphical-editor/entitylang/org.spoofax.graphical.entitylang.textual/test/example.ent	Mon Aug  6 02:36:38 2012	(r25257)
@@ -18,4 +18,4 @@
   location : String
 }
 
-primitive String
\ No newline at end of file
+datatype String
\ No newline at end of file

Added: experimental/graphical-editor/entitylang/org.spoofax.graphical.entitylang.textual/test/library.analyzed.aterm
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ experimental/graphical-editor/entitylang/org.spoofax.graphical.entitylang.textual/test/library.analyzed.aterm	Mon Aug  6 02:36:38 2012	(r25257)
@@ -0,0 +1,19 @@
+( Module(
+    "library"{[Module(), "library"]}
+  , [ Entity(
+        "Book"{[Type(), "Book", "library"]}
+      , [ Property("title"{[Property(), "title", "Book", "library"]}, "String"{[Type(), "String", "library"]})
+        , Property("author"{[Property(), "author", "Book", "library"]}, "Author"{[Type(), "Author", "library"]})
+        , Property("isbn"{[Property(), "isbn", "Book", "library"]}, "Int"{[Type(), "Int", "library"]})
+        ]
+      )
+    , Entity(
+      	"Author"{[Type(), "Author", "library"]}
+      	, [Property("name"{[Property(), "name", "Author", "library"]}, "String"{[Type(), "String", "library"]})]
+      	)
+    , DataType("String"{[Type(), "String", "library"]})
+    , DataType("Int"{[Type(), "Int", "library"]})
+    ]
+  )
+, []
+)
\ No newline at end of file

Added: experimental/graphical-editor/entitylang/org.spoofax.graphical.entitylang.textual/test/library.aterm
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ experimental/graphical-editor/entitylang/org.spoofax.graphical.entitylang.textual/test/library.aterm	Mon Aug  6 02:36:38 2012	(r25257)
@@ -0,0 +1,11 @@
+Module(
+  "library"
+, [ Entity(
+      "Book"
+    , [Property("title", "String"), Property("author", "Author"), Property("isbn", "Int")]
+    )
+  , Entity("Author", [Property("name", "String")])
+  , DataType("String")
+  , DataType("Int")
+  ]
+)
\ No newline at end of file

Added: experimental/graphical-editor/entitylang/org.spoofax.graphical.entitylang.textual/test/library.ent
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ experimental/graphical-editor/entitylang/org.spoofax.graphical.entitylang.textual/test/library.ent	Mon Aug  6 02:36:38 2012	(r25257)
@@ -0,0 +1,14 @@
+module library
+
+entity Book {
+  title     : String
+  author 	: Author
+  isbn 		: Int
+}
+
+entity Author {
+  name 		: String
+}
+
+datatype String
+datatype Int
\ No newline at end of file

From oskarvanrest at gmail.com  Mon Aug  6 07:43:36 2012
From: oskarvanrest at gmail.com (Oskar van Rest)
Date: Mon, 06 Aug 2012 05:43:36 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25258 -
	experimental/graphical-editor/entitylang/org.spoofax.graphical.entitylang.textual/test
Message-ID: <20120806054336.64E912B8018@mx2.tudelft.nl>

Author: OskarVanRest
Date: Mon Aug  6 05:43:36 2012
New Revision: 25258
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25258&sc=1

Log:


Modified:
   experimental/graphical-editor/entitylang/org.spoofax.graphical.entitylang.textual/test/library.analyzed.aterm
   experimental/graphical-editor/entitylang/org.spoofax.graphical.entitylang.textual/test/library.aterm
   experimental/graphical-editor/entitylang/org.spoofax.graphical.entitylang.textual/test/library.ent

Modified: experimental/graphical-editor/entitylang/org.spoofax.graphical.entitylang.textual/test/library.analyzed.aterm
==============================================================================
--- experimental/graphical-editor/entitylang/org.spoofax.graphical.entitylang.textual/test/library.analyzed.aterm	Mon Aug  6 02:36:38 2012	(r25257)
+++ experimental/graphical-editor/entitylang/org.spoofax.graphical.entitylang.textual/test/library.analyzed.aterm	Mon Aug  6 05:43:36 2012	(r25258)
@@ -2,16 +2,11 @@
     "library"{[Module(), "library"]}
   , [ Entity(
         "Book"{[Type(), "Book", "library"]}
-      , [ Property("title"{[Property(), "title", "Book", "library"]}, "String"{[Type(), "String", "library"]})
-        , Property("author"{[Property(), "author", "Book", "library"]}, "Author"{[Type(), "Author", "library"]})
+      , [ Property("author"{[Property(), "author", "Book", "library"]}, "Author"{[Type(), "Author", "library"]})
         , Property("isbn"{[Property(), "isbn", "Book", "library"]}, "Int"{[Type(), "Int", "library"]})
         ]
       )
-    , Entity(
-      	"Author"{[Type(), "Author", "library"]}
-      	, [Property("name"{[Property(), "name", "Author", "library"]}, "String"{[Type(), "String", "library"]})]
-      	)
-    , DataType("String"{[Type(), "String", "library"]})
+    , Entity("Author"{[Type(), "Author", "library"]}, [])
     , DataType("Int"{[Type(), "Int", "library"]})
     ]
   )

Modified: experimental/graphical-editor/entitylang/org.spoofax.graphical.entitylang.textual/test/library.aterm
==============================================================================
--- experimental/graphical-editor/entitylang/org.spoofax.graphical.entitylang.textual/test/library.aterm	Mon Aug  6 02:36:38 2012	(r25257)
+++ experimental/graphical-editor/entitylang/org.spoofax.graphical.entitylang.textual/test/library.aterm	Mon Aug  6 05:43:36 2012	(r25258)
@@ -2,10 +2,9 @@
   "library"
 , [ Entity(
       "Book"
-    , [Property("title", "String"), Property("author", "Author"), Property("isbn", "Int")]
+    , [Property("author", "Author"), Property("isbn", "Int")]
     )
-  , Entity("Author", [Property("name", "String")])
-  , DataType("String")
+  , Entity("Author", [])
   , DataType("Int")
   ]
 )
\ No newline at end of file

Modified: experimental/graphical-editor/entitylang/org.spoofax.graphical.entitylang.textual/test/library.ent
==============================================================================
--- experimental/graphical-editor/entitylang/org.spoofax.graphical.entitylang.textual/test/library.ent	Mon Aug  6 02:36:38 2012	(r25257)
+++ experimental/graphical-editor/entitylang/org.spoofax.graphical.entitylang.textual/test/library.ent	Mon Aug  6 05:43:36 2012	(r25258)
@@ -1,14 +1,11 @@
 module library
 
 entity Book {
-  title     : String
   author 	: Author
   isbn 		: Int
 }
 
 entity Author {
-  name 		: String
 }
 
-datatype String
 datatype Int
\ No newline at end of file

From m.dejonge at tudelft.nl  Mon Aug  6 11:34:19 2012
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Mon, 06 Aug 2012 09:34:19 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25259 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection
Message-ID: <20120806093419.BF1FC108C02A@mx3.tudelft.nl>

Author: MaartjeDeJonge
Date: Mon Aug  6 09:34:18 2012
New Revision: 25259
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25259&sc=1

Log:


Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java	Mon Aug  6 05:43:36 2012	(r25258)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java	Mon Aug  6 09:34:18 2012	(r25259)
@@ -327,4 +327,8 @@
 	private String getInputString() {
 		return ImploderAttachment.getTokenizer(getTerm()).getInput();
 	}
+
+	public boolean isDiscardRecovery() {
+		return getSubtermRecoveries() != null && getSubtermRecoveries().isEmpty();
+	}
 }

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java	Mon Aug  6 05:43:36 2012	(r25258)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java	Mon Aug  6 09:34:18 2012	(r25259)
@@ -6,7 +6,13 @@
 import java.util.ArrayList;
 import java.util.IdentityHashMap;
 
+import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.ITermFactory;
+import org.spoofax.jsglr.client.imploder.TermTreeFactory;
+import org.spoofax.terms.TermFactory;
+
+import com.sun.xml.internal.bind.marshaller.MinimumEscapeHandler;
 
 /**
  * Analyzes the terms in the correct AST that are affected during editing and therefore (possible) damaged.
@@ -57,8 +63,11 @@
 	private RecoverInterpretation constructMinimalCostRecovery(IStrategoTerm term, IStrategoTerm parent) {
 		//candidates can be null
 		RecoverInterpretation candidate1 = constructRepairSubtermsRecovery(term, parent);
-		if(!hasAssociatedDeletions(term) && term.isList()){
-			return candidate1;
+		if(term.isList()){
+			if(!hasAssociatedDeletions(term))
+				return candidate1;
+			//else
+				//return sublistRecovery(term, parent);
 		}
 		RecoverInterpretation candidate2 = constructReplaceBySubtermsRecovery(term, parent);
 		RecoverInterpretation candidate3 = constructDiscardRecovery(term, parent);
@@ -69,6 +78,66 @@
 		return getMinimumCostRecovery(candidates);
 	}
 	
+	private RecoverInterpretation sublistRecovery(IStrategoTerm term, IStrategoTerm parent) {
+		assert term.isList();
+		assert term.getSubtermCount() != 0;
+		
+		final ITermFactory termFactory = new TermFactory().getFactoryWithStorageType(IStrategoTerm.MUTABLE);
+		final TermTreeFactory termTreeFactory = new TermTreeFactory(termFactory);
+		IStrategoTerm prefixSublist = null;
+		IStrategoTerm suffixSublist = null;
+		for (int i = 0; i < term.getSubtermCount(); i++) {
+			if(i == term.getSubtermCount()-1 || hasCorrectSeparationAfterIndex(term, i)){
+				if(i==0){
+					prefixSublist = term.getSubterm(0);
+				}
+				else{
+					IStrategoTerm firstChild = term.getSubterm(0);
+					IStrategoTerm lastChild = term.getSubterm(i);
+					prefixSublist = termTreeFactory.createSublist((IStrategoList)term, firstChild, lastChild);					
+				}
+				if(i < term.getSubtermCount()-1){
+					IStrategoTerm firstChild = term.getSubterm(i+1);
+					IStrategoTerm lastChild = term.getSubterm(term.getSubtermCount() -1);
+					if(firstChild == lastChild)
+						suffixSublist = firstChild;
+					else
+						suffixSublist = termTreeFactory.createSublist((IStrategoList)term, firstChild, lastChild);
+				}
+			}
+		}
+		assert prefixSublist != null;
+		if(suffixSublist == null){
+			//isRecovered == false
+			//Recovery: prefix => bestSubtermRecovery(prefix)
+		}
+		else {
+			//Recovery_Prefix: prefix => bestSubtermRecovery(prefix)
+			//Recovery_Suffix: suffix => sublistRecovery(suffix, parent)
+			//isRecovered iff both non-discards
+			//Recovery: term, [prefixRec, suffixRec]
+		}
+		
+		RecoverInterpretation prefixRecovery = null; //TODO
+		RecoverInterpretation suffixRecovery = null;
+		if(suffixSublist != null){
+			suffixRecovery = null; //TODO
+		}
+		
+		
+		return null;
+	}
+
+	private boolean hasCorrectSeparationAfterIndex(IStrategoTerm listTerm, int i) {
+		if(i < listTerm.getSubtermCount() - 1){
+			int startOffset = getRightToken(listTerm.getSubterm(i)).getEndOffset() + 1;
+			int endOffset = getLeftToken(listTerm.getSubterm(i+1)).getStartOffset() - 1;
+			return getCoveredOffsets(startOffset, endOffset, offsetsDeletedChars).isEmpty();
+		}
+		else
+			return true;
+	}
+
 	private RecoverInterpretation constructRepairSubtermsRecovery(IStrategoTerm term, IStrategoTerm parent) {
 		if(hasAssociatedDeletions(term))
 			return null; //term itself is broken thus it can not be recovered by repairing subterms
@@ -100,20 +169,59 @@
 	}
 
 	private RecoverInterpretation getRecoveryFromSubterms(IStrategoTerm visitedTerm, IStrategoTerm visitedParent, IStrategoTerm term, IStrategoTerm parent) {
-		//visited term may provide a candidate recovery
+		//set recover interpretation provided by the visited term
+		RecoverInterpretation fromVisitedRecovery = null;
 		RecoverInterpretation candidateFromVisited = lookupRecovery(visitedTerm, null);
-		assert candidateFromVisited == null || candidateFromVisited.getTerm() == visitedTerm;
-		if(candidateFromVisited != null && candidateFromVisited.hasSameSort(term, parent)){
+		if(candidateFromVisited != null && candidateFromVisited.hasCompatibleSort(term, parent)){
+			assert candidateFromVisited.getTerm() == visitedTerm;
+			fromVisitedRecovery = RecoverInterpretation.createReplaceBySubtermsInterpretation(term, parent, candidateFromVisited);
+			assert fromVisitedRecovery != null && fromVisitedRecovery.getTerm() == term && fromVisitedRecovery.hasCompatibleSort(term, parent);
+		}
+
+		//return from visited recovery if that is known to be better than interpretations provided by its subterms
+		if(fromVisitedRecovery != null && (fromVisitedRecovery.hasSameSort(term, parent) || candidateFromVisited.isUndamagedTerm())){
 			//optimal interpretation for the fragment already found, no need to further traverse subterms 
-			return RecoverInterpretation.createReplaceBySubtermsInterpretation(term, parent, candidateFromVisited);
+			return fromVisitedRecovery;
 		}
-		if(candidateFromVisited != null && candidateFromVisited.isUndamagedTerm()){
-			if(candidateFromVisited.hasCompatibleSort(term, parent)){
-				return RecoverInterpretation.createReplaceBySubtermsInterpretation(term, parent, candidateFromVisited);
-			}
-			//return null;
+
+		//find candidates by traversing subterms of visited term
+		RecoverInterpretation fromSubtermsRecovery = null;
+		if(parent == null || !parent.isList()){
+			fromSubtermsRecovery = getMinimumCostRecoveryFromChildterms(visitedTerm, term, parent);
 		}
-		
+		else { //parent is list
+			//TODO: separators?
+			fromSubtermsRecovery = getMergedRecoveriesFromChildTerms(visitedTerm, term, parent);
+		}
+
+		//compares recovery from subterms and recovery from visited term and chooses the best of both.
+		RecoverInterpretation minimumCostRecovery = getMinimumCostRecovery(fromSubtermsRecovery, fromVisitedRecovery);
+		assert minimumCostRecovery == null || (minimumCostRecovery.getTerm() == term && minimumCostRecovery.hasCompatibleSort(term, parent)) ;
+		return minimumCostRecovery;
+	}
+
+	private RecoverInterpretation getMergedRecoveriesFromChildTerms(
+			IStrategoTerm visitedTerm, IStrategoTerm term, IStrategoTerm parent) {
+		ArrayList<RecoverInterpretation> candidatesFromSubterms = getRecoverCandidatesFromChildTerms(visitedTerm, term, parent);
+		ArrayList<RecoverInterpretation> mergedSubtermRecoveries = new ArrayList<RecoverInterpretation>();
+		for (int i = 0; i < candidatesFromSubterms.size(); i++) {
+			mergedSubtermRecoveries.addAll(candidatesFromSubterms.get(i).getSubtermRecoveries());
+		}
+		RecoverInterpretation fromSubtermsRecovery = null;
+		if(!mergedSubtermRecoveries.isEmpty()){
+			fromSubtermsRecovery = RecoverInterpretation.createReplaceBySubtermsInterpretation(term, parent, mergedSubtermRecoveries);
+		}
+		return fromSubtermsRecovery;
+	}
+
+	private RecoverInterpretation getMinimumCostRecoveryFromChildterms(IStrategoTerm visitedTerm, IStrategoTerm term, IStrategoTerm parent) {
+		ArrayList<RecoverInterpretation> candidatesFromSubterms = getRecoverCandidatesFromChildTerms(visitedTerm, term, parent);
+		RecoverInterpretation minimumCostRecovery = getMinimumCostRecovery(candidatesFromSubterms); //can be null
+		return minimumCostRecovery;
+	}
+
+	private ArrayList<RecoverInterpretation> getRecoverCandidatesFromChildTerms(
+			IStrategoTerm visitedTerm, IStrategoTerm term, IStrategoTerm parent) {
 		//traverse subterms of subterm
 		ArrayList<RecoverInterpretation> candidatesFromSubterms = new ArrayList<RecoverInterpretation> ();
 		for (int i = 0; i < visitedTerm.getSubtermCount(); i++) {
@@ -121,42 +229,13 @@
 			//System.out.println("visited: " + subterm);
 			RecoverInterpretation subtermRecovery = getRecoveryFromSubterms(subterm, visitedTerm, term, parent);
 			//System.out.println("recovery: " + subtermRecovery);
-			if(subtermRecovery != null){
-				candidatesFromSubterms.add(subtermRecovery);
+			if(subtermRecovery != null && !subtermRecovery.isDiscardRecovery()){
 				assert subtermRecovery.hasCompatibleSort(term, parent);
+				assert subtermRecovery.getTerm() == term;
+				candidatesFromSubterms.add(subtermRecovery);
 			}
 		}
-		
-		//non-list elements: pick best
-		//TODO: what if term is list, what about separators
-		if(parent == null || !parent.isList()){
-			ArrayList<RecoverInterpretation> candidates = new ArrayList<RecoverInterpretation>();
-			if(candidateFromVisited != null && candidateFromVisited.hasCompatibleSort(term, parent)){
-				candidates.add(RecoverInterpretation.createReplaceBySubtermsInterpretation(term, parent, candidateFromVisited));
-			}
-			for (RecoverInterpretation subRecovery : candidatesFromSubterms) {
-				candidates.add(RecoverInterpretation.createReplaceBySubtermsInterpretation(term, parent, subRecovery));
-			}
-			RecoverInterpretation minimumCostRecovery = getMinimumCostRecovery(candidates);
-			if(minimumCostRecovery != null)
-				return RecoverInterpretation.createReplaceBySubtermsInterpretation(term, parent, minimumCostRecovery);
-			return null;
-		}
-		else { //parent is list
-			ArrayList<RecoverInterpretation> mergedSubtermRecoveries = new ArrayList<RecoverInterpretation>();
-			for (int i = 0; i < candidatesFromSubterms.size(); i++) {
-				mergedSubtermRecoveries.addAll(candidatesFromSubterms.get(i).getSubtermRecoveries());
-			}
-			RecoverInterpretation fromSubtermsRecovery = null;
-			if(!mergedSubtermRecoveries.isEmpty()){
-				fromSubtermsRecovery = RecoverInterpretation.createReplaceBySubtermsInterpretation(term, parent, mergedSubtermRecoveries);
-			}
-			if(candidateFromVisited != null && candidateFromVisited.hasCompatibleSort(term, parent)){
-				RecoverInterpretation fromVisistedRecovery = RecoverInterpretation.createReplaceBySubtermsInterpretation(term, parent, candidateFromVisited);
-				return this.getMinimumCostRecovery(fromSubtermsRecovery, fromVisistedRecovery);				
-			}
-			return fromSubtermsRecovery;
-		}
+		return candidatesFromSubterms;
 	}
 
 	private RecoverInterpretation lookupRecovery(IStrategoTerm visitedTerm, IStrategoTerm parentTerm) {
@@ -187,7 +266,6 @@
 	}
 
 
-
 	private boolean hasDeletions(IStrategoTerm term) {
 		return !getCoveredOffsets(term, this.offsetsDeletedChars).isEmpty();
 	}
@@ -208,9 +286,14 @@
 	}
 
 	private static ArrayList<Integer> getCoveredOffsets(IStrategoTerm term, ArrayList<Integer> offsets) {
-		ArrayList<Integer> coveredOffsets = new ArrayList<Integer>();
 		int startOffset = getLeftToken(term).getStartOffset();
 		int endOffset = getRightToken(term).getEndOffset();
+		ArrayList<Integer> coveredOffsets = getCoveredOffsets(startOffset, endOffset, offsets);
+		return coveredOffsets;
+	}
+
+	private static ArrayList<Integer> getCoveredOffsets(int startOffset, int endOffset, ArrayList<Integer> offsets) {
+		ArrayList<Integer> coveredOffsets = new ArrayList<Integer>();
 		for (int i = 0; i < offsets.size(); i++) {
 			int offset = offsets.get(i); 
 			if(startOffset <= offset && offset <= endOffset){

From m.dejonge at tudelft.nl  Mon Aug  6 16:32:28 2012
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Mon, 06 Aug 2012 14:32:28 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25260 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test
Message-ID: <20120806143228.A359C2B8020@mx2.tudelft.nl>

Author: MaartjeDeJonge
Date: Mon Aug  6 14:32:28 2012
New Revision: 25260
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25260&sc=1

Log:


Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionInsertonsInToken.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionNestedListElems.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionSeparators.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionInsertonsInToken.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionInsertonsInToken.java	Mon Aug  6 09:34:18 2012	(r25259)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionInsertonsInToken.java	Mon Aug  6 14:32:28 2012	(r25260)
@@ -25,7 +25,7 @@
 		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
 		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
 		super.parseString(editRegionRecovery.getRecoveredInput());
-		Assert.assertEquals("\n\t\tSys tem.out.println(v);", concatenated); 
+		Assert.assertEquals("Sys tem.out.println()", concatenated); 
 	}
 
 	@Test
@@ -35,7 +35,7 @@
 		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
 		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
 		super.parseString(editRegionRecovery.getRecoveredInput());
-		Assert.assertEquals("\n\t\tSysttem.out.println(v);", concatenated); 
+		Assert.assertEquals("Systtem.out.println()", concatenated); 
 	}
 
 	@Test
@@ -55,7 +55,7 @@
 		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
 		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
 		super.parseString(editRegionRecovery.getRecoveredInput());
-		Assert.assertEquals("\n\t\tSys-tem.out.println(v);", concatenated); 
+		Assert.assertEquals("Sys-tem.out.println()", concatenated); 
 	}
 
 	@Test

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionNestedListElems.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionNestedListElems.java	Mon Aug  6 09:34:18 2012	(r25259)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionNestedListElems.java	Mon Aug  6 14:32:28 2012	(r25260)
@@ -18,35 +18,43 @@
 		setJavaParser();
 	}
 
-	@Ignore @Test
+	@Test
 	public void testDeletionInParentElem1() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
-		String expectedConcatenatedDiscards = "@@";
+		String expectedConcatenatedDiscards = "while(i > 5)\n\t\t\t\n\t\t}";
 		String pathToErroneousFile = pathToJavaTestInputs + "/deletion-in-parent-elem1.java";
-		super.parseString(editRegionRecovery.getRecoveredInput());
 		testDiscardedCharacters(expectedConcatenatedDiscards, pathToErroneousFile);
+		super.parseString(editRegionRecovery.getRecoveredInput());
 	}
 
-	@Ignore @Test
+	@Test
 	public void testDeletionInParentElem2() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
-		String expectedConcatenatedDiscards = "@@";
+		String expectedConcatenatedDiscards = "while(i > 5\n\t\t\t\n\t\t}";
 		String pathToErroneousFile = pathToJavaTestInputs + "/deletion-in-parent-elem2.java";
-		super.parseString(editRegionRecovery.getRecoveredInput());
 		testDiscardedCharacters(expectedConcatenatedDiscards, pathToErroneousFile);
+		super.parseString(editRegionRecovery.getRecoveredInput());
 	}
 
-	@Ignore @Test
+	@Test
 	public void testDeletionInParentElem3() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
-		String expectedConcatenatedDiscards = "@@";
+		String expectedConcatenatedDiscards = "while(){\n\t\t\t\n\t\t}";
 		String pathToErroneousFile = pathToJavaTestInputs + "/deletion-in-parent-elem3.java";
-		super.parseString(editRegionRecovery.getRecoveredInput());
 		testDiscardedCharacters(expectedConcatenatedDiscards, pathToErroneousFile);
+		super.parseString(editRegionRecovery.getRecoveredInput());
 	}
 
-	@Ignore @Test
+	@Test
 	public void testDeletionInParentElem4() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
-		String expectedConcatenatedDiscards = "@@";
+		String expectedConcatenatedDiscards = "while(i > 5 {\n\t\t\t\n\t\t}";
 		String pathToErroneousFile = pathToJavaTestInputs + "/deletion-in-parent-elem4.java";
+		testDiscardedCharacters(expectedConcatenatedDiscards, pathToErroneousFile);
 		super.parseString(editRegionRecovery.getRecoveredInput());
+	}
+
+	@Test
+	public void testDeletionInParentAndChild() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String expectedConcatenatedDiscards = "while(i > 5 {\n\t\t\t\n\t\t\ti = i + \n\t\t\t\t\n\t\t\t\n\t\t}";
+		String pathToErroneousFile = pathToJavaTestInputs + "/deletion-in-parent-and-child-elem.java";
 		testDiscardedCharacters(expectedConcatenatedDiscards, pathToErroneousFile);
+		super.parseString(editRegionRecovery.getRecoveredInput());
 	}
 }

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionSeparators.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionSeparators.java	Mon Aug  6 09:34:18 2012	(r25259)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionSeparators.java	Mon Aug  6 14:32:28 2012	(r25260)
@@ -25,7 +25,7 @@
 		ArrayList<Integer> discardOffsets = super.getDiscardOffsets(lastErr0AST, erroneousInput);
 		String concatenated = concatenatedDiscardChars(erroneousInput, discardOffsets);
 		super.parseString(editRegionRecovery.getRecoveredInput());
-		Assert.assertEquals("int y ", concatenated);
+		Assert.assertEquals(" int z", concatenated);
 	}
 	
 	@Test

From m.dejonge at tudelft.nl  Mon Aug  6 16:32:57 2012
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Mon, 06 Aug 2012 14:32:57 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25261 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection
Message-ID: <20120806143257.A1516CC1A4@mx4.tudelft.nl>

Author: MaartjeDeJonge
Date: Mon Aug  6 14:32:57 2012
New Revision: 25261
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25261&sc=1

Log:


Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DiscardableRegion.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/LayoutEditsAnalyzer.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DiscardableRegion.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DiscardableRegion.java	Mon Aug  6 14:32:28 2012	(r25260)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DiscardableRegion.java	Mon Aug  6 14:32:57 2012	(r25261)
@@ -27,7 +27,10 @@
 		this.startOffset = startOffset;
 		this.endOffset = endOffset;
 		this.inputString = inputString;
+		assert inputString != null;
 		assert startOffset <= endOffset;
+		assert startOffset >= 0;
+		assert endOffset <= inputString.length() - 1;
 	}
 
 //getters
@@ -95,7 +98,7 @@
 			}
 		}
 		if(startOffset != -1){
-			DiscardableRegion region = new DiscardableRegion(startOffset, offsets.get(offsets.size()-1), null);
+			DiscardableRegion region = new DiscardableRegion(startOffset, offsets.get(offsets.size()-1), inputString);
 			result.add(region);
 		}
 		return result;		

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java	Mon Aug  6 14:32:28 2012	(r25260)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java	Mon Aug  6 14:32:57 2012	(r25261)
@@ -203,6 +203,11 @@
 	}
 
 	private DiscardableRegion mapRegion(DiscardableRegion region, boolean isInCorrectInputString){
+		String input = this.getCorrectInput();
+		if(isInCorrectInputString){
+			input = this.getErroneousInput();
+		}
+
 		int startOffset = -1;
 		int endOffset = -1;
 		for (int offset = region.getStartOffset(); offset <= region.getEndOffset(); offset++) {
@@ -214,10 +219,6 @@
 			}
 		}
 		if(startOffset >= 0){
-			String input = this.getCorrectInput();
-			if(!isInCorrectInputString){
-				input = this.getErroneousInput();
-			}
 			return new DiscardableRegion(startOffset, endOffset, input);
 		}
 		return null;

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/LayoutEditsAnalyzer.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/LayoutEditsAnalyzer.java	Mon Aug  6 14:32:28 2012	(r25260)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/LayoutEditsAnalyzer.java	Mon Aug  6 14:32:57 2012	(r25261)
@@ -63,8 +63,8 @@
 				}
 				if(!Token.isWhiteSpace(tokenWithDeletions)){
 					DiscardableRegion commentRegion = new DiscardableRegion(tokenWithDeletions.getStartOffset(), tokenWithDeletions.getEndOffset(), input);
-					damagedCommentRegions.add(commentRegion);
 					assert !HelperFunctions.contains(damagedCommentRegions, commentRegion);
+					damagedCommentRegions.add(commentRegion);
 				}
 			}
 		}

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java	Mon Aug  6 14:32:28 2012	(r25260)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java	Mon Aug  6 14:32:57 2012	(r25261)
@@ -189,11 +189,24 @@
 	 * @return
 	 */
 	public static RecoverInterpretation createDiscardInterpretation(IStrategoTerm term, IStrategoTerm parentTerm){
-		assert parentTerm.isList() || HelperFunctions.isSomeNode(term);
+		assert term.isList() || HelperFunctions.isSomeNode(term); //parentTerm.isList()
 		return new RecoverInterpretation(term, parentTerm, false, new ArrayList<RecoverInterpretation>());
 	}
 
 	/**
+	 * Returns a recover interpretation based on repairing sublists with correct separation in between.
+	 * @param term
+	 * @param parentTerm
+	 * @param recoveredSubterms
+	 * @return
+	 */
+	public static RecoverInterpretation createRepairSublistsInterpretation(IStrategoTerm term, IStrategoTerm parentTerm, ArrayList<RecoverInterpretation> recoveredSublists){
+		assert !recoveredSublists.contains(null);
+		//assert sublists cover list (?)
+		return new RecoverInterpretation(term, parentTerm, true, recoveredSublists);
+	}
+
+	/**
 	 * Returns a recover interpretation based on repairing the subterms
 	 * Intended for terms that are not affected themselves, but do have changes in their subterms,
 	 * whereby the child terms can be recovered.
@@ -231,7 +244,7 @@
 	 * @return
 	 */
 	public static RecoverInterpretation createReplaceBySubtermsInterpretation(IStrategoTerm term, IStrategoTerm parentTerm, ArrayList<RecoverInterpretation> recoveredSubterms){
-		assert parentTerm.isList() || recoveredSubterms.size() == 1;
+		assert (parentTerm.isList() && recoveredSubterms.size() >= 1) || recoveredSubterms.size() == 1;
 		return new RecoverInterpretation(term, parentTerm, false, recoveredSubterms);
 	}
 
@@ -250,7 +263,7 @@
 	}
 
 	private void checkAssertions() {
-		assert subtermRecoveries == null? (isRecovered && this.recoveryCosts == 0) : recoveryCosts > 0;
+		assert subtermRecoveries == null? (isRecovered && this.recoveryCosts == 0) : recoveryCosts >= 0;
 		int subtermCosts = 0;
 		if(this.subtermRecoveries != null){
 			for (RecoverInterpretation subtermRecovery : this.subtermRecoveries) {

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java	Mon Aug  6 14:32:28 2012	(r25260)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java	Mon Aug  6 14:32:57 2012	(r25261)
@@ -12,8 +12,6 @@
 import org.spoofax.jsglr.client.imploder.TermTreeFactory;
 import org.spoofax.terms.TermFactory;
 
-import com.sun.xml.internal.bind.marshaller.MinimumEscapeHandler;
-
 /**
  * Analyzes the terms in the correct AST that are affected during editing and therefore (possible) damaged.
  * Constructs a recovery based on discarding tokens associated to erroneous (discardable) terms. 
@@ -62,72 +60,71 @@
 	
 	private RecoverInterpretation constructMinimalCostRecovery(IStrategoTerm term, IStrategoTerm parent) {
 		//candidates can be null
-		RecoverInterpretation candidate1 = constructRepairSubtermsRecovery(term, parent);
-		if(term.isList()){
-			if(!hasAssociatedDeletions(term))
-				return candidate1;
-			//else
-				//return sublistRecovery(term, parent);
+		RecoverInterpretation discardRecovery = constructDiscardRecovery(term, parent);
+		RecoverInterpretation childTermsRecovery = null;
+		if(!term.isList())
+			childTermsRecovery = constructRepairSubtermsRecovery(term, parent);
+		else {
+			childTermsRecovery = sublistRecovery(0, term, parent); 
+			if(childTermsRecovery != null)
+				return childTermsRecovery;
+			return discardRecovery;
 		}
-		RecoverInterpretation candidate2 = constructReplaceBySubtermsRecovery(term, parent);
-		RecoverInterpretation candidate3 = constructDiscardRecovery(term, parent);
+		RecoverInterpretation subTermsRecovery = constructReplaceBySubtermsRecovery(term, parent);
 		ArrayList<RecoverInterpretation> candidates = new ArrayList<RecoverInterpretation>();
-		candidates.add(candidate1);
-		candidates.add(candidate2);
-		candidates.add(candidate3);
+		candidates.add(childTermsRecovery);
+		candidates.add(subTermsRecovery);
+		candidates.add(discardRecovery);
 		return getMinimumCostRecovery(candidates);
 	}
 	
-	private RecoverInterpretation sublistRecovery(IStrategoTerm term, IStrategoTerm parent) {
-		assert term.isList();
-		assert term.getSubtermCount() != 0;
+	private RecoverInterpretation sublistRecovery(int startIndex, IStrategoTerm listTerm, IStrategoTerm parent) {
+		assert listTerm.isList();
+		assert listTerm.getSubtermCount() != 0;
 		
-		final ITermFactory termFactory = new TermFactory().getFactoryWithStorageType(IStrategoTerm.MUTABLE);
-		final TermTreeFactory termTreeFactory = new TermTreeFactory(termFactory);
-		IStrategoTerm prefixSublist = null;
-		IStrategoTerm suffixSublist = null;
-		for (int i = 0; i < term.getSubtermCount(); i++) {
-			if(i == term.getSubtermCount()-1 || hasCorrectSeparationAfterIndex(term, i)){
-				if(i==0){
-					prefixSublist = term.getSubterm(0);
-				}
-				else{
-					IStrategoTerm firstChild = term.getSubterm(0);
-					IStrategoTerm lastChild = term.getSubterm(i);
-					prefixSublist = termTreeFactory.createSublist((IStrategoList)term, firstChild, lastChild);					
-				}
-				if(i < term.getSubtermCount()-1){
-					IStrategoTerm firstChild = term.getSubterm(i+1);
-					IStrategoTerm lastChild = term.getSubterm(term.getSubtermCount() -1);
-					if(firstChild == lastChild)
-						suffixSublist = firstChild;
-					else
-						suffixSublist = termTreeFactory.createSublist((IStrategoList)term, firstChild, lastChild);
+		for (int i = startIndex; i < listTerm.getSubtermCount(); i++) {
+			if(i == listTerm.getSubtermCount()-1 || hasCorrectSeparationAfterIndex(listTerm, i)){
+				int endIndex = i;
+				IStrategoTerm prefixSublist = createSublist(listTerm, startIndex, endIndex);
+				ArrayList<RecoverInterpretation> candidates = 
+						getRecoverCandidatesFromChildTerms(listTerm, startIndex, endIndex, prefixSublist, listTerm);
+				RecoverInterpretation prefixRecovery = getMinimumCostRecovery(candidates);
+				if(prefixRecovery != null){
+					assert prefixRecovery.getTerm() == prefixSublist;
+					assert prefixRecovery.getSubtermRecoveries().size() >= 1;
+					assert !prefixRecovery.isDiscardRecovery();
+					RecoverInterpretation suffixRecovery = sublistRecovery(endIndex + 1, listTerm, parent);
+					if(suffixRecovery != null){
+						assert !suffixRecovery.isDiscardRecovery();
+						ArrayList<RecoverInterpretation> recoveredSubLists = new ArrayList<RecoverInterpretation>();
+						recoveredSubLists.add(prefixRecovery);
+						recoveredSubLists.add(suffixRecovery);
+						return RecoverInterpretation.createRepairSublistsInterpretation(listTerm, parent, recoveredSubLists);
+					}
+					else{ //prefixRecovery != null && suffixRecovery == null
+						ArrayList<RecoverInterpretation> prefixCandidates = prefixRecovery.getSubtermRecoveries();
+						if(startIndex == 0) //whole list recovered with single term
+							return RecoverInterpretation.createReplaceBySubtermsInterpretation(listTerm, parent, prefixCandidates);
+						IStrategoTerm sublist = createSublist(listTerm, startIndex, listTerm.getSubtermCount() - 1);
+						return RecoverInterpretation.createReplaceBySubtermsInterpretation(sublist, listTerm, prefixCandidates);
+					}
 				}
 			}
 		}
-		assert prefixSublist != null;
-		if(suffixSublist == null){
-			//isRecovered == false
-			//Recovery: prefix => bestSubtermRecovery(prefix)
-		}
-		else {
-			//Recovery_Prefix: prefix => bestSubtermRecovery(prefix)
-			//Recovery_Suffix: suffix => sublistRecovery(suffix, parent)
-			//isRecovered iff both non-discards
-			//Recovery: term, [prefixRec, suffixRec]
-		}
-		
-		RecoverInterpretation prefixRecovery = null; //TODO
-		RecoverInterpretation suffixRecovery = null;
-		if(suffixSublist != null){
-			suffixRecovery = null; //TODO
-		}
-		
-		
 		return null;
 	}
 
+	private IStrategoTerm createSublist(IStrategoTerm listTerm, int startIndex,
+			int endIndex) {
+		IStrategoTerm prefixSublist;
+		final ITermFactory termFactory = new TermFactory().getFactoryWithStorageType(IStrategoTerm.MUTABLE);
+		final TermTreeFactory termTreeFactory = new TermTreeFactory(termFactory);
+		IStrategoTerm firstChild = listTerm.getSubterm(startIndex);
+		IStrategoTerm lastChild = listTerm.getSubterm(endIndex);
+		prefixSublist = termTreeFactory.createSublist((IStrategoList)listTerm, firstChild, lastChild);
+		return prefixSublist;
+	}
+
 	private boolean hasCorrectSeparationAfterIndex(IStrategoTerm listTerm, int i) {
 		if(i < listTerm.getSubtermCount() - 1){
 			int startOffset = getRightToken(listTerm.getSubterm(i)).getEndOffset() + 1;
@@ -155,7 +152,7 @@
 	}
 	
 	private RecoverInterpretation constructDiscardRecovery(IStrategoTerm term, IStrategoTerm parent) {
-		if(HelperFunctions.isSomeNode(term) || (parent != null && parent.isList())){
+		if(HelperFunctions.isSomeNode(term) || term.isList()){ //|| (parent != null && parent.isList())
 			return RecoverInterpretation.createDiscardInterpretation(term, parent);
 		}
 		return null;
@@ -222,9 +219,23 @@
 
 	private ArrayList<RecoverInterpretation> getRecoverCandidatesFromChildTerms(
 			IStrategoTerm visitedTerm, IStrategoTerm term, IStrategoTerm parent) {
+		if(visitedTerm.getSubtermCount() == 0)
+			return new ArrayList<RecoverInterpretation>();
+		int startIndex = 0;
+		int endIndex = visitedTerm.getSubtermCount() - 1;
+		ArrayList<RecoverInterpretation> candidatesFromSubterms = getRecoverCandidatesFromChildTerms(visitedTerm, startIndex, endIndex, term, parent);
+		return candidatesFromSubterms;
+	}
+
+	private ArrayList<RecoverInterpretation> getRecoverCandidatesFromChildTerms(
+			IStrategoTerm visitedTerm, int startIndex, int endIndex,
+			IStrategoTerm term, IStrategoTerm parent) {
+		assert endIndex <= visitedTerm.getSubtermCount()-1;
+		assert startIndex >= 0;
+		assert startIndex <= endIndex;
 		//traverse subterms of subterm
 		ArrayList<RecoverInterpretation> candidatesFromSubterms = new ArrayList<RecoverInterpretation> ();
-		for (int i = 0; i < visitedTerm.getSubtermCount(); i++) {
+		for (int i = startIndex; i <= endIndex; i++) {
 			IStrategoTerm subterm = visitedTerm.getSubterm(i);
 			//System.out.println("visited: " + subterm);
 			RecoverInterpretation subtermRecovery = getRecoveryFromSubterms(subterm, visitedTerm, term, parent);

From m.dejonge at tudelft.nl  Tue Aug  7 09:46:18 2012
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Tue, 07 Aug 2012 07:46:18 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25262 - in
	spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego:
	. edit-sequence
Message-ID: <20120807074618.CDF5E7F8051@mx1.tudelft.nl>

Author: MaartjeDeJonge
Date: Tue Aug  7 07:46:15 2012
New Revision: 25262
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25262&sc=1

Log:


Added:
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/bashRename.sh   (contents, props changed)
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_1.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_10.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_11.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_12.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_13.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_14.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_15.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_16.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_17.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_18.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_19.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_2.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_20.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_21.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_22.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_23.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_24.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_25.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_26.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_27.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_28.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_29.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_3.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_30.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_31.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_32.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_33.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_34.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_35.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_36.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_37.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_38.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_39.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_4.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_40.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_41.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_42.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_43.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_44.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_45.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_46.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_47.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_48.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_49.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_5.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_50.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_51.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_52.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_53.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_54.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_55.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_56.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_57.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_58.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_59.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_6.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_60.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_61.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_62.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_63.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_64.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_65.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_66.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_67.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_68.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_69.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_7.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_70.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_71.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_72.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_73.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_8.str.scn
   spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_9.str.scn

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/bashRename.sh
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/bashRename.sh	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,9 @@
+#bash
+counter=1;
+for f in *str.scn; do 
+	echo $f
+	echo edit_$counter.str.scn; 
+	mv $f edit_$counter.str.scn; 
+	counter=`expr $counter + 1` 
+done
+

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_1.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_1.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,187 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			result := $[Seq([strategy], [<concat-listOfIfs(|x)> xs])]
+	
+	concat-listOfIfs(|strategy):
+		[] -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_10.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_10.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,188 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	<write-to-string;
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			result := $[Seq([strategy], [<concat-listOfIfs(|x)> xs])]
+	
+	concat-listOfIfs(|strategy):
+		[] -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_11.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_11.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,188 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	<write-to-string;deb
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			result := $[Seq([strategy], [<concat-listOfIfs(|x)> xs])]
+	
+	concat-listOfIfs(|strategy):
+		[] -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_12.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_12.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,188 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	<write-to-string;debug>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			result := $[Seq([strategy], [<concat-listOfIfs(|x)> xs])]
+	
+	concat-listOfIfs(|strategy):
+		[] -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_13.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_13.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,188 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	<write-to-string;debug> l
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			result := $[Seq([strategy], [<concat-listOfIfs(|x)> xs])]
+	
+	concat-listOfIfs(|strategy):
+		[] -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_14.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_14.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,189 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			result := $[Seq([strategy], [<concat-listOfIfs(|x)> xs])]
+	
+	concat-listOfIfs(|strategy):
+		[] -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_15.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_15.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,189 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<w
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			result := $[Seq([strategy], [<concat-listOfIfs(|x)> xs])]
+	
+	concat-listOfIfs(|strategy):
+		[] -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_16.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_16.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,189 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-strin;
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			result := $[Seq([strategy], [<concat-listOfIfs(|x)> xs])]
+	
+	concat-listOfIfs(|strategy):
+		[] -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_17.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_17.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,189 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			result := $[Seq([strategy], [<concat-listOfIfs(|x)> xs])]
+	
+	concat-listOfIfs(|strategy):
+		[] -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_18.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_18.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,189 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			result := $[Seq([strategy], [<concat-listOfIfs(|x)> xs])]
+	
+	concat-listOfIfs(|strategy):
+		[] -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_19.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_19.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,189 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;eb
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			result := $[Seq([strategy], [<concat-listOfIfs(|x)> xs])]
+	
+	concat-listOfIfs(|strategy):
+		[] -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_2.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_2.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,188 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			result := $[Seq([strategy], [<concat-listOfIfs(|x)> xs])]
+	
+	concat-listOfIfs(|strategy):
+		[] -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_20.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_20.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,189 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			result := $[Seq([strategy], [<concat-listOfIfs(|x)> xs])]
+	
+	concat-listOfIfs(|strategy):
+		[] -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_21.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_21.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,189 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;de
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			result := $[Seq([strategy], [<concat-listOfIfs(|x)> xs])]
+	
+	concat-listOfIfs(|strategy):
+		[] -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_22.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_22.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,189 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug>
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			result := $[Seq([strategy], [<concat-listOfIfs(|x)> xs])]
+	
+	concat-listOfIfs(|strategy):
+		[] -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_23.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_23.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,189 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> s
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			result := $[Seq([strategy], [<concat-listOfIfs(|x)> xs])]
+	
+	concat-listOfIfs(|strategy):
+		[] -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_24.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_24.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,187 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			result := $[Seq([strategy], [<concat-listOfIfs(|x)> xs])]
+	
+
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_25.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_25.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,189 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+		concat-listOfIfs(|strategy):
+		[] -> strategy
+				
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			result := $[Seq([strategy], [<concat-listOfIfs(|x)> xs])]	
+
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_26.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_26.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,189 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			result := $[Seq([strategy], [<concat-listOfIfs(|x)> xs])]
+	
+	concat-listOfIfs(|strategy):
+		[] -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_27.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_27.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,189 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			result := $[Seq([strategy], [<concat-listOfIfs(|x)> xs])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_28.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_28.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,190 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			;
+			result := $[Seq([strategy], [<concat-listOfIfs(|x)> xs])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_29.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_29.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,190 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			; deb
+			result := $[Seq([strategy], [<concat-listOfIfs(|x)> xs])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_3.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_3.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,188 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	w
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			result := $[Seq([strategy], [<concat-listOfIfs(|x)> xs])]
+	
+	concat-listOfIfs(|strategy):
+		[] -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_30.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_30.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,190 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			; <debug
+			result := $[Seq([strategy], [<concat-listOfIfs(|x)> xs])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_31.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_31.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,190 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			; <debug>
+			result := $[Seq([strategy], [<concat-listOfIfs(|x)> xs])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_32.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_32.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,190 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			; <debug> d
+			result := $[Seq([strategy], [<concat-listOfIfs(|x)> xs])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_33.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_33.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,190 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			; <debug> st
+			result := $[Seq([strategy], [<concat-listOfIfs(|x)> xs])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_34.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_34.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,190 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+			result := $[Seq([strategy], [<concat-listOfIfs(|x)> xs])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_35.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_35.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,190 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+			;result := $[Seq([strategy], [<concat-listOfIfs(|x)> xs])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_36.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_36.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,190 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+			; result := $[Seq([strategy], [])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_37.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_37.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,190 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+			; result := $[Seq([strategy], [r])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_38.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_38.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,191 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+		;
+			; result := $[Seq([strategy], [r'])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_39.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_39.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,191 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+		;
+		; result := $[Seq([strategy], [r'])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_4.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_4.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,188 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			result := $[Seq([strategy], [<concat-listOfIfs(|x)> xs])]
+	
+	concat-listOfIfs(|strategy):
+		[] -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_40.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_40.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,191 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+		;	r
+		; 	result := $[Seq([strategy], [r'])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_41.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_41.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,191 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+		;	r' :
+		; 	result := $[Seq([strategy], [r'])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_42.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_42.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,191 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+		;	r' :=
+		; 	result := $[Seq([strategy], [r'])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_43.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_43.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,191 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+		;	r' := <concat-listOfIfs(|x)> xs
+		; 	result := $[Seq([strategy], [r'])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_44.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_44.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,192 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+		;	r' := <concat-listOfIfs(|x)> xs
+		;	
+		; 	result := $[Seq([strategy], [r'])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_45.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_45.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,192 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+		;	r' := <concat-listOfIfs(|x)> xs
+		;	<
+		; 	result := $[Seq([strategy], [r'])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_46.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_46.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,192 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+		;	r' := <concat-listOfIfs(|x)> xs
+		;	<d
+		; 	result := $[Seq([strategy], [r'])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_47.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_47.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,192 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+		;	r' := <concat-listOfIfs(|x)> xs
+		;	<debug>
+		; 	result := $[Seq([strategy], [r'])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_48.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_48.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,192 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+		;	r' := <concat-listOfIfs(|x)> xs
+		;	<debug> r'
+		; 	result := $[Seq([strategy], [r'])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_49.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_49.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,192 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+		;	r' := <concat-listOfIfs(|x)> xs
+		;	<write-to-string;debug> r'
+		; 	result := $[Seq([strategy], [r'])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_5.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_5.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,188 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	!
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			result := $[Seq([strategy], [<concat-listOfIfs(|x)> xs])]
+	
+	concat-listOfIfs(|strategy):
+		[] -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_50.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_50.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,192 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+		;	r' := <concat-listOfIfs(|x)> xs
+		;	<write-to-string;debug> r'
+		; 	result := $[Seq([strategy], [r'])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> $strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_51.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_51.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,192 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+		;	r' := <concat-listOfIfs(|x)> xs
+		;	<write-to-string;debug> r'
+		; 	result := $[Seq([strategy], [r'])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> $[strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_52.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_52.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,192 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+		;	r' := <concat-listOfIfs(|x)> xs
+		;	<write-to-string;debug> r'
+		; 	result := $[Seq([strategy], [r'])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> $[[strategy]]
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_53.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_53.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,193 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+		;	r' := <concat-listOfIfs(|x)> xs
+		;	<write-to-string;debug> r'
+		;
+		; 	result := $[Seq([strategy], [r'])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> $[[strategy]]
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_54.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_54.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,193 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+		;	r' := <concat-listOfIfs(|x)> xs
+		;	<write-to-string;debug> r'
+		; 	<
+		; 	result := $[Seq([strategy], [r'])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> $[[strategy]]
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_55.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_55.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,193 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+		;	r' := <concat-listOfIfs(|x)> xs
+		;	<write-to-string;debug> r'
+		; 	<wr
+		; 	result := $[Seq([strategy], [r'])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> $[[strategy]]
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_56.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_56.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,193 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+		;	r' := <concat-listOfIfs(|x)> xs
+		;	<write-to-string;debug> r'
+		; 	<
+		; 	result := $[Seq([strategy], [r'])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> $[[strategy]]
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_57.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_57.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,193 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+		;	r' := <concat-listOfIfs(|x)> xs
+		;	<write-to-string;debug> r'
+		; 	<c
+		; 	result := $[Seq([strategy], [r'])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> $[[strategy]]
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_58.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_58.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,193 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+		;	r' := <concat-listOfIfs(|x)> xs
+		;	<write-to-string;debug> r'
+		; 	<concat-strings;
+		; 	result := $[Seq([strategy], [r'])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> $[[strategy]]
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_59.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_59.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,193 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+		;	r' := <concat-listOfIfs(|x)> xs
+		;	<write-to-string;debug> r'
+		; 	<concat-strings;deb
+		; 	result := $[Seq([strategy], [r'])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> $[[strategy]]
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_6.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_6.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,188 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	!l
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			result := $[Seq([strategy], [<concat-listOfIfs(|x)> xs])]
+	
+	concat-listOfIfs(|strategy):
+		[] -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_60.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_60.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,193 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+		;	r' := <concat-listOfIfs(|x)> xs
+		;	<write-to-string;debug> r'
+		; 	<concat-strings;debug>
+		; 	result := $[Seq([strategy], [r'])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> $[[strategy]]
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_61.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_61.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,193 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+		;	r' := <concat-listOfIfs(|x)> xs
+		;	<write-to-string;debug> r'
+		; 	<concat-strings;debug> []
+		; 	result := $[Seq([strategy], [r'])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> $[[strategy]]
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_62.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_62.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,193 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+		;	r' := <concat-listOfIfs(|x)> xs
+		;	<write-to-string;debug> r'
+		; 	<concat-strings;debug> [<]
+		; 	result := $[Seq([strategy], [r'])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> $[[strategy]]
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_63.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_63.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,193 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+		;	r' := <concat-listOfIfs(|x)> xs
+		;	<write-to-string;debug> r'
+		; 	<concat-strings;debug> [<wr]
+		; 	result := $[Seq([strategy], [r'])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> $[[strategy]]
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_64.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_64.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,193 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+		;	r' := <concat-listOfIfs(|x)> xs
+		;	<write-to-string;debug> r'
+		; 	<concat-strings;debug> []
+		; 	result := $[Seq([strategy], [r'])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> $[[strategy]]
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_65.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_65.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,193 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+		;	r' := <concat-listOfIfs(|x)> xs
+		;	<write-to-string;debug> r'
+		; 	<concat-strings;debug> ["]
+		; 	result := $[Seq([strategy], [r'])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> $[[strategy]]
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_66.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_66.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,193 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+		;	r' := <concat-listOfIfs(|x)> xs
+		;	<write-to-string;debug> r'
+		; 	<concat-strings;debug> ["xs: "]
+		; 	result := $[Seq([strategy], [r'])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> $[[strategy]]
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_67.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_67.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,193 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+		;	r' := <concat-listOfIfs(|x)> xs
+		;	<write-to-string;debug> r'
+		; 	<concat-strings;debug> ["xs: ";]
+		; 	result := $[Seq([strategy], [r'])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> $[[strategy]]
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_68.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_68.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,193 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+		;	r' := <concat-listOfIfs(|x)> xs
+		;	<write-to-string;debug> r'
+		; 	<concat-strings;debug> ["xs: "]
+		; 	result := $[Seq([strategy], [r'])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> $[[strategy]]
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_69.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_69.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,193 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+		;	r' := <concat-listOfIfs(|x)> xs
+		;	<write-to-string;debug> r'
+		; 	<concat-strings;debug> ["xs: ",]
+		; 	result := $[Seq([strategy], [r'])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> $[[strategy]]
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_7.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_7.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,188 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			result := $[Seq([strategy], [<concat-listOfIfs(|x)> xs])]
+	
+	concat-listOfIfs(|strategy):
+		[] -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_70.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_70.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,193 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+		;	r' := <concat-listOfIfs(|x)> xs
+		;	<write-to-string;debug> r'
+		; 	<concat-strings;debug> ["xs: ",<]
+		; 	result := $[Seq([strategy], [r'])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> $[[strategy]]
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_71.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_71.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,193 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+		;	r' := <concat-listOfIfs(|x)> xs
+		;	<write-to-string;debug> r'
+		; 	<concat-strings;debug> ["xs: ",<w]
+		; 	result := $[Seq([strategy], [r'])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> $[[strategy]]
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_72.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_72.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,193 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+		;	r' := <concat-listOfIfs(|x)> xs
+		;	<write-to-string;debug> r'
+		; 	<concat-strings;debug> ["xs: ",<write-to-string>]
+		; 	result := $[Seq([strategy], [r'])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> $[[strategy]]
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_73.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_73.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,193 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <all-keys-CoverageRules>
+		;	<write-to-string;debug> listOfIfs
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		;	<write-to-string;debug> strategy'
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			 <debug> strategy
+		;	r' := <concat-listOfIfs(|x)> xs
+		;	<write-to-string;debug> r'
+		; 	<concat-strings;debug> ["xs: ",<write-to-string> xs]
+		; 	result := $[Seq([strategy], [r'])]
+	
+	concat-listOfIfs(|strategy):
+		_ -> $[[strategy]]
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_8.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_8.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,188 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	<
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			result := $[Seq([strategy], [<concat-listOfIfs(|x)> xs])]
+	
+	concat-listOfIfs(|strategy):
+		[] -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_9.str.scn
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/tests-editregions/stratego/edit-sequence/edit_9.str.scn	Tue Aug  7 07:46:15 2012	(r25262)
@@ -0,0 +1,188 @@
+module coverage
+
+imports
+	coverage/construct-text
+	coverage/layout-adaption
+	coverage/origin-tracking
+	include/SpoofaxLang
+	libstrc
+	
+rules
+	
+	external parse-str-file(|)
+	external apply-inline-coverage(|newProjectName, ast)
+	external change-files(|astChanges, textChanges)
+	
+	
+	run-with-coverage(|projectname, filename)=
+		file:= <parse-str-file> filename
+	;	coverageProjectName := <conc-strings> (projectname,"-CoverageTest")
+	;	astChanges := <apply-inline-coverage(|coverageProjectName, file)>
+	; 	textReplaceTerm:= <construct-textual-change(pp-dynRules)> astChanges
+	  	;	<write-to-string;debug> astChanges
+	  	;	<write-to-string;debug> textReplaceTerm
+	;	<conc-strings;change-files(|astChanges,textReplaceTerm)> (coverageProjectName, "/trans/analysis.str") 
+	
+	pp-dynRules =
+    	pp-stratego-string
+	
+    inlineCoverage:
+		(_,ast2,_,ast,path,project-path) -> ([(ast,new-ast')], fatal-errors, errors, warnings)
+		with
+			rules(MainStrategy := "analyse")
+		;   new-ast := <topdown(try(inlineCoverageRules))> ast
+		;	fatal-errors:= []
+		;	errors := []
+		; 	warnings := []
+		;	MainStrategy;debug
+		;	new-ast' := <topdown(try(write-feedback))> new-ast
+		
+			
+	write-feedback:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		where
+			!name; debug;
+			<eq> (name, <MainStrategy>)
+			;<debug> "ok!"
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	<w
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		 	
+	write-feedback:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+			
+	write-feedback:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+			
+	write-feedback:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+		
+	write-feedback: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		where
+			<eq> (name, <MainStrategy>)
+		with
+			listOfIfs := <map(add-feedback)> <bagof-CoverageRules>
+		;	strategy' := <concat-listOfIfs(|strategy)> listOfIfs
+	
+	concat-listOfIfs(|strategy):
+		[x | xs] -> result
+		with
+			result := $[Seq([strategy], [<concat-listOfIfs(|x)> xs])]
+	
+	concat-listOfIfs(|strategy):
+		[] -> strategy
+				
+	add-feedback=
+		?ruleName
+	;	dr1 := <conc-strings> (ruleName, "_1")
+	;	!IfThen(BA(CallNoArgs(SVar(dr1)), NoAnnoList(Int("1"))), GenDynRules([SetDynRuleMatch(DynRuleId(RDecNoArgs("Covered")), NoAnnoList(Str(<double-quote> dr1)))]))
+			
+	inlineCoverageRules:
+		SDefNoArgs(name,strategy) -> SDefNoArgs(name,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		SDef(name,args,strategy) -> SDef(name,args,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		SDefT(name,args1,args2,strategy) -> SDefT(name,args1,args2,strategy')
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,strategy)) -> RDefNoArgs(name,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+			
+	inlineCoverageRules:
+		RDefNoArgs(name,Rule(a,b,WithClause(strategy))) -> RDefNoArgs(name,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,strategy)) -> RDef(name,args,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+			
+	inlineCoverageRules:
+		RDef(name,args,Rule(a,b,WithClause(strategy))) -> RDef(name,args,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,strategy)) -> RDefT(name,args1,args2,Rule(a,b,strategy'))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+		
+	inlineCoverageRules: 
+		RDefT(name,args1,args2,Rule(a,b,WithClause(strategy))) -> RDefT(name,args1,args2,Rule(a,b,WithClause(strategy')))
+		with
+			strategy' := <try(surroundStrategy(|name))> strategy
+	
+	surroundStrategy(|name)=
+		?strategy
+	;	if not(<eq> (name,<MainStrategy>)) then
+			mainName := <newname> name
+		;	rules(CoverageRules : mainName)
+		;	dr1_name := <concat-strings> [mainName, "_1"]
+		;	dr1 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr1_name)), NoAnnoList(Int("1")))])
+		;	dr2_name := <concat-strings> [mainName, "_2"]
+		;	dr2 := GenDynRules([DynRuleAssign(DynRuleId(RDecNoArgs(dr2_name)), NoAnnoList(Int("1")))])
+		;	!Seq(dr1,Seq(strategy,dr2))
+		end
+				
\ No newline at end of file

From m.dejonge at tudelft.nl  Tue Aug  7 09:47:28 2012
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Tue, 07 Aug 2012 07:47:28 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25263 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection
Message-ID: <20120807074728.51180108C009@mx3.tudelft.nl>

Author: MaartjeDeJonge
Date: Tue Aug  7 07:47:27 2012
New Revision: 25263
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25263&sc=1

Log:


Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DiscardableRegion.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DiscardableRegion.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DiscardableRegion.java	Tue Aug  7 07:46:15 2012	(r25262)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DiscardableRegion.java	Tue Aug  7 07:47:27 2012	(r25263)
@@ -185,6 +185,11 @@
 	public String constructFragment() {
 		return inputString.substring(getStartOffset(), getEndOffset() + 1);
 	}
+	
+	@Override
+	public String toString(){
+		return constructFragment();
+	}
 
 //private functions
 	

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java	Tue Aug  7 07:46:15 2012	(r25262)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java	Tue Aug  7 07:47:27 2012	(r25263)
@@ -9,6 +9,7 @@
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.ITermFactory;
+import org.spoofax.jsglr.client.imploder.ImploderAttachment;
 import org.spoofax.jsglr.client.imploder.TermTreeFactory;
 import org.spoofax.terms.TermFactory;
 
@@ -54,8 +55,12 @@
 		for (int i = 0; i < term.getSubtermCount(); i++) {
 			collectRecoveries(term.getSubterm(i), term);
 		}
-		RecoverInterpretation recovery = constructMinimalCostRecovery(term, parent);		
-		recoveryLookup.put(term, recovery);
+		int s = ImploderAttachment.getLeftToken(term).getStartOffset();
+		int e =ImploderAttachment.getRightToken(term).getEndOffset();
+		System.out.println(ImploderAttachment.getTokenizer(term).getInput().substring(s, e+1));
+		RecoverInterpretation recovery = constructMinimalCostRecovery(term, parent);
+		if(recovery != null)
+			recoveryLookup.put(term, recovery);
 	}
 	
 	private RecoverInterpretation constructMinimalCostRecovery(IStrategoTerm term, IStrategoTerm parent) {

From m.dejonge at tudelft.nl  Tue Aug  7 10:08:54 2012
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Tue, 07 Aug 2012 08:08:54 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25264 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test
Message-ID: <20120807080854.CB33C108C02E@mx3.tudelft.nl>

Author: MaartjeDeJonge
Date: Tue Aug  7 08:08:54 2012
New Revision: 25264
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25264&sc=1

Log:


Added:
   spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditSequenceStratego.java   (contents, props changed)
Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/AbstractTestRegionDetection.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionNestedListElems.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/AbstractTestRegionDetection.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/AbstractTestRegionDetection.java	Tue Aug  7 07:47:27 2012	(r25263)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/AbstractTestRegionDetection.java	Tue Aug  7 08:08:54 2012	(r25264)
@@ -98,4 +98,12 @@
 				lastErr0AST = parseFile(pathToCorrectFile);
 			}
 
+	protected void setStrategoParser() throws IOException,
+	InvalidParseTableException, FileNotFoundException,
+	BadTokenException, TokenExpectedException, ParseException,
+	SGLRException {
+		String pathToParseTable = "tests/grammars/Stratego.tbl";
+		setSGLR(pathToParseTable);
+	}
+
 }
\ No newline at end of file

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionNestedListElems.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionNestedListElems.java	Tue Aug  7 07:47:27 2012	(r25263)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionNestedListElems.java	Tue Aug  7 08:08:54 2012	(r25264)
@@ -3,7 +3,6 @@
 
 import java.io.IOException;
 
-import org.junit.Ignore;
 import org.junit.Test;
 import org.spoofax.jsglr.client.InvalidParseTableException;
 import org.spoofax.jsglr.client.ParseException;

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditSequenceStratego.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditSequenceStratego.java	Tue Aug  7 08:08:54 2012	(r25264)
@@ -0,0 +1,75 @@
+package org.spoofax.jsglr.client.editregion.test;
+
+import java.io.FileNotFoundException;
+import java.io.IOException;
+
+import org.junit.Test;
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParseException;
+import org.spoofax.jsglr.client.editregion.detection.EditRegionDetector;
+import org.spoofax.jsglr.shared.BadTokenException;
+import org.spoofax.jsglr.shared.SGLRException;
+import org.spoofax.jsglr.shared.TokenExpectedException;
+
+public class TestEditSequenceStratego extends AbstractTestRegionDetection {
+
+	public TestEditSequenceStratego() throws IOException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, SGLRException{
+		pathToJavaTestInputs = "tests-editregions/java/separators";
+		setStrategoParser();
+	}
+
+	@Test
+	public void test() throws FileNotFoundException, IOException {
+		lastErr0AST = null;
+		String path = "tests-editregions/stratego/edit-sequence";
+		for (int i = 0; i < 73; i++) {
+			String fname = path + "/edit_"+ i + ".str.scn";
+			if(lastErr0AST != null){
+				String erroneousInput = loadAsString(fname);
+				editRegionRecovery = new EditRegionDetector(lastErr0AST, erroneousInput);
+				try {
+					parseString(editRegionRecovery.getRecoveredInput());
+					System.out.println("recovered: " + fname);
+				} 
+				catch (Exception e) {
+					System.err.println("failed: " + fname);
+					System.err.println(editRegionRecovery.getDeletedSubstrings());
+					System.err.println(editRegionRecovery.getInsertedSubstrings());
+					System.err.println(editRegionRecovery.getEditedRegionsCorrect());
+					System.err.println(editRegionRecovery.getEditedRegionsErroneous());
+					System.err.println(editRegionRecovery.getEditedTerms());
+				} 	
+			}
+			try {
+				lastErr0AST = parseFile(fname);
+				System.out.println("err0: " + fname);
+			} 
+			catch (Exception e) {
+				//
+			} 	
+			
+		}
+	}
+
+	@Test
+	public void test_no_recovery_1() throws FileNotFoundException, IOException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		String path = "tests-editregions/stratego/edit-sequence";
+		String fname_corr = path + "/edit_"+ 26 + ".str.scn";
+		String fname_err  = path + "/edit_"+ 27 + ".str.scn";
+		lastErr0AST = parseFile(fname_corr);
+		String erroneousInput = loadAsString(fname_err);
+		editRegionRecovery = new EditRegionDetector(lastErr0AST, erroneousInput);
+		try {
+			parseString(editRegionRecovery.getRecoveredInput());
+			System.out.println("recovered: " + fname_err);
+		} 
+		catch (Exception e) {
+			System.err.println("failed: " + fname_err);
+			System.err.println(editRegionRecovery.getDeletedSubstrings());
+			System.err.println(editRegionRecovery.getInsertedSubstrings());
+			System.err.println(editRegionRecovery.getEditedRegionsCorrect());
+			System.err.println(editRegionRecovery.getEditedRegionsErroneous());
+			System.err.println(editRegionRecovery.getEditedTerms());
+		} 			
+	}
+}

From m.dejonge at tudelft.nl  Tue Aug  7 10:27:41 2012
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Tue, 07 Aug 2012 08:27:41 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25265 - in
	spoofax/trunk/spoofax/org.spoofax.jsglr:
	src/org/spoofax/jsglr/client/editregion/detection
	test/org/spoofax/jsglr/client/editregion/test
Message-ID: <20120807082741.B979E108C02E@mx3.tudelft.nl>

Author: MaartjeDeJonge
Date: Tue Aug  7 08:27:39 2012
New Revision: 25265
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25265&sc=1

Log:


Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditSequenceStratego.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java	Tue Aug  7 08:08:54 2012	(r25264)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java	Tue Aug  7 08:27:39 2012	(r25265)
@@ -145,7 +145,7 @@
 		if(this.getSubtermRecoveries() == null){ //trivial recovery (no damage)
 			return new ArrayList<IStrategoTerm>();
 		}
-		if(!isRecovered){ 
+		if(!isRecovered && hasNonLayoutTokenDiscards()){
 			damagedTerms.add(getTerm());
 		}
 		for (int i = 0; i < this.getSubtermRecoveries().size(); i++) {
@@ -153,6 +153,15 @@
 		}
 		return damagedTerms;
 	}
+
+	private boolean hasNonLayoutTokenDiscards() {
+		int recoverCostsSubterms = 0;
+		for (RecoverInterpretation subtermRecovery : getSubtermRecoveries()) {
+			recoverCostsSubterms += subtermRecovery.getRecoveryCosts();
+		}
+		assert recoveryCosts >= recoverCostsSubterms;
+		return recoveryCosts > recoverCostsSubterms;
+	}
 	
 	@Override
 	public String toString(){

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java	Tue Aug  7 08:08:54 2012	(r25264)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java	Tue Aug  7 08:27:39 2012	(r25265)
@@ -55,9 +55,9 @@
 		for (int i = 0; i < term.getSubtermCount(); i++) {
 			collectRecoveries(term.getSubterm(i), term);
 		}
-		int s = ImploderAttachment.getLeftToken(term).getStartOffset();
-		int e =ImploderAttachment.getRightToken(term).getEndOffset();
-		System.out.println(ImploderAttachment.getTokenizer(term).getInput().substring(s, e+1));
+		//int s = ImploderAttachment.getLeftToken(term).getStartOffset();
+		//int e =ImploderAttachment.getRightToken(term).getEndOffset();
+		//System.out.println(ImploderAttachment.getTokenizer(term).getInput().substring(s, e+1));
 		RecoverInterpretation recovery = constructMinimalCostRecovery(term, parent);
 		if(recovery != null)
 			recoveryLookup.put(term, recovery);

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditSequenceStratego.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditSequenceStratego.java	Tue Aug  7 08:08:54 2012	(r25264)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditSequenceStratego.java	Tue Aug  7 08:27:39 2012	(r25265)
@@ -30,6 +30,8 @@
 				try {
 					parseString(editRegionRecovery.getRecoveredInput());
 					System.out.println("recovered: " + fname);
+					System.out.println(editRegionRecovery.getDiscardOffsetsErroneousInput().size());
+					System.out.println(editRegionRecovery.getEditedRegionsErroneous());
 				} 
 				catch (Exception e) {
 					System.err.println("failed: " + fname);

From m.dejonge at tudelft.nl  Tue Aug  7 10:28:17 2012
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Tue, 07 Aug 2012 08:28:17 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25266 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection
Message-ID: <20120807082817.5C0F2108C033@mx3.tudelft.nl>

Author: MaartjeDeJonge
Date: Tue Aug  7 08:28:16 2012
New Revision: 25266
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25266&sc=1

Log:


Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java	Tue Aug  7 08:27:39 2012	(r25265)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java	Tue Aug  7 08:28:16 2012	(r25266)
@@ -9,7 +9,6 @@
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.ITermFactory;
-import org.spoofax.jsglr.client.imploder.ImploderAttachment;
 import org.spoofax.jsglr.client.imploder.TermTreeFactory;
 import org.spoofax.terms.TermFactory;
 

From m.dejonge at tudelft.nl  Tue Aug  7 15:14:47 2012
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Tue, 07 Aug 2012 13:14:47 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25267 - in
	spoofax/trunk/spoofax/org.spoofax.jsglr:
	src/org/spoofax/jsglr/client/editregion/detection
	test/org/spoofax/jsglr/client/editregion/test
Message-ID: <20120807131447.B3F672B8008@mx2.tudelft.nl>

Author: MaartjeDeJonge
Date: Tue Aug  7 13:14:44 2012
New Revision: 25267
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25267&sc=1

Log:


Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DamagedTokenAnalyzer.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DiscardableRegion.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/LayoutEditsAnalyzer.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TerminalEditsAnalyzer.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditSequenceStratego.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DamagedTokenAnalyzer.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DamagedTokenAnalyzer.java	Tue Aug  7 08:28:16 2012	(r25266)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DamagedTokenAnalyzer.java	Tue Aug  7 13:14:44 2012	(r25267)
@@ -23,7 +23,15 @@
 	//filled in the token stream analysis
 	private final ArrayList<IToken> tokensDamagedByInsertion;
 	private final ArrayList<IToken> tokensDamagedByDeletion;
-	
+
+	/**
+	 * Returns tokens in token stream
+	 * @return
+	 */
+	public ITokenizer getTokens() {
+		return tokens;
+	}
+
 	/**
 	 * Returns all tokens in the correct term that are (possible) damaged by
 	 * the insertion of characters between the start and end character of the token.   
@@ -92,7 +100,7 @@
 	 */
 	public boolean isDamagedByInsertion(IToken t) {
 		int startOffset = t.getStartOffset();
-		int endOffset = t.getEndOffset();
+		int endOffset = t.getEndOffset();		
 		int offsetPreviousMatch = -1;
 		for (int j = startOffset; j <= endOffset; j++) {
 			int matchIndexInElems2 = lcs.getMatchIndexInElems2(j);
@@ -104,6 +112,7 @@
 		return false;
 	}
 	
+
 	/**
 	 * Says whether a token is a layout token between two non-layout tokens that has been completely removed,
 	 * and therefore may affect the parse result.

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DiscardableRegion.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DiscardableRegion.java	Tue Aug  7 08:28:16 2012	(r25266)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DiscardableRegion.java	Tue Aug  7 13:14:44 2012	(r25267)
@@ -123,7 +123,33 @@
 		Collections.sort(result);
 		return result;
 	}
-	
+
+	public static ArrayList<DiscardableRegion> mergeSubsequentRegions(ArrayList<DiscardableRegion> regions){
+		ArrayList<DiscardableRegion> merged = new ArrayList<DiscardableRegion>();
+		if(!regions.isEmpty()){
+			merged.add(regions.get(0));
+		}
+		int index = 1;
+		while (index < regions.size()) {
+			DiscardableRegion r1 = merged.get(0);
+			DiscardableRegion r2 = regions.get(index);
+			assert r2.getEndOffset() > r1.getStartOffset() : "input regions should be ordered"; 
+			if(r1.getEndOffset() + 1 < r2.getStartOffset()){
+				merged.add(r2);
+			}
+			else {
+				int startOffset = Math.min(r1.getStartOffset(), r2.getStartOffset());
+				int endOffset = Math.max(r1.getEndOffset(), r2.getEndOffset());
+				assert r1.getInputString() == r2.getInputString();
+				DiscardableRegion mergedRegion = new DiscardableRegion(startOffset, endOffset, r1.getInputString());
+				merged.set(merged.size()-1, mergedRegion);
+			}
+			index ++;
+		}
+		assert merged.size() <= regions.size();
+		return merged;
+	}
+
 	/**
 	 * Merges ordered region lists so that the resulting lists is ordered and merges overlapping regions
 	 * @param regions1
@@ -182,10 +208,30 @@
 		return result;
 	}
 
+	/**
+	 * Constructs the discarded fragment
+	 * @return
+	 */
 	public String constructFragment() {
 		return inputString.substring(getStartOffset(), getEndOffset() + 1);
 	}
 	
+	/**
+	 * Includes preceding and succeeding layout (to be used with the permissive grammars technique) 
+	 * @return
+	 */
+	public DiscardableRegion extendRegionWithWhitespace(){
+		int start = this.startOffset;
+		while(start > 0 && Character.isWhitespace(this.inputString.charAt(start-1))){
+			start -= 1;
+		}
+		int end = this.endOffset;
+		while(end < inputString.length()-2 && Character.isWhitespace(this.inputString.charAt(end+1))){
+			end += 1;
+		}
+		return new DiscardableRegion(start, end, inputString);
+	}
+	
 	@Override
 	public String toString(){
 		return constructFragment();

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java	Tue Aug  7 08:28:16 2012	(r25266)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java	Tue Aug  7 13:14:44 2012	(r25267)
@@ -60,7 +60,10 @@
 			RecoverInterpretation emptyRecovery = RecoverInterpretation.createDiscardInterpretation(correctAST, null);
 			return emptyRecovery.getDamagedRegions();
 		}
-		return DiscardableRegion.mergeRegions(discardRecovery.getDamagedRegions(), discardableCommentRegions);
+		return 
+				DiscardableRegion.mergeSubsequentRegions(
+						DiscardableRegion.mergeRegions(discardRecovery.getDamagedRegions(), discardableCommentRegions)
+				);
 	}
 	
 	/**
@@ -114,7 +117,10 @@
 	public ArrayList<DiscardableRegion> getEditedRegionsErroneous(){
 		ArrayList<DiscardableRegion> editsFromDeletions = mapRegions(getEditedRegionsCorrect(), true);
 		ArrayList<DiscardableRegion> editsFromInsertions = DiscardableRegion.constructRegionsFromOffsets(getInsertionOffsets(), this.getErroneousInput());
-		return DiscardableRegion.mergeRegions(editsFromDeletions, editsFromInsertions);
+		return 
+				DiscardableRegion.mergeSubsequentRegions(
+						DiscardableRegion.mergeRegions(editsFromDeletions, editsFromInsertions)
+				);
 	}
 
 	/**
@@ -159,19 +165,33 @@
 	private void detectEditRegions() {
 		ITokenizer tokens = ImploderAttachment.getTokenizer(correctAST);
 
+		long time = System.currentTimeMillis();
+		
 		// calculates offsets deleted characters (correct input), and offsets inserted characters (erroneous input)
 		constructCharacterMatching();
 		ArrayList<Integer> offsetsDeletedChars = lcs.getUnMatchedIndices1();
+		System.out.println("LCS: " + (System.currentTimeMillis()-time));
+		time = System.currentTimeMillis();
+		//TODO: LCS on lines (instead of characters) in case LCS optimized does not work to reduce the size enough
+		
+		DamagedTokenAnalyzer tokenEdits = new DamagedTokenAnalyzer(tokens, lcs);
+		System.out.println("token edits: " + (System.currentTimeMillis()-time));
+		time = System.currentTimeMillis();
+		//TODO: Improve performance!!
 
 		//removes from deletion offsets, all offsets of layout characters that are irrelevant for the parse result.
 		//detects all edited comment regions, since these may affect the parse result if they are broken.
-		LayoutEditsAnalyzer loAnalyzer = new LayoutEditsAnalyzer(tokens, lcs);
+		LayoutEditsAnalyzer loAnalyzer = new LayoutEditsAnalyzer(tokenEdits);
 		this.discardableCommentRegions = loAnalyzer.getDamagedCommentRegions();
 		loAnalyzer.filterNonLayoutOffsets(offsetsDeletedChars);
-		
+		System.out.println("layout edits: " + (System.currentTimeMillis()-time));
+		time = System.currentTimeMillis();
+
 		//extends deletion offsets so that all possible damaged tokens are covered
-		TerminalEditsAnalyzer terminalAnalyzer = new TerminalEditsAnalyzer(tokens, lcs);
+		TerminalEditsAnalyzer terminalAnalyzer = new TerminalEditsAnalyzer(tokenEdits);
 		terminalAnalyzer.addDamagedTokensStartOffsets(offsetsDeletedChars);
+		System.out.println("terminal edits: " + (System.currentTimeMillis()-time));
+		time = System.currentTimeMillis();
 
 		//detects discardable regions that correspond to edited terms.
 		//NonTerminalEditsAnalyzer brokenConstructDetector = new NonTerminalEditsAnalyzer(correctAST, offsetsDeletedChars);
@@ -180,6 +200,8 @@
 		//detects discardable regions that correspond to edited terms.
 		TermEditsAnalyzer brokenConstructDetector = new TermEditsAnalyzer(offsetsDeletedChars, correctAST);
 		this.discardRecovery = brokenConstructDetector.getDiscardRecovery();		
+		System.out.println("Term edits: " + (System.currentTimeMillis()-time));
+		time = System.currentTimeMillis();
 	}
 	
 

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/LayoutEditsAnalyzer.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/LayoutEditsAnalyzer.java	Tue Aug  7 08:28:16 2012	(r25266)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/LayoutEditsAnalyzer.java	Tue Aug  7 13:14:44 2012	(r25267)
@@ -24,7 +24,6 @@
 	//filled in the analysis
 	private final ArrayList<DiscardableRegion> damagedCommentRegions;
 	private final ArrayList<Integer> offsetsDeletedLayoutChars;
-	private final ITokenizer tokens;
 	
 	/**
 	 * Returns the comment regions that are edited and therefore (possible) damaged.
@@ -46,16 +45,15 @@
 	 * Filters the offsets of the deleted characters, removing comment and whitespace offsets 
 	 * that are either irrelevant (not affecting the parse result) or allready processed (block comment damage)
 	 */
-	public LayoutEditsAnalyzer(ITokenizer tokens, LCS<Character> lcs){
+	public LayoutEditsAnalyzer(DamagedTokenAnalyzer tokenEdits){
 		this.offsetsDeletedLayoutChars = new ArrayList<Integer>();
 		this.damagedCommentRegions = new ArrayList<DiscardableRegion>();
-		tokenEdits = new DamagedTokenAnalyzer(tokens, lcs);
-		this.tokens = tokens;
+		this.tokenEdits = tokenEdits;
 		analyze();
 	}
 	
 	private void analyze() {
-		String input = tokens.getInput();
+		String input = tokenEdits.getTokens().getInput();
 		for (IToken tokenWithDeletions : tokenEdits.getTokensDamagedByDeletion()) {
 			if(tokenWithDeletions.getKind() == Token.TK_LAYOUT){
 				if(!tokenEdits.isDamagingLayoutDeletion(tokenWithDeletions)){

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java	Tue Aug  7 08:28:16 2012	(r25266)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java	Tue Aug  7 13:14:44 2012	(r25267)
@@ -10,6 +10,7 @@
 import org.spoofax.jsglr.client.imploder.ITokenizer;
 import org.spoofax.jsglr.client.imploder.ImploderAttachment;
 import org.spoofax.jsglr.client.imploder.Token;
+import org.spoofax.terms.attachments.ParentAttachment;
 
 /**
  * Represents a recovery based on discarding tokens associated to the term and/or its subterms.
@@ -198,7 +199,7 @@
 	 * @return
 	 */
 	public static RecoverInterpretation createDiscardInterpretation(IStrategoTerm term, IStrategoTerm parentTerm){
-		assert term.isList() || HelperFunctions.isSomeNode(term); //parentTerm.isList()
+		assert term.isList() || HelperFunctions.isSomeNode(term) || parentTerm == null; //parentTerm.isList()
 		return new RecoverInterpretation(term, parentTerm, false, new ArrayList<RecoverInterpretation>());
 	}
 

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TerminalEditsAnalyzer.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TerminalEditsAnalyzer.java	Tue Aug  7 08:28:16 2012	(r25266)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TerminalEditsAnalyzer.java	Tue Aug  7 13:14:44 2012	(r25267)
@@ -37,9 +37,9 @@
 	 * The reason is that a "parse-as-whitespace" recovery may not repair the problem.
 	 * Example damaged token: 'priva at te'
 	 */
-	public TerminalEditsAnalyzer(ITokenizer tokens, LCS<Character> lcs){
+	public TerminalEditsAnalyzer(DamagedTokenAnalyzer tokenEdits){
 		this.startOffsetsTokensDamagedByInsertions = new ArrayList<Integer>();
-		tokenEdits = new DamagedTokenAnalyzer(tokens, lcs);
+		this.tokenEdits = tokenEdits;
 		analyze();
 	}
 	

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditSequenceStratego.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditSequenceStratego.java	Tue Aug  7 08:28:16 2012	(r25266)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditSequenceStratego.java	Tue Aug  7 13:14:44 2012	(r25267)
@@ -20,13 +20,28 @@
 
 	@Test
 	public void test() throws FileNotFoundException, IOException {
+		//TODO: improve performance of DamagedTokenAnalyzer
+		//TODO: look at LCS algorithms, prevent LCS on too large sequence
+		
 		lastErr0AST = null;
 		String path = "tests-editregions/stratego/edit-sequence";
+//		for (int i = 0; i < 73; i++) {
+//			String fname = path + "/edit_"+ i + ".str.scn";
+//			try {
+//				parseFile(fname);
+//			} 
+//			catch (Exception e) {
+//				//
+//			} 	
+//			
+//		}
 		for (int i = 0; i < 73; i++) {
 			String fname = path + "/edit_"+ i + ".str.scn";
 			if(lastErr0AST != null){
 				String erroneousInput = loadAsString(fname);
+				long timeStart = System.currentTimeMillis();
 				editRegionRecovery = new EditRegionDetector(lastErr0AST, erroneousInput);
+				System.out.println("time: " + (System.currentTimeMillis() - timeStart));
 				try {
 					parseString(editRegionRecovery.getRecoveredInput());
 					System.out.println("recovered: " + fname);
@@ -55,6 +70,11 @@
 
 	@Test
 	public void test_no_recovery_1() throws FileNotFoundException, IOException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+
+//		[] -> strategy
+//		     ---
+//		_ -> strategy
+
 		String path = "tests-editregions/stratego/edit-sequence";
 		String fname_corr = path + "/edit_"+ 26 + ".str.scn";
 		String fname_err  = path + "/edit_"+ 27 + ".str.scn";
@@ -74,4 +94,32 @@
 			System.err.println(editRegionRecovery.getEditedTerms());
 		} 			
 	}
+
+	@Test
+	public void test_no_recovery_2() throws FileNotFoundException, IOException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+
+//		;result := $[Seq([strategy], [<concat-listOfIfs(|x)> xs])]
+//				---
+//		; result := $[Seq([strategy], [])]
+
+		String path = "tests-editregions/stratego/edit-sequence";
+		String fname_corr = path + "/edit_"+ 35 + ".str.scn";
+		String fname_err  = path + "/edit_"+ 36 + ".str.scn";
+		lastErr0AST = parseFile(fname_corr);
+		String erroneousInput = loadAsString(fname_err);
+		editRegionRecovery = new EditRegionDetector(lastErr0AST, erroneousInput);
+		try {
+			parseString(editRegionRecovery.getRecoveredInput());
+			System.out.println("recovered: " + fname_err);
+		} 
+		catch (Exception e) {
+			System.err.println("failed: " + fname_err);
+			System.err.println(editRegionRecovery.getDeletedSubstrings());
+			System.err.println(editRegionRecovery.getInsertedSubstrings());
+			System.err.println(editRegionRecovery.getEditedRegionsCorrect());
+			System.err.println(editRegionRecovery.getEditedRegionsErroneous());
+			System.err.println(editRegionRecovery.getEditedTerms());
+		} 			
+	}
+
 }

From andre.s.d.vieira at gmail.com  Thu Aug  9 11:26:11 2012
From: andre.s.d.vieira at gmail.com (Andre Vieira)
Date: Thu, 09 Aug 2012 09:26:11 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25268 - in
	spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3:
	b_2568crashed l_14863crashed l_1855 l_1855crashed
	n_1790crashed p_2535 p_2535crashed
Message-ID: <20120809092611.E09F37F8028@mx1.tudelft.nl>

Author: AndreVieira
Date: Thu Aug  9 09:26:10 2012
New Revision: 25268
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25268&sc=1

Log:


Added:
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/b_2568crashed/
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/b_2568crashed/AST.aterm
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/b_2568crashed/program.app
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/b_2568crashed/strategyResult.txt
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855/
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855/AST.aterm
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855/amb0.app
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855/amb0.aterm
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855/amb1.app
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855/amb1.aterm
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855/amb2.app
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855/amb2.aterm
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855/amb3.app
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855/amb3.aterm
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855/program.app
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855/strategyResult.txt
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855crashed/
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855crashed/AST.aterm
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855crashed/program.app
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855crashed/strategyResult.txt
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/n_1790crashed/
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/n_1790crashed/AST.aterm
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/n_1790crashed/program.app
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/n_1790crashed/strategyResult.txt
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/p_2535/
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/p_2535/amb0.app
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/p_2535/amb0.aterm
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/p_2535crashed/
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/p_2535crashed/AST.aterm
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/p_2535crashed/program.app
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/p_2535crashed/strategyResult.txt
Modified:
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_14863crashed/program.app

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/b_2568crashed/AST.aterm
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/b_2568crashed/AST.aterm	Thu Aug  9 09:26:10 2012	(r25268)
@@ -0,0 +1,123 @@
+Application(
+  "m"
+, [ ACPolicy(Name("lh2o"))
+  , ACPolicy(Name("Z_QM_8RU_CP"))
+  , Section(
+      " p p  ."
+    , [ LocalRedefine(
+          []
+        , "Z_QM_8RU_CP"
+        , []
+        , "m"
+        , LocalRedefineArgs([Var("m8P__Q_18X3")])
+        )
+      , ServiceFunction("Z_QM_8RU_CP", [], Block([]))
+      , SearchMapping("m", [])
+      , Description([])
+      , VarDeclInit("Z_QM_8RU_CP", GenericSort("m8P__Q_18X3", [SimpleSort("nIwx_____UM")]), False())
+      ]
+    )
+  , ACPolicy(PolicyAnd(Name("Z_QM_8RU_CP"), Name("lh2o")))
+  , AccessControlDefinition(
+      Some("Z_QM_8RU_CP")
+    , [ SpecialAccessControlRule("nIwx_____UM", IsA(False(), SimpleSort("m8P__Q_18X3")))
+      , SpecialAccessControlRule(
+          "lh2o"
+        , FunctionRefCall(FunctionRef("Z_QM_8RU_CP", [], SimpleSort("Void")), [])
+        )
+      ]
+    )
+  , AccessControlDefinition(
+      Some("m")
+    , [ Predicate(
+          "m"
+        , [ Arg("m8P__Q_18X3", GenericSort("lh2o", [SimpleSort("m8P__Q_18X3")]))
+          , Arg("nIwx_____UM", SimpleSort("m"))
+          , Arg("m", FunctionSort([], SimpleSort("Void")))
+          ]
+        , IfExp(
+            Assignment(
+              Mod(
+                RenderEmailFunctionCall(EmailCall("m", []))
+              , FunctionRef("lh2o", [], SimpleSort("Void"))
+              )
+            , SmallerThanOrEqual(ThisCall("lh2o", []), FieldAccess(Var("externalscope"), "nIwx_____UM"))
+            )
+          , ListCreation([])
+          , Var("m")
+          )
+        )
+      ]
+    )
+  , AccessControlDefinition(
+      Some("m8P__Q_18X3")
+    , [ AccessControlPrincipal("m8P__Q_18X3", ["m"])
+      , AccessControlPointcut("Z_QM_8RU_CP", [], [])
+      , SpecialAccessControlRule("lh2o", SmallerThanOrEqual(Var("nIwx_____UM"), Var("Z_QM_8RU_CP")))
+      , AccessControlPointcut(
+          "m8P__Q_18X3"
+        , [ Arg("m", FunctionSort([], SimpleSort("Z_QM_8RU_CP")))
+          , Arg("nIwx_____UM", GenericSort("Z_QM_8RU_CP", [SimpleSort("m8P__Q_18X3")]))
+          , Arg("m8P__Q_18X3", SimpleSort("nIwx_____UM"))
+          , Arg("nIwx_____UM", FunctionSort([], SimpleSort("lh2o")))
+          , Arg("lh2o", SimpleSort("lh2o"))
+          ]
+        , []
+        )
+      , AccessControlPointcut("nIwx_____UM", [], [])
+      , AccessControlPointcut("lh2o", [], [])
+      , AccessControlRule(
+          "nIwx_____UM"
+        , "*"
+        , MatchArgs([], Some("*"))
+        , Div(Var("Z_QM_8RU_CP"), Var("m"))
+        , []
+        )
+      , AccessControlPointcut("m", [], [])
+      , AccessControlRule(
+          "nIwx_____UM"
+        , "m"
+        , MatchArgs([], Some("*"))
+        , Suggest("bQ_", SpellCheck(), [Similarity(False())])
+        , []
+        )
+      , AccessControlRule("nIwx_____UM", "*", MatchArgs([], None()), False(), [])
+      ]
+    )
+  , AccessControlDefinition(
+      None()
+    , [ Predicate("m", [], False())
+      , AccessControlRule(
+          "nIwx_____UM"
+        , "YZ_R*"
+        , MatchArgs([], Some("*"))
+        , LargerThan(RenderEmailFunctionCall(EmailCall("Z_QM_8RU_CP", [])), SearcherInit("EG", []))
+        , []
+        )
+      , AccessControlPointcut("nIwx_____UM", [], [])
+      , AccessControlPointcut("lh2o", [], [])
+      , AccessControlPrincipal("m8P__Q_18X3", ["Z_QM_8RU_CP", "m8P__Q_18X3", "m", "m", "nIwx_____UM"])
+      ]
+    )
+  , AccessControlDefinition(
+      None()
+    , [ AccessControlPrincipal("nIwx_____UM", ["Z_QM_8RU_CP"])
+      , Predicate(
+          "lh2o"
+        , []
+        , AllFacetResults("j_3", EmailFunctionCall(EmailCall("m", [])))
+        )
+      , AccessControlRule(
+          "nIwx_____UM"
+        , "m"
+        , MatchArgs([], Some("*"))
+        , FunctionRef("m", [], SimpleSort("nIwx_____UM"))
+        , []
+        )
+      , Predicate("m", [], Eq(GlobalVar("nIwx_____UM"), False()))
+      , Predicate("nIwx_____UM", [], True())
+      , AccessControlPointcut("Z_QM_8RU_CP", [], [])
+      ]
+    )
+  ]
+)
\ No newline at end of file

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/b_2568crashed/program.app
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/b_2568crashed/program.app	Thu Aug  9 09:26:10 2012	(r25268)
@@ -0,0 +1,241 @@
+application m
+
+access
+
+control
+
+policy
+
+lh2o
+
+access
+
+control
+
+policy
+
+Z_QM_8RU_CP
+
+section p p  .
+
+  define
+
+  Z_QM_8RU_CP
+
+  (
+
+  )
+
+  =
+
+  m
+
+  (
+
+  *
+
+  ,
+
+  m8P__Q_18X3
+
+  )
+
+  service
+
+  Z_QM_8RU_CP
+
+  (
+
+  )
+
+  {
+  }
+
+  search mapping m {
+  }
+
+  description {
+  }
+
+  var Z_QM_8RU_CP : m8P__Q_18X3<nIwx_____UM> := false
+
+access
+
+control
+
+policy
+
+Z_QM_8RU_CP
+
+AND
+
+lh2o
+
+access control rules
+  Z_QM_8RU_CP
+  rule nIwx_____UM {
+    false is a m8P__Q_18X3
+  }
+  rule lh2o {
+    function.Z_QM_8RU_CP():Void()
+  }
+
+access control rules
+  m
+  predicate
+  m
+  (
+  m8P__Q_18X3 : lh2o<m8P__Q_18X3>
+  ,
+  nIwx_____UM : m
+  ,
+  m : function ( ) : Void
+  )
+  {
+  if
+  (
+  renderemail ( m ( ) ) % function. lh2o ( ) : Void := lh2o() <= externalscope . nIwx_____UM
+  )
+  [
+  ]
+  else
+  m
+  }
+
+access control rules
+  m8P__Q_18X3
+  principal
+  is
+  m8P__Q_18X3
+  with
+  credentials
+  m
+  pointcut
+  Z_QM_8RU_CP
+  (
+  )
+  {
+  }
+  rule lh2o {
+    nIwx_____UM <= Z_QM_8RU_CP
+  }
+  pointcut
+  m8P__Q_18X3
+  (
+  m : function ( ) : Z_QM_8RU_CP
+  ,
+  nIwx_____UM : Z_QM_8RU_CP<m8P__Q_18X3>
+  ,
+  m8P__Q_18X3 : nIwx_____UM
+  ,
+  nIwx_____UM : function ( ) : lh2o
+  ,
+  lh2o : lh2o
+  )
+  {
+  }
+  pointcut
+  nIwx_____UM
+  (
+  )
+  {
+  }
+  pointcut
+  lh2o
+  (
+  )
+  {
+  }
+  rule nIwx_____UM * ( * ) {
+    Z_QM_8RU_CP / m
+  }
+  pointcut
+  m
+  (
+  )
+  {
+  }
+  rule nIwx_____UM m ( * ) {
+    bQ_ corrections similarity false
+  }
+  rule nIwx_____UM * (  ) {
+    false
+  }
+
+access control rules
+  predicate
+  m
+  (
+  )
+  {
+  false
+  }
+  rule nIwx_____UM YZ_R* ( * ) {
+    renderemail ( Z_QM_8RU_CP ( ) ) > search EG
+  }
+  pointcut
+  nIwx_____UM
+  (
+  )
+  {
+  }
+  pointcut
+  lh2o
+  (
+  )
+  {
+  }
+  principal
+  is
+  m8P__Q_18X3
+  with
+  credentials
+  Z_QM_8RU_CP
+  ,
+  m8P__Q_18X3
+  ,
+  m
+  ,
+  m
+  ,
+  nIwx_____UM
+
+access control rules
+  principal
+  is
+  nIwx_____UM
+  with
+  credentials
+  Z_QM_8RU_CP
+  predicate
+  lh2o
+  (
+  )
+  {
+  all j_3 facets from email ( m ( ) )
+  }
+  rule nIwx_____UM m ( * ) {
+    function. m ( ) : nIwx_____UM
+  }
+  predicate
+  m
+  (
+  )
+  {
+  global.nIwx_____UM
+  ==
+  false
+  }
+  predicate
+  nIwx_____UM
+  (
+  )
+  {
+  true
+  }
+  pointcut
+  Z_QM_8RU_CP
+  (
+  )
+  {
+  }
\ No newline at end of file

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/b_2568crashed/strategyResult.txt
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/b_2568crashed/strategyResult.txt	Thu Aug  9 09:26:10 2012	(r25268)
@@ -0,0 +1,82 @@
+
+Analyzing: TestFolder/program.app
+rename: 0.110 s
+
+* : error: Variable 'm8P__Q_18X3' not defined
+m8P__Q_18X3
+WebDSL: rewriting failed, trace:
+	editor_analyze1_0_0
+	editor_analyze1_0_0
+	editor_analyze_0_0
+	editor_analyze_work_0_0
+	in_typechecking_phase_1_0
+	dr_scope_1_1
+	editor_check_0_1
+	dr_scope_1_1
+	dr_scope_1_1
+	dbg_time_1_1
+	catch_errors_editor_1_0
+	dr_scope_1_1
+	dr_scope_1_1
+	constraint_error_all_0_0
+	bottomup_1_0
+	bottomup_1_0
+	bottomup_1_0
+	bottomup_1_0
+	bottomup_1_0
+	try_1_0
+	constraint_error_0_0
+	constraint_error_ui_0_0
+	constraint_error_ui_0_0_fragment_1
+	local_redefine_arg_types_0_2
+	map_1_0
+	eq_type_of_0_0
+	EntDecl_0_0
+	dr_lookup_rule_0_2
+	dr_lookup_rule_0_2
+	dr_lookup_rule_1_2
+	dr_lookup_rule_1_2
+	dr_lookup_rule_1_2
+	dr_lookup_rule_1_2
+[ WebDSL | critical ] Internal error: with clause failed unexpectedly in rule 'local-redefine-arg-types'
+           LocalRedefine([],"Z_QM_8RU_CP",[],"m",LocalRedefineArgs([Var("m8P__Q_18X3")])){TopLevelName("topdef160")}Analyzing: TestFolder/program.app
+rename: 0.110 s
+
+* : error: Variable 'm8P__Q_18X3' not defined
+m8P__Q_18X3
+WebDSL: rewriting failed, trace:
+	editor_analyze1_0_0
+	editor_analyze1_0_0
+	editor_analyze_0_0
+	editor_analyze_work_0_0
+	in_typechecking_phase_1_0
+	dr_scope_1_1
+	editor_check_0_1
+	dr_scope_1_1
+	dr_scope_1_1
+	dbg_time_1_1
+	catch_errors_editor_1_0
+	dr_scope_1_1
+	dr_scope_1_1
+	constraint_error_all_0_0
+	bottomup_1_0
+	bottomup_1_0
+	bottomup_1_0
+	bottomup_1_0
+	bottomup_1_0
+	try_1_0
+	constraint_error_0_0
+	constraint_error_ui_0_0
+	constraint_error_ui_0_0_fragment_1
+	local_redefine_arg_types_0_2
+	map_1_0
+	eq_type_of_0_0
+	EntDecl_0_0
+	dr_lookup_rule_0_2
+	dr_lookup_rule_0_2
+	dr_lookup_rule_1_2
+	dr_lookup_rule_1_2
+	dr_lookup_rule_1_2
+	dr_lookup_rule_1_2
+[ WebDSL | critical ] Internal error: with clause failed unexpectedly in rule 'local-redefine-arg-types'
+           LocalRedefine([],"Z_QM_8RU_CP",[],"m",LocalRedefineArgs([Var("m8P__Q_18X3")])){TopLevelName("topdef160")}
\ No newline at end of file

Modified: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_14863crashed/program.app
==============================================================================
--- spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_14863crashed/program.app	Tue Aug  7 13:14:44 2012	(r25267)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_14863crashed/program.app	Thu Aug  9 09:26:10 2012	(r25268)
@@ -43,8 +43,7 @@
   {
   }
   rule Q_b akqIUM2* (  ) {
-    ~ externalscope . ookL3GK_7g0 >= Or [ [
-                                          ] | q25__Y : function ( ) : Void in false / function.CRso_FJ49hY():CRso_FJ49hY(*,) ] % List<CRso_FJ49hY>() matching
+    ~ externalscope . ookL3GK_7g0 >= Or [ [] | q25__Y : function ( ) : Void in false / function.CRso_FJ49hY():CRso_FJ49hY(*,) ] % List<CRso_FJ49hY>() matching
   }
   predicate
   CRso_FJ49hY

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855/AST.aterm
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855/AST.aterm	Thu Aug  9 09:26:10 2012	(r25268)
@@ -0,0 +1,11 @@
+error(
+  "Parse error"
+, [ localized(
+      "Syntax error near unexpected character 'i'"
+    , area-in-file(
+        "string"
+      , area(4, 293, 4, 293, 457, 0)
+      )
+    )
+  ]
+)
\ No newline at end of file

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855/amb0.app
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855/amb0.app	Thu Aug  9 09:26:10 2012	(r25268)
@@ -0,0 +1 @@
+externalscope.lEBrN_ > global.G__kz > List<lEBrN_<k>>().lEBrN_()
\ No newline at end of file

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855/amb0.aterm
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855/amb0.aterm	Thu Aug  9 09:26:10 2012	(r25268)
@@ -0,0 +1,22 @@
+amb(
+  [ LargerThan(
+      LargerThan(FieldAccess(Var("externalscope"), "lEBrN_"), GlobalVar("G__kz"))
+    , Call(
+        TypedListCreation(GenericSort("lEBrN_", [SimpleSort("k")]), [])
+      , "lEBrN_"
+      , []
+      )
+    )
+  , LargerThan(
+      FieldAccess(Var("externalscope"), "lEBrN_")
+    , LargerThan(
+        GlobalVar("G__kz")
+      , Call(
+          TypedListCreation(GenericSort("lEBrN_", [SimpleSort("k")]), [])
+        , "lEBrN_"
+        , []
+        )
+      )
+    )
+  ]
+)
\ No newline at end of file

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855/amb1.app
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855/amb1.app	Thu Aug  9 09:26:10 2012	(r25268)
@@ -0,0 +1 @@
+global.G__kz > List<lEBrN_<k>>().lEBrN_() > email ( C3_Z8_b_Nrw ( ) )
\ No newline at end of file

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855/amb1.aterm
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855/amb1.aterm	Thu Aug  9 09:26:10 2012	(r25268)
@@ -0,0 +1,25 @@
+amb(
+  [ LargerThan(
+      LargerThan(
+        GlobalVar("G__kz")
+      , Call(
+          TypedListCreation(GenericSort("lEBrN_", [SimpleSort("k")]), [])
+        , "lEBrN_"
+        , []
+        )
+      )
+    , EmailFunctionCall(EmailCall("C3_Z8_b_Nrw", []))
+    )
+  , LargerThan(
+      GlobalVar("G__kz")
+    , LargerThan(
+        Call(
+          TypedListCreation(GenericSort("lEBrN_", [SimpleSort("k")]), [])
+        , "lEBrN_"
+        , []
+        )
+      , EmailFunctionCall(EmailCall("C3_Z8_b_Nrw", []))
+      )
+    )
+  ]
+)
\ No newline at end of file

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855/amb2.app
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855/amb2.app	Thu Aug  9 09:26:10 2012	(r25268)
@@ -0,0 +1 @@
+externalscope.lEBrN_ > global.G__kz > List<lEBrN_<k>>().lEBrN_() > email ( C3_Z8_b_Nrw ( ) )
\ No newline at end of file

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855/amb2.aterm
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855/amb2.aterm	Thu Aug  9 09:26:10 2012	(r25268)
@@ -0,0 +1,28 @@
+amb(
+  [ LargerThan(
+      LargerThan(
+        LargerThan(FieldAccess(Var("externalscope"), "lEBrN_"), GlobalVar("G__kz"))
+      , Call(
+          TypedListCreation(GenericSort("lEBrN_", [SimpleSort("k")]), [])
+        , "lEBrN_"
+        , []
+        )
+      )
+    , EmailFunctionCall(EmailCall("C3_Z8_b_Nrw", []))
+    )
+  , LargerThan(
+      FieldAccess(Var("externalscope"), "lEBrN_")
+    , LargerThan(
+        LargerThan(
+          GlobalVar("G__kz")
+        , Call(
+            TypedListCreation(GenericSort("lEBrN_", [SimpleSort("k")]), [])
+          , "lEBrN_"
+          , []
+          )
+        )
+      , EmailFunctionCall(EmailCall("C3_Z8_b_Nrw", []))
+      )
+    )
+  ]
+)
\ No newline at end of file

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855/amb3.app
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855/amb3.app	Thu Aug  9 09:26:10 2012	(r25268)
@@ -0,0 +1 @@
+externalscope.lEBrN_ > global.G__kz > List<lEBrN_<k>>().lEBrN_() > email ( C3_Z8_b_Nrw ( ) )
\ No newline at end of file

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855/amb3.aterm
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855/amb3.aterm	Thu Aug  9 09:26:10 2012	(r25268)
@@ -0,0 +1,28 @@
+amb(
+  [ LargerThan(
+      FieldAccess(Var("externalscope"), "lEBrN_")
+    , LargerThan(
+        LargerThan(
+          GlobalVar("G__kz")
+        , Call(
+            TypedListCreation(GenericSort("lEBrN_", [SimpleSort("k")]), [])
+          , "lEBrN_"
+          , []
+          )
+        )
+      , EmailFunctionCall(EmailCall("C3_Z8_b_Nrw", []))
+      )
+    )
+  , LargerThan(
+      LargerThan(FieldAccess(Var("externalscope"), "lEBrN_"), GlobalVar("G__kz"))
+    , LargerThan(
+        Call(
+          TypedListCreation(GenericSort("lEBrN_", [SimpleSort("k")]), [])
+        , "lEBrN_"
+        , []
+        )
+      , EmailFunctionCall(EmailCall("C3_Z8_b_Nrw", []))
+      )
+    )
+  ]
+)
\ No newline at end of file

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855/program.app
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855/program.app	Thu Aug  9 09:26:10 2012	(r25268)
@@ -0,0 +1,137 @@
+module _o/TF5.N2O-Y0
+request
+var ZdY3H__ : Ref<ZdY3H__> := email ( HnC2PKL__7_ ( List<pXR7QR<pXR7QR>>(), function.pXR7QR():U_C7k, pXR7QR, validatetemplate(V__3Y[]{
+                                                                                                                                     }), Or["\"\"\""%!email(pXR7QR())for(pXR7QR:ZdY3H__<HnC2PKL__7_>in( {} as pXR7QR )>=email(ZdY3H__()))], And[falseisaZdY3H__isaRef<pXR7QR>for(pXR7QR:C_<pXR7QR>inif(if(externalscope.HnC2PKL__7_[email(HnC2PKL__7_())])email(HnC2PKL__7_())elsefalse)renderemail(HnC2PKL__7_())*{}elseAnd[[]<{}for(C_:ZdY3H__<ZdY3H__>intrue)]orderbyif(null)function.HnC2PKL__7_():HnC2PKL__7_()elseZdY3H__()limitRef<HnC2PKL__7_>{}.HnC2PKL__7_()offsetfunction.U_C7k():C_(*,)>=results from function():HnC2PKL__7_{})], ( externalscope . pXR7QR as function ( ) : U_C7k ) := And [ renderemail ( C_ ( ) ) for ( C_ : Ref<Ref<function():pXR7QR>> in / ^|\2{54}+|\n++|(?:^{54})++ /.U_C7k() order by function.C_():Void(*,) % Ref<pXR7QR>{} ) ], function. C_ ( ) : Void + function. C_ ( ) : C_ ) )
+native
+class
+C_.U_C7k.ZdY3H__
+:
+U_C7k
+{
+pXR7QR
+:
+HnC2PKL__7_
+<
+HnC2PKL__7_
+<
+>
+,
+ZdY3H__
+,
+ZdY3H__
+<
+>
+>
+pXR7QR
+:
+HnC2PKL__7_
+<
+>
+constructor
+(
+)
+constructor
+(
+HnC2PKL__7_
+<
+>
+,
+HnC2PKL__7_
+<
+>
+,
+HnC2PKL__7_
+,
+C_
+,
+ZdY3H__
+<
+>
+,
+U_C7k
+,
+HnC2PKL__7_
+,
+C_
+<
+>
+)
+pXR7QR.pXR7QR
+as
+ZdY3H__
+(
+)
+:
+C_
+<
+>
+constructor
+(
+U_C7k
+<
+C_
+,
+U_C7k
+<
+>
+,
+HnC2PKL__7_
+,
+HnC2PKL__7_
+,
+C_
+<
+>
+,
+HnC2PKL__7_
+<
+>
+,
+HnC2PKL__7_
+<
+>
+,
+ZdY3H__
+<
+>
+,
+C_
+<
+>
+,
+U_C7k
+>
+)
+}
+action ignore-validation ignore-validation ignore-validation ignore-validation ignore-validation ignore-validation ignore-validation ignore-validation ignore-validation HnC2PKL__7_ ( C_ : U_C7k, HnC2PKL__7_ : pXR7QR<U_C7k>, HnC2PKL__7_ : function ( ) : U_C7k, U_C7k : C_, ZdY3H__ : Ref<Ref<function():U_C7k>>, ZdY3H__ : function ( ) : ZdY3H__, pXR7QR : ZdY3H__, HnC2PKL__7_ : function ( ) : C_, C_ : C_<pXR7QR> )
+{
+}
+extend
+session
+C_
+{
+}
+recommenderStaticOrder
+C_
+{
+pXR7QR
+C_
+pXR7QR
+C_
+C_
+HnC2PKL__7_
+ZdY3H__
+C_
+}
+access
+control
+policy
+ZdY3H__
+AND
+HnC2PKL__7_
+AND
+pXR7QR
+AND
+HnC2PKL__7_
+AND
+C_
\ No newline at end of file

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855/strategyResult.txt
==============================================================================

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855crashed/AST.aterm
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855crashed/AST.aterm	Thu Aug  9 09:26:10 2012	(r25268)
@@ -0,0 +1,186 @@
+Application(
+  "k_W26U_B"
+, [ ACPolicy(
+      PolicyOr(
+        PolicyOr(
+          PolicyOr(
+            PolicyOr(
+              Name("k_W26U_B")
+            , PolicyAnd(
+                PolicyAnd(PolicyAnd(Name("G__kz"), Name("k_W26U_B")), Name("k"))
+              , Name("k_W26U_B")
+              )
+            )
+          , PolicyAnd(PolicyAnd(Name("k_W26U_B"), Name("G__kz")), Name("k"))
+          )
+        , PolicyAnd(PolicyAnd(Name("G__kz"), Name("k_W26U_B")), Name("k_W26U_B"))
+        )
+      , PolicyAnd(Name("k"), Name("k"))
+      )
+    )
+  , Section(
+      " o+q  ."
+    , [ ExtendEntity("lEBrN_", [])
+      , ServiceFunction("k", [], Block([]))
+      , DeriveWebServices("C3_Z8_b_Nrw", "lEBrN_")
+      , FullTextAnalyzer(
+          Some("default_builtin_analyzer")
+        , "k_W26U_B"
+        , FullTextAnalyzerBodyDef([], Tokenizer("k_W26U_B", []), [])
+        )
+      , RecommendConfigStaticOrder(
+          "k"
+        , RecommendUser("k")
+        , RecommendItem("k_W26U_B")
+        , RecommendValue("k")
+        , RecommendAlgorithm("C3_Z8_b_Nrw")
+        , RecommendNeighborAlg("k_W26U_B")
+        , RecommendNeighborSize("C3_Z8_b_Nrw")
+        , RecommendType("G__kz")
+        , RecommendSchedule("G__kz")
+        )
+      , ExtendSessionEntity("G__kz", [])
+      ]
+    )
+  , AccessControlDefinition(
+      Some("C3_Z8_b_Nrw")
+    , [ AccessControlPrincipal("C3_Z8_b_Nrw", ["k_W26U_B"])
+      , AccessControlRule(
+          "k_W26U_B"
+        , "jY1*"
+        , MatchArgs([], Some("*"))
+        , Not(
+            ForExp(
+              OrForExp(
+                ForExpNoFilter(
+                  True()
+                , "G__kz"
+                , SimpleSort("lEBrN_")
+                , Cast(Int("-83"), GenericSort("lEBrN_", [SimpleSort("lEBrN_")]))
+                )
+              )
+            , "C3_Z8_b_Nrw"
+            , SimpleSort("k")
+            , ListCreation([])
+            , FilterNoOrderBy(
+                SmallerThan(
+                  Div(RenderTemplateFunctionCall(TemplateCallNoBody("KE_W_v", [])), ValidateTemplateFunctionCall(ValidationErrors()))
+                , False()
+                )
+              , Limit(
+                  ThisCall("C3_Z8_b_Nrw", [])
+                , LargerThan(
+                    LargerThan(FieldAccess(Var("externalscope"), "lEBrN_"), GlobalVar("G__kz"))
+                  , LargerThan(
+                      Call(
+                        TypedListCreation(GenericSort("lEBrN_", [SimpleSort("k")]), [])
+                      , "lEBrN_"
+                      , []
+                      )
+                    , EmailFunctionCall(EmailCall("C3_Z8_b_Nrw", []))
+                    )
+                  )
+                )
+              )
+            )
+          )
+        , []
+        )
+      , SpecialAccessControlRule("k_W26U_B", ListCreation([]))
+      , SpecialAccessControlRule(
+          "k_W26U_B"
+        , Eq(
+            NotEq(Var("G__kz"), True())
+          , EmailFunctionCall(EmailCall("C3_Z8_b_Nrw", []))
+          )
+        )
+      , SpecialAccessControlRule(
+          "G__kz"
+        , Div(
+            TypedSetCreation(GenericSort("C3_Z8_b_Nrw", [SimpleSort("G__kz")]), [])
+          , CollectionIndex(ListCreation([]), SetCreation([]))
+          )
+        )
+      , AccessControlPointcut(
+          "k"
+        , [ Arg("k", RefSort(FunctionSort([], SimpleSort("lEBrN_"))))
+          , Arg("lEBrN_", SimpleSort("k"))
+          , Arg("k", SimpleSort("lEBrN_"))
+          , Arg("G__kz", FunctionSort([], SimpleSort("C3_Z8_b_Nrw")))
+          , Arg("k", GenericSort("k_W26U_B", [SimpleSort("k_W26U_B")]))
+          , Arg("lEBrN_", SimpleSort("k_W26U_B"))
+          , Arg("C3_Z8_b_Nrw", SimpleSort("G__kz"))
+          , Arg(
+              "k"
+            , RefSort(RefSort(GenericSort("G__kz", [SimpleSort("k")])))
+            )
+          , Arg("k_W26U_B", GenericSort("G__kz", [SimpleSort("C3_Z8_b_Nrw")]))
+          , Arg("k_W26U_B", RefSort(GenericSort("G__kz", [SimpleSort("C3_Z8_b_Nrw")])))
+          ]
+        , []
+        )
+      , AccessControlRule(
+          "lEBrN_"
+        , "*"
+        , MatchArgs([], Some("*"))
+        , FunctionRef("lEBrN_", [], SimpleSort("k"))
+        , []
+        )
+      , AccessControlPrincipal(
+          "k"
+        , ["k", "C3_Z8_b_Nrw", "C3_Z8_b_Nrw", "G__kz", "k", "C3_Z8_b_Nrw"]
+        )
+      , AccessControlRule(
+          "k"
+        , "*"
+        , MatchArgs([], Some("*"))
+        , Float(".8d")
+        , [ SpecialAccessControlRule(
+              "k"
+            , ObjectCreation(RefSort(RefSort(RefSort(SimpleSort("G__kz")))), [])
+            )
+          , AccessControlRule(
+              "G__kz"
+            , "*"
+            , MatchArgs([], Some("*"))
+            , CollectionIndex(False(), Var("k"))
+            , []
+            )
+          , AccessControlRule(
+              "lEBrN_"
+            , "jY1*"
+            , MatchArgs([], Some("*"))
+            , SearchTimeString(
+                Add(
+                  ObjectCreation(SimpleSort("k"), [])
+                , OrForExp(
+                    ForExp(
+                      Add(
+                        SendEmailFunctionCall(EmailCall("lEBrN_", []))
+                      , ObjectCreation(FunctionSort([], SimpleSort("G__kz")), [])
+                      )
+                    , "C3_Z8_b_Nrw"
+                    , FunctionSort([], SimpleSort("k_W26U_B"))
+                    , True()
+                    , FilterNoWhereNoLimit(OrderNonSpecific(EmailFunctionCall(EmailCall("k", []))))
+                    )
+                  )
+                )
+              )
+            , []
+            )
+          , SpecialAccessControlRule("C3_Z8_b_Nrw", FieldAccess(FieldAccess(Var("externalscope"), "G__kz"), "C3_Z8_b_Nrw"))
+          , SpecialAccessControlRule("k_W26U_B", FieldAccess(Var("externalscope"), "k"))
+          , AccessControlRule(
+              "C3_Z8_b_Nrw"
+            , "jY1*"
+            , MatchArgs([], Some("*"))
+            , Mul(ListCreation([]), True())
+            , []
+            )
+          ]
+        )
+      ]
+    )
+  ]
+)
\ No newline at end of file

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855crashed/program.app
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855crashed/program.app	Thu Aug  9 09:26:10 2012	(r25268)
@@ -0,0 +1,210 @@
+application k_W26U_B
+
+access
+
+control
+
+policy
+
+k_W26U_B
+
+OR
+
+G__kz
+
+AND
+
+k_W26U_B
+
+AND
+
+k
+
+AND
+
+k_W26U_B
+
+OR
+
+k_W26U_B
+
+AND
+
+G__kz
+
+AND
+
+k
+
+OR
+
+G__kz
+
+AND
+
+k_W26U_B
+
+AND
+
+k_W26U_B
+
+OR
+
+k
+
+AND
+
+k
+
+section o+q  .
+
+  extend entity lEBrN_ {
+  }
+
+  service
+
+  k
+
+  (
+
+  )
+
+  {
+  }
+
+  derive
+
+  webservices
+
+  for
+
+  C3_Z8_b_Nrw
+
+  ,
+
+  with
+
+  nameproperty
+
+  lEBrN_
+
+  default_builtin_analyzer analyzer k_W26U_B {
+    tokenizer = k_W26U_B ( )
+  }
+
+  recommenderStaticOrder
+
+  k
+
+  {
+
+  k
+
+  k_W26U_B
+
+  k
+
+  C3_Z8_b_Nrw
+
+  k_W26U_B
+
+  C3_Z8_b_Nrw
+
+  G__kz
+
+  G__kz
+
+  }
+
+  extend
+
+  session
+
+  G__kz
+
+  {
+
+  }
+
+access control rules
+  C3_Z8_b_Nrw
+  principal
+  is
+  C3_Z8_b_Nrw
+  with
+  credentials
+  k_W26U_B
+  rule k_W26U_B jY1* ( * ) {
+    ! [ Or [ true for ( G__kz : lEBrN_ in ( -83 as lEBrN_<lEBrN_> ) ) ] for ( C3_Z8_b_Nrw : k in [] where rendertemplate ( KE_W_v() ) / validatetemplate ( validationErrors ( ) ) < false limit C3_Z8_b_Nrw() offset externalscope . lEBrN_ > global.G__kz > List<lEBrN_<k>>().lEBrN_() > email ( C3_Z8_b_Nrw ( ) ) ) ]
+  }
+  rule k_W26U_B {
+    []
+  }
+  rule k_W26U_B {
+    G__kz != true == email ( C3_Z8_b_Nrw ( ) )
+  }
+  rule G__kz {
+    Set<C3_Z8_b_Nrw<G__kz>>() / [
+                                ] [ {} ]
+  }
+  pointcut
+  k
+  (
+  k : Ref<function():lEBrN_>
+  ,
+  lEBrN_ : k
+  ,
+  k : lEBrN_
+  ,
+  G__kz : function ( ) : C3_Z8_b_Nrw
+  ,
+  k : k_W26U_B<k_W26U_B>
+  ,
+  lEBrN_ : k_W26U_B
+  ,
+  C3_Z8_b_Nrw : G__kz
+  ,
+  k : Ref<Ref<G__kz<k>>>
+  ,
+  k_W26U_B : G__kz<C3_Z8_b_Nrw>
+  ,
+  k_W26U_B : Ref<G__kz<C3_Z8_b_Nrw>>
+  )
+  {
+  }
+  rule lEBrN_ * ( * ) {
+    function. lEBrN_ ( ) : k
+  }
+  principal
+  is
+  k
+  with
+  credentials
+  k
+  ,
+  C3_Z8_b_Nrw
+  ,
+  C3_Z8_b_Nrw
+  ,
+  G__kz
+  ,
+  k
+  ,
+  C3_Z8_b_Nrw
+  rule k * ( * ) {
+    .8d
+    rule k {
+      Ref<Ref<Ref<G__kz>>>{}
+    } rule G__kz * ( * ) {
+        false [ k ]
+      } rule lEBrN_ jY1* ( * ) {
+          searchtime from k{} + Or [ sendemail ( lEBrN_ ( ) ) + function ( ) : G__kz {
+                                                                                     } for ( C3_Z8_b_Nrw : function ( ) : k_W26U_B in true order by email ( k ( ) ) ) ]
+        } rule C3_Z8_b_Nrw {
+            externalscope.G__kz.C3_Z8_b_Nrw
+          } rule k_W26U_B {
+              externalscope . k
+            } rule C3_Z8_b_Nrw jY1* ( * ) {
+                [] * true
+              }
+  }
\ No newline at end of file

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855crashed/strategyResult.txt
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/l_1855crashed/strategyResult.txt	Thu Aug  9 09:26:10 2012	(r25268)
@@ -0,0 +1,554 @@
+
+Analyzing: TestFolder/program.app
+rename: 0.140 s
+
+* : error: Extended entity lEBrN_ does not exist: extend entity lEBrN_ {
+}
+extend entity lEBrN_ {
+}
+* : error: Recommendation Block 'k' does not use a correct boolean or preference algoritm, please correct the typo, correct values are [Euclidean, Pearson, Loglikelihood, Tanimoto], current value: 'C3_Z8_b_Nrw'
+recommenderStaticOrder k { k k_W26U_B k C3_Z8_b_Nrw k_W26U_B C3_Z8_b_Nrw G__kz
+G__kz }
+* : error: Recommendation Block 'k' does not use a correct neighborhood algoritm, please correct the typo, correct values are [NUser, Threshold], current value: 'k_W26U_B'
+recommenderStaticOrder k { k k_W26U_B k C3_Z8_b_Nrw k_W26U_B C3_Z8_b_Nrw G__kz
+G__kz }
+* : error: Recommendation Block 'k' does not use a recommendation type, please correct the typo, correct values are [Item, User, Both], current value: 'G__kz'
+recommenderStaticOrder k { k k_W26U_B k C3_Z8_b_Nrw k_W26U_B C3_Z8_b_Nrw G__kz
+G__kz }
+* : error: Recommendation Block 'k' does not use a correct neighborhood and type combination, either unset the neighborhood or switch the type to User. Current value of the type: 'G__kz'
+recommenderStaticOrder k { k k_W26U_B k C3_Z8_b_Nrw k_W26U_B C3_Z8_b_Nrw G__kz
+G__kz }
+* : error: Extended session entity G__kz does not exist: extend session G__kz { }
+extend session G__kz { }
+* : error: Entity 'C3_Z8_b_Nrw' does not exist, and cannot be used as principal for access control.
+principal is C3_Z8_b_Nrw with credentials k_W26U_B
+* : error: Principal credential 'k_W26U_B' is not a property of entity 'C3_Z8_b_Nrw'.
+k_W26U_B
+* : error: Principal credential 'k_W26U_B' is not compatible with String type.
+k_W26U_B
+* : error: Only one access control principal can be defined.
+principal is C3_Z8_b_Nrw with credentials k_W26U_B
+* : error: Type not defined: lEBrN_
+lEBrN_
+* : error: Type not defined: lEBrN_
+lEBrN_
+* : error: Generic type not defined: lEBrN_<lEBrN_>
+lEBrN_<lEBrN_>
+* : error: Cannot cast -83 to type lEBrN_<lEBrN_>
+( -83 as lEBrN_<lEBrN_> )
+* : error: collection in for-expression does not contain declared type lEBrN_
+[ true for ( G__kz : lEBrN_ in ( -83 as lEBrN_<lEBrN_> ) ) ]
+* : error: Type not defined: k
+k
+* : error: Type cannot be determined for empty untyped list creation.
+[]
+* : error: Template with signature KE_W_v() not defined 
+KE_W_v()
+* : error: Wrong operand types for operator Div: rendertemplate ( KE_W_v() ) has type String,validatetemplate ( validationErrors ( ) ) has type String
+rendertemplate ( KE_W_v() ) / validatetemplate ( validationErrors ( ) )
+* : error: No function 'C3_Z8_b_Nrw' with signature C3_Z8_b_Nrw(). Available global functions with that name: 
+C3_Z8_b_Nrw()
+* : error: Variable 'externalscope' not defined
+externalscope
+* : error: Type not defined: k
+k
+* : error: Generic type not defined: lEBrN_<k>
+lEBrN_<k>
+* : error: No function 'lEBrN_' for 'List<lEBrN_<k>>()' with signature lEBrN_()
+List<lEBrN_<k>>().lEBrN_()
+* : error: No email definition for C3_Z8_b_Nrw ( ).
+C3_Z8_b_Nrw ( )
+* : error: Expression should be of type Int
+C3_Z8_b_Nrw()
+* : error: Expression should be of type Int
+externalscope.lEBrN_ > global.G__kz > List<lEBrN_<k>>().lEBrN_() > email (
+C3_Z8_b_Nrw ( ) )
+* : error: where clause should return a boolean: 
+where rendertemplate ( KE_W_v() ) / validatetemplate ( validationErrors ( ) ) <
+false limit C3_Z8_b_Nrw() offset externalscope.lEBrN_ > global.G__kz >
+List<lEBrN_<k>>().lEBrN_() > email ( C3_Z8_b_Nrw ( ) )
+* : error: collection in for-expression does not contain declared type k
+[ Or [ true for ( G__kz : lEBrN_ in ( -83 as lEBrN_<lEBrN_> ) ) ] for (
+C3_Z8_b_Nrw : k in [] where rendertemplate ( KE_W_v() ) / validatetemplate (
+validationErrors ( ) ) < false limit C3_Z8_b_Nrw() offset externalscope.lEBrN_ >
+global.G__kz > List<lEBrN_<k>>().lEBrN_() > email ( C3_Z8_b_Nrw ( ) ) ) ]
+* : error: [ Or [ true for ( G__kz : lEBrN_ in ( -83 as lEBrN_<lEBrN_> ) ) ] for (
+C3_Z8_b_Nrw : k in [] where rendertemplate ( KE_W_v() ) / validatetemplate (
+validationErrors ( ) ) < false limit C3_Z8_b_Nrw() offset externalscope.lEBrN_ >
+global.G__kz > List<lEBrN_<k>>().lEBrN_() > email ( C3_Z8_b_Nrw ( ) ) ) ] is not of type Bool
+! [ Or [ true for ( G__kz : lEBrN_ in ( -83 as lEBrN_<lEBrN_> ) ) ] for (
+C3_Z8_b_Nrw : k in [] where rendertemplate ( KE_W_v() ) / validatetemplate (
+validationErrors ( ) ) < false limit C3_Z8_b_Nrw() offset externalscope.lEBrN_ >
+global.G__kz > List<lEBrN_<k>>().lEBrN_() > email ( C3_Z8_b_Nrw ( ) ) ) ]
+* : error: rule type unknown: rule k_W26U_B jY1* ( * ) {
+  ! [ Or [ true for ( G__kz : lEBrN_ in ( -83 as lEBrN_<lEBrN_> ) ) ] for ( C3_Z8_b_Nrw : k in [] where rendertemplate ( KE_W_v() ) / validatetemplate ( validationErrors ( ) ) < false limit C3_Z8_b_Nrw() offset externalscope.lEBrN_ > global.G__kz > List<lEBrN_<k>>().lEBrN_() > email ( C3_Z8_b_Nrw ( ) ) ) ]
+}
+rule k_W26U_B jY1* ( * ) {
+  ! [ Or [ true for ( G__kz : lEBrN_ in ( -83 as lEBrN_<lEBrN_> ) ) ] for ( C3_Z8_b_Nrw : k in [] where rendertemplate ( KE_W_v() ) / validatetemplate ( validationErrors ( ) ) < false limit C3_Z8_b_Nrw() offset externalscope.lEBrN_ > global.G__kz > List<lEBrN_<k>>().lEBrN_() > email ( C3_Z8_b_Nrw ( ) ) ) ]
+}
+* : error: Type cannot be determined for empty untyped list creation.
+[]
+* : error: rule type unknown: rule k_W26U_B {
+  []
+}
+rule k_W26U_B {
+  []
+}
+* : error: Variable 'G__kz' not defined
+G__kz
+* : error: No email definition for C3_Z8_b_Nrw ( ).
+C3_Z8_b_Nrw ( )
+* : error: rule type unknown: rule k_W26U_B {
+  G__kz != true == email ( C3_Z8_b_Nrw ( ) )
+}
+rule k_W26U_B {
+  G__kz != true == email ( C3_Z8_b_Nrw ( ) )
+}
+* : error: Type not defined: G__kz
+G__kz
+* : error: Generic type not defined: C3_Z8_b_Nrw<G__kz>
+C3_Z8_b_Nrw<G__kz>
+* : error: Type cannot be determined for empty untyped list creation.
+[]
+* : error: Type cannot be determined for empty untyped set creation.
+{}
+* : error: rule type unknown: rule G__kz {
+  Set<C3_Z8_b_Nrw<G__kz>>() / [] [ {} ]
+}
+rule G__kz {
+  Set<C3_Z8_b_Nrw<G__kz>>() / [] [ {} ]
+}
+* : error: Type not defined: lEBrN_
+lEBrN_
+* : error: Reference argument 'Ref<function():lEBrN_>' only allowed in formal parameters of pages, templates, or ajax templates
+k : Ref<function():lEBrN_>
+* : error: Generic type not defined: EntityTypeNamed<k>
+EntityTypeNamed<k>
+* : error: Generic type not defined: EntityTypeNamed<lEBrN_>
+EntityTypeNamed<lEBrN_>
+* : error: Type not defined: C3_Z8_b_Nrw
+C3_Z8_b_Nrw
+* : error: Type not defined: k_W26U_B
+k_W26U_B
+* : error: Generic type not defined: k_W26U_B<k_W26U_B>
+k_W26U_B<k_W26U_B>
+* : error: Type not defined: k_W26U_B
+k_W26U_B
+* : error: Generic type not defined: EntityTypeNamed<G__kz>
+EntityTypeNamed<G__kz>
+* : error: Type not defined: k
+k
+* : error: Generic type not defined: G__kz<k>
+G__kz<k>
+* : error: Reference argument 'Ref<Ref<G__kz<k>>>' only allowed in formal parameters of pages, templates, or ajax templates
+k : Ref<Ref<G__kz<k>>>
+* : error: Type not defined: C3_Z8_b_Nrw
+C3_Z8_b_Nrw
+* : error: Generic type not defined: G__kz<C3_Z8_b_Nrw>
+G__kz<C3_Z8_b_Nrw>
+* : error: Type not defined: C3_Z8_b_Nrw
+C3_Z8_b_Nrw
+* : error: Generic type not defined: G__kz<C3_Z8_b_Nrw>
+G__kz<C3_Z8_b_Nrw>
+* : error: Reference argument 'Ref<G__kz<C3_Z8_b_Nrw>>' only allowed in formal parameters of pages, templates, or ajax templates
+k_W26U_B : Ref<G__kz<C3_Z8_b_Nrw>>
+* : error: Generic type not defined: EntityTypeNamed<k>
+EntityTypeNamed<k>
+* : error: rule should contain a Bool expression: rule lEBrN_ * ( * ) {
+  function. lEBrN_ ( ) : EntityTypeNamed<k>
+}
+rule lEBrN_ * ( * ) {
+  function. lEBrN_ ( ) : EntityTypeNamed<k>
+}
+* : error: rule type unknown: rule lEBrN_ * ( * ) {
+  function. lEBrN_ ( ) : EntityTypeNamed<k>
+}
+rule lEBrN_ * ( * ) {
+  function. lEBrN_ ( ) : EntityTypeNamed<k>
+}
+* : error: Entity 'k' does not exist, and cannot be used as principal for access control.
+principal is k with credentials k , C3_Z8_b_Nrw , C3_Z8_b_Nrw , G__kz , k ,
+C3_Z8_b_Nrw
+* : error: Principal credential 'k' is not a property of entity 'k'.
+k
+* : error: Principal credential 'k' is not compatible with String type.
+k
+* : error: Principal credential 'C3_Z8_b_Nrw' is not a property of entity 'k'.
+C3_Z8_b_Nrw
+* : error: Principal credential 'C3_Z8_b_Nrw' is not compatible with String type.
+C3_Z8_b_Nrw
+* : error: Principal credential 'C3_Z8_b_Nrw' is not a property of entity 'k'.
+C3_Z8_b_Nrw
+* : error: Principal credential 'C3_Z8_b_Nrw' is not compatible with String type.
+C3_Z8_b_Nrw
+* : error: Principal credential 'G__kz' is not a property of entity 'k'.
+G__kz
+* : error: Principal credential 'G__kz' is not compatible with String type.
+G__kz
+* : error: Principal credential 'k' is not a property of entity 'k'.
+k
+* : error: Principal credential 'k' is not compatible with String type.
+k
+* : error: Principal credential 'C3_Z8_b_Nrw' is not a property of entity 'k'.
+C3_Z8_b_Nrw
+* : error: Principal credential 'C3_Z8_b_Nrw' is not compatible with String type.
+C3_Z8_b_Nrw
+* : error: Only one access control principal can be defined.
+principal is k with credentials k , C3_Z8_b_Nrw , C3_Z8_b_Nrw , G__kz , k ,
+C3_Z8_b_Nrw
+* : error: Type not defined: G__kz
+G__kz
+* : error: Entity object instantiation syntax is only supported for entity types, found type: 'Ref<Ref<Ref<G__kz>>>'
+Ref<Ref<Ref<G__kz>>>{}
+* : error: rule should contain a Bool expression: rule k {
+  Ref<Ref<Ref<G__kz>>>{}
+}
+rule k {
+  Ref<Ref<Ref<G__kz>>>{}
+}
+* : error: rule type unknown: rule k {
+  Ref<Ref<Ref<G__kz>>>{}
+}
+rule k {
+  Ref<Ref<Ref<G__kz>>>{}
+}
+* : error: Variable 'k' not defined
+k
+* : error: rule type unknown: rule G__kz * ( * ) {
+  false [ k ]
+}
+rule G__kz * ( * ) {
+  false [ k ]
+}
+* : error: Type not defined: k
+k
+* : error: Entity object instantiation syntax is only supported for entity types, found type: 'k'
+k{}
+* : error: No email definition for lEBrN_ ( ).
+lEBrN_ ( )
+* : error: Type not defined: G__kz
+G__kz
+* : error: Entity object instantiation syntax is only supported for entity types, found type: 'function():G__kz'
+function():G__kz{}
+* : error: Wrong operand types for operator Add: sendemail ( lEBrN_ ( ) ) has type Bool,function():G__kz{} has type function():G__kz
+sendemail ( lEBrN_ ( ) ) + function():G__kz{}
+* : error: Generic type not defined: EntityTypeNamed<k_W26U_B>
+EntityTypeNamed<k_W26U_B>
+* : error: No email definition for k ( ).
+k ( )
+WebDSL: rewriting failed, trace:
+	editor_analyze1_0_0
+	editor_analyze1_0_0
+	editor_analyze_0_0
+	editor_analyze_work_0_0
+	in_typechecking_phase_1_0
+	dr_scope_1_1
+	editor_check_0_1
+	dr_scope_1_1
+	dr_scope_1_1
+	dbg_time_1_1
+	catch_errors_editor_1_0
+	dr_scope_1_1
+	dr_scope_1_1
+	constraint_error_all_0_0
+	bottomup_1_0
+	bottomup_1_0
+	bottomup_1_0
+	bottomup_1_0
+	bottomup_1_0
+	bottomup_1_0
+	bottomup_1_0
+	bottomup_1_0
+	bottomup_1_0
+	bottomup_1_0
+	bottomup_1_0
+	try_1_0
+	constraint_error_0_0
+	constraint_error_action_0_0
+	constraint_error_action_0_0_fragment_1
+	constraint_error_action_0_0_fragment_0
+	forexp_constraint_error_0_2
+	pp_type_0_0
+	pp_type_aux_0_0
+	pp_type_0_0
+	pp_type_aux_0_0
+	pp_type_0_0
+	pp_type_aux_0_0
+[ WebDSL | critical ] Internal error: with clause failed unexpectedly in rule 'pp-type'
+           "k_W26U_B"{"topdef36_k_W26U_B1"}Analyzing: TestFolder/program.app
+rename: 0.140 s
+
+* : error: Extended entity lEBrN_ does not exist: extend entity lEBrN_ {
+}
+extend entity lEBrN_ {
+}
+* : error: Recommendation Block 'k' does not use a correct boolean or preference algoritm, please correct the typo, correct values are [Euclidean, Pearson, Loglikelihood, Tanimoto], current value: 'C3_Z8_b_Nrw'
+recommenderStaticOrder k { k k_W26U_B k C3_Z8_b_Nrw k_W26U_B C3_Z8_b_Nrw G__kz
+G__kz }
+* : error: Recommendation Block 'k' does not use a correct neighborhood algoritm, please correct the typo, correct values are [NUser, Threshold], current value: 'k_W26U_B'
+recommenderStaticOrder k { k k_W26U_B k C3_Z8_b_Nrw k_W26U_B C3_Z8_b_Nrw G__kz
+G__kz }
+* : error: Recommendation Block 'k' does not use a recommendation type, please correct the typo, correct values are [Item, User, Both], current value: 'G__kz'
+recommenderStaticOrder k { k k_W26U_B k C3_Z8_b_Nrw k_W26U_B C3_Z8_b_Nrw G__kz
+G__kz }
+* : error: Recommendation Block 'k' does not use a correct neighborhood and type combination, either unset the neighborhood or switch the type to User. Current value of the type: 'G__kz'
+recommenderStaticOrder k { k k_W26U_B k C3_Z8_b_Nrw k_W26U_B C3_Z8_b_Nrw G__kz
+G__kz }
+* : error: Extended session entity G__kz does not exist: extend session G__kz { }
+extend session G__kz { }
+* : error: Entity 'C3_Z8_b_Nrw' does not exist, and cannot be used as principal for access control.
+principal is C3_Z8_b_Nrw with credentials k_W26U_B
+* : error: Principal credential 'k_W26U_B' is not a property of entity 'C3_Z8_b_Nrw'.
+k_W26U_B
+* : error: Principal credential 'k_W26U_B' is not compatible with String type.
+k_W26U_B
+* : error: Only one access control principal can be defined.
+principal is C3_Z8_b_Nrw with credentials k_W26U_B
+* : error: Type not defined: lEBrN_
+lEBrN_
+* : error: Type not defined: lEBrN_
+lEBrN_
+* : error: Generic type not defined: lEBrN_<lEBrN_>
+lEBrN_<lEBrN_>
+* : error: Cannot cast -83 to type lEBrN_<lEBrN_>
+( -83 as lEBrN_<lEBrN_> )
+* : error: collection in for-expression does not contain declared type lEBrN_
+[ true for ( G__kz : lEBrN_ in ( -83 as lEBrN_<lEBrN_> ) ) ]
+* : error: Type not defined: k
+k
+* : error: Type cannot be determined for empty untyped list creation.
+[]
+* : error: Template with signature KE_W_v() not defined 
+KE_W_v()
+* : error: Wrong operand types for operator Div: rendertemplate ( KE_W_v() ) has type String,validatetemplate ( validationErrors ( ) ) has type String
+rendertemplate ( KE_W_v() ) / validatetemplate ( validationErrors ( ) )
+* : error: No function 'C3_Z8_b_Nrw' with signature C3_Z8_b_Nrw(). Available global functions with that name: 
+C3_Z8_b_Nrw()
+* : error: Variable 'externalscope' not defined
+externalscope
+* : error: Type not defined: k
+k
+* : error: Generic type not defined: lEBrN_<k>
+lEBrN_<k>
+* : error: No function 'lEBrN_' for 'List<lEBrN_<k>>()' with signature lEBrN_()
+List<lEBrN_<k>>().lEBrN_()
+* : error: No email definition for C3_Z8_b_Nrw ( ).
+C3_Z8_b_Nrw ( )
+* : error: Expression should be of type Int
+C3_Z8_b_Nrw()
+* : error: Expression should be of type Int
+externalscope.lEBrN_ > global.G__kz > List<lEBrN_<k>>().lEBrN_() > email (
+C3_Z8_b_Nrw ( ) )
+* : error: where clause should return a boolean: 
+where rendertemplate ( KE_W_v() ) / validatetemplate ( validationErrors ( ) ) <
+false limit C3_Z8_b_Nrw() offset externalscope.lEBrN_ > global.G__kz >
+List<lEBrN_<k>>().lEBrN_() > email ( C3_Z8_b_Nrw ( ) )
+* : error: collection in for-expression does not contain declared type k
+[ Or [ true for ( G__kz : lEBrN_ in ( -83 as lEBrN_<lEBrN_> ) ) ] for (
+C3_Z8_b_Nrw : k in [] where rendertemplate ( KE_W_v() ) / validatetemplate (
+validationErrors ( ) ) < false limit C3_Z8_b_Nrw() offset externalscope.lEBrN_ >
+global.G__kz > List<lEBrN_<k>>().lEBrN_() > email ( C3_Z8_b_Nrw ( ) ) ) ]
+* : error: [ Or [ true for ( G__kz : lEBrN_ in ( -83 as lEBrN_<lEBrN_> ) ) ] for (
+C3_Z8_b_Nrw : k in [] where rendertemplate ( KE_W_v() ) / validatetemplate (
+validationErrors ( ) ) < false limit C3_Z8_b_Nrw() offset externalscope.lEBrN_ >
+global.G__kz > List<lEBrN_<k>>().lEBrN_() > email ( C3_Z8_b_Nrw ( ) ) ) ] is not of type Bool
+! [ Or [ true for ( G__kz : lEBrN_ in ( -83 as lEBrN_<lEBrN_> ) ) ] for (
+C3_Z8_b_Nrw : k in [] where rendertemplate ( KE_W_v() ) / validatetemplate (
+validationErrors ( ) ) < false limit C3_Z8_b_Nrw() offset externalscope.lEBrN_ >
+global.G__kz > List<lEBrN_<k>>().lEBrN_() > email ( C3_Z8_b_Nrw ( ) ) ) ]
+* : error: rule type unknown: rule k_W26U_B jY1* ( * ) {
+  ! [ Or [ true for ( G__kz : lEBrN_ in ( -83 as lEBrN_<lEBrN_> ) ) ] for ( C3_Z8_b_Nrw : k in [] where rendertemplate ( KE_W_v() ) / validatetemplate ( validationErrors ( ) ) < false limit C3_Z8_b_Nrw() offset externalscope.lEBrN_ > global.G__kz > List<lEBrN_<k>>().lEBrN_() > email ( C3_Z8_b_Nrw ( ) ) ) ]
+}
+rule k_W26U_B jY1* ( * ) {
+  ! [ Or [ true for ( G__kz : lEBrN_ in ( -83 as lEBrN_<lEBrN_> ) ) ] for ( C3_Z8_b_Nrw : k in [] where rendertemplate ( KE_W_v() ) / validatetemplate ( validationErrors ( ) ) < false limit C3_Z8_b_Nrw() offset externalscope.lEBrN_ > global.G__kz > List<lEBrN_<k>>().lEBrN_() > email ( C3_Z8_b_Nrw ( ) ) ) ]
+}
+* : error: Type cannot be determined for empty untyped list creation.
+[]
+* : error: rule type unknown: rule k_W26U_B {
+  []
+}
+rule k_W26U_B {
+  []
+}
+* : error: Variable 'G__kz' not defined
+G__kz
+* : error: No email definition for C3_Z8_b_Nrw ( ).
+C3_Z8_b_Nrw ( )
+* : error: rule type unknown: rule k_W26U_B {
+  G__kz != true == email ( C3_Z8_b_Nrw ( ) )
+}
+rule k_W26U_B {
+  G__kz != true == email ( C3_Z8_b_Nrw ( ) )
+}
+* : error: Type not defined: G__kz
+G__kz
+* : error: Generic type not defined: C3_Z8_b_Nrw<G__kz>
+C3_Z8_b_Nrw<G__kz>
+* : error: Type cannot be determined for empty untyped list creation.
+[]
+* : error: Type cannot be determined for empty untyped set creation.
+{}
+* : error: rule type unknown: rule G__kz {
+  Set<C3_Z8_b_Nrw<G__kz>>() / [] [ {} ]
+}
+rule G__kz {
+  Set<C3_Z8_b_Nrw<G__kz>>() / [] [ {} ]
+}
+* : error: Type not defined: lEBrN_
+lEBrN_
+* : error: Reference argument 'Ref<function():lEBrN_>' only allowed in formal parameters of pages, templates, or ajax templates
+k : Ref<function():lEBrN_>
+* : error: Generic type not defined: EntityTypeNamed<k>
+EntityTypeNamed<k>
+* : error: Generic type not defined: EntityTypeNamed<lEBrN_>
+EntityTypeNamed<lEBrN_>
+* : error: Type not defined: C3_Z8_b_Nrw
+C3_Z8_b_Nrw
+* : error: Type not defined: k_W26U_B
+k_W26U_B
+* : error: Generic type not defined: k_W26U_B<k_W26U_B>
+k_W26U_B<k_W26U_B>
+* : error: Type not defined: k_W26U_B
+k_W26U_B
+* : error: Generic type not defined: EntityTypeNamed<G__kz>
+EntityTypeNamed<G__kz>
+* : error: Type not defined: k
+k
+* : error: Generic type not defined: G__kz<k>
+G__kz<k>
+* : error: Reference argument 'Ref<Ref<G__kz<k>>>' only allowed in formal parameters of pages, templates, or ajax templates
+k : Ref<Ref<G__kz<k>>>
+* : error: Type not defined: C3_Z8_b_Nrw
+C3_Z8_b_Nrw
+* : error: Generic type not defined: G__kz<C3_Z8_b_Nrw>
+G__kz<C3_Z8_b_Nrw>
+* : error: Type not defined: C3_Z8_b_Nrw
+C3_Z8_b_Nrw
+* : error: Generic type not defined: G__kz<C3_Z8_b_Nrw>
+G__kz<C3_Z8_b_Nrw>
+* : error: Reference argument 'Ref<G__kz<C3_Z8_b_Nrw>>' only allowed in formal parameters of pages, templates, or ajax templates
+k_W26U_B : Ref<G__kz<C3_Z8_b_Nrw>>
+* : error: Generic type not defined: EntityTypeNamed<k>
+EntityTypeNamed<k>
+* : error: rule should contain a Bool expression: rule lEBrN_ * ( * ) {
+  function. lEBrN_ ( ) : EntityTypeNamed<k>
+}
+rule lEBrN_ * ( * ) {
+  function. lEBrN_ ( ) : EntityTypeNamed<k>
+}
+* : error: rule type unknown: rule lEBrN_ * ( * ) {
+  function. lEBrN_ ( ) : EntityTypeNamed<k>
+}
+rule lEBrN_ * ( * ) {
+  function. lEBrN_ ( ) : EntityTypeNamed<k>
+}
+* : error: Entity 'k' does not exist, and cannot be used as principal for access control.
+principal is k with credentials k , C3_Z8_b_Nrw , C3_Z8_b_Nrw , G__kz , k ,
+C3_Z8_b_Nrw
+* : error: Principal credential 'k' is not a property of entity 'k'.
+k
+* : error: Principal credential 'k' is not compatible with String type.
+k
+* : error: Principal credential 'C3_Z8_b_Nrw' is not a property of entity 'k'.
+C3_Z8_b_Nrw
+* : error: Principal credential 'C3_Z8_b_Nrw' is not compatible with String type.
+C3_Z8_b_Nrw
+* : error: Principal credential 'C3_Z8_b_Nrw' is not a property of entity 'k'.
+C3_Z8_b_Nrw
+* : error: Principal credential 'C3_Z8_b_Nrw' is not compatible with String type.
+C3_Z8_b_Nrw
+* : error: Principal credential 'G__kz' is not a property of entity 'k'.
+G__kz
+* : error: Principal credential 'G__kz' is not compatible with String type.
+G__kz
+* : error: Principal credential 'k' is not a property of entity 'k'.
+k
+* : error: Principal credential 'k' is not compatible with String type.
+k
+* : error: Principal credential 'C3_Z8_b_Nrw' is not a property of entity 'k'.
+C3_Z8_b_Nrw
+* : error: Principal credential 'C3_Z8_b_Nrw' is not compatible with String type.
+C3_Z8_b_Nrw
+* : error: Only one access control principal can be defined.
+principal is k with credentials k , C3_Z8_b_Nrw , C3_Z8_b_Nrw , G__kz , k ,
+C3_Z8_b_Nrw
+* : error: Type not defined: G__kz
+G__kz
+* : error: Entity object instantiation syntax is only supported for entity types, found type: 'Ref<Ref<Ref<G__kz>>>'
+Ref<Ref<Ref<G__kz>>>{}
+* : error: rule should contain a Bool expression: rule k {
+  Ref<Ref<Ref<G__kz>>>{}
+}
+rule k {
+  Ref<Ref<Ref<G__kz>>>{}
+}
+* : error: rule type unknown: rule k {
+  Ref<Ref<Ref<G__kz>>>{}
+}
+rule k {
+  Ref<Ref<Ref<G__kz>>>{}
+}
+* : error: Variable 'k' not defined
+k
+* : error: rule type unknown: rule G__kz * ( * ) {
+  false [ k ]
+}
+rule G__kz * ( * ) {
+  false [ k ]
+}
+* : error: Type not defined: k
+k
+* : error: Entity object instantiation syntax is only supported for entity types, found type: 'k'
+k{}
+* : error: No email definition for lEBrN_ ( ).
+lEBrN_ ( )
+* : error: Type not defined: G__kz
+G__kz
+* : error: Entity object instantiation syntax is only supported for entity types, found type: 'function():G__kz'
+function():G__kz{}
+* : error: Wrong operand types for operator Add: sendemail ( lEBrN_ ( ) ) has type Bool,function():G__kz{} has type function():G__kz
+sendemail ( lEBrN_ ( ) ) + function():G__kz{}
+* : error: Generic type not defined: EntityTypeNamed<k_W26U_B>
+EntityTypeNamed<k_W26U_B>
+* : error: No email definition for k ( ).
+k ( )
+WebDSL: rewriting failed, trace:
+	editor_analyze1_0_0
+	editor_analyze1_0_0
+	editor_analyze_0_0
+	editor_analyze_work_0_0
+	in_typechecking_phase_1_0
+	dr_scope_1_1
+	editor_check_0_1
+	dr_scope_1_1
+	dr_scope_1_1
+	dbg_time_1_1
+	catch_errors_editor_1_0
+	dr_scope_1_1
+	dr_scope_1_1
+	constraint_error_all_0_0
+	bottomup_1_0
+	bottomup_1_0
+	bottomup_1_0
+	bottomup_1_0
+	bottomup_1_0
+	bottomup_1_0
+	bottomup_1_0
+	bottomup_1_0
+	bottomup_1_0
+	bottomup_1_0
+	bottomup_1_0
+	try_1_0
+	constraint_error_0_0
+	constraint_error_action_0_0
+	constraint_error_action_0_0_fragment_1
+	constraint_error_action_0_0_fragment_0
+	forexp_constraint_error_0_2
+	pp_type_0_0
+	pp_type_aux_0_0
+	pp_type_0_0
+	pp_type_aux_0_0
+	pp_type_0_0
+	pp_type_aux_0_0
+[ WebDSL | critical ] Internal error: with clause failed unexpectedly in rule 'pp-type'
+           "k_W26U_B"{"topdef36_k_W26U_B1"}
\ No newline at end of file

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/n_1790crashed/AST.aterm
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/n_1790crashed/AST.aterm	Thu Aug  9 09:26:10 2012	(r25268)
@@ -0,0 +1,48 @@
+ApplicationDefs(
+  Qualified("l9_4JRa3N_D", "S_")
+, [ RecommendConfig(
+      "S_"
+    , [ RecommendArgument("algorithm", "0465")
+      , RecommendArgument("algorithm", TimeInterval([]))
+      , RecommendArgument("neighborhoodsize", TimeInterval([]))
+      , RecommendArgument("user", "LFB_62_eQHC")
+      ]
+    )
+  ]
+, [ Section(
+      " p ."
+    , [ ServiceFunction(
+          "S_"
+        , [ Arg("mih_6", FunctionSort([], SimpleSort("S_")))
+          , Arg("LFB_62_eQHC", FunctionSort([], SimpleSort("Void")))
+          , Arg("S_", GenericSort("mih_6", [SimpleSort("l9_4JRa3N_D")]))
+          , Arg("mih_6", SimpleSort("S_"))
+          , Arg("l9_4JRa3N_D", GenericSort("l9_4JRa3N_D", [SimpleSort("mih_6")]))
+          , Arg("S_", GenericSort("LFB_62_eQHC", [SimpleSort("mih_6")]))
+          ]
+        , Block([])
+        )
+      ]
+    )
+  , AccessControlDefinition(
+      Some("mih_6")
+    , [ SpecialAccessControlRule(
+          "bmr_"
+        , Call(
+            RegexPattern(
+              TupleBranch(
+                SingleBranch(Pieces([SingleAtom(QuotedAtom("--!$!"))]))
+              , SingleBranch(Pieces([QuantifiedAtom(LineStart(), ReluctantOneOrMore())]))
+              )
+            )
+          , "bmr_"
+          , []
+          )
+        )
+      , Predicate("LFB_62_eQHC", [], True())
+      , AccessControlPrincipal("S_", ["mih_6"])
+      , AccessControlPrincipal("LFB_62_eQHC", ["mih_6"])
+      ]
+    )
+  ]
+)
\ No newline at end of file

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/n_1790crashed/program.app
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/n_1790crashed/program.app	Thu Aug  9 09:26:10 2012	(r25268)
@@ -0,0 +1,89 @@
+application l9_4JRa3N_D.S_
+
+recommend
+
+S_
+
+{
+
+algorithm
+
+=
+
+0465
+
+algorithm
+
+=
+
+neighborhoodsize
+
+=
+
+user
+
+=
+
+LFB_62_eQHC
+
+}
+
+section p .
+
+  service
+
+  S_
+
+  (
+
+  mih_6 : function ( ) : S_
+
+  ,
+
+  LFB_62_eQHC : function ( ) : Void
+
+  ,
+
+  S_ : mih_6<l9_4JRa3N_D>
+
+  ,
+
+  mih_6 : S_
+
+  ,
+
+  l9_4JRa3N_D : l9_4JRa3N_D<mih_6>
+
+  ,
+
+  S_ : LFB_62_eQHC<mih_6>
+
+  )
+
+  {
+  }
+
+access control rules
+  mih_6
+  rule bmr_ {
+    / \Q--!$!\E|^+? /.bmr_()
+  }
+  predicate
+  LFB_62_eQHC
+  (
+  )
+  {
+  true
+  }
+  principal
+  is
+  S_
+  with
+  credentials
+  mih_6
+  principal
+  is
+  LFB_62_eQHC
+  with
+  credentials
+  mih_6
\ No newline at end of file

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/n_1790crashed/strategyResult.txt
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/n_1790crashed/strategyResult.txt	Thu Aug  9 09:26:10 2012	(r25268)
@@ -0,0 +1,42 @@
+
+Analyzing: TestFolder/program.app
+WebDSL: rewriting failed, trace:
+	editor_analyze1_0_0
+	editor_analyze1_0_0
+	editor_analyze_0_0
+	editor_analyze_work_0_0
+	in_typechecking_phase_1_0
+	dr_scope_1_1
+	dr_scope_1_1
+	declare_globals_0_0
+	typecheck_declare_0_0
+	log_time_1_1
+	declare_all_0_0
+	dr_scope_1_1
+	alltd_1_0
+	declare_0_0
+	declare_recommend_0_0
+	normalize_recommend_0_0
+	fetch_elem_1_0
+[ WebDSL | critical ] Internal error: with clause failed unexpectedly in rule 'normalize-recommend'
+           RecommendConfig("S_",[RecommendArgument("algorithm","0465"),RecommendArgument("algorithm",TimeInterval([])),RecommendArgument("neighborhoodsize",TimeInterval([])),RecommendArgument("user","LFB_62_eQHC")])Analyzing: TestFolder/program.app
+WebDSL: rewriting failed, trace:
+	editor_analyze1_0_0
+	editor_analyze1_0_0
+	editor_analyze_0_0
+	editor_analyze_work_0_0
+	in_typechecking_phase_1_0
+	dr_scope_1_1
+	dr_scope_1_1
+	declare_globals_0_0
+	typecheck_declare_0_0
+	log_time_1_1
+	declare_all_0_0
+	dr_scope_1_1
+	alltd_1_0
+	declare_0_0
+	declare_recommend_0_0
+	normalize_recommend_0_0
+	fetch_elem_1_0
+[ WebDSL | critical ] Internal error: with clause failed unexpectedly in rule 'normalize-recommend'
+           RecommendConfig("S_",[RecommendArgument("algorithm","0465"),RecommendArgument("algorithm",TimeInterval([])),RecommendArgument("neighborhoodsize",TimeInterval([])),RecommendArgument("user","LFB_62_eQHC")])
\ No newline at end of file

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/p_2535/amb0.app
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/p_2535/amb0.app	Thu Aug  9 09:26:10 2012	(r25268)
@@ -0,0 +1 @@
+/ \Qv&,,F,,q!\E /.w8() == [] == []
\ No newline at end of file

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/p_2535/amb0.aterm
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/p_2535/amb0.aterm	Thu Aug  9 09:26:10 2012	(r25268)
@@ -0,0 +1,22 @@
+amb(
+  [ Eq(
+      Eq(
+        Call(
+          RegexPattern(SingleBranch(Pieces([SingleAtom(QuotedAtom("v&,,F,,q!"))])))
+        , "w8"
+        , []
+        )
+      , ListCreation([])
+      )
+    , ListCreation([])
+    )
+  , Eq(
+      Call(
+        RegexPattern(SingleBranch(Pieces([SingleAtom(QuotedAtom("v&,,F,,q!"))])))
+      , "w8"
+      , []
+      )
+    , Eq(ListCreation([]), ListCreation([]))
+    )
+  ]
+)
\ No newline at end of file

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/p_2535crashed/AST.aterm
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/p_2535crashed/AST.aterm	Thu Aug  9 09:26:10 2012	(r25268)
@@ -0,0 +1,224 @@
+Module(
+  "_Ty__2.E/_g-"
+, [ AccessControlDefinition(
+      None()
+    , [ AccessControlRule(
+          "w6I38E__3F8"
+        , "*"
+        , MatchArgs([], Some("*"))
+        , And(SetCreation([]), RenderTemplateFunctionCall(TemplateCallProps("B76_103qJ_X", [])))
+        , []
+        )
+      , AccessControlRule(
+          "l1U"
+        , "K"
+        , MatchArgs([], None())
+        , SetCreation([])
+        , []
+        )
+      , Predicate(
+          "w6I38E__3F8"
+        , [ Arg("TN5", SimpleSort("w6I38E__3F8"))
+          , Arg("TN5", GenericSort("m_7R_4", [SimpleSort("l1U")]))
+          , Arg("w6I38E__3F8", FunctionSort([], SimpleSort("m_7R_4")))
+          ]
+        , SmallerThan(
+            Call(
+              RegexPattern(SingleBranch(Pieces([QuantifiedAtom(AtomLiteral("/"), PossessiveOneOrMore())])))
+            , "w8"
+            , []
+            )
+          , FieldAccess(RenderTemplateFunctionCall(TemplateCallNoBody("N", [])), "m_7R_4")
+          )
+        )
+      , AccessControlPrincipal("m_7R_4", ["w6I38E__3F8"])
+      , AccessControlRule(
+          "TN5"
+        , "*"
+        , MatchArgs([], Some("*"))
+        , InColl(
+            RenderEmailFunctionCall(EmailCall("TN5", []))
+          , Mod(
+              ForExpNoFilter(
+                Not(Int("-8"))
+              , "m_7R_4"
+              , FunctionSort([], SimpleSort("Void"))
+              , Eq(
+                  Eq(
+                    Call(
+                      RegexPattern(SingleBranch(Pieces([SingleAtom(QuotedAtom("v&,,F,,q!"))])))
+                    , "w8"
+                    , []
+                    )
+                  , ListCreation([])
+                  )
+                , ListCreation([])
+                )
+              )
+            , EmailFunctionCall(EmailCall("w6I38E__3F8", []))
+            )
+          )
+        , []
+        )
+      , AccessControlPrincipal("m_7R_4", ["w6I38E__3F8"])
+      , AccessControlPrincipal(
+          "w6I38E__3F8"
+        , ["w8", "l1U", "w8", "w8", "w6I38E__3F8", "TN5", "m_7R_4", "m_7R_4"]
+        )
+      , AccessControlPrincipal("m_7R_4", ["w6I38E__3F8"])
+      , AccessControlRule(
+          "m_7R_4"
+        , "*"
+        , MatchArgs([], None())
+        , RenderEmailFunctionCall(EmailCall("l1U", []))
+        , []
+        )
+      , AccessControlPrincipal("w8", ["w8"])
+      ]
+    )
+  , AccessControlDefinition(
+      Some("w6I38E__3F8")
+    , [ AccessControlRule(
+          "l1U"
+        , "k"
+        , MatchArgs([], Some("*"))
+        , Call(
+            RegexPattern(SingleBranch(Pieces([SingleAtom(AtomLiteral("/"))])))
+          , "TN5"
+          , []
+          )
+        , []
+        )
+      , Predicate(
+          "l1U"
+        , [ Arg("TN5", RefSort(SimpleSort("w6I38E__3F8")))
+          , Arg("w8", FunctionSort([], SimpleSort("Void")))
+          , Arg("TN5", RefSort(GenericSort("m_7R_4", [SimpleSort("TN5")])))
+          , Arg("TN5", SimpleSort("w6I38E__3F8"))
+          , Arg("m_7R_4", SimpleSort("w6I38E__3F8"))
+          , Arg("w6I38E__3F8", RefSort(RefSort(SimpleSort("m_7R_4"))))
+          , Arg("TN5", FunctionSort([], SimpleSort("w6I38E__3F8")))
+          , Arg("w8", SimpleSort("TN5"))
+          ]
+        , SetCreation([])
+        )
+      , Predicate("w8", [], EmailFunctionCall(EmailCall("w8", [])))
+      , SpecialAccessControlRule("w8", ValidateTemplateFunctionCall(TemplateCallNoAssigns("N", [], TemplateWith([]))))
+      , AccessControlPrincipal(
+          "m_7R_4"
+        , ["TN5", "m_7R_4", "TN5", "w6I38E__3F8", "TN5", "TN5", "TN5", "l1U"]
+        )
+      ]
+    )
+  , Section(
+      " p o  p*p % ."
+    , [ RecommendConfigStaticOrder(
+          "TN5"
+        , RecommendUser("w8")
+        , RecommendItem("w6I38E__3F8")
+        , RecommendValue("w6I38E__3F8")
+        , RecommendAlgorithm("m_7R_4")
+        , RecommendNeighborAlg("w6I38E__3F8")
+        , RecommendNeighborSize("l1U")
+        , RecommendType("w8")
+        , RecommendSchedule("l1U")
+        )
+      , VarDeclInitInferred(
+          "m_7R_4"
+        , ObjectCreation(
+            RefSort(RefSort(GenericSort("TN5", [SimpleSort("TN5")])))
+          , []
+          )
+        )
+      , Test("", Block([]))
+      , Entity("l1U", "l1U", [])
+      , AccessControlPrincipal("w6I38E__3F8", ["m_7R_4"])
+      , ServiceFunction("w8", [], Block([]))
+      , RecommendConfig("w6I38E__3F8", [])
+      , VarDecl("w6I38E__3F8", SimpleSort("m_7R_4"))
+      ]
+    )
+  , AccessControlDefinition(
+      None()
+    , [ AccessControlPrincipal("w6I38E__3F8", ["l1U"])
+      , Predicate(
+          "w6I38E__3F8"
+        , []
+        , Assignment(
+            Not(
+              AndForExp(
+                ForExpNoFilter(
+                  Call(ThisCall("w8", []), "w8", [])
+                , "w8"
+                , GenericSort("m_7R_4", [SimpleSort("w6I38E__3F8")])
+                , Null()
+                )
+              )
+            )
+          , Call(Null(), "m_7R_4", [])
+          )
+        )
+      , AccessControlPrincipal(
+          "TN5"
+        , ["w8", "l1U", "TN5", "w8", "w6I38E__3F8", "w6I38E__3F8", "TN5", "l1U", "TN5"]
+        )
+      , Predicate("w8", [], FieldAccess(Null(), "TN5"))
+      ]
+    )
+  , AccessControlDefinition(
+      None()
+    , [ AccessControlPointcut("l1U", [], [])
+      , Predicate(
+          "l1U"
+        , []
+        , Or(
+            FieldAccess(Var("externalscope"), "TN5")
+          , FunctionRefCallPartial(FunctionRef("m_7R_4", [], SimpleSort("TN5")), [])
+          )
+        )
+      , AccessControlRule(
+          "l1U"
+        , "K"
+        , MatchArgs([], None())
+        , FieldAccess(Var("externalscope"), "m_7R_4")
+        , []
+        )
+      , Predicate(
+          "l1U"
+        , []
+        , SmallerThanOrEqual(
+            SmallerThan(
+              ThisCall("TN5", [])
+            , InColl(
+                SendEmailFunctionCall(EmailCall("TN5", []))
+              , Not(
+                  Call(
+                    RegexPattern(SingleBranch(Pieces([SingleAtom(QuotedAtom("""))])))
+                  , "TN5"
+                  , []
+                  )
+                )
+              )
+            )
+          , TypedListCreation(FunctionSort([], SimpleSort("w6I38E__3F8")), [])
+          )
+        )
+      , SpecialAccessControlRule(
+          "w6I38E__3F8"
+        , Add(EmailFunctionCall(EmailCall("TN5", [])), RenderTemplateFunctionCall(ValidationErrors("TN5")))
+        )
+      , AccessControlPointcut("l1U", [], [])
+      , AccessControlPrincipal("w6I38E__3F8", ["TN5"])
+      ]
+    )
+  , ACPolicy(
+      PolicyOr(
+        PolicyOr(
+          PolicyAnd(PolicyAnd(Name("m_7R_4"), Name("l1U")), Name("m_7R_4"))
+        , PolicyAnd(Name("w6I38E__3F8"), Name("TN5"))
+        )
+      , PolicyAnd(Name("m_7R_4"), Name("l1U"))
+      )
+    )
+  ]
+)
\ No newline at end of file

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/p_2535crashed/program.app
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/p_2535crashed/program.app	Thu Aug  9 09:26:10 2012	(r25268)
@@ -0,0 +1,319 @@
+module _Ty__2.E/_g-
+access control rules
+  rule w6I38E__3F8 * ( * ) {
+    {} && rendertemplate ( B76_103qJ_X[] )
+  }
+  rule l1U K (  ) {
+    {}
+  }
+  predicate
+  w6I38E__3F8
+  (
+  TN5 : w6I38E__3F8
+  ,
+  TN5 : m_7R_4<l1U>
+  ,
+  w6I38E__3F8 : function ( ) : m_7R_4
+  )
+  {
+  / /++ /.w8()
+  <
+  rendertemplate(N()).m_7R_4
+  }
+  principal
+  is
+  m_7R_4
+  with
+  credentials
+  w6I38E__3F8
+  rule TN5 * ( * ) {
+    renderemail ( TN5 ( ) ) in [ ! -8 for ( m_7R_4 : function ( ) : Void in / \Qv&,,F,,q!\E /.w8() == [] == [
+                                                                                                            ] ) ] % email ( w6I38E__3F8 ( ) )
+  }
+  principal
+  is
+  m_7R_4
+  with
+  credentials
+  w6I38E__3F8
+  principal
+  is
+  w6I38E__3F8
+  with
+  credentials
+  w8
+  ,
+  l1U
+  ,
+  w8
+  ,
+  w8
+  ,
+  w6I38E__3F8
+  ,
+  TN5
+  ,
+  m_7R_4
+  ,
+  m_7R_4
+  principal
+  is
+  m_7R_4
+  with
+  credentials
+  w6I38E__3F8
+  rule m_7R_4 * (  ) {
+    renderemail ( l1U ( ) )
+  }
+  principal
+  is
+  w8
+  with
+  credentials
+  w8
+access control rules
+  w6I38E__3F8
+  rule l1U k ( * ) {
+    / / /.TN5()
+  }
+  predicate
+  l1U
+  (
+  TN5 : Ref<w6I38E__3F8>
+  ,
+  w8 : function ( ) : Void
+  ,
+  TN5 : Ref<m_7R_4<TN5>>
+  ,
+  TN5 : w6I38E__3F8
+  ,
+  m_7R_4 : w6I38E__3F8
+  ,
+  w6I38E__3F8 : Ref<Ref<m_7R_4>>
+  ,
+  TN5 : function ( ) : w6I38E__3F8
+  ,
+  w8 : TN5
+  )
+  {
+  {}
+  }
+  predicate
+  w8
+  (
+  )
+  {
+  email
+  (
+  w8
+  (
+  )
+  )
+  }
+  rule w8 {
+    validatetemplate ( N()with { } )
+  }
+  principal
+  is
+  m_7R_4
+  with
+  credentials
+  TN5
+  ,
+  m_7R_4
+  ,
+  TN5
+  ,
+  w6I38E__3F8
+  ,
+  TN5
+  ,
+  TN5
+  ,
+  TN5
+  ,
+  l1U
+section p o  p*p % .
+
+  recommenderStaticOrder
+
+  TN5
+
+  {
+
+  w8
+
+  w6I38E__3F8
+
+  w6I38E__3F8
+
+  m_7R_4
+
+  w6I38E__3F8
+
+  l1U
+
+  w8
+
+  l1U
+
+  }
+
+  var m_7R_4 := Ref<Ref<TN5<TN5>>>{}
+
+  test
+
+  
+
+  {
+  }
+
+  entity l1U : l1U {
+  }
+
+  principal
+
+  is
+
+  w6I38E__3F8
+
+  with
+
+  credentials
+
+  m_7R_4
+
+  service
+
+  w8
+
+  (
+
+  )
+
+  {
+  }
+
+  recommend
+
+  w6I38E__3F8
+
+  {
+
+  }
+
+  var w6I38E__3F8 : m_7R_4 ;
+access control rules
+  principal
+  is
+  w6I38E__3F8
+  with
+  credentials
+  l1U
+  predicate
+  w6I38E__3F8
+  (
+  )
+  {
+  ! And [ w8().w8() for ( w8 : m_7R_4<w6I38E__3F8> in null ) ] := null.m_7R_4()
+  }
+  principal
+  is
+  TN5
+  with
+  credentials
+  w8
+  ,
+  l1U
+  ,
+  TN5
+  ,
+  w8
+  ,
+  w6I38E__3F8
+  ,
+  w6I38E__3F8
+  ,
+  TN5
+  ,
+  l1U
+  ,
+  TN5
+  predicate
+  w8
+  (
+  )
+  {
+  null.TN5
+  }
+access control rules
+  pointcut
+  l1U
+  (
+  )
+  {
+  }
+  predicate
+  l1U
+  (
+  )
+  {
+  externalscope
+  .
+  TN5
+  ||
+  function.m_7R_4():TN5(*,)
+  }
+  rule l1U K (  ) {
+    externalscope . m_7R_4
+  }
+  predicate
+  l1U
+  (
+  )
+  {
+  TN5()
+  <
+  sendemail
+  (
+  TN5
+  (
+  )
+  )
+  in
+  !
+  / \Q"\E /.TN5()
+  <=
+  List<function ( ) : w6I38E__3F8>()
+  }
+  rule w6I38E__3F8 {
+    email ( TN5 ( ) ) + rendertemplate ( validationErrors ( TN5 ) )
+  }
+  pointcut
+  l1U
+  (
+  )
+  {
+  }
+  principal
+  is
+  w6I38E__3F8
+  with
+  credentials
+  TN5
+access
+control
+policy
+m_7R_4
+AND
+l1U
+AND
+m_7R_4
+OR
+w6I38E__3F8
+AND
+TN5
+OR
+m_7R_4
+AND
+l1U
\ No newline at end of file

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/p_2535crashed/strategyResult.txt
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/p_2535crashed/strategyResult.txt	Thu Aug  9 09:26:10 2012	(r25268)
@@ -0,0 +1,44 @@
+
+Analyzing: TestFolder/program.app
+Explicitly importing main file: program  
+WebDSL: rewriting failed, trace:
+	editor_analyze1_0_0
+	editor_analyze1_0_0
+	editor_analyze_0_0
+	editor_analyze_work_0_0
+	in_typechecking_phase_1_0
+	dr_scope_1_1
+	dr_scope_1_1
+	declare_globals_0_0
+	typecheck_declare_0_0
+	log_time_1_1
+	declare_all_0_0
+	dr_scope_1_1
+	alltd_1_0
+	declare_0_0
+	declare_recommend_0_0
+	normalize_recommend_0_0
+	fetch_elem_1_0
+[ WebDSL | critical ] Internal error: with clause failed unexpectedly in rule 'normalize-recommend'
+           RecommendConfig("w6I38E__3F8",[])Analyzing: TestFolder/program.app
+Explicitly importing main file: program  
+WebDSL: rewriting failed, trace:
+	editor_analyze1_0_0
+	editor_analyze1_0_0
+	editor_analyze_0_0
+	editor_analyze_work_0_0
+	in_typechecking_phase_1_0
+	dr_scope_1_1
+	dr_scope_1_1
+	declare_globals_0_0
+	typecheck_declare_0_0
+	log_time_1_1
+	declare_all_0_0
+	dr_scope_1_1
+	alltd_1_0
+	declare_0_0
+	declare_recommend_0_0
+	normalize_recommend_0_0
+	fetch_elem_1_0
+[ WebDSL | critical ] Internal error: with clause failed unexpectedly in rule 'normalize-recommend'
+           RecommendConfig("w6I38E__3F8",[])
\ No newline at end of file

From andre.s.d.vieira at gmail.com  Thu Aug  9 13:55:25 2012
From: andre.s.d.vieira at gmail.com (Andre Vieira)
Date: Thu, 09 Aug 2012 11:55:25 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25269 - in
	spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3:
	x_1623 x_1623crashed
Message-ID: <20120809115525.30C4D108C022@mx3.tudelft.nl>

Author: AndreVieira
Date: Thu Aug  9 11:55:24 2012
New Revision: 25269
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25269&sc=1

Log:


Added:
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/x_1623/
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/x_1623/amb0.app
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/x_1623/amb0.aterm
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/x_1623crashed/
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/x_1623crashed/AST.aterm
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/x_1623crashed/program.app
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/x_1623crashed/strategyResult.txt

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/x_1623/amb0.app
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/x_1623/amb0.app	Thu Aug  9 11:55:24 2012	(r25269)
@@ -0,0 +1 @@
+FOnamespace by CE_49_v3e__namespace by FOnamespace by E_2fY_V_IE_2fY_V_I as sqiM4 with depth -73 ^ -5fCE_49_v3e__ (  ) as sqiM4 ^ -84E53f for subclass sqiM4 as d_H0721_6 for subclass E_2fY_V_I with depth -55 (  ) for subclass CE_49_v3e__ with depth -55
\ No newline at end of file

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/x_1623/amb0.aterm
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/x_1623/amb0.aterm	Thu Aug  9 11:55:24 2012	(r25269)
@@ -0,0 +1,58 @@
+amb(
+  [ [ SearchFieldMapping(None(), "FO", [])
+    , SearchNamespaceMapping("CE_49_v3e__")
+    , SearchNamespaceMapping("FO")
+    , SearchNamespaceMapping("E_2fY_V_I")
+    , SearchFieldMapping(
+        None()
+      , "E_2fY_V_I"
+      , [FieldName("sqiM4"), EmbeddedDepth("-73"), Boost("-5f")]
+      )
+    , SearchFieldMapping(
+        None()
+      , "CE_49_v3e__"
+      , [SearchMappingAnno([]), FieldName("sqiM4"), Boost("-84E53")]
+      )
+    , SearchFieldMapping(
+        None()
+      , "f"
+      , [ TargetEntity("sqiM4")
+        , FieldName("d_H0721_6")
+        , TargetEntity("E_2fY_V_I")
+        , EmbeddedDepth("-55")
+        , SearchMappingAnno([])
+        , TargetEntity("CE_49_v3e__")
+        , EmbeddedDepth("-55")
+        ]
+      )
+    ]
+  ,
+   	
+   	
+   	 [ SearchFieldMapping(None(), "FO", [])
+    , SearchNamespaceMapping("CE_49_v3e__")
+    , SearchNamespaceMapping("FO")
+    , SearchNamespaceMapping("E_2fY_V_I")
+    , SearchFieldMapping(
+        None()
+      , "E_2fY_V_I"
+      , [FieldName("sqiM4"), EmbeddedDepth("-73"), Boost("-5f")]
+      )
+    , SearchFieldMapping(
+        None()
+      , "CE_49_v3e__"
+      , [ SearchMappingAnno([])
+        , FieldName("sqiM4")
+        , Boost("-84E53f")
+        , TargetEntity("sqiM4")
+        , FieldName("d_H0721_6")
+        , TargetEntity("E_2fY_V_I")
+        , EmbeddedDepth("-55")
+        , SearchMappingAnno([])
+        , TargetEntity("CE_49_v3e__")
+        , EmbeddedDepth("-55")
+        ]
+      )
+    ]
+  ]
+)
\ No newline at end of file

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/x_1623crashed/AST.aterm
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/x_1623crashed/AST.aterm	Thu Aug  9 11:55:24 2012	(r25269)
@@ -0,0 +1,162 @@
+Application(
+  "E_2fY_V_I"
+, [ Section("   .", [])
+  , AccessControlDefinition(
+      Some("sqiM4")
+    , [ AccessControlPrincipal("d_H0721_6", ["CE_49_v3e__", "FO", "E_2fY_V_I", "FO", "CE_49_v3e__"])
+      , AccessControlPointcut(
+          "d_H0721_6"
+        , [ Arg("d_H0721_6", GenericSort("E_2fY_V_I", [SimpleSort("FO")]))
+          , Arg("E_2fY_V_I", FunctionSort([], SimpleSort("FO")))
+          , Arg("FO", SimpleSort("CE_49_v3e__"))
+          , Arg("d_H0721_6", RefSort(GenericSort("d_H0721_6", [SimpleSort("CE_49_v3e__")])))
+          , Arg("FO", GenericSort("d_H0721_6", [SimpleSort("d_H0721_6")]))
+          , Arg("FO", SimpleSort("FO"))
+          ]
+        , [ AccessControlPointcutElement("E_2fY_V_I", "*", [], Some("*"))
+          , AccessControlPointcutElement("d_H0721_6", "k__bM", [], None())
+          , AccessControlPointcutElement("E_2fY_V_I", "*", [], Some("*"))
+          , AccessControlPointcutElement("CE_49_v3e__", "*", [], Some("*"))
+          , AccessControlPointcutElement("CE_49_v3e__", "*", [], None())
+          ]
+        )
+      ]
+    )
+  , ACPolicy(Name("sqiM4"))
+  , Section(
+      "  qo  N ~L ."
+    , [ EntityNoSuper(
+          "FO"
+        , [ CachedEntity()
+          , Function("d_H0721_6", [], SimpleSort("Void"), Block([]))
+          , PredicateInEntity("FO", [], SetCreation([]))
+          , SearchMappingEmbedded([])
+          , PredicateInEntity("sqiM4", [], ValidateTemplateFunctionCall(TemplateCallNoBody("q_84_CI_D_q", [])))
+          , ExtendFunction(
+              ExtendFunction(Function("CE_49_v3e__", [], SimpleSort("Void"), Block([])))
+            )
+          , PredicateInEntity("FO", [], FunctionRef("d_H0721_6", [], SimpleSort("Void")))
+          , Property("FO", Ref(), FunctionSort([], SimpleSort("Void")), [])
+          ]
+        )
+      , RecommendConfigStaticOrder(
+          "CE_49_v3e__"
+        , RecommendUser("CE_49_v3e__")
+        , RecommendItem("E_2fY_V_I")
+        , RecommendValue("E_2fY_V_I")
+        , RecommendAlgorithm("sqiM4")
+        , RecommendNeighborAlg("E_2fY_V_I")
+        , RecommendNeighborSize("FO")
+        , RecommendType("d_H0721_6")
+        , RecommendSchedule("CE_49_v3e__")
+        )
+      , RequestScope(VarDecl("sqiM4", FunctionSort([], SimpleSort("Void"))))
+      , Enum(
+          "sqiM4"
+        , [ EnumValue("sqiM4", ""$"")
+          , EnumValue("E_2fY_V_I", ""z at 3uS{xP_ "")
+          , EnumValue("d_H0721_6", ""z at 3uS{xP_ "")
+          , EnumValue("sqiM4", ""$"")
+          , EnumValue("E_2fY_V_I", ""+{o  639 '"")
+          , EnumValue("d_H0721_6", ""z at 3uS{xP_ "")
+          , EnumValue("CE_49_v3e__", ""+{o  639 '"")
+          , EnumValue("FO", ""\"\""")
+          , EnumValue("CE_49_v3e__", ""\""")
+          ]
+        )
+      , Function("sqiM4", [], SimpleSort("CE_49_v3e__"), Block([]))
+      , Test("CE_49_v3e__", Block([]))
+      , DeriveCrud("CE_49_v3e__")
+      , TypeDef("CE_49_v3e__", [])
+      , RequestScope(VarDeclInitInferred("sqiM4", EmailFunctionCall(EmailCall("d_H0721_6", []))))
+      , Predicate(
+          "d_H0721_6"
+        , [ Arg("sqiM4", RefSort(FunctionSort([], SimpleSort("Void"))))
+          , Arg("FO", RefSort(GenericSort("CE_49_v3e__", [SimpleSort("CE_49_v3e__")])))
+          , Arg("FO", RefSort(GenericSort("CE_49_v3e__", [SimpleSort("CE_49_v3e__")])))
+          ]
+        , Not(
+            Call(
+              RegexPattern(SingleBranch(Pieces([SingleAtom(QuotedAtom("p%!"))])))
+            , "E_2fY_V_I"
+            , []
+            )
+          )
+        )
+      ]
+    )
+  , AccessControlDefinition(
+      None()
+    , [ AccessControlPrincipal("E_2fY_V_I", ["d_H0721_6"])
+      , AccessControlPrincipal("sqiM4", ["sqiM4"])
+      , AccessControlRule(
+          "sqiM4"
+        , "*"
+        , MatchArgs([], Some("*"))
+        , True()
+        , []
+        )
+      , SpecialAccessControlRule("sqiM4", ThisCall("E_2fY_V_I", []))
+      , AccessControlPointcut("CE_49_v3e__", [], [])
+      , AccessControlPrincipal("FO", ["E_2fY_V_I"])
+      , Predicate("CE_49_v3e__", [], Call(ListCreation([]), "CE_49_v3e__", []))
+      , AccessControlPointcut("d_H0721_6", [], [])
+      , Predicate(
+          "d_H0721_6"
+        , []
+        , Div(ListCreation([]), FunctionRef("CE_49_v3e__", [], SimpleSort("FO")))
+        )
+      ]
+    )
+  , Section(
+      "  qo  N ~L ."
+    , [ FullTextAnalyzer(
+          Some("default_builtin_analyzer")
+        , "sqiM4"
+        , FullTextAnalyzerBodyDef([], Tokenizer("E_2fY_V_I", []), [])
+        )
+      , SearchMapping(
+          "E_2fY_V_I"
+        , [ [ SearchFieldMapping(None(), "FO", [])
+            , SearchNamespaceMapping("CE_49_v3e__")
+            , SearchNamespaceMapping("FO")
+            , SearchNamespaceMapping("E_2fY_V_I")
+            , SearchFieldMapping(
+                None()
+              , "E_2fY_V_I"
+              , [FieldName("sqiM4"), EmbeddedDepth("-73"), Boost("-5f")]
+              )
+            , SearchFieldMapping(
+                None()
+              , "CE_49_v3e__"
+              , [ SearchMappingAnno([])
+                , FieldName("sqiM4")
+                , Boost("-84E53f")
+                , TargetEntity("sqiM4")
+                , FieldName("d_H0721_6")
+                , TargetEntity("E_2fY_V_I")
+                , EmbeddedDepth("-55")
+                , SearchMappingAnno([])
+                , TargetEntity("CE_49_v3e__")
+                , EmbeddedDepth("-55")
+                ]
+              )
+            ]
+          , SearchFieldMapping(Some("+"), "d_H0721_6", [])
+          ]
+        )
+      ]
+    )
+  , AccessControlDefinition(
+      Some("CE_49_v3e__")
+    , [ AccessControlPrincipal("sqiM4", ["CE_49_v3e__", "FO", "d_H0721_6", "CE_49_v3e__", "d_H0721_6"])
+      , AccessControlPointcut("d_H0721_6", [], [])
+      , AccessControlPrincipal("d_H0721_6", ["E_2fY_V_I"])
+      , AccessControlPrincipal(
+          "d_H0721_6"
+        , ["d_H0721_6", "sqiM4", "FO", "CE_49_v3e__", "CE_49_v3e__", "E_2fY_V_I", "E_2fY_V_I", "d_H0721_6"]
+        )
+      ]
+    )
+  ]
+)
\ No newline at end of file

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/x_1623crashed/program.app
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/x_1623crashed/program.app	Thu Aug  9 11:55:24 2012	(r25269)
@@ -0,0 +1,322 @@
+application E_2fY_V_I
+
+section   .
+
+access control rules
+  sqiM4
+  principal
+  is
+  d_H0721_6
+  with
+  credentials
+  CE_49_v3e__
+  ,
+  FO
+  ,
+  E_2fY_V_I
+  ,
+  FO
+  ,
+  CE_49_v3e__
+  pointcut
+  d_H0721_6
+  (
+  d_H0721_6 : E_2fY_V_I<FO>
+  ,
+  E_2fY_V_I : function ( ) : FO
+  ,
+  FO : CE_49_v3e__
+  ,
+  d_H0721_6 : Ref<d_H0721_6<CE_49_v3e__>>
+  ,
+  FO : d_H0721_6<d_H0721_6>
+  ,
+  FO : FO
+  )
+  {
+  E_2fY_V_I
+  *
+  (
+  *
+  )
+  ,
+  d_H0721_6
+  k__bM
+  (
+  )
+  ,
+  E_2fY_V_I
+  *
+  (
+  *
+  )
+  ,
+  CE_49_v3e__
+  *
+  (
+  *
+  )
+  ,
+  CE_49_v3e__
+  *
+  (
+  )
+  }
+
+access
+
+control
+
+policy
+
+sqiM4
+
+section  qo  N ~L .
+
+  entity FO {
+    cache
+    function d_H0721_6 ( ) : Void
+    {
+    }
+    predicate
+    FO
+    (
+    )
+    {
+    {}
+    }
+    search mapping {
+    }
+    predicate
+    sqiM4
+    (
+    )
+    {
+    validatetemplate
+    (
+    q_84_CI_D_q()
+    )
+    }
+    extend
+    extend
+    function CE_49_v3e__ ( ) : Void
+    {
+    }
+    predicate
+    FO
+    (
+    )
+    {
+    function.
+    d_H0721_6
+    (
+    )
+    :
+    Void
+    }
+    FO -> function ( ) : Void ( )
+  }
+
+  recommenderStaticOrder
+
+  CE_49_v3e__
+
+  {
+
+  CE_49_v3e__
+
+  E_2fY_V_I
+
+  E_2fY_V_I
+
+  sqiM4
+
+  E_2fY_V_I
+
+  FO
+
+  d_H0721_6
+
+  CE_49_v3e__
+
+  }
+
+  request
+
+  var sqiM4 : function ( ) : Void
+
+  enum sqiM4 { sqiM4("$"), E_2fY_V_I("z at 3uS{xP_ "), d_H0721_6("z at 3uS{xP_ "), sqiM4("$"), E_2fY_V_I("+{o  639 '"), d_H0721_6("z at 3uS{xP_ "), CE_49_v3e__("+{o  639 '"), FO("\"\""), CE_49_v3e__ ( "\"" ) }
+
+  function sqiM4 ( ) : CE_49_v3e__
+  {
+  }
+
+  test
+
+  CE_49_v3e__
+
+  {
+  }
+
+  derive
+
+  CRUD
+
+  CE_49_v3e__
+
+  type CE_49_v3e__ { }
+
+  request
+
+  var sqiM4 := email ( d_H0721_6 ( ) )
+
+  predicate
+
+  d_H0721_6
+
+  (
+
+  sqiM4 : Ref<function():Void>
+
+  ,
+
+  FO : Ref<CE_49_v3e__<CE_49_v3e__>>
+
+  ,
+
+  FO : Ref<CE_49_v3e__<CE_49_v3e__>>
+
+  )
+
+  {
+
+  !
+
+  / \Qp%!\E /.E_2fY_V_I()
+
+  }
+
+access control rules
+  principal
+  is
+  E_2fY_V_I
+  with
+  credentials
+  d_H0721_6
+  principal
+  is
+  sqiM4
+  with
+  credentials
+  sqiM4
+  rule sqiM4 * ( * ) {
+    true
+  }
+  rule sqiM4 {
+    E_2fY_V_I()
+  }
+  pointcut
+  CE_49_v3e__
+  (
+  )
+  {
+  }
+  principal
+  is
+  FO
+  with
+  credentials
+  E_2fY_V_I
+  predicate
+  CE_49_v3e__
+  (
+  )
+  {
+  [].CE_49_v3e__()
+  }
+  pointcut
+  d_H0721_6
+  (
+  )
+  {
+  }
+  predicate
+  d_H0721_6
+  (
+  )
+  {
+  [
+  ]
+  /
+  function.
+  CE_49_v3e__
+  (
+  )
+  :
+  FO
+  }
+
+section  qo  N ~L .
+
+  default_builtin_analyzer analyzer sqiM4 {
+    tokenizer = E_2fY_V_I ( )
+  }
+
+  search mapping E_2fY_V_I {
+     FO
+    namespace by CE_49_v3e__
+    namespace by FO
+    namespace by E_2fY_V_I
+     E_2fY_V_I as sqiM4 with depth -73 ^ -5f
+     CE_49_v3e__ (  ) as sqiM4 ^ -84E53f for subclass sqiM4 as d_H0721_6 for subclass E_2fY_V_I with depth -55 (  ) for subclass CE_49_v3e__ with depth -55
+    + d_H0721_6
+  }
+
+access control rules
+  CE_49_v3e__
+  principal
+  is
+  sqiM4
+  with
+  credentials
+  CE_49_v3e__
+  ,
+  FO
+  ,
+  d_H0721_6
+  ,
+  CE_49_v3e__
+  ,
+  d_H0721_6
+  pointcut
+  d_H0721_6
+  (
+  )
+  {
+  }
+  principal
+  is
+  d_H0721_6
+  with
+  credentials
+  E_2fY_V_I
+  principal
+  is
+  d_H0721_6
+  with
+  credentials
+  d_H0721_6
+  ,
+  sqiM4
+  ,
+  FO
+  ,
+  CE_49_v3e__
+  ,
+  CE_49_v3e__
+  ,
+  E_2fY_V_I
+  ,
+  E_2fY_V_I
+  ,
+  d_H0721_6
\ No newline at end of file

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/x_1623crashed/strategyResult.txt
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/x_1623crashed/strategyResult.txt	Thu Aug  9 11:55:24 2012	(r25269)
@@ -0,0 +1,42 @@
+
+Analyzing: TestFolder/program.app
+WebDSL: rewriting failed, trace:
+	editor_analyze1_0_0
+	editor_analyze1_0_0
+	editor_analyze_0_0
+	editor_analyze_work_0_0
+	in_typechecking_phase_1_0
+	dr_scope_1_1
+	dr_scope_1_1
+	declare_globals_0_0
+	typecheck_declare_0_0
+	log_time_1_1
+	declare_all_0_0
+	dr_scope_1_1
+	alltd_1_0
+	declare_0_0
+	declare_search_0_0
+	map_1_0
+	declare_search_mapping_0_1
+[ WebDSL | critical ] Internal error: with clause failed unexpectedly in rule 'declare-search'
+           SearchMapping("E_2fY_V_I",[[SearchFieldMapping(None,"FO",[]),SearchNamespaceMapping("CE_49_v3e__"),SearchNamespaceMapping("FO"),SearchNamespaceMapping("E_2fY_V_I"),SearchFieldMapping(None,"E_2fY_V_I",[FieldName("sqiM4"),EmbeddedDepth("-73"),Boost("-5f")]),SearchFieldMapping(None,"CE_49_v3e__",[SearchMappingAnno([]),FieldName("sqiM4"),Boost("-84E53f"),TargetEntity("sqiM4"),FieldName("d_H0721_6"),TargetEntity("E_2fY_V_I"),EmbeddedDepth("-55"),SearchMappingAnno([]),TargetEntity("CE_49_v3e__"),EmbeddedDepth("-55")])],SearchFieldMapping(Some("+"),"d_H0721_6",[])])Analyzing: TestFolder/program.app
+WebDSL: rewriting failed, trace:
+	editor_analyze1_0_0
+	editor_analyze1_0_0
+	editor_analyze_0_0
+	editor_analyze_work_0_0
+	in_typechecking_phase_1_0
+	dr_scope_1_1
+	dr_scope_1_1
+	declare_globals_0_0
+	typecheck_declare_0_0
+	log_time_1_1
+	declare_all_0_0
+	dr_scope_1_1
+	alltd_1_0
+	declare_0_0
+	declare_search_0_0
+	map_1_0
+	declare_search_mapping_0_1
+[ WebDSL | critical ] Internal error: with clause failed unexpectedly in rule 'declare-search'
+           SearchMapping("E_2fY_V_I",[[SearchFieldMapping(None,"FO",[]),SearchNamespaceMapping("CE_49_v3e__"),SearchNamespaceMapping("FO"),SearchNamespaceMapping("E_2fY_V_I"),SearchFieldMapping(None,"E_2fY_V_I",[FieldName("sqiM4"),EmbeddedDepth("-73"),Boost("-5f")]),SearchFieldMapping(None,"CE_49_v3e__",[SearchMappingAnno([]),FieldName("sqiM4"),Boost("-84E53f"),TargetEntity("sqiM4"),FieldName("d_H0721_6"),TargetEntity("E_2fY_V_I"),EmbeddedDepth("-55"),SearchMappingAnno([]),TargetEntity("CE_49_v3e__"),EmbeddedDepth("-55")])],SearchFieldMapping(Some("+"),"d_H0721_6",[])])
\ No newline at end of file

From andre.s.d.vieira at gmail.com  Thu Aug  9 14:22:07 2012
From: andre.s.d.vieira at gmail.com (Andre Vieira)
Date: Thu, 09 Aug 2012 12:22:07 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25270 -
	spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/x_1623
Message-ID: <20120809122207.6DFB3CC19E@mx4.tudelft.nl>

Author: AndreVieira
Date: Thu Aug  9 12:22:07 2012
New Revision: 25270
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25270&sc=1

Log:


Added:
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/x_1623/solution.txt

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/x_1623/solution.txt
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/x_1623/solution.txt	Thu Aug  9 12:22:07 2012	(r25270)
@@ -0,0 +1,3 @@
+Follow restriction for Float introduced 
+
+Float -/- [fFdD]
\ No newline at end of file

From andre.s.d.vieira at gmail.com  Tue Aug 14 15:01:59 2012
From: andre.s.d.vieira at gmail.com (Andre Vieira)
Date: Tue, 14 Aug 2012 13:01:59 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25271 - in
	spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3:
	s_23795 s_23795crashed
Message-ID: <20120814130159.2EA1BCC1AF@mx4.tudelft.nl>

Author: AndreVieira
Date: Tue Aug 14 13:01:58 2012
New Revision: 25271
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25271&sc=1

Log:


Added:
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/s_23795/
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/s_23795/amb0.app
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/s_23795/amb0.aterm
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/s_23795crashed/
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/s_23795crashed/AST.aterm
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/s_23795crashed/program.app
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/s_23795crashed/strategyResult.txt

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/s_23795/amb0.app
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/s_23795/amb0.app	Tue Aug 14 13:01:58 2012	(r25271)
@@ -0,0 +1 @@
+where O__4_Oe_CIP completions similarity O16zRr6F() limit Set<O16zRr6F<O16zRr6F>>() offset true || email ( p_F___m_27_ ( ) ) < renderemail ( XF2B_5_X_ ( ) )
\ No newline at end of file

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/s_23795/amb0.aterm
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/s_23795/amb0.aterm	Tue Aug 14 13:01:58 2012	(r25271)
@@ -0,0 +1,34 @@
+amb(
+  [ FilterNoOrderBy(
+      Suggest("O__4_Oe_CIP", AutoComplete(), [Similarity(ThisCall("O16zRr6F", []))])
+    , Limit(
+        TypedSetCreation(GenericSort("O16zRr6F", [SimpleSort("O16zRr6F")]), [])
+      , Or(
+          True()
+        , SmallerThan(
+            EmailFunctionCall(EmailCall("p_F___m_27_", []))
+          , RenderEmailFunctionCall(EmailCall("XF2B_5_X_", []))
+          )
+        )
+      )
+    )
+  , FilterNoOrderBy(
+      Suggest(
+        "O__4_Oe_CIP"
+      , AutoComplete()
+      , [ Similarity(ThisCall("O16zRr6F", []))
+        , MaxResults(TypedSetCreation(GenericSort("O16zRr6F", [SimpleSort("O16zRr6F")]), []))
+        ]
+      )
+    , LimitNoLimit(
+        Or(
+          True()
+        , SmallerThan(
+            EmailFunctionCall(EmailCall("p_F___m_27_", []))
+          , RenderEmailFunctionCall(EmailCall("XF2B_5_X_", []))
+          )
+        )
+      )
+    )
+  ]
+)
\ No newline at end of file

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/s_23795crashed/AST.aterm
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/s_23795crashed/AST.aterm	Tue Aug 14 13:01:58 2012	(r25271)
@@ -0,0 +1,284 @@
+ModuleDefs(
+  "R-h_c"
+, [ Description([])
+  , RequestScope(
+      VarDecl("F2", RefSort(RefSort(FunctionSort([], SimpleSort("S6fr3OF_6MH")))))
+    )
+  , DeriveCrud("F2")
+  , Enum("S6fr3OF_6MH", [])
+  , Enum(
+      "XF2B_5_X_"
+    , [ EnumValue("p_F___m_27_", ""ps e-"")
+      , EnumValue("O16zRr6F", ""ps e-"")
+      , EnumValue("O16zRr6F", "" N 6"")
+      , EnumValue("F2", "" N 6"")
+      , EnumValue("F2", "" Sz P"")
+      ]
+    )
+  , SearchMapping("F2", [])
+  , InvokeEvery(
+      ForExp(
+        TypedListCreation(RefSort(GenericSort("p_F___m_27_", [SimpleSort("XF2B_5_X_")])), [])
+      , "S6fr3OF_6MH"
+      , GenericSort("p_F___m_27_", [SimpleSort("S6fr3OF_6MH")])
+      , AndForExp(
+          ForExp(
+            GlobalVar("p_F___m_27_")
+          , "XF2B_5_X_"
+          , SimpleSort("O16zRr6F")
+          , FunctionRefCall(FunctionRef("XF2B_5_X_", [], SimpleSort("Void")), [])
+          , FilterNoLimit(
+              EmailFunctionCall(EmailCall("S6fr3OF_6MH", []))
+            , OrderDescending(
+                ForExpNoFilter(
+                  ForExp(
+                    LargerThanOrEqual(
+                      SmallerThan(
+                        Sub(
+                          Cast(
+                            ThisCall("p_F___m_27_", [])
+                          , GenericSort("XF2B_5_X_", [SimpleSort("O16zRr6F")])
+                          )
+                        , Mod(FieldAccess(False(), "S6fr3OF_6MH"), Var("S6fr3OF_6MH"))
+                        )
+                      , Cast(
+                          TypedSetCreation(FunctionSort([], SimpleSort("Void")), [])
+                        , FunctionSort([], SimpleSort("Void"))
+                        )
+                      )
+                    , Null()
+                    )
+                  , "S6fr3OF_6MH"
+                  , SimpleSort("F2")
+                  , Var("S6fr3OF_6MH")
+                  , FilterNoWhere(
+                      OrderDescending(
+                        AndForExp(
+                          ForExpNoFilter(
+                            Add(Var("F2"), SetCreation([]))
+                          , "XF2B_5_X_"
+                          , GenericSort("F2", [SimpleSort("S6fr3OF_6MH")])
+                          , NotEq(SetCreation([]), ListCreation([]))
+                          )
+                        )
+                      )
+                    , Limit(
+                        Int("76")
+                      , ForExp(
+                          Add(
+                            Mul(Var("p_F___m_27_"), False())
+                          , RenderEmailFunctionCall(EmailCall("p_F___m_27_", []))
+                          )
+                        , "F2"
+                        , GenericSort("O16zRr6F", [SimpleSort("F2")])
+                        , Call(
+                            RegexPattern(
+                              TupleBranch(
+                                SingleBranch(
+                                  Pieces(
+                                    [ QuantifiedAtom(
+                                        NegativeLookbehind(SingleBranch(Pieces([QuantifiedAtom(QuotedAtom("""), ReluctantOneOrMore())])))
+                                      , ReluctantOnceOrNot()
+                                      )
+                                    ]
+                                  )
+                                )
+                              , SingleBranch(
+                                  Pieces(
+                                    [ SingleAtom(AtomLiteral("e"))
+                                    , SingleAtom(AtomLiteral("m"))
+                                    , SingleAtom(AtomLiteral("p"))
+                                    , SingleAtom(AtomLiteral("t"))
+                                    , QuantifiedAtom(AtomLiteral("y"), ReluctantOneOrMore())
+                                    ]
+                                  )
+                                )
+                              )
+                            )
+                          , "p_F___m_27_"
+                          , []
+                          )
+                        , FilterNoWhereNoLimit(OrderDescending(Null()))
+                        )
+                      )
+                    )
+                  )
+                , "S6fr3OF_6MH"
+                , FunctionSort([], SimpleSort("p_F___m_27_"))
+                , LargerThanOrEqual(Null(), ThisCall("p_F___m_27_", []))
+                )
+              )
+            )
+          )
+        )
+      , FilterNoOrderBy(
+          Suggest("O__4_Oe_CIP", AutoComplete(), [Similarity(ThisCall("O16zRr6F", []))])
+        , Limit(
+            TypedSetCreation(GenericSort("O16zRr6F", [SimpleSort("O16zRr6F")]), [])
+          , Or(
+              True()
+            , SmallerThan(
+                EmailFunctionCall(EmailCall("p_F___m_27_", []))
+              , RenderEmailFunctionCall(EmailCall("XF2B_5_X_", []))
+              )
+            )
+          )
+        )
+      )
+    , TimeInterval(
+        [ Hours(ThisCall("F2", []))
+        , Seconds(FunctionRef("S6fr3OF_6MH", [], SimpleSort("O16zRr6F")))
+        , Milliseconds(
+            IfExp(
+              FieldAccess(
+                CollectionIndex(
+                  FunctionRefCall(FunctionRef("p_F___m_27_", [], SimpleSort("Void")), [])
+                , Call(
+                    RegexPattern(SingleBranch(Pieces([SingleAtom(SingleCharacter())])))
+                  , "F2"
+                  , []
+                  )
+                )
+              , "F2"
+              )
+            , ListCreation([])
+            , ListCreation([])
+            )
+          )
+        ]
+      )
+    )
+  , DefinePage([], "p_F___m_27_", [], None(), [])
+  , DeriveWebServices("p_F___m_27_", "XF2B_5_X_")
+  , VarDecl("S6fr3OF_6MH", GenericSort("XF2B_5_X_", [SimpleSort("O16zRr6F")]))
+  ]
+, [ ACPolicy(Name("p_F___m_27_"))
+  , Section(
+      " p ppp"
+    , [ InvokeEvery(FunctionRef("XF2B_5_X_", [], SimpleSort("Void")), TimeInterval([]))
+      , Enum("O16zRr6F", [])
+      , FullTextAnalyzer(
+          None()
+        , "XF2B_5_X_"
+        , FullTextAnalyzerBodyDef([], Tokenizer("O16zRr6F", []), [])
+        )
+      , SearchMapping("S6fr3OF_6MH", [])
+      , DefinePage([], "p_F___m_27_", [], TemplateArgs([]), [])
+      , Note([])
+      , TypeDef("S6fr3OF_6MH", [])
+      , RecommendConfig("S6fr3OF_6MH", [])
+      , Enum("F2", [])
+      , InvokeEvery(
+          FunctionRefCall(FunctionRef("p_F___m_27_", [], SimpleSort("Void")), [])
+        , TimeInterval([])
+        )
+      ]
+    )
+  , ACPolicy(
+      PolicyOr(
+        PolicyAnd(
+          PolicyAnd(
+            PolicyAnd(
+              PolicyAnd(PolicyAnd(Name("XF2B_5_X_"), Name("S6fr3OF_6MH")), Name("p_F___m_27_"))
+            , Name("F2")
+            )
+          , Name("O16zRr6F")
+          )
+        , Name("XF2B_5_X_")
+        )
+      , PolicyAnd(Name("O16zRr6F"), Name("F2"))
+      )
+    )
+  , Section(
+      " |o8 o "
+    , [ DefineTemplate([], "S6fr3OF_6MH", [], None(), [])
+      , LocalRedefine([], "F2", [], "F2", None())
+      , Test("F2", Block([]))
+      , ExtendEntity("S6fr3OF_6MH", [])
+      , AccessControlPrincipal("S6fr3OF_6MH", ["XF2B_5_X_"])
+      , DeriveWebServices("XF2B_5_X_", "O16zRr6F")
+      , Imports("-xZz_i.r.-/.--3-/_Uo_n.0_-")
+      ]
+    )
+  , AccessControlDefinition(
+      None()
+    , [ Predicate(
+          "S6fr3OF_6MH"
+        , []
+        , FieldAccess(Call(SetCreation([]), "F2", []), "F2")
+        )
+      , AccessControlPrincipal("XF2B_5_X_", ["O16zRr6F"])
+      , AccessControlPrincipal("XF2B_5_X_", ["S6fr3OF_6MH"])
+      , SpecialAccessControlRule(
+          "XF2B_5_X_"
+        , TypedListCreation(RefSort(GenericSort("F2", [SimpleSort("S6fr3OF_6MH")])), [])
+        )
+      , AccessControlPrincipal("S6fr3OF_6MH", ["S6fr3OF_6MH"])
+      , SpecialAccessControlRule(
+          "O16zRr6F"
+        , Or(
+            Null()
+          , TypedSetCreation(RefSort(FunctionSort([], SimpleSort("Void"))), [])
+          )
+        )
+      , AccessControlPrincipal("S6fr3OF_6MH", ["XF2B_5_X_"])
+      , Predicate("S6fr3OF_6MH", [], RenderEmailFunctionCall(EmailCall("S6fr3OF_6MH", [])))
+      , Predicate("S6fr3OF_6MH", [], ThisCall("p_F___m_27_", []))
+      , Predicate(
+          "XF2B_5_X_"
+        , []
+        , Add(
+            Add(FunctionRef("S6fr3OF_6MH", [], SimpleSort("Void")), Var("XF2B_5_X_"))
+          , TypedListCreation(
+              RefSort(RefSort(GenericSort("O16zRr6F", [SimpleSort("S6fr3OF_6MH")])))
+            , []
+            )
+          )
+        )
+      ]
+    )
+  , ACPolicy(
+      PolicyAnd(
+        PolicyAnd(
+          PolicyAnd(PolicyAnd(Name("p_F___m_27_"), Name("F2")), Name("XF2B_5_X_"))
+        , Name("O16zRr6F")
+        )
+      , Name("F2")
+      )
+    )
+  , Section(
+      " |o8 o "
+    , [ Predicate(
+          "XF2B_5_X_"
+        , [ Arg("F2", SimpleSort("O16zRr6F"))
+          , Arg("F2", SimpleSort("p_F___m_27_"))
+          , Arg("F2", FunctionSort([], SimpleSort("Void")))
+          , Arg("F2", RefSort(SimpleSort("F2")))
+          , Arg("S6fr3OF_6MH", FunctionSort([], SimpleSort("Void")))
+          , Arg("p_F___m_27_", RefSort(GenericSort("O16zRr6F", [SimpleSort("O16zRr6F")])))
+          , Arg("S6fr3OF_6MH", RefSort(SimpleSort("O16zRr6F")))
+          , Arg("F2", GenericSort("p_F___m_27_", [SimpleSort("F2")]))
+          , Arg("F2", GenericSort("S6fr3OF_6MH", [SimpleSort("XF2B_5_X_")]))
+          ]
+        , ValidateTemplateFunctionCall(TemplateCallNoBody("LD8ei_pB_Q", []))
+        )
+      ]
+    )
+  , ACPolicy(
+      PolicyOr(Name("XF2B_5_X_"), PolicyAnd(Name("F2"), Name("XF2B_5_X_")))
+    )
+  , ACPolicy(Name("XF2B_5_X_"))
+  , Section(
+      "   opoJ b f"
+    , [ VarDeclInit(
+          "S6fr3OF_6MH"
+        , RefSort(RefSort(GenericSort("F2", [SimpleSort("XF2B_5_X_")])))
+        , EmailFunctionCall(EmailCall("XF2B_5_X_", []))
+        )
+      , AccessControlPrincipal("p_F___m_27_", ["F2"])
+      , ExtendSessionEntity("F2", [])
+      , Enum("O16zRr6F", [])
+      ]
+    )
+  ]
+)
\ No newline at end of file

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/s_23795crashed/program.app
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/s_23795crashed/program.app	Tue Aug 14 13:01:58 2012	(r25271)
@@ -0,0 +1,377 @@
+module R-h_c
+description {
+}
+request
+var F2 : Ref<Ref<function():S6fr3OF_6MH>>
+derive
+CRUD
+F2
+enum S6fr3OF_6MH { }
+enum XF2B_5_X_ { p_F___m_27_("ps e-"), O16zRr6F("ps e-"), O16zRr6F(" N 6"), F2(" N 6"), F2 ( " Sz P" ) }
+search mapping F2 {
+}
+invoke
+[ List<Ref<p_F___m_27_<XF2B_5_X_>>>() for ( S6fr3OF_6MH : p_F___m_27_<S6fr3OF_6MH> in And [ global.p_F___m_27_ for ( XF2B_5_X_ : O16zRr6F in function.XF2B_5_X_():Void() where email ( S6fr3OF_6MH ( ) ) order by [ [ ( p_F___m_27_() as XF2B_5_X_<O16zRr6F> ) - false.S6fr3OF_6MH % S6fr3OF_6MH < ( Set<function ( ) : Void>() as function ( ) : Void ) >= null for ( S6fr3OF_6MH : F2 in S6fr3OF_6MH order by And [ F2 + {} for ( XF2B_5_X_ : F2<S6fr3OF_6MH> in {} != [
+                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ] ) ] desc limit 76 offset [ p_F___m_27_ * false + renderemail ( p_F___m_27_ ( ) ) for ( F2 : O16zRr6F<F2> in / (?<!\Q"\E+?)??|empty+? /.p_F___m_27_() order by null desc ) ] ) ] for ( S6fr3OF_6MH : function ( ) : p_F___m_27_ in null >= p_F___m_27_() ) ] desc ) ] where O__4_Oe_CIP completions (similarity O16zRr6F()) limit Set<O16zRr6F<O16zRr6F>>() offset true || email ( p_F___m_27_ ( ) ) < renderemail ( XF2B_5_X_ ( ) ) ) ]
+every
+F2()
+hours
+function.
+S6fr3OF_6MH
+(
+)
+:
+O16zRr6F
+seconds
+if
+(
+function.p_F___m_27_():Void()[/ . /.F2()].F2
+)
+[
+]
+else
+[]
+milliseconds
+page
+p_F___m_27_
+(
+)
+{
+}
+derive
+webservices
+for
+p_F___m_27_
+,
+with
+nameproperty
+XF2B_5_X_
+var S6fr3OF_6MH : XF2B_5_X_<O16zRr6F> ;
+access
+control
+policy
+p_F___m_27_
+section p ppp
+
+  invoke
+
+  function.
+
+  XF2B_5_X_
+
+  (
+
+  )
+
+  :
+
+  Void
+
+  every
+
+  enum O16zRr6F { }
+
+  analyzer XF2B_5_X_ {
+    tokenizer = O16zRr6F ( )
+  }
+
+  search mapping S6fr3OF_6MH {
+  }
+
+  page
+
+  p_F___m_27_
+
+  (
+
+  )
+
+  requires
+
+  {
+
+  }
+
+  note
+    {
+  }
+
+  type S6fr3OF_6MH { }
+
+  recommend
+
+  S6fr3OF_6MH
+
+  {
+
+  }
+
+  enum F2 { }
+
+  invoke
+
+  function.p_F___m_27_():Void()
+
+  every
+access
+control
+policy
+XF2B_5_X_
+AND
+S6fr3OF_6MH
+AND
+p_F___m_27_
+AND
+F2
+AND
+O16zRr6F
+AND
+XF2B_5_X_
+OR
+O16zRr6F
+AND
+F2
+section |o8 o 
+
+  template
+
+  S6fr3OF_6MH
+
+  (
+
+  )
+
+  {
+
+  }
+
+  define
+
+  F2
+
+  (
+
+  )
+
+  =
+
+  F2
+
+  test
+
+  F2
+
+  {
+  }
+
+  extend entity S6fr3OF_6MH {
+  }
+
+  principal
+
+  is
+
+  S6fr3OF_6MH
+
+  with
+
+  credentials
+
+  XF2B_5_X_
+
+  derive
+
+  webservices
+
+  for
+
+  XF2B_5_X_
+
+  ,
+
+  with
+
+  nameproperty
+
+  O16zRr6F
+
+  imports -xZz_i.r.-/.--3-/_Uo_n.0_-
+access control rules
+  predicate
+  S6fr3OF_6MH
+  (
+  )
+  {
+  {}.F2().F2
+  }
+  principal
+  is
+  XF2B_5_X_
+  with
+  credentials
+  O16zRr6F
+  principal
+  is
+  XF2B_5_X_
+  with
+  credentials
+  S6fr3OF_6MH
+  rule XF2B_5_X_ {
+    List<Ref<F2<S6fr3OF_6MH>>>()
+  }
+  principal
+  is
+  S6fr3OF_6MH
+  with
+  credentials
+  S6fr3OF_6MH
+  rule O16zRr6F {
+    null || Set<Ref<function():Void>>()
+  }
+  principal
+  is
+  S6fr3OF_6MH
+  with
+  credentials
+  XF2B_5_X_
+  predicate
+  S6fr3OF_6MH
+  (
+  )
+  {
+  renderemail
+  (
+  S6fr3OF_6MH
+  (
+  )
+  )
+  }
+  predicate
+  S6fr3OF_6MH
+  (
+  )
+  {
+  p_F___m_27_()
+  }
+  predicate
+  XF2B_5_X_
+  (
+  )
+  {
+  function.
+  S6fr3OF_6MH
+  (
+  )
+  :
+  Void
+  +
+  XF2B_5_X_
+  +
+  List<Ref<Ref<O16zRr6F<S6fr3OF_6MH>>>>()
+  }
+access
+control
+policy
+p_F___m_27_
+AND
+F2
+AND
+XF2B_5_X_
+AND
+O16zRr6F
+AND
+F2
+section |o8 o 
+
+  predicate
+
+  XF2B_5_X_
+
+  (
+
+  F2 : O16zRr6F
+
+  ,
+
+  F2 : p_F___m_27_
+
+  ,
+
+  F2 : function ( ) : Void
+
+  ,
+
+  F2 : Ref<F2>
+
+  ,
+
+  S6fr3OF_6MH : function ( ) : Void
+
+  ,
+
+  p_F___m_27_ : Ref<O16zRr6F<O16zRr6F>>
+
+  ,
+
+  S6fr3OF_6MH : Ref<O16zRr6F>
+
+  ,
+
+  F2 : p_F___m_27_<F2>
+
+  ,
+
+  F2 : S6fr3OF_6MH<XF2B_5_X_>
+
+  )
+
+  {
+
+  validatetemplate
+
+  (
+
+  LD8ei_pB_Q()
+
+  )
+
+  }
+access
+control
+policy
+XF2B_5_X_
+OR
+F2
+AND
+XF2B_5_X_
+access
+control
+policy
+XF2B_5_X_
+section   opoJ b f
+
+  var S6fr3OF_6MH : Ref<Ref<F2<XF2B_5_X_>>> := email ( XF2B_5_X_ ( ) )
+
+  principal
+
+  is
+
+  p_F___m_27_
+
+  with
+
+  credentials
+
+  F2
+
+  extend
+
+  session
+
+  F2
+
+  {
+
+  }
+
+  enum O16zRr6F { }
\ No newline at end of file

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/s_23795crashed/strategyResult.txt
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/s_23795crashed/strategyResult.txt	Tue Aug 14 13:01:58 2012	(r25271)
@@ -0,0 +1,52 @@
+
+Analyzing: TestFolder/program.app
+Updating cache: /Users/andre/Documents/TU/Dropbox/MP/Code/MP/WebDSL-CoverageTest/.cache/+Users+andre+Documents+TU+Dropbox+MP+Code+MP+WebDSL-CoverageTest+TestFolder+.servletapp+src-webdsl-template+built-in.app.sig
+Explicitly importing main file: program  
+
+* : error: Global variable 'S6fr3OF_6MH' must be initialized.
+var S6fr3OF_6MH : XF2B_5_X_<O16zRr6F> ;
+WebDSL: rewriting failed, trace:
+	editor_analyze0_0_0
+	editor_analyze0_0_0
+	editor_analyze_0_0
+	editor_analyze_work_0_0
+	in_typechecking_phase_1_0
+	dr_scope_1_1
+	dr_scope_1_1
+	declare_globals_0_0
+	typecheck_declare_0_0
+	log_time_1_1
+	declare_all_0_0
+	dr_scope_1_1
+	alltd_1_0
+	declare_0_0
+	declare_recommend_0_0
+	normalize_recommend_0_0
+	fetch_elem_1_0
+[ WebDSL | critical ] Internal error: with clause failed unexpectedly in rule 'normalize-recommend'
+           RecommendConfig("S6fr3OF_6MH",[])Analyzing: TestFolder/program.app
+Updating cache: /Users/andre/Documents/TU/Dropbox/MP/Code/MP/WebDSL-CoverageTest/.cache/+Users+andre+Documents+TU+Dropbox+MP+Code+MP+WebDSL-CoverageTest+TestFolder+.servletapp+src-webdsl-template+built-in.app.sig
+Explicitly importing main file: program  
+
+* : error: Global variable 'S6fr3OF_6MH' must be initialized.
+var S6fr3OF_6MH : XF2B_5_X_<O16zRr6F> ;
+WebDSL: rewriting failed, trace:
+	editor_analyze0_0_0
+	editor_analyze0_0_0
+	editor_analyze_0_0
+	editor_analyze_work_0_0
+	in_typechecking_phase_1_0
+	dr_scope_1_1
+	dr_scope_1_1
+	declare_globals_0_0
+	typecheck_declare_0_0
+	log_time_1_1
+	declare_all_0_0
+	dr_scope_1_1
+	alltd_1_0
+	declare_0_0
+	declare_recommend_0_0
+	normalize_recommend_0_0
+	fetch_elem_1_0
+[ WebDSL | critical ] Internal error: with clause failed unexpectedly in rule 'normalize-recommend'
+           RecommendConfig("S6fr3OF_6MH",[])
\ No newline at end of file

From andre.s.d.vieira at gmail.com  Tue Aug 14 15:07:19 2012
From: andre.s.d.vieira at gmail.com (Andre Vieira)
Date: Tue, 14 Aug 2012 13:07:19 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25272 -
	spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/w_1446crashed
Message-ID: <20120814130719.A16152B8024@mx2.tudelft.nl>

Author: AndreVieira
Date: Tue Aug 14 13:07:19 2012
New Revision: 25272
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25272&sc=1

Log:


Added:
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/w_1446crashed/
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/w_1446crashed/AST.aterm
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/w_1446crashed/program.app
   spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/w_1446crashed/strategyResult.txt

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/w_1446crashed/AST.aterm
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/w_1446crashed/AST.aterm	Tue Aug 14 13:07:19 2012	(r25272)
@@ -0,0 +1,186 @@
+Module(
+  "_-_s/I1-_R"
+, [ AccessControlDefinition(
+      None()
+    , [ Predicate(
+          "mCPU4"
+        , []
+        , InColl(
+            SendEmailFunctionCall(EmailCall("mCPU4", []))
+          , FieldAccess(Var("externalscope"), "vb")
+          )
+        )
+      ]
+    )
+  , AccessControlDefinition(None(), [])
+  , ACPolicy(
+      PolicyOr(
+        PolicyOr(Name("As_UHhP2_7_"), Name("vb"))
+      , PolicyAnd(PolicyAnd(Name("nH5jZP67"), Name("As_UHhP2_7_")), Name("mCPU4"))
+      )
+    )
+  , Section(
+      " FG  xl p"
+    , [ EntityNoSuper("mCPU4", [])
+      , DeriveCrud("q")
+      , DeriveCrud("As_UHhP2_7_")
+      , Define([], "nH5jZP67", [], None(), [])
+      , ExtendSessionEntity("As_UHhP2_7_", [])
+      , Imports("Oth_Krv.-7")
+      , RecommendConfig("As_UHhP2_7_", [])
+      , TypeDef(
+          "q"
+        , [ TypeDefAnno(LengthAnno("-1613"))
+          , NativeClassFunctionFromStatic(
+              Qualified(Qualified("As_UHhP2_7_", "q"), "q")
+            , NativeClassFunction(None(), "As_UHhP2_7_", [], NativeClassFunctionReturn(NativeSimpleType("nH5jZP67")))
+            )
+          , TypeDefAnno(IncompleteInverseAnno("As_UHhP2_7_"))
+          , NativeClassFunctionFromStatic(
+              Qualified("mCPU4", "mCPU4")
+            , NativeClassFunction(NativeClassFunctionStatic(), "mCPU4", [], NativeClassFunctionReturn(NativeGenericType("As_UHhP2_7_", [])))
+            )
+          , NativeClassFunctionFromStatic(
+              Qualified("vb", "vb")
+            , NativeClassFunction(NativeClassFunctionStatic(), "mCPU4", [], None())
+            )
+          ]
+        )
+      , RecommendConfigStaticOrder(
+          "q"
+        , RecommendUser("q")
+        , RecommendItem("vb")
+        , RecommendValue("As_UHhP2_7_")
+        , RecommendAlgorithm("q")
+        , RecommendNeighborAlg("vb")
+        , RecommendNeighborSize("vb")
+        , RecommendType("As_UHhP2_7_")
+        , RecommendSchedule("q")
+        )
+      ]
+    )
+  , Section(" FG  xl p", [DeriveWebServices("nH5jZP67", "q")])
+  , Section(" x+", [SessionEntity("nH5jZP67", [])])
+  , AccessControlDefinition(
+      Some("nH5jZP67")
+    , [ AccessControlPrincipal("mCPU4", ["q"])
+      , Predicate(
+          "mCPU4"
+        , []
+        , LargerThanOrEqual(
+            NotEq(
+              InColl(ThisCall("q", []), Var("nH5jZP67"))
+            , Call(
+                RegexPattern(
+                  TupleBranch(
+                    SingleBranch(
+                      Pieces(
+                        [ SingleAtom(AtomLiteral("e"))
+                        , SingleAtom(AtomLiteral("m"))
+                        , SingleAtom(AtomLiteral("p"))
+                        , SingleAtom(AtomLiteral("t"))
+                        , SingleAtom(AtomLiteral("y"))
+                        ]
+                      )
+                    )
+                  , TupleBranch(
+                      SingleBranch(Pieces([SingleAtom(SingleCharacter())]))
+                    , SingleBranch(
+                        Pieces(
+                          [ SingleAtom(AtomLiteral("e"))
+                          , SingleAtom(AtomLiteral("m"))
+                          , SingleAtom(AtomLiteral("p"))
+                          , SingleAtom(AtomLiteral("t"))
+                          , SingleAtom(AtomLiteral("y"))
+                          ]
+                        )
+                      )
+                    )
+                  )
+                )
+              , "nH5jZP67"
+              , []
+              )
+            )
+          , ForExp(
+              FieldAccess(
+                Call(
+                  RegexPattern(
+                    SingleBranch(
+                      Pieces(
+                        [ SingleAtom(AtomLiteral("e"))
+                        , SingleAtom(AtomLiteral("m"))
+                        , SingleAtom(AtomLiteral("p"))
+                        , SingleAtom(AtomLiteral("t"))
+                        , QuantifiedAtom(AtomLiteral("y"), PossessiveOnceOrNot())
+                        ]
+                      )
+                    )
+                  )
+                , "q"
+                , []
+                )
+              , "mCPU4"
+              )
+            , "nH5jZP67"
+            , FunctionSort([], SimpleSort("Void"))
+            , ObjectCreation(FunctionSort([], SimpleSort("mCPU4")), [])
+            , FilterNoOrderBy(
+                RenderEmailFunctionCall(EmailCall("nH5jZP67", []))
+              , Limit(
+                  Call(
+                    RegexPattern(SingleBranch(Pieces([SingleAtom(QuotedAtom("""))])))
+                  , "nH5jZP67"
+                  , []
+                  )
+                , AndForExp(
+                    ForExp(
+                      FunctionRefCallPartial(FunctionRef("vb", [], SimpleSort("As_UHhP2_7_")), [])
+                    , "nH5jZP67"
+                    , RefSort(GenericSort("q", [SimpleSort("q")]))
+                    , TypedListCreation(RefSort(GenericSort("q", [SimpleSort("nH5jZP67")])), [])
+                    , FilterNoWhereNoOrderBy(Limit(ThisCall("q", []), SetCreation([])))
+                    )
+                  )
+                )
+              )
+            )
+          )
+        )
+      , SpecialAccessControlRule("As_UHhP2_7_", Call(False(), "nH5jZP67", []))
+      , AccessControlPointcut("nH5jZP67", [], [])
+      , Predicate(
+          "mCPU4"
+        , []
+        , CollectionIndex(
+            FunctionRefCallPartial(FunctionRef("nH5jZP67", [], SimpleSort("Void")), [])
+          , ObjectCreation(FunctionSort([], SimpleSort("Void")), [])
+          )
+        )
+      , AccessControlPointcut("mCPU4", [], [])
+      , AccessControlPointcut("nH5jZP67", [], [])
+      , AccessControlPrincipal("As_UHhP2_7_", ["q"])
+      ]
+    )
+  , Section(
+      " FG  xl p"
+    , [ Predicate("mCPU4", [], ValidateTemplateFunctionCall(ValidationErrors("mCPU4")))
+      , DeriveWebServices("nH5jZP67", "As_UHhP2_7_")
+      , Action([], "vb", [], Block([]))
+      , Imports("3_1jTo4-/_")
+      , ExtendSessionEntity("As_UHhP2_7_", [])
+      , Define([], "vb", [], None(), [])
+      , InvokeEvery(Int("2"), TimeInterval([]))
+      , SearchMapping("vb", [])
+      ]
+    )
+  , AccessControlDefinition(
+      Some("vb")
+    , [ SpecialAccessControlRule("q", SmallerThanOrEqual(ListCreation([]), SetCreation([])))
+      , AccessControlPointcut("As_UHhP2_7_", [], [])
+      , AccessControlPointcut("nH5jZP67", [], [])
+      , AccessControlPointcut("mCPU4", [], [])
+      ]
+    )
+  ]
+)
\ No newline at end of file

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/w_1446crashed/program.app
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/w_1446crashed/program.app	Tue Aug 14 13:07:19 2012	(r25272)
@@ -0,0 +1,289 @@
+module _-_s/I1-_R
+access control rules
+  predicate
+  mCPU4
+  (
+  )
+  {
+  sendemail
+  (
+  mCPU4
+  (
+  )
+  )
+  in
+  externalscope
+  .
+  vb
+  }
+access control rules
+access
+control
+policy
+As_UHhP2_7_
+OR
+vb
+OR
+nH5jZP67
+AND
+As_UHhP2_7_
+AND
+mCPU4
+section FG  xl p
+
+  entity mCPU4 {
+  }
+
+  derive
+
+  CRUD
+
+  q
+
+  derive
+
+  CRUD
+
+  As_UHhP2_7_
+
+  define
+
+  nH5jZP67
+
+  (
+
+  )
+
+  {
+
+  }
+
+  extend
+
+  session
+
+  As_UHhP2_7_
+
+  {
+
+  }
+
+  imports Oth_Krv.-7
+
+  recommend
+
+  As_UHhP2_7_
+
+  {
+
+  }
+
+  type q { length= -1613 As_UHhP2_7_.q.q as As_UHhP2_7_ ( ) : nH5jZP67 inverse = As_UHhP2_7_ mCPU4.mCPU4 as static mCPU4 ( ) : As_UHhP2_7_ < > vb.vb as static mCPU4 ( ) }
+
+  recommenderStaticOrder
+
+  q
+
+  {
+
+  q
+
+  vb
+
+  As_UHhP2_7_
+
+  q
+
+  vb
+
+  vb
+
+  As_UHhP2_7_
+
+  q
+
+  }
+section FG  xl p
+
+  derive
+
+  webservices
+
+  for
+
+  nH5jZP67
+
+  ,
+
+  with
+
+  nameproperty
+
+  q
+section x+
+
+  session nH5jZP67 {
+  }
+access control rules
+  nH5jZP67
+  principal
+  is
+  mCPU4
+  with
+  credentials
+  q
+  predicate
+  mCPU4
+  (
+  )
+  {
+  q()
+  in
+  nH5jZP67
+  !=
+  / empty|.|empty /.nH5jZP67()
+  >=
+  [ / empty?+ /.q().mCPU4 for ( nH5jZP67 : function ( ) : Void in function ( ) : mCPU4 {
+                                                                                       } where renderemail ( nH5jZP67 ( ) ) limit / \Q"\E /.nH5jZP67() offset And [ function.vb():As_UHhP2_7_(*,) for ( nH5jZP67 : Ref<q<q>> in List<Ref<q<nH5jZP67>>>() limit q() offset {} ) ] ) ]
+  }
+  rule As_UHhP2_7_ {
+    false.nH5jZP67()
+  }
+  pointcut
+  nH5jZP67
+  (
+  )
+  {
+  }
+  predicate
+  mCPU4
+  (
+  )
+  {
+  function.nH5jZP67():Void(*,)
+  [
+  function():Void{}
+  ]
+  }
+  pointcut
+  mCPU4
+  (
+  )
+  {
+  }
+  pointcut
+  nH5jZP67
+  (
+  )
+  {
+  }
+  principal
+  is
+  As_UHhP2_7_
+  with
+  credentials
+  q
+section FG  xl p
+
+  predicate
+
+  mCPU4
+
+  (
+
+  )
+
+  {
+
+  validatetemplate
+
+  (
+
+  validationErrors
+
+  (
+
+  mCPU4
+
+  )
+
+  )
+
+  }
+
+  derive
+
+  webservices
+
+  for
+
+  nH5jZP67
+
+  ,
+
+  with
+
+  nameproperty
+
+  As_UHhP2_7_
+
+  action vb ( )
+  {
+  }
+
+  imports 3_1jTo4-/_
+
+  extend
+
+  session
+
+  As_UHhP2_7_
+
+  {
+
+  }
+
+  define
+
+  vb
+
+  (
+
+  )
+
+  {
+
+  }
+
+  invoke
+
+  2
+
+  every
+
+  search mapping vb {
+  }
+access control rules
+  vb
+  rule q {
+    [
+    ] <= {}
+  }
+  pointcut
+  As_UHhP2_7_
+  (
+  )
+  {
+  }
+  pointcut
+  nH5jZP67
+  (
+  )
+  {
+  }
+  pointcut
+  mCPU4
+  (
+  )
+  {
+  }
\ No newline at end of file

Added: spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/w_1446crashed/strategyResult.txt
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/spoofax-testing-automation/Errors/WebDSL3/w_1446crashed/strategyResult.txt	Tue Aug 14 13:07:19 2012	(r25272)
@@ -0,0 +1,44 @@
+
+Analyzing: TestFolder/program.app
+Explicitly importing main file: program  
+WebDSL: rewriting failed, trace:
+	editor_analyze0_0_0
+	editor_analyze0_0_0
+	editor_analyze_0_0
+	editor_analyze_work_0_0
+	in_typechecking_phase_1_0
+	dr_scope_1_1
+	dr_scope_1_1
+	declare_globals_0_0
+	typecheck_declare_0_0
+	log_time_1_1
+	declare_all_0_0
+	dr_scope_1_1
+	alltd_1_0
+	declare_0_0
+	declare_recommend_0_0
+	normalize_recommend_0_0
+	fetch_elem_1_0
+[ WebDSL | critical ] Internal error: with clause failed unexpectedly in rule 'normalize-recommend'
+           RecommendConfig("As_UHhP2_7_",[])Analyzing: TestFolder/program.app
+Explicitly importing main file: program  
+WebDSL: rewriting failed, trace:
+	editor_analyze0_0_0
+	editor_analyze0_0_0
+	editor_analyze_0_0
+	editor_analyze_work_0_0
+	in_typechecking_phase_1_0
+	dr_scope_1_1
+	dr_scope_1_1
+	declare_globals_0_0
+	typecheck_declare_0_0
+	log_time_1_1
+	declare_all_0_0
+	dr_scope_1_1
+	alltd_1_0
+	declare_0_0
+	declare_recommend_0_0
+	normalize_recommend_0_0
+	fetch_elem_1_0
+[ WebDSL | critical ] Internal error: with clause failed unexpectedly in rule 'normalize-recommend'
+           RecommendConfig("As_UHhP2_7_",[])
\ No newline at end of file

From R.B.Vermaas at tudelft.nl  Sat Aug 25 19:20:35 2012
From: R.B.Vermaas at tudelft.nl (Rob Vermaas)
Date: Sat, 25 Aug 2012 17:20:35 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25273 - in hydra: .
	jobs strategoxt webdsl
Message-ID: <20120825172035.D59A67F8015@mx1.tudelft.nl>

Author: rob
Date: Sat Aug 25 17:20:34 2012
New Revision: 25273
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25273&sc=1

Log:
replace jdk by openjdk (not tested)

Modified:
   hydra/jobs/aster.nix
   hydra/jobs/org.spoofax.aterm.nix
   hydra/jobs/org.spoofax.interpreter.core.nix
   hydra/jobs/org.spoofax.interpreter.library.jsglr.nix
   hydra/jobs/org.spoofax.jsglr.nix
   hydra/jobs/org.spoofax.jssglr.nix
   hydra/jobs/org.spoofax.terms.nix
   hydra/jobs/spoofax-ace.nix
   hydra/jobs/spoofax-imp-new-terms.nix
   hydra/jobs/spoofax-interpreter.nix
   hydra/jobs/strategoxt-java-bootstrap.nix
   hydra/jobs/webworker.nix
   hydra/spoofax-fun.nix
   hydra/strategoxt/packages.nix
   hydra/webdsl/machine.nix
   hydra/webdsl/tests-separate-compilation.nix
   hydra/webdsl/tests.nix

Modified: hydra/jobs/aster.nix
==============================================================================
--- hydra/jobs/aster.nix	Tue Aug 14 13:07:19 2012	(r25272)
+++ hydra/jobs/aster.nix	Sat Aug 25 17:20:34 2012	(r25273)
@@ -20,7 +20,7 @@
       spec = specs.aster ; 
 
       extraJobs = builder : {
-        asterJava = { strcJava }: 
+        asterJava = { strcJava ? jobs.tarball }: 
           let pkgs = (import nixpkgs { });
           in
             pkgs.stdenv.mkDerivation (
@@ -45,7 +45,7 @@
                 '';
 
                 buildInputs =
-                  [strcJava pkgs.jdk] ++ (spec pkgs).svnBuildInputs ++ (map (spec2: builder.easyBuild pkgs spec2) (spec pkgs).svnRequires);
+                  [strcJava pkgs.openjdk] ++ (spec pkgs).svnBuildInputs ++ (map (spec2: builder.easyBuild pkgs spec2) (spec pkgs).svnRequires);
             });
         };
     } ;

Modified: hydra/jobs/org.spoofax.aterm.nix
==============================================================================
--- hydra/jobs/org.spoofax.aterm.nix	Tue Aug 14 13:07:19 2012	(r25272)
+++ hydra/jobs/org.spoofax.aterm.nix	Sat Aug 25 17:20:34 2012	(r25273)
@@ -13,7 +13,7 @@
     antTargets = ["compile" "jar" "check"];
 
     buildfile = "build.ant.xml";
-    buildInputs = [pkgs.ant];
+    buildInputs = [pkgs.apacheAntOpenJDK];
   };
 
 }

Modified: hydra/jobs/org.spoofax.interpreter.core.nix
==============================================================================
--- hydra/jobs/org.spoofax.interpreter.core.nix	Tue Aug 14 13:07:19 2012	(r25272)
+++ hydra/jobs/org.spoofax.interpreter.core.nix	Sat Aug 25 17:20:34 2012	(r25273)
@@ -30,7 +30,7 @@
     antBuildInputs = [spoofaxTerms jars.junit jars.antjunit];
 
     buildfile = "build.ant.xml";
-    buildInputs = [pkgs.ant];
+    buildInputs = [pkgs.apacheAntOpenJDK];
 
     preConfigure = ''
       mkdir -p lib/

Modified: hydra/jobs/org.spoofax.interpreter.library.jsglr.nix
==============================================================================
--- hydra/jobs/org.spoofax.interpreter.library.jsglr.nix	Tue Aug 14 13:07:19 2012	(r25272)
+++ hydra/jobs/org.spoofax.interpreter.library.jsglr.nix	Sat Aug 25 17:20:34 2012	(r25273)
@@ -36,7 +36,7 @@
     antBuildInputs = [spoofaxCore spoofaxJsglr spoofaxTerms jars.junit jars.antjunit];
 
     buildfile = "build.ant.xml";
-    buildInputs = [pkgs.ant];
+    buildInputs = [pkgs.apacheAntOpenJDK];
 
     preConfigure = ''
       mkdir -p lib/

Modified: hydra/jobs/org.spoofax.jsglr.nix
==============================================================================
--- hydra/jobs/org.spoofax.jsglr.nix	Tue Aug 14 13:07:19 2012	(r25272)
+++ hydra/jobs/org.spoofax.jsglr.nix	Sat Aug 25 17:20:34 2012	(r25273)
@@ -30,7 +30,7 @@
     antBuildInputs = [spoofaxTerms jars.junit jars.antjunit];
 
     buildfile = "build.ant.xml";
-    buildInputs = [pkgs.ant];
+    buildInputs = [pkgs.apacheAntOpenJDK];
 
     preConfigure = ''
       mkdir -p lib/

Modified: hydra/jobs/org.spoofax.jssglr.nix
==============================================================================
--- hydra/jobs/org.spoofax.jssglr.nix	Tue Aug 14 13:07:19 2012	(r25272)
+++ hydra/jobs/org.spoofax.jssglr.nix	Sat Aug 25 17:20:34 2012	(r25273)
@@ -38,7 +38,7 @@
     ];
     antTargets = [ "jssglr_gwt_c" ];
     buildfile = "build.xml";
-    buildInputs = [pkgs.ant];
+    buildInputs = [pkgs.apacheAntOpenJDK];
 
     finalPhase = ''
       rm -rf $out/bin

Modified: hydra/jobs/org.spoofax.terms.nix
==============================================================================
--- hydra/jobs/org.spoofax.terms.nix	Tue Aug 14 13:07:19 2012	(r25272)
+++ hydra/jobs/org.spoofax.terms.nix	Sat Aug 25 17:20:34 2012	(r25273)
@@ -13,7 +13,7 @@
     antTargets = ["compile" "jar" "check"];
 
     buildfile = "build.ant.xml";
-    buildInputs = [pkgs.ant];
+    buildInputs = [pkgs.apacheAntOpenJDK];
   };
 
 }

Modified: hydra/jobs/spoofax-ace.nix
==============================================================================
--- hydra/jobs/spoofax-ace.nix	Tue Aug 14 13:07:19 2012	(r25272)
+++ hydra/jobs/spoofax-ace.nix	Sat Aug 25 17:20:34 2012	(r25273)
@@ -30,7 +30,7 @@
      { name = "resourcesDir"; value =''./resources''; }
     ];
 
-    buildInputs = [pkgs.ant strcJava ];
+    buildInputs = [pkgs.apacheAntOpenJDK strcJava ];
     antTargets = [ "jar" ];
     buildfile = "build.xml";
 

Modified: hydra/jobs/spoofax-imp-new-terms.nix
==============================================================================
--- hydra/jobs/spoofax-imp-new-terms.nix	Tue Aug 14 13:07:19 2012	(r25272)
+++ hydra/jobs/spoofax-imp-new-terms.nix	Sat Aug 25 17:20:34 2012	(r25273)
@@ -114,7 +114,7 @@
 	      	pkgs.which 
 	      	pkgs.ecj 
 	      	pkgs.jdk 
-	      	pkgs.ant
+	      	pkgs.apacheAntOpenJDK
 	      ];
 	      mvnFlags = "-Dmaven.repo.local=/tmp/m3";
 	      buildPhase = ''

Modified: hydra/jobs/spoofax-interpreter.nix
==============================================================================
--- hydra/jobs/spoofax-interpreter.nix	Tue Aug 14 13:07:19 2012	(r25272)
+++ hydra/jobs/spoofax-interpreter.nix	Sat Aug 25 17:20:34 2012	(r25273)
@@ -44,7 +44,7 @@
     antBuildInputs = [spoofaxCore spoofaxTerms spoofaxJsglr spoofaxLibraryJsglr jars.jline jars.junit jars.antjunit];
 
     buildfile = "build.ant.xml";
-    buildInputs = [pkgs.ant strategoxt pkgs.strategoPackages017.sdf];
+    buildInputs = [pkgs.apacheAntOpenJDK strategoxt pkgs.strategoPackages017.sdf];
 
     preConfigure = 
       ''

Modified: hydra/jobs/strategoxt-java-bootstrap.nix
==============================================================================
--- hydra/jobs/strategoxt-java-bootstrap.nix	Tue Aug 14 13:07:19 2012	(r25272)
+++ hydra/jobs/strategoxt-java-bootstrap.nix	Sat Aug 25 17:20:34 2012	(r25273)
@@ -6,18 +6,12 @@
 } :
 let
   pkgs = import nixpkgs { system = "i686-linux"; };
-/*
-  strategoxtJavaBackend = pkgs.fetchsvn {
-    url = https://svn.strategoxt.org/repos/StrategoXT/strategoxt-java-backend/trunk;
-    rev = 22230;
-    sha256 = "0d49aihzqn9ylgjdq4v2vrrzwql9pabwirssgz9jmk0df1bvcs0c";
-  };
-*/
+
   bootstrap = baseline: nr:
     pkgs.releaseTools.antBuild {
       name = "strategoxt-java-${toString nr}";
       src = strategoxtJava;
-      buildInputs = with pkgs; [ strategoPackages.sdf strategoPackages.strategoxt ecj jdk ];
+      buildInputs = with pkgs; [ strategoPackages.sdf strategoPackages.strategoxt ecj openjdk ];
 
       postUnpack = ''
         cd $sourceRoot

Modified: hydra/jobs/webworker.nix
==============================================================================
--- hydra/jobs/webworker.nix	Tue Aug 14 13:07:19 2012	(r25272)
+++ hydra/jobs/webworker.nix	Sat Aug 25 17:20:34 2012	(r25273)
@@ -33,7 +33,7 @@
 
     antTargets = [ "clean" "compile" "jar" ];
     buildfile = "build.xml";
-    buildInputs = [pkgs.ant];
+    buildInputs = [pkgs.apacheAntOpenJDK];
 
     jars = ["./webworker.jar"];
   };

Modified: hydra/spoofax-fun.nix
==============================================================================
--- hydra/spoofax-fun.nix	Tue Aug 14 13:07:19 2012	(r25272)
+++ hydra/spoofax-fun.nix	Sat Aug 25 17:20:34 2012	(r25273)
@@ -27,7 +27,7 @@
   name = "${name}-r${toString src.rev}";
   inherit src eclipse;
     
-  buildInputs = [ pkgs.maven3 pkgs.ant ] ++ optional (args ? buildInputs) args.buildInputs ;
+  buildInputs = [ pkgs.maven3 pkgs.apacheAntOpenJDK ] ++ optional (args ? buildInputs) args.buildInputs ;
 
   buildPhase = 
   let

Modified: hydra/strategoxt/packages.nix
==============================================================================
--- hydra/strategoxt/packages.nix	Tue Aug 14 13:07:19 2012	(r25272)
+++ hydra/strategoxt/packages.nix	Sat Aug 25 17:20:34 2012	(r25273)
@@ -362,7 +362,7 @@
       svnBuildInputs = buildInputs ++ (autotools pkgs);
       svnRequires = [aterm sdf2Bundle strategoxt javaFront];
       svnConfigureFlags = [
-          ("--with-jdk=" + pkgs.jdk)
+          ("--with-jdk=" + pkgs.openjdk)
           ("--with-bcel=" + pkgs.jakartabcel)
           ("--with-regexp=" + pkgs.jakartaregexp)
           ("--with-shared-objects=" + pkgs.sharedobjects)
@@ -370,11 +370,11 @@
           ("--with-aterm-java=" + pkgs.atermjava)
         ];
 
-      buildInputs = [pkgs.pkgconfig pkgs.unzip pkgs.zlib pkgs.jdk];
+      buildInputs = [pkgs.pkgconfig pkgs.unzip pkgs.zlib pkgs.openjdk];
       requires = svnRequires;
 
       customEnv = pkgs.lib.optionalAttrs pkgs.stdenv.isDarwin {
-        NIX_CFLAGS_COMPILE = "-I${pkgs.jdk}/include/darwin";
+        NIX_CFLAGS_COMPILE = "-I${pkgs.openjdk}/include/darwin";
       };
 
       rpmBuildSupported = true;
@@ -400,7 +400,7 @@
 
       svnBuildInputs = buildInputs ++ (autotools pkgs);
       svnRequires = [aterm sdf2Bundle strategoxt javaFront dryad];
-      buildInputs = [pkgs.pkgconfig pkgs.zlib pkgs.jdk];
+      buildInputs = [pkgs.pkgconfig pkgs.zlib pkgs.openjdk];
       requires = svnRequires;
 
       rpmBuildSupported = true;
@@ -425,7 +425,7 @@
 
       buildInputs = 
         [pkgs.pkgconfig pkgs.unzip pkgs.zlib pkgs.which] 
-        ++ pkgs.lib.optional pkgs.stdenv.isLinux [(pkgs.ecj.override { gcj = pkgs.jdk; }) pkgs.jdk] 
+        ++ pkgs.lib.optional pkgs.stdenv.isLinux [(pkgs.ecj.override { gcj = pkgs.openjdk; }) pkgs.openjdk] 
         ++ pkgs.lib.optional pkgs.stdenv.isDarwin [(pkgs.ecj.override { gcj = pkgs.openjdk; }) pkgs.openjdk];
       requires = svnRequires;
 
@@ -459,7 +459,7 @@
 
       svnBuildInputs = buildInputs ++ (autotools pkgs);
       svnRequires = [aterm sdf2Bundle strategoxt javaFront dryad];
-      buildInputs = [pkgs.pkgconfig pkgs.zlib pkgs.jdk];
+      buildInputs = [pkgs.pkgconfig pkgs.zlib pkgs.openjdk];
       requires = svnRequires;
 
       rpmBuildSupported = false;
@@ -556,7 +556,7 @@
 
       svnBuildInputs = buildInputs ++ (autotools pkgs);
       svnRequires = [aterm sdf2Bundle strategoxt javaFront dryad dryadCompiler];
-      buildInputs = [pkgs.pkgconfig pkgs.jdk pkgs.valgrind];
+      buildInputs = [pkgs.pkgconfig pkgs.openjdk pkgs.valgrind];
       requires = svnRequires;
 
       rpmBuildSupported = false;
@@ -575,7 +575,7 @@
       svnBuildInputs = buildInputs ++ (autotools pkgs);
       svnRequires = [aterm sdf2Bundle strategoxt javaFront dryad];
       svnConfigureFlags = [("--with-eclipse=" + pkgs.jdtsdk + "/eclipse")];
-      buildInputs = [pkgs.pkgconfig pkgs.zlib pkgs.jdk];
+      buildInputs = [pkgs.pkgconfig pkgs.zlib pkgs.openjdk];
       requires = svnRequires;
       configureFlags = svnConfigureFlags;
 
@@ -598,7 +598,7 @@
           pkgs.pkgconfig
         ]; 
       svnRequires = [aterm sdf2Bundle strategoxt javaFront];
-      buildInputs = [pkgs.pkgconfig] ++ pkgs.lib.optional pkgs.stdenv.isLinux [pkgs.apacheAnt pkgs.ecj pkgs.jdk] ++ pkgs.lib.optional pkgs.stdenv.isDarwin [pkgs.ecjDarwin pkgs.openjdkDarwin pkgs.antDarwin];
+      buildInputs = [pkgs.pkgconfig] ++ pkgs.lib.optional pkgs.stdenv.isLinux [pkgs.apacheAntOpenJDK pkgs.ecj pkgs.openjdk] ++ pkgs.lib.optional pkgs.stdenv.isDarwin [pkgs.ecjDarwin pkgs.openjdkDarwin pkgs.antDarwin];
       requires = svnRequires;
 
       extraVirtualDebs =
@@ -973,7 +973,7 @@
 
       svnBuildInputs = buildInputs ++ (autotools pkgs);
       svnRequires = requires;
-      buildInputs = [pkgs.pkgconfig pkgs.jdk pkgs.php];
+      buildInputs = [pkgs.pkgconfig pkgs.openjdk pkgs.php];
       # TODO: do not depend on javaFront sqlFront
       requires = [strategoxt javaFront sqlFront phpFront];
 
@@ -996,7 +996,7 @@
 
       svnBuildInputs = buildInputs ++ (autotools pkgs);
       svnRequires = requires;
-      buildInputs = [pkgs.pkgconfig  pkgs.jdk pkgs.php];
+      buildInputs = [pkgs.pkgconfig  pkgs.openjdk pkgs.php];
       requires = [strategoxt javaFront stringborg];
 
       rpmBuildSupported = false;
@@ -1020,7 +1020,7 @@
 
       svnBuildInputs = buildInputs ++ (autotools pkgs);
       svnRequires = requires;
-      buildInputs = [pkgs.pkgconfig pkgs.apacheAnt];
+      buildInputs = [pkgs.pkgconfig pkgs.apacheAntOpenJDK];
       requires = [strategoxt javaFront];
 
       makeDistRequiresInstall = false;
@@ -1439,7 +1439,7 @@
       fullName = "Java Development Kit";
       packageName = "jdk";
       releaseInfo = {
-        # TODO: build = pkgs.jdk;
+        # TODO: build = pkgs.openjdk;
         rpm = genericRPM {
             url = file:///tmp/jdk-6-linux-i586.rpm;
             md5 = "ab5a48edd7d74538e506e8e089490e4b";

Modified: hydra/webdsl/machine.nix
==============================================================================
--- hydra/webdsl/machine.nix	Tue Aug 14 13:07:19 2012	(r25272)
+++ hydra/webdsl/machine.nix	Sat Aug 25 17:20:34 2012	(r25273)
@@ -2,7 +2,7 @@
 {
   virtualisation.memorySize = pkgs.lib.mkOverride 150 3072;
   virtualisation.diskSize = 2048;
-  environment.systemPackages = [ pkgs.firefox pkgs.ant pkgs.jdk pkgs.subversion pkgs.maven2 ];
+  environment.systemPackages = [ pkgs.firefox pkgs.apacheAntOpenJDK pkgs.jdk pkgs.subversion pkgs.maven2 ];
   system.copySystemConfiguration = false;
 }
 

Modified: hydra/webdsl/tests-separate-compilation.nix
==============================================================================
--- hydra/webdsl/tests-separate-compilation.nix	Tue Aug 14 13:07:19 2012	(r25272)
+++ hydra/webdsl/tests-separate-compilation.nix	Sat Aug 25 17:20:34 2012	(r25273)
@@ -29,7 +29,7 @@
   build = appname : src : maintainers :
     pkgs.stdenv.mkDerivation rec {
       name = "${appname}-r${toString src.rev}";
-      buildInputs = [webdsl pkgs.ant];
+      buildInputs = [webdsl pkgs.apacheAntOpenJDK];
       buildCommand = ''
         ensureDir $out/nix-support        
         ulimit -s unlimited 
@@ -68,7 +68,7 @@
         require = [ ./machine.nix ];
         drv = pkgs.stdenv.mkDerivation {
           name = "webdsl-webcheck-r${toString webdslSrc.rev}";
-          buildInputs = [pkgs.ant pkgs.jdk pkgs.firefox36Pkgs.firefox webdsl];
+          buildInputs = [pkgs.apacheAntOpenJDK pkgs.jdk pkgs.firefox36Pkgs.firefox webdsl];
           buildCommand = '' 
             ensureDir $out
             cp -R ${webdslSrc}/test/succeed-web succeed-web

Modified: hydra/webdsl/tests.nix
==============================================================================
--- hydra/webdsl/tests.nix	Tue Aug 14 13:07:19 2012	(r25272)
+++ hydra/webdsl/tests.nix	Sat Aug 25 17:20:34 2012	(r25273)
@@ -2,47 +2,47 @@
 , webdsl ? {outPath = builtins.storePath /nix/store/fy8d3qkfhk3k1y10jpdx09q4w43bnh0a-webdsl-9.7pre4063;}
 , nixos ? ../../nixos
 }:
-let 
+let
   pkgs = import nixpkgs { system = "i686-linux"; };
   appIni = name : pkgs.writeText "application.ini" ''
     export BACKEND=servlet
     export TOMCATPATH=/opt/tomcat
     export APPNAME=${name}
     export DBSERVER=localhost
-    export DBUSER=webdsluser 
+    export DBUSER=webdsluser
     export DBPASSWORD=
     export DBNAME=webdsldb
     export DBMODE=create-drop
     export SMTPHOST=localhost
     export SMTPPORT=25
-    export SMTPUSER=  
+    export SMTPUSER=
     export SMTPPASS=
     export SMTPSSL=false
     export SMTPTLS=false
   '';
- 
+
   defaultMaintainters = [ "rob.vermaas at gmail.com" "dgroenewegen at gmail.com" ];
 
   build = appname : src : maintainers :
     pkgs.stdenv.mkDerivation rec {
       name = "${appname}-r${toString src.rev}";
-      buildInputs = [webdsl pkgs.ant];
+      buildInputs = [webdsl pkgs.apacheAntOpenJDK];
       buildCommand = ''
-        ensureDir $out/nix-support        
-        ulimit -s unlimited 
+        ensureDir $out/nix-support
+        ulimit -s unlimited
         export ANT_ARGS="-lib `ls ${pkgs.hydraAntLogger}/lib/java/*.jar | head -1`"
         export ANT_LOGGER="org.hydra.ant.HydraLogger"
 
-        header "Copying sources"        
+        header "Copying sources"
         cp -vR ${src}/* .
         if ! test -f application.ini ; then
           cp -v ${appIni appname} application.ini
         fi
-        chmod -R 755 . 
+        chmod -R 755 .
         stopNest
- 
+
         header "Building"
-        webdsl build        
+        webdsl build
         stopNest
 
         touch $out/nix-support/hydra-build-products
@@ -66,16 +66,16 @@
         require = [ ./machine.nix ];
         drv = pkgs.stdenv.mkDerivation {
           name = "webdsl-webcheck-r${toString webdslSrc.rev}";
-          buildInputs = [pkgs.ant pkgs.jdk pkgs.firefox13Pkgs.firefox webdsl];
-          buildCommand = '' 
+          buildInputs = [pkgs.apacheAntOpenJDK pkgs.jdk pkgs.firefox13Pkgs.firefox webdsl];
+          buildCommand = ''
             ensureDir $out
             cp -R ${webdslSrc}/test/succeed-web succeed-web
-            
+
             cd succeed-web
             TOPDIR=`pwd`
             FAILED=""
             export DISPLAY=:0.0
-            for test in *.app */*.app */*/*.app; do 
+            for test in *.app */*.app */*/*.app; do
               header "Running $test"
               result=""
               cd $TOPDIR/`dirname $test`
@@ -90,7 +90,7 @@
               exit 0
             else
               exit 1
-            fi            
+            fi
           '';
         };
       };

From R.B.Vermaas at tudelft.nl  Sat Aug 25 19:35:21 2012
From: R.B.Vermaas at tudelft.nl (Rob Vermaas)
Date: Sat, 25 Aug 2012 17:35:21 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25274 - hydra/jobs
Message-ID: <20120825173521.BAEEB2B8003@mx2.tudelft.nl>

Author: rob
Date: Sat Aug 25 17:35:21 2012
New Revision: 25274
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25274&sc=1

Log:
more jdk -> openjdk

Modified:
   hydra/jobs/spoofax-imp-new-terms.nix
   hydra/jobs/spoofax-imp-release.nix
   hydra/jobs/spoofax-imp.nix
   hydra/jobs/strategoxt-javascript-backend.nix

Modified: hydra/jobs/spoofax-imp-new-terms.nix
==============================================================================
--- hydra/jobs/spoofax-imp-new-terms.nix	Sat Aug 25 17:20:34 2012	(r25273)
+++ hydra/jobs/spoofax-imp-new-terms.nix	Sat Aug 25 17:35:21 2012	(r25274)
@@ -113,7 +113,7 @@
 	      	pkgs.pkgconfig 
 	      	pkgs.which 
 	      	pkgs.ecj 
-	      	pkgs.jdk 
+	      	pkgs.openjdk 
 	      	pkgs.apacheAntOpenJDK
 	      ];
 	      mvnFlags = "-Dmaven.repo.local=/tmp/m3";

Modified: hydra/jobs/spoofax-imp-release.nix
==============================================================================
--- hydra/jobs/spoofax-imp-release.nix	Sat Aug 25 17:20:34 2012	(r25273)
+++ hydra/jobs/spoofax-imp-release.nix	Sat Aug 25 17:35:21 2012	(r25274)
@@ -139,7 +139,7 @@
       name = "spoofax-imp-r${spoofaxRev}";
       inherit (jobs) src;
           
-      buildInputs = with pkgs; [ maven3 strcJava pkgconfig which ecj jdk ant ];
+      buildInputs = with pkgs; [ maven3 strcJava pkgconfig which ecj openjdk apacheAntOpenJDK];
       mvnFlags = "-Dversion=1.0.0-SNAPSHOT -DgroupId=spoofax -Dtycho.targetPlatform=${eclipse}/eclipse -Dmaven.repo.local=/tmp/m3";
 
       M2_REPO="/tmp/m3";

Modified: hydra/jobs/spoofax-imp.nix
==============================================================================
--- hydra/jobs/spoofax-imp.nix	Sat Aug 25 17:20:34 2012	(r25273)
+++ hydra/jobs/spoofax-imp.nix	Sat Aug 25 17:35:21 2012	(r25274)
@@ -156,7 +156,7 @@
       name = "spoofax-imp-r${spoofaxRev}";
       inherit (jobs) src;
           
-      buildInputs = with pkgs; [ maven3 strcJava pkgconfig which ecj jdk ant ];
+      buildInputs = with pkgs; [ maven3 strcJava pkgconfig which ecj openjdk apacheAntOpenJDK];
       mvnFlags = "-Dversion=1.0.0-SNAPSHOT -DgroupId=spoofax -Dtycho.targetPlatform=${eclipse}/eclipse -Dmaven.repo.local=/tmp/m3";
 
       M2_REPO="/tmp/m3";

Modified: hydra/jobs/strategoxt-javascript-backend.nix
==============================================================================
--- hydra/jobs/strategoxt-javascript-backend.nix	Sat Aug 25 17:20:34 2012	(r25273)
+++ hydra/jobs/strategoxt-javascript-backend.nix	Sat Aug 25 17:35:21 2012	(r25274)
@@ -17,7 +17,7 @@
  build = stdenv.mkDerivation {
     name = "strategoxt-javascript-backend";
     src  = "${jsbackend}";
-    buildInputs = with pkgs; [ strcJava jdk fastjar ]; 
+    buildInputs = with pkgs; [ strcJava openjdk fastjar ]; 
 
     configurePhase = ''
       ensureDir org.strategoxt.strj/java

From R.B.Vermaas at tudelft.nl  Sat Aug 25 21:45:55 2012
From: R.B.Vermaas at tudelft.nl (Rob Vermaas)
Date: Sat, 25 Aug 2012 19:45:55 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25275 - hydra/webdsl
Message-ID: <20120825194555.8CFDECC161@mx4.tudelft.nl>

Author: rob
Date: Sat Aug 25 19:45:54 2012
New Revision: 25275
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25275&sc=1

Log:
use openjdk

Modified:
   hydra/webdsl/machine.nix
   hydra/webdsl/tests-separate-compilation.nix
   hydra/webdsl/tests.nix

Modified: hydra/webdsl/machine.nix
==============================================================================
--- hydra/webdsl/machine.nix	Sat Aug 25 17:35:21 2012	(r25274)
+++ hydra/webdsl/machine.nix	Sat Aug 25 19:45:54 2012	(r25275)
@@ -2,7 +2,7 @@
 {
   virtualisation.memorySize = pkgs.lib.mkOverride 150 3072;
   virtualisation.diskSize = 2048;
-  environment.systemPackages = [ pkgs.firefox pkgs.apacheAntOpenJDK pkgs.jdk pkgs.subversion pkgs.maven2 ];
+  environment.systemPackages = [ pkgs.firefox pkgs.apacheAntOpenJDK pkgs.openjdk pkgs.subversion pkgs.maven3 ];
   system.copySystemConfiguration = false;
 }
 

Modified: hydra/webdsl/tests-separate-compilation.nix
==============================================================================
--- hydra/webdsl/tests-separate-compilation.nix	Sat Aug 25 17:35:21 2012	(r25274)
+++ hydra/webdsl/tests-separate-compilation.nix	Sat Aug 25 19:45:54 2012	(r25275)
@@ -68,7 +68,7 @@
         require = [ ./machine.nix ];
         drv = pkgs.stdenv.mkDerivation {
           name = "webdsl-webcheck-r${toString webdslSrc.rev}";
-          buildInputs = [pkgs.apacheAntOpenJDK pkgs.jdk pkgs.firefox36Pkgs.firefox webdsl];
+          buildInputs = [pkgs.apacheAntOpenJDK pkgs.openjdk pkgs.firefox36Pkgs.firefox webdsl];
           buildCommand = '' 
             ensureDir $out
             cp -R ${webdslSrc}/test/succeed-web succeed-web

Modified: hydra/webdsl/tests.nix
==============================================================================
--- hydra/webdsl/tests.nix	Sat Aug 25 17:35:21 2012	(r25274)
+++ hydra/webdsl/tests.nix	Sat Aug 25 19:45:54 2012	(r25275)
@@ -66,7 +66,7 @@
         require = [ ./machine.nix ];
         drv = pkgs.stdenv.mkDerivation {
           name = "webdsl-webcheck-r${toString webdslSrc.rev}";
-          buildInputs = [pkgs.apacheAntOpenJDK pkgs.jdk pkgs.firefox13Pkgs.firefox webdsl];
+          buildInputs = [pkgs.apacheAntOpenJDK pkgs.openjdk pkgs.firefox13Pkgs.firefox webdsl];
           buildCommand = ''
             ensureDir $out
             cp -R ${webdslSrc}/test/succeed-web succeed-web

From m.dejonge at tudelft.nl  Sun Aug 26 20:31:20 2012
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Sun, 26 Aug 2012 18:31:20 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25276 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection
Message-ID: <20120826183120.4D9E5108C005@mx3.tudelft.nl>

Author: MaartjeDeJonge
Date: Sun Aug 26 18:31:19 2012
New Revision: 25276
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25276&sc=1

Log:


Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DamagedTokenAnalyzer.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/LCS.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TerminalEditsAnalyzer.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DamagedTokenAnalyzer.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DamagedTokenAnalyzer.java	Sat Aug 25 19:45:54 2012	(r25275)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DamagedTokenAnalyzer.java	Sun Aug 26 18:31:19 2012	(r25276)
@@ -84,7 +84,7 @@
 	public ArrayList<Integer> getOffsetsDeletions(IToken t) {
 		int startOffset = t.getStartOffset();
 		int endOffset = t.getEndOffset();
-		ArrayList<Integer> deletions = new ArrayList<Integer>();
+		ArrayList<Integer> deletions = new ArrayList<Integer>();		
 		for (int j = startOffset; j <= endOffset; j++) {
 			if(lcs.getMatchIndexInElems2(j) == -1){
 				deletions.add(j);
@@ -156,13 +156,42 @@
 	}
 	
 	private void analyzeDamagedTokens() {
+		//hack to improve the performance
+		ArrayList<Integer> lcsOffsets1 = lcs.getMatchedIndices1();
+		ArrayList<Integer> lcsOffsets2 = lcs.getMatchedIndices2();
+		int lengthMatchedPrefix = 0;
+		while(
+			lengthMatchedPrefix < lcs.getLCSSize() &&
+			lcsOffsets1.get(lengthMatchedPrefix) == lengthMatchedPrefix &&
+			lcsOffsets2.get(lengthMatchedPrefix) == lengthMatchedPrefix
+		)
+		{
+			lengthMatchedPrefix ++;
+		}
+
+		int lengthMatchedSuffix = 0;
+		int elems1Size = lcs.getElems1().size();
+		int elems2Size = lcs.getElems2().size();
+		while(
+			lengthMatchedSuffix < lcs.getLCSSize() &&
+			lcsOffsets1.get(lcs.getLCSSize() - 1 - lengthMatchedSuffix) == elems1Size - 1 - lengthMatchedSuffix &&
+			lcsOffsets2.get(lcs.getLCSSize() - 1 - lengthMatchedSuffix) == elems2Size - 1 - lengthMatchedSuffix
+		)
+		{
+			lengthMatchedSuffix ++;
+		}
+		
+
 		for (int i = 0; i < tokens.getTokenCount(); i++) {
 			IToken t = tokens.getTokenAt(i);
-			if (isDamagedByDeletion(t)){
-				tokensDamagedByDeletion.add(t);
-			}
-			if (isDamagedByInsertion(t)){
-				tokensDamagedByInsertion.add(t);
+			boolean possibleDamaged = t.getEndOffset() >= lengthMatchedPrefix -1 && t.getStartOffset() <= lcs.getElems1().size() - lengthMatchedSuffix + 1; //performance
+			if(possibleDamaged){
+				if (isDamagedByDeletion(t)){
+					tokensDamagedByDeletion.add(t);
+				}
+				if (isDamagedByInsertion(t)){
+					tokensDamagedByInsertion.add(t);
+				}
 			}
 		}
 	}

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/LCS.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/LCS.java	Sat Aug 25 19:45:54 2012	(r25275)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/LCS.java	Sun Aug 26 18:31:19 2012	(r25276)
@@ -84,7 +84,9 @@
 	 * @return
 	 */
 	public ArrayList<Integer> getMatchedIndices1() {
-		return matchedIndices1;
+		ArrayList<Integer> result = new ArrayList<Integer>();
+		result.addAll(matchedIndices1);
+		return result;
 	}
 
 	/**
@@ -92,7 +94,9 @@
 	 * @return
 	 */
 	public ArrayList<Integer> getMatchedIndices2() {
-		return matchedIndices2;
+		ArrayList<Integer> result = new ArrayList<Integer>();
+		result.addAll(matchedIndices2);
+		return result;
 	}
 
 	/**

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TerminalEditsAnalyzer.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TerminalEditsAnalyzer.java	Sat Aug 25 19:45:54 2012	(r25275)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/TerminalEditsAnalyzer.java	Sun Aug 26 18:31:19 2012	(r25276)
@@ -3,9 +3,7 @@
 import java.util.ArrayList;
 import java.util.Collections;
 
-import org.spoofax.jsglr.client.editregion.detection.LCS;
 import org.spoofax.jsglr.client.imploder.IToken;
-import org.spoofax.jsglr.client.imploder.ITokenizer;
 import org.spoofax.jsglr.client.imploder.Token;
 
 /**

From m.dejonge at tudelft.nl  Sun Aug 26 20:32:14 2012
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Sun, 26 Aug 2012 18:32:14 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25277 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test
Message-ID: <20120826183214.B2111CC126@mx4.tudelft.nl>

Author: MaartjeDeJonge
Date: Sun Aug 26 18:32:14 2012
New Revision: 25277
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25277&sc=1

Log:


Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditSequenceStratego.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditSequenceStratego.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditSequenceStratego.java	Sun Aug 26 18:31:19 2012	(r25276)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditSequenceStratego.java	Sun Aug 26 18:32:14 2012	(r25277)
@@ -20,8 +20,7 @@
 
 	@Test
 	public void test() throws FileNotFoundException, IOException {
-		//TODO: improve performance of DamagedTokenAnalyzer
-		//TODO: look at LCS algorithms, prevent LCS on too large sequence
+		//TODO: improve LCS algorithms, LCS on fragments (separated by newline)
 		
 		lastErr0AST = null;
 		String path = "tests-editregions/stratego/edit-sequence";

From m.dejonge at tudelft.nl  Mon Aug 27 07:20:42 2012
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Mon, 27 Aug 2012 05:20:42 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25278 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection
Message-ID: <20120827052042.DE757108C004@mx3.tudelft.nl>

Author: MaartjeDeJonge
Date: Mon Aug 27 05:20:41 2012
New Revision: 25278
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25278&sc=1

Log:
improv

Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DamagedTokenAnalyzer.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/LCS.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DamagedTokenAnalyzer.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DamagedTokenAnalyzer.java	Sun Aug 26 18:32:14 2012	(r25277)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/DamagedTokenAnalyzer.java	Mon Aug 27 05:20:41 2012	(r25278)
@@ -156,35 +156,12 @@
 	}
 	
 	private void analyzeDamagedTokens() {
-		//hack to improve the performance
-		ArrayList<Integer> lcsOffsets1 = lcs.getMatchedIndices1();
-		ArrayList<Integer> lcsOffsets2 = lcs.getMatchedIndices2();
-		int lengthMatchedPrefix = 0;
-		while(
-			lengthMatchedPrefix < lcs.getLCSSize() &&
-			lcsOffsets1.get(lengthMatchedPrefix) == lengthMatchedPrefix &&
-			lcsOffsets2.get(lengthMatchedPrefix) == lengthMatchedPrefix
-		)
-		{
-			lengthMatchedPrefix ++;
-		}
-
-		int lengthMatchedSuffix = 0;
-		int elems1Size = lcs.getElems1().size();
-		int elems2Size = lcs.getElems2().size();
-		while(
-			lengthMatchedSuffix < lcs.getLCSSize() &&
-			lcsOffsets1.get(lcs.getLCSSize() - 1 - lengthMatchedSuffix) == elems1Size - 1 - lengthMatchedSuffix &&
-			lcsOffsets2.get(lcs.getLCSSize() - 1 - lengthMatchedSuffix) == elems2Size - 1 - lengthMatchedSuffix
-		)
-		{
-			lengthMatchedSuffix ++;
-		}
-		
-
 		for (int i = 0; i < tokens.getTokenCount(); i++) {
 			IToken t = tokens.getTokenAt(i);
-			boolean possibleDamaged = t.getEndOffset() >= lengthMatchedPrefix -1 && t.getStartOffset() <= lcs.getElems1().size() - lengthMatchedSuffix + 1; //performance
+			//hack to improve the performance
+			boolean possibleDamaged = 
+				t.getEndOffset() >= lcs.getMatchedPrefixSize() - 1 && 
+				t.getStartOffset() <= lcs.getElems1().size() - lcs.getMatchedSuffixSize() + 1; 
 			if(possibleDamaged){
 				if (isDamagedByDeletion(t)){
 					tokensDamagedByDeletion.add(t);

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/LCS.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/LCS.java	Sun Aug 26 18:32:14 2012	(r25277)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/LCS.java	Mon Aug 27 05:20:41 2012	(r25278)
@@ -12,19 +12,26 @@
 public class LCS<T> {
 	
 	private final LCSCommand<T> lcsCommand;
-	private List<T> elems1;
-	private List<T> elems2;
+	private ArrayList<T> elems1;
+	private ArrayList<T> elems2;
 	private ArrayList<Integer> matchedIndices1;
 	private ArrayList<Integer> matchedIndices2;
+	
+	private ArrayList<Integer> unMatchedIndices1;
+	private ArrayList<Integer> unMatchedIndices2;
+	private ArrayList<T> resultLCS1;
+	private ArrayList<T> resultLCS2;
+	private ArrayList<T> resultUnmatched1;
+	private ArrayList<T> resultUnmatched2;
+	private int matchedPrefixSize;
+	private int matchedSuffixSize;
 
 	/**
 	 * Returns the elements of the first input list
 	 * @return 
 	 */
 	public ArrayList<T> getElems1() {
-		ArrayList<T> result = new ArrayList<T>();
-		result.addAll(elems1);
-		return result;
+		return elems1;
 	}
 
 	/**
@@ -32,9 +39,7 @@
 	 * @return
 	 */
 	public ArrayList<T> getElems2() {
-		ArrayList<T> result = new ArrayList<T>();
-		result.addAll(elems2);
-		return result;
+		return elems2;
 	}
 	
 	/**
@@ -84,9 +89,7 @@
 	 * @return
 	 */
 	public ArrayList<Integer> getMatchedIndices1() {
-		ArrayList<Integer> result = new ArrayList<Integer>();
-		result.addAll(matchedIndices1);
-		return result;
+		return matchedIndices1;
 	}
 
 	/**
@@ -94,9 +97,7 @@
 	 * @return
 	 */
 	public ArrayList<Integer> getMatchedIndices2() {
-		ArrayList<Integer> result = new ArrayList<Integer>();
-		result.addAll(matchedIndices2);
-		return result;
+		return matchedIndices2;
 	}
 
 	/**
@@ -104,7 +105,10 @@
 	 * @return
 	 */
 	public ArrayList<Integer> getUnMatchedIndices1() {
-		return getUnmatchedIndices(elems1, matchedIndices1);
+		if(unMatchedIndices1 == null){
+			unMatchedIndices1 = getUnmatchedIndices(elems1, matchedIndices1);
+		}
+		return unMatchedIndices1;
 	}
 
 	/**
@@ -112,7 +116,10 @@
 	 * @return
 	 */
 	public ArrayList<Integer> getUnMatchedIndices2() {
-		return getUnmatchedIndices(elems2, matchedIndices2);
+		if(unMatchedIndices2 == null){
+			unMatchedIndices2 = getUnmatchedIndices(elems2, matchedIndices2);
+		}
+		return unMatchedIndices2;
 	}
 
 	/**
@@ -121,7 +128,10 @@
 	 * @return LCS elements for input 1
 	 */
 	public ArrayList<T> getResultLCS1() {
-		return getIncludedElems(elems1, matchedIndices1);
+		if(resultLCS1 == null){
+			resultLCS1 = getIncludedElems(elems1, matchedIndices1);
+		}
+		return resultLCS1;
 	}
 
 	/**
@@ -130,7 +140,10 @@
 	 * @return LCS elements for input 2
 	 */
 	public ArrayList<T> getResultLCS2() {
-		return getIncludedElems(elems2, matchedIndices2);
+		if(resultLCS2 == null){
+			resultLCS2 = getIncludedElems(elems2, matchedIndices2);
+		}
+		return resultLCS2;
 	}
 
 	/**
@@ -139,7 +152,10 @@
 	 * @return non-LCS elements for input 1
 	 */
 	public ArrayList<T> getResultUnmatched1() {
-		return getIncludedElems(elems1, getUnMatchedIndices1());
+		if(resultUnmatched1 == null){
+			resultUnmatched1 = getIncludedElems(elems1, getUnMatchedIndices1());
+		}
+		return resultUnmatched1;
 	}
 
 	/**
@@ -148,7 +164,10 @@
 	 * @return non-LCS elements for input 2
 	 */
 	public ArrayList<T> getResultUnmatched2() {
-		return getIncludedElems(elems2, getUnMatchedIndices2());
+		if(resultUnmatched2 == null){
+			resultUnmatched2 = getIncludedElems(elems2, getUnMatchedIndices2());
+		}
+		return resultUnmatched2;
 	}
 	
 	/**
@@ -160,6 +179,46 @@
 	}
 
 	/**
+	 * Returns the number of matched elements at the prefix
+	 * @return
+	 */
+	public int getMatchedPrefixSize(){
+		if(matchedPrefixSize == -1){
+			matchedPrefixSize = 0;
+			while(
+				matchedPrefixSize < getLCSSize() &&
+				matchedIndices1.get(matchedPrefixSize) == matchedPrefixSize &&
+				matchedIndices2.get(matchedPrefixSize) == matchedPrefixSize
+			)
+			{
+				matchedPrefixSize ++;
+			}
+		}
+		return matchedPrefixSize;
+	}
+
+	/**
+	 * Returns the number of matched elements at the suffix
+	 * @return
+	 */
+	public int getMatchedSuffixSize(){
+		if(matchedSuffixSize == -1){
+			matchedSuffixSize = 0;
+			int elems1Size = elems1.size();
+			int elems2Size = elems2.size();
+			while(
+				matchedSuffixSize < getLCSSize() &&
+				matchedIndices1.get(getLCSSize() - 1 - matchedSuffixSize) == elems1Size - 1 - matchedSuffixSize &&
+				matchedIndices2.get(getLCSSize() - 1 - matchedSuffixSize) == elems2Size - 1 - matchedSuffixSize
+			)
+			{
+				matchedSuffixSize ++;
+			}
+		}
+		return matchedSuffixSize;
+	}
+
+	/**
 	 * Finds the Longest Common Subsequence of two lists with elements
 	 * @param lcsCommand Implements the matching criterion
 	 */
@@ -168,7 +227,15 @@
 		elems2 = new ArrayList<T>();
 		matchedIndices1 = new ArrayList<Integer>();
 		matchedIndices2 = new ArrayList<Integer>();
+		unMatchedIndices1 = null;
+		unMatchedIndices2 = null;
+		resultLCS1 = null;
+		resultLCS2 = null;
+		resultUnmatched1 = null;
+		resultUnmatched2 = null;
 		this.lcsCommand = lcsCommand;
+		matchedPrefixSize = -1;
+		matchedSuffixSize = -1;
 	}
 			
 	/**
@@ -179,8 +246,8 @@
 	 */
 	public LCS<T> createLCSResultsOptimized(List<T> elems1, List<T> elems2) {
 		clearResults();
-		this.elems1 = elems1;
-		this.elems2 = elems2;
+		this.elems1.addAll(elems1);
+		this.elems2.addAll(elems2);
 		return createLCSResultsOptimized();
 	}
 	
@@ -191,8 +258,8 @@
 	 */
 	public LCS<T> createLCSResults(List<T> elems1, List<T> elems2) {
 		clearResults();
-		this.elems1 = elems1;
-		this.elems2 = elems2;
+		this.elems1.addAll(elems1);
+		this.elems2.addAll(elems2);
 		lcs(elems1, elems2, 0);
 		checkAssertions(elems1, elems2);
 		return this;
@@ -202,8 +269,18 @@
 // helper functions
 
 	private void clearResults(){
+		elems1.clear();
+		elems2.clear();
 		matchedIndices1.clear();
 		matchedIndices2.clear();
+		unMatchedIndices1 = null;
+		unMatchedIndices2 = null;
+		resultLCS1 = null;
+		resultLCS2 = null;
+		resultUnmatched1 = null;
+		resultUnmatched2 = null;
+		matchedPrefixSize = -1;
+		matchedSuffixSize = -1;
 	}
 
 	private ArrayList<Integer> getUnmatchedIndices(List<T> elems, ArrayList<Integer> indices) {

From m.dejonge at tudelft.nl  Mon Aug 27 07:44:54 2012
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Mon, 27 Aug 2012 05:44:54 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25279 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection
Message-ID: <20120827054454.BD30A7F8004@mx1.tudelft.nl>

Author: MaartjeDeJonge
Date: Mon Aug 27 05:44:54 2012
New Revision: 25279
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25279&sc=1

Log:


Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/LayoutEditsAnalyzer.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/LayoutEditsAnalyzer.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/LayoutEditsAnalyzer.java	Mon Aug 27 05:20:41 2012	(r25278)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/LayoutEditsAnalyzer.java	Mon Aug 27 05:44:54 2012	(r25279)
@@ -2,11 +2,8 @@
 
 import java.util.ArrayList;
 
-import org.spoofax.jsglr.client.editregion.detection.LCS;
 import org.spoofax.jsglr.client.imploder.IToken;
-import org.spoofax.jsglr.client.imploder.ITokenizer;
 import org.spoofax.jsglr.client.imploder.Token;
-import org.spoofax.jsglr.client.editregion.detection.DiscardableRegion;
 
 /**
  * Determines the comment regions that are edited and therefore (possible) damaged.

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java	Mon Aug 27 05:20:41 2012	(r25278)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java	Mon Aug 27 05:44:54 2012	(r25279)
@@ -10,7 +10,6 @@
 import org.spoofax.jsglr.client.imploder.ITokenizer;
 import org.spoofax.jsglr.client.imploder.ImploderAttachment;
 import org.spoofax.jsglr.client.imploder.Token;
-import org.spoofax.terms.attachments.ParentAttachment;
 
 /**
  * Represents a recovery based on discarding tokens associated to the term and/or its subterms.

From m.dejonge at tudelft.nl  Mon Aug 27 07:52:41 2012
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Mon, 27 Aug 2012 05:52:41 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25280 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test
Message-ID: <20120827055241.2CF58CC1C1@mx4.tudelft.nl>

Author: MaartjeDeJonge
Date: Mon Aug 27 05:52:40 2012
New Revision: 25280
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25280&sc=1

Log:


Added:
   spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionPerformanceConstraints.java   (contents, props changed)

Added: spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionPerformanceConstraints.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/test/org/spoofax/jsglr/client/editregion/test/TestEditRegionPerformanceConstraints.java	Mon Aug 27 05:52:40 2012	(r25280)
@@ -0,0 +1,24 @@
+package org.spoofax.jsglr.client.editregion.test;
+
+import static org.junit.Assert.*;
+
+import org.junit.Ignore;
+import org.junit.Test;
+
+public class TestEditRegionPerformanceConstraints {
+
+	@Test @Ignore
+	public void testPerformanceLargeEditRegion() {
+		fail("Not yet implemented");
+		//TODO: what if editing is done at the start AND at the end of a (large) file?
+		//Best would be to match lines before (in stead of) matching characters
+		//Alternatively, the application of the algorithm should be cancelled.
+	}
+
+	@Test @Ignore
+	public void testPerformanceMultipleEdits() {
+		fail("Not yet implemented");
+		//TODO: what if the correct file and the erroneous file are completely different?
+		//The application of the algorithm should be cancelled.		
+	}
+}

