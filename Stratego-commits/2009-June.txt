From L.C.L.Kats at tudelft.nl  Tue Jun  2 12:01:56 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Tue, 02 Jun 2009 10:01:56 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19502 - LennartKats -
	in spoofax-imp/trunk/org.strategoxt.imp.runtime: .
	src/org/strategoxt/imp/runtime/parser
	src/org/strategoxt/imp/runtime/parser/ast
	src/org/strategoxt/imp/runtime/parser/tokens
	src/org/strategoxt/imp/runtime/services
Message-ID: <200906021001.n52A12bd028990@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-06-02 10:01:55 +0000 (Tue, 02 Jun 2009)
New Revision: 19502

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19502&view=rev

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/Spoofax-IMP (with assertions).launch
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ParseErrorHandler.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/SGLRParseController.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AmbAsfixImploder.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/tokens/SGLRTokenizer.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoFeedback.java

Log:
- Some more parse error reporting fixes
- Re-enabled prefer/avoid filtering in the imploder for now

Changes:

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/Spoofax-IMP (with assertions).launch
===================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/Spoofax-IMP (with assertions).launch	2009-06-02 08:33:59 UTC (rev 19501)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/Spoofax-IMP (with assertions).launch	2009-06-02 10:01:55 UTC (rev 19502)
@@ -3,7 +3,7 @@
 <booleanAttribute key="append.args" value="true"/>
 <booleanAttribute key="askclear" value="true"/>
 <booleanAttribute key="automaticAdd" value="true"/>
-<booleanAttribute key="automaticValidate" value="true"/>
+<booleanAttribute key="automaticValidate" value="false"/>
 <stringAttribute key="bootstrap" value=""/>
 <stringAttribute key="checked" value="[NONE]"/>
 <booleanAttribute key="clearConfig" value="false"/>

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ParseErrorHandler.java
===================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ParseErrorHandler.java	2009-06-02 08:33:59 UTC (rev 19501)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ParseErrorHandler.java	2009-06-02 10:01:55 UTC (rev 19502)
@@ -44,7 +44,12 @@
 	}
 	
 	public void clearErrors() {
-		messages.clearMessages();
+		try {
+			messages.clearMessages();
+		} catch (RuntimeException e) {
+			// Might happen if editor is closed
+			Environment.logException("Exception occurred in clearing error markers", e);
+		}
 		handler.clearMarkers(sourceInfo.getResource());
 	}
 	
@@ -75,13 +80,7 @@
 	private void reportOnRepairedCode(SGLRTokenizer tokenizer, ATerm term) {
 		// TODO: Nicer error messages; merge consecutive error tokens etc.
 		
-		// TODO: Report error for INSERTEND tokens
-		
-		// TODO: Try using constructor matching to recognize WATER tokens..?
-		//       (which wasn't working before...)
-		
 		if ("amb".equals(((ATermAppl) term).getAFun().getName())) {
-			
 			for (ATermList cons = (ATermList) term.getChildAt(0); !cons.isEmpty(); cons = cons.getNext()) {
 				reportOnRepairedCode(tokenizer, cons.getFirst());
 			}
@@ -92,17 +91,8 @@
 		ATermAppl rhs = termAt(prod, 1);
 		ATermAppl attrs = termAt(prod, 2);
 		ATermList contents = termAt(term, 1);
-		boolean isWaterTerm = isErrorProduction(attrs, WATER);	//isWater(rhs);
-		boolean isInsertTerm = isErrorProduction(attrs, INSERT);	
-		boolean isEndInsertTerm = isErrorProduction(attrs, INSERT_END);	
-		int beginErrorOffSet = 0;		
+		int beginErrorOffSet = offset;
 		
-		//pre visit: keep offset as begin of error
-		if(isWaterTerm || isInsertTerm || isEndInsertTerm)
-        { 
-        	beginErrorOffSet = offset;        	
-        }
-		
 		// Recurse the tree and update the offset
 		for (int i = 0; i < contents.getLength(); i++) {
 			ATerm child = contents.elementAt(i);
@@ -114,15 +104,13 @@
 		}
 		
 		//post visit: report error				
-		if (isWaterTerm) {
+		if (isErrorProduction(attrs, WATER)) {
 			IToken token = tokenizer.makeErrorToken(beginErrorOffSet, offset - 1);
 			reportErrorAtTokens(token, token, "'" + token + "' not expected here");
-		}
-		if (isEndInsertTerm) {
+		} else if (isErrorProduction(attrs, INSERT_END)) {
 			IToken token = tokenizer.makeErrorToken(beginErrorOffSet, offset - 1);
 			reportErrorAtTokens(token, token, "Closing of '" + token + "' is expected here");
-		}
-		if (isInsertTerm) {
+		} else if (isErrorProduction(attrs, INSERT)) {
 			IToken token = tokenizer.makeErrorTokenSkipLayout(beginErrorOffSet, offset + 1);
 			String inserted = "";
 			if (rhs.getName() == "lit") {
@@ -143,23 +131,21 @@
 	public void reportError(SGLRTokenizer tokenizer, BadTokenException exception) {
 		IToken token = tokenizer.makeErrorToken(exception.getOffset());
 		String message = exception.isEOFToken()
-        	? exception.getShortMessage()
-        	: "'" + token + "' not expected here";
-        	reportErrorAtTokens(token, token, message);
+			? exception.getShortMessage()
+			: "'" + token + "' not expected here";
+		reportErrorAtTokens(token, token, message);
 	}
 	
 	public void reportError(SGLRTokenizer tokenizer, ParseTimeoutException exception) {
 		Environment.logException(exception);
-		reportError(tokenizer, (BadTokenException) exception);
+		String message = "Internal parsing error: " + exception.getMessage();
+		reportErrorAtFirstLine(message);
 	}
 	 
 	public void reportError(SGLRTokenizer tokenizer, Exception exception) {
 		String message = "Internal parsing error: " + exception;
-		IToken token = tokenizer.makeErrorToken(0);
-		
 		Environment.logException("Internal parsing error", exception);
-		
-		reportErrorAtTokens(token, token, message);
+		reportErrorAtFirstLine(message);
 	}
 	
 	private void reportErrorAtTokens(IToken left, IToken right, String message) {
@@ -173,6 +159,13 @@
 			message += " (recovery unavailable)";
 		
 		handler.addMarker(sourceInfo.getResource(), left, right, message, IMarker.SEVERITY_ERROR);
+	}
+	
+	private void reportErrorAtFirstLine(String message) {
+		if (!isRecoveryEnabled)
+			message += " (recovery unavailable)";
+		
+		handler.addMarkerFirstLine(sourceInfo.getResource(), message, IMarker.SEVERITY_ERROR);
 	}	
 	
 	private static boolean isErrorProduction(ATermAppl attrs, String consName) {		

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/SGLRParseController.java
===================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/SGLRParseController.java	2009-06-02 08:33:59 UTC (rev 19501)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/SGLRParseController.java	2009-06-02 10:01:55 UTC (rev 19502)
@@ -157,9 +157,10 @@
 			
 			char[] inputChars = input.toCharArray();
 				
-			currentAst = parser.parse(inputChars, filename);
-			
 			if (monitor.isCanceled()) return null;
+                        currentAst = parser.parse(inputChars, filename);			
+			if (monitor.isCanceled()) return null;
+			// For error handling, retrieve the cached, unimploded asfix tree
 			asfix = parser.parseNoImplode(inputChars, filename);
 			if (monitor.isCanceled()) return null;
 			

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AmbAsfixImploder.java
===================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AmbAsfixImploder.java	2009-06-02 08:33:59 UTC (rev 19501)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AmbAsfixImploder.java	2009-06-02 10:01:55 UTC (rev 19502)
@@ -8,6 +8,7 @@
 
 import aterm.ATerm;
 import aterm.ATermAppl;
+import aterm.ATermList;
 import aterm.pure.ATermListImpl;
 
 /**
@@ -58,8 +59,7 @@
 	 */
 	@Override
 	protected ATermAppl resolveAmbiguities(ATerm node) {
-		return (ATermAppl) node;
-		/* UNDONE: prefer/avoid disambiguation in imploder
+		// TODO: disable when prefer/avoid disambiguation works in Disambiguator
 		if (!"amb".equals(((ATermAppl) node).getName()))
 			return (ATermAppl) node;
 		
@@ -95,7 +95,6 @@
 		return ambs.getLength() == 1
 				? (ATermAppl) ambs.getSubTerm(0)
 				: (ATermAppl) node;
-		*/
 	}
 	
 }

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/tokens/SGLRTokenizer.java
===================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/tokens/SGLRTokenizer.java	2009-06-02 08:33:59 UTC (rev 19501)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/tokens/SGLRTokenizer.java	2009-06-02 10:01:55 UTC (rev 19502)
@@ -128,17 +128,31 @@
 	 * Creates an error token on stream part
 	 */
 	public IToken makeErrorToken(int beginOffset, int endOffset) {		
+		if (endOffset >= lexStream.getStreamLength()) {
+			endOffset = lexStream.getStreamLength() - 1;
+			beginOffset = Math.min(beginOffset, endOffset);
+		}
+
 		return new Token(parseStream, beginOffset, endOffset, TK_ERROR.ordinal());
 	}
 	
 	/**
 	 * Creates an error token on stream part, backwards skipping whitespace
 	 */
-	public IToken makeErrorTokenSkipLayout(int beginOffset, int endOffset) {		
-		int skipLength =0;
-		while (isWhitespaceChar(beginOffset-skipLength-1) && beginOffset-skipLength>0) {
-			skipLength++;
+	public IToken makeErrorTokenSkipLayout(int beginOffset, int endOffset) {
+		if (endOffset >= lexStream.getStreamLength()) {
+			endOffset = lexStream.getStreamLength() - 1;
+			beginOffset = Math.min(beginOffset, endOffset);
 		}
+
+		int skipLength;
+		
+		for (skipLength = 0; beginOffset - skipLength > 0; skipLength++) {
+			char c = lexStream.getCharValue(beginOffset - skipLength - 1);
+			if (!Character.isWhitespace(c) || c == '\n')
+				break;
+		}
+		
 		return makeErrorToken(beginOffset-skipLength, endOffset-skipLength);
 	}
 	

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoFeedback.java
===================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoFeedback.java	2009-06-02 08:33:59 UTC (rev 19501)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoFeedback.java	2009-06-02 10:01:55 UTC (rev 19502)
@@ -228,6 +228,9 @@
 	 * @see #getAstNode(IStrategoTerm)  To retrieve the AST node associated with the resulting term.
 	 */
 	public IStrategoTerm invoke(String function, IStrategoTerm term, ISourceInfo sourceInfo) {
+		if (interpreter == null)
+			return null;
+		
 		synchronized (Environment.getSyncRoot()) {
 		    Debug.startTimer();
 		    boolean success;



From L.C.L.Kats at tudelft.nl  Tue Jun  2 12:04:21 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Tue, 02 Jun 2009 10:04:21 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19503 - LennartKats -
	spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
Message-ID: <200906021003.n52A3Sd7029034@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-06-02 10:04:21 +0000 (Tue, 02 Jun 2009)
New Revision: 19503

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19503&view=rev

Modified:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Disambiguator.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Frame.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Link.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParseTimeoutException.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java

Log:
- Always initialize the recover handler
- Disabled filterPriorities by default for now
- ...


Changes:

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Disambiguator.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Disambiguator.java	2009-06-02 10:01:55 UTC (rev 19502)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Disambiguator.java	2009-06-02 10:04:21 UTC (rev 19503)
@@ -141,8 +141,8 @@
     }
     
     public final void setDefaultFilters() {
-        filterAny = true;        
-        filterCycles = false; // TODO: filterCycles true by default        
+        filterAny = false;        
+        filterCycles = false; // TODO: filterCycles
         filterDirectPreference = true;        
         filterIndirectPreference = false;        
         filterPreferenceCount = false;        
@@ -150,7 +150,7 @@
         filterTopSort = true;        
         filterReject = true;
         filterAssociativity = true;
-        filterPriorities = true;
+        filterPriorities = false; // XXX: filterPriorities true by default when no longer borked
     }
     
     public Disambiguator() {
@@ -306,7 +306,16 @@
                 List<IParseNode> ambs = ((Amb)t).getAlternatives();
                 t = filterAmbiguities(ambs);
             } else {
-                throw new NotImplementedException();
+            	// TODO: Test me?
+                if (filterReject && parseTable.hasRejects() && hasRejectProd(t)) {
+                    return null;
+                }
+                List<IParseNode> ambs = ((Amb) t).getAlternatives();
+                ambs = filterTree(ambs, false);
+                
+                if (ambs == null) return null;
+                
+                return new Amb(ambs);
             }
         } else if(t instanceof ParseNode) {
             ParseNode node = (ParseNode) t;
@@ -516,6 +525,16 @@
         // - not ok
         
         throw new NotImplementedException();
+        /*
+        if (ATisEqual(t, injT)) {
+           return newTree;
+        } else {
+          ATermList sons = (ATermList)ATgetArgument((ATerm) t, 1);
+          tree newSon = SG_Replace_Under_Injections((tree)ATgetFirst(sons), 
+                                                    injT, newTree);
+          return ATsetArgument((ATermAppl)t, (ATerm)ATmakeList1((ATerm)newSon), 1);
+        }
+        */
     }
 
     private IParseNode jumpOverInjections(IParseNode t) {

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Frame.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Frame.java	2009-06-02 10:01:55 UTC (rev 19502)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Frame.java	2009-06-02 10:04:21 UTC (rev 19503)
@@ -9,7 +9,9 @@
 
 import java.io.Serializable;
 import java.util.ArrayList;
+import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.WeakHashMap;
 
 
 public class Frame implements Serializable {
@@ -225,7 +227,7 @@
                         SGLR.TRACE("SG_ - l0 == l1");
                     }
                     return true;
-                } else if (l1.parent.findLink(arity - 1, l0)) {
+                } else if (arity > 1 && l1.parent.findLink(arity - 1, l0)) {
                     if(Tools.tracing) {
                         SGLR.TRACE("SG_ - findlink");
                     }

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Link.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Link.java	2009-06-02 10:01:55 UTC (rev 19502)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Link.java	2009-06-02 10:04:21 UTC (rev 19503)
@@ -12,7 +12,7 @@
 
     public static int linksCreated =0; //mj Testing
     
-    public Frame parent;
+    protected Frame parent;
 
     protected IParseNode label;
 

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParseTimeoutException.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParseTimeoutException.java	2009-06-02 10:01:55 UTC (rev 19502)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParseTimeoutException.java	2009-06-02 10:04:21 UTC (rev 19503)
@@ -8,6 +8,11 @@
 public class ParseTimeoutException extends BadTokenException {
     private static final long serialVersionUID = -8773024983956495431L;
 
+    @Override
+    public String getShortMessage() {
+        return "Parser time out";
+    }
+    
     public ParseTimeoutException(SGLR parser, int token, int offset, int lineNumber, int columnNumber) {
         super(parser, token, offset, lineNumber, columnNumber);
     }

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-06-02 10:01:55 UTC (rev 19502)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-06-02 10:04:21 UTC (rev 19503)
@@ -130,6 +130,7 @@
     
     public void setRecoverHandler(RecoverAlgorithm recoverHandler) {
         this.recoverHandler = recoverHandler;
+        recoverHandler.initialize(this);
     }
     
     public RecoveryBase getRecoverHandler() {
@@ -369,8 +370,7 @@
     private void parseCharacter() throws IOException {
         logBeforeParseCharacter();
 
-        ArrayDeque<Frame> actives = new ArrayDeque<Frame>();
-        actives.addAll(activeStacks); // FIXME avoid garbage        
+        ArrayDeque<Frame> actives = new ArrayDeque<Frame>(activeStacks); // FIXME avoid garbage        
         clearForActorDelayed(false);
         clearForShifter(false);
         while (actives.size() > 0 || forActor.size() > 0) {



From L.C.L.Kats at tudelft.nl  Tue Jun  2 17:40:53 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Tue, 02 Jun 2009 15:40:53 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19505 - LennartKats -
	in sglr-recovery/trunk: . other-parsers other-parsers/src
	other-parsers/src/sglrbridges
	other-parsers/src/sglrbridges/otherparsers
Message-ID: <200906021539.n52FdxSx001814@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-06-02 15:40:53 +0000 (Tue, 02 Jun 2009)
New Revision: 19505

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19505&view=rev

Added:
   sglr-recovery/trunk/other-parsers/
   sglr-recovery/trunk/other-parsers/.classpath
   sglr-recovery/trunk/other-parsers/.project
   sglr-recovery/trunk/other-parsers/src/
   sglr-recovery/trunk/other-parsers/src/sglrbridges/
   sglr-recovery/trunk/other-parsers/src/sglrbridges/otherparsers/
   sglr-recovery/trunk/other-parsers/src/sglrbridges/otherparsers/JDTParser.java
   sglr-recovery/trunk/other-parsers/src/sglrbridges/otherparsers/LPGParser.java
   sglr-recovery/trunk/other-parsers/src/sglrbridges/otherparsers/LPGToATerm.java

Log:
Added project for invoking other people's parsers.

Changes:

Added: sglr-recovery/trunk/other-parsers/.classpath
===================================================================
--- sglr-recovery/trunk/other-parsers/.classpath	                        (rev 0)
+++ sglr-recovery/trunk/other-parsers/.classpath	2009-06-02 15:40:53 UTC (rev 19505)
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/org.spoofax.interpreter.adapter.ecj"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/org.eclipse.imp.lpg.runtime"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/lpg.runtime.java"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/org.eclipse.imp.runtime"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>

Added: sglr-recovery/trunk/other-parsers/.project
===================================================================
--- sglr-recovery/trunk/other-parsers/.project	                        (rev 0)
+++ sglr-recovery/trunk/other-parsers/.project	2009-06-02 15:40:53 UTC (rev 19505)
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>other-parsers</name>
+	<comment></comment>
+	<projects>
+		<project>org.eclipse.imp.lpg.runtime</project>
+		<project>org.spoofax.interpreter.adapter.ecj</project>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>

Added: sglr-recovery/trunk/other-parsers/src/sglrbridges/otherparsers/JDTParser.java
===================================================================
--- sglr-recovery/trunk/other-parsers/src/sglrbridges/otherparsers/JDTParser.java	                        (rev 0)
+++ sglr-recovery/trunk/other-parsers/src/sglrbridges/otherparsers/JDTParser.java	2009-06-02 15:40:53 UTC (rev 19505)
@@ -0,0 +1,19 @@
+package sglrbridges.otherparsers;
+
+import java.io.IOException;
+
+import org.spoofax.ecjadapter.ParseJava;
+import org.spoofax.interpreter.core.InterpreterException;
+
+/**
+ * A convenience class for parsing with the JDT.
+ * 
+ * @see ParseJava
+ * 
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class JDTParser extends ParseJava  {
+	public static void main(String[] args) throws IOException, InterpreterException {
+		ParseJava.main(args);
+	}
+}

Added: sglr-recovery/trunk/other-parsers/src/sglrbridges/otherparsers/LPGParser.java
===================================================================
--- sglr-recovery/trunk/other-parsers/src/sglrbridges/otherparsers/LPGParser.java	                        (rev 0)
+++ sglr-recovery/trunk/other-parsers/src/sglrbridges/otherparsers/LPGParser.java	2009-06-02 15:40:53 UTC (rev 19505)
@@ -0,0 +1,33 @@
+package sglrbridges.otherparsers;
+
+import lpg.runtime.IAst;
+
+import org.eclipse.imp.lpg.parser.JavaLexer;
+import org.eclipse.imp.lpg.parser.JavaParser;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class LPGParser {
+	
+	public static void main(String[] args) throws Exception {
+		if (args.length != 2 || !"-i".equals(args[0])) {
+			System.err.println("Usage: LPGParser -i <file>");
+			System.exit(1);
+		}
+		
+		JavaLexer lexer = new JavaLexer(args[1]);
+		JavaParser parser = new JavaParser();
+
+		parser.reset(lexer.getLexStream());
+		lexer.lexer(parser.getParseStream());
+		
+		IAst ast = parser.parser();
+		
+		if (ast == null) {
+			System.out.println("null");
+		} else {	
+			System.out.println(LPGToATerm.toString(ast));
+		}
+	}
+}

Added: sglr-recovery/trunk/other-parsers/src/sglrbridges/otherparsers/LPGToATerm.java
===================================================================
--- sglr-recovery/trunk/other-parsers/src/sglrbridges/otherparsers/LPGToATerm.java	                        (rev 0)
+++ sglr-recovery/trunk/other-parsers/src/sglrbridges/otherparsers/LPGToATerm.java	2009-06-02 15:40:53 UTC (rev 19505)
@@ -0,0 +1,65 @@
+package sglrbridges.otherparsers;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+import lpg.runtime.IAst;
+
+import org.eclipse.imp.lpg.parser.JavaParser.AstToken;
+import org.eclipse.imp.lpg.parser.JavaParser.ILiteral;
+import org.eclipse.imp.lpg.parser.JavaParser.INumericType;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class LPGToATerm {
+	public static String toString(IAst ast) {
+		StringBuilder result = new StringBuilder();
+		toString(ast, result);
+		return result.toString();
+	}
+	
+	private static void toString(IAst ast, StringBuilder result) {		
+		if (ast instanceof INumericType || ast instanceof ILiteral) {
+			// TODO: do something different for literals?
+			applToString(ast, result);
+		} else {
+			applToString(ast, result);
+		}
+	}
+
+	private static void applToString(IAst ast, StringBuilder result) {
+		result.append(ast.getClass().getSimpleName());
+		result.append("([");
+		
+		ArrayList<?> children = ast.getChildren();
+		// removeTokens(children);
+		
+		if (children.size() == 0) {
+			// toString != getClass().getName() + "@" + Integer.toHexString(hashCode())?
+			result.append('"');
+			result.append(ast);
+			result.append('"');
+		} else {
+			toString((IAst) children.get(0), result);
+			for (int i = 1, size = children.size(); i < size; i++) {
+				result.append(',');
+				toString((IAst) children.get(i), result);
+			}
+		}
+		
+		result.append("])");
+	}
+	
+	/*
+	private static<T> void removeTokens(List<T> nodes) {
+		Iterator<T> it = nodes.iterator();
+		while (it.hasNext()) {
+			T node = it.next();
+			if (node instanceof AstToken)
+				it.remove();
+		}
+	}
+	*/
+}



From zef at zefhemel.com  Wed Jun  3 11:03:27 2009
From: zef at zefhemel.com (Zef Hemel)
Date: Wed, 03 Jun 2009 09:03:27 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19506 - zef -
	pil/trunk/src/lib/db
Message-ID: <200906030902.n5392Wu4015035@proliant.st.ewi.tudelft.nl>

Author: zef
Date: 2009-06-03 09:03:27 +0000 (Wed, 03 Jun 2009)
New Revision: 19506

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19506&view=rev

Modified:
   pil/trunk/src/lib/db/collection.pil
   pil/trunk/src/lib/db/db.pil
   pil/trunk/src/lib/db/model.pil
   pil/trunk/src/lib/db/query.pil
   pil/trunk/src/lib/db/test.pil
   pil/trunk/src/lib/db/util.pil

Log:
Prefetch fixes


Changes:

Modified: pil/trunk/src/lib/db/collection.pil
===================================================================
--- pil/trunk/src/lib/db/collection.pil	2009-06-02 15:40:53 UTC (rev 19505)
+++ pil/trunk/src/lib/db/collection.pil	2009-06-03 09:03:27 UTC (rev 19506)
@@ -87,6 +87,7 @@
   }
 
   List<T> list(DatabaseSession session) {
+    filter = new AndFilter(filter, new PropertyFilter(inverseField, "=", self.id));
     return super.list(session);
   }
 
@@ -110,22 +111,15 @@
   }
 }
 
-class pil::db::model::ManyToOne<T> {
-  Entity self = null;
-  Class cls = null;
-  String inverseField = null;
-
+class pil::db::model::ManyToOne<T> extends OneToOne<T> {
   T value = null;
   String id = null;
 
-  new(Entity self, Class cls, String inverseField) {
-    this.self = self;
-    this.cls = cls;
-    this.inverseField = inverseField;
+  new(Entity self, Class cls, String inverseField) extends super(self, cls, inverseField) {
   }
 
   void set(T value, DatabaseSession session) {
-    if(value == this.value) {
+    if(value == this.value && id != null) {
       return;
     }
     // First set old inverse relation thing to null, if the value wasn't null before

Modified: pil/trunk/src/lib/db/db.pil
===================================================================
--- pil/trunk/src/lib/db/db.pil	2009-06-02 15:40:53 UTC (rev 19505)
+++ pil/trunk/src/lib/db/db.pil	2009-06-03 09:03:27 UTC (rev 19506)
@@ -14,6 +14,7 @@
   Dialect dialect = null;
   Connection conn = null;
   Set<Entity> trackEntities = new Set<Entity>();
+  Int queryCounter = 0;
 
   new(Connection conn, Dialect dialect) {
     this.conn = conn;
@@ -29,17 +30,21 @@
     }
     println("]");
     */
+    queryCounter = queryCounter + 1;
     conn.updateQuery(sql, args);
   }
 
   List<Result> queryWithArgs(String sql, Array<Object> args) {
     println(sql);
+    /*
     var l = new List<Object>();
     for(Object o : args) {
       l.add(o);
     }
     print("Arguments: ");
     println(l);
+    */
+    queryCounter = queryCounter + 1;
     return conn.query(sql, args);
   }
 
@@ -120,7 +125,6 @@
     var o = cls.newInstance().as<Entity>;
     var counter = fieldOffset + 1;
     o.id = r.getString(fieldOffset);
-    println("Just read: " + o.id);
     for(FieldMapping f : mapping.fieldMappings) {
       if(f instanceof OneToOneFieldMapping) {
         getObjectField(o, f.fieldName).as<OneToOne<Object>>.setId(r.getString(counter));

Modified: pil/trunk/src/lib/db/model.pil
===================================================================
--- pil/trunk/src/lib/db/model.pil	2009-06-02 15:40:53 UTC (rev 19505)
+++ pil/trunk/src/lib/db/model.pil	2009-06-03 09:03:27 UTC (rev 19506)
@@ -145,16 +145,15 @@
   }
 }
 
-class pil::db::model::ManyToOneFieldMapping extends pil::db::model::FieldMapping {
-  Class cls = null;
-
-  new(String fieldName, Class cls) extends super(fieldName) {
-    this.cls = cls;
+class pil::db::model::ManyToOneFieldMapping extends pil::db::model::OneToOneFieldMapping {
+  new(String fieldName, Class cls) extends super(fieldName, cls) {
   }
 
+  /*
   String createSQL(Dialect dialect) {
     var foreignTable = classMappings[cls].tableName;
     return "`" + fieldName + "` " + dialect.getType(stringType, 36) + " DEFAULT NULL"; //, " +
            //"FOREIGN KEY (`" + fieldName + "`) REFERENCES `" + foreignTable + "`(`id`) ";
   }
+  */
 }

Modified: pil/trunk/src/lib/db/query.pil
===================================================================
--- pil/trunk/src/lib/db/query.pil	2009-06-02 15:40:53 UTC (rev 19505)
+++ pil/trunk/src/lib/db/query.pil	2009-06-03 09:03:27 UTC (rev 19506)
@@ -74,6 +74,7 @@
     var joinSql = "";
 
     for(String prefetchField : prefetchFields) {
+      println("Prefetch field: " + prefetchField);
       if(mapping.fields[prefetchField] instanceof SimpleReferenceFieldMapping) {
         var cls2 = mapping.fields[prefetchField].as<SimpleReferenceFieldMapping>.cls;
         var mapping2 = classMappings[cls2];
@@ -90,15 +91,17 @@
     var results = new List<T>();
     for(Result r : session.queryWithArgs(sql, args.as<Array<Object>>)) {
       var e = session.resultToEntity(cls, r, 0);
-      var offset = mapping.fieldMappings.length;
+      var offset = countSelectFields(mapping.fieldMappings);
       for(String prefetchField : prefetchFields) {
-        var cls2 = mapping.fields[prefetchField].as<SimpleReferenceFieldMapping>.cls;
-        var mapping2 = classMappings[cls2];
-        var e2 = session.resultToEntity(cls2, r, offset);
-        SimpleReference<Object> sr = getObjectField(e, prefetchField).as<SimpleReference<Object>>;
-        sr.id = e2.id;
-        sr.value = e2;
-        offset = offset + mapping2.fieldMappings.length;
+        if(mapping.fields[prefetchField] instanceof SimpleReferenceFieldMapping) {
+          var cls2 = mapping.fields[prefetchField].as<SimpleReferenceFieldMapping>.cls;
+          var mapping2 = classMappings[cls2];
+          var e2 = session.resultToEntity(cls2, r, offset);
+          SimpleReference<Object> sr = getObjectField(e, prefetchField).as<SimpleReference<Object>>;
+          sr.id = e2.id;
+          sr.value = e2;
+          offset = offset + countSelectFields(mapping2.fieldMappings);
+        }
       }
       results.add(e.as<T>);
     }

Modified: pil/trunk/src/lib/db/test.pil
===================================================================
--- pil/trunk/src/lib/db/test.pil	2009-06-02 15:40:53 UTC (rev 19505)
+++ pil/trunk/src/lib/db/test.pil	2009-06-03 09:03:27 UTC (rev 19506)
@@ -111,12 +111,34 @@
   session.flush();
 
   var u2 = session.get(typeof User, u.id).as<User>;
-  println("u2 id: " + u2.id);
   var messages = u2.messages.list(session);
   assertEqual(messages.length, 1, "number of messages check");
-  for(Message m2 : messages) {
-    assertEqual(m2.id, m.id, "message id check");
+  assertEqual(messages[0].id, m.id, "message id check");
+  println(messages[0].sender.get(session));
+  messages[0].sender.set(null, session);
+  session.flush();
+  messages = u2.messages.list(session);
+  assertEqual(messages.length, 0, "check message removed");
+}
+
+void testPrefetch(DatabaseSession session) {
+  println("Testing prefetch");
+  var u = new User();
+  u.name = "User 1";
+  session.add(u);
+  for(Int i = 0; i < 25; i++) {
+    var m = new Message();
+    m.message = "Message " + i.as<String>;
+    m.sender.set(u, session);
+    session.add(m);
   }
+  session.flush();
+  var q = new QuerySet<Message>(typeof Message).prefetch("sender");
+  var qc = session.queryCounter;
+  for(Message m : q.list(session)) {
+    println(m.sender.get(session).name + ": " + m.message);
+  }
+  assertEqual(session.queryCounter, qc+1, "check query count");
 }
 
 void main(Array<String> args) {
@@ -135,46 +157,9 @@
   testOneToOne(session);
   cleanup(session);
   testOneToMany(session);
+  cleanup(session);
+  testPrefetch(session);
   reportTestResults();
-  /*
-
-  var zef = new User();
-  zef.name = "Zef Hemel";
-  zef.age = 25;
-  zef.bio = "He's a nice guy.";
-  session.add(zef);
-  zef.age = 26;
-  var zefAddr = new Address();
-  zefAddr.street = "Chopinplein";
-  zefAddr.number = 64;
-  zef.address.set(zefAddr, session);
-  var m = new Message();
-  m.message = "Just got up.";
-  zef.messages.add(m, session);
-  session.add(m);
-  println("Now flushing.");
-  session.flush();
-  for(Message message : session.all(typeof Message)) {
-    if(message.sender.get(session) != null) {
-      println(message.sender.get(session).name + ": " + message.message);
-      message.sender.get(session).age = message.sender.get(session).age + 1;
-    } else {
-      println("<unkown>: " + message.message);
-    }
-    //message.sender.set(null, session);
-  }
-  //zef.address.set(null, session);
-  println("Now flushing again.");
-  session.flush();
-  println("All users where age < 10 or age > 25 order descending by age:");
-  var q = new QuerySet<User>(typeof User).filter(new OrFilter(new PropertyFilter("age", "<", 10), new PropertyFilter("age", ">", 26))).prefetch("address").orderBy(new OrderBy(typeof User, "age", false));
-  for(User user : q.list(session)) {
-    println(user.name + " age " + user.age.as<String> + " street: " + user.address.get(session).street);
-  }
-  println("Now printing all of Zef's messages:");
-  for(Message message : zef.messages.list(session)) {
-    println(message.message);
-  }
-  */
+  println("Performed " + session.queryCounter.as<String> + " queries.");
 }
 

Modified: pil/trunk/src/lib/db/util.pil
===================================================================
--- pil/trunk/src/lib/db/util.pil	2009-06-02 15:40:53 UTC (rev 19505)
+++ pil/trunk/src/lib/db/util.pil	2009-06-03 09:03:27 UTC (rev 19506)
@@ -49,3 +49,13 @@
     return value;
   }
 }
+
+Int pil::db::util::countSelectFields(Array<FieldMapping> mappings) {
+  var counter = 0;
+  for(FieldMapping m : mappings) {
+    if(m.isSelectField()) {
+      counter = counter + 1;
+    }
+  }
+  return counter + 1;
+}



From zef at zefhemel.com  Thu Jun  4 15:42:35 2009
From: zef at zefhemel.com (Zef Hemel)
Date: Thu, 04 Jun 2009 13:42:35 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19511 - zef -
	pil/trunk/src/lib/db
Message-ID: <200906041341.n54Dfd09003841@proliant.st.ewi.tudelft.nl>

Author: zef
Date: 2009-06-04 13:42:35 +0000 (Thu, 04 Jun 2009)
New Revision: 19511

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19511&view=rev

Modified:
   pil/trunk/src/lib/db/collection.pil
   pil/trunk/src/lib/db/db.pil
   pil/trunk/src/lib/db/model.pil
   pil/trunk/src/lib/db/query.pil
   pil/trunk/src/lib/db/test.pil
   pil/trunk/src/lib/db/util.pil

Log:
N:M relations adding, removing and contains check. No listing yet.


Changes:

Modified: pil/trunk/src/lib/db/collection.pil
===================================================================
--- pil/trunk/src/lib/db/collection.pil	2009-06-04 13:11:55 UTC (rev 19510)
+++ pil/trunk/src/lib/db/collection.pil	2009-06-04 13:42:35 UTC (rev 19511)
@@ -67,21 +67,18 @@
 }
 
 class pil::db::model::OneToMany<T> extends QuerySet<T> {
-  Set<T> local = new Set<T>();
   Entity self = null;
   String inverseField = null;
 
   new(Entity self, Class cls, String inverseField) extends super(cls) {
     this.self = self;
     this.inverseField = inverseField;
-    //this.filter = new PropertyFilter(inverseField, "=", self.id);
   }
 
   void add(T item, DatabaseSession session) {
     session.add(item.as<Entity>);
     ManyToOne<Object> invProp = getObjectField(item, inverseField).as<ManyToOne<Object>>;
     if(invProp.get(session) != self) {
-      local.add(item);
       invProp.set(self, session);
     }
   }
@@ -92,18 +89,13 @@
   }
 
   Bool contains(T item, DatabaseSession session) {
-    if(local.contains(item)) {
-      return true;
-    }
+    session.flush();
     return session.query("SELECT " + session.simpleSelectFrom(cls) + " WHERE `" + inverseField + "` = '" + self.id + "'").length > 0;
   }
 
   void remove(T item, DatabaseSession session) {
     session.add(item.as<Entity>);
     getObjectField(item, inverseField).as<ManyToOne<Object>>.set(null, session);
-    if(local.contains(item)) {
-      local.remove(item);
-    }
   }
 
   QuerySet<T> newThis() {
@@ -154,3 +146,59 @@
     return value;
   }
 }
+
+class pil::db::model::ManyToMany<T> extends OneToMany<T> {
+  String relationName = null;
+
+  new(Entity self, Class cls, String inverseField, String relationName) extends super(self, cls, inverseField) {
+    this.relationName = relationName;
+  }
+
+  void add(T item, DatabaseSession session) {
+    session.add(item.as<Entity>);
+    ManyToMany<Entity> invProp = getObjectField(item, inverseField).as<ManyToMany<Entity>>;
+    if(!invProp.contains(self, session)) {
+      var fromMapping = classMappings[self.class];
+      var toMapping = classMappings[cls];
+      session.updateQueryWithArgs("INSERT INTO `" + getTableName() + "` (`" + fromMapping.tableName + "`, `" + toMapping.tableName + "`) VALUES (?, ?)", new Array<Object>(self.id, item.as<Entity>.id));
+    }
+  }
+
+  /*
+  List<T> list(DatabaseSession session) {
+    filter = new AndFilter(filter, new PropertyFilter(inverseField, "=", self.id));
+    return super.list(session);
+  }
+  */
+
+  Bool contains(T item, DatabaseSession session) {
+    session.flush();
+    var fromMapping = classMappings[self.class];
+    var toMapping = classMappings[cls];
+    return session.query("SELECT `" + fromMapping.tableName + "`, `" + toMapping.tableName + "` FROM `" + getTableName() + "` WHERE `" + fromMapping.tableName + "` = '" + self.id + "' AND `" + toMapping.tableName + "` = '" + item.as<Entity>.id + "'").length > 0;
+  }
+
+  Bool isManaging() {
+    return !classMappings[cls].fields[inverseField].as<ManyToManyFieldMapping>.managing;
+  }
+
+  String getTableName() {
+    var fromMapping = classMappings[self.class];
+    var toMapping = classMappings[cls];
+    if(toMapping.fields[inverseField].as<ManyToManyFieldMapping>.managing) {
+      return toMapping.tableName + "_" + relationName + "_" + fromMapping.tableName;
+    } else {
+      return fromMapping.tableName + "_" + relationName + "_" + toMapping.tableName;
+    }
+  }
+
+  void remove(T item, DatabaseSession session) {
+    var fromMapping = classMappings[self.class];
+    var toMapping = classMappings[cls];
+    session.updateQuery("DELETE FROM `" + getTableName() + "` WHERE `" + fromMapping.tableName + "` = '" + self.id + "' AND `" + toMapping.tableName + "` = '" + item.as<Entity>.id + "'");
+  }
+
+  QuerySet<T> newThis() {
+    return new ManyToMany<T>(self, cls, inverseField, relationName);
+  }
+}

Modified: pil/trunk/src/lib/db/db.pil
===================================================================
--- pil/trunk/src/lib/db/db.pil	2009-06-04 13:11:55 UTC (rev 19510)
+++ pil/trunk/src/lib/db/db.pil	2009-06-04 13:42:35 UTC (rev 19511)
@@ -68,7 +68,9 @@
         return;
       }
     }
-    updateQuery(mapping.createSQL(dialect));
+    for(String sql : mapping.createSQLs(dialect)) {
+      updateQuery(sql);
+    }
   }
 
   void registerEntityClass(Class cls) {
@@ -99,13 +101,16 @@
     return sql.as<String>;
   }
 
-  String simpleSelect(Class cls) {
+  String simpleSelect(Class cls, String tableName) {
     var mapping = classMappings[cls];
-    var sql = new MutableString("`" + mapping.tableName + "`.`id`, ");
+    if(tableName == null) {
+      tableName = mapping.tableName;
+    }
+    var sql = new MutableString("`" + tableName + "`.`id`, ");
     var sqlParts = new List<String>();
     for(FieldMapping f : mapping.fieldMappings) {
       if(f.isSelectField()) {
-        sqlParts.add("`" + mapping.tableName + "`.`" + f.fieldName + "`");
+        sqlParts.add("`" + tableName + "`.`" + f.fieldName + "`");
       }
     }
     sql.append(joinStrings(", ", sqlParts));
@@ -126,16 +131,18 @@
     var counter = fieldOffset + 1;
     o.id = r.getString(fieldOffset);
     for(FieldMapping f : mapping.fieldMappings) {
-      if(f instanceof OneToOneFieldMapping) {
-        getObjectField(o, f.fieldName).as<OneToOne<Object>>.setId(r.getString(counter));
-      } else if(f instanceof OneToManyFieldMapping) {
-        // nothing
-      } else if(f instanceof ManyToOneFieldMapping) {
-        getObjectField(o, f.fieldName).as<ManyToOne<Object>>.setId(r.getString(counter));
-      } else {
-        setObjectField(o, f.fieldName, r.getObject(counter));
+      if(f.isSelectField()) {
+        if(f instanceof OneToOneFieldMapping) {
+          getObjectField(o, f.fieldName).as<OneToOne<Object>>.setId(r.getString(counter));
+        } else if(f instanceof OneToManyFieldMapping) {
+          // nothing
+        } else if(f instanceof ManyToOneFieldMapping) {
+          getObjectField(o, f.fieldName).as<ManyToOne<Object>>.setId(r.getString(counter));
+        } else {
+          setObjectField(o, f.fieldName, r.getObject(counter));
+        }
+        counter++;
       }
-      counter++;
     }
     o.isNew = false;
     o.snapshot(this);

Modified: pil/trunk/src/lib/db/model.pil
===================================================================
--- pil/trunk/src/lib/db/model.pil	2009-06-04 13:11:55 UTC (rev 19510)
+++ pil/trunk/src/lib/db/model.pil	2009-06-04 13:42:35 UTC (rev 19511)
@@ -65,18 +65,26 @@
     }
   }
 
-
-  String createSQL(Dialect dialect) {
+  List<String> createSQLs(Dialect dialect) {
+    var sqls = new List<String>();
     var sql = new MutableString();
-    sql.append("CREATE TABLE " + tableName + " (\n");
+    sql.append("CREATE TABLE `" + tableName + "` (\n");
     sql.append("  `id` " + dialect.getType(stringType, 36) + " NOT NULL,\n");
     for(FieldMapping fm : fieldMappings) {
-      sql.append("  " + fm.createSQL(dialect));
-      sql.append(",\n");
+      var sqlPart = fm.createSQL(dialect);
+      if(sqlPart != null) {
+        sql.append("  " + sqlPart);
+        sql.append(",\n");
+      }
+      var tableSql = fm.createTableSQL(dialect);
+      if(tableSql != null) {
+        sqls.add(tableSql);
+      }
     }
     sql.append("  PRIMARY KEY  (`id`)\n");
     sql.append(");");
-    return sql.as<String>;
+    sqls.add(sql.as<String>);
+    return sqls;
   }
 }
 
@@ -88,9 +96,13 @@
   }
 
   String createSQL(Dialect dialect) {
-    return "ERROR!";
+    return null;
   }
 
+  String createTableSQL(Dialect dialect) {
+    return null;
+  }
+
   Bool isSelectField() {
     return true;
   }
@@ -137,7 +149,7 @@
   }
 
   String createSQL(Dialect dialect) {
-    return "";
+    return null;
   }
 
   Bool isSelectField() {
@@ -148,12 +160,38 @@
 class pil::db::model::ManyToOneFieldMapping extends pil::db::model::OneToOneFieldMapping {
   new(String fieldName, Class cls) extends super(fieldName, cls) {
   }
+}
 
-  /*
-  String createSQL(Dialect dialect) {
-    var foreignTable = classMappings[cls].tableName;
-    return "`" + fieldName + "` " + dialect.getType(stringType, 36) + " DEFAULT NULL"; //, " +
-           //"FOREIGN KEY (`" + fieldName + "`) REFERENCES `" + foreignTable + "`(`id`) ";
+class pil::db::model::ManyToManyFieldMapping extends pil::db::model::FieldMapping {
+  Class fromCls = null;
+  Class toCls = null;
+  String relationName = null;
+  Bool managing = true;
+
+  new(String fieldName, String relationName, Class fromCls, Class toCls, Bool managing) extends super(fieldName) {
+    this.fromCls = fromCls;
+    this.toCls = toCls;
+    this.relationName = relationName;
+    this.managing = managing;
   }
-  */
+
+  Bool isSelectField() {
+    return false;
+  }
+
+  String createTableSQL(Dialect dialect) {
+    if(managing) {
+      var fromMapping = classMappings[fromCls];
+      var toMapping = classMappings[toCls];
+      var sql = new MutableString();
+      var tableName = fromMapping.tableName + "_" + relationName + "_" + toMapping.tableName;
+      sql.append("CREATE TABLE `" + tableName + "` (\n");
+      sql.append("   `" + fromMapping.tableName + "` " + dialect.getType(stringType, 36) + " DEFAULT NULL,\n");
+      sql.append("   `" + toMapping.tableName + "` " + dialect.getType(stringType, 36) + " DEFAULT NULL\n");
+      sql.append(");\n");
+      return sql.as<String>;
+    } else {
+      return null;
+    }
+  }
 }

Modified: pil/trunk/src/lib/db/query.pil
===================================================================
--- pil/trunk/src/lib/db/query.pil	2009-06-04 13:11:55 UTC (rev 19510)
+++ pil/trunk/src/lib/db/query.pil	2009-06-04 13:42:35 UTC (rev 19511)
@@ -11,7 +11,7 @@
   Class cls = null;
   Filter filter = new NullFilter();
   List<OrderBy> orderColumns = new List<OrderBy>();
-  List<String> prefetchFields = new List<String>();
+  List<FieldName> prefetchFields = new List<FieldName>();
   DatabaseSession session = null;
 
   new(Class cls) {
@@ -30,7 +30,10 @@
     return c;
   }
 
-  QuerySet<T> prefetch(String field) {
+  QuerySet<T> prefetch(FieldName field) {
+    if(prefetchFields.contains(field)) {
+      return this;
+    }
     QuerySet<T> c = clone();
     c.prefetchFields.add(field);
     return c;
@@ -44,8 +47,8 @@
     QuerySet<T> c = newThis();
     c.filter = filter;
     c.session = session;
-    c.prefetchFields = new List<String>();
-    for(String f : prefetchFields) {
+    c.prefetchFields = new List<FieldName>();
+    for(FieldName f : prefetchFields) {
       c.prefetchFields.add(f);
     }
     c.orderColumns = new List<OrderBy>();
@@ -69,17 +72,29 @@
 
   List<T> list(DatabaseSession session) {
     var args = new List<Object>();
-    var selectSql = "SELECT " + session.simpleSelect(cls);
+    var selectSql = "SELECT " + session.simpleSelect(cls, null);
     var mapping = classMappings[cls];
     var joinSql = "";
 
-    for(String prefetchField : prefetchFields) {
-      println("Prefetch field: " + prefetchField);
-      if(mapping.fields[prefetchField] instanceof SimpleReferenceFieldMapping) {
-        var cls2 = mapping.fields[prefetchField].as<SimpleReferenceFieldMapping>.cls;
+    for(Int i = 0; i < prefetchFields.length; i++) {
+      prefetchFields[i].prepare(this.as<QuerySet<Entity>>);
+    }
+
+    for(FieldName prefetchField : prefetchFields) {
+      if(prefetchField instanceof SimpleFieldName) {
+        var prefetchFieldName = prefetchField.as<SimpleFieldName>.name;
+        var cls2 = mapping.fields[prefetchFieldName].as<SimpleReferenceFieldMapping>.cls;
         var mapping2 = classMappings[cls2];
-        selectSql = selectSql + ", " + session.simpleSelect(cls2);
-        joinSql = joinSql + "LEFT JOIN `" + mapping2.tableName + "` ON `" + mapping2.tableName + "`.`id` = `" + mapping.tableName + "`.`" + prefetchField + "` ";
+        var tblName = prefetchFieldName + "_tbl";
+        selectSql = selectSql + ", " + session.simpleSelect(cls2, tblName);
+        joinSql = joinSql + "LEFT JOIN `" + mapping2.tableName + "` AS `" + tblName + "`  ON `" + tblName + "`.`id` = `" + mapping.tableName + "`.`" + prefetchFieldName + "` ";
+      } else if(prefetchField instanceof CompositeFieldName) {
+        var prefetchFieldName = prefetchField.as<CompositeFieldName>.name;
+        var cls2 = mapping.fields[prefetchFieldName].as<SimpleReferenceFieldMapping>.cls;
+        var mapping2 = classMappings[cls2];
+        var tblName = prefetchFieldName + "_tbl";
+        selectSql = selectSql + ", " + session.simpleSelect(cls2, tblName);
+        joinSql = joinSql + "LEFT JOIN `" + mapping2.tableName + "` AS `" + tblName + "`  ON `" + tblName + "`.`id` = `" + mapping.tableName + "`.`" + prefetchFieldName + "` ";
       }
     }
 
@@ -89,24 +104,45 @@
       sql = sql + " ORDER BY " + joinStrings(", ", map<OrderBy,String>(String(OrderBy ob) { ob.createSQL(session.dialect) }, orderColumns));
     }
     var results = new List<T>();
+    session.flush();
     for(Result r : session.queryWithArgs(sql, args.as<Array<Object>>)) {
       var e = session.resultToEntity(cls, r, 0);
       var offset = countSelectFields(mapping.fieldMappings);
-      for(String prefetchField : prefetchFields) {
-        if(mapping.fields[prefetchField] instanceof SimpleReferenceFieldMapping) {
-          var cls2 = mapping.fields[prefetchField].as<SimpleReferenceFieldMapping>.cls;
-          var mapping2 = classMappings[cls2];
-          var e2 = session.resultToEntity(cls2, r, offset);
-          SimpleReference<Object> sr = getObjectField(e, prefetchField).as<SimpleReference<Object>>;
-          sr.id = e2.id;
-          sr.value = e2;
-          offset = offset + countSelectFields(mapping2.fieldMappings);
-        }
+      for(FieldName prefetchField : prefetchFields) {
+        var prefetchFieldName = prefetchField.as<SimpleFieldName>.name;
+        var cls2 = mapping.fields[prefetchFieldName].as<SimpleReferenceFieldMapping>.cls;
+        var mapping2 = classMappings[cls2];
+        var e2 = session.resultToEntity(cls2, r, offset);
+        SimpleReference<Object> sr = getObjectField(e, prefetchFieldName).as<SimpleReference<Object>>;
+        sr.id = e2.id;
+        sr.value = e2;
+        offset = offset + countSelectFields(mapping2.fieldMappings);
       }
       results.add(e.as<T>);
     }
     return results;
   }
+
+  Class fieldName2Class(Class start, FieldName fieldName) {
+    if(fieldName instanceof SimpleFieldName) {
+      var name = fieldName.as<SimpleFieldName>.name;
+      for(Field f : start.fields) {
+        if(f.name == name) {
+          return f.type;
+        }
+      }
+      throw new Exception("Field not found: " + name);
+    } else {
+      start = fieldName2Class(start, fieldName.as<CompositeFieldName>.fieldName);
+      var name = fieldName.as<CompositeFieldName>.name;
+      for(Field f : start.fields) {
+        if(f.name == name) {
+          return f.type;
+        }
+      }
+      throw new Exception("Field not found: " + name);
+    }
+  }
 }
 
 class pil::db::query::Filter {
@@ -169,6 +205,58 @@
   }
 }
 
+class pil::db::query::FieldName {
+  void prepare(QuerySet<Entity> querySet) {
+  }
+}
+
+class pil::db::query::SimpleFieldName extends FieldName {
+  String name = null;
+
+  new(String name) {
+    this.name = name;
+  }
+
+  Bool ==(Object other) {
+    if(other == null) {
+      return false;
+    }
+    if(other instanceof SimpleFieldName) {
+      return other.as<SimpleFieldName>.name == name;
+    }
+    return false;
+  }
+}
+
+class pil::db::query::CompositeFieldName extends FieldName {
+  FieldName fieldName = null;
+  String name = null;
+
+  new(FieldName fieldName, String name) {
+    this.fieldName = fieldName;
+    this.name = name;
+  }
+
+  void prepare(QuerySet<Entity> querySet) {
+    if(fieldName instanceof SimpleFieldName) {
+      querySet.prefetch(fieldName.as<SimpleFieldName>);
+    } else {
+      throw new Exception("Can't handle this yet.");
+    }
+  }
+
+  Bool ==(Object other) {
+    if(other == null) {
+      return false;
+    }
+    if(other instanceof CompositeFieldName) {
+      var oth = other.as<CompositeFieldName>;
+      return oth.fieldName == fieldName && oth.name == name;
+    }
+    return false;
+  }
+}
+
 // OrderBy
 class pil::db::query::OrderBy {
   Class cls = null;

Modified: pil/trunk/src/lib/db/test.pil
===================================================================
--- pil/trunk/src/lib/db/test.pil	2009-06-04 13:11:55 UTC (rev 19510)
+++ pil/trunk/src/lib/db/test.pil	2009-06-04 13:42:35 UTC (rev 19511)
@@ -19,6 +19,7 @@
   String bio = "";
   OneToOne<Address> address = new OneToOne<Address>(this, typeof Address, "owner");
   OneToMany<Message> messages = new OneToMany<Message>(this, typeof Message, "sender");
+  ManyToMany<User> groups = new ManyToMany<User>(this, typeof Group, "members", "groupMembership");
 
   ClassMapping getMapping() {
     var fields = new List<FieldMapping>();
@@ -26,11 +27,24 @@
     fields.add(new ValueFieldMapping("age", pil::db::type::intType, 0));
     fields.add(new ValueFieldMapping("bio", pil::db::type::stringType, 1024));
     fields.add(new OneToOneFieldMapping("address", typeof Address));
+    fields.add(new ManyToManyFieldMapping("groups", "groupMembership", typeof User, typeof Group, false));
     fields.add(new OneToManyFieldMapping("messages", typeof Message));
     return new ClassMapping(typeof User, "User", fields.as<Array<FieldMapping>>);
   }
 }
 
+class Group extends Entity {
+  String name = "";
+  ManyToMany<User> members = new ManyToMany<User>(this, typeof User, "groups", "groupMembership");
+
+  ClassMapping getMapping() {
+    var fields = new List<FieldMapping>();
+    fields.add(new ValueFieldMapping("name", pil::db::type::stringType, 255));
+    fields.add(new ManyToManyFieldMapping("members", "groupMembership", typeof Group, typeof User, true));
+    return new ClassMapping(typeof Group, "Group", fields.as<Array<FieldMapping>>);
+  }
+}
+
 class Address extends Entity {
   OneToOne<User> owner = new OneToOne<User>(this, typeof User, "address");
   String street = "";
@@ -61,6 +75,8 @@
   session.updateQuery("DELETE FROM User");
   session.updateQuery("DELETE FROM Address");
   session.updateQuery("DELETE FROM Message");
+  session.updateQuery("DELETE FROM `Group`");
+  session.updateQuery("DELETE FROM Group_groupMembership_User");
 }
 
 void testSimple(DatabaseSession session) {
@@ -133,14 +149,33 @@
     session.add(m);
   }
   session.flush();
-  var q = new QuerySet<Message>(typeof Message).prefetch("sender");
+  var q = new QuerySet<Message>(typeof Message).prefetch(new SimpleFieldName("sender"));
   var qc = session.queryCounter;
   for(Message m : q.list(session)) {
-    println(m.sender.get(session).name + ": " + m.message);
+    assertEqual(m.sender.get(session).name, u.name, "checking sender name");
   }
   assertEqual(session.queryCounter, qc+1, "check query count");
+  //println(q.fieldName2Class(typeof Message, new CompositeFieldName(new SimpleFieldName("sender"), "address")));
 }
 
+void testManyToMany(DatabaseSession session) {
+  println("Testing N:M");
+  var u = new User();
+  u.name = "User 1";
+  session.add(u);
+
+  var g = new Group();
+  g.name = "Group 1";
+  session.add(g);
+
+  g.members.add(u, session);
+  g.members.add(u, session);
+  g.members.add(u, session);
+  assert(g.members.contains(u, session), "add successful");
+  g.members.remove(u, session);
+  assert(!g.members.contains(u, session), "remove successful");
+}
+
 void main(Array<String> args) {
   var dialect = new pil::db::dialect::MySQLDialect();
   var db = new pil::db::Database(dialect, "localhost", "root", "", "pildb");
@@ -149,6 +184,7 @@
   session.registerEntityClass(typeof User);
   session.registerEntityClass(typeof Message);
   session.registerEntityClass(typeof Address);
+  session.registerEntityClass(typeof Group);
   session.updateSchemas();
 
   cleanup(session);
@@ -159,6 +195,9 @@
   testOneToMany(session);
   cleanup(session);
   testPrefetch(session);
+  cleanup(session);
+  testManyToMany(session);
+  
   reportTestResults();
   println("Performed " + session.queryCounter.as<String> + " queries.");
 }

Modified: pil/trunk/src/lib/db/util.pil
===================================================================
--- pil/trunk/src/lib/db/util.pil	2009-06-04 13:11:55 UTC (rev 19510)
+++ pil/trunk/src/lib/db/util.pil	2009-06-04 13:42:35 UTC (rev 19511)
@@ -45,6 +45,8 @@
     return value.as<ManyToOne<Object>>.id;
   } else if(value instanceof OneToMany<Object>) {
     return null;
+  } else if(value instanceof ManyToMany<Object>) {
+    return null;
   } else {
     return value;
   }



From zef at zefhemel.com  Fri Jun  5 15:30:03 2009
From: zef at zefhemel.com (Zef Hemel)
Date: Fri, 05 Jun 2009 13:30:03 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19512 - zef -
	pil/trunk/src/lib/db
Message-ID: <200906051329.n55DT6TJ022770@proliant.st.ewi.tudelft.nl>

Author: zef
Date: 2009-06-05 13:30:03 +0000 (Fri, 05 Jun 2009)
New Revision: 19512

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19512&view=rev

Modified:
   pil/trunk/src/lib/db/collection.pil
   pil/trunk/src/lib/db/db.pil
   pil/trunk/src/lib/db/model.pil
   pil/trunk/src/lib/db/query.pil
   pil/trunk/src/lib/db/test.pil

Log:
N:M relations now also work. Sessions now maintain an entity cache. Yes, it appears I'm slowly rebuilding quite a bit of hibernate here :-)


Changes:

Modified: pil/trunk/src/lib/db/collection.pil
===================================================================
--- pil/trunk/src/lib/db/collection.pil	2009-06-04 13:42:35 UTC (rev 19511)
+++ pil/trunk/src/lib/db/collection.pil	2009-06-05 13:30:03 UTC (rev 19512)
@@ -147,11 +147,16 @@
   }
 }
 
-class pil::db::model::ManyToMany<T> extends OneToMany<T> {
+class pil::db::model::ManyToMany<T> extends QuerySet<T> {
   String relationName = null;
+  Entity self = null;
+  String inverseField = inverseField;
 
-  new(Entity self, Class cls, String inverseField, String relationName) extends super(self, cls, inverseField) {
+  new(Entity self, Class cls, String inverseField, String relationName) extends super(cls) {
     this.relationName = relationName;
+    this.self = self;
+    this.inverseField = inverseField;
+    this.relationName = relationName;
   }
 
   void add(T item, DatabaseSession session) {
@@ -164,12 +169,13 @@
     }
   }
 
-  /*
   List<T> list(DatabaseSession session) {
-    filter = new AndFilter(filter, new PropertyFilter(inverseField, "=", self.id));
+    var fromMapping = classMappings[self.class];
+    var toMapping = classMappings[cls];
+    additionalJoinSqls.add("LEFT JOIN `" + getTableName() + "` AS mtm ON mtm.`" + toMapping.tableName + "` = `" + toMapping.tableName  + "`.`id` ");
+    additionalWhereSqls.add("mtm.`" + fromMapping.tableName + "` = '" + self.id + "'");
     return super.list(session);
   }
-  */
 
   Bool contains(T item, DatabaseSession session) {
     session.flush();

Modified: pil/trunk/src/lib/db/db.pil
===================================================================
--- pil/trunk/src/lib/db/db.pil	2009-06-04 13:42:35 UTC (rev 19511)
+++ pil/trunk/src/lib/db/db.pil	2009-06-05 13:30:03 UTC (rev 19512)
@@ -16,6 +16,8 @@
   Set<Entity> trackEntities = new Set<Entity>();
   Int queryCounter = 0;
 
+  Map<String, Entity> entityCache = new Map<String, Entity>();
+
   new(Connection conn, Dialect dialect) {
     this.conn = conn;
     this.dialect = dialect;
@@ -126,6 +128,9 @@
   }
 
   Entity resultToEntity(Class cls, Result r, Int fieldOffset) {
+    if(entityCache.contains(r.getString(fieldOffset))) {
+      return entityCache[r.getString(fieldOffset)];
+    }
     var mapping = classMappings[cls];
     var o = cls.newInstance().as<Entity>;
     var counter = fieldOffset + 1;
@@ -151,7 +156,10 @@
   }
 
   void add(Entity e) {
-    trackEntities.add(e);
+    if(!entityCache.contains(e.id)) {
+      entityCache[e.id] = e;
+      trackEntities.add(e);
+    }
   }
 
   void persist(Entity e) {

Modified: pil/trunk/src/lib/db/model.pil
===================================================================
--- pil/trunk/src/lib/db/model.pil	2009-06-04 13:42:35 UTC (rev 19511)
+++ pil/trunk/src/lib/db/model.pil	2009-06-05 13:30:03 UTC (rev 19512)
@@ -47,6 +47,16 @@
   Int hashCode() {
     return id.hashCode();
   }
+
+  Bool ==(Object o) {
+    if(o == null) {
+      return false;
+    }
+    if(!(o instanceof Entity)) {
+      return false;
+    }
+    return id == o.as<Entity>.id;
+  }
 }
 
 class pil::db::model::ClassMapping {

Modified: pil/trunk/src/lib/db/query.pil
===================================================================
--- pil/trunk/src/lib/db/query.pil	2009-06-04 13:42:35 UTC (rev 19511)
+++ pil/trunk/src/lib/db/query.pil	2009-06-05 13:30:03 UTC (rev 19512)
@@ -13,6 +13,8 @@
   List<OrderBy> orderColumns = new List<OrderBy>();
   List<FieldName> prefetchFields = new List<FieldName>();
   DatabaseSession session = null;
+  List<String> additionalJoinSqls = new List<String>();
+  List<String> additionalWhereSqls = new List<String>();
 
   new(Class cls) {
     this.cls = cls;
@@ -74,8 +76,12 @@
     var args = new List<Object>();
     var selectSql = "SELECT " + session.simpleSelect(cls, null);
     var mapping = classMappings[cls];
-    var joinSql = "";
+    var joinSql = new MutableString();
 
+    for(String j : additionalJoinSqls) {
+      joinSql.append(j);
+    }
+
     for(Int i = 0; i < prefetchFields.length; i++) {
       prefetchFields[i].prepare(this.as<QuerySet<Entity>>);
     }
@@ -87,19 +93,23 @@
         var mapping2 = classMappings[cls2];
         var tblName = prefetchFieldName + "_tbl";
         selectSql = selectSql + ", " + session.simpleSelect(cls2, tblName);
-        joinSql = joinSql + "LEFT JOIN `" + mapping2.tableName + "` AS `" + tblName + "`  ON `" + tblName + "`.`id` = `" + mapping.tableName + "`.`" + prefetchFieldName + "` ";
+        joinSql.append("LEFT JOIN `" + mapping2.tableName + "` AS `" + tblName + "`  ON `" + tblName + "`.`id` = `" + mapping.tableName + "`.`" + prefetchFieldName + "` ");
       } else if(prefetchField instanceof CompositeFieldName) {
         var prefetchFieldName = prefetchField.as<CompositeFieldName>.name;
         var cls2 = mapping.fields[prefetchFieldName].as<SimpleReferenceFieldMapping>.cls;
         var mapping2 = classMappings[cls2];
         var tblName = prefetchFieldName + "_tbl";
         selectSql = selectSql + ", " + session.simpleSelect(cls2, tblName);
-        joinSql = joinSql + "LEFT JOIN `" + mapping2.tableName + "` AS `" + tblName + "`  ON `" + tblName + "`.`id` = `" + mapping.tableName + "`.`" + prefetchFieldName + "` ";
+        joinSql.append("LEFT JOIN `" + mapping2.tableName + "` AS `" + tblName + "`  ON `" + tblName + "`.`id` = `" + mapping.tableName + "`.`" + prefetchFieldName + "` ");
       }
     }
 
-    var whereSql = "WHERE " + filter.createSQL(session.dialect, args);
-    var sql = selectSql + " FROM `" + mapping.tableName + "` " + joinSql + " " + whereSql;
+    var whereSql = new MutableString();
+    whereSql.append("WHERE " + filter.createSQL(session.dialect, args));
+    for(String w : additionalWhereSqls) {
+      whereSql.append(" AND " + w);
+    }
+    var sql = selectSql + " FROM `" + mapping.tableName + "` " + joinSql.as<String> + " " + whereSql;
     if(orderColumns.length > 0) {
       sql = sql + " ORDER BY " + joinStrings(", ", map<OrderBy,String>(String(OrderBy ob) { ob.createSQL(session.dialect) }, orderColumns));
     }

Modified: pil/trunk/src/lib/db/test.pil
===================================================================
--- pil/trunk/src/lib/db/test.pil	2009-06-04 13:42:35 UTC (rev 19511)
+++ pil/trunk/src/lib/db/test.pil	2009-06-05 13:30:03 UTC (rev 19512)
@@ -130,7 +130,6 @@
   var messages = u2.messages.list(session);
   assertEqual(messages.length, 1, "number of messages check");
   assertEqual(messages[0].id, m.id, "message id check");
-  println(messages[0].sender.get(session));
   messages[0].sender.set(null, session);
   session.flush();
   messages = u2.messages.list(session);
@@ -160,20 +159,31 @@
 
 void testManyToMany(DatabaseSession session) {
   println("Testing N:M");
-  var u = new User();
-  u.name = "User 1";
-  session.add(u);
-
   var g = new Group();
   g.name = "Group 1";
   session.add(g);
 
-  g.members.add(u, session);
-  g.members.add(u, session);
-  g.members.add(u, session);
-  assert(g.members.contains(u, session), "add successful");
-  g.members.remove(u, session);
-  assert(!g.members.contains(u, session), "remove successful");
+  var g2 = new Group();
+  g2.name = "Group 2";
+  session.add(g2);
+
+  List<User> even = new List<User>();
+
+  for(Int i = 0; i < 10; i++) {
+    var u = new User();
+    u.name = "User " + i.as<String>;
+    session.add(u);
+    if(i % 2 == 0) {
+      g.members.add(u, session);
+      even.add(u);
+    } else {
+      g2.members.add(u, session);
+    }
+  }
+
+  for(User gu : g.members.list(session)) {
+    assert(even.contains(gu), "checking collection values");
+  }
 }
 
 void main(Array<String> args) {



From zef at zefhemel.com  Mon Jun  8 12:59:18 2009
From: zef at zefhemel.com (Zef Hemel)
Date: Mon, 08 Jun 2009 10:59:18 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19513 - zef -
	pil/trunk/src/lib/db
Message-ID: <200906081058.n58AwH2o025413@proliant.st.ewi.tudelft.nl>

Author: zef
Date: 2009-06-08 10:59:18 +0000 (Mon, 08 Jun 2009)
New Revision: 19513

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19513&view=rev

Modified:
   pil/trunk/src/lib/db/collection.pil
   pil/trunk/src/lib/db/db.pil
   pil/trunk/src/lib/db/query.pil
   pil/trunk/src/lib/db/test.pil

Log:
Fixes


Changes:

Modified: pil/trunk/src/lib/db/collection.pil
===================================================================
--- pil/trunk/src/lib/db/collection.pil	2009-06-05 13:30:03 UTC (rev 19512)
+++ pil/trunk/src/lib/db/collection.pil	2009-06-08 10:59:18 UTC (rev 19513)
@@ -84,8 +84,11 @@
   }
 
   List<T> list(DatabaseSession session) {
+    var oldFilter = filter;
     filter = new AndFilter(filter, new PropertyFilter(inverseField, "=", self.id));
-    return super.list(session);
+    List<T> result = super.list(session);
+    filter = oldFilter;
+    return result;
   }
 
   Bool contains(T item, DatabaseSession session) {
@@ -152,6 +155,8 @@
   Entity self = null;
   String inverseField = inverseField;
 
+  Set<T> local = new Set<T>();
+
   new(Entity self, Class cls, String inverseField, String relationName) extends super(cls) {
     this.relationName = relationName;
     this.self = self;
@@ -161,12 +166,19 @@
 
   void add(T item, DatabaseSession session) {
     session.add(item.as<Entity>);
-    ManyToMany<Entity> invProp = getObjectField(item, inverseField).as<ManyToMany<Entity>>;
-    if(!invProp.contains(self, session)) {
-      var fromMapping = classMappings[self.class];
-      var toMapping = classMappings[cls];
-      session.updateQueryWithArgs("INSERT INTO `" + getTableName() + "` (`" + fromMapping.tableName + "`, `" + toMapping.tableName + "`) VALUES (?, ?)", new Array<Object>(self.id, item.as<Entity>.id));
+    local.add(item);
+  }
+
+  void persist(DatabaseSession session) {
+    for(T item : local) {
+      ManyToMany<Entity> invProp = getObjectField(item, inverseField).as<ManyToMany<Entity>>;
+      if(!invProp.contains(self, session)) {
+        var fromMapping = classMappings[self.class];
+        var toMapping = classMappings[cls];
+        session.updateQueryWithArgs("INSERT INTO `" + getTableName() + "` (`" + fromMapping.tableName + "`, `" + toMapping.tableName + "`) VALUES (?, ?)", new Array<Object>(self.id, item.as<Entity>.id));
+      }
     }
+    local = new Set<T>();
   }
 
   List<T> list(DatabaseSession session) {
@@ -174,11 +186,16 @@
     var toMapping = classMappings[cls];
     additionalJoinSqls.add("LEFT JOIN `" + getTableName() + "` AS mtm ON mtm.`" + toMapping.tableName + "` = `" + toMapping.tableName  + "`.`id` ");
     additionalWhereSqls.add("mtm.`" + fromMapping.tableName + "` = '" + self.id + "'");
-    return super.list(session);
+    List<T> result = super.list(session);
+    additionalJoinSqls = new List<String>();
+    additionalWhereSqls = new List<String>();
+    return result;
   }
 
   Bool contains(T item, DatabaseSession session) {
-    session.flush();
+    if(local.contains(item)) {
+      return true;
+    }
     var fromMapping = classMappings[self.class];
     var toMapping = classMappings[cls];
     return session.query("SELECT `" + fromMapping.tableName + "`, `" + toMapping.tableName + "` FROM `" + getTableName() + "` WHERE `" + fromMapping.tableName + "` = '" + self.id + "' AND `" + toMapping.tableName + "` = '" + item.as<Entity>.id + "'").length > 0;

Modified: pil/trunk/src/lib/db/db.pil
===================================================================
--- pil/trunk/src/lib/db/db.pil	2009-06-05 13:30:03 UTC (rev 19512)
+++ pil/trunk/src/lib/db/db.pil	2009-06-08 10:59:18 UTC (rev 19513)
@@ -18,13 +18,17 @@
 
   Map<String, Entity> entityCache = new Map<String, Entity>();
 
+  Bool debug = false;
+
   new(Connection conn, Dialect dialect) {
     this.conn = conn;
     this.dialect = dialect;
   }
 
   void updateQueryWithArgs(String sql, Array<Object> args) {
-    println(sql);
+    if(debug) {
+      println(sql);
+    }
     /*
     println("[");
     for(Object o : args) {
@@ -37,7 +41,9 @@
   }
 
   List<Result> queryWithArgs(String sql, Array<Object> args) {
-    println(sql);
+    if(debug) {
+      println(sql);
+    }
     /*
     var l = new List<Object>();
     for(Object o : args) {
@@ -128,6 +134,9 @@
   }
 
   Entity resultToEntity(Class cls, Result r, Int fieldOffset) {
+    if(r.getObject(fieldOffset) == null) { // id column == null
+      return null;
+    }
     if(entityCache.contains(r.getString(fieldOffset))) {
       return entityCache[r.getString(fieldOffset)];
     }
@@ -143,7 +152,7 @@
           // nothing
         } else if(f instanceof ManyToOneFieldMapping) {
           getObjectField(o, f.fieldName).as<ManyToOne<Object>>.setId(r.getString(counter));
-        } else {
+        } else if(r.getObject(counter) != null) {
           setObjectField(o, f.fieldName, r.getObject(counter));
         }
         counter++;
@@ -168,7 +177,11 @@
     var cls = e.class;
     for(Field f : cls.fields) {
       if(mapping.fields.contains(f.name)) {
-        values[f.name] = f.get(e);
+        var val = f.get(e);
+        if(val instanceof ManyToMany<Entity>) {
+          val.as<ManyToMany<Entity>>.persist(this);
+        }
+        values[f.name] = val;
       }
     }
     var fieldList = new List<String>();

Modified: pil/trunk/src/lib/db/query.pil
===================================================================
--- pil/trunk/src/lib/db/query.pil	2009-06-05 13:30:03 UTC (rev 19512)
+++ pil/trunk/src/lib/db/query.pil	2009-06-08 10:59:18 UTC (rev 19513)
@@ -124,8 +124,10 @@
         var mapping2 = classMappings[cls2];
         var e2 = session.resultToEntity(cls2, r, offset);
         SimpleReference<Object> sr = getObjectField(e, prefetchFieldName).as<SimpleReference<Object>>;
-        sr.id = e2.id;
-        sr.value = e2;
+        if(e2 != null) {
+          sr.id = e2.id;
+          sr.value = e2;
+        }
         offset = offset + countSelectFields(mapping2.fieldMappings);
       }
       results.add(e.as<T>);

Modified: pil/trunk/src/lib/db/test.pil
===================================================================
--- pil/trunk/src/lib/db/test.pil	2009-06-05 13:30:03 UTC (rev 19512)
+++ pil/trunk/src/lib/db/test.pil	2009-06-08 10:59:18 UTC (rev 19513)
@@ -181,15 +181,19 @@
     }
   }
 
-  for(User gu : g.members.list(session)) {
+  for(User gu : g.members.prefetch(new SimpleFieldName("address")).list(session)) {
     assert(even.contains(gu), "checking collection values");
   }
+
+  assertEqual(g.members.local.length, 0, "local changes flushed");
 }
 
 void main(Array<String> args) {
   var dialect = new pil::db::dialect::MySQLDialect();
   var db = new pil::db::Database(dialect, "localhost", "root", "", "pildb");
+
   var session = new DatabaseSession(db.getConnection(), dialect);
+  session.debug = true;
 
   session.registerEntityClass(typeof User);
   session.registerEntityClass(typeof Message);



From zef at zefhemel.com  Mon Jun  8 13:01:48 2009
From: zef at zefhemel.com (Zef Hemel)
Date: Mon, 08 Jun 2009 11:01:48 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19514 - zef -
	pil/trunk/src/lib/db
Message-ID: <200906081100.n58B0ld2025442@proliant.st.ewi.tudelft.nl>

Author: zef
Date: 2009-06-08 11:01:48 +0000 (Mon, 08 Jun 2009)
New Revision: 19514

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19514&view=rev

Added:
   pil/trunk/src/lib/db/Makefile
   pil/trunk/src/lib/db/test.sh

Log:


Changes:

Added: pil/trunk/src/lib/db/Makefile
===================================================================
--- pil/trunk/src/lib/db/Makefile	                        (rev 0)
+++ pil/trunk/src/lib/db/Makefile	2009-06-08 11:01:48 UTC (rev 19514)
@@ -0,0 +1,22 @@
+PILJAR=/Domain/tudelft.net/Users/zhemel/svn/pil/src/lib/pil.jar
+
+#all: java python
+
+java: clean
+	mkdir -p java-output/src
+	pilc -i db.pil -d java-output/src --gen-external-classinfos --java
+	pilc -i test.pil -d java-output/src --java
+	cp -r java-support/* java-output/
+	cp $(PILJAR) java-output/lib
+	cd java-output; ant
+
+python: clean
+	mkdir -p python-output
+	pilc -i test.pil -d python-output/src --gen-external-classinfos --python
+	#cp -r java-support/* java-output/
+	#cp $(PILJAR) java-output/lib
+	#cd java-output; ant
+
+clean:
+	rm -f *.pil.h 
+	rm -rf java-output

Added: pil/trunk/src/lib/db/test.sh
===================================================================
--- pil/trunk/src/lib/db/test.sh	                        (rev 0)
+++ pil/trunk/src/lib/db/test.sh	2009-06-08 11:01:48 UTC (rev 19514)
@@ -0,0 +1,6 @@
+#!/bin/bash
+
+make || exit
+cd java-output/bin
+java -cp ../lib/mysql-connector.jar:../lib/json.jar:../lib/pil.jar:. application.Main
+cd ../..


Property changes on: pil/trunk/src/lib/db/test.sh
___________________________________________________________________
Added: svn:executable
   + *



From E.Visser at tudelft.nl  Sat Jun 13 14:37:16 2009
From: E.Visser at tudelft.nl (Eelco Visser)
Date: Sat, 13 Jun 2009 12:37:16 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19523 - visser -
	tutorial/trunk
Message-ID: <200906131236.n5DCa9uC018446@proliant.st.ewi.tudelft.nl>

Author: visser
Date: 2009-06-13 12:37:16 +0000 (Sat, 13 Jun 2009)
New Revision: 19523

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19523&view=rev

Modified:
   tutorial/trunk/tasks.app

Log:
task page to demonstrate viewPage derivation

Changes:

Modified: tutorial/trunk/tasks.app
===================================================================
--- tutorial/trunk/tasks.app	2009-06-09 11:24:51 UTC (rev 19522)
+++ tutorial/trunk/tasks.app	2009-06-13 12:37:16 UTC (rev 19523)
@@ -1,81 +1,89 @@
 application tasks
 
-  entity User {
-    username :: String (id,name)
-    tasks    -> List<Task>
-    log      -> List<Task>
-  }
+entity User {
+  username :: String (id,name)
+  tasks    -> Set<Task>
+  log      -> Set<Task>
+}
 
-  entity Task {
-    description :: String
-    done        :: Bool
-  }
-  
-  define page tasks(user : User) {
-    var newTask : Task := Task{ done := false } 
-    action addtask() { 
-      user.tasks.add(newTask); 
-      newTask.save(); 
-    }
-    action done(task : Task) { 
-      task.done := true; 
-      task.save(); 
-   }
-    action archive(task : Task) { 
-      user.tasks.remove(task); 
-      user.log.add(task);
-      user.save(); 
-    }
-    section{
-      header{"Tasks for " output(user.username) }
-      table{
-        for(task : Task in user.tasks) {
-          row{ 
-            output(task.done)
-            output(task.description)
-            form{ 
-              if(!task.done) {
-                action("Done", done(task))
-              } else {
-                action("Archive", archive(task))
-              }
-            }
-          }
+entity Task {
+  description :: String (name)
+  done        :: Bool
+}
+
+define page home() {
+  section{
+    header{"Users"}
+    list{ 
+      for(user : User) {
+        listitem{ 
+          navigate(tasks(user)){output(user.username)} 
+          " (" output(user.tasks.length) ")" 
         }
       }
-      form{
-        input(newTask.description)
-        action("Add Task", addtask())
-      }
-      navigate(home()){"Home"}
     }
+    navigate(newuser()){"Add new user"}
   }
-  
-  define page newuser() {
-    var user : User := User {}
+}
+
+define page newuser() {
+  var user : User := User {}
+  section{
+    header{"Add new user"}
     form{
-      group("Add new user") {
+      table{
         derive editRows from user for ( username )
       }
       action("Add", add())
-      action add() { 
+      action add() {
         user.save(); 
-        return tasks(user); 
+        return tasks(user);
       }
     }
   }
-  
-  define page home() {
-    section{
-      header{"Users"}
-      list{ 
-        for(user : User) {
-          listitem{ 
-            navigate(tasks(user)){output(user.username)} 
-            " (" output(user.tasks.length) ")" 
+}
+
+define page tasks(user : User) {
+  var newTask : Task := Task{ done := false } 
+  action addtask() { 
+    user.tasks.add(newTask); 
+    newTask.save(); 
+  }
+  action done(task : Task) { 
+    task.done := true; 
+    task.save(); 
+  }
+  action archive(task : Task) { 
+    user.tasks.remove(task); 
+    user.log.add(task);
+    user.save(); 
+  }
+  section{
+    header{"Tasks for " output(user.username) }
+    table{
+      for(task : Task in user.tasks) {
+        row{ 
+          output(task.done)
+          navigate(task(user, task)){output(task.name)}
+          form{ 
+            if(!task.done) {
+              action("Done", done(task))
+            } else {
+              action("Archive", archive(task))
+            }
           }
         }
       }
-      navigate(newuser()){"Add new user"}
     }
-  }
\ No newline at end of file
+    form{
+      input(newTask.description)
+      action("Add Task", addtask())
+    }
+    navigate(home()){"Home"}
+  }
+}
+
+define page task(user : User, task : Task) {
+  derive viewPage from task
+  navigate(tasks(user)){output(user.name)}
+}



From E.Visser at tudelft.nl  Sat Jun 13 15:11:27 2009
From: E.Visser at tudelft.nl (Eelco Visser)
Date: Sat, 13 Jun 2009 13:11:27 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19524 - visser -
	tutorial/trunk
Message-ID: <200906131310.n5DDAKNw018924@proliant.st.ewi.tudelft.nl>

Author: visser
Date: 2009-06-13 13:11:27 +0000 (Sat, 13 Jun 2009)
New Revision: 19524

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19524&view=rev

Modified:
   tutorial/trunk/tasks.app

Log:
rows and columns required in tables

Changes:

Modified: tutorial/trunk/tasks.app
===================================================================
--- tutorial/trunk/tasks.app	2009-06-13 12:37:16 UTC (rev 19523)
+++ tutorial/trunk/tasks.app	2009-06-13 13:11:27 UTC (rev 19524)
@@ -63,22 +63,27 @@
     table{
       for(task : Task in user.tasks) {
         row{ 
-          output(task.done)
-          navigate(task(user, task)){output(task.name)}
-          form{ 
-            if(!task.done) {
-              action("Done", done(task))
-            } else {
-              action("Archive", archive(task))
+          column{ output(task.done) }
+          column{ navigate(task(user, task)){output(task.name)} }
+          column{ 
+            form{ 
+              if(!task.done) {
+                action("Done", done(task))
+              } else {
+                action("Archive", archive(task))
+              }
             }
           }
         }
       }
+      form{
+        row{
+          column{}
+          column{ input(newTask.description) }
+          column{ action("Add Task", addtask()) }
+        }
+      }
     }
-    form{
-      input(newTask.description)
-      action("Add Task", addtask())
-    }
     navigate(home()){"Home"}
   }
 }



From E.Visser at tudelft.nl  Sat Jun 13 17:05:26 2009
From: E.Visser at tudelft.nl (Eelco Visser)
Date: Sat, 13 Jun 2009 15:05:26 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19525 - visser -
	tutorial/trunk
Message-ID: <200906131504.n5DF4Jnj020045@proliant.st.ewi.tudelft.nl>

Author: visser
Date: 2009-06-13 15:05:26 +0000 (Sat, 13 Jun 2009)
New Revision: 19525

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19525&view=rev

Modified:
   tutorial/trunk/tasks.app

Log:
tabbed task page with tab for editing; to use case as example

Changes:

Modified: tutorial/trunk/tasks.app
===================================================================
--- tutorial/trunk/tasks.app	2009-06-13 13:11:27 UTC (rev 19524)
+++ tutorial/trunk/tasks.app	2009-06-13 15:05:26 UTC (rev 19525)
@@ -64,7 +64,7 @@
       for(task : Task in user.tasks) {
         row{ 
           column{ output(task.done) }
-          column{ navigate(task(user, task)){output(task.name)} }
+          column{ navigate(task(user, task,"")){output(task.name)} }
           column{ 
             form{ 
               if(!task.done) {
@@ -88,7 +88,29 @@
   }
 }
 
-define page task(user : User, task : Task) {
+define page taskold(user : User, task : Task) {
   derive viewPage from task
   navigate(tasks(user)){output(user.name)}
 }
+
+define page task(user : User, task : Task, tab : String) {
+  case(tab) {
+    "" {
+      derive viewPage from task
+      navigate(tasks(user)){output(user.name)} " "
+      navigate(task(user,task,"edit")){"Edit"}
+    }
+    "edit" {
+      form{
+        input(task.description)
+        action("Save", save())
+        action save() {
+          task.save();
+          return task(user,task,"");
+        }
+      }
+      navigate(tasks(user)){output(user.name)} " "
+      navigate(task(user,task,"")){"View"}
+    }
+  }
+}



From L.C.L.Kats at tudelft.nl  Tue Jun 23 16:12:49 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Tue, 23 Jun 2009 14:12:49 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19536 - LennartKats - in
	spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser:
	. tokens
Message-ID: <200906231411.n5NEBUlX023247@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-06-23 14:12:49 +0000 (Tue, 23 Jun 2009)
New Revision: 19536

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19536&view=rev

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/SGLRParseController.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/tokens/SGLRTokenizer.java

Log:
Error reporting tweaks.

Changes:

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/SGLRParseController.java
===================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/SGLRParseController.java	2009-06-23 12:53:36 UTC (rev 19535)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/SGLRParseController.java	2009-06-23 14:12:49 UTC (rev 19536)
@@ -170,15 +170,15 @@
 			errorHandler.reportNonFatalErrors(parser.getTokenizer(), asfix);
 				
 			Debug.stopTimer("File parsed: " + filename);
-		} catch (TokenExpectedException e) {
-			errorHandler.clearErrors(); // (may not be synchronized; uses workspace lock)
-			errorHandler.reportError(parser.getTokenizer(), e);
 		} catch (ParseTimeoutException e) {
 			// TODO: Don't show stack trace for this
 			if (monitor.isCanceled()) return null;
 			errorHandler.clearErrors();
 			errorHandler.setRecoveryEnabled(false);
 			errorHandler.reportError(parser.getTokenizer(), e);
+		} catch (TokenExpectedException e) {
+			errorHandler.clearErrors(); // (must not be synchronized; uses workspace lock)
+			errorHandler.reportError(parser.getTokenizer(), e);
 		} catch (BadTokenException e) {
 			errorHandler.clearErrors();
 			errorHandler.setRecoveryEnabled(false);

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/tokens/SGLRTokenizer.java
===================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/tokens/SGLRTokenizer.java	2009-06-23 12:53:36 UTC (rev 19535)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/tokens/SGLRTokenizer.java	2009-06-23 14:12:49 UTC (rev 19536)
@@ -108,6 +108,7 @@
 			
 			if (onlySeenWhitespace) {
 				onlySeenWhitespace = isWhitespace;
+				offset++;
 			} else if (isWhitespace) {
 				break;
 			}



From L.C.L.Kats at tudelft.nl  Wed Jun 24 12:53:45 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Wed, 24 Jun 2009 10:53:45 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19544 - LennartKats -
	spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser
Message-ID: <200906241052.n5OAqPQ4004705@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-06-24 10:53:45 +0000 (Wed, 24 Jun 2009)
New Revision: 19544

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19544&view=rev

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/SGLRParseController.java

Log:
Use CoarseGrainedRecovery/structure recovery for the editor.

Changes:

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/SGLRParseController.java
===================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/SGLRParseController.java	2009-06-24 08:56:33 UTC (rev 19543)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/SGLRParseController.java	2009-06-24 10:53:45 UTC (rev 19544)
@@ -22,8 +22,8 @@
 import org.eclipse.imp.services.IAnnotationTypeInfo;
 import org.eclipse.imp.services.ILanguageSyntaxProperties;
 import org.eclipse.jface.text.IRegion;
-import org.spoofax.jsglr.BackTrackRecovery2;
 import org.spoofax.jsglr.BadTokenException;
+import org.spoofax.jsglr.CoarseGrainedRecovery;
 import org.spoofax.jsglr.ParseTable;
 import org.spoofax.jsglr.ParseTimeoutException;
 import org.spoofax.jsglr.SGLR;
@@ -123,7 +123,7 @@
     	ParseTable table = Environment.getParseTable(language);
 		parser = new JSGLRI(table, startSymbol, this, tokenManager);
 		parser.setKeepAmbiguities(false); // not interested in ambiguities in the editor
-		parser.setRecoverHandler(new BackTrackRecovery2());
+		parser.setRecoverHandler(new CoarseGrainedRecovery());
     }
 
     public void initialize(IPath filePath, ISourceProject project,
@@ -158,7 +158,7 @@
 			char[] inputChars = input.toCharArray();
 				
 			if (monitor.isCanceled()) return null;
-                        currentAst = parser.parse(inputChars, filename);			
+			currentAst = parser.parse(inputChars, filename);			
 			if (monitor.isCanceled()) return null;
 			// For error handling, retrieve the cached, unimploded asfix tree
 			asfix = parser.parseNoImplode(inputChars, filename);



From L.C.L.Kats at tudelft.nl  Wed Jun 24 12:54:17 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Wed, 24 Jun 2009 10:54:17 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19545 - LennartKats -
	spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
Message-ID: <200906241052.n5OAquSm004710@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-06-24 10:54:17 +0000 (Wed, 24 Jun 2009)
New Revision: 19545

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19545&view=rev

Modified:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java

Log:
Work around for setRecoverHandler() to at least support CoarseGrainedRecovery.

Changes:

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-06-24 10:53:45 UTC (rev 19544)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-06-24 10:54:17 UTC (rev 19545)
@@ -163,8 +163,14 @@
     }
     
     public void setRecoverHandler(RecoverAlgorithm recoverHandler) {
-        this.recoverHandler = recoverHandler;
-        recoverHandler.initialize(this);
+        // HACK: just check the recover handler's type and do the right thing
+        if (recoverHandler instanceof CoarseGrainedRecovery) {
+            setUseStructureRecovery(true);
+        } else {
+            throw new org.spoofax.NotImplementedException();
+        }
+        // this.recoverHandler = recoverHandler;
+        // recoverHandler.initialize(this);
     }
     
     public RecoveryBase getRecoverHandler() {



From L.C.L.Kats at tudelft.nl  Wed Jun 24 12:56:00 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Wed, 24 Jun 2009 10:56:00 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19546 - LennartKats -
	spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
Message-ID: <200906241054.n5OAsdS6004717@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-06-24 10:56:00 +0000 (Wed, 24 Jun 2009)
New Revision: 19546

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19546&view=rev

Modified:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java

Log:
Work around for setRecoverHandler() to at least support NoRecovery.

Changes:

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-06-24 10:54:17 UTC (rev 19545)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-06-24 10:56:00 UTC (rev 19546)
@@ -166,6 +166,8 @@
         // HACK: just check the recover handler's type and do the right thing
         if (recoverHandler instanceof CoarseGrainedRecovery) {
             setUseStructureRecovery(true);
+        } else if (recoverHandler instanceof NoRecovery) {
+            setUseStructureRecovery(false);
         } else {
             throw new org.spoofax.NotImplementedException();
         }



From L.C.L.Kats at tudelft.nl  Thu Jun 25 10:27:08 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Thu, 25 Jun 2009 08:27:08 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19547 - LennartKats -
	in spoofax/trunk/spoofax: org.spoofax.aterm/src/aterm/pure
	org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms
Message-ID: <200906250825.n5P8Plcm019266@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-06-25 08:27:08 +0000 (Thu, 25 Jun 2009)
New Revision: 19547

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19547&view=rev

Modified:
   spoofax/trunk/spoofax/org.spoofax.aterm/src/aterm/pure/BitStream.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/BasicStrategoAppl.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/BasicStrategoList.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/BasicTermFactory.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/IStrategoConstructor.java

Log:
- Pretty printer tuning
- Support parsing textual aterms with numbers in the constructors
- Avoid using an array for bitstream temporary data

Changes:

Modified: spoofax/trunk/spoofax/org.spoofax.aterm/src/aterm/pure/BitStream.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.aterm/src/aterm/pure/BitStream.java	2009-06-24 10:56:00 UTC (rev 19546)
+++ spoofax/trunk/spoofax/org.spoofax.aterm/src/aterm/pure/BitStream.java	2009-06-25 08:27:08 UTC (rev 19547)
@@ -15,7 +15,7 @@
  */
 public class BitStream {
 
-    InputStream stream;
+    private final InputStream stream;
     private int bitsInBuffer;
     private int bitBuffer;
 
@@ -26,36 +26,34 @@
     }
 
     public int readInt() throws IOException {
-        int[] buf = new int[5];
-
-        buf[0] = readByte();
+        int buf0 = readByte();
         
         // Check if 1st character is enough
-        if((buf[0] & 0x80) == 0)
-            return buf[0];
+        if((buf0 & 0x80) == 0)
+            return buf0;
 
-        buf[1]  = readByte();
+        int buf1  = readByte();
         
         // Check if 2nd character is enough
-        if((buf[0] & 0x40) == 0)
-            return buf[1] + ((buf[0] & ~0xc0) << 8);
+        if((buf0 & 0x40) == 0)
+            return buf1 + ((buf0 & ~0xc0) << 8);
 
-        buf[2] = readByte();
+        int buf2 = readByte();
 
         // Check if 3rd character is enough
-        if((buf[0] & 0x20) == 0 )
-            return buf[2] + (buf[1] << 8) + ((buf[0] & ~0xe0) << 16);
+        if((buf0 & 0x20) == 0 )
+            return buf2 + (buf1 << 8) + ((buf0 & ~0xe0) << 16);
 
-        buf[3] = readByte();
+        int buf3 = readByte();
         
         // Check if 4th character is enough
-        if((buf[0] & 0x10) == 0 )
-            return buf[3] + (buf[2] << 8) + (buf[1] << 16) +
-              ((buf[0] & ~0xf0) << 24);
+        if((buf0 & 0x10) == 0 )
+            return buf3 + (buf2 << 8) + (buf1 << 16) +
+              ((buf0 & ~0xf0) << 24);
         
-        buf[4] = readByte();
+        int buf4 = readByte();
 
-        return buf[4] + (buf[3] << 8) + (buf[2] << 16) + (buf[1] << 24);
+        return buf4 + (buf3 << 8) + (buf2 << 16) + (buf1 << 24);
     }
 
     protected int readByte() throws IOException {

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/BasicStrategoAppl.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/BasicStrategoAppl.java	2009-06-24 10:56:00 UTC (rev 19546)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/BasicStrategoAppl.java	2009-06-25 08:27:08 UTC (rev 19547)
@@ -77,7 +77,7 @@
             pp.indent(ctor.getName().length());
             kids[0].prettyPrint(pp);
             for(int i = 1; i < kids.length; i++) {
-                pp.print(", ");
+                pp.print(",");
                 kids[i].prettyPrint(pp);
             }
             pp.println(")");
@@ -90,15 +90,15 @@
     public String toString() {
         StringBuilder sb = new StringBuilder();
         sb.append(ctor.getName());
-        sb.append("(");
         if(kids.length > 0) {
+            sb.append("(");
             sb.append(kids[0]);
             for(int i = 1; i < kids.length; i++) {
                 sb.append(",");
                 sb.append(kids[i].toString());
             }
+            sb.append(")");
         }
-        sb.append(")");
         appendAnnotations(sb);
         return sb.toString();
     }

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/BasicStrategoList.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/BasicStrategoList.java	2009-06-24 10:56:00 UTC (rev 19546)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/BasicStrategoList.java	2009-06-25 08:27:08 UTC (rev 19547)
@@ -113,7 +113,7 @@
             pp.indent(2);
             head().prettyPrint(pp);
             for (IStrategoList cur = tail(); !cur.isEmpty(); cur = cur.tail()) {
-                pp.print(", ");
+                pp.print(",");
                 pp.nextIndentOff();
                 cur.head().prettyPrint(pp);
                 pp.println("");

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/BasicTermFactory.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/BasicTermFactory.java	2009-06-24 10:56:00 UTC (rev 19546)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/BasicTermFactory.java	2009-06-25 08:27:08 UTC (rev 19547)
@@ -7,6 +7,7 @@
  */
 package org.spoofax.interpreter.terms;
 
+import java.io.BufferedInputStream;
 import java.io.ByteArrayInputStream;
 import java.io.FileInputStream;
 import java.io.IOException;
@@ -26,7 +27,7 @@
 
 public class BasicTermFactory implements ITermFactory {
 
-    public static final IStrategoTerm[] EMPTY = new IStrategoTerm[0];
+    public static final IStrategoTerm[] EMPTY = {};
 
     public static final BasicStrategoList EMPTY_LIST = new BasicStrategoList(null, null, null); 
 
@@ -41,6 +42,8 @@
     }
 
     public IStrategoTerm parseFromStream(InputStream inputStream) throws IOException {
+        if (!(inputStream instanceof BufferedInputStream))
+            inputStream = new BufferedInputStream(inputStream);
         PushbackInputStream bis = new PushbackInputStream(inputStream);
         
         return parseFromStream(bis);
@@ -136,7 +139,7 @@
         do {
             sb.append((char)ch);
             ch = bis.read();
-        } while(Character.isLetter(ch) || ch == '-');
+        } while(Character.isLetterOrDigit(ch) || ch == '-');
         
         //System.err.println(" - " + sb.toString());
         

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/IStrategoConstructor.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/IStrategoConstructor.java	2009-06-24 10:56:00 UTC (rev 19546)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/IStrategoConstructor.java	2009-06-25 08:27:08 UTC (rev 19547)
@@ -9,7 +9,9 @@
 
 public interface IStrategoConstructor extends IStrategoTerm {
 
+    @Deprecated
     public IStrategoAppl instantiate(ITermFactory factory, IStrategoTerm... kids);
+    @Deprecated
     public IStrategoAppl instantiate(ITermFactory factory, IStrategoList kids);
 
     public String getName();



From L.C.L.Kats at tudelft.nl  Thu Jun 25 10:28:10 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Thu, 25 Jun 2009 08:28:10 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19548 - LennartKats -
	spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.aterm/src/org/spoofax/interpreter/adapter/aterm
Message-ID: <200906250826.n5P8Qmsl019271@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-06-25 08:28:10 +0000 (Thu, 25 Jun 2009)
New Revision: 19548

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19548&view=rev

Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.aterm/src/org/spoofax/interpreter/adapter/aterm/BAFBasicTermFactory.java

Log:
BAFBasicTermFactory tuning

Changes:

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.aterm/src/org/spoofax/interpreter/adapter/aterm/BAFBasicTermFactory.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.aterm/src/org/spoofax/interpreter/adapter/aterm/BAFBasicTermFactory.java	2009-06-25 08:27:08 UTC (rev 19547)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.aterm/src/org/spoofax/interpreter/adapter/aterm/BAFBasicTermFactory.java	2009-06-25 08:28:10 UTC (rev 19548)
@@ -1,13 +1,14 @@
 package org.spoofax.interpreter.adapter.aterm;
 
+import java.io.BufferedInputStream;
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.PushbackInputStream;
 
 import org.spoofax.interpreter.terms.BasicTermFactory;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.TermConverter;
 
+import aterm.ATerm;
 import aterm.pure.BAFReader;
 
 /**
@@ -17,26 +18,27 @@
  */
 public class BAFBasicTermFactory extends BasicTermFactory {
     
-    private final WrappedATermFactory wrappedFactory = new UnsharedWrappedATermFactory();
+    private final TermConverter converter = new TermConverter(this);
     
-    private final TermConverter converter = new TermConverter(this);
+    private final WrappedATermFactory wrappedFactory;
+    
+    public BAFBasicTermFactory() {
+        this(new UnsharedWrappedATermFactory());
+    }
+    
+    public BAFBasicTermFactory(WrappedATermFactory wrappedFactory) {
+        this.wrappedFactory = wrappedFactory;
+    }
 
     @Override
     public IStrategoTerm parseFromStream(InputStream inputStream) throws IOException {
-        PushbackInputStream bis = new PushbackInputStream(inputStream, BAFReader.BAF_MAGIC_SIZE);
+        BufferedInputStream bis = new BufferedInputStream(inputStream);
         
-        return parseFromStream(bis);
-    }  
-    
-    @Override
-    public IStrategoTerm parseFromStream(PushbackInputStream inputStream)
-            throws IOException {
-        
-        if (BAFReader.isBinaryATerm(inputStream)) {
-            IStrategoTerm result = wrappedFactory.parseFromStream(inputStream);
-            return converter.convert(result);
+        if (BAFReader.isBinaryATerm(bis)) {
+            ATerm result = new BAFReader(wrappedFactory.getFactory(), bis).readFromBinaryFile(true);
+            return converter.convert(wrappedFactory.wrapTerm(result));
         } else {
-            return super.parseFromStream(inputStream);
+            return super.parseFromStream(bis);
         }
     }
 }



From L.C.L.Kats at tudelft.nl  Thu Jun 25 10:33:00 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Thu, 25 Jun 2009 08:33:00 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19549 - LennartKats -
	in spoofax/trunk/spoofax:
	org.spoofax.interpreter.adapter.aterm/src/org/spoofax/interpreter/adapter/aterm
	org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj
	org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms
	org.spoofax.jsglr
Message-ID: <200906250831.n5P8VdVN019307@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-06-25 08:33:00 +0000 (Thu, 25 Jun 2009)
New Revision: 19549

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19549&view=rev

Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.aterm/src/org/spoofax/interpreter/adapter/aterm/WrappedATerm.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/ASTCtor.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/AbstractECJNode.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/ECJAnnoWrapper.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedASTNode.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedASTNodeList.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedECJNode.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedGenericAppl.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/BasicStrategoTerm.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/BasicStrategoTuple.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/IStrategoTerm.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/IStrategoTermBuilder.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/jsglr

Log:
Added a IStrategoTerm.getStorageType() accessor to determine if terms are maximally shared, immutable, etc.

Changes:

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.aterm/src/org/spoofax/interpreter/adapter/aterm/WrappedATerm.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.aterm/src/org/spoofax/interpreter/adapter/aterm/WrappedATerm.java	2009-06-25 08:28:10 UTC (rev 19548)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.aterm/src/org/spoofax/interpreter/adapter/aterm/WrappedATerm.java	2009-06-25 08:33:00 UTC (rev 19549)
@@ -30,6 +30,10 @@
         this(parent, annotations.isEmpty() ? parent.makeList() : (IStrategoList) parent.wrapTerm(annotations));
     }
     
+    public int getStorageType() {
+        return MAXIMALLY_SHARED;
+    }
+    
     // FIXME: WrappedATerm.slowCompare does not take annotations into account
     //        (but wrapped aterms don't play nice with other aterms anyway atm)
     

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/ASTCtor.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/ASTCtor.java	2009-06-25 08:28:10 UTC (rev 19548)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/ASTCtor.java	2009-06-25 08:33:00 UTC (rev 19549)
@@ -25,6 +25,10 @@
         this.arity = arity;
     }
     
+    public int getStorageType() {
+        return IMMUTABLE;
+    }
+    
     public int getArity() {
         return arity;
     }

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/AbstractECJNode.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/AbstractECJNode.java	2009-06-25 08:28:10 UTC (rev 19548)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/AbstractECJNode.java	2009-06-25 08:33:00 UTC (rev 19549)
@@ -15,6 +15,10 @@
 	public IStrategoList getAnnotations() {
 		return BasicTermFactory.EMPTY_LIST;
 	}
+    
+    public int getStorageType() {
+        return MUTABLE;
+    }
 
     @Override
     public boolean equals(Object obj) {

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/ECJAnnoWrapper.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/ECJAnnoWrapper.java	2009-06-25 08:28:10 UTC (rev 19548)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/ECJAnnoWrapper.java	2009-06-25 08:33:00 UTC (rev 19549)
@@ -19,6 +19,10 @@
 		this.wrappee = wrappee;
 		this.annotations = annotations;
 	}
+    
+	public int getStorageType() {
+		return IMMUTABLE;
+	}
 	
 	public IStrategoTerm[] getAllSubterms() {
 		return wrappee.getAllSubterms();

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedASTNode.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedASTNode.java	2009-06-25 08:28:10 UTC (rev 19548)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedASTNode.java	2009-06-25 08:33:00 UTC (rev 19549)
@@ -12,6 +12,10 @@
 
     public abstract ASTNode getWrappee();
     
+    public int getStorageType() {
+        return MUTABLE;
+    }
+    
     @Override
     public boolean match(IStrategoTerm second) {
     	if(!(second instanceof WrappedASTNode))

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedASTNodeList.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedASTNodeList.java	2009-06-25 08:28:10 UTC (rev 19548)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedASTNodeList.java	2009-06-25 08:33:00 UTC (rev 19549)
@@ -29,6 +29,10 @@
         this.wrappee = (List<ASTNode>)wrappee;
     }
     
+    public int getStorageType() {
+        return MUTABLE;
+    }
+    
     public IStrategoTerm get(int i) {
         return getSubterm(i);
     }

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedECJNode.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedECJNode.java	2009-06-25 08:28:10 UTC (rev 19548)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedECJNode.java	2009-06-25 08:33:00 UTC (rev 19549)
@@ -23,4 +23,8 @@
     public IStrategoList getAnnotations() {
     	return BasicTermFactory.EMPTY_LIST;
     }
+    
+    public int getStorageType() {
+        return MUTABLE;
+    }
 }

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedGenericAppl.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedGenericAppl.java	2009-06-25 08:28:10 UTC (rev 19548)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedGenericAppl.java	2009-06-25 08:33:00 UTC (rev 19549)
@@ -25,6 +25,10 @@
         this.children = children;
     }
     
+    public int getStorageType() {
+        return MUTABLE;
+    }
+    
     public IStrategoTerm[] getArguments() {
         return children;
     }

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/BasicStrategoTerm.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/BasicStrategoTerm.java	2009-06-25 08:28:10 UTC (rev 19548)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/BasicStrategoTerm.java	2009-06-25 08:33:00 UTC (rev 19549)
@@ -14,6 +14,10 @@
     protected BasicStrategoTerm(IStrategoList annotations) {
         this.annotations = annotations;
     }
+    
+    public int getStorageType() {
+        return IMMUTABLE;
+    }
 
     public boolean match(IStrategoTerm second) {
         return this == second || doSlowMatch(second);

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/BasicStrategoTuple.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/BasicStrategoTuple.java	2009-06-25 08:28:10 UTC (rev 19548)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/BasicStrategoTuple.java	2009-06-25 08:33:00 UTC (rev 19549)
@@ -74,7 +74,7 @@
             pp.indent(2);
             get(0).prettyPrint(pp);
             for(int i = 1; i < sz; i++) {
-                pp.print(", ");
+                pp.print(",");
                 pp.nextIndentOff();
                 get(i).prettyPrint(pp);
                 pp.println("");

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/IStrategoTerm.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/IStrategoTerm.java	2009-06-25 08:28:10 UTC (rev 19548)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/IStrategoTerm.java	2009-06-25 08:33:00 UTC (rev 19549)
@@ -18,11 +18,17 @@
     public static final int CTOR = 6;
     public static final int TUPLE = 7;
     public static final int REF = 8;
+    
+    public static final int MUTABLE = 0;
+    public static final int IMMUTABLE = 1;
+    public static final int SHARABLE = 2;
+    public static final int MAXIMALLY_SHARED = 3;
 
     public int getSubtermCount();
     public IStrategoTerm getSubterm(int index);
     public IStrategoTerm[] getAllSubterms();
     public int getTermType();
+    public int getStorageType();
     
     public IStrategoList getAnnotations();
     

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/IStrategoTermBuilder.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/IStrategoTermBuilder.java	2009-06-25 08:28:10 UTC (rev 19548)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/java/org/spoofax/interpreter/terms/IStrategoTermBuilder.java	2009-06-25 08:33:00 UTC (rev 19549)
@@ -14,6 +14,8 @@
     
     public IStrategoConstructor makeConstructor(String string, int arity);
 
+    // TODO: Rename makeApl() IStrategoList overload to avoid accidental invocation
+    @Deprecated
     public IStrategoAppl makeAppl(IStrategoConstructor ctr, IStrategoList kids);
     public IStrategoAppl makeAppl(IStrategoConstructor ctr, IStrategoTerm... terms);
 
@@ -25,6 +27,7 @@
     public IStrategoList makeList(Collection<IStrategoTerm> terms);
     
     // TODO: Rename makeList() head/tail overload to avoid accidental invocation
+    @Deprecated
     public IStrategoList makeList(IStrategoTerm head, IStrategoList tail);
     
     public IStrategoTerm annotateTerm(IStrategoTerm term, IStrategoList annotations);

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/jsglr
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/jsglr	2009-06-25 08:28:10 UTC (rev 19548)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/jsglr	2009-06-25 08:33:00 UTC (rev 19549)
@@ -20,7 +20,7 @@
 	-Xmx1024m \
 	-Xss10m \
 	-cp ${fcp} \
-	org.spoofax.jsglr.Main $1 $2 $3 $4 $5 $6 $7 $8 $9 $10 $11 $12
+	org.spoofax.jsglr.Main $1 $2 $3 $4 $5 $6 $7 $8 $9 $10 $11 $12 >&2
 
 java \
 	-Xmx1024m \



From L.C.L.Kats at tudelft.nl  Thu Jun 25 10:35:44 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Thu, 25 Jun 2009 08:35:44 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19550 - LennartKats -
	in spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj:
	. .settings src/org/spoofax/interpreter/adapter/ecj
Message-ID: <200906250834.n5P8YNsF019319@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-06-25 08:35:44 +0000 (Thu, 25 Jun 2009)
New Revision: 19550

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19550&view=rev

Added:
   spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/.settings/
   spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/.settings/org.eclipse.jdt.core.prefs
Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedActualTypeSignature.java

Log:
Forced ECJ project to be 1.5 compatibile, like most other Spoofax projects.

Changes:

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/.settings/org.eclipse.jdt.core.prefs
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/.settings/org.eclipse.jdt.core.prefs	                        (rev 0)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/.settings/org.eclipse.jdt.core.prefs	2009-06-25 08:35:44 UTC (rev 19550)
@@ -0,0 +1,268 @@
+#Thu Jun 25 10:30:32 CEST 2009
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.5
+org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
+org.eclipse.jdt.core.compiler.compliance=1.5
+org.eclipse.jdt.core.compiler.debug.lineNumber=generate
+org.eclipse.jdt.core.compiler.debug.localVariable=generate
+org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.source=1.5
+org.eclipse.jdt.core.formatter.align_type_members_on_columns=false
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_allocation_expression=16
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_enum_constant=16
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_explicit_constructor_call=16
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_method_invocation=16
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_qualified_allocation_expression=16
+org.eclipse.jdt.core.formatter.alignment_for_assignment=0
+org.eclipse.jdt.core.formatter.alignment_for_binary_expression=16
+org.eclipse.jdt.core.formatter.alignment_for_compact_if=16
+org.eclipse.jdt.core.formatter.alignment_for_conditional_expression=80
+org.eclipse.jdt.core.formatter.alignment_for_enum_constants=0
+org.eclipse.jdt.core.formatter.alignment_for_expressions_in_array_initializer=16
+org.eclipse.jdt.core.formatter.alignment_for_multiple_fields=16
+org.eclipse.jdt.core.formatter.alignment_for_parameters_in_constructor_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_parameters_in_method_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_selector_in_method_invocation=16
+org.eclipse.jdt.core.formatter.alignment_for_superclass_in_type_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_enum_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_type_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_constructor_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_method_declaration=16
+org.eclipse.jdt.core.formatter.blank_lines_after_imports=1
+org.eclipse.jdt.core.formatter.blank_lines_after_package=1
+org.eclipse.jdt.core.formatter.blank_lines_before_field=0
+org.eclipse.jdt.core.formatter.blank_lines_before_first_class_body_declaration=0
+org.eclipse.jdt.core.formatter.blank_lines_before_imports=1
+org.eclipse.jdt.core.formatter.blank_lines_before_member_type=1
+org.eclipse.jdt.core.formatter.blank_lines_before_method=1
+org.eclipse.jdt.core.formatter.blank_lines_before_new_chunk=1
+org.eclipse.jdt.core.formatter.blank_lines_before_package=0
+org.eclipse.jdt.core.formatter.blank_lines_between_import_groups=1
+org.eclipse.jdt.core.formatter.blank_lines_between_type_declarations=1
+org.eclipse.jdt.core.formatter.brace_position_for_annotation_type_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_anonymous_type_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_array_initializer=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_block=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_block_in_case=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_constructor_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_enum_constant=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_enum_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_method_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_switch=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_type_declaration=end_of_line
+org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_block_comment=false
+org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_javadoc_comment=false
+org.eclipse.jdt.core.formatter.comment.format_block_comments=true
+org.eclipse.jdt.core.formatter.comment.format_header=false
+org.eclipse.jdt.core.formatter.comment.format_html=true
+org.eclipse.jdt.core.formatter.comment.format_javadoc_comments=true
+org.eclipse.jdt.core.formatter.comment.format_line_comments=true
+org.eclipse.jdt.core.formatter.comment.format_source_code=true
+org.eclipse.jdt.core.formatter.comment.indent_parameter_description=true
+org.eclipse.jdt.core.formatter.comment.indent_root_tags=true
+org.eclipse.jdt.core.formatter.comment.insert_new_line_before_root_tags=insert
+org.eclipse.jdt.core.formatter.comment.insert_new_line_for_parameter=insert
+org.eclipse.jdt.core.formatter.comment.line_length=80
+org.eclipse.jdt.core.formatter.compact_else_if=true
+org.eclipse.jdt.core.formatter.continuation_indentation=2
+org.eclipse.jdt.core.formatter.continuation_indentation_for_array_initializer=2
+org.eclipse.jdt.core.formatter.format_guardian_clause_on_one_line=false
+org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_annotation_declaration_header=true
+org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_constant_header=true
+org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_declaration_header=true
+org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_type_header=true
+org.eclipse.jdt.core.formatter.indent_breaks_compare_to_cases=true
+org.eclipse.jdt.core.formatter.indent_empty_lines=false
+org.eclipse.jdt.core.formatter.indent_statements_compare_to_block=true
+org.eclipse.jdt.core.formatter.indent_statements_compare_to_body=true
+org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_cases=true
+org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_switch=false
+org.eclipse.jdt.core.formatter.indentation.size=4
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_local_variable=insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_member=insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_parameter=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_opening_brace_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_at_end_of_file_if_missing=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_catch_in_try_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_closing_brace_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_else_in_if_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_finally_in_try_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_while_in_do_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_annotation_declaration=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_anonymous_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_block=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_constant=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_declaration=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_method_body=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_after_and_in_type_parameter=insert
+org.eclipse.jdt.core.formatter.insert_space_after_assignment_operator=insert
+org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation_type_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_binary_operator=insert
+org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_parameters=insert
+org.eclipse.jdt.core.formatter.insert_space_after_closing_brace_in_block=insert
+org.eclipse.jdt.core.formatter.insert_space_after_closing_paren_in_cast=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_assert=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_case=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_conditional=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_for=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_labeled_statement=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_allocation_expression=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_annotation=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_array_initializer=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_parameters=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_throws=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_constant_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_declarations=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_explicitconstructorcall_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_increments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_inits=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_parameters=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_throws=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_invocation_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_field_declarations=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_local_declarations=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_parameterized_type_reference=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_superinterfaces=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_parameters=insert
+org.eclipse.jdt.core.formatter.insert_space_after_ellipsis=insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_parameterized_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_brace_in_array_initializer=insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_cast=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_catch=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_constructor_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_enum_constant=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_for=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_if=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_invocation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_parenthesized_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_switch=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_synchronized=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_while=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_postfix_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_prefix_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_question_in_conditional=insert
+org.eclipse.jdt.core.formatter.insert_space_after_question_in_wildcard=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_semicolon_in_for=insert
+org.eclipse.jdt.core.formatter.insert_space_after_unary_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_and_in_type_parameter=insert
+org.eclipse.jdt.core.formatter.insert_space_before_assignment_operator=insert
+org.eclipse.jdt.core.formatter.insert_space_before_at_in_annotation_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_binary_operator=insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_parameterized_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_brace_in_array_initializer=insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_cast=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_catch=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_constructor_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_enum_constant=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_for=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_if=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_invocation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_parenthesized_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_switch=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_synchronized=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_while=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_assert=insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_case=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_conditional=insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_default=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_for=insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_labeled_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_throws=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_constant_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_declarations=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_explicitconstructorcall_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_increments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_inits=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_throws=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_invocation_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_field_declarations=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_local_declarations=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_parameterized_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_superinterfaces=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_ellipsis=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_parameterized_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_annotation_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_anonymous_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_array_initializer=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_block=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_constructor_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_constant=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_method_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_switch=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation_type_member_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_catch=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_constructor_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_enum_constant=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_for=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_if=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_invocation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_parenthesized_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_switch=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_synchronized=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_while=insert
+org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_return=insert
+org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_throw=insert
+org.eclipse.jdt.core.formatter.insert_space_before_postfix_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_prefix_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_question_in_conditional=insert
+org.eclipse.jdt.core.formatter.insert_space_before_question_in_wildcard=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_semicolon=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_semicolon_in_for=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_unary_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_brackets_in_array_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_braces_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_brackets_in_array_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_annotation_type_member_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_constructor_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_enum_constant=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_invocation=do not insert
+org.eclipse.jdt.core.formatter.keep_else_statement_on_same_line=false
+org.eclipse.jdt.core.formatter.keep_empty_array_initializer_on_one_line=false
+org.eclipse.jdt.core.formatter.keep_imple_if_on_one_line=false
+org.eclipse.jdt.core.formatter.keep_then_statement_on_same_line=false
+org.eclipse.jdt.core.formatter.lineSplit=80
+org.eclipse.jdt.core.formatter.never_indent_block_comments_on_first_column=false
+org.eclipse.jdt.core.formatter.never_indent_line_comments_on_first_column=false
+org.eclipse.jdt.core.formatter.number_of_blank_lines_at_beginning_of_method_body=0
+org.eclipse.jdt.core.formatter.number_of_empty_lines_to_preserve=1
+org.eclipse.jdt.core.formatter.put_empty_statement_on_new_line=true
+org.eclipse.jdt.core.formatter.tabulation.char=space
+org.eclipse.jdt.core.formatter.tabulation.size=4
+org.eclipse.jdt.core.formatter.use_tabs_only_for_leading_indentations=false
+org.eclipse.jdt.core.formatter.wrap_before_binary_operator=true

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedActualTypeSignature.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedActualTypeSignature.java	2009-06-25 08:33:00 UTC (rev 19549)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/interpreter/adapter/ecj/WrappedActualTypeSignature.java	2009-06-25 08:35:44 UTC (rev 19550)
@@ -26,7 +26,7 @@
 			final String te = Signature.getTypeErasure(wrappee);
 			final String p = Signature.getSignatureQualifier(te);
 			final String n = Signature.getSignatureSimpleName(te);
-			return ECJFactory.wrap(p.isEmpty() ? n : p + "." + n);
+			return ECJFactory.wrap(p.length() == 0 ? n : p + "." + n);
 		}
 		case 3:
 			return ECJFactory.wrapSignatures(Signature.getTypeArguments(wrappee));



From L.C.L.Kats at tudelft.nl  Thu Jun 25 11:58:35 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Thu, 25 Jun 2009 09:58:35 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19553 - LennartKats -
	spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
Message-ID: <200906250957.n5P9vEbZ020568@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-06-25 09:58:35 +0000 (Thu, 25 Jun 2009)
New Revision: 19553

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19553&view=rev

Modified:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java

Log:
Public interface tweaks; trying to get old-style recovery working again, to no avail.

Changes:

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-06-25 09:45:25 UTC (rev 19552)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-06-25 09:58:35 UTC (rev 19553)
@@ -163,16 +163,12 @@
     }
     
     public void setRecoverHandler(RecoverAlgorithm recoverHandler) {
-        // HACK: just check the recover handler's type and do the right thing
-        if (recoverHandler instanceof CoarseGrainedRecovery) {
-            setUseStructureRecovery(true);
-        } else if (recoverHandler instanceof NoRecovery) {
-            setUseStructureRecovery(false);
-        } else {
-            throw new org.spoofax.NotImplementedException();
-        }
-        // this.recoverHandler = recoverHandler;
-        // recoverHandler.initialize(this);
+        // TODO: Fix this; structure-recovery should follow the same basic interface!
+        //       (There shouldn't be a instanceof test or separate setUseStructureRecovery method
+        //        even having StructureRecovery inherit from NoRecovery would be better atm)
+        useIntegratedRecovery = false;
+        this.recoverHandler = recoverHandler;
+        recoverHandler.initialize(this);
     }
     
     public RecoveryBase getRecoverHandler() {
@@ -180,17 +176,20 @@
     }
 
     //TODO: Recovery choices (???): structure / structure+bridge / structure+fine-grained / structure+bridge+fine-grained / old backtrack
+    /**
+     * Structure-based recovery with bridge parsing.
+     */
     public void setUseStructureRecovery(boolean useRoughRecovery, IRecoveryParser parser) {
-        this.recoverIntegrator = new RecoveryConnector(this, parser);
-        this.useIntegratedRecovery = useRoughRecovery;
+        useIntegratedRecovery = true;
+        recoverIntegrator = new RecoveryConnector(this, null);
     }
     
-    /*
-     * Structure recovery without bridge parsing
+    /**
+     * Structure-based recovery without bridge parsing.
      */
-    public void setUseStructureRecovery(boolean useRoughRecovery) {        
-        this.useIntegratedRecovery = useRoughRecovery;
-        this.recoverIntegrator = new RecoveryConnector(this, null);
+    @Deprecated
+    public final void setUseStructureRecovery(boolean useRoughRecovery) {        
+        setUseStructureRecovery(useRoughRecovery, null);
     }
     
     /**
@@ -305,13 +304,11 @@
                 recoverIntegrator.recover();                 
                 if(acceptingStack==null && activeStacks.size()>0)
                     return sglrParse(startSymbol);
-            }
-            /*
-            else if(recoverHandler.meetsRecoverCriteria()){
+            } else if(recoverHandler.meetsRecoverCriteria()){
                 recoverHandler.recover();                                
                 if(acceptingStack==null)
                     return sglrParse(startSymbol);
-            }*/
+            }
         } catch (CancellationException e) {
             throw new ParseTimeoutException(this, currentToken, tokensSeen - 1, lineNumber,
                     columnNumber);



From L.C.L.Kats at tudelft.nl  Thu Jun 25 13:18:45 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Thu, 25 Jun 2009 11:18:45 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19554 - LennartKats -
	spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
Message-ID: <200906251117.n5PBHNcZ021854@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-06-25 11:18:45 +0000 (Thu, 25 Jun 2009)
New Revision: 19554

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19554&view=rev

Added:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecoveryAlgorithm.java
Modified:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java

Log:
New StructureRecoveryAlgorithm class for configuring the structure-based recovery approach.

Changes:

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-06-25 09:58:35 UTC (rev 19553)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-06-25 11:18:45 UTC (rev 19554)
@@ -178,6 +178,9 @@
     //TODO: Recovery choices (???): structure / structure+bridge / structure+fine-grained / structure+bridge+fine-grained / old backtrack
     /**
      * Structure-based recovery with bridge parsing.
+     * 
+     * @see #setRecoverHandler(RecoverAlgorithm) Can be used to achieve the same
+     *      effect when using {@link StructureRecoveryAlgorithm}.
      */
     public void setUseStructureRecovery(boolean useRoughRecovery, IRecoveryParser parser) {
         useIntegratedRecovery = true;
@@ -187,7 +190,6 @@
     /**
      * Structure-based recovery without bridge parsing.
      */
-    @Deprecated
     public final void setUseStructureRecovery(boolean useRoughRecovery) {        
         setUseStructureRecovery(useRoughRecovery, null);
     }
@@ -305,7 +307,7 @@
                 if(acceptingStack==null && activeStacks.size()>0)
                     return sglrParse(startSymbol);
             } else if(recoverHandler.meetsRecoverCriteria()){
-                recoverHandler.recover();                                
+                recoverHandler.recover();
                 if(acceptingStack==null)
                     return sglrParse(startSymbol);
             }

Added: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecoveryAlgorithm.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecoveryAlgorithm.java	                        (rev 0)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecoveryAlgorithm.java	2009-06-25 11:18:45 UTC (rev 19554)
@@ -0,0 +1,25 @@
+package org.spoofax.jsglr;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ * 
+ * @see SGLR#setRecoverHandler(RecoverAlgorithm)
+ */
+public final class StructureRecoveryAlgorithm extends NoRecovery {
+    
+    private final IRecoveryParser recoverer;
+    
+    public StructureRecoveryAlgorithm() {
+        this(null);
+    }
+    
+    public StructureRecoveryAlgorithm(IRecoveryParser recoverer) {
+        this.recoverer = recoverer;
+    }
+    
+    
+    @Override
+    public void initialize(SGLR parser) {
+        parser.setUseStructureRecovery(true, recoverer);
+    }
+}



From L.C.L.Kats at tudelft.nl  Thu Jun 25 13:19:50 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Thu, 25 Jun 2009 11:19:50 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19555 - LennartKats - in
	spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser:
	. ast
Message-ID: <200906251118.n5PBISnH021862@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-06-25 11:19:50 +0000 (Thu, 25 Jun 2009)
New Revision: 19555

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19555&view=rev

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/SGLRParseController.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AsfixImploder.java

Log:
Switched to structure-based recovery. Assertion error message fix.

Changes:

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/SGLRParseController.java
===================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/SGLRParseController.java	2009-06-25 11:18:45 UTC (rev 19554)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/SGLRParseController.java	2009-06-25 11:19:50 UTC (rev 19555)
@@ -23,11 +23,11 @@
 import org.eclipse.imp.services.ILanguageSyntaxProperties;
 import org.eclipse.jface.text.IRegion;
 import org.spoofax.jsglr.BadTokenException;
-import org.spoofax.jsglr.CoarseGrainedRecovery;
 import org.spoofax.jsglr.ParseTable;
 import org.spoofax.jsglr.ParseTimeoutException;
 import org.spoofax.jsglr.SGLR;
 import org.spoofax.jsglr.SGLRException;
+import org.spoofax.jsglr.StructureRecoveryAlgorithm;
 import org.spoofax.jsglr.TokenExpectedException;
 import org.spoofax.jsglr.Tools;
 import org.strategoxt.imp.runtime.Debug;
@@ -122,8 +122,10 @@
     	
     	ParseTable table = Environment.getParseTable(language);
 		parser = new JSGLRI(table, startSymbol, this, tokenManager);
+		// TODO: Do something useful with ambiguities
 		parser.setKeepAmbiguities(false); // not interested in ambiguities in the editor
-		parser.setRecoverHandler(new CoarseGrainedRecovery());
+		// parser.setRecoverHandler(new CoarseGrainedRecovery());
+		parser.setRecoverHandler(new StructureRecoveryAlgorithm());
     }
 
     public void initialize(IPath filePath, ISourceProject project,

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AsfixImploder.java
===================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AsfixImploder.java	2009-06-25 11:18:45 UTC (rev 19554)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AsfixImploder.java	2009-06-25 11:19:50 UTC (rev 19555)
@@ -345,8 +345,8 @@
 			: "Character from asfix stream (" + character.getInt()
 			+ ") must be in lex stream ("
 			+ (tokenizer.getLexStream().getInputChars().length > offset 
-			   ? "???"
-			   : (int) tokenizer.getLexStream().getCharValue(offset)) + ")";
+			   ? (int) tokenizer.getLexStream().getCharValue(offset)
+			   :  "???") + ")";
 		
 		offset++;
 	}



From L.C.L.Kats at tudelft.nl  Thu Jun 25 16:56:52 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Thu, 25 Jun 2009 14:56:52 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19556 - LennartKats -
	sglr-recovery/trunk/permissive-grammars/trans/make-permissive
	spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
Message-ID: <200906251455.n5PEtUPU024588@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-06-25 14:56:51 +0000 (Thu, 25 Jun 2009)
New Revision: 19556

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19556&view=rev

Added:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ProductionType.java
Modified:
   sglr-recovery/trunk/permissive-grammars/trans/make-permissive/insert-sections.astr
   sglr-recovery/trunk/permissive-grammars/trans/make-permissive/sketch.txt
   sglr-recovery/trunk/permissive-grammars/trans/make-permissive/water-sections.astr
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Action.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Disambiguator.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/FatalException.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Label.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParseTable.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Production.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ProductionAttributes.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Reduce.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ReduceLookahead.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java

Log:
- Changed the parser and grammar generator to use {recover} for recovery attributes
  (rebuild everything with 'make' to ensure it works again)

- Added a System.err.println() warning in case the recovery parser is used
  with a parse table without {recover} productions

- Introduced a ProductionType class that defines the AVOID/PREFER/... constants

Changes:

Modified: sglr-recovery/trunk/permissive-grammars/trans/make-permissive/insert-sections.astr
===================================================================
--- sglr-recovery/trunk/permissive-grammars/trans/make-permissive/insert-sections.astr	2009-06-25 11:19:50 UTC (rev 19555)
+++ sglr-recovery/trunk/permissive-grammars/trans/make-permissive/insert-sections.astr	2009-06-25 14:56:51 UTC (rev 19556)
@@ -60,7 +60,7 @@
   eq lexical-insert-prod:
     prod([lit(_) | pattern-and-lit], _, _) ->
     |[ 
-       -> ~closinglit {avoid, cons("INSERTION")}
+       -> ~closinglit {recover, cons("INSERTION")}
     ]|
     where
       id.in-context-free-section
@@ -89,7 +89,7 @@
   def lexical-insert-open-prod:
     prod([openinglit | pattern-and-lit], _, _) ->
     |[ 
-       -> ~openinglit {avoid, cons("INSERTION")}
+       -> ~openinglit {recover, cons("INSERTION")}
     ]|
     where
       id.in-context-free-section
@@ -109,7 +109,7 @@
   eq lexical-insert-prod:
     prod([openinglit | pattern-and-lit], sort, _) ->
     |[ 
-       ~openinglit                    -> ~openingsort {avoid}
+       ~openinglit                    -> ~openingsort {recover}
        ~openingsort ~pattern WATEREOF -> ~sort {cons("INSERTEND")}
     ]|
     where
@@ -143,7 +143,7 @@
   // i.e., in Java, the original production is:
   //   "\""             StringPart* "\"" -> StringLiteral {cons("String")}
   // and cannot just be transformed to:
-  //   INSERTOPENQUOTE0 StringPart* "\n" -> StringLiteral    {avoid, cons("INSERTEND")}
+  //   INSERTOPENQUOTE0 StringPart* "\n" -> StringLiteral {recover, cons("INSERTEND")}
   
   eq kernel-insert-prod =
     id.in-kernel-section;
@@ -152,7 +152,7 @@
   def insert-quote-prod:
     prod([openingquote | pattern-and-quote], sort, _) ->
     |[ 
-       ~openingquote                       -> ~openingquotesort {avoid}
+       ~openingquote                       -> ~openingquotesort {recover}
        ~openingquotesort ~pattern "\\n"    -> ~sort             {cons("INSERTEND")}
        ~openingquotesort ~pattern WATEREOF -> ~sort             {cons("INSERTEND")}
     ]|
@@ -212,7 +212,7 @@
 
   def lexical-insert-all-prod:
     lit @ lit(_) ->
-    |[ -> ~lit {avoid, cons("INSERTION")} ]|
+    |[ -> ~lit {recover, cons("INSERTION")} ]|
     where
       id.in-context-free-section
     where

Modified: sglr-recovery/trunk/permissive-grammars/trans/make-permissive/sketch.txt
===================================================================
--- sglr-recovery/trunk/permissive-grammars/trans/make-permissive/sketch.txt	2009-06-25 11:19:50 UTC (rev 19555)
+++ sglr-recovery/trunk/permissive-grammars/trans/make-permissive/sketch.txt	2009-06-25 14:56:51 UTC (rev 19556)
@@ -10,7 +10,7 @@
     BlockStm         BlockStmStar     -> BlockStmStar {ast("<conc([<1>],<2>)>)")}
     BlockStmMetaStar BlockStmStar     -> BlockStmStar {ast("<conc(<1>,<2>)>)")}
     BlockStmStar     BlockStmMetaStar -> BlockStmStar {ast("<conc(<1>,<2>)>)")}
-    WATER            BlockStmStar     -> BlockStmStar {ast("<conc([Water(<1>)],<2>)>"), avoid}
+    WATER            BlockStmStar     -> BlockStmStar {ast("<conc([Water(<1>)],<2>)>"), recover}
                                       -> BlockStmStar {ast("[]")}
 
 Note: WATER for nestable scopes should probably not accept "}".

Modified: sglr-recovery/trunk/permissive-grammars/trans/make-permissive/water-sections.astr
===================================================================
--- sglr-recovery/trunk/permissive-grammars/trans/make-permissive/water-sections.astr	2009-06-25 11:19:50 UTC (rev 19555)
+++ sglr-recovery/trunk/permissive-grammars/trans/make-permissive/water-sections.astr	2009-06-25 14:56:51 UTC (rev 19556)
@@ -10,9 +10,9 @@
          WATER WATERTOKEN WATERTOKENSTART WATERTOKENSEPARATOR
        
        lexical syntax
-         [A-Za-z0-9\_]                  -> WATERTOKENSTART {avoid}
+         [A-Za-z0-9\_]                  -> WATERTOKENSTART {recover}
          WATERTOKENSTART [A-Za-z0-9\_]* -> WATERTOKEN
-         ~[A-Za-z0-9\_\ \t\12\r\n]      -> WATERTOKENSEPARATOR {avoid}
+         ~[A-Za-z0-9\_\ \t\12\r\n]      -> WATERTOKENSEPARATOR {recover}
          WATERTOKEN                     -> WATER
          WATERTOKENSEPARATOR            -> WATER
   

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Action.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Action.java	2009-06-25 11:19:50 UTC (rev 19555)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Action.java	2009-06-25 14:56:51 UTC (rev 19556)
@@ -51,7 +51,7 @@
         for(ActionItem ai : items) {
             if(ai instanceof Reduce) {
                 Reduce r = (Reduce) ai;
-                if(r.status == Reduce.REJECT)
+                if(r.status == ProductionType.REJECT)
                     return true;
             }
                 
@@ -63,7 +63,7 @@
         for(ActionItem ai : items)
             if(ai instanceof Reduce) {
                 Reduce r = (Reduce) ai;
-                if(r.status == Reduce.PREFER)
+                if(r.status == ProductionType.PREFER)
                     return true;
             }
         return false;
@@ -73,7 +73,7 @@
         for(ActionItem ai : items)
             if(ai instanceof Reduce) {
                 Reduce r = (Reduce) ai;
-                if(r.status == Reduce.AVOID) {
+                if(r.status == ProductionType.AVOID) {
                     if(SGLR.isDebugging()) {
                         Tools.debug(this);
                     }

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Disambiguator.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Disambiguator.java	2009-06-25 11:19:50 UTC (rev 19555)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Disambiguator.java	2009-06-25 14:56:51 UTC (rev 19556)
@@ -838,9 +838,9 @@
             return countPrefers(((Amb) t).getAlternatives());
         } else if (t instanceof ParseNode) {
             int type = getProductionType(t);
-            if (type == ProductionAttributes.PREFER)
+            if (type == ProductionType.PREFER)
                 return 1;
-            else if (type == ProductionAttributes.AVOID)
+            else if (type == ProductionType.AVOID)
                 return 0;
             return countPrefers(((ParseNode) t).getKids());
         }
@@ -863,9 +863,9 @@
             return countAvoids(((Amb) t).getAlternatives());
         } else if (t instanceof ParseNode) {
             int type = getProductionType(t);
-            if (type == ProductionAttributes.PREFER)
+            if (type == ProductionType.PREFER)
                 return 0;
-            else if (type == ProductionAttributes.AVOID)
+            else if (type == ProductionType.AVOID)
                 return 1;
             return countAvoids(((ParseNode) t).getKids());
         }
@@ -953,8 +953,8 @@
 
         int prodType = getProductionType(t);
 
-        if (t instanceof ParseNode && prodType != ProductionAttributes.PREFER
-                && prodType != ProductionAttributes.AVOID) {
+        if (t instanceof ParseNode && prodType != ProductionType.PREFER
+                && prodType != ProductionType.AVOID) {
 
             Label prod = getLabel(t);
             ParseNode n = (ParseNode) t;
@@ -964,8 +964,8 @@
 
                 int prodTypeX = getProductionType(x);
 
-                if (x instanceof ParseNode && prodTypeX != ProductionAttributes.PREFER
-                        && prodTypeX != ProductionAttributes.AVOID) {
+                if (x instanceof ParseNode && prodTypeX != ProductionType.PREFER
+                        && prodTypeX != ProductionType.AVOID) {
                     prod = getLabel(x);
                 } else {
                     return n;
@@ -987,7 +987,7 @@
     }
 
     private int getProductionType(IParseNode t) {
-        return getLabel(t).getAttributes().type;
+        return getLabel(t).getAttributes().getType();
     }
 
     private boolean isMoreEager(IParseNode left, IParseNode right) {

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/FatalException.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/FatalException.java	2009-06-25 11:19:50 UTC (rev 19555)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/FatalException.java	2009-06-25 14:56:51 UTC (rev 19556)
@@ -7,7 +7,7 @@
  */
 package org.spoofax.jsglr;
 
-public class FatalException extends RuntimeException {
+public class FatalException extends IllegalStateException {
 
     private static final long serialVersionUID = 7683640314752021983L;
 

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Label.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Label.java	2009-06-25 11:19:50 UTC (rev 19555)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Label.java	2009-06-25 14:56:51 UTC (rev 19556)
@@ -31,12 +31,16 @@
     }
 
     public boolean isLeftAssociative() {
-        return productionAttributes.type == ProductionAttributes.LEFT_ASSOCIATIVE;
+        return productionAttributes.getType() == ProductionType.LEFT_ASSOCIATIVE;
     }
 
     public boolean isRightAssociative() {
-        return productionAttributes.type == ProductionAttributes.RIGHT_ASSOCIATIVE;
+        return productionAttributes.getType() == ProductionType.RIGHT_ASSOCIATIVE;
     }
+    
+    public boolean isRecoverProduction() {
+        return productionAttributes.isRecoverProduction();
+    }
 
     public boolean isMoreEager(Label rightProd) {
         return productionAttributes.isMoreEager(rightProd.productionAttributes);

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParseTable.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParseTable.java	2009-06-25 11:19:50 UTC (rev 19555)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParseTable.java	2009-06-25 14:56:51 UTC (rev 19556)
@@ -35,11 +35,13 @@
     
     private Associativity[] associativities;
     
-    private Boolean hasRejects;
+    private boolean hasRejects;
     
-    private Boolean hasAvoids;
+    private boolean hasAvoids;
     
-    private Boolean hasPrefers;
+    private boolean hasPrefers;
+    
+    private boolean hasRecovers;
 
     transient private ATermFactory factory;
 
@@ -193,45 +195,56 @@
             throws InvalidParseTableException {
         if (attr.getName().equals("attrs")) {
             int type = 0;
+            boolean isRecover = false;
             ATerm term = null;
+            
             for (ATermList ls = (ATermList) attr.getChildAt(0); !ls.isEmpty(); ls = ls.getNext()) {
                 ATermAppl t = (ATermAppl) ls.getFirst();
                 String ctor = t.getName();
                 if (ctor.equals("reject")) {
-                    type = ProductionAttributes.REJECT;
+                    type = ProductionType.REJECT;
+                    hasRejects = true;
                 } else if (ctor.equals("prefer")) {
-                    type = ProductionAttributes.PREFER;
+                    type = ProductionType.PREFER;
+                    hasPrefers = true;
                 } else if (ctor.equals("avoid")) {
-                    type = ProductionAttributes.AVOID;
+                    type = ProductionType.AVOID;
+                    hasAvoids = true;
                 } else if (ctor.equals("bracket")) {
-                    type = ProductionAttributes.BRACKET;
-                } else if (ctor.equals("assoc")) {
-                    ATermAppl a = (ATermAppl) t.getChildAt(0);
-                    if (a.getName().equals("left") || a.getName().equals("assoc")) {
-                    	// ('assoc' is identical to 'left' for the parser)
-                        type = ProductionAttributes.LEFT_ASSOCIATIVE;
-                    } else if (a.getName().equals("right")) {
-                        type = ProductionAttributes.RIGHT_ASSOCIATIVE;
+                    type = ProductionType.BRACKET;
+                } else {
+                    if (ctor.equals("assoc")) {
+                        ATermAppl a = (ATermAppl) t.getChildAt(0);
+                        if (a.getName().equals("left") || a.getName().equals("assoc")) {
+                        	// ('assoc' is identical to 'left' for the parser)
+                            type = ProductionType.LEFT_ASSOCIATIVE;
+                        } else if (a.getName().equals("right")) {
+                            type = ProductionType.RIGHT_ASSOCIATIVE;
+                        } else {
+                            throw new InvalidParseTableException("Unknown assocativity: " + a.getName());
+                        }
+                    } else if (	ctor.equals("term") && t.getChildCount() == 1) {
+                        // Term needs to be shaped as term(cons(Constructor)) to be a constructor
+                    	if(t.getChildAt(0) instanceof ATermAppl) {
+                    	    ATermAppl child = (ATermAppl) t.getChildAt(0);
+                            if (child.getChildCount() == 1 && child.getName().equals("cons")) {
+                    			term = (ATerm) t.getChildAt(0).getChildAt(0);
+                    		} else if (child.getChildCount() == 0 && child.getName().equals("recover")) {
+                    		    hasRecovers = isRecover = true;
+                    		}
+                    	}
+                    	// TODO Support other terms that are not a constructor (custom annotations)
+                    } else if (ctor.equals("id")) {
+                        // FIXME not certain about this
+                        term = (ATerm) t.getChildAt(0);
                     } else {
-                        throw new InvalidParseTableException("Unknown assocativity: " + a.getName());
+                        throw new InvalidParseTableException("Unknown attribute: " + t);
                     }
-                } else if (	ctor.equals("term") && t.getChildCount() == 1) {
-                	// Term needs to be shaped as term(cons(Constructor)) to be a constructor
-                	if(	t.getChildAt(0) instanceof ATermAppl &&
-                		((ATermAppl)t.getChildAt(0)).getName().equals("cons") && 
-                		((ATermAppl)t.getChildAt(0)).getChildCount() == 1		)
-                			term = (ATerm) t.getChildAt(0).getChildAt(0);
-                	// TODO Support other terms that are not a constructor (custom annotations)
-                } else if (ctor.equals("id")) {
-                    // FIXME not certain about this
-                    term = (ATerm) t.getChildAt(0);
-                } else {
-                    throw new InvalidParseTableException("Unknown attribute: " + t);
                 }
             }
-            return new ProductionAttributes(type, term);
+            return new ProductionAttributes(term, type, isRecover);
         } else if (attr.getName().equals("no-attrs")) {
-            return new ProductionAttributes(ProductionAttributes.NO_TYPE, null);
+            return new ProductionAttributes(null, ProductionType.NO_TYPE, false);
         }
         throw new InvalidParseTableException("Unknown attribute type: " + attr);
     }
@@ -292,7 +305,8 @@
                 int productionArity = Term.intAt(a, 0);
                 int label = Term.intAt(a, 1);
                 int status = Term.intAt(a, 2);
-                item = makeReduce(productionArity, label, status);
+                boolean isRecoverAction = getLabel(label).getAttributes().isRecoverProduction();
+                item = makeReduce(productionArity, label, status, isRecoverAction);
             } else if(a.getName().equals("reduce") && a.getAFun().getArity() == 4) {
                 int productionArity = Term.intAt(a, 0);
                 int label = Term.intAt(a, 1);
@@ -345,8 +359,8 @@
         return new ReduceLookahead(productionArity, label, status, charClasses);
     }
 
-    private Reduce makeReduce(int arity, int label, int status) {
-        Reduce r = new Reduce(arity, label, status);
+    private Reduce makeReduce(int arity, int label, int status, boolean isRecoverAction) {
+        Reduce r = new Reduce(arity, label, status, isRecoverAction);
         Reduce cached = reduceMap.get(r);
         if (cached == null) {
             reduceMap.put(r, r);
@@ -488,46 +502,26 @@
         return total;
     }
 
-    public boolean hasRejects() {
-        if (hasRejects == null) {
-            for (State s : states) {
-                if (s.rejectable()) {
-                    return hasRejects = true;                    
-                }
-            }
-            hasRejects = false;
-        }
-        return hasRejects;
-    }
-
     public boolean hasPriorities() {
         return priorities.length > 0 || associativities.length > 0;
     }
 
+    public boolean hasRejects() {
+        return hasRejects;
+    }
+
     public boolean hasPrefers() {
-        if (hasPrefers == null) {
-            for (State s : states) {
-                if (s.hasPrefer()) {
-                    return hasPrefers = true;
-                }
-            }
-            hasPrefers = false;
-        }
         return hasPrefers;
     }
 
     public boolean hasAvoids() {
-        if (hasAvoids == null) {
-            for (State s : states) {
-                if (s.hasAvoid()) {
-                    return hasAvoids = true;
-                }
-            }
-            hasAvoids = false;
-        }
         return hasAvoids;
     }
     
+    public boolean hasRecovers() {
+        return hasRecovers;
+    }
+    
     public boolean hasPrefersOrAvoids() {
         return hasAvoids() || hasPrefers();
     }

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Production.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Production.java	2009-06-25 11:19:50 UTC (rev 19555)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Production.java	2009-06-25 14:56:51 UTC (rev 19556)
@@ -7,8 +7,10 @@
  */
 package org.spoofax.jsglr;
 
-import java.util.List;
+import static org.spoofax.jsglr.ProductionType.*;
+
 import java.io.Serializable;
+import java.util.List;
 
 public class Production implements Serializable {
 
@@ -19,24 +21,16 @@
     public final int label;
 
     public final int status;
+    
+    private final boolean isRecover;
 
-    // FIXME: These should be factored out in a separate constant class.
-    public static final int NORMAL = Reduce.NORMAL;
-
-    public static final int PREFER = Reduce.PREFER;
-
-    public static final int AVOID = Reduce.AVOID;
-
-    public static final int REJECT = Reduce.REJECT;
-
-    public Production(int arity, int label, int status) {
+    public Production(int arity, int label, int status, boolean isRecover) {
         this.arity = arity;
         this.label = label;
         this.status = status;
-
+        this.isRecover = isRecover;
     }
 
-
     public IParseNode apply(List<IParseNode> kids) {
         switch(status) {
         case REJECT:
@@ -45,15 +39,19 @@
             return new ParseAvoid(label, kids);
         case PREFER:
             return new ParsePrefer(label, kids);
-        case NORMAL:
+        case NO_TYPE:
             return new ParseNode(label, kids);
         }
-        throw new FatalException();
+        throw new IllegalStateException();
     }
 
-    boolean isReject() {
+    public boolean isRejectProduction() {
         return status == REJECT;
     }
+    
+    public boolean isRecoverProduction() {
+        return isRecover;
+    }
 
     @Override
     public boolean equals(Object obj) {

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ProductionAttributes.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ProductionAttributes.java	2009-06-25 11:19:50 UTC (rev 19555)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ProductionAttributes.java	2009-06-25 14:56:51 UTC (rev 19556)
@@ -7,6 +7,8 @@
  */
 package org.spoofax.jsglr;
 
+import static org.spoofax.jsglr.ProductionType.*;
+
 import java.io.Serializable;
 
 import aterm.ATerm;
@@ -15,27 +17,16 @@
 
     private static final long serialVersionUID = 556855017447626835L;
 
-    public final static int NO_TYPE = 0;
+    private final int type;
+    
+    private final boolean isRecover;
 
-    public final static int LEFT_ASSOCIATIVE = 1;
+    private final transient ATerm abstractCtor;
 
-    public final static int RIGHT_ASSOCIATIVE = 2;
-
-    public final static int PREFER = 3;
-
-    public final static int AVOID = 4;
-
-    public final static int BRACKET = 5;
-
-    public final static int REJECT = 6;
-
-    protected final int type;
-
-    protected final transient ATerm abstractCtor;
-
-    ProductionAttributes(int type, ATerm ctor) {
+    ProductionAttributes(ATerm ctor, int type, boolean isRecover) {
         this.type = type;
         this.abstractCtor = ctor;
+        this.isRecover = isRecover;
     }
 
     public final int getType() {
@@ -45,6 +36,10 @@
     public final ATerm getTerm() {
         return abstractCtor;
     }
+    
+    public boolean isRecoverProduction() {
+        return isRecover;
+    }
 
     public boolean isMoreEager(ProductionAttributes other) {
         return type != other.type && (type == PREFER || other.type == AVOID);

Added: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ProductionType.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ProductionType.java	                        (rev 0)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ProductionType.java	2009-06-25 14:56:51 UTC (rev 19556)
@@ -0,0 +1,27 @@
+package org.spoofax.jsglr;
+
+/**
+ * SGLR production types, used in the parse table format.
+ * 
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public final class ProductionType {
+    
+    // FIXME: The 3, 5, and 6 values may not correspond to the parse table format
+
+    public final static int NO_TYPE = 0;
+
+    public final static int REJECT = 1;
+
+    public final static int PREFER = 2;
+
+    protected final static int BRACKET = 3;
+
+    public final static int AVOID = 4;
+
+    protected final static int LEFT_ASSOCIATIVE = 5;
+
+    protected final static int RIGHT_ASSOCIATIVE = 6;
+    
+    private ProductionType() {}
+}

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Reduce.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Reduce.java	2009-06-25 11:19:50 UTC (rev 19555)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Reduce.java	2009-06-25 14:56:51 UTC (rev 19556)
@@ -25,14 +25,9 @@
 	public SpecialAttribute specialAttribute;
 
 	public Arguments eTree;
-    
-    public static final int NORMAL = 0;
-    public static final int REJECT = 1;
-    public static final int PREFER = 2;
-    public static final int AVOID = 4;
 
     
-    public Reduce(int arity, int label, int status) {
+    public Reduce(int arity, int label, int status, boolean isRecoverAction) {
         
         super(REDUCE);
         
@@ -40,7 +35,7 @@
         this.label = label;
         this.status = status;
       
-        production = new Production(arity, label, status);
+        production = new Production(arity, label, status, isRecoverAction);
     }
     
     

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ReduceLookahead.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ReduceLookahead.java	2009-06-25 11:19:50 UTC (rev 19555)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ReduceLookahead.java	2009-06-25 14:56:51 UTC (rev 19556)
@@ -29,7 +29,7 @@
         this.status = status;
         this.charClasses = charClasses;
 
-        production = new Production(arity, label, status);
+        production = new Production(arity, label, status, false);
     }
 
     @Override

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-06-25 11:19:50 UTC (rev 19555)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-06-25 14:56:51 UTC (rev 19556)
@@ -104,6 +104,8 @@
     private RecoveryConnector recoverIntegrator;
     
     private boolean useIntegratedRecovery;
+
+    private boolean reduceRecoverOnly;
     
     //Keeps track of the indentation for each line
     public IndentationHandler getIndentHandler() {
@@ -163,12 +165,11 @@
     }
     
     public void setRecoverHandler(RecoverAlgorithm recoverHandler) {
-        // TODO: Fix this; structure-recovery should follow the same basic interface!
-        //       (There shouldn't be a instanceof test or separate setUseStructureRecovery method
-        //        even having StructureRecovery inherit from NoRecovery would be better atm)
         useIntegratedRecovery = false;
         this.recoverHandler = recoverHandler;
         recoverHandler.initialize(this);
+        if (!parseTable.hasRecovers() && recoverHandler.getClass() != NoRecovery.class)
+            System.err.println("Warning: parse table has no recovery productions");
     }
     
     public RecoveryBase getRecoverHandler() {
@@ -584,16 +585,15 @@
             logAfterDoReductions();
         }
     }
-
-    private boolean reduceRecoverOnly;
     
     private boolean recoverModeOk(Frame st, Production prod) {
-        if(useIntegratedRecovery && prod.status == Reduce.AVOID && !reduceRecoverOnly && recoverTolerance>0){
+        if(useIntegratedRecovery && prod.isRecoverProduction() && !reduceRecoverOnly && recoverTolerance>0){
            //if(findStack(recoveryActor, st.state)==null)
             if(!recoveryActor.contains(st))
                 recoveryActor.addFirst(st);
         }
-        return (!useIntegratedRecovery || ((prod.status == Reduce.AVOID)==reduceRecoverOnly));
+        // TODO: is this condition right??
+        return !useIntegratedRecovery || prod.isRecoverProduction() == reduceRecoverOnly;
     }
     
     private void doLimitedReductions(Frame st, Production prod, Link l) throws IOException { //Todo: Look add sharing code with doReductions
@@ -639,7 +639,7 @@
         IParseNode t = prod.apply(kids);
         Frame st1; 
         Link nl;
-        if(prod.status == Reduce.AVOID){
+        if(prod.status == ProductionType.AVOID){
             if(!useIntegratedRecovery)
             {                
                 recoverHandler.handleRecoverProduction(st0, s, length, numberOfAvoids, t);
@@ -658,7 +658,7 @@
 
             if (nl != null) {
                 logAmbiguity(st0, prod, st1, nl);
-                if (prod.isReject()) {
+                if (prod.isRejectProduction()) {
                     nl.reject();
                 }
                 handleAmbiguity(numberOfAvoids, t, nl);
@@ -666,7 +666,7 @@
             } else {
                 nl = st1.addLink(st0, t, length);
                 nl.avoidCount = numberOfAvoids;
-                if (prod.isReject())
+                if (prod.isRejectProduction())
                     nl.reject();                
                 logAddedLink(st0, st1, nl);              
                 actorOnActiveStacksOverNewLink(nl);
@@ -720,7 +720,7 @@
         if(Tools.tracing) {
             TRACE("SG_AddStack() - " + st1.state.stateNumber);
         }
-        if (prod.isReject()) {
+        if (prod.isRejectProduction()) {
             if (Tools.logging) {
                 Tools.logger("Reject [new]");
             }
@@ -769,7 +769,7 @@
 
     private int calcAvoidCount(Production prod, Path path) {
         int numberOfAvoids = path.getAvoidCount();
-        if(prod.status == Reduce.AVOID)
+        if(prod.status == ProductionType.AVOID)
         {
             numberOfAvoids +=1;
         }
@@ -778,7 +778,7 @@
     
     private int calcAvoidCountResricted(Production prod, Path path) {
         int numberOfAvoids = path.getAvoidCount(lengthAvoidCheck);
-        if(prod.status == Reduce.AVOID)
+        if(prod.status == ProductionType.AVOID)
         {
             numberOfAvoids +=1;
         }
@@ -1261,7 +1261,7 @@
     private void logAmbiguity(Frame st0, Production prod, Frame st1, Link nl) {
         if (Tools.logging) {
             Tools.logger("Ambiguity: direct link ", st0.state.stateNumber, " -> ",
-                         st1.state.stateNumber, " ", (prod.isReject() ? "{reject}" : ""));
+                         st1.state.stateNumber, " ", (prod.isRejectProduction() ? "{reject}" : ""));
             if (nl.label instanceof ParseNode) {
                 Tools.logger("nl is ", nl.isRejected() ? "{reject}" : "", " for ",
                              ((ParseNode) nl.label).label);



From L.C.L.Kats at tudelft.nl  Thu Jun 25 17:07:54 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Thu, 25 Jun 2009 15:07:54 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19557 - LennartKats -
	spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast
Message-ID: <200906251506.n5PF6Wg8024983@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-06-25 15:07:54 +0000 (Thu, 25 Jun 2009)
New Revision: 19557

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19557&view=rev

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AsfixImploder.java

Log:
Fixed a case with nested ambiguities the imploder couldn't handle.

Changes:

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AsfixImploder.java
===================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AsfixImploder.java	2009-06-25 14:56:51 UTC (rev 19556)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AsfixImploder.java	2009-06-25 15:07:54 UTC (rev 19557)
@@ -257,11 +257,13 @@
 		final ATermListImpl ambs = termAt(node, 0);
 		
 		ATermAppl lastNonAvoid = null;
+		ATermAppl firstOption = null;
 		boolean multipleNonAvoids = false;
 		
 	alts:
 		for (int i = 0; i < ambs.getLength(); i++) {
 			ATermAppl prod = resolveAmbiguities(termAt(ambs, i));
+			if (firstOption == null) firstOption = prod;
 			ATermAppl appl = termAt(prod, APPL_PROD);
 			ATermAppl attrs = termAt(appl, PROD_ATTRS);
 			
@@ -271,7 +273,7 @@
 				for (int j = 0; j < attrList.getLength(); j++) {
 					ATerm attr = termAt(attrList, j);
 					if (isAppl(attr) && "prefer".equals(asAppl(attr).getName())) {
-						return resolveAmbiguities(prod);
+						return prod;
 					} else if (isAppl(attr) && "avoid".equals(asAppl(attr).getName())) {
 						continue alts;
 					}
@@ -286,10 +288,10 @@
 		}
 		
 		if (!multipleNonAvoids) {
-			return lastNonAvoid != null ? lastNonAvoid : applAt(ambs, 0);
+			return lastNonAvoid != null ? lastNonAvoid : firstOption;
 		} else {
 			if (Debug.ENABLED && !lexicalContext) reportUnresolvedAmb(ambs);
-			return resolveAmbiguities(ambs.getFirst());
+			return firstOption;
 		}
 	}
 	



From L.C.L.Kats at tudelft.nl  Fri Jun 26 09:57:36 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Fri, 26 Jun 2009 07:57:36 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19558 - LennartKats -
	in strc-java/trunk/java/runtime/org/strategoxt/lang: . compat
	compat/override
Message-ID: <200906260756.n5Q7uD3Z003422@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-06-26 07:57:35 +0000 (Fri, 26 Jun 2009)
New Revision: 19558

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19558&view=rev

Added:
   strc-java/trunk/java/runtime/org/strategoxt/lang/DynamicStrategy.java
   strc-java/trunk/java/runtime/org/strategoxt/lang/InteropSDefT.java
   strc-java/trunk/java/runtime/org/strategoxt/lang/InteropStrategyDef.java
Modified:
   strc-java/trunk/java/runtime/org/strategoxt/lang/Context.java
   strc-java/trunk/java/runtime/org/strategoxt/lang/InteropStrategy.java
   strc-java/trunk/java/runtime/org/strategoxt/lang/SRTS_all.java
   strc-java/trunk/java/runtime/org/strategoxt/lang/StrategoExit.java
   strc-java/trunk/java/runtime/org/strategoxt/lang/Strategy.java
   strc-java/trunk/java/runtime/org/strategoxt/lang/compat/libstrc_compat.java
   strc-java/trunk/java/runtime/org/strategoxt/lang/compat/override/
   strc-java/trunk/java/runtime/org/strategoxt/lang/compat/override/jsglr-parser-compat.str
   strc-java/trunk/java/runtime/org/strategoxt/lang/compat/override/strc-compat.str

Log:
- New HybridInterpreter class that uses the compiled libraries

- Avoided using generic types in the Strategy class, since this makes
  Sun's compiler copy them to all subclasses.


Changes (first 1000 lines of the diffs):

Modified: strc-java/trunk/java/runtime/org/strategoxt/lang/Context.java
===================================================================
--- strc-java/trunk/java/runtime/org/strategoxt/lang/Context.java	2009-06-25 15:07:54 UTC (rev 19557)
+++ strc-java/trunk/java/runtime/org/strategoxt/lang/Context.java	2009-06-26 07:57:35 UTC (rev 19558)
@@ -2,6 +2,8 @@
 
 import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
 
 import org.spoofax.interpreter.adapter.aterm.BAFBasicTermFactory;
 import org.spoofax.interpreter.core.InterpreterException;
@@ -26,11 +28,9 @@
 	
 	private final InteropContext interopContext = new InteropContext(this);
 
-    private final HashMap<String, IOperatorRegistry> operatorRegistryMap =
-    	new HashMap<String, IOperatorRegistry>();
+    private final Map<String, IOperatorRegistry> operatorRegistryMap;
 
-    private final ArrayList<IOperatorRegistry> operatorRegistries =
-    	new ArrayList<IOperatorRegistry>();
+    private final List<IOperatorRegistry> operatorRegistries;
     
     private final CompatManager compat = new CompatManager();
     
@@ -39,25 +39,46 @@
 	
 	private final ITermFactory factory;
     
-    private String lastPrimitiveName1, lastPrimitiveName2;
+    private transient String lastPrimitiveName1, lastPrimitiveName2;
     
-    private AbstractPrimitive lastPrimitive1, lastPrimitive2;
+    private transient AbstractPrimitive lastPrimitive1, lastPrimitive2;
     
     public Context() {
     	this(new BAFBasicTermFactory());
     }
     
+    public Context(Context other) {
+    	this(other.getFactory());
+    	operatorRegistryMap.clear();
+    	operatorRegistryMap.putAll(other.operatorRegistryMap);
+    	operatorRegistries.addAll(other.operatorRegistries);
+    }
+    
     public Context(ITermFactory factory) {
-    	this.factory = factory;
+    	this(factory, new HashMap<String, IOperatorRegistry>(), new ArrayList<IOperatorRegistry>());
         SSLLibrary ssl = new SSLLibrary();
 		operatorRegistryMap.put(SSLLibrary.REGISTRY_NAME, ssl);
         operatorRegistries.add(ssl);
     }
+    
+    protected Context(ITermFactory factory, Map<String, IOperatorRegistry> operatorRegistryMap, List<IOperatorRegistry> operatorRegistries) {
+    	this.factory = factory;
+    	this.operatorRegistryMap = operatorRegistryMap;
+    	this.operatorRegistries = operatorRegistries;
+    }
 	
 	public final ITermFactory getFactory() {
 		return factory;
 	}
 	
+	public List<IOperatorRegistry> getOperatorRegistries() {
+		return operatorRegistries;
+	}
+	
+	public Map<String, IOperatorRegistry> getOperatorRegistryMap() {
+		return operatorRegistryMap;
+	}
+	
 	public UncaughtExceptionHandler getExceptionHandler() {
 		return exceptionHandler;
 	}
@@ -78,8 +99,13 @@
 
     public final void addOperatorRegistry(IOperatorRegistry or) {
         IOperatorRegistry previous = operatorRegistryMap.put(or.getOperatorRegistryName(), or);
-        if (previous != null) operatorRegistries.remove(previous);
-        operatorRegistries.add(or);
+        if (previous == null) {
+        	operatorRegistries.add(or);
+        } else {
+        	int i = operatorRegistries.indexOf(previous);
+        	operatorRegistries.remove(previous);
+        	operatorRegistries.add(i, or);
+        }
     }
     
     public void postInit(String componentName) {
@@ -110,14 +136,18 @@
     	return strategy.invoke(this, term);
     }
     
-    public IStrategoTerm invokePrimitive(String name, IStrategoTerm term, IStrategy[] args, IStrategoTerm[] targs) {
+    public final IStrategoTerm invokePrimitive(String name, IStrategoTerm term, IStrategy[] sargs, IStrategoTerm[] targs) {
     	AbstractPrimitive primitive = lookupOperator(name);
     	if (primitive == null)
     		throw new StrategoException("Illegal primitive invoked: " + name);
 
-    	interopContext.setCurrent(term);
+    	return invokePrimitive(primitive, term, sargs, targs);
+    }
+
+	public IStrategoTerm invokePrimitive(AbstractPrimitive primitive, IStrategoTerm term, IStrategy[] sargs, IStrategoTerm[] targs) {
+		interopContext.setCurrent(term);
 		try {
-			if (primitive.call(interopContext, InteropStrategy.toInteropStrategies(args), targs)) {
+			if (primitive.call(interopContext, InteropStrategy.toInteropStrategies(sargs), targs)) {
 				return interopContext.current();
 			} else {
 				return null;
@@ -126,11 +156,11 @@
 			uninit();
 			throw new StrategoExit(e.getValue());
 		} catch (InterpreterException e) {
-			throw new StrategoException("Exception in execution of primitive '" + name + "'", e);
+			throw new StrategoException("Exception in execution of primitive '" + primitive.getName() + "'", e);
 		} catch (RuntimeException e) {
-			throw new StrategoException("Exception in execution of primitive '" + name + "'", e);
+			throw new StrategoException("Exception in execution of primitive '" + primitive.getName() + "'", e);
 		}
-    }
+	}
 
 	public AbstractPrimitive lookupOperator(String name) {
 		if (lastPrimitiveName1 == name) {

Added: strc-java/trunk/java/runtime/org/strategoxt/lang/DynamicStrategy.java
===================================================================
--- strc-java/trunk/java/runtime/org/strategoxt/lang/DynamicStrategy.java	                        (rev 0)
+++ strc-java/trunk/java/runtime/org/strategoxt/lang/DynamicStrategy.java	2009-06-26 07:57:35 UTC (rev 19558)
@@ -0,0 +1,184 @@
+package org.strategoxt.lang;
+
+import static org.strategoxt.lang.Term.*;
+
+import org.spoofax.interpreter.terms.IStrategoTerm;
+
+/**
+ * An abstract strategy class. Inheritor classes must implement invokeDynamic().
+ * 
+ * @see Strategy	An abstract strategy class where invoke() should be implemented.
+ * 
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public abstract class DynamicStrategy extends DynamicStrategyOverloads<IStrategy, IStrategoTerm> implements IStrategy {
+	
+	public String getName() {
+		return getClass().getSimpleName();
+	}
+	
+	@Override
+	public String toString() {
+		return getName();
+	}
+}
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+abstract class DynamicStrategyOverloads<S extends IStrategy, T extends IStrategoTerm>
+		implements IStrategyOverloads<S, T>, IDynamicStrategyOverload<T> {
+	
+	public T invoke(Context context, T current) {
+		return invokeDynamic(context, current, EMPTY_STRATEGY_LIST, EMPTY_TERM_LIST);
+	}
+
+	public T invoke(Context context, T current, T t1) {
+		return invokeDynamic(context, current, EMPTY_STRATEGY_LIST, new IStrategoTerm[] { t1 });
+	}
+
+	public T invoke(Context context, T current, T t1, T t2) {
+		return invokeDynamic(context, current, EMPTY_STRATEGY_LIST, new IStrategoTerm[] { t1, t2 });
+	}
+
+	public T invoke(Context context, T current, T t1, T t2, T t3) {
+		return invokeDynamic(context, current, EMPTY_STRATEGY_LIST, new IStrategoTerm[] { t1, t2, t3 });
+	}
+
+	public T invoke(Context context, T current, T t1, T t2, T t3, T t4) {
+		return invokeDynamic(context, current, EMPTY_STRATEGY_LIST, new IStrategoTerm[] { t1, t2, t3, t4 });
+	}
+
+	public T invoke(Context context, T current, T t1, T t2, T t3, T t4, T t5) {
+		return invokeDynamic(context, current, EMPTY_STRATEGY_LIST, new IStrategoTerm[] { t1, t2, t3, t4, t5 });
+	}
+
+	public T invoke(Context context, T current, S s1) {
+		return invokeDynamic(context, current, new IStrategy[] { s1 }, EMPTY_TERM_LIST);
+	}
+
+	public T invoke(Context context, T current, S s1, T t1) {
+		return invokeDynamic(context, current, new IStrategy[] { s1 }, new IStrategoTerm[] { t1 });
+	}
+
+	public T invoke(Context context, T current, S s1, T t1, T t2) {
+		return invokeDynamic(context, current, new IStrategy[] { s1 }, new IStrategoTerm[] { t1, t2 });
+	}
+
+	public T invoke(Context context, T current, S s1, T t1, T t2, T t3) {
+		return invokeDynamic(context, current, new IStrategy[] { s1 }, new IStrategoTerm[] { t1, t2, t3 });
+	}
+
+	public T invoke(Context context, T current, S s1, T t1, T t2, T t3, T t4) {
+		return invokeDynamic(context, current, new IStrategy[] { s1 }, new IStrategoTerm[] { t1, t2, t3, t4 });
+	}
+
+	public T invoke(Context context, T current, S s1, T t1, T t2, T t3, T t4, T t5) {
+		return invokeDynamic(context, current, new IStrategy[] { s1 }, new IStrategoTerm[] { t1, t2, t3, t4, t5 });
+	}
+
+	public T invoke(Context context, T current, S s1, S s2) {
+		return invokeDynamic(context, current, new IStrategy[] { s1, s2 }, EMPTY_TERM_LIST);
+	}
+
+	public T invoke(Context context, T current, S s1, S s2, T t1) {
+		return invokeDynamic(context, current, new IStrategy[] { s1, s2 }, new IStrategoTerm[] { t1 });
+	}
+
+	public T invoke(Context context, T current, S s1, S s2, T t1, T t2) {
+		return invokeDynamic(context, current, new IStrategy[] { s1, s2 }, new IStrategoTerm[] { t1, t2 });
+	}
+
+	public T invoke(Context context, T current, S s1, S s2, T t1, T t2, T t3) {
+		return invokeDynamic(context, current, new IStrategy[] { s1, s2 }, new IStrategoTerm[] { t1, t2, t3 });
+	}
+
+	public T invoke(Context context, T current, S s1, S s2, T t1, T t2, T t3, T t4) {
+		return invokeDynamic(context, current, new IStrategy[] { s1, s2 }, new IStrategoTerm[] { t1, t2, t3, t4 });
+	}
+
+	public T invoke(Context context, T current, S s1, S s2, T t1, T t2, T t3, T t4, T t5) {
+		return invokeDynamic(context, current, new IStrategy[] { s1, s2 }, new IStrategoTerm[] { t1, t2, t3, t4, t5 });
+	}
+
+	public T invoke(Context context, T current, S s1, S s2, S s3) {
+		return invokeDynamic(context, current, new IStrategy[] { s1, s2, s3 }, EMPTY_TERM_LIST);
+	}
+
+	public T invoke(Context context, T current, S s1, S s2, S s3, T t1) {
+		return invokeDynamic(context, current, new IStrategy[] { s1, s2, s3 }, new IStrategoTerm[] { t1 });
+	}
+
+	public T invoke(Context context, T current, S s1, S s2, S s3, T t1, T t2) {
+		return invokeDynamic(context, current, new IStrategy[] { s1, s2, s3 }, new IStrategoTerm[] { t1, t2 });
+	}
+
+	public T invoke(Context context, T current, S s1, S s2, S s3, T t1, T t2, T t3) {
+		return invokeDynamic(context, current, new IStrategy[] { s1, s2, s3 }, new IStrategoTerm[] { t1, t2, t3 });
+	}
+
+	public T invoke(Context context, T current, S s1, S s2, S s3, T t1, T t2, T t3, T t4) {
+		return invokeDynamic(context, current, new IStrategy[] { s1, s2, s3 }, new IStrategoTerm[] { t1, t2, t3, t4 });
+	}
+
+	public T invoke(Context context, T current, S s1, S s2, S s3, T t1, T t2, T t3, T t4, T t5) {
+		return invokeDynamic(context, current, new IStrategy[] { s1, s2, s3 }, new IStrategoTerm[] { t1, t2, t3, t4, t5 });
+	}
+
+	public T invoke(Context context, T current, S s1, S s2, S s3, S s4) {
+		return invokeDynamic(context, current, new IStrategy[] { s1, s2, s3, s4 }, EMPTY_TERM_LIST);
+	}
+
+	public T invoke(Context context, T current, S s1, S s2, S s3, S s4, T t1) {
+		return invokeDynamic(context, current, new IStrategy[] { s1, s2, s3, s4 }, new IStrategoTerm[] { t1 });
+	}
+
+	public T invoke(Context context, T current, S s1, S s2, S s3, S s4, T t1, T t2) {
+		return invokeDynamic(context, current, new IStrategy[] { s1, s2, s3, s4 }, new IStrategoTerm[] { t1, t2 });
+	}
+
+	public T invoke(Context context, T current, S s1, S s2, S s3, S s4, T t1, T t2, T t3) {
+		return invokeDynamic(context, current, new IStrategy[] { s1, s2, s3, s4 }, new IStrategoTerm[] { t1, t2, t3 });
+	}
+
+	public T invoke(Context context, T current, S s1, S s2, S s3, S s4, T t1, T t2, T t3, T t4) {
+		return invokeDynamic(context, current, new IStrategy[] { s1, s2, s3, s4 }, new IStrategoTerm[] { t1, t2, t3, t4 });
+	}
+
+	public T invoke(Context context, T current, S s1, S s2, S s3, S s4, T t1, T t2, T t3, T t4, T t5) {
+		return invokeDynamic(context, current, new IStrategy[] { s1, s2, s3, s4 }, new IStrategoTerm[] { t1, t2, t3, t4, t5 });
+	}
+
+	public T invoke(Context context, T current, S s1, S s2, S s3, S s4, S s5) {
+		return invokeDynamic(context, current, new IStrategy[] { s1, s2, s3, s4, s5 }, EMPTY_TERM_LIST);
+	}
+
+	public T invoke(Context context, T current, S s1, S s2, S s3, S s4, S s5, T t1) {
+		return invokeDynamic(context, current, new IStrategy[] { s1, s2, s3, s4, s5 }, new IStrategoTerm[] { t1 });
+	}
+
+	public T invoke(Context context, T current, S s1, S s2, S s3, S s4, S s5, T t1, T t2) {
+		return invokeDynamic(context, current, new IStrategy[] { s1, s2, s3, s4, s5 }, new IStrategoTerm[] { t1, t2 });
+	}
+
+	public T invoke(Context context, T current, S s1, S s2, S s3, S s4, S s5, T t1, T t2, T t3) {
+		return invokeDynamic(context, current, new IStrategy[] { s1, s2, s3, s4, s5 }, new IStrategoTerm[] { t1, t2, t3 });
+	}
+
+	public T invoke(Context context, T current, S s1, S s2, S s3, S s4, S s5, T t1, T t2, T t3, T t4) {
+		return invokeDynamic(context, current, new IStrategy[] { s1, s2, s3, s4, s5 }, new IStrategoTerm[] { t1, t2, t3, t4 });
+	}
+
+	public T invoke(Context context, T current, S s1, S s2, S s3, S s4, S s5, T t1, T t2, T t3, T t4, T t5) {
+		return invokeDynamic(context, current, new IStrategy[] { s1, s2, s3, s4, s5 }, new IStrategoTerm[] { t1, t2, t3, t4, t5 });
+	}
+}
+
+/**
+ * Defines the invokeDynamic method with a custom, erased return type,
+ * while avoiding the <code>@Override</code> requirement of abstract methods. 
+ */
+interface IDynamicStrategyOverload<T extends IStrategoTerm> extends IDynamicStrategy {
+	public T invokeDynamic(Context context, IStrategoTerm current,
+			IStrategy[] sargs, IStrategoTerm[] targs);
+}
\ No newline at end of file

Added: strc-java/trunk/java/runtime/org/strategoxt/lang/InteropSDefT.java
===================================================================
--- strc-java/trunk/java/runtime/org/strategoxt/lang/InteropSDefT.java	                        (rev 0)
+++ strc-java/trunk/java/runtime/org/strategoxt/lang/InteropSDefT.java	2009-06-26 07:57:35 UTC (rev 19558)
@@ -0,0 +1,88 @@
+package org.strategoxt.lang;
+
+import java.util.Arrays;
+
+import org.spoofax.interpreter.core.IContext;
+import org.spoofax.interpreter.core.InterpreterException;
+import org.spoofax.interpreter.core.VarScope;
+import org.spoofax.interpreter.stratego.SDefT;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+
+/**
+ * Adapts an {@link SDefT} definition to an {@link IStrategy},
+ * making interpreter strategy arguments accessible to the compiled strategies.
+ * 
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class InteropSDefT extends DynamicStrategy implements IStrategy {
+	
+	private final SDefT definition;
+	
+	private final IContext context;
+	
+	public InteropSDefT(SDefT definition, IContext context) {
+		this.definition = definition;
+		this.context = context;
+	}
+	
+	public static IStrategy[] toInteropSDefTs(SDefT[] definitions, IContext context) {
+		IStrategy[] results = new IStrategy[definitions.length];
+		for (int i = 0; i < definitions.length; i++) {
+			SDefT definition = definitions[i];
+			if (definition instanceof InteropStrategyDef) {
+				results[i] = ((InteropStrategyDef) definition).getStrategy();
+			} else {
+				results[i] = new InteropSDefT(definitions[i], context);
+			}
+		}
+		return results;
+	}
+	
+	public IStrategoTerm invokeDynamic(Context compilerContext, IStrategoTerm current, IStrategy[] sargs, IStrategoTerm[] targs) {
+		VarScope oldScope = context.getVarScope();
+		try {
+			if (sargs.length != 0 || targs.length != 0) {
+				VarScope newScope = new VarScope(oldScope);
+				assignParameters(compilerContext, newScope, sargs, targs);
+				context.setVarScope(newScope);
+			}
+			
+			context.setCurrent(current);
+			boolean success = definition.evaluate(context);
+			return success ? context.current() : null;
+		} catch (InterpreterException e) {
+			throw new StrategoException("Exception in interpreter", e);
+		} finally {
+			context.restoreVarScope(oldScope);
+		}
+	}
+
+	private void assignParameters(Context compiledContext, VarScope scope, IStrategy[] sargs, IStrategoTerm[] targs)
+			throws InterpreterException {
+		
+		SDefT.SVar[] sparams = definition.getStrategyParams();
+		String[] tparams = definition.getTermParams();
+		SDefT[] sargs2 = InteropStrategyDef.toInteropStrategyDefs(sargs, context, compiledContext);
+		if (sparams.length != sargs.length || tparams.length != targs.length) {
+			throw new InterpreterException("Illegal number of arguments passed to strategy "
+					+ getName() + ": (" + Arrays.toString(sargs) + "|" + Arrays.toString(targs) + ")");
+		}
+		
+		for (int i = 0; i < sparams.length; i++) {
+			scope.addSVar(sparams[i].name, sargs2[i]);
+		}
+		
+		for (int i = 0; i < tparams.length; i++) {
+			scope.add(tparams[i], targs[i]);
+		}
+	}
+	
+	@Override
+	public String getName() {
+		return definition.getName();
+	}
+	
+	public SDefT getDefinition() {
+		return definition;
+	}
+}

Modified: strc-java/trunk/java/runtime/org/strategoxt/lang/InteropStrategy.java
===================================================================
--- strc-java/trunk/java/runtime/org/strategoxt/lang/InteropStrategy.java	2009-06-25 15:07:54 UTC (rev 19557)
+++ strc-java/trunk/java/runtime/org/strategoxt/lang/InteropStrategy.java	2009-06-26 07:57:35 UTC (rev 19558)
@@ -1,6 +1,7 @@
 package org.strategoxt.lang;
 
 import org.spoofax.NotImplementedException;
+import org.spoofax.interpreter.core.IConstruct;
 import org.spoofax.interpreter.core.IContext;
 import org.spoofax.interpreter.core.InterpreterException;
 import org.spoofax.interpreter.stratego.CallT;
@@ -8,24 +9,46 @@
 import org.spoofax.interpreter.terms.IStrategoTerm;
 
 /**
+ * Adapts an {@link IStrategy} strategy to a {@link CallT},
+ * making interpreter strategies and primitives with strategy arguments
+ * accessible for compiled strategies.
+ * 
  * @author Lennart Kats <lennart add lclnet.nl>
  */
 public class InteropStrategy extends CallT {
 	
-	private static final CallT[] EMPTY_CALLT_LIST = new CallT[0];
+	private static final CallT[] NO_CALLTS = {};
 	
-	private static final IStrategy[] EMPTY_ISTRATEGY_LIST = new IStrategy[0];
+	private static final IStrategy[] NO_ISTRATEGIES = {};
 	
 	private final IStrategy strategy;
 	
+	private final Context context;
+	
+	/**
+	 * Creates a new InteropStrategy instance.
+	 * 
+	 * @param strategy	The strategy to adapt.
+	 */
 	public InteropStrategy(IStrategy strategy) {
+		this(strategy, null);
+	}
+	
+	/**
+	 * Creates a new InteropStrategy instance.
+	 * 
+	 * @param strategy	The strategy to adapt.
+	 * @param context	The compiled context, if used with an interpreter context.
+	 */
+	public InteropStrategy(IStrategy strategy, Context context) {
 		super(strategy.getName(), null, null);
 		
 		this.strategy = strategy;
+		this.context = context;
 	}
     
 	public static CallT[] toInteropStrategies(IStrategy[] strategies) {
-    	if (strategies.length == 0) return EMPTY_CALLT_LIST;
+    	if (strategies.length == 0) return NO_CALLTS;
     	
     	CallT[] results = new CallT[strategies.length];
     	for (int i = 0; i < strategies.length; i++)
@@ -35,7 +58,7 @@
     
 	public static IStrategy[] fromInteropStrategies(Strategy[] strategies) {
 		if (strategies.length == 0)
-			return EMPTY_ISTRATEGY_LIST;
+			return NO_ISTRATEGIES;
 
 		IStrategy[] results = new IStrategy[strategies.length];
 		for (int i = 0; i < strategies.length; i++) {
@@ -51,29 +74,37 @@
 	protected String getTraceName() {
 		return strategy.getName();
 	}
+	
+	@Override
+	public IConstruct eval(IContext env) throws InterpreterException {
+		return evaluate(env)
+			? getHook().pop().onSuccess(env)
+			: getHook().pop().onFailure(env);
+	}
 
 	@Override
-	public boolean evaluate(IContext env) throws InterpreterException {
-		if (!(env instanceof InteropContext))
-			throw new StrategoException("Expected InteropContext");
-		Context context = ((InteropContext) env).getContext();	
-		
-		IStrategoTerm result = strategy.invoke(context, env.current());
+	public boolean evaluate(IContext env) {
+		IStrategoTerm result = strategy.invoke(getCompiledContext(env), env.current());
 		if (result == null) return false;
 		env.setCurrent(result);
 		
 		return true;
 	}
-	
-	@Override
-	public boolean evaluateWithArgs(IContext env, Strategy[] sv,
-			IStrategoTerm[] tv) throws InterpreterException {
 
+	private Context getCompiledContext(IContext env) {
+		if (context != null)
+			return context;
+		
 		if (!(env instanceof InteropContext))
 			throw new StrategoException("Expected InteropContext");
 		Context context = ((InteropContext) env).getContext();
-		
-		IStrategoTerm result = strategy.invokeDynamic(context, env.current(), fromInteropStrategies(sv), tv);
+		return context;
+	}
+	
+	@Override
+	public boolean evaluateWithArgs(IContext env, Strategy[] sv, IStrategoTerm[] tv) {
+		IStrategoTerm result = strategy.invokeDynamic(
+				getCompiledContext(env),env.current(), fromInteropStrategies(sv), tv);
 		if (result == null) return false;
 		env.setCurrent(result);		
 		return true;		

Added: strc-java/trunk/java/runtime/org/strategoxt/lang/InteropStrategyDef.java
===================================================================
--- strc-java/trunk/java/runtime/org/strategoxt/lang/InteropStrategyDef.java	                        (rev 0)
+++ strc-java/trunk/java/runtime/org/strategoxt/lang/InteropStrategyDef.java	2009-06-26 07:57:35 UTC (rev 19558)
@@ -0,0 +1,184 @@
+package org.strategoxt.lang;
+
+import org.spoofax.interpreter.core.IConstruct;
+import org.spoofax.interpreter.core.IContext;
+import org.spoofax.interpreter.core.InterpreterException;
+import org.spoofax.interpreter.core.VarScope;
+import org.spoofax.interpreter.stratego.SDefT;
+import org.spoofax.interpreter.stratego.StupidFormatter;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+
+/**
+ * Adapts an {@link IStrategy} strategy to a {@link SDefT},
+ * making compiled strategies accessible to the interpreter.
+ * 
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class InteropStrategyDef extends SDefT {
+	
+	private static final ConstType CONST_TYPE = new ConstType();
+	
+	private static final SVar[] NO_SVARS = {};
+	
+	private static final String[] NO_STRINGS = {};
+	
+	private final Context compiledContext;
+	
+	private final IContext context;
+	
+	private final Class<? extends IStrategy> strategyClass;
+	
+	private IStrategy strategy;
+
+	// TODO: Optimize - take a Class<IStrategy> or String argument for lazy loading
+	public InteropStrategyDef(Class<? extends IStrategy> strategyClass, IContext context, Context compiledContext) {
+		this.strategyClass = strategyClass;
+		this.compiledContext = compiledContext;
+		this.context = context;
+	}
+
+	public InteropStrategyDef(IStrategy strategy, IContext context, Context compiledContext) {
+		this.strategyClass = null;
+		this.compiledContext = compiledContext;
+		this.context = context;
+		this.strategy = strategy;
+	}
+
+	public static SDefT[] toInteropStrategyDefs(IStrategy[] strategies, IContext context, Context compiledContext) {
+		SDefT[] results = new SDefT[strategies.length];
+		for (int i = 0; i < strategies.length; i++) {
+			IStrategy strategy = strategies[i];
+			if (strategy instanceof InteropSDefT) {
+				results[i] = ((InteropSDefT) strategy).getDefinition();
+			} else {
+				results[i] = new InteropStrategyDef(strategy, context, compiledContext);
+			}
+		}
+		return results;
+	}
+
+	@Override
+	public String getName() {
+		return getStrategy().getName();
+	}
+
+	@Override
+	public SVar[] getStrategyParams() {
+		SVar[] results = super.getStrategyParams();
+		if (results != null) return results;
+		
+		String name = getName();
+		int countEnd = name.lastIndexOf('_');
+		int countStart = name.lastIndexOf('_', countEnd - 1);
+		int count = Integer.parseInt(name.substring(countStart + 1, countEnd));
+		
+		if (count == 0) return NO_SVARS;
+		
+		results = new SVar[count];
+		for (int i = 0; i < results.length; i++) {
+			results[i] = new SVar("s" + i, CONST_TYPE);
+		}
+		
+		return results;
+	}
+
+	@Override
+	public String[] getTermParams() {
+		String[] results = super.getTermParams();
+		if (results != null) return results;
+		
+		String name = getName();
+		int countStart = name.lastIndexOf('_');
+		int count = Integer.parseInt(name.substring(countStart + 1));
+		
+		if (count == 0) return NO_STRINGS;
+		
+		results = new String[count];
+		for (int i = 0; i < results.length; i++) {
+			results[i] = "t" + i;
+		}
+		
+		return results;
+	}
+	
+	@Override
+	public VarScope getScope() {
+		return context.getVarScope();
+	}
+	
+	@Override
+	public org.spoofax.interpreter.stratego.Strategy getBody() {
+		return new org.spoofax.interpreter.stratego.Strategy() {
+			public IConstruct eval(IContext env) throws InterpreterException {
+				return evaluate(env)
+					? getHook().pop().onSuccess(env)
+					: getHook().pop().onFailure(env);
+			}
+			
+			@Override
+			public boolean evaluate(IContext env) throws InterpreterException {
+				return InteropStrategyDef.this.evaluate(env);
+			}
+
+			public void prettyPrint(StupidFormatter fmt) {
+				InteropStrategyDef.this.prettyPrint(fmt);
+			}
+			
+			@Override
+			protected String getTraceName() {
+				return getName();
+			}
+		};
+	}
+	
+	@Override
+	public boolean evaluate(IContext env) throws InterpreterException {
+		VarScope scope = env.getVarScope();
+		SVar[] svars = getStrategyParams();
+		String[] tvars = getTermParams();
+		SDefT[] sargs = new SDefT[svars.length];
+		IStrategoTerm[] targs = new IStrategoTerm[tvars.length];
+		
+		for (int i = 0; i < svars.length; i++) {
+			SDefT sarg = scope.lookupSVar(svars[i].name);
+			if (sarg == null) throw new InterpreterException("Missing strategy argument: " + svars[i].name);
+			sargs[i] = sarg;
+		}
+		
+		for (int i = 0; i < tvars.length; i++) {
+			IStrategoTerm targ = scope.lookup(tvars[i]);
+            if (targ == null) throw new InterpreterException("Missing term argument: " + tvars[i]);
+			targs[i] = targ;
+		}
+		
+		IStrategy[] sdefargs = InteropSDefT.toInteropSDefTs(sargs, env);
+		IStrategoTerm result = getStrategy().invokeDynamic(compiledContext, env.current(), sdefargs, targs);
+		
+		if (result != null) {
+			env.setCurrent(result);
+			return true;
+		} else {
+			return false;
+		}
+	}
+	
+	public IStrategy getStrategy() {
+		if (strategy == null) {
+			try {
+				// TODO: is this a good performance trade off??
+				strategy = (IStrategy) strategyClass.getField("instance").get(null);
+			} catch (IllegalAccessException e) {
+				throw new StrategoException("Unable to instantiate compiled strategy", e);
+			} catch (IllegalArgumentException e) {
+				throw new StrategoException("Unable to instantiate compiled strategy", e);
+			} catch (SecurityException e) {
+				throw new StrategoException("Unable to instantiate compiled strategy", e);
+			} catch (NoSuchFieldException e) {
+				throw new StrategoException("Unable to instantiate compiled strategy", e);
+			}
+		}
+			
+		return strategy;
+	}
+}
+

Modified: strc-java/trunk/java/runtime/org/strategoxt/lang/SRTS_all.java
===================================================================
--- strc-java/trunk/java/runtime/org/strategoxt/lang/SRTS_all.java	2009-06-25 15:07:54 UTC (rev 19557)
+++ strc-java/trunk/java/runtime/org/strategoxt/lang/SRTS_all.java	2009-06-26 07:57:35 UTC (rev 19558)
@@ -69,7 +69,7 @@
 			} else if (tail2 == tail) { // (match() not necessary because of recursion)
 				return list;
 			} else {
-				return context.getFactory().makeList(head2, tail2);
+				return context.getFactory().makeList(head, tail2);
 			}
 		} else {
 			return mapIgnoreAnnos(context, head2, list, s);
@@ -109,7 +109,7 @@
 				return null;
 			} else if (tail2 != tail) { // (match() not necessary because of recursion)
 				// TODO: head/tail variation of replaceList
-				return context.getFactory().makeList(head2, tail2);
+				return context.getFactory().makeList(head, tail2);
 			} else {
 				return list;
 			}

Modified: strc-java/trunk/java/runtime/org/strategoxt/lang/StrategoExit.java
===================================================================
--- strc-java/trunk/java/runtime/org/strategoxt/lang/StrategoExit.java	2009-06-25 15:07:54 UTC (rev 19557)
+++ strc-java/trunk/java/runtime/org/strategoxt/lang/StrategoExit.java	2009-06-26 07:57:35 UTC (rev 19558)
@@ -16,6 +16,11 @@
         this.value = value;
     }
     
+    public StrategoExit(int value, Throwable cause) {
+    	super("Legal exit", cause);
+    	this.value = value;
+    }
+    
     public int getValue() {
         return value;
     }

Modified: strc-java/trunk/java/runtime/org/strategoxt/lang/Strategy.java
===================================================================
--- strc-java/trunk/java/runtime/org/strategoxt/lang/Strategy.java	2009-06-25 15:07:54 UTC (rev 19557)
+++ strc-java/trunk/java/runtime/org/strategoxt/lang/Strategy.java	2009-06-26 07:57:35 UTC (rev 19558)
@@ -3,9 +3,15 @@
 import org.spoofax.interpreter.terms.IStrategoTerm;
 
 /**
+ * An abstract strategy class. Inheritor classes should implement one
+ * of the invoke() overloads or invokeDynamic() as appropriate.
+ * 
+ * @see DynamicStrategy
+ *        An abstract strategy class where invokeDynamic() should be implemented.
+ * 
  * @author Lennart Kats <lennart add lclnet.nl>
  */
-public abstract class Strategy extends StrategyOverloads<IStrategy, IStrategoTerm> implements IStrategy {
+public class Strategy implements IStrategy {
 	/**
 	 * Invoke this strategy using a dynamic number of arguments.
 	 * 
@@ -71,154 +77,148 @@
 		}
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
-}
 
-/**
- * @author Lennart Kats <lennart add lclnet.nl>
- */
-class StrategyOverloads<S extends IStrategy, T extends IStrategoTerm> implements IStrategyOverloads<S,T> {
-
-	public T invoke(Context context, T current) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public T invoke(Context context, T current, T t1) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategoTerm t1) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public T invoke(Context context, T current, T t1, T t2) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategoTerm t1, IStrategoTerm t2) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public T invoke(Context context, T current, T t1, T t2, T t3) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public T invoke(Context context, T current, T t1, T t2, T t3, T t4) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public T invoke(Context context, T current, T t1, T t2, T t3, T t4, T t5) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4, IStrategoTerm t5) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public T invoke(Context context, T current, S s1) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public T invoke(Context context, T current, S s1, T t1) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategoTerm t1) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public T invoke(Context context, T current, S s1, T t1, T t2) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategoTerm t1, IStrategoTerm t2) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public T invoke(Context context, T current, S s1, T t1, T t2, T t3) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public T invoke(Context context, T current, S s1, T t1, T t2, T t3, T t4) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public T invoke(Context context, T current, S s1, T t1, T t2, T t3, T t4, T t5) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4, IStrategoTerm t5) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public T invoke(Context context, T current, S s1, S s2) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, T t1) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategoTerm t1) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, T t1, T t2) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategoTerm t1, IStrategoTerm t2) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, T t1, T t2, T t3) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, T t1, T t2, T t3, T t4) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, T t1, T t2, T t3, T t4, T t5) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4, IStrategoTerm t5) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, S s3) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategy s3) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, S s3, T t1) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategy s3, IStrategoTerm t1) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, S s3, T t1, T t2) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategy s3, IStrategoTerm t1, IStrategoTerm t2) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, S s3, T t1, T t2, T t3) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategy s3, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, S s3, T t1, T t2, T t3, T t4) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategy s3, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, S s3, T t1, T t2, T t3, T t4, T t5) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategy s3, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4, IStrategoTerm t5) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, S s3, S s4) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategy s3, IStrategy s4) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, S s3, S s4, T t1) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategy s3, IStrategy s4, IStrategoTerm t1) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, S s3, S s4, T t1, T t2) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategy s3, IStrategy s4, IStrategoTerm t1, IStrategoTerm t2) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, S s3, S s4, T t1, T t2, T t3) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategy s3, IStrategy s4, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, S s3, S s4, T t1, T t2, T t3, T t4) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategy s3, IStrategy s4, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, S s3, S s4, T t1, T t2, T t3, T t4, T t5) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategy s3, IStrategy s4, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4, IStrategoTerm t5) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, S s3, S s4, S s5) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategy s3, IStrategy s4, IStrategy s5) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, S s3, S s4, S s5, T t1) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategy s3, IStrategy s4, IStrategy s5, IStrategoTerm t1) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, S s3, S s4, S s5, T t1, T t2) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategy s3, IStrategy s4, IStrategy s5, IStrategoTerm t1, IStrategoTerm t2) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, S s3, S s4, S s5, T t1, T t2, T t3) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategy s3, IStrategy s4, IStrategy s5, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, S s3, S s4, S s5, T t1, T t2, T t3, T t4) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategy s3, IStrategy s4, IStrategy s5, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, S s3, S s4, S s5, T t1, T t2, T t3, T t4, T t5) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategy s3, IStrategy s4, IStrategy s5, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4, IStrategoTerm t5) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 	

Modified: strc-java/trunk/java/runtime/org/strategoxt/lang/compat/libstrc_compat.java
===================================================================
--- strc-java/trunk/java/runtime/org/strategoxt/lang/compat/libstrc_compat.java	2009-06-25 15:07:54 UTC (rev 19557)
+++ strc-java/trunk/java/runtime/org/strategoxt/lang/compat/libstrc_compat.java	2009-06-26 07:57:35 UTC (rev 19558)
@@ -11,7 +11,11 @@
  * @author Lennart Kats <lennart add lclnet.nl>
  */
 public class libstrc_compat {
+	private static boolean isInitialized;
+	
 	public static void init(Context context) {
+		if (isInitialized) return;
+		isInitialized = true;
 		context.addOperatorRegistry(new OperatorRegistry());
 		strc_compat.init(context);
 	}


Property changes on: strc-java/trunk/java/runtime/org/strategoxt/lang/compat/override

(67 diff lines omitted)


From L.C.L.Kats at tudelft.nl  Fri Jun 26 09:58:24 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Fri, 26 Jun 2009 07:58:24 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19559 - LennartKats -
	in strc-java/trunk/java/runtime/org/strategoxt/lang: . parallel
Message-ID: <200906260757.n5Q7v2Kh003427@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-06-26 07:58:24 +0000 (Fri, 26 Jun 2009)
New Revision: 19559

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19559&view=rev

Added:
   strc-java/trunk/java/runtime/org/strategoxt/lang/parallel/
   strc-java/trunk/java/runtime/org/strategoxt/lang/parallel/ParallelAll.java
   strc-java/trunk/java/runtime/org/strategoxt/lang/parallel/ParallelContext.java
   strc-java/trunk/java/runtime/org/strategoxt/lang/parallel/ParallelJob.java
   strc-java/trunk/java/runtime/org/strategoxt/lang/parallel/ParallelJobAbortedException.java
   strc-java/trunk/java/runtime/org/strategoxt/lang/parallel/ParallelJobExecutor.java
   strc-java/trunk/java/runtime/org/strategoxt/lang/parallel/PureOperatorSet.java
   strc-java/trunk/java/runtime/org/strategoxt/lang/parallel/libstratego_parallel.java

Log:
Experimental parallel execution library, overriding 'all' and derived strategies such as 'map'.

Changes:

Added: strc-java/trunk/java/runtime/org/strategoxt/lang/parallel/ParallelAll.java
===================================================================
--- strc-java/trunk/java/runtime/org/strategoxt/lang/parallel/ParallelAll.java	                        (rev 0)
+++ strc-java/trunk/java/runtime/org/strategoxt/lang/parallel/ParallelAll.java	2009-06-26 07:58:24 UTC (rev 19559)
@@ -0,0 +1,251 @@
+package org.strategoxt.lang.parallel;
+
+import static java.lang.Math.*;
+import static org.spoofax.interpreter.terms.IStrategoTerm.*;
+import static org.strategoxt.lang.parallel.ParallelJob.*;
+
+import java.util.WeakHashMap;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
+
+import org.spoofax.interpreter.terms.IStrategoList;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.strategoxt.lang.Context;
+import org.strategoxt.lang.IStrategy;
+import org.strategoxt.lang.SRTS_all;
+import org.strategoxt.lang.StrategoException;
+import org.strategoxt.lang.StrategoExit;
+
+import static org.strategoxt.lang.parallel.libstratego_parallel.*;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class ParallelAll extends SRTS_all {
+
+	/**
+	 * Gets the active ParallelAll instance, or null.
+	 * Is set by {@link libstratego_parallel#init(Context)}.
+	 */
+	public static ParallelAll instance;
+	
+	private static final WeakHashMap<IStrategoTerm, Integer> termSizes =
+		new WeakHashMap<IStrategoTerm, Integer>();
+	
+	private final ParallelJobExecutor executor = new ParallelJobExecutor();
+	
+	private int termSizeThreshold = DEFAULT_TERM_SIZE_THRESHOLD;
+
+	private int subtermCountThreshold = DEFAULT_SUBTERM_COUNT_THRESHOLD;
+	
+	private double jobLengthMultiplier = DEFAULT_JOB_LENGTH_MULTIPLIER;
+
+	private AtomicInteger parallelismLevel = new AtomicInteger(0);
+	
+	private volatile boolean isParallelActive;
+	
+	private volatile boolean allowUnorderedOnce;
+	
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s) {
+		// TODO: The focus thread could actually start more jobs, given a priority job queue
+		if ((ALLOW_NESTED_JOBS || !isParallelActive) && isCandidateTerm(context, current) && ENABLED) {
+			context.push("<parallel>");
+			IStrategoTerm result = invokeParallel(context, current, s);
+			
+			if (result == null) context.popOnFailure();
+			else context.popOnSuccess();
+			
+			return result;
+		} else {
+			return super.invoke(context, current, s);
+		}
+	}
+
+	public IStrategoTerm invokeParallel(final Context context, final IStrategoTerm current, final IStrategy s) {		
+		final IStrategoTerm[] inputs = current.getAllSubterms();
+		final IStrategoTerm[] outputs = new IStrategoTerm[inputs.length];
+		final AtomicInteger focusIndex = new AtomicInteger(0); // index of the job with side effects
+		final AtomicBoolean isAborted = new AtomicBoolean(false);
+		final AtomicReference<String> lastSynchronousOperation = DIAGNOSE_SYNCHRONOUS_OPERATIONS ? new AtomicReference<String>() : null;
+		final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
+		final Object notifier = new Object();
+		final boolean allowUnordered;
+		
+		ParallelJob firstJob = null;
+		
+		// HACK
+		final boolean allowGrayListed = "lifted1240".equals(s.getName()) || "lifted835".equals(s.getName()) 
+				|| "lifted233".equals(s.getName())  || "lifted324".equals(s.getName())
+				|| "lifted55".equals(s.getName());
+		
+		if (ALLOW_NESTED_JOBS) {
+			int level = parallelismLevel.incrementAndGet();
+			// We can only do this if there are no other parallel jobs active,
+			// otherwise we'd get confused about the place unordered is allowed
+			allowUnordered = level == 1 && allowUnorderedOnce;
+			allowUnorderedOnce = false;
+		} else {
+			isParallelActive = true;
+			allowUnordered = allowUnorderedOnce;
+			allowUnorderedOnce = false;
+		}
+		
+		try {
+			double jobLengthPrecise = (double) inputs.length / (executor.getMaximumPoolSize() + 1) * jobLengthMultiplier;
+			int jobLength = max(1, (int) jobLengthPrecise);
+			
+			if (VERBOSE)
+				System.out.print("<" + inputs.length / jobLength);
+			
+			// Populate thread pool
+			for (int i = 0; i < inputs.length; i += jobLength) {
+				final int index = i;
+				ParallelJob job = new ParallelJob(inputs, outputs, index, jobLength, parallelismLevel.get(), focusIndex, notifier) {
+					@Override
+					public IStrategoTerm execute(IStrategoTerm input) {
+						if (isAborted.get()) return null;
+
+						IStrategoTerm result = null;
+						try {
+							ParallelContext parallelContext = new ParallelContext(context, executor, this, isAborted, allowUnordered, allowGrayListed);
+							if (DIAGNOSE_SYNCHRONOUS_OPERATIONS)
+								parallelContext.setLastSynchronousOperation(lastSynchronousOperation);
+							result = s.invoke(parallelContext, input);
+							
+						} catch (ParallelJobAbortedException e) {
+							// Fine here
+						} catch (RuntimeException e) {
+							exception.set(e);
+						} catch (Error e) {
+							exception.set(e);
+						}
+						
+						if (result == null) {
+							isAborted.set(true);
+							getFocusIndex().set(COMPLETED_FOCUS_INDEX);
+							executor.getQueue().clear();
+							synchronized (notifier) {
+								if (VERBOSE) System.out.print("!>");
+								notifier.notifyAll();
+							}
+						}
+						
+						return result;
+					}
+				};
+				
+				if (firstJob == null) {
+					firstJob = job;
+				} else {
+					executor.execute(job);
+				}
+			}
+			
+			assert firstJob != null;
+			firstJob.run();
+
+			joinExecutor(focusIndex, notifier);
+		} catch (InterruptedException e) {
+			throw new RuntimeException(e);
+		} finally {
+			if (ALLOW_NESTED_JOBS) parallelismLevel.decrementAndGet();
+			else isParallelActive = false;
+		}
+		
+		if (DIAGNOSE_SYNCHRONOUS_OPERATIONS) {
+			System.out.print("(" + s.getName() + (lastSynchronousOperation.get() == null ? "+" : "-" + lastSynchronousOperation) + ")");
+		}
+		
+		if (isAborted.get()) {
+			if (exception.get() != null) {
+				if (exception.get() instanceof StrategoExit) {
+					throw new StrategoExit(((StrategoExit) exception.get()).getValue(), exception.get());
+				} else {
+					throw new StrategoException("Exception in asynchronous job", exception.get());
+				}
+			}
+			return null;
+		}
+		
+		assert current.getTermType() == LIST;
+		return context.getFactory().replaceList(outputs, (IStrategoList) current);
+	}
+	
+	public void setAllowUnorderedOnce(boolean allowUnorderedOnce) {
+		this.allowUnorderedOnce = allowUnorderedOnce;
+	}
+
+	private void joinExecutor(AtomicInteger focusIndex, Object notifier) throws InterruptedException {
+		// Help the thread pool
+		Runnable job;
+		while ((job = executor.getQueue().poll()) != null) {
+			job.run();
+		}
+		
+		// Wait for other threads
+		ParallelJob.waitForFocusIndex(focusIndex, COMPLETED_FOCUS_INDEX, notifier);
+	}
+	
+	protected boolean isCandidateTerm(Context context, IStrategoTerm term) {
+		if (term.getTermType() == LIST
+				&& term.getStorageType() != MUTABLE
+				&& term.getSubtermCount() >= subtermCountThreshold
+				&& getTermSize(term, 1) >= termSizeThreshold) {
+
+			if (parallelismLevel.get() > 2) {
+				return false;
+			}
+
+			if (parallelismLevel.get() > 1 && !((ParallelContext) context).getJob().isFocusJob()) {
+				return false;
+			}
+			
+			for (IStrategoList cons = (IStrategoList) term; !cons.isEmpty(); cons = cons.tail()) {
+				if (!cons.getAnnotations().isEmpty())
+					return false;
+			}
+			return true;
+		} else {
+			return false;
+		}
+	}
+	
+	/**
+	 * Gets the size of a term (using a cache).
+	 * Stops counting if {@link #termSizeThreshold} is reached.
+	 */
+	protected int getTermSize(IStrategoTerm term, int initialSize) {
+		int subtermCount = term.getSubtermCount();
+		if (subtermCount == 0) return initialSize;
+
+		Integer cached = termSizes.get(term);
+		if (cached != null) return initialSize + cached;
+
+		int size = initialSize + subtermCount;
+		
+		if (term.getTermType() == LIST) {
+			for (IStrategoList cons = (IStrategoList) term; !cons.isEmpty(); cons = cons.tail()) {
+				IStrategoTerm subterm = cons.head();
+				size = getTermSize(subterm, size);
+				if (size >= termSizeThreshold) {
+					termSizes.put(term, size);
+					return size;
+				}
+			}
+		} else {
+			for (int i = 0; i < subtermCount; i++) {
+				IStrategoTerm subterm = term.getSubterm(i);
+				size = getTermSize(subterm, size);
+				if (size >= termSizeThreshold) {
+					termSizes.put(term, size);
+					return size;
+				}
+			}
+		}
+		
+		termSizes.put(term, size);
+		return size;
+	} 
+}

Added: strc-java/trunk/java/runtime/org/strategoxt/lang/parallel/ParallelContext.java
===================================================================
--- strc-java/trunk/java/runtime/org/strategoxt/lang/parallel/ParallelContext.java	                        (rev 0)
+++ strc-java/trunk/java/runtime/org/strategoxt/lang/parallel/ParallelContext.java	2009-06-26 07:58:24 UTC (rev 19559)
@@ -0,0 +1,129 @@
+package org.strategoxt.lang.parallel;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
+
+import org.spoofax.interpreter.library.AbstractPrimitive;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.strategoxt.lang.Context;
+import org.strategoxt.lang.IStrategy;
+import static org.strategoxt.lang.parallel.libstratego_parallel.*;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class ParallelContext extends Context {
+	
+	private final ParallelJobExecutor executor;
+	
+	private final ParallelJob job;
+	
+	private final AtomicBoolean isAborted;
+	
+	private final boolean allowUnordered;
+	
+	private final boolean allowGrayListed;
+	
+	private AtomicReference<String> lastSynchronousOperation;
+
+	/**
+	 * Constructs a new parallelism-aware context.
+	 * 
+	 * @param context
+	 * @param executor
+	 * @param job
+	 * @param aborted
+	 * @param allowUnordered
+	 *            Allows all threads to use any operation, using locks for
+	 *            non-whitelisted ones.
+	 * @param allowGrayListed
+	 *            Allows all threads to use white-listed and gray-listed
+	 *            operations in parallel, without locks. Using other
+	 *            operations will break the program.
+	 */
+	public ParallelContext(Context context, ParallelJobExecutor executor, ParallelJob job, AtomicBoolean aborted, boolean allowUnordered, boolean allowGrayListed) {
+		super(context.getFactory(), context.getOperatorRegistryMap(), context.getOperatorRegistries());
+		this.executor = executor;
+		this.job = job;
+		this.isAborted = aborted;
+		this.allowUnordered = allowUnordered;
+		this.allowGrayListed = allowGrayListed;
+	}
+	
+	void setLastSynchronousOperation(AtomicReference<String> value) {
+		this.lastSynchronousOperation = value;
+	}
+	
+	/* UNDONE: expensive according to profiler
+	@Override
+	public void popOnFailure() {
+		if (isAborted.get() && !job.isFocusJob())
+			throw new ParallelJobAbortedException();
+		super.popOnFailure();
+	}
+	*/
+	
+	@Override
+	public void postInit(String componentName) {
+		// Do nothing
+	}
+	
+	@Override
+	protected void finalize() throws Throwable {
+		// Do nothing
+	}
+	
+	@Override
+	public IStrategoTerm invokePrimitive(AbstractPrimitive primitive, IStrategoTerm term, IStrategy[] args, IStrategoTerm[] targs) {
+		if (isAborted.get() && !job.isFocusJob())
+			throw new ParallelJobAbortedException();
+		
+		String name = primitive.getName();
+		
+		if (!DIAGNOSE_SYNCHRONOUS_OPERATIONS && job.isFocusJob())
+			return super.invokePrimitive(primitive, term, args, targs);
+		
+		if (PureOperatorSet.isWhiteListed(name))
+			return super.invokePrimitive(primitive, term, args, targs);
+		
+		if (DIAGNOSE_SYNCHRONOUS_OPERATIONS) {
+			if (lastSynchronousOperation.get() == null && !PureOperatorSet.isGrayListed(name))
+				lastSynchronousOperation.set(name);
+		}
+		
+		if (allowUnordered) {
+			synchronized (executor) {
+				return super.invokePrimitive(primitive, term, args, targs);
+			}
+		}
+		
+		if (allowGrayListed) {
+			if (PureOperatorSet.isGrayListed(name))
+				return super.invokePrimitive(primitive, term, args, targs);
+			else
+				throw new IllegalStateException("Uses non-graylisted operation: " + name);
+		}
+		
+		// If all else fails, perform any "black-listed" operations in an ordered fashion
+		waitForFocus();
+		
+		return super.invokePrimitive(primitive, term, args, targs);
+	}
+	
+	public ParallelJob getJob() {
+		return job;
+	}
+	
+	private void waitForFocus() {
+		executor.asyncBeginSleep();
+		try {
+			job.waitForFocus();
+			if (isAborted.get() && !job.isFocusJob())
+				throw new ParallelJobAbortedException();
+		} catch (InterruptedException e) {
+			throw new RuntimeException(e);
+		} finally {
+			executor.asyncEndSleep();
+		}
+	}
+}

Added: strc-java/trunk/java/runtime/org/strategoxt/lang/parallel/ParallelJob.java
===================================================================
--- strc-java/trunk/java/runtime/org/strategoxt/lang/parallel/ParallelJob.java	                        (rev 0)
+++ strc-java/trunk/java/runtime/org/strategoxt/lang/parallel/ParallelJob.java	2009-06-26 07:58:24 UTC (rev 19559)
@@ -0,0 +1,159 @@
+package org.strategoxt.lang.parallel;
+
+import static java.lang.Math.*;
+import static org.strategoxt.lang.parallel.libstratego_parallel.*;
+
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.spoofax.interpreter.terms.IStrategoTerm;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public abstract class ParallelJob implements Runnable, Comparable<ParallelJob> {
+	
+	public static final int COMPLETED_FOCUS_INDEX = Integer.MAX_VALUE;
+	
+	private final IStrategoTerm[] inputs;
+	
+	private final IStrategoTerm[] outputs;
+	
+	private final int startIndex;
+	
+	private final int jobLength;
+	
+	private final int parallelismLevel;
+	
+	private final AtomicInteger focusIndex;
+	
+	private final Object notifier;
+	
+	private boolean isFocusJob;
+	
+	/**
+	 * Constructs a new parallel job.
+	 * 
+	 * @param inputs		The inputs for this job.
+	 * @param outputs		The outputs for this job.
+	 * @param startIndex	The starting index in <code>inputs</code> to process.
+	 * @param jobLength		The number of entries in <code>inputs</code> to process.
+	 * @param focusIndex	The index of the focus job.
+	 * @param notifier		An object used for synchronization and event notification.
+	 */
+	public ParallelJob(IStrategoTerm[] inputs, IStrategoTerm[] outputs,
+			int startIndex, int jobLength, int parallelismLevel, AtomicInteger focusIndex, Object notifier) {
+		
+		this.inputs = inputs;
+		this.outputs = outputs;
+		this.startIndex = startIndex;
+		this.jobLength = jobLength;
+		this.parallelismLevel = parallelismLevel;
+		this.focusIndex = focusIndex;
+		this.notifier = notifier;
+	}
+
+	public final void run() {
+		if (VERBOSE) System.out.print('.');
+		int end = min(inputs.length, startIndex + jobLength);
+			
+		for (int i = startIndex; i < end; i++) {
+			IStrategoTerm result = execute(inputs[i]);
+			if (result == null) break;
+			outputs[i] = result;
+		}
+		
+		if (VERBOSE && !isFocusJob)
+			System.out.print('!');
+		
+		updateFocusIndex();
+		
+		if (ADJUST_FOCUS_THREAD_PRIORITY) {
+			Thread thread = Thread.currentThread();
+			if (thread.getPriority() != Thread.NORM_PRIORITY)
+				thread.setPriority(Thread.NORM_PRIORITY);
+		}
+	}
+	
+	public AtomicInteger getFocusIndex() {
+		return focusIndex;
+	}
+
+	private void updateFocusIndex() {
+		if (focusIndex.get() == COMPLETED_FOCUS_INDEX) return;
+		
+		// synchronized here ensures ordered writes to 'outputs'
+		synchronized (notifier) {
+			int oldFocusIndex = focusIndex.get();
+			if (oldFocusIndex == COMPLETED_FOCUS_INDEX) return;
+			int newFocusIndex = oldFocusIndex;
+			
+			while (newFocusIndex < outputs.length) {
+				int lastJob = min(newFocusIndex + jobLength, outputs.length) - 1;
+				if (newFocusIndex > oldFocusIndex) {
+					focusIndex.set(newFocusIndex);
+				}
+				if (outputs[lastJob] == null) {
+					if (newFocusIndex > oldFocusIndex) {
+						notifier.notifyAll();
+					}
+					return;
+				}
+				newFocusIndex += jobLength;
+			}
+			
+			focusIndex.set(COMPLETED_FOCUS_INDEX);
+			if (VERBOSE) System.out.print(">");
+			notifier.notifyAll();
+		}
+	}
+	
+	public abstract IStrategoTerm execute(IStrategoTerm input);
+	
+	public boolean isFocusJob() {
+		return isFocusJob || focusIndex.get() == startIndex;
+	}
+	
+	public void waitForFocus() throws InterruptedException {
+		if (!isFocusJob) {
+			// waitForFocusIndex(focusIndex, startIndex, notifier);
+			waitForFocusIndexEagerly();
+			if (ADJUST_FOCUS_THREAD_PRIORITY)
+				Thread.currentThread().setPriority(Thread.MAX_PRIORITY);
+			isFocusJob = true;
+		}
+	}
+
+	private void waitForFocusIndexEagerly() throws InterruptedException {
+		if (focusIndex.get() < startIndex) {
+			synchronized (notifier) {
+				updateFocusIndex();
+				while (focusIndex.get() < startIndex) {
+					if (VERBOSE) System.out.print('$');
+					notifier.wait();
+				}
+			}
+		}
+	}
+
+	protected static void waitForFocusIndex(AtomicInteger focusIndex, int index, Object notifier) throws InterruptedException {
+		if (focusIndex.get() < index) {
+			synchronized (notifier) {
+				while (focusIndex.get() < index) {
+					notifier.wait();
+				}
+			}
+		}
+	}
+	
+	public int compareTo(ParallelJob o) {
+		if (parallelismLevel > o.parallelismLevel) {
+			return -1;
+		} else if (parallelismLevel == o.parallelismLevel) {
+			return startIndex < o.startIndex
+					? -1
+					: startIndex == o.startIndex ? 0 : 1;
+		} else {
+			return 1;
+		}
+	}
+}

Added: strc-java/trunk/java/runtime/org/strategoxt/lang/parallel/ParallelJobAbortedException.java
===================================================================
--- strc-java/trunk/java/runtime/org/strategoxt/lang/parallel/ParallelJobAbortedException.java	                        (rev 0)
+++ strc-java/trunk/java/runtime/org/strategoxt/lang/parallel/ParallelJobAbortedException.java	2009-06-26 07:58:24 UTC (rev 19559)
@@ -0,0 +1,15 @@
+package org.strategoxt.lang.parallel;
+
+import org.strategoxt.lang.StrategoException;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class ParallelJobAbortedException extends StrategoException {
+
+	private static final long serialVersionUID = 3832524936272309156L;
+
+	public ParallelJobAbortedException() {
+		super("Parallel running Stratego job aborted");
+	}
+}

Added: strc-java/trunk/java/runtime/org/strategoxt/lang/parallel/ParallelJobExecutor.java
===================================================================
--- strc-java/trunk/java/runtime/org/strategoxt/lang/parallel/ParallelJobExecutor.java	                        (rev 0)
+++ strc-java/trunk/java/runtime/org/strategoxt/lang/parallel/ParallelJobExecutor.java	2009-06-26 07:58:24 UTC (rev 19559)
@@ -0,0 +1,78 @@
+package org.strategoxt.lang.parallel;
+
+import static org.strategoxt.lang.parallel.libstratego_parallel.*;
+
+import java.util.concurrent.PriorityBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+import org.spoofax.jsglr.NotImplementedException;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class ParallelJobExecutor extends ThreadPoolExecutor {
+	
+	private final int asyncMaxPoolSize;
+	
+	private final boolean isConstantPoolSize;
+	
+	private int asyncPoolSize;
+
+	public ParallelJobExecutor() {
+		this(DEFAULT_ACTIVE_THREADS, DEFAULT_MAX_THREADS);
+	}
+	
+	public ParallelJobExecutor(int activeThreads, int maxThreads) {
+		super(activeThreads - 1, maxThreads - 1, 60L, TimeUnit.SECONDS, new PriorityBlockingQueue<Runnable>());
+		isConstantPoolSize = activeThreads == maxThreads;
+		this.asyncPoolSize = activeThreads;
+		this.asyncMaxPoolSize = maxThreads;
+	}
+	
+	@Override
+	public synchronized int getCorePoolSize() {
+		return super.getCorePoolSize();
+	}
+	
+	@Override
+	public synchronized int getMaximumPoolSize() {
+		return super.getMaximumPoolSize();
+	}
+	
+	@Override
+	public void setCorePoolSize(int corePoolSize) {
+		throw new NotImplementedException();
+	}
+	
+	@Override
+	public void setMaximumPoolSize(int maximumPoolSize) {
+		throw new NotImplementedException();
+	}
+	
+	/**
+	 * Indicates that a thread is going into an inactive state.
+	 * Must be executed from a worker thread, and balanced
+	 * with {@link #asyncEndSleep()};
+	 */
+	public synchronized void asyncBeginSleep() {
+		if (!isConstantPoolSize) {
+			asyncPoolSize++;
+			if (asyncPoolSize <= asyncMaxPoolSize)
+				super.setCorePoolSize(asyncPoolSize);
+		}
+	}
+	
+	/**
+	 * Indicates that a thread resumes from an inactive state.
+	 * Must be executed from a worker thread, and balanced
+	 * with {@link #asyncBeginSleep()};
+	 */
+	public synchronized void asyncEndSleep() {
+		if (!isConstantPoolSize) {
+			asyncPoolSize--;
+			if (asyncPoolSize <= asyncMaxPoolSize)
+				super.setCorePoolSize(asyncPoolSize);
+		}
+	}
+}

Added: strc-java/trunk/java/runtime/org/strategoxt/lang/parallel/PureOperatorSet.java
===================================================================
--- strc-java/trunk/java/runtime/org/strategoxt/lang/parallel/PureOperatorSet.java	                        (rev 0)
+++ strc-java/trunk/java/runtime/org/strategoxt/lang/parallel/PureOperatorSet.java	2009-06-26 07:58:24 UTC (rev 19559)
@@ -0,0 +1,97 @@
+package org.strategoxt.lang.parallel;
+
+import java.util.HashSet;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class PureOperatorSet {
+
+	// TODO: PureOperatorSet should be a field in Context, not static
+	//       (also, any "pure" operators should add themselves)
+
+	/**
+	 * Primitives that are always thread safe.
+	 */
+	@SuppressWarnings("serial")
+	private static final HashSet<String> whiteList = new HashSet<String>() {{
+		add("SSL_new");
+		add("SSL_newname");
+		add("SSL_is_string");
+		add("SSL_is_real");
+		add("SSL_is_int");
+		add("SSL_get_list_length");
+		add("SSL_get_constructor");
+		add("SSL_get_arguments");
+		add("SSL_get_appl_arguments_map");
+		add("SSL_mkterm");
+		add("SSL_concat_strings");
+		add("SSL_strcat");
+		add("SSL_gti");
+		add("SSL_lti");
+		add("SSL_gtr");
+		add("SSL_ltr");
+		add("SSL_addr");
+		add("SSL_subtr");
+		add("SSL_divr");
+		add("SSL_addi");
+		add("SSL_subti");
+		add("SSL_divi");
+		add("SSL_explode_string");
+		add("SSL_implode_string");
+		add("SSL_string_to_int");
+		add("SSL_int_to_string");
+		add("SSL_getenv");
+		add("JSGLR_parse_string_pt_compat");
+		add("JSGLR_parse_string_pt");
+		add("JSGLR_open_parsetable");
+		// TODO: More "pure" operators
+	}};
+	
+	/**
+	 * Primitives that are thread safe only if not
+	 * combined with other white/gray-listed primitives.
+	 */
+	@SuppressWarnings("serial")
+	private static final HashSet<String> grayList = new HashSet<String>() {{
+		add("SSL_dynamic_rules_hashtable");
+		add("SSL_hashtable_get");
+		add("SSL_indexedSet_get");
+		add("SSL_hashtable_elements");
+		add("SSL_indexedSet_elements");
+		add("SSL_table_hashtable");
+		add("SSL_table_fold");
+		add("SSL_keys_fold");
+		add("SSL_values_fold");
+	}};
+	
+	/* UNDONE: operator blacklist
+	 * Primitives that are generally not thread safe.
+	 * If explicitly indicated, they may be used with synchronization locks,
+	 * together with the gray-listed opertors, which must then also
+	 * be locked.
+	 *
+	@SuppressWarnings("serial")
+	private static final HashSet<String> blackList = new HashSet<String>() {{
+		add("SSL_hashtable_put");
+		add("SSL_indexedSet_put");
+		add("SSL_hashtable_remove");
+		add("SSL_indexedSet_remove");
+		add("SSL_hashtable_reset");
+		add("SSL_indexedSet_reset");
+		add("SSL_hashtable_create");
+		add("SSL_indexedSet_create");
+		add("SSL_fputs");
+	}};
+	*/
+	
+	private PureOperatorSet() {}
+	
+	public static boolean isWhiteListed(String name) {
+		return whiteList.contains(name);
+	}
+	
+	public static boolean isGrayListed(String name) {
+		return grayList.contains(name);
+	}
+}

Added: strc-java/trunk/java/runtime/org/strategoxt/lang/parallel/libstratego_parallel.java
===================================================================
--- strc-java/trunk/java/runtime/org/strategoxt/lang/parallel/libstratego_parallel.java	                        (rev 0)
+++ strc-java/trunk/java/runtime/org/strategoxt/lang/parallel/libstratego_parallel.java	2009-06-26 07:58:24 UTC (rev 19559)
@@ -0,0 +1,57 @@
+package org.strategoxt.lang.parallel;
+
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.strategoxt.lang.Context;
+import org.strategoxt.lang.IStrategy;
+import org.strategoxt.lang.SRTS_all;
+import org.strategoxt.lang.Strategy;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class libstratego_parallel {
+	
+	protected static final boolean ENABLED = true;
+	
+	protected static final boolean VERBOSE = true;
+	
+	protected static final boolean DIAGNOSE_SYNCHRONOUS_OPERATIONS = false;
+	
+	protected static final int DEFAULT_ACTIVE_THREADS = 4;
+	
+	protected static final int DEFAULT_MAX_THREADS = 4;
+	
+	protected static final int DEFAULT_TERM_SIZE_THRESHOLD = 3200;
+	
+	protected static final int DEFAULT_SUBTERM_COUNT_THRESHOLD = 6;
+	
+	protected static final double DEFAULT_JOB_LENGTH_MULTIPLIER = .5;
+	
+	protected static final boolean ALLOW_NESTED_JOBS = false;
+	
+	protected static final boolean ADJUST_FOCUS_THREAD_PRIORITY = true;
+	
+	private static boolean isInitialized; 
+	
+	public static void init(Context context) {
+		if (isInitialized) return;
+		isInitialized = true;
+		
+		ParallelAll.instance = new ParallelAll();
+		SRTS_all.instance = ParallelAll.instance;
+	}
+	
+	public static class parallel_unordered_0_0 extends Strategy {
+		public static parallel_unordered_0_0 instance = new parallel_unordered_0_0();
+		
+		@Override
+		public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s) {
+			ParallelAll.instance.setAllowUnorderedOnce(true);
+			try {
+				return s.invoke(context, current, s);
+			} finally {
+				ParallelAll.instance.setAllowUnorderedOnce(false);
+			}
+		}
+	}
+}



From L.C.L.Kats at tudelft.nl  Fri Jun 26 09:59:17 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Fri, 26 Jun 2009 07:59:17 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19560 - LennartKats -
	in strc-java/trunk/java: . META-INF runtime/org/strategoxt
Message-ID: <200906260757.n5Q7vsId003434@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-06-26 07:59:17 +0000 (Fri, 26 Jun 2009)
New Revision: 19560

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19560&view=rev

Added:
   strc-java/trunk/java/META-INF/MANIFEST-repacked.MF
   strc-java/trunk/java/runtime/org/strategoxt/HybridInterpreter.java
Modified:
   strc-java/trunk/java/Makefile.am

Log:
Actual HybridInterpreter class.

Changes:

Added: strc-java/trunk/java/META-INF/MANIFEST-repacked.MF
===================================================================
--- strc-java/trunk/java/META-INF/MANIFEST-repacked.MF	                        (rev 0)
+++ strc-java/trunk/java/META-INF/MANIFEST-repacked.MF	2009-06-26 07:59:17 UTC (rev 19560)
@@ -0,0 +1,5 @@
+Manifest-Version: 1.0
+Created-By: 1.6.0_10 (Sun Microsystems Inc.)
+Main-Class: org.strategoxt.strj
+Class-Path: strategoxt-no-compression.jar
+Export-Package: org.strategoxt
Modified: strc-java/trunk/java/Makefile.am
===================================================================
--- strc-java/trunk/java/Makefile.am	2009-06-26 07:58:24 UTC (rev 19559)
+++ strc-java/trunk/java/Makefile.am	2009-06-26 07:59:17 UTC (rev 19560)
@@ -28,6 +28,7 @@
   lib/org/strategoxt/libstratego_rtg.java \
   lib/org/strategoxt/libstratego_aterm.java \
   lib/org/strategoxt/libstratego_sdf.java \
+  lib/org/strategoxt/libstratego_tool_doc.java \
   lib/org/strategoxt/libstrc.java \
   lib/org/strategoxt/libjava_front.java
 
@@ -56,7 +57,7 @@
 JARIN2=`find lib      | grep -E '\.class|\.rtree|\.af|\.tbl' | sed 's!lib/!-C lib/ !'`
 JARIN3=`find compiler | grep -E '\.class|\.rtree|\.af|\.tbl' | sed 's!compiler/!-C compiler/ !'`
 
-jar : ext-lib .ALLCLASSES
+jar strategoxt.jar : ext-lib # .ALLCLASSES $(RUNTIMEJAVAS) $(LIBARYJAVAS) $(COMPILERJAVAS)
 	$(JAR) cfm strategoxt.jar META-INF/MANIFEST.MF $(JARIN1)
 	$(JAR) ufm strategoxt.jar META-INF/MANIFEST.MF $(JARIN2)
 	$(JAR) ufm strategoxt.jar META-INF/MANIFEST.MF $(JARIN3)
@@ -68,6 +69,20 @@
 	$(JAR) ufm strategoxt.jar META-INF/MANIFEST.MF -C $(BASEPATH)/org.spoofax.interpreter.library.jsglr/bin/ .
 	jar i strategoxt.jar
 
+smalljar :
+	$(JAR) cfm0 strategoxt.jar META-INF/MANIFEST.MF $(JARIN1)
+	$(JAR) ufm0 strategoxt.jar META-INF/MANIFEST.MF $(JARIN2)
+	$(JAR) ufm0 strategoxt.jar META-INF/MANIFEST.MF $(JARIN3)
+	$(JAR) ufm0 strategoxt.jar META-INF/MANIFEST.MF -C ext-lib/ .
+	$(JAR) ufm0 strategoxt.jar META-INF/MANIFEST.MF -C $(BASEPATH)/org.spoofax.interpreter.core/bin/ .
+	$(JAR) ufm0 strategoxt.jar META-INF/MANIFEST.MF -C $(BASEPATH)/../../branches/spoofax-recovery/bin/ .
+	$(JAR) ufm0 strategoxt.jar META-INF/MANIFEST.MF -C $(BASEPATH)/org.spoofax.aterm/bin/ .
+	$(JAR) ufm0 strategoxt.jar META-INF/MANIFEST.MF -C $(BASEPATH)/org.spoofax.interpreter.adapter.aterm/bin/ .
+	$(JAR) ufm0 strategoxt.jar META-INF/MANIFEST.MF -C $(BASEPATH)/org.spoofax.interpreter.library.jsglr/bin/ .
+	mv strategoxt.jar strategoxt-no-compression.jar
+	jar cfm strategoxt.jar META-INF/MANIFEST-repacked.MF strategoxt-no-compression.jar
+	jar i strategoxt.jar
+
 ext-lib : $(BASEPATH)/org.spoofax.aterm/lib/jjtraveler-0.4.3.jar $(BASEPATH)/org.spoofax.aterm/lib/shared-objects-1.4.jar
 	([ -d ext-lib ] || mkdir ext-lib); \
 	cat $(BASEPATH)/org.spoofax.aterm/lib/jjtraveler-0.4.3.jar | (cd ext-lib; $(JAR) x); \
@@ -84,28 +99,31 @@
 	cp $< $@
 
 lib/org/strategoxt/libstratego_xtc.java : lib/org/strategoxt/libstratego-xtc.rtree ../trans/strj
-	../trans/strj -I $(STRATEGOXT)/share/xtc -i $< -o $@ $(STRJOPTIONS) -la org.strategoxt.libstratego_lib -D GetInternalDefaultXtcRepository=None
+	../trans/strj -I $(STRATEGOXT)/share/xtc -i $< -o $@ $(STRJOPTIONS) -la stratego-lib -D GetInternalDefaultXtcRepository=None
 
 lib/org/strategoxt/libstratego_sglr.java : $(STRATEGOXT)/share/libstratego-sglr.ctree ../trans/strj
-	../trans/strj -I $(STRATEGOXT)/share -i $< -o $@ $(STRJOPTIONS) -la org.strategoxt.libstratego_lib -la org.strategoxt.libstratego_xtc
+	../trans/strj -I $(STRATEGOXT)/share -i $< -o $@ $(STRJOPTIONS) -la stratego-lib -la stratego-xtc
 
 lib/org/strategoxt/libstratego_rtg.java : $(STRATEGOXT)/share/libstratego-rtg.ctree ../trans/strj runtime/org/strategoxt/lang/compat/libstratego_rtg_compat.java
-	../trans/strj -I $(STRATEGOXT)/share -i $< -o $@ $(STRJOPTIONS) -la org.strategoxt.libstratego_lib -la org.strategoxt.libstratego_sglr -la org.strategoxt.lang.compat.libstratego_rtg_compat
+	../trans/strj -I $(STRATEGOXT)/share -i $< -o $@ $(STRJOPTIONS) -la stratego-lib -la stratego-sglr -la org.strategoxt.lang.compat.libstratego_rtg_compat
 
 lib/org/strategoxt/libstratego_gpp.java : $(STRATEGOXT)/share/libstratego-gpp.ctree ../trans/strj
-	../trans/strj -I $(STRATEGOXT)/share -i $< -o $@ $(STRJOPTIONS) -la org.strategoxt.libstratego_lib -la org.strategoxt.libstratego_lib -la org.strategoxt.libstratego_sglr
+	../trans/strj -I $(STRATEGOXT)/share -i $< -o $@ $(STRJOPTIONS) -la stratego-lib -la stratego-lib -la stratego-sglr
 
 lib/org/strategoxt/libstratego_aterm.java : $(STRATEGOXT)/share/libstratego-aterm.ctree runtime/org/strategoxt/lang/compat/override/libstratego_aterm_compat.java ../trans/strj
-	../trans/strj -I $(STRATEGOXT)/share -i $< -o $@ $(STRJOPTIONS) -la org.strategoxt.libstratego_lib -la org.strategoxt.libstratego_gpp -la org.strategoxt.lang.compat.override.libstratego_aterm_compat
+	../trans/strj -I $(STRATEGOXT)/share -i $< -o $@ $(STRJOPTIONS) -la stratego-lib -la stratego-gpp -la org.strategoxt.lang.compat.override.libstratego_aterm_compat
 
 lib/org/strategoxt/libstratego_sdf.java : $(STRATEGOXT)/share/libstratego-sdf.ctree ../trans/strj
-	../trans/strj -I $(STRATEGOXT)/share -i $< -o $@ $(STRJOPTIONS) -la org.strategoxt.libstratego_lib -la org.strategoxt.libstratego_sglr -la org.strategoxt.libstratego_gpp -la org.strategoxt.libstratego_aterm 
+	../trans/strj -I $(STRATEGOXT)/share -i $< -o $@ $(STRJOPTIONS) -la stratego-lib -la stratego-sglr -la stratego-gpp -la stratego-aterm 
 
+lib/org/strategoxt/libstratego_tool_doc.java : $(STRATEGOXT)/share/libstratego-tool-doc.ctree ../trans/strj
+	../trans/strj -I $(STRATEGOXT)/share -i $< -o $@ $(STRJOPTIONS) -la stratego-lib -la stratego-sglr -la stratego-gpp -la stratego-xtc -la stratego-aterm -D SRTS-package-bugreport='"bugs at strategoxt.org"' -D SRTS-package-name='"<SRTS-package-name>"' -D SRTS-package-revision='"<SRTS-package-revision>"' -D SRTS-package-version='"<SRTS-package-version>"'
+
 lib/org/strategoxt/libstrc.java : $(STRATEGOXT)/share/libstrc.ctree ../trans/strj runtime/org/strategoxt/lang/compat/libstrc_compat.java
-	../trans/strj -I $(STRATEGOXT)/share -I $(STRATEGOXT)/share/sdf/stratego-front -i $< -o $@ $(STRJOPTIONS) -la org.strategoxt.libstratego_lib -la org.strategoxt.libstratego_sglr -la org.strategoxt.libstratego_gpp -la org.strategoxt.libstratego_rtg -la org.strategoxt.libstratego_xtc -la org.strategoxt.lang.compat.libstrc_compat
+	../trans/strj -I $(STRATEGOXT)/share -I $(STRATEGOXT)/share/sdf/stratego-front -i $< -o $@ $(STRJOPTIONS) -la stratego-lib -la stratego-sglr -la stratego-gpp -la stratego-rtg -la stratego-xtc -la org.strategoxt.lang.compat.libstrc_compat
 
 lib/org/strategoxt/libjava_front.java : $(JAVA_FRONT)/share/java-front/libjava-front.ctree ../trans/strj
-	../trans/strj -I $(JAVA_FRONT)/share/java-front-syntax -i $< -o $@ $(STRJOPTIONS) -la org.strategoxt.libstratego_lib -la org.strategoxt.libstratego_sglr -la org.strategoxt.libstratego_gpp
+	../trans/strj -I $(JAVA_FRONT)/share/java-front-syntax -i $< -o $@ $(STRJOPTIONS) -la stratego-lib -la stratego-sglr -la stratego-gpp
 
 ###### RUNTIME #######
 
@@ -113,27 +131,27 @@
 	parse-stratego -i $< -o $@
 
 runtime/org/strategoxt/lang/compat/override/libstratego_aterm_compat.java : runtime/org/strategoxt/lang/compat/override/libstratego_aterm_compat.rtree ../trans/strj
-	../trans/strj -I $(STRATEGOXT)/share -i $< -o $@ $(STRJOPTIONS) -p org.strategoxt.lang.compat.override -la org.strategoxt.libstratego_lib -la org.strategoxt.libstratego_gpp
+	../trans/strj -I $(STRATEGOXT)/share -i $< -o $@ $(STRJOPTIONS) -p org.strategoxt.lang.compat.override -la stratego-lib -la stratego-gpp
 
 runtime/org/strategoxt/lang/compat/override/jsglr_parser_compat.java : runtime/org/strategoxt/lang/compat/override/jsglr-parser-compat.str ../trans/strj
-	../trans/strj -i $< -o $@ $(STRJOPTIONS) -p org.strategoxt.lang.compat.override -la org.strategoxt.libstratego_lib -la org.strategoxt.libstratego_sglr -la org.strategoxt.libstratego_xtc
+	../trans/strj -i $< -o $@ $(STRJOPTIONS) -p org.strategoxt.lang.compat.override -la stratego-lib -la stratego-sglr -la stratego-xtc
 
 runtime/org/strategoxt/lang/compat/override/jsglr_parser.java : runtime/org/strategoxt/lang/compat/override/jsglr-parser.str ../trans/strj
-	../trans/strj -i $< -o $@ $(STRJOPTIONS) -p org.strategoxt.lang.compat.override -la org.strategoxt.libstratego_lib
+	../trans/strj -i $< -o $@ $(STRJOPTIONS) -p org.strategoxt.lang.compat.override -la stratego-lib
 
 runtime/org/strategoxt/lang/compat/override/performance_tweaks.java : runtime/org/strategoxt/lang/compat/override/performance-tweaks.str ../trans/strj
-	../trans/strj -i $< -o $@ $(STRJOPTIONS) -p org.strategoxt.lang.compat.override -la org.strategoxt.libstratego_lib
+	../trans/strj -i $< -o $@ $(STRJOPTIONS) -p org.strategoxt.lang.compat.override -la stratego-lib
 
 runtime/org/strategoxt/lang/compat/override/xtc_compat.java : runtime/org/strategoxt/lang/compat/override/xtc-compat.str ../trans/strj
-	../trans/strj -i $< -o $@ $(STRJOPTIONS) -p org.strategoxt.lang.compat.override -la org.strategoxt.libstratego_lib -la org.strategoxt.libstratego_xtc
+	../trans/strj -i $< -o $@ $(STRJOPTIONS) -p org.strategoxt.lang.compat.override -la stratego-lib -la stratego-xtc
 
 runtime/org/strategoxt/lang/compat/override/strc_compat.java : runtime/org/strategoxt/lang/compat/override/strc-compat.str ../trans/strj
-	../trans/strj -I $(STRATEGOXT)/share -I $(STRATEGOXT)/share/sdf/stratego-front -i $< -o $@ $(STRJOPTIONS) -p org.strategoxt.lang.compat.override -la org.strategoxt.libstratego_lib -la org.strategoxt.libstratego_xtc -la org.strategoxt.libstrc
+	../trans/strj -I $(STRATEGOXT)/share -I $(STRATEGOXT)/share/sdf/stratego-front -I $(JAVA_FRONT)/share/java-front -i $< -o $@ $(STRJOPTIONS) -p org.strategoxt.lang.compat.override -la stratego-lib -la stratego-xtc -la org.strategoxt.libstrc
 
 ###### COMPILER #######
 
 compiler/org/strategoxt/strj.java : ../trans/strj.ctree ../trans/strj
-	../trans/strj -i $< -o $@ -p org.strategoxt --verbose 3 -la org.strategoxt.libstratego_lib -la org.strategoxt.libstratego_xtc -la org.strategoxt.libstratego_gpp -la org.strategoxt.libstrc -la org.strategoxt.libjava_front # -D DEFAULT_XTC_REPOSITORY="\"$(REPOSITORY)\""
+	../trans/strj -i $< -o $@ -p org.strategoxt --verbose 3 -la stratego-lib -la stratego-xtc -la stratego-gpp -la org.strategoxt.libstrc -la org.strategoxt.libjava_front # -D DEFAULT_XTC_REPOSITORY="\"$(REPOSITORY)\""
 
 ###### GENERAL #######
 

Added: strc-java/trunk/java/runtime/org/strategoxt/HybridInterpreter.java
===================================================================
--- strc-java/trunk/java/runtime/org/strategoxt/HybridInterpreter.java	                        (rev 0)
+++ strc-java/trunk/java/runtime/org/strategoxt/HybridInterpreter.java	2009-06-26 07:59:17 UTC (rev 19560)
@@ -0,0 +1,52 @@
+package org.strategoxt;
+
+import org.spoofax.interpreter.adapter.aterm.BAFBasicTermFactory;
+import org.spoofax.interpreter.core.IContext;
+import org.spoofax.interpreter.core.Interpreter;
+import org.spoofax.interpreter.terms.ITermFactory;
+import org.strategoxt.lang.Context;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class HybridInterpreter extends Interpreter {
+	
+	private final Context compiledContext;
+
+	public HybridInterpreter() {
+		this(new BAFBasicTermFactory());
+	}
+
+	public HybridInterpreter(ITermFactory factory) {
+		this(factory, factory);
+	}
+
+	public HybridInterpreter(ITermFactory termFactory, ITermFactory programFactory) {
+		super(termFactory, programFactory);
+		
+		compiledContext = new Context(termFactory);
+		registerLibraries();
+	}
+	
+	protected void registerLibraries() {
+		IContext context = getContext();
+		Context compiledContext = getCompiledContext();
+		
+		// TODO: Optimize - could this be shared across threads?
+		libstratego_aterm.registerInterop(context, compiledContext);
+		libstratego_lib.registerInterop(context, compiledContext);
+		libstratego_rtg.registerInterop(context, compiledContext);
+		libstratego_sdf.registerInterop(context, compiledContext);
+		libstratego_xtc.registerInterop(context, compiledContext);
+		libstratego_sglr.registerInterop(context, compiledContext);
+		libstratego_tool_doc.registerInterop(context, compiledContext);
+		libstratego_rtg.registerInterop(context, compiledContext);
+		libjava_front.registerInterop(context, compiledContext);
+		libstrc.registerInterop(context, compiledContext);
+	}
+	
+	public Context getCompiledContext() {
+		return compiledContext;
+	}
+
+}



From L.C.L.Kats at tudelft.nl  Fri Jun 26 10:00:05 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Fri, 26 Jun 2009 08:00:05 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19561 - LennartKats -
	in strc-java/trunk: . .settings test test/basic trans
Message-ID: <200906260758.n5Q7wgJm003441@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-06-26 08:00:05 +0000 (Fri, 26 Jun 2009)
New Revision: 19561

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19561&view=rev

Added:
   strc-java/trunk/test/basic/pp_java5_to_string.str
Modified:
   strc-java/trunk/.classpath
   strc-java/trunk/.settings/org.eclipse.jdt.core.prefs
   strc-java/trunk/test/Makefile.am
   strc-java/trunk/test/basic/gchoice_1.str
   strc-java/trunk/trans/Makefile.am
   strc-java/trunk/trans/java-postprocess.str
   strc-java/trunk/trans/s2j.str

Log:
Some optimization tweaks and misc. changes.

Changes:

Modified: strc-java/trunk/.classpath
===================================================================
--- strc-java/trunk/.classpath	2009-06-26 07:59:17 UTC (rev 19560)
+++ strc-java/trunk/.classpath	2009-06-26 08:00:05 UTC (rev 19561)
@@ -5,6 +5,6 @@
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/J2SE-1.5"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/3"/>
 	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
-	<classpathentry kind="lib" path="java/lib"/>
+	<classpathentry kind="lib" path="java/strategoxt.jar" sourcepath="java/lib"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>

Modified: strc-java/trunk/.settings/org.eclipse.jdt.core.prefs
===================================================================
--- strc-java/trunk/.settings/org.eclipse.jdt.core.prefs	2009-06-26 07:59:17 UTC (rev 19560)
+++ strc-java/trunk/.settings/org.eclipse.jdt.core.prefs	2009-06-26 08:00:05 UTC (rev 19561)
@@ -1,4 +1,4 @@
-#Sat Feb 21 12:59:05 CET 2009
+#Mon Jun 01 12:56:28 CEST 2009
 eclipse.preferences.version=1
 org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
 org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.5
@@ -7,6 +7,77 @@
 org.eclipse.jdt.core.compiler.debug.lineNumber=generate
 org.eclipse.jdt.core.compiler.debug.localVariable=generate
 org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.doc.comment.support=enabled
+org.eclipse.jdt.core.compiler.problem.annotationSuperInterface=warning
 org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.autoboxing=ignore
+org.eclipse.jdt.core.compiler.problem.deprecation=warning
+org.eclipse.jdt.core.compiler.problem.deprecationInDeprecatedCode=disabled
+org.eclipse.jdt.core.compiler.problem.deprecationWhenOverridingDeprecatedMethod=disabled
+org.eclipse.jdt.core.compiler.problem.discouragedReference=warning
+org.eclipse.jdt.core.compiler.problem.emptyStatement=ignore
 org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.problem.fallthroughCase=warning
+org.eclipse.jdt.core.compiler.problem.fatalOptionalError=enabled
+org.eclipse.jdt.core.compiler.problem.fieldHiding=ignore
+org.eclipse.jdt.core.compiler.problem.finalParameterBound=warning
+org.eclipse.jdt.core.compiler.problem.finallyBlockNotCompletingNormally=warning
+org.eclipse.jdt.core.compiler.problem.forbiddenReference=error
+org.eclipse.jdt.core.compiler.problem.hiddenCatchBlock=warning
+org.eclipse.jdt.core.compiler.problem.incompatibleNonInheritedInterfaceMethod=warning
+org.eclipse.jdt.core.compiler.problem.incompleteEnumSwitch=warning
+org.eclipse.jdt.core.compiler.problem.indirectStaticAccess=ignore
+org.eclipse.jdt.core.compiler.problem.invalidJavadoc=warning
+org.eclipse.jdt.core.compiler.problem.invalidJavadocTags=enabled
+org.eclipse.jdt.core.compiler.problem.invalidJavadocTagsDeprecatedRef=enabled
+org.eclipse.jdt.core.compiler.problem.invalidJavadocTagsNotVisibleRef=enabled
+org.eclipse.jdt.core.compiler.problem.invalidJavadocTagsVisibility=public
+org.eclipse.jdt.core.compiler.problem.localVariableHiding=ignore
+org.eclipse.jdt.core.compiler.problem.methodWithConstructorName=warning
+org.eclipse.jdt.core.compiler.problem.missingDeprecatedAnnotation=ignore
+org.eclipse.jdt.core.compiler.problem.missingJavadocComments=ignore
+org.eclipse.jdt.core.compiler.problem.missingJavadocCommentsOverriding=disabled
+org.eclipse.jdt.core.compiler.problem.missingJavadocCommentsVisibility=public
+org.eclipse.jdt.core.compiler.problem.missingJavadocTagDescription=return_tag
+org.eclipse.jdt.core.compiler.problem.missingJavadocTags=ignore
+org.eclipse.jdt.core.compiler.problem.missingJavadocTagsOverriding=disabled
+org.eclipse.jdt.core.compiler.problem.missingJavadocTagsVisibility=public
+org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotation=warning
+org.eclipse.jdt.core.compiler.problem.missingSerialVersion=warning
+org.eclipse.jdt.core.compiler.problem.noEffectAssignment=warning
+org.eclipse.jdt.core.compiler.problem.noImplicitStringConversion=warning
+org.eclipse.jdt.core.compiler.problem.nonExternalizedStringLiteral=ignore
+org.eclipse.jdt.core.compiler.problem.nullReference=warning
+org.eclipse.jdt.core.compiler.problem.overridingPackageDefaultMethod=warning
+org.eclipse.jdt.core.compiler.problem.parameterAssignment=ignore
+org.eclipse.jdt.core.compiler.problem.possibleAccidentalBooleanAssignment=ignore
+org.eclipse.jdt.core.compiler.problem.potentialNullReference=ignore
+org.eclipse.jdt.core.compiler.problem.rawTypeReference=warning
+org.eclipse.jdt.core.compiler.problem.redundantNullCheck=warning
+org.eclipse.jdt.core.compiler.problem.redundantSuperinterface=ignore
+org.eclipse.jdt.core.compiler.problem.specialParameterHidingField=disabled
+org.eclipse.jdt.core.compiler.problem.staticAccessReceiver=warning
+org.eclipse.jdt.core.compiler.problem.suppressWarnings=enabled
+org.eclipse.jdt.core.compiler.problem.syntheticAccessEmulation=ignore
+org.eclipse.jdt.core.compiler.problem.typeParameterHiding=warning
+org.eclipse.jdt.core.compiler.problem.uncheckedTypeOperation=warning
+org.eclipse.jdt.core.compiler.problem.undocumentedEmptyBlock=ignore
+org.eclipse.jdt.core.compiler.problem.unhandledWarningToken=warning
+org.eclipse.jdt.core.compiler.problem.unnecessaryElse=ignore
+org.eclipse.jdt.core.compiler.problem.unnecessaryTypeCheck=warning
+org.eclipse.jdt.core.compiler.problem.unqualifiedFieldAccess=ignore
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownException=ignore
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionExemptExceptionAndThrowable=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionIncludeDocCommentReference=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionWhenOverriding=disabled
+org.eclipse.jdt.core.compiler.problem.unusedImport=warning
+org.eclipse.jdt.core.compiler.problem.unusedLabel=warning
+org.eclipse.jdt.core.compiler.problem.unusedLocal=warning
+org.eclipse.jdt.core.compiler.problem.unusedParameter=ignore
+org.eclipse.jdt.core.compiler.problem.unusedParameterIncludeDocCommentReference=enabled
+org.eclipse.jdt.core.compiler.problem.unusedParameterWhenImplementingAbstract=disabled
+org.eclipse.jdt.core.compiler.problem.unusedParameterWhenOverridingConcrete=disabled
+org.eclipse.jdt.core.compiler.problem.unusedPrivateMember=warning
+org.eclipse.jdt.core.compiler.problem.unusedWarningToken=warning
+org.eclipse.jdt.core.compiler.problem.varargsArgumentNeedCast=warning
 org.eclipse.jdt.core.compiler.source=1.5

Modified: strc-java/trunk/test/Makefile.am
===================================================================
--- strc-java/trunk/test/Makefile.am	2009-06-26 07:59:17 UTC (rev 19560)
+++ strc-java/trunk/test/Makefile.am	2009-06-26 08:00:05 UTC (rev 19561)
@@ -50,7 +50,7 @@
            internal_1 internal_2 override_1 extend_1 \
            shared_var_1 shared_var_2 shared_var_3 shared_var_4 shared_var_5 \
            dynrules_1 dynrules_2 dynrules_3 dynrules_4 dynrules_5 iset_1 fetch_1 \
-           mapconcat_1 traversal_1 annos_1 annos_2
+           mapconcat_1 traversal_1 annos_1 annos_2 pp_java5_to_string
 
 BASICTESTFILES=$(addprefix basic/,$(addsuffix .str,$(BASICTESTS)))
 
@@ -79,10 +79,13 @@
 	$(MAKE) -C ../trans strj
 
 %.ctree : %.str
-	$(SCOMPILE) -O 0 --format-check 0 -F -I strc1 -i $< -o $@
+	$(SCOMPILE) -O 0 $(JAVA_FRONT_STRCFLAGS) --format-check 0 -F -I strc1 -i $< -o $@
 
+%.str : %.astr
+	aster -i $< -o $@
+
 %.java : %.ctree ../trans/strj
-	../trans/strj -i $< -o $@ -la org.strategoxt.libstratego_lib
+	../trans/strj -i $< -o $@ -la stratego-lib -la java-front
 
 %.class : %.java
 	$(JAVAC) $(JAVACFLAGS) $<

Modified: strc-java/trunk/test/basic/gchoice_1.str
===================================================================
--- strc-java/trunk/test/basic/gchoice_1.str	2009-06-26 07:59:17 UTC (rev 19560)
+++ strc-java/trunk/test/basic/gchoice_1.str	2009-06-26 08:00:05 UTC (rev 19561)
@@ -1,5 +1,8 @@
 module gchoice_1
 
+imports
+  libstratego-lib
+
 signature constructors
   Nil  : Nil
   Cons : Term -> Cons
@@ -7,5 +10,10 @@
 rules
 
   main =
-    not(id < (id < fail + !3) + !2)
-
+    not(
+      id
+      < (id < fail + !3)
+      + !2
+    )
+  ; (id < id + ?never)
+  ; not(!never)

Added: strc-java/trunk/test/basic/pp_java5_to_string.str
===================================================================
--- strc-java/trunk/test/basic/pp_java5_to_string.str	                        (rev 0)
+++ strc-java/trunk/test/basic/pp_java5_to_string.str	2009-06-26 08:00:05 UTC (rev 19561)
@@ -0,0 +1,10 @@
+module pp-java5-to-string
+
+imports libjava-front libstratego-lib
+
+rules
+
+  main =
+    !CompilationUnit(None,[],[ClassDec(ClassDecHead([],Id("Foo"),None,None,None),ClassBody([]))])
+  ; pp-java5-to-string
+  ; is-string

Modified: strc-java/trunk/trans/Makefile.am
===================================================================
--- strc-java/trunk/trans/Makefile.am	2009-06-26 07:59:17 UTC (rev 19560)
+++ strc-java/trunk/trans/Makefile.am	2009-06-26 08:00:05 UTC (rev 19561)
@@ -25,8 +25,8 @@
 
 BASEPATH=../../../spoofax/trunk/spoofax
 SPCLASSPATH=$(BASEPATH)/org.spoofax.interpreter.core/bin:$(BASEPATH)/org.spoofax.interpreter.adapter.aterm/bin:$(BASEPATH)/org.spoofax.interpreter.library.jsglr/bin:$(BASEPATH)/../../branches/spoofax-recovery/bin:$(BASEPATH)/org.spoofax.aterm/bin/:$(BASEPATH)/org.spoofax.aterm/lib/jjtraveler-0.4.3.jar:$(BASEPATH)/org.spoofax.aterm/lib/shared-objects-1.4.jar
-CLASSPATH=$(SPCLASSPATH):../java/runtime:../java/lib:../java/compiler:.
-JAVACFLAGS=-J-Xmx256m -cp $(CLASSPATH) -Xss10m -source 5 -nowarn
+CLASSPATH=.:$(SPCLASSPATH):../java/runtime:../java/lib:../java/compiler
+JAVACFLAGS=-J-Xmx256m -cp $(CLASSPATH) -source 5 -nowarn
 JAVAC=`if which ecj >/dev/null; then echo ecj; else echo javac; fi`
 
 %.rtg.af : $(JAVA_FRONT)/share/java-front/Java-15.rtg
@@ -35,6 +35,9 @@
 %.ctree : %.str
 	strc -F --format-check 0 --library -la stratego-lib -i $< -o $@ -O 0
 
+%.str : %.astr
+	aster -i $< -o $@
+
 strj.ctree : strj.rtree $(STRJSOURCES:.str=.rtree) strj
 	$(SCOMPILE) $(STRINCLUDES) $(STRCFLAGS) $(SCFLAGS) -i $< -o $@ -F -m main-strj
 

Modified: strc-java/trunk/trans/java-postprocess.str
===================================================================
--- strc-java/trunk/trans/java-postprocess.str	2009-06-26 07:59:17 UTC (rev 19560)
+++ strc-java/trunk/trans/java-postprocess.str	2009-06-26 08:00:05 UTC (rev 19561)
@@ -111,6 +111,9 @@
     If(e, s1, Empty()) -> If(e, s1)
   
   java-simplify-stm :
+    Block([Block(s)]) -> Block(s)
+  
+  java-simplify-stm :
     |[ if (e1 == e2) ; else stm2 ]| -> |[ if (e1 != e2) stm2 ]|
   
   java-simplify-expr :
@@ -137,11 +140,12 @@
 strategies
 
   java-optimize =
-    topdown-consnil(try(
+    topdown-consnil(repeat(
       optimize-match-test
+    + optimize-assignments
     ))
   ; bottomup(repeat( // should be done after previous pass
-      optimize-if-true-break
+      optimize-conditionals
     ))
 
   optimize-match-test :
@@ -206,6 +210,9 @@
     with
       bstm_othermatch'* := <try(replace-match-test1(|x_actualcons, x_cached))> bstm_othermatch*
   
+  match-decls-and-appl-text :
+    [Block(bstm*) | _] -> <match-decls-and-appl-test> bstm*
+  
   match-decls-and-appl-test :
     bstm* |[ IStrategoTerm x = null; bstm* ]| -> ([<Hd> | bstm_decl*], x_cons, bstm_body*)
     where
@@ -223,30 +230,50 @@
     <+
       !e_cons => |[ x_cons ]|
 
-  optimize-if-true-break :
-    bstm |[ { Fail: { if (TRUE) break Success; } bstm* } ]| -> |[ if (TRUE) break Success; ]|
+  optimize-conditionals :
+    bstm |[ Fail: { if (TRUE) break Fail; bstm1* } ]| -> bstm |[ ; ]|
+
+  optimize-conditionals :
+    bstm |[ { if (TRUE) break x; bstm* } ]| -> bstm |[ { if (TRUE) break x; } ]|
+    where
+      not(!bstm* => [])
   
-  optimize-if-true-break :
+  optimize-conditionals :
     bstm |[ if (e) if (TRUE) stm ]| -> |[ if (e) stm ]|
   
-  optimize-if-true-break :
+  optimize-conditionals :
     bstm |[ Success: { if (e) break Success; bstm* } ]| -> |[ if (!e) { bstm* } ]|
   
-  optimize-if-true-break :
+  optimize-conditionals :
     bstm |[ if (!(e1 == e2)) stm ]| -> |[ if (e1 != e2) stm ]|
   
-  optimize-if-true-break :
+  optimize-conditionals :
     bstm |[ if (e1) { if (e2) stm } ]| -> |[ if (e1 && e2) stm ]|
     where
       not(!e2 => expr |[ TRUE ]|)
   
-  optimize-if-true-break :
+  optimize-conditionals :
     |[ Fail: { bstm* } ]| -> |[ Fail: { bstm'* } ]|
     where
       !bstm*
     ; one(?|[ if (e) break Fail; ]|)
     ; at-last([remove-if-true]) => bstm'*
   
+  optimize-conditionals :
+    Block([Block(s)]) -> Block(s)
+  
+  optimize-assignments :
+    bstm* |[ term = y; x = term; term = z; bstm* ]| ->
+    bstm* |[ x = y; term = z; bstm* ]|
+    where
+      not(!z => expr |[ term ]|)
+  
+  optimize-assignments :
+    bstm* |[ x = y; x = e; bstm* ]| ->
+    bstm* |[ x = e; bstm* ]|
+    where
+      not(<oncetd(?x)> e)
+  
   remove-if-true :
     |[ if (TRUE) break Fail; ]| -> |[ break Fail; ]|
   

Modified: strc-java/trunk/trans/s2j.str
===================================================================
--- strc-java/trunk/trans/s2j.str	2009-06-26 07:59:17 UTC (rev 19560)
+++ strc-java/trunk/trans/s2j.str	2009-06-26 08:00:05 UTC (rev 19561)
@@ -109,7 +109,6 @@
      public class x_name {
 
      private static boolean TRACES_ENABLED = e_traces;
-     private static boolean TRUE = true; // (ECJ 3.3 reachability detection bug workaround)
      private static ITermFactory constantFactory;
 
      ~*cnst-decls
@@ -140,13 +139,13 @@
      ]|
 
      ~*main
-     ~*register
      ~*constant
 
      ~*constant-defs
      ~*function-defs
      ~*lifted-defs
 
+     ~*register
      }
      ]|
   with 
@@ -438,6 +437,7 @@
     SDefT(x, s*, t*, s) ->
     |[ mod_override*
        public IStrategoTerm invoke(Context context, IStrategoTerm term, param*) {
+           boolean TRUE = true; // (ECJ 3.3 reachability detection bug workaround)
            ITermFactory termFactory = context.getFactory();
            bstm_init*
            if (TRACES_ENABLED) context.push("~x");
@@ -462,7 +462,7 @@
         else
           mod_override* := [ anno |[ @Override ]| ]
         end
-      ; bstm := <translate-body> s  
+      ; bstm := <translate-strategy> s  
       |}
     
   translate-outer-definition :
@@ -509,14 +509,13 @@
   
 strategies
   
-  /** @type Strategy -> Stm */
-  translate-body = 
-    translate-strategy
-
-  translation-failed = ?x#(_) ; log(|Error(), [ "Unknown constructor type ", x ]) ; fail
-  
   translate-Scope : 
-    Scope(vars, body) -> bstm* |[ bstm_decl* bstm_body ]|
+    Scope(vars, body) -> bstm* |[
+      // { // TODO: using an actual scope might reduce the # of local variable slots
+        bstm_decl*
+        bstm_body
+      // }
+    ]|
     with
       bstm_decl* := <map(to-java-vardecl)> vars
     ; bstm_body  := <translate-strategy> body



From L.C.L.Kats at tudelft.nl  Fri Jun 26 11:22:32 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Fri, 26 Jun 2009 09:22:32 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19563 - LennartKats -
	in strc-java/trunk: java java/runtime/org/strategoxt/lang
	java/runtime/org/strategoxt/lang/compat
	java/runtime/org/strategoxt/lang/parallel trans
Message-ID: <200906260921.n5Q9L9qU004774@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-06-26 09:22:32 +0000 (Fri, 26 Jun 2009)
New Revision: 19563

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19563&view=rev

Removed:
   strc-java/trunk/java/runtime/org/strategoxt/lang/IStrategy.java
Modified:
   strc-java/trunk/java/Makefile.am
   strc-java/trunk/java/runtime/org/strategoxt/lang/Context.java
   strc-java/trunk/java/runtime/org/strategoxt/lang/DynamicStrategy.java
   strc-java/trunk/java/runtime/org/strategoxt/lang/IDynamicStrategy.java
   strc-java/trunk/java/runtime/org/strategoxt/lang/InteropSDefT.java
   strc-java/trunk/java/runtime/org/strategoxt/lang/InteropStrategy.java
   strc-java/trunk/java/runtime/org/strategoxt/lang/InteropStrategyDef.java
   strc-java/trunk/java/runtime/org/strategoxt/lang/SRTS_EXT_crush_3_0.java
   strc-java/trunk/java/runtime/org/strategoxt/lang/SRTS_EXT_filter_1_0.java
   strc-java/trunk/java/runtime/org/strategoxt/lang/SRTS_all.java
   strc-java/trunk/java/runtime/org/strategoxt/lang/SRTS_one.java
   strc-java/trunk/java/runtime/org/strategoxt/lang/SRTS_some.java
   strc-java/trunk/java/runtime/org/strategoxt/lang/Strategy.java
   strc-java/trunk/java/runtime/org/strategoxt/lang/Term.java
   strc-java/trunk/java/runtime/org/strategoxt/lang/compat/libstratego_rtg_compat.java
   strc-java/trunk/java/runtime/org/strategoxt/lang/parallel/ParallelAll.java
   strc-java/trunk/java/runtime/org/strategoxt/lang/parallel/ParallelContext.java
   strc-java/trunk/java/runtime/org/strategoxt/lang/parallel/libstratego_parallel.java
   strc-java/trunk/trans/java-postprocess.str
   strc-java/trunk/trans/s2j.str

Log:
- Removed IStrategy interface
- No longer (indirectly) accessing private fields from inner classes

Changes (first 1000 lines of the diffs):

Modified: strc-java/trunk/java/Makefile.am
===================================================================
--- strc-java/trunk/java/Makefile.am	2009-06-26 08:28:41 UTC (rev 19562)
+++ strc-java/trunk/java/Makefile.am	2009-06-26 09:22:32 UTC (rev 19563)
@@ -37,9 +37,10 @@
 nobase_pkgdata_DATA = $(LIBRARYJAVAS) $(COMPILERJAVAS) .ALLCLASSES $(RUNTIMECLASSES) $(LIBRARYCLASSES) $(COMPILERCLASSES)
 
 CLEANFILES = \
-  $(RUNTIMECLASSES) $(LIBRARYCLASSES) \
+  $(RUNTIMECLASSES) $(LIBRARYCLASSES) $(COMPILERCLASSES) \
   $(subst runtime/org/strategoxt/lang/compat/libstrc_compat.java,, \
   $(subst runtime/org/strategoxt/lang/compat/libstratego_rtg_compat.java,,$(LIBRARYJAVAS))) \
+  $(COMPILERJAVAS) \
   .ALLCLASSES
 
 # HACK: hardcoded, relative classpath

Modified: strc-java/trunk/java/runtime/org/strategoxt/lang/Context.java
===================================================================
--- strc-java/trunk/java/runtime/org/strategoxt/lang/Context.java	2009-06-26 08:28:41 UTC (rev 19562)
+++ strc-java/trunk/java/runtime/org/strategoxt/lang/Context.java	2009-06-26 09:22:32 UTC (rev 19563)
@@ -122,7 +122,7 @@
     	uninit();
     }
     
-    public IStrategoTerm invokeStrategyCLI(IStrategy strategy, String appName, String[] args) {
+    public IStrategoTerm invokeStrategyCLI(Strategy strategy, String appName, String[] args) {
     	ITermFactory factory = getFactory();    	
     	IStrategoTerm[] termArgs = new IStrategoTerm[args.length + 1];
 		termArgs[0] = factory.makeString(appName);
@@ -136,7 +136,7 @@
     	return strategy.invoke(this, term);
     }
     
-    public final IStrategoTerm invokePrimitive(String name, IStrategoTerm term, IStrategy[] sargs, IStrategoTerm[] targs) {
+    public final IStrategoTerm invokePrimitive(String name, IStrategoTerm term, Strategy[] sargs, IStrategoTerm[] targs) {
     	AbstractPrimitive primitive = lookupOperator(name);
     	if (primitive == null)
     		throw new StrategoException("Illegal primitive invoked: " + name);
@@ -144,7 +144,7 @@
     	return invokePrimitive(primitive, term, sargs, targs);
     }
 
-	public IStrategoTerm invokePrimitive(AbstractPrimitive primitive, IStrategoTerm term, IStrategy[] sargs, IStrategoTerm[] targs) {
+	public IStrategoTerm invokePrimitive(AbstractPrimitive primitive, IStrategoTerm term, Strategy[] sargs, IStrategoTerm[] targs) {
 		interopContext.setCurrent(term);
 		try {
 			if (primitive.call(interopContext, InteropStrategy.toInteropStrategies(sargs), targs)) {

Modified: strc-java/trunk/java/runtime/org/strategoxt/lang/DynamicStrategy.java
===================================================================
--- strc-java/trunk/java/runtime/org/strategoxt/lang/DynamicStrategy.java	2009-06-26 08:28:41 UTC (rev 19562)
+++ strc-java/trunk/java/runtime/org/strategoxt/lang/DynamicStrategy.java	2009-06-26 09:22:32 UTC (rev 19563)
@@ -11,174 +11,189 @@
  * 
  * @author Lennart Kats <lennart add lclnet.nl>
  */
-public abstract class DynamicStrategy extends DynamicStrategyOverloads<IStrategy, IStrategoTerm> implements IStrategy {
+public abstract class DynamicStrategy extends Strategy implements IDynamicStrategy {
 	
-	public String getName() {
-		return getClass().getSimpleName();
-	}
+	@Override
+	public abstract IStrategoTerm invokeDynamic(Context context, IStrategoTerm current,
+			Strategy[] sargs, IStrategoTerm[] targs);
 	
 	@Override
-	public String toString() {
-		return getName();
+	public IStrategoTerm invoke(Context context, IStrategoTerm current) {
+		return invokeDynamic(context, current, NO_STRATEGIES, NO_TERMS);
 	}
-}
 
-/**
- * @author Lennart Kats <lennart add lclnet.nl>
- */
-abstract class DynamicStrategyOverloads<S extends IStrategy, T extends IStrategoTerm>
-		implements IStrategyOverloads<S, T>, IDynamicStrategyOverload<T> {
-	
-	public T invoke(Context context, T current) {
-		return invokeDynamic(context, current, EMPTY_STRATEGY_LIST, EMPTY_TERM_LIST);
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategoTerm t1) {
+		return invokeDynamic(context, current, NO_STRATEGIES, new IStrategoTerm[] { t1 });
 	}
 
-	public T invoke(Context context, T current, T t1) {
-		return invokeDynamic(context, current, EMPTY_STRATEGY_LIST, new IStrategoTerm[] { t1 });
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategoTerm t1, IStrategoTerm t2) {
+		return invokeDynamic(context, current, NO_STRATEGIES, new IStrategoTerm[] { t1, t2 });
 	}
 
-	public T invoke(Context context, T current, T t1, T t2) {
-		return invokeDynamic(context, current, EMPTY_STRATEGY_LIST, new IStrategoTerm[] { t1, t2 });
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3) {
+		return invokeDynamic(context, current, NO_STRATEGIES, new IStrategoTerm[] { t1, t2, t3 });
 	}
 
-	public T invoke(Context context, T current, T t1, T t2, T t3) {
-		return invokeDynamic(context, current, EMPTY_STRATEGY_LIST, new IStrategoTerm[] { t1, t2, t3 });
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4) {
+		return invokeDynamic(context, current, NO_STRATEGIES, new IStrategoTerm[] { t1, t2, t3, t4 });
 	}
 
-	public T invoke(Context context, T current, T t1, T t2, T t3, T t4) {
-		return invokeDynamic(context, current, EMPTY_STRATEGY_LIST, new IStrategoTerm[] { t1, t2, t3, t4 });
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4, IStrategoTerm t5) {
+		return invokeDynamic(context, current, NO_STRATEGIES, new IStrategoTerm[] { t1, t2, t3, t4, t5 });
 	}
 
-	public T invoke(Context context, T current, T t1, T t2, T t3, T t4, T t5) {
-		return invokeDynamic(context, current, EMPTY_STRATEGY_LIST, new IStrategoTerm[] { t1, t2, t3, t4, t5 });
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1) {
+		return invokeDynamic(context, current, new Strategy[] { s1 }, NO_TERMS);
 	}
 
-	public T invoke(Context context, T current, S s1) {
-		return invokeDynamic(context, current, new IStrategy[] { s1 }, EMPTY_TERM_LIST);
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, IStrategoTerm t1) {
+		return invokeDynamic(context, current, new Strategy[] { s1 }, new IStrategoTerm[] { t1 });
 	}
 
-	public T invoke(Context context, T current, S s1, T t1) {
-		return invokeDynamic(context, current, new IStrategy[] { s1 }, new IStrategoTerm[] { t1 });
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, IStrategoTerm t1, IStrategoTerm t2) {
+		return invokeDynamic(context, current, new Strategy[] { s1 }, new IStrategoTerm[] { t1, t2 });
 	}
 
-	public T invoke(Context context, T current, S s1, T t1, T t2) {
-		return invokeDynamic(context, current, new IStrategy[] { s1 }, new IStrategoTerm[] { t1, t2 });
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3) {
+		return invokeDynamic(context, current, new Strategy[] { s1 }, new IStrategoTerm[] { t1, t2, t3 });
 	}
 
-	public T invoke(Context context, T current, S s1, T t1, T t2, T t3) {
-		return invokeDynamic(context, current, new IStrategy[] { s1 }, new IStrategoTerm[] { t1, t2, t3 });
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4) {
+		return invokeDynamic(context, current, new Strategy[] { s1 }, new IStrategoTerm[] { t1, t2, t3, t4 });
 	}
 
-	public T invoke(Context context, T current, S s1, T t1, T t2, T t3, T t4) {
-		return invokeDynamic(context, current, new IStrategy[] { s1 }, new IStrategoTerm[] { t1, t2, t3, t4 });
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4, IStrategoTerm t5) {
+		return invokeDynamic(context, current, new Strategy[] { s1 }, new IStrategoTerm[] { t1, t2, t3, t4, t5 });
 	}
 
-	public T invoke(Context context, T current, S s1, T t1, T t2, T t3, T t4, T t5) {
-		return invokeDynamic(context, current, new IStrategy[] { s1 }, new IStrategoTerm[] { t1, t2, t3, t4, t5 });
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2) {
+		return invokeDynamic(context, current, new Strategy[] { s1, s2 }, NO_TERMS);
 	}
 
-	public T invoke(Context context, T current, S s1, S s2) {
-		return invokeDynamic(context, current, new IStrategy[] { s1, s2 }, EMPTY_TERM_LIST);
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, IStrategoTerm t1) {
+		return invokeDynamic(context, current, new Strategy[] { s1, s2 }, new IStrategoTerm[] { t1 });
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, T t1) {
-		return invokeDynamic(context, current, new IStrategy[] { s1, s2 }, new IStrategoTerm[] { t1 });
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, IStrategoTerm t1, IStrategoTerm t2) {
+		return invokeDynamic(context, current, new Strategy[] { s1, s2 }, new IStrategoTerm[] { t1, t2 });
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, T t1, T t2) {
-		return invokeDynamic(context, current, new IStrategy[] { s1, s2 }, new IStrategoTerm[] { t1, t2 });
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3) {
+		return invokeDynamic(context, current, new Strategy[] { s1, s2 }, new IStrategoTerm[] { t1, t2, t3 });
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, T t1, T t2, T t3) {
-		return invokeDynamic(context, current, new IStrategy[] { s1, s2 }, new IStrategoTerm[] { t1, t2, t3 });
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4) {
+		return invokeDynamic(context, current, new Strategy[] { s1, s2 }, new IStrategoTerm[] { t1, t2, t3, t4 });
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, T t1, T t2, T t3, T t4) {
-		return invokeDynamic(context, current, new IStrategy[] { s1, s2 }, new IStrategoTerm[] { t1, t2, t3, t4 });
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4, IStrategoTerm t5) {
+		return invokeDynamic(context, current, new Strategy[] { s1, s2 }, new IStrategoTerm[] { t1, t2, t3, t4, t5 });
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, T t1, T t2, T t3, T t4, T t5) {
-		return invokeDynamic(context, current, new IStrategy[] { s1, s2 }, new IStrategoTerm[] { t1, t2, t3, t4, t5 });
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, Strategy s3) {
+		return invokeDynamic(context, current, new Strategy[] { s1, s2, s3 }, NO_TERMS);
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, S s3) {
-		return invokeDynamic(context, current, new IStrategy[] { s1, s2, s3 }, EMPTY_TERM_LIST);
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, Strategy s3, IStrategoTerm t1) {
+		return invokeDynamic(context, current, new Strategy[] { s1, s2, s3 }, new IStrategoTerm[] { t1 });
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, S s3, T t1) {
-		return invokeDynamic(context, current, new IStrategy[] { s1, s2, s3 }, new IStrategoTerm[] { t1 });
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, Strategy s3, IStrategoTerm t1, IStrategoTerm t2) {
+		return invokeDynamic(context, current, new Strategy[] { s1, s2, s3 }, new IStrategoTerm[] { t1, t2 });
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, S s3, T t1, T t2) {
-		return invokeDynamic(context, current, new IStrategy[] { s1, s2, s3 }, new IStrategoTerm[] { t1, t2 });
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, Strategy s3, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3) {
+		return invokeDynamic(context, current, new Strategy[] { s1, s2, s3 }, new IStrategoTerm[] { t1, t2, t3 });
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, S s3, T t1, T t2, T t3) {
-		return invokeDynamic(context, current, new IStrategy[] { s1, s2, s3 }, new IStrategoTerm[] { t1, t2, t3 });
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, Strategy s3, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4) {
+		return invokeDynamic(context, current, new Strategy[] { s1, s2, s3 }, new IStrategoTerm[] { t1, t2, t3, t4 });
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, S s3, T t1, T t2, T t3, T t4) {
-		return invokeDynamic(context, current, new IStrategy[] { s1, s2, s3 }, new IStrategoTerm[] { t1, t2, t3, t4 });
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, Strategy s3, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4, IStrategoTerm t5) {
+		return invokeDynamic(context, current, new Strategy[] { s1, s2, s3 }, new IStrategoTerm[] { t1, t2, t3, t4, t5 });
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, S s3, T t1, T t2, T t3, T t4, T t5) {
-		return invokeDynamic(context, current, new IStrategy[] { s1, s2, s3 }, new IStrategoTerm[] { t1, t2, t3, t4, t5 });
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, Strategy s3, Strategy s4) {
+		return invokeDynamic(context, current, new Strategy[] { s1, s2, s3, s4 }, NO_TERMS);
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, S s3, S s4) {
-		return invokeDynamic(context, current, new IStrategy[] { s1, s2, s3, s4 }, EMPTY_TERM_LIST);
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, Strategy s3, Strategy s4, IStrategoTerm t1) {
+		return invokeDynamic(context, current, new Strategy[] { s1, s2, s3, s4 }, new IStrategoTerm[] { t1 });
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, S s3, S s4, T t1) {
-		return invokeDynamic(context, current, new IStrategy[] { s1, s2, s3, s4 }, new IStrategoTerm[] { t1 });
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, Strategy s3, Strategy s4, IStrategoTerm t1, IStrategoTerm t2) {
+		return invokeDynamic(context, current, new Strategy[] { s1, s2, s3, s4 }, new IStrategoTerm[] { t1, t2 });
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, S s3, S s4, T t1, T t2) {
-		return invokeDynamic(context, current, new IStrategy[] { s1, s2, s3, s4 }, new IStrategoTerm[] { t1, t2 });
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, Strategy s3, Strategy s4, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3) {
+		return invokeDynamic(context, current, new Strategy[] { s1, s2, s3, s4 }, new IStrategoTerm[] { t1, t2, t3 });
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, S s3, S s4, T t1, T t2, T t3) {
-		return invokeDynamic(context, current, new IStrategy[] { s1, s2, s3, s4 }, new IStrategoTerm[] { t1, t2, t3 });
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, Strategy s3, Strategy s4, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4) {
+		return invokeDynamic(context, current, new Strategy[] { s1, s2, s3, s4 }, new IStrategoTerm[] { t1, t2, t3, t4 });
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, S s3, S s4, T t1, T t2, T t3, T t4) {
-		return invokeDynamic(context, current, new IStrategy[] { s1, s2, s3, s4 }, new IStrategoTerm[] { t1, t2, t3, t4 });
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, Strategy s3, Strategy s4, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4, IStrategoTerm t5) {
+		return invokeDynamic(context, current, new Strategy[] { s1, s2, s3, s4 }, new IStrategoTerm[] { t1, t2, t3, t4, t5 });
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, S s3, S s4, T t1, T t2, T t3, T t4, T t5) {
-		return invokeDynamic(context, current, new IStrategy[] { s1, s2, s3, s4 }, new IStrategoTerm[] { t1, t2, t3, t4, t5 });
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, Strategy s3, Strategy s4, Strategy s5) {
+		return invokeDynamic(context, current, new Strategy[] { s1, s2, s3, s4, s5 }, NO_TERMS);
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, S s3, S s4, S s5) {
-		return invokeDynamic(context, current, new IStrategy[] { s1, s2, s3, s4, s5 }, EMPTY_TERM_LIST);
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, Strategy s3, Strategy s4, Strategy s5, IStrategoTerm t1) {
+		return invokeDynamic(context, current, new Strategy[] { s1, s2, s3, s4, s5 }, new IStrategoTerm[] { t1 });
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, S s3, S s4, S s5, T t1) {
-		return invokeDynamic(context, current, new IStrategy[] { s1, s2, s3, s4, s5 }, new IStrategoTerm[] { t1 });
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, Strategy s3, Strategy s4, Strategy s5, IStrategoTerm t1, IStrategoTerm t2) {
+		return invokeDynamic(context, current, new Strategy[] { s1, s2, s3, s4, s5 }, new IStrategoTerm[] { t1, t2 });
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, S s3, S s4, S s5, T t1, T t2) {
-		return invokeDynamic(context, current, new IStrategy[] { s1, s2, s3, s4, s5 }, new IStrategoTerm[] { t1, t2 });
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, Strategy s3, Strategy s4, Strategy s5, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3) {
+		return invokeDynamic(context, current, new Strategy[] { s1, s2, s3, s4, s5 }, new IStrategoTerm[] { t1, t2, t3 });
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, S s3, S s4, S s5, T t1, T t2, T t3) {
-		return invokeDynamic(context, current, new IStrategy[] { s1, s2, s3, s4, s5 }, new IStrategoTerm[] { t1, t2, t3 });
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, Strategy s3, Strategy s4, Strategy s5, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4) {
+		return invokeDynamic(context, current, new Strategy[] { s1, s2, s3, s4, s5 }, new IStrategoTerm[] { t1, t2, t3, t4 });
 	}
 
-	public T invoke(Context context, T current, S s1, S s2, S s3, S s4, S s5, T t1, T t2, T t3, T t4) {
-		return invokeDynamic(context, current, new IStrategy[] { s1, s2, s3, s4, s5 }, new IStrategoTerm[] { t1, t2, t3, t4 });
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, Strategy s3, Strategy s4, Strategy s5, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4, IStrategoTerm t5) {
+		return invokeDynamic(context, current, new Strategy[] { s1, s2, s3, s4, s5 }, new IStrategoTerm[] { t1, t2, t3, t4, t5 });
 	}
-
-	public T invoke(Context context, T current, S s1, S s2, S s3, S s4, S s5, T t1, T t2, T t3, T t4, T t5) {
-		return invokeDynamic(context, current, new IStrategy[] { s1, s2, s3, s4, s5 }, new IStrategoTerm[] { t1, t2, t3, t4, t5 });
-	}
-}
-
-/**
- * Defines the invokeDynamic method with a custom, erased return type,
- * while avoiding the <code>@Override</code> requirement of abstract methods. 
- */
-interface IDynamicStrategyOverload<T extends IStrategoTerm> extends IDynamicStrategy {
-	public T invokeDynamic(Context context, IStrategoTerm current,
-			IStrategy[] sargs, IStrategoTerm[] targs);
 }
\ No newline at end of file

Modified: strc-java/trunk/java/runtime/org/strategoxt/lang/IDynamicStrategy.java
===================================================================
--- strc-java/trunk/java/runtime/org/strategoxt/lang/IDynamicStrategy.java	2009-06-26 08:28:41 UTC (rev 19562)
+++ strc-java/trunk/java/runtime/org/strategoxt/lang/IDynamicStrategy.java	2009-06-26 09:22:32 UTC (rev 19563)
@@ -11,7 +11,7 @@
 	 * 
 	 * @return The resulting term, or null in case of failure.
 	 */
-	IStrategoTerm invokeDynamic(Context context, IStrategoTerm current, IStrategy[] sargs, IStrategoTerm[] targs);
+	IStrategoTerm invokeDynamic(Context context, IStrategoTerm current, Strategy[] sargs, IStrategoTerm[] targs);
 
 	String getName();
 }

Deleted: strc-java/trunk/java/runtime/org/strategoxt/lang/IStrategy.java
===================================================================
--- strc-java/trunk/java/runtime/org/strategoxt/lang/IStrategy.java	2009-06-26 08:28:41 UTC (rev 19562)
+++ strc-java/trunk/java/runtime/org/strategoxt/lang/IStrategy.java	2009-06-26 09:22:32 UTC (rev 19563)
@@ -1,100 +0,0 @@
-package org.strategoxt.lang;
-
-import org.spoofax.interpreter.terms.IStrategoTerm;
-
-
-/**
- * @author Lennart Kats <lennart add lclnet.nl>
- */
-public interface IStrategy extends IDynamicStrategy, IStrategyOverloads<IStrategy, IStrategoTerm> {}
-
-/**
- * Defines different overloads for the invoke() method.
- * 
- * @author Lennart Kats <lennart add lclnet.nl>
- */
-interface IStrategyOverloads<S extends IStrategy, T extends IStrategoTerm> {
-	// 0 strategy arguments
-	
-	T invoke(Context context, T current);
-	
-	T invoke(Context context, T current, T t1);
-
-	T invoke(Context context, T current, T t1, T t2);
-
-	T invoke(Context context, T current, T t1, T t2, T t3);
-
-	T invoke(Context context, T current, T t1, T t2, T t3, T t4);
-
-	T invoke(Context context, T current, T t1, T t2, T t3, T t4, T t5);
-	
-	// 1 strategy argument
-	
-	T invoke(Context context, T current, S s1);
-
-	T invoke(Context context, T current, S s1, T t1);
-
-	T invoke(Context context, T current, S s1, T t1, T t2);
-
-	T invoke(Context context, T current, S s1, T t1, T t2, T t3);
-
-	T invoke(Context context, T current, S s1, T t1, T t2, T t3, T t4);
-
-	T invoke(Context context, T current, S s1, T t1, T t2, T t3, T t4, T t5);
-
-	// 2 strategy arguments
-
-	T invoke(Context context, T current, S s1, S s2);
-
-	T invoke(Context context, T current, S s1, S s2, T t1);
-
-	T invoke(Context context, T current, S s1, S s2, T t1, T t2);
-
-	T invoke(Context context, T current, S s1, S s2, T t1, T t2, T t3);
-
-	T invoke(Context context, T current, S s1, S s2, T t1, T t2, T t3, T t4);
-
-	T invoke(Context context, T current, S s1, S s2, T t1, T t2, T t3, T t4, T t5);
-
-	// 3 strategy arguments
-
-	T invoke(Context context, T current, S s1, S s2, S s3);
-
-	T invoke(Context context, T current, S s1, S s2, S s3, T t1);
-
-	T invoke(Context context, T current, S s1, S s2, S s3, T t1, T t2);
-
-	T invoke(Context context, T current, S s1, S s2, S s3, T t1, T t2, T t3);
-
-	T invoke(Context context, T current, S s1, S s2, S s3, T t1, T t2, T t3, T t4);
-
-	T invoke(Context context, T current, S s1, S s2, S s3, T t1, T t2, T t3, T t4, T t5);
-
-	// 4 strategy arguments
-
-	T invoke(Context context, T current, S s1, S s2, S s3, S s4);
-
-	T invoke(Context context, T current, S s1, S s2, S s3, S s4, T t1);
-
-	T invoke(Context context, T current, S s1, S s2, S s3, S s4, T t1, T t2);
-
-	T invoke(Context context, T current, S s1, S s2, S s3, S s4, T t1, T t2, T t3);
-
-	T invoke(Context context, T current, S s1, S s2, S s3, S s4, T t1, T t2, T t3, T t4);
-
-	T invoke(Context context, T current, S s1, S s2, S s3, S s4, T t1, T t2, T t3, T t4, T t5);
-
-	// 5 strategy arguments
-
-	T invoke(Context context, T current, S s1, S s2, S s3, S s4, S s5);
-
-	T invoke(Context context, T current, S s1, S s2, S s3, S s4, S s5, T t1);
-
-	T invoke(Context context, T current, S s1, S s2, S s3, S s4, S s5, T t1, T t2);
-
-	T invoke(Context context, T current, S s1, S s2, S s3, S s4, S s5, T t1, T t2, T t3);
-
-	T invoke(Context context, T current, S s1, S s2, S s3, S s4, S s5, T t1, T t2, T t3, T t4);
-
-	T invoke(Context context, T current, S s1, S s2, S s3, S s4, S s5, T t1, T t2, T t3, T t4, T t5);
-}

Modified: strc-java/trunk/java/runtime/org/strategoxt/lang/InteropSDefT.java
===================================================================
--- strc-java/trunk/java/runtime/org/strategoxt/lang/InteropSDefT.java	2009-06-26 08:28:41 UTC (rev 19562)
+++ strc-java/trunk/java/runtime/org/strategoxt/lang/InteropSDefT.java	2009-06-26 09:22:32 UTC (rev 19563)
@@ -9,12 +9,12 @@
 import org.spoofax.interpreter.terms.IStrategoTerm;
 
 /**
- * Adapts an {@link SDefT} definition to an {@link IStrategy},
+ * Adapts an {@link SDefT} definition to a {@link Strategy},
  * making interpreter strategy arguments accessible to the compiled strategies.
  * 
  * @author Lennart Kats <lennart add lclnet.nl>
  */
-public class InteropSDefT extends DynamicStrategy implements IStrategy {
+public class InteropSDefT extends DynamicStrategy {
 	
 	private final SDefT definition;
 	
@@ -25,8 +25,8 @@
 		this.context = context;
 	}
 	
-	public static IStrategy[] toInteropSDefTs(SDefT[] definitions, IContext context) {
-		IStrategy[] results = new IStrategy[definitions.length];
+	public static Strategy[] toInteropSDefTs(SDefT[] definitions, IContext context) {
+		Strategy[] results = new Strategy[definitions.length];
 		for (int i = 0; i < definitions.length; i++) {
 			SDefT definition = definitions[i];
 			if (definition instanceof InteropStrategyDef) {
@@ -38,7 +38,8 @@
 		return results;
 	}
 	
-	public IStrategoTerm invokeDynamic(Context compilerContext, IStrategoTerm current, IStrategy[] sargs, IStrategoTerm[] targs) {
+	@Override
+	public IStrategoTerm invokeDynamic(Context compilerContext, IStrategoTerm current, Strategy[] sargs, IStrategoTerm[] targs) {
 		VarScope oldScope = context.getVarScope();
 		try {
 			if (sargs.length != 0 || targs.length != 0) {
@@ -57,7 +58,7 @@
 		}
 	}
 
-	private void assignParameters(Context compiledContext, VarScope scope, IStrategy[] sargs, IStrategoTerm[] targs)
+	private void assignParameters(Context compiledContext, VarScope scope, Strategy[] sargs, IStrategoTerm[] targs)
 			throws InterpreterException {
 		
 		SDefT.SVar[] sparams = definition.getStrategyParams();

Modified: strc-java/trunk/java/runtime/org/strategoxt/lang/InteropStrategy.java
===================================================================
--- strc-java/trunk/java/runtime/org/strategoxt/lang/InteropStrategy.java	2009-06-26 08:28:41 UTC (rev 19562)
+++ strc-java/trunk/java/runtime/org/strategoxt/lang/InteropStrategy.java	2009-06-26 09:22:32 UTC (rev 19563)
@@ -5,11 +5,11 @@
 import org.spoofax.interpreter.core.IContext;
 import org.spoofax.interpreter.core.InterpreterException;
 import org.spoofax.interpreter.stratego.CallT;
-import org.spoofax.interpreter.stratego.Strategy;
 import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.strategoxt.lang.Strategy;
 
 /**
- * Adapts an {@link IStrategy} strategy to a {@link CallT},
+ * Adapts an {@link Strategy} strategy to a {@link CallT},
  * making interpreter strategies and primitives with strategy arguments
  * accessible for compiled strategies.
  * 
@@ -19,9 +19,9 @@
 	
 	private static final CallT[] NO_CALLTS = {};
 	
-	private static final IStrategy[] NO_ISTRATEGIES = {};
+	private static final Strategy[] NO_ISTRATEGIES = {};
 	
-	private final IStrategy strategy;
+	private final Strategy strategy;
 	
 	private final Context context;
 	
@@ -30,7 +30,7 @@
 	 * 
 	 * @param strategy	The strategy to adapt.
 	 */
-	public InteropStrategy(IStrategy strategy) {
+	public InteropStrategy(Strategy strategy) {
 		this(strategy, null);
 	}
 	
@@ -40,14 +40,14 @@
 	 * @param strategy	The strategy to adapt.
 	 * @param context	The compiled context, if used with an interpreter context.
 	 */
-	public InteropStrategy(IStrategy strategy, Context context) {
+	public InteropStrategy(Strategy strategy, Context context) {
 		super(strategy.getName(), null, null);
 		
 		this.strategy = strategy;
 		this.context = context;
 	}
     
-	public static CallT[] toInteropStrategies(IStrategy[] strategies) {
+	public static CallT[] toInteropStrategies(Strategy[] strategies) {
     	if (strategies.length == 0) return NO_CALLTS;
     	
     	CallT[] results = new CallT[strategies.length];
@@ -56,13 +56,13 @@
     	return results;
     }
     
-	public static IStrategy[] fromInteropStrategies(Strategy[] strategies) {
+	public static Strategy[] fromInteropStrategies(org.spoofax.interpreter.stratego.Strategy[] strategies) {
 		if (strategies.length == 0)
 			return NO_ISTRATEGIES;
 
-		IStrategy[] results = new IStrategy[strategies.length];
+		Strategy[] results = new Strategy[strategies.length];
 		for (int i = 0; i < strategies.length; i++) {
-			Strategy strategy = strategies[i];
+			org.spoofax.interpreter.stratego.Strategy strategy = strategies[i];
 			if (!(strategy instanceof InteropStrategy))
 				throw new StrategoException("Expected InteropStrategy");
 			results[i] = ((InteropStrategy) strategy).strategy;
@@ -102,7 +102,7 @@
 	}
 	
 	@Override
-	public boolean evaluateWithArgs(IContext env, Strategy[] sv, IStrategoTerm[] tv) {
+	public boolean evaluateWithArgs(IContext env, org.spoofax.interpreter.stratego.Strategy[] sv, IStrategoTerm[] tv) {
 		IStrategoTerm result = strategy.invokeDynamic(
 				getCompiledContext(env),env.current(), fromInteropStrategies(sv), tv);
 		if (result == null) return false;
@@ -111,7 +111,7 @@
 	}
 	
 	@Override
-	public Strategy evalWithArgs(IContext env, Strategy[] sv,
+	public org.spoofax.interpreter.stratego.Strategy evalWithArgs(IContext env, org.spoofax.interpreter.stratego.Strategy[] sv,
 			IStrategoTerm[] actualTVars) throws InterpreterException {
 		throw new NotImplementedException();
 	}

Modified: strc-java/trunk/java/runtime/org/strategoxt/lang/InteropStrategyDef.java
===================================================================
--- strc-java/trunk/java/runtime/org/strategoxt/lang/InteropStrategyDef.java	2009-06-26 08:28:41 UTC (rev 19562)
+++ strc-java/trunk/java/runtime/org/strategoxt/lang/InteropStrategyDef.java	2009-06-26 09:22:32 UTC (rev 19563)
@@ -9,7 +9,7 @@
 import org.spoofax.interpreter.terms.IStrategoTerm;
 
 /**
- * Adapts an {@link IStrategy} strategy to a {@link SDefT},
+ * Adapts an {@link Strategy} strategy to a {@link SDefT},
  * making compiled strategies accessible to the interpreter.
  * 
  * @author Lennart Kats <lennart add lclnet.nl>
@@ -26,28 +26,28 @@
 	
 	private final IContext context;
 	
-	private final Class<? extends IStrategy> strategyClass;
+	private final Class<? extends Strategy> strategyClass;
 	
-	private IStrategy strategy;
+	private Strategy strategy;
 
-	// TODO: Optimize - take a Class<IStrategy> or String argument for lazy loading
-	public InteropStrategyDef(Class<? extends IStrategy> strategyClass, IContext context, Context compiledContext) {
+	// TODO: Optimize - take a Class<Strategy> or String argument for lazy loading
+	public InteropStrategyDef(Class<? extends Strategy> strategyClass, IContext context, Context compiledContext) {
 		this.strategyClass = strategyClass;
 		this.compiledContext = compiledContext;
 		this.context = context;
 	}
 
-	public InteropStrategyDef(IStrategy strategy, IContext context, Context compiledContext) {
+	public InteropStrategyDef(Strategy strategy, IContext context, Context compiledContext) {
 		this.strategyClass = null;
 		this.compiledContext = compiledContext;
 		this.context = context;
 		this.strategy = strategy;
 	}
 
-	public static SDefT[] toInteropStrategyDefs(IStrategy[] strategies, IContext context, Context compiledContext) {
+	public static SDefT[] toInteropStrategyDefs(Strategy[] strategies, IContext context, Context compiledContext) {
 		SDefT[] results = new SDefT[strategies.length];
 		for (int i = 0; i < strategies.length; i++) {
-			IStrategy strategy = strategies[i];
+			Strategy strategy = strategies[i];
 			if (strategy instanceof InteropSDefT) {
 				results[i] = ((InteropSDefT) strategy).getDefinition();
 			} else {
@@ -151,7 +151,7 @@
 			targs[i] = targ;
 		}
 		
-		IStrategy[] sdefargs = InteropSDefT.toInteropSDefTs(sargs, env);
+		Strategy[] sdefargs = InteropSDefT.toInteropSDefTs(sargs, env);
 		IStrategoTerm result = getStrategy().invokeDynamic(compiledContext, env.current(), sdefargs, targs);
 		
 		if (result != null) {
@@ -162,11 +162,11 @@
 		}
 	}
 	
-	public IStrategy getStrategy() {
+	public Strategy getStrategy() {
 		if (strategy == null) {
 			try {
 				// TODO: is this a good performance trade off??
-				strategy = (IStrategy) strategyClass.getField("instance").get(null);
+				strategy = (Strategy) strategyClass.getField("instance").get(null);
 			} catch (IllegalAccessException e) {
 				throw new StrategoException("Unable to instantiate compiled strategy", e);
 			} catch (IllegalArgumentException e) {

Modified: strc-java/trunk/java/runtime/org/strategoxt/lang/SRTS_EXT_crush_3_0.java
===================================================================
--- strc-java/trunk/java/runtime/org/strategoxt/lang/SRTS_EXT_crush_3_0.java	2009-06-26 08:28:41 UTC (rev 19562)
+++ strc-java/trunk/java/runtime/org/strategoxt/lang/SRTS_EXT_crush_3_0.java	2009-06-26 09:22:32 UTC (rev 19563)
@@ -12,14 +12,14 @@
 
 	@Override
 	public IStrategoTerm invoke(Context context, IStrategoTerm current,
-			IStrategy nul, IStrategy sum, IStrategy s) {
+			Strategy nul, Strategy sum, Strategy s) {
 		
 		// TODO: Is getAllSubterms() a good idea for crush/foldr of lists? 
 		
 		ITermFactory factory = context.getFactory();
 		IStrategoTerm[] subterms = current.getAllSubterms();
 		
-		IStrategoTerm result = factory.makeList(Term.EMPTY_TERM_LIST);
+		IStrategoTerm result = factory.makeList(Term.NO_TERMS);
 		result = nul.invoke(context, result);
 		if (result == null) return null;
 		

Modified: strc-java/trunk/java/runtime/org/strategoxt/lang/SRTS_EXT_filter_1_0.java
===================================================================
--- strc-java/trunk/java/runtime/org/strategoxt/lang/SRTS_EXT_filter_1_0.java	2009-06-26 08:28:41 UTC (rev 19562)
+++ strc-java/trunk/java/runtime/org/strategoxt/lang/SRTS_EXT_filter_1_0.java	2009-06-26 09:22:32 UTC (rev 19563)
@@ -16,7 +16,7 @@
 	private static final int LARGE_LIST_SIZE = 10;
 	
 	@Override
-	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s) {
 		if (current.getTermType() != IStrategoTerm.LIST)
 			return null;
 		
@@ -39,7 +39,7 @@
 
 	private IStrategoTerm filterMaintainTailAnnos(Context context, 
 			IStrategoTerm[] prefix, IStrategoList tail, int tailStart,
-			IStrategy s) {
+			Strategy s) {
 		// Filter prefix, disregarding annotations
 		for (int j = 0; j < tailStart; j++) {
 			prefix[j] = s.invoke(context, prefix[j]);
@@ -57,7 +57,7 @@
 		return result;
 	}
 
-	private IStrategoList filterMaintainAnnos(Context context, IStrategoList list, IStrategy s) {
+	private IStrategoList filterMaintainAnnos(Context context, IStrategoList list, Strategy s) {
 		if (list.isEmpty())
 			return list;
 		
@@ -78,12 +78,12 @@
 		}
 	}
 	
-	private IStrategoList filterIgnoreAnnos(Context context, IStrategoTerm[] list, IStrategy s) {
+	private IStrategoList filterIgnoreAnnos(Context context, IStrategoTerm[] list, Strategy s) {
 		for (int i = 0; i < list.length; i++) {
 			list[i] = s.invoke(context, list[i]);
 		}
 		
-		IStrategoList result = context.getFactory().makeList(Term.EMPTY_TERM_LIST);
+		IStrategoList result = context.getFactory().makeList(Term.NO_TERMS);
 		for (int i = list.length - 1; i >= 0; i--) {
 			IStrategoTerm head = list[i];
 			if (head != null)

Modified: strc-java/trunk/java/runtime/org/strategoxt/lang/SRTS_all.java
===================================================================
--- strc-java/trunk/java/runtime/org/strategoxt/lang/SRTS_all.java	2009-06-26 08:28:41 UTC (rev 19562)
+++ strc-java/trunk/java/runtime/org/strategoxt/lang/SRTS_all.java	2009-06-26 09:22:32 UTC (rev 19563)
@@ -14,7 +14,7 @@
 	public static SRTS_all instance = new SRTS_all();
 
 	@Override
-	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s) {
 		int termType = current.getTermType();
 		
 		if (termType == LIST) {
@@ -52,7 +52,7 @@
 		}
 	}
 
-	private static IStrategoTerm map(Context context, IStrategoList list, IStrategy s) {
+	private static IStrategoTerm map(Context context, IStrategoList list, Strategy s) {
 		if (list.getSubtermCount() == 0)
 			return list;
 
@@ -76,7 +76,7 @@
 		}
 	}
 
-	private static IStrategoList mapIgnoreAnnos(Context context, IStrategoTerm head2, IStrategoList list, IStrategy s) {
+	private static IStrategoList mapIgnoreAnnos(Context context, IStrategoTerm head2, IStrategoList list, Strategy s) {
 		IStrategoTerm[] items = list.getAllSubterms();
 		items[0] = head2;
 		assert list.head() != null : "List implementation must not expose internal array";
@@ -92,7 +92,7 @@
 		return context.getFactory().replaceList(items, list);
 	}
 
-	private static IStrategoList mapMaintainAnnos(Context context, IStrategoList list, IStrategy s) {
+	private static IStrategoList mapMaintainAnnos(Context context, IStrategoList list, Strategy s) {
 		if (list.isEmpty())
 			return list;
 		

Modified: strc-java/trunk/java/runtime/org/strategoxt/lang/SRTS_one.java
===================================================================
--- strc-java/trunk/java/runtime/org/strategoxt/lang/SRTS_one.java	2009-06-26 08:28:41 UTC (rev 19562)
+++ strc-java/trunk/java/runtime/org/strategoxt/lang/SRTS_one.java	2009-06-26 09:22:32 UTC (rev 19563)
@@ -14,7 +14,7 @@
 	public static SRTS_one instance = new SRTS_one();
 
 	@Override
-	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s) {
 		int termType = current.getTermType();
 		
 		if (termType == LIST)
@@ -49,7 +49,7 @@
 		}
 	}
 	
-	private static IStrategoList fetchMaintainAnnos(Context context, IStrategoList current, IStrategy s) {
+	private static IStrategoList fetchMaintainAnnos(Context context, IStrategoList current, Strategy s) {
 		if (current.isEmpty()) {
 			return null;
 		} else {

Modified: strc-java/trunk/java/runtime/org/strategoxt/lang/SRTS_some.java
===================================================================
--- strc-java/trunk/java/runtime/org/strategoxt/lang/SRTS_some.java	2009-06-26 08:28:41 UTC (rev 19562)
+++ strc-java/trunk/java/runtime/org/strategoxt/lang/SRTS_some.java	2009-06-26 09:22:32 UTC (rev 19563)
@@ -14,7 +14,7 @@
 	public static SRTS_some instance = new SRTS_some();
 
 	@Override
-	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s) {
 		int termType = current.getTermType();
 		
 		if (termType == LIST)
@@ -50,7 +50,7 @@
 		}
 	}
 	
-	private static IStrategoList map1MaintainAnnos(Context context, IStrategoList list, IStrategy s, boolean foundSome) {
+	private static IStrategoList map1MaintainAnnos(Context context, IStrategoList list, Strategy s, boolean foundSome) {
 		if (list.isEmpty()) {
 			return foundSome ? list : null;
 		} else {
@@ -84,7 +84,7 @@
 		}
 	}
 
-	private static IStrategoList mapTryIgnoreAnnos(Context context, IStrategoTerm head2, IStrategoList list, IStrategy s) {
+	private static IStrategoList mapTryIgnoreAnnos(Context context, IStrategoTerm head2, IStrategoList list, Strategy s) {
 		IStrategoTerm[] items = list.getAllSubterms();
 		items[0] = head2;
 		assert list.head() != head2;

Modified: strc-java/trunk/java/runtime/org/strategoxt/lang/Strategy.java
===================================================================
--- strc-java/trunk/java/runtime/org/strategoxt/lang/Strategy.java	2009-06-26 08:28:41 UTC (rev 19562)
+++ strc-java/trunk/java/runtime/org/strategoxt/lang/Strategy.java	2009-06-26 09:22:32 UTC (rev 19563)
@@ -11,7 +11,7 @@
  * 
  * @author Lennart Kats <lennart add lclnet.nl>
  */
-public class Strategy implements IStrategy {
+public class Strategy {
 	/**
 	 * Invoke this strategy using a dynamic number of arguments.
 	 * 
@@ -22,7 +22,7 @@
 	 * @return The resulting term, or null in case of failure.
 	 */
 	public IStrategoTerm invokeDynamic(Context context, IStrategoTerm current,
-			IStrategy[] s, IStrategoTerm[] t) {
+			Strategy[] s, IStrategoTerm[] t) {
 
 		switch (s.length) {
 			case 0:
@@ -102,123 +102,123 @@
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategoTerm t1) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, IStrategoTerm t1) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategoTerm t1, IStrategoTerm t2) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, IStrategoTerm t1, IStrategoTerm t2) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4, IStrategoTerm t5) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4, IStrategoTerm t5) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategoTerm t1) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, IStrategoTerm t1) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategoTerm t1, IStrategoTerm t2) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, IStrategoTerm t1, IStrategoTerm t2) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4, IStrategoTerm t5) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4, IStrategoTerm t5) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategy s3) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, Strategy s3) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategy s3, IStrategoTerm t1) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, Strategy s3, IStrategoTerm t1) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategy s3, IStrategoTerm t1, IStrategoTerm t2) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, Strategy s3, IStrategoTerm t1, IStrategoTerm t2) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategy s3, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, Strategy s3, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategy s3, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, Strategy s3, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategy s3, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4, IStrategoTerm t5) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, Strategy s3, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4, IStrategoTerm t5) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategy s3, IStrategy s4) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, Strategy s3, Strategy s4) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategy s3, IStrategy s4, IStrategoTerm t1) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, Strategy s3, Strategy s4, IStrategoTerm t1) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategy s3, IStrategy s4, IStrategoTerm t1, IStrategoTerm t2) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, Strategy s3, Strategy s4, IStrategoTerm t1, IStrategoTerm t2) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategy s3, IStrategy s4, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, Strategy s3, Strategy s4, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategy s3, IStrategy s4, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, Strategy s3, Strategy s4, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategy s3, IStrategy s4, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4, IStrategoTerm t5) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, Strategy s3, Strategy s4, IStrategoTerm t1, IStrategoTerm t2, IStrategoTerm t3, IStrategoTerm t4, IStrategoTerm t5) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategy s3, IStrategy s4, IStrategy s5) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, Strategy s3, Strategy s4, Strategy s5) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategy s3, IStrategy s4, IStrategy s5, IStrategoTerm t1) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, Strategy s3, Strategy s4, Strategy s5, IStrategoTerm t1) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());
 	}
 
-	public IStrategoTerm invoke(Context context, IStrategoTerm current, IStrategy s1, IStrategy s2, IStrategy s3, IStrategy s4, IStrategy s5, IStrategoTerm t1, IStrategoTerm t2) {
+	public IStrategoTerm invoke(Context context, IStrategoTerm current, Strategy s1, Strategy s2, Strategy s3, Strategy s4, Strategy s5, IStrategoTerm t1, IStrategoTerm t2) {
 		throw new IllegalArgumentException("Illegal arguments for " + getName());

(295 diff lines omitted)


From L.C.L.Kats at tudelft.nl  Fri Jun 26 11:58:09 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Fri, 26 Jun 2009 09:58:09 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19564 - LennartKats -
	in sglr-recovery/trunk/bridge-definitions: . grammars/java
Message-ID: <200906260956.n5Q9ukJv005090@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-06-26 09:58:09 +0000 (Fri, 26 Jun 2009)
New Revision: 19564

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19564&view=rev

Added:
   sglr-recovery/trunk/bridge-definitions/Makefile
   sglr-recovery/trunk/bridge-definitions/syntax/
Removed:
   sglr-recovery/trunk/bridge-definitions/grammars/java/Java-15.br

Log:
First attempt to make a bridge definition SDF grammar.

Changes:

Added: sglr-recovery/trunk/bridge-definitions/Makefile
===================================================================
--- sglr-recovery/trunk/bridge-definitions/Makefile	                        (rev 0)
+++ sglr-recovery/trunk/bridge-definitions/Makefile	2009-06-26 09:58:09 UTC (rev 19564)
@@ -0,0 +1,21 @@
+all : trans/make-bridge
+
+# General rules
+
+%.tbl : %.def
+	sdf2table -i $< -o $@ -m `basename $< .def`
+
+%.tbl : %.gendef
+	sdf2table -i $< -o $@ -m `basename $< .gendef`
+
+%.def : %.sdf
+	pack-sdf -i $< -o $@ \
+	         -I $(HOME)/.nix-profile/share/java-front-syntax
+
+%.coretbl : %.def
+	sdf2table -i $< -o $@ -m `basename $< .def` -n
+
+%.coredef : %.coretbl
+	implodePT -i $< | pp-sdf -o $@
+
+

Deleted: sglr-recovery/trunk/bridge-definitions/grammars/java/Java-15.br
===================================================================
--- sglr-recovery/trunk/bridge-definitions/grammars/java/Java-15.br	2009-06-26 09:22:32 UTC (rev 19563)
+++ sglr-recovery/trunk/bridge-definitions/grammars/java/Java-15.br	2009-06-26 09:58:09 UTC (rev 19564)
@@ -1,264 +0,0 @@
-module Java-15
-
-islands // Brackets
-
-  // All tokens have a unique identifier for generality here
-  // I'm not sure if we should assume otherwise
-  //
-  // (Some new production could come along that might
-  //  match a "{" with a "end" or something.)
-
-  LBrace1 = ConstrBody("{")
-  LBrace2 = SwitchBlock("{")
-  LBrace3 = AnnoDec("{")
-  LBrace4 = ClassBody("{")
-  LBrace5 = ElemValArrayInit("{")
-  LBrace6 = InterfaceDec("{")
-  LBrace7 = Block("{")
-  LBrace8 = EnumBody("{")
-  LBrace9 = ArrayInit("{")
-
-  RBrace1 = ConstrBody("}")
-  RBrace2 = SwitchBlock("}")
-  RBrace3 = AnnoDec("}")
-  RBrace4 = ClassBody("}")
-  RBrace5 = ElemValArrayInit("}")
-  RBrace6 = InterfaceDec("}")
-  RBrace7 = Block("}")
-  RBrace8 = EnumBody("}")
-  RBrace9 = ArrayInit("}")
-
-islands // Parentheses
-
-  LParen1 = QSuperConstrInv("(")
-  LParen2 = SuperConstrInv("(")
-  LParen3 = Catch("(")
-  LParen4 = ForEach("(")
-  LParen5 = DoWhile("(")
-  LParen6 = Switch("(")
-  LParen7 = DeprAbstractMethodDec("(")
-  LParen8 = AnnoMethodDec("(")
-  LParen9 = MethodDecHead("(")
-  LParen10 = Anno("(")
-  LParen11 = QNewInstance("(")
-  LParen12 = Invoke("(")
-  LParen13 = CastRef("(")
-  LParen14 = CastPrim("(")
-  LParen15 = NewInstance("(")
-  LParen16 = SingleElemAnno("(")
-  LParen17 = DeprMethodDecHead("(")
-  LParen18 = AbstractMethodDec("(")
-  LParen19 = If("(")
-  LParen20 = While("(")
-  LParen21 = For("(")
-  LParen22 = Synchronized("(")
-  LParen23 = AltConstrInv("(")
-  LParen24 = ConstrDecHead("(")
-
-  RParen1 = QSuperConstrInv(")")
-  RParen2 = SuperConstrInv(")")
-  RParen3 = Catch(")")
-  RParen4 = ForEach(")")
-  RParen5 = DoWhile(")")
-  RParen6 = Switch(")")
-  RParen7 = DeprAbstractMethodDec(")")
-  RParen8 = AnnoMethodDec(")")
-  RParen9 = MethodDecHead(")")
-  RParen10 = Anno(")")
-  RParen11 = QNewInstance(")")
-  RParen12 = Invoke(")")
-  RParen13 = CastRef(")")
-  RParen14 = CastPrim(")")
-  RParen15 = NewInstance(")")
-  RParen17 = SingleElemAnno(")")
-  RParen19 = DeprMethodDecHead(")")
-  RParen20 = AbstractMethodDec(")")
-  RParen21 = If(")")
-  RParen22 = While(")")
-  RParen23 = For(")")
-  RParen24 = Synchronized(")")
-  RParen25 = AltConstrInv(")")
-  RParen26 = ConstrDecHead(")")
-
-reefs // Layout and keywords
-  
-  Layout  = LAYOUT(_) // note the wild card
-
-  Keyword = If("if")
-  Keyword = While("while")
-  Keyword = For("for")
-  
-  // ...keywords...
-
-bridges // Automatically included from the general implementation
-  //
-  // attr int Layout.pos = ...
-  // attr Layout Island.indent = first left Layout
-
-bridges // Brackets
-
-  // for I in {1..9}; do echo ...; done
-
-  bridge LBrace1 to RBrace1
-    when LBrace1.indent.pos == RBrace1.indent.pos
-
-  bridge LBrace2 to RBrace2
-    when LBrace2.indent.pos == RBrace2.indent.pos
-
-  bridge LBrace3 to RBrace3
-    when LBrace3.indent.pos == RBrace3.indent.pos
-
-  bridge LBrace4 to RBrace4
-    when LBrace4.indent.pos == RBrace4.indent.pos
-
-  bridge LBrace5 to RBrace5
-    when LBrace5.indent.pos == RBrace5.indent.pos
-
-  bridge LBrace6 to RBrace6
-    when LBrace6.indent.pos == RBrace6.indent.pos
-
-  bridge LBrace7 to RBrace7
-    when LBrace7.indent.pos == RBrace7.indent.pos
-
-  bridge LBrace8 to RBrace8
-    when LBrace8.indent.pos == RBrace8.indent.pos
-
-  bridge LBrace9 to RBrace9
-    when LBrace9.indent.pos == RBrace9.indent.pos
-
-bridges // Brackets: insertion of "{"
-
-  // (hope I got these right)
-   
-  recover LBrace1
-    find Layout
-    where #1.indent.pos >= RBrace1.indent.pos
-    insert after #1
-    
-  recover LBrace2
-    find Layout
-    where #1.indent.pos >= RBrace2.indent.pos
-    insert after #1
-    
-  recover LBrace3
-    find Layout
-    where #1.indent.pos >= RBrace3.indent.pos
-    insert after #1
-    
-  recover LBrace4
-    find Layout
-    where #1.indent.pos >= RBrace4.indent.pos
-    insert after #1
-    
-  recover LBrace5
-    find Layout
-    where #1.indent.pos >= RBrace5.indent.pos
-    insert after #1
-    
-  recover LBrace6
-    find Layout
-    where #1.indent.pos >= RBrace6.indent.pos
-    insert after #1
-    
-  recover LBrace7
-    find Layout
-    where #1.indent.pos >= RBrace7.indent.pos
-    insert after #1
-    
-  recover LBrace8
-    find Layout
-    where #1.indent.pos >= RBrace8.indent.pos
-    insert after #1
-    
-  recover LBrace9
-    find Layout
-    where #1.indent.pos >= RBrace9.indent.pos
-    insert after #1
-
-bridges // Insertion of "}"
-
-  // ...
-
-bridges // Parentheses
-    
-  bridge LParen1 to RParen1
-    when LParen1.indent.pos == RParen1.indent.pos
-    
-  bridge LParen2 to RParen2
-    when LParen2.indent.pos == RParen2.indent.pos
-    
-  bridge LParen3 to RParen3
-    when LParen3.indent.pos == RParen3.indent.pos
-    
-  bridge LParen4 to RParen4
-    when LParen4.indent.pos == RParen4.indent.pos
-    
-  bridge LParen5 to RParen5
-    when LParen5.indent.pos == RParen5.indent.pos
-    
-  bridge LParen6 to RParen6
-    when LParen6.indent.pos == RParen6.indent.pos
-    
-  bridge LParen7 to RParen7
-    when LParen7.indent.pos == RParen7.indent.pos
-    
-  bridge LParen8 to RParen8
-    when LParen8.indent.pos == RParen8.indent.pos
-    
-  bridge LParen9 to RParen9
-    when LParen9.indent.pos == RParen9.indent.pos
-    
-  bridge LParen10 to RParen10
-    when LParen10.indent.pos == RParen10.indent.pos
-    
-  bridge LParen11 to RParen11
-    when LParen11.indent.pos == RParen11.indent.pos
-    
-  bridge LParen12 to RParen12
-    when LParen12.indent.pos == RParen12.indent.pos
-    
-  bridge LParen13 to RParen13
-    when LParen13.indent.pos == RParen13.indent.pos
-    
-  bridge LParen14 to RParen14
-    when LParen14.indent.pos == RParen14.indent.pos
-    
-  bridge LParen15 to RParen15
-    when LParen15.indent.pos == RParen15.indent.pos
-    
-  bridge LParen16 to RParen16
-    when LParen16.indent.pos == RParen16.indent.pos
-    
-  bridge LParen17 to RParen17
-    when LParen17.indent.pos == RParen17.indent.pos
-    
-  bridge LParen18 to RParen18
-    when LParen18.indent.pos == RParen18.indent.pos
-    
-  bridge LParen19 to RParen19
-    when LParen19.indent.pos == RParen19.indent.pos
-    
-  bridge LParen20 to RParen20
-    when LParen20.indent.pos == RParen20.indent.pos
-    
-  bridge LParen21 to RParen21
-    when LParen21.indent.pos == RParen21.indent.pos
-    
-  bridge LParen22 to RParen22
-    when LParen22.indent.pos == RParen22.indent.pos
-    
-  bridge LParen23 to RParen23
-    when LParen23.indent.pos == RParen23.indent.pos
-    
-  bridge LParen24 to RParen24
-    when LParen24.indent.pos == RParen24.indent.pos
-    
-  bridge LParen25 to RParen25
-    when LParen25.indent.pos == RParen25.indent.pos
-    
-  bridge LParen26 to RParen26
-    when LParen26.indent.pos == RParen26.indent.pos
-
-bridges // Insertion of "(" and ")"
-
-  // ...
\ No newline at end of file



From L.C.L.Kats at tudelft.nl  Fri Jun 26 11:58:19 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Fri, 26 Jun 2009 09:58:19 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19565 - LennartKats -
	sglr-recovery/trunk/bridge-definitions/syntax
Message-ID: <200906260956.n5Q9uu5i005149@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-06-26 09:58:19 +0000 (Fri, 26 Jun 2009)
New Revision: 19565

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19565&view=rev

Added:
   sglr-recovery/trunk/bridge-definitions/syntax/BridgeDefinition.sdf

Log:
First attempt to make a bridge definition SDF grammar.

Changes:

Added: sglr-recovery/trunk/bridge-definitions/syntax/BridgeDefinition.sdf
===================================================================
--- sglr-recovery/trunk/bridge-definitions/syntax/BridgeDefinition.sdf	                        (rev 0)
+++ sglr-recovery/trunk/bridge-definitions/syntax/BridgeDefinition.sdf	2009-06-26 09:58:19 UTC (rev 19565)
@@ -0,0 +1,33 @@
+module BridgeDefinition
+
+imports
+  Common
+
+hiddens
+  context-free start-symbols
+    Definition
+
+exports
+
+  context-free syntax
+  
+    "grammar" ID ";" Import* Rule* -> Definition {cons("Definition")}
+
+    "import" ID ";" -> Import {cons("Import")}
+
+    "island" ID ":" ID "=" String "for-sglr" AltPattern ";" -> Rule {cons("Island")}
+    "reef"   ID ":" ID "=" String "=" Pattern "for-sglr" AltPattern ";" -> Rule {cons("Reef")}
+    "ignore" Pattern "to" Pattern ";" -> Rule {cons("Ignore")}
+    "bridge" "from" ID "to" ID ";" -> Rule {cons("Bridge")}
+  
+  context-free syntax
+  
+    "WS"                   -> Pattern {cons("WS")}
+    "NEWLINE"              -> Pattern {cons("NEWLINE")}
+    "TAB"                  -> Pattern {cons("TAB")}
+    String                 -> Pattern {cons("String")}
+    AltPattern "+"         -> Pattern {cons("Plus")}
+    AltPattern "*"         -> Pattern {cons("Star")}
+    AltPattern "?"         -> Pattern {cons("Opt")}
+    "(" {Pattern "|"}+ ")" -> AltPattern {cons("Alt")}
+



From L.C.L.Kats at tudelft.nl  Fri Jun 26 13:12:46 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Fri, 26 Jun 2009 11:12:46 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19566 - LennartKats -
	in sglr-recovery/trunk/bridge-definitions: . syntax
Message-ID: <200906261111.n5QBBOR8006267@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-06-26 11:12:46 +0000 (Fri, 26 Jun 2009)
New Revision: 19566

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19566&view=rev

Added:
   sglr-recovery/trunk/bridge-definitions/syntax/Common.sdf
Modified:
   sglr-recovery/trunk/bridge-definitions/Makefile
   sglr-recovery/trunk/bridge-definitions/syntax/BridgeDefinition.sdf

Log:
Grammar fixes.

Changes:

Modified: sglr-recovery/trunk/bridge-definitions/Makefile
===================================================================
--- sglr-recovery/trunk/bridge-definitions/Makefile	2009-06-26 09:58:19 UTC (rev 19565)
+++ sglr-recovery/trunk/bridge-definitions/Makefile	2009-06-26 11:12:46 UTC (rev 19566)
@@ -1,5 +1,7 @@
-all : trans/make-bridge
+all : syntax/BridgeDefinition.tbl trans/make-bridge
 
+syntax/BridgeDefinition.def : $(wildcard syntax/*.sdf)
+
 # General rules
 
 %.tbl : %.def

Modified: sglr-recovery/trunk/bridge-definitions/syntax/BridgeDefinition.sdf
===================================================================
--- sglr-recovery/trunk/bridge-definitions/syntax/BridgeDefinition.sdf	2009-06-26 09:58:19 UTC (rev 19565)
+++ sglr-recovery/trunk/bridge-definitions/syntax/BridgeDefinition.sdf	2009-06-26 11:12:46 UTC (rev 19566)
@@ -15,8 +15,8 @@
 
     "import" ID ";" -> Import {cons("Import")}
 
-    "island" ID ":" ID "=" String "for-sglr" AltPattern ";" -> Rule {cons("Island")}
-    "reef"   ID ":" ID "=" String "=" Pattern "for-sglr" AltPattern ";" -> Rule {cons("Reef")}
+    "island" ID ":" ID "=" String  "for-sglr" AltPattern ";" -> Rule {cons("Island")}
+    "reef"   ID ":" ID "=" Pattern "for-sglr" AltPattern ";" -> Rule {cons("Reef")}
     "ignore" Pattern "to" Pattern ";" -> Rule {cons("Ignore")}
     "bridge" "from" ID "to" ID ";" -> Rule {cons("Bridge")}
   

Added: sglr-recovery/trunk/bridge-definitions/syntax/Common.sdf
===================================================================
--- sglr-recovery/trunk/bridge-definitions/syntax/Common.sdf	                        (rev 0)
+++ sglr-recovery/trunk/bridge-definitions/syntax/Common.sdf	2009-06-26 11:12:46 UTC (rev 19566)
@@ -0,0 +1,42 @@
+module Common
+
+exports
+
+  sorts
+    ID INT STRING StringChar CommentChar
+
+  lexical syntax
+  
+    [a-zA-Z][a-zA-Z0-9\_]* -> ID
+    "-"? [0-9]+            -> INT
+    "\"" ~[\"\n]* "\""     -> STRING
+    
+    "\"" StringChar* "\""        -> STRING
+    ~[\"\n]                      -> StringChar
+    "\\\""                       -> StringChar
+    
+    [\ \t\n\r]             -> LAYOUT
+    
+    [\*]                             -> CommentChar
+    "/*" (~[\*] | CommentChar)* "*/" -> LAYOUT
+    "//" ~[\n\r]* ([\n\r] | Eof)     -> LAYOUT
+    
+    -> Eof
+  
+  lexical restrictions
+  
+  	CommentChar -/- [\/]
+  	Int         -/- [0-9]
+  	Id          -/- [a-zA-Z0-9\_]    
+    SectionName -/- ~[\n\r]
+    Eof         -/- ~[]
+
+  context-free restrictions
+
+    LAYOUT? -/- [\ \t\n\r]
+    LAYOUT? -/- [\/].[\/]
+    LAYOUT? -/- [\/].[\*]
+
+  context-free syntax
+  
+    STRING -> String {cons("String")}



From L.C.L.Kats at tudelft.nl  Mon Jun 29 11:58:03 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Mon, 29 Jun 2009 09:58:03 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19575 - LennartKats -
	in sglr-recovery/trunk/Evaluation_Recovery: . .settings
Message-ID: <200906290956.n5T9ua7A001273@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-06-29 09:58:03 +0000 (Mon, 29 Jun 2009)
New Revision: 19575

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19575&view=rev

Added:
   sglr-recovery/trunk/Evaluation_Recovery/.settings/
   sglr-recovery/trunk/Evaluation_Recovery/.settings/org.eclipse.jdt.core.prefs

Log:
Use Java 5.

Changes:

Added: sglr-recovery/trunk/Evaluation_Recovery/.settings/org.eclipse.jdt.core.prefs
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/.settings/org.eclipse.jdt.core.prefs	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/.settings/org.eclipse.jdt.core.prefs	2009-06-29 09:58:03 UTC (rev 19575)
@@ -0,0 +1,12 @@
+#Mon Jun 29 11:55:21 CEST 2009
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.5
+org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
+org.eclipse.jdt.core.compiler.compliance=1.5
+org.eclipse.jdt.core.compiler.debug.lineNumber=generate
+org.eclipse.jdt.core.compiler.debug.localVariable=generate
+org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.source=1.5



From L.C.L.Kats at tudelft.nl  Mon Jun 29 12:08:52 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Mon, 29 Jun 2009 10:08:52 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19576 - LennartKats -
	in sglr-recovery/trunk/other-parsers: . .settings META-INF
Message-ID: <200906291007.n5TA7PZL001716@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-06-29 10:08:52 +0000 (Mon, 29 Jun 2009)
New Revision: 19576

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19576&view=rev

Added:
   sglr-recovery/trunk/other-parsers/.settings/
   sglr-recovery/trunk/other-parsers/.settings/org.eclipse.jdt.core.prefs
   sglr-recovery/trunk/other-parsers/META-INF/
   sglr-recovery/trunk/other-parsers/META-INF/MANIFEST.MF
   sglr-recovery/trunk/other-parsers/build.properties
Modified:
   sglr-recovery/trunk/other-parsers/.classpath
   sglr-recovery/trunk/other-parsers/.project

Log:
Converted 'other-parsers' to an Eclipse project to allow plugin dependencies.

Changes:

Modified: sglr-recovery/trunk/other-parsers/.classpath
===================================================================
--- sglr-recovery/trunk/other-parsers/.classpath	2009-06-29 09:58:03 UTC (rev 19575)
+++ sglr-recovery/trunk/other-parsers/.classpath	2009-06-29 10:08:52 UTC (rev 19576)
@@ -1,10 +1,8 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
 	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/J2SE-1.5"/>
+	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
 	<classpathentry combineaccessrules="false" kind="src" path="/org.spoofax.interpreter.adapter.ecj"/>
-	<classpathentry combineaccessrules="false" kind="src" path="/org.eclipse.imp.lpg.runtime"/>
-	<classpathentry combineaccessrules="false" kind="src" path="/lpg.runtime.java"/>
-	<classpathentry combineaccessrules="false" kind="src" path="/org.eclipse.imp.runtime"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>

Modified: sglr-recovery/trunk/other-parsers/.project
===================================================================
--- sglr-recovery/trunk/other-parsers/.project	2009-06-29 09:58:03 UTC (rev 19575)
+++ sglr-recovery/trunk/other-parsers/.project	2009-06-29 10:08:52 UTC (rev 19576)
@@ -12,8 +12,19 @@
 			<arguments>
 			</arguments>
 		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.pde.ManifestBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.pde.SchemaBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
 	</buildSpec>
 	<natures>
 		<nature>org.eclipse.jdt.core.javanature</nature>
+		<nature>org.eclipse.pde.PluginNature</nature>
 	</natures>
 </projectDescription>

Added: sglr-recovery/trunk/other-parsers/.settings/org.eclipse.jdt.core.prefs
===================================================================
--- sglr-recovery/trunk/other-parsers/.settings/org.eclipse.jdt.core.prefs	                        (rev 0)
+++ sglr-recovery/trunk/other-parsers/.settings/org.eclipse.jdt.core.prefs	2009-06-29 10:08:52 UTC (rev 19576)
@@ -0,0 +1,12 @@
+#Mon Jun 29 12:02:26 CEST 2009
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.5
+org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
+org.eclipse.jdt.core.compiler.compliance=1.5
+org.eclipse.jdt.core.compiler.debug.lineNumber=generate
+org.eclipse.jdt.core.compiler.debug.localVariable=generate
+org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.source=1.5

Added: sglr-recovery/trunk/other-parsers/META-INF/MANIFEST.MF
===================================================================
--- sglr-recovery/trunk/other-parsers/META-INF/MANIFEST.MF	                        (rev 0)
+++ sglr-recovery/trunk/other-parsers/META-INF/MANIFEST.MF	2009-06-29 10:08:52 UTC (rev 19576)
@@ -0,0 +1,11 @@
+Manifest-Version: 1.0
+Bundle-ManifestVersion: 2
+Bundle-Name: other_parsers
+Bundle-SymbolicName: other_parsers
+Bundle-Version: 1.0.0
+Export-Package: sglrbridges.otherparsers
+Require-Bundle: org.eclipse.imp.lpg;bundle-version="0.1.79",
+ org.eclipse.imp.runtime;bundle-version="0.1.88",
+ lpg.runtime;bundle-version="2.0.16",
+ org.eclipse.imp.lpg.runtime;bundle-version="0.1.79"
+Bundle-RequiredExecutionEnvironment: J2SE-1.5

Added: sglr-recovery/trunk/other-parsers/build.properties
===================================================================
--- sglr-recovery/trunk/other-parsers/build.properties	                        (rev 0)
+++ sglr-recovery/trunk/other-parsers/build.properties	2009-06-29 10:08:52 UTC (rev 19576)
@@ -0,0 +1,3 @@
+source.. = src/
+bin.includes = META-INF/,\
+               .



From L.C.L.Kats at tudelft.nl  Mon Jun 29 12:09:15 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Mon, 29 Jun 2009 10:09:15 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19577 - LennartKats -
	sglr-recovery/trunk/bridge-definitions/syntax
Message-ID: <200906291007.n5TA7mCU001721@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-06-29 10:09:14 +0000 (Mon, 29 Jun 2009)
New Revision: 19577

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19577&view=rev

Modified:
   sglr-recovery/trunk/bridge-definitions/syntax/BridgeDefinition.sdf
   sglr-recovery/trunk/bridge-definitions/syntax/Common.sdf

Log:
Syntax fixes.

Changes:

Modified: sglr-recovery/trunk/bridge-definitions/syntax/BridgeDefinition.sdf
===================================================================
--- sglr-recovery/trunk/bridge-definitions/syntax/BridgeDefinition.sdf	2009-06-29 10:08:52 UTC (rev 19576)
+++ sglr-recovery/trunk/bridge-definitions/syntax/BridgeDefinition.sdf	2009-06-29 10:09:14 UTC (rev 19577)
@@ -15,7 +15,7 @@
 
     "import" ID ";" -> Import {cons("Import")}
 
-    "island" ID ":" ID "=" String  "for-sglr" AltPattern ";" -> Rule {cons("Island")}
+    "island" ID ":" ID "=" STRING  "for-sglr" AltPattern ";" -> Rule {cons("Island")}
     "reef"   ID ":" ID "=" Pattern "for-sglr" AltPattern ";" -> Rule {cons("Reef")}
     "ignore" Pattern "to" Pattern ";" -> Rule {cons("Ignore")}
     "bridge" "from" ID "to" ID ";" -> Rule {cons("Bridge")}
@@ -25,7 +25,7 @@
     "WS"                   -> Pattern {cons("WS")}
     "NEWLINE"              -> Pattern {cons("NEWLINE")}
     "TAB"                  -> Pattern {cons("TAB")}
-    String                 -> Pattern {cons("String")}
+    STRING                 -> Pattern {cons("String")}
     AltPattern "+"         -> Pattern {cons("Plus")}
     AltPattern "*"         -> Pattern {cons("Star")}
     AltPattern "?"         -> Pattern {cons("Opt")}

Modified: sglr-recovery/trunk/bridge-definitions/syntax/Common.sdf
===================================================================
--- sglr-recovery/trunk/bridge-definitions/syntax/Common.sdf	2009-06-29 10:08:52 UTC (rev 19576)
+++ sglr-recovery/trunk/bridge-definitions/syntax/Common.sdf	2009-06-29 10:09:14 UTC (rev 19577)
@@ -11,32 +11,27 @@
     "-"? [0-9]+            -> INT
     "\"" ~[\"\n]* "\""     -> STRING
     
-    "\"" StringChar* "\""        -> STRING
-    ~[\"\n]                      -> StringChar
-    "\\\""                       -> StringChar
+    "\"" StringChar* "\"" -> STRING
+    ~[\"\n]               -> StringChar
+    "\\\""                -> StringChar
     
-    [\ \t\n\r]             -> LAYOUT
+    [\ \t\n\r] -> LAYOUT
     
     [\*]                             -> CommentChar
     "/*" (~[\*] | CommentChar)* "*/" -> LAYOUT
-    "//" ~[\n\r]* ([\n\r] | Eof)     -> LAYOUT
+    "//" ~[\n\r]* ([\n\r] | EOF)     -> LAYOUT
     
-    -> Eof
+    -> EOF
   
   lexical restrictions
   
-  	CommentChar -/- [\/]
-  	Int         -/- [0-9]
-  	Id          -/- [a-zA-Z0-9\_]    
-    SectionName -/- ~[\n\r]
-    Eof         -/- ~[]
+    CommentChar -/- [\/]
+    INT         -/- [0-9]
+    ID          -/- [a-zA-Z0-9\_]
+    EOF         -/- ~[]
 
   context-free restrictions
 
     LAYOUT? -/- [\ \t\n\r]
     LAYOUT? -/- [\/].[\/]
     LAYOUT? -/- [\/].[\*]
-
-  context-free syntax
-  
-    STRING -> String {cons("String")}



From L.C.L.Kats at tudelft.nl  Mon Jun 29 12:09:25 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Mon, 29 Jun 2009 10:09:25 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19578 - LennartKats -
	sglr-recovery/trunk/Evaluation_Recovery
Message-ID: <200906291007.n5TA7wo2001724@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-06-29 10:09:25 +0000 (Mon, 29 Jun 2009)
New Revision: 19578

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19578&view=rev

Removed:
   sglr-recovery/trunk/Evaluation_Recovery/.jsglr-log
Modified:
   sglr-recovery/trunk/Evaluation_Recovery/.classpath

Log:


Changes:

Modified: sglr-recovery/trunk/Evaluation_Recovery/.classpath
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/.classpath	2009-06-29 10:09:14 UTC (rev 19577)
+++ sglr-recovery/trunk/Evaluation_Recovery/.classpath	2009-06-29 10:09:25 UTC (rev 19578)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
 	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/J2SE-1.5"/>
 	<classpathentry combineaccessrules="false" kind="src" path="/org.bripgen"/>
 	<classpathentry combineaccessrules="false" kind="src" path="/org.briplib"/>
 	<classpathentry combineaccessrules="false" kind="src" path="/org.spoofax.jsglr [spoofax-recovery branch]"/>



From mdjonge at xs4all.nl  Tue Jun  2 10:33:24 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Tue, 02 Jun 2009 08:33:24 -0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19501 - MaartjeDeJonge
	- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
Message-ID: <200906020833.n528X5Cx027095@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-02 08:33:59 +0000 (Tue, 02 Jun 2009)
New Revision: 19501

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19501&view=rev

Modified:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParserHistory.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java

Log:
more efficient "big reduce" calculation

Changes:

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParserHistory.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParserHistory.java	2009-05-29 15:41:54 UTC (rev 19500)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParserHistory.java	2009-06-02 08:33:59 UTC (rev 19501)
@@ -5,6 +5,9 @@
 
 public class ParserHistory {
     
+    private final static int MAX_SIZE_NEW_LINE_POINTS = 150;
+    private final static int MIN_SIZE_NEW_LINE_POINTS = 50;
+    
     private int previousBigReduceIndex;
     private int bigReduceIndex;    
     private int indexConstruct;    
@@ -12,6 +15,7 @@
     private char[] recoverTokenStream;
     private int recoverTokenCount;
     private int tokenIndex;
+    private boolean reduceIndexesSet;
     
     public int getTokenIndex() {
         return tokenIndex;
@@ -35,6 +39,7 @@
         tokenIndex=0;
         previousBigReduceIndex=0;
         bigReduceIndex=0;
+        reduceIndexesSet=false;
     }
     
     /*
@@ -82,11 +87,28 @@
         int indent = myParser.getIndentHandler().getIndentValue();
         IndentInfo newLinePoint= new IndentInfo(myParser.lineNumber, myParser.tokensSeen-1, indent);
         newLinePoint.fillStackNodes(myParser.activeStacks);
-        newLinePoints.add(newLinePoint);       
+        newLinePoints.add(newLinePoint);   
+        if(newLinePoints.size()> MAX_SIZE_NEW_LINE_POINTS)
+            removeOldPoints();
     }
     
+    private void removeOldPoints() {
+        setBigReducePoints();
+        int firstPointIndex = Math.min(previousBigReduceIndex-1, nrOfLines()-MIN_SIZE_NEW_LINE_POINTS);
+        ArrayList<IndentInfo> shrinkedList = new ArrayList<IndentInfo>();
+        shrinkedList.ensureCapacity(newLinePoints.size());
+        shrinkedList.addAll(newLinePoints.subList(firstPointIndex, newLinePoints.size()-1));
+        newLinePoints = shrinkedList;
+        bigReduceIndex-=firstPointIndex;
+        previousBigReduceIndex-=firstPointIndex;
+    }
+
     public void setBigReducePoints(){
-        int brLength=newLinePoints.get(bigReduceIndex).maxReduceLength();
+        if(reduceIndexesSet==false){
+            setBigReducesFirstTime();
+            return;
+        }
+        int brLength=getBigReducePoint().maxReduceLength();
         int oldBR=bigReduceIndex;
         for (int i = newLinePoints.size()-1; i > bigReduceIndex; i--) {
             IndentInfo point=newLinePoints.get(i);                      
@@ -105,6 +127,20 @@
         }
     }
     
+    private void setBigReducesFirstTime() {
+        bigReduceIndex=0;
+        previousBigReduceIndex=0;
+        int brLength=0;
+        for (int i = 0; i < newLinePoints.size(); i++) {
+            if(newLinePoints.get(i).maxReduceLength()>brLength){
+                previousBigReduceIndex=bigReduceIndex;
+                bigReduceIndex=i;
+            }            
+        }
+        if(newLinePoints.size()>MIN_SIZE_NEW_LINE_POINTS-1)
+            reduceIndexesSet=true;        
+    }
+
     public String getFragment(int startTok, int endTok) {
         String fragment="";
         for (int i = startTok; i <= endTok; i++) {
@@ -127,16 +163,16 @@
         return newLinePoints.get(previousBigReduceIndex);
     } 
     
-    public void moveToParentConstruct() {
-        int parentConstructIndex=0;
+    public boolean moveToParentConstruct() {        
         int loopIndex = newLinePoints.size()-2;
-        while ( loopIndex >= 0 && parentConstructIndex==0) {
+        while ( loopIndex >= 0) {
             if(newLinePoints.get(loopIndex).getIndentValue()< getConstructPoint().getIndentValue()){
-                parentConstructIndex = loopIndex;               
+                indexConstruct = loopIndex;  
+                return true;
             }
             loopIndex--;
         }
-        indexConstruct = parentConstructIndex;
+        return false;
     } 
     
     public int nrOfLines(){
@@ -155,14 +191,14 @@
 
         if(indexConstruct<=0)
             return false;
-        int previousConstructIndex=-1;
         int loopIndex = indexConstruct -1;
         IndentInfo currentLine=newLinePoints.get(indexConstruct);
-        while ( loopIndex >= 0 && previousConstructIndex==-1) {
+        while ( loopIndex >= 0) {
             IndentInfo priorLine=newLinePoints.get(loopIndex);            
             if(priorLine.getIndentValue()==currentLine.getIndentValue()){
                 if(loopIndex!=indexConstruct - 1 || priorLine.structureStartPosition() <= currentLine.structureStartPosition()){ //skip closing tag
-                    previousConstructIndex = loopIndex;   
+                    indexConstruct = loopIndex;
+                    return true;
                 }          
             }
             if(priorLine.getIndentValue()< currentLine.getIndentValue()){
@@ -170,8 +206,7 @@
             }
             loopIndex--;
         }        
-        indexConstruct = previousConstructIndex;
-        return true;   
+        return false; 
     }
     
     public void addRecoverLines(ArrayList<IndentInfo> recoverNewLinePoints) {

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java	2009-05-29 15:41:54 UTC (rev 19500)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java	2009-06-02 08:33:59 UTC (rev 19501)
@@ -103,11 +103,11 @@
                 recoverAction=SkipAction.SKIP_PARENT;
                 break;
             case SKIP_PARENT:
-                getHistory().moveToParentConstruct();
-                if(getHistory().getConstructPoint().getTokensSeen()<= getHistory().getPreviousBigReducePoint().getTokensSeen())
+                boolean movedToParent = getHistory().moveToParentConstruct();
+                if(hasLowIndentation() || !movedToParent)
                     recoverAction=SkipAction.SKIP_FORWARD;
                 else
-                    recoverAction = SkipAction.SKIP_CURRENT;
+                    recoverAction = SkipAction.SKIP_CURRENT;            
                 break;
             case SKIP_FORWARD:
                 skipForward();
@@ -127,6 +127,10 @@
         reset();        
     }
 
+    private boolean hasLowIndentation() {
+        return getHistory().getConstructPoint().getTokensSeen()<= getHistory().getPreviousBigReducePoint().getTokensSeen();
+    }
+
     private void forcingParse() throws IOException{
         EofRecovery eofR = new EofRecovery();        
         eofR.myParser=myParser;



From mdjonge at xs4all.nl  Tue Jun  2 15:21:35 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Tue, 02 Jun 2009 13:21:35 -0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19504 - MaartjeDeJonge
	- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
Message-ID: <200906021321.n52DLHUi032602@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-02 13:22:11 +0000 (Tue, 02 Jun 2009)
New Revision: 19504

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19504&view=rev

Modified:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java

Log:
RecoveryRefacrored => StructureRecovery

Changes:

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java	2009-06-02 10:04:21 UTC (rev 19503)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java	2009-06-02 13:22:11 UTC (rev 19504)
@@ -5,12 +5,12 @@
 public class RecoveryConnector {
     private SGLR mySGLR;
     private IRecoveryParser recoveryParser;
-    private RecoveryRefactored skipRecovery;
+    private StructureRecovery skipRecovery;
     
     public RecoveryConnector(SGLR parser, IRecoveryParser recoveryParser){
         mySGLR=parser;
         this.recoveryParser = recoveryParser;
-        skipRecovery = new RecoveryRefactored(mySGLR);
+        skipRecovery = new StructureRecovery(mySGLR);
     }
     
     public void recover() throws IOException{



From mdjonge at xs4all.nl  Thu Jun  4 11:55:05 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Thu, 04 Jun 2009 09:55:05 -0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19507 - MaartjeDeJonge
	- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
Message-ID: <200906040954.n549skUk000619@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-04 09:55:42 +0000 (Thu, 04 Jun 2009)
New Revision: 19507

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19507&view=rev

Added:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/FineGrainedRepair.java
Modified:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Frame.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Path.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java

Log:
Fine-grained recovery plugged-in, Whitespace added as last recover mechanism. 

Changes:

Added: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/FineGrainedRepair.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/FineGrainedRepair.java	                        (rev 0)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/FineGrainedRepair.java	2009-06-04 09:55:42 UTC (rev 19507)
@@ -0,0 +1,35 @@
+package org.spoofax.jsglr;
+
+import java.io.IOException;
+
+import org.spoofax.ArrayDeque;
+
+public class FineGrainedRepair {
+    
+    private SGLR myParser;
+    
+    private ParserHistory getHistory() {
+        return myParser.history;        
+    }
+    
+    public FineGrainedRepair(SGLR sglr){
+        myParser=sglr;        
+    }
+    
+    public void findRecoverBranch(int startIndex, int endIndex, ArrayDeque<Frame> stackNodes) throws IOException{
+        myParser.activeStacks=stackNodes;
+        getHistory().setTokenIndex(startIndex);
+        recoverParse(endIndex);
+    }
+    
+    private void recoverParse(int endIndex) throws IOException{
+        myParser.setRecoverTolerance(3);
+        while (getHistory().getTokenIndex() < endIndex && myParser.activeStacks.size() > 0){
+            getHistory().readRecoverToken(myParser);
+            myParser.doParseStep();
+            //Tools.debug("Recover: "+(char)myParser.currentToken);             
+        }
+        myParser.setRecoverTolerance(0);
+    }
+
+}

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Frame.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Frame.java	2009-06-03 09:03:27 UTC (rev 19506)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Frame.java	2009-06-04 09:55:42 UTC (rev 19507)
@@ -21,11 +21,21 @@
     public static int framesCreated =0; //MJ: for testing
 
     public final State state;
+    
+    private int minRecoverCount;
 
     // Using a Vector and regular iteration takes parsing of file-test from 1100ms (min) to 2020ms (max)!
     // TODO: Just use an ArrayList for Frame.steps?
     //       which should have better performance than the obsolete, synchronized Vector classs
     
+    public int getMinRecoverCount() {
+        return minRecoverCount;
+    }
+
+    public void setMinRecoverCount(int minRecoverCount) {
+        this.minRecoverCount = minRecoverCount;
+    }
+
     private Link[] steps;
     private int stepsCount;
 
@@ -36,7 +46,8 @@
         state = s;
         steps = new Link[20];
         stepsCount = 0;
-        framesCreated +=1; //MJ: for testing        
+        framesCreated +=1; //MJ: for testing 
+        minRecoverCount=-1;
     }
 
     public boolean allLinksRejected() {

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Path.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Path.java	2009-06-03 09:03:27 UTC (rev 19506)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Path.java	2009-06-04 09:55:42 UTC (rev 19507)
@@ -43,6 +43,13 @@
         }
         return result;        
     }
+    
+    public int getAvoidCount(int maxCharLength)
+    {
+        if(parent==null || this.length<=maxCharLength)
+            return getAvoidCount();
+        return parent.getAvoidCount(maxCharLength);
+    }
 
     //todo managed
     //public static final PathObjectFactory FACTORY = new PathObjectFactory();

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java	2009-06-03 09:03:27 UTC (rev 19506)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java	2009-06-04 09:55:42 UTC (rev 19507)
@@ -2,6 +2,8 @@
 
 import java.io.IOException;
 
+import junit.framework.Assert;
+
 public class RecoveryConnector {
     private SGLR mySGLR;
     private IRecoveryParser recoveryParser;
@@ -13,17 +15,54 @@
         skipRecovery = new StructureRecovery(mySGLR);
     }
     
+    private ParserHistory getHistory() {
+        return mySGLR.history;
+    }
+    
     public void recover() throws IOException{
         
         skipRecovery.recover();
         String errorFragment = skipRecovery.getErrorFragment();
-        Tools.debug(errorFragment);        
+        Tools.debug(errorFragment); 
+        //BRIDGE REPAIR
+        tryBridgeRepair(errorFragment);
+        if(recoverySucceeded())
+            Tools.debug("Bridge Repair Succeeded");        
+        else { //FINEGRAINED REPAIR
+            Tools.debug("Bridge Repair Failed");
+            tryFineGrainedRepair();
+        }           
+        if(recoverySucceeded())
+            Tools.debug("Fine-Grained Repair Succeeded");        
+        else { //WHITESPACE REPAIR
+            Tools.debug("FineGrained Repair Failed");
+            whiteSpaceParse(errorFragment);
+            Assert.assertTrue("White space parse unexpectly fails", recoverySucceeded());
+        }        
+                
+    }
+
+    private boolean recoverySucceeded() {
+        return mySGLR.activeStacks.size()>0 || mySGLR.acceptingStack!=null;
+    }
+
+    private void whiteSpaceParse(String errorFragment) throws IOException {
+        mySGLR.activeStacks.addAll(skipRecovery.getStartSkipPosition().getStackNodes());            
+        tryParsing(errorFragment, true);
+        parseRemainingTokens();
+    }
+
+    private void tryFineGrainedRepair() throws IOException {
+        FineGrainedRepair fineGrained=new FineGrainedRepair(mySGLR);            
+        fineGrained.findRecoverBranch(skipRecovery.getStartSkipPosition().getTokensSeen(), skipRecovery.getSkipPoint().getTokensSeen(), skipRecovery.getStartSkipPosition().getStackNodes());
+        parseRemainingTokens();
+    }
+
+    private void tryBridgeRepair(String errorFragment) throws IOException {
         String repairedFragment = repairBridges(errorFragment);        
         mySGLR.activeStacks=skipRecovery.getStartSkipPosition().getStackNodes();   
-        tryParsing(repairedFragment);
-        if(mySGLR.activeStacks.size()>0){           
-            skipRecovery.parseRemainingTokens();
-        }        
+        tryParsing(repairedFragment, false);      
+        parseRemainingTokens();
     }
 
     private String repairBridges(String errorFragment) {
@@ -46,15 +85,49 @@
         return "/*" + errorFragment + "*/";
     }
     
-    private void tryParsing(String repairedFragment) throws IOException{
+    private void tryParsing(String fragment, boolean asLayout) throws IOException{
+        int indexFragment = findFirstNonLayoutToken(fragment);        
+        while(indexFragment<fragment.length() && recoverySucceeded()) {                        
+            mySGLR.currentToken=fragment.charAt(indexFragment);
+            indexFragment++;
+            if(!asLayout)
+                mySGLR.doParseStep();
+            else
+                parseAsLayout();
+        }       
+    }
+    
+    public void parseRemainingTokens() throws IOException{
+        getHistory().setTokenIndex(skipRecovery.getSkipPoint().getTokensSeen());
+        while(!getHistory().hasFinishedRecoverTokens()&& recoverySucceeded()){        
+            getHistory().readRecoverToken(mySGLR);
+            //Tools.debug("***"+(char)mySGLR.currentToken);
+            mySGLR.doParseStep();            
+        }        
+    }
+
+    
+    
+    private void parseAsLayout() throws IOException {        
+        switch (mySGLR.currentToken) {                
+        case '\n':
+            mySGLR.doParseStep();
+            break;
+        case '\t':
+            mySGLR.doParseStep();
+            break;
+        default:
+            mySGLR.currentToken=' ';
+            mySGLR.doParseStep();
+            break;
+        }
+    }
+
+    private int findFirstNonLayoutToken(String repairedFragment) {
         int indexFragment=0;
         while(indexFragment<repairedFragment.length()-1 && (repairedFragment.charAt(indexFragment)==' ' || repairedFragment.charAt(indexFragment)=='\t'))
-            indexFragment++;        
-        while(indexFragment<repairedFragment.length() && mySGLR.activeStacks.size() > 0) {                        
-            mySGLR.currentToken=repairedFragment.charAt(indexFragment);
             indexFragment++;
-            mySGLR.doParseStep();
-        }       
+        return indexFragment;
     }
 
 }

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-06-03 09:03:27 UTC (rev 19506)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-06-04 09:55:42 UTC (rev 19507)
@@ -95,7 +95,7 @@
     
     private RecoveryConnector recoverIntegrator;
     
-    private boolean useStructureRecovery;
+    private boolean useIntegratedRecovery;
     
     //Keeps track of the indentation for each line
     public IndentationHandler getIndentHandler() {
@@ -139,11 +139,11 @@
 
     public void setUseStructureRecovery(boolean useRoughRecovery, IRecoveryParser parser) {
         this.recoverIntegrator = new RecoveryConnector(this, parser);
-        this.useStructureRecovery = useRoughRecovery;
+        this.useIntegratedRecovery = useRoughRecovery;
     }
     
     public void setUseStructureRecovery(boolean useRoughRecovery) {        
-        this.useStructureRecovery = useRoughRecovery;
+        this.useIntegratedRecovery = useRoughRecovery;
         this.recoverIntegrator = new RecoveryConnector(this, null);
     }
     
@@ -175,7 +175,7 @@
         recoverHandler = new NoRecovery();
         //recoverHandler = new CoarseGrainedRecovery();        
         recoverHandler.initialize(this);        
-        useStructureRecovery = false;
+        useIntegratedRecovery = false;
         recoverIntegrator = null;
         history=new ParserHistory(); 
         setEofRecoverParse(false);
@@ -253,17 +253,17 @@
             
            // history.logBigReductionList();
             
-            if(useStructureRecovery && acceptingStack==null){
-                recoverIntegrator.recover();                
+            if(useIntegratedRecovery && acceptingStack==null){
+                recoverIntegrator.recover();                 
                 if(acceptingStack==null)
                     return sglrParse(startSymbol);
-            }            
-            
-            if(recoverHandler.meetsRecoverCriteria()){
+            }
+            /*
+            else if(recoverHandler.meetsRecoverCriteria()){
                 recoverHandler.recover();                                
                 if(acceptingStack==null)
                     return sglrParse(startSymbol);
-            }
+            }*/
         } catch (CancellationException e) {
             throw new ParseTimeoutException(this, currentToken, tokensSeen - 1, lineNumber,
                     columnNumber);
@@ -278,6 +278,8 @@
      
         logParseResult(s);
         //Tools.debug("avoids: "+s.avoidCount);
+        //Tools.debug(s.label.toParseTree(parseTable));
+        
         return disambiguator.applyFilters(this, s.label, startSymbol, tokensSeen);
     }
 
@@ -506,16 +508,24 @@
     }
 
     private void doReductions(Frame st, Production prod) throws IOException {
-        List<Path> paths = st.findAllPaths(prod.arity);         
-        logBeforeDoReductions(st, prod, paths.size());
-        reduceAllPaths(prod, paths);
-        logAfterDoReductions();
+        if(!violatesRecoverTolerance(st, prod)){
+            List<Path> paths = st.findAllPaths(prod.arity);         
+            logBeforeDoReductions(st, prod, paths.size());
+            reduceAllPaths(prod, paths);
+            logAfterDoReductions();
+        }
     }
+
+    private boolean violatesRecoverTolerance(Frame st, Production prod) {
+        return useIntegratedRecovery && prod.status == Reduce.AVOID && st.getMinRecoverCount()>= recoverTolerance;
+    }
     
     private void doLimitedReductions(Frame st, Production prod, Link l) throws IOException { //Todo: Look add sharing code with doReductions
-        List<Path> paths = st.findLimitedPaths(prod.arity, l); //find paths containing the link         
-        logBeforeLimitedReductions(st, prod, l, paths);        
-        reduceAllPaths(prod, paths);
+        if(!violatesRecoverTolerance(st, prod)){
+            List<Path> paths = st.findLimitedPaths(prod.arity, l); //find paths containing the link         
+            logBeforeLimitedReductions(st, prod, l, paths);        
+            reduceAllPaths(prod, paths);
+        }
     }
 
     private void reduceAllPaths(Production prod, List<Path> paths)
@@ -551,13 +561,17 @@
         IParseNode t = prod.apply(kids);
         Frame st1; 
         Link nl;
-        if(prod.status == Reduce.AVOID)
-        {
-            recoverHandler.handleRecoverProduction(st0, s, length, numberOfAvoids, t);
-            if(recoverHandler.haltsOnRecoverProduction(st0)){
+        if(prod.status == Reduce.AVOID){
+            if(useIntegratedRecovery && numberOfAvoids>recoverTolerance)
+            {
                 return;
             }
-        }        
+            else{
+                recoverHandler.handleRecoverProduction(st0, s, length, numberOfAvoids, t);
+                if(recoverHandler.haltsOnRecoverProduction(st0))
+                    return;
+            }
+        }                
         logBeforeReducer(s, prod, length);
         increaseReductionCount();        
         st1 = findStack(activeStacks, s);
@@ -591,14 +605,18 @@
     
     private void handleAmbiguity(int numberOfAvoids, IParseNode t, Link nl) {        
         //if both branches contain no recover productions, create an Amb node.
-        if(eofRecoverParse)
-            return; //no ambiguity!
         if(numberOfAvoids == 0 && nl.avoidCount==0){
             createAmbNode(t, nl);
-        }        
-        //if one (or both) branches contain a recover production, the recover-algorithm decides how to handle them  
+            return;
+        }
+        // old recovery method
+        if(!useIntegratedRecovery)
+            recoverHandler.handleAmbiguity(numberOfAvoids, t, nl);
+        // integrated recovery method
+        if(useIntegratedRecovery && eofRecoverParse)
+            return; //not interested in ambiguity!
         else{
-            recoverHandler.handleAmbiguity(numberOfAvoids, t, nl);            
+            return; //MJ: disambiguate by avoidCount, indentation ..                      
         }                
     }
 
@@ -853,7 +871,24 @@
         WORK_AROUND_MULTIPLE_LOOKAHEAD = value;
     }   
        
+
+      
+    private int recoverTolerance;
     
+    public void setRecoverTolerance(int recoverTolerance) {
+        this.recoverTolerance = recoverTolerance;
+    }    
+    
+    private void setFrameAvoidCount(Frame parent, Frame frame, Path p, int backWardsLength){
+        int avoidValue = p.getAvoidCount(backWardsLength);
+        if(p.getLength() < backWardsLength)
+            avoidValue+=parent.getMinRecoverCount();
+        if(frame.getMinRecoverCount()<0 || frame.getMinRecoverCount()> avoidValue)
+            frame.setMinRecoverCount(avoidValue);
+        if(frame.getMinRecoverCount()<0)
+            frame.setMinRecoverCount(0);
+    }
+    
     ////////////////////////////////////////////////////// Log functions ///////////////////////////////////////////////////////////////////////////////
     
     static void TRACE(String string) {

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java	2009-06-03 09:03:27 UTC (rev 19506)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java	2009-06-04 09:55:42 UTC (rev 19507)
@@ -28,6 +28,13 @@
     private ArrayList<IndentInfo> recoverlines;   
    
     /*
+     * 
+     */
+    public IndentInfo getSkipPoint() {
+        return skipPoint;
+    }
+    
+    /*
      * Parser state before the skipping
      */
     public IndentInfo getStartSkipPosition() {
@@ -189,7 +196,7 @@
         skipPoint=IndentInfo.cloneIndentInfo(startPoint);
         startSkipPosition = IndentInfo.cloneIndentInfo(startPoint);
         int tokIndexLine=getHistory().getTokensSeenStartLine(startSkipPosition.getTokensSeen());
-        startSkipPosition.setTokensSeen(tokIndexLine);
+        startSkipPosition.setTokensSeen(tokIndexLine); //TODO: better solution
     }
 
     private void doSkipRecoverStep() throws IOException {
@@ -210,16 +217,8 @@
             if(meetsSuccessCriteriaForRecovery())
                 return; //end of attempt                     
         }       
-    }
+    }    
     
-    public void parseRemainingTokens() throws IOException{
-        getHistory().setTokenIndex(skipPoint.getTokensSeen());
-        while(!getHistory().hasFinishedRecoverTokens()){        
-            getHistory().readRecoverToken(myParser);
-            myParser.doParseStep();            
-        }        
-    }
-
     private boolean meetsSuccessCriteriaForRecovery() {
         if(skipIndentHandler.lineMarginEnded() && getHistory().hasFinishedRecoverTokens())
             return inspectLinePoints();
@@ -256,13 +255,10 @@
             readNextToken(); 
             if ((reachedErrorDetectionLine() && endOfConstruct(skipP)) || myParser.currentToken==SGLR.EOF) {
                 endSkipFound=true;                 
-                int indent = skipIndentHandler.getIndentValue();
+                int indent = skipIndentHandler.getIndentValue();                
                 skipPoint = new IndentInfo(-1, getHistory().getTokenIndex() -1, indent);
                 skipPoint.fillStackNodes(myParser.activeStacks);
-            }
-            else{                
-                parseAsLayout();                
-            }
+            }            
         }        
     }
 
@@ -272,22 +268,7 @@
 
     private boolean reachedErrorDetectionLine() {
         return getHistory().getTokenIndex()>=getHistory().getLine(getHistory().nrOfLines()-1).getTokensSeen();
-    }
-
-    private void parseAsLayout() throws IOException {        
-        switch (myParser.currentToken) {                
-        case '\n':
-            myParser.doParseStep();
-            break;
-        case '\t':
-            myParser.doParseStep();
-            break;
-        default:
-            myParser.currentToken=' ';
-            myParser.doParseStep();
-            break;
-        }
-    }
+    }    
     
     private void readNextToken() throws IOException {
         getHistory().readRecoverToken(myParser);
@@ -297,9 +278,12 @@
     }       
        
     private void updateRecoverLinePoint(SGLR myParser) {
-        if(myParser.getIndentHandler().lineMarginEnded()){
-            int indent = myParser.getIndentHandler().getIndentValue();
-            IndentInfo newLinePoint= new IndentInfo(myParser.lineNumber, getHistory().getTokenIndex(), indent);
+        if(skipIndentHandler.lineMarginEnded()){
+            int indent = skipIndentHandler.getIndentValue();
+            int lineNumber =-1;
+            if(getHistory().hasFinishedRecoverTokens())
+                lineNumber=myParser.lineNumber;
+            IndentInfo newLinePoint= new IndentInfo(lineNumber, getHistory().getTokenIndex(), indent);
             newLinePoint.fillStackNodes(myParser.activeStacks);
             recoverlines.add(newLinePoint);  
         }      



From mdjonge at xs4all.nl  Thu Jun  4 15:05:06 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Thu, 04 Jun 2009 13:05:06 -0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19508 - MaartjeDeJonge
	- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
Message-ID: <200906041304.n54D4meO003448@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-04 13:05:44 +0000 (Thu, 04 Jun 2009)
New Revision: 19508

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19508&view=rev

Added:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoverDisambiguator.java
Modified:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/FineGrainedRepair.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java

Log:


Changes:

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/FineGrainedRepair.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/FineGrainedRepair.java	2009-06-04 09:55:42 UTC (rev 19507)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/FineGrainedRepair.java	2009-06-04 13:05:44 UTC (rev 19508)
@@ -9,7 +9,7 @@
     private SGLR myParser;
     
     private ParserHistory getHistory() {
-        return myParser.history;        
+        return myParser.getHistory();        
     }
     
     public FineGrainedRepair(SGLR sglr){
@@ -17,7 +17,8 @@
     }
     
     public void findRecoverBranch(int startIndex, int endIndex, ArrayDeque<Frame> stackNodes) throws IOException{
-        myParser.activeStacks=stackNodes;
+        myParser.activeStacks.clear();
+        myParser.activeStacks.addAll(stackNodes);
         getHistory().setTokenIndex(startIndex);
         recoverParse(endIndex);
     }

Added: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoverDisambiguator.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoverDisambiguator.java	                        (rev 0)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoverDisambiguator.java	2009-06-04 13:05:44 UTC (rev 19508)
@@ -0,0 +1,64 @@
+package org.spoofax.jsglr;
+
+public class RecoverDisambiguator {
+    
+    private ParseTable parseTable;
+    
+    public RecoverDisambiguator(ParseTable pt){
+        parseTable=pt;
+    }
+    
+    public void handleAmbiguity(int avoidCount_t, IParseNode t, Link nl){
+        assert !(nl.avoidCount == 0 && avoidCount_t == 0)
+                : "ambiguity without recover productions should not be handled by RecoverAlgorithm";
+        
+        //A. Choose branch without recover productions
+        boolean hasRecoverFreeBranch = trySelectNoRecoveries(avoidCount_t, t, nl);
+        if(hasRecoverFreeBranch)
+            return;
+        //B. Disambiguate by indentation
+        boolean hasIndentPreference = trySelectByIndentation(avoidCount_t, t, nl);
+        if(hasIndentPreference){
+            return;
+        }
+        //C. choose branche with smallest number of avoids
+        trySelectOnAvoidCount(avoidCount_t, t, nl);
+    }
+    
+    private boolean trySelectOnAvoidCount(int avoidCount_t, IParseNode t, Link nl) {
+        if(avoidCount_t == nl.avoidCount)
+            return false;
+        if(avoidCount_t < nl.avoidCount)
+            setLabel(0, t, nl);
+        return true;
+    }
+    
+    private boolean trySelectNoRecoveries(int avoidCount_t, IParseNode t, Link nl){     
+        if(nl.avoidCount==0)
+            return true;
+        if(avoidCount_t==0){
+            setLabel(0, t, nl);
+            return true;
+        }
+        return false;
+    }
+    
+    private boolean trySelectByIndentation(int avoidCount_t, IParseNode t, Link nl) {
+        IndentationDisambiguator indentFilter=new IndentationDisambiguator();
+        indentFilter.evaluateIndentation(nl.label.toParseTree(parseTable));
+        int nlScore=indentFilter.getIndentDeviationListElements();
+        indentFilter.evaluateIndentation(t.toParseTree(parseTable));
+        int tScore=indentFilter.getIndentDeviationListElements();
+        if(tScore == nlScore)
+            return false;
+        if(tScore < nlScore){
+            setLabel(avoidCount_t, t, nl);
+        }
+        return true;
+    }
+    
+    private void setLabel(int avoidCount_t, IParseNode t, Link nl) {
+        nl.label=t;
+        nl.avoidCount=avoidCount_t;
+    }
+}

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java	2009-06-04 09:55:42 UTC (rev 19507)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java	2009-06-04 13:05:44 UTC (rev 19508)
@@ -16,31 +16,49 @@
     }
     
     private ParserHistory getHistory() {
-        return mySGLR.history;
+        return mySGLR.getHistory();
     }
     
     public void recover() throws IOException{
         
-        skipRecovery.recover();
+        boolean skipSucceeded = skipRecovery.recover();
+        mySGLR.acceptingStack=null;
         String errorFragment = skipRecovery.getErrorFragment();
         Tools.debug(errorFragment); 
         //BRIDGE REPAIR
         tryBridgeRepair(errorFragment);
-        if(recoverySucceeded())
-            Tools.debug("Bridge Repair Succeeded");        
-        else { //FINEGRAINED REPAIR
-            Tools.debug("Bridge Repair Failed");
-            tryFineGrainedRepair();
-        }           
-        if(recoverySucceeded())
-            Tools.debug("Fine-Grained Repair Succeeded");        
-        else { //WHITESPACE REPAIR
-            Tools.debug("FineGrained Repair Failed");
+        if(recoverySucceeded()){
+            Tools.debug("Bridge Repair Succeeded");
+            return;
+        }
+        Tools.debug("Bridge Repair Failed");
+        //FINEGRAINED REPAIR        
+        tryFineGrainedRepair();                   
+        if(recoverySucceeded()){
+            Tools.debug("Fine-Grained Repair Succeeded");
+            return;
+        }
+        Tools.debug("FineGrained Repair Failed");
+        //WHITESPACE REPAIR
+        if (skipSucceeded) {            
             whiteSpaceParse(errorFragment);
-            Assert.assertTrue("White space parse unexpectly fails", recoverySucceeded());
-        }        
-                
+            assert recoverySucceeded() : "White space parse unexpectly fails";
+        }
+        //FORCE PREFIX ACCEPT
+        else {
+            Tools.debug("Enforcing Accepting Stack");
+            mySGLR.setEofRecoverParse(true);
+            forcingParse(); 
+            mySGLR.setEofRecoverParse(false);
+            assert recoverySucceeded() : "'Force-Accepting-Stack' unexpectly fails"; 
+        }               
     }
+    
+    private void forcingParse() throws IOException{
+        EofRecovery eofR = new EofRecovery();        
+        eofR.myParser=mySGLR;
+        eofR.enforceAccept(getHistory().getBigReducePoint().getStackNodes());
+    }
 
     private boolean recoverySucceeded() {
         return mySGLR.activeStacks.size()>0 || mySGLR.acceptingStack!=null;
@@ -60,7 +78,7 @@
 
     private void tryBridgeRepair(String errorFragment) throws IOException {
         String repairedFragment = repairBridges(errorFragment);        
-        mySGLR.activeStacks=skipRecovery.getStartSkipPosition().getStackNodes();   
+        mySGLR.activeStacks.addAll(skipRecovery.getStartSkipPosition().getStackNodes());   
         tryParsing(repairedFragment, false);      
         parseRemainingTokens();
     }
@@ -108,24 +126,23 @@
 
     
     
-    private void parseAsLayout() throws IOException {        
-        switch (mySGLR.currentToken) {                
-        case '\n':
+    private void parseAsLayout() throws IOException { //TODO: EOF 
+        //Tools.debug("As Whitespace: " + (char)mySGLR.currentToken);
+        if(isLayoutCharacter((char)mySGLR.currentToken))
             mySGLR.doParseStep();
-            break;
-        case '\t':
-            mySGLR.doParseStep();
-            break;
-        default:
+        else{
             mySGLR.currentToken=' ';
-            mySGLR.doParseStep();
-            break;
+            mySGLR.doParseStep();            
         }
     }
+    
+    private boolean isLayoutCharacter(char aChar){
+        return aChar==' ' || aChar == '\t' || aChar=='\n';
+    }
 
     private int findFirstNonLayoutToken(String repairedFragment) {
         int indexFragment=0;
-        while(indexFragment<repairedFragment.length()-1 && (repairedFragment.charAt(indexFragment)==' ' || repairedFragment.charAt(indexFragment)=='\t'))
+        while(indexFragment<repairedFragment.length()-1 && isLayoutCharacter(repairedFragment.charAt(indexFragment)))
             indexFragment++;
         return indexFragment;
     }

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-06-04 09:55:42 UTC (rev 19507)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-06-04 13:05:44 UTC (rev 19508)
@@ -102,8 +102,14 @@
         return indentHandler;
     }
     
-    ParserHistory history;
+    private ParserHistory history;
     
+    public ParserHistory getHistory() {
+        return history;
+    }
+
+    private RecoverDisambiguator recoverDisambiguator;
+    
     private boolean eofRecoverParse;
 
     public void setEofRecoverParse(boolean eofRecoverParse) {
@@ -123,9 +129,10 @@
         assert pf != null;
         assert parseTable != null;
         // Init with a new factory for both serialized or BAF instances.
+        this.parseTable = parseTable;
         basicInit(pf);
 
-        this.parseTable = parseTable;
+        
     }
     
     public void setRecoverHandler(RecoverAlgorithm recoverHandler) {
@@ -179,6 +186,7 @@
         recoverIntegrator = null;
         history=new ParserHistory(); 
         setEofRecoverParse(false);
+        recoverDisambiguator=new RecoverDisambiguator(this.parseTable);
     }
 
     public static boolean isDebugging() {
@@ -616,7 +624,8 @@
         if(useIntegratedRecovery && eofRecoverParse)
             return; //not interested in ambiguity!
         else{
-            return; //MJ: disambiguate by avoidCount, indentation ..                      
+            recoverDisambiguator.handleAmbiguity(numberOfAvoids, t, nl);
+            //return; //MJ: disambiguate by avoidCount, indentation ..                      
         }                
     }
 

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java	2009-06-04 09:55:42 UTC (rev 19507)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java	2009-06-04 13:05:44 UTC (rev 19508)
@@ -13,8 +13,7 @@
         SKIP_CURRENT,
         SKIP_SIBLINGS,
         SKIP_PARENT,
-        SKIP_FORWARD,    
-        ENFORCE_ACCEPT,
+        SKIP_FORWARD,
         STOPPED        
     }    
     
@@ -79,13 +78,13 @@
     }
 
     private ParserHistory getHistory() {
-        return myParser.history;
+        return myParser.getHistory();
     }
 
     /*
      * Recovers by skipping (parse as whitespace) part of the input string
      */
-    public void recover() throws IOException {
+    public boolean recover() throws IOException {
         getHistory().setBigReducePoints();
         getHistory().moveToLastConstruct();
         errorDetectionPosition=myParser.tokensSeen;
@@ -118,32 +117,22 @@
                 break;
             case SKIP_FORWARD:
                 skipForward();
-                recoverAction = SkipAction.ENFORCE_ACCEPT;
-                break;            
-            case ENFORCE_ACCEPT:
-                myParser.setEofRecoverParse(true);
-                forcingParse(); 
-                myParser.setEofRecoverParse(false);
-                recoverAction=SkipAction.STOPPED;
-                break;  
+                recoverAction = SkipAction.STOPPED;
+                break;
             case STOPPED:                                
                 break;          
-            }            
+            }   
         }
-        getHistory().addRecoverLines(recoverlines);
-        reset();        
+        if(recoverySucceeded())
+            getHistory().addRecoverLines(recoverlines);
+        reset();
+        return recoverySucceeded();
     }
 
     private boolean hasLowIndentation() {
         return getHistory().getConstructPoint().getTokensSeen()<= getHistory().getPreviousBigReducePoint().getTokensSeen();
     }
 
-    private void forcingParse() throws IOException{
-        EofRecovery eofR = new EofRecovery();        
-        eofR.myParser=myParser;
-        eofR.enforceAccept(getHistory().getBigReducePoint().getStackNodes());
-    }
-
     private boolean recoverySucceeded() {
         return (myParser.activeStacks.size() > 0 || myParser.acceptingStack!=null);
     }    



From mdjonge at xs4all.nl  Thu Jun  4 15:11:30 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Thu, 04 Jun 2009 13:11:30 -0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19510 - MaartjeDeJonge
	- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
Message-ID: <200906041310.n54DAxQ9003523@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-04 13:11:55 +0000 (Thu, 04 Jun 2009)
New Revision: 19510

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19510&view=rev

Modified:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java

Log:
renaming

Changes:

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java	2009-06-04 13:09:27 UTC (rev 19509)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java	2009-06-04 13:11:55 UTC (rev 19510)
@@ -21,7 +21,7 @@
     
     public void recover() throws IOException{
         
-        boolean skipSucceeded = skipRecovery.recover();
+        boolean skipSucceeded = skipRecovery.selectErroneousFragment();
         mySGLR.acceptingStack=null;
         String errorFragment = skipRecovery.getErrorFragment();
         Tools.debug(errorFragment); 
@@ -47,9 +47,9 @@
         //FORCE PREFIX ACCEPT
         else {
             Tools.debug("Enforcing Accepting Stack");
-            mySGLR.setEofRecoverParse(true);
+            mySGLR.setEnforcePrefixAccept(true);
             forcingParse(); 
-            mySGLR.setEofRecoverParse(false);
+            mySGLR.setEnforcePrefixAccept(false);
             assert recoverySucceeded() : "'Force-Accepting-Stack' unexpectly fails"; 
         }               
     }

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-06-04 13:09:27 UTC (rev 19509)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-06-04 13:11:55 UTC (rev 19510)
@@ -110,10 +110,10 @@
 
     private RecoverDisambiguator recoverDisambiguator;
     
-    private boolean eofRecoverParse;
+    private boolean enforcePrefixAccept;
 
-    public void setEofRecoverParse(boolean eofRecoverParse) {
-        this.eofRecoverParse = eofRecoverParse;
+    public void setEnforcePrefixAccept(boolean forcingParse) {
+        this.enforcePrefixAccept = forcingParse;
     }
 
     //Creates indent- and dedent- tokens
@@ -185,7 +185,7 @@
         useIntegratedRecovery = false;
         recoverIntegrator = null;
         history=new ParserHistory(); 
-        setEofRecoverParse(false);
+        setEnforcePrefixAccept(false);
         recoverDisambiguator=new RecoverDisambiguator(this.parseTable);
     }
 
@@ -351,7 +351,7 @@
 
         while (forShifter.size() > 0) {
             ActionState as = forShifter.remove();
-            if(eofRecoverParse)
+            if(enforcePrefixAccept)
                 prod=parseTable.lookupProduction(as.currentToken);
             if (!parseTable.hasRejects() || !as.st.allLinksRejected()) {
                 Frame st1 = findStack(activeStacks, as.s);
@@ -425,7 +425,7 @@
         State s = st.peek();
         logBeforeActor(st, s);        
         for (Action action : s.getActions()) {
-            if(eofRecoverParse)
+            if(enforcePrefixAccept)
                 currentToken = action.getFirstCharValue();
             if (action.accepts(currentToken)) {
                 for (ActionItem ai : action.getActionItems()) {
@@ -621,7 +621,7 @@
         if(!useIntegratedRecovery)
             recoverHandler.handleAmbiguity(numberOfAvoids, t, nl);
         // integrated recovery method
-        if(useIntegratedRecovery && eofRecoverParse)
+        if(useIntegratedRecovery && enforcePrefixAccept)
             return; //not interested in ambiguity!
         else{
             recoverDisambiguator.handleAmbiguity(numberOfAvoids, t, nl);
@@ -674,7 +674,7 @@
                 continue; //stacknode will find reduction in regular process
 
             for (Action action : st2.peek().getActions()) {
-                if (action.accepts(currentToken) || eofRecoverParse) {
+                if (action.accepts(currentToken) || enforcePrefixAccept) {
                     for (ActionItem ai : action.getActionItems()) {                  
                         switch(ai.type) {
                             case ActionItem.REDUCE:

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java	2009-06-04 13:09:27 UTC (rev 19509)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java	2009-06-04 13:11:55 UTC (rev 19510)
@@ -67,7 +67,7 @@
         skipIndentHandler.initEvaluationVariables();
         skipIndentHandler.setInLeftMargin(false);
         recoverlines.clear();
-        myParser.setEofRecoverParse(false);
+        myParser.setEnforcePrefixAccept(false);
     }
 
     private void initialize() {
@@ -84,7 +84,7 @@
     /*
      * Recovers by skipping (parse as whitespace) part of the input string
      */
-    public boolean recover() throws IOException {
+    public boolean selectErroneousFragment() throws IOException {
         getHistory().setBigReducePoints();
         getHistory().moveToLastConstruct();
         errorDetectionPosition=myParser.tokensSeen;



From mdjonge at xs4all.nl  Mon Jun  8 17:01:28 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Mon, 08 Jun 2009 15:01:28 -0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19515 - MaartjeDeJonge
	- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
Message-ID: <200906081501.n58F1ApX029109@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-08 15:02:11 +0000 (Mon, 08 Jun 2009)
New Revision: 19515

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19515&view=rev

Modified:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/EofRecovery.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IndentationHandler.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParserHistory.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java

Log:
dealing with block-closings, fixed errors

Changes:

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/EofRecovery.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/EofRecovery.java	2009-06-08 11:01:48 UTC (rev 19514)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/EofRecovery.java	2009-06-08 15:02:11 UTC (rev 19515)
@@ -5,39 +5,29 @@
 
 public class EofRecovery {
     
+    private static final int MAX_PARSE_STEPS=20;
+    private SGLR myParser;
     
-    public SGLR myParser;
+    public EofRecovery(SGLR sglr){
+        myParser=sglr;
+    }
     
-    public void enforceAccept(ArrayDeque<Frame> stackNodes) throws IOException {                 
+    public void enforceAccept(ArrayDeque<Frame> stackNodes) throws IOException { 
+        myParser.setEnforcePrefixAccept(true);
         myParser.activeStacks.clear();
         myParser.activeStacks.addAll(stackNodes);
         myParser.currentToken = -1;
         ArrayDeque<Frame> oldStacks=new ArrayDeque<Frame>();
         oldStacks.addAll(myParser.activeStacks);
-        while (myParser.activeStacks.size()>0) {
+        int nrOfSteps=0;
+        while (myParser.activeStacks.size()>0 && nrOfSteps<MAX_PARSE_STEPS) {
             //logStackNodes();
-            myParser.doParseStep();              
+            myParser.doParseStep(); 
+            nrOfSteps++;
             if(myParser.acceptingStack!=null)
-               break;
-            clearActiveStacks(oldStacks);            
-            oldStacks.addAll(myParser.activeStacks);
+               break;            
         }
-    }    
-
-    private void clearActiveStacks(ArrayDeque<Frame> oldStacks) {
-        ArrayDeque<Frame> clearedStacks=new ArrayDeque<Frame>();
-        for (Frame frame : myParser.activeStacks) {
-            boolean containedInOld=false;
-            for (Frame frameInOld : oldStacks) {                    
-                if(frameInOld.state.stateNumber==frame.state.stateNumber){
-                    containedInOld=true;
-                    break;
-                }
-            }
-            if(!containedInOld)
-                clearedStacks.add(frame);
-        }
-        myParser.activeStacks=clearedStacks;
+        myParser.setEnforcePrefixAccept(false); 
     }
     
     private void logStackNodes() {

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IndentationHandler.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IndentationHandler.java	2009-06-08 11:01:48 UTC (rev 19514)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IndentationHandler.java	2009-06-08 15:02:11 UTC (rev 19515)
@@ -9,6 +9,7 @@
     private boolean isInLeftMargin; 
     private int indentValue; 
     private boolean lineMarginFound;  
+    private boolean emptyLineFound;
     
     /*
      * Says whether the indenthandler is supposed to be in the left margin 
@@ -36,6 +37,10 @@
         indentValue = startIndent;
     }
     
+    public boolean emptyLineParsed() {
+        // TODO Auto-generated method stub
+        return emptyLineFound;
+    }   
     
     /*
      * The last inspected character marks the end of the margin 
@@ -56,6 +61,7 @@
         indentValue = 0;        
         setInLeftMargin(true);
         lineMarginFound =false;
+        emptyLineFound=false;
     }  
     
     /*
@@ -65,7 +71,8 @@
     {
         boolean oldLeftMargin = isInLeftMargin();
         updateLeftMargeFields(curTok);
-        lineMarginFound = oldLeftMargin && !isInLeftMargin();         
+        lineMarginFound = oldLeftMargin && !isInLeftMargin();   
+        emptyLineFound = oldLeftMargin && curTok=='\n';
     }    
     
     private void updateLeftMargeFields(int charValue) {        
@@ -86,5 +93,7 @@
             setInLeftMargin(false); //Indent value is set after first non-whitespace character of a line
             break;
         }
-    }   
+    }
+
+    
 }

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParserHistory.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParserHistory.java	2009-06-08 11:01:48 UTC (rev 19514)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParserHistory.java	2009-06-08 15:02:11 UTC (rev 19515)
@@ -83,6 +83,10 @@
         }
     }
     
+    public boolean constructAfterEmptyLine(){
+        return getConstructPoint().getLineNumber() > newLinePoints.get(indexConstruct-1).getLineNumber()+1;
+    }
+    
     private void keepNewLinePoint(SGLR myParser) {
         int indent = myParser.getIndentHandler().getIndentValue();
         IndentInfo newLinePoint= new IndentInfo(myParser.lineNumber, myParser.tokensSeen-1, indent);
@@ -132,9 +136,11 @@
         previousBigReduceIndex=0;
         int brLength=0;
         for (int i = 0; i < newLinePoints.size(); i++) {
-            if(newLinePoints.get(i).maxReduceLength()>brLength){
+            int reduceLength=newLinePoints.get(i).maxReduceLength();
+            if(reduceLength>brLength){
                 previousBigReduceIndex=bigReduceIndex;
                 bigReduceIndex=i;
+                brLength=reduceLength;
             }            
         }
         if(newLinePoints.size()>MIN_SIZE_NEW_LINE_POINTS-1)

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java	2009-06-08 11:01:48 UTC (rev 19514)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java	2009-06-08 15:02:11 UTC (rev 19515)
@@ -80,17 +80,20 @@
     private ParserHistory getHistory() {
         return myParser.getHistory();
     }
+    
+    
 
     /*
      * Recovers by skipping (parse as whitespace) part of the input string
      */
-    public boolean selectErroneousFragment() throws IOException {
+    public boolean selectErroneousFragment() throws IOException {       
+        
         getHistory().setBigReducePoints();
         getHistory().moveToLastConstruct();
         errorDetectionPosition=myParser.tokensSeen;
         recoverAction = SkipAction.SKIP_PREVIOUS;
         while (recoverySucceeded()==false && recoverAction != SkipAction.STOPPED) {
-            if(isDebugMode)
+            //if(isDebugMode)
                 Tools.debug("ACTION: "+recoverAction);
             switch (recoverAction) {
             case SKIP_PREVIOUS:
@@ -104,7 +107,7 @@
                 skipCurrentConstruct();
                 recoverAction=SkipAction.SKIP_SIBLINGS;                
                 break;
-            case SKIP_SIBLINGS:
+            case SKIP_SIBLINGS:  
                 skipChilds();
                 recoverAction=SkipAction.SKIP_PARENT;
                 break;
@@ -116,6 +119,7 @@
                     recoverAction = SkipAction.SKIP_CURRENT;            
                 break;
             case SKIP_FORWARD:
+                getHistory().moveToLastConstruct();
                 skipForward();
                 recoverAction = SkipAction.STOPPED;
                 break;
@@ -130,7 +134,9 @@
     }
 
     private boolean hasLowIndentation() {
-        return getHistory().getConstructPoint().getTokensSeen()<= getHistory().getPreviousBigReducePoint().getTokensSeen();
+        boolean smallTokenPos = getHistory().getConstructPoint().getTokensSeen() <= getHistory().getPreviousBigReducePoint().getTokensSeen();
+        boolean smallIndent = getHistory().getConstructPoint().getIndentValue() <= getHistory().getPreviousBigReducePoint().getIndentValue();
+        return smallTokenPos || smallIndent;
     }
 
     private boolean recoverySucceeded() {
@@ -140,14 +146,24 @@
     /*
      * Skips children around the error
      */
-    private void skipChilds() throws IOException {        
-        do {
+    private void skipChilds() throws IOException { 
+        boolean lowIndent = hasLowIndentation();
+        int forward=2;
+        boolean movedToPrev=true;        
+        do {            
+            movedToPrev=!getHistory().constructAfterEmptyLine() && getHistory().moveToPreviousConstruct();
+            if(movedToPrev)
+                forward+=2;            
             setSkipPoint(getHistory().getConstructPoint());
             int indent = skipPoint.getIndentValue();
-            while (!hasDedent(skipPoint.getIndentValue(), indent) && (recoverySucceeded()==false) && (myParser.currentToken != SGLR.EOF)) {
+            int childsSkipped=0;
+            while ((childsSkipped < forward || movedToPrev==false) && !hasDedent(skipPoint.getIndentValue(), indent) && (recoverySucceeded()==false) && (myParser.currentToken != SGLR.EOF)) {
                 doSkipRecoverStep();
-            }            
-        } while ((recoverySucceeded()==false) && (myParser.currentToken != SGLR.EOF)&& getHistory().moveToPreviousConstruct());      
+                childsSkipped++;                
+            }
+            if(lowIndent && startSkipPosition.getLineNumber()<getHistory().getBigReducePoint().getLineNumber()-10)
+                break;//not too far backwards
+        } while (movedToPrev && (recoverySucceeded()==false) && (myParser.currentToken != SGLR.EOF));      
     }
     
     private boolean hasDedent(int indentNew, int indentOld) {
@@ -198,9 +214,10 @@
         recoverlines.clear();
         if (isDebugMode) 
             Tools.debug("-- RecoverParse started -- ");        
-        myParser.doParseStep();
-        while(myParser.currentToken != SGLR.EOF && myParser.activeStacks.size() > 0) {                        
-            readNextToken();     
+        //myParser.doParseStep();
+        while(myParser.activeStacks.size() > 0) {                        
+            readNextToken(); 
+           // Tools.debug((char)myParser.currentToken);
             updateRecoverLinePoint(myParser);
             myParser.doParseStep();            
             if(meetsSuccessCriteriaForRecovery())
@@ -211,7 +228,7 @@
     private boolean meetsSuccessCriteriaForRecovery() {
         if(skipIndentHandler.lineMarginEnded() && getHistory().hasFinishedRecoverTokens())
             return inspectLinePoints();
-        return false;
+        return myParser.acceptingStack!=null;
     }
     
     /*
@@ -240,17 +257,42 @@
         getHistory().setTokenIndex(skipP.getTokensSeen()); 
         skipIndentHandler.setInLeftMargin(false);
         boolean endSkipFound=false;
-        while (endSkipFound==false) {
+        boolean childFound=false;
+        boolean prevLineEmpty=false;
+        while (endSkipFound==false) {            
             readNextToken(); 
-            if ((reachedErrorDetectionLine() && endOfConstruct(skipP)) || myParser.currentToken==SGLR.EOF) {
+            prevLineEmpty=skipIndentHandler.emptyLineParsed();
+            if(childFound(skipP))
+                childFound=true;
+            if (endOfConstruct(skipP) || myParser.currentToken==SGLR.EOF) {//reachedErrorDetectionLine() && 
                 endSkipFound=true;                 
                 int indent = skipIndentHandler.getIndentValue();                
                 skipPoint = new IndentInfo(-1, getHistory().getTokenIndex() -1, indent);
                 skipPoint.fillStackNodes(myParser.activeStacks);
             }            
-        }        
+        }
+        
+        if (childFound && skipP.getIndentValue() == skipPoint.getIndentValue() && !prevLineEmpty) {
+            while (myParser.currentToken != SGLR.EOF) {
+                readNextToken();
+                if (endOfConstruct(skipP)) {//next line has same or lower indent: previous line possible closing, thus skip.
+                    skipPoint.setTokensSeen(getHistory().getTokenIndex() - 1);
+                    skipPoint.setIndentValue(skipIndentHandler.getIndentValue());
+                    break;
+                }
+                if (childFound(skipP)) //higher indentation: probably no closing
+                    break;
+            }
+        }
+        getHistory().setTokenIndex(skipPoint.getTokensSeen());
+        //Tools.debug("skip try: "+getErrorFragment());
+       
     }
 
+    private boolean childFound(IndentInfo skipP) {
+        return skipIndentHandler.lineMarginEnded()&& skipIndentHandler.getIndentValue() > skipP.getIndentValue();
+    }
+
     private boolean endOfConstruct(IndentInfo skipP) {
         return (skipIndentHandler.lineMarginEnded() && skipIndentHandler.getIndentValue() <= skipP.getIndentValue());
     }



From mdjonge at xs4all.nl  Wed Jun 17 15:41:11 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Wed, 17 Jun 2009 13:41:11 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19526 - MaartjeDeJonge
	- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
Message-ID: <200906171339.n5HDdxg1006584@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-17 13:41:11 +0000 (Wed, 17 Jun 2009)
New Revision: 19526

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19526&view=rev

Added:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IndentationFilter.java
Modified:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/FineGrainedRepair.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Frame.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IndentInfo.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IndentationDisambiguator.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParserHistory.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoverDisambiguator.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java

Log:
fine-grained-recovery: SGLR explores recover branches with a maximum tolerance

Changes (first 1000 lines of the diffs):

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/FineGrainedRepair.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/FineGrainedRepair.java	2009-06-13 15:05:26 UTC (rev 19525)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/FineGrainedRepair.java	2009-06-17 13:41:11 UTC (rev 19526)
@@ -1,36 +1,183 @@
 package org.spoofax.jsglr;
 
 import java.io.IOException;
+import java.util.ArrayList;
+import aterm.ATerm;
 
-import org.spoofax.ArrayDeque;
-
 public class FineGrainedRepair {
     
     private SGLR myParser;
+    private ArrayList<IndentInfo> newLinePoints; 
+    private int indexLineRecovery;
+    private IndentationDisambiguator indentComparer;
+    private int endRecovery;
     
     private ParserHistory getHistory() {
         return myParser.getHistory();        
     }
     
     public FineGrainedRepair(SGLR sglr){
-        myParser=sglr;        
+        myParser=sglr;  
+        myParser.setMaxNrOfRecoveries(2);
+        myParser.setLengthAvoidCheck(50);
+        newLinePoints=new ArrayList<IndentInfo>();
+        indexLineRecovery=-1;
+        indentComparer=new IndentationDisambiguator();
     }
     
-    public void findRecoverBranch(int startIndex, int endIndex, ArrayDeque<Frame> stackNodes) throws IOException{
+    public void findRecoverBranch(ArrayList<IndentInfo> lines, int endTokenIndex) throws IOException{
+        endRecovery=endTokenIndex;
+        indexLineRecovery=-1;
+        newLinePoints=lines;
+        while (newLinePoints.size()>0) {
+            if(newLinePoints.get(newLinePoints.size()-1).getTokensSeen()>=endRecovery){
+                newLinePoints.remove(newLinePoints.size()-1);
+            }
+            else
+                break;
+        }
+        if(newLinePoints.size()==0)
+            return;         
+        myParser.setFineGrainedMode(true);       
         myParser.activeStacks.clear();
-        myParser.activeStacks.addAll(stackNodes);
-        getHistory().setTokenIndex(startIndex);
-        recoverParse(endIndex);
+        if(searchIndentDeviation()){
+            IndentInfo recoverLine = newLinePoints.get(indexLineRecovery); 
+            setParserForRecovery(recoverLine);            
+            myParser.setFineGrainedMode(false);
+            getHistory().readRecoverToken(myParser);            
+            myParser.doParseStep();            
+            myParser.setFineGrainedMode(true);
+            if(indexLineRecovery<newLinePoints.size()-1){
+                IndentInfo nextLine = newLinePoints.get(indexLineRecovery+1); 
+                recoverLineAndContinueParse(false, nextLine.getTokensSeen()+1);
+            }
+            else
+                recoverLineAndContinueParse(true, endRecovery);                
+        }
+        if (recoveryNotSucceeded()) {
+            forwardRecovery();
+        }
+        myParser.setFineGrainedMode(false);
     }
+
+    private void forwardRecovery() throws IOException {
+        if(lastLineRecovered())
+            return;    
+        setIndexOnLastLine();
+        IndentInfo recoverLine = newLinePoints.get(indexLineRecovery); 
+        setParserForRecovery(recoverLine);  
+        recoverLineAndContinueParse(true, endRecovery);                
+        if(recoveryNotSucceeded())
+            forwardRecovery();        
+    }
+
+    private boolean recoveryNotSucceeded() {
+        // TODO Auto-generated method stub
+        return myParser.activeStacks.size()==0;
+    }
+
+    private void setIndexOnLastLine() {             
+        if(newLinePoints.size()>1 && indexLineRecovery < newLinePoints.size()-2)
+            indexLineRecovery= newLinePoints.size()-2;
+        else
+            indexLineRecovery = newLinePoints.size()-1;
+    }
     
-    private void recoverParse(int endIndex) throws IOException{
-        myParser.setRecoverTolerance(3);
-        while (getHistory().getTokenIndex() < endIndex && myParser.activeStacks.size() > 0){
+    private void recoverLineAndContinueParse(boolean recoverEndOnNewLine, int lastRecoverToken) throws IOException{               
+        while (myParser.activeStacks.size() > 0 && !getHistory().hasFinishedRecoverTokens()){
             getHistory().readRecoverToken(myParser);
-            myParser.doParseStep();
-            //Tools.debug("Recover: "+(char)myParser.currentToken);             
+            //Tools.debug("Recover Fragment: "+(char)myParser.currentToken + getHistory().getTokenIndex()); 
+            myParser.doParseStep();            
+            if(myParser.currentToken=='\n'){
+                if(recoverEndOnNewLine){                   
+                    myParser.setFineGrainedMode(false);
+                }
+                if(getHistory().getTokenIndex() > getLastNewLinePoint().getTokensSeen() && (getHistory().getTokenIndex() <= endRecovery)){
+                    AddNewLinePoint();
+                }                
+            }
+            if(getHistory().getTokenIndex() > lastRecoverToken+1){                 
+                myParser.setFineGrainedMode(false);
+            }                 
         }
-        myParser.setRecoverTolerance(0);
+        myParser.setFineGrainedMode(false);
     }
+    
+    private void AddNewLinePoint() {
+        // TODO Auto-generated method stub
+        IndentInfo newLinePoint = new IndentInfo(-1, getHistory().getTokenIndex(), -1);
+        newLinePoint.fillStackNodes(myParser.activeStacks);
+        newLinePoints.add(newLinePoint);        
+    }
+    
+    private IndentInfo getLastNewLinePoint() {
+        IndentInfo recoverStart;
+        recoverStart= newLinePoints.get(newLinePoints.size()-1);
+        return recoverStart;
+    }
+    
+    private void setParserForRecovery(IndentInfo recoverStart) {        
+        myParser.setFineGrainedMode(true);
+        myParser.activeStacks.addAll(recoverStart.getStackNodes());
+        //myParser.setRecoverStartPos(recoverStart.getTokensSeen());
+        getHistory().setTokenIndex(recoverStart.getTokensSeen());
+    }
 
+    private boolean searchIndentDeviation() {
+        if (newLinePoints.size()<2)
+            return false;        
+        int startTok=newLinePoints.get(0).getTokensSeen();
+        for (int i = 1; i < newLinePoints.size(); i++) {
+            IndentInfo line =newLinePoints.get(i);            
+            if(line.structureStartPosition()>startTok){            
+                Link lnk = line.getReductionLink();
+                IParseNode pNode =lnk.label;
+                if(pNode!=null){
+                    ATerm t = pNode.toParseTree(myParser.getParseTable());                    
+                    int beginIndent = findBeginIndent(line);                    
+                    indentComparer.evaluateIndentation(t, beginIndent);
+                    int devValue=indentComparer.getIndentDeviationListElements();
+                    if(devValue>0){
+                        int errorLineIndex=findIndexLine(line.structureStartPosition() + indentComparer.getPosFirstErrorListElement());
+                        //debugErrorLine(line, beginIndent, devValue, errorLineIndex);
+                        indexLineRecovery=errorLineIndex;
+                        return true;
+                    }
+                }
+            }
+        }
+        return false;
+    }
+
+    private void debugErrorLine(IndentInfo line, int beginIndent, int devValue,
+            int errorLineIndex) {
+        IndentInfo errorLine = newLinePoints.get(errorLineIndex);
+        Tools.debug("Start-Indent: "+ beginIndent);
+        Tools.debug("Indent: "+ line.getIndentValue());
+        Tools.debug("Line: "+ line.getLineNumber());
+        Tools.debug("Score: "+devValue);
+        Tools.debug("Error-Line: "+ errorLine.getLineNumber());                
+        //Tools.debug(t);
+    }
+    
+    private int findBeginIndent(IndentInfo indInf){ 
+        int i = findIndexLine(indInf.structureStartPosition());
+        if(i>=0)
+            return newLinePoints.get(i).getIndentValue();
+        return -1;
+    }
+    
+    private int findIndexLine(int tokPos){        
+        for (int i = newLinePoints.size()-1; i >= 0; i--) {
+            IndentInfo lineInList=newLinePoints.get(i);
+            if(lineInList.getTokensSeen()<= tokPos)
+                return i;
+        }        
+        return -1;
+    }
+
+    private boolean lastLineRecovered() {        
+        return indexLineRecovery>=newLinePoints.size()-1;
+    }    
+   
 }

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Frame.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Frame.java	2009-06-13 15:05:26 UTC (rev 19525)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Frame.java	2009-06-17 13:41:11 UTC (rev 19526)
@@ -21,21 +21,13 @@
     public static int framesCreated =0; //MJ: for testing
 
     public final State state;
-    
-    private int minRecoverCount;
 
     // Using a Vector and regular iteration takes parsing of file-test from 1100ms (min) to 2020ms (max)!
     // TODO: Just use an ArrayList for Frame.steps?
     //       which should have better performance than the obsolete, synchronized Vector classs
     
-    public int getMinRecoverCount() {
-        return minRecoverCount;
-    }
+    
 
-    public void setMinRecoverCount(int minRecoverCount) {
-        this.minRecoverCount = minRecoverCount;
-    }
-
     private Link[] steps;
     private int stepsCount;
 
@@ -47,7 +39,7 @@
         steps = new Link[20];
         stepsCount = 0;
         framesCreated +=1; //MJ: for testing 
-        minRecoverCount=-1;
+        
     }
 
     public boolean allLinksRejected() {

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IndentInfo.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IndentInfo.java	2009-06-13 15:05:26 UTC (rev 19525)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IndentInfo.java	2009-06-17 13:41:11 UTC (rev 19526)
@@ -2,6 +2,8 @@
 
 import org.spoofax.ArrayDeque;
 
+import aterm.ATerm;
+
 /*
  * Should be created before parsing the first character of a line
  * Keeps information about indentation of a line.
@@ -61,6 +63,13 @@
         stackNodes=new ArrayDeque<Frame>();
     }
 
+    public IndentInfo() {
+        lineNumber=-1;
+        tokensSeen=-1;
+        indentValue=-1;
+        stackNodes=new ArrayDeque<Frame>();
+    }
+
     /*
      * Calculates the biggest reduce belonging to this backtrack point.
      */
@@ -82,4 +91,20 @@
     {
         return tokensSeen - maxReduceLength();        
     }
+    
+    public Link getReductionLink() {
+        int maxPathLength = -1;
+        Link result=null;
+        for (Frame activeStack : stackNodes) {
+            for (Path p : activeStack.findAllPaths(3)) {//3=> shifted_LO, reduced_LO, ReducedCodeFragment
+                int length = p.getLength(); //length => total_length, p => reduce_length, p.p => layout_length (-shift), p.p.p => shift_length (=1)                 
+                if(length > maxPathLength){
+                    maxPathLength = length;
+                    if(p.parent.label!=null)
+                        result =p.parent.lnk;
+                }
+            }
+        }
+        return result;
+    }    
 }

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IndentationDisambiguator.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IndentationDisambiguator.java	2009-06-13 15:05:26 UTC (rev 19525)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IndentationDisambiguator.java	2009-06-17 13:41:11 UTC (rev 19526)
@@ -31,6 +31,14 @@
     private int indentDeviationListElements;// Sum differences in indentation of list elements, calculated for the root term.
     private int indentCongruenceOfListElements; //Number of congruent list elements  
     private int indentDeviationClosingTokens; 
+   
+    public int getPosFirstErrorListElement() {
+        return posFirstErrorListElement;
+    }
+
+    private int posFirstErrorListElement;
+    private int charCount;       
+    
   
     /*
      * Gets the indent deviation of closing tokens with respect to the first child
@@ -67,6 +75,8 @@
         indentDeviationListElements = 0;
         indentCongruenceOfListElements = 0;
         indentDeviationClosingTokens=0;
+        posFirstErrorListElement=-1;        
+        charCount=0;
         myIndentHandler.initEvaluationVariables();        
     }
     
@@ -126,6 +136,7 @@
             ATermInt tInt = (ATermInt)t;
             int charValue = tInt.getInt();            
             myIndentHandler.updateIndentation(charValue);
+            charCount++;
             //Tools.debug((char)charValue + "("+myIndentHandler.getIndentValue()+")");
         }
         //calculate score by depth-first traversal
@@ -135,7 +146,8 @@
             ATermList contents = termAt(t, 1);           
             int prevSiblingIdentValue = -1; 
             int firstChildIndentValue=-1;            
-            for (int i = 0; i < contents.getLength(); i++) {                
+            for (int i = 0; i < contents.getLength(); i++) { 
+                //Tools.debug("child" +i);
                 helperIndentHandler.setIndentValue(myIndentHandler.getIndentValue());
                 int indentCurrentChild =findStartIndent(contents.elementAt(i), helperIndentHandler);
                 if (indentCurrentChild >= 0 && prevSiblingIdentValue >=0) {
@@ -144,8 +156,14 @@
                         //Tools.debug("current indent: " + indentCurrentChild);
                         //Tools.debug("diff indent: " + diff);
                         indentDeviationListElements += Math.abs(diff);
-                        if (diff == 0)
-                            indentCongruenceOfListElements += 1;
+                        if(diff!=0 && posFirstErrorListElement==-1){
+                            posFirstErrorListElement=charCount;
+                            if(myIndentHandler.isInLeftMargin()||myIndentHandler.lineMarginEnded())
+                                posFirstErrorListElement-= myIndentHandler.getIndentValue();
+                        }
+                        if (diff == 0){
+                            indentCongruenceOfListElements += 1;                            
+                        }
                     }  
                     else if(isLiteralProduction(contents.elementAt(i))){   //(?)i==contents.getLength()-1 &&
                         //Tools.debug(" lit prod ");

Added: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IndentationFilter.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IndentationFilter.java	                        (rev 0)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/IndentationFilter.java	2009-06-17 13:41:11 UTC (rev 19526)
@@ -0,0 +1,35 @@
+package org.spoofax.jsglr;
+
+import static org.spoofax.jsglr.Term.applAt;
+import static org.spoofax.jsglr.Term.termAt;
+import aterm.ATerm;
+import aterm.ATermAppl;
+import aterm.ATermInt;
+import aterm.ATermList;
+import aterm.pure.ATermListImpl;
+
+public class IndentationFilter {
+    
+    public static void resolveAmbiguitiesByIndentation(ATerm node)
+    {
+        if (node.getChildCount()>1)               
+        {
+            ATermList contents;
+            if ("amb".equals(((ATermAppl) node).getName())){
+                contents = termAt(node, 0);
+            }
+            else{
+                contents = termAt(node, 1);
+            }  
+            for (int i = 0; i < contents.getLength(); i++) {
+                resolveAmbiguitiesByIndentation(contents.elementAt(i));
+            }
+        } 
+
+        if ("amb".equals(((ATermAppl) node).getName())){
+            ATermListImpl ambs = termAt(node, 0);
+            node = ambs.elementAt(0);
+        }        
+    }
+
+}

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParserHistory.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParserHistory.java	2009-06-13 15:05:26 UTC (rev 19525)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParserHistory.java	2009-06-17 13:41:11 UTC (rev 19526)
@@ -10,7 +10,16 @@
     
     private int previousBigReduceIndex;
     private int bigReduceIndex;    
-    private int indexConstruct;    
+    private int indexConstruct; 
+    
+    public int getIndexConstruct() {
+        return indexConstruct;
+    }
+
+    public void setIndexConstruct(int indexConstruct) {
+        this.indexConstruct = indexConstruct;
+    }
+
     private ArrayList<IndentInfo> newLinePoints;      
     private char[] recoverTokenStream;
     private int recoverTokenCount;
@@ -169,6 +178,14 @@
         return newLinePoints.get(previousBigReduceIndex);
     } 
     
+    public void moveToBigReducePoint() {
+        indexConstruct=bigReduceIndex;
+    }   
+    
+    public void moveToPreviousBigReducePoint() {
+        indexConstruct = previousBigReduceIndex;
+    } 
+    
     public boolean moveToParentConstruct() {        
         int loopIndex = newLinePoints.size()-2;
         while ( loopIndex >= 0) {
@@ -222,6 +239,31 @@
         newLinePoints.addAll(recoverNewLinePoints);        
     }
     /*
+    //TODO: StartSkip as index
+    public ArrayList<IndentInfo> getRecentHistory(int fromTokensSeen, int toTokensSeen){
+        ArrayList<IndentInfo> recentHistory=new ArrayList<IndentInfo>();
+        int recentStart=0;
+        int recentEnd=newLinePoints.size();
+        for (int i = newLinePoints.size()-1; i > 0; i--) {
+            int toksSeen=newLinePoints.get(i).getTokensSeen();
+            if(toksSeen>=toTokensSeen)
+                recentEnd=i;
+            if(toksSeen<=fromTokensSeen){
+                recentStart=i;
+                break;
+            }
+        }        
+        recentHistory.addAll(newLinePoints.subList(recentStart, recentEnd));
+        return recentHistory;
+    }*/
+
+    public ArrayList<IndentInfo> getLinesFrom(int startIndex) {
+        ArrayList<IndentInfo> recentHistory=new ArrayList<IndentInfo>();
+        recentHistory.addAll(newLinePoints.subList(startIndex, newLinePoints.size()));
+        return recentHistory;
+    }
+    
+    /*
     ///////////////////////////////// LOG /////////////////////////////////////////////////////////////////
     public void logBigReductionList() {        
         for (int i = 0; i < newLinePoints.size(); i++) {

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoverDisambiguator.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoverDisambiguator.java	2009-06-13 15:05:26 UTC (rev 19525)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoverDisambiguator.java	2009-06-17 13:41:11 UTC (rev 19526)
@@ -3,33 +3,43 @@
 public class RecoverDisambiguator {
     
     private ParseTable parseTable;
+    static int testCount=0;
     
     public RecoverDisambiguator(ParseTable pt){
-        parseTable=pt;
+        parseTable=pt;        
     }
     
-    public void handleAmbiguity(int avoidCount_t, IParseNode t, Link nl){
-        assert !(nl.avoidCount == 0 && avoidCount_t == 0)
-                : "ambiguity without recover productions should not be handled by RecoverAlgorithm";
+    public void handleAmbiguity(int avoidCount_t, IParseNode t, Link nl){  
+        testCount++;
+        if(nl.isRejected()){
+            setLabel(0, t, nl);
+            return;
+        }  
         
+        /*    
         //A. Choose branch without recover productions
         boolean hasRecoverFreeBranch = trySelectNoRecoveries(avoidCount_t, t, nl);
         if(hasRecoverFreeBranch)
             return;
+        /*
         //B. Disambiguate by indentation
+        long start = System.currentTimeMillis();        
         boolean hasIndentPreference = trySelectByIndentation(avoidCount_t, t, nl);
+        long durationIndentDisamb = System.currentTimeMillis()-start;
+        //Tools.debug("Disamb-time: "+ durationIndentDisamb);
         if(hasIndentPreference){
             return;
-        }
+        }*/
         //C. choose branche with smallest number of avoids
         trySelectOnAvoidCount(avoidCount_t, t, nl);
+        
     }
     
     private boolean trySelectOnAvoidCount(int avoidCount_t, IParseNode t, Link nl) {
         if(avoidCount_t == nl.avoidCount)
             return false;
         if(avoidCount_t < nl.avoidCount)
-            setLabel(0, t, nl);
+            setLabel(avoidCount_t, t, nl);
         return true;
     }
     

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java	2009-06-13 15:05:26 UTC (rev 19525)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java	2009-06-17 13:41:11 UTC (rev 19526)
@@ -23,8 +23,12 @@
         
         boolean skipSucceeded = skipRecovery.selectErroneousFragment();
         mySGLR.acceptingStack=null;
+        long startSkip=System.currentTimeMillis();
         String errorFragment = skipRecovery.getErrorFragment();
-        Tools.debug(errorFragment); 
+        long durationSkip=System.currentTimeMillis()-startSkip;
+        Tools.debug("Skip time: "+ durationSkip);
+        Tools.debug(errorFragment);
+        
         //BRIDGE REPAIR
         tryBridgeRepair(errorFragment);
         if(recoverySucceeded()){
@@ -32,8 +36,13 @@
             return;
         }
         Tools.debug("Bridge Repair Failed");
-        //FINEGRAINED REPAIR        
-        tryFineGrainedRepair();                   
+        
+        //FINEGRAINED REPAIR 
+        long startFineGrained=System.currentTimeMillis();
+        tryFineGrainedRepair();       
+        long durationFG=System.currentTimeMillis()-startFineGrained;
+        Tools.debug("Fine-Grained time: "+ durationFG);
+        //Tools.debug("Disambiguations: " +  RecoverDisambiguator.testCount);
         if(recoverySucceeded()){
             Tools.debug("Fine-Grained Repair Succeeded");
             return;
@@ -41,25 +50,23 @@
         Tools.debug("FineGrained Repair Failed");
         //WHITESPACE REPAIR
         if (skipSucceeded) {            
-            whiteSpaceParse(errorFragment);
-            assert recoverySucceeded() : "White space parse unexpectly fails";
+            whiteSpaceParse(errorFragment); 
+            if(recoverySucceeded())
+                Tools.debug("WhiteSpace Repair Succeeded");
+            else
+                Tools.debug("WhiteSpace Repair unexpectly fails");
         }
         //FORCE PREFIX ACCEPT
-        else {
-            Tools.debug("Enforcing Accepting Stack");
-            mySGLR.setEnforcePrefixAccept(true);
-            forcingParse(); 
-            mySGLR.setEnforcePrefixAccept(false);
-            assert recoverySucceeded() : "'Force-Accepting-Stack' unexpectly fails"; 
-        }               
+        else {            
+            EofRecovery eofR = new EofRecovery(mySGLR);
+            eofR.enforceAccept(getHistory().getBigReducePoint().getStackNodes());
+            if(recoverySucceeded())
+                Tools.debug("Enforcing Accepting Stack - Succeeded");
+            else
+                Tools.debug("Enforcing Accepting Stack - Failed");
+        }
     }
     
-    private void forcingParse() throws IOException{
-        EofRecovery eofR = new EofRecovery();        
-        eofR.myParser=mySGLR;
-        eofR.enforceAccept(getHistory().getBigReducePoint().getStackNodes());
-    }
-
     private boolean recoverySucceeded() {
         return mySGLR.activeStacks.size()>0 || mySGLR.acceptingStack!=null;
     }
@@ -72,8 +79,7 @@
 
     private void tryFineGrainedRepair() throws IOException {
         FineGrainedRepair fineGrained=new FineGrainedRepair(mySGLR);            
-        fineGrained.findRecoverBranch(skipRecovery.getStartSkipPosition().getTokensSeen(), skipRecovery.getSkipPoint().getTokensSeen(), skipRecovery.getStartSkipPosition().getStackNodes());
-        parseRemainingTokens();
+        fineGrained.findRecoverBranch(skipRecovery.getSkippedLines(), skipRecovery.getEndSkipPosition());        
     }
 
     private void tryBridgeRepair(String errorFragment) throws IOException {
@@ -105,7 +111,7 @@
     
     private void tryParsing(String fragment, boolean asLayout) throws IOException{
         int indexFragment = findFirstNonLayoutToken(fragment);        
-        while(indexFragment<fragment.length() && recoverySucceeded()) {                        
+        while(indexFragment<fragment.length() && mySGLR.activeStacks.size()>0) {                        
             mySGLR.currentToken=fragment.charAt(indexFragment);
             indexFragment++;
             if(!asLayout)
@@ -116,8 +122,8 @@
     }
     
     public void parseRemainingTokens() throws IOException{
-        getHistory().setTokenIndex(skipRecovery.getSkipPoint().getTokensSeen());
-        while(!getHistory().hasFinishedRecoverTokens()&& recoverySucceeded()){        
+        getHistory().setTokenIndex(skipRecovery.getEndSkipPosition());
+        while(!getHistory().hasFinishedRecoverTokens() && mySGLR.activeStacks.size()>0){        
             getHistory().readRecoverToken(mySGLR);
             //Tools.debug("***"+(char)mySGLR.currentToken);
             mySGLR.doParseStep();            

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-06-13 15:05:26 UTC (rev 19525)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-06-17 13:41:11 UTC (rev 19526)
@@ -89,10 +89,18 @@
     private int reductionCount;
 
     private PushbackInputStream currentInputStream;
-
-    //Keeps track of the indentation for each line
+   
+    //Creates indent- and dedent- tokens
+    //Meant for parsing of indentation based languages
+    //TODO: still under construction
+    private IndentTokenizer indentTokenHandler;
+    
+    // ------------------------------------- Integrated recovery  ------------------------
+  //Keeps track of the indentation for each line
     private IndentationHandler indentHandler;
     
+    private ParserHistory history;
+    
     private RecoveryConnector recoverIntegrator;
     
     private boolean useIntegratedRecovery;
@@ -102,24 +110,45 @@
         return indentHandler;
     }
     
-    private ParserHistory history;
-    
     public ParserHistory getHistory() {
         return history;
-    }
-
-    private RecoverDisambiguator recoverDisambiguator;
+    }    
     
+    // -------------------- forcing accept recovery --------------------------------
     private boolean enforcePrefixAccept;
 
     public void setEnforcePrefixAccept(boolean forcingParse) {
         this.enforcePrefixAccept = forcingParse;
     }
+    
+    //-------------------------- fine-grained recovery ----------------------------------
+    private boolean fineGrainemode;
+    private int recoverTolerance;
+    private ArrayDeque<Frame> recoveryActor;    
+    private int maxNrOfRecoveries; //max number of recoveries allowed fragment during fine-grained recovery
+    private RecoverDisambiguator recoverDisambiguator;
+    private boolean recoveryWorkAround;
+    private int lengthAvoidCheck; //checks number of avoids over restricted fragment
 
-    //Creates indent- and dedent- tokens
-    //Meant for parsing of indentation based languages
-    //TODO: still under construction
-    private IndentTokenizer indentTokenHandler;
+    public void setMaxNrOfRecoveries(int maxNrOfRecoveries) {
+        this.maxNrOfRecoveries = maxNrOfRecoveries;
+    }
+
+    public void setLengthAvoidCheck(int lengthAvoidCheck) {
+        this.lengthAvoidCheck = lengthAvoidCheck;
+    }
+
+    public void setRecoveryTestingWorkAround(boolean b) {
+        recoveryWorkAround = b;        
+    }
+    
+    public void setFineGrainedMode(boolean b) {
+        fineGrainemode=b; 
+        if(fineGrainemode)
+            recoverTolerance=maxNrOfRecoveries;
+        else
+            recoverTolerance=0;
+    }
        
     SGLR() {
         basicInit(null);
@@ -130,9 +159,7 @@
         assert parseTable != null;
         // Init with a new factory for both serialized or BAF instances.
         this.parseTable = parseTable;
-        basicInit(pf);
-
-        
+        basicInit(pf);        
     }
     
     public void setRecoverHandler(RecoverAlgorithm recoverHandler) {
@@ -169,6 +196,7 @@
         activeStacks = new ArrayDeque<Frame>();     
         forActor = new ArrayDeque<Frame>();
         forActorDelayed = new ArrayDeque<Frame>();
+        recoveryActor = new ArrayDeque<Frame>();
         forShifter = new ArrayDeque<ActionState>();
 
         // FIXME This is *wrong*: need to set the input string size instead
@@ -299,6 +327,8 @@
     public void doParseStep() throws IOException {               
         parseCharacter(); //applies reductions on active stack structure and fills forshifter                      
         shifter(); //renewes active stacks with states in forshifter
+        if(useIntegratedRecovery && fineGrainemode)
+            recoverTolerance=maxNrOfRecoveries;
     }    
 
     private void initParseVariables(InputStream fis) {        
@@ -383,6 +413,7 @@
         ArrayDeque<Frame> actives = new ArrayDeque<Frame>(activeStacks); // FIXME avoid garbage        
         clearForActorDelayed(false);
         clearForShifter(false);
+        recoveryActor.clear();
         while (actives.size() > 0 || forActor.size() > 0) {
             Frame st;
             st = pickStackNodeFromActivesOrForActor(actives);
@@ -391,8 +422,18 @@
             }
             
             if(actives.size() == 0 && forActor.size() == 0) {
+                reduceRecoverOnly=false;
                 fillForActorWithDelayedFrames(); //Fills foractor, clears foractor delayed
             }
+            if(fineGrainemode && actives.size() == 0 && forActor.size() == 0) {
+                if(recoverTolerance<=0 || recoveryActor.size()==0){
+                    reduceRecoverOnly=false;
+                    return;
+                }
+                fillForActorWithRecoverFrames(); //Fills foractor, clears recover actor
+                recoverTolerance-=1;
+                reduceRecoverOnly=true;
+            }
                 
         }
     }
@@ -404,6 +445,11 @@
         forActor = forActorDelayed;
         forActorDelayed = new ArrayDeque<Frame>(); // FIXME: avoid garbage
     }
+    
+    private void fillForActorWithRecoverFrames() {       
+        forActor = recoveryActor;
+        recoveryActor = new ArrayDeque<Frame>(); // FIXME: avoid garbage
+    }
 
     private Frame pickStackNodeFromActivesOrForActor(ArrayDeque<Frame> actives) {
         Frame st;
@@ -428,9 +474,11 @@
             if(enforcePrefixAccept)
                 currentToken = action.getFirstCharValue();
             if (action.accepts(currentToken)) {
-                for (ActionItem ai : action.getActionItems()) {
+                for (ActionItem ai : action.getActionItems()) {                    
                     switch (ai.type) {
                         case ActionItem.SHIFT: {
+                            if(reduceRecoverOnly)
+                                break;
                             Shift sh = (Shift) ai;
                             ActionState actState = new ActionState(st, parseTable.getState(sh.nextState));
                             actState.currentToken = currentToken;                            
@@ -454,6 +502,8 @@
                             break;
                         }
                         case ActionItem.ACCEPT: {
+                            if(reduceRecoverOnly)
+                                break;
                             if (!st.allLinksRejected()) {
                                 acceptingStack = st;
                                 if (Tools.logging) {
@@ -516,7 +566,7 @@
     }
 
     private void doReductions(Frame st, Production prod) throws IOException {
-        if(!violatesRecoverTolerance(st, prod)){
+        if(recoverModeOk(st, prod)){
             List<Path> paths = st.findAllPaths(prod.arity);         
             logBeforeDoReductions(st, prod, paths.size());
             reduceAllPaths(prod, paths);
@@ -524,12 +574,19 @@
         }
     }
 
-    private boolean violatesRecoverTolerance(Frame st, Production prod) {
-        return useIntegratedRecovery && prod.status == Reduce.AVOID && st.getMinRecoverCount()>= recoverTolerance;
+    private boolean reduceRecoverOnly;
+    
+    private boolean recoverModeOk(Frame st, Production prod) {
+        if(useIntegratedRecovery && prod.status == Reduce.AVOID && !reduceRecoverOnly && recoverTolerance>0){
+           //if(findStack(recoveryActor, st.state)==null)
+            if(!recoveryActor.contains(st))
+                recoveryActor.addFirst(st);
+        }
+        return (!useIntegratedRecovery || ((prod.status == Reduce.AVOID)==reduceRecoverOnly));
     }
     
     private void doLimitedReductions(Frame st, Production prod, Link l) throws IOException { //Todo: Look add sharing code with doReductions
-        if(!violatesRecoverTolerance(st, prod)){
+        if(recoverModeOk(st, prod)){
             List<Path> paths = st.findLimitedPaths(prod.arity, l); //find paths containing the link         
             logBeforeLimitedReductions(st, prod, l, paths);        
             reduceAllPaths(prod, paths);
@@ -565,16 +622,15 @@
 
     private void reducer(Frame st0, State s, Production prod, List<IParseNode> kids, Path path) throws IOException {
         int length = path.getLength();        
-        int numberOfAvoids = calcAvoidCount(prod, path);         
+        int numberOfAvoids = calcAvoidCount(prod, path); 
+        if(fineGrainemode && calcAvoidCountResricted(prod, path) > maxNrOfRecoveries)
+            return;
         IParseNode t = prod.apply(kids);
         Frame st1; 
         Link nl;
         if(prod.status == Reduce.AVOID){
-            if(useIntegratedRecovery && numberOfAvoids>recoverTolerance)
-            {
-                return;
-            }
-            else{
+            if(!useIntegratedRecovery)
+            {                
                 recoverHandler.handleRecoverProduction(st0, s, length, numberOfAvoids, t);
                 if(recoverHandler.haltsOnRecoverProduction(st0))
                     return;
@@ -611,21 +667,27 @@
         }
     }
     
-    private void handleAmbiguity(int numberOfAvoids, IParseNode t, Link nl) {        
+    private void handleAmbiguity(int numberOfAvoids, IParseNode t, Link nl) throws IOException {        
         //if both branches contain no recover productions, create an Amb node.
         if(numberOfAvoids == 0 && nl.avoidCount==0){
-            createAmbNode(t, nl);
+            if (!recoveryWorkAround) {
+                createAmbNode(t, nl);
+            }
             return;
         }
         // old recovery method
-        if(!useIntegratedRecovery)
+        if(!useIntegratedRecovery){
             recoverHandler.handleAmbiguity(numberOfAvoids, t, nl);
+            return;
+        }
         // integrated recovery method
-        if(useIntegratedRecovery && enforcePrefixAccept)
+        if(enforcePrefixAccept)
             return; //not interested in ambiguity!
         else{
+            int nlOld = nl.avoidCount;
             recoverDisambiguator.handleAmbiguity(numberOfAvoids, t, nl);
-            //return; //MJ: disambiguate by avoidCount, indentation ..                      
+            if(nl.avoidCount < nlOld)
+                actorOnActiveStacksOverNewLink(nl);
         }                
     }
 
@@ -703,6 +765,15 @@
         return numberOfAvoids;
     }
     
+    private int calcAvoidCountResricted(Production prod, Path path) {
+        int numberOfAvoids = path.getAvoidCount(lengthAvoidCheck);
+        if(prod.status == Reduce.AVOID)
+        {
+            numberOfAvoids +=1;
+        }
+        return numberOfAvoids;
+    }
+    
     private boolean inReduceStacks(Queue<Frame> q, Frame frame) {
         if(Tools.tracing) {
             TRACE("SG_InReduceStacks() - " + frame.state.stateNumber);
@@ -882,22 +953,8 @@
        
 
       
-    private int recoverTolerance;
+      
     
-    public void setRecoverTolerance(int recoverTolerance) {
-        this.recoverTolerance = recoverTolerance;
-    }    
-    
-    private void setFrameAvoidCount(Frame parent, Frame frame, Path p, int backWardsLength){
-        int avoidValue = p.getAvoidCount(backWardsLength);
-        if(p.getLength() < backWardsLength)
-            avoidValue+=parent.getMinRecoverCount();
-        if(frame.getMinRecoverCount()<0 || frame.getMinRecoverCount()> avoidValue)
-            frame.setMinRecoverCount(avoidValue);
-        if(frame.getMinRecoverCount()<0)
-            frame.setMinRecoverCount(0);
-    }
-    
     ////////////////////////////////////////////////////// Log functions ///////////////////////////////////////////////////////////////////////////////
     
     static void TRACE(String string) {
@@ -1248,6 +1305,15 @@
         return stackPaths.toArray(new String[stackPaths.size()]);
     }  
     
+    private String[] viewRecoverActor(){
+        List<String> stackPaths = new ArrayList<String>();
+        for (Frame actNode : recoveryActor) {
+            List<String> testMJ = actNode.getStackPaths("", false);
+            stackPaths.addAll(testMJ);
+        }
+        return stackPaths.toArray(new String[stackPaths.size()]);
+    }  
+    
     private String[] viewStackObject()
     {
         return viewStackObject(false);
@@ -1261,5 +1327,8 @@
     private void mjTesting() {        
         Tools.debug((char)currentToken); 
     }
+
+     
     
+    
 }

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java	2009-06-13 15:05:26 UTC (rev 19525)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java	2009-06-17 13:41:11 UTC (rev 19526)
@@ -16,12 +16,11 @@
         SKIP_FORWARD,
         STOPPED        
     }    
-    
+    private int startSkipIndex;
     private SGLR myParser;
     private IndentationHandler skipIndentHandler;    
     private IndentInfo skipPoint;
-    private SkipAction recoverAction;
-    private IndentInfo startSkipPosition;
+    private SkipAction recoverAction;    
     private int errorDetectionPosition;    
     protected boolean isDebugMode;
     private ArrayList<IndentInfo> recoverlines;   
@@ -29,22 +28,27 @@
     /*
      * 
      */
-    public IndentInfo getSkipPoint() {
-        return skipPoint;
+    public int getEndSkipPosition() {
+        return skipPoint.getTokensSeen();
     }
     
     /*
      * Parser state before the skipping
      */
     public IndentInfo getStartSkipPosition() {
-        return startSkipPosition;
+        return getHistory().getLine(startSkipIndex);
     }
     
+    public ArrayList<IndentInfo> getSkippedLines() {
+        return getHistory().getLinesFrom(startSkipIndex);
+    }
+    
     /*
-     * Skipped fragment containing errors
+     * Skipped fragment containing errors, including preceding indentation
      */
-    public String getErrorFragment() {       
-        return getHistory().getFragment(startSkipPosition.getTokensSeen(), skipPoint.getTokensSeen()-1);
+    public String getErrorFragment() { 
+        int tokIndexLine=getHistory().getTokensSeenStartLine(getStartSkipPosition().getTokensSeen());
+        return getHistory().getFragment(tokIndexLine, skipPoint.getTokensSeen()-1);
     }
     
     
@@ -72,8 +76,8 @@
 
     private void initialize() {

(90 diff lines omitted)


From mdjonge at xs4all.nl  Tue Jun 23 11:55:44 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Tue, 23 Jun 2009 09:55:44 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19528 - MaartjeDeJonge
	- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
Message-ID: <200906230954.n5N9sPpL020045@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-23 09:55:43 +0000 (Tue, 23 Jun 2009)
New Revision: 19528

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19528&view=rev

Modified:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java

Log:
avoid endless looping

Changes:

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-06-22 11:46:41 UTC (rev 19527)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-06-23 09:55:43 UTC (rev 19528)
@@ -291,7 +291,7 @@
             
             if(useIntegratedRecovery && acceptingStack==null){
                 recoverIntegrator.recover();                 
-                if(acceptingStack==null)
+                if(acceptingStack==null && activeStacks.size()>0)
                     return sglrParse(startSymbol);
             }
             /*



From mdjonge at xs4all.nl  Tue Jun 23 18:24:35 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Tue, 23 Jun 2009 16:24:35 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19537 - MaartjeDeJonge
	- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
Message-ID: <200906231623.n5NGNGGm024674@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-23 16:24:35 +0000 (Tue, 23 Jun 2009)
New Revision: 19537

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19537&view=rev

Modified:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java

Log:
option: useStructureRecoveryWithoutBridgeParser

Changes:

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java	2009-06-23 14:12:49 UTC (rev 19536)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java	2009-06-23 16:24:35 UTC (rev 19537)
@@ -9,10 +9,22 @@
     private IRecoveryParser recoveryParser;
     private StructureRecovery skipRecovery;
     
+    private boolean useBridgeParser;
+    
+    public void setUseBridgeParser(boolean useBridgeParser) {
+        this.useBridgeParser = useBridgeParser;
+    }
+
     public RecoveryConnector(SGLR parser, IRecoveryParser recoveryParser){
-        mySGLR=parser;
-        this.recoveryParser = recoveryParser;
+        mySGLR=parser;        
         skipRecovery = new StructureRecovery(mySGLR);
+        if(recoveryParser!=null){
+            this.recoveryParser = recoveryParser;
+            useBridgeParser=true;
+        }
+        else
+            useBridgeParser=false;
+        
     }
     
     private ParserHistory getHistory() {
@@ -30,13 +42,15 @@
         Tools.debug(errorFragment);
         
         //BRIDGE REPAIR
-        tryBridgeRepair(errorFragment);
-        if(recoverySucceeded()){
-            Tools.debug("Bridge Repair Succeeded");
-            return;
+        if(useBridgeParser){
+            
+            tryBridgeRepair(errorFragment);
+            if(recoverySucceeded()){
+                Tools.debug("Bridge Repair Succeeded");
+                return;
+            }
+            Tools.debug("Bridge Repair Failed");
         }
-        Tools.debug("Bridge Repair Failed");
-        
         //FINEGRAINED REPAIR 
         long startFineGrained=System.currentTimeMillis();
         tryFineGrainedRepair();       

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-06-23 14:12:49 UTC (rev 19536)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-06-23 16:24:35 UTC (rev 19537)
@@ -171,11 +171,15 @@
         return recoverHandler;
     }
 
+    //TODO: Recovery choices (???): structure / structure+bridge / structure+fine-grained / structure+bridge+fine-grained / old backtrack
     public void setUseStructureRecovery(boolean useRoughRecovery, IRecoveryParser parser) {
         this.recoverIntegrator = new RecoveryConnector(this, parser);
         this.useIntegratedRecovery = useRoughRecovery;
     }
     
+    /*
+     * Structure recovery without bridge parsing
+     */
     public void setUseStructureRecovery(boolean useRoughRecovery) {        
         this.useIntegratedRecovery = useRoughRecovery;
         this.recoverIntegrator = new RecoveryConnector(this, null);



From mdjonge at xs4all.nl  Thu Jun 25 11:40:28 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Thu, 25 Jun 2009 09:40:28 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19551 - MaartjeDeJonge
	- sglr-recovery
Message-ID: <200906250939.n5P9d6g0020373@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-25 09:40:28 +0000 (Thu, 25 Jun 2009)
New Revision: 19551

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19551&view=rev

Added:
   sglr-recovery/TestJDT/

Log:
Initial import.

Changes:



From mdjonge at xs4all.nl  Thu Jun 25 11:45:26 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Thu, 25 Jun 2009 09:45:26 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19552 - MaartjeDeJonge
	- in sglr-recovery/TestJDT: . inputFiles languageFiles src
Message-ID: <200906250944.n5P9i4On020474@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-25 09:45:25 +0000 (Thu, 25 Jun 2009)
New Revision: 19552

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19552&view=rev

Added:
   sglr-recovery/TestJDT/.classpath
   sglr-recovery/TestJDT/.project
   sglr-recovery/TestJDT/compare_ast/
   sglr-recovery/TestJDT/inputFiles/
   sglr-recovery/TestJDT/inputFiles/correctFile.java
   sglr-recovery/TestJDT/inputFiles/currentLineError.java
   sglr-recovery/TestJDT/inputFiles/doubleClosed_If.java
   sglr-recovery/TestJDT/inputFiles/emptyClass.java
   sglr-recovery/TestJDT/inputFiles/exampleFile.java
   sglr-recovery/TestJDT/inputFiles/flawedDeclaration.java
   sglr-recovery/TestJDT/inputFiles/flawedImport.java
   sglr-recovery/TestJDT/inputFiles/flawedMethodHeader.java
   sglr-recovery/TestJDT/inputFiles/flawed_IfBlock.java
   sglr-recovery/TestJDT/inputFiles/previousLineError.java
   sglr-recovery/TestJDT/inputFiles/test.java
   sglr-recovery/TestJDT/inputFiles/test1.java
   sglr-recovery/TestJDT/inputFiles/unclosedMethod.java
   sglr-recovery/TestJDT/inputFiles/unclosed_If.java
   sglr-recovery/TestJDT/java15_output/
   sglr-recovery/TestJDT/jdt_output/
   sglr-recovery/TestJDT/jdt_to_java15_output/
   sglr-recovery/TestJDT/languageFiles/
   sglr-recovery/TestJDT/languageFiles/.libs/
   sglr-recovery/TestJDT/languageFiles/Java-15.str
   sglr-recovery/TestJDT/languageFiles/Java-15.tbl
   sglr-recovery/TestJDT/languageFiles/JdtToJava15
   sglr-recovery/TestJDT/languageFiles/JdtToJava15.c
   sglr-recovery/TestJDT/languageFiles/JdtToJava15.dep
   sglr-recovery/TestJDT/languageFiles/JdtToJava15.lo
   sglr-recovery/TestJDT/languageFiles/JdtToJava15.str
   sglr-recovery/TestJDT/languageFiles/JdtTransformRules.str
   sglr-recovery/TestJDT/languageFiles/jdt.str
   sglr-recovery/TestJDT/processInput.sh
   sglr-recovery/TestJDT/src/
   sglr-recovery/TestJDT/src/BaseTest.java

Log:
jdt-> ast

Changes (first 1000 lines of the diffs):

Added: sglr-recovery/TestJDT/.classpath
===================================================================
--- sglr-recovery/TestJDT/.classpath	                        (rev 0)
+++ sglr-recovery/TestJDT/.classpath	2009-06-25 09:45:25 UTC (rev 19552)
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/other-parsers"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/3"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/org.spoofax.interpreter.core"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>

Added: sglr-recovery/TestJDT/.project
===================================================================
--- sglr-recovery/TestJDT/.project	                        (rev 0)
+++ sglr-recovery/TestJDT/.project	2009-06-25 09:45:25 UTC (rev 19552)
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>TestJDT</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>

Added: sglr-recovery/TestJDT/inputFiles/correctFile.java
===================================================================
--- sglr-recovery/TestJDT/inputFiles/correctFile.java	                        (rev 0)
+++ sglr-recovery/TestJDT/inputFiles/correctFile.java	2009-06-25 09:45:25 UTC (rev 19552)
@@ -0,0 +1,22 @@
+package test;
+
+import java.io.IOException;
+import junit.framework.Assert;
+import org.spoofax.jsglr.SGLRException;
+class X {
+	
+  private int correctMethod1(){
+     corr2();    
+     return corrInt;
+  }
+
+  private int correctMethod2(){
+      int corrLine1;
+      if(true){
+    	  corrLine2();
+      }
+      corrLine3();     
+      corrLine4();
+  }
+}
+

Added: sglr-recovery/TestJDT/inputFiles/currentLineError.java
===================================================================
--- sglr-recovery/TestJDT/inputFiles/currentLineError.java	                        (rev 0)
+++ sglr-recovery/TestJDT/inputFiles/currentLineError.java	2009-06-25 09:45:25 UTC (rev 19552)
@@ -0,0 +1,28 @@
+package test;
+
+import java.io.IOException;
+import junit.framework.Assert;
+import org.spoofax.jsglr.SGLRException;
+class X {
+	
+  private int correctMethod1(){
+     corr2();    
+     return corrInt;
+  }
+
+  private int ErrorFragment(){
+      int corrLine1;
+      corrLine2();      
+      corrLine3();
+  }      
+  
+  private int correctMethod2(){
+      corr2();
+      corr2();
+      int corrInt=1;
+      return corrInt;
+  }
+  
+
+}
+

Added: sglr-recovery/TestJDT/inputFiles/doubleClosed_If.java
===================================================================
--- sglr-recovery/TestJDT/inputFiles/doubleClosed_If.java	                        (rev 0)
+++ sglr-recovery/TestJDT/inputFiles/doubleClosed_If.java	2009-06-25 09:45:25 UTC (rev 19552)
@@ -0,0 +1,30 @@
+package org.spoofax.jsglr;
+
+import java.io.IOException;
+import java.util.ArrayList;
+
+class X {
+	
+  private int correctMethod1(){
+     bla();
+     bla();
+     int i=1;
+     return 2;
+  }
+	
+  private int wronglyClosedMethod(){
+      if(true){
+         i=5;
+      }
+      bla();      
+  }     
+  
+  private int correctMethod2(){
+      bla();
+      bla();
+      int i=1;
+      return 2;
+  }
+
+
+}
\ No newline at end of file

Added: sglr-recovery/TestJDT/inputFiles/emptyClass.java
===================================================================
--- sglr-recovery/TestJDT/inputFiles/emptyClass.java	                        (rev 0)
+++ sglr-recovery/TestJDT/inputFiles/emptyClass.java	2009-06-25 09:45:25 UTC (rev 19552)
@@ -0,0 +1,3 @@
+class X {
+}
+

Added: sglr-recovery/TestJDT/inputFiles/exampleFile.java
===================================================================
--- sglr-recovery/TestJDT/inputFiles/exampleFile.java	                        (rev 0)
+++ sglr-recovery/TestJDT/inputFiles/exampleFile.java	2009-06-25 09:45:25 UTC (rev 19552)
@@ -0,0 +1,13 @@
+package test;
+
+import java.io.anImport;
+
+class X {
+	
+  private int aMethod(){
+     aMethodCall();
+     int aVarDeclaration;     
+     return aReturnStatement;
+  }  
+}
+

Added: sglr-recovery/TestJDT/inputFiles/flawedDeclaration.java
===================================================================
--- sglr-recovery/TestJDT/inputFiles/flawedDeclaration.java	                        (rev 0)
+++ sglr-recovery/TestJDT/inputFiles/flawedDeclaration.java	2009-06-25 09:45:25 UTC (rev 19552)
@@ -0,0 +1,19 @@
+package org.spoofax.jsglr;
+
+import java.io.IOException;
+import java.util.ArrayList;
+
+class X {
+	
+  private int anInt; 
+  private int errorDeclaration;
+  private String aString;  
+	
+  private int correctMethod(){
+     bla();
+     bla();
+     int i=1;
+     return 2;
+  }	
+  
+}
\ No newline at end of file

Added: sglr-recovery/TestJDT/inputFiles/flawedImport.java
===================================================================
--- sglr-recovery/TestJDT/inputFiles/flawedImport.java	                        (rev 0)
+++ sglr-recovery/TestJDT/inputFiles/flawedImport.java	2009-06-25 09:45:25 UTC (rev 19552)
@@ -0,0 +1,16 @@
+package org.spoofax.jsglr;
+
+import java.io.IOException;
+import java.ErrorImport;
+import java.io;
+
+class X {
+  
+  private int correctMethod1(){
+      bla();
+      bla();
+      int i=1;
+      return 2;
+  }
+
+}
\ No newline at end of file

Added: sglr-recovery/TestJDT/inputFiles/flawedMethodHeader.java
===================================================================
--- sglr-recovery/TestJDT/inputFiles/flawedMethodHeader.java	                        (rev 0)
+++ sglr-recovery/TestJDT/inputFiles/flawedMethodHeader.java	2009-06-25 09:45:25 UTC (rev 19552)
@@ -0,0 +1,27 @@
+package org.spoofax.jsglr;
+
+import java.io.IOException;
+import java.util.ArrayList;
+
+class X {
+	
+  private int Fragment(){
+	 int i=1;
+     int i;
+  }
+	
+  private int correctMethod1(){
+     bla();
+     bla();
+     int i=1;
+     return 2;
+  }
+    
+  private int correctMethod2(){
+      bla();
+      bla();
+      int i=1;
+      return 2;
+  }
+
+}
\ No newline at end of file

Added: sglr-recovery/TestJDT/inputFiles/flawed_IfBlock.java
===================================================================
--- sglr-recovery/TestJDT/inputFiles/flawed_IfBlock.java	                        (rev 0)
+++ sglr-recovery/TestJDT/inputFiles/flawed_IfBlock.java	2009-06-25 09:45:25 UTC (rev 19552)
@@ -0,0 +1,26 @@
+class X {
+	
+  private int correctMethod1(){
+     corr2();    
+     return corrInt;
+  }
+
+  private int ErrorFragment(){
+      int corrLine1;
+      corrLine2();
+      int i;
+      if(bla)
+    	  i=0;    	          
+      corrLine3();
+  }      
+  
+  private int correctMethod2(){
+      corr2();
+      corr2();
+      int corrInt=1;
+      return corrInt;
+  }
+  
+
+}
+

Added: sglr-recovery/TestJDT/inputFiles/previousLineError.java
===================================================================
--- sglr-recovery/TestJDT/inputFiles/previousLineError.java	                        (rev 0)
+++ sglr-recovery/TestJDT/inputFiles/previousLineError.java	2009-06-25 09:45:25 UTC (rev 19552)
@@ -0,0 +1,24 @@
+class X {
+	
+  private int correctMethod1(){
+     corr2();    
+     return corrInt;
+  }
+
+  private int ErrorFragment(){
+      int corrLine1;
+      corrLine2();
+      int i = bla();
+      corrLine3();
+  }      
+  
+  private int correctMethod2(){
+      corr2();
+      corr2();
+      int corrInt=1;
+      return corrInt;
+  }
+  
+
+}
+

Added: sglr-recovery/TestJDT/inputFiles/test.java
===================================================================
--- sglr-recovery/TestJDT/inputFiles/test.java	                        (rev 0)
+++ sglr-recovery/TestJDT/inputFiles/test.java	2009-06-25 09:45:25 UTC (rev 19552)
@@ -0,0 +1,42 @@
+class X {
+	
+	private void testExpr(){
+		if(!bla())
+			return;
+		if(bla())
+			return;
+		if(bla)
+			return;
+		if(!bla)
+			return;
+	}
+	
+	private void testEquations(){
+		boolean b = i==j;
+		boolean b = i>=j;
+		boolean b = i<=j;
+		boolean b = i>j;
+		boolean b = i<j;
+		boolean b = i!=4;
+		
+	}
+	
+	int aReturnMethod(){
+		if(true)
+			return 5;
+		methodCallA();
+		int i = methodCallB(2,"bla");
+		return 1;
+	}
+	
+	int aIfElseMethod(){
+		if(true)
+			return 5;
+		else if(j==4)
+			return 6;
+		else
+			return 7;
+	}
+	
+}
+

Added: sglr-recovery/TestJDT/inputFiles/test1.java
===================================================================
--- sglr-recovery/TestJDT/inputFiles/test1.java	                        (rev 0)
+++ sglr-recovery/TestJDT/inputFiles/test1.java	2009-06-25 09:45:25 UTC (rev 19552)
@@ -0,0 +1,34 @@
+package test;
+
+import java.io.anImport;
+import java.util.ArrayList;
+
+import bla.foo.bar.hoi; 
+
+
+class X {
+	
+	
+	
+	int aMethod(){
+	     
+	  }  
+	
+	private OwnType aPrivateMethod(int arg1, OwnType arg2, String arg3){
+	     
+	  }  
+	
+	public void aPublicMethod(){
+		int i;
+		i=1;
+		int i=1;
+	     
+	  }  
+	
+	
+	private static int aPrivateStaticMethod(){
+	     
+	  }  
+  
+}
+

Added: sglr-recovery/TestJDT/inputFiles/unclosedMethod.java
===================================================================
--- sglr-recovery/TestJDT/inputFiles/unclosedMethod.java	                        (rev 0)
+++ sglr-recovery/TestJDT/inputFiles/unclosedMethod.java	2009-06-25 09:45:25 UTC (rev 19552)
@@ -0,0 +1,22 @@
+class X {
+	
+  private int correctMethod1(){
+     corr2();    
+     return corrInt;
+  }
+
+  private int UnclosedMethod(){
+      int corrLine1;
+      corrLine2();
+  }     
+  
+  private int correctMethod2(){
+      corr2();
+      corr2();
+      int corrInt=1;
+      return corrInt;
+  }
+  
+
+}
+

Added: sglr-recovery/TestJDT/inputFiles/unclosed_If.java
===================================================================
--- sglr-recovery/TestJDT/inputFiles/unclosed_If.java	                        (rev 0)
+++ sglr-recovery/TestJDT/inputFiles/unclosed_If.java	2009-06-25 09:45:25 UTC (rev 19552)
@@ -0,0 +1,29 @@
+package org.spoofax.jsglr;
+
+import java.io.IOException;
+import java.util.ArrayList;
+
+class X {
+	
+  private int correctMethod1(){
+     bla();
+     bla();
+     int i=1;
+     return 2;
+  }
+	
+  private int UnclosedIf(){
+    if(true){
+      i=5;
+    }
+    return 7;
+  } 
+	  
+  private int correctMethod2(){
+      bla();
+      bla();
+      int i=1;
+      return 2;
+  }
+
+}
\ No newline at end of file

Added: sglr-recovery/TestJDT/languageFiles/Java-15.str
===================================================================
--- sglr-recovery/TestJDT/languageFiles/Java-15.str	                        (rev 0)
+++ sglr-recovery/TestJDT/languageFiles/Java-15.str	2009-06-25 09:45:25 UTC (rev 19552)
@@ -0,0 +1,368 @@
+module CompilerOutput/Java-15
+
+signature
+  constructors
+    Some                    : TypeArgs -> OptTypeArgs0
+    None                    : OptTypeArgs0
+                            : TypeArgs -> OptTypeArgs0
+                            : ClassMod -> Anno_ClassMod0
+                            : Anno -> Anno_ClassMod0
+                            : InterfaceMod -> Anno_InterfaceMod0
+                            : Anno -> Anno_InterfaceMod0
+                            : AbstractMethodMod -> Anno_AbstractMethodMod0
+                            : Anno -> Anno_AbstractMethodMod0
+                            : ConstantMod -> Anno_ConstantMod0
+                            : Anno -> Anno_ConstantMod0
+                            : ConstrMod -> Anno_ConstrMod0
+                            : Anno -> Anno_ConstrMod0
+                            : VarMod -> Anno_VarMod0
+                            : Anno -> Anno_VarMod0
+                            : MethodMod -> Anno_MethodMod0
+                            : Anno -> Anno_MethodMod0
+                            : FieldMod -> Anno_FieldMod0
+                            : Anno -> Anno_FieldMod0
+    Conc                    : ListStarOfCharClass1 * ListPlusOfCharClass1 -> ListPlusOfCharClass1
+    Conc                    : ListPlusOfCharClass1 * ListStarOfCharClass1 -> ListPlusOfCharClass1
+    Conc                    : ListPlusOfCharClass1 * ListPlusOfCharClass1 -> ListPlusOfCharClass1
+    Cons                    : Int * ListStarOfCharClass1 -> ListPlusOfCharClass1
+    CompilationUnit         : Option(PackageDec) * List(ImportDec) * List(TypeDec) -> CompilationUnit
+    Semicolon               : TypeDec
+                            : InterfaceDec -> TypeDec
+                            : ClassDec -> TypeDec
+    StaticImportOnDemandDec : TypeName -> ImportDec
+    StaticImportDec         : TypeName * Id -> ImportDec
+    TypeImportOnDemandDec   : PackageName -> ImportDec
+    TypeImportDec           : TypeName -> ImportDec
+    PackageDec              : List(Anno) * PackageName -> PackageDec
+    ElemValArrayInit        : List(ElemVal) -> ElemVal
+                            : Anno -> ElemVal
+                            : Expr -> ElemVal
+    ElemValPair             : Id * ElemVal -> ElemValPair
+    MarkerAnno              : TypeName -> Anno
+    SingleElemAnno          : TypeName * ElemVal -> Anno
+    Anno                    : TypeName * List(ElemValPair) -> Anno
+                            : ArrayAccess -> LHS
+                            : FieldAccess -> LHS
+                            : ExprName -> LHS
+                            : Expr -> CondMid
+    GenericMethod           : AmbName * TypeArgs * Id -> MethodSpec
+    QSuperMethod            : TypeName * OptTypeArgs0 * Id -> MethodSpec
+    SuperMethod             : OptTypeArgs0 * Id -> MethodSpec
+    Method                  : Expr * OptTypeArgs0 * Id -> MethodSpec
+    Method                  : MethodName -> MethodSpec
+                            : Expr -> ArraySubscript
+    ArrayAccess             : Expr * ArraySubscript -> ArrayAccess
+    QSuperField             : TypeName * Id -> FieldAccess
+    SuperField              : Id -> FieldAccess
+    Field                   : Expr * Id -> FieldAccess
+    Dim                     : Expr -> DimExpr
+    UnboundWld              : TypeName -> ArrayBaseType
+                            : TypeName -> ArrayBaseType
+                            : PrimType -> ArrayBaseType
+    NewArray                : ArrayBaseType * List(Dim) * ArrayInit -> ArrayCreationExpr
+    NewArray                : ArrayBaseType * List(DimExpr) * List(Dim) -> ArrayCreationExpr
+    Semicolon               : ClassMemberDec
+                            : InterfaceDec -> ClassMemberDec
+                            : ClassDec -> ClassMemberDec
+                            : MethodDec -> ClassMemberDec
+                            : FieldDec -> ClassMemberDec
+                            : ConstrDec -> ClassBodyDec
+                            : StaticInit -> ClassBodyDec
+                            : InstanceInit -> ClassBodyDec
+                            : ClassMemberDec -> ClassBodyDec
+    ImplementsDec           : List(InterfaceType) -> Interfaces
+    SuperDec                : ClassType -> Super
+                            : StrictFP -> ClassMod
+                            : Final -> ClassMod
+                            : Static -> ClassMod
+                            : Private -> ClassMod
+                            : Protected -> ClassMod
+                            : Public -> ClassMod
+                            : Abstract -> ClassMod
+    ClassDecHead            : List(Anno_ClassMod0) * Id * Option(TypeParams) * Option(Super) * Option(Interfaces) -> ClassDecHead
+    ClassBody               : List(ClassBodyDec) -> ClassBody
+    ClassDec                : ClassDecHead * ClassBody -> ClassDec
+                            : EnumDec -> ClassDec
+                            : StrictFP -> InterfaceMod
+                            : Static -> InterfaceMod
+                            : Abstract -> InterfaceMod
+                            : Private -> InterfaceMod
+                            : Protected -> InterfaceMod
+                            : Public -> InterfaceMod
+    Semicolon               : InterfaceMemberDec
+                            : InterfaceDec -> InterfaceMemberDec
+                            : ClassDec -> InterfaceMemberDec
+                            : AbstractMethodDec -> InterfaceMemberDec
+                            : ConstantDec -> InterfaceMemberDec
+    ExtendsInterfaces       : List(InterfaceType) -> ExtendsInterfaces
+    InterfaceDecHead        : List(Anno_InterfaceMod0) * Id * Option(TypeParams) * Option(ExtendsInterfaces) -> InterfaceDecHead
+    InterfaceDec            : InterfaceDecHead * List(InterfaceMemberDec) -> InterfaceDec
+                            : AnnoDec -> InterfaceDec
+    DefaultVal              : ElemVal -> DefaultVal
+    Semicolon               : AnnoElemDec
+                            : AnnoDec -> AnnoElemDec
+                            : EnumDec -> AnnoElemDec
+                            : InterfaceDec -> AnnoElemDec
+                            : ClassDec -> AnnoElemDec
+                            : ConstantDec -> AnnoElemDec
+    AnnoMethodDec           : List(AbstractMethodMod) * Type * Id * Option(DefaultVal) -> AnnoElemDec
+    AnnoDecHead             : List(Anno_InterfaceMod0) * Id -> AnnoDecHead
+    AnnoDec                 : AnnoDecHead * List(AnnoElemDec) -> AnnoDec
+                            : Abstract -> AbstractMethodMod
+                            : Public -> AbstractMethodMod
+    DeprAbstractMethodDec   : List(Anno_AbstractMethodMod0) * Option(TypeParams) * ResultType * Id * List(FormalParam) * List(Dim) * Option(Throws) -> AbstractMethodDec
+    AbstractMethodDec       : List(Anno_AbstractMethodMod0) * Option(TypeParams) * ResultType * Id * List(FormalParam) * Option(Throws) -> AbstractMethodDec
+                            : Final -> ConstantMod
+                            : Static -> ConstantMod
+                            : Public -> ConstantMod
+    ConstantDec             : List(Anno_ConstantMod0) * Type * List(VarDec) -> ConstantDec
+    EnumBodyDecs            : List(ClassBodyDec) -> EnumBodyDecs
+                            : List(Expr) -> EnumConstArgs
+    EnumConst               : Id * Option(EnumConstArgs) * Option(ClassBody) -> EnumConst
+    EnumBody                : List(EnumConst) * Option(EnumBodyDecs) -> EnumBody
+    EnumDecHead             : List(Anno_ClassMod0) * Id * Option(Interfaces) -> EnumDecHead
+    EnumDec                 : EnumDecHead * EnumBody -> EnumDec
+                            : Private -> ConstrMod
+                            : Protected -> ConstrMod
+                            : Public -> ConstrMod
+    QSuperConstrInv         : Expr * OptTypeArgs0 * List(Expr) -> ConstrInv
+    SuperConstrInv          : OptTypeArgs0 * List(Expr) -> ConstrInv
+    AltConstrInv            : OptTypeArgs0 * List(Expr) -> ConstrInv
+    ConstrBody              : Option(ConstrInv) * List(BlockStm) -> ConstrBody
+    ConstrDecHead           : List(Anno_ConstrMod0) * Option(TypeParams) * Id * List(FormalParam) * Option(Throws) -> ConstrHead
+    ConstrDec               : ConstrHead * ConstrBody -> ConstrDec
+    StaticInit              : Block -> StaticInit
+    InstanceInit            : Block -> InstanceInit
+    NoMethodBody            : MethodBody
+                            : Block -> MethodBody
+                            : ClassType -> ExceptionType
+    ThrowsDec               : List(ExceptionType) -> Throws
+                            : StrictFP -> MethodMod
+                            : Native -> MethodMod
+                            : Synchronized -> MethodMod
+                            : Final -> MethodMod
+                            : Static -> MethodMod
+                            : Abstract -> MethodMod
+                            : Private -> MethodMod
+                            : Protected -> MethodMod
+                            : Public -> MethodMod
+                            : Final -> VarMod
+    VarArityParam           : List(Anno_VarMod0) * Type * VarDecId -> FormalParam
+    Param                   : List(Anno_VarMod0) * Type * VarDecId -> FormalParam
+    Void                    : ResultType
+                            : Type -> ResultType
+    DeprMethodDecHead       : List(Anno_MethodMod0) * Option(TypeParams) * ResultType * Id * List(FormalParam) * List(Dim) * Option(Throws) -> MethodDecHead
+    MethodDecHead           : List(Anno_MethodMod0) * Option(TypeParams) * ResultType * Id * List(FormalParam) * Option(Throws) -> MethodDecHead
+    MethodDec               : MethodDecHead * MethodBody -> MethodDec
+                            : Stm -> BlockStm
+    ClassDecStm             : ClassDec -> BlockStm
+                            : LocalVarDecStm -> BlockStm
+    Block                   : List(BlockStm) -> Block
+    Catch                   : FormalParam * Block -> CatchClause
+    Default                 : SwitchLabel
+    Case                    : Expr -> SwitchLabel
+    SwitchGroup             : List(SwitchLabel) * List(BlockStm) -> SwitchGroup
+    SwitchBlock             : List(SwitchGroup) * List(SwitchLabel) -> SwitchBlock
+    ExprStm                 : Expr -> ExprStm
+    Try                     : Block * List(CatchClause) * Block -> Stm
+    Try                     : Block * List(CatchClause) -> Stm
+    Synchronized            : Expr * Block -> Stm
+    Throw                   : Expr -> Stm
+    Return                  : Option(Expr) -> Stm
+    Continue                : Option(Id) -> Stm
+    Break                   : Option(Id) -> Stm
+    ForEach                 : FormalParam * Expr * Stm -> Stm
+    For                     : List(Expr) * Option(Expr) * List(Expr) * Stm -> Stm
+    For                     : LocalVarDec * Option(Expr) * List(Expr) * Stm -> Stm
+    DoWhile                 : Stm * Expr -> Stm
+    While                   : Expr * Stm -> Stm
+    Switch                  : Expr * SwitchBlock -> Stm
+    AssertStm               : Expr * Expr -> Stm
+    AssertStm               : Expr -> Stm
+    If                      : Expr * Stm * Stm -> Stm
+    If                      : Expr * Stm -> Stm
+                            : ExprStm -> Stm
+    Labeled                 : Id * Stm -> Stm
+    Empty                   : Stm
+                            : Block -> Stm
+    LocalVarDec             : List(Anno_VarMod0) * Type * List(VarDec) -> LocalVarDec
+    LocalVarDecStm          : LocalVarDec -> LocalVarDecStm
+                            : Volatile -> FieldMod
+                            : Transient -> FieldMod
+                            : Final -> FieldMod
+                            : Static -> FieldMod
+                            : Private -> FieldMod
+                            : Protected -> FieldMod
+                            : Public -> FieldMod
+                            : ArrayInit -> VarInit
+                            : Expr -> VarInit
+    Dim                     : Dim
+    ArrayVarDecId           : Id * List(Dim) -> VarDecId
+                            : Id -> VarDecId
+    VarDec                  : VarDecId * VarInit -> VarDec
+    VarDec                  : VarDecId -> VarDec
+    FieldDec                : List(Anno_FieldMod0) * Type * List(VarDec) -> FieldDec
+    ArrayInit               : List(VarInit) -> ArrayInit
+    VoidClass               : ClassLiteral
+    Class                   : Type -> ClassLiteral
+                            : ClassLiteral -> Literal
+                            : NullLiteral -> Literal
+                            : StringLiteral -> Literal
+                            : CharLiteral -> Literal
+                            : BoolLiteral -> Literal
+                            : FloatLiteral -> Literal
+                            : IntLiteral -> Literal
+    AssignOr                : LHS * Expr -> Expr
+    AssignExcOr             : LHS * Expr -> Expr
+    AssignAnd               : LHS * Expr -> Expr
+    AssignURightShift       : LHS * Expr -> Expr
+    AssignRightShift        : LHS * Expr -> Expr
+    AssignLeftShift         : LHS * Expr -> Expr
+    AssignMinus             : LHS * Expr -> Expr
+    AssignPlus              : LHS * Expr -> Expr
+    AssignRemain            : LHS * Expr -> Expr
+    AssignDiv               : LHS * Expr -> Expr
+    AssignMul               : LHS * Expr -> Expr
+    Assign                  : LHS * Expr -> Expr
+    Cond                    : Expr * CondMid * Expr -> Expr
+    Or                      : Expr * Expr -> Expr
+    ExcOr                   : Expr * Expr -> Expr
+    And                     : Expr * Expr -> Expr
+    LazyOr                  : Expr * Expr -> Expr
+    LazyAnd                 : Expr * Expr -> Expr
+    NotEq                   : Expr * Expr -> Expr
+    Eq                      : Expr * Expr -> Expr
+    GtEq                    : Expr * Expr -> Expr
+    LtEq                    : Expr * Expr -> Expr
+    Gt                      : Expr * Expr -> Expr
+    Lt                      : Expr * Expr -> Expr
+    URightShift             : Expr * Expr -> Expr
+    RightShift              : Expr * Expr -> Expr
+    LeftShift               : Expr * Expr -> Expr
+    Minus                   : Expr * Expr -> Expr
+    Plus                    : Expr * Expr -> Expr
+    Remain                  : Expr * Expr -> Expr
+    Div                     : Expr * Expr -> Expr
+    Mul                     : Expr * Expr -> Expr
+    InstanceOf              : Expr * RefType -> Expr
+    CastRef                 : RefType * Expr -> Expr
+    CastPrim                : PrimType * Expr -> Expr
+    Not                     : Expr -> Expr
+    Complement              : Expr -> Expr
+    PreDecr                 : Expr -> Expr
+    PreIncr                 : Expr -> Expr
+    Minus                   : Expr -> Expr
+    Plus                    : Expr -> Expr
+    PostDecr                : Expr -> Expr
+    PostIncr                : Expr -> Expr
+                            : ExprName -> Expr
+    Invoke                  : MethodSpec * List(Expr) -> Expr
+                            : ArrayAccess -> Expr
+                            : FieldAccess -> Expr
+                            : ArrayCreationExpr -> Expr
+    QNewInstance            : Expr * OptTypeArgs0 * Id * OptTypeArgs0 * List(Expr) * Option(ClassBody) -> Expr
+    NewInstance             : OptTypeArgs0 * ClassOrInterfaceType * List(Expr) * Option(ClassBody) -> Expr
+    QThis                   : TypeName -> Expr
+    This                    : Expr
+    Lit                     : Literal -> Expr
+                            : RefType -> Type
+                            : PrimType -> Type
+    ArrayType               : Type -> ArrayType
+    Member                  : TypeDecSpec * TypeArgs * Id -> TypeDecSpec
+                            : TypeName -> TypeDecSpec
+    InterfaceType           : TypeDecSpec * OptTypeArgs0 -> InterfaceType
+    ClassType               : TypeDecSpec * OptTypeArgs0 -> ClassType
+    ClassOrInterfaceType    : TypeDecSpec * OptTypeArgs0 -> ClassOrInterfaceType
+                            : ArrayType -> RefType
+                            : ClassOrInterfaceType -> RefType
+                            : Id -> TypeVarId
+    TypeParams              : List(TypeParam) -> TypeParams
+    TypeBound               : List(ClassOrInterfaceType) -> TypeBound
+    TypeParam               : TypeVarId * Option(TypeBound) -> TypeParam
+    WildcardLowerBound      : RefType -> WildcardBound
+    WildcardUpperBound      : RefType -> WildcardBound
+    Wildcard                : Option(WildcardBound) -> ActualTypeArg
+                            : Type -> ActualTypeArg
+    TypeArgs                : List(ActualTypeArg) -> TypeArgs
+    PackageOrTypeName       : PackageOrTypeName * Id -> PackageOrTypeName
+    PackageOrTypeName       : Id -> PackageOrTypeName
+    MethodName              : AmbName * Id -> MethodName
+    MethodName              : Id -> MethodName
+    ExprName                : AmbName * Id -> ExprName
+    ExprName                : Id -> ExprName
+    TypeName                : PackageOrTypeName * Id -> TypeName
+    TypeName                : Id -> TypeName
+    AmbName                 : AmbName * Id -> AmbName
+    AmbName                 : Id -> AmbName
+    PackageName             : List(Id) -> PackageName
+    Double                  : FloatType
+    Float                   : FloatType
+    Char                    : IntType
+    Long                    : IntType
+    Int                     : IntType
+    Short                   : IntType
+    Byte                    : IntType
+                            : FloatType -> NumType
+                            : IntType -> NumType
+    Boolean                 : PrimType
+                            : NumType -> PrimType
+    Null                    : NullLiteral
+                            : String -> StringChars
+                            : EscapeSeq -> StringPart
+                            : UnicodeEscape -> StringPart
+    Chars                   : StringChars -> StringPart
+    String                  : List(StringPart) -> StringLiteral
+                            : Int -> SingleChar
+                            : EscapeSeq -> CharContent
+                            : UnicodeEscape -> CharContent
+    Single                  : SingleChar -> CharContent
+    Char                    : CharContent -> CharLiteral
+                            : Int -> LastOcta
+    OctaEscape3             : Int * Int * Int -> OctaEscape
+    OctaEscape2             : Int * Int -> OctaEscape
+    OctaEscape2             : Int * LastOcta -> OctaEscape
+    OctaEscape1             : LastOcta -> OctaEscape
+    NamedEscape             : Int -> NamedEscape
+                            : NamedEscape -> EscapeSeq
+                            : OctaEscape -> EscapeSeq
+    False                   : Bool
+    True                    : Bool
+    Bool                    : Bool -> BoolLiteral
+    Float                   : HexaFloatLiteral -> FloatLiteral
+    Float                   : DeciFloatLiteral -> FloatLiteral
+                            : String -> HexaFloatLiteral
+                            : String -> DeciFloatLiteral
+    Octa                    : OctaLiteral -> IntLiteral
+    Hexa                    : HexaLiteral -> IntLiteral
+    Deci                    : DeciLiteral -> IntLiteral
+                            : String -> OctaLiteral
+                            : String -> HexaLiteral
+                            : String -> DeciLiteral
+    StrictFP                : StrictFP
+    Synchronized            : Synchronized
+    Volatile                : Volatile
+    Transient               : Transient
+    Native                  : Native
+    Static                  : Static
+    Final                   : Final
+    Abstract                : Abstract
+    Protected               : Protected
+    Private                 : Private
+    Public                  : Public
+    Id                      : ID -> Id
+                            : String -> ID
+                            : String -> UnicodeEscape
+    UnicodeEscape           : ListPlusOfCharClass1 * Int * Int * Int * Int -> UnicodeEscape
+
+
+signature
+  constructors
+    Some : a -> Option(a)
+    None : Option(a)
+
+
+signature
+  constructors
+    Cons : a * List(a) -> List(a)
+    Nil  : List(a)
+    Conc : List(a) * List(a) -> List(a)

Added: sglr-recovery/TestJDT/languageFiles/Java-15.tbl
===================================================================
(Binary files differ)


Property changes on: sglr-recovery/TestJDT/languageFiles/Java-15.tbl
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: sglr-recovery/TestJDT/languageFiles/JdtToJava15
===================================================================
(Binary files differ)


Property changes on: sglr-recovery/TestJDT/languageFiles/JdtToJava15
___________________________________________________________________
Added: svn:executable
   + *
Added: svn:mime-type
   + application/octet-stream

Added: sglr-recovery/TestJDT/languageFiles/JdtToJava15.c
===================================================================
--- sglr-recovery/TestJDT/languageFiles/JdtToJava15.c	                        (rev 0)
+++ sglr-recovery/TestJDT/languageFiles/JdtToJava15.c	2009-06-25 09:45:25 UTC (rev 19552)
@@ -0,0 +1,1729 @@
+#include <srts/stratego.h>
+#include <stratego-lib/stratego-lib.h>
+void init_constructors (void)
+{
+}
+static Symbol sym__2;
+static Symbol sym_Id_1;
+static Symbol sym_Public_0;
+static Symbol sym_Private_0;
+static Symbol sym_Static_0;
+static Symbol sym_Deci_1;
+static Symbol sym_Bool_1;
+static Symbol sym_True_0;
+static Symbol sym_False_0;
+static Symbol sym_String_1;
+static Symbol sym_Chars_1;
+static Symbol sym_Boolean_0;
+static Symbol sym_Int_0;
+static Symbol sym_PackageName_1;
+static Symbol sym_TypeName_1;
+static Symbol sym_TypeName_2;
+static Symbol sym_ExprName_1;
+static Symbol sym_MethodName_1;
+static Symbol sym_PackageOrTypeName_1;
+static Symbol sym_PackageOrTypeName_2;
+static Symbol sym_ClassOrInterfaceType_2;
+static Symbol sym_Lit_1;
+static Symbol sym_Invoke_2;
+static Symbol sym_Not_1;
+static Symbol sym_Lt_2;
+static Symbol sym_Gt_2;
+static Symbol sym_LtEq_2;
+static Symbol sym_GtEq_2;
+static Symbol sym_Eq_2;
+static Symbol sym_NotEq_2;
+static Symbol sym_Assign_2;
+static Symbol sym_FieldDec_3;
+static Symbol sym_VarDec_1;
+static Symbol sym_VarDec_2;
+static Symbol sym_LocalVarDecStm_1;
+static Symbol sym_LocalVarDec_3;
+static Symbol sym_If_2;
+static Symbol sym_If_3;
+static Symbol sym_Return_1;
+static Symbol sym_ExprStm_1;
+static Symbol sym_MethodDec_2;
+static Symbol sym_MethodDecHead_6;
+static Symbol sym_Void_0;
+static Symbol sym_Param_3;
+static Symbol sym_ClassDec_2;
+static Symbol sym_ClassBody_1;
+static Symbol sym_ClassDecHead_5;
+static Symbol sym_Method_1;
+static Symbol sym_PackageDec_2;
+static Symbol sym_TypeImportDec_1;
+static Symbol sym_Nil_0;
+static Symbol sym_Cons_2;
+static Symbol sym_None_0;
+static Symbol sym_Some_1;
+static Symbol sym_FieldDeclaration_4;
+static Symbol sym_PrefixExpressionOperator_1;
+static Symbol sym_PrefixExpression_2;
+static Symbol sym_InfixExpression_4;
+static Symbol sym_IfStatement_3;
+static Symbol sym_MethodInvocation_4;
+static Symbol sym_VariableDeclarationFragment_3;
+static Symbol sym_VariableDeclarationStatement_3;
+static Symbol sym_AssignmentOperator_1;
+static Symbol sym_Assignment_3;
+static Symbol sym_ReturnStatement_1;
+static Symbol sym_ExpressionStatement_1;
+static Symbol sym_BooleanLiteral_1;
+static Symbol sym_StringLiteral_1;
+static Symbol sym_NumberLiteral_1;
+static Symbol sym_SingleVariableDeclaration_5;
+static Symbol sym_SimpleType_1;
+static Symbol sym_ModifierKeyword_1;
+static Symbol sym_Modifier_1;
+static Symbol sym_PrimitiveType_1;
+static Symbol sym_MethodDeclaration_8;
+static Symbol sym_QualifiedName_2;
+static Symbol sym_ImportDeclaration_3;
+static Symbol sym_PackageDeclaration_3;
+static Symbol sym_TypeDeclaration_8;
+static Symbol sym_SimpleName_1;
+static void init_module_constructors (void)
+{
+sym__2 = ATmakeSymbol("", 2, ATfalse);
+ATprotectSymbol(sym__2);
+sym_Id_1 = ATmakeSymbol("Id", 1, ATfalse);
+ATprotectSymbol(sym_Id_1);
+sym_Public_0 = ATmakeSymbol("Public", 0, ATfalse);
+ATprotectSymbol(sym_Public_0);
+sym_Private_0 = ATmakeSymbol("Private", 0, ATfalse);
+ATprotectSymbol(sym_Private_0);
+sym_Static_0 = ATmakeSymbol("Static", 0, ATfalse);
+ATprotectSymbol(sym_Static_0);
+sym_Deci_1 = ATmakeSymbol("Deci", 1, ATfalse);
+ATprotectSymbol(sym_Deci_1);
+sym_Bool_1 = ATmakeSymbol("Bool", 1, ATfalse);
+ATprotectSymbol(sym_Bool_1);
+sym_True_0 = ATmakeSymbol("True", 0, ATfalse);
+ATprotectSymbol(sym_True_0);
+sym_False_0 = ATmakeSymbol("False", 0, ATfalse);
+ATprotectSymbol(sym_False_0);
+sym_String_1 = ATmakeSymbol("String", 1, ATfalse);
+ATprotectSymbol(sym_String_1);
+sym_Chars_1 = ATmakeSymbol("Chars", 1, ATfalse);
+ATprotectSymbol(sym_Chars_1);
+sym_Boolean_0 = ATmakeSymbol("Boolean", 0, ATfalse);
+ATprotectSymbol(sym_Boolean_0);
+sym_Int_0 = ATmakeSymbol("Int", 0, ATfalse);
+ATprotectSymbol(sym_Int_0);
+sym_PackageName_1 = ATmakeSymbol("PackageName", 1, ATfalse);
+ATprotectSymbol(sym_PackageName_1);
+sym_TypeName_1 = ATmakeSymbol("TypeName", 1, ATfalse);
+ATprotectSymbol(sym_TypeName_1);
+sym_TypeName_2 = ATmakeSymbol("TypeName", 2, ATfalse);
+ATprotectSymbol(sym_TypeName_2);
+sym_ExprName_1 = ATmakeSymbol("ExprName", 1, ATfalse);
+ATprotectSymbol(sym_ExprName_1);
+sym_MethodName_1 = ATmakeSymbol("MethodName", 1, ATfalse);
+ATprotectSymbol(sym_MethodName_1);
+sym_PackageOrTypeName_1 = ATmakeSymbol("PackageOrTypeName", 1, ATfalse);
+ATprotectSymbol(sym_PackageOrTypeName_1);
+sym_PackageOrTypeName_2 = ATmakeSymbol("PackageOrTypeName", 2, ATfalse);
+ATprotectSymbol(sym_PackageOrTypeName_2);
+sym_ClassOrInterfaceType_2 = ATmakeSymbol("ClassOrInterfaceType", 2, ATfalse);
+ATprotectSymbol(sym_ClassOrInterfaceType_2);
+sym_Lit_1 = ATmakeSymbol("Lit", 1, ATfalse);
+ATprotectSymbol(sym_Lit_1);
+sym_Invoke_2 = ATmakeSymbol("Invoke", 2, ATfalse);
+ATprotectSymbol(sym_Invoke_2);
+sym_Not_1 = ATmakeSymbol("Not", 1, ATfalse);
+ATprotectSymbol(sym_Not_1);
+sym_Lt_2 = ATmakeSymbol("Lt", 2, ATfalse);
+ATprotectSymbol(sym_Lt_2);

(1914 diff lines omitted)


From mdjonge at xs4all.nl  Fri Jun 26 15:57:23 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Fri, 26 Jun 2009 13:57:23 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19567 - MaartjeDeJonge
	- sglr-recovery
Message-ID: <200906261356.n5QDu0eP008129@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-26 13:57:23 +0000 (Fri, 26 Jun 2009)
New Revision: 19567

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19567&view=rev

Added:
   sglr-recovery/Evaluation_Recovery/

Log:
Initial import.

Changes:



From mdjonge at xs4all.nl  Fri Jun 26 16:00:33 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Fri, 26 Jun 2009 14:00:33 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19568 - MaartjeDeJonge
	- sglr-recovery
Message-ID: <200906261359.n5QDxAn2008171@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-26 14:00:32 +0000 (Fri, 26 Jun 2009)
New Revision: 19568

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19568&view=rev

Removed:
   sglr-recovery/Evaluation_Recovery/

Log:
wrong location

Changes:



From mdjonge at xs4all.nl  Fri Jun 26 16:06:38 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Fri, 26 Jun 2009 14:06:38 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19569 - MaartjeDeJonge
	- sglr-recovery/trunk
Message-ID: <200906261405.n5QE5F3Z008459@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-26 14:06:38 +0000 (Fri, 26 Jun 2009)
New Revision: 19569

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19569&view=rev

Added:
   sglr-recovery/trunk/Evaluation_Recovery/

Log:
Initial import.

Changes:



From mdjonge at xs4all.nl  Fri Jun 26 16:09:23 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Fri, 26 Jun 2009 14:09:23 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19570 - MaartjeDeJonge
	- in sglr-recovery/trunk/Evaluation_Recovery: . Compare
	Correct_Files Correct_Files/input_files Error_Files
	Error_Files/input_files Language_Files src
Message-ID: <200906261408.n5QE80SL008477@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-26 14:09:23 +0000 (Fri, 26 Jun 2009)
New Revision: 19570

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19570&view=rev

Added:
   sglr-recovery/trunk/Evaluation_Recovery/.classpath
   sglr-recovery/trunk/Evaluation_Recovery/.jsglr-log
   sglr-recovery/trunk/Evaluation_Recovery/.project
   sglr-recovery/trunk/Evaluation_Recovery/Compare/
   sglr-recovery/trunk/Evaluation_Recovery/Compare/Ast/
   sglr-recovery/trunk/Evaluation_Recovery/Compare/Java/
   sglr-recovery/trunk/Evaluation_Recovery/CompileTransformation.sh
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/check_ast/
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testFile.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/jdt_ast/
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/jdt_tree/
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/sglr_ast/
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/sglr_parsetree/
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testFile.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/jdt_ast/
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/jdt_java/
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/jdt_tree/
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/sglr_ast/
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/sglr_java/
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/sglr_parsetree/
   sglr-recovery/trunk/Evaluation_Recovery/Language_Files/
   sglr-recovery/trunk/Evaluation_Recovery/Language_Files/.libs/
   sglr-recovery/trunk/Evaluation_Recovery/Language_Files/CombineAll.tbl
   sglr-recovery/trunk/Evaluation_Recovery/Language_Files/InsertOnly.tbl
   sglr-recovery/trunk/Evaluation_Recovery/Language_Files/Java-15-Tokenizer.tbl
   sglr-recovery/trunk/Evaluation_Recovery/Language_Files/Java-15.str
   sglr-recovery/trunk/Evaluation_Recovery/Language_Files/Java-15.tbl
   sglr-recovery/trunk/Evaluation_Recovery/Language_Files/JdtToJava15
   sglr-recovery/trunk/Evaluation_Recovery/Language_Files/JdtToJava15.c
   sglr-recovery/trunk/Evaluation_Recovery/Language_Files/JdtToJava15.dep
   sglr-recovery/trunk/Evaluation_Recovery/Language_Files/JdtToJava15.lo
   sglr-recovery/trunk/Evaluation_Recovery/Language_Files/JdtToJava15.str
   sglr-recovery/trunk/Evaluation_Recovery/Language_Files/JdtTransformRules.str
   sglr-recovery/trunk/Evaluation_Recovery/Language_Files/SpecialTokenRecovery.tbl
   sglr-recovery/trunk/Evaluation_Recovery/Language_Files/jdt.str
   sglr-recovery/trunk/Evaluation_Recovery/Run.sh
   sglr-recovery/trunk/Evaluation_Recovery/how to
   sglr-recovery/trunk/Evaluation_Recovery/src/
   sglr-recovery/trunk/Evaluation_Recovery/src/ProcessFiles.java

Log:
initial commit of project

Changes (first 1000 lines of the diffs):

Added: sglr-recovery/trunk/Evaluation_Recovery/.classpath
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/.classpath	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/.classpath	2009-06-26 14:09:23 UTC (rev 19570)
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/org.bripgen"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/org.briplib"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/org.spoofax.jsglr [spoofax-recovery branch]"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/3"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/other-parsers"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/org.spoofax.interpreter.core"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/org.spoofax.aterm"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>

Added: sglr-recovery/trunk/Evaluation_Recovery/.project
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/.project	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/.project	2009-06-26 14:09:23 UTC (rev 19570)
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>Evaluation_Recovery</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>

Added: sglr-recovery/trunk/Evaluation_Recovery/CompileTransformation.sh
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/CompileTransformation.sh	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/CompileTransformation.sh	2009-06-26 14:09:23 UTC (rev 19570)
@@ -0,0 +1,30 @@
+#!/bin/sh
+
+#compiles transformation program
+strc -i Language_Files/JdtToJava15.str -la stratego-lib
+
+
+loc="Correct_Files"
+
+#check transformed ast with original
+ext=.readable
+jdtLocation="jdt_ast"
+sglrLocation="sglr_ast"
+diffDir="$loc/check_ast"
+jdtAstDir=$loc/$jdtLocation
+sglrAstDir=$loc/$sglrLocation
+
+jdtFiles="$jdtAstDir/*$ext"
+for jdtTree in $jdtFiles
+do	
+	jdtTree=${jdtTree#*\/}
+	jdtTree=${jdtTree#*\/}
+	jdtTreeName=${jdtTree%.*}
+	jdtTreeName=${jdtTreeName%.*}	
+	echo $jdtTreeName	
+	
+	#compare readable ast's
+	diff $jdtAstDir/$jdtTree $sglrAstDir/$jdtTreeName.readable.ast > $diffDir/$jdtTreeName.diff
+done
+
+


Property changes on: sglr-recovery/trunk/Evaluation_Recovery/CompileTransformation.sh
___________________________________________________________________
Added: svn:executable
   + *

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testFile.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testFile.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testFile.java	2009-06-26 14:09:23 UTC (rev 19570)
@@ -0,0 +1,22 @@
+package org.spoofax.jsglr;
+
+import java.io.IOException;
+import java.util.ArrayList;
+
+class X {
+	
+  private int method1(){
+     bla();
+     bla();
+     int i=1;
+     return 2;
+  }  
+  
+  private int method2(){
+      bla();
+      bla();
+      int i=1;
+      return 2;
+  }
+
+}
\ No newline at end of file

Added: sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testFile.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testFile.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testFile.java	2009-06-26 14:09:23 UTC (rev 19570)
@@ -0,0 +1,22 @@
+package org.spoofax.jsglr;
+
+import java.io.IOException;
+import java.util.ArrayList;
+
+class X {
+	
+  private int method1(){
+     bla();
+     bla();
+     int i=1 /*;*/
+     return 2;
+  }  
+  
+  private int method2(){
+      bla();
+      bla();
+      int i=1;
+      return 2;
+  }
+
+}
\ No newline at end of file

Added: sglr-recovery/trunk/Evaluation_Recovery/Language_Files/CombineAll.tbl
===================================================================
(Binary files differ)


Property changes on: sglr-recovery/trunk/Evaluation_Recovery/Language_Files/CombineAll.tbl
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: sglr-recovery/trunk/Evaluation_Recovery/Language_Files/InsertOnly.tbl
===================================================================
(Binary files differ)


Property changes on: sglr-recovery/trunk/Evaluation_Recovery/Language_Files/InsertOnly.tbl
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: sglr-recovery/trunk/Evaluation_Recovery/Language_Files/Java-15-Tokenizer.tbl
===================================================================
(Binary files differ)


Property changes on: sglr-recovery/trunk/Evaluation_Recovery/Language_Files/Java-15-Tokenizer.tbl
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: sglr-recovery/trunk/Evaluation_Recovery/Language_Files/Java-15.str
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Language_Files/Java-15.str	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Language_Files/Java-15.str	2009-06-26 14:09:23 UTC (rev 19570)
@@ -0,0 +1,368 @@
+module CompilerOutput/Java-15
+
+signature
+  constructors
+    Some                    : TypeArgs -> OptTypeArgs0
+    None                    : OptTypeArgs0
+                            : TypeArgs -> OptTypeArgs0
+                            : ClassMod -> Anno_ClassMod0
+                            : Anno -> Anno_ClassMod0
+                            : InterfaceMod -> Anno_InterfaceMod0
+                            : Anno -> Anno_InterfaceMod0
+                            : AbstractMethodMod -> Anno_AbstractMethodMod0
+                            : Anno -> Anno_AbstractMethodMod0
+                            : ConstantMod -> Anno_ConstantMod0
+                            : Anno -> Anno_ConstantMod0
+                            : ConstrMod -> Anno_ConstrMod0
+                            : Anno -> Anno_ConstrMod0
+                            : VarMod -> Anno_VarMod0
+                            : Anno -> Anno_VarMod0
+                            : MethodMod -> Anno_MethodMod0
+                            : Anno -> Anno_MethodMod0
+                            : FieldMod -> Anno_FieldMod0
+                            : Anno -> Anno_FieldMod0
+    Conc                    : ListStarOfCharClass1 * ListPlusOfCharClass1 -> ListPlusOfCharClass1
+    Conc                    : ListPlusOfCharClass1 * ListStarOfCharClass1 -> ListPlusOfCharClass1
+    Conc                    : ListPlusOfCharClass1 * ListPlusOfCharClass1 -> ListPlusOfCharClass1
+    Cons                    : Int * ListStarOfCharClass1 -> ListPlusOfCharClass1
+    CompilationUnit         : Option(PackageDec) * List(ImportDec) * List(TypeDec) -> CompilationUnit
+    Semicolon               : TypeDec
+                            : InterfaceDec -> TypeDec
+                            : ClassDec -> TypeDec
+    StaticImportOnDemandDec : TypeName -> ImportDec
+    StaticImportDec         : TypeName * Id -> ImportDec
+    TypeImportOnDemandDec   : PackageName -> ImportDec
+    TypeImportDec           : TypeName -> ImportDec
+    PackageDec              : List(Anno) * PackageName -> PackageDec
+    ElemValArrayInit        : List(ElemVal) -> ElemVal
+                            : Anno -> ElemVal
+                            : Expr -> ElemVal
+    ElemValPair             : Id * ElemVal -> ElemValPair
+    MarkerAnno              : TypeName -> Anno
+    SingleElemAnno          : TypeName * ElemVal -> Anno
+    Anno                    : TypeName * List(ElemValPair) -> Anno
+                            : ArrayAccess -> LHS
+                            : FieldAccess -> LHS
+                            : ExprName -> LHS
+                            : Expr -> CondMid
+    GenericMethod           : AmbName * TypeArgs * Id -> MethodSpec
+    QSuperMethod            : TypeName * OptTypeArgs0 * Id -> MethodSpec
+    SuperMethod             : OptTypeArgs0 * Id -> MethodSpec
+    Method                  : Expr * OptTypeArgs0 * Id -> MethodSpec
+    Method                  : MethodName -> MethodSpec
+                            : Expr -> ArraySubscript
+    ArrayAccess             : Expr * ArraySubscript -> ArrayAccess
+    QSuperField             : TypeName * Id -> FieldAccess
+    SuperField              : Id -> FieldAccess
+    Field                   : Expr * Id -> FieldAccess
+    Dim                     : Expr -> DimExpr
+    UnboundWld              : TypeName -> ArrayBaseType
+                            : TypeName -> ArrayBaseType
+                            : PrimType -> ArrayBaseType
+    NewArray                : ArrayBaseType * List(Dim) * ArrayInit -> ArrayCreationExpr
+    NewArray                : ArrayBaseType * List(DimExpr) * List(Dim) -> ArrayCreationExpr
+    Semicolon               : ClassMemberDec
+                            : InterfaceDec -> ClassMemberDec
+                            : ClassDec -> ClassMemberDec
+                            : MethodDec -> ClassMemberDec
+                            : FieldDec -> ClassMemberDec
+                            : ConstrDec -> ClassBodyDec
+                            : StaticInit -> ClassBodyDec
+                            : InstanceInit -> ClassBodyDec
+                            : ClassMemberDec -> ClassBodyDec
+    ImplementsDec           : List(InterfaceType) -> Interfaces
+    SuperDec                : ClassType -> Super
+                            : StrictFP -> ClassMod
+                            : Final -> ClassMod
+                            : Static -> ClassMod
+                            : Private -> ClassMod
+                            : Protected -> ClassMod
+                            : Public -> ClassMod
+                            : Abstract -> ClassMod
+    ClassDecHead            : List(Anno_ClassMod0) * Id * Option(TypeParams) * Option(Super) * Option(Interfaces) -> ClassDecHead
+    ClassBody               : List(ClassBodyDec) -> ClassBody
+    ClassDec                : ClassDecHead * ClassBody -> ClassDec
+                            : EnumDec -> ClassDec
+                            : StrictFP -> InterfaceMod
+                            : Static -> InterfaceMod
+                            : Abstract -> InterfaceMod
+                            : Private -> InterfaceMod
+                            : Protected -> InterfaceMod
+                            : Public -> InterfaceMod
+    Semicolon               : InterfaceMemberDec
+                            : InterfaceDec -> InterfaceMemberDec
+                            : ClassDec -> InterfaceMemberDec
+                            : AbstractMethodDec -> InterfaceMemberDec
+                            : ConstantDec -> InterfaceMemberDec
+    ExtendsInterfaces       : List(InterfaceType) -> ExtendsInterfaces
+    InterfaceDecHead        : List(Anno_InterfaceMod0) * Id * Option(TypeParams) * Option(ExtendsInterfaces) -> InterfaceDecHead
+    InterfaceDec            : InterfaceDecHead * List(InterfaceMemberDec) -> InterfaceDec
+                            : AnnoDec -> InterfaceDec
+    DefaultVal              : ElemVal -> DefaultVal
+    Semicolon               : AnnoElemDec
+                            : AnnoDec -> AnnoElemDec
+                            : EnumDec -> AnnoElemDec
+                            : InterfaceDec -> AnnoElemDec
+                            : ClassDec -> AnnoElemDec
+                            : ConstantDec -> AnnoElemDec
+    AnnoMethodDec           : List(AbstractMethodMod) * Type * Id * Option(DefaultVal) -> AnnoElemDec
+    AnnoDecHead             : List(Anno_InterfaceMod0) * Id -> AnnoDecHead
+    AnnoDec                 : AnnoDecHead * List(AnnoElemDec) -> AnnoDec
+                            : Abstract -> AbstractMethodMod
+                            : Public -> AbstractMethodMod
+    DeprAbstractMethodDec   : List(Anno_AbstractMethodMod0) * Option(TypeParams) * ResultType * Id * List(FormalParam) * List(Dim) * Option(Throws) -> AbstractMethodDec
+    AbstractMethodDec       : List(Anno_AbstractMethodMod0) * Option(TypeParams) * ResultType * Id * List(FormalParam) * Option(Throws) -> AbstractMethodDec
+                            : Final -> ConstantMod
+                            : Static -> ConstantMod
+                            : Public -> ConstantMod
+    ConstantDec             : List(Anno_ConstantMod0) * Type * List(VarDec) -> ConstantDec
+    EnumBodyDecs            : List(ClassBodyDec) -> EnumBodyDecs
+                            : List(Expr) -> EnumConstArgs
+    EnumConst               : Id * Option(EnumConstArgs) * Option(ClassBody) -> EnumConst
+    EnumBody                : List(EnumConst) * Option(EnumBodyDecs) -> EnumBody
+    EnumDecHead             : List(Anno_ClassMod0) * Id * Option(Interfaces) -> EnumDecHead
+    EnumDec                 : EnumDecHead * EnumBody -> EnumDec
+                            : Private -> ConstrMod
+                            : Protected -> ConstrMod
+                            : Public -> ConstrMod
+    QSuperConstrInv         : Expr * OptTypeArgs0 * List(Expr) -> ConstrInv
+    SuperConstrInv          : OptTypeArgs0 * List(Expr) -> ConstrInv
+    AltConstrInv            : OptTypeArgs0 * List(Expr) -> ConstrInv
+    ConstrBody              : Option(ConstrInv) * List(BlockStm) -> ConstrBody
+    ConstrDecHead           : List(Anno_ConstrMod0) * Option(TypeParams) * Id * List(FormalParam) * Option(Throws) -> ConstrHead
+    ConstrDec               : ConstrHead * ConstrBody -> ConstrDec
+    StaticInit              : Block -> StaticInit
+    InstanceInit            : Block -> InstanceInit
+    NoMethodBody            : MethodBody
+                            : Block -> MethodBody
+                            : ClassType -> ExceptionType
+    ThrowsDec               : List(ExceptionType) -> Throws
+                            : StrictFP -> MethodMod
+                            : Native -> MethodMod
+                            : Synchronized -> MethodMod
+                            : Final -> MethodMod
+                            : Static -> MethodMod
+                            : Abstract -> MethodMod
+                            : Private -> MethodMod
+                            : Protected -> MethodMod
+                            : Public -> MethodMod
+                            : Final -> VarMod
+    VarArityParam           : List(Anno_VarMod0) * Type * VarDecId -> FormalParam
+    Param                   : List(Anno_VarMod0) * Type * VarDecId -> FormalParam
+    Void                    : ResultType
+                            : Type -> ResultType
+    DeprMethodDecHead       : List(Anno_MethodMod0) * Option(TypeParams) * ResultType * Id * List(FormalParam) * List(Dim) * Option(Throws) -> MethodDecHead
+    MethodDecHead           : List(Anno_MethodMod0) * Option(TypeParams) * ResultType * Id * List(FormalParam) * Option(Throws) -> MethodDecHead
+    MethodDec               : MethodDecHead * MethodBody -> MethodDec
+                            : Stm -> BlockStm
+    ClassDecStm             : ClassDec -> BlockStm
+                            : LocalVarDecStm -> BlockStm
+    Block                   : List(BlockStm) -> Block
+    Catch                   : FormalParam * Block -> CatchClause
+    Default                 : SwitchLabel
+    Case                    : Expr -> SwitchLabel
+    SwitchGroup             : List(SwitchLabel) * List(BlockStm) -> SwitchGroup
+    SwitchBlock             : List(SwitchGroup) * List(SwitchLabel) -> SwitchBlock
+    ExprStm                 : Expr -> ExprStm
+    Try                     : Block * List(CatchClause) * Block -> Stm
+    Try                     : Block * List(CatchClause) -> Stm
+    Synchronized            : Expr * Block -> Stm
+    Throw                   : Expr -> Stm
+    Return                  : Option(Expr) -> Stm
+    Continue                : Option(Id) -> Stm
+    Break                   : Option(Id) -> Stm
+    ForEach                 : FormalParam * Expr * Stm -> Stm
+    For                     : List(Expr) * Option(Expr) * List(Expr) * Stm -> Stm
+    For                     : LocalVarDec * Option(Expr) * List(Expr) * Stm -> Stm
+    DoWhile                 : Stm * Expr -> Stm
+    While                   : Expr * Stm -> Stm
+    Switch                  : Expr * SwitchBlock -> Stm
+    AssertStm               : Expr * Expr -> Stm
+    AssertStm               : Expr -> Stm
+    If                      : Expr * Stm * Stm -> Stm
+    If                      : Expr * Stm -> Stm
+                            : ExprStm -> Stm
+    Labeled                 : Id * Stm -> Stm
+    Empty                   : Stm
+                            : Block -> Stm
+    LocalVarDec             : List(Anno_VarMod0) * Type * List(VarDec) -> LocalVarDec
+    LocalVarDecStm          : LocalVarDec -> LocalVarDecStm
+                            : Volatile -> FieldMod
+                            : Transient -> FieldMod
+                            : Final -> FieldMod
+                            : Static -> FieldMod
+                            : Private -> FieldMod
+                            : Protected -> FieldMod
+                            : Public -> FieldMod
+                            : ArrayInit -> VarInit
+                            : Expr -> VarInit
+    Dim                     : Dim
+    ArrayVarDecId           : Id * List(Dim) -> VarDecId
+                            : Id -> VarDecId
+    VarDec                  : VarDecId * VarInit -> VarDec
+    VarDec                  : VarDecId -> VarDec
+    FieldDec                : List(Anno_FieldMod0) * Type * List(VarDec) -> FieldDec
+    ArrayInit               : List(VarInit) -> ArrayInit
+    VoidClass               : ClassLiteral
+    Class                   : Type -> ClassLiteral
+                            : ClassLiteral -> Literal
+                            : NullLiteral -> Literal
+                            : StringLiteral -> Literal
+                            : CharLiteral -> Literal
+                            : BoolLiteral -> Literal
+                            : FloatLiteral -> Literal
+                            : IntLiteral -> Literal
+    AssignOr                : LHS * Expr -> Expr
+    AssignExcOr             : LHS * Expr -> Expr
+    AssignAnd               : LHS * Expr -> Expr
+    AssignURightShift       : LHS * Expr -> Expr
+    AssignRightShift        : LHS * Expr -> Expr
+    AssignLeftShift         : LHS * Expr -> Expr
+    AssignMinus             : LHS * Expr -> Expr
+    AssignPlus              : LHS * Expr -> Expr
+    AssignRemain            : LHS * Expr -> Expr
+    AssignDiv               : LHS * Expr -> Expr
+    AssignMul               : LHS * Expr -> Expr
+    Assign                  : LHS * Expr -> Expr
+    Cond                    : Expr * CondMid * Expr -> Expr
+    Or                      : Expr * Expr -> Expr
+    ExcOr                   : Expr * Expr -> Expr
+    And                     : Expr * Expr -> Expr
+    LazyOr                  : Expr * Expr -> Expr
+    LazyAnd                 : Expr * Expr -> Expr
+    NotEq                   : Expr * Expr -> Expr
+    Eq                      : Expr * Expr -> Expr
+    GtEq                    : Expr * Expr -> Expr
+    LtEq                    : Expr * Expr -> Expr
+    Gt                      : Expr * Expr -> Expr
+    Lt                      : Expr * Expr -> Expr
+    URightShift             : Expr * Expr -> Expr
+    RightShift              : Expr * Expr -> Expr
+    LeftShift               : Expr * Expr -> Expr
+    Minus                   : Expr * Expr -> Expr
+    Plus                    : Expr * Expr -> Expr
+    Remain                  : Expr * Expr -> Expr
+    Div                     : Expr * Expr -> Expr
+    Mul                     : Expr * Expr -> Expr
+    InstanceOf              : Expr * RefType -> Expr
+    CastRef                 : RefType * Expr -> Expr
+    CastPrim                : PrimType * Expr -> Expr
+    Not                     : Expr -> Expr
+    Complement              : Expr -> Expr
+    PreDecr                 : Expr -> Expr
+    PreIncr                 : Expr -> Expr
+    Minus                   : Expr -> Expr
+    Plus                    : Expr -> Expr
+    PostDecr                : Expr -> Expr
+    PostIncr                : Expr -> Expr
+                            : ExprName -> Expr
+    Invoke                  : MethodSpec * List(Expr) -> Expr
+                            : ArrayAccess -> Expr
+                            : FieldAccess -> Expr
+                            : ArrayCreationExpr -> Expr
+    QNewInstance            : Expr * OptTypeArgs0 * Id * OptTypeArgs0 * List(Expr) * Option(ClassBody) -> Expr
+    NewInstance             : OptTypeArgs0 * ClassOrInterfaceType * List(Expr) * Option(ClassBody) -> Expr
+    QThis                   : TypeName -> Expr
+    This                    : Expr
+    Lit                     : Literal -> Expr
+                            : RefType -> Type
+                            : PrimType -> Type
+    ArrayType               : Type -> ArrayType
+    Member                  : TypeDecSpec * TypeArgs * Id -> TypeDecSpec
+                            : TypeName -> TypeDecSpec
+    InterfaceType           : TypeDecSpec * OptTypeArgs0 -> InterfaceType
+    ClassType               : TypeDecSpec * OptTypeArgs0 -> ClassType
+    ClassOrInterfaceType    : TypeDecSpec * OptTypeArgs0 -> ClassOrInterfaceType
+                            : ArrayType -> RefType
+                            : ClassOrInterfaceType -> RefType
+                            : Id -> TypeVarId
+    TypeParams              : List(TypeParam) -> TypeParams
+    TypeBound               : List(ClassOrInterfaceType) -> TypeBound
+    TypeParam               : TypeVarId * Option(TypeBound) -> TypeParam
+    WildcardLowerBound      : RefType -> WildcardBound
+    WildcardUpperBound      : RefType -> WildcardBound
+    Wildcard                : Option(WildcardBound) -> ActualTypeArg
+                            : Type -> ActualTypeArg
+    TypeArgs                : List(ActualTypeArg) -> TypeArgs
+    PackageOrTypeName       : PackageOrTypeName * Id -> PackageOrTypeName
+    PackageOrTypeName       : Id -> PackageOrTypeName
+    MethodName              : AmbName * Id -> MethodName
+    MethodName              : Id -> MethodName
+    ExprName                : AmbName * Id -> ExprName
+    ExprName                : Id -> ExprName
+    TypeName                : PackageOrTypeName * Id -> TypeName
+    TypeName                : Id -> TypeName
+    AmbName                 : AmbName * Id -> AmbName
+    AmbName                 : Id -> AmbName
+    PackageName             : List(Id) -> PackageName
+    Double                  : FloatType
+    Float                   : FloatType
+    Char                    : IntType
+    Long                    : IntType
+    Int                     : IntType
+    Short                   : IntType
+    Byte                    : IntType
+                            : FloatType -> NumType
+                            : IntType -> NumType
+    Boolean                 : PrimType
+                            : NumType -> PrimType
+    Null                    : NullLiteral
+                            : String -> StringChars
+                            : EscapeSeq -> StringPart
+                            : UnicodeEscape -> StringPart
+    Chars                   : StringChars -> StringPart
+    String                  : List(StringPart) -> StringLiteral
+                            : Int -> SingleChar
+                            : EscapeSeq -> CharContent
+                            : UnicodeEscape -> CharContent
+    Single                  : SingleChar -> CharContent
+    Char                    : CharContent -> CharLiteral
+                            : Int -> LastOcta
+    OctaEscape3             : Int * Int * Int -> OctaEscape
+    OctaEscape2             : Int * Int -> OctaEscape
+    OctaEscape2             : Int * LastOcta -> OctaEscape
+    OctaEscape1             : LastOcta -> OctaEscape
+    NamedEscape             : Int -> NamedEscape
+                            : NamedEscape -> EscapeSeq
+                            : OctaEscape -> EscapeSeq
+    False                   : Bool
+    True                    : Bool
+    Bool                    : Bool -> BoolLiteral
+    Float                   : HexaFloatLiteral -> FloatLiteral
+    Float                   : DeciFloatLiteral -> FloatLiteral
+                            : String -> HexaFloatLiteral
+                            : String -> DeciFloatLiteral
+    Octa                    : OctaLiteral -> IntLiteral
+    Hexa                    : HexaLiteral -> IntLiteral
+    Deci                    : DeciLiteral -> IntLiteral
+                            : String -> OctaLiteral
+                            : String -> HexaLiteral
+                            : String -> DeciLiteral
+    StrictFP                : StrictFP
+    Synchronized            : Synchronized
+    Volatile                : Volatile
+    Transient               : Transient
+    Native                  : Native
+    Static                  : Static
+    Final                   : Final
+    Abstract                : Abstract
+    Protected               : Protected
+    Private                 : Private
+    Public                  : Public
+    Id                      : ID -> Id
+                            : String -> ID
+                            : String -> UnicodeEscape
+    UnicodeEscape           : ListPlusOfCharClass1 * Int * Int * Int * Int -> UnicodeEscape
+
+
+signature
+  constructors
+    Some : a -> Option(a)
+    None : Option(a)
+
+
+signature
+  constructors
+    Cons : a * List(a) -> List(a)
+    Nil  : List(a)
+    Conc : List(a) * List(a) -> List(a)

Added: sglr-recovery/trunk/Evaluation_Recovery/Language_Files/Java-15.tbl
===================================================================
(Binary files differ)


Property changes on: sglr-recovery/trunk/Evaluation_Recovery/Language_Files/Java-15.tbl
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: sglr-recovery/trunk/Evaluation_Recovery/Language_Files/JdtToJava15
===================================================================
(Binary files differ)


Property changes on: sglr-recovery/trunk/Evaluation_Recovery/Language_Files/JdtToJava15
___________________________________________________________________
Added: svn:executable
   + *
Added: svn:mime-type
   + application/octet-stream

Added: sglr-recovery/trunk/Evaluation_Recovery/Language_Files/JdtToJava15.c
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Language_Files/JdtToJava15.c	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Language_Files/JdtToJava15.c	2009-06-26 14:09:23 UTC (rev 19570)
@@ -0,0 +1,1937 @@
+#include <srts/stratego.h>
+#include <stratego-lib/stratego-lib.h>
+void init_constructors (void)
+{
+}
+static Symbol sym__2;
+static Symbol sym_Id_1;
+static Symbol sym_Public_0;
+static Symbol sym_Private_0;
+static Symbol sym_Static_0;
+static Symbol sym_Deci_1;
+static Symbol sym_Bool_1;
+static Symbol sym_True_0;
+static Symbol sym_False_0;
+static Symbol sym_String_1;
+static Symbol sym_Chars_1;
+static Symbol sym_Boolean_0;
+static Symbol sym_Int_0;
+static Symbol sym_PackageName_1;
+static Symbol sym_TypeName_1;
+static Symbol sym_TypeName_2;
+static Symbol sym_ExprName_1;
+static Symbol sym_MethodName_1;
+static Symbol sym_PackageOrTypeName_1;
+static Symbol sym_PackageOrTypeName_2;
+static Symbol sym_ClassOrInterfaceType_2;
+static Symbol sym_Lit_1;
+static Symbol sym_Invoke_2;
+static Symbol sym_Not_1;
+static Symbol sym_Lt_2;
+static Symbol sym_Gt_2;
+static Symbol sym_LtEq_2;
+static Symbol sym_GtEq_2;
+static Symbol sym_Eq_2;
+static Symbol sym_NotEq_2;
+static Symbol sym_Assign_2;
+static Symbol sym_FieldDec_3;
+static Symbol sym_VarDec_1;
+static Symbol sym_VarDec_2;
+static Symbol sym_LocalVarDecStm_1;
+static Symbol sym_LocalVarDec_3;
+static Symbol sym_If_2;
+static Symbol sym_If_3;
+static Symbol sym_While_2;
+static Symbol sym_Return_1;
+static Symbol sym_ExprStm_1;
+static Symbol sym_Block_1;
+static Symbol sym_MethodDec_2;
+static Symbol sym_MethodDecHead_6;
+static Symbol sym_Void_0;
+static Symbol sym_Param_3;
+static Symbol sym_EnumDecHead_3;
+static Symbol sym_EnumBody_2;
+static Symbol sym_EnumConst_3;
+static Symbol sym_ClassDec_2;
+static Symbol sym_ClassBody_1;
+static Symbol sym_ClassDecHead_5;
+static Symbol sym_Method_1;
+static Symbol sym_PackageDec_2;
+static Symbol sym_TypeImportDec_1;
+static Symbol sym_Nil_0;
+static Symbol sym_Cons_2;
+static Symbol sym_None_0;
+static Symbol sym_Some_1;
+static Symbol sym_Initializer_1;
+static Symbol sym_WhileStatement_2;
+static Symbol sym_FieldDeclaration_4;
+static Symbol sym_PrefixExpressionOperator_1;
+static Symbol sym_PrefixExpression_2;
+static Symbol sym_InfixExpression_4;
+static Symbol sym_IfStatement_3;
+static Symbol sym_MethodInvocation_4;
+static Symbol sym_VariableDeclarationFragment_3;
+static Symbol sym_VariableDeclarationStatement_3;
+static Symbol sym_AssignmentOperator_1;
+static Symbol sym_Assignment_3;
+static Symbol sym_ReturnStatement_1;
+static Symbol sym_ExpressionStatement_1;
+static Symbol sym_BooleanLiteral_1;
+static Symbol sym_StringLiteral_1;
+static Symbol sym_NumberLiteral_1;
+static Symbol sym_SingleVariableDeclaration_5;
+static Symbol sym_SimpleType_1;
+static Symbol sym_ModifierKeyword_1;
+static Symbol sym_Modifier_1;
+static Symbol sym_PrimitiveType_1;
+static Symbol sym_MethodDeclaration_8;
+static Symbol sym_QualifiedName_2;
+static Symbol sym_ImportDeclaration_3;
+static Symbol sym_PackageDeclaration_3;
+static Symbol sym_TypeDeclaration_8;
+static Symbol sym_SimpleName_1;
+static void init_module_constructors (void)
+{
+sym__2 = ATmakeSymbol("", 2, ATfalse);
+ATprotectSymbol(sym__2);
+sym_Id_1 = ATmakeSymbol("Id", 1, ATfalse);
+ATprotectSymbol(sym_Id_1);
+sym_Public_0 = ATmakeSymbol("Public", 0, ATfalse);
+ATprotectSymbol(sym_Public_0);
+sym_Private_0 = ATmakeSymbol("Private", 0, ATfalse);
+ATprotectSymbol(sym_Private_0);
+sym_Static_0 = ATmakeSymbol("Static", 0, ATfalse);
+ATprotectSymbol(sym_Static_0);
+sym_Deci_1 = ATmakeSymbol("Deci", 1, ATfalse);
+ATprotectSymbol(sym_Deci_1);
+sym_Bool_1 = ATmakeSymbol("Bool", 1, ATfalse);
+ATprotectSymbol(sym_Bool_1);
+sym_True_0 = ATmakeSymbol("True", 0, ATfalse);
+ATprotectSymbol(sym_True_0);
+sym_False_0 = ATmakeSymbol("False", 0, ATfalse);
+ATprotectSymbol(sym_False_0);
+sym_String_1 = ATmakeSymbol("String", 1, ATfalse);
+ATprotectSymbol(sym_String_1);
+sym_Chars_1 = ATmakeSymbol("Chars", 1, ATfalse);
+ATprotectSymbol(sym_Chars_1);
+sym_Boolean_0 = ATmakeSymbol("Boolean", 0, ATfalse);
+ATprotectSymbol(sym_Boolean_0);
+sym_Int_0 = ATmakeSymbol("Int", 0, ATfalse);
+ATprotectSymbol(sym_Int_0);
+sym_PackageName_1 = ATmakeSymbol("PackageName", 1, ATfalse);
+ATprotectSymbol(sym_PackageName_1);
+sym_TypeName_1 = ATmakeSymbol("TypeName", 1, ATfalse);
+ATprotectSymbol(sym_TypeName_1);
+sym_TypeName_2 = ATmakeSymbol("TypeName", 2, ATfalse);
+ATprotectSymbol(sym_TypeName_2);
+sym_ExprName_1 = ATmakeSymbol("ExprName", 1, ATfalse);
+ATprotectSymbol(sym_ExprName_1);
+sym_MethodName_1 = ATmakeSymbol("MethodName", 1, ATfalse);
+ATprotectSymbol(sym_MethodName_1);
+sym_PackageOrTypeName_1 = ATmakeSymbol("PackageOrTypeName", 1, ATfalse);
+ATprotectSymbol(sym_PackageOrTypeName_1);
+sym_PackageOrTypeName_2 = ATmakeSymbol("PackageOrTypeName", 2, ATfalse);
+ATprotectSymbol(sym_PackageOrTypeName_2);
+sym_ClassOrInterfaceType_2 = ATmakeSymbol("ClassOrInterfaceType", 2, ATfalse);
+ATprotectSymbol(sym_ClassOrInterfaceType_2);
+sym_Lit_1 = ATmakeSymbol("Lit", 1, ATfalse);
+ATprotectSymbol(sym_Lit_1);
+sym_Invoke_2 = ATmakeSymbol("Invoke", 2, ATfalse);
+ATprotectSymbol(sym_Invoke_2);
+sym_Not_1 = ATmakeSymbol("Not", 1, ATfalse);
+ATprotectSymbol(sym_Not_1);
+sym_Lt_2 = ATmakeSymbol("Lt", 2, ATfalse);
+ATprotectSymbol(sym_Lt_2);
+sym_Gt_2 = ATmakeSymbol("Gt", 2, ATfalse);
+ATprotectSymbol(sym_Gt_2);
+sym_LtEq_2 = ATmakeSymbol("LtEq", 2, ATfalse);
+ATprotectSymbol(sym_LtEq_2);
+sym_GtEq_2 = ATmakeSymbol("GtEq", 2, ATfalse);
+ATprotectSymbol(sym_GtEq_2);
+sym_Eq_2 = ATmakeSymbol("Eq", 2, ATfalse);
+ATprotectSymbol(sym_Eq_2);
+sym_NotEq_2 = ATmakeSymbol("NotEq", 2, ATfalse);
+ATprotectSymbol(sym_NotEq_2);
+sym_Assign_2 = ATmakeSymbol("Assign", 2, ATfalse);
+ATprotectSymbol(sym_Assign_2);
+sym_FieldDec_3 = ATmakeSymbol("FieldDec", 3, ATfalse);
+ATprotectSymbol(sym_FieldDec_3);
+sym_VarDec_1 = ATmakeSymbol("VarDec", 1, ATfalse);
+ATprotectSymbol(sym_VarDec_1);
+sym_VarDec_2 = ATmakeSymbol("VarDec", 2, ATfalse);
+ATprotectSymbol(sym_VarDec_2);
+sym_LocalVarDecStm_1 = ATmakeSymbol("LocalVarDecStm", 1, ATfalse);
+ATprotectSymbol(sym_LocalVarDecStm_1);
+sym_LocalVarDec_3 = ATmakeSymbol("LocalVarDec", 3, ATfalse);
+ATprotectSymbol(sym_LocalVarDec_3);
+sym_If_2 = ATmakeSymbol("If", 2, ATfalse);
+ATprotectSymbol(sym_If_2);
+sym_If_3 = ATmakeSymbol("If", 3, ATfalse);
+ATprotectSymbol(sym_If_3);
+sym_While_2 = ATmakeSymbol("While", 2, ATfalse);
+ATprotectSymbol(sym_While_2);
+sym_Return_1 = ATmakeSymbol("Return", 1, ATfalse);
+ATprotectSymbol(sym_Return_1);
+sym_ExprStm_1 = ATmakeSymbol("ExprStm", 1, ATfalse);
+ATprotectSymbol(sym_ExprStm_1);
+sym_Block_1 = ATmakeSymbol("Block", 1, ATfalse);
+ATprotectSymbol(sym_Block_1);
+sym_MethodDec_2 = ATmakeSymbol("MethodDec", 2, ATfalse);
+ATprotectSymbol(sym_MethodDec_2);
+sym_MethodDecHead_6 = ATmakeSymbol("MethodDecHead", 6, ATfalse);
+ATprotectSymbol(sym_MethodDecHead_6);
+sym_Void_0 = ATmakeSymbol("Void", 0, ATfalse);
+ATprotectSymbol(sym_Void_0);
+sym_Param_3 = ATmakeSymbol("Param", 3, ATfalse);
+ATprotectSymbol(sym_Param_3);
+sym_EnumDecHead_3 = ATmakeSymbol("EnumDecHead", 3, ATfalse);
+ATprotectSymbol(sym_EnumDecHead_3);
+sym_EnumBody_2 = ATmakeSymbol("EnumBody", 2, ATfalse);
+ATprotectSymbol(sym_EnumBody_2);
+sym_EnumConst_3 = ATmakeSymbol("EnumConst", 3, ATfalse);
+ATprotectSymbol(sym_EnumConst_3);
+sym_ClassDec_2 = ATmakeSymbol("ClassDec", 2, ATfalse);
+ATprotectSymbol(sym_ClassDec_2);
+sym_ClassBody_1 = ATmakeSymbol("ClassBody", 1, ATfalse);
+ATprotectSymbol(sym_ClassBody_1);
+sym_ClassDecHead_5 = ATmakeSymbol("ClassDecHead", 5, ATfalse);
+ATprotectSymbol(sym_ClassDecHead_5);
+sym_Method_1 = ATmakeSymbol("Method", 1, ATfalse);
+ATprotectSymbol(sym_Method_1);
+sym_PackageDec_2 = ATmakeSymbol("PackageDec", 2, ATfalse);
+ATprotectSymbol(sym_PackageDec_2);
+sym_TypeImportDec_1 = ATmakeSymbol("TypeImportDec", 1, ATfalse);
+ATprotectSymbol(sym_TypeImportDec_1);
+sym_Nil_0 = ATmakeSymbol("Nil", 0, ATfalse);
+ATprotectSymbol(sym_Nil_0);
+sym_Cons_2 = ATmakeSymbol("Cons", 2, ATfalse);
+ATprotectSymbol(sym_Cons_2);
+sym_None_0 = ATmakeSymbol("None", 0, ATfalse);
+ATprotectSymbol(sym_None_0);
+sym_Some_1 = ATmakeSymbol("Some", 1, ATfalse);
+ATprotectSymbol(sym_Some_1);
+sym_Initializer_1 = ATmakeSymbol("Initializer", 1, ATfalse);
+ATprotectSymbol(sym_Initializer_1);
+sym_WhileStatement_2 = ATmakeSymbol("WhileStatement", 2, ATfalse);
+ATprotectSymbol(sym_WhileStatement_2);
+sym_FieldDeclaration_4 = ATmakeSymbol("FieldDeclaration", 4, ATfalse);
+ATprotectSymbol(sym_FieldDeclaration_4);
+sym_PrefixExpressionOperator_1 = ATmakeSymbol("PrefixExpressionOperator", 1, ATfalse);
+ATprotectSymbol(sym_PrefixExpressionOperator_1);
+sym_PrefixExpression_2 = ATmakeSymbol("PrefixExpression", 2, ATfalse);
+ATprotectSymbol(sym_PrefixExpression_2);
+sym_InfixExpression_4 = ATmakeSymbol("InfixExpression", 4, ATfalse);
+ATprotectSymbol(sym_InfixExpression_4);
+sym_IfStatement_3 = ATmakeSymbol("IfStatement", 3, ATfalse);
+ATprotectSymbol(sym_IfStatement_3);
+sym_MethodInvocation_4 = ATmakeSymbol("MethodInvocation", 4, ATfalse);
+ATprotectSymbol(sym_MethodInvocation_4);
+sym_VariableDeclarationFragment_3 = ATmakeSymbol("VariableDeclarationFragment", 3, ATfalse);
+ATprotectSymbol(sym_VariableDeclarationFragment_3);
+sym_VariableDeclarationStatement_3 = ATmakeSymbol("VariableDeclarationStatement", 3, ATfalse);
+ATprotectSymbol(sym_VariableDeclarationStatement_3);
+sym_AssignmentOperator_1 = ATmakeSymbol("AssignmentOperator", 1, ATfalse);
+ATprotectSymbol(sym_AssignmentOperator_1);
+sym_Assignment_3 = ATmakeSymbol("Assignment", 3, ATfalse);
+ATprotectSymbol(sym_Assignment_3);
+sym_ReturnStatement_1 = ATmakeSymbol("ReturnStatement", 1, ATfalse);
+ATprotectSymbol(sym_ReturnStatement_1);
+sym_ExpressionStatement_1 = ATmakeSymbol("ExpressionStatement", 1, ATfalse);
+ATprotectSymbol(sym_ExpressionStatement_1);
+sym_BooleanLiteral_1 = ATmakeSymbol("BooleanLiteral", 1, ATfalse);
+ATprotectSymbol(sym_BooleanLiteral_1);
+sym_StringLiteral_1 = ATmakeSymbol("StringLiteral", 1, ATfalse);
+ATprotectSymbol(sym_StringLiteral_1);
+sym_NumberLiteral_1 = ATmakeSymbol("NumberLiteral", 1, ATfalse);
+ATprotectSymbol(sym_NumberLiteral_1);
+sym_SingleVariableDeclaration_5 = ATmakeSymbol("SingleVariableDeclaration", 5, ATfalse);
+ATprotectSymbol(sym_SingleVariableDeclaration_5);
+sym_SimpleType_1 = ATmakeSymbol("SimpleType", 1, ATfalse);
+ATprotectSymbol(sym_SimpleType_1);
+sym_ModifierKeyword_1 = ATmakeSymbol("ModifierKeyword", 1, ATfalse);
+ATprotectSymbol(sym_ModifierKeyword_1);
+sym_Modifier_1 = ATmakeSymbol("Modifier", 1, ATfalse);
+ATprotectSymbol(sym_Modifier_1);
+sym_PrimitiveType_1 = ATmakeSymbol("PrimitiveType", 1, ATfalse);
+ATprotectSymbol(sym_PrimitiveType_1);
+sym_MethodDeclaration_8 = ATmakeSymbol("MethodDeclaration", 8, ATfalse);
+ATprotectSymbol(sym_MethodDeclaration_8);
+sym_QualifiedName_2 = ATmakeSymbol("QualifiedName", 2, ATfalse);
+ATprotectSymbol(sym_QualifiedName_2);
+sym_ImportDeclaration_3 = ATmakeSymbol("ImportDeclaration", 3, ATfalse);
+ATprotectSymbol(sym_ImportDeclaration_3);
+sym_PackageDeclaration_3 = ATmakeSymbol("PackageDeclaration", 3, ATfalse);
+ATprotectSymbol(sym_PackageDeclaration_3);
+sym_TypeDeclaration_8 = ATmakeSymbol("TypeDeclaration", 8, ATfalse);
+ATprotectSymbol(sym_TypeDeclaration_8);
+sym_SimpleName_1 = ATmakeSymbol("SimpleName", 1, ATfalse);
+ATprotectSymbol(sym_SimpleName_1);
+}
+static ATerm term25;
+static ATerm term24;
+static ATerm term23;
+static ATerm term22;
+static ATerm term21;
+static ATerm term20;
+static ATerm term19;
+static ATerm term18;
+static ATerm term17;
+static ATerm term16;
+static ATerm term15;
+static ATerm term14;
+static ATerm term13;
+static ATerm term12;
+static ATerm term11;
+static ATerm term10;
+static ATerm term9;
+static ATerm term8;
+static ATerm term7;
+static ATerm term6;
+static ATerm term5;
+static ATerm term4;
+static ATerm term3;
+static ATerm term2;
+static ATerm term1;
+static ATerm term0;
+static void init_module_constant_terms (void)
+{
+ATprotect(&(term0));
+term0 = (ATerm) ATmakeAppl(sym_None_0);
+ATprotect(&(term1));
+term1 = term0;
+ATprotect(&(term2));
+term2 = (ATerm) ATmakeAppl(sym_True_0);
+ATprotect(&(term3));
+term3 = term2;
+ATprotect(&(term4));
+term4 = (ATerm) ATmakeAppl(sym_Bool_1, term3);
+ATprotect(&(term5));
+term5 = term4;
+ATprotect(&(term6));
+term6 = (ATerm) ATmakeAppl(sym_Lit_1, term5);
+ATprotect(&(term7));
+term7 = term6;
+ATprotect(&(term8));
+term8 = (ATerm) ATmakeAppl(sym_False_0);
+ATprotect(&(term9));
+term9 = term8;
+ATprotect(&(term10));
+term10 = (ATerm) ATmakeAppl(sym_Bool_1, term9);
+ATprotect(&(term11));
+term11 = term10;
+ATprotect(&(term12));
+term12 = (ATerm) ATmakeAppl(sym_Lit_1, term11);
+ATprotect(&(term13));
+term13 = term12;
+ATprotect(&(term14));
+term14 = (ATerm) ATmakeAppl(sym_Boolean_0);
+ATprotect(&(term15));
+term15 = term14;
+ATprotect(&(term16));
+term16 = (ATerm) ATmakeAppl(sym_Int_0);
+ATprotect(&(term17));
+term17 = term16;
+ATprotect(&(term18));
+term18 = (ATerm) ATmakeAppl(sym_Void_0);
+ATprotect(&(term19));
+term19 = term18;
+ATprotect(&(term20));
+term20 = (ATerm) ATmakeAppl(sym_Public_0);
+ATprotect(&(term21));
+term21 = term20;
+ATprotect(&(term22));
+term22 = (ATerm) ATmakeAppl(sym_Private_0);
+ATprotect(&(term23));
+term23 = term22;
+ATprotect(&(term24));
+term24 = (ATerm) ATmakeAppl(sym_Static_0);
+ATprotect(&(term25));
+term25 = term24;
+}
+#include <srts/init-stratego-application.h>
+extern const char * __tracing_table [];
+extern unsigned short __tracing_table_counter;
+ATerm conc_0_0 (StrSL sl, ATerm t);
+ATerm map_1_0 (StrSL sl, StrCL b_83, ATerm t);
+ATerm try_1_0 (StrSL sl, StrCL p_60, ATerm t);
+ATerm topdown_1_0 (StrSL sl, StrCL b_53, ATerm t);
+ATerm outermost_1_0 (StrSL sl, StrCL t_51, ATerm t);
+ATerm io_wrap_1_0 (StrSL sl, StrCL k_44, ATerm t);
+static ATerm lifted6 (StrSL sl, ATerm t);
+ATerm rewriteAst_0_0 (StrSL sl, ATerm t);
+static ATerm lifted4 (StrSL sl, ATerm t);
+static ATerm lifted3 (StrSL sl, ATerm t);
+static ATerm lifted2 (StrSL sl, ATerm t);
+static ATerm lifted1 (StrSL sl, ATerm t);
+ATerm main_0_0 (StrSL sl, ATerm t);
+ATerm Stm_0_0 (StrSL sl, ATerm t);
+ATerm ModKey_0_0 (StrSL sl, ATerm t);
+ATerm RewriteMethod_0_0 (StrSL sl, ATerm t);
+ATerm RewritePrimitive_0_0 (StrSL sl, ATerm t);
+ATerm Import_0_0 (StrSL sl, ATerm t);
+static ATerm lifted0 (StrSL sl, ATerm t);
+ATerm T_0_0 (StrSL sl, ATerm t);
+ATerm RP_0_0 (StrSL sl, ATerm t);
+ATerm RewriteClass_0_0 (StrSL sl, ATerm t);
+ATerm rewriteAst_0_0 (StrSL sl, ATerm t)
+{
+__tracing_table[__tracing_table_counter++] = "rewriteAst_0_0";
+sl_decl(sl);
+{
+struct str_closure o_160 = { &(lifted6) , &(frame) };
+StrCL lifted6_cl = &(o_160);
+t = outermost_1_0(sl, lifted6_cl, t);
+if((t == NULL))
+goto fail14 ;
+}
+__tracing_table[--__tracing_table_counter] = NULL;
+return(t);
+fail14 :
+--__tracing_table_counter;
+return(NULL);
+}
+static ATerm lifted6 (StrSL sl, ATerm t)
+{
+__tracing_table[__tracing_table_counter++] = "lifted6";
+sl_decl(sl);
+{
+ATerm trm102 = t;
+ATerm trm103 = t;
+ATerm trm104 = t;
+ATerm trm105 = t;
+ATerm trm106 = t;
+ATerm trm107 = t;
+ATerm trm108 = t;
+ATerm trm109 = t;
+ATerm trm110 = t;
+ATerm trm111 = t;
+ATerm trm112 = t;
+t = T_0_0(sl_up(sl), t);
+if((t == NULL))
+goto label61 ;
+goto label60 ;
+label61 :
+t = trm112;
+{
+ATerm j_159 = NULL,k_159 = NULL;
+if(match_cons(t, sym_VarDec_2))
+{
+j_159 = ATgetArgument(t, 0);
+{
+ATerm trm113 = ATgetArgument(t, 1);
+if(!(match_cons(trm113, sym_None_0)))
+goto label59 ;
+}
+}
+else
+goto label59 ;

(2029 diff lines omitted)


From mdjonge at xs4all.nl  Fri Jun 26 16:27:18 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Fri, 26 Jun 2009 14:27:18 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19571 - MaartjeDeJonge
	- sglr-recovery/trunk
Message-ID: <200906261425.n5QEPtU6008650@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-26 14:27:18 +0000 (Fri, 26 Jun 2009)
New Revision: 19571

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19571&view=rev

Added:
   sglr-recovery/trunk/lpg.runtime.java/

Log:
Initial import.

Changes:



From mdjonge at xs4all.nl  Fri Jun 26 16:27:53 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Fri, 26 Jun 2009 14:27:53 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19572 - MaartjeDeJonge
	- in sglr-recovery/trunk/lpg.runtime.java: . .settings
	META-INF docs src src/lpg src/lpg/runtime
Message-ID: <200906261426.n5QEQUhO008655@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-26 14:27:53 +0000 (Fri, 26 Jun 2009)
New Revision: 19572

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19572&view=rev

Added:
   sglr-recovery/trunk/lpg.runtime.java/.classpath
   sglr-recovery/trunk/lpg.runtime.java/.cvsignore
   sglr-recovery/trunk/lpg.runtime.java/.project
   sglr-recovery/trunk/lpg.runtime.java/.settings/
   sglr-recovery/trunk/lpg.runtime.java/.settings/org.eclipse.jdt.core.prefs
   sglr-recovery/trunk/lpg.runtime.java/.settings/org.eclipse.jdt.ui.prefs
   sglr-recovery/trunk/lpg.runtime.java/Eclipse Public License - Version 1_0.htm
   sglr-recovery/trunk/lpg.runtime.java/META-INF/
   sglr-recovery/trunk/lpg.runtime.java/META-INF/MANIFEST.MF
   sglr-recovery/trunk/lpg.runtime.java/build-user.xml
   sglr-recovery/trunk/lpg.runtime.java/build.properties
   sglr-recovery/trunk/lpg.runtime.java/cruise-build.xml
   sglr-recovery/trunk/lpg.runtime.java/docs/
   sglr-recovery/trunk/lpg.runtime.java/docs/Readme.txt
   sglr-recovery/trunk/lpg.runtime.java/exportPlugin.xml
   sglr-recovery/trunk/lpg.runtime.java/src/
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/.cvsignore
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/AbstractToken.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/Adjunct.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/BacktrackingParser.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/BadParseException.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/BadParseSymFileException.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/ConfigurationElement.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/ConfigurationStack.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/DeterministicParser.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/DiagnoseParser.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/Differ.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/DifferLines.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/DifferTokens.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/ErrorToken.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/IAbstractArrayList.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/IAst.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/IAstVisitor.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/ILexStream.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/IMessageHandler.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/IPrsStream.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/IToken.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/IntSegmentedTuple.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/IntTuple.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/LexParser.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/LexStream.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/LpgLexStream.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/Messages.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/MismatchedInputCharsException.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/Monitor.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/NotBacktrackParseTableException.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/NotDeterministicParseTableException.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/NullExportedSymbolsException.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/NullTerminalSymbolsException.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/ObjectTuple.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/ParseErrorCodes.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/ParseTable.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/PrsStream.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/RecoveryParser.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/RuleAction.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/Stacks.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/StateElement.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/Token.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/TokenStream.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/TokenStreamNotIPrsStreamException.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/UnavailableParserInformationException.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/UndefinedEofSymbolException.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/UnimplementedTerminalsException.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/UnknownStreamType.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/Utf8LexStream.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/Utf8LpgLexStream.java
   sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/messages.properties

Log:


Changes (first 1000 lines of the diffs):

Added: sglr-recovery/trunk/lpg.runtime.java/.classpath
===================================================================
--- sglr-recovery/trunk/lpg.runtime.java/.classpath	                        (rev 0)
+++ sglr-recovery/trunk/lpg.runtime.java/.classpath	2009-06-26 14:27:53 UTC (rev 19572)
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>

Added: sglr-recovery/trunk/lpg.runtime.java/.cvsignore
===================================================================
--- sglr-recovery/trunk/lpg.runtime.java/.cvsignore	                        (rev 0)
+++ sglr-recovery/trunk/lpg.runtime.java/.cvsignore	2009-06-26 14:27:53 UTC (rev 19572)
@@ -0,0 +1,3 @@
+bin
+lpg.runtime*.jar
+lpgruntime.jar

Added: sglr-recovery/trunk/lpg.runtime.java/.project
===================================================================
--- sglr-recovery/trunk/lpg.runtime.java/.project	                        (rev 0)
+++ sglr-recovery/trunk/lpg.runtime.java/.project	2009-06-26 14:27:53 UTC (rev 19572)
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>lpg.runtime.java</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.pde.ManifestBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.pde.SchemaBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.pde.PluginNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>

Added: sglr-recovery/trunk/lpg.runtime.java/.settings/org.eclipse.jdt.core.prefs
===================================================================
--- sglr-recovery/trunk/lpg.runtime.java/.settings/org.eclipse.jdt.core.prefs	                        (rev 0)
+++ sglr-recovery/trunk/lpg.runtime.java/.settings/org.eclipse.jdt.core.prefs	2009-06-26 14:27:53 UTC (rev 19572)
@@ -0,0 +1,12 @@
+#Tue Feb 20 13:59:35 EST 2007
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.5
+org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
+org.eclipse.jdt.core.compiler.compliance=1.5
+org.eclipse.jdt.core.compiler.debug.lineNumber=generate
+org.eclipse.jdt.core.compiler.debug.localVariable=generate
+org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.source=1.5

Added: sglr-recovery/trunk/lpg.runtime.java/.settings/org.eclipse.jdt.ui.prefs
===================================================================
--- sglr-recovery/trunk/lpg.runtime.java/.settings/org.eclipse.jdt.ui.prefs	                        (rev 0)
+++ sglr-recovery/trunk/lpg.runtime.java/.settings/org.eclipse.jdt.ui.prefs	2009-06-26 14:27:53 UTC (rev 19572)
@@ -0,0 +1,3 @@
+#Tue Feb 20 13:59:35 EST 2007
+eclipse.preferences.version=1
+internal.default.compliance=default

Added: sglr-recovery/trunk/lpg.runtime.java/Eclipse Public License - Version 1_0.htm
===================================================================
--- sglr-recovery/trunk/lpg.runtime.java/Eclipse Public License - Version 1_0.htm	                        (rev 0)
+++ sglr-recovery/trunk/lpg.runtime.java/Eclipse Public License - Version 1_0.htm	2009-06-26 14:27:53 UTC (rev 19572)
@@ -0,0 +1,328 @@
+<html xmlns:o="urn:schemas-microsoft-com:office:office"
+xmlns:w="urn:schemas-microsoft-com:office:word"
+xmlns="http://www.w3.org/TR/REC-html40">
+
+<head>
+<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
+<meta name=ProgId content=Word.Document>
+<meta name=Generator content="Microsoft Word 9">
+<meta name=Originator content="Microsoft Word 9">
+<link rel=File-List
+href="./Eclipse%20EPL%202003_11_10%20Final_files/filelist.xml">
+<title>Eclipse Public License - Version 1.0</title>
+<!--[if gte mso 9]><xml>
+ <o:DocumentProperties>
+  <o:Revision>2</o:Revision>
+  <o:TotalTime>3</o:TotalTime>
+  <o:Created>2004-03-05T23:03:00Z</o:Created>
+  <o:LastSaved>2004-03-05T23:03:00Z</o:LastSaved>
+  <o:Pages>4</o:Pages>
+  <o:Words>1626</o:Words>
+  <o:Characters>9270</o:Characters>
+   <o:Lines>77</o:Lines>
+  <o:Paragraphs>18</o:Paragraphs>
+  <o:CharactersWithSpaces>11384</o:CharactersWithSpaces>
+  <o:Version>9.4402</o:Version>
+ </o:DocumentProperties>
+</xml><![endif]--><!--[if gte mso 9]><xml>
+ <w:WordDocument>
+  <w:TrackRevisions/>
+ </w:WordDocument>
+</xml><![endif]-->
+<style>
+<!--
+ /* Font Definitions */
+ at font-face
+	{font-family:Tahoma;
+	panose-1:2 11 6 4 3 5 4 4 2 4;
+	mso-font-charset:0;
+	mso-generic-font-family:swiss;
+	mso-font-pitch:variable;
+	mso-font-signature:553679495 -2147483648 8 0 66047 0;}
+ /* Style Definitions */
+p.MsoNormal, li.MsoNormal, div.MsoNormal
+	{mso-style-parent:"";
+	margin:0in;
+	margin-bottom:.0001pt;
+	mso-pagination:widow-orphan;
+	font-size:12.0pt;
+	font-family:"Times New Roman";
+	mso-fareast-font-family:"Times New Roman";}
+p
+	{margin-right:0in;
+	mso-margin-top-alt:auto;
+	mso-margin-bottom-alt:auto;
+	margin-left:0in;
+	mso-pagination:widow-orphan;
+	font-size:12.0pt;
+	font-family:"Times New Roman";
+	mso-fareast-font-family:"Times New Roman";}
+p.BalloonText, li.BalloonText, div.BalloonText
+	{mso-style-name:"Balloon Text";
+	margin:0in;
+	margin-bottom:.0001pt;
+	mso-pagination:widow-orphan;
+	font-size:8.0pt;
+	font-family:Tahoma;
+	mso-fareast-font-family:"Times New Roman";}
+ at page Section1
+	{size:8.5in 11.0in;
+	margin:1.0in 1.25in 1.0in 1.25in;
+	mso-header-margin:.5in;
+	mso-footer-margin:.5in;
+	mso-paper-source:0;}
+div.Section1
+	{page:Section1;}
+-->
+</style>
+</head>
+
+<body lang=EN-US style='tab-interval:.5in'>
+
+<div class=Section1>
+
+<p align=center style='text-align:center'><b>Eclipse Public License - v 1.0</b>
+</p>
+
+<p><span style='font-size:10.0pt'>THE ACCOMPANYING PROGRAM IS PROVIDED UNDER
+THE TERMS OF THIS ECLIPSE PUBLIC LICENSE (&quot;AGREEMENT&quot;). ANY USE,
+REPRODUCTION OR DISTRIBUTION OF THE PROGRAM CONSTITUTES RECIPIENT'S ACCEPTANCE
+OF THIS AGREEMENT.</span> </p>
+
+<p><b><span style='font-size:10.0pt'>1. DEFINITIONS</span></b> </p>
+
+<p><span style='font-size:10.0pt'>&quot;Contribution&quot; means:</span> </p>
+
+<p class=MsoNormal style='margin-left:.5in'><span style='font-size:10.0pt'>a)
+in the case of the initial Contributor, the initial code and documentation
+distributed under this Agreement, and<br clear=left>
+b) in the case of each subsequent Contributor:</span></p>
+
+<p class=MsoNormal style='margin-left:.5in'><span style='font-size:10.0pt'>i)
+changes to the Program, and</span></p>
+
+<p class=MsoNormal style='margin-left:.5in'><span style='font-size:10.0pt'>ii)
+additions to the Program;</span></p>
+
+<p class=MsoNormal style='margin-left:.5in'><span style='font-size:10.0pt'>where
+such changes and/or additions to the Program originate from and are distributed
+by that particular Contributor. A Contribution 'originates' from a Contributor
+if it was added to the Program by such Contributor itself or anyone acting on
+such Contributor's behalf. Contributions do not include additions to the
+Program which: (i) are separate modules of software distributed in conjunction
+with the Program under their own license agreement, and (ii) are not derivative
+works of the Program. </span></p>
+
+<p><span style='font-size:10.0pt'>&quot;Contributor&quot; means any person or
+entity that distributes the Program.</span> </p>
+
+<p><span style='font-size:10.0pt'>&quot;Licensed Patents &quot; mean patent
+claims licensable by a Contributor which are necessarily infringed by the use
+or sale of its Contribution alone or when combined with the Program. </span></p>
+
+<p><span style='font-size:10.0pt'>&quot;Program&quot; means the Contributions
+distributed in accordance with this Agreement.</span> </p>
+
+<p><span style='font-size:10.0pt'>&quot;Recipient&quot; means anyone who
+receives the Program under this Agreement, including all Contributors.</span> </p>
+
+<p><b><span style='font-size:10.0pt'>2. GRANT OF RIGHTS</span></b> </p>
+
+<p class=MsoNormal style='margin-left:.5in'><span style='font-size:10.0pt'>a)
+Subject to the terms of this Agreement, each Contributor hereby grants Recipient
+a non-exclusive, worldwide, royalty-free copyright license to<span
+style='color:red'> </span>reproduce, prepare derivative works of, publicly
+display, publicly perform, distribute and sublicense the Contribution of such
+Contributor, if any, and such derivative works, in source code and object code
+form.</span></p>
+
+<p class=MsoNormal style='margin-left:.5in'><span style='font-size:10.0pt'>b)
+Subject to the terms of this Agreement, each Contributor hereby grants
+Recipient a non-exclusive, worldwide,<span style='color:green'> </span>royalty-free
+patent license under Licensed Patents to make, use, sell, offer to sell, import
+and otherwise transfer the Contribution of such Contributor, if any, in source
+code and object code form. This patent license shall apply to the combination
+of the Contribution and the Program if, at the time the Contribution is added
+by the Contributor, such addition of the Contribution causes such combination
+to be covered by the Licensed Patents. The patent license shall not apply to
+any other combinations which include the Contribution. No hardware per se is
+licensed hereunder. </span></p>
+
+<p class=MsoNormal style='margin-left:.5in'><span style='font-size:10.0pt'>c)
+Recipient understands that although each Contributor grants the licenses to its
+Contributions set forth herein, no assurances are provided by any Contributor
+that the Program does not infringe the patent or other intellectual property
+rights of any other entity. Each Contributor disclaims any liability to Recipient
+for claims brought by any other entity based on infringement of intellectual
+property rights or otherwise. As a condition to exercising the rights and
+licenses granted hereunder, each Recipient hereby assumes sole responsibility
+to secure any other intellectual property rights needed, if any. For example,
+if a third party patent license is required to allow Recipient to distribute
+the Program, it is Recipient's responsibility to acquire that license before
+distributing the Program.</span></p>
+
+<p class=MsoNormal style='margin-left:.5in'><span style='font-size:10.0pt'>d)
+Each Contributor represents that to its knowledge it has sufficient copyright
+rights in its Contribution, if any, to grant the copyright license set forth in
+this Agreement. </span></p>
+
+<p><b><span style='font-size:10.0pt'>3. REQUIREMENTS</span></b> </p>
+
+<p><span style='font-size:10.0pt'>A Contributor may choose to distribute the
+Program in object code form under its own license agreement, provided that:</span>
+</p>
+
+<p class=MsoNormal style='margin-left:.5in'><span style='font-size:10.0pt'>a)
+it complies with the terms and conditions of this Agreement; and</span></p>
+
+<p class=MsoNormal style='margin-left:.5in'><span style='font-size:10.0pt'>b)
+its license agreement:</span></p>
+
+<p class=MsoNormal style='margin-left:.5in'><span style='font-size:10.0pt'>i)
+effectively disclaims on behalf of all Contributors all warranties and
+conditions, express and implied, including warranties or conditions of title
+and non-infringement, and implied warranties or conditions of merchantability
+and fitness for a particular purpose; </span></p>
+
+<p class=MsoNormal style='margin-left:.5in'><span style='font-size:10.0pt'>ii)
+effectively excludes on behalf of all Contributors all liability for damages,
+including direct, indirect, special, incidental and consequential damages, such
+as lost profits; </span></p>
+
+<p class=MsoNormal style='margin-left:.5in'><span style='font-size:10.0pt'>iii)
+states that any provisions which differ from this Agreement are offered by that
+Contributor alone and not by any other party; and</span></p>
+
+<p class=MsoNormal style='margin-left:.5in'><span style='font-size:10.0pt'>iv)
+states that source code for the Program is available from such Contributor, and
+informs licensees how to obtain it in a reasonable manner on or through a
+medium customarily used for software exchange.<span style='color:blue'> </span></span></p>
+
+<p><span style='font-size:10.0pt'>When the Program is made available in source
+code form:</span> </p>
+
+<p class=MsoNormal style='margin-left:.5in'><span style='font-size:10.0pt'>a)
+it must be made available under this Agreement; and </span></p>
+
+<p class=MsoNormal style='margin-left:.5in'><span style='font-size:10.0pt'>b) a
+copy of this Agreement must be included with each copy of the Program. </span></p>
+
+<p><span style='font-size:10.0pt'>Contributors may not remove or alter any
+copyright notices contained within the Program. </span></p>
+
+<p><span style='font-size:10.0pt'>Each Contributor must identify itself as the
+originator of its Contribution, if any, in a manner that reasonably allows
+subsequent Recipients to identify the originator of the Contribution. </span></p>
+
+<p><b><span style='font-size:10.0pt'>4. COMMERCIAL DISTRIBUTION</span></b> </p>
+
+<p><span style='font-size:10.0pt'>Commercial distributors of software may
+accept certain responsibilities with respect to end users, business partners
+and the like. While this license is intended to facilitate the commercial use
+of the Program, the Contributor who includes the Program in a commercial
+product offering should do so in a manner which does not create potential
+liability for other Contributors. Therefore, if a Contributor includes the
+Program in a commercial product offering, such Contributor (&quot;Commercial
+Contributor&quot;) hereby agrees to defend and indemnify every other
+Contributor (&quot;Indemnified Contributor&quot;) against any losses, damages and
+costs (collectively &quot;Losses&quot;) arising from claims, lawsuits and other
+legal actions brought by a third party against the Indemnified Contributor to
+the extent caused by the acts or omissions of such Commercial Contributor in
+connection with its distribution of the Program in a commercial product
+offering. The obligations in this section do not apply to any claims or Losses
+relating to any actual or alleged intellectual property infringement. In order
+to qualify, an Indemnified Contributor must: a) promptly notify the Commercial
+Contributor in writing of such claim, and b) allow the Commercial Contributor
+to control, and cooperate with the Commercial Contributor in, the defense and
+any related settlement negotiations. The Indemnified Contributor may participate
+in any such claim at its own expense.</span> </p>
+
+<p><span style='font-size:10.0pt'>For example, a Contributor might include the
+Program in a commercial product offering, Product X. That Contributor is then a
+Commercial Contributor. If that Commercial Contributor then makes performance
+claims, or offers warranties related to Product X, those performance claims and
+warranties are such Commercial Contributor's responsibility alone. Under this
+section, the Commercial Contributor would have to defend claims against the
+other Contributors related to those performance claims and warranties, and if a
+court requires any other Contributor to pay any damages as a result, the
+Commercial Contributor must pay those damages.</span> </p>
+
+<p><b><span style='font-size:10.0pt'>5. NO WARRANTY</span></b> </p>
+
+<p><span style='font-size:10.0pt'>EXCEPT AS EXPRESSLY SET FORTH IN THIS
+AGREEMENT, THE PROGRAM IS PROVIDED ON AN &quot;AS IS&quot; BASIS, WITHOUT
+WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING,
+WITHOUT LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,
+MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is solely
+responsible for determining the appropriateness of using and distributing the
+Program and assumes all risks associated with its exercise of rights under this
+Agreement , including but not limited to the risks and costs of program errors,
+compliance with applicable laws, damage to or loss of data, programs or
+equipment, and unavailability or interruption of operations. </span></p>
+
+<p><b><span style='font-size:10.0pt'>6. DISCLAIMER OF LIABILITY</span></b> </p>
+
+<p><span style='font-size:10.0pt'>EXCEPT AS EXPRESSLY SET FORTH IN THIS
+AGREEMENT, NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND ON ANY THEORY
+OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OR DISTRIBUTION OF
+THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED HEREUNDER, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGES.</span> </p>
+
+<p><b><span style='font-size:10.0pt'>7. GENERAL</span></b> </p>
+
+<p><span style='font-size:10.0pt'>If any provision of this Agreement is invalid
+or unenforceable under applicable law, it shall not affect the validity or
+enforceability of the remainder of the terms of this Agreement, and without
+further action by the parties hereto, such provision shall be reformed to the
+minimum extent necessary to make such provision valid and enforceable.</span> </p>
+
+<p><span style='font-size:10.0pt'>If Recipient institutes patent litigation
+against any entity (including a cross-claim or counterclaim in a lawsuit)
+alleging that the Program itself (excluding combinations of the Program with
+other software or hardware) infringes such Recipient's patent(s), then such
+Recipient's rights granted under Section 2(b) shall terminate as of the date
+such litigation is filed. </span></p>
+
+<p><span style='font-size:10.0pt'>All Recipient's rights under this Agreement
+shall terminate if it fails to comply with any of the material terms or
+conditions of this Agreement and does not cure such failure in a reasonable
+period of time after becoming aware of such noncompliance. If all Recipient's
+rights under this Agreement terminate, Recipient agrees to cease use and
+distribution of the Program as soon as reasonably practicable. However,
+Recipient's obligations under this Agreement and any licenses granted by
+Recipient relating to the Program shall continue and survive. </span></p>
+
+<p><span style='font-size:10.0pt'>Everyone is permitted to copy and distribute
+copies of this Agreement, but in order to avoid inconsistency the Agreement is
+copyrighted and may only be modified in the following manner. The Agreement
+Steward reserves the right to publish new versions (including revisions) of
+this Agreement from time to time. No one other than the Agreement Steward has
+the right to modify this Agreement. The Eclipse Foundation is the initial
+Agreement Steward. The Eclipse Foundation may assign the responsibility to
+serve as the Agreement Steward to a suitable separate entity. Each new version
+of the Agreement will be given a distinguishing version number. The Program
+(including Contributions) may always be distributed subject to the version of
+the Agreement under which it was received. In addition, after a new version of
+the Agreement is published, Contributor may elect to distribute the Program
+(including its Contributions) under the new version. Except as expressly stated
+in Sections 2(a) and 2(b) above, Recipient receives no rights or licenses to
+the intellectual property of any Contributor under this Agreement, whether
+expressly, by implication, estoppel or otherwise. All rights in the Program not
+expressly granted under this Agreement are reserved.</span> </p>
+
+<p><span style='font-size:10.0pt'>This Agreement is governed by the laws of the
+State of New York and the intellectual property laws of the United States of
+America. No party to this Agreement will bring a legal action under this
+Agreement more than one year after the cause of action arose. Each party waives
+its rights to a jury trial in any resulting litigation.</span> </p>
+
+<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>
+
+</div>
+
+</body>
+
+</html>
\ No newline at end of file

Added: sglr-recovery/trunk/lpg.runtime.java/META-INF/MANIFEST.MF
===================================================================
--- sglr-recovery/trunk/lpg.runtime.java/META-INF/MANIFEST.MF	                        (rev 0)
+++ sglr-recovery/trunk/lpg.runtime.java/META-INF/MANIFEST.MF	2009-06-26 14:27:53 UTC (rev 19572)
@@ -0,0 +1,9 @@
+Manifest-Version: 1.0
+Bundle-ManifestVersion: 2
+Bundle-Name: LPG Java Runtime
+Bundle-SymbolicName: lpg.runtime
+Bundle-ClassPath: lpgruntime.jar
+Bundle-Version: 2.0.17
+Bundle-Vendor: pcharles at us.ibm.com
+Bundle-Localization: plugin
+Export-Package: lpg.runtime

Added: sglr-recovery/trunk/lpg.runtime.java/build-user.xml
===================================================================
--- sglr-recovery/trunk/lpg.runtime.java/build-user.xml	                        (rev 0)
+++ sglr-recovery/trunk/lpg.runtime.java/build-user.xml	2009-06-26 14:27:53 UTC (rev 19572)
@@ -0,0 +1,3 @@
+<target name="help">
+    <echo message="Please run: $ ant -v -projecthelp"/>
+</target>
\ No newline at end of file

Added: sglr-recovery/trunk/lpg.runtime.java/build.properties
===================================================================
--- sglr-recovery/trunk/lpg.runtime.java/build.properties	                        (rev 0)
+++ sglr-recovery/trunk/lpg.runtime.java/build.properties	2009-06-26 14:27:53 UTC (rev 19572)
@@ -0,0 +1,15 @@
+source.lpgruntime.jar = src/
+output.lpgruntime.jar = bin/
+bin.includes = plugin.xml,\
+               META-INF/,\
+               lpgexe/,\
+               templates/,\
+               classes/
+src.includes = .classpath,\
+               .project,\
+               META-INF/,\
+               build.properties,\
+               docs/,\
+               src/,\
+               templates/,\
+               include/

Added: sglr-recovery/trunk/lpg.runtime.java/cruise-build.xml
===================================================================
--- sglr-recovery/trunk/lpg.runtime.java/cruise-build.xml	                        (rev 0)
+++ sglr-recovery/trunk/lpg.runtime.java/cruise-build.xml	2009-06-26 14:27:53 UTC (rev 19572)
@@ -0,0 +1,15 @@
+<project name="lpg.javaruntime.v2" default="all">
+    <target name="all" depends="compile, test, publish"/>
+
+    <target name="compile">
+      <cvs command="update -d -P -A" failonerror="true"/>
+      <ant antfile="exportPlugin.xml" target="build.jars"/>
+    </target>
+
+    <target name="test" depends="compile">
+    </target>
+
+    <target name="publish" depends="compile">
+        <ant antfile="exportPlugin.xml" target="publish"/>
+    </target>
+</project>

Added: sglr-recovery/trunk/lpg.runtime.java/docs/Readme.txt
===================================================================
--- sglr-recovery/trunk/lpg.runtime.java/docs/Readme.txt	                        (rev 0)
+++ sglr-recovery/trunk/lpg.runtime.java/docs/Readme.txt	2009-06-26 14:27:53 UTC (rev 19572)
@@ -0,0 +1 @@
+The doc files have been moved to lpg.generator/docs
\ No newline at end of file

Added: sglr-recovery/trunk/lpg.runtime.java/exportPlugin.xml
===================================================================
--- sglr-recovery/trunk/lpg.runtime.java/exportPlugin.xml	                        (rev 0)
+++ sglr-recovery/trunk/lpg.runtime.java/exportPlugin.xml	2009-06-26 14:27:53 UTC (rev 19572)
@@ -0,0 +1,78 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project name="lpg.runtime.java" default="build.plugin.jar" basedir=".">
+	<target name="init">
+		<loadfile property="plugin.id" srcfile="META-INF/MANIFEST.MF">
+			<filterchain>
+				<containsregex pattern="Bundle-SymbolicName:"/>
+				<replaceregex pattern="Bundle-SymbolicName: ([^;]*)(;.*)?" replace="\1"/>
+				<striplinebreaks/>
+			</filterchain>
+		</loadfile>
+		<!-- <echo message="Plugin ID = ${plugin.id}"/> -->
+
+		<loadfile property="plugin.version" srcfile="META-INF/MANIFEST.MF">
+			<filterchain>
+				<containsregex pattern="Bundle-Version:"/>
+				<replaceregex pattern="Bundle-Version: (.*)" replace="\1"/>
+				<striplinebreaks/>
+			</filterchain>
+		</loadfile>
+		<!-- <echo message="Plugin version = ${plugin.version}"/> -->
+
+		<property name="plugin.jar.name" value="${plugin.id}_${plugin.version}.jar"/>
+		<property name="build.result.folder" value="${basedir}/../lpg.update/plugins"/>
+	</target>
+
+    <target name="javaInit" description="Initializes compiler settings from bundle meta-data">
+        <loadfile property="javacSource" srcfile=".settings/org.eclipse.jdt.core.prefs">
+            <filterchain>
+                <containsregex pattern="org.eclipse.jdt.core.compiler.source"/>
+                <replaceregex pattern="org.eclipse.jdt.core.compiler.source=(.*)" replace="\1"/>
+                <striplinebreaks/>
+            </filterchain>
+        </loadfile>
+        <echo message="Java source compatibility = ${javacSource}"/>
+
+        <loadfile property="javacTarget" srcfile=".settings/org.eclipse.jdt.core.prefs">
+            <filterchain>
+                <containsregex pattern="org.eclipse.jdt.core.compiler.codegen.targetPlatform"/>
+                <replaceregex pattern="org.eclipse.jdt.core.compiler.codegen.targetPlatform=(.*)" replace="\1"/>
+                <striplinebreaks/>
+            </filterchain>
+        </loadfile>
+        <echo message="Java target compatibility = ${javacTarget}"/>
+
+        <property name="compilerArg" value=""/>
+    </target>
+
+	<target name="build.plugin.jar" depends="init,javaInit">
+		<echo message="basedir = ${basedir}"/>
+		<property name="temp.folder" value="temp"/>
+		<mkdir dir="${temp.folder}"/>
+
+        <delete dir="${temp.folder}/bin"/>
+        <mkdir dir="${temp.folder}/bin"/>
+        <!-- compile the source code -->
+        <javac destdir="${temp.folder}/bin" failonerror="${javacFailOnError}"
+               verbose="${javacVerbose}" debug="${javacDebugInfo}"
+               includeAntRuntime="no" bootclasspath="${bootclasspath}"
+               source="${javacSource}" target="${javacTarget}">
+            <compilerarg line="${compilerArg}"/>
+            <classpath>
+                <pathelement path="${plugin.dependencies}"/>
+                <pathelement path="${eclipse.build.path}"/>
+            </classpath>
+            <src path="src/"/>
+        </javac>
+        <copy todir="${temp.folder}/bin">
+            <fileset dir="src" includes="**/*.properties"/>
+        </copy>
+        <!-- Copy necessary resources -->
+
+		<jar destfile="lpgruntime.jar" basedir="${temp.folder}/bin"
+			 includes="**/*.class,**/*.properties"/>
+		<jar destfile="${build.result.folder}/${plugin.jar.name}" basedir="${basedir}"
+			 manifest="META-INF/MANIFEST.MF"
+			includes="lpgruntime.jar"/>
+	</target>
+</project>

Added: sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/.cvsignore
===================================================================
--- sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/.cvsignore	                        (rev 0)
+++ sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/.cvsignore	2009-06-26 14:27:53 UTC (rev 19572)
@@ -0,0 +1 @@
+*Backup*

Added: sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/AbstractToken.java
===================================================================
--- sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/AbstractToken.java	                        (rev 0)
+++ sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/AbstractToken.java	2009-06-26 14:27:53 UTC (rev 19572)
@@ -0,0 +1,84 @@
+package lpg.runtime;
+
+public abstract class AbstractToken implements IToken
+{
+    private int kind = 0,
+                startOffset = 0,
+                endOffset = 0,
+                tokenIndex = 0,
+                adjunctIndex;
+    private IPrsStream iPrsStream;
+
+    public AbstractToken() {}
+    public AbstractToken(IPrsStream iPrsStream, int startOffset, int endOffset, int kind)
+    {
+        this.iPrsStream = iPrsStream;
+        this.startOffset = startOffset;
+        this.endOffset = endOffset;
+        this.kind = kind;
+    }
+
+    public int getKind() { return kind; }
+    public void setKind(int kind) { this.kind = kind; }
+
+    public int getStartOffset() { return startOffset; }
+    public void setStartOffset(int startOffset)
+    {
+        this.startOffset = startOffset;
+    }
+
+    public int getEndOffset() { return endOffset; }
+    public void setEndOffset(int endOffset)
+    {
+        this.endOffset = endOffset;
+    }
+
+    public int getTokenIndex() { return tokenIndex; }
+    public void setTokenIndex(int tokenIndex) { this.tokenIndex = tokenIndex; }
+
+    public void setAdjunctIndex(int adjunctIndex) { this.adjunctIndex = adjunctIndex; }
+    public int getAdjunctIndex() { return adjunctIndex; }
+    
+    public IPrsStream getIPrsStream() { return iPrsStream; }
+    public ILexStream getILexStream() { return iPrsStream == null ? null : iPrsStream.getILexStream(); }
+    public int getLine() { return (iPrsStream == null ? 0 : iPrsStream.getILexStream().getLineNumberOfCharAt(startOffset)); }
+    public int getColumn() { return (iPrsStream == null ? 0 : iPrsStream.getILexStream().getColumnOfCharAt(startOffset)); }
+    public int getEndLine() { return (iPrsStream == null ? 0 : iPrsStream.getILexStream().getLineNumberOfCharAt(endOffset)); }
+    public int getEndColumn() { return (iPrsStream == null ? 0 : iPrsStream.getILexStream().getColumnOfCharAt(endOffset)); }
+
+    /**
+     * @deprecated replaced by {@link #getIPrsStream()}
+     */
+    public IPrsStream getPrsStream() { return iPrsStream; }
+
+
+    /**
+     * @deprecated replaced by {@link #getILexStream()}
+     */
+    public ILexStream getLexStream() { return iPrsStream == null ? null : iPrsStream.getILexStream(); }
+
+    /**
+     * @deprecated replaced by {@link #toString()}
+     */
+    public String getValue(char[] inputChars)
+    {
+        if (iPrsStream != null)
+            return toString();
+        if (iPrsStream.getLexStream() instanceof LexStream)
+        {
+            LexStream lex_stream = (LexStream) iPrsStream.getLexStream();
+            if (inputChars != lex_stream.getInputChars())
+                throw new MismatchedInputCharsException();
+            return toString();
+        }
+        throw new UnknownStreamType("Unknown stream type " +
+                                    iPrsStream.getLexStream().getClass().toString());
+    }
+
+    public String toString()
+    {
+        return (iPrsStream == null
+                           ? "<toString>"
+                           : iPrsStream.toString(this, this));
+    }
+}
\ No newline at end of file

Added: sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/Adjunct.java
===================================================================
--- sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/Adjunct.java	                        (rev 0)
+++ sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/Adjunct.java	2009-06-26 14:27:53 UTC (rev 19572)
@@ -0,0 +1,13 @@
+package lpg.runtime;
+
+public class Adjunct extends AbstractToken
+{
+    public Adjunct() {}
+    public Adjunct(IPrsStream prsStream, int startOffset, int endOffset, int kind)
+    {
+        super(prsStream, startOffset, endOffset, kind);
+    }
+    public IToken[] getFollowingAdjuncts() { return null; }
+    public IToken[] getPrecedingAdjuncts() { return null; }
+}
+

Added: sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/BacktrackingParser.java
===================================================================
--- sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/BacktrackingParser.java	                        (rev 0)
+++ sglr-recovery/trunk/lpg.runtime.java/src/lpg/runtime/BacktrackingParser.java	2009-06-26 14:27:53 UTC (rev 19572)
@@ -0,0 +1,888 @@
+package lpg.runtime;
+
+public class BacktrackingParser extends Stacks
+{
+    private Monitor monitor;
+    private int START_STATE,
+                NUM_RULES,
+                NT_OFFSET,
+                LA_STATE_OFFSET,
+                EOFT_SYMBOL,
+                ERROR_SYMBOL,
+                ACCEPT_ACTION,
+                ERROR_ACTION;
+
+    private int lastToken,
+                currentAction;
+    private TokenStream tokStream;
+    private ParseTable prs;
+    private RuleAction ra;
+    private IntSegmentedTuple action = new IntSegmentedTuple(10, 1024); // IntTuple(1 << 20),
+    private IntTuple tokens;
+    private int actionStack[];
+    private boolean skipTokens = false; // true if error productions are used to skip tokens
+    
+    //
+    // A starting marker indicates that we are dealing with an entry point
+    // for a given nonterminal. We need to execute a shift action on the
+    // marker in order to parse the entry point in question.
+    //
+    private int markerTokenIndex = 0;
+    private int getMarkerToken(int marker_kind, int start_token_index)        
+    {
+        if (marker_kind == 0)
+            return 0;
+        else
+        {
+            if (markerTokenIndex == 0)
+            { 
+                if (! (tokStream instanceof IPrsStream))
+                    throw new TokenStreamNotIPrsStreamException();
+                markerTokenIndex = ((IPrsStream) tokStream).makeErrorToken(tokStream.getPrevious(start_token_index),
+                                                                           tokStream.getPrevious(start_token_index),
+                                                                           tokStream.getPrevious(start_token_index),
+                                                                           marker_kind);
+            }
+            else ((IPrsStream) tokStream).getIToken(markerTokenIndex).setKind(marker_kind);
+        }
+        
+        return markerTokenIndex;
+    }
+
+    //
+    // Override the getToken function in Stacks.
+    //
+    public final int getToken(int i)
+    {
+        return tokens.get(locationStack[stateStackTop + (i - 1)]);
+    }
+
+    public final int getCurrentRule()     { return currentAction; }
+    public final int getFirstToken()      { return tokStream.getFirstRealToken(getToken(1)); }
+    public final int getFirstToken(int i) { return tokStream.getFirstRealToken(getToken(i)); }
+    public final int getLastToken()       { return tokStream.getLastRealToken(lastToken); }
+    public final int getLastToken(int i)  { int l = (i >= prs.rhs(currentAction)
+                                                        ? lastToken
+                                                        : tokens.get(locationStack[stateStackTop + i] - 1));
+                                            return tokStream.getLastRealToken(l);
+                                          }
+
+    public void setMonitor(Monitor monitor) { this.monitor = monitor; }
+    
+    public void reset()
+    {
+    	action.reset();
+    	skipTokens = false;
+    	markerTokenIndex = 0;
+    }
+    
+    public void reset(Monitor monitor, TokenStream tokStream)
+    {
+        this.monitor = monitor;
+        this.tokStream = (TokenStream) tokStream;
+        reset();
+    }
+
+
+    public void reset(TokenStream tokStream)
+    {
+        reset (null, tokStream);
+    }
+
+
+    public void reset(Monitor monitor, TokenStream tokStream, ParseTable prs, RuleAction ra) throws BadParseSymFileException,
+                                                                                                    NotBacktrackParseTableException
+    {
+    	reset(monitor, tokStream);
+
+    	this.prs = prs;
+        this.ra = ra;
+
+    	START_STATE = prs.getStartState();
+    	NUM_RULES = prs.getNumRules();
+    	NT_OFFSET = prs.getNtOffset();
+    	LA_STATE_OFFSET = prs.getLaStateOffset();
+    	EOFT_SYMBOL = prs.getEoftSymbol();
+    	ERROR_SYMBOL = prs.getErrorSymbol();
+    	ACCEPT_ACTION = prs.getAcceptAction();
+    	ERROR_ACTION = prs.getErrorAction();
+
+    	if (! prs.isValidForParser()) throw new BadParseSymFileException();
+    	if (! prs.getBacktrack()) throw new NotBacktrackParseTableException();
+    }
+    
+    public void reset(TokenStream tokStream, ParseTable prs, RuleAction ra) throws BadParseSymFileException,
+                                                                                   NotBacktrackParseTableException
+    {
+        reset(null, tokStream, prs, ra);
+    }
+
+    public BacktrackingParser() {}
+
+    public BacktrackingParser(TokenStream tokStream, ParseTable prs, RuleAction ra) throws BadParseSymFileException,
+                                                                                           NotBacktrackParseTableException
+    {
+        reset(null, tokStream, prs, ra);
+    }
+
+    public BacktrackingParser(Monitor monitor, TokenStream tokStream, ParseTable prs, RuleAction ra) throws BadParseSymFileException,
+                                                                                                            NotBacktrackParseTableException
+    {
+        reset(monitor, tokStream, prs, ra);
+    }
+
+    //
+    // Allocate or reallocate all the stacks. Their sizes should always be the same.
+    //
+    public void reallocateOtherStacks(int start_token_index)
+    {
+        // assert(super.stateStack != null);
+        if (this.actionStack == null)
+        {
+            this.actionStack = new int[super.stateStack.length];
+            super.locationStack = new int[super.stateStack.length];
+            super.parseStack = new Object[super.stateStack.length];
+
+            actionStack[0] = 0;
+            locationStack[0] = start_token_index;
+        }
+        else if (this.actionStack.length < super.stateStack.length)
+        {
+            int old_length = this.actionStack.length;
+
+            System.arraycopy(this.actionStack, 0, this.actionStack = new int[super.stateStack.length], 0, old_length);
+            System.arraycopy(super.locationStack, 0, super.locationStack = new int[super.stateStack.length], 0, old_length);
+            System.arraycopy(super.parseStack, 0, super.parseStack = new Object[super.stateStack.length], 0, old_length);
+        }
+        return;
+    }
+
+    //
+    // Always attempt to recover
+    //
+    public Object fuzzyParse() throws BadParseException
+    {
+        return fuzzyParseEntry(0, Integer.MAX_VALUE);
+    }
+
+    //
+    // Recover up to max_error_count times and then quit
+    //
+    public Object fuzzyParse(int max_error_count) throws BadParseException
+    {
+        return fuzzyParseEntry(0, max_error_count);
+    }
+
+    //
+    // Always attempt to recover
+    //
+    public Object fuzzyParseEntry(int marker_kind) throws BadParseException
+    {
+        return fuzzyParseEntry(marker_kind, Integer.MAX_VALUE);
+    }
+
+    //
+    //
+    //
+    public Object fuzzyParseEntry(int marker_kind, int max_error_count) throws BadParseException
+    {
+        action.reset();
+        tokStream.reset(); // Position at first token.
+        reallocateStateStack();
+        stateStackTop = 0;
+        stateStack[0] = START_STATE;
+
+        //
+        // The tuple tokens will eventually contain the sequence 
+        // of tokens that resulted in a successful parse. We leave
+        // it up to the "Stream" implementer to define the predecessor
+        // of the first token as he sees fit.
+        //
+        int first_token = tokStream.peek(),
+            start_token = first_token,
+            marker_token = getMarkerToken(marker_kind, first_token);
+        tokens = new IntTuple(tokStream.getStreamLength());
+        tokens.add(tokStream.getPrevious(first_token));
+
+        int error_token = backtrackParse(action, marker_token);
+        if (error_token != 0) // an error was detected?
+        {
+            if (! (tokStream instanceof IPrsStream))
+                throw new TokenStreamNotIPrsStreamException();
+            RecoveryParser rp = new RecoveryParser(this, monitor, action, tokens, (IPrsStream) tokStream, prs, max_error_count, 0);
+            start_token = rp.recover(marker_token, error_token);
+        }
+
+        if (marker_token != 0 && start_token == first_token)
+            tokens.add(marker_token);
+        int t;
+        for (t = start_token; tokStream.getKind(t) != EOFT_SYMBOL; t = tokStream.getNext(t))
+            tokens.add(t);
+        tokens.add(t);
+
+        return parseActions(marker_kind);
+    }
+
+    //
+    // Parse without attempting any Error token recovery
+    //
+    public Object parse() throws BadParseException
+    {
+        // without an argument parse() will ignore error productions
+        return parseEntry(0, 0);
+    }
+
+    //
+    // Parse input allowing up to max_error_count Error token recoveries.
+    // When max_error_count is 0, no Error token recoveries occur.
+    // When max_error is > 0, it limits the number of Error token recoveries.
+    // When max_error is < 0, the number of error token recoveries is unlimited.
+    // Also, such recoveries only require one token to be parsed beyond the recovery point.
+    // (normally two tokens beyond the recovery point must be parsed)
+    // Thus, a negative max_error_count should be used when error productions are used to 
+    // skip tokens.
+    //
+    public Object parse(int max_error_count) throws BadParseException
+    {
+        return parseEntry(0, max_error_count);
+    }
+
+    //
+    // Parse without attempting any Error token recovery
+    //
+    public Object parseEntry(int marker_kind) throws BadParseException
+    {
+        // without an argument parse() will ignore error productions
+        return parseEntry(marker_kind, 0);
+    }
+
+    //
+    // Parse input allowing up to max_error_count Error token recoveries.
+    // When max_error_count is 0, no Error token recoveries occur.
+    // When max_error is > 0, it limits the number of Error token recoveries.
+    // When max_error is < 0, the number of error token recoveries is unlimited.
+    // Also, such recoveries only require one token to be parsed beyond the recovery point.
+    // (normally two tokens beyond the recovery point must be parsed)
+    // Thus, a negative max_error_count should be used when error productions are used to 
+    // skip tokens.
+    //
+    public Object parseEntry(int marker_kind, int max_error_count) throws BadParseException
+    {
+        action.reset();
+        tokStream.reset(); // Position at first token.
+        reallocateStateStack();
+        stateStackTop = 0;
+        stateStack[0] = START_STATE;
+
+        skipTokens = max_error_count < 0;
+
+        if (max_error_count > 0 && tokStream instanceof IPrsStream)
+            max_error_count = 0;
+        
+        //
+        // The tuple tokens will eventually contain the sequence 
+        // of tokens that resulted in a successful parse. We leave
+        // it up to the "Stream" implementer to define the predecessor
+        // of the first token as he sees fit.
+        //
+        tokens = new IntTuple(tokStream.getStreamLength());
+        tokens.add(tokStream.getPrevious(tokStream.peek()));
+
+        int start_token_index = tokStream.peek(),
+            repair_token = getMarkerToken(marker_kind, start_token_index),
+            start_action_index = action.size(), // obviously 0
+            temp_stack[] = new int[stateStackTop + 1];
+        System.arraycopy(stateStack, 0, temp_stack, 0, temp_stack.length);
+        
+        int initial_error_token = backtrackParse(action, repair_token);
+        for (int error_token = initial_error_token, count = 0;
+             error_token != 0;
+             error_token = backtrackParse(action, repair_token), count++)
+        {

(9870 diff lines omitted)


From mdjonge at xs4all.nl  Fri Jun 26 18:25:33 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Fri, 26 Jun 2009 16:25:33 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19573 - MaartjeDeJonge
	- in sglr-recovery/trunk/Evaluation_Recovery: . Correct_Files
	Correct_Files/input_files Error_Files/input_files
Message-ID: <200906261624.n5QGOACP010022@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-26 16:25:33 +0000 (Fri, 26 Jun 2009)
New Revision: 19573

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19573&view=rev

Added:
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/generated_java/
Modified:
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testFile.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testFile.java
   sglr-recovery/trunk/Evaluation_Recovery/Run.sh

Log:
testfile showing an improved recovery by our method (compared to jdt), refactor script code 

Changes:

Modified: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testFile.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testFile.java	2009-06-26 14:27:53 UTC (rev 19572)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testFile.java	2009-06-26 16:25:33 UTC (rev 19573)
@@ -3,20 +3,40 @@
 import java.io.IOException;
 import java.util.ArrayList;
 
-class X {
-	
-  private int method1(){
-     bla();
-     bla();
-     int i=1;
-     return 2;
-  }  
-  
-  private int method2(){
+class X  
+{ 
+  private int method1()
+  { 
+    bla();
+    bla();
+    int i = 1;
+    return 2;
+  }
+
+  private int method2()
+  { 
+    bla();
+    bla();
+    int i = 1;
+    return 2;
+  }
+
+  private int method3()
+  { 
+    bla();
+    if(true)
+    { 
       bla();
-      bla();
-      int i=1;
-      return 2;
+      int i = 1;
+    }
+    return 2;
   }
 
-}
\ No newline at end of file
+  private int method4()
+  { 
+    bla();
+    bla();
+    int i = 1;
+    return 2;
+  }
+}

Modified: sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testFile.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testFile.java	2009-06-26 14:27:53 UTC (rev 19572)
+++ sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testFile.java	2009-06-26 16:25:33 UTC (rev 19573)
@@ -3,20 +3,39 @@
 import java.io.IOException;
 import java.util.ArrayList;
 
-class X {
-	
-  private int method1(){
-     bla();
-     bla();
-     int i=1 /*;*/
-     return 2;
-  }  
-  
-  private int method2(){
+class X  
+{ 
+  private int method1()
+  { 
+    bla();
+    bla();
+    int i = 1;
+    return 2;
+  }
+
+  private int method2()
+  { 
+    bla();
+    bla();
+    int i = 1;
+    return 2;
+  }
+
+  private int method3()
+  { 
+    bla();
+    if(true)
+    { 
       bla();
-      bla();
-      int i=1;
-      return 2;
+      int i = 1; /*}*/
+    return 2;
   }
 
-}
\ No newline at end of file
+  private int method4()
+  { 
+    bla();
+    bla();
+    int i = 1;
+    return 2;
+  }
+}

Modified: sglr-recovery/trunk/Evaluation_Recovery/Run.sh
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Run.sh	2009-06-26 14:27:53 UTC (rev 19572)
+++ sglr-recovery/trunk/Evaluation_Recovery/Run.sh	2009-06-26 16:25:33 UTC (rev 19573)
@@ -62,115 +62,77 @@
 
 ##########################################################################################################################
 
-#creates java for the abstract syntax trees (sglr-branch)
-ext=.ast
-outputLocation="sglr_java"
-inputLocation="sglr_ast"
-loc=Error_Files
-
+#creates java for the abstract syntax trees (sglr-branch, jdt-branch, correct files)
+printJava(){
+	astDir=$1
+	javaDir=$2
+	astFiles="$astDir/*.ast"
+	for astTree in $astFiles
+	do			
+		astTree=${astTree#*\/}
+		astTree=${astTree#*\/}
+		astTreeName=${astTree%.*}
+		echo $astTree
 	
-astDir=$loc/$inputLocation
-javaDir=$loc/$outputLocation
-astFiles="$astDir/*$ext"
-for astTree in $astFiles
-do	
-	astTree=${astTree#*\/}
-	astTree=${astTree#*\/}
-	astTreeName=${astTree%.*}
-	echo $astTree
-	
-	# create abstract syntax		
-	pp-java -i $astDir/$astTree -o $javaDir/$astTreeName.recovered.java			
-done
+		# create abstract syntax		
+		pp-java -i $astDir/$astTree -o $javaDir/$astTreeName.java			
+	done
+}
 
-#creates java for the abstract syntax trees (jdt-branch)
-ext=.ast
-outputLocation="jdt_java"
-inputLocation="jdt_ast"
-loc=Error_Files
-	
-astDir=$loc/$inputLocation
-javaDir=$loc/$outputLocation
-astFiles="$astDir/*$ext"
-for astTree in $astFiles
-do	
-	astTree=${astTree#*\/}
-	astTree=${astTree#*\/}
-	astTreeName=${astTree%.*}
-	echo $astTree
-	
-	# create abstract syntax		
-	pp-java -i $astDir/$astTree -o $javaDir/$astTreeName.recovered.java			
-done
+printJava "Correct_Files/sglr_ast" "Correct_Files/generated_java"
+printJava "Error_Files/sglr_ast" "Error_Files/sglr_java"
+printJava "Error_Files/jdt_ast" "Error_Files/jdt_java"
 
-
 ################################################################################################################
 
-#compare recovered sglr-ast with correct ast
-compareLoc="Correct_Files/sglr_ast"
-brancheLoc="Error_Files/sglr_ast"
-diffDir="Compare/Ast"
-ext=.readable
-addition=sglr
-
-correctAstFiles="$compareLoc/*$ext"
-for correctTree in $correctAstFiles
-do	
-	correctTree=${correctTree#*\/}
-	correctTree=${correctTree#*\/}
-	correctTreeName=${correctTree%.*}
-	correctTreeName=${correctTreeName%.*}	
-	echo $correctTreeName	
+#compare correct AST with recovered ASTs (jdt, sglr)
+ 
+compareASTs(){
+	diffDir="Compare/Ast"
+	compareLoc=$1
+	brancheLoc=$2
+	addition=$3
+	correctAstFiles="$compareLoc/*.readable"
+	for correctTree in $correctAstFiles
+	do	
+		correctTree=${correctTree#*\/}
+		correctTree=${correctTree#*\/}
+		correctTreeName=${correctTree%.*}
+		correctTreeName=${correctTreeName%.*}	
+		echo $correctTreeName	
 	
-	#compare readable ast's
-	diff $brancheLoc/$correctTree $compareLoc/$correctTree > $diffDir/$correctTreeName.$addition.diff
-done
+		#compare readable ast's
+		diff $brancheLoc/$correctTree $compareLoc/$correctTree > $diffDir/$correctTreeName.$addition.diff
+	done
+}
 
-#compare recovered jdt-ast with correct ast
-compareLoc="Correct_Files/jdt_ast"
-brancheLoc="Error_Files/jdt_ast"
-diffDir="Compare/Ast"
-ext=.readable
-addition=jdt
+compareASTs "Correct_Files/jdt_ast" "Error_Files/jdt_ast" "jdt"
+compareASTs "Correct_Files/sglr_ast" "Error_Files/sglr_ast" "sglr"
 
 
-correctAstFiles="$compareLoc/*$ext"
-for correctTree in $correctAstFiles
-do	
-	correctTree=${correctTree#*\/}
-	correctTree=${correctTree#*\/}
-	correctTreeName=${correctTree%.*}
-	correctTreeName=${correctTreeName%.*}	
-	echo $correctTreeName	
-	
-	#compare readable ast's
-	diff $brancheLoc/$correctTree $compareLoc/$correctTree > $diffDir/$correctTreeName.$addition.diff
-done
-
 ################################################################################################################
 
-#compare recovered sglr-java with correct java code
-compareLoc="Correct_Files/input_files"
-brancheLoc="Error_Files/sglr_java"
-diffDir="Compare/Java"
-ext=.java
-addition=sglr
 
-correctJavaFiles="$compareLoc/*$ext"
-for correctJava in $correctJavaFiles
-do	
-	correctJava=${correctJava#*\/}
-	correctJava=${correctJava#*\/}
-	correctJavaName=${correctJava%.*}	
-	echo $correctJavaName
+compareJava(){
+	diffDir="Compare/Java"
+	compareLoc=$1
+	brancheLoc=$2
+	addition=$3		
+	correctJavaFiles="$compareLoc/*.java"
+	for correctJava in $correctJavaFiles
+	do	
+		correctJava=${correctJava#*\/}
+		correctJava=${correctJava#*\/}
+		correctJavaName=${correctJava%.*}	
+		echo $correctJavaName
 	
-	#compare readable ast's
-	diff $brancheLoc/$correctJavaName.recovered.java $compareLoc/$correctJava > $diffDir/$correctJavaName.$addition.diff
-done
+		#compare readable ast's
+		diff $brancheLoc/$correctJavaName.java $compareLoc/$correctJava > $diffDir/$correctJavaName.$addition.diff
+	done
+}
 
+compareJava "Correct_Files/generated_java" "Error_Files/sglr_java" "sglr"
+compareJava "Correct_Files/generated_java" "Error_Files/jdt_java" "jdt"
 
 
 
-
-
-



From mdjonge at xs4all.nl  Mon Jun 29 11:05:24 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Mon, 29 Jun 2009 09:05:24 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19574 - MaartjeDeJonge
	- in sglr-recovery/trunk/Evaluation_Recovery: . Compare/Ast
	Compare/Java src
Message-ID: <200906290903.n5T93vSU000739@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-29 09:05:24 +0000 (Mon, 29 Jun 2009)
New Revision: 19574

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19574&view=rev

Modified:
   sglr-recovery/trunk/Evaluation_Recovery/.classpath
   sglr-recovery/trunk/Evaluation_Recovery/Compare/Ast/
   sglr-recovery/trunk/Evaluation_Recovery/Compare/Java/
   sglr-recovery/trunk/Evaluation_Recovery/src/ProcessFiles.java

Log:
bridge parser included (fix build path)

Changes:

Modified: sglr-recovery/trunk/Evaluation_Recovery/.classpath
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/.classpath	2009-06-26 16:25:33 UTC (rev 19573)
+++ sglr-recovery/trunk/Evaluation_Recovery/.classpath	2009-06-29 09:05:24 UTC (rev 19574)
@@ -9,5 +9,6 @@
 	<classpathentry combineaccessrules="false" kind="src" path="/other-parsers"/>
 	<classpathentry combineaccessrules="false" kind="src" path="/org.spoofax.interpreter.core"/>
 	<classpathentry combineaccessrules="false" kind="src" path="/org.spoofax.aterm"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/org.strategoxt.imp.runtime"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>


Property changes on: sglr-recovery/trunk/Evaluation_Recovery/Compare/Ast
___________________________________________________________________
Added: svn:ignore
   + *.diff



Property changes on: sglr-recovery/trunk/Evaluation_Recovery/Compare/Java
___________________________________________________________________
Added: svn:ignore
   + *.diff


Modified: sglr-recovery/trunk/Evaluation_Recovery/src/ProcessFiles.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/src/ProcessFiles.java	2009-06-26 16:25:33 UTC (rev 19573)
+++ sglr-recovery/trunk/Evaluation_Recovery/src/ProcessFiles.java	2009-06-29 09:05:24 UTC (rev 19574)
@@ -6,12 +6,16 @@
 import java.io.OutputStream;
 import junit.framework.TestCase;
 
+import org.bripgen.sglr.example.JavaSGLRBridgeParser;
 import org.spoofax.interpreter.core.InterpreterException;
 import org.spoofax.jsglr.IRecoveryParser;
+import org.spoofax.jsglr.NoRecovery;
 import org.spoofax.jsglr.ParseTableManager;
 import org.spoofax.jsglr.SGLR;
 import org.spoofax.jsglr.SGLRException;
 import org.spoofax.jsglr.Tools;
+import org.strategoxt.imp.runtime.parser.StandAloneSGLRI;
+
 import sglrbridges.otherparsers.JDTParser;
 import aterm.ATerm;
 
@@ -28,7 +32,7 @@
 	private final static String TOKEN_PARSE_TABLE ="Language_Files/Java-15-Tokenizer.tbl";	
 	
 	private SGLR sglr;
-	//private StandAloneSGLRI tokenParser;
+	private StandAloneSGLRI tokenParser;
 	private IRecoveryParser recoveryParser;
 	private InputStream fis;
 	private boolean useBridgeParser=true;	
@@ -80,10 +84,10 @@
         sglr.setRecoveryTestingWorkAround(true);
         if (TOKEN_PARSE_TABLE != null && useBridgeParser) {
 			FileInputStream table = new FileInputStream(TOKEN_PARSE_TABLE);
-			//tokenParser = new StandAloneSGLRI(null, table, null, /*USE_CSGLR*/true);
-			//tokenParser.setKeepAmbiguities(true);
-	        //tokenParser.setRecoverHandler(new NoRecovery());
-	        //recoveryParser = new JavaSGLRBridgeParser(tokenParser); // TODO: Properly select/load appropriate bridge parser
+			tokenParser = new StandAloneSGLRI(null, table, null, /*USE_CSGLR*/true);
+			tokenParser.setKeepAmbiguities(true);
+	        tokenParser.setRecoverHandler(new NoRecovery());
+	        recoveryParser = new JavaSGLRBridgeParser(tokenParser); // TODO: Properly select/load appropriate bridge parser
 	        sglr.setUseStructureRecovery(true, recoveryParser);
 		}
         else



From mdjonge at xs4all.nl  Mon Jun 29 12:37:53 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Mon, 29 Jun 2009 10:37:53 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19579 - MaartjeDeJonge
	- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
Message-ID: <200906291036.n5TAaQXf002069@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-29 10:37:52 +0000 (Mon, 29 Jun 2009)
New Revision: 19579

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19579&view=rev

Modified:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParserHistory.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java

Log:
deal with openings tokens like { (C# style)

Changes:

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParserHistory.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParserHistory.java	2009-06-29 10:09:25 UTC (rev 19578)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/ParserHistory.java	2009-06-29 10:37:52 UTC (rev 19579)
@@ -21,7 +21,7 @@
     }
 
     private ArrayList<IndentInfo> newLinePoints;      
-    private char[] recoverTokenStream;
+    public char[] recoverTokenStream;
     private int recoverTokenCount;
     private int tokenIndex;
     private boolean reduceIndexesSet;
@@ -206,6 +206,10 @@
         return newLinePoints.get(index);
     }
     
+    public IndentInfo getLastLine(){
+        return newLinePoints.get(newLinePoints.size()-1);
+    }
+    
     public void moveToLastConstruct(){
         indexConstruct=newLinePoints.size()-1;        
     }
@@ -232,6 +236,19 @@
         return false; 
     }
     
+    public boolean moveToDirectPreviousConstruct() {
+
+        if(indexConstruct<=0)
+            return false;        
+        IndentInfo currentLine=newLinePoints.get(indexConstruct);
+        IndentInfo priorLine=newLinePoints.get(indexConstruct -1);      
+        if(priorLine.getIndentValue()==currentLine.getIndentValue()){            
+            indexConstruct -= 1;
+            return true;
+        }
+        return false; 
+    }
+    
     public void addRecoverLines(ArrayList<IndentInfo> recoverNewLinePoints) {
         if(recoverNewLinePoints.size()==0)
             return;

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java	2009-06-29 10:09:25 UTC (rev 19578)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/StructureRecovery.java	2009-06-29 10:37:52 UTC (rev 19579)
@@ -103,7 +103,10 @@
             case SKIP_PREVIOUS:
                 if(getHistory().moveToPreviousConstruct()){
                     skipCurrentConstruct();
-                }                
+                }
+                if(!recoverySucceeded() && getHistory().moveToDirectPreviousConstruct()){ //needed to deal with openings tokens like "{" on single line
+                    skipCurrentConstruct();
+                }
                 getHistory().moveToLastConstruct();
                 recoverAction=SkipAction.SKIP_CURRENT;
                 break;
@@ -268,14 +271,19 @@
             prevLineEmpty=skipIndentHandler.emptyLineParsed();
             if(childFound(skipP))
                 childFound=true;
-            if (endOfConstruct(skipP) || myParser.currentToken==SGLR.EOF) {//reachedErrorDetectionLine() && 
-                endSkipFound=true;                 
-                int indent = skipIndentHandler.getIndentValue();                
-                skipPoint = new IndentInfo(-1, getHistory().getTokenIndex() -1, indent);
-                skipPoint.fillStackNodes(myParser.activeStacks);
+            if (endOfConstruct(skipP)|| myParser.currentToken==SGLR.EOF) {//reachedErrorDetectionLine() && 
+                if(getHistory().getTokenIndex()>= getHistory().getLastLine().getTokensSeen()-1){
+                    endSkipFound=true;                 
+                    int indent = skipIndentHandler.getIndentValue();                
+                    skipPoint = new IndentInfo(-1, getHistory().getTokenIndex() -1, indent);
+                    skipPoint.fillStackNodes(myParser.activeStacks);
+                }
+                else{
+                    childFound=false;
+                }
             }            
         }
-        
+        //Tools.debug("skip try: "+getErrorFragment());
         if (childFound && skipP.getIndentValue() == skipPoint.getIndentValue() && !prevLineEmpty) {
             while (myParser.currentToken != SGLR.EOF) {
                 readNextToken();



From mdjonge at xs4all.nl  Mon Jun 29 12:53:54 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Mon, 29 Jun 2009 10:53:54 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19580 - MaartjeDeJonge
	- sglr-recovery/trunk/Evaluation_Recovery/src
Message-ID: <200906291052.n5TAqRPW002262@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-29 10:53:54 +0000 (Mon, 29 Jun 2009)
New Revision: 19580

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19580&view=rev

Modified:
   sglr-recovery/trunk/Evaluation_Recovery/src/ProcessFiles.java

Log:
setup() called to reset parameters after each test-file.

Changes:

Modified: sglr-recovery/trunk/Evaluation_Recovery/src/ProcessFiles.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/src/ProcessFiles.java	2009-06-29 10:37:52 UTC (rev 19579)
+++ sglr-recovery/trunk/Evaluation_Recovery/src/ProcessFiles.java	2009-06-29 10:53:54 UTC (rev 19580)
@@ -44,26 +44,36 @@
 		JDTParser.main(args);
 	}
 	
-	public void testProcessCorrectFiles() throws IOException, InterpreterException, SGLRException{
+	public void testProcessCorrectFiles() throws Exception{
 		String[] children = collectInputFiles(LOC_CORRECT_INPUTFILES);	
 		for (String fileName : children) {        	
         	if (!fileName.contains("svn")) {
 				createJDT_Tree(fileName, LOC_CORRECT_INPUTFILES, LOC_CORRECT_JDT_TREES);
 				createSGLRParsetree(fileName, LOC_CORRECT_INPUTFILES, LOC_CORRECT_SGLR_PARSETREES);
+				setUp();
 			}
 		}
 	}
 	
-	public void testProcessErrorFiles() throws IOException, InterpreterException, SGLRException{
+	public void testProcessErrorFiles() throws Exception{
 		String[] children = collectInputFiles(LOC_ERROR_INPUTFILES);	
 		for (String fileName : children) {        	
         	if (!fileName.contains("svn")) {
+        		Tools.debug("#####"+fileName + "#####");
 				createJDT_Tree(fileName, LOC_ERROR_INPUTFILES, LOC_ERROR_JDT_TREES);
 				createSGLRParsetree(fileName, LOC_ERROR_INPUTFILES, LOC_ERROR_SGLR_PARSETREES);
+				setUp();
 			}
 		}
 	}
 	
+	public void testFile() throws IOException, InterpreterException, SGLRException{
+		String fileName="testFile.java";
+		//String fileName="testFile2.java";
+		createJDT_Tree(fileName, LOC_ERROR_INPUTFILES, LOC_ERROR_JDT_TREES);
+		createSGLRParsetree(fileName, LOC_ERROR_INPUTFILES, LOC_ERROR_SGLR_PARSETREES);				
+	}
+	
 	/**
      * Used to list the files / subdirectories in a given directory.
      * @param dir Directory to start listing from
@@ -82,7 +92,7 @@
         sglr = new SGLR(ptm.getFactory(), ptm.loadFromFile(PARSE_TABLE));        
         sglr.getDisambiguator().setFilterAny(false);  
         sglr.setRecoveryTestingWorkAround(true);
-        if (TOKEN_PARSE_TABLE != null && useBridgeParser) {
+        if (false && TOKEN_PARSE_TABLE != null && useBridgeParser) {
 			FileInputStream table = new FileInputStream(TOKEN_PARSE_TABLE);
 			tokenParser = new StandAloneSGLRI(null, table, null, /*USE_CSGLR*/true);
 			tokenParser.setKeepAmbiguities(true);



From L.C.L.Kats at tudelft.nl  Tue Jun 30 11:42:57 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Tue, 30 Jun 2009 09:42:57 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19593 - LennartKats -
	sglr-recovery/trunk/permissive-grammars/grammars/stratego-java
Message-ID: <200906300941.n5U9fU4f019994@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-06-30 09:42:57 +0000 (Tue, 30 Jun 2009)
New Revision: 19593

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19593&view=rev

Modified:
   sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-1.sdf
   sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-2.sdf
   sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-3.sdf
   sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-4.sdf
   sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-5.sdf
   sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-6.sdf
   sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-7-alt.sdf
   sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-7.sdf
   sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-8.sdf
   sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-9.sdf
   sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-X.sdf
   sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-X2.sdf
   sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-X3.sdf
   sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-X4.sdf
   sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-X5.sdf
   sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-X6.sdf
   sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained.sdf

Log:
s/{avoid}/{recover}/

Changes:

Modified: sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-1.sdf
===================================================================
--- sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-1.sdf	2009-06-29 19:33:32 UTC (rev 19592)
+++ sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-1.sdf	2009-06-30 09:42:57 UTC (rev 19593)
@@ -15,7 +15,7 @@
     WATER WATERSTART
 
   lexical syntax
-%%    ~[\ \t\12\r\n]             -> WATERSTART {avoid}
+%%    ~[\ \t\12\r\n]             -> WATERSTART {recover}
 %%    WATERSTART ~[\ \t\12\r\n]* -> WATER
     ~[\ \t\12\r\n]+ -> WATER
   

Modified: sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-2.sdf
===================================================================
--- sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-2.sdf	2009-06-29 19:33:32 UTC (rev 19592)
+++ sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-2.sdf	2009-06-30 09:42:57 UTC (rev 19593)
@@ -13,7 +13,7 @@
     WATER WATERSTART
 
   lexical syntax
-    ~[\ \t\12\r\n]             -> WATERSTART {avoid}
+    ~[\ \t\12\r\n]             -> WATERSTART {recover}
     WATERSTART ~[\ \t\12\r\n]* -> WATER
 %%    ~[\ \t\12\r\n]+ -> WATER
   

Modified: sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-3.sdf
===================================================================
--- sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-3.sdf	2009-06-29 19:33:32 UTC (rev 19592)
+++ sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-3.sdf	2009-06-30 09:42:57 UTC (rev 19593)
@@ -18,7 +18,7 @@
     WATER WATERSTART DefSTAR DefSTARWATER
 
   lexical syntax
-%%    ~[\ \t\12\r\n]             -> WATERSTART {avoid}
+%%    ~[\ \t\12\r\n]             -> WATERSTART {recover}
 %%    WATERSTART ~[\ \t\12\r\n]* -> WATER
     ~[\ \t\12\r\n]+ -> WATER
   

Modified: sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-4.sdf
===================================================================
--- sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-4.sdf	2009-06-29 19:33:32 UTC (rev 19592)
+++ sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-4.sdf	2009-06-30 09:42:57 UTC (rev 19593)
@@ -15,7 +15,7 @@
     WATER WATERSTART DefSTAR DefSTARWATER
 
   lexical syntax
-%%    ~[\ \t\12\r\n]             -> WATERSTART {avoid}
+%%    ~[\ \t\12\r\n]             -> WATERSTART {recover}
 %%    WATERSTART ~[\ \t\12\r\n]* -> WATER
     ~[\ \t\12\r\n]+ -> WATER
   

Modified: sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-5.sdf
===================================================================
--- sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-5.sdf	2009-06-29 19:33:32 UTC (rev 19592)
+++ sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-5.sdf	2009-06-30 09:42:57 UTC (rev 19593)
@@ -15,7 +15,7 @@
     WATER WATERSTART DefSTAR DefSTARWATER
 
   lexical syntax
-%%    ~[\ \t\12\r\n]             -> WATERSTART {avoid}
+%%    ~[\ \t\12\r\n]             -> WATERSTART {recover}
 %%    WATERSTART ~[\ \t\12\r\n]* -> WATER
 %%  ~[\ \t\12\r\n]+ -> WATER
   

Modified: sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-6.sdf
===================================================================
--- sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-6.sdf	2009-06-29 19:33:32 UTC (rev 19592)
+++ sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-6.sdf	2009-06-30 09:42:57 UTC (rev 19593)
@@ -16,7 +16,7 @@
     WATER WATERSTART DefSTAR DefSTARWATER
 
   lexical syntax
-%%    ~[\ \t\12\r\n]             -> WATERSTART {avoid}
+%%    ~[\ \t\12\r\n]             -> WATERSTART {recover}
 %%    WATERSTART ~[\ \t\12\r\n]* -> WATER
     ~[\ \t\12\r\n]+ -> WATER
   

Modified: sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-7-alt.sdf
===================================================================
--- sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-7-alt.sdf	2009-06-29 19:33:32 UTC (rev 19592)
+++ sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-7-alt.sdf	2009-06-30 09:42:57 UTC (rev 19593)
@@ -21,7 +21,7 @@
     WATER WATERSTART DefSTAR DefSTARWATER
 
   lexical syntax
-%%    ~[\ \t\12\r\n]             -> WATERSTART {avoid}
+%%    ~[\ \t\12\r\n]             -> WATERSTART {recover}
 %%    WATERSTART ~[\ \t\12\r\n]* -> WATER
     ~[\ \t\12\r\n]+ -> WATER
   

Modified: sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-7.sdf
===================================================================
--- sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-7.sdf	2009-06-29 19:33:32 UTC (rev 19592)
+++ sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-7.sdf	2009-06-30 09:42:57 UTC (rev 19593)
@@ -20,7 +20,7 @@
     WATER WATERSTART DefSTAR DefSTARWATER
 
   lexical syntax
-%%    ~[\ \t\12\r\n]             -> WATERSTART {avoid}
+%%    ~[\ \t\12\r\n]             -> WATERSTART {recover}
 %%    WATERSTART ~[\ \t\12\r\n]* -> WATER
     ~[\ \t\12\r\n]+ -> WATER
   

Modified: sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-8.sdf
===================================================================
--- sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-8.sdf	2009-06-29 19:33:32 UTC (rev 19592)
+++ sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-8.sdf	2009-06-30 09:42:57 UTC (rev 19593)
@@ -18,7 +18,7 @@
     WATER WATERSTART DefSTAR DefSTARWATER
 
   lexical syntax
-%%    ~[\ \t\12\r\n]             -> WATERSTART {avoid}
+%%    ~[\ \t\12\r\n]             -> WATERSTART {recover}
 %%    WATERSTART ~[\ \t\12\r\n]* -> WATER
     ~[\ \t\12\r\n]+ -> WATER
   

Modified: sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-9.sdf
===================================================================
--- sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-9.sdf	2009-06-29 19:33:32 UTC (rev 19592)
+++ sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-9.sdf	2009-06-30 09:42:57 UTC (rev 19593)
@@ -22,7 +22,7 @@
     WATER WATERSTART DefSTAR DefSTARWATER DefPURESTARWATER
 
   lexical syntax
-%%    ~[\ \t\12\r\n]             -> WATERSTART {avoid}
+%%    ~[\ \t\12\r\n]             -> WATERSTART {recover}
 %%    WATERSTART ~[\ \t\12\r\n]* -> WATER
     ~[\ \t\12\r\n]+ -> WATER
   

Modified: sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-X.sdf
===================================================================
--- sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-X.sdf	2009-06-29 19:33:32 UTC (rev 19592)
+++ sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-X.sdf	2009-06-30 09:42:57 UTC (rev 19593)
@@ -20,7 +20,7 @@
     WATER WATERSTART DefSTAR DefSTARWATER DefPURESTARWATER
 
   lexical syntax
-%%    ~[\ \t\12\r\n]             -> WATERSTART {avoid}
+%%    ~[\ \t\12\r\n]             -> WATERSTART {recover}
 %%    WATERSTART ~[\ \t\12\r\n]* -> WATER
     ~[\ \t\12\r\n]+ -> WATER
   

Modified: sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-X2.sdf
===================================================================
--- sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-X2.sdf	2009-06-29 19:33:32 UTC (rev 19592)
+++ sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-X2.sdf	2009-06-30 09:42:57 UTC (rev 19593)
@@ -16,7 +16,7 @@
     WATER WATERSTART DefSTAR DefSTARWATER DefPURESTARWATER
 
   lexical syntax
-%%    ~[\ \t\12\r\n]             -> WATERSTART {avoid}
+%%    ~[\ \t\12\r\n]             -> WATERSTART {recover}
 %%    WATERSTART ~[\ \t\12\r\n]* -> WATER
     ~[\ \t\12\r\n]+ -> WATER
   

Modified: sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-X3.sdf
===================================================================
--- sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-X3.sdf	2009-06-29 19:33:32 UTC (rev 19592)
+++ sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-X3.sdf	2009-06-30 09:42:57 UTC (rev 19593)
@@ -16,7 +16,7 @@
     WATER WATERSTART DefSTAR DefSTARWATER DefPURESTARWATER
 
   lexical syntax
-%%    ~[\ \t\12\r\n]             -> WATERSTART {avoid}
+%%    ~[\ \t\12\r\n]             -> WATERSTART {recover}
 %%    WATERSTART ~[\ \t\12\r\n]* -> WATER
     ~[\ \t\12\r\n]+ -> WATER
   

Modified: sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-X4.sdf
===================================================================
--- sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-X4.sdf	2009-06-29 19:33:32 UTC (rev 19592)
+++ sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-X4.sdf	2009-06-30 09:42:57 UTC (rev 19593)
@@ -16,7 +16,7 @@
     WATER WATERSTART DefSTAR DefSTARWATER DefPURESTARWATER
 
   lexical syntax
-%%    ~[\ \t\12\r\n]             -> WATERSTART {avoid}
+%%    ~[\ \t\12\r\n]             -> WATERSTART {recover}
 %%    WATERSTART ~[\ \t\12\r\n]* -> WATER
     ~[\ \t\12\r\n]+ -> WATER
   

Modified: sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-X5.sdf
===================================================================
--- sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-X5.sdf	2009-06-29 19:33:32 UTC (rev 19592)
+++ sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-X5.sdf	2009-06-30 09:42:57 UTC (rev 19593)
@@ -17,7 +17,7 @@
     WATER WATERSTART DefSTAR DefSTARWATER DefPURESTARWATER
 
   lexical syntax
-%%    ~[\ \t\12\r\n]             -> WATERSTART {avoid}
+%%    ~[\ \t\12\r\n]             -> WATERSTART {recover}
 %%    WATERSTART ~[\ \t\12\r\n]* -> WATER
     ~[\ \t\12\r\n]+ -> WATER
   

Modified: sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-X6.sdf
===================================================================
--- sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-X6.sdf	2009-06-29 19:33:32 UTC (rev 19592)
+++ sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained-X6.sdf	2009-06-30 09:42:57 UTC (rev 19593)
@@ -17,7 +17,7 @@
     WATER WATERSTART DefSTAR DefSTARWATER DefPURESTARWATER
 
   lexical syntax
-%%    ~[\ \t\12\r\n]             -> WATERSTART {avoid}
+%%    ~[\ \t\12\r\n]             -> WATERSTART {recover}
 %%    WATERSTART ~[\ \t\12\r\n]* -> WATER
     ~[\ \t\12\r\n]+ -> WATER
   

Modified: sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained.sdf
===================================================================
--- sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained.sdf	2009-06-29 19:33:32 UTC (rev 19592)
+++ sglr-recovery/trunk/permissive-grammars/grammars/stratego-java/Stratego-Java-15-Permissive-CoarseGrained.sdf	2009-06-30 09:42:57 UTC (rev 19593)
@@ -13,7 +13,7 @@
     WATER WATERSTART DefSTAR DefSTARWATER
 
   lexical syntax
-%%    ~[\ \t\12\r\n]             -> WATERSTART {avoid}
+%%    ~[\ \t\12\r\n]             -> WATERSTART {recover}
 %%    WATERSTART ~[\ \t\12\r\n]* -> WATER
     ~[\ \t\12\r\n]+ -> WATER
   



From L.C.L.Kats at tudelft.nl  Tue Jun 30 12:10:28 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Tue, 30 Jun 2009 10:10:28 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19594 - LennartKats -
	sglr-recovery/trunk/other-parsers/src/sglrbridges/otherparsers
	spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
Message-ID: <200906301009.n5UA90wU020511@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-06-30 10:10:28 +0000 (Tue, 30 Jun 2009)
New Revision: 19594

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19594&view=rev

Modified:
   sglr-recovery/trunk/other-parsers/src/sglrbridges/otherparsers/LPGToATerm.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java

Log:
Made RecoveryConnector.isLayoutCharacter public; some minor tweaks.

Changes:

Modified: sglr-recovery/trunk/other-parsers/src/sglrbridges/otherparsers/LPGToATerm.java
===================================================================
--- sglr-recovery/trunk/other-parsers/src/sglrbridges/otherparsers/LPGToATerm.java	2009-06-30 09:42:57 UTC (rev 19593)
+++ sglr-recovery/trunk/other-parsers/src/sglrbridges/otherparsers/LPGToATerm.java	2009-06-30 10:10:28 UTC (rev 19594)
@@ -1,12 +1,9 @@
 package sglrbridges.otherparsers;
 
 import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
 
 import lpg.runtime.IAst;
 
-import org.eclipse.imp.lpg.parser.JavaParser.AstToken;
 import org.eclipse.imp.lpg.parser.JavaParser.ILiteral;
 import org.eclipse.imp.lpg.parser.JavaParser.INumericType;
 

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java	2009-06-30 09:42:57 UTC (rev 19593)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoveryConnector.java	2009-06-30 10:10:28 UTC (rev 19594)
@@ -2,8 +2,6 @@
 
 import java.io.IOException;
 
-import junit.framework.Assert;
-
 public class RecoveryConnector {
     private SGLR mySGLR;
     private IRecoveryParser recoveryParser;
@@ -124,6 +122,7 @@
     }
     
     private void tryParsing(String fragment, boolean asLayout) throws IOException{
+        // Skip any leading whitespace, since we already parsed up to that point
         int indexFragment = findFirstNonLayoutToken(fragment);        
         while(indexFragment<fragment.length() && mySGLR.activeStacks.size()>0) {                        
             mySGLR.currentToken=fragment.charAt(indexFragment);
@@ -156,7 +155,8 @@
         }
     }
     
-    private boolean isLayoutCharacter(char aChar){
+    public static boolean isLayoutCharacter(char aChar) {
+        // TODO: Move this to the parse table class; only it truely can now layout characters
         return aChar==' ' || aChar == '\t' || aChar=='\n';
     }
 



From L.C.L.Kats at tudelft.nl  Tue Jun 30 12:55:26 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Tue, 30 Jun 2009 10:55:26 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19595 - LennartKats - in
	spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser:
	. ast
Message-ID: <200906301053.n5UArwhB020823@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-06-30 10:55:26 +0000 (Tue, 30 Jun 2009)
New Revision: 19595

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19595&view=rev

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ParseErrorHandler.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/SGLRParseController.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AmbAsfixImploder.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AsfixImploder.java

Log:
Support reporting parse errors for structure recovery. (Still getting some off-by-one errors.)

Changes:

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ParseErrorHandler.java
===================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ParseErrorHandler.java	2009-06-30 10:10:28 UTC (rev 19594)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ParseErrorHandler.java	2009-06-30 10:55:26 UTC (rev 19595)
@@ -6,6 +6,7 @@
 import org.eclipse.imp.parser.IMessageHandler;
 import org.spoofax.jsglr.BadTokenException;
 import org.spoofax.jsglr.ParseTimeoutException;
+import org.spoofax.jsglr.RecoveryConnector;
 import org.spoofax.jsglr.TokenExpectedException;
 import org.strategoxt.imp.runtime.Environment;
 import org.strategoxt.imp.runtime.ISourceInfo;
@@ -23,12 +24,27 @@
  */
 public class ParseErrorHandler {
 	
+	/**
+	 * The constructor used for "water" recovery rules.
+	 */
 	public static final String WATER = "WATER";
 	
-	private static final String INSERT = "INSERTION";
+	/**
+	 * The constructor used for "insertion" recovery rules.
+	 */
+	public static final String INSERT = "INSERTION";
 	
-	private static final String INSERT_END = "INSERTEND";
+	/**
+	 * The constructor used for "end insertion" recovery rules.
+	 */
+	public static final String INSERT_END = "INSERTEND";
 	
+	/**
+	 * The parse stream character that indicates a character has
+	 * been skipped by the parser.
+	 */
+	public static final char SKIPPED_CHAR = (char) -1;
+	
 	private final AstMessageHandler handler = new AstMessageHandler(AstMessageHandler.PARSE_MARKER_TYPE);
 	
 	private final ISourceInfo sourceInfo;
@@ -70,19 +86,20 @@
 	 */
 	public void reportNonFatalErrors(SGLRTokenizer tokenizer, ATerm top) {
 		try {
-			offset=0;
-			reportOnRepairedCode(tokenizer, termAt(top, 0));
+			offset = 0;
+			reportSkippedFragments(tokenizer);
+			reportRecoveredErrors(tokenizer, termAt(top, 0));
 		} catch (RuntimeException e) {
 			reportError(tokenizer, e);
 		}
 	}
 
-	private void reportOnRepairedCode(SGLRTokenizer tokenizer, ATerm term) {
+	private void reportRecoveredErrors(SGLRTokenizer tokenizer, ATerm term) {
 		// TODO: Nicer error messages; merge consecutive error tokens etc.
 		
 		if ("amb".equals(((ATermAppl) term).getAFun().getName())) {
 			for (ATermList cons = (ATermList) term.getChildAt(0); !cons.isEmpty(); cons = cons.getNext()) {
-				reportOnRepairedCode(tokenizer, cons.getFirst());
+				reportRecoveredErrors(tokenizer, cons.getFirst());
 			}
 			return;
 		}
@@ -99,7 +116,7 @@
 			if (child.getType() == ATerm.INT) {
 				offset += 1;				
 			} else {
-				reportOnRepairedCode(tokenizer, child);
+				reportRecoveredErrors(tokenizer, child);
 			}
 		}
 		
@@ -120,6 +137,26 @@
 		}
 	}
 	
+	private void reportSkippedFragments(SGLRTokenizer tokenizer) {
+		char[] inputChars = tokenizer.getLexStream().getInputChars();
+		for (int i = 0; i < inputChars.length; i++) {
+			char c = inputChars[i];
+			if (c == SKIPPED_CHAR) {
+				int beginSkipped = i;
+				int endSkipped = i;
+				while (++i < inputChars.length) {
+					c = inputChars[i];
+					if (c == SKIPPED_CHAR)
+						endSkipped = i;
+					else if (!RecoveryConnector.isLayoutCharacter(c))
+						break;
+				}
+				IToken token = tokenizer.makeErrorToken(beginSkipped, endSkipped);
+				reportErrorAtTokens(token, token, "Could not parse this fragment");
+			}
+		}
+	}
+	
 		
 	public void reportError(SGLRTokenizer tokenizer, TokenExpectedException exception) {
 		String message = exception.getShortMessage();

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/SGLRParseController.java
===================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/SGLRParseController.java	2009-06-30 10:10:28 UTC (rev 19594)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/SGLRParseController.java	2009-06-30 10:55:26 UTC (rev 19595)
@@ -160,7 +160,7 @@
 			char[] inputChars = input.toCharArray();
 				
 			if (monitor.isCanceled()) return null;
-			currentAst = parser.parse(inputChars, filename);			
+			currentAst = parser.parse(inputChars, filename);
 			if (monitor.isCanceled()) return null;
 			// For error handling, retrieve the cached, unimploded asfix tree
 			asfix = parser.parseNoImplode(inputChars, filename);

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AmbAsfixImploder.java
===================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AmbAsfixImploder.java	2009-06-30 10:10:28 UTC (rev 19594)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AmbAsfixImploder.java	2009-06-30 10:55:26 UTC (rev 19595)
@@ -38,13 +38,13 @@
 		
 		final int oldOffset = offset;
 		final int oldBeginOffset = tokenizer.getStartOffset();
-		final boolean oldLexicalContext = lexicalContext;
+		final boolean oldLexicalContext = inLexicalContext;
 		
 		for (ATerm amb : ambs) {
 			// Restore lexical state for each branch
 			offset = oldOffset;
 			tokenizer.setStartOffset(oldBeginOffset);
-			lexicalContext = oldLexicalContext;
+			inLexicalContext = oldLexicalContext;
 			
 			results.add(implodeAppl(amb));
 		}

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AsfixImploder.java
===================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AsfixImploder.java	2009-06-30 10:10:28 UTC (rev 19594)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AsfixImploder.java	2009-06-30 10:55:26 UTC (rev 19595)
@@ -12,7 +12,10 @@
 import lpg.runtime.IToken;
 import lpg.runtime.PrsStream;
 
+import org.spoofax.jsglr.RecoveryConnector;
 import org.strategoxt.imp.runtime.Debug;
+import org.strategoxt.imp.runtime.Environment;
+import org.strategoxt.imp.runtime.parser.ParseErrorHandler;
 import org.strategoxt.imp.runtime.parser.tokens.SGLRTokenizer;
 import org.strategoxt.imp.runtime.parser.tokens.TokenKindManager;
 
@@ -56,7 +59,7 @@
 	/** Character offset for the current implosion. */ 
 	protected int offset;
 	
-	protected boolean lexicalContext;
+	protected boolean inLexicalContext;
 	
     public AsfixImploder(TokenKindManager tokenManager) {
 		this.tokenManager = tokenManager;
@@ -79,7 +82,7 @@
 		
 		ATerm top = (ATerm) asfix.getChildAt(PARSE_TREE);
 		offset = 0;
-		lexicalContext = false;
+		inLexicalContext = false;
 		
 		try {
 			result = implodeAppl(top);
@@ -113,20 +116,20 @@
 		IToken prevToken = tokenizer.currentToken();
 		
 		// Enter lexical context if this is a lex node
-		boolean lexicalStart = !lexicalContext
+		boolean lexicalStart = !inLexicalContext
 			&& ("lex".equals(rhs.getName()) || AsfixAnalyzer.isLiteral(rhs)
 			    || AsfixAnalyzer.isLayout(rhs));
 		
-		if (lexicalStart) lexicalContext = true;
+		if (lexicalStart) inLexicalContext = true;
 		
-		if (!lexicalContext && "sort".equals(rhs.getName()) && lhs.getLength() == 1 && termAt(contents, 0).getType() == ATerm.INT) {
+		if (!inLexicalContext && "sort".equals(rhs.getName()) && lhs.getLength() == 1 && termAt(contents, 0).getType() == ATerm.INT) {
 			return createIntTerminal(contents, rhs);
 		}
 		
-		boolean isList = !lexicalContext && AsfixAnalyzer.isList(rhs);
-		boolean isVar  = !lexicalContext && !isList && "varsym".equals(rhs.getName());
+		boolean isList = !inLexicalContext && AsfixAnalyzer.isList(rhs);
+		boolean isVar  = !inLexicalContext && !isList && "varsym".equals(rhs.getName());
 		
-		if (isVar) lexicalContext = true;
+		if (isVar) inLexicalContext = true;
 		
 		// Recurse the tree (and set children if applicable)
 		ArrayList<AstNode> children =
@@ -134,7 +137,7 @@
 		
 		if (lexicalStart || isVar) {
 			return createStringTerminal(lhs, rhs);
-		} else if (lexicalContext) {
+		} else if (inLexicalContext) {
 			return null; // don't create tokens inside lexical context; just create one big token at the top
 		} else {
 			return createNonTerminalOrInjection(lhs, rhs, attrs, prevToken, children, isList);
@@ -142,7 +145,7 @@
 	}
 
 	protected ArrayList<AstNode> implodeChildNodes(ATermList contents) {
-		ArrayList<AstNode> results = lexicalContext
+		ArrayList<AstNode> results = inLexicalContext
 				? null
 				: new ArrayList<AstNode>(
 						min(EXPECTED_NODE_CHILDREN, contents.getChildCount()));
@@ -165,7 +168,7 @@
 	}
 
 	private StringAstNode createStringTerminal(ATermList lhs, ATermAppl rhs) {
-		lexicalContext = false;
+		inLexicalContext = false;
 		IToken token = tokenizer.makeToken(offset, tokenManager.getTokenKind(lhs, rhs), true);
 		String sort = reader.getSort(rhs);
 		
@@ -290,7 +293,7 @@
 		if (!multipleNonAvoids) {
 			return lastNonAvoid != null ? lastNonAvoid : firstOption;
 		} else {
-			if (Debug.ENABLED && !lexicalContext) reportUnresolvedAmb(ambs);
+			if (Debug.ENABLED && !inLexicalContext) reportUnresolvedAmb(ambs);
 			return firstOption;
 		}
 	}
@@ -342,14 +345,30 @@
 	
 	/** Implode any appl(_, _) that constructs a lex terminal. */
 	protected void implodeLexical(ATermInt character) {
-		assert tokenizer.getLexStream().getInputChars().length > offset
-		    && character.getInt() == tokenizer.getLexStream().getCharValue(offset)
-			: "Character from asfix stream (" + character.getInt()
-			+ ") must be in lex stream ("
-			+ (tokenizer.getLexStream().getInputChars().length > offset 
-			   ? (int) tokenizer.getLexStream().getCharValue(offset)
-			   :  "???") + ")";
+		char[] inputChars = tokenizer.getLexStream().getInputChars();
+		if (inputChars.length <= offset) {
+			// TODO: Must throw an exception in this case
+			Environment.logException("Unexpected character in parse tree: " + (char) character.getInt());
+			// offset++;
+			return;
+			// throw new IllegalStateException("Unexpected character in parse tree: " + character);
+		}
 		
+		char parsedChar = (char) character.getInt();
+		char inputChar = inputChars[offset];
+		
+		if (parsedChar != inputChar) {
+			if (RecoveryConnector.isLayoutCharacter((char) parsedChar)) {
+				// Remember that the parser skipped the current character
+				// for later error reporting. (Cannot modify the immutable
+				// parse tree here; changing the original stream instead.)
+				inputChars[offset] = ParseErrorHandler.SKIPPED_CHAR;
+			} else {
+				throw new IllegalStateException("Character from asfix stream (" + parsedChar
+						+ ") must be in lex stream (" + inputChar + ")");
+			}
+		}
+		
 		offset++;
 	}
 }



From L.C.L.Kats at tudelft.nl  Tue Jun 30 15:40:58 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Tue, 30 Jun 2009 13:40:58 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19598 - LennartKats - in
	spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser:
	. ast
Message-ID: <200906301339.n5UDdVZH022840@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-06-30 13:40:58 +0000 (Tue, 30 Jun 2009)
New Revision: 19598

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19598&view=rev

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ParseErrorHandler.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/SGLRParseController.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AsfixImploder.java

Log:
- Properly handle parse tree ambiguities in the error reporting module
- Report any ambiguities in context-free syntax in the editor

Changes:

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ParseErrorHandler.java
===================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ParseErrorHandler.java	2009-06-30 11:34:07 UTC (rev 19597)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ParseErrorHandler.java	2009-06-30 13:40:58 UTC (rev 19598)
@@ -10,6 +10,7 @@
 import org.spoofax.jsglr.TokenExpectedException;
 import org.strategoxt.imp.runtime.Environment;
 import org.strategoxt.imp.runtime.ISourceInfo;
+import org.strategoxt.imp.runtime.parser.ast.AsfixImploder;
 import org.strategoxt.imp.runtime.parser.ast.AstMessageHandler;
 import org.strategoxt.imp.runtime.parser.tokens.SGLRTokenizer;
 
@@ -49,11 +50,13 @@
 	
 	private final ISourceInfo sourceInfo;
 	
-	private boolean isRecoveryEnabled = true;
+	private boolean isRecoveryAvailable = true;
 
 	private IMessageHandler messages;
 	
 	private int offset;
+	
+	private boolean inLexicalContext;
 
 	public ParseErrorHandler(ISourceInfo sourceInfo) {
 		this.sourceInfo = sourceInfo;
@@ -77,8 +80,8 @@
 	 * Informs the parse error handler that recovery is unavailable.
 	 * This information is reflected in any parse error messages.
 	 */
-	public void setRecoveryEnabled(boolean recoveryEnabled) {
-		this.isRecoveryEnabled = recoveryEnabled;
+	public void setRecoveryAvailable(boolean recoveryAvailable) {
+		this.isRecoveryAvailable = recoveryAvailable;
 	}
 	
 	/**
@@ -88,19 +91,23 @@
 		try {
 			offset = 0;
 			reportSkippedFragments(tokenizer);
-			reportRecoveredErrors(tokenizer, termAt(top, 0));
+			ATermAppl asfix = termAt(top, 0);
+			reportRecoveredErrors(tokenizer, asfix);
 		} catch (RuntimeException e) {
 			reportError(tokenizer, e);
 		}
 	}
 
-	private void reportRecoveredErrors(SGLRTokenizer tokenizer, ATerm term) {
+	private void reportRecoveredErrors(SGLRTokenizer tokenizer, ATermAppl term) {
 		// TODO: Nicer error messages; merge consecutive error tokens etc.
+		int startOffset = offset;
 		
-		if ("amb".equals(((ATermAppl) term).getAFun().getName())) {
-			for (ATermList cons = (ATermList) term.getChildAt(0); !cons.isEmpty(); cons = cons.getNext()) {
-				reportRecoveredErrors(tokenizer, cons.getFirst());
-			}
+		if ("amb".equals(term.getAFun().getName())) {
+			// Report errors in first ambiguous branch and update offset
+			ATermList ambs = termAt(term, 0);
+			reportRecoveredErrors(tokenizer, (ATermAppl) ambs.getFirst());
+			
+			reportAmbiguity(tokenizer, term, startOffset);
 			return;
 		}
 		
@@ -108,35 +115,63 @@
 		ATermAppl rhs = termAt(prod, 1);
 		ATermAppl attrs = termAt(prod, 2);
 		ATermList contents = termAt(term, 1);
-		int beginErrorOffSet = offset;
+		boolean lexicalStart = false;
 		
-		// Recurse the tree and update the offset
+		if (!inLexicalContext && AsfixImploder.isLexicalNode(rhs) || AsfixImploder.isVariableNode(rhs)) {
+			inLexicalContext = lexicalStart = true;
+		}
+		
+		// Recursively visit the subtree and update the offset
 		for (int i = 0; i < contents.getLength(); i++) {
 			ATerm child = contents.elementAt(i);
 			if (child.getType() == ATerm.INT) {
 				offset += 1;				
 			} else {
-				reportRecoveredErrors(tokenizer, child);
+				reportRecoveredErrors(tokenizer, (ATermAppl) child);
 			}
 		}
 		
 		//post visit: report error				
 		if (isErrorProduction(attrs, WATER)) {
-			IToken token = tokenizer.makeErrorToken(beginErrorOffSet, offset - 1);
+			IToken token = tokenizer.makeErrorToken(startOffset, offset - 1);
 			reportErrorAtTokens(token, token, "'" + token + "' not expected here");
 		} else if (isErrorProduction(attrs, INSERT_END)) {
-			IToken token = tokenizer.makeErrorToken(beginErrorOffSet, offset - 1);
+			IToken token = tokenizer.makeErrorToken(startOffset, offset - 1);
 			reportErrorAtTokens(token, token, "Closing of '" + token + "' is expected here");
 		} else if (isErrorProduction(attrs, INSERT)) {
-			IToken token = tokenizer.makeErrorTokenSkipLayout(beginErrorOffSet, offset + 1);
-			String inserted = "";
+			IToken token = tokenizer.makeErrorTokenSkipLayout(startOffset, offset + 1);
+			String inserted = ""; // TODO: Handle this default case better
 			if (rhs.getName() == "lit") {
 				inserted = applAt(rhs, 0).getName();
 			}
 			reportErrorAtTokens(token, token, "Expected: '" + inserted + "'");
 		}
+		
+		if (lexicalStart) inLexicalContext = false;
 	}
 	
+	private void reportAmbiguity(SGLRTokenizer tokenizer, ATermAppl amb, int startOffset) {
+		if (!inLexicalContext && hasContextFreeNode(amb)) {
+			IToken token = tokenizer.makeErrorToken(startOffset, offset - 1);
+			reportErrorAtTokens(token, token, "Fragment is ambiguous");
+		}
+	}
+	
+	private static boolean hasContextFreeNode(ATermAppl term) {
+		if ("lit".equals(term.getAFun().getName()))
+			return true;
+		
+		for (int i = 0; i < term.getChildCount(); i++) {
+			ATerm child = termAt(term, i);
+			if (child.getType() == ATerm.AFUN) {
+				boolean success = hasContextFreeNode((ATermAppl) child);
+				if (success) return true;
+			}
+		}
+		
+		return false;
+	}
+	
 	private void reportSkippedFragments(SGLRTokenizer tokenizer) {
 		char[] inputChars = tokenizer.getLexStream().getInputChars();
 		for (int i = 0; i < inputChars.length; i++) {
@@ -192,14 +227,14 @@
 		// 		message, max(0, left.getStartOffset()), max(0, right.getEndOffset()),
 		// 		left.getColumn(), right.getEndColumn(), left.getLine(), right.getEndLine());
 		
-		if (!isRecoveryEnabled)
+		if (!isRecoveryAvailable)
 			message += " (recovery unavailable)";
 		
 		handler.addMarker(sourceInfo.getResource(), left, right, message, IMarker.SEVERITY_ERROR);
 	}
 	
 	private void reportErrorAtFirstLine(String message) {
-		if (!isRecoveryEnabled)
+		if (!isRecoveryAvailable)
 			message += " (recovery unavailable)";
 		
 		handler.addMarkerFirstLine(sourceInfo.getResource(), message, IMarker.SEVERITY_ERROR);

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/SGLRParseController.java
===================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/SGLRParseController.java	2009-06-30 11:34:07 UTC (rev 19597)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/SGLRParseController.java	2009-06-30 13:40:58 UTC (rev 19598)
@@ -168,7 +168,7 @@
 			
 			// (must not be synchronized; uses workspace lock)
 			errorHandler.clearErrors();
-			errorHandler.setRecoveryEnabled(true);
+			errorHandler.setRecoveryAvailable(true);
 			errorHandler.reportNonFatalErrors(parser.getTokenizer(), asfix);
 				
 			Debug.stopTimer("File parsed: " + filename);
@@ -176,22 +176,22 @@
 			// TODO: Don't show stack trace for this
 			if (monitor.isCanceled()) return null;
 			errorHandler.clearErrors();
-			errorHandler.setRecoveryEnabled(false);
+			errorHandler.setRecoveryAvailable(false);
 			errorHandler.reportError(parser.getTokenizer(), e);
 		} catch (TokenExpectedException e) {
 			errorHandler.clearErrors(); // (must not be synchronized; uses workspace lock)
 			errorHandler.reportError(parser.getTokenizer(), e);
 		} catch (BadTokenException e) {
 			errorHandler.clearErrors();
-			errorHandler.setRecoveryEnabled(false);
+			errorHandler.setRecoveryAvailable(false);
 			errorHandler.reportError(parser.getTokenizer(), e);
 		} catch (SGLRException e) {
 			errorHandler.clearErrors();
-			errorHandler.setRecoveryEnabled(false);
+			errorHandler.setRecoveryAvailable(false);
 			errorHandler.reportError(parser.getTokenizer(), e);
 		} catch (IOException e) {
 			errorHandler.clearErrors();
-			errorHandler.setRecoveryEnabled(false);
+			errorHandler.setRecoveryAvailable(false);
 			errorHandler.reportError(parser.getTokenizer(), e);
 		} catch (OperationCanceledException e) {
 			return null;

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AsfixImploder.java
===================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AsfixImploder.java	2009-06-30 11:34:07 UTC (rev 19597)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AsfixImploder.java	2009-06-30 13:40:58 UTC (rev 19598)
@@ -116,9 +116,7 @@
 		IToken prevToken = tokenizer.currentToken();
 		
 		// Enter lexical context if this is a lex node
-		boolean lexicalStart = !inLexicalContext
-			&& ("lex".equals(rhs.getName()) || AsfixAnalyzer.isLiteral(rhs)
-			    || AsfixAnalyzer.isLayout(rhs));
+		boolean lexicalStart = !inLexicalContext && isLexicalNode(rhs);
 		
 		if (lexicalStart) inLexicalContext = true;
 		
@@ -127,7 +125,7 @@
 		}
 		
 		boolean isList = !inLexicalContext && AsfixAnalyzer.isList(rhs);
-		boolean isVar  = !inLexicalContext && !isList && "varsym".equals(rhs.getName());
+		boolean isVar  = !inLexicalContext && !isList && isVariableNode(rhs);
 		
 		if (isVar) inLexicalContext = true;
 		
@@ -144,6 +142,30 @@
 		}
 	}
 
+	/**
+	 * Identifies lexical parse tree nodes.
+	 * 
+	 * @see #isVariableNode(ATermAppl)
+	 *      Identifies variables, which are usually treated similarly to
+	 *      lexical nodes.
+	 * 
+	 * @return true if the current node is lexical.
+	 */
+	public static boolean isLexicalNode(ATermAppl rhs) {
+		return ("lex".equals(rhs.getName()) || AsfixAnalyzer.isLiteral(rhs)
+		    || AsfixAnalyzer.isLayout(rhs));
+	}
+
+	/**
+	 * Identifies parse tree nodes that begin variables.
+	 * 
+	 * @see #isVariableNode(ATermAppl) 
+	 * @return true if the current node is lexical.
+	 */
+	public static boolean isVariableNode(ATermAppl rhs) {
+		return "varsym".equals(rhs.getName());
+	}
+
 	protected ArrayList<AstNode> implodeChildNodes(ATermList contents) {
 		ArrayList<AstNode> results = inLexicalContext
 				? null



From L.C.L.Kats at tudelft.nl  Tue Jun 30 16:29:40 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Tue, 30 Jun 2009 14:29:40 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19600 - LennartKats -
	in strategoxt/branches/strategoxt-annos: . stratego-libraries
	stratego-libraries/rtg/lib
Message-ID: <200906301428.n5UESCM0023335@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-06-30 14:29:40 +0000 (Tue, 30 Jun 2009)
New Revision: 19600

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19600&view=rev

Modified:
   strategoxt/branches/strategoxt-annos/
   strategoxt/branches/strategoxt-annos/stratego-libraries/configure.ac
   strategoxt/branches/strategoxt-annos/stratego-libraries/rtg/lib/Makefile.am

Log:
Merged in r19375:19379 from trunk to fix libstratego-rtg build.

Changes:


Property changes on: strategoxt/branches/strategoxt-annos
___________________________________________________________________
Modified: svn:mergeinfo
   - /strategoxt/branches/strategoxt-with:18038-18120
   + /strategoxt/branches/strategoxt-with:18038-18120
/strategoxt/trunk:19376-19378

Modified: strategoxt/branches/strategoxt-annos/stratego-libraries/configure.ac
===================================================================
--- strategoxt/branches/strategoxt-annos/stratego-libraries/configure.ac	2009-06-30 14:10:16 UTC (rev 19599)
+++ strategoxt/branches/strategoxt-annos/stratego-libraries/configure.ac	2009-06-30 14:29:40 UTC (rev 19600)
@@ -43,7 +43,7 @@
   PPTABLETBL_UNINSTALLED='$(STRATEGOXT)/share/sdf/gpp'
   SDFTBL_UNINSTALLED='$(STRATEGOXT)/share/sdf/sdf-front'
   SDFPPTBL_UNINSTALLED='$(STRATEGOXT)/share/sdf-front'
-  RTGTBL_UNINSTALLED='$(STRATEGOXT)/share/sdf/stratego-regular/rtg.tbl'
+  RTGTBL_UNINSTALLED='$(STRATEGOXT)/share/sdf/stratego-regular'
   STRATEGOTBL_UNINSTALLED='$(STRATEGOXT)/share/sdf/stratego-front/Stratego.tbl'
   STRATEGOBOXTBL_UNINSTALLED='$(STRATEGOXT)/share/sdf/gpp/Stratego-Box.tbl'
   SGLRI='$(STRATEGOXT)/bin/sglri'
@@ -60,7 +60,7 @@
     PPTABLETBL_UNINSTALLED='$(top_builddir)/../gpp/syn/pp-table'
     SDFTBL_UNINSTALLED='$(top_builddir)/../sdf-front/syn'
     SDFPPTBL_UNINSTALLED='$(top_builddir)/../sdf-front/pp'
-    RTGTBL_UNINSTALLED='$(top_builddir)/../stratego-regular/syn/rtg.tbl'
+    RTGTBL_UNINSTALLED='$(top_builddir)/../stratego-regular/syn'
     STRATEGOTBL_UNINSTALLED='$(top_builddir)/../stratego-front/syn/Stratego.tbl'
     STRATEGOBOXTBL_UNINSTALLED='$(top_builddir)/../gpp/syn/box/Stratego-Box.tbl'
     METAEXPLODE='XTC_REPOSITORY=$(BUILD_REPOSITORY) $(top_builddir)/../strc-core/tools/meta-explode'

Modified: strategoxt/branches/strategoxt-annos/stratego-libraries/rtg/lib/Makefile.am
===================================================================
--- strategoxt/branches/strategoxt-annos/stratego-libraries/rtg/lib/Makefile.am	2009-06-30 14:10:16 UTC (rev 19599)
+++ strategoxt/branches/strategoxt-annos/stratego-libraries/rtg/lib/Makefile.am	2009-06-30 14:29:40 UTC (rev 19600)
@@ -6,11 +6,11 @@
 lib_LTLIBRARIES  = libstratego-rtg.la
 EXTRA_DIST = $(rtglib) $(rtglib:.str=.rtree) $(nobase_data_DATA)
 CLEANFILES = $(wildcard *.dep) 
-BOOTCLEANFILES = rtg-aterm.c libstratego-rtg.rtree libstratego-rtg.c $(rtglib:.str=.rtree)
+BOOTCLEANFILES = libstratego-rtg.rtree libstratego-rtg.c $(rtglib:.str=.rtree)
 
 rtglib = stratego-rtg.str $(wildcard stratego/rtg/*.str)
 
-libstratego_rtg_la_SOURCES = libstratego-rtg.c rtg-aterm.c libstratego-rtg-native.c
+libstratego_rtg_la_SOURCES = libstratego-rtg.c libstratego-rtg-native.c
 libstratego_rtg_la_CFLAGS   = $(AM_CFLAGS)
 libstratego_rtg_la_LDFLAGS  = -avoid-version -no-undefined $(AM_LDFLAGS)
 libstratego_rtg_la_CPPFLAGS = $(STRATEGO_UNINSTALLED_CFLAGS) \
@@ -22,11 +22,9 @@
 STRCFLAGS = \
   $(STRATEGO_XTC_UNINSTALLED_STRCFLAGS) \
   $(STRATEGO_SGLR_UNINSTALLED_STRCFLAGS) \
-  $(STRATEGO_UNINSTALLED_STRCFLAGS)
+  $(STRATEGO_UNINSTALLED_STRCFLAGS) \
+  -I $(RTGTBL_UNINSTALLED) 
 
-rtg-aterm.c :
-	$(top_builddir)/build-tools/cgen-aterm --name STRRTG_get_rtg_parsetable -i $(RTGTBL_UNINSTALLED) > $@
-
 libstratego-rtg.rtree libstratego-rtg.c : $(rtglib:.str=.rtree) 
 	$(STRC_UNINSTALLED) -c --library -i $(srcdir)/stratego-rtg.str -o libstratego-rtg.rtree --verbose 1 $(STRCFLAGS)
 	rm libstratego-rtg.str



From L.C.L.Kats at tudelft.nl  Tue Jun 30 16:45:58 2009
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Tue, 30 Jun 2009 14:45:58 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19601 - LennartKats -
	in sglr-recovery/trunk/permissive-grammars: . trans/make-permissive
Message-ID: <200906301444.n5UEiUOt023456@proliant.st.ewi.tudelft.nl>

Author: LennartKats
Date: 2009-06-30 14:45:58 +0000 (Tue, 30 Jun 2009)
New Revision: 19601

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19601&view=rev

Added:
   sglr-recovery/trunk/permissive-grammars/trans/make-permissive/optimize.astr
Modified:
   sglr-recovery/trunk/permissive-grammars/Makefile
   sglr-recovery/trunk/permissive-grammars/trans/make-permissive/make-permissive.astr

Log:
Added an optimization to work around a minor bug in the SDF normalizer,
which caused some ambiguities for parsed literals.

When this is enabled, the rules have the form:
  -> [\125] {recover, cons("INSERTION")}
instead of:
  -> "}" {recover, cons("INSERTION")}


Changes:

Modified: sglr-recovery/trunk/permissive-grammars/Makefile
===================================================================
--- sglr-recovery/trunk/permissive-grammars/Makefile	2009-06-30 14:29:40 UTC (rev 19600)
+++ sglr-recovery/trunk/permissive-grammars/Makefile	2009-06-30 14:45:58 UTC (rev 19601)
@@ -46,22 +46,22 @@
 	$(MAKE) -C trans/make-permissive
 	
 %-Permissive.gendef : %.def trans/make-permissive/make-permissive 
-	trans/make-permissive/make-permissive -i $< -o $@ -m `basename $< .def` -mo `basename $@ .gendef`
+	trans/make-permissive/make-permissive -i $< -o $@ -m `basename $< .def` -mo `basename $@ .gendef` --optimize on
 	
 %-Permissive-WaterOnly.gendef : %.def trans/make-permissive/make-permissive 
-	trans/make-permissive/make-permissive -i $< -o $@ -m `basename $< .def` -mo `basename $@ .gendef` --insertions off
+	trans/make-permissive/make-permissive -i $< -o $@ -m `basename $< .def` -mo `basename $@ .gendef` --optimize on --insertions off
 	
 %-Permissive-InsertionsOnly.gendef : %.def trans/make-permissive/make-permissive 
-	trans/make-permissive/make-permissive -i $< -o $@ -m `basename $< .def` -mo `basename $@ .gendef` --water off --open-insertions off
+	trans/make-permissive/make-permissive -i $< -o $@ -m `basename $< .def` -mo `basename $@ .gendef` --optimize on --water off --open-insertions off
 	
 %-Permissive-InsertionsOnly-WithOpenBraces.gendef : %.def trans/make-permissive/make-permissive 
-	trans/make-permissive/make-permissive -i $< -o $@ -m `basename $< .def` -mo `basename $@ .gendef` --water off --open-insertions on
+	trans/make-permissive/make-permissive -i $< -o $@ -m `basename $< .def` -mo `basename $@ .gendef` --optimize on --water off --open-insertions on
 	
 %-Permissive-WithOpenBraces.gendef : %.def trans/make-permissive/make-permissive 
-	trans/make-permissive/make-permissive -i $< -o $@ -m `basename $< .def` -mo `basename $@ .gendef` --open-insertions on
+	trans/make-permissive/make-permissive -i $< -o $@ -m `basename $< .def` -mo `basename $@ .gendef` --optimize on --open-insertions on
 
 %-Permissive-AllInsertions.gendef : %.def trans/make-permissive/make-permissive 
-	trans/make-permissive/make-permissive -i $< -o $@ -m `basename $< .def` -mo `basename $@ .gendef` --all-insertions on
+	trans/make-permissive/make-permissive -i $< -o $@ -m `basename $< .def` -mo `basename $@ .gendef` --optimize on --all-insertions on
 
 .PHONY :
 

Modified: sglr-recovery/trunk/permissive-grammars/trans/make-permissive/make-permissive.astr
===================================================================
--- sglr-recovery/trunk/permissive-grammars/trans/make-permissive/make-permissive.astr	2009-06-30 14:29:40 UTC (rev 19600)
+++ sglr-recovery/trunk/permissive-grammars/trans/make-permissive/make-permissive.astr	2009-06-30 14:45:58 UTC (rev 19601)
@@ -16,6 +16,7 @@
   sdf-heuristics
   water-sections
   insert-sections
+  optimize
 
 overlays
 
@@ -24,6 +25,7 @@
   ALL_INSERTIONS_ON  = "all-insertions"
   INSERTIONS_ON      = "insertions"
   SEPARATORS_ON      = "separators"
+  OPTIMIZE_ON        = "optimize"
 
 strategies // I/O
 
@@ -39,6 +41,7 @@
       id.init;
 
       add-permissive-sections;
+      optimize-sdf;
       
       sdf-desugar;      
       parenthesize-Sdf2;
@@ -72,6 +75,11 @@
     , "off"
     , "Add insertion recovery rules for all literals (not recommended)"
     )
+  + SwitchOption(|
+      OPTIMIZE_ON()
+    , "off"
+    , "Optimize the inserted literals to character groups"
+    )
   + ArgOption(
       "-m"
     , <set-config> ("-m", <id>)

Added: sglr-recovery/trunk/permissive-grammars/trans/make-permissive/optimize.astr
===================================================================
--- sglr-recovery/trunk/permissive-grammars/trans/make-permissive/optimize.astr	                        (rev 0)
+++ sglr-recovery/trunk/permissive-grammars/trans/make-permissive/optimize.astr	2009-06-30 14:45:58 UTC (rev 19601)
@@ -0,0 +1,18 @@
+module optimize
+
+strategies
+
+  optimize-sdf = alltd(optimize)
+  
+  // Convert literal rhs to char group (e.g., "{" -> [\125])
+  optimize:
+    prod(pattern, lit(s), attrs) ->
+    prod(
+      pattern
+    , char-class(simple-charclass(present(numeric(chargroup))))
+    , attrs
+    )
+    where
+      <explode-string> s => ['"', char, '"']
+    with
+      chargroup := <conc-strings> ("\\", <write-to-string> char)
\ No newline at end of file



From mdjonge at xs4all.nl  Mon Jun 29 12:58:42 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Mon, 29 Jun 2009 10:58:42 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19581 - MaartjeDeJonge
	- sglr-recovery/trunk/Evaluation_Recovery/src
Message-ID: <200906291057.n5TAvG8Z002300@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-29 10:58:42 +0000 (Mon, 29 Jun 2009)
New Revision: 19581

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19581&view=rev

Modified:
   sglr-recovery/trunk/Evaluation_Recovery/src/ProcessFiles.java

Log:
no-bridgeparser (gives an exeption)

Changes:

Modified: sglr-recovery/trunk/Evaluation_Recovery/src/ProcessFiles.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/src/ProcessFiles.java	2009-06-29 10:53:54 UTC (rev 19580)
+++ sglr-recovery/trunk/Evaluation_Recovery/src/ProcessFiles.java	2009-06-29 10:58:42 UTC (rev 19581)
@@ -35,7 +35,7 @@
 	private StandAloneSGLRI tokenParser;
 	private IRecoveryParser recoveryParser;
 	private InputStream fis;
-	private boolean useBridgeParser=true;	
+	private boolean useBridgeParser=false;	
 	
 
 	private void createJDT_Tree(String fileName, String inputDir, String outputDir) throws IOException, InterpreterException {	
@@ -92,7 +92,7 @@
         sglr = new SGLR(ptm.getFactory(), ptm.loadFromFile(PARSE_TABLE));        
         sglr.getDisambiguator().setFilterAny(false);  
         sglr.setRecoveryTestingWorkAround(true);
-        if (false && TOKEN_PARSE_TABLE != null && useBridgeParser) {
+        if (TOKEN_PARSE_TABLE != null && useBridgeParser) {
 			FileInputStream table = new FileInputStream(TOKEN_PARSE_TABLE);
 			tokenParser = new StandAloneSGLRI(null, table, null, /*USE_CSGLR*/true);
 			tokenParser.setKeepAmbiguities(true);



From mdjonge at xs4all.nl  Mon Jun 29 13:47:57 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Mon, 29 Jun 2009 11:47:57 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19582 - MaartjeDeJonge
	- in sglr-recovery/trunk/Evaluation_Recovery: Language_Files src
Message-ID: <200906291146.n5TBkV5P003094@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-29 11:47:57 +0000 (Mon, 29 Jun 2009)
New Revision: 19582

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19582&view=rev

Modified:
   sglr-recovery/trunk/Evaluation_Recovery/Language_Files/SpecialTokenRecovery.tbl
   sglr-recovery/trunk/Evaluation_Recovery/src/ProcessFiles.java

Log:
avoid -> recover

Changes:

Modified: sglr-recovery/trunk/Evaluation_Recovery/Language_Files/SpecialTokenRecovery.tbl
===================================================================
(Binary files differ)

Modified: sglr-recovery/trunk/Evaluation_Recovery/src/ProcessFiles.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/src/ProcessFiles.java	2009-06-29 10:58:42 UTC (rev 19581)
+++ sglr-recovery/trunk/Evaluation_Recovery/src/ProcessFiles.java	2009-06-29 11:47:57 UTC (rev 19582)
@@ -28,14 +28,15 @@
 	private final static String LOC_CORRECT_SGLR_PARSETREES="Correct_Files/sglr_parsetree";
 	private final static String LOC_ERROR_SGLR_PARSETREES="Error_Files/sglr_parsetree";
 	
-	private final static String PARSE_TABLE ="Language_Files/InsertOnly.tbl";
+	//private final static String PARSE_TABLE ="Language_Files/InsertOnly.tbl";
+	private final static String PARSE_TABLE ="Language_Files/SpecialTokenRecovery.tbl";
 	private final static String TOKEN_PARSE_TABLE ="Language_Files/Java-15-Tokenizer.tbl";	
 	
 	private SGLR sglr;
 	private StandAloneSGLRI tokenParser;
 	private IRecoveryParser recoveryParser;
 	private InputStream fis;
-	private boolean useBridgeParser=false;	
+	private boolean useBridgeParser=true;	
 	
 
 	private void createJDT_Tree(String fileName, String inputDir, String outputDir) throws IOException, InterpreterException {	



From mdjonge at xs4all.nl  Mon Jun 29 14:01:20 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Mon, 29 Jun 2009 12:01:20 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19583 - MaartjeDeJonge -
	spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/ecjadapter
Message-ID: <200906291159.n5TBxrGM003270@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-29 12:01:20 +0000 (Mon, 29 Jun 2009)
New Revision: 19583

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19583&view=rev

Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/ecjadapter/ParseJava.java

Log:
error recovery

Changes:

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/ecjadapter/ParseJava.java
===================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/ecjadapter/ParseJava.java	2009-06-29 11:47:57 UTC (rev 19582)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/org/spoofax/ecjadapter/ParseJava.java	2009-06-29 12:01:20 UTC (rev 19583)
@@ -9,9 +9,15 @@
 
 import java.io.BufferedReader;
 import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
 import java.io.FileReader;
 import java.io.IOException;
+import java.util.HashMap;
+import java.util.Hashtable;
+import java.util.Map;
+import java.util.Set;
 
+import org.eclipse.jdt.core.JavaCore;
 import org.eclipse.jdt.core.dom.AST;
 import org.eclipse.jdt.core.dom.ASTNode;
 import org.eclipse.jdt.core.dom.ASTParser;
@@ -26,13 +32,19 @@
     public static void main(String[] args) throws IOException, InterpreterException {
         
     	String inputFile = null;
-        
+    	String outputFile = null;
+    	boolean statmentsRecovery=false;
+    	
         for (int i = 0; i < args.length; i++) {
             if (args[i].equals("--debug")) {
                 DebugUtil.setDebug(true);
             } else if (args[i].equals("-i")) {
                 inputFile = args[i + 1];
-            } 
+            } else if (args[i].equals("-o")) {
+                outputFile = args[i + 1];
+            }else if (args[i].equals("-sr")) {
+                statmentsRecovery=true;
+            }
         }
 
         if(inputFile == null) {
@@ -40,7 +52,7 @@
             System.exit(2);
         }
 
-        IStrategoTerm r = parseJava(inputFile);
+        IStrategoTerm r = parseJava(inputFile, statmentsRecovery);
         if(r == null) {
         	System.err.println("Failed to open and read file " + inputFile);
         	System.exit(3);
@@ -48,12 +60,20 @@
 
         InlinePrinter ip = new InlinePrinter();
         r.prettyPrint(ip);
-        System.out.println(ip.getString());
+        String output= ip.getString();
+        System.out.println(output);
+        
+        if(outputFile!=null){
+        	FileOutputStream ous = new FileOutputStream(outputFile);
+        	ous.write(output.getBytes());
+        }
     }
  
-    private static IStrategoTerm parseJava(String fileName) throws FileNotFoundException, IOException {
+    private static IStrategoTerm parseJava(String fileName, boolean useStatementsRecovery) throws FileNotFoundException, IOException {
     
     	ASTParser parser = ASTParser.newParser(AST.JLS3);
+    	parser.setStatementsRecovery(useStatementsRecovery);   	
+    	
     	parser.setSource(getBytes(fileName));
     
     	ASTNode ast = parser.createAST(null);



From mdjonge at xs4all.nl  Mon Jun 29 14:31:01 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Mon, 29 Jun 2009 12:31:01 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19584 - MaartjeDeJonge
	- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
Message-ID: <200906291229.n5TCTY32003726@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-29 12:31:01 +0000 (Mon, 29 Jun 2009)
New Revision: 19584

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19584&view=rev

Modified:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java

Log:
bridge parser

Changes:

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-06-29 12:01:20 UTC (rev 19583)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-06-29 12:31:01 UTC (rev 19584)
@@ -185,7 +185,7 @@
      */
     public void setUseStructureRecovery(boolean useRoughRecovery, IRecoveryParser parser) {
         useIntegratedRecovery = true;
-        recoverIntegrator = new RecoveryConnector(this, null);
+        recoverIntegrator = new RecoveryConnector(this, parser);
     }
     
     /**



From mdjonge at xs4all.nl  Mon Jun 29 15:48:35 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Mon, 29 Jun 2009 13:48:35 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19585 - MaartjeDeJonge
	- in sglr-recovery/trunk/Evaluation_Recovery: Language_Files src
Message-ID: <200906291347.n5TDl8l6004665@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-29 13:48:35 +0000 (Mon, 29 Jun 2009)
New Revision: 19585

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19585&view=rev

Removed:
   sglr-recovery/trunk/Evaluation_Recovery/Language_Files/CombineAll.tbl
   sglr-recovery/trunk/Evaluation_Recovery/Language_Files/InsertOnly.tbl
Modified:
   sglr-recovery/trunk/Evaluation_Recovery/src/ProcessFiles.java

Log:
old avoid-tables removed
xxtestFile

Changes:

Deleted: sglr-recovery/trunk/Evaluation_Recovery/Language_Files/CombineAll.tbl
===================================================================
(Binary files differ)

Deleted: sglr-recovery/trunk/Evaluation_Recovery/Language_Files/InsertOnly.tbl
===================================================================
(Binary files differ)

Modified: sglr-recovery/trunk/Evaluation_Recovery/src/ProcessFiles.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/src/ProcessFiles.java	2009-06-29 12:31:01 UTC (rev 19584)
+++ sglr-recovery/trunk/Evaluation_Recovery/src/ProcessFiles.java	2009-06-29 13:48:35 UTC (rev 19585)
@@ -36,7 +36,7 @@
 	private StandAloneSGLRI tokenParser;
 	private IRecoveryParser recoveryParser;
 	private InputStream fis;
-	private boolean useBridgeParser=true;	
+	private boolean useBridgeParser=false;	
 	
 
 	private void createJDT_Tree(String fileName, String inputDir, String outputDir) throws IOException, InterpreterException {	
@@ -68,7 +68,7 @@
 		}
 	}
 	
-	public void testFile() throws IOException, InterpreterException, SGLRException{
+	public void xxtestFile() throws IOException, InterpreterException, SGLRException{
 		String fileName="testFile.java";
 		//String fileName="testFile2.java";
 		createJDT_Tree(fileName, LOC_ERROR_INPUTFILES, LOC_ERROR_JDT_TREES);



From emma at cs.lth.se  Mon Jun 29 15:50:18 2009
From: emma at cs.lth.se (Emma NilssonNyman)
Date: Mon, 29 Jun 2009 13:50:18 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19586 -
	EmmaNilssonNyman - sglr-recovery/trunk/Evaluation_Recovery/src
Message-ID: <200906291348.n5TDmpkE004686@proliant.st.ewi.tudelft.nl>

Author: EmmaNilssonNyman
Date: 2009-06-29 13:50:18 +0000 (Mon, 29 Jun 2009)
New Revision: 19586

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19586&view=rev

Modified:
   sglr-recovery/trunk/Evaluation_Recovery/src/ProcessFiles.java

Log:
Changed to the generated bridge parser

Changes:

Modified: sglr-recovery/trunk/Evaluation_Recovery/src/ProcessFiles.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/src/ProcessFiles.java	2009-06-29 13:48:35 UTC (rev 19585)
+++ sglr-recovery/trunk/Evaluation_Recovery/src/ProcessFiles.java	2009-06-29 13:50:18 UTC (rev 19586)
@@ -6,7 +6,7 @@
 import java.io.OutputStream;
 import junit.framework.TestCase;
 
-import org.bripgen.sglr.example.JavaSGLRBridgeParser;
+import org.bripgen.sglr.java.JavaSGLRBridgeParser;
 import org.spoofax.interpreter.core.InterpreterException;
 import org.spoofax.jsglr.IRecoveryParser;
 import org.spoofax.jsglr.NoRecovery;



From mdjonge at xs4all.nl  Mon Jun 29 15:56:38 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Mon, 29 Jun 2009 13:56:38 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19587 - MaartjeDeJonge
	- sglr-recovery/trunk/Evaluation_Recovery
Message-ID: <200906291355.n5TDtBBm004761@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-29 13:56:38 +0000 (Mon, 29 Jun 2009)
New Revision: 19587

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19587&view=rev

Modified:
   sglr-recovery/trunk/Evaluation_Recovery/CompileTransformation.sh

Log:
.ast.readable

Changes:

Modified: sglr-recovery/trunk/Evaluation_Recovery/CompileTransformation.sh
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/CompileTransformation.sh	2009-06-29 13:50:18 UTC (rev 19586)
+++ sglr-recovery/trunk/Evaluation_Recovery/CompileTransformation.sh	2009-06-29 13:56:38 UTC (rev 19587)
@@ -24,7 +24,7 @@
 	echo $jdtTreeName	
 	
 	#compare readable ast's
-	diff $jdtAstDir/$jdtTree $sglrAstDir/$jdtTreeName.readable.ast > $diffDir/$jdtTreeName.diff
+	diff $jdtAstDir/$jdtTree $sglrAstDir/$jdtTreeName.ast.readable > $diffDir/$jdtTreeName.diff
 done
 
 



From emma at cs.lth.se  Mon Jun 29 17:12:46 2009
From: emma at cs.lth.se (Emma NilssonNyman)
Date: Mon, 29 Jun 2009 15:12:46 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19588 -
	EmmaNilssonNyman - in sglr-recovery/trunk/Evaluation_Recovery:
	Correct_Files/input_files Error_Files/input_files
Message-ID: <200906291511.n5TFBK9i005873@proliant.st.ewi.tudelft.nl>

Author: EmmaNilssonNyman
Date: 2009-06-29 15:12:46 +0000 (Mon, 29 Jun 2009)
New Revision: 19588

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19588&view=rev

Added:
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testA1.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testA2.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testA3.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testA4.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testA5.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testA6.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testB1.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testB2.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testB3.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testB4.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testB5.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testB6.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testC1.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testC2.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testC3.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testC4.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testD1.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testD2.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testD3.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testD4.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testE1.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testE2.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testE3.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testF1.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testF2.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testF3.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testG1.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testG2.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testG3.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testH1.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testH2.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testH3.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testH4.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testI1.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testI2.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testI3.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testI4.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testI5.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testI6.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testJ1.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testJ2.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testK1.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testK2.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testK3.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testL1.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testL2.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testA1.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testA2.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testA3.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testA4.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testA5.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testA6.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testB1.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testB2.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testB3.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testB4.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testB5.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testB6.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testC1.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testC2.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testC3.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testC4.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testD1.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testD2.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testD3.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testD4.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testE1.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testE2.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testE3.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testF1.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testF2.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testF3.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testG1.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testG2.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testG3.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testH1.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testH2.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testH3.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testH4.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testI1.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testI2.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testI3.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testI4.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testI5.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testI6.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testJ1.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testJ2.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testK1.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testK2.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testK3.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testL1.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testL2.java

Log:
New test files

Changes (first 1000 lines of the diffs):

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testA1.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testA1.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testA1.java	2009-06-29 15:12:46 UTC (rev 19588)
@@ -0,0 +1,15 @@
+
+/* Peak program */
+class C {
+	void m() {
+		if (true) {
+			for (int i; i < 10; i++) {
+				if (true) {
+					if (true) {
+						int a;
+					}
+				}
+			}
+		}
+	}
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testA2.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testA2.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testA2.java	2009-06-29 15:12:46 UTC (rev 19588)
@@ -0,0 +1,15 @@
+
+/* Peak program */
+class C {
+	void m() {
+		if (true) {
+			for (int i; i < 10; i++) {
+				if (true) {
+					if (true) {
+						int a;
+					}
+				}
+			}
+		}
+	}
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testA3.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testA3.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testA3.java	2009-06-29 15:12:46 UTC (rev 19588)
@@ -0,0 +1,15 @@
+
+/* Peak program */
+class C {
+	void m() {
+		if (true) {
+			for (int i; i < 10; i++) {
+				if (true) {
+					if (true) {
+						int a;
+					}
+				}
+			}
+		}
+	}
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testA4.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testA4.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testA4.java	2009-06-29 15:12:46 UTC (rev 19588)
@@ -0,0 +1,15 @@
+
+/* Peak program */
+class C {
+	void m() {
+		if (true) {
+			for (int i; i < 10; i++) {
+				if (true) {
+					if (true) {
+						int a;
+					}
+				}
+			}
+		}
+	}
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testA5.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testA5.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testA5.java	2009-06-29 15:12:46 UTC (rev 19588)
@@ -0,0 +1,15 @@
+
+/* Peak program */
+class C {
+	void m() {
+		if (true) {
+			for (int i; i < 10; i++) {
+				if (true) {
+					if (true) {
+						int a;
+					}
+				}
+			}
+		}
+	}
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testA6.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testA6.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testA6.java	2009-06-29 15:12:46 UTC (rev 19588)
@@ -0,0 +1,15 @@
+
+/* Peak program */
+class C {
+	void m() {
+		if (true) {
+			for (int i; i < 10; i++) {
+				if (true) {
+					if (true) {
+						int a;
+					}
+				}
+			}
+		}
+	}
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testB1.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testB1.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testB1.java	2009-06-29 15:12:46 UTC (rev 19588)
@@ -0,0 +1,15 @@
+/* Bumpy road */
+class C {
+	void m() {
+		int a;
+	}
+	void n() {
+		int b;
+	}
+	void o() {
+		int c;
+	}
+	void p() {
+		int d;
+	}
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testB2.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testB2.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testB2.java	2009-06-29 15:12:46 UTC (rev 19588)
@@ -0,0 +1,15 @@
+/* Bumpy road */
+class C {
+	void m() {
+		int a;
+	}
+	void n() {
+		int b;
+	}
+	void o() {
+		int c;
+	}
+	void p() {
+		int d;
+	}
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testB3.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testB3.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testB3.java	2009-06-29 15:12:46 UTC (rev 19588)
@@ -0,0 +1,15 @@
+/* Bumpy road */
+class C {
+	void m() {
+		int a;
+	}
+	void n() {
+		int b;
+	}
+	void o() {
+		int c;
+	}
+	void p() {
+		int d;
+	}
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testB4.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testB4.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testB4.java	2009-06-29 15:12:46 UTC (rev 19588)
@@ -0,0 +1,15 @@
+/* Bumpy road */
+class C {
+	void m() {
+		int a;
+	}
+	void n() {
+		int b;
+	}
+	void o() {
+		int c;
+	}
+	void p() {
+		int d;
+	}
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testB5.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testB5.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testB5.java	2009-06-29 15:12:46 UTC (rev 19588)
@@ -0,0 +1,15 @@
+/* Bumpy road */
+class C {
+	void m() {
+		int a;
+	}
+	void n() {
+		int b;
+	}
+	void o() {
+		int c;
+	}
+	void p() {
+		int d;
+	}
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testB6.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testB6.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testB6.java	2009-06-29 15:12:46 UTC (rev 19588)
@@ -0,0 +1,15 @@
+/* Bumpy road */
+class C {
+	void m() {
+		int a;
+	}
+	void n() {
+		int b;
+	}
+	void o() {
+		int c;
+	}
+	void p() {
+		int d;
+	}
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testC1.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testC1.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testC1.java	2009-06-29 15:12:46 UTC (rev 19588)
@@ -0,0 +1,43 @@
+/* Rocky mountains */
+class C {
+	int a;
+	void C() {
+		int b;
+	}
+	void m() {
+		if (true) {
+			if (true) {
+				int c;
+				int d;
+			}
+		}
+		if (true) {
+			int e;
+		}
+		int f;
+	}
+	class D {
+		void m() {
+			if (true) {
+				for (int i=0;i<10;i++) {
+					int g;
+					int h;
+					if (true) {
+						int j;
+					}
+				}
+			}
+		}
+		void n() {
+			int k;
+		}
+	}
+	int n() {
+		return 0;
+	}
+}
+class E {
+	void m() {
+		int a;
+	}
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testC2.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testC2.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testC2.java	2009-06-29 15:12:46 UTC (rev 19588)
@@ -0,0 +1,43 @@
+/* Rocky mountains */
+class C {
+	int a;
+	void C() {
+		int b;
+	}
+	void m() {
+		if (true) {
+			if (true) {
+				int c;
+				int d;
+			}
+		}
+		if (true) {
+			int e;
+		}
+		int f;
+	}
+	class D {
+		void m() {
+			if (true) {
+				for (int i=0;i<10;i++) {
+					int g;
+					int h;
+					if (true) {
+						int j;
+					}
+				}
+			}
+		}
+		void n() {
+			int k;
+		}
+	}
+	int n() {
+		return 0;
+	}
+}
+class E {
+	void m() {
+		int a;
+	}
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testC3.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testC3.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testC3.java	2009-06-29 15:12:46 UTC (rev 19588)
@@ -0,0 +1,43 @@
+/* Rocky mountains */
+class C {
+	int a;
+	void C() {
+		int b;
+	}
+	void m() {
+		if (true) {
+			if (true) {
+				int c;
+				int d;
+			}
+		}
+		if (true) {
+			int e;
+		}
+		int f;
+	}
+	class D {
+		void m() {
+			if (true) {
+				for (int i=0;i<10;i++) {
+					int g;
+					int h;
+					if (true) {
+						int j;
+					}
+				}
+			}
+		}
+		void n() {
+			int k;
+		}
+	}
+	int n() {
+		return 0;
+	}
+}
+class E {
+	void m() {
+		int a;
+	}
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testC4.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testC4.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testC4.java	2009-06-29 15:12:46 UTC (rev 19588)
@@ -0,0 +1,43 @@
+/* Rocky mountains */
+class C {
+	int a;
+	void C() {
+		int b;
+	}
+	void m() {
+		if (true) {
+			if (true) {
+				int c;
+				int d;
+			}
+		}
+		if (true) {
+			int e;
+		}
+		int f;
+	}
+	class D {
+		void m() {
+			if (true) {
+				for (int i=0;i<10;i++) {
+					int g;
+					int h;
+					if (true) {
+						int j;
+					}
+				}
+			}
+		}
+		void n() {
+			int k;
+		}
+	}
+	int n() {
+		return 0;
+	}
+}
+class E {
+	void m() {
+		int a;
+	}
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testD1.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testD1.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testD1.java	2009-06-29 15:12:46 UTC (rev 19588)
@@ -0,0 +1,30 @@
+/* Misinterpreted statements - if */
+class C {
+	void m() {
+		int a;
+		if (true) {
+			int b;
+		}
+	}
+	void n() {
+		int a;
+		if (true) {
+			int b;
+			if (true) {
+				int c;
+				int d;
+			}
+		}
+		int c;
+	}
+	void o() {
+		int a;
+		if (true) {
+			int b;
+		}
+		if (true) {
+			int c;
+		}
+		int d;
+	}
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testD2.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testD2.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testD2.java	2009-06-29 15:12:46 UTC (rev 19588)
@@ -0,0 +1,30 @@
+/* Misinterpreted statements - if */
+class C {
+	void m() {
+		int a;
+		if (true) {
+			int b;
+		}
+	}
+	void n() {
+		int a;
+		if (true) {
+			int b;
+			if (true) {
+				int c;
+				int d;
+			}
+		}
+		int c;
+	}
+	void o() {
+		int a;
+		if (true) {
+			int b;
+		}
+		if (true) {
+			int c;
+		}
+		int d;
+	}
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testD3.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testD3.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testD3.java	2009-06-29 15:12:46 UTC (rev 19588)
@@ -0,0 +1,30 @@
+/* Misinterpreted statements - if */
+class C {
+	void m() {
+		int a;
+		if (true) {
+			int b;
+		}
+	}
+	void n() {
+		int a;
+		if (true) {
+			int b;
+			if (true) {
+				int c;
+				int d;
+			}
+		}
+		int c;
+	}
+	void o() {
+		int a;
+		if (true) {
+			int b;
+		}
+		if (true) {
+			int c;
+		}
+		int d;
+	}
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testD4.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testD4.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testD4.java	2009-06-29 15:12:46 UTC (rev 19588)
@@ -0,0 +1,30 @@
+/* Misinterpreted statements - if */
+class C {
+	void m() {
+		int a;
+		if (true) {
+			int b;
+		}
+	}
+	void n() {
+		int a;
+		if (true) {
+			int b;
+			if (true) {
+				int c;
+				int d;
+			}
+		}
+		int c;
+	}
+	void o() {
+		int a;
+		if (true) {
+			int b;
+		}
+		if (true) {
+			int c;
+		}
+		int d;
+	}
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testE1.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testE1.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testE1.java	2009-06-29 15:12:46 UTC (rev 19588)
@@ -0,0 +1,17 @@
+/* Misinterpreted statements - for */
+class C {
+	void m() {
+		for (int i=0;i<10;i++) {
+			int a;
+		}
+	}
+	void n() {
+		for (int i=0;i<10;i++) {
+			for (int j=0;j<10;j++) {
+				int a;
+			}
+			int b;
+		}
+		int c;
+	}
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testE2.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testE2.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testE2.java	2009-06-29 15:12:46 UTC (rev 19588)
@@ -0,0 +1,17 @@
+/* Misinterpreted statements - for */
+class C {
+	void m() {
+		for (int i=0;i<10;i++) {
+			int a;
+		}
+	}
+	void n() {
+		for (int i=0;i<10;i++) {
+			for (int j=0;j<10;j++) {
+				int a;
+			}
+			int b;
+		}
+		int c;
+	}
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testE3.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testE3.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testE3.java	2009-06-29 15:12:46 UTC (rev 19588)
@@ -0,0 +1,17 @@
+/* Misinterpreted statements - for */
+class C {
+	void m() {
+		for (int i=0;i<10;i++) {
+			int a;
+		}
+	}
+	void n() {
+		for (int i=0;i<10;i++) {
+			for (int j=0;j<10;j++) {
+				int a;
+			}
+			int b;
+		}
+		int c;
+	}
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testF1.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testF1.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testF1.java	2009-06-29 15:12:46 UTC (rev 19588)
@@ -0,0 +1,25 @@
+/* Several statements in a row */
+class C {
+	int a;
+	int b;
+	public C() {
+		int a;
+	}
+	int c;
+	void m() {
+		int a;
+		if (true) {
+			int a;
+			int b;
+		}
+		int b;
+		if (true) {
+			int a;
+		}
+	}
+	int d;
+	void n() {
+		int a;
+	}
+	int e;
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testF2.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testF2.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testF2.java	2009-06-29 15:12:46 UTC (rev 19588)
@@ -0,0 +1,25 @@
+/* Several statements in a row */
+class C {
+	int a;
+	int b;
+	public C() {
+		int a;
+	}
+	int c;
+	void m() {
+		int a;
+		if (true) {
+			int a;
+			int b;
+		}
+		int b;
+		if (true) {
+			int a;
+		}
+	}
+	int d;
+	void n() {
+		int a;
+	}
+	int e;
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testF3.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testF3.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testF3.java	2009-06-29 15:12:46 UTC (rev 19588)
@@ -0,0 +1,25 @@
+/* Several statements in a row */
+class C {
+	int a;
+	int b;
+	public C() {
+		int a;
+	}
+	int c;
+	void m() {
+		int a;
+		if (true) {
+			int a;
+			int b;
+		}
+		int b;
+		if (true) {
+			int a;
+		}
+	}
+	int d;
+	void n() {
+		int a;
+	}
+	int e;
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testG1.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testG1.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testG1.java	2009-06-29 15:12:46 UTC (rev 19588)
@@ -0,0 +1,36 @@
+/* Statements with different structure */
+class C {
+	public C() {
+		int a;
+		do {
+			int b;
+			int c;
+		} while (true);
+		int d;
+	}
+	void m() throws Exception {
+		int a;
+		try {
+			int a;
+			int b;
+		} catch (Exception e) {
+			throw new Exception();
+		}
+		int b;
+	}
+	void n() {
+		int a;
+		switch(a) {
+			case 0:
+			int b;
+			break;
+			case 3:
+			int s;
+			break;
+		}
+		int b;
+	}
+	void o() {
+		int a = ((3 + 5) > 4) ? n() : m();
+	}
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testG2.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testG2.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testG2.java	2009-06-29 15:12:46 UTC (rev 19588)
@@ -0,0 +1,36 @@
+/* Statements with different structure */
+class C {
+	public C() {
+		int a;
+		do {
+			int b;
+			int c;
+		} while (true);
+		int d;
+	}
+	void m() throws Exception {
+		int a;
+		try {
+			int a;
+			int b;
+		} catch (Exception e) {
+			throw new Exception();
+		}
+		int b;
+	}
+	void n() {
+		int a;
+		switch(a) {
+			case 0:
+			int b;
+			break;
+			case 3:
+			int s;
+			break;
+		}
+		int b;
+	}
+	void o() {
+		int a = ((3 + 5) > 4) ? n() : m();
+	}
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testG3.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testG3.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testG3.java	2009-06-29 15:12:46 UTC (rev 19588)
@@ -0,0 +1,36 @@
+/* Statements with different structure */
+class C {
+	public C() {
+		int a;
+		do {
+			int b;
+			int c;
+		} while (true);
+		int d;
+	}
+	void m() throws Exception {
+		int a;
+		try {
+			int a;
+			int b;
+		} catch (Exception e) {
+			throw new Exception();
+		}
+		int b;
+	}
+	void n() {
+		int a;
+		switch(a) {
+			case 0:
+			int b;
+			break;
+			case 3:
+			int s;
+			break;
+		}
+		int b;
+	}
+	void o() {
+		int a = ((3 + 5) > 4) ? n() : m();
+	}
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testH1.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testH1.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testH1.java	2009-06-29 15:12:46 UTC (rev 19588)
@@ -0,0 +1,19 @@
+/* Method declarations */
+class C {
+	void m() {
+		int a;
+		int b;
+	}
+	void n(int a) {
+		int b;
+		int c;
+	}
+	void o(int a, int b) {
+		int c;
+		int d;
+	}
+	void p(int a, int b, int c) {
+		int d;
+		int e;
+	}
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testH2.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testH2.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testH2.java	2009-06-29 15:12:46 UTC (rev 19588)
@@ -0,0 +1,19 @@
+/* Method declarations */
+class C {
+	void m() {
+		int a;
+		int b;
+	}
+	void n(int a) {
+		int b;
+		int c;
+	}
+	void o(int a, int b) {
+		int c;
+		int d;
+	}
+	void p(int a, int b, int c) {
+		int d;
+		int e;
+	}
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testH3.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testH3.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testH3.java	2009-06-29 15:12:46 UTC (rev 19588)
@@ -0,0 +1,19 @@
+/* Method declarations */
+class C {
+	void m() {
+		int a;
+		int b;
+	}
+	void n(int a) {
+		int b;
+		int c;
+	}
+	void o(int a, int b) {
+		int c;
+		int d;
+	}
+	void p(int a, int b, int c) {
+		int d;
+		int e;
+	}
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testH4.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testH4.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testH4.java	2009-06-29 15:12:46 UTC (rev 19588)
@@ -0,0 +1,19 @@
+/* Method declarations */
+class C {
+	void m() {
+		int a;
+		int b;
+	}
+	void n(int a) {
+		int b;
+		int c;
+	}
+	void o(int a, int b) {
+		int c;
+		int d;
+	}
+	void p(int a, int b, int c) {
+		int d;
+		int e;
+	}
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testI1.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testI1.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testI1.java	2009-06-29 15:12:46 UTC (rev 19588)
@@ -0,0 +1,13 @@
+/* Method calls */
+class C {
+	void m() {
+		m();
+		m(5);
+		m(6, 7);
+		m(8, 9, 10);
+		m(m(), m().n());
+		m(new C());
+		m().m();
+		m(new D() { void m() { int a; }});
+	}
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testI2.java

(1552 diff lines omitted)


From mdjonge at xs4all.nl  Mon Jun 29 18:26:55 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Mon, 29 Jun 2009 16:26:55 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19589 - MaartjeDeJonge
	- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr
Message-ID: <200906291625.n5TGPSCL006713@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-29 16:26:55 +0000 (Mon, 29 Jun 2009)
New Revision: 19589

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19589&view=rev

Modified:
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/BackTrackRecovery2.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Frame.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Link.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Path.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoverAlgorithm.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoverDisambiguator.java
   spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java

Log:
avoid => recover

Changes:

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/BackTrackRecovery2.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/BackTrackRecovery2.java	2009-06-29 15:12:46 UTC (rev 19588)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/BackTrackRecovery2.java	2009-06-29 16:26:55 UTC (rev 19589)
@@ -279,7 +279,7 @@
 
             if (nl == null) { //no need to handle ambiguity, just skip!?
                 nl = st1.addLink(recNode.parentStack, oldLink.label, oldLink.length);
-                nl.avoidCount = oldLink.avoidCount;
+                nl.recoverCount = oldLink.recoverCount;
             }
         }
     }    

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Frame.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Frame.java	2009-06-29 15:12:46 UTC (rev 19588)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Frame.java	2009-06-29 16:26:55 UTC (rev 19589)
@@ -281,8 +281,8 @@
         int result = 0;
         for (int i = 0; i < stepsCount; i++) {
             if(i==0){
-                result = steps[i].avoidCount;
-            result = Math.min(result, steps[i].avoidCount);
+                result = steps[i].recoverCount;
+            result = Math.min(result, steps[i].recoverCount);
             }            
         }
         return result;
@@ -300,11 +300,11 @@
         for (int i = 0; i < stepsCount; i++) {
             Link ln = steps[i];
             List<String> childColl;
-            if(ln.avoidCount ==0 || (avoidFree==false)) {
-                if(ln.avoidCount ==0)
+            if(ln.recoverCount ==0 || (avoidFree==false)) {
+                if(ln.recoverCount ==0)
                     childColl= ln.parent.getStackPaths(" - "+front, avoidFree); 
                 else {
-                    String frnt = "-$"+ ln.avoidCount +"$-" + front;
+                    String frnt = "-$"+ ln.recoverCount +"$-" + front;
                     childColl=ln.parent.getStackPaths(frnt, avoidFree);
                 }
                 stackStrings.addAll(childColl);

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Link.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Link.java	2009-06-29 15:12:46 UTC (rev 19588)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Link.java	2009-06-29 16:26:55 UTC (rev 19589)
@@ -20,7 +20,7 @@
     
     public int length; //mj: private final (see sglr.reducer: replace link by link with less avoids)
     
-    public int avoidCount;
+    public int recoverCount;
     
 
     public Link(Frame destination, IParseNode t, int length) {
@@ -28,7 +28,7 @@
         label = t;
         rejected = false;
         this.length = length;
-        avoidCount =0;
+        recoverCount =0;
         linksCreated +=1;
     }
 

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Path.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Path.java	2009-06-29 15:12:46 UTC (rev 19588)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/Path.java	2009-06-29 16:26:55 UTC (rev 19589)
@@ -30,25 +30,25 @@
     
     public Link lnk;
     
-    public int getAvoidCount()
+    public int getRecoverCount()
     {
         int result = 0;
         if(lnk!=null)
         {
-            result+=lnk.avoidCount;           
+            result+=lnk.recoverCount;           
         }
         if(parent!=null) //Todo: find out relation linktoparent/parent
         {
-            result += parent.getAvoidCount();
+            result += parent.getRecoverCount();
         }
         return result;        
     }
     
-    public int getAvoidCount(int maxCharLength)
+    public int getRecoverCount(int maxCharLength)
     {
         if(parent==null || this.length<=maxCharLength)
-            return getAvoidCount();
-        return parent.getAvoidCount(maxCharLength);
+            return getRecoverCount();
+        return parent.getRecoverCount(maxCharLength);
     }
 
     //todo managed

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoverAlgorithm.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoverAlgorithm.java	2009-06-29 15:12:46 UTC (rev 19588)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoverAlgorithm.java	2009-06-29 16:26:55 UTC (rev 19589)
@@ -29,33 +29,33 @@
         exceededMax=false;
     }
     
-    public void handleAmbiguity(int avoidCount_t, IParseNode t, Link nl){
-        assert !(nl.avoidCount == 0 && avoidCount_t == 0)
+    public void handleAmbiguity(int recovercount_t, IParseNode t, Link nl){
+        assert !(nl.recoverCount == 0 && recovercount_t == 0)
                 : "ambiguity without recover productions should not be handled by RecoverAlgorithm";
         
         //A. Choose branch without recover productions
-        boolean hasRecoverFreeBranch = trySelectNoRecoveries(avoidCount_t, t, nl);
+        boolean hasRecoverFreeBranch = trySelectNoRecoveries(recovercount_t, t, nl);
         if(hasRecoverFreeBranch)
             return;
         //B. Disambiguate by indentation
-        boolean hasIndentPreference = trySelectByIndentation(avoidCount_t, t, nl);
+        boolean hasIndentPreference = trySelectByIndentation(recovercount_t, t, nl);
         if(hasIndentPreference){
             return;
         }
         //C. choose branche with smallest number of avoids
-        trySelectOnAvoidCount(avoidCount_t, t, nl);
+        trySelectOnRecoverCount(recovercount_t, t, nl);
     }
 
-    private boolean trySelectOnAvoidCount(int avoidCount_t, IParseNode t, Link nl) {
-        if(avoidCount_t == nl.avoidCount)
+    private boolean trySelectOnRecoverCount(int avoidCount_t, IParseNode t, Link nl) {
+        if(avoidCount_t == nl.recoverCount)
             return false;
-        if(avoidCount_t < nl.avoidCount)
+        if(avoidCount_t < nl.recoverCount)
             setLabel(0, t, nl);
         return true;
     }
     
     private boolean trySelectNoRecoveries(int avoidCount_t, IParseNode t, Link nl){     
-        if(nl.avoidCount==0)
+        if(nl.recoverCount==0)
             return true;
         if(avoidCount_t==0){
             setLabel(0, t, nl);
@@ -78,9 +78,9 @@
         return true;
     }
 
-    private void setLabel(int avoidCount_t, IParseNode t, Link nl) {
+    private void setLabel(int recoverCount_t, IParseNode t, Link nl) {
         nl.label=t;
-        nl.avoidCount=avoidCount_t;
+        nl.recoverCount=recoverCount_t;
     }
     
     /*
@@ -137,7 +137,7 @@
         Link nl;
         st1 = myParser.newStack(s);            
         nl = st1.addLink(parentFrame, t, length);
-        nl.avoidCount = numberOfAvoids;
+        nl.recoverCount = numberOfAvoids;
         return st1;
     }
     

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoverDisambiguator.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoverDisambiguator.java	2009-06-29 15:12:46 UTC (rev 19588)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/RecoverDisambiguator.java	2009-06-29 16:26:55 UTC (rev 19589)
@@ -9,7 +9,7 @@
         parseTable=pt;        
     }
     
-    public void handleAmbiguity(int avoidCount_t, IParseNode t, Link nl){  
+    public void handleAmbiguity(int recoverCount_t, IParseNode t, Link nl){  
         testCount++;
         if(nl.isRejected()){
             setLabel(0, t, nl);
@@ -31,20 +31,20 @@
             return;
         }*/
         //C. choose branche with smallest number of avoids
-        trySelectOnAvoidCount(avoidCount_t, t, nl);
+        trySelectOnRecoverCount(recoverCount_t, t, nl);
         
     }
     
-    private boolean trySelectOnAvoidCount(int avoidCount_t, IParseNode t, Link nl) {
-        if(avoidCount_t == nl.avoidCount)
+    private boolean trySelectOnRecoverCount(int recoverCount_t, IParseNode t, Link nl) {
+        if(recoverCount_t == nl.recoverCount)
             return false;
-        if(avoidCount_t < nl.avoidCount)
-            setLabel(avoidCount_t, t, nl);
+        if(recoverCount_t < nl.recoverCount)
+            setLabel(recoverCount_t, t, nl);
         return true;
     }
     
     private boolean trySelectNoRecoveries(int avoidCount_t, IParseNode t, Link nl){     
-        if(nl.avoidCount==0)
+        if(nl.recoverCount==0)
             return true;
         if(avoidCount_t==0){
             setLabel(0, t, nl);
@@ -67,8 +67,8 @@
         return true;
     }
     
-    private void setLabel(int avoidCount_t, IParseNode t, Link nl) {
+    private void setLabel(int recoverCount_t, IParseNode t, Link nl) {
         nl.label=t;
-        nl.avoidCount=avoidCount_t;
+        nl.recoverCount=recoverCount_t;
     }
 }

Modified: spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java
===================================================================
--- spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-06-29 15:12:46 UTC (rev 19588)
+++ spoofax/branches/spoofax-recovery/src/org/spoofax/jsglr/SGLR.java	2009-06-29 16:26:55 UTC (rev 19589)
@@ -325,7 +325,7 @@
             throw new ParseException(this, "Accepting stack has no link");
      
         logParseResult(s);
-        //Tools.debug("avoids: "+s.avoidCount);
+        Tools.debug("avoids: "+s.recoverCount);
         //Tools.debug(s.label.toParseTree(parseTable));
         
         return disambiguator.applyFilters(this, s.label, startSymbol, tokensSeen);
@@ -633,16 +633,16 @@
 
     private void reducer(Frame st0, State s, Production prod, List<IParseNode> kids, Path path) throws IOException {
         int length = path.getLength();        
-        int numberOfAvoids = calcAvoidCount(prod, path); 
-        if(fineGrainemode && calcAvoidCountResricted(prod, path) > maxNrOfRecoveries)
+        int numberOfRecoveries = calcRecoverCount(prod, path); 
+        if(fineGrainemode && calcRecoverCountResricted(prod, path) > maxNrOfRecoveries)
             return;
         IParseNode t = prod.apply(kids);
         Frame st1; 
         Link nl;
-        if(prod.status == ProductionType.AVOID){
+        if(prod.isRecoverProduction()){
             if(!useIntegratedRecovery)
             {                
-                recoverHandler.handleRecoverProduction(st0, s, length, numberOfAvoids, t);
+                recoverHandler.handleRecoverProduction(st0, s, length, numberOfRecoveries, t);
                 if(recoverHandler.haltsOnRecoverProduction(st0))
                     return;
             }
@@ -651,7 +651,7 @@
         increaseReductionCount();        
         st1 = findStack(activeStacks, s);
         if (st1 == null) {
-            addNewStack(st0, s, prod, length, numberOfAvoids, t);            
+            addNewStack(st0, s, prod, length, numberOfRecoveries, t);            
         } else {
             /* A stack with state s exists; check for ambiguities */
             nl = st1.findDirectLink(st0);
@@ -661,11 +661,11 @@
                 if (prod.isRejectProduction()) {
                     nl.reject();
                 }
-                handleAmbiguity(numberOfAvoids, t, nl);
+                handleAmbiguity(numberOfRecoveries, t, nl);
 
             } else {
                 nl = st1.addLink(st0, t, length);
-                nl.avoidCount = numberOfAvoids;
+                nl.recoverCount = numberOfRecoveries;
                 if (prod.isRejectProduction())
                     nl.reject();                
                 logAddedLink(st0, st1, nl);              
@@ -678,9 +678,9 @@
         }
     }
     
-    private void handleAmbiguity(int numberOfAvoids, IParseNode t, Link nl) throws IOException {        
+    private void handleAmbiguity(int numberOfRecoveries, IParseNode t, Link nl) throws IOException {        
         //if both branches contain no recover productions, create an Amb node.
-        if(numberOfAvoids == 0 && nl.avoidCount==0){
+        if(numberOfRecoveries == 0 && nl.recoverCount==0){
             if (!recoveryWorkAround) {
                 createAmbNode(t, nl);
             }
@@ -688,16 +688,16 @@
         }
         // old recovery method
         if(!useIntegratedRecovery){
-            recoverHandler.handleAmbiguity(numberOfAvoids, t, nl);
+            recoverHandler.handleAmbiguity(numberOfRecoveries, t, nl);
             return;
         }
         // integrated recovery method
         if(enforcePrefixAccept)
             return; //not interested in ambiguity!
         else{
-            int nlOld = nl.avoidCount;
-            recoverDisambiguator.handleAmbiguity(numberOfAvoids, t, nl);
-            if(nl.avoidCount < nlOld)
+            int nlOld = nl.recoverCount;
+            recoverDisambiguator.handleAmbiguity(numberOfRecoveries, t, nl);
+            if(nl.recoverCount < nlOld)
                 actorOnActiveStacksOverNewLink(nl);
         }                
     }
@@ -708,13 +708,13 @@
     }
     
     private void addNewStack(Frame st0, State s, Production prod, int length,
-            int numberOfAvoids, IParseNode t) {
+            int numberOfRecoveries, IParseNode t) {
         Frame st1;
         Link nl;
         /* Found no existing stack with for state s; make new stack */
         st1 = newStack(s);            
         nl = st1.addLink(st0, t, length);
-        nl.avoidCount = numberOfAvoids;   
+        nl.recoverCount = numberOfRecoveries;   
         addStack(st1);            
         forActorDelayed.addFirst(st1);
         if(Tools.tracing) {
@@ -767,22 +767,22 @@
         }
     }    
 
-    private int calcAvoidCount(Production prod, Path path) {
-        int numberOfAvoids = path.getAvoidCount();
-        if(prod.status == ProductionType.AVOID)
+    private int calcRecoverCount(Production prod, Path path) {
+        int numberOfRecoveries = path.getRecoverCount();
+        if(prod.isRecoverProduction())
         {
-            numberOfAvoids +=1;
+            numberOfRecoveries+=1;
         }
-        return numberOfAvoids;
+        return numberOfRecoveries;
     }
     
-    private int calcAvoidCountResricted(Production prod, Path path) {
-        int numberOfAvoids = path.getAvoidCount(lengthAvoidCheck);
-        if(prod.status == ProductionType.AVOID)
+    private int calcRecoverCountResricted(Production prod, Path path) {
+        int numberOfRecoveries = path.getRecoverCount(lengthAvoidCheck);
+        if(prod.isRecoverProduction())
         {
-            numberOfAvoids +=1;
+            numberOfRecoveries +=1;
         }
-        return numberOfAvoids;
+        return numberOfRecoveries;
     }
     
     private boolean inReduceStacks(Queue<Frame> q, Frame frame) {
@@ -1011,7 +1011,7 @@
             //Tools.debug("Links: " + Link.linksCreated);
             m.setLinkedCreated(Link.linksCreated);
             //Tools.debug("avoids: " + s.avoidCount);
-            m.setAvoidCount(s.avoidCount);
+            m.setAvoidCount(s.recoverCount);
             //Tools.debug("Total Time: " + parseTime);
             m.setParseTime(parseTime);
             //Tools.debug("Total Count: " + parseCount);



From mdjonge at xs4all.nl  Mon Jun 29 21:20:21 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Mon, 29 Jun 2009 19:20:21 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19590 - MaartjeDeJonge
	- in sglr-recovery/trunk/Evaluation_Recovery: . Compare/Java
	Correct_Files Correct_Files/development_files
	Correct_Files/generated_java Correct_Files/input_files
	Correct_Files/jdt_ast Correct_Files/jdt_tree
	Correct_Files/sglr_ast Correct_Files/sglr_parsetree
	Error_Files Error_Files/development_files
	Error_Files/input_files Error_Files/jdt_ast
	Error_Files/jdt_java Error_Files/jdt_tree
	Error_Files/sglr_ast Error_Files/sglr_java
	Error_Files/sglr_parsetree Language_Files src
Message-ID: <200906291918.n5TJIsZL008755@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-29 19:20:21 +0000 (Mon, 29 Jun 2009)
New Revision: 19590

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19590&view=rev

Added:
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/correctFile.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/currentLineError.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/doubleClosed_If.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/flawedDeclaration.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/flawedImport.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/flawedMethodHeader.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/flawed_IfBlock.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/methodOutsideClass.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/morePartsStructureError.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/multipleErrors.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/previousLineError.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/priorSiblingError.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/sloppyCode.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/testFile.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/twoSeparatedErrors.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/unclosedClassBody.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/unclosedMethod.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/unclosed_If.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testFile2.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/correctFile.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/currentLineError.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/doubleClosed_If.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/flawedDeclaration.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/flawedImport.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/flawedMethodHeader.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/flawed_IfBlock.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/methodOutsideClass.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/morePartsStructureError.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/multipleErrors.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/previousLineError.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/priorSiblingError.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/sloppyCode.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/testFile.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/twoSeparatedErrors.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/unclosedClassBody.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/unclosedMethod.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/unclosed_If.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testFile2.java
   sglr-recovery/trunk/Evaluation_Recovery/Language_Files/InsertDelete.tbl
   sglr-recovery/trunk/Evaluation_Recovery/Language_Files/InsertNoOpen.tbl
   sglr-recovery/trunk/Evaluation_Recovery/Language_Files/InsertNoOpenDelete.tbl
   sglr-recovery/trunk/Evaluation_Recovery/Language_Files/InsertOnly.tbl
   sglr-recovery/trunk/Evaluation_Recovery/clean.sh
Modified:
   sglr-recovery/trunk/Evaluation_Recovery/Compare/Java/
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/generated_java/
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/jdt_ast/
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/jdt_tree/
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/sglr_ast/
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/sglr_parsetree/
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/jdt_ast/
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/jdt_java/
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/jdt_tree/
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/sglr_ast/
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/sglr_java/
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/sglr_parsetree/
   sglr-recovery/trunk/Evaluation_Recovery/Run.sh
   sglr-recovery/trunk/Evaluation_Recovery/src/ProcessFiles.java

Log:
- clean script
- remove empty diffs
- development files

Changes (first 1000 lines of the diffs):


Property changes on: sglr-recovery/trunk/Evaluation_Recovery/Compare/Java
___________________________________________________________________
Modified: svn:ignore
   - *.diff

   + *.diff
*.diff.txt


Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/correctFile.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/correctFile.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/correctFile.java	2009-06-29 19:20:21 UTC (rev 19590)
@@ -0,0 +1,22 @@
+package test;
+
+import java.io.IOException;
+import junit.framework.Assert;
+import org.spoofax.jsglr.SGLRException;
+class X {
+	
+  private int correctMethod1(){
+     corr2();    
+     return corrInt;
+  }
+
+  private int correctMethod2(){
+      int corrLine1;
+      if(true){
+    	  corrLine2();
+      }
+      corrLine3();     
+      corrLine4();
+  }
+}
+

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/currentLineError.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/currentLineError.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/currentLineError.java	2009-06-29 19:20:21 UTC (rev 19590)
@@ -0,0 +1,29 @@
+package test;
+
+import java.io.IOException;
+import junit.framework.Assert;
+import org.spoofax.jsglr.SGLRException;
+class X {
+	
+  private int correctMethod1(){
+     corr2();    
+     return corrInt;
+  }
+
+  private int ErrorFragment(){
+      int corrLine1;
+      int i;
+      corrLine2();      
+      corrLine3();
+  }      
+  
+  private int correctMethod2(){
+      corr2();
+      corr2();
+      int corrInt=1;
+      return corrInt;
+  }
+  
+
+}
+

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/doubleClosed_If.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/doubleClosed_If.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/doubleClosed_If.java	2009-06-29 19:20:21 UTC (rev 19590)
@@ -0,0 +1,30 @@
+package org.spoofax.jsglr;
+
+import java.io.IOException;
+import java.util.ArrayList;
+
+class X {
+	
+  private int correctMethod1(){
+     bla();
+     bla();
+     int i=1;
+     return 2;
+  }
+	
+  private int wronglyClosedMethod(){
+      if(true){
+         i=5;
+      }
+      bla();      
+  }     
+  
+  private int correctMethod2(){
+      bla();
+      bla();
+      int i=1;
+      return 2;
+  }
+
+
+}
\ No newline at end of file

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/flawedDeclaration.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/flawedDeclaration.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/flawedDeclaration.java	2009-06-29 19:20:21 UTC (rev 19590)
@@ -0,0 +1,19 @@
+package org.spoofax.jsglr;
+
+import java.io.IOException;
+import java.util.ArrayList;
+
+class X {
+	
+  private int anInt; 
+  private int errorDeclaration;
+  private String aString;  
+	
+  private int correctMethod(){
+     bla();
+     bla();
+     int i=1;
+     return 2;
+  }	
+  
+}
\ No newline at end of file

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/flawedImport.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/flawedImport.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/flawedImport.java	2009-06-29 19:20:21 UTC (rev 19590)
@@ -0,0 +1,16 @@
+package org.spoofax.jsglr;
+
+import java.io.IOException;
+import java.ErrorImport;
+import java.io;
+
+class X {
+  
+  private int correctMethod1(){
+      bla();
+      bla();
+      int i=1;
+      return 2;
+  }
+
+}
\ No newline at end of file

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/flawedMethodHeader.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/flawedMethodHeader.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/flawedMethodHeader.java	2009-06-29 19:20:21 UTC (rev 19590)
@@ -0,0 +1,28 @@
+package org.spoofax.jsglr;
+
+import java.io.IOException;
+import java.util.ArrayList;
+
+class X {
+	
+  private int Fragment();
+  {
+	 int i=1;
+     int i;
+  }
+	
+  private int correctMethod1(){
+     bla();
+     bla();
+     int i=1;
+     return 2;
+  }
+    
+  private int correctMethod2(){
+      bla();
+      bla();
+      int i=1;
+      return 2;
+  }
+
+}
\ No newline at end of file

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/flawed_IfBlock.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/flawed_IfBlock.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/flawed_IfBlock.java	2009-06-29 19:20:21 UTC (rev 19590)
@@ -0,0 +1,27 @@
+class X {
+	
+  private int correctMethod1(){
+     corr2();    
+     return corrInt;
+  }
+
+  private int ErrorFragment(){
+      int corrLine1;
+      corrLine2();
+      int i;
+      if(bla()){
+    	  i=0; 
+	  }   	          
+      corrLine3();
+  }      
+  
+  private int correctMethod2(){
+      corr2();
+      corr2();
+      int corrInt=1;
+      return corrInt;
+  }
+  
+
+}
+

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/methodOutsideClass.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/methodOutsideClass.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/methodOutsideClass.java	2009-06-29 19:20:21 UTC (rev 19590)
@@ -0,0 +1,19 @@
+class X {
+	
+  private int correctMethod1(){
+     corr2();
+     corr2();
+     if(true)
+        return 5;
+     int corrInt=1;
+     return corrInt;
+  }
+  
+  private int bla(){
+	  bla();
+  }
+}
+  
+  
+
+  
\ No newline at end of file

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/morePartsStructureError.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/morePartsStructureError.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/morePartsStructureError.java	2009-06-29 19:20:21 UTC (rev 19590)
@@ -0,0 +1,30 @@
+class X {
+	
+  private int correctMethod1(){
+     corr2();    
+     return corrInt;
+  }
+
+  private int errorFragment(){
+      int corrLine1;
+      corrLine2();
+      if(bla()){
+          int i;
+          return 2; }
+      else if (true)
+          return 4;
+      else
+          return 5;
+      corrLine3();
+  }     
+  
+  private int correctMethod2(){
+      corr2();
+      corr2();
+      int corrInt=1;
+      return corrInt;
+  }
+  
+
+}
+

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/multipleErrors.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/multipleErrors.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/multipleErrors.java	2009-06-29 19:20:21 UTC (rev 19590)
@@ -0,0 +1,28 @@
+class X {
+	
+  private int correctMethod1(){
+     corr2();
+     corr2();
+     if(true)
+        return 5;
+     int corrInt=1;
+     return corrInt;
+  }
+  
+  private int correctMethod2(){
+      corr2();
+      corr2();
+      int corrInt=1;
+      return corrInt;  }
+
+
+  
+  private int correctMethod3(){
+      corr2();
+      corr2();
+      int corrInt=1;
+      return corrInt;
+  }  
+
+}
+

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/previousLineError.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/previousLineError.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/previousLineError.java	2009-06-29 19:20:21 UTC (rev 19590)
@@ -0,0 +1,24 @@
+class X {
+	
+  private int correctMethod1(){
+     corr2();    
+     return corrInt;
+  }
+
+  private int ErrorFragment(){
+      int corrLine1;
+      corrLine2();
+      int i = bla();
+      corrLine3();
+  }      
+  
+  private int correctMethod2(){
+      corr2();
+      corr2();
+      int corrInt=1;
+      return corrInt;
+  }
+  
+
+}
+

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/priorSiblingError.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/priorSiblingError.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/priorSiblingError.java	2009-06-29 19:20:21 UTC (rev 19590)
@@ -0,0 +1,29 @@
+class X {
+	
+  private int correctMethod1(){
+     corr2();    
+     return corrInt;
+  }
+
+  private int errorFragment(){
+      int i;
+      if(true){
+          bla();
+          doSomething();
+      }
+      int j;
+      int k;
+      doSomething2();
+      return 5;
+  }  
+  
+  private int correctMethod2(){
+      corr2();
+      corr2();
+      int corrInt=1;
+      return corrInt;
+  }
+  
+
+}
+

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/sloppyCode.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/sloppyCode.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/sloppyCode.java	2009-06-29 19:20:21 UTC (rev 19590)
@@ -0,0 +1,72 @@
+class X {
+	
+  private int correctMethod1(){
+     corr2();
+     corr2();
+     if(true)
+        return 5;
+     int corrInt=1;
+     return corrInt;
+  }
+  
+  private int correctMethod1(){
+	     corr2();
+	     corr2();
+	     if(true)
+	        return 5;
+	     int corrInt=1;
+	     return corrInt;
+	  }
+  
+  private int correctMethod1(){
+	     corr2();
+	     corr2();
+	     if(true)
+	        return 5;
+	     int corrInt=1;
+	     return corrInt;
+   }
+
+  private int ErrorTooMuchClosing(){
+      if(bla1()){
+         while(true){
+             bla2();
+         }
+         stm();
+      }
+      int i;
+      int j;
+      bla3();
+  }
+
+  int j;
+
+  private int ErrorMissingClosing(){
+     if(bla1()){
+       bla();
+       while(true){
+           bla2();
+           stm(); }
+     }
+     int i;
+     int j;
+     bla3();
+  }
+      
+  private int correctMethod2(){
+      corr2();
+      corr2();
+      int corrInt=1;
+      return corrInt;
+  }
+  
+  private int correctMethod3(){
+      corr2();
+      corr2();
+      int corrInt=1;
+      return corrInt;
+  }
+  
+
+}
+

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/testFile.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/testFile.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/testFile.java	2009-06-29 19:20:21 UTC (rev 19590)
@@ -0,0 +1,30 @@
+package org.spoofax.jsglr;
+
+import java.io.IOException;
+import java.util.ArrayList;
+
+class X {
+	
+  private int correctMethod1(){
+     bla();
+     bla();
+     int i=1;
+     return 2;
+  }
+	
+  private int wronglyClosedMethod(){
+      if(true){
+         i=5;
+      }
+      bla();      
+  }     
+  
+  private int correctMethod2(){
+      bla();
+      bla();
+      int i=1;
+      return 2;
+  }
+
+
+}
\ No newline at end of file

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/twoSeparatedErrors.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/twoSeparatedErrors.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/twoSeparatedErrors.java	2009-06-29 19:20:21 UTC (rev 19590)
@@ -0,0 +1,62 @@
+class X {
+	
+  private int correctMethod1(){
+     corr2();
+     corr2();
+     if(true)
+        return 5;
+     int corrInt=1;
+     return corrInt;
+  }
+
+  private int ErrorTooMuchClosing(){
+      if(bla1()){
+         while(true){
+             bla2();
+         }
+         stm();
+      }
+      int i;
+      int j;
+      bla3();
+  }
+
+  private int correctMethod2(){
+    corr2();
+    corr2();
+    if(true)
+       return 5;
+    int corrInt=1;
+    return corrInt;
+  }
+
+  private int ErrorMissingClosing(){
+     if(bla1()){
+       bla();
+       while(true){
+           bla2();
+           stm(); 
+       }
+     }
+     int i;
+     int j;
+     bla3();
+  }
+      
+  private int correctMethod3(){
+      corr2();
+      corr2();
+      int corrInt=1;
+      return corrInt;
+  }
+  
+  private int correctMethod4(){
+      corr2();
+      corr2();
+      int corrInt=1;
+      return corrInt;
+  }
+  
+
+}
+

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/unclosedClassBody.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/unclosedClassBody.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/unclosedClassBody.java	2009-06-29 19:20:21 UTC (rev 19590)
@@ -0,0 +1,25 @@
+class X {
+	
+	  private int correctMethod1(){
+	     corr2();
+	     corr2();
+	     if(true)
+	        return 5;
+	     int corrInt=1;
+	     return corrInt;
+	  }
+	  	  
+	  private int bla(){
+		  bla();
+	  }
+}
+	  
+	  
+	  
+        
+	  
+	  
+	  
+	     
+
+  
\ No newline at end of file

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/unclosedMethod.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/unclosedMethod.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/unclosedMethod.java	2009-06-29 19:20:21 UTC (rev 19590)
@@ -0,0 +1,22 @@
+class X {
+	
+  private int correctMethod1(){
+     corr2();    
+     return corrInt;
+  }
+
+  private int UnclosedMethod(){
+      int corrLine1;
+      corrLine2();
+  }     
+  
+  private int correctMethod2(){
+      corr2();
+      corr2();
+      int corrInt=1;
+      return corrInt;
+  }
+  
+
+}
+

Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/unclosed_If.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/unclosed_If.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/unclosed_If.java	2009-06-29 19:20:21 UTC (rev 19590)
@@ -0,0 +1,29 @@
+package org.spoofax.jsglr;
+
+import java.io.IOException;
+import java.util.ArrayList;
+
+class X {
+	
+  private int correctMethod1(){
+     bla();
+     bla();
+     int i=1;
+     return 2;
+  }
+	
+  private int UnclosedIf(){
+    if(true){
+      i=5;
+    }
+    return 7;
+  } 
+	  
+  private int correctMethod2(){
+      bla();
+      bla();
+      int i=1;
+      return 2;
+  }
+
+}
\ No newline at end of file


Property changes on: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/generated_java
___________________________________________________________________
Added: svn:ignore
   + *.java


Added: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testFile2.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testFile2.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testFile2.java	2009-06-29 19:20:21 UTC (rev 19590)
@@ -0,0 +1,35 @@
+package org.spoofax.jsglr;
+
+import java.io.IOException;
+import java.util.ArrayList;
+
+class X  
+{ 
+  
+  private int method2()
+  { 
+    bla();
+    bla();
+    int i = 1;
+    return 2;
+  }
+
+  private int method3()
+  { 
+    bla();
+    if(true)
+    { 
+      bla();
+      int i = 1;
+    }
+    return 2;
+  }
+
+  private int method4()
+  { 
+    bla();
+    bla();
+    int i = 1;
+    return 2;
+  }
+}


Property changes on: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/jdt_ast
___________________________________________________________________
Added: svn:ignore
   + *.*



Property changes on: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/jdt_tree
___________________________________________________________________
Added: svn:ignore
   + *.*



Property changes on: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/sglr_ast
___________________________________________________________________
Added: svn:ignore
   + *.*



Property changes on: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/sglr_parsetree
___________________________________________________________________
Added: svn:ignore
   + *.*


Added: sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/correctFile.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/correctFile.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/correctFile.java	2009-06-29 19:20:21 UTC (rev 19590)
@@ -0,0 +1,25 @@
+package test;
+
+import java.io.IOException;
+import junit.framework.Assert;
+import org.spoofax.jsglr.SGLRException;
+
+class X  
+{ 
+  private int correctMethod1()
+  { 
+    corr2();
+    return corrInt;
+  }
+
+  private int correctMethod2()
+  { 
+    int corrLine1;
+    if(true)
+    { 
+      corrLine2();
+    }
+    corrLine3();
+    corrLine4();
+  }
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/currentLineError.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/currentLineError.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/currentLineError.java	2009-06-29 19:20:21 UTC (rev 19590)
@@ -0,0 +1,30 @@
+package test;
+
+import java.io.IOException;
+import junit.framework.Assert;
+import org.spoofax.jsglr.SGLRException;
+
+class X  
+{ 
+  private int correctMethod1()
+  { 
+    corr2();
+    return corrInt;
+  }
+
+  private int ErrorFragment()
+  { 
+    int corrLine1;
+    int i); 
+    corrLine2();
+    corrLine3();
+  }
+
+  private int correctMethod2()
+  { 
+    corr2();
+    corr2();
+    int corrInt = 1;
+    return corrInt;
+  }
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/doubleClosed_If.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/doubleClosed_If.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/doubleClosed_If.java	2009-06-29 19:20:21 UTC (rev 19590)
@@ -0,0 +1,31 @@
+package org.spoofax.jsglr;
+
+import java.io.IOException;
+import java.util.ArrayList;
+
+class X  
+{ 
+  private int correctMethod1()
+  { 
+    bla();
+    bla();
+    int i = 1;
+    return 2;
+  }
+
+  private int wronglyClosedMethod()
+  { 
+    if(true)/*{*/ 
+      i = 5;
+    }
+    bla();
+  }
+
+  private int correctMethod2()
+  { 
+    bla();
+    bla();
+    int i = 1;
+    return 2;
+  }
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/flawedDeclaration.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/flawedDeclaration.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/flawedDeclaration.java	2009-06-29 19:20:21 UTC (rev 19590)
@@ -0,0 +1,21 @@
+package org.spoofax.jsglr;
+
+import java.io.IOException;
+import java.util.ArrayList;
+
+class X  
+{ 
+  private int anInt;
+
+  private int errorDeclaration /*;*/
+
+  private String aString;
+
+  private int correctMethod()
+  { 
+    bla();
+    bla();
+    int i = 1;
+    return 2;
+  }
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/flawedImport.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/flawedImport.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/flawedImport.java	2009-06-29 19:20:21 UTC (rev 19590)
@@ -0,0 +1,16 @@
+package org.spoofax.jsglr;
+
+import java.io.IOException;
+import java.ErrorImport/*;*/
+import java.io;
+
+class X  
+{ 
+  private int correctMethod1()
+  { 
+    bla();
+    bla();
+    int i = 1;
+    return 2;
+  }
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/flawedMethodHeader.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/flawedMethodHeader.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/flawedMethodHeader.java	2009-06-29 19:20:21 UTC (rev 19590)
@@ -0,0 +1,29 @@
+package org.spoofax.jsglr;
+
+import java.io.IOException;
+import java.util.ArrayList;
+
+class X  
+{ 
+  private int Fragment();
+  { 
+    int i = 1;
+    int i;
+  }
+
+  private int correctMethod1()
+  { 
+    bla();
+    bla();
+    int i = 1;
+    return 2;
+  }
+
+  private int correctMethod2()
+  { 
+    bla();
+    bla();
+    int i = 1;
+    return 2;
+  }
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/flawed_IfBlock.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/flawed_IfBlock.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/flawed_IfBlock.java	2009-06-29 19:20:21 UTC (rev 19590)
@@ -0,0 +1,26 @@
+class X  
+{ 
+  private int correctMethod1()
+  { 
+    corr2();
+    return corrInt;
+  }
+
+  private int ErrorFragment()
+  { 
+    int corrLine1;
+    corrLine2();
+    int i;
+    if(bla())){
+        i = 0;
+    corrLine3();
+  }
+
+  private int correctMethod2()
+  { 
+    corr2();
+    corr2();
+    int corrInt = 1;
+    return corrInt;
+  }
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/methodOutsideClass.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/methodOutsideClass.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/methodOutsideClass.java	2009-06-29 19:20:21 UTC (rev 19590)
@@ -0,0 +1,22 @@
+class X  
+{ 
+  private int correctMethod1()
+  { 
+    corr2();
+    corr2();
+    if(true)
+      return 5;
+    int corrInt = 1;
+    return corrInt;
+  }
+
+  private int bla()
+  { 
+    bla();
+  }
+}
+
+private int bla()
+{ 
+  bla();
+}

Added: sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/morePartsStructureError.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/morePartsStructureError.java	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/morePartsStructureError.java	2009-06-29 19:20:21 UTC (rev 19590)
@@ -0,0 +1,32 @@
+class X  
+{ 
+  private int correctMethod1()
+  { 

(644 diff lines omitted)


From mdjonge at xs4all.nl  Mon Jun 29 21:25:26 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Mon, 29 Jun 2009 19:25:26 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19591 - MaartjeDeJonge
	- sglr-recovery/trunk/Evaluation_Recovery/src
Message-ID: <200906291923.n5TJNxMC008797@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-29 19:25:26 +0000 (Mon, 29 Jun 2009)
New Revision: 19591

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19591&view=rev

Modified:
   sglr-recovery/trunk/Evaluation_Recovery/src/ProcessFiles.java

Log:
bp

Changes:

Modified: sglr-recovery/trunk/Evaluation_Recovery/src/ProcessFiles.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/src/ProcessFiles.java	2009-06-29 19:20:21 UTC (rev 19590)
+++ sglr-recovery/trunk/Evaluation_Recovery/src/ProcessFiles.java	2009-06-29 19:25:26 UTC (rev 19591)
@@ -40,7 +40,7 @@
 	private StandAloneSGLRI tokenParser;
 	private IRecoveryParser recoveryParser;
 	private InputStream fis;
-	private boolean useBridgeParser=false;	
+	private boolean useBridgeParser=true;	
 	
 
 	private void createJDT_Tree(String fileName, String inputDir, String outputDir) throws IOException, InterpreterException {	



From mdjonge at xs4all.nl  Mon Jun 29 21:33:32 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Mon, 29 Jun 2009 19:33:32 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19592 - MaartjeDeJonge
	- sglr-recovery/trunk/Evaluation_Recovery
Message-ID: <200906291932.n5TJW5EH008850@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-29 19:33:32 +0000 (Mon, 29 Jun 2009)
New Revision: 19592

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19592&view=rev

Modified:
   sglr-recovery/trunk/Evaluation_Recovery/Run.sh

Log:
.diff.txt

Changes:

Modified: sglr-recovery/trunk/Evaluation_Recovery/Run.sh
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Run.sh	2009-06-29 19:25:26 UTC (rev 19591)
+++ sglr-recovery/trunk/Evaluation_Recovery/Run.sh	2009-06-29 19:33:32 UTC (rev 19592)
@@ -102,7 +102,7 @@
 		echo $correctTreeName	
 	
 		#compare readable ast's
-		diff $brancheLoc/$correctTree $compareLoc/$correctTree > $diffDir/$correctTreeName.$addition.diff
+		diff $brancheLoc/$correctTree $compareLoc/$correctTree > $diffDir/$correctTreeName.$addition.diff.txt
 	done
 }
 



From mdjonge at xs4all.nl  Tue Jun 30 13:33:37 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Tue, 30 Jun 2009 11:33:37 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19596 - MaartjeDeJonge
	- in sglr-recovery/trunk/Evaluation_Recovery: . Compare/Ast
	Correct_Files/check_ast Correct_Files/development_files
	Error_Files/development_files Language_Files src
Message-ID: <200906301132.n5UBW9Uw021326@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-30 11:33:37 +0000 (Tue, 30 Jun 2009)
New Revision: 19596

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19596&view=rev

Modified:
   sglr-recovery/trunk/Evaluation_Recovery/Compare/Ast/
   sglr-recovery/trunk/Evaluation_Recovery/CompileTransformation.sh
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/check_ast/
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/flawedMethodHeader.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/flawedMethodHeader.java
   sglr-recovery/trunk/Evaluation_Recovery/Language_Files/JdtToJava15
   sglr-recovery/trunk/Evaluation_Recovery/Language_Files/JdtToJava15.c
   sglr-recovery/trunk/Evaluation_Recovery/Language_Files/JdtToJava15.str
   sglr-recovery/trunk/Evaluation_Recovery/Language_Files/JdtTransformRules.str
   sglr-recovery/trunk/Evaluation_Recovery/Language_Files/jdt.str
   sglr-recovery/trunk/Evaluation_Recovery/src/ProcessFiles.java

Log:


Changes (first 1000 lines of the diffs):


Property changes on: sglr-recovery/trunk/Evaluation_Recovery/Compare/Ast
___________________________________________________________________
Modified: svn:ignore
   - *.diff

   + *.diff
*


Modified: sglr-recovery/trunk/Evaluation_Recovery/CompileTransformation.sh
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/CompileTransformation.sh	2009-06-30 10:55:26 UTC (rev 19595)
+++ sglr-recovery/trunk/Evaluation_Recovery/CompileTransformation.sh	2009-06-30 11:33:37 UTC (rev 19596)
@@ -4,8 +4,64 @@
 strc -i Language_Files/JdtToJava15.str -la stratego-lib
 
 
+rm Correct_Files/jdt_ast/*.*
+rm Correct_Files/check_ast/*.*
+
+
+
+
+
 loc="Correct_Files"
 
+
+fileLocations="Correct_Files"
+
+#transform jdt-trees to sglr trees
+ext=.jdt
+outputLocation="jdt_ast"
+inputLocation="jdt_tree"
+transformFile=Language_Files/JdtToJava15
+
+for loc in $fileLocations
+do
+	jdtTreeDir=$loc/$inputLocation
+	astDir=$loc/$outputLocation
+	jdtFiles="$jdtTreeDir/*$ext"
+	for jdtTree in $jdtFiles
+	do	
+		jdtTree=${jdtTree#*\/}
+		jdtTree=${jdtTree#*\/}
+		jdtTreeName=${jdtTree%.*}
+		echo $jdtTree
+		
+		# print abstract syntax
+		pp-aterm -i $jdtTreeDir/$jdtTree -o $jdtTreeDir/$jdtTree.readable
+		
+		#transform jdt -> java-15 ast
+		$transformFile -i $jdtTreeDir/$jdtTree -o $astDir/$jdtTreeName.ast
+		pp-aterm -i $astDir/$jdtTreeName.ast -o $astDir/$jdtTreeName.ast.readable
+		
+		#compare readable ast's
+		#diff $astDir/$jdtTreeName.jdt.readable.ast java15_output/$jdtTreeName.java15.readable.ast > compare_ast/$jdtTreeName.diff
+	done
+done
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
 #check transformed ast with original
 ext=.readable
 jdtLocation="jdt_ast"
@@ -24,7 +80,12 @@
 	echo $jdtTreeName	
 	
 	#compare readable ast's
-	diff $jdtAstDir/$jdtTree $sglrAstDir/$jdtTreeName.ast.readable > $diffDir/$jdtTreeName.diff
+	diff $jdtAstDir/$jdtTree $sglrAstDir/$jdtTreeName.ast.readable > $diffDir/$jdtTreeName.diff.txt
 done
 
+#remove empty diff files 
+for i in $diffDir/*.* 
+do [ ! -s $i ] && rm -f $i 
+done
 
+


Property changes on: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/check_ast
___________________________________________________________________
Added: svn:ignore
   + *.diff.txt


Modified: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/flawedMethodHeader.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/flawedMethodHeader.java	2009-06-30 10:55:26 UTC (rev 19595)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/development_files/flawedMethodHeader.java	2009-06-30 11:33:37 UTC (rev 19596)
@@ -5,7 +5,7 @@
 
 class X {
 	
-  private int Fragment();
+  private int Fragment()
   {
 	 int i=1;
      int i;

Modified: sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/flawedMethodHeader.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/flawedMethodHeader.java	2009-06-30 10:55:26 UTC (rev 19595)
+++ sglr-recovery/trunk/Evaluation_Recovery/Error_Files/development_files/flawedMethodHeader.java	2009-06-30 11:33:37 UTC (rev 19596)
@@ -5,7 +5,7 @@
 
 class X  
 { 
-  private int Fragment();
+  private int Fragment())
   { 
     int i = 1;
     int i;

Modified: sglr-recovery/trunk/Evaluation_Recovery/Language_Files/JdtToJava15
===================================================================
(Binary files differ)

Modified: sglr-recovery/trunk/Evaluation_Recovery/Language_Files/JdtToJava15.c
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Language_Files/JdtToJava15.c	2009-06-30 10:55:26 UTC (rev 19595)
+++ sglr-recovery/trunk/Evaluation_Recovery/Language_Files/JdtToJava15.c	2009-06-30 11:33:37 UTC (rev 19596)
@@ -25,7 +25,9 @@
 static Symbol sym_PackageOrTypeName_2;
 static Symbol sym_ClassOrInterfaceType_2;
 static Symbol sym_Lit_1;
+static Symbol sym_NewInstance_4;
 static Symbol sym_Invoke_2;
+static Symbol sym_PostIncr_1;
 static Symbol sym_Not_1;
 static Symbol sym_Lt_2;
 static Symbol sym_Gt_2;
@@ -33,6 +35,8 @@
 static Symbol sym_GtEq_2;
 static Symbol sym_Eq_2;
 static Symbol sym_NotEq_2;
+static Symbol sym_LazyAnd_2;
+static Symbol sym_LazyOr_2;
 static Symbol sym_Assign_2;
 static Symbol sym_FieldDec_3;
 static Symbol sym_VarDec_1;
@@ -42,6 +46,7 @@
 static Symbol sym_If_2;
 static Symbol sym_If_3;
 static Symbol sym_While_2;
+static Symbol sym_For_4;
 static Symbol sym_Return_1;
 static Symbol sym_ExprStm_1;
 static Symbol sym_Block_1;
@@ -49,6 +54,10 @@
 static Symbol sym_MethodDecHead_6;
 static Symbol sym_Void_0;
 static Symbol sym_Param_3;
+static Symbol sym_ThrowsDec_1;
+static Symbol sym_ConstrDec_2;
+static Symbol sym_ConstrDecHead_5;
+static Symbol sym_ConstrBody_2;
 static Symbol sym_EnumDecHead_3;
 static Symbol sym_EnumBody_2;
 static Symbol sym_EnumConst_3;
@@ -62,6 +71,12 @@
 static Symbol sym_Cons_2;
 static Symbol sym_None_0;
 static Symbol sym_Some_1;
+static Symbol sym_ClassType_1;
+static Symbol sym_ClassInstanceCreation_4;
+static Symbol sym_PostfixExpressionOperator_1;
+static Symbol sym_PostfixExpression_2;
+static Symbol sym_ForStatement_4;
+static Symbol sym_VariableDeclarationExpression_3;
 static Symbol sym_Initializer_1;
 static Symbol sym_WhileStatement_2;
 static Symbol sym_FieldDeclaration_4;
@@ -136,8 +151,12 @@
 ATprotectSymbol(sym_ClassOrInterfaceType_2);
 sym_Lit_1 = ATmakeSymbol("Lit", 1, ATfalse);
 ATprotectSymbol(sym_Lit_1);
+sym_NewInstance_4 = ATmakeSymbol("NewInstance", 4, ATfalse);
+ATprotectSymbol(sym_NewInstance_4);
 sym_Invoke_2 = ATmakeSymbol("Invoke", 2, ATfalse);
 ATprotectSymbol(sym_Invoke_2);
+sym_PostIncr_1 = ATmakeSymbol("PostIncr", 1, ATfalse);
+ATprotectSymbol(sym_PostIncr_1);
 sym_Not_1 = ATmakeSymbol("Not", 1, ATfalse);
 ATprotectSymbol(sym_Not_1);
 sym_Lt_2 = ATmakeSymbol("Lt", 2, ATfalse);
@@ -152,6 +171,10 @@
 ATprotectSymbol(sym_Eq_2);
 sym_NotEq_2 = ATmakeSymbol("NotEq", 2, ATfalse);
 ATprotectSymbol(sym_NotEq_2);
+sym_LazyAnd_2 = ATmakeSymbol("LazyAnd", 2, ATfalse);
+ATprotectSymbol(sym_LazyAnd_2);
+sym_LazyOr_2 = ATmakeSymbol("LazyOr", 2, ATfalse);
+ATprotectSymbol(sym_LazyOr_2);
 sym_Assign_2 = ATmakeSymbol("Assign", 2, ATfalse);
 ATprotectSymbol(sym_Assign_2);
 sym_FieldDec_3 = ATmakeSymbol("FieldDec", 3, ATfalse);
@@ -170,6 +193,8 @@
 ATprotectSymbol(sym_If_3);
 sym_While_2 = ATmakeSymbol("While", 2, ATfalse);
 ATprotectSymbol(sym_While_2);
+sym_For_4 = ATmakeSymbol("For", 4, ATfalse);
+ATprotectSymbol(sym_For_4);
 sym_Return_1 = ATmakeSymbol("Return", 1, ATfalse);
 ATprotectSymbol(sym_Return_1);
 sym_ExprStm_1 = ATmakeSymbol("ExprStm", 1, ATfalse);
@@ -184,6 +209,14 @@
 ATprotectSymbol(sym_Void_0);
 sym_Param_3 = ATmakeSymbol("Param", 3, ATfalse);
 ATprotectSymbol(sym_Param_3);
+sym_ThrowsDec_1 = ATmakeSymbol("ThrowsDec", 1, ATfalse);
+ATprotectSymbol(sym_ThrowsDec_1);
+sym_ConstrDec_2 = ATmakeSymbol("ConstrDec", 2, ATfalse);
+ATprotectSymbol(sym_ConstrDec_2);
+sym_ConstrDecHead_5 = ATmakeSymbol("ConstrDecHead", 5, ATfalse);
+ATprotectSymbol(sym_ConstrDecHead_5);
+sym_ConstrBody_2 = ATmakeSymbol("ConstrBody", 2, ATfalse);
+ATprotectSymbol(sym_ConstrBody_2);
 sym_EnumDecHead_3 = ATmakeSymbol("EnumDecHead", 3, ATfalse);
 ATprotectSymbol(sym_EnumDecHead_3);
 sym_EnumBody_2 = ATmakeSymbol("EnumBody", 2, ATfalse);
@@ -210,6 +243,18 @@
 ATprotectSymbol(sym_None_0);
 sym_Some_1 = ATmakeSymbol("Some", 1, ATfalse);
 ATprotectSymbol(sym_Some_1);
+sym_ClassType_1 = ATmakeSymbol("ClassType", 1, ATfalse);
+ATprotectSymbol(sym_ClassType_1);
+sym_ClassInstanceCreation_4 = ATmakeSymbol("ClassInstanceCreation", 4, ATfalse);
+ATprotectSymbol(sym_ClassInstanceCreation_4);
+sym_PostfixExpressionOperator_1 = ATmakeSymbol("PostfixExpressionOperator", 1, ATfalse);
+ATprotectSymbol(sym_PostfixExpressionOperator_1);
+sym_PostfixExpression_2 = ATmakeSymbol("PostfixExpression", 2, ATfalse);
+ATprotectSymbol(sym_PostfixExpression_2);
+sym_ForStatement_4 = ATmakeSymbol("ForStatement", 4, ATfalse);
+ATprotectSymbol(sym_ForStatement_4);
+sym_VariableDeclarationExpression_3 = ATmakeSymbol("VariableDeclarationExpression", 3, ATfalse);
+ATprotectSymbol(sym_VariableDeclarationExpression_3);
 sym_Initializer_1 = ATmakeSymbol("Initializer", 1, ATfalse);
 ATprotectSymbol(sym_Initializer_1);
 sym_WhileStatement_2 = ATmakeSymbol("WhileStatement", 2, ATfalse);
@@ -352,16 +397,18 @@
 extern const char * __tracing_table [];
 extern unsigned short __tracing_table_counter;
 ATerm conc_0_0 (StrSL sl, ATerm t);
-ATerm map_1_0 (StrSL sl, StrCL b_83, ATerm t);
-ATerm try_1_0 (StrSL sl, StrCL p_60, ATerm t);
-ATerm topdown_1_0 (StrSL sl, StrCL b_53, ATerm t);
-ATerm outermost_1_0 (StrSL sl, StrCL t_51, ATerm t);
-ATerm io_wrap_1_0 (StrSL sl, StrCL k_44, ATerm t);
-static ATerm lifted6 (StrSL sl, ATerm t);
+ATerm map_1_0 (StrSL sl, StrCL b_86, ATerm t);
+ATerm try_1_0 (StrSL sl, StrCL m_63, ATerm t);
+ATerm topdown_1_0 (StrSL sl, StrCL h_56, ATerm t);
+ATerm outermost_1_0 (StrSL sl, StrCL y_54, ATerm t);
+ATerm io_wrap_1_0 (StrSL sl, StrCL c_47, ATerm t);
+static ATerm lifted8 (StrSL sl, ATerm t);
 ATerm rewriteAst_0_0 (StrSL sl, ATerm t);
 static ATerm lifted4 (StrSL sl, ATerm t);
 static ATerm lifted3 (StrSL sl, ATerm t);
 static ATerm lifted2 (StrSL sl, ATerm t);
+static ATerm lifted7 (StrSL sl, ATerm t);
+static ATerm lifted6 (StrSL sl, ATerm t);
 static ATerm lifted1 (StrSL sl, ATerm t);
 ATerm main_0_0 (StrSL sl, ATerm t);
 ATerm Stm_0_0 (StrSL sl, ATerm t);
@@ -378,203 +425,223 @@
 __tracing_table[__tracing_table_counter++] = "rewriteAst_0_0";
 sl_decl(sl);
 {
-struct str_closure o_160 = { &(lifted6) , &(frame) };
-StrCL lifted6_cl = &(o_160);
-t = outermost_1_0(sl, lifted6_cl, t);
+struct str_closure p_168 = { &(lifted8) , &(frame) };
+StrCL lifted8_cl = &(p_168);
+t = outermost_1_0(sl, lifted8_cl, t);
 if((t == NULL))
-goto fail14 ;
+goto fail16 ;
 }
 __tracing_table[--__tracing_table_counter] = NULL;
 return(t);
-fail14 :
+fail16 :
 --__tracing_table_counter;
 return(NULL);
 }
-static ATerm lifted6 (StrSL sl, ATerm t)
+static ATerm lifted8 (StrSL sl, ATerm t)
 {
-__tracing_table[__tracing_table_counter++] = "lifted6";
+__tracing_table[__tracing_table_counter++] = "lifted8";
 sl_decl(sl);
 {
-ATerm trm102 = t;
-ATerm trm103 = t;
-ATerm trm104 = t;
-ATerm trm105 = t;
-ATerm trm106 = t;
-ATerm trm107 = t;
-ATerm trm108 = t;
-ATerm trm109 = t;
-ATerm trm110 = t;
-ATerm trm111 = t;
-ATerm trm112 = t;
+ATerm trm125 = t;
+ATerm trm126 = t;
+ATerm trm127 = t;
+ATerm trm128 = t;
+ATerm trm129 = t;
+ATerm trm130 = t;
+ATerm trm131 = t;
+ATerm trm132 = t;
+ATerm trm133 = t;
+ATerm trm134 = t;
+ATerm trm135 = t;
+ATerm trm136 = t;
 t = T_0_0(sl_up(sl), t);
 if((t == NULL))
-goto label61 ;
-goto label60 ;
-label61 :
-t = trm112;
+goto label72 ;
+goto label71 ;
+label72 :
+t = trm136;
 {
-ATerm j_159 = NULL,k_159 = NULL;
+ATerm l_166 = NULL,m_166 = NULL;
 if(match_cons(t, sym_VarDec_2))
 {
-j_159 = ATgetArgument(t, 0);
+l_166 = ATgetArgument(t, 0);
 {
-ATerm trm113 = ATgetArgument(t, 1);
-if(!(match_cons(trm113, sym_None_0)))
-goto label59 ;
+ATerm trm137 = ATgetArgument(t, 1);
+if(!(match_cons(trm137, sym_None_0)))
+goto label70 ;
 }
 }
 else
-goto label59 ;
-k_159 = t;
-t = (ATerm) ATmakeAppl(sym_VarDec_1, j_159);
-goto label60 ;
+goto label70 ;
+m_166 = t;
+t = (ATerm) ATmakeAppl(sym_VarDec_1, l_166);
+goto label71 ;
 }
-label60 :
+label71 :
 ;
-goto label58 ;
-label59 :
-t = trm111;
+goto label69 ;
+label70 :
+t = trm135;
 t = Stm_0_0(sl_up(sl), t);
 if((t == NULL))
-goto label57 ;
+goto label68 ;
 else
-goto label58 ;
-label58 :
+goto label69 ;
+label69 :
 ;
-goto label56 ;
-label57 :
-t = trm110;
+goto label67 ;
+label68 :
+t = trm134;
 {
-ATerm l_159 = NULL,m_159 = NULL;
+ATerm n_166 = NULL,s_166 = NULL;
 if(match_cons(t, sym_NumberLiteral_1))
 {
-l_159 = ATgetArgument(t, 0);
+n_166 = ATgetArgument(t, 0);
 }
 else
-goto label55 ;
-m_159 = t;
-t = (ATerm) ATmakeAppl(sym_Lit_1, (ATerm) ATmakeAppl(sym_Deci_1, l_159));
-goto label56 ;
+goto label66 ;
+s_166 = t;
+t = (ATerm) ATmakeAppl(sym_Lit_1, (ATerm) ATmakeAppl(sym_Deci_1, n_166));
+goto label67 ;
 }
-label56 :
+label67 :
 ;
-goto label54 ;
-label55 :
-t = trm109;
+goto label65 ;
+label66 :
+t = trm133;
 {
-ATerm n_159 = NULL,r_159 = NULL,s_159 = NULL,t_159 = NULL;
+ATerm t_166 = NULL,u_166 = NULL,z_166 = NULL,a_167 = NULL;
 if(match_cons(t, sym_SingleVariableDeclaration_5))
 {
-n_159 = ATgetArgument(t, 0);
-r_159 = ATgetArgument(t, 1);
-s_159 = ATgetArgument(t, 2);
+t_166 = ATgetArgument(t, 0);
+u_166 = ATgetArgument(t, 1);
+z_166 = ATgetArgument(t, 2);
 {
-ATerm trm114 = ATgetArgument(t, 3);
-if(!(((ATgetType(trm114) == AT_INT) && (ATgetInt((ATermInt) trm114) == 0))))
-goto label53 ;
+ATerm trm138 = ATgetArgument(t, 3);
+if(!(((ATgetType(trm138) == AT_INT) && (ATgetInt((ATermInt) trm138) == 0))))
+goto label64 ;
 }
 {
-ATerm trm115 = ATgetArgument(t, 4);
-if(!(match_cons(trm115, sym_None_0)))
-goto label53 ;
+ATerm trm139 = ATgetArgument(t, 4);
+if(!(match_cons(trm139, sym_None_0)))
+goto label64 ;
 }
 }
 else
-goto label53 ;
-t_159 = t;
-t = (ATerm) ATmakeAppl(sym_Param_3, n_159, r_159, s_159);
-goto label54 ;
+goto label64 ;
+a_167 = t;
+t = (ATerm) ATmakeAppl(sym_Param_3, t_166, u_166, z_166);
+goto label65 ;
 }
-label54 :
+label65 :
 ;
-goto label52 ;
-label53 :
-t = trm108;
+goto label63 ;
+label64 :
+t = trm132;
 {
-ATerm u_159 = NULL,v_159 = NULL;
+ATerm b_167 = NULL,g_167 = NULL;
 if(match_cons(t, sym_SimpleType_1))
 {
-u_159 = ATgetArgument(t, 0);
+b_167 = ATgetArgument(t, 0);
 }
 else
-goto label51 ;
-v_159 = t;
-t = (ATerm) ATmakeAppl(sym_ClassOrInterfaceType_2, (ATerm)ATmakeAppl(sym_TypeName_1, u_159), term1);
-goto label52 ;
+goto label62 ;
+g_167 = t;
+t = (ATerm) ATmakeAppl(sym_ClassOrInterfaceType_2, (ATerm)ATmakeAppl(sym_TypeName_1, b_167), term1);
+goto label63 ;
 }
-label52 :
+label63 :
 ;
-goto label50 ;
-label51 :
-t = trm107;
+goto label61 ;
+label62 :
+t = trm131;
 t = ModKey_0_0(sl_up(sl), t);
 if((t == NULL))
-goto label49 ;
+goto label60 ;
 else
-goto label50 ;
-label50 :
+goto label61 ;
+label61 :
 ;
-goto label48 ;
-label49 :
-t = trm106;
+goto label59 ;
+label60 :
+t = trm130;
 t = RewritePrimitive_0_0(sl_up(sl), t);
 if((t == NULL))
-goto label47 ;
+goto label58 ;
 else
-goto label48 ;
-label48 :
+goto label59 ;
+label59 :
 ;
-goto label46 ;
-label47 :
-t = trm105;
+goto label57 ;
+label58 :
+t = trm129;
 t = RewriteMethod_0_0(sl_up(sl), t);
 if((t == NULL))
-goto label45 ;
+goto label56 ;
 else
-goto label46 ;
-label46 :
+goto label57 ;
+label57 :
 ;
-goto label44 ;
-label45 :
-t = trm104;
+goto label55 ;
+label56 :
+t = trm128;
 t = Import_0_0(sl_up(sl), t);
 if((t == NULL))
-goto label43 ;
+goto label54 ;
 else
-goto label44 ;
-label44 :
+goto label55 ;
+label55 :
 ;
-goto label42 ;
-label43 :
-t = trm103;
+goto label53 ;
+label54 :
+t = trm127;
 {
-ATerm z_159 = NULL,a_160 = NULL;
+ATerm j_167 = NULL,k_167 = NULL;
 if(match_cons(t, sym_SimpleName_1))
 {
-z_159 = ATgetArgument(t, 0);
+j_167 = ATgetArgument(t, 0);
 }
 else
-goto label41 ;
-a_160 = t;
-t = (ATerm) ATmakeAppl(sym_Id_1, z_159);
-goto label42 ;
+goto label52 ;
+k_167 = t;
+t = (ATerm) ATmakeAppl(sym_Id_1, j_167);
+goto label53 ;
 }
-label42 :
+label53 :
 ;
-goto label40 ;
-label41 :
-t = trm102;
+goto label51 ;
+label52 :
+t = trm126;
 t = RewriteClass_0_0(sl_up(sl), t);
 if((t == NULL))
-goto fail15 ;
+goto label50 ;
 else
-goto label40 ;
-label40 :
+goto label51 ;
+label51 :
 ;
+goto label49 ;
+label50 :
+t = trm125;
+{
+ATerm l_167 = NULL,p_167 = NULL,q_167 = NULL,r_167 = NULL;
+if(match_cons(t, sym_VariableDeclarationFragment_3))
+{
+p_167 = ATgetArgument(t, 0);
+l_167 = ATgetArgument(t, 1);
+q_167 = ATgetArgument(t, 2);
 }
+else
+goto fail17 ;
+r_167 = t;
+t = (ATerm) ATmakeAppl(sym_VarDec_2, p_167, q_167);
+goto label49 ;
+}
+label49 :
+;
+}
 __tracing_table[--__tracing_table_counter] = NULL;
 return(t);
-fail15 :
+fail17 :
 --__tracing_table_counter;
 return(NULL);
 }
@@ -583,8 +650,8 @@
 __tracing_table[__tracing_table_counter++] = "main_0_0";
 sl_decl(sl);
 {
-struct str_closure n_160 = { &(lifted1) , &(frame) };
-StrCL lifted1_cl = &(n_160);
+struct str_closure o_168 = { &(lifted1) , &(frame) };
+StrCL lifted1_cl = &(o_168);
 t = io_wrap_1_0(sl, lifted1_cl, t);
 if((t == NULL))
 goto fail9 ;
@@ -600,20 +667,25 @@
 __tracing_table[__tracing_table_counter++] = "lifted1";
 sl_decl(sl);
 {
-struct str_closure c_160 = { &(lifted2) , &(frame) };
-StrCL lifted2_cl = &(c_160);
+struct str_closure x_167 = { &(lifted6) , &(frame) };
+StrCL lifted6_cl = &(x_167);
+struct str_closure b_168 = { &(lifted2) , &(frame) };
+StrCL lifted2_cl = &(b_168);
 t = outermost_1_0(sl_up(sl), lifted2_cl, t);
 if((t == NULL))
 goto fail10 ;
 {
-struct str_closure j_160 = { &(lifted3) , &(frame) };
-StrCL lifted3_cl = &(j_160);
+struct str_closure n_168 = { &(lifted3) , &(frame) };
+StrCL lifted3_cl = &(n_168);
 t = topdown_1_0(sl_up(sl), lifted3_cl, t);
 if((t == NULL))
 goto fail10 ;
 t = rewriteAst_0_0(sl_up(sl), t);
 if((t == NULL))
 goto fail10 ;
+t = topdown_1_0(sl_up(sl), lifted6_cl, t);
+if((t == NULL))
+goto fail10 ;
 }
 }
 __tracing_table[--__tracing_table_counter] = NULL;
@@ -627,15 +699,15 @@
 __tracing_table[__tracing_table_counter++] = "lifted3";
 sl_decl(sl);
 {
-struct str_closure i_160 = { &(lifted4) , &(frame) };
-StrCL lifted4_cl = &(i_160);
+struct str_closure l_168 = { &(lifted4) , &(frame) };
+StrCL lifted4_cl = &(l_168);
 t = try_1_0(sl_up(sl_up(sl)), lifted4_cl, t);
 if((t == NULL))
-goto fail12 ;
+goto fail14 ;
 }
 __tracing_table[--__tracing_table_counter] = NULL;
 return(t);
-fail12 :
+fail14 :
 --__tracing_table_counter;
 return(NULL);
 }
@@ -644,29 +716,29 @@
 __tracing_table[__tracing_table_counter++] = "lifted4";
 sl_decl(sl);
 {
-ATerm d_158 = NULL,h_158 = NULL,s_158 = NULL;
+ATerm x_164 = NULL,y_164 = NULL,a_165 = NULL;
 if(match_cons(t, sym_PackageName_1))
 {
-d_158 = ATgetArgument(t, 0);
+x_164 = ATgetArgument(t, 0);
 }
 else
-goto fail13 ;
-s_158 = t;
-t = d_158;
+goto fail15 ;
+a_165 = t;
+t = x_164;
 {
-struct str_closure d_160 = { &(RP_0_0) , sl_up(sl_up(sl_up(sl))) };
-StrCL lifted5_cl = &(d_160);
+struct str_closure g_168 = { &(RP_0_0) , sl_up(sl_up(sl_up(sl))) };
+StrCL lifted5_cl = &(g_168);
 t = outermost_1_0(sl_up(sl_up(sl_up(sl))), lifted5_cl, t);
 if((t == NULL))
-goto fail13 ;
-h_158 = t;
-t = s_158;
-t = (ATerm) ATmakeAppl(sym_PackageName_1, h_158);
+goto fail15 ;
+y_164 = t;
+t = a_165;
+t = (ATerm) ATmakeAppl(sym_PackageName_1, y_164);
 }
 }
 __tracing_table[--__tracing_table_counter] = NULL;
 return(t);
-fail13 :
+fail15 :
 --__tracing_table_counter;
 return(NULL);
 }
@@ -675,17 +747,34 @@
 __tracing_table[__tracing_table_counter++] = "lifted2";
 sl_decl(sl);
 {
-ATerm v_157 = NULL,w_157 = NULL,x_157 = NULL,c_158 = NULL;
+ATerm o_164 = NULL,q_164 = NULL,u_164 = NULL,v_164 = NULL;
 if(match_cons(t, sym_PackageDeclaration_3))
 {
-v_157 = ATgetArgument(t, 0);
-w_157 = ATgetArgument(t, 1);
-x_157 = ATgetArgument(t, 2);
+o_164 = ATgetArgument(t, 0);
+q_164 = ATgetArgument(t, 1);
+u_164 = ATgetArgument(t, 2);
 }
 else
+goto fail13 ;
+v_164 = t;
+t = (ATerm) ATmakeAppl(sym_Some_1, (ATerm) ATmakeAppl(sym_PackageDec_2, q_164, (ATerm) ATmakeAppl(sym_PackageName_1, u_164)));
+}
+__tracing_table[--__tracing_table_counter] = NULL;
+return(t);
+fail13 :
+--__tracing_table_counter;
+return(NULL);
+}
+static ATerm lifted6 (StrSL sl, ATerm t)
+{
+__tracing_table[__tracing_table_counter++] = "lifted6";
+sl_decl(sl);
+{
+struct str_closure w_167 = { &(lifted7) , &(frame) };
+StrCL lifted7_cl = &(w_167);
+t = try_1_0(sl_up(sl_up(sl)), lifted7_cl, t);
+if((t == NULL))
 goto fail11 ;
-c_158 = t;
-t = (ATerm) ATmakeAppl(sym_Some_1, (ATerm) ATmakeAppl(sym_PackageDec_2, w_157, (ATerm) ATmakeAppl(sym_PackageName_1, x_157)));
 }
 __tracing_table[--__tracing_table_counter] = NULL;
 return(t);
@@ -693,95 +782,118 @@
 --__tracing_table_counter;
 return(NULL);
 }
+static ATerm lifted7 (StrSL sl, ATerm t)
+{
+__tracing_table[__tracing_table_counter++] = "lifted7";
+sl_decl(sl);
+{
+ATerm c_165 = NULL,e_165 = NULL,h_165 = NULL,m_165 = NULL;
+if(match_cons(t, sym_VariableDeclarationFragment_3))
+{
+e_165 = ATgetArgument(t, 0);
+c_165 = ATgetArgument(t, 1);
+h_165 = ATgetArgument(t, 2);
+}
+else
+goto fail12 ;
+m_165 = t;
+t = (ATerm) ATmakeAppl(sym_VarDec_2, e_165, h_165);
+}
+__tracing_table[--__tracing_table_counter] = NULL;
+return(t);
+fail12 :
+--__tracing_table_counter;
+return(NULL);
+}
 ATerm Stm_0_0 (StrSL sl, ATerm t)
 {
 __tracing_table[__tracing_table_counter++] = "Stm_0_0";
 sl_decl(sl);
 {
-ATerm trm93 = t;
-ATerm v_20 = NULL,w_20 = NULL,x_20 = NULL;
+ATerm trm116 = t;
+ATerm u_22 = NULL,v_22 = NULL,w_22 = NULL;
 if(match_cons(t, sym_ExprStm_1))
 {
-ATerm trm94 = ATgetArgument(t, 0);
-if(match_cons(trm94, sym_Assignment_3))
+ATerm trm117 = ATgetArgument(t, 0);
+if(match_cons(trm117, sym_Assignment_3))
 {
-ATerm trm95 = ATgetArgument(trm94, 0);
-if(match_cons(trm95, sym_AssignmentOperator_1))
+ATerm trm118 = ATgetArgument(trm117, 0);
+if(match_cons(trm118, sym_AssignmentOperator_1))
 {
-ATerm trm96 = ATgetArgument(trm95, 0);
-if(!((ATgetSymbol(trm96) == ATmakeSymbol("=", 0, ATtrue))))
-goto label38 ;
+ATerm trm119 = ATgetArgument(trm118, 0);
+if(!((ATgetSymbol(trm119) == ATmakeSymbol("=", 0, ATtrue))))
+goto label47 ;
 }
 else
-goto label38 ;
-v_20 = ATgetArgument(trm94, 1);
-w_20 = ATgetArgument(trm94, 2);
+goto label47 ;
+u_22 = ATgetArgument(trm117, 1);
+v_22 = ATgetArgument(trm117, 2);
 }
 else
-goto label38 ;
+goto label47 ;
 }
 else
-goto label38 ;
-x_20 = t;
-t = (ATerm) ATmakeAppl(sym_ExprStm_1, (ATerm) ATmakeAppl(sym_Assign_2, (ATerm)ATmakeAppl(sym_ExprName_1, v_20), w_20));
-goto label37 ;
-label38 :
-t = trm93;
+goto label47 ;
+w_22 = t;
+t = (ATerm) ATmakeAppl(sym_ExprStm_1, (ATerm) ATmakeAppl(sym_Assign_2, (ATerm)ATmakeAppl(sym_ExprName_1, u_22), v_22));
+goto label46 ;
+label47 :
+t = trm116;
 {
-ATerm trm97 = t;
-ATerm q_20 = NULL,r_20 = NULL,s_20 = NULL,t_20 = NULL,u_20 = NULL;
+ATerm trm120 = t;
+ATerm p_22 = NULL,q_22 = NULL,r_22 = NULL,s_22 = NULL,t_22 = NULL;
 if(match_cons(t, sym_VariableDeclarationStatement_3))
 {
-q_20 = ATgetArgument(t, 0);
-r_20 = ATgetArgument(t, 1);
+p_22 = ATgetArgument(t, 0);
+q_22 = ATgetArgument(t, 1);
 {
-ATerm trm98 = ATgetArgument(t, 2);
-if(((ATgetType(trm98) == AT_LIST) && !(ATisEmpty(trm98))))
+ATerm trm121 = ATgetArgument(t, 2);
+if(((ATgetType(trm121) == AT_LIST) && !(ATisEmpty(trm121))))
 {
-ATerm trm99 = ATgetFirst((ATermList) trm98);
-if(match_cons(trm99, sym_VariableDeclarationFragment_3))
+ATerm trm122 = ATgetFirst((ATermList) trm121);
+if(match_cons(trm122, sym_VariableDeclarationFragment_3))
 {
-s_20 = ATgetArgument(trm99, 0);
+r_22 = ATgetArgument(trm122, 0);
 {
-ATerm trm100 = ATgetArgument(trm99, 1);
-if(!(((ATgetType(trm100) == AT_INT) && (ATgetInt((ATermInt) trm100) == 0))))
-goto label39 ;
+ATerm trm123 = ATgetArgument(trm122, 1);
+if(!(((ATgetType(trm123) == AT_INT) && (ATgetInt((ATermInt) trm123) == 0))))
+goto label48 ;
 }
-t_20 = ATgetArgument(trm99, 2);
+s_22 = ATgetArgument(trm122, 2);
 }
 else
-goto label39 ;
+goto label48 ;
 {
-ATerm trm101 = (ATerm) ATgetNext((ATermList) trm98);
-if(!(((ATgetType(trm101) == AT_LIST) && ATisEmpty(trm101))))
-goto label39 ;
+ATerm trm124 = (ATerm) ATgetNext((ATermList) trm121);
+if(!(((ATgetType(trm124) == AT_LIST) && ATisEmpty(trm124))))
+goto label48 ;
 }
 }
 else
-goto label39 ;
+goto label48 ;
 }
 }
 else
-goto label39 ;
-u_20 = t;
-t = (ATerm) ATmakeAppl(sym_LocalVarDecStm_1, (ATerm) ATmakeAppl(sym_LocalVarDec_3, q_20, r_20, (ATerm) ATinsert(ATempty, (ATerm) ATmakeAppl(sym_VarDec_2, s_20, t_20))));
-goto label37 ;
-label39 :
-t = trm97;
+goto label48 ;
+t_22 = t;
+t = (ATerm) ATmakeAppl(sym_LocalVarDecStm_1, (ATerm) ATmakeAppl(sym_LocalVarDec_3, p_22, q_22, (ATerm) ATinsert(ATempty, (ATerm) ATmakeAppl(sym_VarDec_2, r_22, s_22))));
+goto label46 ;
+label48 :
+t = trm120;
 {
-ATerm o_20 = NULL,p_20 = NULL;
+ATerm n_22 = NULL,o_22 = NULL;
 if(match_cons(t, sym_ReturnStatement_1))
 {
-o_20 = ATgetArgument(t, 0);
+n_22 = ATgetArgument(t, 0);
 }
 else
 goto fail8 ;
-p_20 = t;
-t = (ATerm) ATmakeAppl(sym_Return_1, (ATerm) ATmakeAppl(sym_Some_1, o_20));
-goto label37 ;
+o_22 = t;
+t = (ATerm) ATmakeAppl(sym_Return_1, (ATerm) ATmakeAppl(sym_Some_1, n_22));
+goto label46 ;
 }
 }
-label37 :
+label46 :
 ;
 }
 __tracing_table[--__tracing_table_counter] = NULL;
@@ -795,58 +907,58 @@
 __tracing_table[__tracing_table_counter++] = "ModKey_0_0";
 sl_decl(sl);
 {
-ATerm trm85 = t;
-ATerm f_20 = NULL;
+ATerm trm108 = t;
+ATerm e_22 = NULL;
 if(match_cons(t, sym_Modifier_1))
 {
-ATerm trm86 = ATgetArgument(t, 0);
-if(match_cons(trm86, sym_ModifierKeyword_1))
+ATerm trm109 = ATgetArgument(t, 0);
+if(match_cons(trm109, sym_ModifierKeyword_1))
 {
-ATerm trm87 = ATgetArgument(trm86, 0);
-if(!(((ATgetType(trm87) == AT_INT) && (ATgetInt((ATermInt) trm87) == 1))))
-goto label35 ;
+ATerm trm110 = ATgetArgument(trm109, 0);
+if(!(((ATgetType(trm110) == AT_INT) && (ATgetInt((ATermInt) trm110) == 1))))
+goto label44 ;
 }
 else
-goto label35 ;
+goto label44 ;
 }
 else
-goto label35 ;
-f_20 = t;
+goto label44 ;
+e_22 = t;
 t = term21;
-goto label34 ;
-label35 :
-t = trm85;
+goto label43 ;
+label44 :
+t = trm108;
 {
-ATerm trm88 = t;
-ATerm e_20 = NULL;
+ATerm trm111 = t;
+ATerm d_22 = NULL;
 if(match_cons(t, sym_Modifier_1))
 {
-ATerm trm89 = ATgetArgument(t, 0);
-if(match_cons(trm89, sym_ModifierKeyword_1))
+ATerm trm112 = ATgetArgument(t, 0);
+if(match_cons(trm112, sym_ModifierKeyword_1))
 {
-ATerm trm90 = ATgetArgument(trm89, 0);
-if(!(((ATgetType(trm90) == AT_INT) && (ATgetInt((ATermInt) trm90) == 2))))
-goto label36 ;
+ATerm trm113 = ATgetArgument(trm112, 0);
+if(!(((ATgetType(trm113) == AT_INT) && (ATgetInt((ATermInt) trm113) == 2))))
+goto label45 ;
 }
 else
-goto label36 ;
+goto label45 ;
 }
 else
-goto label36 ;
-e_20 = t;
+goto label45 ;
+d_22 = t;
 t = term23;

(1428 diff lines omitted)


From mdjonge at xs4all.nl  Tue Jun 30 13:34:07 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Tue, 30 Jun 2009 11:34:07 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19597 - MaartjeDeJonge
	- sglr-recovery/trunk/Evaluation_Recovery/src
Message-ID: <200906301132.n5UBWdT8021333@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-30 11:34:07 +0000 (Tue, 30 Jun 2009)
New Revision: 19597

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19597&view=rev

Modified:
   sglr-recovery/trunk/Evaluation_Recovery/src/ProcessFiles.java

Log:


Changes:

Modified: sglr-recovery/trunk/Evaluation_Recovery/src/ProcessFiles.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/src/ProcessFiles.java	2009-06-30 11:33:37 UTC (rev 19596)
+++ sglr-recovery/trunk/Evaluation_Recovery/src/ProcessFiles.java	2009-06-30 11:34:07 UTC (rev 19597)
@@ -40,7 +40,7 @@
 	private StandAloneSGLRI tokenParser;
 	private IRecoveryParser recoveryParser;
 	private InputStream fis;
-	private boolean useBridgeParser=false;	
+	private boolean useBridgeParser=true;	
 	
 
 	private void createJDT_Tree(String fileName, String inputDir, String outputDir) throws IOException, InterpreterException {	



From mdjonge at xs4all.nl  Tue Jun 30 16:10:16 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Tue, 30 Jun 2009 14:10:16 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19599 - MaartjeDeJonge
	- in sglr-recovery/trunk/Evaluation_Recovery:
	Correct_Files/input_files Error_Files/input_files Language_Files
Message-ID: <200906301408.n5UE8mkj023192@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-30 14:10:16 +0000 (Tue, 30 Jun 2009)
New Revision: 19599

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19599&view=rev

Modified:
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testJ1.java
   sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testJ2.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testJ1.java
   sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testJ2.java
   sglr-recovery/trunk/Evaluation_Recovery/Language_Files/JdtToJava15
   sglr-recovery/trunk/Evaluation_Recovery/Language_Files/JdtToJava15.c
   sglr-recovery/trunk/Evaluation_Recovery/Language_Files/JdtTransformRules.str
   sglr-recovery/trunk/Evaluation_Recovery/Language_Files/jdt.str

Log:
transform program extended for input files

Changes (first 1000 lines of the diffs):

Modified: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testJ1.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testJ1.java	2009-06-30 13:40:58 UTC (rev 19598)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testJ1.java	2009-06-30 14:10:16 UTC (rev 19599)
@@ -2,7 +2,7 @@
 class C {
 	void m() {
 		int a;
-		if (true && true && true || true && 4 < 5 || true && 6 < 9) {
+		if (true && true || true && 4 < 5 || true && 6 < 9) {
 			int b;
 		}
 		int c;

Modified: sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testJ2.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testJ2.java	2009-06-30 13:40:58 UTC (rev 19598)
+++ sglr-recovery/trunk/Evaluation_Recovery/Correct_Files/input_files/testJ2.java	2009-06-30 14:10:16 UTC (rev 19599)
@@ -2,7 +2,7 @@
 class C {
 	void m() {
 		int a;
-		if (true && true && true || true && 4 < 5 || true && 6 < 9) {
+		if (true && true || true && 4 < 5 || true && 6 < 9) {
 			int b;
 		}
 		int c;

Modified: sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testJ1.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testJ1.java	2009-06-30 13:40:58 UTC (rev 19598)
+++ sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testJ1.java	2009-06-30 14:10:16 UTC (rev 19599)
@@ -2,7 +2,7 @@
 class C {
 	void m() {
 		int a;
-		if (true && true && true || 
+		if (true && true || 
 			true && 4 < 5 || 
 			true && 6 < 9) {
 			int b;

Modified: sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testJ2.java
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testJ2.java	2009-06-30 13:40:58 UTC (rev 19598)
+++ sglr-recovery/trunk/Evaluation_Recovery/Error_Files/input_files/testJ2.java	2009-06-30 14:10:16 UTC (rev 19599)
@@ -2,7 +2,7 @@
 class C {
 	void m() {
 		int a;
-		if (true && true && true || true && 4 < 5 || true && 6 < 9) {
+		if (true && true || true && 4 < 5 || true && 6 < 9) {
 			int b;
 		}
 		int c;

Modified: sglr-recovery/trunk/Evaluation_Recovery/Language_Files/JdtToJava15
===================================================================
(Binary files differ)

Modified: sglr-recovery/trunk/Evaluation_Recovery/Language_Files/JdtToJava15.c
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Language_Files/JdtToJava15.c	2009-06-30 13:40:58 UTC (rev 19598)
+++ sglr-recovery/trunk/Evaluation_Recovery/Language_Files/JdtToJava15.c	2009-06-30 14:10:16 UTC (rev 19599)
@@ -24,11 +24,13 @@
 static Symbol sym_PackageOrTypeName_1;
 static Symbol sym_PackageOrTypeName_2;
 static Symbol sym_ClassOrInterfaceType_2;
+static Symbol sym_ClassType_2;
 static Symbol sym_Lit_1;
 static Symbol sym_NewInstance_4;
 static Symbol sym_Invoke_2;
 static Symbol sym_PostIncr_1;
 static Symbol sym_Not_1;
+static Symbol sym_Plus_2;
 static Symbol sym_Lt_2;
 static Symbol sym_Gt_2;
 static Symbol sym_LtEq_2;
@@ -37,6 +39,7 @@
 static Symbol sym_NotEq_2;
 static Symbol sym_LazyAnd_2;
 static Symbol sym_LazyOr_2;
+static Symbol sym_Cond_3;
 static Symbol sym_Assign_2;
 static Symbol sym_FieldDec_3;
 static Symbol sym_VarDec_1;
@@ -45,10 +48,19 @@
 static Symbol sym_LocalVarDec_3;
 static Symbol sym_If_2;
 static Symbol sym_If_3;
+static Symbol sym_Switch_2;
 static Symbol sym_While_2;
+static Symbol sym_DoWhile_2;
 static Symbol sym_For_4;
+static Symbol sym_Break_1;
 static Symbol sym_Return_1;
+static Symbol sym_Throw_1;
+static Symbol sym_Try_2;
 static Symbol sym_ExprStm_1;
+static Symbol sym_SwitchBlock_2;
+static Symbol sym_SwitchGroup_2;
+static Symbol sym_Case_1;
+static Symbol sym_Catch_2;
 static Symbol sym_Block_1;
 static Symbol sym_MethodDec_2;
 static Symbol sym_MethodDecHead_6;
@@ -65,12 +77,23 @@
 static Symbol sym_ClassBody_1;
 static Symbol sym_ClassDecHead_5;
 static Symbol sym_Method_1;
+static Symbol sym_Method_3;
 static Symbol sym_PackageDec_2;
 static Symbol sym_TypeImportDec_1;
 static Symbol sym_Nil_0;
 static Symbol sym_Cons_2;
 static Symbol sym_None_0;
 static Symbol sym_Some_1;
+static Symbol sym_BreakStatement_1;
+static Symbol sym_SwitchCase_1;
+static Symbol sym_SwitchStatement_2;
+static Symbol sym_ThrowStatement_1;
+static Symbol sym_ParenthesizedExpression_1;
+static Symbol sym_ConditionalExpression_3;
+static Symbol sym_CatchClause_2;
+static Symbol sym_TryStatement_3;
+static Symbol sym_DoStatement_2;
+static Symbol sym_AnonymousClassDeclaration_1;
 static Symbol sym_ClassType_1;
 static Symbol sym_ClassInstanceCreation_4;
 static Symbol sym_PostfixExpressionOperator_1;
@@ -149,6 +172,8 @@
 ATprotectSymbol(sym_PackageOrTypeName_2);
 sym_ClassOrInterfaceType_2 = ATmakeSymbol("ClassOrInterfaceType", 2, ATfalse);
 ATprotectSymbol(sym_ClassOrInterfaceType_2);
+sym_ClassType_2 = ATmakeSymbol("ClassType", 2, ATfalse);
+ATprotectSymbol(sym_ClassType_2);
 sym_Lit_1 = ATmakeSymbol("Lit", 1, ATfalse);
 ATprotectSymbol(sym_Lit_1);
 sym_NewInstance_4 = ATmakeSymbol("NewInstance", 4, ATfalse);
@@ -159,6 +184,8 @@
 ATprotectSymbol(sym_PostIncr_1);
 sym_Not_1 = ATmakeSymbol("Not", 1, ATfalse);
 ATprotectSymbol(sym_Not_1);
+sym_Plus_2 = ATmakeSymbol("Plus", 2, ATfalse);
+ATprotectSymbol(sym_Plus_2);
 sym_Lt_2 = ATmakeSymbol("Lt", 2, ATfalse);
 ATprotectSymbol(sym_Lt_2);
 sym_Gt_2 = ATmakeSymbol("Gt", 2, ATfalse);
@@ -175,6 +202,8 @@
 ATprotectSymbol(sym_LazyAnd_2);
 sym_LazyOr_2 = ATmakeSymbol("LazyOr", 2, ATfalse);
 ATprotectSymbol(sym_LazyOr_2);
+sym_Cond_3 = ATmakeSymbol("Cond", 3, ATfalse);
+ATprotectSymbol(sym_Cond_3);
 sym_Assign_2 = ATmakeSymbol("Assign", 2, ATfalse);
 ATprotectSymbol(sym_Assign_2);
 sym_FieldDec_3 = ATmakeSymbol("FieldDec", 3, ATfalse);
@@ -191,14 +220,32 @@
 ATprotectSymbol(sym_If_2);
 sym_If_3 = ATmakeSymbol("If", 3, ATfalse);
 ATprotectSymbol(sym_If_3);
+sym_Switch_2 = ATmakeSymbol("Switch", 2, ATfalse);
+ATprotectSymbol(sym_Switch_2);
 sym_While_2 = ATmakeSymbol("While", 2, ATfalse);
 ATprotectSymbol(sym_While_2);
+sym_DoWhile_2 = ATmakeSymbol("DoWhile", 2, ATfalse);
+ATprotectSymbol(sym_DoWhile_2);
 sym_For_4 = ATmakeSymbol("For", 4, ATfalse);
 ATprotectSymbol(sym_For_4);
+sym_Break_1 = ATmakeSymbol("Break", 1, ATfalse);
+ATprotectSymbol(sym_Break_1);
 sym_Return_1 = ATmakeSymbol("Return", 1, ATfalse);
 ATprotectSymbol(sym_Return_1);
+sym_Throw_1 = ATmakeSymbol("Throw", 1, ATfalse);
+ATprotectSymbol(sym_Throw_1);
+sym_Try_2 = ATmakeSymbol("Try", 2, ATfalse);
+ATprotectSymbol(sym_Try_2);
 sym_ExprStm_1 = ATmakeSymbol("ExprStm", 1, ATfalse);
 ATprotectSymbol(sym_ExprStm_1);
+sym_SwitchBlock_2 = ATmakeSymbol("SwitchBlock", 2, ATfalse);
+ATprotectSymbol(sym_SwitchBlock_2);
+sym_SwitchGroup_2 = ATmakeSymbol("SwitchGroup", 2, ATfalse);
+ATprotectSymbol(sym_SwitchGroup_2);
+sym_Case_1 = ATmakeSymbol("Case", 1, ATfalse);
+ATprotectSymbol(sym_Case_1);
+sym_Catch_2 = ATmakeSymbol("Catch", 2, ATfalse);
+ATprotectSymbol(sym_Catch_2);
 sym_Block_1 = ATmakeSymbol("Block", 1, ATfalse);
 ATprotectSymbol(sym_Block_1);
 sym_MethodDec_2 = ATmakeSymbol("MethodDec", 2, ATfalse);
@@ -231,6 +278,8 @@
 ATprotectSymbol(sym_ClassDecHead_5);
 sym_Method_1 = ATmakeSymbol("Method", 1, ATfalse);
 ATprotectSymbol(sym_Method_1);
+sym_Method_3 = ATmakeSymbol("Method", 3, ATfalse);
+ATprotectSymbol(sym_Method_3);
 sym_PackageDec_2 = ATmakeSymbol("PackageDec", 2, ATfalse);
 ATprotectSymbol(sym_PackageDec_2);
 sym_TypeImportDec_1 = ATmakeSymbol("TypeImportDec", 1, ATfalse);
@@ -243,6 +292,26 @@
 ATprotectSymbol(sym_None_0);
 sym_Some_1 = ATmakeSymbol("Some", 1, ATfalse);
 ATprotectSymbol(sym_Some_1);
+sym_BreakStatement_1 = ATmakeSymbol("BreakStatement", 1, ATfalse);
+ATprotectSymbol(sym_BreakStatement_1);
+sym_SwitchCase_1 = ATmakeSymbol("SwitchCase", 1, ATfalse);
+ATprotectSymbol(sym_SwitchCase_1);
+sym_SwitchStatement_2 = ATmakeSymbol("SwitchStatement", 2, ATfalse);
+ATprotectSymbol(sym_SwitchStatement_2);
+sym_ThrowStatement_1 = ATmakeSymbol("ThrowStatement", 1, ATfalse);
+ATprotectSymbol(sym_ThrowStatement_1);
+sym_ParenthesizedExpression_1 = ATmakeSymbol("ParenthesizedExpression", 1, ATfalse);
+ATprotectSymbol(sym_ParenthesizedExpression_1);
+sym_ConditionalExpression_3 = ATmakeSymbol("ConditionalExpression", 3, ATfalse);
+ATprotectSymbol(sym_ConditionalExpression_3);
+sym_CatchClause_2 = ATmakeSymbol("CatchClause", 2, ATfalse);
+ATprotectSymbol(sym_CatchClause_2);
+sym_TryStatement_3 = ATmakeSymbol("TryStatement", 3, ATfalse);
+ATprotectSymbol(sym_TryStatement_3);
+sym_DoStatement_2 = ATmakeSymbol("DoStatement", 2, ATfalse);
+ATprotectSymbol(sym_DoStatement_2);
+sym_AnonymousClassDeclaration_1 = ATmakeSymbol("AnonymousClassDeclaration", 1, ATfalse);
+ATprotectSymbol(sym_AnonymousClassDeclaration_1);
 sym_ClassType_1 = ATmakeSymbol("ClassType", 1, ATfalse);
 ATprotectSymbol(sym_ClassType_1);
 sym_ClassInstanceCreation_4 = ATmakeSymbol("ClassInstanceCreation", 4, ATfalse);
@@ -397,11 +466,11 @@
 extern const char * __tracing_table [];
 extern unsigned short __tracing_table_counter;
 ATerm conc_0_0 (StrSL sl, ATerm t);
-ATerm map_1_0 (StrSL sl, StrCL b_86, ATerm t);
-ATerm try_1_0 (StrSL sl, StrCL m_63, ATerm t);
-ATerm topdown_1_0 (StrSL sl, StrCL h_56, ATerm t);
-ATerm outermost_1_0 (StrSL sl, StrCL y_54, ATerm t);
-ATerm io_wrap_1_0 (StrSL sl, StrCL c_47, ATerm t);
+ATerm map_1_0 (StrSL sl, StrCL q_90, ATerm t);
+ATerm try_1_0 (StrSL sl, StrCL e_66, ATerm t);
+ATerm topdown_1_0 (StrSL sl, StrCL g_59, ATerm t);
+ATerm outermost_1_0 (StrSL sl, StrCL c_58, ATerm t);
+ATerm io_wrap_1_0 (StrSL sl, StrCL y_49, ATerm t);
 static ATerm lifted8 (StrSL sl, ATerm t);
 ATerm rewriteAst_0_0 (StrSL sl, ATerm t);
 static ATerm lifted4 (StrSL sl, ATerm t);
@@ -425,8 +494,8 @@
 __tracing_table[__tracing_table_counter++] = "rewriteAst_0_0";
 sl_decl(sl);
 {
-struct str_closure p_168 = { &(lifted8) , &(frame) };
-StrCL lifted8_cl = &(p_168);
+struct str_closure f_173 = { &(lifted8) , &(frame) };
+StrCL lifted8_cl = &(f_173);
 t = outermost_1_0(sl, lifted8_cl, t);
 if((t == NULL))
 goto fail16 ;
@@ -442,201 +511,201 @@
 __tracing_table[__tracing_table_counter++] = "lifted8";
 sl_decl(sl);
 {
-ATerm trm125 = t;
-ATerm trm126 = t;
-ATerm trm127 = t;
-ATerm trm128 = t;
-ATerm trm129 = t;
-ATerm trm130 = t;
-ATerm trm131 = t;
-ATerm trm132 = t;
-ATerm trm133 = t;
-ATerm trm134 = t;
-ATerm trm135 = t;
-ATerm trm136 = t;
+ATerm trm164 = t;
+ATerm trm165 = t;
+ATerm trm166 = t;
+ATerm trm167 = t;
+ATerm trm168 = t;
+ATerm trm169 = t;
+ATerm trm170 = t;
+ATerm trm171 = t;
+ATerm trm172 = t;
+ATerm trm173 = t;
+ATerm trm174 = t;
+ATerm trm175 = t;
 t = T_0_0(sl_up(sl), t);
 if((t == NULL))
-goto label72 ;
-goto label71 ;
-label72 :
-t = trm136;
+goto label83 ;
+goto label82 ;
+label83 :
+t = trm175;
 {
-ATerm l_166 = NULL,m_166 = NULL;
+ATerm h_172 = NULL,i_172 = NULL;
 if(match_cons(t, sym_VarDec_2))
 {
-l_166 = ATgetArgument(t, 0);
+h_172 = ATgetArgument(t, 0);
 {
-ATerm trm137 = ATgetArgument(t, 1);
-if(!(match_cons(trm137, sym_None_0)))
-goto label70 ;
+ATerm trm176 = ATgetArgument(t, 1);
+if(!(match_cons(trm176, sym_None_0)))
+goto label81 ;
 }
 }
 else
-goto label70 ;
-m_166 = t;
-t = (ATerm) ATmakeAppl(sym_VarDec_1, l_166);
-goto label71 ;
+goto label81 ;
+i_172 = t;
+t = (ATerm) ATmakeAppl(sym_VarDec_1, h_172);
+goto label82 ;
 }
-label71 :
+label82 :
 ;
-goto label69 ;
-label70 :
-t = trm135;
+goto label80 ;
+label81 :
+t = trm174;
 t = Stm_0_0(sl_up(sl), t);
 if((t == NULL))
-goto label68 ;
+goto label79 ;
 else
-goto label69 ;
-label69 :
+goto label80 ;
+label80 :
 ;
-goto label67 ;
-label68 :
-t = trm134;
+goto label78 ;
+label79 :
+t = trm173;
 {
-ATerm n_166 = NULL,s_166 = NULL;
+ATerm j_172 = NULL,k_172 = NULL;
 if(match_cons(t, sym_NumberLiteral_1))
 {
-n_166 = ATgetArgument(t, 0);
+j_172 = ATgetArgument(t, 0);
 }
 else
-goto label66 ;
-s_166 = t;
-t = (ATerm) ATmakeAppl(sym_Lit_1, (ATerm) ATmakeAppl(sym_Deci_1, n_166));
-goto label67 ;
+goto label77 ;
+k_172 = t;
+t = (ATerm) ATmakeAppl(sym_Lit_1, (ATerm) ATmakeAppl(sym_Deci_1, j_172));
+goto label78 ;
 }
-label67 :
+label78 :
 ;
-goto label65 ;
-label66 :
-t = trm133;
+goto label76 ;
+label77 :
+t = trm172;
 {
-ATerm t_166 = NULL,u_166 = NULL,z_166 = NULL,a_167 = NULL;
+ATerm l_172 = NULL,m_172 = NULL,n_172 = NULL,o_172 = NULL;
 if(match_cons(t, sym_SingleVariableDeclaration_5))
 {
-t_166 = ATgetArgument(t, 0);
-u_166 = ATgetArgument(t, 1);
-z_166 = ATgetArgument(t, 2);
+l_172 = ATgetArgument(t, 0);
+m_172 = ATgetArgument(t, 1);
+n_172 = ATgetArgument(t, 2);
 {
-ATerm trm138 = ATgetArgument(t, 3);
-if(!(((ATgetType(trm138) == AT_INT) && (ATgetInt((ATermInt) trm138) == 0))))
-goto label64 ;
+ATerm trm177 = ATgetArgument(t, 3);
+if(!(((ATgetType(trm177) == AT_INT) && (ATgetInt((ATermInt) trm177) == 0))))
+goto label75 ;
 }
 {
-ATerm trm139 = ATgetArgument(t, 4);
-if(!(match_cons(trm139, sym_None_0)))
-goto label64 ;
+ATerm trm178 = ATgetArgument(t, 4);
+if(!(match_cons(trm178, sym_None_0)))
+goto label75 ;
 }
 }
 else
-goto label64 ;
-a_167 = t;
-t = (ATerm) ATmakeAppl(sym_Param_3, t_166, u_166, z_166);
-goto label65 ;
+goto label75 ;
+o_172 = t;
+t = (ATerm) ATmakeAppl(sym_Param_3, l_172, m_172, n_172);
+goto label76 ;
 }
-label65 :
+label76 :
 ;
-goto label63 ;
-label64 :
-t = trm132;
+goto label74 ;
+label75 :
+t = trm171;
 {
-ATerm b_167 = NULL,g_167 = NULL;
+ATerm p_172 = NULL,q_172 = NULL;
 if(match_cons(t, sym_SimpleType_1))
 {
-b_167 = ATgetArgument(t, 0);
+p_172 = ATgetArgument(t, 0);
 }
 else
-goto label62 ;
-g_167 = t;
-t = (ATerm) ATmakeAppl(sym_ClassOrInterfaceType_2, (ATerm)ATmakeAppl(sym_TypeName_1, b_167), term1);
-goto label63 ;
+goto label73 ;
+q_172 = t;
+t = (ATerm) ATmakeAppl(sym_ClassOrInterfaceType_2, (ATerm)ATmakeAppl(sym_TypeName_1, p_172), term1);
+goto label74 ;
 }
-label63 :
+label74 :
 ;
-goto label61 ;
-label62 :
-t = trm131;
+goto label72 ;
+label73 :
+t = trm170;
 t = ModKey_0_0(sl_up(sl), t);
 if((t == NULL))
-goto label60 ;
+goto label71 ;
 else
-goto label61 ;
-label61 :
+goto label72 ;
+label72 :
 ;
-goto label59 ;
-label60 :
-t = trm130;
+goto label70 ;
+label71 :
+t = trm169;
 t = RewritePrimitive_0_0(sl_up(sl), t);
 if((t == NULL))
-goto label58 ;
+goto label69 ;
 else
-goto label59 ;
-label59 :
+goto label70 ;
+label70 :
 ;
-goto label57 ;
-label58 :
-t = trm129;
+goto label68 ;
+label69 :
+t = trm168;
 t = RewriteMethod_0_0(sl_up(sl), t);
 if((t == NULL))
-goto label56 ;
+goto label67 ;
 else
-goto label57 ;
-label57 :
+goto label68 ;
+label68 :
 ;
-goto label55 ;
-label56 :
-t = trm128;
+goto label66 ;
+label67 :
+t = trm167;
 t = Import_0_0(sl_up(sl), t);
 if((t == NULL))
-goto label54 ;
+goto label65 ;
 else
-goto label55 ;
-label55 :
+goto label66 ;
+label66 :
 ;
-goto label53 ;
-label54 :
-t = trm127;
+goto label64 ;
+label65 :
+t = trm166;
 {
-ATerm j_167 = NULL,k_167 = NULL;
+ATerm r_172 = NULL,s_172 = NULL;
 if(match_cons(t, sym_SimpleName_1))
 {
-j_167 = ATgetArgument(t, 0);
+r_172 = ATgetArgument(t, 0);
 }
 else
-goto label52 ;
-k_167 = t;
-t = (ATerm) ATmakeAppl(sym_Id_1, j_167);
-goto label53 ;
+goto label63 ;
+s_172 = t;
+t = (ATerm) ATmakeAppl(sym_Id_1, r_172);
+goto label64 ;
 }
-label53 :
+label64 :
 ;
-goto label51 ;
-label52 :
-t = trm126;
+goto label62 ;
+label63 :
+t = trm165;
 t = RewriteClass_0_0(sl_up(sl), t);
 if((t == NULL))
-goto label50 ;
+goto label61 ;
 else
-goto label51 ;
-label51 :
+goto label62 ;
+label62 :
 ;
-goto label49 ;
-label50 :
-t = trm125;
+goto label60 ;
+label61 :
+t = trm164;
 {
-ATerm l_167 = NULL,p_167 = NULL,q_167 = NULL,r_167 = NULL;
+ATerm t_172 = NULL,u_172 = NULL,v_172 = NULL,w_172 = NULL;
 if(match_cons(t, sym_VariableDeclarationFragment_3))
 {
-p_167 = ATgetArgument(t, 0);
-l_167 = ATgetArgument(t, 1);
-q_167 = ATgetArgument(t, 2);
+u_172 = ATgetArgument(t, 0);
+t_172 = ATgetArgument(t, 1);
+v_172 = ATgetArgument(t, 2);
 }
 else
 goto fail17 ;
-r_167 = t;
-t = (ATerm) ATmakeAppl(sym_VarDec_2, p_167, q_167);
-goto label49 ;
+w_172 = t;
+t = (ATerm) ATmakeAppl(sym_VarDec_2, u_172, v_172);
+goto label60 ;
 }
-label49 :
+label60 :
 ;
 }
 __tracing_table[--__tracing_table_counter] = NULL;
@@ -650,8 +719,8 @@
 __tracing_table[__tracing_table_counter++] = "main_0_0";
 sl_decl(sl);
 {
-struct str_closure o_168 = { &(lifted1) , &(frame) };
-StrCL lifted1_cl = &(o_168);
+struct str_closure e_173 = { &(lifted1) , &(frame) };
+StrCL lifted1_cl = &(e_173);
 t = io_wrap_1_0(sl, lifted1_cl, t);
 if((t == NULL))
 goto fail9 ;
@@ -667,16 +736,16 @@
 __tracing_table[__tracing_table_counter++] = "lifted1";
 sl_decl(sl);
 {
-struct str_closure x_167 = { &(lifted6) , &(frame) };
-StrCL lifted6_cl = &(x_167);
-struct str_closure b_168 = { &(lifted2) , &(frame) };
-StrCL lifted2_cl = &(b_168);
+struct str_closure z_172 = { &(lifted6) , &(frame) };
+StrCL lifted6_cl = &(z_172);
+struct str_closure a_173 = { &(lifted2) , &(frame) };
+StrCL lifted2_cl = &(a_173);
 t = outermost_1_0(sl_up(sl), lifted2_cl, t);
 if((t == NULL))
 goto fail10 ;
 {
-struct str_closure n_168 = { &(lifted3) , &(frame) };
-StrCL lifted3_cl = &(n_168);
+struct str_closure d_173 = { &(lifted3) , &(frame) };
+StrCL lifted3_cl = &(d_173);
 t = topdown_1_0(sl_up(sl), lifted3_cl, t);
 if((t == NULL))
 goto fail10 ;
@@ -699,8 +768,8 @@
 __tracing_table[__tracing_table_counter++] = "lifted3";
 sl_decl(sl);
 {
-struct str_closure l_168 = { &(lifted4) , &(frame) };
-StrCL lifted4_cl = &(l_168);
+struct str_closure c_173 = { &(lifted4) , &(frame) };
+StrCL lifted4_cl = &(c_173);
 t = try_1_0(sl_up(sl_up(sl)), lifted4_cl, t);
 if((t == NULL))
 goto fail14 ;
@@ -716,24 +785,24 @@
 __tracing_table[__tracing_table_counter++] = "lifted4";
 sl_decl(sl);
 {
-ATerm x_164 = NULL,y_164 = NULL,a_165 = NULL;
+ATerm p_171 = NULL,q_171 = NULL,r_171 = NULL;
 if(match_cons(t, sym_PackageName_1))
 {
-x_164 = ATgetArgument(t, 0);
+p_171 = ATgetArgument(t, 0);
 }
 else
 goto fail15 ;
-a_165 = t;
-t = x_164;
+r_171 = t;
+t = p_171;
 {
-struct str_closure g_168 = { &(RP_0_0) , sl_up(sl_up(sl_up(sl))) };
-StrCL lifted5_cl = &(g_168);
+struct str_closure b_173 = { &(RP_0_0) , sl_up(sl_up(sl_up(sl))) };
+StrCL lifted5_cl = &(b_173);
 t = outermost_1_0(sl_up(sl_up(sl_up(sl))), lifted5_cl, t);
 if((t == NULL))
 goto fail15 ;
-y_164 = t;
-t = a_165;
-t = (ATerm) ATmakeAppl(sym_PackageName_1, y_164);
+q_171 = t;
+t = r_171;
+t = (ATerm) ATmakeAppl(sym_PackageName_1, q_171);
 }
 }
 __tracing_table[--__tracing_table_counter] = NULL;
@@ -747,17 +816,17 @@
 __tracing_table[__tracing_table_counter++] = "lifted2";
 sl_decl(sl);
 {
-ATerm o_164 = NULL,q_164 = NULL,u_164 = NULL,v_164 = NULL;
+ATerm l_171 = NULL,m_171 = NULL,n_171 = NULL,o_171 = NULL;
 if(match_cons(t, sym_PackageDeclaration_3))
 {
-o_164 = ATgetArgument(t, 0);
-q_164 = ATgetArgument(t, 1);
-u_164 = ATgetArgument(t, 2);
+l_171 = ATgetArgument(t, 0);
+m_171 = ATgetArgument(t, 1);
+n_171 = ATgetArgument(t, 2);
 }
 else
 goto fail13 ;
-v_164 = t;
-t = (ATerm) ATmakeAppl(sym_Some_1, (ATerm) ATmakeAppl(sym_PackageDec_2, q_164, (ATerm) ATmakeAppl(sym_PackageName_1, u_164)));
+o_171 = t;
+t = (ATerm) ATmakeAppl(sym_Some_1, (ATerm) ATmakeAppl(sym_PackageDec_2, m_171, (ATerm) ATmakeAppl(sym_PackageName_1, n_171)));
 }
 __tracing_table[--__tracing_table_counter] = NULL;
 return(t);
@@ -770,8 +839,8 @@
 __tracing_table[__tracing_table_counter++] = "lifted6";
 sl_decl(sl);
 {
-struct str_closure w_167 = { &(lifted7) , &(frame) };
-StrCL lifted7_cl = &(w_167);
+struct str_closure y_172 = { &(lifted7) , &(frame) };
+StrCL lifted7_cl = &(y_172);
 t = try_1_0(sl_up(sl_up(sl)), lifted7_cl, t);
 if((t == NULL))
 goto fail11 ;
@@ -787,17 +856,17 @@
 __tracing_table[__tracing_table_counter++] = "lifted7";
 sl_decl(sl);
 {
-ATerm c_165 = NULL,e_165 = NULL,h_165 = NULL,m_165 = NULL;
+ATerm s_171 = NULL,t_171 = NULL,u_171 = NULL,v_171 = NULL;
 if(match_cons(t, sym_VariableDeclarationFragment_3))
 {
-e_165 = ATgetArgument(t, 0);
-c_165 = ATgetArgument(t, 1);
-h_165 = ATgetArgument(t, 2);
+t_171 = ATgetArgument(t, 0);
+s_171 = ATgetArgument(t, 1);
+u_171 = ATgetArgument(t, 2);
 }
 else
 goto fail12 ;
-m_165 = t;
-t = (ATerm) ATmakeAppl(sym_VarDec_2, e_165, h_165);
+v_171 = t;
+t = (ATerm) ATmakeAppl(sym_VarDec_2, t_171, u_171);
 }
 __tracing_table[--__tracing_table_counter] = NULL;
 return(t);
@@ -810,90 +879,90 @@
 __tracing_table[__tracing_table_counter++] = "Stm_0_0";
 sl_decl(sl);
 {
-ATerm trm116 = t;
-ATerm u_22 = NULL,v_22 = NULL,w_22 = NULL;
+ATerm trm155 = t;
+ATerm u_24 = NULL,v_24 = NULL,w_24 = NULL;
 if(match_cons(t, sym_ExprStm_1))
 {
-ATerm trm117 = ATgetArgument(t, 0);
-if(match_cons(trm117, sym_Assignment_3))
+ATerm trm156 = ATgetArgument(t, 0);
+if(match_cons(trm156, sym_Assignment_3))
 {
-ATerm trm118 = ATgetArgument(trm117, 0);
-if(match_cons(trm118, sym_AssignmentOperator_1))
+ATerm trm157 = ATgetArgument(trm156, 0);
+if(match_cons(trm157, sym_AssignmentOperator_1))
 {
-ATerm trm119 = ATgetArgument(trm118, 0);
-if(!((ATgetSymbol(trm119) == ATmakeSymbol("=", 0, ATtrue))))
-goto label47 ;
+ATerm trm158 = ATgetArgument(trm157, 0);
+if(!((ATgetSymbol(trm158) == ATmakeSymbol("=", 0, ATtrue))))
+goto label58 ;
 }
 else
-goto label47 ;
-u_22 = ATgetArgument(trm117, 1);
-v_22 = ATgetArgument(trm117, 2);
+goto label58 ;
+u_24 = ATgetArgument(trm156, 1);
+v_24 = ATgetArgument(trm156, 2);
 }
 else
-goto label47 ;
+goto label58 ;
 }
 else
-goto label47 ;
-w_22 = t;
-t = (ATerm) ATmakeAppl(sym_ExprStm_1, (ATerm) ATmakeAppl(sym_Assign_2, (ATerm)ATmakeAppl(sym_ExprName_1, u_22), v_22));
-goto label46 ;
-label47 :
-t = trm116;
+goto label58 ;
+w_24 = t;
+t = (ATerm) ATmakeAppl(sym_ExprStm_1, (ATerm) ATmakeAppl(sym_Assign_2, (ATerm)ATmakeAppl(sym_ExprName_1, u_24), v_24));
+goto label57 ;
+label58 :
+t = trm155;
 {
-ATerm trm120 = t;
-ATerm p_22 = NULL,q_22 = NULL,r_22 = NULL,s_22 = NULL,t_22 = NULL;
+ATerm trm159 = t;
+ATerm p_24 = NULL,q_24 = NULL,r_24 = NULL,s_24 = NULL,t_24 = NULL;
 if(match_cons(t, sym_VariableDeclarationStatement_3))
 {
-p_22 = ATgetArgument(t, 0);
-q_22 = ATgetArgument(t, 1);
+p_24 = ATgetArgument(t, 0);
+q_24 = ATgetArgument(t, 1);
 {
-ATerm trm121 = ATgetArgument(t, 2);
-if(((ATgetType(trm121) == AT_LIST) && !(ATisEmpty(trm121))))
+ATerm trm160 = ATgetArgument(t, 2);
+if(((ATgetType(trm160) == AT_LIST) && !(ATisEmpty(trm160))))
 {
-ATerm trm122 = ATgetFirst((ATermList) trm121);
-if(match_cons(trm122, sym_VariableDeclarationFragment_3))
+ATerm trm161 = ATgetFirst((ATermList) trm160);
+if(match_cons(trm161, sym_VariableDeclarationFragment_3))
 {
-r_22 = ATgetArgument(trm122, 0);
+r_24 = ATgetArgument(trm161, 0);
 {
-ATerm trm123 = ATgetArgument(trm122, 1);
-if(!(((ATgetType(trm123) == AT_INT) && (ATgetInt((ATermInt) trm123) == 0))))
-goto label48 ;
+ATerm trm162 = ATgetArgument(trm161, 1);
+if(!(((ATgetType(trm162) == AT_INT) && (ATgetInt((ATermInt) trm162) == 0))))
+goto label59 ;
 }
-s_22 = ATgetArgument(trm122, 2);
+s_24 = ATgetArgument(trm161, 2);
 }
 else
-goto label48 ;
+goto label59 ;
 {
-ATerm trm124 = (ATerm) ATgetNext((ATermList) trm121);
-if(!(((ATgetType(trm124) == AT_LIST) && ATisEmpty(trm124))))
-goto label48 ;
+ATerm trm163 = (ATerm) ATgetNext((ATermList) trm160);
+if(!(((ATgetType(trm163) == AT_LIST) && ATisEmpty(trm163))))
+goto label59 ;
 }
 }
 else
-goto label48 ;
+goto label59 ;
 }
 }
 else
-goto label48 ;
-t_22 = t;
-t = (ATerm) ATmakeAppl(sym_LocalVarDecStm_1, (ATerm) ATmakeAppl(sym_LocalVarDec_3, p_22, q_22, (ATerm) ATinsert(ATempty, (ATerm) ATmakeAppl(sym_VarDec_2, r_22, s_22))));
-goto label46 ;
-label48 :
-t = trm120;
+goto label59 ;
+t_24 = t;
+t = (ATerm) ATmakeAppl(sym_LocalVarDecStm_1, (ATerm) ATmakeAppl(sym_LocalVarDec_3, p_24, q_24, (ATerm) ATinsert(ATempty, (ATerm) ATmakeAppl(sym_VarDec_2, r_24, s_24))));
+goto label57 ;
+label59 :
+t = trm159;
 {
-ATerm n_22 = NULL,o_22 = NULL;
+ATerm n_24 = NULL,o_24 = NULL;
 if(match_cons(t, sym_ReturnStatement_1))
 {
-n_22 = ATgetArgument(t, 0);
+n_24 = ATgetArgument(t, 0);
 }
 else
 goto fail8 ;
-o_22 = t;
-t = (ATerm) ATmakeAppl(sym_Return_1, (ATerm) ATmakeAppl(sym_Some_1, n_22));
-goto label46 ;
+o_24 = t;
+t = (ATerm) ATmakeAppl(sym_Return_1, (ATerm) ATmakeAppl(sym_Some_1, n_24));
+goto label57 ;
 }
 }
-label46 :
+label57 :
 ;
 }
 __tracing_table[--__tracing_table_counter] = NULL;
@@ -907,58 +976,58 @@
 __tracing_table[__tracing_table_counter++] = "ModKey_0_0";
 sl_decl(sl);
 {
-ATerm trm108 = t;
-ATerm e_22 = NULL;
+ATerm trm147 = t;
+ATerm e_24 = NULL;
 if(match_cons(t, sym_Modifier_1))
 {
-ATerm trm109 = ATgetArgument(t, 0);
-if(match_cons(trm109, sym_ModifierKeyword_1))
+ATerm trm148 = ATgetArgument(t, 0);
+if(match_cons(trm148, sym_ModifierKeyword_1))
 {
-ATerm trm110 = ATgetArgument(trm109, 0);
-if(!(((ATgetType(trm110) == AT_INT) && (ATgetInt((ATermInt) trm110) == 1))))
-goto label44 ;
+ATerm trm149 = ATgetArgument(trm148, 0);
+if(!(((ATgetType(trm149) == AT_INT) && (ATgetInt((ATermInt) trm149) == 1))))
+goto label55 ;
 }
 else
-goto label44 ;
+goto label55 ;
 }
 else
-goto label44 ;
-e_22 = t;
+goto label55 ;
+e_24 = t;
 t = term21;
-goto label43 ;
-label44 :
-t = trm108;
+goto label54 ;
+label55 :
+t = trm147;
 {
-ATerm trm111 = t;
-ATerm d_22 = NULL;
+ATerm trm150 = t;
+ATerm d_24 = NULL;
 if(match_cons(t, sym_Modifier_1))
 {
-ATerm trm112 = ATgetArgument(t, 0);
-if(match_cons(trm112, sym_ModifierKeyword_1))
+ATerm trm151 = ATgetArgument(t, 0);
+if(match_cons(trm151, sym_ModifierKeyword_1))
 {
-ATerm trm113 = ATgetArgument(trm112, 0);
-if(!(((ATgetType(trm113) == AT_INT) && (ATgetInt((ATermInt) trm113) == 2))))
-goto label45 ;
+ATerm trm152 = ATgetArgument(trm151, 0);
+if(!(((ATgetType(trm152) == AT_INT) && (ATgetInt((ATermInt) trm152) == 2))))
+goto label56 ;
 }
 else
-goto label45 ;
+goto label56 ;
 }
 else
-goto label45 ;
-d_22 = t;
+goto label56 ;
+d_24 = t;
 t = term23;
-goto label43 ;
-label45 :
-t = trm111;
+goto label54 ;
+label56 :
+t = trm150;
 {
-ATerm c_22 = NULL;
+ATerm c_24 = NULL;
 if(match_cons(t, sym_Modifier_1))
 {
-ATerm trm114 = ATgetArgument(t, 0);
-if(match_cons(trm114, sym_ModifierKeyword_1))
+ATerm trm153 = ATgetArgument(t, 0);
+if(match_cons(trm153, sym_ModifierKeyword_1))
 {
-ATerm trm115 = ATgetArgument(trm114, 0);
-if(!(((ATgetType(trm115) == AT_INT) && (ATgetInt((ATermInt) trm115) == 8))))
+ATerm trm154 = ATgetArgument(trm153, 0);
+if(!(((ATgetType(trm154) == AT_INT) && (ATgetInt((ATermInt) trm154) == 8))))
 goto fail7 ;
 }
 else
@@ -966,12 +1035,12 @@
 }
 else
 goto fail7 ;
-c_22 = t;
+c_24 = t;
 t = term25;
-goto label43 ;
+goto label54 ;
 }
 }
-label43 :
+label54 :
 ;
 }
 __tracing_table[--__tracing_table_counter] = NULL;
@@ -985,97 +1054,97 @@
 __tracing_table[__tracing_table_counter++] = "RewriteMethod_0_0";
 sl_decl(sl);
 {
-ATerm trm98 = t;
-ATerm u_21 = NULL,v_21 = NULL,w_21 = NULL,x_21 = NULL,y_21 = NULL,z_21 = NULL,a_22 = NULL,b_22 = NULL;
+ATerm trm137 = t;
+ATerm u_23 = NULL,v_23 = NULL,w_23 = NULL,x_23 = NULL,y_23 = NULL,z_23 = NULL,a_24 = NULL,b_24 = NULL;
 if(match_cons(t, sym_MethodDeclaration_8))
 {
-u_21 = ATgetArgument(t, 0);
-w_21 = ATgetArgument(t, 1);
-x_21 = ATgetArgument(t, 2);
-v_21 = ATgetArgument(t, 3);
-y_21 = ATgetArgument(t, 4);
-z_21 = ATgetArgument(t, 5);
+u_23 = ATgetArgument(t, 0);
+w_23 = ATgetArgument(t, 1);
+x_23 = ATgetArgument(t, 2);
+v_23 = ATgetArgument(t, 3);
+y_23 = ATgetArgument(t, 4);
+z_23 = ATgetArgument(t, 5);
 {
-ATerm trm99 = ATgetArgument(t, 6);
-if(!(((ATgetType(trm99) == AT_LIST) && ATisEmpty(trm99))))
-goto label41 ;
+ATerm trm138 = ATgetArgument(t, 6);
+if(!(((ATgetType(trm138) == AT_LIST) && ATisEmpty(trm138))))
+goto label52 ;
 }
-a_22 = ATgetArgument(t, 7);
+a_24 = ATgetArgument(t, 7);
 }
 else
-goto label41 ;
-b_22 = t;
-t = (ATerm) ATmakeAppl(sym_MethodDec_2, (ATerm)ATmakeAppl(sym_MethodDecHead_6, w_21, term1, x_21, y_21, z_21, term1), a_22);
-goto label40 ;
-label41 :

(1948 diff lines omitted)


From mdjonge at xs4all.nl  Tue Jun 30 16:54:54 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Tue, 30 Jun 2009 14:54:54 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19602 - MaartjeDeJonge
	- sglr-recovery/trunk/Evaluation_Recovery/Language_Files
Message-ID: <200906301453.n5UErQFH023532@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-30 14:54:54 +0000 (Tue, 30 Jun 2009)
New Revision: 19602

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19602&view=rev

Modified:
   sglr-recovery/trunk/Evaluation_Recovery/Language_Files/JdtToJava15
   sglr-recovery/trunk/Evaluation_Recovery/Language_Files/JdtToJava15.c
   sglr-recovery/trunk/Evaluation_Recovery/Language_Files/JdtTransformRules.str
   sglr-recovery/trunk/Evaluation_Recovery/Language_Files/jdt.str

Log:
fix transform for jdt-recovered files

Changes (first 1000 lines of the diffs):

Modified: sglr-recovery/trunk/Evaluation_Recovery/Language_Files/JdtToJava15
===================================================================
(Binary files differ)

Modified: sglr-recovery/trunk/Evaluation_Recovery/Language_Files/JdtToJava15.c
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Language_Files/JdtToJava15.c	2009-06-30 14:45:58 UTC (rev 19601)
+++ sglr-recovery/trunk/Evaluation_Recovery/Language_Files/JdtToJava15.c	2009-06-30 14:54:54 UTC (rev 19602)
@@ -67,6 +67,7 @@
 static Symbol sym_Void_0;
 static Symbol sym_Param_3;
 static Symbol sym_ThrowsDec_1;
+static Symbol sym_InstanceInit_1;
 static Symbol sym_ConstrDec_2;
 static Symbol sym_ConstrDecHead_5;
 static Symbol sym_ConstrBody_2;
@@ -84,6 +85,7 @@
 static Symbol sym_Cons_2;
 static Symbol sym_None_0;
 static Symbol sym_Some_1;
+static Symbol sym_EmptyStatement_0;
 static Symbol sym_BreakStatement_1;
 static Symbol sym_SwitchCase_1;
 static Symbol sym_SwitchStatement_2;
@@ -258,6 +260,8 @@
 ATprotectSymbol(sym_Param_3);
 sym_ThrowsDec_1 = ATmakeSymbol("ThrowsDec", 1, ATfalse);
 ATprotectSymbol(sym_ThrowsDec_1);
+sym_InstanceInit_1 = ATmakeSymbol("InstanceInit", 1, ATfalse);
+ATprotectSymbol(sym_InstanceInit_1);
 sym_ConstrDec_2 = ATmakeSymbol("ConstrDec", 2, ATfalse);
 ATprotectSymbol(sym_ConstrDec_2);
 sym_ConstrDecHead_5 = ATmakeSymbol("ConstrDecHead", 5, ATfalse);
@@ -292,6 +296,8 @@
 ATprotectSymbol(sym_None_0);
 sym_Some_1 = ATmakeSymbol("Some", 1, ATfalse);
 ATprotectSymbol(sym_Some_1);
+sym_EmptyStatement_0 = ATmakeSymbol("EmptyStatement", 0, ATfalse);
+ATprotectSymbol(sym_EmptyStatement_0);
 sym_BreakStatement_1 = ATmakeSymbol("BreakStatement", 1, ATfalse);
 ATprotectSymbol(sym_BreakStatement_1);
 sym_SwitchCase_1 = ATmakeSymbol("SwitchCase", 1, ATfalse);
@@ -381,6 +387,8 @@
 sym_SimpleName_1 = ATmakeSymbol("SimpleName", 1, ATfalse);
 ATprotectSymbol(sym_SimpleName_1);
 }
+static ATerm term27;
+static ATerm term26;
 static ATerm term25;
 static ATerm term24;
 static ATerm term23;
@@ -442,35 +450,39 @@
 ATprotect(&(term15));
 term15 = term14;
 ATprotect(&(term16));
-term16 = (ATerm) ATmakeAppl(sym_Int_0);
+term16 = (ATerm) ATmakeAppl(sym_Block_1, (ATerm) ATempty);
 ATprotect(&(term17));
 term17 = term16;
 ATprotect(&(term18));
-term18 = (ATerm) ATmakeAppl(sym_Void_0);
+term18 = (ATerm) ATmakeAppl(sym_Int_0);
 ATprotect(&(term19));
 term19 = term18;
 ATprotect(&(term20));
-term20 = (ATerm) ATmakeAppl(sym_Public_0);
+term20 = (ATerm) ATmakeAppl(sym_Void_0);
 ATprotect(&(term21));
 term21 = term20;
 ATprotect(&(term22));
-term22 = (ATerm) ATmakeAppl(sym_Private_0);
+term22 = (ATerm) ATmakeAppl(sym_Public_0);
 ATprotect(&(term23));
 term23 = term22;
 ATprotect(&(term24));
-term24 = (ATerm) ATmakeAppl(sym_Static_0);
+term24 = (ATerm) ATmakeAppl(sym_Private_0);
 ATprotect(&(term25));
 term25 = term24;
+ATprotect(&(term26));
+term26 = (ATerm) ATmakeAppl(sym_Static_0);
+ATprotect(&(term27));
+term27 = term26;
 }
 #include <srts/init-stratego-application.h>
 extern const char * __tracing_table [];
 extern unsigned short __tracing_table_counter;
 ATerm conc_0_0 (StrSL sl, ATerm t);
-ATerm map_1_0 (StrSL sl, StrCL q_90, ATerm t);
-ATerm try_1_0 (StrSL sl, StrCL e_66, ATerm t);
-ATerm topdown_1_0 (StrSL sl, StrCL g_59, ATerm t);
-ATerm outermost_1_0 (StrSL sl, StrCL c_58, ATerm t);
-ATerm io_wrap_1_0 (StrSL sl, StrCL y_49, ATerm t);
+ATerm map_1_0 (StrSL sl, StrCL k_91, ATerm t);
+ATerm try_1_0 (StrSL sl, StrCL n_66, ATerm t);
+ATerm topdown_1_0 (StrSL sl, StrCL p_59, ATerm t);
+ATerm outermost_1_0 (StrSL sl, StrCL l_58, ATerm t);
+ATerm io_wrap_1_0 (StrSL sl, StrCL h_50, ATerm t);
 static ATerm lifted8 (StrSL sl, ATerm t);
 ATerm rewriteAst_0_0 (StrSL sl, ATerm t);
 static ATerm lifted4 (StrSL sl, ATerm t);
@@ -494,8 +506,8 @@
 __tracing_table[__tracing_table_counter++] = "rewriteAst_0_0";
 sl_decl(sl);
 {
-struct str_closure f_173 = { &(lifted8) , &(frame) };
-StrCL lifted8_cl = &(f_173);
+struct str_closure p_173 = { &(lifted8) , &(frame) };
+StrCL lifted8_cl = &(p_173);
 t = outermost_1_0(sl, lifted8_cl, t);
 if((t == NULL))
 goto fail16 ;
@@ -511,11 +523,6 @@
 __tracing_table[__tracing_table_counter++] = "lifted8";
 sl_decl(sl);
 {
-ATerm trm164 = t;
-ATerm trm165 = t;
-ATerm trm166 = t;
-ATerm trm167 = t;
-ATerm trm168 = t;
 ATerm trm169 = t;
 ATerm trm170 = t;
 ATerm trm171 = t;
@@ -523,189 +530,194 @@
 ATerm trm173 = t;
 ATerm trm174 = t;
 ATerm trm175 = t;
+ATerm trm176 = t;
+ATerm trm177 = t;
+ATerm trm178 = t;
+ATerm trm179 = t;
+ATerm trm180 = t;
 t = T_0_0(sl_up(sl), t);
 if((t == NULL))
-goto label83 ;
-goto label82 ;
-label83 :
-t = trm175;
+goto label86 ;
+goto label85 ;
+label86 :
+t = trm180;
 {
-ATerm h_172 = NULL,i_172 = NULL;
+ATerm q_172 = NULL,r_172 = NULL;
 if(match_cons(t, sym_VarDec_2))
 {
-h_172 = ATgetArgument(t, 0);
+q_172 = ATgetArgument(t, 0);
 {
-ATerm trm176 = ATgetArgument(t, 1);
-if(!(match_cons(trm176, sym_None_0)))
-goto label81 ;
+ATerm trm181 = ATgetArgument(t, 1);
+if(!(match_cons(trm181, sym_None_0)))
+goto label84 ;
 }
 }
 else
-goto label81 ;
-i_172 = t;
-t = (ATerm) ATmakeAppl(sym_VarDec_1, h_172);
-goto label82 ;
+goto label84 ;
+r_172 = t;
+t = (ATerm) ATmakeAppl(sym_VarDec_1, q_172);
+goto label85 ;
 }
-label82 :
+label85 :
 ;
-goto label80 ;
-label81 :
-t = trm174;
+goto label83 ;
+label84 :
+t = trm179;
 t = Stm_0_0(sl_up(sl), t);
 if((t == NULL))
-goto label79 ;
+goto label82 ;
 else
-goto label80 ;
-label80 :
+goto label83 ;
+label83 :
 ;
-goto label78 ;
-label79 :
-t = trm173;
+goto label81 ;
+label82 :
+t = trm178;
 {
-ATerm j_172 = NULL,k_172 = NULL;
+ATerm s_172 = NULL,t_172 = NULL;
 if(match_cons(t, sym_NumberLiteral_1))
 {
-j_172 = ATgetArgument(t, 0);
+s_172 = ATgetArgument(t, 0);
 }
 else
-goto label77 ;
-k_172 = t;
-t = (ATerm) ATmakeAppl(sym_Lit_1, (ATerm) ATmakeAppl(sym_Deci_1, j_172));
-goto label78 ;
+goto label80 ;
+t_172 = t;
+t = (ATerm) ATmakeAppl(sym_Lit_1, (ATerm) ATmakeAppl(sym_Deci_1, s_172));
+goto label81 ;
 }
-label78 :
+label81 :
 ;
-goto label76 ;
-label77 :
-t = trm172;
+goto label79 ;
+label80 :
+t = trm177;
 {
-ATerm l_172 = NULL,m_172 = NULL,n_172 = NULL,o_172 = NULL;
+ATerm u_172 = NULL,v_172 = NULL,w_172 = NULL,x_172 = NULL;
 if(match_cons(t, sym_SingleVariableDeclaration_5))
 {
-l_172 = ATgetArgument(t, 0);
-m_172 = ATgetArgument(t, 1);
-n_172 = ATgetArgument(t, 2);
+u_172 = ATgetArgument(t, 0);
+v_172 = ATgetArgument(t, 1);
+w_172 = ATgetArgument(t, 2);
 {
-ATerm trm177 = ATgetArgument(t, 3);
-if(!(((ATgetType(trm177) == AT_INT) && (ATgetInt((ATermInt) trm177) == 0))))
-goto label75 ;
+ATerm trm182 = ATgetArgument(t, 3);
+if(!(((ATgetType(trm182) == AT_INT) && (ATgetInt((ATermInt) trm182) == 0))))
+goto label78 ;
 }
 {
-ATerm trm178 = ATgetArgument(t, 4);
-if(!(match_cons(trm178, sym_None_0)))
-goto label75 ;
+ATerm trm183 = ATgetArgument(t, 4);
+if(!(match_cons(trm183, sym_None_0)))
+goto label78 ;
 }
 }
 else
-goto label75 ;
-o_172 = t;
-t = (ATerm) ATmakeAppl(sym_Param_3, l_172, m_172, n_172);
-goto label76 ;
+goto label78 ;
+x_172 = t;
+t = (ATerm) ATmakeAppl(sym_Param_3, u_172, v_172, w_172);
+goto label79 ;
 }
-label76 :
+label79 :
 ;
-goto label74 ;
-label75 :
-t = trm171;
+goto label77 ;
+label78 :
+t = trm176;
 {
-ATerm p_172 = NULL,q_172 = NULL;
+ATerm y_172 = NULL,z_172 = NULL;
 if(match_cons(t, sym_SimpleType_1))
 {
-p_172 = ATgetArgument(t, 0);
+y_172 = ATgetArgument(t, 0);
 }
 else
-goto label73 ;
-q_172 = t;
-t = (ATerm) ATmakeAppl(sym_ClassOrInterfaceType_2, (ATerm)ATmakeAppl(sym_TypeName_1, p_172), term1);
-goto label74 ;
+goto label76 ;
+z_172 = t;
+t = (ATerm) ATmakeAppl(sym_ClassOrInterfaceType_2, (ATerm)ATmakeAppl(sym_TypeName_1, y_172), term1);
+goto label77 ;
 }
-label74 :
+label77 :
 ;
-goto label72 ;
-label73 :
-t = trm170;
+goto label75 ;
+label76 :
+t = trm175;
 t = ModKey_0_0(sl_up(sl), t);
 if((t == NULL))
-goto label71 ;
+goto label74 ;
 else
-goto label72 ;
-label72 :
+goto label75 ;
+label75 :
 ;
-goto label70 ;
-label71 :
-t = trm169;
+goto label73 ;
+label74 :
+t = trm174;
 t = RewritePrimitive_0_0(sl_up(sl), t);
 if((t == NULL))
-goto label69 ;
+goto label72 ;
 else
-goto label70 ;
-label70 :
+goto label73 ;
+label73 :
 ;
-goto label68 ;
-label69 :
-t = trm168;
+goto label71 ;
+label72 :
+t = trm173;
 t = RewriteMethod_0_0(sl_up(sl), t);
 if((t == NULL))
-goto label67 ;
+goto label70 ;
 else
-goto label68 ;
-label68 :
+goto label71 ;
+label71 :
 ;
-goto label66 ;
-label67 :
-t = trm167;
+goto label69 ;
+label70 :
+t = trm172;
 t = Import_0_0(sl_up(sl), t);
 if((t == NULL))
-goto label65 ;
+goto label68 ;
 else
-goto label66 ;
-label66 :
+goto label69 ;
+label69 :
 ;
-goto label64 ;
-label65 :
-t = trm166;
+goto label67 ;
+label68 :
+t = trm171;
 {
-ATerm r_172 = NULL,s_172 = NULL;
+ATerm a_173 = NULL,b_173 = NULL;
 if(match_cons(t, sym_SimpleName_1))
 {
-r_172 = ATgetArgument(t, 0);
+a_173 = ATgetArgument(t, 0);
 }
 else
-goto label63 ;
-s_172 = t;
-t = (ATerm) ATmakeAppl(sym_Id_1, r_172);
-goto label64 ;
+goto label66 ;
+b_173 = t;
+t = (ATerm) ATmakeAppl(sym_Id_1, a_173);
+goto label67 ;
 }
-label64 :
+label67 :
 ;
-goto label62 ;
-label63 :
-t = trm165;
+goto label65 ;
+label66 :
+t = trm170;
 t = RewriteClass_0_0(sl_up(sl), t);
 if((t == NULL))
-goto label61 ;
+goto label64 ;
 else
-goto label62 ;
-label62 :
+goto label65 ;
+label65 :
 ;
-goto label60 ;
-label61 :
-t = trm164;
+goto label63 ;
+label64 :
+t = trm169;
 {
-ATerm t_172 = NULL,u_172 = NULL,v_172 = NULL,w_172 = NULL;
+ATerm c_173 = NULL,d_173 = NULL,e_173 = NULL,f_173 = NULL;
 if(match_cons(t, sym_VariableDeclarationFragment_3))
 {
-u_172 = ATgetArgument(t, 0);
-t_172 = ATgetArgument(t, 1);
-v_172 = ATgetArgument(t, 2);
+d_173 = ATgetArgument(t, 0);
+c_173 = ATgetArgument(t, 1);
+e_173 = ATgetArgument(t, 2);
 }
 else
 goto fail17 ;
-w_172 = t;
-t = (ATerm) ATmakeAppl(sym_VarDec_2, u_172, v_172);
-goto label60 ;
+f_173 = t;
+t = (ATerm) ATmakeAppl(sym_VarDec_2, d_173, e_173);
+goto label63 ;
 }
-label60 :
+label63 :
 ;
 }
 __tracing_table[--__tracing_table_counter] = NULL;
@@ -719,8 +731,8 @@
 __tracing_table[__tracing_table_counter++] = "main_0_0";
 sl_decl(sl);
 {
-struct str_closure e_173 = { &(lifted1) , &(frame) };
-StrCL lifted1_cl = &(e_173);
+struct str_closure o_173 = { &(lifted1) , &(frame) };
+StrCL lifted1_cl = &(o_173);
 t = io_wrap_1_0(sl, lifted1_cl, t);
 if((t == NULL))
 goto fail9 ;
@@ -736,16 +748,16 @@
 __tracing_table[__tracing_table_counter++] = "lifted1";
 sl_decl(sl);
 {
-struct str_closure z_172 = { &(lifted6) , &(frame) };
-StrCL lifted6_cl = &(z_172);
-struct str_closure a_173 = { &(lifted2) , &(frame) };
-StrCL lifted2_cl = &(a_173);
+struct str_closure j_173 = { &(lifted6) , &(frame) };
+StrCL lifted6_cl = &(j_173);
+struct str_closure k_173 = { &(lifted2) , &(frame) };
+StrCL lifted2_cl = &(k_173);
 t = outermost_1_0(sl_up(sl), lifted2_cl, t);
 if((t == NULL))
 goto fail10 ;
 {
-struct str_closure d_173 = { &(lifted3) , &(frame) };
-StrCL lifted3_cl = &(d_173);
+struct str_closure n_173 = { &(lifted3) , &(frame) };
+StrCL lifted3_cl = &(n_173);
 t = topdown_1_0(sl_up(sl), lifted3_cl, t);
 if((t == NULL))
 goto fail10 ;
@@ -768,8 +780,8 @@
 __tracing_table[__tracing_table_counter++] = "lifted3";
 sl_decl(sl);
 {
-struct str_closure c_173 = { &(lifted4) , &(frame) };
-StrCL lifted4_cl = &(c_173);
+struct str_closure m_173 = { &(lifted4) , &(frame) };
+StrCL lifted4_cl = &(m_173);
 t = try_1_0(sl_up(sl_up(sl)), lifted4_cl, t);
 if((t == NULL))
 goto fail14 ;
@@ -785,24 +797,24 @@
 __tracing_table[__tracing_table_counter++] = "lifted4";
 sl_decl(sl);
 {
-ATerm p_171 = NULL,q_171 = NULL,r_171 = NULL;
+ATerm y_171 = NULL,z_171 = NULL,a_172 = NULL;
 if(match_cons(t, sym_PackageName_1))
 {
-p_171 = ATgetArgument(t, 0);
+y_171 = ATgetArgument(t, 0);
 }
 else
 goto fail15 ;
-r_171 = t;
-t = p_171;
+a_172 = t;
+t = y_171;
 {
-struct str_closure b_173 = { &(RP_0_0) , sl_up(sl_up(sl_up(sl))) };
-StrCL lifted5_cl = &(b_173);
+struct str_closure l_173 = { &(RP_0_0) , sl_up(sl_up(sl_up(sl))) };
+StrCL lifted5_cl = &(l_173);
 t = outermost_1_0(sl_up(sl_up(sl_up(sl))), lifted5_cl, t);
 if((t == NULL))
 goto fail15 ;
-q_171 = t;
-t = r_171;
-t = (ATerm) ATmakeAppl(sym_PackageName_1, q_171);
+z_171 = t;
+t = a_172;
+t = (ATerm) ATmakeAppl(sym_PackageName_1, z_171);
 }
 }
 __tracing_table[--__tracing_table_counter] = NULL;
@@ -816,17 +828,17 @@
 __tracing_table[__tracing_table_counter++] = "lifted2";
 sl_decl(sl);
 {
-ATerm l_171 = NULL,m_171 = NULL,n_171 = NULL,o_171 = NULL;
+ATerm u_171 = NULL,v_171 = NULL,w_171 = NULL,x_171 = NULL;
 if(match_cons(t, sym_PackageDeclaration_3))
 {
-l_171 = ATgetArgument(t, 0);
-m_171 = ATgetArgument(t, 1);
-n_171 = ATgetArgument(t, 2);
+u_171 = ATgetArgument(t, 0);
+v_171 = ATgetArgument(t, 1);
+w_171 = ATgetArgument(t, 2);
 }
 else
 goto fail13 ;
-o_171 = t;
-t = (ATerm) ATmakeAppl(sym_Some_1, (ATerm) ATmakeAppl(sym_PackageDec_2, m_171, (ATerm) ATmakeAppl(sym_PackageName_1, n_171)));
+x_171 = t;
+t = (ATerm) ATmakeAppl(sym_Some_1, (ATerm) ATmakeAppl(sym_PackageDec_2, v_171, (ATerm) ATmakeAppl(sym_PackageName_1, w_171)));
 }
 __tracing_table[--__tracing_table_counter] = NULL;
 return(t);
@@ -839,8 +851,8 @@
 __tracing_table[__tracing_table_counter++] = "lifted6";
 sl_decl(sl);
 {
-struct str_closure y_172 = { &(lifted7) , &(frame) };
-StrCL lifted7_cl = &(y_172);
+struct str_closure i_173 = { &(lifted7) , &(frame) };
+StrCL lifted7_cl = &(i_173);
 t = try_1_0(sl_up(sl_up(sl)), lifted7_cl, t);
 if((t == NULL))
 goto fail11 ;
@@ -856,17 +868,17 @@
 __tracing_table[__tracing_table_counter++] = "lifted7";
 sl_decl(sl);
 {
-ATerm s_171 = NULL,t_171 = NULL,u_171 = NULL,v_171 = NULL;
+ATerm b_172 = NULL,c_172 = NULL,d_172 = NULL,e_172 = NULL;
 if(match_cons(t, sym_VariableDeclarationFragment_3))
 {
-t_171 = ATgetArgument(t, 0);
-s_171 = ATgetArgument(t, 1);
-u_171 = ATgetArgument(t, 2);
+c_172 = ATgetArgument(t, 0);
+b_172 = ATgetArgument(t, 1);
+d_172 = ATgetArgument(t, 2);
 }
 else
 goto fail12 ;
-v_171 = t;
-t = (ATerm) ATmakeAppl(sym_VarDec_2, t_171, u_171);
+e_172 = t;
+t = (ATerm) ATmakeAppl(sym_VarDec_2, c_172, d_172);
 }
 __tracing_table[--__tracing_table_counter] = NULL;
 return(t);
@@ -879,90 +891,90 @@
 __tracing_table[__tracing_table_counter++] = "Stm_0_0";
 sl_decl(sl);
 {
-ATerm trm155 = t;
-ATerm u_24 = NULL,v_24 = NULL,w_24 = NULL;
+ATerm trm160 = t;
+ATerm d_25 = NULL,e_25 = NULL,f_25 = NULL;
 if(match_cons(t, sym_ExprStm_1))
 {
-ATerm trm156 = ATgetArgument(t, 0);
-if(match_cons(trm156, sym_Assignment_3))
+ATerm trm161 = ATgetArgument(t, 0);
+if(match_cons(trm161, sym_Assignment_3))
 {
-ATerm trm157 = ATgetArgument(trm156, 0);
-if(match_cons(trm157, sym_AssignmentOperator_1))
+ATerm trm162 = ATgetArgument(trm161, 0);
+if(match_cons(trm162, sym_AssignmentOperator_1))
 {
-ATerm trm158 = ATgetArgument(trm157, 0);
-if(!((ATgetSymbol(trm158) == ATmakeSymbol("=", 0, ATtrue))))
-goto label58 ;
+ATerm trm163 = ATgetArgument(trm162, 0);
+if(!((ATgetSymbol(trm163) == ATmakeSymbol("=", 0, ATtrue))))
+goto label61 ;
 }
 else
-goto label58 ;
-u_24 = ATgetArgument(trm156, 1);
-v_24 = ATgetArgument(trm156, 2);
+goto label61 ;
+d_25 = ATgetArgument(trm161, 1);
+e_25 = ATgetArgument(trm161, 2);
 }
 else
-goto label58 ;
+goto label61 ;
 }
 else
-goto label58 ;
-w_24 = t;
-t = (ATerm) ATmakeAppl(sym_ExprStm_1, (ATerm) ATmakeAppl(sym_Assign_2, (ATerm)ATmakeAppl(sym_ExprName_1, u_24), v_24));
-goto label57 ;
-label58 :
-t = trm155;
+goto label61 ;
+f_25 = t;
+t = (ATerm) ATmakeAppl(sym_ExprStm_1, (ATerm) ATmakeAppl(sym_Assign_2, (ATerm)ATmakeAppl(sym_ExprName_1, d_25), e_25));
+goto label60 ;
+label61 :
+t = trm160;
 {
-ATerm trm159 = t;
-ATerm p_24 = NULL,q_24 = NULL,r_24 = NULL,s_24 = NULL,t_24 = NULL;
+ATerm trm164 = t;
+ATerm y_24 = NULL,z_24 = NULL,a_25 = NULL,b_25 = NULL,c_25 = NULL;
 if(match_cons(t, sym_VariableDeclarationStatement_3))
 {
-p_24 = ATgetArgument(t, 0);
-q_24 = ATgetArgument(t, 1);
+y_24 = ATgetArgument(t, 0);
+z_24 = ATgetArgument(t, 1);
 {
-ATerm trm160 = ATgetArgument(t, 2);
-if(((ATgetType(trm160) == AT_LIST) && !(ATisEmpty(trm160))))
+ATerm trm165 = ATgetArgument(t, 2);
+if(((ATgetType(trm165) == AT_LIST) && !(ATisEmpty(trm165))))
 {
-ATerm trm161 = ATgetFirst((ATermList) trm160);
-if(match_cons(trm161, sym_VariableDeclarationFragment_3))
+ATerm trm166 = ATgetFirst((ATermList) trm165);
+if(match_cons(trm166, sym_VariableDeclarationFragment_3))
 {
-r_24 = ATgetArgument(trm161, 0);
+a_25 = ATgetArgument(trm166, 0);
 {
-ATerm trm162 = ATgetArgument(trm161, 1);
-if(!(((ATgetType(trm162) == AT_INT) && (ATgetInt((ATermInt) trm162) == 0))))
-goto label59 ;
+ATerm trm167 = ATgetArgument(trm166, 1);
+if(!(((ATgetType(trm167) == AT_INT) && (ATgetInt((ATermInt) trm167) == 0))))
+goto label62 ;
 }
-s_24 = ATgetArgument(trm161, 2);
+b_25 = ATgetArgument(trm166, 2);
 }
 else
-goto label59 ;
+goto label62 ;
 {
-ATerm trm163 = (ATerm) ATgetNext((ATermList) trm160);
-if(!(((ATgetType(trm163) == AT_LIST) && ATisEmpty(trm163))))
-goto label59 ;
+ATerm trm168 = (ATerm) ATgetNext((ATermList) trm165);
+if(!(((ATgetType(trm168) == AT_LIST) && ATisEmpty(trm168))))
+goto label62 ;
 }
 }
 else
-goto label59 ;
+goto label62 ;
 }
 }
 else
-goto label59 ;
-t_24 = t;
-t = (ATerm) ATmakeAppl(sym_LocalVarDecStm_1, (ATerm) ATmakeAppl(sym_LocalVarDec_3, p_24, q_24, (ATerm) ATinsert(ATempty, (ATerm) ATmakeAppl(sym_VarDec_2, r_24, s_24))));
-goto label57 ;
-label59 :
-t = trm159;
+goto label62 ;
+c_25 = t;
+t = (ATerm) ATmakeAppl(sym_LocalVarDecStm_1, (ATerm) ATmakeAppl(sym_LocalVarDec_3, y_24, z_24, (ATerm) ATinsert(ATempty, (ATerm) ATmakeAppl(sym_VarDec_2, a_25, b_25))));
+goto label60 ;
+label62 :
+t = trm164;
 {
-ATerm n_24 = NULL,o_24 = NULL;
+ATerm w_24 = NULL,x_24 = NULL;
 if(match_cons(t, sym_ReturnStatement_1))
 {
-n_24 = ATgetArgument(t, 0);
+w_24 = ATgetArgument(t, 0);
 }
 else
 goto fail8 ;
-o_24 = t;
-t = (ATerm) ATmakeAppl(sym_Return_1, (ATerm) ATmakeAppl(sym_Some_1, n_24));
-goto label57 ;
+x_24 = t;
+t = (ATerm) ATmakeAppl(sym_Return_1, (ATerm) ATmakeAppl(sym_Some_1, w_24));
+goto label60 ;
 }
 }
-label57 :
+label60 :
 ;
 }
 __tracing_table[--__tracing_table_counter] = NULL;
@@ -976,58 +988,58 @@
 __tracing_table[__tracing_table_counter++] = "ModKey_0_0";
 sl_decl(sl);
 {
-ATerm trm147 = t;
-ATerm e_24 = NULL;
+ATerm trm152 = t;
+ATerm n_24 = NULL;
 if(match_cons(t, sym_Modifier_1))
 {
-ATerm trm148 = ATgetArgument(t, 0);
-if(match_cons(trm148, sym_ModifierKeyword_1))
+ATerm trm153 = ATgetArgument(t, 0);
+if(match_cons(trm153, sym_ModifierKeyword_1))
 {
-ATerm trm149 = ATgetArgument(trm148, 0);
-if(!(((ATgetType(trm149) == AT_INT) && (ATgetInt((ATermInt) trm149) == 1))))
-goto label55 ;
+ATerm trm154 = ATgetArgument(trm153, 0);
+if(!(((ATgetType(trm154) == AT_INT) && (ATgetInt((ATermInt) trm154) == 1))))
+goto label58 ;
 }
 else
-goto label55 ;
+goto label58 ;
 }
 else
-goto label55 ;
-e_24 = t;
-t = term21;
-goto label54 ;
-label55 :
-t = trm147;
+goto label58 ;
+n_24 = t;
+t = term23;
+goto label57 ;
+label58 :
+t = trm152;
 {
-ATerm trm150 = t;
-ATerm d_24 = NULL;
+ATerm trm155 = t;
+ATerm m_24 = NULL;
 if(match_cons(t, sym_Modifier_1))
 {
-ATerm trm151 = ATgetArgument(t, 0);
-if(match_cons(trm151, sym_ModifierKeyword_1))
+ATerm trm156 = ATgetArgument(t, 0);
+if(match_cons(trm156, sym_ModifierKeyword_1))
 {
-ATerm trm152 = ATgetArgument(trm151, 0);
-if(!(((ATgetType(trm152) == AT_INT) && (ATgetInt((ATermInt) trm152) == 2))))
-goto label56 ;
+ATerm trm157 = ATgetArgument(trm156, 0);
+if(!(((ATgetType(trm157) == AT_INT) && (ATgetInt((ATermInt) trm157) == 2))))
+goto label59 ;
 }
 else
-goto label56 ;
+goto label59 ;
 }
 else
-goto label56 ;
-d_24 = t;
-t = term23;
-goto label54 ;
-label56 :
-t = trm150;
+goto label59 ;
+m_24 = t;
+t = term25;
+goto label57 ;
+label59 :
+t = trm155;
 {
-ATerm c_24 = NULL;
+ATerm l_24 = NULL;
 if(match_cons(t, sym_Modifier_1))
 {
-ATerm trm153 = ATgetArgument(t, 0);
-if(match_cons(trm153, sym_ModifierKeyword_1))
+ATerm trm158 = ATgetArgument(t, 0);
+if(match_cons(trm158, sym_ModifierKeyword_1))
 {
-ATerm trm154 = ATgetArgument(trm153, 0);
-if(!(((ATgetType(trm154) == AT_INT) && (ATgetInt((ATermInt) trm154) == 8))))
+ATerm trm159 = ATgetArgument(trm158, 0);
+if(!(((ATgetType(trm159) == AT_INT) && (ATgetInt((ATermInt) trm159) == 8))))
 goto fail7 ;
 }
 else
@@ -1035,12 +1047,12 @@
 }
 else
 goto fail7 ;
-c_24 = t;
-t = term25;
-goto label54 ;
+l_24 = t;
+t = term27;
+goto label57 ;
 }
 }
-label54 :
+label57 :
 ;
 }
 __tracing_table[--__tracing_table_counter] = NULL;
@@ -1054,97 +1066,97 @@
 __tracing_table[__tracing_table_counter++] = "RewriteMethod_0_0";
 sl_decl(sl);
 {
-ATerm trm137 = t;
-ATerm u_23 = NULL,v_23 = NULL,w_23 = NULL,x_23 = NULL,y_23 = NULL,z_23 = NULL,a_24 = NULL,b_24 = NULL;
+ATerm trm142 = t;
+ATerm d_24 = NULL,e_24 = NULL,f_24 = NULL,g_24 = NULL,h_24 = NULL,i_24 = NULL,j_24 = NULL,k_24 = NULL;
 if(match_cons(t, sym_MethodDeclaration_8))
 {
-u_23 = ATgetArgument(t, 0);
-w_23 = ATgetArgument(t, 1);
-x_23 = ATgetArgument(t, 2);
-v_23 = ATgetArgument(t, 3);
-y_23 = ATgetArgument(t, 4);
-z_23 = ATgetArgument(t, 5);
+d_24 = ATgetArgument(t, 0);
+f_24 = ATgetArgument(t, 1);
+g_24 = ATgetArgument(t, 2);
+e_24 = ATgetArgument(t, 3);
+h_24 = ATgetArgument(t, 4);
+i_24 = ATgetArgument(t, 5);
 {
-ATerm trm138 = ATgetArgument(t, 6);
-if(!(((ATgetType(trm138) == AT_LIST) && ATisEmpty(trm138))))
-goto label52 ;
+ATerm trm143 = ATgetArgument(t, 6);
+if(!(((ATgetType(trm143) == AT_LIST) && ATisEmpty(trm143))))
+goto label55 ;
 }
-a_24 = ATgetArgument(t, 7);
+j_24 = ATgetArgument(t, 7);
 }
 else
-goto label52 ;
-b_24 = t;
-t = (ATerm) ATmakeAppl(sym_MethodDec_2, (ATerm)ATmakeAppl(sym_MethodDecHead_6, w_23, term1, x_23, y_23, z_23, term1), a_24);
-goto label51 ;
-label52 :
-t = trm137;
+goto label55 ;
+k_24 = t;
+t = (ATerm) ATmakeAppl(sym_MethodDec_2, (ATerm)ATmakeAppl(sym_MethodDecHead_6, f_24, term1, g_24, h_24, i_24, term1), j_24);
+goto label54 ;
+label55 :
+t = trm142;
 {
-ATerm trm139 = t;
-ATerm l_23 = NULL,m_23 = NULL,n_23 = NULL,o_23 = NULL,p_23 = NULL,q_23 = NULL,r_23 = NULL,s_23 = NULL,t_23 = NULL;
+ATerm trm144 = t;
+ATerm u_23 = NULL,v_23 = NULL,w_23 = NULL,x_23 = NULL,y_23 = NULL,z_23 = NULL,a_24 = NULL,b_24 = NULL,c_24 = NULL;
 if(match_cons(t, sym_MethodDeclaration_8))
 {
-l_23 = ATgetArgument(t, 0);
-n_23 = ATgetArgument(t, 1);
-o_23 = ATgetArgument(t, 2);
-m_23 = ATgetArgument(t, 3);
-p_23 = ATgetArgument(t, 4);
-q_23 = ATgetArgument(t, 5);
+u_23 = ATgetArgument(t, 0);
+w_23 = ATgetArgument(t, 1);
+x_23 = ATgetArgument(t, 2);
+v_23 = ATgetArgument(t, 3);
+y_23 = ATgetArgument(t, 4);
+z_23 = ATgetArgument(t, 5);
 {
-ATerm trm140 = ATgetArgument(t, 6);
-if(((ATgetType(trm140) == AT_LIST) && !(ATisEmpty(trm140))))
+ATerm trm145 = ATgetArgument(t, 6);
+if(((ATgetType(trm145) == AT_LIST) && !(ATisEmpty(trm145))))
 {
-r_23 = ATgetFirst((ATermList) trm140);
+a_24 = ATgetFirst((ATermList) trm145);
 {
-ATerm trm141 = (ATerm) ATgetNext((ATermList) trm140);
-if(!(((ATgetType(trm141) == AT_LIST) && ATisEmpty(trm141))))
-goto label53 ;
+ATerm trm146 = (ATerm) ATgetNext((ATermList) trm145);
+if(!(((ATgetType(trm146) == AT_LIST) && ATisEmpty(trm146))))
+goto label56 ;
 }
 }
 else
-goto label53 ;
+goto label56 ;
 }
-s_23 = ATgetArgument(t, 7);
+b_24 = ATgetArgument(t, 7);
 }
 else
-goto label53 ;
-t_23 = t;
-t = (ATerm) ATmakeAppl(sym_MethodDec_2, (ATerm)ATmakeAppl(sym_MethodDecHead_6, n_23, term1, o_23, p_23, q_23, (ATerm) ATmakeAppl(sym_Some_1, (ATerm) ATmakeAppl(sym_ThrowsDec_1, (ATerm) ATinsert(ATempty, (ATerm) ATmakeAppl(sym_ClassType_1, (ATerm) ATmakeAppl(sym_TypeName_1, r_23)))))), s_23);
-goto label51 ;
-label53 :
-t = trm139;
+goto label56 ;
+c_24 = t;
+t = (ATerm) ATmakeAppl(sym_MethodDec_2, (ATerm)ATmakeAppl(sym_MethodDecHead_6, w_23, term1, x_23, y_23, z_23, (ATerm) ATmakeAppl(sym_Some_1, (ATerm) ATmakeAppl(sym_ThrowsDec_1, (ATerm) ATinsert(ATempty, (ATerm) ATmakeAppl(sym_ClassType_1, (ATerm) ATmakeAppl(sym_TypeName_1, a_24)))))), b_24);
+goto label54 ;
+label56 :
+t = trm144;
 {
-ATerm g_23 = NULL,h_23 = NULL,i_23 = NULL,j_23 = NULL,k_23 = NULL;
+ATerm p_23 = NULL,q_23 = NULL,r_23 = NULL,s_23 = NULL,t_23 = NULL;
 if(match_cons(t, sym_MethodDec_2))
 {
-ATerm trm142 = ATgetArgument(t, 0);
-if(match_cons(trm142, sym_MethodDecHead_6))
+ATerm trm147 = ATgetArgument(t, 0);
+if(match_cons(trm147, sym_MethodDecHead_6))
 {
-g_23 = ATgetArgument(trm142, 0);
+p_23 = ATgetArgument(trm147, 0);
 {
-ATerm trm143 = ATgetArgument(trm142, 1);
-if(!(match_cons(trm143, sym_None_0)))
+ATerm trm148 = ATgetArgument(trm147, 1);
+if(!(match_cons(trm148, sym_None_0)))
 goto fail6 ;
 }
 {
-ATerm trm144 = ATgetArgument(trm142, 2);
-if(!(match_cons(trm144, sym_None_0)))
+ATerm trm149 = ATgetArgument(trm147, 2);
+if(!(match_cons(trm149, sym_None_0)))
 goto fail6 ;
 }
-h_23 = ATgetArgument(trm142, 3);
-i_23 = ATgetArgument(trm142, 4);
+q_23 = ATgetArgument(trm147, 3);
+r_23 = ATgetArgument(trm147, 4);
 {
-ATerm trm145 = ATgetArgument(trm142, 5);
-if(!(match_cons(trm145, sym_None_0)))
+ATerm trm150 = ATgetArgument(trm147, 5);
+if(!(match_cons(trm150, sym_None_0)))
 goto fail6 ;
 }
 }
 else
 goto fail6 ;
 {
-ATerm trm146 = ATgetArgument(t, 1);
-if(match_cons(trm146, sym_Block_1))
+ATerm trm151 = ATgetArgument(t, 1);
+if(match_cons(trm151, sym_Block_1))
 {
-j_23 = ATgetArgument(trm146, 0);
+s_23 = ATgetArgument(trm151, 0);
 }
 else
 goto fail6 ;
@@ -1152,12 +1164,12 @@
 }
 else
 goto fail6 ;
-k_23 = t;
-t = (ATerm) ATmakeAppl(sym_ConstrDec_2, (ATerm)ATmakeAppl(sym_ConstrDecHead_5, g_23, term1, h_23, i_23, term1), (ATerm) ATmakeAppl(sym_ConstrBody_2, term1, j_23));
-goto label51 ;
+t_23 = t;
+t = (ATerm) ATmakeAppl(sym_ConstrDec_2, (ATerm)ATmakeAppl(sym_ConstrDecHead_5, p_23, term1, q_23, r_23, term1), (ATerm) ATmakeAppl(sym_ConstrBody_2, term1, s_23));
+goto label54 ;
 }
 }
-label51 :
+label54 :
 ;
 }
 __tracing_table[--__tracing_table_counter] = NULL;
@@ -1171,36 +1183,36 @@
 __tracing_table[__tracing_table_counter++] = "RewritePrimitive_0_0";
 sl_decl(sl);
 {
-ATerm trm134 = t;
-ATerm f_23 = NULL;
+ATerm trm139 = t;
+ATerm o_23 = NULL;
 if(match_cons(t, sym_PrimitiveType_1))
 {
-ATerm trm135 = ATgetArgument(t, 0);
-if(!((ATgetSymbol(trm135) == ATmakeSymbol("int", 0, ATtrue))))
-goto label50 ;
+ATerm trm140 = ATgetArgument(t, 0);
+if(!((ATgetSymbol(trm140) == ATmakeSymbol("int", 0, ATtrue))))

(1451 diff lines omitted)


From mdjonge at xs4all.nl  Tue Jun 30 17:24:58 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Tue, 30 Jun 2009 15:24:58 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19603 - MaartjeDeJonge
	- sglr-recovery/trunk/Evaluation_Recovery
Message-ID: <200906301523.n5UFNUMI024061@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-30 15:24:58 +0000 (Tue, 30 Jun 2009)
New Revision: 19603

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19603&view=rev

Modified:
   sglr-recovery/trunk/Evaluation_Recovery/CompileTransformation.sh
   sglr-recovery/trunk/Evaluation_Recovery/Run.sh

Log:
remove echo

Changes:

Modified: sglr-recovery/trunk/Evaluation_Recovery/CompileTransformation.sh
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/CompileTransformation.sh	2009-06-30 14:54:54 UTC (rev 19602)
+++ sglr-recovery/trunk/Evaluation_Recovery/CompileTransformation.sh	2009-06-30 15:24:58 UTC (rev 19603)
@@ -32,7 +32,7 @@
 		jdtTree=${jdtTree#*\/}
 		jdtTree=${jdtTree#*\/}
 		jdtTreeName=${jdtTree%.*}
-		echo $jdtTree
+		#echo $jdtTree
 		
 		# print abstract syntax
 		pp-aterm -i $jdtTreeDir/$jdtTree -o $jdtTreeDir/$jdtTree.readable
@@ -77,7 +77,7 @@
 	jdtTree=${jdtTree#*\/}
 	jdtTreeName=${jdtTree%.*}
 	jdtTreeName=${jdtTreeName%.*}	
-	echo $jdtTreeName	
+	#echo $jdtTreeName	
 	
 	#compare readable ast's
 	diff $jdtAstDir/$jdtTree $sglrAstDir/$jdtTreeName.ast.readable > $diffDir/$jdtTreeName.diff.txt

Modified: sglr-recovery/trunk/Evaluation_Recovery/Run.sh
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Run.sh	2009-06-30 14:54:54 UTC (rev 19602)
+++ sglr-recovery/trunk/Evaluation_Recovery/Run.sh	2009-06-30 15:24:58 UTC (rev 19603)
@@ -20,7 +20,7 @@
 		jdtTree=${jdtTree#*\/}
 		jdtTree=${jdtTree#*\/}
 		jdtTreeName=${jdtTree%.*}
-		echo $jdtTree
+		#echo $jdtTree
 		
 		# print abstract syntax
 		pp-aterm -i $jdtTreeDir/$jdtTree -o $jdtTreeDir/$jdtTree.readable
@@ -51,7 +51,7 @@
 		parseTree=${parseTree#*\/}
 		parseTree=${parseTree#*\/}
 		parseTreeName=${parseTree%.*}
-		echo $parseTree
+		#echo $parseTree
 		
 		# create abstract syntax
 		implode-asfix -i $ptDir/$parseTree -o $astDir/$parseTreeName.ast
@@ -72,7 +72,7 @@
 		astTree=${astTree#*\/}
 		astTree=${astTree#*\/}
 		astTreeName=${astTree%.*}
-		echo $astTree
+		#echo $astTree
 	
 		# create abstract syntax		
 		pp-java -i $astDir/$astTree -o $javaDir/$astTreeName.java			
@@ -99,7 +99,7 @@
 		correctTree=${correctTree#*\/}
 		correctTreeName=${correctTree%.*}
 		correctTreeName=${correctTreeName%.*}	
-		echo $correctTreeName	
+		#echo $correctTreeName	
 	
 		#compare readable ast's
 		diff $brancheLoc/$correctTree $compareLoc/$correctTree > $diffDir/$correctTreeName.$addition.diff.txt
@@ -124,7 +124,7 @@
 		correctJava=${correctJava#*\/}
 		correctJava=${correctJava#*\/}
 		correctJavaName=${correctJava%.*}	
-		echo $correctJavaName
+		#echo $correctJavaName
 	
 		#compare readable ast's
 		diff $brancheLoc/$correctJavaName.java $compareLoc/$correctJava > $diffDir/$correctJavaName.$addition.diff.txt



From mdjonge at xs4all.nl  Tue Jun 30 19:13:18 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Tue, 30 Jun 2009 17:13:18 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19604 - MaartjeDeJonge
	- in sglr-recovery/trunk/Evaluation_Recovery: . Analyse
Message-ID: <200906301711.n5UHBoRU025240@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-30 17:13:18 +0000 (Tue, 30 Jun 2009)
New Revision: 19604

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19604&view=rev

Added:
   sglr-recovery/trunk/Evaluation_Recovery/Analyse/
   sglr-recovery/trunk/Evaluation_Recovery/Analyse/java_diffs/
   sglr-recovery/trunk/Evaluation_Recovery/Analyse/jdt_better_then_sglr/
   sglr-recovery/trunk/Evaluation_Recovery/Analyse/jdt_excellent/
   sglr-recovery/trunk/Evaluation_Recovery/Analyse/jdt_others/
   sglr-recovery/trunk/Evaluation_Recovery/Analyse/sglr_better_then_jdt/
   sglr-recovery/trunk/Evaluation_Recovery/Analyse/sglr_excellent/
   sglr-recovery/trunk/Evaluation_Recovery/Analyse/sglr_others/

Log:
analyse dir

Changes:



From mdjonge at xs4all.nl  Tue Jun 30 19:16:39 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Tue, 30 Jun 2009 17:16:39 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19606 - MaartjeDeJonge
	- sglr-recovery/trunk/Evaluation_Recovery
Message-ID: <200906301715.n5UHFBCS025271@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-30 17:16:39 +0000 (Tue, 30 Jun 2009)
New Revision: 19606

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19606&view=rev

Added:
   sglr-recovery/trunk/Evaluation_Recovery/Analyse.sh

Log:


Changes:

Added: sglr-recovery/trunk/Evaluation_Recovery/Analyse.sh
===================================================================
--- sglr-recovery/trunk/Evaluation_Recovery/Analyse.sh	                        (rev 0)
+++ sglr-recovery/trunk/Evaluation_Recovery/Analyse.sh	2009-06-30 17:16:39 UTC (rev 19606)
@@ -0,0 +1,74 @@
+#!/bin/sh
+
+diffDir="Analyse/java_diffs"
+jdtBetter=Analyse/jdt_better_then_sglr
+sglrBetter=Analyse/sglr_better_then_jdt
+
+rm $diffDir/*.*
+rm Analyse/sglr_excellent/*.*
+rm Analyse/jdt_excellent/*.*
+rm $jdtBetter/*.*
+rm $sglrBetter/*.*
+rm Analyse/sglr_others/*.*
+rm Analyse/jdt_others/*.*
+
+
+compareJava(){	
+	compareLoc=$1
+	brancheLoc=$2
+	addition=$3		
+	correctJavaFiles="$compareLoc/*.java"
+	for correctJava in $correctJavaFiles
+	do	
+		correctJava=${correctJava#*\/}
+		correctJava=${correctJava#*\/}
+		correctJavaName=${correctJava%.*}	
+		#echo $correctJavaName
+	
+		#compare readable java
+		diff $brancheLoc/$correctJavaName.java $compareLoc/$correctJava > $diffDir/$correctJavaName.$addition.txt
+	done
+}
+
+compareJava "Correct_Files/generated_java" "Error_Files/sglr_java" "sglr"
+compareJava "Correct_Files/generated_java" "Error_Files/jdt_java" "jdt"
+
+################################################################################################################
+
+#search empty java diff files
+
+findExcellent(){ 
+	addition=$1
+	for i in $diffDir/*.$addition.txt 
+	do 
+		if [ ! -s $i ]; then 
+			cp -f $i Analyse/${addition}_excellent 
+		else 
+			cp -f $i Analyse/${addition}_others 
+		fi 
+	done
+}
+
+findExcellent "sglr"
+findExcellent "jdt"
+
+compareLines(){
+	for jdtFile in $diffDir/*.jdt.txt	
+	do 
+		sglrFile=${jdtFile%.*}
+		sglrFile=${sglrFile%.*}	
+		sglrFile=$sglrFile.sglr.txt		
+		sglrLineCount=$(wc -l < $sglrFile)
+		jdtLineCount=$(wc -l < $jdtFile)
+		#echo "sglr: $sglrLineCount"
+		#echo "jdt: $jdtLineCount"		
+		if [ "$sglrLineCount" -gt "$jdtLineCount" ]; then 
+			cp -f $jdtFile $jdtBetter 			
+		elif [ "$sglrLineCount" -lt "$jdtLineCount" ]; then
+			cp -f $sglrFile $sglrBetter			
+		fi 
+	done
+}
+
+compareLines
+


Property changes on: sglr-recovery/trunk/Evaluation_Recovery/Analyse.sh
___________________________________________________________________
Added: svn:executable
   + *



From mdjonge at xs4all.nl  Tue Jun 30 19:15:41 2009
From: mdjonge at xs4all.nl (Maartje de Jonge)
Date: Tue, 30 Jun 2009 17:15:41 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - 19605 - MaartjeDeJonge
	- in sglr-recovery/trunk/Evaluation_Recovery/Analyse:
	java_diffs jdt_better_then_sglr jdt_excellent jdt_others
	sglr_better_then_jdt sglr_excellent sglr_others
Message-ID: <200906301714.n5UHEDee025255@proliant.st.ewi.tudelft.nl>

Author: MaartjeDeJonge
Date: 2009-06-30 17:15:41 +0000 (Tue, 30 Jun 2009)
New Revision: 19605

You can view the changes in this commit at:
   https://svn.strategoxt.org/viewvc/StrategoXT?rev=19605&view=rev

Modified:
   sglr-recovery/trunk/Evaluation_Recovery/Analyse/java_diffs/
   sglr-recovery/trunk/Evaluation_Recovery/Analyse/jdt_better_then_sglr/
   sglr-recovery/trunk/Evaluation_Recovery/Analyse/jdt_excellent/
   sglr-recovery/trunk/Evaluation_Recovery/Analyse/jdt_others/
   sglr-recovery/trunk/Evaluation_Recovery/Analyse/sglr_better_then_jdt/
   sglr-recovery/trunk/Evaluation_Recovery/Analyse/sglr_excellent/
   sglr-recovery/trunk/Evaluation_Recovery/Analyse/sglr_others/

Log:
svn-ignore

Changes:


Property changes on: sglr-recovery/trunk/Evaluation_Recovery/Analyse/java_diffs
___________________________________________________________________
Added: svn:ignore
   + *.txt



Property changes on: sglr-recovery/trunk/Evaluation_Recovery/Analyse/jdt_better_then_sglr
___________________________________________________________________
Added: svn:ignore
   + *.txt



Property changes on: sglr-recovery/trunk/Evaluation_Recovery/Analyse/jdt_excellent
___________________________________________________________________
Added: svn:ignore
   + *.txt



Property changes on: sglr-recovery/trunk/Evaluation_Recovery/Analyse/jdt_others
___________________________________________________________________
Added: svn:ignore
   + *.txt



Property changes on: sglr-recovery/trunk/Evaluation_Recovery/Analyse/sglr_better_then_jdt
___________________________________________________________________
Added: svn:ignore
   + *.txt



Property changes on: sglr-recovery/trunk/Evaluation_Recovery/Analyse/sglr_excellent
___________________________________________________________________
Added: svn:ignore
   + *



Property changes on: sglr-recovery/trunk/Evaluation_Recovery/Analyse/sglr_others
___________________________________________________________________
Added: svn:ignore
   + *




