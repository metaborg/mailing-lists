From gabrielkonat at gmail.com  Fri Mar  1 14:35:11 2013
From: gabrielkonat at gmail.com (Gabriël Konat)
Date: Fri, 01 Mar 2013 13:35:11 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25988 - in
	spoofax-imp/trunk: org.strategoxt.imp.generator/src/sdf2imp/project
	org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building
Message-ID: <20130301133511.71C1C7F80C3@mx1.tudelft.nl>

Author: gkonat
Date: Fri Mar  1 13:35:10 2013
New Revision: 25988
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25988&sc=1

Log:
Call on-save handler for tmpl, nd and nab files before building.

Added:
   spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building/AntForceOnSave.java
Modified:
   spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-build-xml.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-build-xml.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-build-xml.str	Wed Feb 27 16:20:12 2013	(r25987)
+++ spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-build-xml.str	Fri Mar  1 13:35:10 2013	(r25988)
@@ -58,6 +58,15 @@
     		
     		<!-- used for building inside of Eclipse -->
         <import file="build.generated.xml"/>   
+
+			  <!-- The files for which the on-save handler is called before building -->
+			  <path id="call-onsave.files">
+			    <fileset dir=".">
+			      <include name="**/*.tmpl" />
+			      <include name="**/*.nd" />
+			      <include name="**/*.nab" />
+			    </fileset>
+			  </path>
     
         <!-- Main target -->
         <target name="all" depends="spoofaximp.default.ctree"/>
@@ -76,51 +85,54 @@
     <?xml version="1.0" encoding="UTF-8"?>
     <project name="build.generated">
 
-        <target name="spoofaximp.default" depends="spoofaximp.default.ctree"/>
-        <target name="spoofaximp.default.ctree" depends="
-			check-classpath,
-			init,
-			sdf2table,
-			meta-sdf2table,
-			ppgen,
-			pppack,
-			sdf2imp.eclipse,
-			sdf2imp.standalone,
-			sdf2parenthesize,
-			stratego.aster,
-			java.jar,
-			stratego.ctree,
-			refresh,
-			sdf2imp.eclipse.load" />
-        <target name="spoofaximp.default.jar" depends="
-			check-classpath,
-			init,
-			sdf2table,
-			meta-sdf2table,
-			ppgen,
-			pppack,
-			sdf2imp.eclipse,
-			sdf2imp.standalone,
-			sdf2parenthesize,
-			stratego.aster,
-			java.jar,
-			stratego.jar.helper,
-			refresh,
-			sdf2imp.eclipse.load" />
-        <target name="spoofaximp.default.nostr" depends="
-      check-classpath,
-      init,
-      sdf2table,
-      meta-sdf2table,
-      ppgen,
-      pppack,
-      sdf2imp.eclipse,
-      sdf2imp.standalone,
-      sdf2parenthesize,
-      stratego.aster,
-      java.jar,
-      refresh,
-      sdf2imp.eclipse.load"/>
+			  <target name="spoofaximp.default" depends="spoofaximp.default.ctree" />
+			  <target name="spoofaximp.default.ctree" depends="
+			      check-classpath,
+			      call-onsave,
+			      init,
+			      sdf2table,
+			      meta-sdf2table,
+			      ppgen,
+			      pppack,
+			      sdf2imp.eclipse,
+			      sdf2imp.standalone,
+			      sdf2parenthesize,
+			      stratego.aster,
+			      java.jar,
+			      stratego.ctree,
+			      refresh,
+			      sdf2imp.eclipse.load" />
+			  <target name="spoofaximp.default.jar" depends="
+			      check-classpath,
+			      call-onsave,
+			      init,
+			      sdf2table,
+			      meta-sdf2table,
+			      ppgen,
+			      pppack,
+			      sdf2imp.eclipse,
+			      sdf2imp.standalone,
+			      sdf2parenthesize,
+			      stratego.aster,
+			      java.jar,
+			      stratego.jar.helper,
+			      refresh,
+			      sdf2imp.eclipse.load" />
+			  <target name="spoofaximp.default.nostr" depends="
+			      check-classpath,
+			      call-onsave,
+			      init,
+			      sdf2table,
+			      meta-sdf2table,
+			      ppgen,
+			      pppack,
+			      sdf2imp.eclipse,
+			      sdf2imp.standalone,
+			      sdf2parenthesize,
+			      stratego.aster,
+			      java.jar,
+			      refresh,
+			      sdf2imp.eclipse.load" />
     
         <!-- Initialization -->
         <available file="${src-gen}/<%= pkgdir %>/strategies/Main.java" property="java.jar.enabled"/>
@@ -162,6 +174,23 @@
         <mkdir dir="${lib}"/>
         <mkdir dir="${syntax}"/>
 
+			  <!-- The files for which the on-save handler is called before building -->
+			  <path id="call-onsave.files">
+			    <fileset dir=".">
+			      <include name="**/*.tmpl" />
+			      <include name="**/*.nd" />
+			      <include name="**/*.nab" />
+			    </fileset>
+			  </path>
+				
+				<!-- Call on-save handler for template and name binding files so that their generated files are present -->
+				<target name="call-onsave">
+					<pathconvert pathsep=" " property="call-onsave.args" refid="call-onsave.files" />
+					<java classname="org.strategoxt.imp.metatooling.building.AntForceOnSave" failonerror="true">
+						<arg line="${call-onsave.args}" />
+					</java>
+				</target>
+
         <target name="sdf2imp" depends="sdf2table,sdf2imp.eclipse,sdf2imp.standalone,sdf2parenthesize"/>
         
         <target name="sdf2imp.eclipse" if="eclipse.running" depends="sdf2rtg">

Added: spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building/AntForceOnSave.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building/AntForceOnSave.java	Fri Mar  1 13:35:10 2013	(r25988)
@@ -0,0 +1,21 @@
+package org.strategoxt.imp.metatooling.building;
+
+import java.io.FileNotFoundException;
+
+import org.eclipse.core.runtime.Path;
+import org.eclipse.imp.model.ModelFactory.ModelException;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.strategoxt.imp.runtime.FileState;
+import org.strategoxt.imp.runtime.dynamicloading.BadDescriptorException;
+import org.strategoxt.imp.runtime.services.OnSaveService;
+
+public class AntForceOnSave {
+    public static void main(String[] args) throws FileNotFoundException, BadDescriptorException, ModelException {
+    	for(String arg : args) {
+    		FileState fileState = FileState.getFile(new Path(arg), null);
+    		IStrategoTerm ast = fileState.getAnalyzedAst();
+    		OnSaveService onSave = fileState.getDescriptor().createService(OnSaveService.class, fileState.getParseController());
+    		onSave.invokeOnSave(ast);
+    	}
+    }
+}

From gabrielkonat at gmail.com  Fri Mar  1 14:37:59 2013
From: gabrielkonat at gmail.com (Gabriël Konat)
Date: Fri, 01 Mar 2013 13:37:59 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25989 - in
	spoofax-imp/trunk: org.strategoxt.imp.generator/src/sdf2imp/project
	org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building
Message-ID: <20130301133759.790812B804C@mx2.tudelft.nl>

Author: gkonat
Date: Fri Mar  1 13:37:59 2013
New Revision: 25989
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25989&sc=1

Log:
Catch exceptions

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-build-xml.str
   spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building/AntForceOnSave.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-build-xml.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-build-xml.str	Fri Mar  1 13:35:10 2013	(r25988)
+++ spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-build-xml.str	Fri Mar  1 13:37:59 2013	(r25989)
@@ -186,7 +186,7 @@
 				<!-- Call on-save handler for template and name binding files so that their generated files are present -->
 				<target name="call-onsave">
 					<pathconvert pathsep=" " property="call-onsave.args" refid="call-onsave.files" />
-					<java classname="org.strategoxt.imp.metatooling.building.AntForceOnSave" failonerror="true">
+					<java classname="org.strategoxt.imp.metatooling.building.AntForceOnSave">
 						<arg line="${call-onsave.args}" />
 					</java>
 				</target>

Modified: spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building/AntForceOnSave.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building/AntForceOnSave.java	Fri Mar  1 13:35:10 2013	(r25988)
+++ spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building/AntForceOnSave.java	Fri Mar  1 13:37:59 2013	(r25989)
@@ -5,17 +5,26 @@
 import org.eclipse.core.runtime.Path;
 import org.eclipse.imp.model.ModelFactory.ModelException;
 import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.strategoxt.imp.runtime.Environment;
 import org.strategoxt.imp.runtime.FileState;
 import org.strategoxt.imp.runtime.dynamicloading.BadDescriptorException;
 import org.strategoxt.imp.runtime.services.OnSaveService;
 
 public class AntForceOnSave {
-    public static void main(String[] args) throws FileNotFoundException, BadDescriptorException, ModelException {
+    public static void main(String[] args) {
     	for(String arg : args) {
-    		FileState fileState = FileState.getFile(new Path(arg), null);
-    		IStrategoTerm ast = fileState.getAnalyzedAst();
-    		OnSaveService onSave = fileState.getDescriptor().createService(OnSaveService.class, fileState.getParseController());
-    		onSave.invokeOnSave(ast);
+			try {
+				FileState fileState = FileState.getFile(new Path(arg), null);
+	    		IStrategoTerm ast = fileState.getAnalyzedAst();
+	    		OnSaveService onSave = fileState.getDescriptor().createService(OnSaveService.class, fileState.getParseController());
+	    		onSave.invokeOnSave(ast);
+			} catch (FileNotFoundException e) {
+				Environment.logException("Could not call on-save handler.", e);
+			} catch (BadDescriptorException e) {
+				Environment.logException("Could not call on-save handler.", e);
+			} catch (ModelException e) {
+				Environment.logException("Could not call on-save handler.", e);
+			}
     	}
     }
 }

From m.dejonge at tudelft.nl  Mon Mar  4 15:28:47 2013
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Mon, 04 Mar 2013 14:28:47 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25990 - in
	spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp: .
	project
Message-ID: <20130304142847.12EB2108C010@mx3.tudelft.nl>

Author: MaartjeDeJonge
Date: Mon Mar  4 14:28:45 2013
New Revision: 25990
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25990&sc=1

Log:
refactoring library:
  - extract method: components for analysis and transformation
  - dataflow analysis
  - position fetch strategies
  - operations on (sub)lists in the ast

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/main.str
   spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-refactoring-library.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/main.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/main.str	Fri Mar  1 13:37:59 2013	(r25989)
+++ spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/main.str	Mon Mar  4 14:28:45 2013	(r25990)
@@ -164,6 +164,11 @@
     create-analysis-multifile;
     create-refactoring-files;
     create-rename-refactoring;
+    create-binding-violations;
+    create-data-flow-analysis;
+    create-extract-refactoring;
+    create-fetch-positions;
+    create-list-operations;
     
     copy-jars;
     copy-def-file;

Modified: spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-refactoring-library.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-refactoring-library.str	Fri Mar  1 13:37:59 2013	(r25989)
+++ spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-refactoring-library.str	Mon Mar  4 14:28:45 2013	(r25990)
@@ -654,3 +654,810 @@
       // REMARK: all (possible) changed files are automatically queued for analysis in the Spoofax 
       // refactoring component after the refactoring is executed or canceled by the user
 }
+
+create-binding-violations =
+try(<file-exists <+ mkdir> "lib-refactoring");
+<output-text-file(|["lib-refactoring"], "binding-violations.generated.str")>
+"/**
+ * Strategy to calculate binding violations by comparing binding annotations that 
+ * express the actual and the intended binding structure.
+ */
+module lib-refactoring/binding-violations.generated
+
+strategies 
+
+  /**
+   * @see binding-violation-terms(is-endangered-term)
+   *
+   * @type  (T, T) -> List(T{b1, b2})
+   * @param endangered-terms  List with terms that must be checked for binding violations
+   */
+  binding-violation-terms(|endangered-terms) =
+    binding-violation-terms(is-in-list(|endangered-terms))
+
+  /**
+   * Returns binding violations by comparing the expected binding structure with the actual binding structure
+   * in the asts that result after the transformation.
+   * Can be used to check for violations of name reference, control-flow and data-flow.
+   * For performance reason, only the 'endangered' terms are compared.
+   *
+   * The input term must be a tuple (trm-intended-bindings, trm-actual-bindings) whereby
+   * 1) both terms have the same abstract structure
+   * 2) the trm-intended-bindings contains annotations that express the INTENDED binding structure
+   *    (typically obtained by 'analyze; transform' whereby the transformation preserves the original annotations 
+   *     and sets annotations for newly inserted terms)
+   * 3) the trm-actual-bindings contain name annotations that express the ACTUAL binding structure
+   *    (typically obtained by 'transform; analyze', i.e. reanalyzing the resulting asts)
+   *
+   * @type  (T, T) -> List(T{b1, b2})
+   * @param is-endangered-term  String -> String
+   */  
+  binding-violation-terms(is-endangered-term):
+    trees@(trm-intended-bindings, trm-actual-bindings) -> binding-violation-terms
+    where
+      binding-violation-terms := <
+        bindings-construct-compare-ast;
+        binding-violation-terms-internal(is-endangered-term)
+      > trees
+  
+   //Constructs an AST with information about the original binding structure, and the new binding structure.
+   //Condition: 'trm-intended-bindings' and 'trm-actual-bindings' have the same structure and contain binding information.
+  bindings-construct-compare-ast:
+    (trm-intended-bindings, trm-actual-bindings) -> binding-compare-ast
+    where
+      binding-compare-ast := <merge-bindings>(trm-intended-bindings, trm-actual-bindings)
+  
+  //Returns binding violations by comparing the expected binding with the actual binding, 
+  //both set as annotation on terms (t{b-intended, b-actual}) in the 'binding compare AST'.
+  //For performance reason, only the 'endangered' terms are compared.
+  binding-violation-terms-internal(is-endangered-term):
+    binding-compare-ast -> binding-violation-terms
+    where 
+      all-bindings := <
+        bindings-collect-endangered-terms(is-endangered-term)
+      > binding-compare-ast; 
+      binding-mapping := <make-set> all-bindings; 
+      binding-violations := <bindings-filter-violations> binding-mapping; 
+      binding-violation-terms := <isect> (all-bindings, binding-violations) 
+
+  bindings-collect-endangered-terms(is-endangered-term):
+    binding-compare-ast -> bindings-mapping
+    where
+      bindings-mapping := <
+        collect-all(?_{_, _}; where(strip-annos; is-endangered-term), conc);
+        filter(not(?_{[],[]} <+ ?_{(),()} <+ ?_{None(), None()})) //TODO: nb analysis, ?_{Unresolved(_),Unresolved(_)}
+      > binding-compare-ast
+              
+  bindings-filter-violations:
+    binding-mapping -> <concat> [broken-bindings, created-bindings, changed-bindings]
+    where
+      (broken-bindings,  binding-mapping')  := <partition(is-broken-binding)> binding-mapping; 
+      (created-bindings, binding-mapping'') := <partition(is-created-binding)> binding-mapping';
+      changed-bindings := <bindings-filter-changes> binding-mapping''
+
+  bindings-filter-changes: 
+    [t{b1,b2}|bindings] -> <conc>(conflicts, <bindings-filter-changes> unrelated-bindings)
+    where 
+      (related-bindings, unrelated-bindings) := <partition(?_{b1,_} <+ ?_{_,b2})> bindings;
+      if <filter(not(?_{b1,b2})); ?[]> related-bindings then
+        conflicts := []
+      else
+        conflicts := [t{b1,b2}|related-bindings]
+      end
+  
+  bindings-filter-changes:
+    [] -> []
+
+  is-broken-binding =
+    ?_{_, None()}; not(?_{None(), None()})
+
+  is-broken-binding =
+    ?_{_, ()}; not(?_{(),()})
+
+  is-broken-binding =
+    ?_{_, []}; not(?_{[],[]})
+  
+  is-created-binding =
+    ?n{b1, b2}; 
+    where(<is-broken-binding> n{b2, b1})
+
+
+rules //helpers
+
+  is-in-list(|lst):
+    elem -> elem
+    where
+      <fetch(strip-annos; equal(|<strip-annos> elem))> lst
+
+  //@internal    
+  merge-bindings =
+    merge-bindings-1 <+
+    merge-bindings-2 <+
+    merge-bindings-3 <+
+    merge-bindings-4
+  
+  //@internal    
+  merge-bindings-1:
+    (s1{b1}, s2{b2}) -> s1{b1, b2}
+    where
+      <equal> (s1{},s2{})
+  
+  //@internal    
+  merge-bindings-2:
+    (s1{b1}, s2{}) -> s1{b1, None()}
+    where
+      <equal> (s1{},s2{})
+  
+  //@internal    
+  merge-bindings-3:
+    (s1{}, s2{b2}) -> s1{None(), b2}
+    where
+      <equal> (s1{},s2{})
+  
+  //@internal    
+  merge-bindings-4:
+    (c#(args1), c#(args2)) -> c#(args) 
+    where
+      args := <zip; map(merge-bindings)> (args1, args2)"
+  
+create-data-flow-analysis =
+try(<file-exists <+ mkdir> "lib-refactoring");
+<output-text-file(|["lib-refactoring"], "data-flow-analysis.generated.str")>
+"/**
+ * Language generic template strategy for data-flow analysis.
+ */
+module lib-refactoring/data-flow-analysis.generated
+
+rules //rules that implement the language specific part of the data-flow analysis
+
+  /**
+   * Associates a df-anno to the declared variable. 
+   * The df-anno is set as an annotation on the name of the declared variable, and stored to annotate its subsequent  read accesses. 
+   *
+   * @example VarDecl(name, type) -> VarDecl(<set-new-df-value> name, type)
+   * @type VarDecl -> VarDecl
+   */  
+  df-anno-declare = fail
+    
+  /**
+   * Associates a new df-anno to the assigned variable. 
+   * The df-anno is set as an annotation on the name of the assigned variable, and stored to annotate its subsequent read accesses. 
+   * @example
+   *   Assign(name, value) -> Assign(df-name, value')
+   *   where
+   *     value' := <df-anno> value;
+   *     df-name := <set-new-df-value> name      
+   * @type VarAssignment -> VarAssignment
+   */  
+  df-anno-assign = fail
+    
+  /**
+   * Implements the data-flow for constructs that affect the control flow (and thus also the data-flow).
+   *
+   * @example
+   *   If(c, if-block, else-block) -> If(c, if-block', else-block')
+   *   where
+   *     if-block' := <df-anno> if-block
+   *       \\DFAnno/
+   *     else-block' := <df-anno> else-block
+   * @type T -> T
+   */
+  df-anno-control-flow = fail 
+
+    
+rules //helper rules 
+  
+  /**
+   * Helper rule to associate a new, unique df-anno to the name of a declared or assigned variable.
+   * The df-anno is stored to annotate the names of its subsequent read accesses.
+   * @type String -> String{List(String)}
+   */
+  set-new-df-value:
+    name -> name{[df-anno]}
+    where
+      df-anno := <newname> \"df_\";
+      rules(DFAnno :  name  ->  df-anno)
+
+  
+rules //rules that implement the language generic part of the data-flow analysis
+  
+  /**
+   * Sets data-flow annotations on variable names, so that: 
+   * - variables with the same df-anno have the same value, e.g., 
+   *   VarDecl(\"a{df-x}\"); VarAssign(\"a{df-y}\"); VarUse(\"a{df-y}\"); VarUse(\"a{df-y}\"); VarAssign(\"a{df-z}\"); VarUse(\"a{df-z}\");
+   * - multiple df-annos can be set to represent different control flows, e.g., 
+   *   If(c, VarAssign(\"a{df-x}\");, VarAssign(\"a{df-y}\");); VarUse(\"a{[df-x, df-y]}\")
+   *
+   * @type T -> T
+   */
+  analyze-dataflow:
+    trm -> trm'
+    where
+      {|DFAnno:
+        trm' := <df-anno> trm
+      |}
+  
+  //controls the dataflow traversal
+  df-anno =
+    df-anno-use <+
+    df-anno-declare <+
+    df-anno-assign <+
+    df-anno-control-flow <+ 
+    all(df-anno)
+  
+  //annotates read accesses with a list of df-predecessors
+  //@type String -> String{List(String)} 
+  df-anno-use:
+    name -> name{df-annos} 
+    where
+      <is-string> name;
+      df-annos := <bagof-DFAnno> name"
+
+create-extract-refactoring =
+try(<file-exists <+ mkdir> "lib-refactoring");
+<output-text-file(|["lib-refactoring"], "extract-refactoring.generated.str")>
+"/** 
+* Language generic components for Extract refactorings
+*/
+module lib-refactoring/extract-refactoring.generated
+
+imports
+  lib-refactoring/list-operations.generated
+  lib-refactoring/binding-violations.generated 
+  lib/analysis-library-internal.generated 
+  lib-refactoring/fetch-positions.generated
+  
+rules
+  
+  /**
+   * Applies the extract transformation, that is: 
+   * - inserts the extracted construct after the construct where the extraction takes place, and
+   * - replaces the selected elements with a list of new elements (such as missing declarations and a call to the extracted construct) 
+   *
+   * @param match-construct: matches definitions of the extracted sort
+   * @param replacing-terms: List(T), replaces the selected terms
+   * @param extracted-construct: construct that is extracted
+   * @type (List(T), ast) -> ast
+   */  
+  extract-transformation(match-construct|replacing-terms, extracted-construct):
+    (selected, ast) -> ast-transformed
+    where
+      (from, to) := <position-of-sublist-from-to(|ast)> selected;
+      pos-original-method := <fetch-up-position(match-construct|ast)> from;
+      pos-extracted-construct := <position-next-sibling> pos-original-method;
+      ast-transformed := <
+        replace-sublist(|from, to, replacing-terms);
+        insert-list-element(|pos-extracted-construct, extracted-construct)
+      > ast
+
+  /**
+   * @see extract-method-analysis(is-method-definition, analyze-dataflow, get-declaration-name)
+   * @type (List(T), ast) -> (List(VarDecl), List(VarDecl), List(VarDecl), List(VarDecl))
+   */    
+  extract-method-analysis(is-method-definition, analyze-dataflow) =
+    extract-method-analysis(is-method-definition, analyze-dataflow, nam-get-definition-key)
+
+  /**
+   * Calculates the required information to repair the data-flow after method extractions.
+   * Repair consists of inserting missing declarations (preferrable), or passing variable values
+   * in the form of (in-)parameters and return values (out-parameters).
+   *
+   * Determines the missing declarations in the remainder of the original method and the extracted method.
+   * - missing-vardecls-original: declarations of variables that are used in the remainder of the original method, 
+   *   but declared in the extracted method
+   * - missing-vardecls-extracted: declarations of variables that are used in the extracted method, 
+   *   but declared in the remainder of the original method (and not passed as a parameter).
+   *
+   * Determines the required in- and out- parameters based on a data-flow analysis
+   * - in-parameter-vardecls: declarations of variables that are used in the extracted method, 
+   *   after being assigned in the remainder of the original method 
+   * - out-parameter-vardecls: declarations of variables that are used in the remainder of the original method, 
+   *   after being assigned in the extracted method 
+   *
+   * @param is-method-definition: matches method definitions
+   * @param analyze-dataflow: sets data-flow annotations on variable names, so that: 
+   *  - variables with the same df-anno have the same value, e.g., 
+   *    VarDecl(\"a{df-x}\"); VarAssign(\"a{df-y}\"); VarUse(\"a{df-y}\")
+   *  - multiple df-annos can be set to represent different control flows, e.g., 
+   *    If(c, VarAssign(\"a{df-x}\");, VarAssign(\"a{df-y}\");); VarUse(\"a{[df-x, df-y]}\")
+   *   
+   * @param get-declaration-name: maps a declaration onto its name (fails for terms that are not declarations)
+   * @type (List(T), ast) -> (List(VarDecl), List(VarDecl), List(VarDecl), List(VarDecl))
+   */    
+  extract-method-analysis(is-method-definition, analyze-dataflow, get-declaration-name):
+    (selected, ast) -> (missing-vardecls-original, missing-vardecls-extracted,  in-parameter-vardecls, out-parameter-vardecls)
+    where
+      (pos-from-ast, _) := <position-of-sublist-from-to(|ast)> selected;
+      method := <fetch-up-term(is-method-definition|ast)> pos-from-ast; 
+      (from, to) := <position-of-sublist-from-to(|method)> selected;
+      (missing-vardecls-original, missing-vardecls-extracted') :=
+        <extract-method-missing-declarations(get-declaration-name)> (method, from, to);
+      (in-parameter-vardecls, out-parameter-vardecls) :=
+        <extract-method-parameters(analyze-dataflow, get-declaration-name)> (method, from, to);
+      missing-vardecls-extracted := <diff>(missing-vardecls-extracted', in-parameter-vardecls) //exclude in-parameters from the list of missing vardecls
+
+
+rules //helper rules to perform the required data-flow analyses for method extraction 
+
+  /**
+   * Determines the missing declarations in the remainder of the original method and the extracted method.
+   * - missing-vardecls-original: declarations of variables that are used in the remainder of the original method, 
+   *   but declared in the extracted method
+   * - missing-vardecls-extracted: declarations of variables that are used in the extracted method, 
+   *   but declared in the remainder of the original method (and not passed as a parameter).
+   *
+   * @param get-declaration-name: maps a declaration onto its name (fails for terms that are not declarations)
+   * @type (T, List(Int), List(Int)) -> (List(VarDecl), List(VarDecl))
+   */    
+  extract-method-missing-declarations(get-declaration-name):
+    (method, from, to) -> (missing-vardecls-original, missing-vardecls-extracted)
+    where
+      missing-vardecls-original  := <get-missing-declarations(remove-sublist(|from, to), get-declaration-name)> method;
+      missing-vardecls-extracted := <get-missing-declarations(select-sublist(|from, to), get-declaration-name)> method
+
+  get-missing-declarations(transform, get-declaration-name):
+    term-before -> missing-declarations
+    where
+      term-after := <transform> term-before; 
+      declarations-before := <collect-all(where(get-declaration-name))> term-before;
+      declarations-after := <collect-all(where(get-declaration-name))> term-after;
+      lost-declarations := <diff(where(all(get-declaration-name); eq))> (declarations-before, declarations-after);
+      variables-after := <collect-all(is-string)> term-after;
+      missing-declarations := <filter(where(!(<get-declaration-name>, variables-after); elem))> lost-declarations
+  
+  /**
+   * Determines the required in- and out- parameters based on a data-flow analysis
+   * - in-parameters: variables that are used in the extracted method, after being assigned in the remainder of the original method 
+   * - out-parameters: variables that are used in the remainder of the original method, after being assigned in the extracted method 
+   *
+   * @param analyze-dataflow: sets data-flow annotations on variable names, so that: 
+   *  - variables with the same df-anno have the same value, e.g., 
+   *    VarDecl(\"a{df-x}\"); VarAssign(\"a{df-y}\"); VarUse(\"a{df-y}\")
+   *  - multiple df-annos can be set to represent different control flows, e.g., 
+   *    If(c, VarAssign(\"a{df-x}\");, VarAssign(\"a{df-y}\");); VarUse(\"a{[df-x, df-y]}\")
+   *   
+   * @param get-declaration-name: maps a declaration onto its name (fails for terms that are not declarations)
+   * @type (T, List(Int), List(Int)) -> (List(VarDecl), List(VarDecl))
+   */    
+  extract-method-parameters(analyze-dataflow, get-declaration-name):
+    (method, from, to) -> (in-parameter-vardecls, out-parameter-vardecls)
+    where
+      in-parameter-vardecls := <get-df-changed-declarations(select-sublist(|from, to), get-declaration-name, analyze-dataflow)> method;
+      out-parameter-vardecls := <get-df-changed-declarations(remove-sublist(|from, to), get-declaration-name, analyze-dataflow) > method
+
+  get-df-changed-declarations(transform, get-declaration-name, analyze-dataflow):
+    term -> df-changed-declarations
+    where
+      declarations := <collect-all(where(get-declaration-name))> term;
+      declaration-names := <map(get-declaration-name)> declarations;
+      df-changes := <get-df-changes(transform, analyze-dataflow|declaration-names); map(strip-annos); make-set> term;
+      df-changed-declarations := <filter(where(get-declaration-name; is-in-list(|df-changes)))> declarations
+
+  //Calculates df-changes by comparing INTENDED and ACTUAL 
+  //dataflow annotations in the tree after transformation.
+  //Intended df-annos are obtained via <analyze; transform>,
+  //actual df-annos are obtained via <transform; analyze>
+  get-df-changes(transform, analyze-dataflow|declaration-names):
+    term-before -> df-changes
+    where
+      term-after-df-intended := <analyze-dataflow; transform> term-before; 
+      term-after-df-actual := <transform; analyze-dataflow> term-before; 
+      //df-changes := <binding-violation-terms(|declaration-names)>(term-after-df-intended, term-after-df-actual)
+      df-changes := <binding-violation-terms(|declaration-names)>(term-after-df-intended, term-after-df-actual)"
+      
+create-fetch-positions =
+try(<file-exists <+ mkdir> "lib-refactoring");
+<output-text-file(|["lib-refactoring"], "fetch-positions.generated.str")>
+${module lib-refactoring/fetch-positions.generated
+  
+imports
+  lib/editor-common.generated
+  lib-refactoring/list-operations.generated
+    
+rules //strategies for fetching terms and positions in the ast
+  
+  /**
+   * fetches the AST position by visiting the ancestors 
+   * of a term, bottum up, starting at a certain position.
+   * @param match: matches ancestor term to be fetched
+   * @param ast: AST
+   * @type List(Int) ->  List(Int)
+   */ 
+  fetch-up-position(match|ast):
+    position -> position'
+    where
+      term := <term-at-position(|position)> ast;
+      (term', position') := <fetch-up-with-position(match|ast)> (term, position)
+  
+  /**
+   * fetches the first ancestor of a term, bottum up, 
+   * starting at a certain position.
+   * @param matches ancestor term to be fetched
+   * @param AST
+   * @type List(Int) ->  T
+   */ 
+  fetch-up-term(match|ast):
+    position -> term'
+    where
+      term := <term-at-position(|position)> ast;
+      (term', position') := <fetch-up-with-position(match|ast)> (term, position)
+          
+  /**
+   * fetches an ancestor and its AST position by visiting the ancestors of a term, bottum up
+   * @param matches ancestor term to be fetched
+   * @param AST
+   * @type (Term, List(Int)) -> (Term, List(Int))
+   */ 
+  fetch-up-with-position(match|ast):
+    (term, position) -> (term', position')
+    where
+      (term', position') := <fetch-up-with-position(match, fail|ast)> (term, position)
+  
+  /**
+   * fetches an ancestor and its AST position by visiting the ancestors of a term, bottum up
+   * @param matches ancestor term to be fetched
+   * @param stop criteria
+   * @param AST
+   * @type (Term, List(Int)) -> (Term, List(Int))
+   */  
+  fetch-up-with-position(match, stop|ast):
+    (term, position) -> (term', position')
+    where
+      <not(match)> term;
+      <not(stop)> term;
+      parent-tuple := (<parent-at-position(|position)> ast, <init> position);
+      (term', position') := <fetch-up-with-position(match, stop|ast)> parent-tuple
+  
+  fetch-up-with-position(match, stop|ast):
+    (term, position) -> (term, position)
+    where
+      <match> term
+  
+  /**
+   * fetches a subterm in a chain of single-argument nodes
+   * @param matches subterm to be fetched
+   * @type Term -> Term
+   */  
+  fetch-down-term(match):
+    term -> term'
+    where
+      term' := <fetch-down-with-position(match); Fst> (term, [])
+  
+  /**
+   * fetches a subterm and its position in a chain of single-argument nodes
+   * @param matches subterm to be fetched
+   * @type (Term, List(Int)) -> (Term, List(Int))
+   */  
+  fetch-down-with-position(match):
+    (term, position) -> (term', position')
+    where 
+      <not(match)> term; 
+      <get-arguments; ?[e]> term; 
+      (term', position') := <fetch-down-with-position(match)> (e, <conc>(position,[0]))
+    
+  fetch-down-with-position(match):
+    (term, position) -> (term, position)
+    where
+      <match> term
+  
+  
+rules //strategies for getting the tree positions of subterms
+  
+  /**
+   * Returns the term positions of the first and last elements of a (sub)list,
+   * relative to a given ancestor term.
+   *
+   * @param ast, ancestor term
+   * @type ATerm -> (List(Int), List(Int))
+  */  
+  position-of-sublist-from-to(|ast):
+    sublist -> <position-of-sublist-from-to(|ast, [])> sublist
+  
+  /**
+   * Returns the AST positions of the first and last elements of a (sub)list,
+   * calculated from an ancestor term at a given position.
+   *
+   * @param ast, ancestor term
+   * @param position, List(Int) position of ancestor term  
+   * @type ATerm -> (List(Int), List(Int))
+  */  
+  position-of-sublist-from-to(|ast, position):
+    sublist -> (from, to)
+    where
+      from := <Hd; position-of-subterm(|ast, position)> sublist; 
+      to := <last; position-of-subterm(|ast, position)> sublist
+    where
+      lst := <select-sublist(|from, to)> ast;
+      <equal> (<length> lst, <length> sublist) //TODO: origin equal
+      
+  
+  /**
+   * Returns the position of a subterm relative to an ancestor term.
+   *
+   * @param ast, ancestor term
+   * @type ATerm -> List(Int)
+  */
+  position-of-subterm(|ast) =
+    position-of-subterm(|ast, [])
+  
+  /**
+   * Returns the AST position of a subterm,
+   * calculated from an ancestor term at a given position.
+   *
+   * @param term T, ancestor term
+   * @param term-position List(Int), position of ancestor term  
+   * @type ATerm -> List(Int)
+  */
+  position-of-subterm(|term, term-position):
+    subterm -> <conc>(term-position, position)
+    where
+      position := <position-of-term(origin-equal(|subterm))> term
+  
+  
+rules
+  
+  /**
+   * Returns the position of the next sibling
+   *
+   * @type List(Int) -> List(Int)
+  */
+  position-next-sibling = at-last(([i] -> [<inc> i]))
+}
+
+create-list-operations =
+try(<file-exists <+ mkdir> "lib-refactoring");
+<output-text-file(|["lib-refactoring"], "list-operations.generated.str")>
+${module lib-refactoring/list-operations.generated
+  
+imports
+  lib/editor-common.generated
+  lib-refactoring/fetch-positions.generated  
+  
+  
+rules //select list-elements at position
+    
+  /**
+   * Returns the (sub)list that corresponds to the given AST positions 
+   * @param The position of the first element as List(Int)
+   * @param The position of the last element as List(Int)
+   * @type ATerm -> List(a)
+  */
+  select-sublist(|from, to):
+    ast -> sublist
+    where
+      <equal> (<init> from, <init> to) 
+    where
+      list-pos := <init> from;
+      list := <term-at-position(|list-pos)> ast;
+      sublist := <select-partial-list(|<last> from, <last> to)> list
+      
+  /**
+   * Returns the (sub)list that corresponds to the given list indexes 
+   * @param The index of the first element
+   * @param The index of the last element
+   * @type ATerm -> List(a)
+  */
+  select-partial-list(|from, to): 
+    list -> mid-part
+    where 
+      (prefix, suffix) := <split-at(|<inc> to)> list;
+      (pre, mid-part) := <split-at(|from)> prefix
+      
+  /**
+   * Selects a (sub)list based on origin matching
+   *
+   * @param The subsequent list elements to be removed
+   * @type ATerm -> ATerm
+  */    
+  select-sublist(|sublist):
+    term -> <select-sublist(|from, to)> term
+    where
+      (from, to) := <position-of-sublist-from-to(|term)> sublist
+    
+rules //remove list-elements at position
+      
+  /**
+   * Removes list elements at a given position in the AST
+   *
+   * @param The position of the first element to be removed (from) as List(Int)
+   * @param The position of the last element to be removed (to) as List(Int)
+   * @type ATerm -> ATerm
+  */
+  remove-sublist(|from, to):
+    ast -> ast-with-deletion
+    where
+      <equal> (<init> from, <init> to) 
+    where
+      list-pos := <init> from;
+      ast-with-deletion := <at-position-preserve(remove-partial-list(|<last> from, <last> to)|list-pos)> ast
+  
+  /**
+   * Removes elements from a list
+   *
+   * @param The index of the first element to be removed (from)  
+   * @param The index of the last element to be removed (to)
+   * @type List(T) -> List(T)
+  */
+  remove-partial-list(|from, to): 
+    list -> list-after-deletion
+    where 
+      (part1, tail):=<split-at(|from)> list; 
+      (prefix, part2):=<split-at(|<inc> to)> list;
+      list-after-deletion:=<conc> (part1, part2)//TODO: origin tracking
+  
+  /**
+   * Removes an element at a given position in the AST
+   *
+   * @param The position of the element to be removed  
+   * @type ATerm -> ATerm
+  */
+  remove-list-element(|position)=
+    remove-sublist(|position, position)
+
+    
+rules //insert list elements at position
+  
+  /**
+   * Inserts list elements at a given position 
+   *
+   * @param The position for inserting the sublist as List(Int)  
+   * @param The sublist that will be inserted
+   * @type ATerm -> ATerm
+  */
+  insert-sublist(|position, sublist):
+    ast -> ast-with-insertion
+    where
+      list-pos:=<take(|<length; dec> position)> position;
+      ast-with-insertion:=<at-position-preserve(insert-partial-list(|<last> position, sublist)|list-pos)> ast
+  
+  /**
+   * Inserts list elements at a given index 
+   *
+   * @param The index for inserting the sublist  
+   * @param The sublist that will be inserted
+   * @type ATerm -> ATerm
+  */
+  insert-partial-list(|index, sublist): 
+    list -> list-with-insertion
+    where
+      (prefix, suffix):=<split-at(|index)>;
+      list-with-insertion:=<conc> (prefix, sublist, suffix)
+  
+  /**
+   * Inserts an element at a given position 
+   *
+   * @param The position for inserting the sublist as List(Int)
+   * @param The element that will be inserted
+   * @type ATerm -> ATerm
+  */
+  insert-list-element(|position, element)=
+    insert-sublist(|position, [element])
+  
+
+rules //replace list elements at a certain position
+  
+  /**
+   * Replaces a sublist in the AST with another sublist
+   *
+   * @param The position of the first element of the sublist to be replaced (from)  
+   * @param The position of the last element of the sublist to be replaced (to)
+   * @param The new sublist
+   * @type ATerm -> ATerm
+  */
+  replace-sublist(|from, to, sublist)=
+    remove-sublist(|from, to); 
+    insert-sublist(|from, sublist)
+  
+  /**
+   * Replaces a sublist in the AST with a single list element
+   *
+   * @param The position of the first element of the sublist to be replaced (from)  
+   * @param The position of the last element of the sublist to be replaced (to)
+   * @param The new list element
+   * @type ATerm -> ATerm
+  */
+  replace-sublist-with-element(|from, to, element)=
+    replace-sublist(|from, to, [element])
+  
+  /**
+   * Replaces a list-element in the AST with a sublist
+   *
+   * @param The position of the list element that ill be removed   
+   * @param The sublist that will be inserted
+   * @param The new list element
+   * @type ATerm -> ATerm
+  */
+  replace-all-elements-with-sublist-in-list(|position, sublist)=
+    replace-sublist(|position, position, sublist)
+  
+  
+rules //remove list-elements that match a certain criterion
+  
+  /**
+   * Removes all elements matching s  
+   * @param Strategy that determines the elements that will be removed  
+   * @type ATerm -> ATerm
+  */
+  remove-all-elements(s) =
+    topdown(try(remove-all-elements-from-list(s)))
+  
+  /**
+   * Removes all list elements matching s  
+   * @param Strategy that determines the elements that will be removed  
+   * @type List -> List
+  */
+  remove-all-elements-from-list(s) =
+    replace-all-elements-with-sublist-in-list(s|[])
+
+  /**
+   * Removes elements of a (sub)list from a list that is a subterm of the given term
+   *
+   * @param The subsequent list elements to be removed
+   * @type ATerm -> ATerm
+  */    
+  remove-sublist(|sublist):
+    term -> <remove-sublist(|from, to)> term
+    where
+      (from, to) := <position-of-sublist-from-to(|term)> sublist
+
+rules //replace elements that match a certain criterion
+  
+  /**
+   * Replaces all elements in the AST that match a given strategy with a sublist 
+   * @param Strategy that determines the elements that will be replaced
+   * @param Sublist that replaces the elements
+   * @type ATerm -> ATerm
+  */
+  replace-all-elements-with-sublist(s|sublist)=
+    topdown(try(replace-all-elements-with-sublist-in-list(s|sublist)))
+  
+  /**
+   * Replaces list elements matching a certain strategy with a sublist 
+   * @param Strategy that determines the elements that will be replaced
+   * @param Sublist that replaces the elements
+   * @type List -> List
+  */  
+  replace-all-elements-with-sublist-in-list(s|sublist):
+    list -> result-list
+    where 
+      result-list:=<
+        try(
+          split-fetch(s); 
+          <conc>(
+            <Fst>, 
+            sublist, 
+            <Snd; replace-all-elements-with-sublist-in-list(s|sublist)>
+          )
+        )
+      > list
+  
+  
+rules //helpers
+
+  /**
+   * Applies s at the given position in the AST, while preserving the annotations and origin-term. 
+   *
+   * @type AST -> AST
+   * @param strategy to apply
+   * @param position in AST as List(Int) 
+   */  
+  at-position-preserve(s|position) =
+    origin-track-forced(
+      preserve-annos(
+        at-position-preserve-internal(s|position)
+      )
+    )
+  
+  at-position-preserve-internal(s|position):
+    c#(t*) -> t'
+    where
+      !position => [i | position']
+    where
+      t' := c#(<at-index(at-position-preserve(s|position'))> (i, t*))
+
+  at-position-preserve-internal(s|position):
+    t -> t'
+    where
+      !position => [];
+      t' := <s> t
+}
\ No newline at end of file

From m.dejonge at tudelft.nl  Tue Mar  5 16:11:44 2013
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Tue, 05 Mar 2013 15:11:44 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25991 -
	spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project
Message-ID: <20130305151144.447C1CC1DD@mx4.tudelft.nl>

Author: MaartjeDeJonge
Date: Tue Mar  5 15:11:42 2013
New Revision: 25991
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25991&sc=1

Log:
extends binding violation check to cover list bindings at the reads,
i.e., a violation is detected for "a" in: _{[a], [b]} and  _{[a, x], [q,r]}
since "a" can not be matched uniquely

- extract-method
- data-flow checks for data flow

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-refactoring-library.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-refactoring-library.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-refactoring-library.str	Mon Mar  4 14:28:45 2013	(r25990)
+++ spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-refactoring-library.str	Tue Mar  5 15:11:42 2013	(r25991)
@@ -662,7 +662,7 @@
  * Strategy to calculate binding violations by comparing binding annotations that 
  * express the actual and the intended binding structure.
  */
-module lib-refactoring/binding-violations.generated
+module lib-refactoring/binding-violations-new.generated
 
 strategies 
 
@@ -678,7 +678,7 @@
   /**
    * Returns binding violations by comparing the expected binding structure with the actual binding structure
    * in the asts that result after the transformation.
-   * Can be used to check for violations of name reference, control-flow and data-flow.
+   * Can be used to check for violations of name reference.
    * For performance reason, only the 'endangered' terms are compared.
    *
    * The input term must be a tuple (trm-intended-bindings, trm-actual-bindings) whereby
@@ -697,7 +697,7 @@
     where
       binding-violation-terms := <
         bindings-construct-compare-ast;
-        binding-violation-terms-internal(is-endangered-term)
+        binding-violation-terms-internal(fail, is-endangered-term)
       > trees
   
    //Constructs an AST with information about the original binding structure, and the new binding structure.
@@ -710,15 +710,18 @@
   //Returns binding violations by comparing the expected binding with the actual binding, 
   //both set as annotation on terms (t{b-intended, b-actual}) in the 'binding compare AST'.
   //For performance reason, only the 'endangered' terms are compared.
-  binding-violation-terms-internal(is-endangered-term):
-    binding-compare-ast -> binding-violation-terms
+  binding-violation-terms-internal(uses-list-annos, is-endangered-term):
+    binding-compare-ast -> binding-violations
     where 
       all-bindings := <
-        bindings-collect-endangered-terms(is-endangered-term)
+        bindings-collect-endangered-terms(is-endangered-term);
+        filter(has-binding-info)
       > binding-compare-ast; 
-      binding-mapping := <make-set> all-bindings; 
-      binding-violations := <bindings-filter-violations> binding-mapping; 
-      binding-violation-terms := <isect> (all-bindings, binding-violations) 
+      if not(uses-list-annos) then
+        (binding-violations, _) := <bindings-partition-violations> all-bindings
+      else
+        (binding-violations, _) := <bindings-partition-violations-list-annos> all-bindings        
+      end
 
   bindings-collect-endangered-terms(is-endangered-term):
     binding-compare-ast -> bindings-mapping
@@ -727,27 +730,39 @@
         collect-all(?_{_, _}; where(strip-annos; is-endangered-term), conc);
         filter(not(?_{[],[]} <+ ?_{(),()} <+ ?_{None(), None()})) //TODO: nb analysis, ?_{Unresolved(_),Unresolved(_)}
       > binding-compare-ast
-              
-  bindings-filter-violations:
-    binding-mapping -> <concat> [broken-bindings, created-bindings, changed-bindings]
-    where
-      (broken-bindings,  binding-mapping')  := <partition(is-broken-binding)> binding-mapping; 
-      (created-bindings, binding-mapping'') := <partition(is-created-binding)> binding-mapping';
-      changed-bindings := <bindings-filter-changes> binding-mapping''
+  
+  bindings-partition-violations:
+    bindings -> (violated-bindings, binding-mapping)
+    where
+      (broken-bindings,  bindings-1)  := <partition(is-broken-binding)> bindings; 
+      (created-bindings, bindings-2) := <partition(is-created-binding)> bindings-1;
+      (changed-bindings, binding-mapping) := <partition-is-changed-binding> bindings-2;
+      violated-bindings := <concat> [broken-bindings, created-bindings, changed-bindings]
 
-  bindings-filter-changes: 
-    [t{b1,b2}|bindings] -> <conc>(conflicts, <bindings-filter-changes> unrelated-bindings)
+  partition-is-changed-binding: 
+    [t{b1,b2}|bindings] -> (conflicts, mapping)
     where 
       (related-bindings, unrelated-bindings) := <partition(?_{b1,_} <+ ?_{_,b2})> bindings;
+      (rec-conflicts, rec-mapping):= <partition-is-changed-binding> unrelated-bindings;
       if <filter(not(?_{b1,b2})); ?[]> related-bindings then
-        conflicts := []
+        conflicts := rec-conflicts;
+        mapping := [t{b1,b2}| rec-mapping]
       else
-        conflicts := [t{b1,b2}|related-bindings]
+        conflicts := <conc> ([t{b1,b2}|related-bindings], rec-conflicts);
+        mapping := rec-mapping
       end
   
-  bindings-filter-changes:
-    [] -> []
+  partition-is-changed-binding:
+    [] -> ([], [])
 
+  has-binding-info =
+    has-annos;
+    not(
+      ?_{None(), None()} <+
+      ?_{(),()} <+
+      ?_{[],[]}
+    )
+  
   is-broken-binding =
     ?_{_, None()}; not(?_{None(), None()})
 
@@ -798,7 +813,111 @@
   merge-bindings-4:
     (c#(args1), c#(args2)) -> c#(args) 
     where
-      args := <zip; map(merge-bindings)> (args1, args2)"
+      args := <zip; map(merge-bindings)> (args1, args2)
+      
+rules //support for list annotations with the restriction 'single-anno-declarations + mult-anno-reads'
+
+  /**
+   * @see binding-violation-terms-list-annos(is-endangered-term)
+   *
+   * @type  (T, T) -> List(T{b1, b2})
+   * @param endangered-terms  List with terms that must be checked for binding violations
+   */
+  binding-violation-terms-list-annos(|endangered-terms) =
+    binding-violation-terms-list-annos(is-in-list(|endangered-terms))
+
+  /**
+   * Returns binding violations by comparing the expected binding structure with the actual binding structure
+   * in the asts that result after the transformation.
+   * Can be used to check for violations of data-flow where a term can have multiple predecessors.
+   * For performance reason, only the 'endangered' terms are compared.
+   *
+   * The input term must be a tuple (trm-intended-bindings, trm-actual-bindings) whereby
+   * 1) both terms have the same abstract structure
+   * 2) the trm-intended-bindings contains annotations that express the INTENDED binding structure
+   *    (typically obtained by 'analyze; transform' whereby the transformation preserves the original annotations 
+   *     and sets annotations for newly inserted terms)
+   * 3) the trm-actual-bindings contain name annotations that express the ACTUAL binding structure
+   *    (typically obtained by 'transform; analyze', i.e. reanalyzing the resulting asts)
+   * 4) TODO: for now it only works well in case the binding mapping can be constructed by considering single-anno elems only
+   *
+   * @type  (T, T) -> List(T{b1, b2})
+   * @param is-endangered-term  String -> String
+   */  
+  binding-violation-terms-list-annos(is-endangered-term):
+    trees@(trm-intended-bindings, trm-actual-bindings) -> binding-violation-terms
+    where
+      binding-violation-terms := <
+        bindings-construct-compare-ast;
+        binding-violation-terms-internal(id, is-endangered-term)
+      > trees
+
+
+  //Assumption: 'declarations' are single element (lists), 'reads' can be multiple element lists
+  //The single element lists determine the mapping (and may have violations), reads are checked for violations
+  //REMARK: useful for flow analysis where a read-access can have multiple predecessors
+  bindings-partition-violations-list-annos:
+    bindings -> (binding-violations, mapping)
+    where
+      (broken-list-bindings, bindings-1)  := <partition(is-broken-list-binding)> bindings; 
+      (created-list-bindings, bindings-2)  := <partition(is-created-list-binding)> bindings-1; 
+      list-bindings := <map(try(binding-single-to-list))> bindings-2;
+      (changed-list-bindings, mapping) := <bindings-partition-violations-list-annos-2> list-bindings;
+      binding-violations := <concat> [broken-list-bindings, created-list-bindings, changed-list-bindings]
+  
+  //@internal
+  bindings-partition-violations-list-annos-2:
+    list-bindings -> (binding-violations, mapping)
+    with
+      map({lb1, lb2: (?_{lb1, lb2}; <eq>(<length> lb1, <length> lb2))})
+    where 
+      (singleton-bindings, multiple-bindings) := <partition(?_{[_], [_]})> list-bindings; 
+      (singleton-violations, singleton-mappings) := <bindings-partition-violations> singleton-bindings; 
+      (multiple-bindings', list-violations) := <partition(filter-all-bindings-from-list-binding(|singleton-mappings))> multiple-bindings; 
+      if <not(equal)> (multiple-bindings', multiple-bindings) then
+        (rec-violations, rec-mapping) := <bindings-partition-violations-list-annos-2> multiple-bindings'
+      else //TODO: we can not detect violations such as the 'a' in t{[a, b], [r, s]} and t{[a, c], [t, u]}
+        (rec-violations, rec-mapping) := <bindings-partition-violations> multiple-bindings' 
+        //detects '[a,b]' in t{[a, b], [r, s]} and t{[a, b], [r, u]}
+      end;
+      mapping := <conc>(singleton-mappings, rec-mapping);
+      binding-violations := <concat> [singleton-violations, list-violations, rec-violations]
+  
+  
+  filter-all-bindings-from-list-binding(|binding-mapping):
+    lst-binding at t{b_lst1, b_lst2} -> lst-binding'
+    where
+      lst-binding' := <foldr(!lst-binding, filter-binding-mapping-from-list-binding)> binding-mapping
+    
+  filter-binding-mapping-from-list-binding:
+    (_{[b1], [b2]}, t{b_lst1, b_lst2}) -> t{b_lst1', b_lst2'}
+    where
+      (matched-1, b_lst1') := <partition(?b1)> b_lst1;
+      (matched-2, b_lst2') := <partition(?b2)> b_lst2;
+      <eq>(<length> matched-1, <length> matched-2)
+    
+
+  is-broken-list-binding:
+    t{lb1, lb2} -> t{lb1, lb2}
+    where
+      <gt>(<length> lb1, <length> lb2)
+
+  is-broken-list-binding:
+    t{lb1, lb2} -> t{lb1, lb2}
+    where
+      <is-list> lb1;
+      <not(is-list)> lb2
+
+  is-created-list-binding:
+    t{lb1, lb2} -> t{lb1, lb2}
+    where
+      <is-broken-list-binding> t{lb2, lb1}
+      
+  binding-single-to-list:
+    t{b1, b2} -> t{[b1], [b2]}
+    where
+      <not(is-list)> b1;
+      <not(is-list)> b2"
   
 create-data-flow-analysis =
 try(<file-exists <+ mkdir> "lib-refactoring");
@@ -1043,7 +1162,7 @@
       term-after-df-intended := <analyze-dataflow; transform> term-before; 
       term-after-df-actual := <transform; analyze-dataflow> term-before; 
       //df-changes := <binding-violation-terms(|declaration-names)>(term-after-df-intended, term-after-df-actual)
-      df-changes := <binding-violation-terms(|declaration-names)>(term-after-df-intended, term-after-df-actual)"
+      df-changes := <binding-violation-terms-list-annos(|declaration-names)>(term-after-df-intended, term-after-df-actual)"
       
 create-fetch-positions =
 try(<file-exists <+ mkdir> "lib-refactoring");

From m.dejonge at tudelft.nl  Tue Mar  5 16:13:17 2013
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Tue, 05 Mar 2013 15:13:17 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25992 -
	spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project
Message-ID: <20130305151317.18DDC108C010@mx3.tudelft.nl>

Author: MaartjeDeJonge
Date: Tue Mar  5 15:13:16 2013
New Revision: 25992
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25992&sc=1

Log:


Modified:
   spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-refactoring-library.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-refactoring-library.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-refactoring-library.str	Tue Mar  5 15:11:42 2013	(r25991)
+++ spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-refactoring-library.str	Tue Mar  5 15:13:16 2013	(r25992)
@@ -662,7 +662,7 @@
  * Strategy to calculate binding violations by comparing binding annotations that 
  * express the actual and the intended binding structure.
  */
-module lib-refactoring/binding-violations-new.generated
+module lib-refactoring/binding-violations.generated
 
 strategies 
 

From m.dejonge at tudelft.nl  Tue Mar  5 16:40:13 2013
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Tue, 05 Mar 2013 15:40:13 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25993 -
	spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project
Message-ID: <20130305154013.DF1A6CC1EE@mx4.tudelft.nl>

Author: MaartjeDeJonge
Date: Tue Mar  5 15:40:12 2013
New Revision: 25993
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25993&sc=1

Log:
name-binding-preservation uses new binding-violation module

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-refactoring-library.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-refactoring-library.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-refactoring-library.str	Tue Mar  5 15:13:16 2013	(r25992)
+++ spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-refactoring-library.str	Tue Mar  5 15:40:12 2013	(r25993)
@@ -134,6 +134,7 @@
 imports
   lib-refactoring/analysis-multifile.generated
   lib/index-library.generated
+  lib-refactoring/binding-violations.generated
 
 strategies
 
@@ -197,91 +198,15 @@
     (asts-expected-bindings, asts-actual-bindings)  -> binding-violation-errors
     where
       binding-violation-errors := <
-        name-binding-violation-terms-on-trees(is-endangered-name);
+        binding-violation-terms(is-endangered-name);
+        filter(not(?_{[Unresolved(_)|_], [Unresolved(_)|_]}));
         map(to-namebinding-error)
       > (asts-expected-bindings, asts-actual-bindings)
 
-  /**
-   * Returns name binding violations by comparing the expected binding structure with the actual binding structure.
-   * For performance reason, only the 'endangered' names are compared.
-   *
-   * The input term must be a tuple (asts-expected, asts-actual) whereby
-   * 1) both terms have the same abstract structure
-   * 2) the asts-expected contain name annotations that express the EXPECTED binding structure
-   *    (typically obtained by preserving annos during transformation and setting annos for new inserted definitions)
-   * 3) the asts-actual contain name annotations that express the ACTUAL binding structure
-   *    (typically obtained by reanalyzing the asts-expected)
-   *
-   * @type  (asts-expected, asts-actual) -> List(t{nb1, nb2})
-   * @param is-endangered-name  String -> String
-   */  
-  name-binding-violation-terms-on-trees(is-endangered-name):
-    trees@(asts-expected-bindings, asts-actual-bindings) -> binding-violation-terms
-    where
-      binding-violation-terms := <
-        name-binding-construct-compare-ast;
-        name-binding-violation-terms-on-compare-tree(is-endangered-name)
-      > trees
-  
-   //Constructs an AST with information about the original binding structure, and the new binding structure.
-   //Condition: 'asts-expected-bindings' and 'asts-actual-bindings' have the same structure and contain binding information.
-  name-binding-construct-compare-ast:
-    (asts-expected-bindings, asts-actual-bindings) -> binding-compare-ast
-    where
-      binding-compare-ast := <merge-bindings>(asts-expected-bindings, asts-actual-bindings)
-  
-  //Returns name binding violations by comparing the expected binding with the actual binding, 
-  //both set as annotation on identifier terms.
-  //For performance reason, only the 'endangered' names are compared.
-  name-binding-violation-terms-on-compare-tree(is-endangered-name):
-    binding-compare-ast -> binding-violation-terms
-    where 
-      all-bindings := <
-        collect-binding-pairs(is-endangered-name)
-      > binding-compare-ast; 
-      binding-mapping := <make-set> all-bindings; 
-      binding-violations := <filter-violations> binding-mapping; 
-      binding-violation-terms := <isect> (all-bindings, binding-violations) 
-
-  collect-binding-pairs(is-endangered-name):
-    binding-compare-ast -> bindings-mapping
-    where
-      bindings-mapping := <
-        collect-all(is-string; ?_{_, _}; where(strip-annos; is-endangered-name), conc)
-      > binding-compare-ast
-              
-  filter-violations:
-    binding-mapping -> <concat> [broken-bindings, created-bindings, changed-bindings]
-    where
-      (broken-bindings,  binding-mapping')  := <partition(is-broken-binding)> binding-mapping;
-      (created-bindings, binding-mapping'') := <partition(is-created-binding)> binding-mapping';
-      changed-bindings := <filter-changed-bindings> binding-mapping''
-
-  filter-changed-bindings: 
-    [t{nb1,nb2}|bindings] -> <conc>(conflicts, <filter-changed-bindings> unrelated-bindings)
-    where 
-      (related-bindings, unrelated-bindings) := <partition(?_{nb1,_} <+ ?_{_,nb2})> bindings;
-      if <filter(not(?_{nb1,nb2})); ?[]> related-bindings then
-        conflicts := []
-      else
-        conflicts := [t{nb1,nb2}|related-bindings]
-      end
-  
-  filter-changed-bindings:
-    [] -> []
-
-  is-broken-binding =
-    ?_{_, None()} 
-
   is-broken-binding =
     ?_{nb1, [Unresolved(_)|_]};
     where(<not(?[Unresolved(_)|_])> nb1) 
   
-  is-created-binding =
-    ?n{nb1, nb2}; 
-    where(<is-broken-binding> n{nb2, nb1})
-
-
 rules //report name binding violation to end user
 
   to-namebinding-error =
@@ -296,48 +221,7 @@
     <is-created-binding> -> (<strip-annos>, $[Unbound variabele becomes bound '[<strip-annos>]'])
 
   to-namebinding-error-changed:
-    t{nb1, nb2} -> (<strip-annos>, $[Name collision with name '[<strip-annos>]'])
-
-rules //helpers
-
-  is-in-list(|names):
-    name -> name
-    where
-      <fetch(?name{})> names
-
-  //@internal    
-  merge-bindings =
-    merge-bindings-1 <+
-    merge-bindings-2 <+
-    merge-bindings-3 <+
-    merge-bindings-4
-  
-  //@internal    
-  merge-bindings-1:
-    (s1{nb1}, s2{nb2}) -> s1{nb1, nb2}
-    where
-      <is-string> s1;
-      <equal> (s1{},s2{})
-  
-  //@internal    
-  merge-bindings-2:
-    (s1{nb1}, s2{}) -> s1{nb1, None()}
-    where
-      <is-string> s1;
-      <equal> (s1{},s2{})
-  
-  //@internal    
-  merge-bindings-3:
-    (s1{}, s2{nb2}) -> s1{None(), nb2}
-    where
-      <is-string> s1;
-      <equal> (s1{},s2{})
-  
-  //@internal    
-  merge-bindings-4:
-    (c#(args1), c#(args2)) -> c#(args) 
-    where
-      args := <zip; map(merge-bindings)> (args1, args2)"
+    t{nb1, nb2} -> (<strip-annos>, $[Name collision with name '[<strip-annos>]'])"
 
 
 create-correctness-preservation =
@@ -727,8 +611,7 @@
     binding-compare-ast -> bindings-mapping
     where
       bindings-mapping := <
-        collect-all(?_{_, _}; where(strip-annos; is-endangered-term), conc);
-        filter(not(?_{[],[]} <+ ?_{(),()} <+ ?_{None(), None()})) //TODO: nb analysis, ?_{Unresolved(_),Unresolved(_)}
+        collect-all(?_{_, _}; where(strip-annos; is-endangered-term), conc)
       > binding-compare-ast
   
   bindings-partition-violations:

From g.h.wachsmuth at tudelft.nl  Wed Mar  6 01:00:28 2013
From: g.h.wachsmuth at tudelft.nl (Guido Wachsmuth)
Date: Wed, 06 Mar 2013 00:00:28 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25994 -
	spoofax-imp/branches/nbl-dev/syntax
Message-ID: <20130306000028.F1D502B8010@mx2.tudelft.nl>

Author: GuidoWachsmuth
Date: Wed Mar  6 00:00:27 2013
New Revision: 25994
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25994&sc=1

Log:
added missing features to syntax definition:

1. overlays for names inside a term (needed for Java)
2. constraints for qualifiers (needed for Java)
3. alternative imports (needed for Java)
4. properties for nested references (e.g. `refers to Foo bar in Bar foo of type T`, here `of type T` restricts possible resolutions of `Bar foo`)
5. arbitrary deep nestings of references (e.g. `refers to Foo bar in Bar foo in Foobar foobar`)

Modified:
   spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.sdf

Modified: spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.sdf
==============================================================================
--- spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.sdf	Tue Mar  5 15:40:12 2013	(r25993)
+++ spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.sdf	Wed Mar  6 00:00:27 2013	(r25994)
@@ -27,7 +27,7 @@
 		
 	context-free syntax %% imports
 				
-		"imports" ImportModName* 														-> ModSection {"Imports"}
+		"imports" ImportModName* 														-> ModSection 		{"Imports"}
     ModName																							-> ImportModName	{"Import"}
 
   syntax
@@ -83,10 +83,9 @@
 
 		{RefPart "otherwise"}+															-> NamingRulePart	{"UseSite"} 		
 		"refers" "to" RefPartCore 													-> RefPart				{bracket}
-		IBinding BProperty* RefScope Constraint*						-> RefPartCore		{"Reference"}
+		IBinding Property* RefScope Constraint*							-> RefPartCore		{"Reference"}
 			
-		%% TODO this should be RefPartCore, but without additional constraints
-		"in" Binding																				-> RefScope			 	{"RefScope"}
+		"in" IBinding	Property* RefScope 										-> RefScope			 	{"RefScope"}
 		"in" "current" "scope"															-> RefScope				{"Current"}
 		"in" "surrounding" NamespaceRef											-> RefScope				{"Surrounding"}
 																												-> RefScope				{"All"}
@@ -94,12 +93,21 @@
 	context-free syntax %% qualified names
 
 		{QualifiedPart "otherwise"}+												-> NamingRulePart	{"QualifiedName"} 		
-		"qualifies" Binding "in" Binding 										-> QualifiedPart	{bracket}
+		"qualifies" Binding "in" Binding Constraint*				-> QualifiedPart	{"Qualifier"}
+		
+		{NamedPart "otherwise"}+														-> NamingRulePart	{"OverlayName"} 		
+		"names" Binding									 										-> NamedPart			{"Overlay"}
 		
 	context-free syntax %% imports
 		
-		"imports"{INamespaceRef ","}+ "from" RefPartCore IDefScopes	-> NamingRulePart {"ImportFromSite"}
-		"imports"{INamespaceRef ","}+ "into" RefPartCore IDefScopes	-> NamingRulePart {"ImportToSite"}
+		{ImportPart "otherwise"}+														-> NamingRulePart	{"ImportSite"} 		
+		{INamespaceRef ","}+ "from" IRefScope IDefScopes		-> ImportPart			{bracket}
+		
+		"imports"	-> NamingRulePart {"ImportFromSite"}
+		%% "imports"{INamespaceRef ","}+ "into" RefPartCore IDefScopes	-> NamingRulePart {"ImportToSite"}
+		
+		RefPartCore																					-> IRefScope			
+		RTerm																								-> IRefScope			{"RefScope"}
 		
 																												-> IDefScopes			{"Current"}
 		"into" "current" "scope"														-> IDefScopes			{"Current"}

From g.h.wachsmuth at tudelft.nl  Wed Mar  6 04:20:24 2013
From: g.h.wachsmuth at tudelft.nl (Guido Wachsmuth)
Date: Wed, 06 Mar 2013 03:20:24 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25995 - in
	spoofax-imp/branches/nbl-dev: editor syntax
	syntax/documentation trans
Message-ID: <20130306032024.3032F2B8014@mx2.tudelft.nl>

Author: GuidoWachsmuth
Date: Wed Mar  6 03:20:22 2013
New Revision: 25995
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25995&sc=1

Log:
added initial support for documentation and metadata

Added:
   spoofax-imp/branches/nbl-dev/syntax/documentation/
   spoofax-imp/branches/nbl-dev/syntax/documentation/Development.sdf
   spoofax-imp/branches/nbl-dev/syntax/documentation/Documentation.sdf
   spoofax-imp/branches/nbl-dev/syntax/documentation/Metadata.sdf
Modified:
   spoofax-imp/branches/nbl-dev/editor/NameBindingLanguage-Colorer.esv
   spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.generated.pp
   spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.sdf
   spoofax-imp/branches/nbl-dev/trans/names.nd
   spoofax-imp/branches/nbl-dev/trans/names.str
   spoofax-imp/branches/nbl-dev/trans/new-generate.str

Modified: spoofax-imp/branches/nbl-dev/editor/NameBindingLanguage-Colorer.esv
==============================================================================
--- spoofax-imp/branches/nbl-dev/editor/NameBindingLanguage-Colorer.esv	Wed Mar  6 00:00:27 2013	(r25994)
+++ spoofax-imp/branches/nbl-dev/editor/NameBindingLanguage-Colorer.esv	Wed Mar  6 03:20:22 2013	(r25995)
@@ -14,4 +14,16 @@
   
   PropertyId._ : 0 64 128 italic //bold
   PropertyRef._: 0 64 128 italic bold
-  
\ No newline at end of file
+  
+colorer documentation
+
+  ModMetaData  : 0 0 0 bold
+  Documentation: 0 0 0 bold
+  VersionNumber: 96 96 96
+  EMailAddress : 96 96 96 italic
+  EMail        : 96 96 96
+  Name         : 96 96 96
+  Assignee     : 96 96 96
+  Text         : 96 96 96
+  CodeFragment : 0 96 160
+  TestSuite    : 96 96 96
\ No newline at end of file

Modified: spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.generated.pp
==============================================================================
--- spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.generated.pp	Wed Mar  6 00:00:27 2013	(r25994)
+++ spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.generated.pp	Wed Mar  6 03:20:22 2013	(r25995)
@@ -1,4 +1,24 @@
 [
+   Todo                                                   -- KW["todo"] _1 _2,
+   Fixme                                                  -- KW["fixme"] _1 _2,
+   Discuss                                                -- KW["discuss"] _1 _2,
+   TestSuite                                              -- KW["test"] KW["suite"] _1,
+   None                                                   -- ,
+   AssignedTo                                             -- _1 KW[":"],
+   AssignedTo.1:iter-sep                                  -- _1 KW[","],
+   AssignedTo.1:iter-sep.1:iter                           -- _1,
+   Example                                                -- KW["example"] _1,
+   Description                                            -- KW["description"] _1,
+   Version                                                -- KW["version"] _1,
+   Status                                                 -- V  [H  [KW["status"]] _1],
+   Status.1:iter                                          -- _1,
+   Author                                                 -- KW["author"] _1 _2 _3,
+   Author.1:iter                                          -- _1,
+   None                                                   -- ,
+   EMail                                                  -- KW["("] _1 KW[")"],
+   None                                                   -- ,
+   Affiliation                                            -- V  [H  [KW[","]] _1],
+   Affiliation.1:iter                                     -- _1,
    Int                                                    -- _1,
    Real                                                   -- _1,
    Str                                                    -- _1,
@@ -44,8 +64,9 @@
    ListVar                                                -- _1,
    VarRef                                                 -- _1,
    ListVarRef                                             -- _1,
-   Module                                                 -- KW["module"] _1 _2,
+   Module                                                 -- KW["module"] _1 _2 _3,
    Module.2:iter-star                                     -- _1,
+   Module.3:iter-star                                     -- _1,
    Imports                                                -- V  [H  [KW["imports"]] _1],
    Imports.1:iter-star                                    -- _1,
    Import                                                 -- _1,
@@ -62,8 +83,9 @@
    TypeProp                                               -- KW["type"],
    BindingRules                                           -- V  [H  [KW["binding"] KW["rules"]] _1],
    BindingRules.1:iter-star                               -- _1,
-   BindingRule                                            -- _1 KW[":"] _2,
-   BindingRule.2:iter                                     -- _1,
+   BindingRule                                            -- _1 _2 KW[":"] _3,
+   BindingRule.1:iter-star                                -- _1,
+   BindingRule.3:iter                                     -- _1,
    DefSite                                                -- KW["defines"] _1 _2 _3 _4 _5,
    DefSite.3:iter-star                                    -- _1,
    DefSite.5:iter-star                                    -- _1,
@@ -88,16 +110,23 @@
    Reference                                              -- _1 _2 _3 _4,
    Reference.2:iter-star                                  -- _1,
    Reference.4:iter-star                                  -- _1,
-   RefScope                                               -- KW["in"] _1,
+   RefScope                                               -- KW["in"] _1 _2 _3,
+   RefScope.2:iter-star                                   -- _1,
    Current                                                -- KW["in"] KW["current"] KW["scope"],
    Surrounding                                            -- KW["in"] KW["surrounding"] _1,
    All                                                    -- ,
    QualifiedName                                          -- _1,
    QualifiedName.1:iter-sep                               -- _1 KW["otherwise"],
-   ImportFromSite                                         -- KW["imports"] _1 KW["from"] _2 _3,
-   ImportFromSite.1:iter-sep                              -- _1 KW[","],
-   ImportToSite                                           -- KW["imports"] _1 KW["into"] _2 _3,
-   ImportToSite.1:iter-sep                                -- _1 KW[","],
+   Qualifier                                              -- KW["qualifies"] _1 KW["in"] _2 _3,
+   Qualifier.3:iter-star                                  -- _1,
+   OverlayName                                            -- _1,
+   OverlayName.1:iter-sep                                 -- _1 KW["otherwise"],
+   Overlay                                                -- KW["names"] _1,
+   ImportSite                                             -- _1,
+   ImportSite.1:iter-sep                                  -- _1 KW["otherwise"],
+   Import                                                 -- KW["imports"] _1 KW["from"] _2 _3,
+   Import.1:iter-sep                                      -- _1 KW[","],
+   RefScope                                               -- _1,
    Current                                                -- ,
    Current                                                -- KW["into"] KW["current"] KW["scope"],
    DefScopes                                              -- V  [H  [KW["into"]] _1],

Modified: spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.sdf
==============================================================================
--- spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.sdf	Wed Mar  6 00:00:27 2013	(r25994)
+++ spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.sdf	Wed Mar  6 03:20:22 2013	(r25995)
@@ -8,7 +8,10 @@
 	stratego/NDL-Signatures
 	stratego/NDL-Terms[Var]
 	stratego/NDL-Terms[VarRef]
-		
+	documentation/Metadata
+	documentation/Documentation
+	documentation/Development
+	
 exports 
   
 	context-free start-symbols
@@ -22,7 +25,7 @@
   	
 	context-free syntax
 		
-		"module" ModName ModSection*												-> Start 					{"Module"}
+		"module" ModName ModMetaData* ModSection*						-> Start 					{"Module"}
 		
 		
 	context-free syntax %% imports
@@ -34,7 +37,6 @@
 
 		<ModName-CF> "/" "-" 																-> <ImportModName-CF> {"ImportWildcard"}
     
-
 	context-free syntax %% sections
 		
 		%% Namespaces
@@ -53,7 +55,7 @@
 
 		"binding" "rules" NamingRule*												-> ModSection			{"BindingRules"}
 
-		BTerm ":" NamingRulePart+														-> NamingRule			{"BindingRule"}
+		Documentation* BTerm ":" NamingRulePart+						-> NamingRule			{"BindingRule"}
 		
 	context-free syntax %% definition sites	
 		
@@ -83,7 +85,7 @@
 
 		{RefPart "otherwise"}+															-> NamingRulePart	{"UseSite"} 		
 		"refers" "to" RefPartCore 													-> RefPart				{bracket}
-		IBinding Property* RefScope Constraint*							-> RefPartCore		{"Reference"}
+		IBinding BProperty* RefScope Constraint*						-> RefPartCore		{"Reference"}
 			
 		"in" IBinding	Property* RefScope 										-> RefScope			 	{"RefScope"}
 		"in" "current" "scope"															-> RefScope				{"Current"}
@@ -100,10 +102,9 @@
 		
 	context-free syntax %% imports
 		
-		{ImportPart "otherwise"}+														-> NamingRulePart	{"ImportSite"} 		
-		{INamespaceRef ","}+ "from" IRefScope IDefScopes		-> ImportPart			{bracket}
-		
-		"imports"	-> NamingRulePart {"ImportFromSite"}
+		{ImportPart "otherwise"}+														       -> NamingRulePart	{"ImportSite"} 		
+		"imports"	{INamespaceRef ","}+ "from" IRefScope IDefScopes -> ImportPart			{"Import"}
+
 		%% "imports"{INamespaceRef ","}+ "into" RefPartCore IDefScopes	-> NamingRulePart {"ImportToSite"}
 		
 		RefPartCore																					-> IRefScope			

Added: spoofax-imp/branches/nbl-dev/syntax/documentation/Development.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/nbl-dev/syntax/documentation/Development.sdf	Wed Mar  6 03:20:22 2013	(r25995)
@@ -0,0 +1,21 @@
+module documentation/Development
+
+imports 
+	stratego/NDL-Identifiers
+	documentation/Documentation
+	documentation/Metadata
+
+exports 
+	
+	lexical syntax
+		
+		ModName -> TestSuite
+		
+	context-free syntax
+		
+		"todo"    Assignee Text  -> Documentation {"Todo"}
+		"fixme"   Assignee Text  -> Documentation {"Fixme"}
+		"discuss" Assignee Text  -> Documentation {"Discuss", prefer}
+		"test" "suite" TestSuite -> ModMetaData {"TestSuite"}
+		
+		{Name+ ","}+             -> Assignee {"AssignedTo"}										 		
\ No newline at end of file

Added: spoofax-imp/branches/nbl-dev/syntax/documentation/Documentation.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/nbl-dev/syntax/documentation/Documentation.sdf	Wed Mar  6 03:20:22 2013	(r25995)
@@ -0,0 +1,25 @@
+module documentation/Documentation
+
+exports
+	
+	lexical syntax 
+		
+		"`" ~[\`\n]* "`"          					-> InlineCodeFragment
+		"[[" (~[\]]|ClosingBracket)* "]]"   -> CodeFragment
+		
+		"]" -> ClosingBracket
+		
+		"--" (~[\-]|Minus)* "--"   -> Text
+		
+		"-" -> Minus		
+		
+	lexical restrictions
+		
+		ClosingBracket -/- [\]]
+		Minus -/- [\-]
+		
+	context-free syntax
+		
+		"example" CodeFragment  -> Documentation {"Example"}
+		"description" Text      -> Documentation {"Description"}
+		
\ No newline at end of file

Added: spoofax-imp/branches/nbl-dev/syntax/documentation/Metadata.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/nbl-dev/syntax/documentation/Metadata.sdf	Wed Mar  6 03:20:22 2013	(r25995)
@@ -0,0 +1,36 @@
+module documentation/Metadata
+	
+exports 
+  
+  lexical syntax
+  	
+  	[A-Za-z]+                                         -> Name
+  	
+  	[A-Za-z0-9\!\#\$\%\&\'\*\+\/\=\?\^\_\`\{\|\}\~\-] -> EMailChar
+  	[A-Za-z0-9]([A-Za-z0-9\-]*[A-Za-z0-9])?           -> DomainPart
+  	"." | " dot "                                     -> Dot
+  	{EMailChar+ Dot}+ ("@"|" at ") {DomainPart Dot}+  -> EMailAddress
+  	  	
+  	{[0-9]+ "."}+                                     -> VersionNumber
+  	 
+  	"version" -> Name {reject}
+  	"status"  -> Name {reject}
+  	"author"  -> Name {reject}
+  	
+  lexical restrictions
+  	
+  	Name          -/- [A-Za-z]
+  	DomainPart    -/- [A-Za-z0-9\-]
+  	VersionNumber -/- [0-9\.]
+  	
+	context-free syntax
+  
+  	"version"	VersionNumber						-> ModMetaData {"Version"}
+  	"status" Name+ 									  -> ModMetaData {"Status"}
+  	"author" Name+ EMail Affiliation  -> ModMetaData {"Author"}  
+  	                                  -> EMail       {"None"}
+  	"(" EMailAddress ")"              -> EMail       {"EMail"}
+  	                                  -> Affiliation {"None"}
+  	"," Name+                         -> Affiliation {"Affiliation"}
+  	
+  	
\ No newline at end of file

Modified: spoofax-imp/branches/nbl-dev/trans/names.nd
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/names.nd	Wed Mar  6 00:00:27 2013	(r25994)
+++ spoofax-imp/branches/nbl-dev/trans/names.nd	Wed Mar  6 03:20:22 2013	(r25995)
@@ -35,7 +35,7 @@
 
 rules
 
-	BindingRule(_, _):
+	BindingRule(_, _, _):
 		scopes Variable
 		
 	Var(x):

Modified: spoofax-imp/branches/nbl-dev/trans/names.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/names.str	Wed Mar  6 00:00:27 2013	(r25994)
+++ spoofax-imp/branches/nbl-dev/trans/names.str	Wed Mar  6 03:20:22 2013	(r25995)
@@ -138,7 +138,7 @@
 rules
 
   nam-get-scope-types :
-    BindingRule(_, _) -> [Variable()]
+    BindingRule(_, _, _) -> [Variable()]
 
 
 rules

Modified: spoofax-imp/branches/nbl-dev/trans/new-generate.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/new-generate.str	Wed Mar  6 00:00:27 2013	(r25994)
+++ spoofax-imp/branches/nbl-dev/trans/new-generate.str	Wed Mar  6 03:20:22 2013	(r25995)
@@ -61,7 +61,7 @@
 		
 	// TODO: support multiple definition sites
 	nabl-to-str: 
-		BindingRule(pattern, parts) -> [defscope*, use*]
+		BindingRule(_, pattern, parts) -> [defscope*, use*]
 		where
 			scopes := <filter(?Scopes(<id>)); concat; map(nabl-to-str)> parts
 		where
@@ -93,11 +93,8 @@
 	
 	
 	use-to-str(|pattern):
-		ImportFromSite(_, ref, _) -> <refs-to-str(|pattern)> [ref]
+		Import(_, ref, _) -> <refs-to-str(|pattern)> [ref]
 			
-	use-to-str(|pattern):
-		ImportToSite(_, ref, _) -> <refs-to-str(|pattern)> [ref]
-	
 	// TODO: support properties
 	// TODO: support conditions
 	refs-to-str(|pattern):	
@@ -110,7 +107,7 @@
 		Reference(NameBinding(ns, _), [], All(), []) -> CANDIDATE(<nabl-to-str> ns)
 	
 	ref-to-str: 
-		Reference(NameBinding(ns, _), [], RefScope(NameBinding(ns', t)), []) -> CANDIDATE(<nabl-to-str> ns, <nabl-to-str> ns', <to-ppable-str> t)
+		Reference(NameBinding(ns, _), [], RefScope(NameBinding(ns', t), _, _), []) -> CANDIDATE(<nabl-to-str> ns, <nabl-to-str> ns', <to-ppable-str> t)
 	
 	
 	nabl-to-str: Current() -> TERM("Current")

From g.h.wachsmuth at tudelft.nl  Wed Mar  6 08:49:58 2013
From: g.h.wachsmuth at tudelft.nl (Guido Wachsmuth)
Date: Wed, 06 Mar 2013 07:49:58 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25996 - in
	spoofax-imp/branches/nbl-dev/syntax: . documentation stratego terms
Message-ID: <20130306074958.1F2AB7F801D@mx1.tudelft.nl>

Author: GuidoWachsmuth
Date: Wed Mar  6 07:49:56 2013
New Revision: 25996
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25996&sc=1

Log:
minor fixes, renamed Stratego syntax definitions

Added:
   spoofax-imp/branches/nbl-dev/syntax/terms/
      - copied from r25981, spoofax-imp/branches/nbl-dev/syntax/stratego/
   spoofax-imp/branches/nbl-dev/syntax/terms/Constants.sdf
      - copied, changed from r25981, spoofax-imp/branches/nbl-dev/syntax/stratego/NDL-Constants.sdf
   spoofax-imp/branches/nbl-dev/syntax/terms/Identifiers.sdf
      - copied, changed from r25981, spoofax-imp/branches/nbl-dev/syntax/stratego/NDL-Identifiers.sdf
   spoofax-imp/branches/nbl-dev/syntax/terms/Layout.sdf
      - copied, changed from r25981, spoofax-imp/branches/nbl-dev/syntax/stratego/NDL-Layout.sdf
   spoofax-imp/branches/nbl-dev/syntax/terms/Signatures.sdf
      - copied, changed from r25981, spoofax-imp/branches/nbl-dev/syntax/stratego/NDL-Signatures.sdf
   spoofax-imp/branches/nbl-dev/syntax/terms/StringQuotations.sdf
      - copied, changed from r25981, spoofax-imp/branches/nbl-dev/syntax/stratego/NDL-StringQuotations.sdf
   spoofax-imp/branches/nbl-dev/syntax/terms/Terms.sdf
      - copied, changed from r25981, spoofax-imp/branches/nbl-dev/syntax/stratego/NDL-Terms.sdf
   spoofax-imp/branches/nbl-dev/syntax/terms/Vars.sdf
      - copied, changed from r25981, spoofax-imp/branches/nbl-dev/syntax/stratego/NDL-Vars.sdf
Deleted:
   spoofax-imp/branches/nbl-dev/syntax/stratego/
   spoofax-imp/branches/nbl-dev/syntax/terms/NDL-Constants.sdf
   spoofax-imp/branches/nbl-dev/syntax/terms/NDL-Identifiers.sdf
   spoofax-imp/branches/nbl-dev/syntax/terms/NDL-Layout.sdf
   spoofax-imp/branches/nbl-dev/syntax/terms/NDL-Signatures.sdf
   spoofax-imp/branches/nbl-dev/syntax/terms/NDL-StringQuotations.sdf
   spoofax-imp/branches/nbl-dev/syntax/terms/NDL-Terms.sdf
   spoofax-imp/branches/nbl-dev/syntax/terms/NDL-Vars.sdf
Modified:
   spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.generated.pp
   spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.sdf
   spoofax-imp/branches/nbl-dev/syntax/documentation/Development.sdf

Modified: spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.generated.pp
==============================================================================
--- spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.generated.pp	Wed Mar  6 03:20:22 2013	(r25995)
+++ spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.generated.pp	Wed Mar  6 07:49:56 2013	(r25996)
@@ -3,10 +3,9 @@
    Fixme                                                  -- KW["fixme"] _1 _2,
    Discuss                                                -- KW["discuss"] _1 _2,
    TestSuite                                              -- KW["test"] KW["suite"] _1,
-   None                                                   -- ,
-   AssignedTo                                             -- _1 KW[":"],
-   AssignedTo.1:iter-sep                                  -- _1 KW[","],
-   AssignedTo.1:iter-sep.1:iter                           -- _1,
+   AssignedTo                                             -- _1,
+   AssignedTo.1:iter-star-sep                             -- _1 KW[","],
+   AssignedTo.1:iter-star-sep.1:iter                      -- _1,
    Example                                                -- KW["example"] _1,
    Description                                            -- KW["description"] _1,
    Version                                                -- KW["version"] _1,

Modified: spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.sdf
==============================================================================
--- spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.sdf	Wed Mar  6 03:20:22 2013	(r25995)
+++ spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.sdf	Wed Mar  6 07:49:56 2013	(r25996)
@@ -2,12 +2,12 @@
 
 imports
   
-	stratego/NDL-Layout
-	stratego/NDL-Identifiers
-	stratego/NDL-Vars
-	stratego/NDL-Signatures
-	stratego/NDL-Terms[Var]
-	stratego/NDL-Terms[VarRef]
+	terms/Layout
+	terms/Identifiers
+	terms/Vars
+	terms/Signatures
+	terms/Terms[Var]
+	terms/Terms[VarRef]
 	documentation/Metadata
 	documentation/Documentation
 	documentation/Development

Modified: spoofax-imp/branches/nbl-dev/syntax/documentation/Development.sdf
==============================================================================
--- spoofax-imp/branches/nbl-dev/syntax/documentation/Development.sdf	Wed Mar  6 03:20:22 2013	(r25995)
+++ spoofax-imp/branches/nbl-dev/syntax/documentation/Development.sdf	Wed Mar  6 07:49:56 2013	(r25996)
@@ -1,7 +1,7 @@
 module documentation/Development
 
 imports 
-	stratego/NDL-Identifiers
+	terms/Identifiers
 	documentation/Documentation
 	documentation/Metadata
 
@@ -16,6 +16,6 @@
 		"todo"    Assignee Text  -> Documentation {"Todo"}
 		"fixme"   Assignee Text  -> Documentation {"Fixme"}
 		"discuss" Assignee Text  -> Documentation {"Discuss", prefer}
-		"test" "suite" TestSuite -> ModMetaData {"TestSuite"}
+		"test" "suite" TestSuite -> ModMetaData   {"TestSuite"}
 		
-		{Name+ ","}+             -> Assignee {"AssignedTo"}										 		
\ No newline at end of file
+		{Name+ ","}*             -> Assignee {"AssignedTo"}										 		
\ No newline at end of file

Copied and modified: spoofax-imp/branches/nbl-dev/syntax/terms/Constants.sdf (from r25981, spoofax-imp/branches/nbl-dev/syntax/stratego/NDL-Constants.sdf)
==============================================================================
--- spoofax-imp/branches/nbl-dev/syntax/stratego/NDL-Constants.sdf	Wed Feb 27 10:49:27 2013	(r25981, copy source)
+++ spoofax-imp/branches/nbl-dev/syntax/terms/Constants.sdf	Wed Mar  6 07:49:56 2013	(r25996)
@@ -1,16 +1,21 @@
-module stratego/NDL-Constants
+module terms/Constants
+
 exports
+
   sorts Int Real String StrChar
+
   lexical syntax
-    [\-]? [0-9]+ 		-> Int
+
+    [\-]? [0-9]+              -> Int
     [\-]? [0-9]+ [\.] [0-9]+ 	-> Real
-    "\"" StrChar* "\"" 		-> String
-    ~[\"\\] 			-> StrChar
-    [\\] [\"tnr\\] 		-> StrChar
+    "\"" StrChar* "\""        -> String
+    ~[\"\\]                   -> StrChar
+    [\\] [\"tnr\\]            -> StrChar
 
   sorts Char CharChar
+
   lexical syntax
-    "'" CharChar "'"		-> Char
-    ~[\']			-> CharChar
-    [\\] [\'ntr\ ]		-> CharChar
-    Char		 	-> Id {reject}
+    "'" CharChar "'"          -> Char
+    ~[\']                     -> CharChar
+    [\\] [\'ntr\ ]            -> CharChar
+    Char                      -> Id {reject}

Copied and modified: spoofax-imp/branches/nbl-dev/syntax/terms/Identifiers.sdf (from r25981, spoofax-imp/branches/nbl-dev/syntax/stratego/NDL-Identifiers.sdf)
==============================================================================
--- spoofax-imp/branches/nbl-dev/syntax/stratego/NDL-Identifiers.sdf	Wed Feb 27 10:49:27 2013	(r25981, copy source)
+++ spoofax-imp/branches/nbl-dev/syntax/terms/Identifiers.sdf	Wed Mar  6 07:49:56 2013	(r25996)
@@ -1,28 +1,39 @@
-module stratego/NDL-Identifiers
+module terms/Identifiers
+
 exports
+  
   sorts ModName ModNamePart
+  
   lexical syntax
-    {ModNamePart "/"}+ -> ModName
+  
+    {ModNamePart "/"}+                -> ModName
     [a-zA-Z\.\_] [a-zA-Z0-9\'\.\-\_]* -> ModNamePart
+  
   lexical restrictions
+  
     ModName -/- [a-zA-Z0-9\'\.\-\_]
+  
   lexical syntax
+  
     "imports" 		-> ModName {reject}
     "overlays" 		-> ModName {reject}
-    "rules" 		-> ModName {reject}
+    "rules"       -> ModName {reject}
     "signature" 	-> ModName {reject}
     "strategies" 	-> ModName {reject}
 
   sorts Id LId LCID UCID Wld
+  
   lexical syntax
+  
     [a-zA-Z\_] [a-zA-Z0-9\'\-\_]*     -> Id
     [a-zA-Z\_] [a-zA-Z0-9\'\-\_]* "*" -> LId
     [\'] [a-z]+                       -> Id
 
-    [a-z] [a-zA-Z0-9\'\-\_]*  -> LCID
-    [A-Z] [a-zA-Z0-9\'\-\_]*  -> UCID
+    [a-z] [a-zA-Z0-9\'\-\_]*          -> LCID
+    [A-Z] [a-zA-Z0-9\'\-\_]*          -> UCID
 
   lexical restrictions
+
     Id   -/- [a-zA-Z0-9\'\_\*]
     Id   -/- [\-].~[\>]
     LId  -/- [a-zA-Z0-9\'\-\_]
@@ -30,8 +41,9 @@
     UCID -/- [a-zA-Z0-9\'\-\_]
 
   lexical syntax
-    "_"     -> Id {reject}
-    "'"     -> Id {reject}
+
+    "_"     -> Id   {reject}
+    "'"     -> Id   {reject}
 
     Keyword -> Id   {reject}
     Keyword -> LId  {reject}
@@ -73,25 +85,27 @@
       -/- [a-zA-Z0-9\'\-\_]
   
   sorts Keyword
+
   lexical syntax
-    "all"               -> Keyword
-    "constructors" 	-> Keyword
-    "fail" 		-> Keyword
-    "id" 		-> Keyword
-    "in" 		-> Keyword
-    "let" 		-> Keyword
-    "module" 		-> Keyword
-    "not" 		-> Keyword
-    "one" 		-> Keyword
-    "overlays" 		-> Keyword
-    "prim" 		-> Keyword
-    "rules" 		-> Keyword
-    "script" 		-> Keyword
-    "signature" 	-> Keyword
-    "some" 		-> Keyword
-    "sorts" 		-> Keyword
-    "strategies" 	-> Keyword
-    "stratego" 		-> Keyword
-    "test" 		-> Keyword
-    "where" 		-> Keyword
-    "import-term"	-> Keyword
+
+    "all"           -> Keyword
+    "constructors"  -> Keyword
+    "fail"          -> Keyword
+    "id"            -> Keyword
+    "in"            -> Keyword
+    "let"           -> Keyword
+    "module"        -> Keyword
+    "not"           -> Keyword
+    "one"           -> Keyword
+    "overlays"      -> Keyword
+    "prim"          -> Keyword
+    "rules"         -> Keyword
+    "script"        -> Keyword
+    "signature"     -> Keyword
+    "some"          -> Keyword
+    "sorts"         -> Keyword
+    "strategies"    -> Keyword
+    "stratego"      -> Keyword
+    "test"          -> Keyword
+    "where"         -> Keyword
+    "import-term"   -> Keyword

Copied and modified: spoofax-imp/branches/nbl-dev/syntax/terms/Layout.sdf (from r25981, spoofax-imp/branches/nbl-dev/syntax/stratego/NDL-Layout.sdf)
==============================================================================
--- spoofax-imp/branches/nbl-dev/syntax/stratego/NDL-Layout.sdf	Wed Feb 27 10:49:27 2013	(r25981, copy source)
+++ spoofax-imp/branches/nbl-dev/syntax/terms/Layout.sdf	Wed Mar  6 07:49:56 2013	(r25996)
@@ -1,28 +1,34 @@
-module stratego/NDL-Layout
+module terms/Layout
 exports
+
   sorts Ws ShortCom LongCom CommChar Asterisk Eof 
+
   lexical syntax
-    [\t\ \n\r]			-> Ws
+
+    [\t\ \n\r]                -> Ws
 
     "//" ~[\n]* ([\n] | Eof)	-> ShortCom
-    "/*" CommChar* "*/"	-> LongCom
-				-> Eof  
+    "/*" CommChar* "*/"       -> LongCom
+                              -> Eof  
 
-    ~[\*]     -> CommChar
+    ~[\*]                     -> CommChar
 
-    "*"       -> Asterisk
-    Asterisk  -> CommChar
+    "*"                       -> Asterisk
+    Asterisk                  -> CommChar
 
   lexical restrictions
+
     Asterisk -/- [\/]
     Eof      -/- ~[]
 
   lexical syntax
-    ShortCom 	-> LAYOUT
-    LongCom 	-> LAYOUT
-    Ws 		-> LAYOUT
+
+    ShortCom  -> LAYOUT
+    LongCom   -> LAYOUT
+    Ws 		    -> LAYOUT
 
   context-free restrictions
+
     LAYOUT? -/- [\ \t\n\r]
     LAYOUT? -/- [\/].[\*]
     LAYOUT? -/- [\/].[\/]

Copied and modified: spoofax-imp/branches/nbl-dev/syntax/terms/Signatures.sdf (from r25981, spoofax-imp/branches/nbl-dev/syntax/stratego/NDL-Signatures.sdf)
==============================================================================
--- spoofax-imp/branches/nbl-dev/syntax/stratego/NDL-Signatures.sdf	Wed Feb 27 10:49:27 2013	(r25981, copy source)
+++ spoofax-imp/branches/nbl-dev/syntax/terms/Signatures.sdf	Wed Mar  6 07:49:56 2013	(r25996)
@@ -1,36 +1,42 @@
-module stratego/NDL-Signatures
+module terms/Signatures
+
 imports
-	stratego/NDL-Identifiers
-	stratego/NDL-Constants
-	stratego/NDL-StringQuotations
+
+	terms/Identifiers
+	terms/Constants
+	terms/StringQuotations
 	
 exports
 
 	sorts Sort
+	
 	context-free syntax
 		
-		LCID					-> Sort {cons("SortVar")}
-		UCID					-> Sort {cons("SortNoArgs")}
-		Id "(" {Sort ","}* ")"	-> Sort {cons("Sort")}
+		LCID                     -> Sort       {"SortVar"}
+		UCID                     -> Sort       {"SortNoArgs"}
+		Id "(" {Sort ","}* ")"   -> Sort       {"Sort"}
 
 	sorts TypeDecl PPTerm
+	
 	context-free syntax
 
-		Id     TypeParams PPTerm	-> TypeDecl {cons("TypeDecl")}
-		String TypeParams PPTerm	-> TypeDecl {cons("TypeDeclQ")}
+    Id     TypeParams PPTerm -> TypeDecl   {"TypeDecl"}
+    String TypeParams PPTerm -> TypeDecl   {"TypeDeclQ"}
 
-		String			-> PPTerm {cons("Str")}
+    String                   -> PPTerm     {"Str"}
 		
 	sorts TypeParams TypeParam 
+	
 	context-free syntax
 		
-									-> TypeParams {cons("NoTypeParams")}
-		"(" {TypeParam ","}+  ")"	-> TypeParams {cons("TypeParams")}
-		Id ":" Sort					-> TypeParam {cons("TypeParam")}
-
-	%%%
-	 %% Restriction is required for the Sort* in Sdecl: List(a) is
-	 %% ambiguous.
-	 %%%
+                             -> TypeParams {"NoTypeParams"}
+    "(" {TypeParam ","}+ ")" -> TypeParams {"TypeParams"}
+    Id ":" Sort              -> TypeParam  {"TypeParam"}
+
+  %%%
+  %% Restriction is required for the Sort* in Sdecl: List(a) is
+  %% ambiguous.
+  %%%
 	context-free restrictions
+
 		Sort -/- [\(]

Copied and modified: spoofax-imp/branches/nbl-dev/syntax/terms/StringQuotations.sdf (from r25981, spoofax-imp/branches/nbl-dev/syntax/stratego/NDL-StringQuotations.sdf)
==============================================================================
--- spoofax-imp/branches/nbl-dev/syntax/stratego/NDL-StringQuotations.sdf	Wed Feb 27 10:49:27 2013	(r25981, copy source)
+++ spoofax-imp/branches/nbl-dev/syntax/terms/StringQuotations.sdf	Wed Mar  6 07:49:56 2013	(r25996)
@@ -1,9 +1,11 @@
-module stratego/NDL-StringQuotations
+module terms/StringQuotations
+
+imports terms/Terms
 
-imports stratego/NDL-Terms
 exports
 
   sorts
+
   	PPTerm
     StringQuotation
     StringQuotedPart1 StringQuotedChars1 DollarOpen1 DollarClose1 QuotedBracket1 Dollar1
@@ -20,38 +22,38 @@
 
     StringQuotation -> <PPTerm-CF>
 
-    "$" "[" Padding StringQuotedPart1*               "]"    -> StringQuotation {cons("StringQuotation1") }
-     Padding "[" <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> "]"    -> StringQuotedPart1 {cons("StringEscape1")}
-    <StringQuotedChars1-LEX>                                -> StringQuotedPart1 {cons("QStr")}
-    <Dollar1-LEX>                                           -> StringQuotedPart1 {cons("QDollar")}
-    "$" <QuotedBracket1-LEX> "$"                            -> StringQuotedPart1 {cons("QBr")}
+    "$" "[" Padding StringQuotedPart1*               "]"    -> StringQuotation   {"StringQuotation1"}
+     Padding "[" <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> "]"    -> StringQuotedPart1 {"StringEscape1"}
+    <StringQuotedChars1-LEX>                                -> StringQuotedPart1 {"QStr"}
+    <Dollar1-LEX>                                           -> StringQuotedPart1 {"QDollar"}
+    "$" <QuotedBracket1-LEX> "$"                            -> StringQuotedPart1 {"QBr"}
     ~[\[\]\$]+                                              -> <StringQuotedChars1-LEX>
     [\[\]]                                                  -> <QuotedBracket1-LEX>
     "$"                                                     -> <Dollar1-LEX>
 
-    "$" "{" Padding StringQuotedPart2*               "}"    -> StringQuotation {cons("StringQuotation2") }
-     Padding "{" <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> "}"    -> StringQuotedPart2 {cons("StringEscape2")}
-    <StringQuotedChars2-LEX>                                -> StringQuotedPart2 {cons("QStr")}
-    <Dollar2-LEX>                                           -> StringQuotedPart2 {cons("QDollar")}
-    "$" <QuotedBracket2-LEX> "$"                            -> StringQuotedPart2 {cons("QBr")}
+    "$" "{" Padding StringQuotedPart2*               "}"    -> StringQuotation   {"StringQuotation2"}
+     Padding "{" <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> "}"    -> StringQuotedPart2 {"StringEscape2"}
+    <StringQuotedChars2-LEX>                                -> StringQuotedPart2 {"QStr"}
+    <Dollar2-LEX>                                           -> StringQuotedPart2 {"QDollar"}
+    "$" <QuotedBracket2-LEX> "$"                            -> StringQuotedPart2 {"QBr"}
     ~[\{\}\$]+                                              -> <StringQuotedChars2-LEX>
     [\{\}]                                                  -> <QuotedBracket2-LEX>
     "$"                                                     -> <Dollar2-LEX>
 
-    "$" "(" Padding StringQuotedPart3*              ")"     -> StringQuotation {cons("StringQuotation3") }
-    Padding "(" <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> ")"     -> StringQuotedPart3 {cons("StringEscape3")}
-    <StringQuotedChars3-LEX>                                -> StringQuotedPart3 {cons("QStr")}
-    <Dollar3-LEX>                                           -> StringQuotedPart3 {cons("QDollar")}
-    "$" <QuotedBracket3-LEX> "$"                            -> StringQuotedPart3 {cons("QBr")}
+    "$" "(" Padding StringQuotedPart3*              ")"     -> StringQuotation   {"StringQuotation3"}
+    Padding "(" <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> ")"     -> StringQuotedPart3 {"StringEscape3"}
+    <StringQuotedChars3-LEX>                                -> StringQuotedPart3 {"QStr"}
+    <Dollar3-LEX>                                           -> StringQuotedPart3 {"QDollar"}
+    "$" <QuotedBracket3-LEX> "$"                            -> StringQuotedPart3 {"QBr"}
     ~[\(\)\$]+                                              -> <StringQuotedChars3-LEX>
     [\(\)]                                                  -> <QuotedBracket3-LEX>
     "$"                                                     -> <Dollar3-LEX>
 
-    "$" "<" Padding StringQuotedPart4*               ">"    -> StringQuotation {cons("StringQuotation4") }
-    Padding "<"  <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> ">"    -> StringQuotedPart4 {cons("StringEscape4")}
-    <StringQuotedChars4-LEX>                                -> StringQuotedPart4 {cons("QStr")}
-    <Dollar4-LEX>                                           -> StringQuotedPart4 {cons("QDollar")}
-    "$" <QuotedBracket4-LEX> "$"                            -> StringQuotedPart4 {cons("QBr")}
+    "$" "<" Padding StringQuotedPart4*               ">"    -> StringQuotation   {"StringQuotation4"}
+    Padding "<"  <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> ">"    -> StringQuotedPart4 {"StringEscape4"}
+    <StringQuotedChars4-LEX>                                -> StringQuotedPart4 {"QStr"}
+    <Dollar4-LEX>                                           -> StringQuotedPart4 {"QDollar"}
+    "$" <QuotedBracket4-LEX> "$"                            -> StringQuotedPart4 {"QBr"}
     ~[\<\>\$]+                                              -> <StringQuotedChars4-LEX>
     [\<\>]                                                  -> <QuotedBracket4-LEX>
     "$"                                                     -> <Dollar4-LEX>

Copied and modified: spoofax-imp/branches/nbl-dev/syntax/terms/Terms.sdf (from r25981, spoofax-imp/branches/nbl-dev/syntax/stratego/NDL-Terms.sdf)
==============================================================================
--- spoofax-imp/branches/nbl-dev/syntax/stratego/NDL-Terms.sdf	Wed Feb 27 10:49:27 2013	(r25981, copy source)
+++ spoofax-imp/branches/nbl-dev/syntax/terms/Terms.sdf	Wed Mar  6 07:49:56 2013	(r25996)
@@ -1,12 +1,14 @@
-module stratego/NDL-Terms[Var]
+module terms/Terms[Var]
 
 imports
-	stratego/NDL-Constants
-	stratego/NDL-Identifiers
+
+	terms/Constants
+	terms/Identifiers
 	
 exports
 
-  sorts PreTerm[[Var]] Term
+  sorts PreTerm[[Var]] Term[[Var]]
+  
   context-free syntax
 
     Int                                        -> PreTerm[[Var]] {"Int"}
@@ -16,7 +18,7 @@
     Id "(" {Term[[Var]] ","}* ")"              -> PreTerm[[Var]] {"Op"}
     String "(" {Term[[Var]] ","}* ")"          -> PreTerm[[Var]] {"OpQ"}
 
-	PreTerm[[Var]]                             -> Term[[Var]]    {"NoAnnoList"}
+    PreTerm[[Var]]                             -> Term[[Var]]    {"NoAnnoList"}
 
   context-free syntax
 

Copied and modified: spoofax-imp/branches/nbl-dev/syntax/terms/Vars.sdf (from r25981, spoofax-imp/branches/nbl-dev/syntax/stratego/NDL-Vars.sdf)
==============================================================================
--- spoofax-imp/branches/nbl-dev/syntax/stratego/NDL-Vars.sdf	Wed Feb 27 10:49:27 2013	(r25981, copy source)
+++ spoofax-imp/branches/nbl-dev/syntax/terms/Vars.sdf	Wed Mar  6 07:49:56 2013	(r25996)
@@ -1,7 +1,8 @@
-module stratego/NDL-Vars
+module terms/Vars
 
 imports
-	stratego/NDL-Identifiers
+
+  terms/Identifiers
 	
 exports
 
@@ -16,6 +17,7 @@
   	
     Id  -> VarRef {"VarRef"}
     LId	-> VarRef {"ListVarRef"}
-
+    
   context-free restrictions
+
     Wld -/- [a-zA-Z0-9\'\-\_]

From g.h.wachsmuth at tudelft.nl  Wed Mar  6 09:26:12 2013
From: g.h.wachsmuth at tudelft.nl (Guido Wachsmuth)
Date: Wed, 06 Mar 2013 08:26:12 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25997 - in
	spoofax-imp/branches/nbl-dev/syntax: . common documentation
	nabl terms
Message-ID: <20130306082612.E0C81CC149@mx4.tudelft.nl>

Author: GuidoWachsmuth
Date: Wed Mar  6 08:26:12 2013
New Revision: 25997
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25997&sc=1

Log:
organised syntax definition into sublanguages

Added:
   spoofax-imp/branches/nbl-dev/syntax/common/
   spoofax-imp/branches/nbl-dev/syntax/common/Identifiers.sdf
      - copied, changed from r25996, spoofax-imp/branches/nbl-dev/syntax/terms/Identifiers.sdf
   spoofax-imp/branches/nbl-dev/syntax/common/Layout.sdf
      - copied, changed from r25996, spoofax-imp/branches/nbl-dev/syntax/terms/Layout.sdf
   spoofax-imp/branches/nbl-dev/syntax/common/Modules.sdf
   spoofax-imp/branches/nbl-dev/syntax/nabl/
   spoofax-imp/branches/nbl-dev/syntax/nabl/Namespaces.sdf
   spoofax-imp/branches/nbl-dev/syntax/nabl/Properties.sdf
   spoofax-imp/branches/nbl-dev/syntax/nabl/Rules.sdf
Deleted:
   spoofax-imp/branches/nbl-dev/syntax/terms/Identifiers.sdf
   spoofax-imp/branches/nbl-dev/syntax/terms/Layout.sdf
Modified:
   spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.generated.pp
   spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.sdf
   spoofax-imp/branches/nbl-dev/syntax/documentation/Development.sdf
   spoofax-imp/branches/nbl-dev/syntax/terms/Signatures.sdf
   spoofax-imp/branches/nbl-dev/syntax/terms/Terms.sdf
   spoofax-imp/branches/nbl-dev/syntax/terms/Vars.sdf

Modified: spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.generated.pp
==============================================================================
--- spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.generated.pp	Wed Mar  6 07:49:56 2013	(r25996)
+++ spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.generated.pp	Wed Mar  6 08:26:12 2013	(r25997)
@@ -1,23 +1,26 @@
 [
-   Todo                                                   -- KW["todo"] _1 _2,
-   Fixme                                                  -- KW["fixme"] _1 _2,
-   Discuss                                                -- KW["discuss"] _1 _2,
-   TestSuite                                              -- KW["test"] KW["suite"] _1,
-   AssignedTo                                             -- _1,
-   AssignedTo.1:iter-star-sep                             -- _1 KW[","],
-   AssignedTo.1:iter-star-sep.1:iter                      -- _1,
-   Example                                                -- KW["example"] _1,
-   Description                                            -- KW["description"] _1,
-   Version                                                -- KW["version"] _1,
-   Status                                                 -- V  [H  [KW["status"]] _1],
-   Status.1:iter                                          -- _1,
-   Author                                                 -- KW["author"] _1 _2 _3,
-   Author.1:iter                                          -- _1,
-   None                                                   -- ,
-   EMail                                                  -- KW["("] _1 KW[")"],
-   None                                                   -- ,
-   Affiliation                                            -- V  [H  [KW[","]] _1],
-   Affiliation.1:iter                                     -- _1,
+   SortVar                                                -- _1,
+   SortNoArgs                                             -- _1,
+   Sort                                                   -- _1 KW["("] _2 KW[")"],
+   Sort.2:iter-star-sep                                   -- _1 KW[","],
+   TypeDecl                                               -- _1 _2 _3,
+   TypeDeclQ                                              -- _1 _2 _3,
+   Str                                                    -- _1,
+   NoTypeParams                                           -- ,
+   TypeParams                                             -- KW["("] _1 KW[")"],
+   TypeParams.1:iter-sep                                  -- _1 KW[","],
+   TypeParam                                              -- _1 KW[":"] _2,
+   Properties                                             -- V  [H  [KW["properties"]] _1],
+   Properties.1:iter-star                                 -- _1,
+   Property                                               -- _1 KW["of"] _2 KW[":"] _3,
+   Property.2:iter-sep                                    -- _1 KW[","],
+   PropertyRef                                            -- _1,
+   TypeProp                                               -- KW["type"],
+   Namespaces                                             -- V  [H  [KW["namespaces"]] _1],
+   Namespaces.1:iter-star                                 -- _1,
+   Namespace                                              -- _1,
+   NamespaceRef                                           -- _1,
+   ImportedNsRef                                          -- KW["imported"] _1,
    Int                                                    -- _1,
    Real                                                   -- _1,
    Str                                                    -- _1,
@@ -47,39 +50,11 @@
    ListTail.1:iter-star-sep.1:parameterized-sort.1:"Term" -- ,
    ListTail.2:parameterized-sort                          -- _1 _2,
    ListTail.2:parameterized-sort.1:"Term"                 -- ,
-   SortVar                                                -- _1,
-   SortNoArgs                                             -- _1,
-   Sort                                                   -- _1 KW["("] _2 KW[")"],
-   Sort.2:iter-star-sep                                   -- _1 KW[","],
-   TypeDecl                                               -- _1 _2 _3,
-   TypeDeclQ                                              -- _1 _2 _3,
-   Str                                                    -- _1,
-   NoTypeParams                                           -- ,
-   TypeParams                                             -- KW["("] _1 KW[")"],
-   TypeParams.1:iter-sep                                  -- _1 KW[","],
-   TypeParam                                              -- _1 KW[":"] _2,
    Wld                                                    -- KW["_"],
    Var                                                    -- _1,
    ListVar                                                -- _1,
    VarRef                                                 -- _1,
    ListVarRef                                             -- _1,
-   Module                                                 -- KW["module"] _1 _2 _3,
-   Module.2:iter-star                                     -- _1,
-   Module.3:iter-star                                     -- _1,
-   Imports                                                -- V  [H  [KW["imports"]] _1],
-   Imports.1:iter-star                                    -- _1,
-   Import                                                 -- _1,
-   Namespaces                                             -- V  [H  [KW["namespaces"]] _1],
-   Namespaces.1:iter-star                                 -- _1,
-   Namespace                                              -- _1,
-   NamespaceRef                                           -- _1,
-   ImportedNsRef                                          -- KW["imported"] _1,
-   Properties                                             -- V  [H  [KW["properties"]] _1],
-   Properties.1:iter-star                                 -- _1,
-   Property                                               -- _1 KW["of"] _2 KW[":"] _3,
-   Property.2:iter-sep                                    -- _1 KW[","],
-   PropertyRef                                            -- _1,
-   TypeProp                                               -- KW["type"],
    BindingRules                                           -- V  [H  [KW["binding"] KW["rules"]] _1],
    BindingRules.1:iter-star                               -- _1,
    BindingRule                                            -- _1 _2 KW[":"] _3,
@@ -134,5 +109,30 @@
    PropertyCond                                           -- KW["has"] _1 _2,
    PropertyCond                                           -- KW["is"] KW["of"] _1 _2,
    ReferenceCond                                          -- KW["refers"] KW["to"] _1 _2 _3,
-   ReferenceCond.2:iter-star                              -- _1
+   ReferenceCond.2:iter-star                              -- _1,
+   Todo                                                   -- KW["todo"] _1 _2,
+   Fixme                                                  -- KW["fixme"] _1 _2,
+   Discuss                                                -- KW["discuss"] _1 _2,
+   TestSuite                                              -- KW["test"] KW["suite"] _1,
+   AssignedTo                                             -- _1,
+   AssignedTo.1:iter-star-sep                             -- _1 KW[","],
+   AssignedTo.1:iter-star-sep.1:iter                      -- _1,
+   Example                                                -- KW["example"] _1,
+   Description                                            -- KW["description"] _1,
+   Version                                                -- KW["version"] _1,
+   Status                                                 -- V  [H  [KW["status"]] _1],
+   Status.1:iter                                          -- _1,
+   Author                                                 -- KW["author"] _1 _2 _3,
+   Author.1:iter                                          -- _1,
+   None                                                   -- ,
+   EMail                                                  -- KW["("] _1 KW[")"],
+   None                                                   -- ,
+   Affiliation                                            -- V  [H  [KW[","]] _1],
+   Affiliation.1:iter                                     -- _1,
+   Module                                                 -- KW["module"] _1 _2 _3,
+   Module.2:iter-star                                     -- _1,
+   Module.3:iter-star                                     -- _1,
+   Imports                                                -- V  [H  [KW["imports"]] _1],
+   Imports.1:iter-star                                    -- _1,
+   Import                                                 -- _1
 ]
\ No newline at end of file

Modified: spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.sdf
==============================================================================
--- spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.sdf	Wed Mar  6 07:49:56 2013	(r25996)
+++ spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.sdf	Wed Mar  6 08:26:12 2013	(r25997)
@@ -2,136 +2,19 @@
 
 imports
   
-	terms/Layout
-	terms/Identifiers
-	terms/Vars
-	terms/Signatures
-	terms/Terms[Var]
-	terms/Terms[VarRef]
-	documentation/Metadata
-	documentation/Documentation
-	documentation/Development
+	common/Modules
+	nabl/Rules
 	
-exports 
-  
-	context-free start-symbols
-
-		Start
-
-	context-free syntax
-  	
-		Term[[Var]]			-> BTerm %% term binding variables
-		Term[[VarRef]]	-> RTerm %% term referencing variables
-  	
-	context-free syntax
-		
-		"module" ModName ModMetaData* ModSection*						-> Start 					{"Module"}
-		
-		
-	context-free syntax %% imports
-				
-		"imports" ImportModName* 														-> ModSection 		{"Imports"}
-    ModName																							-> ImportModName	{"Import"}
-
-  syntax
-
-		<ModName-CF> "/" "-" 																-> <ImportModName-CF> {"ImportWildcard"}
-    
-	context-free syntax %% sections
-		
-		%% Namespaces
-		"namespaces" Namespace*															-> ModSection			{"Namespaces"}
-		NamespaceId																					-> Namespace			{"Namespace"}
-		NamespaceId																					-> NamespaceRef		{"NamespaceRef"}
-		NamespaceRef																				-> INamespaceRef
-		"imported" NamespaceId															-> INamespaceRef	{"ImportedNsRef"}
-		
-		%% Properties
-		"properties" PropertyDef*														-> ModSection			{"Properties"}
-		PropertyId "of" {NamespaceRef ","}+ ":" Sort				-> PropertyDef		{"Property"}
-		PropertyId																					-> PropertyRef		{"PropertyRef"}
-		
-		"type"																							-> PropertyRef 		{"TypeProp"}
-
-		"binding" "rules" NamingRule*												-> ModSection			{"BindingRules"}
-
-		Documentation* BTerm ":" NamingRulePart+						-> NamingRule			{"BindingRule"}
-		
-	context-free syntax %% definition sites	
-		
-		"defines" Unique Binding Property* DefScopes Constraint* -> NamingRulePart {"DefSite"}
-		
-																												-> Unique					{"Unique"}
-		"unique"																						-> Unique					{"Unique"}
-		"non-unique"																				-> Unique					{"NonUnique"}
-		
-		NamespaceRef RTerm																	-> Binding			  {"NameBinding"}
-		INamespaceRef RTerm																	-> IBinding			  {"NameBinding"}
-		NamespaceRef BTerm																	-> BBinding			  {"NameBinding"}
-		"of" PropertyRef RTerm															-> Property				{"PropertyBinding"}
-		"of" PropertyRef BTerm															-> BProperty			{"PropertyBinding"}
-		
-																												-> DefScopes			{"Current"}
-		"in" "current" "scope"															-> DefScopes			{"Current"}
-		"in" {DefScope ","}+															  -> DefScopes			{"DefScopes"}
-		"subsequent" "scope"																-> DefScope		  	{"Subsequent"}
-		RTerm																								-> DefScope				{"DefScope"}
-		
-	context-free syntax
-		
-		"scopes" {NamespaceRef ","}+												-> NamingRulePart {"Scopes"}			
-		
-	context-free syntax %% use sites
-
-		{RefPart "otherwise"}+															-> NamingRulePart	{"UseSite"} 		
-		"refers" "to" RefPartCore 													-> RefPart				{bracket}
-		IBinding BProperty* RefScope Constraint*						-> RefPartCore		{"Reference"}
-			
-		"in" IBinding	Property* RefScope 										-> RefScope			 	{"RefScope"}
-		"in" "current" "scope"															-> RefScope				{"Current"}
-		"in" "surrounding" NamespaceRef											-> RefScope				{"Surrounding"}
-																												-> RefScope				{"All"}
+exports
 	
-	context-free syntax %% qualified names
+  context-free start-symbols
 
-		{QualifiedPart "otherwise"}+												-> NamingRulePart	{"QualifiedName"} 		
-		"qualifies" Binding "in" Binding Constraint*				-> QualifiedPart	{"Qualifier"}
-		
-		{NamedPart "otherwise"}+														-> NamingRulePart	{"OverlayName"} 		
-		"names" Binding									 										-> NamedPart			{"Overlay"}
-		
-	context-free syntax %% imports
-		
-		{ImportPart "otherwise"}+														       -> NamingRulePart	{"ImportSite"} 		
-		"imports"	{INamespaceRef ","}+ "from" IRefScope IDefScopes -> ImportPart			{"Import"}
+    Start
 
-		%% "imports"{INamespaceRef ","}+ "into" RefPartCore IDefScopes	-> NamingRulePart {"ImportToSite"}
-		
-		RefPartCore																					-> IRefScope			
-		RTerm																								-> IRefScope			{"RefScope"}
-		
-																												-> IDefScopes			{"Current"}
-		"into" "current" "scope"														-> IDefScopes			{"Current"}
-		"into" {DefScope ","}+	 														-> IDefScopes			{"DefScopes"}
-		
-		%% Constraint
-		"where" RTerm Condition															-> Constraint 		{"Constraint"}
-		"has" PropertyRef BTerm															-> Condition			{"PropertyCond"}
-		"is" "of" PropertyRef BTerm													-> Condition			{"PropertyCond"}
-		"refers" "to" BBinding Property* RefScope						-> Condition			{"ReferenceCond"}
-		  
-	lexical syntax
+  context-free syntax
+  	
+  	Module -> Start
 	
-		"namespaces"	-> ModName			{reject}
-		"properties"	-> ModName			{reject}
-
-		Id						-> NamespaceId
-		"binding"			-> NamespaceId	{reject}
-		"surrounding"	-> NamespaceId	{reject}
-		"properties"	-> NamespaceId	{reject}
-
-		Id						-> PropertyId	
-		"type"				-> PropertyId 	{reject}
 		
 		
  
\ No newline at end of file

Copied and modified: spoofax-imp/branches/nbl-dev/syntax/common/Identifiers.sdf (from r25996, spoofax-imp/branches/nbl-dev/syntax/terms/Identifiers.sdf)
==============================================================================
--- spoofax-imp/branches/nbl-dev/syntax/terms/Identifiers.sdf	Wed Mar  6 07:49:56 2013	(r25996, copy source)
+++ spoofax-imp/branches/nbl-dev/syntax/common/Identifiers.sdf	Wed Mar  6 08:26:12 2013	(r25997)
@@ -1,4 +1,4 @@
-module terms/Identifiers
+module common/Identifiers
 
 exports
   

Copied and modified: spoofax-imp/branches/nbl-dev/syntax/common/Layout.sdf (from r25996, spoofax-imp/branches/nbl-dev/syntax/terms/Layout.sdf)
==============================================================================
--- spoofax-imp/branches/nbl-dev/syntax/terms/Layout.sdf	Wed Mar  6 07:49:56 2013	(r25996, copy source)
+++ spoofax-imp/branches/nbl-dev/syntax/common/Layout.sdf	Wed Mar  6 08:26:12 2013	(r25997)
@@ -1,4 +1,4 @@
-module terms/Layout
+module common/Layout
 exports
 
   sorts Ws ShortCom LongCom CommChar Asterisk Eof 

Added: spoofax-imp/branches/nbl-dev/syntax/common/Modules.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/nbl-dev/syntax/common/Modules.sdf	Wed Mar  6 08:26:12 2013	(r25997)
@@ -0,0 +1,24 @@
+module common/Modules
+
+imports
+  
+	common/Layout
+	common/Identifiers
+	documentation/Metadata
+	documentation/Documentation
+	documentation/Development
+	
+exports 
+  
+	context-free syntax
+		
+		"module" ModName ModMetaData* ModSection* -> Module        {"Module"}
+			
+	context-free syntax %% imports
+				
+		"imports" ImportModName*                  -> ModSection    {"Imports"}
+    ModName                                   -> ImportModName {"Import"}
+
+  syntax
+
+		<ModName-CF> "/" "-"                      -> <ImportModName-CF> {"ImportWildcard"}

Modified: spoofax-imp/branches/nbl-dev/syntax/documentation/Development.sdf
==============================================================================
--- spoofax-imp/branches/nbl-dev/syntax/documentation/Development.sdf	Wed Mar  6 07:49:56 2013	(r25996)
+++ spoofax-imp/branches/nbl-dev/syntax/documentation/Development.sdf	Wed Mar  6 08:26:12 2013	(r25997)
@@ -1,7 +1,7 @@
 module documentation/Development
 
 imports 
-	terms/Identifiers
+	common/Identifiers
 	documentation/Documentation
 	documentation/Metadata
 

Added: spoofax-imp/branches/nbl-dev/syntax/nabl/Namespaces.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/nbl-dev/syntax/nabl/Namespaces.sdf	Wed Mar  6 08:26:12 2013	(r25997)
@@ -0,0 +1,25 @@
+module nabl/Namespaces
+
+imports
+
+  common/Identifiers
+  
+exports 
+  
+  context-free syntax 
+		
+	  "namespaces" Namespace* -> ModSection    {"Namespaces"}
+	  NamespaceId             -> Namespace     {"Namespace"}
+	  NamespaceId	            -> NamespaceRef  {"NamespaceRef"}
+	  NamespaceRef            -> INamespaceRef
+	  "imported" NamespaceId  -> INamespaceRef {"ImportedNsRef"}
+		
+  lexical syntax
+	
+    "namespaces"	-> ModName     {reject}
+		
+    Id            -> NamespaceId
+    "binding"     -> NamespaceId {reject}
+    "surrounding"	-> NamespaceId {reject}
+    "properties"	-> NamespaceId {reject}
+    
\ No newline at end of file

Added: spoofax-imp/branches/nbl-dev/syntax/nabl/Properties.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/nbl-dev/syntax/nabl/Properties.sdf	Wed Mar  6 08:26:12 2013	(r25997)
@@ -0,0 +1,22 @@
+module nabl/Properties
+
+imports
+  common/Identifiers
+  terms/Signatures
+  nabl/Namespaces
+  
+exports 
+
+  context-free syntax
+  	
+    "properties" PropertyDef*                    -> ModSection  {"Properties"}
+    PropertyId "of" {NamespaceRef ","}+ ":" Sort -> PropertyDef {"Property"}
+    PropertyId                                   -> PropertyRef {"PropertyRef"}
+		
+    "type"                                       -> PropertyRef {"TypeProp"}
+
+  lexical syntax
+  
+    "properties" -> ModName    {reject}
+    Id           -> PropertyId 
+    "type"       -> PropertyId {reject}

Added: spoofax-imp/branches/nbl-dev/syntax/nabl/Rules.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/nbl-dev/syntax/nabl/Rules.sdf	Wed Mar  6 08:26:12 2013	(r25997)
@@ -0,0 +1,79 @@
+module nabl/Rules
+
+imports
+
+  terms/Vars  
+  nabl/Namespaces
+  nabl/Properties
+  documentation/Documentation
+  
+exports 
+  
+  context-free syntax
+    
+    "binding" "rules" NamingRule*                       -> ModSection     {"BindingRules"}
+
+    Documentation* BTerm ":" NamingRulePart+            -> NamingRule     {"BindingRule"}
+    
+  context-free syntax %% definition sites 
+    
+    "defines" Unique Binding Property* DefScopes Constraint* -> NamingRulePart {"DefSite"}
+    
+                                                        -> Unique         {"Unique"}
+    "unique"                                            -> Unique         {"Unique"}
+    "non-unique"                                        -> Unique         {"NonUnique"}
+    
+    NamespaceRef RTerm                                  -> Binding        {"NameBinding"}
+    INamespaceRef RTerm                                 -> IBinding       {"NameBinding"}
+    NamespaceRef BTerm                                  -> BBinding       {"NameBinding"}
+    "of" PropertyRef RTerm                              -> Property       {"PropertyBinding"}
+    "of" PropertyRef BTerm                              -> BProperty      {"PropertyBinding"}
+    
+                                                        -> DefScopes      {"Current"}
+    "in" "current" "scope"                              -> DefScopes      {"Current"}
+    "in" {DefScope ","}+                                -> DefScopes      {"DefScopes"}
+    "subsequent" "scope"                                -> DefScope       {"Subsequent"}
+    RTerm                                               -> DefScope       {"DefScope"}
+    
+  context-free syntax
+    
+    "scopes" {NamespaceRef ","}+                        -> NamingRulePart {"Scopes"}      
+    
+  context-free syntax %% use sites
+
+    {RefPart "otherwise"}+                              -> NamingRulePart {"UseSite"}     
+    "refers" "to" RefPartCore                           -> RefPart        {bracket}
+    IBinding BProperty* RefScope Constraint*            -> RefPartCore    {"Reference"}
+      
+    "in" IBinding Property* RefScope                    -> RefScope       {"RefScope"}
+    "in" "current" "scope"                              -> RefScope       {"Current"}
+    "in" "surrounding" NamespaceRef                     -> RefScope       {"Surrounding"}
+                                                        -> RefScope       {"All"}
+  
+  context-free syntax %% qualified names
+
+    {QualifiedPart "otherwise"}+                        -> NamingRulePart {"QualifiedName"}     
+    "qualifies" Binding "in" Binding Constraint*        -> QualifiedPart  {"Qualifier"}
+    
+    {NamedPart "otherwise"}+                            -> NamingRulePart {"OverlayName"}     
+    "names" Binding                                     -> NamedPart      {"Overlay"}
+    
+  context-free syntax %% imports
+    
+    {ImportPart "otherwise"}+                                  -> NamingRulePart  {"ImportSite"}    
+    "imports" {INamespaceRef ","}+ "from" IRefScope IDefScopes -> ImportPart      {"Import"}
+
+    %% "imports"{INamespaceRef ","}+ "into" RefPartCore IDefScopes  -> NamingRulePart {"ImportToSite"}
+    
+    RefPartCore                                         -> IRefScope      
+    RTerm                                               -> IRefScope      {"RefScope"}
+    
+                                                        -> IDefScopes     {"Current"}
+    "into" "current" "scope"                            -> IDefScopes     {"Current"}
+    "into" {DefScope ","}+                              -> IDefScopes     {"DefScopes"}
+    
+    %% Constraint
+    "where" RTerm Condition                             -> Constraint     {"Constraint"}
+    "has" PropertyRef BTerm                             -> Condition      {"PropertyCond"}
+    "is" "of" PropertyRef BTerm                         -> Condition      {"PropertyCond"}
+    "refers" "to" BBinding Property* RefScope           -> Condition      {"ReferenceCond"}

Modified: spoofax-imp/branches/nbl-dev/syntax/terms/Signatures.sdf
==============================================================================
--- spoofax-imp/branches/nbl-dev/syntax/terms/Signatures.sdf	Wed Mar  6 07:49:56 2013	(r25996)
+++ spoofax-imp/branches/nbl-dev/syntax/terms/Signatures.sdf	Wed Mar  6 08:26:12 2013	(r25997)
@@ -2,7 +2,7 @@
 
 imports
 
-	terms/Identifiers
+	common/Identifiers
 	terms/Constants
 	terms/StringQuotations
 	

Modified: spoofax-imp/branches/nbl-dev/syntax/terms/Terms.sdf
==============================================================================
--- spoofax-imp/branches/nbl-dev/syntax/terms/Terms.sdf	Wed Mar  6 07:49:56 2013	(r25996)
+++ spoofax-imp/branches/nbl-dev/syntax/terms/Terms.sdf	Wed Mar  6 08:26:12 2013	(r25997)
@@ -3,7 +3,7 @@
 imports
 
 	terms/Constants
-	terms/Identifiers
+	common/Identifiers
 	
 exports
 

Modified: spoofax-imp/branches/nbl-dev/syntax/terms/Vars.sdf
==============================================================================
--- spoofax-imp/branches/nbl-dev/syntax/terms/Vars.sdf	Wed Mar  6 07:49:56 2013	(r25996)
+++ spoofax-imp/branches/nbl-dev/syntax/terms/Vars.sdf	Wed Mar  6 08:26:12 2013	(r25997)
@@ -2,8 +2,10 @@
 
 imports
 
-  terms/Identifiers
-	
+  common/Identifiers
+  terms/Terms[Var]
+  terms/Terms[VarRef]
+
 exports
 
   sorts Wld Var VarRef
@@ -21,3 +23,8 @@
   context-free restrictions
 
     Wld -/- [a-zA-Z0-9\'\-\_]
+
+  context-free syntax
+    
+    Term[[Var]]     -> BTerm %% term binding variables
+    Term[[VarRef]]  -> RTerm %% term referencing variables

From g.h.wachsmuth at tudelft.nl  Wed Mar  6 09:58:18 2013
From: g.h.wachsmuth at tudelft.nl (Guido Wachsmuth)
Date: Wed, 06 Mar 2013 08:58:18 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25998 - in
	spoofax-imp/branches/nbl-dev: syntax syntax/nabl trans
Message-ID: <20130306085818.8D2577F8007@mx1.tudelft.nl>

Author: GuidoWachsmuth
Date: Wed Mar  6 08:58:17 2013
New Revision: 25998
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25998&sc=1

Log:
fixed generator

Modified:
   spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.generated.pp
   spoofax-imp/branches/nbl-dev/syntax/nabl/Rules.sdf
   spoofax-imp/branches/nbl-dev/trans/names.nd
   spoofax-imp/branches/nbl-dev/trans/names.str
   spoofax-imp/branches/nbl-dev/trans/new-generate.str

Modified: spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.generated.pp
==============================================================================
--- spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.generated.pp	Wed Mar  6 08:26:12 2013	(r25997)
+++ spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.generated.pp	Wed Mar  6 08:58:17 2013	(r25998)
@@ -57,9 +57,8 @@
    ListVarRef                                             -- _1,
    BindingRules                                           -- V  [H  [KW["binding"] KW["rules"]] _1],
    BindingRules.1:iter-star                               -- _1,
-   BindingRule                                            -- _1 _2 KW[":"] _3,
-   BindingRule.1:iter-star                                -- _1,
-   BindingRule.3:iter                                     -- _1,
+   BindingRule                                            -- _1 KW[":"] _2,
+   BindingRule.2:iter                                     -- _1,
    DefSite                                                -- KW["defines"] _1 _2 _3 _4 _5,
    DefSite.3:iter-star                                    -- _1,
    DefSite.5:iter-star                                    -- _1,

Modified: spoofax-imp/branches/nbl-dev/syntax/nabl/Rules.sdf
==============================================================================
--- spoofax-imp/branches/nbl-dev/syntax/nabl/Rules.sdf	Wed Mar  6 08:26:12 2013	(r25997)
+++ spoofax-imp/branches/nbl-dev/syntax/nabl/Rules.sdf	Wed Mar  6 08:58:17 2013	(r25998)
@@ -13,7 +13,8 @@
     
     "binding" "rules" NamingRule*                       -> ModSection     {"BindingRules"}
 
-    Documentation* BTerm ":" NamingRulePart+            -> NamingRule     {"BindingRule"}
+    Documentation                                       -> NamingRule
+    BTerm ":" NamingRulePart+                           -> NamingRule     {"BindingRule"}
     
   context-free syntax %% definition sites 
     

Modified: spoofax-imp/branches/nbl-dev/trans/names.nd
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/names.nd	Wed Mar  6 08:26:12 2013	(r25997)
+++ spoofax-imp/branches/nbl-dev/trans/names.nd	Wed Mar  6 08:58:17 2013	(r25998)
@@ -6,7 +6,7 @@
 
 rules
 
-	Module(m, _): 
+	Module(m, _, _): 
 		defines Module m
 		scopes Namespace, Property
 		
@@ -35,7 +35,7 @@
 
 rules
 
-	BindingRule(_, _, _):
+	BindingRule(_, _):
 		scopes Variable
 		
 	Var(x):

Modified: spoofax-imp/branches/nbl-dev/trans/names.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/names.str	Wed Mar  6 08:26:12 2013	(r25997)
+++ spoofax-imp/branches/nbl-dev/trans/names.str	Wed Mar  6 08:58:17 2013	(r25998)
@@ -27,19 +27,19 @@
 rules
 
   nam-get-scope-types :
-    Module(m, _) -> [Namespace(), Property()]
+    Module(m, _, _) -> [Namespace(), Property()]
 
   nam-get-definition-keys :
-    Module(m, _) -> [m]
+    Module(m, _, _) -> [m]
 
   nam-get-definitions :
-    Module(m, _) -> [(Module(), [m])]
+    Module(m, _, _) -> [(Module(), [m])]
 
   nam-annotate-names(|paths__, path__):
-    Module(m, _) -> <Module(nam-annotate-def(|path__), id)>
+    Module(m, _, _) -> <Module(nam-annotate-def(|path__), id, id)>
 
   nam-unique :
-    Module(m, _) -> <id>
+    Module(m, _, _) -> <id>
 
 
 rules
@@ -138,7 +138,7 @@
 rules
 
   nam-get-scope-types :
-    BindingRule(_, _, _) -> [Variable()]
+    BindingRule(_, _) -> [Variable()]
 
 
 rules

Modified: spoofax-imp/branches/nbl-dev/trans/new-generate.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/new-generate.str	Wed Mar  6 08:26:12 2013	(r25997)
+++ spoofax-imp/branches/nbl-dev/trans/new-generate.str	Wed Mar  6 08:58:17 2013	(r25998)
@@ -8,7 +8,7 @@
 rules
 	
 	generate-name-analysis:
-		(selected, position, ast at Module(name, _), path, project-path) -> (filename, result)
+		(selected, position, ast at Module(name, _, _), path, project-path) -> (filename, result)
 		with
 			filename   := <guarantee-extension(|"str")> path ;
 			str-module := <nabl-to-str; to-ppable-str> ast ;
@@ -25,7 +25,7 @@
 rules // modules
 	
 	nabl-to-str:
-		Module(name, sections) -> Module(name, <filter(nabl-to-str)> sections)
+		Module(name, _, sections) -> Module(name, <filter(nabl-to-str)> sections)
 		
 rules // namespaces 
 			
@@ -61,7 +61,7 @@
 		
 	// TODO: support multiple definition sites
 	nabl-to-str: 
-		BindingRule(_, pattern, parts) -> [defscope*, use*]
+		BindingRule(pattern, parts) -> [defscope*, use*]
 		where
 			scopes := <filter(?Scopes(<id>)); concat; map(nabl-to-str)> parts
 		where

From gabrielkonat at gmail.com  Wed Mar  6 11:18:39 2013
From: gabrielkonat at gmail.com (Gabriël Konat)
Date: Wed, 06 Mar 2013 10:18:39 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r25999 -
	spoofax-imp/branches/nbl-dev/editor
Message-ID: <20130306101839.AD1A6108C00A@mx3.tudelft.nl>

Author: gkonat
Date: Wed Mar  6 10:18:38 2013
New Revision: 25999
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=25999&sc=1

Log:
Generate on save

Modified:
   spoofax-imp/branches/nbl-dev/editor/NameBindingLanguage-Builders.esv

Modified: spoofax-imp/branches/nbl-dev/editor/NameBindingLanguage-Builders.esv
==============================================================================
--- spoofax-imp/branches/nbl-dev/editor/NameBindingLanguage-Builders.esv	Wed Mar  6 08:58:17 2013	(r25998)
+++ spoofax-imp/branches/nbl-dev/editor/NameBindingLanguage-Builders.esv	Wed Mar  6 10:18:38 2013	(r25999)
@@ -22,4 +22,4 @@
   builder  : "Show index entries for all files" = index-allfiles (openeditor) (realtime) (meta) (source)
   builder  : "Clear index" = index-cleanall (meta) (source)                                                                                             
 
-  on save  : editor-save
\ No newline at end of file
+  on save  : generate-name-analysis
\ No newline at end of file

From g.h.wachsmuth at tudelft.nl  Wed Mar  6 20:00:19 2013
From: g.h.wachsmuth at tudelft.nl (Guido Wachsmuth)
Date: Wed, 06 Mar 2013 19:00:19 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26000 - in
	spoofax-imp/branches/nbl-dev: syntax syntax/nabl syntax/terms trans
Message-ID: <20130306190019.EC0E3CC1D4@mx4.tudelft.nl>

Author: GuidoWachsmuth
Date: Wed Mar  6 19:00:18 2013
New Revision: 26000
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26000&sc=1

Log:
added missing syntax for Java cases

Modified:
   spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.generated.pp
   spoofax-imp/branches/nbl-dev/syntax/nabl/Namespaces.sdf
   spoofax-imp/branches/nbl-dev/syntax/nabl/Rules.sdf
   spoofax-imp/branches/nbl-dev/syntax/terms/Vars.sdf
   spoofax-imp/branches/nbl-dev/trans/new-generate.str

Modified: spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.generated.pp
==============================================================================
--- spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.generated.pp	Wed Mar  6 10:18:38 2013	(r25999)
+++ spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.generated.pp	Wed Mar  6 19:00:18 2013	(r26000)
@@ -51,6 +51,7 @@
    ListTail.2:parameterized-sort                          -- _1 _2,
    ListTail.2:parameterized-sort.1:"Term"                 -- ,
    Wld                                                    -- KW["_"],
+   ListWld                                                -- KW["..."],
    Var                                                    -- _1,
    ListVar                                                -- _1,
    VarRef                                                 -- _1,
@@ -66,10 +67,17 @@
    Unique                                                 -- KW["unique"],
    NonUnique                                              -- KW["non-unique"],
    NameBinding                                            -- _1 _2,
-   NameBinding                                            -- _1 _2,
+   NameBinding                                            -- _1 _2 _3,
+   All                                                    -- ,
+   All                                                    -- KW["all"],
+   First                                                  -- KW["first"],
+   Single                                                 -- KW["single"],
+   Best                                                   -- KW["best"],
    NameBinding                                            -- _1 _2,
    PropertyBinding                                        -- KW["of"] _1 _2,
-   PropertyBinding                                        -- KW["of"] _1 _2,
+   PropertyBinding                                        -- KW["of"] _1 _2 _3,
+   Exact                                                  -- ,
+   Conformance                                            -- KW["conformant"],
    Current                                                -- ,
    Current                                                -- KW["in"] KW["current"] KW["scope"],
    DefScopes                                              -- V  [H  [KW["in"]] _1],
@@ -90,16 +98,15 @@
    All                                                    -- ,
    QualifiedName                                          -- _1,
    QualifiedName.1:iter-sep                               -- _1 KW["otherwise"],
-   Qualifier                                              -- KW["qualifies"] _1 KW["in"] _2 _3,
-   Qualifier.3:iter-star                                  -- _1,
    OverlayName                                            -- _1,
    OverlayName.1:iter-sep                                 -- _1 KW["otherwise"],
-   Overlay                                                -- KW["names"] _1,
    ImportSite                                             -- _1,
    ImportSite.1:iter-sep                                  -- _1 KW["otherwise"],
-   Import                                                 -- KW["imports"] _1 KW["from"] _2 _3,
+   Import                                                 -- KW["imports"] _1 _2 _3 _4,
    Import.1:iter-sep                                      -- _1 KW[","],
-   RefScope                                               -- _1,
+   Import.2:iter-star                                     -- _1,
+   Current                                                -- ,
+   RefScope                                               -- KW["from"] _1,
    Current                                                -- ,
    Current                                                -- KW["into"] KW["current"] KW["scope"],
    DefScopes                                              -- V  [H  [KW["into"]] _1],

Modified: spoofax-imp/branches/nbl-dev/syntax/nabl/Namespaces.sdf
==============================================================================
--- spoofax-imp/branches/nbl-dev/syntax/nabl/Namespaces.sdf	Wed Mar  6 10:18:38 2013	(r25999)
+++ spoofax-imp/branches/nbl-dev/syntax/nabl/Namespaces.sdf	Wed Mar  6 19:00:18 2013	(r26000)
@@ -22,4 +22,5 @@
     "binding"     -> NamespaceId {reject}
     "surrounding"	-> NamespaceId {reject}
     "properties"	-> NamespaceId {reject}
-    
\ No newline at end of file
+    "current"     -> NamespaceId {reject}
+    "imported"    -> NamespaceId {reject}
\ No newline at end of file

Modified: spoofax-imp/branches/nbl-dev/syntax/nabl/Rules.sdf
==============================================================================
--- spoofax-imp/branches/nbl-dev/syntax/nabl/Rules.sdf	Wed Mar  6 10:18:38 2013	(r25999)
+++ spoofax-imp/branches/nbl-dev/syntax/nabl/Rules.sdf	Wed Mar  6 19:00:18 2013	(r26000)
@@ -25,10 +25,20 @@
     "non-unique"                                        -> Unique         {"NonUnique"}
     
     NamespaceRef RTerm                                  -> Binding        {"NameBinding"}
-    INamespaceRef RTerm                                 -> IBinding       {"NameBinding"}
+    Disambiguator INamespaceRef RTerm                   -> IBinding       {"NameBinding"}
+    
+                                                        -> Disambiguator  {"All"}
+    "all"                                               -> Disambiguator  {"All"}
+    "first"                                             -> Disambiguator  {"First"}
+    "single"                                            -> Disambiguator  {"Single"}
+    "best"                                              -> Disambiguator  {"Best"}
+        
     NamespaceRef BTerm                                  -> BBinding       {"NameBinding"}
     "of" PropertyRef RTerm                              -> Property       {"PropertyBinding"}
-    "of" PropertyRef BTerm                              -> BProperty      {"PropertyBinding"}
+    "of" PropertyMatch PropertyRef BTerm                -> BProperty      {"PropertyBinding"}
+    
+                                                        -> PropertyMatch  {"Exact"}
+    "conformant"                                        -> PropertyMatch  {"Conformance"}
     
                                                         -> DefScopes      {"Current"}
     "in" "current" "scope"                              -> DefScopes      {"Current"}
@@ -54,20 +64,24 @@
   context-free syntax %% qualified names
 
     {QualifiedPart "otherwise"}+                        -> NamingRulePart {"QualifiedName"}     
-    "qualifies" Binding "in" Binding Constraint*        -> QualifiedPart  {"Qualifier"}
+    "qualifies" RefPartCore                             -> QualifiedPart  {bracket}
     
     {NamedPart "otherwise"}+                            -> NamingRulePart {"OverlayName"}     
-    "names" Binding                                     -> NamedPart      {"Overlay"}
+    "identifies" RefPartCore                            -> NamedPart      {bracket}
     
   context-free syntax %% imports
     
-    {ImportPart "otherwise"}+                                  -> NamingRulePart  {"ImportSite"}    
-    "imports" {INamespaceRef ","}+ "from" IRefScope IDefScopes -> ImportPart      {"Import"}
+    {ImportPart "otherwise"}+                                 -> NamingRulePart  {"ImportSite"}    
+    "imports" {Imported ","}+ BProperty* IRefScope IDefScopes -> ImportPart      {"Import"}
 
+    INamespaceRef                                       -> Imported
+    IBinding                                            -> Imported
+     
     %% "imports"{INamespaceRef ","}+ "into" RefPartCore IDefScopes  -> NamingRulePart {"ImportToSite"}
     
-    RefPartCore                                         -> IRefScope      
-    RTerm                                               -> IRefScope      {"RefScope"}
+                                                        -> IRefScope      {"Current"}
+    "from" RefPartCore                                  -> IRefScope      {bracket}
+    "from" RTerm                                        -> IRefScope      {"RefScope"}
     
                                                         -> IDefScopes     {"Current"}
     "into" "current" "scope"                            -> IDefScopes     {"Current"}

Modified: spoofax-imp/branches/nbl-dev/syntax/terms/Vars.sdf
==============================================================================
--- spoofax-imp/branches/nbl-dev/syntax/terms/Vars.sdf	Wed Mar  6 10:18:38 2013	(r25999)
+++ spoofax-imp/branches/nbl-dev/syntax/terms/Vars.sdf	Wed Mar  6 19:00:18 2013	(r26000)
@@ -12,13 +12,14 @@
   
   context-free syntax
   	
-    "_" -> Wld    {"Wld"}
-    Wld -> Var 
-    Id 	-> Var    {"Var"}
-    LId -> Var    {"ListVar"}
+    "_"   -> Wld    {"Wld"}
+    "..." -> Var    {"ListWld"}
+    Wld   -> Var 
+    Id 	  -> Var    {"Var"}
+    LId   -> Var    {"ListVar"}
   	
-    Id  -> VarRef {"VarRef"}
-    LId	-> VarRef {"ListVarRef"}
+    Id    -> VarRef {"VarRef"}
+    LId	  -> VarRef {"ListVarRef"}
     
   context-free restrictions
 

Modified: spoofax-imp/branches/nbl-dev/trans/new-generate.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/new-generate.str	Wed Mar  6 10:18:38 2013	(r25999)
+++ spoofax-imp/branches/nbl-dev/trans/new-generate.str	Wed Mar  6 19:00:18 2013	(r26000)
@@ -93,7 +93,7 @@
 	
 	
 	use-to-str(|pattern):
-		Import(_, ref, _) -> <refs-to-str(|pattern)> [ref]
+		Import(_, [], ref, _) -> <refs-to-str(|pattern)> [ref]
 			
 	// TODO: support properties
 	// TODO: support conditions

From g.h.wachsmuth at tudelft.nl  Thu Mar  7 20:43:03 2013
From: g.h.wachsmuth at tudelft.nl (Guido Wachsmuth)
Date: Thu, 07 Mar 2013 19:43:03 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26001 -
	spoofax-imp/branches/nbl-dev/trans
Message-ID: <20130307194303.B511BCC25C@mx4.tudelft.nl>

Author: GuidoWachsmuth
Date: Thu Mar  7 19:43:01 2013
New Revision: 26001
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26001&sc=1

Log:
adapted generator to new runtime

Modified:
   spoofax-imp/branches/nbl-dev/trans/new-generate.str

Modified: spoofax-imp/branches/nbl-dev/trans/new-generate.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/new-generate.str	Wed Mar  6 19:00:18 2013	(r26000)
+++ spoofax-imp/branches/nbl-dev/trans/new-generate.str	Thu Mar  7 19:43:01 2013	(r26001)
@@ -126,7 +126,7 @@
 			end
 	 	
 	nabl-to-str: NonUnique() -> TERM("NonUnique")
-	nabl-to-str: Unique()    -> RootApp(CALL("nabl-unique-qualifier"))
+	nabl-to-str: Unique()    -> TERM("Unique")
 	
 	prop-to-str:
 		PropertyBinding(p, t) -> PROPERTY(<nabl-to-str> p, <to-ppable-str> t)			
@@ -146,37 +146,37 @@
 	DEF_RULE(pattern, sc, call) =
 	SDefT(
   	"nabl-def-site"
-	, [DefaultVarDec("cpaths"), DefaultVarDec("spaths")]
-	, [DefaultVarDec("lang"), DefaultVarDec("elems"), DefaultVarDec("tasks"), DefaultVarDec("paths"), DefaultVarDec("states")]
+	, [DefaultVarDec("child-uris"), DefaultVarDec("sibl-uris")]
+	, [DefaultVarDec("context"), DefaultVarDec("uris"), DefaultVarDec("states")]
 	, Seq(Match(pattern), Seq(sc, call))
   )
   	
   DEF_RULE(pattern, call) =
 	SDefT(
   	"nabl-def-site"
-	, [DefaultVarDec("cpaths"), DefaultVarDec("spaths")]
-	, [DefaultVarDec("lang"), DefaultVarDec("elems"), DefaultVarDec("tasks"), DefaultVarDec("paths"), DefaultVarDec("states")]
+	, [DefaultVarDec("child-uris"), DefaultVarDec("sibl-uris")]
+  , [DefaultVarDec("context"), DefaultVarDec("uris"), DefaultVarDec("states")]
 	, Seq(Match(pattern), call)
 	)
   	
 	DEF_CALL(ns, u, ds, s) = 
 	CallT(
 	  SVar("nabl-def")
-  , [CALL("cpaths"), CALL("spaths")]
-  , [ Var("lang"), Var("elems"), Var("tasks"), Var("paths"), ns, u, ds, LIST(s)]
+  , [CALL("child-uris"), CALL("sibl-uris")]
+  , [ Var("context"), Var("uris"), ns, u, ds, LIST(s)]
 	)
 
 	SCOPE_RULE(pattern, scopes) =
 	SDefT(
 	  "nabl-anonymous-scope-site"
-	, [DefaultVarDec("cpaths")]
-	, [DefaultVarDec("lang"), DefaultVarDec("paths"), DefaultVarDec("states")]
+	, [DefaultVarDec("child-uris")]
+	, [DefaultVarDec("context"), DefaultVarDec("uris"), DefaultVarDec("states")]
 	, Seq(
 	  	Match(pattern)
 	  , CallT(
 				SVar("nabl-anonymous-scope")
-  		, [CALL("cpaths")]
-  		, [ Var("lang"), Var("paths"), LIST(scopes) ]
+  		, [CALL("child-uris")]
+  		, [ Var("context"), Var("uris"), LIST(scopes) ]
 		  )
     )
 	)
@@ -184,13 +184,13 @@
 	SCOPE() = Var("scope")
 	
 	SCOPE_CALL()   = CallT(SVar("nabl-def-scope"), [], [SCOPE()])
-	SCOPE_CALL(ns) = Where(Assign(SCOPE(), App(CALL("nabl-def-scope"), ns)))
+	SCOPE_CALL(ns) = Where(Assign(SCOPE(), App(CallT(SVar("nabl-def-scope"), [], [Var("context")]), ns)))
 		
 	PROP_RULE(pattern, call) =
 	SDefT(
   	"nabl-prop-site"
 	, []
-	, [DefaultVarDec("lang"), DefaultVarDec("elems"), DefaultVarDec("tasks"), DefaultVarDec("states")]
+	, [DefaultVarDec("context"), DefaultVarDec("states")]
 	, Seq(Match(pattern), call)
   )
   
@@ -198,7 +198,7 @@
 	CallT(
 		SVar("nabl-props")
   , []
-  , [ Var("lang"), Var("elems"), Var("tasks"), LIST(ps)]
+  , [ Var("context"), LIST(ps)]
 	)
 	
 	PROPERTY(p, v) = TERM("Prop", [p, v])
@@ -207,7 +207,7 @@
 	SDefT(
 	  "nabl-use-site"
 	, []
-	, [DefaultVarDec("lang"), DefaultVarDec("elems"), DefaultVarDec("tasks"), DefaultVarDec("paths"), DefaultVarDec("deps"), DefaultVarDec("states")]
+	, [DefaultVarDec("context"), DefaultVarDec("uris"), DefaultVarDec("deps"), DefaultVarDec("states")]
 	, Seq(Match(pattern), call)
   )
   
@@ -215,7 +215,7 @@
   CallT(
   	SVar("nabl-use")
   , []
-  , [ Var("lang"), Var("elems"), Var("tasks"), Var("paths"), Var("deps"), LIST(candidates)]	
+  , [ Var("context"), Var("uris"), Var("deps"), LIST(candidates)]	
   )
   
   CANDIDATE(ns) =

From g.h.wachsmuth at tudelft.nl  Thu Mar  7 21:40:02 2013
From: g.h.wachsmuth at tudelft.nl (Guido Wachsmuth)
Date: Thu, 07 Mar 2013 20:40:02 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26002 -
	spoofax-imp/branches/nbl-dev/trans
Message-ID: <20130307204002.A81192B8025@mx2.tudelft.nl>

Author: GuidoWachsmuth
Date: Thu Mar  7 20:40:01 2013
New Revision: 26002
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26002&sc=1

Log:
first support for properties in where clauses at definition sites; this works for simple properties, but not for matches or cascading property calculations in where clauses.

Modified:
   spoofax-imp/branches/nbl-dev/trans/new-generate.str

Modified: spoofax-imp/branches/nbl-dev/trans/new-generate.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/new-generate.str	Thu Mar  7 19:43:01 2013	(r26001)
+++ spoofax-imp/branches/nbl-dev/trans/new-generate.str	Thu Mar  7 20:40:01 2013	(r26002)
@@ -73,21 +73,45 @@
 			
 	// TODO: support conditions 
 	def-to-str(|pattern, scopes):
-		DefSite(u, NameBinding(ns, t), ps, ds, []) -> [dr, pr*]
-		where
+		DefSite(u, NameBinding(ns, t), ps, ds, constr*) -> [dr, pr*]
+		where  
+		  // replace name with callback to handle definition site
 			replace := ( <to-ppable-str> t 
 			           , DEF_CALL(<nabl-to-str> ns, <nabl-to-str> u, <nabl-to-str> ds, scopes)
 			           )
-		where
+		where 
+		  // when we have external scopes in a "defines ... in ..." clause, 
+		  // replace these external scopes with callbacks
 			replace* := <?DefScopes(<filter(def-scope-to-str)>); nonempty> ds;
+			// callback to determine external scope 
 			sc       := SCOPE_CALL(<nabl-to-str> ns);
+			// apply all replacements and generate a rule handling this definition site
 			dr       := DEF_RULE(pattern, sc, <replace-all(|[replace, replace*])> pattern) <+
+			// otherwise replace only the name and
+			// generate a rule handling this defintion site
 			dr       := DEF_RULE(pattern, <replace-all(|[replace])> pattern)
 		where
-			preplace := (<to-ppable-str> t, PROP_CALL(<nonempty; map(prop-to-str)> ps));
-			pr*      := [PROP_RULE(pattern, <replace-all(|[preplace])> pattern)] <+
-			pr*      := []
+		  // when this definition site defines properties, replace name with callback
+			preplace  := (<to-ppable-str> t, PROP_CALL(<nonempty; map(prop-to-str)> ps));
+			// create tasks for calculated properties
+			(preplace*, clause*) := <map-with-index(constraint-to-str); unzip> constr*;
+			// replace calculated properties with result variables
+			preplace' := <innermost(replace(|preplace*))> preplace;
+			last := <replace-all(|[preplace'])> pattern;
+			// sequential task creation
+			call := <foldl(!Seq(<Fst>, <Snd>))> (clause*, last);
+			// and generate a rule handling properties at this definition site
+			pr*       := [PROP_RULE(pattern, call)] <+
+			// otherwise generate no rule
+			pr*       := []
 
+  constraint-to-str:
+    (n, Constraint(t, PropertyCond(p, Var(v)))) -> ((Var(v), Var(r)), PROP_TASK(r, <nabl-to-str> p, t))
+    where
+    	r := $[result[n]]
+    
+rules
+	  
 	use-to-str(|pattern):
 		UseSite(refs) -> <refs-to-str(|pattern)> refs
 	
@@ -203,6 +227,21 @@
 	
 	PROPERTY(p, v) = TERM("Prop", [p, v])
 
+  PROP_TASK(v, p, t) =
+  Where(
+    Assign(
+      Var(v)
+    , App(
+        CallT(
+          SVar("new-task")
+        , []
+        , [App(CallNoArgs(SVar("task-in-context")), Var("context"))]
+        )
+      , TERM("PropCalc", [p, t])
+      )
+    )
+  )
+  
 	USE_RULE(pattern, call) =
 	SDefT(
 	  "nabl-use-site"

From g.h.wachsmuth at tudelft.nl  Thu Mar  7 23:44:47 2013
From: g.h.wachsmuth at tudelft.nl (Guido Wachsmuth)
Date: Thu, 07 Mar 2013 22:44:47 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26003 -
	spoofax-imp/branches/nbl-dev/trans
Message-ID: <20130307224447.64BAC7F8052@mx1.tudelft.nl>

Author: GuidoWachsmuth
Date: Thu Mar  7 22:44:45 2013
New Revision: 26003
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26003&sc=1

Log:
support for cascading property calculations at definition sites; still no support for matches on properties

Modified:
   spoofax-imp/branches/nbl-dev/trans/new-generate.str

Modified: spoofax-imp/branches/nbl-dev/trans/new-generate.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/new-generate.str	Thu Mar  7 20:40:01 2013	(r26002)
+++ spoofax-imp/branches/nbl-dev/trans/new-generate.str	Thu Mar  7 22:44:45 2013	(r26003)
@@ -71,14 +71,12 @@
 		where
 			use* := <filter(use-to-str(|pattern))> parts
 			
-	// TODO: support conditions 
 	def-to-str(|pattern, scopes):
 		DefSite(u, NameBinding(ns, t), ps, ds, constr*) -> [dr, pr*]
 		where  
 		  // replace name with callback to handle definition site
-			replace := ( <to-ppable-str> t 
-			           , DEF_CALL(<nabl-to-str> ns, <nabl-to-str> u, <nabl-to-str> ds, scopes)
-			           )
+			t'      := <to-ppable-str> t ;
+			replace := ( t', DEF_CALL(<nabl-to-str> ns, <nabl-to-str> u, <nabl-to-str> ds, scopes))
 		where 
 		  // when we have external scopes in a "defines ... in ..." clause, 
 		  // replace these external scopes with callbacks
@@ -91,24 +89,27 @@
 			// generate a rule handling this defintion site
 			dr       := DEF_RULE(pattern, <replace-all(|[replace])> pattern)
 		where
-		  // when this definition site defines properties, replace name with callback
-			preplace  := (<to-ppable-str> t, PROP_CALL(<nonempty; map(prop-to-str)> ps));
-			// create tasks for calculated properties
-			(preplace*, clause*) := <map-with-index(constraint-to-str); unzip> constr*;
-			// replace calculated properties with result variables
-			preplace' := <innermost(replace(|preplace*))> preplace;
-			last := <replace-all(|[preplace'])> pattern;
-			// sequential task creation
-			call := <foldl(!Seq(<Fst>, <Snd>))> (clause*, last);
-			// and generate a rule handling properties at this definition site
-			pr*       := [PROP_RULE(pattern, call)] <+
+		  // when this definition site defines properties,
+		  // construct a callback
+		  pcall := PROP_CALL(<nonempty; map(prop-to-str)> ps);
+		  // construct sequence of property calculatations and callback
+		  pbody := <constraints-to-str(|1, pcall, t', pattern)> constr*;
+		  // generate a rule handling properties at this definition site
+			pr*   := [PROP_RULE(pattern, pbody)] <+
 			// otherwise generate no rule
-			pr*       := []
+			pr*   := []
 
-  constraint-to-str:
-    (n, Constraint(t, PropertyCond(p, Var(v)))) -> ((Var(v), Var(r)), PROP_TASK(r, <nabl-to-str> p, t))
-    where
-    	r := $[result[n]]
+  constraints-to-str(|n, c, term, pattern):
+  	[] -> <replace-all(|(term, c))> pattern
+  
+  // TODO: support matches
+  constraints-to-str(|n, c, term, pattern):
+    [ Constraint(t, PropertyCond(p, Var(v))) | cs ] -> Seq(PROP_TASK(r, p', t), cont)
+  	where
+  		r         := Var($[result[n]]);
+  		p'        := <nabl-to-str> p;
+  		(cs', c') := <alltd(replace(|[(Var(v), r), (VarRef(v), r)]))> (cs, c);
+  		cont      := <constraints-to-str(|<inc> n, c', term, pattern)> cs'	   
     
 rules
 	  
@@ -230,7 +231,7 @@
   PROP_TASK(v, p, t) =
   Where(
     Assign(
-      Var(v)
+      v
     , App(
         CallT(
           SVar("new-task")
@@ -269,7 +270,7 @@
 
 	replace-all(|rs) = alltd(replace(|rs) <+ introduce-id)
 	
-	replace(|rs): t1 -> t2 where <fetch-elem(?(t1, t2))> rs
+	replace(|rs): t1 -> t2 where <?(t1, t2) <+ fetch-elem(?(t1, t2))> rs
 	
 	introduce-id: Wld()      -> Id()
 	introduce-id: Var(_)     -> Id()

From v.vergu+vc at gmail.com  Mon Mar 11 18:25:20 2013
From: v.vergu+vc at gmail.com (Vlad Vergu)
Date: Mon, 11 Mar 2013 17:25:20 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26004 - in
	spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime:
	services statistics
Message-ID: <20130311172520.89DF1108C018@mx3.tudelft.nl>

Author: VladVergu
Date: Mon Mar 11 17:25:18 2013
New Revision: 26004
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26004&sc=1

Log:
Moved EditScenarioCollector to new statistics package

Added:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/statistics/
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/statistics/EditScenarioCollector.java
      - copied, changed from r25993, spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/EditScenarioCollector.java
Deleted:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/EditScenarioCollector.java
Modified:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/AutoEditStrategy.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/AutoEditStrategy.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/AutoEditStrategy.java	Thu Mar  7 22:44:45 2013	(r26003)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/AutoEditStrategy.java	Mon Mar 11 17:25:18 2013	(r26004)
@@ -45,6 +45,7 @@
 import org.strategoxt.imp.runtime.EditorState;
 import org.strategoxt.imp.runtime.Environment;
 import org.strategoxt.imp.runtime.parser.SGLRParseController;
+import org.strategoxt.imp.runtime.statistics.EditScenarioCollector;
 
 /**
  * @author Lennart Kats <lennart add lclnet.nl>

Copied and modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/statistics/EditScenarioCollector.java (from r25993, spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/EditScenarioCollector.java)
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/EditScenarioCollector.java	Tue Mar  5 15:40:12 2013	(r25993, copy source)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/statistics/EditScenarioCollector.java	Mon Mar 11 17:25:18 2013	(r26004)
@@ -1,4 +1,4 @@
-package org.strategoxt.imp.runtime.services;
+package org.strategoxt.imp.runtime.statistics;
 
 import java.io.File;
 import java.io.FileNotFoundException;

From v.vergu+vc at gmail.com  Mon Mar 11 18:25:25 2013
From: v.vergu+vc at gmail.com (Vlad Vergu)
Date: Mon, 11 Mar 2013 17:25:25 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26005 - in
	spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime:
	. services statistics
Message-ID: <20130311172525.26CC92B800B@mx2.tudelft.nl>

Author: VladVergu
Date: Mon Mar 11 17:25:24 2013
New Revision: 26005
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26005&sc=1

Log:
Basic edit collector with packing and manifest

Added:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/statistics/EditStreak.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/statistics/EditStreakRecorder.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/statistics/RecordedEdit.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/statistics/StreakManifest.java
Modified:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/PreferenceInitializer.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/RuntimeActivator.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/SpoofaxPreferencePage.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/AutoEditStrategy.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/PreferenceInitializer.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/PreferenceInitializer.java	Mon Mar 11 17:25:18 2013	(r26004)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/PreferenceInitializer.java	Mon Mar 11 17:25:24 2013	(r26005)
@@ -2,6 +2,7 @@
 
 import org.eclipse.core.runtime.preferences.AbstractPreferenceInitializer;
 import org.eclipse.jface.preference.IPreferenceStore;
+import org.strategoxt.imp.runtime.statistics.EditStreakRecorder;
 
 /**
  * Class used to initialize default preference values.
@@ -17,5 +18,7 @@
 	public void initializeDefaultPreferences() {
 		IPreferenceStore store = RuntimeActivator.getInstance().getPreferenceStore();
 		store.setDefault(SpoofaxPreferencePage.COLLECT_EDIT_SCENARIOS, false);
+		store.setDefault(EditStreakRecorder.PREF_ENABLE_STREAK, false);
+		store.setDefault(EditStreakRecorder.PREF_STREAK_EXPIRY, EditStreakRecorder.DEFAULT_TIMEOUT);
 	}
 }

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/RuntimeActivator.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/RuntimeActivator.java	Mon Mar 11 17:25:18 2013	(r26004)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/RuntimeActivator.java	Mon Mar 11 17:25:24 2013	(r26005)
@@ -11,10 +11,7 @@
 import org.eclipse.core.runtime.Path;
 import org.eclipse.core.runtime.Platform;
 import org.eclipse.core.runtime.Plugin;
-import org.eclipse.core.runtime.preferences.IEclipsePreferences;
-import org.eclipse.core.runtime.preferences.InstanceScope;
 import org.eclipse.jface.dialogs.MessageDialogWithToggle;
-import org.eclipse.jface.preference.IPreferenceStore;
 import org.eclipse.ui.PlatformUI;
 import org.eclipse.ui.plugin.AbstractUIPlugin;
 import org.osgi.framework.BundleContext;
@@ -118,14 +115,7 @@
 				Environment
 						.logWarning("Make sure Eclipse is started with -vmargs -Xss8m (can be set in eclipse.ini) for an 8 MiB stack size");
 
-			// final String version =
-			// getBundle().getHeaders().get("Bundle-Version");
-			// final String version =
-			// Platform.getBundle(PLUGIN_ID).getVersion().toString();
 			final String version = context.getBundle().getVersion().toString();
-			// final IPreferenceStore prefs = getPreferenceStore();
-			// final IEclipsePreferences prefs =
-			// InstanceScope.INSTANCE.getNode(PLUGIN_ID);
 			final Preferences prefs = Platform.getPreferencesService().getRootNode()
 					.node(Plugin.PLUGIN_PREFERENCE_SCOPE).node(PLUGIN_ID);
 

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/SpoofaxPreferencePage.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/SpoofaxPreferencePage.java	Mon Mar 11 17:25:18 2013	(r26004)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/SpoofaxPreferencePage.java	Mon Mar 11 17:25:24 2013	(r26005)
@@ -1,16 +1,19 @@
 package org.strategoxt.imp.runtime;
 
-import org.eclipse.jface.preference.*;
-import org.eclipse.ui.IWorkbenchPreferencePage;
+import org.eclipse.jface.preference.BooleanFieldEditor;
+import org.eclipse.jface.preference.FieldEditorPreferencePage;
+import org.eclipse.jface.preference.IntegerFieldEditor;
 import org.eclipse.ui.IWorkbench;
-import org.strategoxt.imp.runtime.RuntimeActivator;
+import org.eclipse.ui.IWorkbenchPreferencePage;
+import org.strategoxt.imp.runtime.statistics.EditStreakRecorder;
 
 /**
  * 
  */
-public class SpoofaxPreferencePage
-	extends FieldEditorPreferencePage
-	implements IWorkbenchPreferencePage {
+public class SpoofaxPreferencePage extends FieldEditorPreferencePage implements
+		IWorkbenchPreferencePage {
+	
+	public static final String ID = "org.strategoxt.imp.runtime.SpoofaxPreferencePage";
 
 	public static final String COLLECT_EDIT_SCENARIOS = "collectEditScenariosPreference";
 
@@ -19,27 +22,37 @@
 		setPreferenceStore(RuntimeActivator.getInstance().getPreferenceStore());
 		setDescription("Preferences for language development with Spoofax");
 	}
-	
+
 	/**
-	 * Creates the field editors. Field editors are abstractions of
-	 * the common GUI blocks needed to manipulate various types
-	 * of preferences. Each field editor knows how to save and
-	 * restore itself.
+	 * Creates the field editors. Field editors are abstractions of the common
+	 * GUI blocks needed to manipulate various types of preferences. Each field
+	 * editor knows how to save and restore itself.
 	 */
 	@Override
 	public void createFieldEditors() {
-		addField(
-			new BooleanFieldEditor(
-				COLLECT_EDIT_SCENARIOS,
-				"&Collect Edit Scenarios",
+		addField(new BooleanFieldEditor(COLLECT_EDIT_SCENARIOS, "&Collect Edit Scenarios",
+				getFieldEditorParent()));
+
+		/*
+		 * Edit streak recording preferences
+		 */
+		addField(new BooleanFieldEditor(EditStreakRecorder.PREF_ENABLE_STREAK, "&Record Edit Streaks",
+				getFieldEditorParent()));
+
+		getPreferenceStore().addPropertyChangeListener(EditStreakRecorder.INSTANCE());
+		
+		addField(new IntegerFieldEditor(EditStreakRecorder.PREF_STREAK_EXPIRY, "Streak expiry (in milliseconds)",
 				getFieldEditorParent()));
 	}
 
-	/* (non-Javadoc)
-	 * @see org.eclipse.ui.IWorkbenchPreferencePage#init(org.eclipse.ui.IWorkbench)
+	/*
+	 * (non-Javadoc)
+	 * 
+	 * @see
+	 * org.eclipse.ui.IWorkbenchPreferencePage#init(org.eclipse.ui.IWorkbench)
 	 */
 	public void init(IWorkbench workbench) {
 		//
 	}
-	
+
 }
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/AutoEditStrategy.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/AutoEditStrategy.java	Mon Mar 11 17:25:18 2013	(r26004)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/AutoEditStrategy.java	Mon Mar 11 17:25:24 2013	(r26005)
@@ -40,55 +40,56 @@
 import org.eclipse.swt.graphics.Point;
 import org.spoofax.NotImplementedException;
 import org.spoofax.interpreter.terms.ISimpleTerm;
+import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.jsglr.client.imploder.IToken;
 import org.spoofax.jsglr.client.imploder.ITokenizer;
 import org.strategoxt.imp.runtime.EditorState;
 import org.strategoxt.imp.runtime.Environment;
 import org.strategoxt.imp.runtime.parser.SGLRParseController;
 import org.strategoxt.imp.runtime.statistics.EditScenarioCollector;
+import org.strategoxt.imp.runtime.statistics.EditStreakRecorder;
 
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
  */
 public class AutoEditStrategy implements IAutoEditStrategy, VerifyKeyListener {
-	
+
 	private static boolean justProcessedKeyEvent;
-		
+
 	private final ILanguageSyntaxProperties syntax;
-	
+
 	private final String[][] allFences;
-	
+
 	private final int maxOpenFenceLength;
-	
+
 	private final int maxCloseFenceLength;
-	
+
 	private static UniversalEditor lastEditor;
-	
+
 	private IParseController controller;
-	
+
 	private UniversalEditor editor;
-	
+
 	private int lastAutoInsertedFenceLine;
-	
+
 	private int lastAutoInsertedFencesLength;
-	
+
 	private String lastAutoInsertedFenceLineStart;
-	
+
 	private String lastAutoInsertedFenceLineEnd;
 
 	private boolean allowAutoRemoveFence;
-	
+
 	private Stack<Integer> lastAutoInsertionOpenFences = new Stack<Integer>();
-	
+
 	private EditScenarioCollector editScenarioCollector;
 
 	public AutoEditStrategy(ILanguageSyntaxProperties syntax) {
 		this.syntax = syntax;
-		
-		allFences = syntax instanceof SyntaxProperties
-				? ((SyntaxProperties) syntax).getAllFences()
+
+		allFences = syntax instanceof SyntaxProperties ? ((SyntaxProperties) syntax).getAllFences()
 				: syntax.getFences();
-		
+
 		int maxOpenFenceLength = 0;
 		int maxCloseFenceLength = 0;
 		for (String[] fencePair : allFences) {
@@ -97,20 +98,20 @@
 			if (fencePair[1].length() > maxCloseFenceLength)
 				maxCloseFenceLength = fencePair[1].length();
 		}
-		
+
 		this.maxOpenFenceLength = maxOpenFenceLength;
 		this.maxCloseFenceLength = maxCloseFenceLength;
 		editScenarioCollector = new EditScenarioCollector();
 	}
-	
+
 	public void initialize(IParseController controller) {
 		this.controller = controller;
 	}
-	
+
 	public void customizeDocumentCommand(IDocument document, DocumentCommand command) {
 		try {
 			indentPastedContent(document, command);
-				
+
 		} catch (BadLocationException e) {
 			Environment.logException("Could not determine auto edit strategy", e);
 		} catch (RuntimeException e) {
@@ -121,21 +122,27 @@
 	public void verifyKey(VerifyEvent event) {
 		try {
 			String input = new String(new char[] { event.character });
-			Point selection = getEditor().getSelection(); 
-			if(controller instanceof SGLRParseController) {
-				((SGLRParseController)controller).getParser().setCursorLocation(selection.x);
-				editScenarioCollector.collectEditorFile(((SGLRParseController)controller).getCurrentAst(), selection.x);
+			Point selection = getEditor().getSelection();
+			if (controller instanceof SGLRParseController) {
+				((SGLRParseController) controller).getParser().setCursorLocation(selection.x);
+				final IStrategoTerm ast = ((SGLRParseController) controller).getCurrentAst();
+				editScenarioCollector.collectEditorFile(ast, selection.x);
+				EditStreakRecorder.INSTANCE().recordEdit(ast);
 			}
 			ISourceViewer viewer = getEditor().getServiceControllerManager().getSourceViewer();
 			if (event.widget instanceof StyledText
-					&& indentAfterNewline(viewer, viewer.getDocument(), selection.x, selection.y, input)) {
+					&& indentAfterNewline(viewer, viewer.getDocument(), selection.x, selection.y,
+							input)) {
 				// Make sure caret is visible (urgh)
 				((StyledText) event.widget).invokeAction(ST.LINE_UP);
 				((StyledText) event.widget).invokeAction(ST.LINE_DOWN);
 				event.doit = false;
-			} else if (insertClosingFence(viewer, viewer.getDocument(), selection.x, selection.y, input)
-					|| skipClosingFence(viewer, viewer.getDocument(), selection.x, selection.y, input)
-					|| undoClosingFence(viewer, viewer.getDocument(), selection.x, selection.y, input)) {
+			} else if (insertClosingFence(viewer, viewer.getDocument(), selection.x, selection.y,
+					input)
+					|| skipClosingFence(viewer, viewer.getDocument(), selection.x, selection.y,
+							input)
+					|| undoClosingFence(viewer, viewer.getDocument(), selection.x, selection.y,
+							input)) {
 				event.doit = false;
 			}
 		} catch (BadLocationException e) {
@@ -146,14 +153,15 @@
 			justProcessedKeyEvent = false;
 		}
 	}
-	
+
 	protected static boolean pollJustProcessedKeyEvent() {
 		boolean result = justProcessedKeyEvent;
 		justProcessedKeyEvent = false;
 		return result;
 	}
 
-	protected void indentPastedContent(IDocument document, DocumentCommand command) throws BadLocationException {
+	protected void indentPastedContent(IDocument document, DocumentCommand command)
+			throws BadLocationException {
 		// UNDONE: Disabled smart pasting for now
 		if ("true".equals("true"))
 			return;
@@ -161,13 +169,14 @@
 			String lineStart = getLineBeforeOffset(document, command.offset);
 			if (lineStart.trim().length() > 0) {
 				// Sanity check: only indent based on empty lines
-				// (don't do it if the pasted content may be a new definition which
+				// (don't do it if the pasted content may be a new definition
+				// which
 				// may have to be dedented)
 				return;
 			}
 			String indentation = getIndentation(lineStart);
-			//if (isCloseFenceLine(lineStart)) (noop with above sanity check)
-			//	indentation += createIndentationLevel();
+			// if (isCloseFenceLine(lineStart)) (noop with above sanity check)
+			// indentation += createIndentationLevel();
 			command.text = setIndentation(command.text, indentation);
 		}
 	}
@@ -177,10 +186,12 @@
 	 * Also handles indentation after indentation triggers (which are just
 	 * opening fences).
 	 */
-	protected boolean indentAfterNewline(ISourceViewer viewer, IDocument document, int offset, int length, String input) throws BadLocationException {
+	protected boolean indentAfterNewline(ISourceViewer viewer, IDocument document, int offset,
+			int length, String input) throws BadLocationException {
 		// TODO: support matching fences for indentation:
-		//   "\"" "\""
-		//   (may be very tricky, when detecting if something is a closing " or opening ")
+		// "\"" "\""
+		// (may be very tricky, when detecting if something is a closing
+		// " or opening ")
 		if (input.equals("\n") || input.equals("\r") || input.equals("\r\n")) {
 			justProcessedKeyEvent = true;
 			String lineStart = getLineBeforeOffset(document, offset);
@@ -190,7 +201,8 @@
 			if (closeFence != null) {
 				if (isCloseFenceLine(lineEnd, closeFence)) {
 					upToCursor = "\n" + getIndentation(lineStart, true) + createIndentationLevel();
-					document.replace(offset, length, upToCursor + "\n" + getIndentation(lineStart, true));
+					document.replace(offset, length,
+							upToCursor + "\n" + getIndentation(lineStart, true));
 				} else {
 					upToCursor = "\n" + getIndentation(lineStart, true) + createIndentationLevel();
 					document.replace(offset, length, upToCursor);
@@ -205,23 +217,24 @@
 		}
 		return false;
 	}
-	
-	protected boolean insertClosingFence(ISourceViewer viewer, IDocument document, int offset, int length, String input) throws BadLocationException {
+
+	protected boolean insertClosingFence(ISourceViewer viewer, IDocument document, int offset,
+			int length, String input) throws BadLocationException {
 		// TODO: proper newline after multiline insertion"
-		//   "c\nthen\n\ts\nend" may need an extra \n
-		
+		// "c\nthen\n\ts\nend" may need an extra \n
+
 		// TODO: respect word boundaries
-		//    insert only if "\bif" is typed
-		
+		// insert only if "\bif" is typed
+
 		// TODO: respect Eclipse preference for inserting brackets
-		
+
 		if (input.length() == 0)
 			return false;
 
 		String lineEnd = getLineAfterOffset(document, offset, length);
 		if (getEditor().getInsertMode() == SMART_INSERT
 				|| stripCommentsAndLayout(lineEnd).length() == 0) {
-			
+
 			// Backtrack to see if a fence was typed in
 			// for (int i = 0; i < maxOpenFenceLength && offset - i >= 0; i++) {
 			for (int i = min(maxOpenFenceLength - 1, offset); i >= 0; i--) {
@@ -236,7 +249,8 @@
 					String lineStart = getLineBeforeOffset(document, offset);
 					closeFence = formatInsertedText(closeFence, lineStart);
 					document.replace(offset, length, input + closeFence);
-					IRegion selection = getInsertedTextSelection(offset + input.length(), closeFence);
+					IRegion selection = getInsertedTextSelection(offset + input.length(),
+							closeFence);
 					viewer.setSelectedRange(selection.getOffset(), selection.getLength());
 					lastAutoInsertedFenceLine = document.getLineOfOffset(offset);
 					lastAutoInsertedFenceLineStart = lineStart;
@@ -244,22 +258,23 @@
 					if (lastAutoInsertedFencesLength == 0)
 						allowAutoRemoveFence = true;
 					lastAutoInsertedFencesLength += closeFence.length();
-					allowAutoRemoveFence = allowAutoRemoveFence
-							&& openFence.length() == 1 && closeFence.length() == 1;
+					allowAutoRemoveFence = allowAutoRemoveFence && openFence.length() == 1
+							&& closeFence.length() == 1;
 					lastAutoInsertionOpenFences.push(offset - i + input.length());
 					return true;
 				}
 			}
- 		}
+		}
 		return false;
 	}
-	
-	private boolean isIdentifierAfterOffset(IDocument document, int offset) throws BadLocationException {
+
+	private boolean isIdentifierAfterOffset(IDocument document, int offset)
+			throws BadLocationException {
 		final int ASSUMED_IDENTIFIER_SIZE = 6;
 
 		if (syntax instanceof SyntaxProperties) {
 			Pattern identifierPattern = ((SyntaxProperties) syntax).getIdentifierLexical();
-		
+
 			for (int i = offset, max = document.getLength(); i < max; i++) {
 				char c = document.getChar(i);
 				if (c == '\n' || c == '\r')
@@ -273,12 +288,13 @@
 		}
 		return false;
 	}
-	
+
 	/**
-	 * Tests {@link #isFenceAfterOffset()} succeeds for any of the opening fences.
-	 * Inefficient. 
+	 * Tests {@link #isFenceAfterOffset()} succeeds for any of the opening
+	 * fences. Inefficient.
 	 */
-	private boolean isOpenFenceAfterOffset(IDocument document, int offset) throws BadLocationException {
+	private boolean isOpenFenceAfterOffset(IDocument document, int offset)
+			throws BadLocationException {
 		for (String[] fencePair : allFences) {
 			String openFence = fencePair[0];
 			if (isFenceAfterOffset(document, offset, openFence))
@@ -286,56 +302,62 @@
 		}
 		return false;
 	}
-	
+
 	/**
-	 * Tests if the offset starts with a particular closing fence,
-	 * ignoring whitespace, comments, and lexicals.
+	 * Tests if the offset starts with a particular closing fence, ignoring
+	 * whitespace, comments, and lexicals.
 	 * 
 	 * @see #stripCommentsAndLayout(String)
 	 */
-	private boolean isFenceAfterOffset(IDocument document, int offset, String fence) throws BadLocationException {
+	private boolean isFenceAfterOffset(IDocument document, int offset, String fence)
+			throws BadLocationException {
 		for (int max = document.getLength(); offset < max; offset++) {
 			char c = document.getChar(offset);
 			if (c == '\n' || c == '\r' || !Character.isWhitespace(c))
 				break;
 		}
-		
+
 		int endOffset = offset + fence.length();
-		return endOffset < document.getLength() && document.get(offset, endOffset - offset).equals(fence);
+		return endOffset < document.getLength()
+				&& document.get(offset, endOffset - offset).equals(fence);
 	}
 
 	public static String formatInsertedText(String text, String lineStart) {
 		return text.replace("\\n", "\n" + getIndentation(lineStart, true))
-				.replace("\\t", createIndentationLevel())
-				.replace("\\\"", "\"")
+				.replace("\\t", createIndentationLevel()).replace("\\\"", "\"")
 				.replace("\\\\", "\\");
 	}
 
 	private IRegion getInsertedTextSelection(int startOffset, String insertedText) {
 		// TODO: improve or eliminate getInsertedTextSelection()
-		//  - support selections in strings like "(abc)"
-		//  - move to SyntaxProperties 
-		//  - maybe use this for content completion selections?
+		// - support selections in strings like "(abc)"
+		// - move to SyntaxProperties
+		// - maybe use this for content completion selections?
 		if (syntax instanceof SyntaxProperties) {
-			Matcher matcher = ((SyntaxProperties) syntax).getIdentifierLexical().matcher(insertedText);
+			Matcher matcher = ((SyntaxProperties) syntax).getIdentifierLexical().matcher(
+					insertedText);
 			return new Region(startOffset, matcher.lookingAt() ? matcher.end() : 0);
 		} else {
 			return new Region(startOffset, 0);
 		}
 	}
-	
+
 	/**
-	 * Skip automatically inserted closing fences when the user
-	 * types them in again.
+	 * Skip automatically inserted closing fences when the user types them in
+	 * again.
 	 */
-	protected boolean skipClosingFence(ISourceViewer viewer, IDocument document, int offset, int length, String input) throws BadLocationException {
-		if (lastAutoInsertedFencesLength > 0 && document.getLineOfOffset(offset) == lastAutoInsertedFenceLine) {
+	protected boolean skipClosingFence(ISourceViewer viewer, IDocument document, int offset,
+			int length, String input) throws BadLocationException {
+		if (lastAutoInsertedFencesLength > 0
+				&& document.getLineOfOffset(offset) == lastAutoInsertedFenceLine) {
 			String lineEnd = getLineAfterOffset(document, offset, length);
 			if (lastAutoInsertedFenceLineEnd.startsWith(input)
 					&& lineEnd.equals(lastAutoInsertedFenceLineEnd)
-					&& getLineBeforeOffset(document, offset).startsWith(lastAutoInsertedFenceLineStart)) {
+					&& getLineBeforeOffset(document, offset).startsWith(
+							lastAutoInsertedFenceLineStart)) {
 				justProcessedKeyEvent = true;
-				lastAutoInsertedFenceLineEnd = lastAutoInsertedFenceLineEnd.substring(input.length());
+				lastAutoInsertedFenceLineEnd = lastAutoInsertedFenceLineEnd.substring(input
+						.length());
 				lastAutoInsertedFencesLength--;
 				if (!lastAutoInsertionOpenFences.isEmpty())
 					lastAutoInsertionOpenFences.pop();
@@ -351,35 +373,40 @@
 		}
 		return false;
 	}
-	
+
 	/**
-	 * Undo automatically inserted closing fences when the user
-	 * deletes the opening fence.
+	 * Undo automatically inserted closing fences when the user deletes the
+	 * opening fence.
 	 */
-	protected boolean undoClosingFence(ISourceViewer viewer, IDocument document, int offset, int length, String input) throws BadLocationException {
+	protected boolean undoClosingFence(ISourceViewer viewer, IDocument document, int offset,
+			int length, String input) throws BadLocationException {
 		if (lastAutoInsertedFencesLength > 0 && allowAutoRemoveFence
 				&& document.getLineOfOffset(offset) == lastAutoInsertedFenceLine) {
 			if ("\b".equals(input)) {
 				String deletedChar = document.get(offset - 1, 1);
 				String closeFence = document.get(offset, 1);
 				String expectedCloseFence = getMatchingCloseFence(deletedChar);
-				if (offset == lastAutoInsertionOpenFences.peek() && closeFence.equals(expectedCloseFence)) {
+				if (offset == lastAutoInsertionOpenFences.peek()
+						&& closeFence.equals(expectedCloseFence)) {
 					justProcessedKeyEvent = true;
 					lastAutoInsertedFencesLength--;
 					lastAutoInsertedFenceLineEnd = lastAutoInsertedFenceLineEnd.substring(1);
 					lastAutoInsertionOpenFences.pop();
-					if (getLineBeforeOffset(document, offset).equals(lastAutoInsertedFenceLineStart))
-						lastAutoInsertedFenceLineStart = lastAutoInsertedFenceLineStart.substring(0, lastAutoInsertedFenceLineStart.length() - 1);
+					if (getLineBeforeOffset(document, offset)
+							.equals(lastAutoInsertedFenceLineStart))
+						lastAutoInsertedFenceLineStart = lastAutoInsertedFenceLineStart.substring(
+								0, lastAutoInsertedFenceLineStart.length() - 1);
 					document.replace(offset - 1, 2, "");
 					return true;
 				}
-			} else if (!lastAutoInsertionOpenFences.isEmpty() && lastAutoInsertionOpenFences.peek() > offset) {
+			} else if (!lastAutoInsertionOpenFences.isEmpty()
+					&& lastAutoInsertionOpenFences.peek() > offset) {
 				allowAutoRemoveFence = false;
 			}
 		}
 		return false;
 	}
-	
+
 	private UniversalEditor getEditor() {
 		assert controller != null;
 		if (editor == null) {
@@ -390,12 +417,14 @@
 		return editor;
 	}
 
-	public static String getLineBeforeOffset(IDocument document, int offset) throws BadLocationException {
+	public static String getLineBeforeOffset(IDocument document, int offset)
+			throws BadLocationException {
 		IRegion region = document.getLineInformationOfOffset(offset);
 		return document.get(region.getOffset(), offset - region.getOffset());
 	}
 
-	public static String getLineAfterOffset(IDocument document, int offset, int length) throws BadLocationException {
+	public static String getLineAfterOffset(IDocument document, int offset, int length)
+			throws BadLocationException {
 		IRegion region = document.getLineInformationOfOffset(offset + length);
 		int startOffset = offset + length;
 		int endOffset = region.getOffset() + region.getLength();
@@ -408,11 +437,11 @@
 				&& (text.startsWith(" ") || text.startsWith("\t") || text.contains("\n"))
 				&& text.trim().length() > 0;
 	}
-	
+
 	public static String setIndentation(String text, String indentation) {
 		String oldIndentation = getMultiLineIndentation(text);
 		text = removeIndentation(text, oldIndentation.toCharArray());
-		
+
 		return indentation + text.replace("\n", "\n" + indentation);
 	}
 
@@ -423,7 +452,7 @@
 			result.append(removeSingleLineIndentation(line, indentation, tabWidth) + "\n");
 		}
 		result.deleteCharAt(result.length() - 1);
-		
+
 		text = result.toString();
 		return text;
 	}
@@ -437,14 +466,15 @@
 				if (line.charAt(0) == '\t') {
 					lineOffset++;
 				} else {
-					// TODO: Better support for mixed tabs and spaces when pasting text?
+					// TODO: Better support for mixed tabs and spaces when
+					// pasting text?
 					for (int i = 0; i < tabWidth; i++) {
 						if (line.charAt(lineOffset) != ' ')
 							break;
 						lineOffset++;
 					}
 				}
-			} else if (line.charAt(lineOffset) == ' '){
+			} else if (line.charAt(lineOffset) == ' ') {
 				lineOffset++;
 			} else {
 				break;
@@ -463,22 +493,20 @@
 		}
 		return result;
 	}
-	
+
 	private static String createIndentationLevel() {
 		// TODO: Respect tabs vs. spaces Eclipse preference
 		return useSpacesInsteadOfTabs() ? createSpacesIndentationLevel() : "\t";
 	}
-	
+
 	private static boolean useSpacesInsteadOfTabs() {
 		IPreferenceStore preferences;
-		if(lastEditor!=null){
+		if (lastEditor != null) {
 			preferences = lastEditor.getThePreferenceStore();
-		}
-		else{
+		} else {
 			preferences = EditorState.getActiveEditor().getEditor().getThePreferenceStore();
 		}
-		return preferences != null && 
-			preferences.getBoolean(EDITOR_SPACES_FOR_TABS);
+		return preferences != null && preferences.getBoolean(EDITOR_SPACES_FOR_TABS);
 	}
 
 	private static String createSpacesIndentationLevel() {
@@ -489,42 +517,41 @@
 		}
 		return result.toString();
 	}
-	
+
 	public static int getTabWidth() {
 		IPreferenceStore preferences;
-		if(lastEditor!=null){
+		if (lastEditor != null) {
 			preferences = lastEditor.getThePreferenceStore();
-		}
-		else{
+		} else {
 			preferences = EditorState.getActiveEditor().getEditor().getThePreferenceStore();
 		}
 		return preferences.getInt(EDITOR_TAB_WIDTH); // PreferenceCache.tabWidth;
 	}
-	
+
 	private static String getIndentation(String line) {
 		return getIndentation(line, false);
 	}
-	
+
 	private static String getIndentation(String line, boolean considerPrefix) {
 		int i = 0;
-		
+
 		// HACK: support Stratego-like prefix semicolons
 		if (considerPrefix)
 			line = line.replace(';', ' ').replace(',', ' ');
-		
+
 		for (int length = line.length(); i < length; i++) {
 			char c = line.charAt(i);
 			if (c != ' ' && c != '\t') {
 				return line.substring(0, i);
 			}
 		}
-		
+
 		return i == line.length() ? line : "";
 	}
-	
+
 	/**
-	 * Tests if the line ends with an opening fence,
-	 * ignoring whitespace, comments, and lexicals.
+	 * Tests if the line ends with an opening fence, ignoring whitespace,
+	 * comments, and lexicals.
 	 * 
 	 * @return the matching closing fence, or null if no open fence on this line
 	 * 
@@ -537,15 +564,16 @@
 			String openFence = line.substring(offset, line.length());
 			String closeFence = getMatchingCloseFence(openFence);
 			if (closeFence != null
-					&& (!isIdentifier(openFence) || offset == 0 || !isIdentifier(line.substring(offset - 1, offset))))
+					&& (!isIdentifier(openFence) || offset == 0 || !isIdentifier(line.substring(
+							offset - 1, offset))))
 				return closeFence;
 		}
 		return null;
 	}
-	
+
 	/**
-	 * Tests if the line starts with a particular closing fence,
-	 * ignoring whitespace, comments, and lexicals.
+	 * Tests if the line starts with a particular closing fence, ignoring
+	 * whitespace, comments, and lexicals.
 	 * 
 	 * @see #stripCommentsAndLayout(String)
 	 */
@@ -554,12 +582,13 @@
 		for (int i = 1; i <= maxCloseFenceLength && i <= line.length(); i++) {
 			String closeFence = line.substring(0, i);
 			if (closeFence.equals(fence)
-					&& (!isIdentifier(closeFence) || i == line.length() || !isIdentifier(line.substring(i, i + 1))))
+					&& (!isIdentifier(closeFence) || i == line.length() || !isIdentifier(line
+							.substring(i, i + 1))))
 				return true;
 		}
-		return false;	
+		return false;
 	}
-	
+
 	private boolean isIdentifier(String text) {
 		if (syntax instanceof SyntaxProperties) {
 			Matcher matcher = ((SyntaxProperties) syntax).getIdentifierLexical().matcher(text);
@@ -568,7 +597,7 @@
 			throw new NotImplementedException();
 		}
 	}
-	
+
 	private String getMatchingCloseFence(String text) {
 		if (text.length() > maxOpenFenceLength)
 			return null;
@@ -578,7 +607,7 @@
 		}
 		return null;
 	}
-	
+
 	@SuppressWarnings("unused")
 	private String getMatchingOpenFence(String text) {
 		if (text.length() > maxCloseFenceLength)
@@ -589,9 +618,10 @@
 		}
 		return null;
 	}
-	
+
 	/**
-	 * Dumb stripping of comments and layout, ignoring string literals and the like.
+	 * Dumb stripping of comments and layout, ignoring string literals and the
+	 * like.
 	 */
 	private String stripCommentsAndLayout(String line) {
 		final String singleLineCommentPrefix = syntax.getSingleLineCommentPrefix();
@@ -603,23 +633,26 @@
 		// TODO: strip block comments
 		return line.trim();
 	}
-	
+
 	/**
-	 * Determines if inserting the text, inserted at the given point,
-	 * would be parsed as a lexical or comment.
+	 * Determines if inserting the text, inserted at the given point, would be
+	 * parsed as a lexical or comment.
 	 * 
-	 * Currently looks at the tokenkind at the given offset:
-	 * string and layout tokens lead to a result of true.
+	 * Currently looks at the tokenkind at the given offset: string and layout
+	 * tokens lead to a result of true.
 	 */
-	private boolean isParsedAsLexicalOrLayout(IDocument document, int offset, String text) throws BadLocationException {
-		// TODO: better robustness of isParsedAsLexicalOrLayout if parsed AST is not up to date (like ContentProposer has)
+	private boolean isParsedAsLexicalOrLayout(IDocument document, int offset, String text)
+			throws BadLocationException {
+		// TODO: better robustness of isParsedAsLexicalOrLayout if parsed AST is
+		// not up to date (like ContentProposer has)
 		if (controller.getCurrentAst() == null)
 			return false;
-		ISimpleTerm node = (ISimpleTerm) controller.getSourcePositionLocator().findNode(controller.getCurrentAst(), offset);
+		ISimpleTerm node = (ISimpleTerm) controller.getSourcePositionLocator().findNode(
+				controller.getCurrentAst(), offset);
 		if (node == null)
 			return false;
 		ITokenizer tokens = getLeftToken(node).getTokenizer();
-		
+
 		for (int i = getLeftToken(node).getIndex(), max = getRightToken(node).getIndex(); i <= max; i++) {
 			IToken token = tokens.getTokenAt(i);
 			if (token.getStartOffset() <= offset && offset <= token.getEndOffset()) {
@@ -629,30 +662,42 @@
 							return true;
 						continue;
 					case TK_LAYOUT:
-						if (token.toString().trim().length() > 0 && isSameLine(document, offset, token))
+						if (token.toString().trim().length() > 0
+								&& isSameLine(document, offset, token))
 							return true; // part of a comment
 						continue;
 					case TK_ERROR:
-						// TODO: test if part of comment? can't test if part of string...
-						// IRegion line = document.getLineInformationOfOffset(command.offset);
-						// String lineString = document.get(line.getOffset(), line.getLength());
-						// lineString = start + ContentProposer.COMPLETION_TOKEN + end
+						// TODO: test if part of comment? can't test if part of
+						// string...
+						// IRegion line =
+						// document.getLineInformationOfOffset(command.offset);
+						// String lineString = document.get(line.getOffset(),
+						// line.getLength());
+						// lineString = start + ContentProposer.COMPLETION_TOKEN
+						// + end
 					case TK_IDENTIFIER:
-						/* UNDONE: Detect string literals even if their lexical pattern uses sorts instead of char classes
-						           (e.g., in the SDF syntax, strings are defined as "\"" StrChar* "\"")
-						String tokenText = token.toString();
-						if ((tokenText.startsWith("\"") && tokenText.endsWith("\""))
-								|| (tokenText.startsWith("'") && tokenText.endsWith("'"))) {
-							return true;
-						} else {
-							continue;
-						}
-						*/
-						if (isSameLine(document, offset, token) && isIdentifier(token.toString())) // sanity check
-							return true; // either a string or just not a keyword
+						/*
+						 * UNDONE: Detect string literals even if their lexical
+						 * pattern uses sorts instead of char classes (e.g., in
+						 * the SDF syntax, strings are defined as "\"" StrChar*
+						 * "\"") String tokenText = token.toString(); if
+						 * ((tokenText.startsWith("\"") &&
+						 * tokenText.endsWith("\"")) ||
+						 * (tokenText.startsWith("'") &&
+						 * tokenText.endsWith("'"))) { return true; } else {
+						 * continue; }
+						 */
+						if (isSameLine(document, offset, token) && isIdentifier(token.toString())) // sanity
+																									// check
+							return true; // either a string or just not a
+											// keyword
 						continue;
-					case TK_NUMBER: case TK_OPERATOR:
-					case TK_VAR: case TK_EOF: case TK_UNKNOWN: case TK_RESERVED:
+					case TK_NUMBER:
+					case TK_OPERATOR:
+					case TK_VAR:
+					case TK_EOF:
+					case TK_UNKNOWN:
+					case TK_RESERVED:
 					case TK_KEYWORD:
 						continue;
 					default:
@@ -662,7 +707,7 @@
 		}
 		return false;
 	}
-	
+
 	/**
 	 * Sanity check: ensure token and cursor are on the same line.
 	 */

Added: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/statistics/EditStreak.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/statistics/EditStreak.java	Mon Mar 11 17:25:24 2013	(r26005)
@@ -0,0 +1,110 @@
+/**
+ * 
+ */
+package org.strategoxt.imp.runtime.statistics;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.PrintStream;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
+
+import org.eclipse.core.resources.IResource;
+import org.eclipse.core.runtime.IPath;
+import org.spoofax.jsglr.client.imploder.ImploderAttachment;
+
+/**
+ * @author Vlad Vergu <v.a.vergu add tudelft.nl>
+ * 
+ */
+public class EditStreak {
+	private final List<RecordedEdit> edits = new LinkedList<RecordedEdit>();
+
+	private volatile long lastEdit = -1;
+
+	public long getLastEdit() {
+		if (edits.size() == 0) {
+			return -1;
+		}
+		return lastEdit;
+	}
+
+	public void addEdit(RecordedEdit edit) {
+		assert lastEdit <= edit.timestamp;
+		edits.add(edit);
+		lastEdit = edit.timestamp;
+	}
+
+	public void commit() {
+		final Collection<EditStreak> streaks = splitPerProject();
+		for (EditStreak editStreak : streaks) {
+			try {
+				editStreak.doCommit();
+			} catch (IOException e) {
+				e.printStackTrace();
+			}
+		}
+	}
+
+	private void doCommit() throws IOException {
+		final IPath project = edits.get(0).project;
+		final StreakManifest manifest = StreakManifest.getManifest(project);
+		final int streakNumber = manifest.addStreak(this);
+
+		final File streaksFolder = new File(project.toFile(), EditStreakRecorder.RECORD_LOCATION);
+		if (!streaksFolder.exists()) {
+			streaksFolder.createNewFile();
+		}
+		for (RecordedEdit edit : edits) {
+			final IPath sFilePath = edit.resource.getProjectRelativePath();
+			ensureDirectories(streaksFolder, sFilePath.segments());
+			final File outFile = new File(streaksFolder, sFilePath.toString() + "._" + streakNumber);
+			final PrintStream ps = new PrintStream(outFile);
+			ps.print(ImploderAttachment.getTokenizer(edit.ast).getInput());
+			ps.close();
+		}
+
+	}
+
+	private void ensureDirectories(File parentFolder, String[] segments) {
+		for (int idx = 0; idx < segments.length - 1; idx++) {
+			parentFolder = new File(parentFolder, segments[idx]);
+		}
+		parentFolder.mkdirs();
+	}
+
+	public Set<IResource> getAffectedFiles() {
+		final Set<IResource> files = new HashSet<IResource>();
+		for (RecordedEdit edit : edits) {
+			files.add(edit.resource);
+		}
+		return files;
+	}
+
+	public void pack() {
+		final HashMap<IResource, RecordedEdit> packetEdits = new HashMap<IResource, RecordedEdit>();
+		for (RecordedEdit edit : edits) {
+			packetEdits.put(edit.resource, edit);
+		}
+		edits.clear();
+		edits.addAll(packetEdits.values());
+	}
+
+	private Collection<EditStreak> splitPerProject() {
+		final HashMap<IPath, EditStreak> projectStreaks = new HashMap<IPath, EditStreak>();
+		for (RecordedEdit edit : edits) {
+			EditStreak streak = projectStreaks.get(edit.project);
+			if (streak == null) {
+				streak = new EditStreak();
+				projectStreaks.put(edit.project, streak);
+			}
+			streak.addEdit(edit);
+		}
+
+		return projectStreaks.values();
+	}
+}

Added: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/statistics/EditStreakRecorder.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/statistics/EditStreakRecorder.java	Mon Mar 11 17:25:24 2013	(r26005)
@@ -0,0 +1,161 @@
+/**
+ * 
+ */
+package org.strategoxt.imp.runtime.statistics;
+
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+
+import org.eclipse.jface.preference.IPreferenceStore;
+import org.eclipse.jface.util.IPropertyChangeListener;
+import org.eclipse.jface.util.PropertyChangeEvent;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.strategoxt.imp.runtime.RuntimeActivator;
+import org.strategoxt.imp.runtime.services.AutoEditStrategy;
+import org.strategoxt.imp.runtime.stratego.SourceAttachment;
+
+/**
+ * Records edits made to files. It detects and packs edit streaks into single
+ * versions automatically if this option is enabled.
+ * 
+ * Edits are submitted by {@link AutoEditStrategy} through calls to the
+ * {@link #recordEdit(IStrategoTerm)} method. Calls to the
+ * {@link #recordEdit(IStrategoTerm)} method are asynchronous, this class
+ * manages its own thread and uses it to perform background processing.
+ * 
+ * 
+ * Auto-chunking works like this:
+ * 
+ * All edits are continuously recorded. If no edits are made for at least
+ * {@link #PREF_STREAK_EXPIRY} milliseconds the edits are packed and the diffs
+ * are committed.
+ * 
+ * @author Vlad Vergu <v.a.vergu add tudelft.nl>
+ * 
+ */
+public class EditStreakRecorder implements Runnable, IPropertyChangeListener {
+
+	/* preference IDs */
+	public static final String PREF_ENABLE_STREAK = "streakPrefRecordEnable";
+
+	public static final String PREF_STREAK_EXPIRY = "streakPrefStreakExpiry";
+
+	public static final String RECORD_LOCATION = "_recordedstreaks";
+
+	public static final int DEFAULT_TIMEOUT = 600;
+
+	private boolean cfgEnabled;
+
+	private int cfgStreakExp;
+
+	private Thread thread;
+
+	private final BlockingQueue<RecordedEdit> queue;
+
+	private EditStreak currentStreak;
+
+	private volatile boolean doStop;
+
+	private EditStreakRecorder() {
+		this.queue = new LinkedBlockingQueue<RecordedEdit>();
+		final IPreferenceStore store = RuntimeActivator.getInstance().getPreferenceStore();
+		this.cfgEnabled = store.getBoolean(PREF_ENABLE_STREAK);
+		this.cfgStreakExp = store.getInt(PREF_STREAK_EXPIRY);
+		init();
+	}
+
+	private static EditStreakRecorder INSTANCE;
+
+	public static EditStreakRecorder INSTANCE() {
+		if (INSTANCE == null) {
+			INSTANCE = new EditStreakRecorder();
+		}
+		return INSTANCE;
+	}
+
+	/**
+	 * Enqueue recording of the given ast. The edited path is determined from
+	 * the {@link SourceAttachment} of the AST.
+	 * 
+	 * @param ast
+	 */
+	public void recordEdit(IStrategoTerm ast) {
+		assert ast != null;
+		if (this.thread == null || !this.thread.isAlive() || doStop) {
+			return;
+		}
+		queue.add(new RecordedEdit(ast, System.currentTimeMillis()));
+	}
+
+	public void run() {
+		while (!doStop) {
+			RecordedEdit edit = null;
+			try {
+				edit = queue.poll(cfgStreakExp, TimeUnit.MILLISECONDS);
+			} catch (InterruptedException e) {
+				// irrelevant
+			}
+			if (currentStreak == null) {
+				currentStreak = new EditStreak();
+			}
+
+			final long lastStreakEdit = currentStreak.getLastEdit();
+			final long now = System.currentTimeMillis();
+			if (lastStreakEdit >= 0 && currentStreak.getLastEdit() + cfgStreakExp < now) {
+				currentStreak.pack();
+				currentStreak.commit();
+				currentStreak = new EditStreak();
+			}
+
+			if (edit != null) {
+				currentStreak.addEdit(edit);
+			}
+		}
+		if (currentStreak != null) {
+			currentStreak.commit();
+		}
+	}
+
+	private void start() {
+		if (this.thread == null || !this.thread.isAlive()) {
+			this.doStop = false;
+			this.thread = new Thread(this);
+			this.thread.setDaemon(true);
+			this.thread.setName("EditStreakRecorder");
+			this.thread.setPriority(Thread.MIN_PRIORITY);
+			this.thread.start();
+		}
+	}
+
+	private void stop() {
+		if (this.thread != null && this.thread.isAlive()) {
+			System.out.println("Stopping...");
+			this.doStop = true;
+			this.thread.interrupt();
+		}
+	}
+
+	public void init() {
+		if (cfgEnabled) {
+			if (this.thread == null || !this.thread.isAlive()) {
+				start();
+			}
+		} else {
+			if (this.thread != null && this.thread.isAlive()) {
+				stop();
+			}
+		}
+	}
+
+	public void propertyChange(PropertyChangeEvent event) {
+		if (event.getProperty() == PREF_ENABLE_STREAK) {
+			this.cfgEnabled = (Boolean) event.getNewValue();
+			init();
+		} else if (event.getProperty() == PREF_STREAK_EXPIRY) {
+			this.cfgStreakExp = (Integer) event.getNewValue();
+			init();
+		}
+	}
+
+}

Added: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/statistics/RecordedEdit.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/statistics/RecordedEdit.java	Mon Mar 11 17:25:24 2013	(r26005)
@@ -0,0 +1,31 @@
+/**
+ * 
+ */
+package org.strategoxt.imp.runtime.statistics;
+
+import org.eclipse.core.resources.IResource;
+import org.eclipse.core.runtime.IPath;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.strategoxt.imp.runtime.stratego.SourceAttachment;
+
+/**
+ * @author Vlad Vergu <v.a.vergu add tudelft.nl>
+ *
+ */
+public class RecordedEdit {
+
+	public final long timestamp;
+	public final IStrategoTerm ast;
+	public final IResource resource;
+	public final IPath project;
+	
+	public RecordedEdit(IStrategoTerm ast, long timestamp) {
+		assert ast != null;
+		this.ast = ast;
+		this.timestamp = timestamp;
+		this.resource = SourceAttachment.getResource(ast);
+		this.project = this.resource.getProject().getLocation();
+	}
+	
+	
+}

Added: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/statistics/StreakManifest.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/statistics/StreakManifest.java	Mon Mar 11 17:25:24 2013	(r26005)
@@ -0,0 +1,99 @@
+/**
+ * 
+ */
+package org.strategoxt.imp.runtime.statistics;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.Properties;
+import java.util.Set;
+
+import org.eclipse.core.resources.IResource;
+import org.eclipse.core.runtime.IPath;
+
+/**
+ * @author Vlad Vergu <v.a.vergu add tudelft.nl>
+ * 
+ */
+public class StreakManifest {
+
+	protected static final String PROP_TOTAL_STREAKS = "numstreaks";
+
+	protected static final String PROP_PREFIX_STREAK = "streak.";
+
+	protected static final String PROP_SUFFIX_FILES = ".files";
+
+	private final File manifestFile;
+
+	private Properties props;
+
+	private StreakManifest(IPath project) {
+		assert project != null;
+		final File projectDir = project.toFile();
+		assert projectDir.exists();
+		final File streaksDir = new File(projectDir, EditStreakRecorder.RECORD_LOCATION);
+		if (!streaksDir.exists() || streaksDir.isFile()) {
+			streaksDir.mkdir();
+		}
+		manifestFile = new File(streaksDir, "streaks.mf").getAbsoluteFile();
+		load();
+	}
+
+	private void load() {
+		FileInputStream fis = null;
+		try {
+			if (!manifestFile.exists()) {
+				manifestFile.createNewFile();
+			}
+			fis = new FileInputStream(manifestFile);
+			props = new Properties();
+			props.load(fis);
+		} catch (IOException e) {
+			;
+		} finally {
+			try {
+				if (fis != null)
+					fis.close();
+			} catch (IOException e) {
+				;
+			}
+		}
+	}
+
+	public int addStreak(EditStreak streak) {
+		assert streak != null;
+		final int totalStreaks = Integer.parseInt(props.getProperty(PROP_TOTAL_STREAKS, "0")) + 1;
+
+		final Set<IResource> files = streak.getAffectedFiles();
+		assert files.size() > 0;
+		final Iterator<IResource> fiter = files.iterator();
+		final StringBuilder streakFilesStr = new StringBuilder();
+		while (fiter.hasNext()) {
+			final IResource f = fiter.next();
+			streakFilesStr.append(f.getProjectRelativePath().toString());
+			streakFilesStr.append("." + totalStreaks);
+			if (fiter.hasNext()) {
+				streakFilesStr.append(",");
+			}
+		}
+		props.put(PROP_PREFIX_STREAK + totalStreaks + PROP_SUFFIX_FILES, streakFilesStr.toString());
+		props.put(PROP_TOTAL_STREAKS, totalStreaks + "");
+		FileOutputStream fos;
+		try {
+			fos = new FileOutputStream(manifestFile);
+			props.store(fos, "");
+		} catch (IOException e) {
+			;
+		}
+		return totalStreaks;
+	}
+
+	public static StreakManifest getManifest(IPath project) {
+		assert project != null;
+		return new StreakManifest(project);
+	}
+
+}


From g.h.wachsmuth at tudelft.nl  Tue Mar 12 04:11:04 2013
From: g.h.wachsmuth at tudelft.nl (Guido Wachsmuth)
Date: Tue, 12 Mar 2013 03:11:04 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26006 - in
	spoofax-imp/branches/nbl-dev: syntax syntax/nabl test trans
	trans/generation
Message-ID: <20130312031104.DBD232B800B@mx2.tudelft.nl>

Author: GuidoWachsmuth
Date: Tue Mar 12 03:11:03 2013
New Revision: 26006
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26006&sc=1

Log:
full support for constraints on definition and scope sites

Added:
   spoofax-imp/branches/nbl-dev/trans/generation/
   spoofax-imp/branches/nbl-dev/trans/generation/constraints.str
   spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str
   spoofax-imp/branches/nbl-dev/trans/generation/main.str
   spoofax-imp/branches/nbl-dev/trans/generation/rules.str
   spoofax-imp/branches/nbl-dev/trans/generation/sections.str
   spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str
   spoofax-imp/branches/nbl-dev/trans/generation/util.str
Deleted:
   spoofax-imp/branches/nbl-dev/trans/new-generate.str
Modified:
   spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.generated.pp
   spoofax-imp/branches/nbl-dev/syntax/nabl/Rules.sdf
   spoofax-imp/branches/nbl-dev/test/example.nab
   spoofax-imp/branches/nbl-dev/trans/namebindinglanguage.str
   spoofax-imp/branches/nbl-dev/trans/names.nd
   spoofax-imp/branches/nbl-dev/trans/names.str

Modified: spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.generated.pp
==============================================================================
--- spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.generated.pp	Mon Mar 11 17:25:24 2013	(r26005)
+++ spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.generated.pp	Tue Mar 12 03:11:03 2013	(r26006)
@@ -58,8 +58,9 @@
    ListVarRef                                             -- _1,
    BindingRules                                           -- V  [H  [KW["binding"] KW["rules"]] _1],
    BindingRules.1:iter-star                               -- _1,
-   BindingRule                                            -- _1 KW[":"] _2,
-   BindingRule.2:iter                                     -- _1,
+   BindingRule                                            -- _1 _2 KW[":"] _3,
+   BindingRule.2:iter-star                                -- _1,
+   BindingRule.3:iter                                     -- _1,
    DefSite                                                -- KW["defines"] _1 _2 _3 _4 _5,
    DefSite.3:iter-star                                    -- _1,
    DefSite.5:iter-star                                    -- _1,
@@ -79,8 +80,8 @@
    Exact                                                  -- ,
    Conformance                                            -- KW["conformant"],
    Current                                                -- ,
-   Current                                                -- KW["in"] KW["current"] KW["scope"],
-   DefScopes                                              -- V  [H  [KW["in"]] _1],
+   Current                                                -- KW["current"] KW["scope"],
+   DefScopes                                              -- _1,
    DefScopes.1:iter-sep                                   -- _1 KW[","],
    Subsequent                                             -- KW["subsequent"] KW["scope"],
    DefScope                                               -- _1,
@@ -91,26 +92,30 @@
    Reference                                              -- _1 _2 _3 _4,
    Reference.2:iter-star                                  -- _1,
    Reference.4:iter-star                                  -- _1,
-   RefScope                                               -- KW["in"] _1 _2 _3,
-   RefScope.2:iter-star                                   -- _1,
-   Current                                                -- KW["in"] KW["current"] KW["scope"],
-   Surrounding                                            -- KW["in"] KW["surrounding"] _1,
    All                                                    -- ,
+   Current                                                -- KW["current"] KW["scope"],
+   Surrounding                                            -- KW["surrounding"] _1,
+   RefScope                                               -- _1 _2 _3,
+   RefScope.2:iter-star                                   -- _1,
    QualifiedName                                          -- _1,
    QualifiedName.1:iter-sep                               -- _1 KW["otherwise"],
    OverlayName                                            -- _1,
    OverlayName.1:iter-sep                                 -- _1 KW["otherwise"],
    ImportSite                                             -- _1,
    ImportSite.1:iter-sep                                  -- _1 KW["otherwise"],
-   Import                                                 -- KW["imports"] _1 _2 _3 _4,
-   Import.1:iter-sep                                      -- _1 KW[","],
-   Import.2:iter-star                                     -- _1,
-   Current                                                -- ,
+   SingleImport                                           -- KW["imports"] _1 _2 _3 _4 _5,
+   SingleImport.2:iter-star                               -- _1,
+   SingleImport.5:iter-star                               -- _1,
+   WildcardImport                                         -- KW["imports"] _1 _2 _3 _4 _5,
+   WildcardImport.1:iter-sep                              -- _1 KW[","],
+   WildcardImport.2:iter-star                             -- _1,
+   WildcardImport.5:iter-star                             -- _1,
+   Reference                                              -- _1 _2 _3 _4,
+   Reference.2:iter-star                                  -- _1,
+   Reference.4:iter-star                                  -- _1,
+   All                                                    -- ,
    RefScope                                               -- KW["from"] _1,
    Current                                                -- ,
-   Current                                                -- KW["into"] KW["current"] KW["scope"],
-   DefScopes                                              -- V  [H  [KW["into"]] _1],
-   DefScopes.1:iter-sep                                   -- _1 KW[","],
    Constraint                                             -- KW["where"] _1 _2,
    PropertyCond                                           -- KW["has"] _1 _2,
    PropertyCond                                           -- KW["is"] KW["of"] _1 _2,

Modified: spoofax-imp/branches/nbl-dev/syntax/nabl/Rules.sdf
==============================================================================
--- spoofax-imp/branches/nbl-dev/syntax/nabl/Rules.sdf	Mon Mar 11 17:25:24 2013	(r26005)
+++ spoofax-imp/branches/nbl-dev/syntax/nabl/Rules.sdf	Tue Mar 12 03:11:03 2013	(r26006)
@@ -14,7 +14,7 @@
     "binding" "rules" NamingRule*                       -> ModSection     {"BindingRules"}
 
     Documentation                                       -> NamingRule
-    BTerm ":" NamingRulePart+                           -> NamingRule     {"BindingRule"}
+    BTerm Constraint* ":" NamingRulePart+               -> NamingRule     {"BindingRule"}
     
   context-free syntax %% definition sites 
     
@@ -41,8 +41,9 @@
     "conformant"                                        -> PropertyMatch  {"Conformance"}
     
                                                         -> DefScopes      {"Current"}
-    "in" "current" "scope"                              -> DefScopes      {"Current"}
-    "in" {DefScope ","}+                                -> DefScopes      {"DefScopes"}
+    "in" DefScopesCore                                  -> DefScopes      {bracket}
+    "current" "scope"                                   -> DefScopesCore  {"Current"}
+    {DefScope ","}+                                     -> DefScopesCore  {"DefScopes"}
     "subsequent" "scope"                                -> DefScope       {"Subsequent"}
     RTerm                                               -> DefScope       {"DefScope"}
     
@@ -56,10 +57,11 @@
     "refers" "to" RefPartCore                           -> RefPart        {bracket}
     IBinding BProperty* RefScope Constraint*            -> RefPartCore    {"Reference"}
       
-    "in" IBinding Property* RefScope                    -> RefScope       {"RefScope"}
-    "in" "current" "scope"                              -> RefScope       {"Current"}
-    "in" "surrounding" NamespaceRef                     -> RefScope       {"Surrounding"}
                                                         -> RefScope       {"All"}
+    "in" RefScopeCore                                   -> RefScope       {bracket}
+    "current" "scope"                                   -> RefScopeCore   {"Current"}
+    "surrounding" NamespaceRef                          -> RefScopeCore   {"Surrounding"}
+    IBinding Property* RefScope                         -> RefScopeCore   {"RefScope"}
   
   context-free syntax %% qualified names
 
@@ -71,21 +73,18 @@
     
   context-free syntax %% imports
     
-    {ImportPart "otherwise"}+                                 -> NamingRulePart  {"ImportSite"}    
-    "imports" {Imported ","}+ BProperty* IRefScope IDefScopes -> ImportPart      {"Import"}
+    {ImportPart "otherwise"}+                                                  -> NamingRulePart  {"ImportSite"}    
+    "imports" IBinding BProperty* IRefScope IDefScopes Constraint*             -> ImportPart      {"SingleImport"}
+    "imports" {INamespaceRef ","}+ BProperty* IRefScope IDefScopes Constraint* -> ImportPart      {"WildcardImport"}
 
-    INamespaceRef                                       -> Imported
-    IBinding                                            -> Imported
-     
-    %% "imports"{INamespaceRef ","}+ "into" RefPartCore IDefScopes  -> NamingRulePart {"ImportToSite"}
-    
-                                                        -> IRefScope      {"Current"}
-    "from" RefPartCore                                  -> IRefScope      {bracket}
+    IBinding BProperty* RefScope Constraint*            -> RefPartCore    {"Reference"}
+      
+                                                        -> IRefScope      {"All"}
+    "from" RefScopeCore                                 -> IRefScope      {bracket}
     "from" RTerm                                        -> IRefScope      {"RefScope"}
     
                                                         -> IDefScopes     {"Current"}
-    "into" "current" "scope"                            -> IDefScopes     {"Current"}
-    "into" {DefScope ","}+                              -> IDefScopes     {"DefScopes"}
+    "into" DefScopesCore                                -> IDefScopes     {bracket}
     
     %% Constraint
     "where" RTerm Condition                             -> Constraint     {"Constraint"}

Modified: spoofax-imp/branches/nbl-dev/test/example.nab
==============================================================================
--- spoofax-imp/branches/nbl-dev/test/example.nab	Mon Mar 11 17:25:24 2013	(r26005)
+++ spoofax-imp/branches/nbl-dev/test/example.nab	Tue Mar 12 03:11:03 2013	(r26006)
@@ -14,10 +14,9 @@
  
 binding rules
 
-	Entity(name, x) :
-		scopes Property, Method
-		defines 
-			Entity name  
-			of type EntityType(name)
-			of ancestors []
-			//in subsequent scope, x
+	Foo(x, y)
+	  where x has type (t, _, t)
+	  where y has type t:
+	  defines Entity x of type t
+	  refers to Entity y
+	  
\ No newline at end of file

Added: spoofax-imp/branches/nbl-dev/trans/generation/constraints.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/nbl-dev/trans/generation/constraints.str	Tue Mar 12 03:11:03 2013	(r26006)
@@ -0,0 +1,74 @@
+module generation/constraints
+
+imports 
+  
+  libstrc
+  include/NameBindingLanguage
+  generation/util
+  generation/main
+  
+rules
+  
+  constraints-to-str: 
+    ([], (bnd*, rep*, n, str)) -> (bnd*, rep*, n, str, [])
+  
+  constraints-to-str: 
+    ([c | cs ], (bnd*, rep*, n, prev)) -> (bnd3*, rep3*, n3, Seq(prev, cont), [r1*, r2*])
+    where
+      (bnd2*, rep2*, n2, curr, r1*) := <constraint-to-str(|bnd*, rep*, n)> c;
+      (bnd3*, rep3*, n3, cont, r2*) := <constraints-to-str> (cs, (bnd2*, rep2*, n2, curr))    
+
+  constraint-to-str(|bnd*, rep*, n):  
+    Constraint(t1, PropertyCond(p, t2)) -> result
+    where
+      // create new task for property calculation
+      r  := Var($[r[n]]);
+      p' := <nabl-to-str> p;
+      t3 := <alltd(replace(|rep*))> t1;
+      pt := PROP_TASK(r, p', t3);
+      if 
+        Var(v) := t2;
+        <not(elem)> (v, bnd*) 
+     then // single unbound variable is replaced with result
+        result := ( [v, bnd*]
+                  , [(Var(v), r), (VarRef(v), r), rep*]
+                  , <inc> n
+                  , pt
+                  , []
+                  )
+      else
+      	var*   := <collect-all(?Var(<id>))> t2;
+      	bvar*  := <isect; map(!Var(<id>))> (var*, bnd*);
+      	result := <matches-to-str(|t2, r, bvar*)> (var*, bnd*, rep*, <inc> n, pt)
+      end
+  
+  matches-to-str(|term, res, bvar*):
+  	([], bnd*, rep*, n, pt) -> (bnd*, rep*, n, pt, [])
+ 
+  matches-to-str(|term, res, bvar*):
+  	([v|vs], bnd*, rep*, n, prev) -> (bnd3*, rep3*, n3, Seq(prev, cont), [mr, r*])
+    where
+    	mn    := NoAnnoList(Str(<newname; double-quote> "match"));
+    	r     := Var($[r[n]]);
+    	bvar2*:= <alltd(replace(|rep*))> bvar*;
+    	mt    := MATCH_TASK(r, mn, bvar2*, res);
+    	mr    := MATCH_RULE(mn, term, bvar*, Var(v));
+    	bnd2* := [v, bnd*];
+    	rep2* := [(Var(v), r), (VarRef(v), r), rep*];
+    	n2    := <inc> n;
+    	(bnd3*, rep3*, n3, cont, r*) := <matches-to-str(|term, res, bvar*)> (vs, bnd2*, rep2*, n2, mt)
+      
+overlays
+    
+  MATCH_RULE(n, lhs, bnd, rhs) = RDefNoArgs("nabl-match", RuleNoCond(TUPLE([n, lhs, LIST(bnd)]), rhs))
+
+  PROP_TASK(v, p, t)     = NEW_TASK(v, TERM("PropCalc", [p, t]))
+  MATCH_TASK(v, n, b, t) = NEW_TASK(v, TERM("Match", [n, LIST(b), t]))
+  
+  NEW_TASK(v, t) = Where(Assign(v, NEW_TASK(t)))
+  
+  NEW_TASK(t) =
+  App(
+    CallT(SVar("new-task"), [], [App(CallNoArgs(SVar("task-in-context")), Var("context"))])
+  , t
+  )
\ No newline at end of file

Added: spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str	Tue Mar 12 03:11:03 2013	(r26006)
@@ -0,0 +1,85 @@
+module generation/def-sites
+
+imports
+  
+  libstrc
+  include/NameBindingLanguage
+  
+  generation/util
+  generation/main
+  generation/constraints
+  
+rules // definitions, scopes, properties
+    
+  def-to-str(|bnd*, rep*, n, cont, pattern, scopes):
+    DefSite(u, NameBinding(ns, t), ps, ds, constr*) -> [dr, pr*]
+    where  
+      // replace name with callback to handle definition site
+      t'      := <to-ppable-str> t ;
+      replace := ( t', DEF_CALL(<nabl-to-str> ns, <nabl-to-str> u, <nabl-to-str> ds, scopes))
+    where 
+      // when we have external scopes in a "defines ... in ..." clause, 
+      // replace these external scopes with callbacks
+      replace* := <?DefScopes(<filter(def-scope-to-str)>); nonempty> ds;
+      // callback to determine external scope 
+      sc       := SCOPE_CALL(<nabl-to-str> ns);
+      // apply all replacements and generate a rule handling this definition site
+      dr       := DEF_RULE(Match(pattern), Seq(sc, <replace-all(|[replace, replace*])> pattern)) <+
+      // otherwise replace only the name and
+      // generate a rule handling this defintion site
+      dr       := DEF_RULE(Match(pattern), <replace-all(|[replace])> pattern)
+    where
+      // when this definition site defines properties,
+      // construct sequence of property calculatations
+      (_, rep2*, _, ccall2, rule*) := <constraints-to-str> (constr*, (bnd*, rep*, n, cont));
+      // and a callback
+      pcall  := <alltd(replace(|rep2*))> PROP_CALL(<nonempty; map(prop-to-str)> ps);
+      // generate a rule handling properties at this definition site
+      pbody := <replace-all(|[(t', pcall)])> pattern ;
+      pr*   := [PROP_RULE(ccall2, pbody), rule*] <+
+      // otherwise generate no rule
+      pr*   := []
+
+  def-scope-to-str:
+    DefScope(x) -> (<to-ppable-str> x, SCOPE_CALL())      
+
+  prop-to-str:
+    PropertyBinding(p, t) -> PROPERTY(<nabl-to-str> p, <to-ppable-str> t)     
+
+overlays
+  
+  DEF_RULE(match, call) =
+  SDefT(
+    "nabl-def-site"
+  , [DefaultVarDec("child-uris"), DefaultVarDec("sibl-uris")]
+  , [DefaultVarDec("context"), DefaultVarDec("uris"), DefaultVarDec("states")]
+  , Seq(match, call)
+  )
+    
+  DEF_CALL(ns, u, ds, s) = 
+  CallT(
+    SVar("nabl-def")
+  , [CALL("child-uris"), CALL("sibl-uris")]
+  , [ Var("context"), Var("uris"), ns, u, ds, LIST(s)]
+  )
+
+  SCOPE_CALL()   = CallT(SVar("nabl-def-scope"), [], [SCOPE()])
+  SCOPE_CALL(ns) = Where(Assign(SCOPE(), App(CallT(SVar("nabl-def-scope"), [], [Var("context")]), ns)))
+    
+  PROP_RULE(match, call) =
+  SDefT(
+    "nabl-prop-site"
+  , []
+  , [DefaultVarDec("context"), DefaultVarDec("states")]
+  , Seq(match, call)
+  )
+  
+  PROP_CALL(ps) = 
+  CallT(
+    SVar("nabl-props")
+  , []
+  , [ Var("context"), LIST(ps)]
+  )
+  
+  PROPERTY(p, v) = TERM("Prop", [p, v])
+

Added: spoofax-imp/branches/nbl-dev/trans/generation/main.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/nbl-dev/trans/generation/main.str	Tue Mar 12 03:11:03 2013	(r26006)
@@ -0,0 +1,25 @@
+module generation/main
+
+imports
+  
+  libstrc
+  include/NameBindingLanguage
+  generation/util
+  generation/sections
+  
+rules
+  
+  generate-name-analysis:
+    (selected, position, ast at Module(name, _, _), path, project-path) -> (filename, result)
+    with
+      filename   := <guarantee-extension(|"str")> path ;
+      str-module := <nabl-to-str; to-ppable-str> ast ;
+      // use next line to debug which AST node cannot be handled by the pretty-printer
+      <bottomup(try(not(is-string) ; not(is-list) ; not(pp-stratego-string) ; debug(!"cannot pp ")))> str-module ;
+      result     := <pp-stratego-string> str-module
+
+rules // modules
+  
+  nabl-to-str:
+    Module(name, _, sections) -> Module(name, <filter(nabl-to-str)> sections)
+    

Added: spoofax-imp/branches/nbl-dev/trans/generation/rules.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/nbl-dev/trans/generation/rules.str	Tue Mar 12 03:11:03 2013	(r26006)
@@ -0,0 +1,46 @@
+module generation/rules
+  
+imports
+  
+  libstrc
+  include/NameBindingLanguage
+  
+  generation/util
+  generation/constraints
+  generation/def-sites
+  generation/use-sites
+  
+rules
+  
+  // TODO: support multiple definition sites
+  nabl-to-str: 
+    BindingRule(pattern, constr*, parts) -> [defscope*, use*, rule*]
+    where
+      bound* := <collect-all(?Var(<id>))> pattern;
+      (bnd*, rep*, n, cont, rule*)  := <constraints-to-str> (constr*, (bound*, [], 1, Match(pattern)));
+      scope* := <filter(?Scopes(<id>)); concat; map(nabl-to-str)> parts
+    where
+      defscope* := <fetch-elem(def-to-str(|bnd*, rep*, n, cont, pattern, scope*))> parts <+
+      defscope* := [SCOPE_RULE(pattern, <nonempty> scope*)] <+
+      defscope* := []
+    where
+      use* := <filter(use-to-str(|pattern))> parts
+      
+overlays
+	
+	SCOPE_RULE(pattern, scopes) =
+  SDefT(
+    "nabl-anonymous-scope-site"
+  , [DefaultVarDec("child-uris")]
+  , [DefaultVarDec("context"), DefaultVarDec("uris"), DefaultVarDec("states")]
+  , Seq(
+      Match(pattern)
+    , CallT(
+        SVar("nabl-anonymous-scope")
+      , [CALL("child-uris")]
+      , [ Var("context"), Var("uris"), LIST(scopes) ]
+      )
+    )
+  )
+    
+  
\ No newline at end of file

Added: spoofax-imp/branches/nbl-dev/trans/generation/sections.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/nbl-dev/trans/generation/sections.str	Tue Mar 12 03:11:03 2013	(r26006)
@@ -0,0 +1,41 @@
+module generation/sections
+
+imports
+  
+  libstrc
+  include/NameBindingLanguage
+  
+  generation/util
+  generation/rules
+    
+rules // namespaces 
+      
+  nabl-to-str:
+    Namespaces(namespaces) -> Signature([Constructors(<map(nabl-to-str)> namespaces)])
+    
+  nabl-to-str: // generates constructors for namespaces
+    Namespace(ns) -> CONS_DECL(ns, "Namespace")
+  
+  nabl-to-str: NamespaceRef(ns) -> TERM(ns)
+
+rules // properties
+        
+  nabl-to-str:
+    Properties(props) -> Signature([Constructors(<map(nabl-to-str)> props)])
+  
+  nabl-to-str: // generate constructors for properties
+    Property(prop, _, _) -> CONS_DECL(prop, "Property") 
+
+  nabl-to-str: PropertyRef(p) -> TERM(p)
+  nabl-to-str: TypeProp()     -> TERM("Type")
+
+rules // imports
+    
+  nabl-to-str = Imports(![ImportWildcard("lib/nbl"), ImportWildcard("lib/task")|<id>])
+    
+rules // binding rules
+
+  nabl-to-str:
+    BindingRules(rs) -> Rules(<filter(nabl-to-str); concat; nonempty> rs)
+      
+  
\ No newline at end of file

Added: spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str	Tue Mar 12 03:11:03 2013	(r26006)
@@ -0,0 +1,78 @@
+module generation/use-sites
+
+imports
+  
+  libstrc
+  include/NameBindingLanguage
+  
+  generation/util
+  generation/main
+  generation/constraints
+
+rules
+    
+  use-to-str(|pattern):
+    UseSite(refs) -> <refs-to-str(|pattern)> refs
+  
+  use-to-str(|pattern):
+    ImportSite(imports) -> <refs-to-str(|pattern)> imports
+      
+  // TODO: support properties
+  // TODO: support conditions
+  refs-to-str(|pattern):  
+    refs -> USE_RULE(pattern, <replace-all(|[replace])> pattern)
+    where
+      Hd => Reference(NameBinding(_, _, t), _, _, _) <+
+      Hd => SingleImport(NameBinding(_, _, t), _, _, _, _) <+
+      Hd => WildcardImport(_, _, RefScope(NameBinding(_, _, t)), _, _)
+    where
+      replace := (<to-ppable-str> t, USE_CALL(<filter(ref-to-str); nonempty> refs))
+      
+  ref-to-str: 
+    Reference(NameBinding(ns, _), [], All(), []) -> CANDIDATE(<nabl-to-str> ns)
+  
+  ref-to-str: 
+    Reference(NameBinding(ns, _), [], RefScope(NameBinding(ns', t), _, _), []) -> CANDIDATE(<nabl-to-str> ns, <nabl-to-str> ns', <to-ppable-str> t)
+  
+  //ref-to-str
+  
+  nabl-to-str: Current() -> TERM("Current")
+  nabl-to-str: 
+    DefScopes(ds) -> LIST([sc1*, sc2*])
+    where
+      if <fetch-elem(?DefScope(_))> ds then
+        sc1* := [SCOPE()]
+      else
+        sc1* := []
+      end;
+      if <fetch-elem(?Subsequent())> ds then
+        sc2* := [TERM("Subsequent")]
+      else
+        sc2* := []
+      end
+    
+  nabl-to-str: NonUnique() -> TERM("NonUnique")
+  nabl-to-str: Unique()    -> TERM("Unique")
+  
+overlays
+     
+  USE_RULE(pattern, call) =
+  SDefT(
+    "nabl-use-site"
+  , []
+  , [DefaultVarDec("context"), DefaultVarDec("uris"), DefaultVarDec("deps"), DefaultVarDec("states")]
+  , Seq(Match(pattern), call)
+  )
+  
+  USE_CALL(candidates) =
+  CallT(
+    SVar("nabl-use")
+  , []
+  , [ Var("context"), Var("uris"), Var("deps"), LIST(candidates)] 
+  )
+  
+  CANDIDATE(ns) =
+  TERM("UseCandidate", [ns, LIST([]), TERM("Current"), TERM("All")])
+
+  CANDIDATE(ns1, ns2, n) =
+  TERM("UseCandidate", [ns1, LIST([]), TERM("Current"), TERM("Context", [n, ns2, LIST([]), TERM("All")])])

Added: spoofax-imp/branches/nbl-dev/trans/generation/util.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/nbl-dev/trans/generation/util.str	Tue Mar 12 03:11:03 2013	(r26006)
@@ -0,0 +1,37 @@
+module generation/util
+
+imports
+  
+  libstrc
+  include/NameBindingLanguage
+  
+rules 
+  
+  nonempty = where(Hd)
+
+  replace-all(|rs) = alltd(replace(|rs) <+ introduce-id)
+  
+  replace(|rs): t1 -> t2 where <?(t1, t2) <+ fetch-elem(?(t1, t2))> rs
+  
+  introduce-id: Wld()      -> Id()
+  introduce-id: Var(_)     -> Id()
+  introduce-id: ListVar(_) -> Id()
+    
+  to-ppable-str = alltd(to-ppable-str-local)
+    
+  to-ppable-str-local: ListVar(x)    -> Var(x)
+  to-ppable-str-local: VarRef(x)     -> Var(x)
+  to-ppable-str-local: ListVarRef(x) -> Var(x)
+
+overlays
+  
+  CONS_DECL(c, t) = OpDecl(c, ConstType(SortNoArgs(t)))
+  TERM(o, args)   = NoAnnoList(Op(o, args))
+  TERM(o)         = TERM(o, [])
+  TUPLE(elems)    = NoAnnoList(Tuple(elems))
+  LIST(elems)     = NoAnnoList(List(elems))
+  CALL(s)         = CallNoArgs(SVar(s))
+
+  SCOPE() = Var("scope")
+  
+  
\ No newline at end of file

Modified: spoofax-imp/branches/nbl-dev/trans/namebindinglanguage.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/namebindinglanguage.str	Mon Mar 11 17:25:24 2013	(r26005)
+++ spoofax-imp/branches/nbl-dev/trans/namebindinglanguage.str	Tue Mar 12 03:11:03 2013	(r26006)
@@ -9,7 +9,7 @@
   lib/compilation-library.generated
 	constraints
 	names
-  new-generate
+  generation/-
 
 rules // Analysis
   

Modified: spoofax-imp/branches/nbl-dev/trans/names.nd
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/names.nd	Mon Mar 11 17:25:24 2013	(r26005)
+++ spoofax-imp/branches/nbl-dev/trans/names.nd	Tue Mar 12 03:11:03 2013	(r26006)
@@ -35,7 +35,7 @@
 
 rules
 
-	BindingRule(_, _):
+	BindingRule(_, _, _):
 		scopes Variable
 		
 	Var(x):

Modified: spoofax-imp/branches/nbl-dev/trans/names.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/names.str	Mon Mar 11 17:25:24 2013	(r26005)
+++ spoofax-imp/branches/nbl-dev/trans/names.str	Tue Mar 12 03:11:03 2013	(r26006)
@@ -138,7 +138,7 @@
 rules
 
   nam-get-scope-types :
-    BindingRule(_, _) -> [Variable()]
+    BindingRule(_, _, _) -> [Variable()]
 
 
 rules

From g.h.wachsmuth at tudelft.nl  Tue Mar 12 18:18:36 2013
From: g.h.wachsmuth at tudelft.nl (Guido Wachsmuth)
Date: Tue, 12 Mar 2013 17:18:36 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26007 -
	spoofax-imp/branches/nbl-dev/trans/generation
Message-ID: <20130312171836.8DED57F802D@mx1.tudelft.nl>

Author: GuidoWachsmuth
Date: Tue Mar 12 17:18:36 2013
New Revision: 26007
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26007&sc=1

Log:
simplified generation of constraint tasks to ease handling of use site constraints

Modified:
   spoofax-imp/branches/nbl-dev/trans/generation/constraints.str
   spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str
   spoofax-imp/branches/nbl-dev/trans/generation/rules.str
   spoofax-imp/branches/nbl-dev/trans/generation/sections.str
   spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str
   spoofax-imp/branches/nbl-dev/trans/generation/util.str

Modified: spoofax-imp/branches/nbl-dev/trans/generation/constraints.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/constraints.str	Tue Mar 12 03:11:03 2013	(r26006)
+++ spoofax-imp/branches/nbl-dev/trans/generation/constraints.str	Tue Mar 12 17:18:36 2013	(r26007)
@@ -9,54 +9,40 @@
   
 rules
   
-  constraints-to-str: 
-    ([], (bnd*, rep*, n, str)) -> (bnd*, rep*, n, str, [])
+  constraints-to-str(|replace*, bound*, rule*, n) = 
+    map-with-index(constraint-to-str(|replace*, bound*, rule*, n));
+    concat
   
-  constraints-to-str: 
-    ([c | cs ], (bnd*, rep*, n, prev)) -> (bnd3*, rep3*, n3, Seq(prev, cont), [r1*, r2*])
-    where
-      (bnd2*, rep2*, n2, curr, r1*) := <constraint-to-str(|bnd*, rep*, n)> c;
-      (bnd3*, rep3*, n3, cont, r2*) := <constraints-to-str> (cs, (bnd2*, rep2*, n2, curr))    
-
-  constraint-to-str(|bnd*, rep*, n):  
-    Constraint(t1, PropertyCond(p, t2)) -> result
+  constraint-to-str(|replace*, bound*, rule*, i):  
+    (j, Constraint(t1, PropertyCond(p, t2))) -> [PROP_TASK(r, <nabl-to-str> p, <alltd(replace(|replace*))> t1), match*]
     where
       // create new task for property calculation
-      r  := Var($[r[n]]);
-      p' := <nabl-to-str> p;
-      t3 := <alltd(replace(|rep*))> t1;
-      pt := PROP_TASK(r, p', t3);
+      n := <addi> (i, j);
+      r := Var($[pr[n]]);
       if 
         Var(v) := t2;
-        <not(elem)> (v, bnd*) 
+        <not(iset-contains(|t2))> bound* 
      then // single unbound variable is replaced with result
-        result := ( [v, bnd*]
-                  , [(Var(v), r), (VarRef(v), r), rep*]
-                  , <inc> n
-                  , pt
-                  , []
-                  )
+        <hashtable-put(|Var(v), r)> replace*;
+        <hashtable-put(|VarRef(v), r)> replace*;
+        <iset-add(|Var(v))> bound*;
+        match* := []
       else
-      	var*   := <collect-all(?Var(<id>))> t2;
-      	bvar*  := <isect; map(!Var(<id>))> (var*, bnd*);
-      	result := <matches-to-str(|t2, r, bvar*)> (var*, bnd*, rep*, <inc> n, pt)
+      	var*   := <collect-all(?Var(_))> t2;
+      	bvar*  := <isect> (var*, <iset-elements> bound*);
+      	match* := <map-with-index(match-to-str(|replace*, bound*, rule*, t2, r, bvar*, n))> var*
       end
   
-  matches-to-str(|term, res, bvar*):
-  	([], bnd*, rep*, n, pt) -> (bnd*, rep*, n, pt, [])
- 
-  matches-to-str(|term, res, bvar*):
-  	([v|vs], bnd*, rep*, n, prev) -> (bnd3*, rep3*, n3, Seq(prev, cont), [mr, r*])
+   match-to-str(|replace*, bound*, rule*, term, res, bvar*, i):
+  	(j, Var(v)) -> MATCH_TASK(r, mn, bvar'*, res)
     where
-    	mn    := NoAnnoList(Str(<newname; double-quote> "match"));
-    	r     := Var($[r[n]]);
-    	bvar2*:= <alltd(replace(|rep*))> bvar*;
-    	mt    := MATCH_TASK(r, mn, bvar2*, res);
-    	mr    := MATCH_RULE(mn, term, bvar*, Var(v));
-    	bnd2* := [v, bnd*];
-    	rep2* := [(Var(v), r), (VarRef(v), r), rep*];
-    	n2    := <inc> n;
-    	(bnd3*, rep3*, n3, cont, r*) := <matches-to-str(|term, res, bvar*)> (vs, bnd2*, rep2*, n2, mt)
+    	mn     := NoAnnoList(Str(<newname; double-quote> "match"));
+    	r      := Var($[mr[i]_[j]]);
+    	bvar'* := <alltd(replace(|replace*))> bvar*;
+    	<hashtable-put(|Var(v), r)> replace*;
+      <hashtable-put(|VarRef(v), r)> replace*;
+    	<iset-add(|Var(v))> bound*;
+    	<iset-add(|MATCH_RULE(mn, term, bvar*, Var(v)))> rule*
       
 overlays
     

Modified: spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str	Tue Mar 12 03:11:03 2013	(r26006)
+++ spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str	Tue Mar 12 17:18:36 2013	(r26007)
@@ -11,34 +11,34 @@
   
 rules // definitions, scopes, properties
     
-  def-to-str(|bnd*, rep*, n, cont, pattern, scopes):
-    DefSite(u, NameBinding(ns, t), ps, ds, constr*) -> [dr, pr*]
+  def-to-str(|replace*, bound*, rule*, task*, pattern, scopes):
+    DefSite(u, NameBinding(ns, t), ps, ds, constr*) -> <id>
     where  
       // replace name with callback to handle definition site
-      t'      := <to-ppable-str> t ;
-      replace := ( t', DEF_CALL(<nabl-to-str> ns, <nabl-to-str> u, <nabl-to-str> ds, scopes))
+      r := ( t, DEF_CALL(<nabl-to-str> ns, <nabl-to-str> u, <nabl-to-str> ds, scopes) )
     where 
       // when we have external scopes in a "defines ... in ..." clause, 
       // replace these external scopes with callbacks
-      replace* := <?DefScopes(<filter(def-scope-to-str)>); nonempty> ds;
+      r* := <?DefScopes(<filter(def-scope-to-str)>); nonempty> ds;
       // callback to determine external scope 
-      sc       := SCOPE_CALL(<nabl-to-str> ns);
+      sc := SCOPE_CALL(<nabl-to-str> ns);
       // apply all replacements and generate a rule handling this definition site
-      dr       := DEF_RULE(Match(pattern), Seq(sc, <replace-all(|[replace, replace*])> pattern)) <+
+      <iset-add(|DEF_RULE(Match(pattern), Seq(sc, <replace-all(|[r, r*])> pattern)))> rule* <+
       // otherwise replace only the name and
       // generate a rule handling this defintion site
-      dr       := DEF_RULE(Match(pattern), <replace-all(|[replace])> pattern)
+      <iset-add(|DEF_RULE(Match(pattern), <replace-all(|[r])> pattern))> rule*
     where
       // when this definition site defines properties,
       // construct sequence of property calculatations
-      (_, rep2*, _, ccall2, rule*) := <constraints-to-str> (constr*, (bnd*, rep*, n, cont));
       // and a callback
-      pcall  := <alltd(replace(|rep2*))> PROP_CALL(<nonempty; map(prop-to-str)> ps);
+      task'* := <constraints-to-str(|replace*, bound*, rule*, <length> task*)> constr*;
+      pcall  := <alltd(replace(|replace*))> PROP_CALL(<nonempty; map(prop-to-str)> ps);
+      pcall' := <replace-all(|[(t, pcall)])> pattern;
       // generate a rule handling properties at this definition site
-      pbody := <replace-all(|[(t', pcall)])> pattern ;
-      pr*   := [PROP_RULE(ccall2, pbody), rule*] <+
+      pbody  := <foldr(!pcall', to-seq)> [task*, task'*] ;
+      <iset-add(|PROP_RULE(Seq(Match(pattern), pbody)))> rule* <+
       // otherwise generate no rule
-      pr*   := []
+      id
 
   def-scope-to-str:
     DefScope(x) -> (<to-ppable-str> x, SCOPE_CALL())      
@@ -46,6 +46,23 @@
   prop-to-str:
     PropertyBinding(p, t) -> PROPERTY(<nabl-to-str> p, <to-ppable-str> t)     
 
+  nabl-to-str: Current() -> TERM("Current")
+  nabl-to-str: 
+    DefScopes(ds) -> LIST([sc1*, sc2*])
+    where
+      if <fetch-elem(?DefScope(_))> ds then
+        sc1* := [SCOPE()]
+      else
+        sc1* := []
+      end;
+      if <fetch-elem(?Subsequent())> ds then
+        sc2* := [TERM("Subsequent")]
+      else
+        sc2* := []
+      end
+    
+  nabl-to-str: NonUnique() -> TERM("NonUnique")
+  nabl-to-str: Unique()    -> TERM("Unique")
 overlays
   
   DEF_RULE(match, call) =
@@ -66,12 +83,12 @@
   SCOPE_CALL()   = CallT(SVar("nabl-def-scope"), [], [SCOPE()])
   SCOPE_CALL(ns) = Where(Assign(SCOPE(), App(CallT(SVar("nabl-def-scope"), [], [Var("context")]), ns)))
     
-  PROP_RULE(match, call) =
+  PROP_RULE(body) =
   SDefT(
     "nabl-prop-site"
   , []
   , [DefaultVarDec("context"), DefaultVarDec("states")]
-  , Seq(match, call)
+  , body
   )
   
   PROP_CALL(ps) = 

Modified: spoofax-imp/branches/nbl-dev/trans/generation/rules.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/rules.str	Tue Mar 12 03:11:03 2013	(r26006)
+++ spoofax-imp/branches/nbl-dev/trans/generation/rules.str	Tue Mar 12 17:18:36 2013	(r26007)
@@ -13,18 +13,22 @@
 rules
   
   // TODO: support multiple definition sites
-  nabl-to-str: 
-    BindingRule(pattern, constr*, parts) -> [defscope*, use*, rule*]
+  nabl-to-str(|replace*, bound*, rule*): 
+    BindingRule(pattern, constr*, parts) -> <id>
     where
-      bound* := <collect-all(?Var(<id>))> pattern;
-      (bnd*, rep*, n, cont, rule*)  := <constraints-to-str> (constr*, (bound*, [], 1, Match(pattern)));
-      scope* := <filter(?Scopes(<id>)); concat; map(nabl-to-str)> parts
+      <hashtable-clear> replace*;
+      <iset-clear> bound*;
+      <iset-clear> rule*
     where
-      defscope* := <fetch-elem(def-to-str(|bnd*, rep*, n, cont, pattern, scope*))> parts <+
-      defscope* := [SCOPE_RULE(pattern, <nonempty> scope*)] <+
-      defscope* := []
+      <iset-addlist(|<collect-all(?Var(_))> pattern)> bound*;
+      task* := <constraints-to-str(|replace*, bound*, rule*, 0)> constr*;
+      scope* := <filter(?Scopes(<id>)); concat; map(nabl-to-str)> parts
     where
-      use* := <filter(use-to-str(|pattern))> parts
+      <fetch-elem(def-to-str(|replace*, bound*, rule*, task*, pattern, scope*))> parts <+
+      <iset-add(|SCOPE_RULE(pattern, <nonempty> scope*))> rule* <+
+      id
+    // where
+    //   use* := <uses-to-str(|bnd*, rep*, n, cont, pattern)> parts
       
 overlays
 	

Modified: spoofax-imp/branches/nbl-dev/trans/generation/sections.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/sections.str	Tue Mar 12 03:11:03 2013	(r26006)
+++ spoofax-imp/branches/nbl-dev/trans/generation/sections.str	Tue Mar 12 17:18:36 2013	(r26007)
@@ -36,6 +36,17 @@
 rules // binding rules
 
   nabl-to-str:
-    BindingRules(rs) -> Rules(<filter(nabl-to-str); concat; nonempty> rs)
+    BindingRules(rs) -> Rules(<nonempty> rs')
+    where
+      new-hashtable => replace*;
+      new-iset      => bound*;
+      new-iset      => rule*;
+      
+      <filter(nabl-to-str(|replace*, bound*, rule*))> rs;
+      rs' := <iset-elements> rule*;
+      
+      <hashtable-destroy> replace*;
+      <iset-destroy> bound*;
+      <iset-destroy> rule*
       
   
\ No newline at end of file

Modified: spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str	Tue Mar 12 03:11:03 2013	(r26006)
+++ spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str	Tue Mar 12 17:18:36 2013	(r26007)
@@ -10,58 +10,55 @@
   generation/constraints
 
 rules
-    
-  use-to-str(|pattern):
-    UseSite(refs) -> <refs-to-str(|pattern)> refs
-  
-  use-to-str(|pattern):
-    ImportSite(imports) -> <refs-to-str(|pattern)> imports
-      
-  // TODO: support properties
-  // TODO: support conditions
-  refs-to-str(|pattern):  
-    refs -> USE_RULE(pattern, <replace-all(|[replace])> pattern)
-    where
-      Hd => Reference(NameBinding(_, _, t), _, _, _) <+
-      Hd => SingleImport(NameBinding(_, _, t), _, _, _, _) <+
-      Hd => WildcardImport(_, _, RefScope(NameBinding(_, _, t)), _, _)
-    where
-      replace := (<to-ppable-str> t, USE_CALL(<filter(ref-to-str); nonempty> refs))
-      
-  ref-to-str: 
-    Reference(NameBinding(ns, _), [], All(), []) -> CANDIDATE(<nabl-to-str> ns)
-  
-  ref-to-str: 
-    Reference(NameBinding(ns, _), [], RefScope(NameBinding(ns', t), _, _), []) -> CANDIDATE(<nabl-to-str> ns, <nabl-to-str> ns', <to-ppable-str> t)
   
-  //ref-to-str
+  uses-to-str(|bnd*, rep*, n, cont, pattern) =
+    filter(?UseSite(_) + ?ImportSite);
+    if nonempty then
+       (_, _, _, call, r*) := <uses-to-str> (<id>, bnd*, rep*, n, Match(pattern));
+      ![USE_RULE(call), r*]
+    else
+      ![]
+    end
+    
+  uses-to-str:
+    ([], bnd*, rep*, n, str) -> (bnd*, rep*, n, str, [])
   
-  nabl-to-str: Current() -> TERM("Current")
-  nabl-to-str: 
-    DefScopes(ds) -> LIST([sc1*, sc2*])
-    where
-      if <fetch-elem(?DefScope(_))> ds then
-        sc1* := [SCOPE()]
-      else
-        sc1* := []
-      end;
-      if <fetch-elem(?Subsequent())> ds then
-        sc2* := [TERM("Subsequent")]
-      else
-        sc2* := []
-      end
+  // uses-to-str: 
+  //   ([u | us ], bnd*, rep*, n, prev) -> (bnd3*, rep3*, n3, cont, [r1*, r2*])
+  //   where
+  //     (bnd2*, rep2*, n2, curr, r1*) := <use-to-str(|bnd*, rep*, n, prev)> u;
+  //     (bnd3*, rep3*, n3, cont, r2*) := <uses-to-str> (us, bnd2*, rep2*, n2, curr)    
+
+rules
     
-  nabl-to-str: NonUnique() -> TERM("NonUnique")
-  nabl-to-str: Unique()    -> TERM("Unique")
+  // use-to-str(|bnd*, rep*, n, prev) =   
+  //   (
+  //     ?UseSite(<id>) 
+  //   + ?ImportSite(<id>)
+  //   ) ;
+  //   where (
+  //     ?[Reference(NameBinding(_, _, t), _, _, _)|_] <+
+  //     ?[SingleImport(NameBinding(_, _, t), _, _, _, _)|_] <+
+  //     ?[WildcardImport(_, _, RefScope(NameBinding(_, _, t)), _, _)|_]
+  //   );
+  //   !(<to-ppable-str> t, USE_CALL(<refs-to-str>))
+  //     
+  // ref-to-str(|bnd*, rep*, n, prev): 
+  //   Reference(NameBinding(_, ns, _), [], All(), constr*) -> CANDIDATE(<nabl-to-str> ns)
+  //   where
+  //     <constraints-to-str> (constr*, (bnd*, rep*, n, prev))
+  //     
+  // ref-to-str: 
+  //   Reference(NameBinding(_, ns, _), [], RefScope(NameBinding(_, ns', t), _, _), []) -> CANDIDATE(<nabl-to-str> ns, <nabl-to-str> ns', <to-ppable-str> t)
   
 overlays
      
-  USE_RULE(pattern, call) =
+  USE_RULE(call) =
   SDefT(
     "nabl-use-site"
   , []
   , [DefaultVarDec("context"), DefaultVarDec("uris"), DefaultVarDec("deps"), DefaultVarDec("states")]
-  , Seq(Match(pattern), call)
+  , call
   )
   
   USE_CALL(candidates) =

Modified: spoofax-imp/branches/nbl-dev/trans/generation/util.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/util.str	Tue Mar 12 03:11:03 2013	(r26006)
+++ spoofax-imp/branches/nbl-dev/trans/generation/util.str	Tue Mar 12 17:18:36 2013	(r26007)
@@ -5,13 +5,18 @@
   libstrc
   include/NameBindingLanguage
   
+rules
+  
+  to-seq: (c1, c2) -> Seq(c1, c2)
+  
 rules 
   
   nonempty = where(Hd)
 
   replace-all(|rs) = alltd(replace(|rs) <+ introduce-id)
   
-  replace(|rs): t1 -> t2 where <?(t1, t2) <+ fetch-elem(?(t1, t2))> rs
+  replace(|rs): t  -> <hashtable-get(|t)> rs
+  replace(|rs): t1 -> t2 where <fetch-elem(?(t1, t2))> rs
   
   introduce-id: Wld()      -> Id()
   introduce-id: Var(_)     -> Id()

From g.h.wachsmuth at tudelft.nl  Tue Mar 12 18:56:18 2013
From: g.h.wachsmuth at tudelft.nl (Guido Wachsmuth)
Date: Tue, 12 Mar 2013 17:56:18 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26008 -
	spoofax-imp/branches/nbl-dev/trans/generation
Message-ID: <20130312175618.666667F8025@mx1.tudelft.nl>

Author: GuidoWachsmuth
Date: Tue Mar 12 17:56:16 2013
New Revision: 26008
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26008&sc=1

Log:
bug-fixes in replacements

Modified:
   spoofax-imp/branches/nbl-dev/trans/generation/constraints.str
   spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str
   spoofax-imp/branches/nbl-dev/trans/generation/rules.str
   spoofax-imp/branches/nbl-dev/trans/generation/util.str

Modified: spoofax-imp/branches/nbl-dev/trans/generation/constraints.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/constraints.str	Tue Mar 12 17:18:36 2013	(r26007)
+++ spoofax-imp/branches/nbl-dev/trans/generation/constraints.str	Tue Mar 12 17:56:16 2013	(r26008)
@@ -10,8 +10,8 @@
 rules
   
   constraints-to-str(|replace*, bound*, rule*, n) = 
-    map-with-index(constraint-to-str(|replace*, bound*, rule*, n));
-    concat
+    map-with-index(to-ppable-str; constraint-to-str(|replace*, bound*, rule*, n));
+    concat <+ []
   
   constraint-to-str(|replace*, bound*, rule*, i):  
     (j, Constraint(t1, PropertyCond(p, t2))) -> [PROP_TASK(r, <nabl-to-str> p, <alltd(replace(|replace*))> t1), match*]
@@ -24,7 +24,6 @@
         <not(iset-contains(|t2))> bound* 
      then // single unbound variable is replaced with result
         <hashtable-put(|Var(v), r)> replace*;
-        <hashtable-put(|VarRef(v), r)> replace*;
         <iset-add(|Var(v))> bound*;
         match* := []
       else
@@ -40,7 +39,6 @@
     	r      := Var($[mr[i]_[j]]);
     	bvar'* := <alltd(replace(|replace*))> bvar*;
     	<hashtable-put(|Var(v), r)> replace*;
-      <hashtable-put(|VarRef(v), r)> replace*;
     	<iset-add(|Var(v))> bound*;
     	<iset-add(|MATCH_RULE(mn, term, bvar*, Var(v)))> rule*
       

Modified: spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str	Tue Mar 12 17:18:36 2013	(r26007)
+++ spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str	Tue Mar 12 17:56:16 2013	(r26008)
@@ -15,7 +15,8 @@
     DefSite(u, NameBinding(ns, t), ps, ds, constr*) -> <id>
     where  
       // replace name with callback to handle definition site
-      r := ( t, DEF_CALL(<nabl-to-str> ns, <nabl-to-str> u, <nabl-to-str> ds, scopes) )
+      t' := <to-ppable-str> t;
+      r  := ( t', DEF_CALL(<nabl-to-str> ns, <nabl-to-str> u, <nabl-to-str> ds, scopes) )
     where 
       // when we have external scopes in a "defines ... in ..." clause, 
       // replace these external scopes with callbacks
@@ -27,18 +28,17 @@
       // otherwise replace only the name and
       // generate a rule handling this defintion site
       <iset-add(|DEF_RULE(Match(pattern), <replace-all(|[r])> pattern))> rule*
-    where
+    where try(
       // when this definition site defines properties,
       // construct sequence of property calculatations
       // and a callback
       task'* := <constraints-to-str(|replace*, bound*, rule*, <length> task*)> constr*;
       pcall  := <alltd(replace(|replace*))> PROP_CALL(<nonempty; map(prop-to-str)> ps);
-      pcall' := <replace-all(|[(t, pcall)])> pattern;
+      pcall' := <replace-all(|[(t', pcall)])> pattern;
       // generate a rule handling properties at this definition site
       pbody  := <foldr(!pcall', to-seq)> [task*, task'*] ;
-      <iset-add(|PROP_RULE(Seq(Match(pattern), pbody)))> rule* <+
-      // otherwise generate no rule
-      id
+      <iset-add(|PROP_RULE(Seq(Match(pattern), pbody)))> rule* 
+    )
 
   def-scope-to-str:
     DefScope(x) -> (<to-ppable-str> x, SCOPE_CALL())      

Modified: spoofax-imp/branches/nbl-dev/trans/generation/rules.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/rules.str	Tue Mar 12 17:18:36 2013	(r26007)
+++ spoofax-imp/branches/nbl-dev/trans/generation/rules.str	Tue Mar 12 17:56:16 2013	(r26008)
@@ -20,12 +20,13 @@
       <iset-clear> bound*;
       <iset-clear> rule*
     where
-      <iset-addlist(|<collect-all(?Var(_))> pattern)> bound*;
-      task* := <constraints-to-str(|replace*, bound*, rule*, 0)> constr*;
+      pattern':= <to-ppable-str> pattern;
+      <iset-addlist(|<collect-all(?Var(_))> pattern')> bound*;
+      task*  := <constraints-to-str(|replace*, bound*, rule*, 0)> constr*;
       scope* := <filter(?Scopes(<id>)); concat; map(nabl-to-str)> parts
     where
-      <fetch-elem(def-to-str(|replace*, bound*, rule*, task*, pattern, scope*))> parts <+
-      <iset-add(|SCOPE_RULE(pattern, <nonempty> scope*))> rule* <+
+      <fetch-elem(def-to-str(|replace*, bound*, rule*, task*, pattern', scope*))> parts <+
+      <iset-add(|SCOPE_RULE(pattern', <nonempty> scope*))> rule* <+
       id
     // where
     //   use* := <uses-to-str(|bnd*, rep*, n, cont, pattern)> parts

Modified: spoofax-imp/branches/nbl-dev/trans/generation/util.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/util.str	Tue Mar 12 17:18:36 2013	(r26007)
+++ spoofax-imp/branches/nbl-dev/trans/generation/util.str	Tue Mar 12 17:56:16 2013	(r26008)
@@ -15,8 +15,8 @@
 
   replace-all(|rs) = alltd(replace(|rs) <+ introduce-id)
   
-  replace(|rs): t  -> <hashtable-get(|t)> rs
-  replace(|rs): t1 -> t2 where <fetch-elem(?(t1, t2))> rs
+  replace(|rs): t -> <hashtable-get(|t)> rs
+  replace(|rs): t -> <lookup'> (t, rs)
   
   introduce-id: Wld()      -> Id()
   introduce-id: Var(_)     -> Id()

From g.h.wachsmuth at tudelft.nl  Tue Mar 12 20:37:10 2013
From: g.h.wachsmuth at tudelft.nl (Guido Wachsmuth)
Date: Tue, 12 Mar 2013 19:37:10 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26009 -
	spoofax-imp/branches/nbl-dev/trans/generation
Message-ID: <20130312193710.8FB0C7F8035@mx1.tudelft.nl>

Author: GuidoWachsmuth
Date: Tue Mar 12 19:37:08 2013
New Revision: 26009
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26009&sc=1

Log:
another bugfix: generate all rules, not just the last
share hashtable and iset between rules

Modified:
   spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str
   spoofax-imp/branches/nbl-dev/trans/generation/main.str
   spoofax-imp/branches/nbl-dev/trans/generation/rules.str
   spoofax-imp/branches/nbl-dev/trans/generation/sections.str

Modified: spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str	Tue Mar 12 17:56:16 2013	(r26008)
+++ spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str	Tue Mar 12 19:37:08 2013	(r26009)
@@ -39,7 +39,7 @@
       pbody  := <foldr(!pcall', to-seq)> [task*, task'*] ;
       <iset-add(|PROP_RULE(Seq(Match(pattern), pbody)))> rule* 
     )
-
+    
   def-scope-to-str:
     DefScope(x) -> (<to-ppable-str> x, SCOPE_CALL())      
 

Modified: spoofax-imp/branches/nbl-dev/trans/generation/main.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/main.str	Tue Mar 12 17:56:16 2013	(r26008)
+++ spoofax-imp/branches/nbl-dev/trans/generation/main.str	Tue Mar 12 19:37:08 2013	(r26009)
@@ -21,5 +21,14 @@
 rules // modules
   
   nabl-to-str:
-    Module(name, _, sections) -> Module(name, <filter(nabl-to-str)> sections)
-    
+    Module(name, _, sections) -> Module(name, sections')
+    where
+      new-hashtable => replace*;
+      new-iset      => bound*;
+      new-iset      => rule*;
+      
+      sections' := <filter(nabl-to-str(|replace*, bound*, rule*))> sections;
+      
+      <hashtable-destroy> replace*;
+      <iset-destroy> bound*;
+      <iset-destroy> rule*    

Modified: spoofax-imp/branches/nbl-dev/trans/generation/rules.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/rules.str	Tue Mar 12 17:56:16 2013	(r26008)
+++ spoofax-imp/branches/nbl-dev/trans/generation/rules.str	Tue Mar 12 19:37:08 2013	(r26009)
@@ -17,8 +17,7 @@
     BindingRule(pattern, constr*, parts) -> <id>
     where
       <hashtable-clear> replace*;
-      <iset-clear> bound*;
-      <iset-clear> rule*
+      <iset-clear> bound*
     where
       pattern':= <to-ppable-str> pattern;
       <iset-addlist(|<collect-all(?Var(_))> pattern')> bound*;

Modified: spoofax-imp/branches/nbl-dev/trans/generation/sections.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/sections.str	Tue Mar 12 17:56:16 2013	(r26008)
+++ spoofax-imp/branches/nbl-dev/trans/generation/sections.str	Tue Mar 12 19:37:08 2013	(r26009)
@@ -10,7 +10,7 @@
     
 rules // namespaces 
       
-  nabl-to-str:
+  nabl-to-str(|replace*, bound*, rule*):
     Namespaces(namespaces) -> Signature([Constructors(<map(nabl-to-str)> namespaces)])
     
   nabl-to-str: // generates constructors for namespaces
@@ -20,7 +20,7 @@
 
 rules // properties
         
-  nabl-to-str:
+  nabl-to-str(|replace*, bound*, rule*):
     Properties(props) -> Signature([Constructors(<map(nabl-to-str)> props)])
   
   nabl-to-str: // generate constructors for properties
@@ -31,22 +31,14 @@
 
 rules // imports
     
-  nabl-to-str = Imports(![ImportWildcard("lib/nbl"), ImportWildcard("lib/task")|<id>])
+  nabl-to-str(|replace*, bound*, rule*) = Imports(![ImportWildcard("lib/nbl"), ImportWildcard("lib/task")|<id>])
     
 rules // binding rules
 
-  nabl-to-str:
+  nabl-to-str(|replace*, bound*, rule*):
     BindingRules(rs) -> Rules(<nonempty> rs')
     where
-      new-hashtable => replace*;
-      new-iset      => bound*;
-      new-iset      => rule*;
-      
+      <iset-clear> rule*;
       <filter(nabl-to-str(|replace*, bound*, rule*))> rs;
-      rs' := <iset-elements> rule*;
-      
-      <hashtable-destroy> replace*;
-      <iset-destroy> bound*;
-      <iset-destroy> rule*
-      
-  
\ No newline at end of file
+      rs' := <iset-elements> rule*
+     
\ No newline at end of file

From g.h.wachsmuth at tudelft.nl  Wed Mar 13 01:11:03 2013
From: g.h.wachsmuth at tudelft.nl (Guido Wachsmuth)
Date: Wed, 13 Mar 2013 00:11:03 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26010 - in
	spoofax-imp/branches/nbl-dev: test trans/generation
Message-ID: <20130313001103.2398E7F8025@mx1.tudelft.nl>

Author: GuidoWachsmuth
Date: Wed Mar 13 00:11:01 2013
New Revision: 26010
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26010&sc=1

Log:
support for simple use sites w/ properties and constraints

Modified:
   spoofax-imp/branches/nbl-dev/test/example.nab
   spoofax-imp/branches/nbl-dev/trans/generation/constraints.str
   spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str
   spoofax-imp/branches/nbl-dev/trans/generation/rules.str
   spoofax-imp/branches/nbl-dev/trans/generation/sections.str
   spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str
   spoofax-imp/branches/nbl-dev/trans/generation/util.str

Modified: spoofax-imp/branches/nbl-dev/test/example.nab
==============================================================================
--- spoofax-imp/branches/nbl-dev/test/example.nab	Tue Mar 12 19:37:08 2013	(r26009)
+++ spoofax-imp/branches/nbl-dev/test/example.nab	Wed Mar 13 00:11:01 2013	(r26010)
@@ -14,9 +14,23 @@
  
 binding rules
 
-	Foo(x, y)
+  Bar(x)
+    where x has type (t, t):
+    defines Entity x of type z
+      where t has type (t, z)
+      
+  Bar(x):
+    refers to Entity x
+  
+  FooBar(x, y):
+    refers to Entity x of type y
+    
+	Foo(x, y, z)
 	  where x has type (t, _, t)
 	  where y has type t:
-	  defines Entity x of type t
-	  refers to Entity y
-	  
\ No newline at end of file
+	  refers to Entity x of type t
+      where z has type y
+	  otherwise refers to Entity y of type y
+	  refers to Entity y 
+    refers to Entity z
+     
\ No newline at end of file

Modified: spoofax-imp/branches/nbl-dev/trans/generation/constraints.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/constraints.str	Tue Mar 12 19:37:08 2013	(r26009)
+++ spoofax-imp/branches/nbl-dev/trans/generation/constraints.str	Wed Mar 13 00:11:01 2013	(r26010)
@@ -9,16 +9,17 @@
   
 rules
   
-  constraints-to-str(|replace*, bound*, rule*, n) = 
-    map-with-index(to-ppable-str; constraint-to-str(|replace*, bound*, rule*, n));
-    concat <+ []
-  
-  constraint-to-str(|replace*, bound*, rule*, i):  
-    (j, Constraint(t1, PropertyCond(p, t2))) -> [PROP_TASK(r, <nabl-to-str> p, <alltd(replace(|replace*))> t1), match*]
+  constraints-to-str(|replace*, bound*, rule*, task*) = 
+    !(<id>, task*);
+    foldl(to-ppable-str; constraint-to-str(|replace*, bound*, rule*))
+    
+  constraint-to-str(|replace*, bound*, rule*):  
+    (Constraint(t1, PropertyCond(p, t2)), cs*) -> [cs*, PROP_TASK(r, <nabl-to-str> p, t1'), match*]
     where
+      t1' := <alltd(replace(|replace*))> t1;
       // create new task for property calculation
-      n := <addi> (i, j);
-      r := Var($[pr[n]]);
+      n   := <length> cs*;
+      r   := Var($[r[n]]);
       if 
         Var(v) := t2;
         <not(iset-contains(|t2))> bound* 
@@ -29,15 +30,16 @@
       else
       	var*   := <collect-all(?Var(_))> t2;
       	bvar*  := <isect> (var*, <iset-elements> bound*);
-      	match* := <map-with-index(match-to-str(|replace*, bound*, rule*, t2, r, bvar*, n))> var*
+      	bvar'* := <alltd(replace(|replace*))> bvar*;
+      	match* := <map-with-index(match-to-str(|replace*, bound*, rule*, t2, r, bvar*, bvar'*, n))> var*
       end
   
-   match-to-str(|replace*, bound*, rule*, term, res, bvar*, i):
-  	(j, Var(v)) -> MATCH_TASK(r, mn, bvar'*, res)
+   match-to-str(|replace*, bound*, rule*, term, res, bvar*, bvar'*, n):
+  	(i, Var(v)) -> MATCH_TASK(r, mn, bvar'*, res)
     where
     	mn     := NoAnnoList(Str(<newname; double-quote> "match"));
-    	r      := Var($[mr[i]_[j]]);
-    	bvar'* := <alltd(replace(|replace*))> bvar*;
+    	n'     := <addi> (n, i);
+    	r      := Var($[r[n']]);
     	<hashtable-put(|Var(v), r)> replace*;
     	<iset-add(|Var(v))> bound*;
     	<iset-add(|MATCH_RULE(mn, term, bvar*, Var(v)))> rule*

Modified: spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str	Tue Mar 12 19:37:08 2013	(r26009)
+++ spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str	Wed Mar 13 00:11:01 2013	(r26010)
@@ -10,7 +10,6 @@
   generation/constraints
   
 rules // definitions, scopes, properties
-    
   def-to-str(|replace*, bound*, rule*, task*, pattern, scopes):
     DefSite(u, NameBinding(ns, t), ps, ds, constr*) -> <id>
     where  
@@ -32,11 +31,11 @@
       // when this definition site defines properties,
       // construct sequence of property calculatations
       // and a callback
-      task'* := <constraints-to-str(|replace*, bound*, rule*, <length> task*)> constr*;
+      task'* := <constraints-to-str(|replace*, bound*, rule*, task*)> constr*;
       pcall  := <alltd(replace(|replace*))> PROP_CALL(<nonempty; map(prop-to-str)> ps);
       pcall' := <replace-all(|[(t', pcall)])> pattern;
       // generate a rule handling properties at this definition site
-      pbody  := <foldr(!pcall', to-seq)> [task*, task'*] ;
+      pbody  := <foldr(!pcall', to-seq)> task'* ;
       <iset-add(|PROP_RULE(Seq(Match(pattern), pbody)))> rule* 
     )
     

Modified: spoofax-imp/branches/nbl-dev/trans/generation/rules.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/rules.str	Tue Mar 12 19:37:08 2013	(r26009)
+++ spoofax-imp/branches/nbl-dev/trans/generation/rules.str	Wed Mar 13 00:11:01 2013	(r26010)
@@ -14,21 +14,21 @@
   
   // TODO: support multiple definition sites
   nabl-to-str(|replace*, bound*, rule*): 
-    BindingRule(pattern, constr*, parts) -> <id>
+    BindingRule(pattern, constr*, clause*) -> <id>
     where
       <hashtable-clear> replace*;
       <iset-clear> bound*
     where
       pattern':= <to-ppable-str> pattern;
       <iset-addlist(|<collect-all(?Var(_))> pattern')> bound*;
-      task*  := <constraints-to-str(|replace*, bound*, rule*, 0)> constr*;
-      scope* := <filter(?Scopes(<id>)); concat; map(nabl-to-str)> parts
+      task*  := <constraints-to-str(|replace*, bound*, rule*, [])> constr*;
+      scope* := <filter(?Scopes(<id>)); concat; map(nabl-to-str)> clause*
+    where try (   
+       <fetch-elem(def-to-str(|replace*, bound*, rule*, task*, pattern', scope*))> clause* 
+    <+ <iset-add(|SCOPE_RULE(pattern', <nonempty> scope*))> rule*
+    )
     where
-      <fetch-elem(def-to-str(|replace*, bound*, rule*, task*, pattern', scope*))> parts <+
-      <iset-add(|SCOPE_RULE(pattern', <nonempty> scope*))> rule* <+
-      id
-    // where
-    //   use* := <uses-to-str(|bnd*, rep*, n, cont, pattern)> parts
+      <uses-to-str(|replace*, bound*, rule*, task*, pattern')> clause*
       
 overlays
 	

Modified: spoofax-imp/branches/nbl-dev/trans/generation/sections.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/sections.str	Tue Mar 12 19:37:08 2013	(r26009)
+++ spoofax-imp/branches/nbl-dev/trans/generation/sections.str	Wed Mar 13 00:11:01 2013	(r26010)
@@ -36,9 +36,8 @@
 rules // binding rules
 
   nabl-to-str(|replace*, bound*, rule*):
-    BindingRules(rs) -> Rules(<nonempty> rs')
+    BindingRules(rs) -> Rules(<iset-elements; nonempty> rule*)
     where
       <iset-clear> rule*;
-      <filter(nabl-to-str(|replace*, bound*, rule*))> rs;
-      rs' := <iset-elements> rule*
+      <filter(nabl-to-str(|replace*, bound*, rule*))> rs
      
\ No newline at end of file

Modified: spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str	Tue Mar 12 19:37:08 2013	(r26009)
+++ spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str	Wed Mar 13 00:11:01 2013	(r26010)
@@ -8,49 +8,44 @@
   generation/util
   generation/main
   generation/constraints
-
+  generation/def-sites
+  
 rules
   
-  uses-to-str(|bnd*, rep*, n, cont, pattern) =
-    filter(?UseSite(_) + ?ImportSite);
+  uses-to-str(|replace*, bound*, rule*, task*, pattern) =
+    filter(?UseSite(<id>) + ?ImportSite(<id>));
     if nonempty then
-       (_, _, _, call, r*) := <uses-to-str> (<id>, bnd*, rep*, n, Match(pattern));
-      ![USE_RULE(call), r*]
-    else
-      ![]
+      (rep*, task'*) := <foldl(use-to-str(|replace*, bound*, rule*))> (<id>, ([], task*));
+      ubody  := <foldr(<replace-all(|rep*)> pattern, to-seq)> task'* ;
+      <iset-add(|USE_RULE(Seq(Match(pattern), ubody)))> rule*
     end
     
-  uses-to-str:
-    ([], bnd*, rep*, n, str) -> (bnd*, rep*, n, str, [])
-  
-  // uses-to-str: 
-  //   ([u | us ], bnd*, rep*, n, prev) -> (bnd3*, rep3*, n3, cont, [r1*, r2*])
-  //   where
-  //     (bnd2*, rep2*, n2, curr, r1*) := <use-to-str(|bnd*, rep*, n, prev)> u;
-  //     (bnd3*, rep3*, n3, cont, r2*) := <uses-to-str> (us, bnd2*, rep2*, n2, curr)    
-
-rules
+  use-to-str(|replace*, bound*, rule*):
+    (u, (r*, task*)) -> ([(t', USE_CALL(c*)), r*], task'*)
+    where 
+      < ?[Reference(NameBinding(_, _, t), _, _, _)|_] 
+      + ?[SingleImport(NameBinding(_, _, t), _, _, _, _)|_] 
+      + ?[WildcardImport(_, _, RefScope(NameBinding(_, _, t)), _, _)|_]
+      > u;
+      t'           := <to-ppable-str> t;
+      (c*, task'*) := <foldl(to-ppable-str; (ref-to-str(|replace*, bound*, rule*) <+ Snd))> (u, ([], task*))
     
-  // use-to-str(|bnd*, rep*, n, prev) =   
-  //   (
-  //     ?UseSite(<id>) 
-  //   + ?ImportSite(<id>)
-  //   ) ;
-  //   where (
-  //     ?[Reference(NameBinding(_, _, t), _, _, _)|_] <+
-  //     ?[SingleImport(NameBinding(_, _, t), _, _, _, _)|_] <+
-  //     ?[WildcardImport(_, _, RefScope(NameBinding(_, _, t)), _, _)|_]
-  //   );
-  //   !(<to-ppable-str> t, USE_CALL(<refs-to-str>))
-  //     
-  // ref-to-str(|bnd*, rep*, n, prev): 
-  //   Reference(NameBinding(_, ns, _), [], All(), constr*) -> CANDIDATE(<nabl-to-str> ns)
-  //   where
-  //     <constraints-to-str> (constr*, (bnd*, rep*, n, prev))
-  //     
-  // ref-to-str: 
+  ref-to-str(|replace*, bound*, rule*): 
+    (Reference(NameBinding(_, ns, _), prop*, All(), constr*), (c*, task*)) -> ([c*, CANDIDATE(<nabl-to-str> ns, prop'*)], task'*)
+    where
+      replace2* := <hashtable-copy> replace*;
+      bound2*   := <iset-copy> bound*;
+      task'*    := <constraints-to-str(|replace2*, bound2*, rule*, task*)> constr*;
+      prop'*    := <map(prop-to-str); alltd(replace(|replace2*))> prop*;
+      <hashtable-destroy> replace2*;
+      <iset-destroy> bound2*
+      
+  // ref-to-str(|replace*, bound*, rule*, n): 
   //   Reference(NameBinding(_, ns, _), [], RefScope(NameBinding(_, ns', t), _, _), []) -> CANDIDATE(<nabl-to-str> ns, <nabl-to-str> ns', <to-ppable-str> t)
   
+  prop-to-str:
+    PropertyBinding(_, p, t) -> PROPERTY(<nabl-to-str> p, <to-ppable-str> t)     
+
 overlays
      
   USE_RULE(call) =
@@ -68,8 +63,8 @@
   , [ Var("context"), Var("uris"), Var("deps"), LIST(candidates)] 
   )
   
-  CANDIDATE(ns) =
-  TERM("UseCandidate", [ns, LIST([]), TERM("Current"), TERM("All")])
+  CANDIDATE(ns, ps) =
+  TERM("UseCandidate", [ns, LIST(ps), TERM("Current"), TERM("All")])
 
   CANDIDATE(ns1, ns2, n) =
   TERM("UseCandidate", [ns1, LIST([]), TERM("Current"), TERM("Context", [n, ns2, LIST([]), TERM("All")])])

Modified: spoofax-imp/branches/nbl-dev/trans/generation/util.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/util.str	Tue Mar 12 19:37:08 2013	(r26009)
+++ spoofax-imp/branches/nbl-dev/trans/generation/util.str	Wed Mar 13 00:11:01 2013	(r26010)
@@ -28,6 +28,8 @@
   to-ppable-str-local: VarRef(x)     -> Var(x)
   to-ppable-str-local: ListVarRef(x) -> Var(x)
 
+  iset-copy = iset-elements => elem*; new-iset ; iset-addlist(|elem*)
+  
 overlays
   
   CONS_DECL(c, t) = OpDecl(c, ConstType(SortNoArgs(t)))

From g.h.wachsmuth at tudelft.nl  Wed Mar 13 03:07:47 2013
From: g.h.wachsmuth at tudelft.nl (Guido Wachsmuth)
Date: Wed, 13 Mar 2013 02:07:47 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26011 -
	spoofax-imp/branches/nbl-dev/trans/generation
Message-ID: <20130313020747.AE9312B802D@mx2.tudelft.nl>

Author: GuidoWachsmuth
Date: Wed Mar 13 02:07:45 2013
New Revision: 26011
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26011&sc=1

Log:
support for imports as use sites; better constructor names for namespaces and properties to avoid name clashes with variables

Modified:
   spoofax-imp/branches/nbl-dev/trans/generation/sections.str
   spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str

Modified: spoofax-imp/branches/nbl-dev/trans/generation/sections.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/sections.str	Wed Mar 13 00:11:01 2013	(r26010)
+++ spoofax-imp/branches/nbl-dev/trans/generation/sections.str	Wed Mar 13 02:07:45 2013	(r26011)
@@ -14,9 +14,9 @@
     Namespaces(namespaces) -> Signature([Constructors(<map(nabl-to-str)> namespaces)])
     
   nabl-to-str: // generates constructors for namespaces
-    Namespace(ns) -> CONS_DECL(ns, "Namespace")
+    Namespace(ns) -> CONS_DECL($[NablNs[ns]], "Namespace")
   
-  nabl-to-str: NamespaceRef(ns) -> TERM(ns)
+  nabl-to-str: NamespaceRef(ns) -> TERM($[NablNs[ns]])
 
 rules // properties
         
@@ -24,9 +24,9 @@
     Properties(props) -> Signature([Constructors(<map(nabl-to-str)> props)])
   
   nabl-to-str: // generate constructors for properties
-    Property(prop, _, _) -> CONS_DECL(prop, "Property") 
+    Property(prop, _, _) -> CONS_DECL($[NablProp_[prop]], "Property") 
 
-  nabl-to-str: PropertyRef(p) -> TERM(p)
+  nabl-to-str: PropertyRef(p) -> TERM($[NablProp_[p]])
   nabl-to-str: TypeProp()     -> TERM("Type")
 
 rules // imports

Modified: spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str	Wed Mar 13 00:11:01 2013	(r26010)
+++ spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str	Wed Mar 13 02:07:45 2013	(r26011)
@@ -25,13 +25,18 @@
     where 
       < ?[Reference(NameBinding(_, _, t), _, _, _)|_] 
       + ?[SingleImport(NameBinding(_, _, t), _, _, _, _)|_] 
-      + ?[WildcardImport(_, _, RefScope(NameBinding(_, _, t)), _, _)|_]
+      + ?[WildcardImport(_, _, RefScope(NameBinding(_, _, t), _, _), _, _)|_]
       > u;
       t'           := <to-ppable-str> t;
       (c*, task'*) := <foldl(to-ppable-str; (ref-to-str(|replace*, bound*, rule*) <+ Snd))> (u, ([], task*))
     
   ref-to-str(|replace*, bound*, rule*): 
-    (Reference(NameBinding(_, ns, _), prop*, All(), constr*), (c*, task*)) -> ([c*, CANDIDATE(<nabl-to-str> ns, prop'*)], task'*)
+    (c, (c*, task*)) -> ([c*, CANDIDATE(<nabl-to-str> ns, prop'*)], task'*)
+    where
+      < ?Reference(NameBinding(_, ns, _), prop*, All(), constr*)
+      + ?SingleImport(NameBinding(_, ns, _), prop*, All(), _, constr*)
+      + ?WildcardImport(_, _, RefScope(NameBinding(_, ns, _), prop*, All()), _, constr*)
+      > c
     where
       replace2* := <hashtable-copy> replace*;
       bound2*   := <iset-copy> bound*;

From g.h.wachsmuth at tudelft.nl  Wed Mar 13 09:12:02 2013
From: g.h.wachsmuth at tudelft.nl (Guido Wachsmuth)
Date: Wed, 13 Mar 2013 08:12:02 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26012 -
	spoofax-imp/branches/nbl-dev/trans/generation
Message-ID: <20130313081202.9922E7F802B@mx1.tudelft.nl>

Author: GuidoWachsmuth
Date: Wed Mar 13 08:12:00 2013
New Revision: 26012
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26012&sc=1

Log:
extracted generation of namespace and property names

Modified:
   spoofax-imp/branches/nbl-dev/trans/generation/sections.str

Modified: spoofax-imp/branches/nbl-dev/trans/generation/sections.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/sections.str	Wed Mar 13 02:07:45 2013	(r26011)
+++ spoofax-imp/branches/nbl-dev/trans/generation/sections.str	Wed Mar 13 08:12:00 2013	(r26012)
@@ -14,21 +14,25 @@
     Namespaces(namespaces) -> Signature([Constructors(<map(nabl-to-str)> namespaces)])
     
   nabl-to-str: // generates constructors for namespaces
-    Namespace(ns) -> CONS_DECL($[NablNs[ns]], "Namespace")
+    Namespace(ns) -> CONS_DECL(<ns-name-to-str> ns, "Namespace")
   
-  nabl-to-str: NamespaceRef(ns) -> TERM($[NablNs[ns]])
+  nabl-to-str: NamespaceRef(ns) -> TERM(<ns-name-to-str> ns)
 
+  ns-name-to-str: ns -> $[NablNs[ns]]
+  
 rules // properties
         
   nabl-to-str(|replace*, bound*, rule*):
     Properties(props) -> Signature([Constructors(<map(nabl-to-str)> props)])
   
   nabl-to-str: // generate constructors for properties
-    Property(prop, _, _) -> CONS_DECL($[NablProp_[prop]], "Property") 
+    Property(p, _, _) -> CONS_DECL(<ns-prop-name-to-str> p, "Property") 
 
-  nabl-to-str: PropertyRef(p) -> TERM($[NablProp_[p]])
+  nabl-to-str: PropertyRef(p) -> TERM(<ns-prop-name-to-str> p)
   nabl-to-str: TypeProp()     -> TERM("Type")
 
+  ns-prop-name-to-str: p -> $[NablProp_[p]]
+
 rules // imports
     
   nabl-to-str(|replace*, bound*, rule*) = Imports(![ImportWildcard("lib/nbl"), ImportWildcard("lib/task")|<id>])
@@ -40,4 +44,4 @@
     where
       <iset-clear> rule*;
       <filter(nabl-to-str(|replace*, bound*, rule*))> rs
-     
\ No newline at end of file
+  
\ No newline at end of file

From g.h.wachsmuth at tudelft.nl  Wed Mar 13 09:12:29 2013
From: g.h.wachsmuth at tudelft.nl (Guido Wachsmuth)
Date: Wed, 13 Mar 2013 08:12:29 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26013 -
	spoofax-imp/branches/nbl-dev/trans/generation
Message-ID: <20130313081229.2A9207F8037@mx1.tudelft.nl>

Author: GuidoWachsmuth
Date: Wed Mar 13 08:12:28 2013
New Revision: 26013
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26013&sc=1

Log:
generation of nabl-get-name rules

Modified:
   spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str
   spoofax-imp/branches/nbl-dev/trans/generation/rules.str
   spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str

Modified: spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str	Wed Mar 13 08:12:00 2013	(r26012)
+++ spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str	Wed Mar 13 08:12:28 2013	(r26013)
@@ -27,6 +27,8 @@
       // otherwise replace only the name and
       // generate a rule handling this defintion site
       <iset-add(|DEF_RULE(Match(pattern), <replace-all(|[r])> pattern))> rule*
+    where
+    	<iset-add(|NAME_RULE(pattern, t'))> rule*
     where try(
       // when this definition site defines properties,
       // construct sequence of property calculatations
@@ -62,6 +64,7 @@
     
   nabl-to-str: NonUnique() -> TERM("NonUnique")
   nabl-to-str: Unique()    -> TERM("Unique")
+  
 overlays
   
   DEF_RULE(match, call) =
@@ -71,7 +74,9 @@
   , [DefaultVarDec("context"), DefaultVarDec("uris"), DefaultVarDec("states")]
   , Seq(match, call)
   )
-    
+  
+  NAME_RULE(lhs, rhs) = RDefNoArgs("nabl-get-name", RuleNoCond(lhs, rhs))
+	
   DEF_CALL(ns, u, ds, s) = 
   CallT(
     SVar("nabl-def")

Modified: spoofax-imp/branches/nbl-dev/trans/generation/rules.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/rules.str	Wed Mar 13 08:12:00 2013	(r26012)
+++ spoofax-imp/branches/nbl-dev/trans/generation/rules.str	Wed Mar 13 08:12:28 2013	(r26013)
@@ -12,7 +12,7 @@
   
 rules
   
-  // TODO: support multiple definition sites
+  // TODO: support multiple definition sites?
   nabl-to-str(|replace*, bound*, rule*): 
     BindingRule(pattern, constr*, clause*) -> <id>
     where

Modified: spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str	Wed Mar 13 08:12:00 2013	(r26012)
+++ spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str	Wed Mar 13 08:12:28 2013	(r26013)
@@ -13,21 +13,30 @@
 rules
   
   uses-to-str(|replace*, bound*, rule*, task*, pattern) =
+    where (uses-to-name-rule(|rule*, pattern));
     filter(?UseSite(<id>) + ?ImportSite(<id>));
     if nonempty then
       (rep*, task'*) := <foldl(use-to-str(|replace*, bound*, rule*))> (<id>, ([], task*));
       ubody  := <foldr(<replace-all(|rep*)> pattern, to-seq)> task'* ;
       <iset-add(|USE_RULE(Seq(Match(pattern), ubody)))> rule*
     end
+  
+  uses-to-name-rule(|rule*, pattern) =
+  	?[UseSite(<use-to-name>)]  => t;
+  	<iset-add(|NAME_RULE(pattern, t))> rule*
+  
+  use-to-name =
+  	Hd;  
+  	( ?Reference(NameBinding(_, _, t), _, _, _)
+    + ?SingleImport(NameBinding(_, _, t), _, _, _, _)
+    + ?WildcardImport(_, _, RefScope(NameBinding(_, _, t), _, _), _, _)
+    );
+    <to-ppable-str> t
     
   use-to-str(|replace*, bound*, rule*):
     (u, (r*, task*)) -> ([(t', USE_CALL(c*)), r*], task'*)
     where 
-      < ?[Reference(NameBinding(_, _, t), _, _, _)|_] 
-      + ?[SingleImport(NameBinding(_, _, t), _, _, _, _)|_] 
-      + ?[WildcardImport(_, _, RefScope(NameBinding(_, _, t), _, _), _, _)|_]
-      > u;
-      t'           := <to-ppable-str> t;
+      t'           := <use-to-name> u;
       (c*, task'*) := <foldl(to-ppable-str; (ref-to-str(|replace*, bound*, rule*) <+ Snd))> (u, ([], task*))
     
   ref-to-str(|replace*, bound*, rule*): 

From g.h.wachsmuth at tudelft.nl  Wed Mar 13 19:51:16 2013
From: g.h.wachsmuth at tudelft.nl (Guido Wachsmuth)
Date: Wed, 13 Mar 2013 18:51:16 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26014 -
	spoofax-imp/branches/nbl-dev/trans/generation
Message-ID: <20130313185116.71BD8CC1D1@mx4.tudelft.nl>

Author: GuidoWachsmuth
Date: Wed Mar 13 18:51:14 2013
New Revision: 26014
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26014&sc=1

Log:
fixed bug where not all rules for use sites where generated

Modified:
   spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str

Modified: spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str	Wed Mar 13 08:12:28 2013	(r26013)
+++ spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str	Wed Mar 13 18:51:14 2013	(r26014)
@@ -13,7 +13,7 @@
 rules
   
   uses-to-str(|replace*, bound*, rule*, task*, pattern) =
-    where (uses-to-name-rule(|rule*, pattern));
+    where (try(uses-to-name-rule(|rule*, pattern)));
     filter(?UseSite(<id>) + ?ImportSite(<id>));
     if nonempty then
       (rep*, task'*) := <foldl(use-to-str(|replace*, bound*, rule*))> (<id>, ([], task*));

From g.h.wachsmuth at tudelft.nl  Thu Mar 14 13:10:15 2013
From: g.h.wachsmuth at tudelft.nl (Guido Wachsmuth)
Date: Thu, 14 Mar 2013 12:10:15 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26015 -
	spoofax-imp/branches/nbl-dev/trans/generation
Message-ID: <20130314121015.CBAB47F801A@mx1.tudelft.nl>

Author: GuidoWachsmuth
Date: Thu Mar 14 12:10:13 2013
New Revision: 26015
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26015&sc=1

Log:
support for contextual references; make context explicit again

Modified:
   spoofax-imp/branches/nbl-dev/trans/generation/constraints.str
   spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str
   spoofax-imp/branches/nbl-dev/trans/generation/rules.str
   spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str

Modified: spoofax-imp/branches/nbl-dev/trans/generation/constraints.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/constraints.str	Wed Mar 13 18:51:14 2013	(r26014)
+++ spoofax-imp/branches/nbl-dev/trans/generation/constraints.str	Thu Mar 14 12:10:13 2013	(r26015)
@@ -55,6 +55,6 @@
   
   NEW_TASK(t) =
   App(
-    CallT(SVar("new-task"), [], [App(CallNoArgs(SVar("task-in-context")), Var("context"))])
+    CallT(SVar("new-task"), [], [Var("tasks")])
   , t
   )
\ No newline at end of file

Modified: spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str	Wed Mar 13 18:51:14 2013	(r26014)
+++ spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str	Thu Mar 14 12:10:13 2013	(r26015)
@@ -71,7 +71,12 @@
   SDefT(
     "nabl-def-site"
   , [DefaultVarDec("child-uris"), DefaultVarDec("sibl-uris")]
-  , [DefaultVarDec("context"), DefaultVarDec("uris"), DefaultVarDec("states")]
+  , [ DefaultVarDec("lang")
+    , DefaultVarDec("partition")
+    , DefaultVarDec("uniques")
+    , DefaultVarDec("elems")
+    , DefaultVarDec("uris")
+    , DefaultVarDec("states")]
   , Seq(match, call)
   )
   
@@ -81,17 +86,22 @@
   CallT(
     SVar("nabl-def")
   , [CALL("child-uris"), CALL("sibl-uris")]
-  , [ Var("context"), Var("uris"), ns, u, ds, LIST(s)]
+  , [ Var("lang")
+    , Var("partition")
+    , Var("uniques")
+    , Var("elems")
+    , Var("uris")
+    , ns, u, ds, LIST(s)]
   )
 
   SCOPE_CALL()   = CallT(SVar("nabl-def-scope"), [], [SCOPE()])
-  SCOPE_CALL(ns) = Where(Assign(SCOPE(), App(CallT(SVar("nabl-def-scope"), [], [Var("context")]), ns)))
+  SCOPE_CALL(ns) = Where(Assign(SCOPE(), App(CallT(SVar("nabl-construct-def-scope"), [], [Var("lang"), Var("partition"), Var("uniques")]), ns)))
     
   PROP_RULE(body) =
   SDefT(
     "nabl-prop-site"
   , []
-  , [DefaultVarDec("context"), DefaultVarDec("states")]
+  , [ DefaultVarDec("elems"), DefaultVarDec("tasks"), DefaultVarDec("states")]
   , body
   )
   
@@ -99,7 +109,7 @@
   CallT(
     SVar("nabl-props")
   , []
-  , [ Var("context"), LIST(ps)]
+  , [ Var("elems"), LIST(ps)]
   )
   
   PROPERTY(p, v) = TERM("Prop", [p, v])

Modified: spoofax-imp/branches/nbl-dev/trans/generation/rules.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/rules.str	Wed Mar 13 18:51:14 2013	(r26014)
+++ spoofax-imp/branches/nbl-dev/trans/generation/rules.str	Thu Mar 14 12:10:13 2013	(r26015)
@@ -36,13 +36,21 @@
   SDefT(
     "nabl-anonymous-scope-site"
   , [DefaultVarDec("child-uris")]
-  , [DefaultVarDec("context"), DefaultVarDec("uris"), DefaultVarDec("states")]
+  , [ DefaultVarDec("lang")
+    , DefaultVarDec("partition")
+    , DefaultVarDec("uniques")
+    , DefaultVarDec("uris")
+    , DefaultVarDec("states") ]
   , Seq(
       Match(pattern)
     , CallT(
         SVar("nabl-anonymous-scope")
       , [CALL("child-uris")]
-      , [ Var("context"), Var("uris"), LIST(scopes) ]
+      , [ Var("lang")
+        , Var("partition")
+        , Var("uniques")
+        , Var("uris")
+        , LIST(scopes) ]
       )
     )
   )

Modified: spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str	Wed Mar 13 18:51:14 2013	(r26014)
+++ spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str	Thu Mar 14 12:10:13 2013	(r26015)
@@ -54,9 +54,19 @@
       <hashtable-destroy> replace2*;
       <iset-destroy> bound2*
       
-  // ref-to-str(|replace*, bound*, rule*, n): 
-  //   Reference(NameBinding(_, ns, _), [], RefScope(NameBinding(_, ns', t), _, _), []) -> CANDIDATE(<nabl-to-str> ns, <nabl-to-str> ns', <to-ppable-str> t)
-  
+  ref-to-str(|replace*, bound*, rule*): 
+    (c, (c*, task*)) -> ([c*, CANDIDATE(<nabl-to-str> ns, <nabl-to-str> ns', t', prop'*)], task'*)
+    where
+      <?Reference(NameBinding(_, ns, _), prop*, RefScope(NameBinding(_, ns', t), _, _), constr*)> c
+    where
+      replace2* := <hashtable-copy> replace*;
+      bound2*   := <iset-copy> bound*;
+      task'*    := <constraints-to-str(|replace2*, bound2*, rule*, task*)> constr*;
+      prop'*    := <map(prop-to-str); alltd(replace(|replace2*))> prop*;
+      t'        := <to-ppable-str; alltd(replace(|replace2*))> t;
+      <hashtable-destroy> replace2*;
+      <iset-destroy> bound2*
+     
   prop-to-str:
     PropertyBinding(_, p, t) -> PROPERTY(<nabl-to-str> p, <to-ppable-str> t)     
 
@@ -66,7 +76,12 @@
   SDefT(
     "nabl-use-site"
   , []
-  , [DefaultVarDec("context"), DefaultVarDec("uris"), DefaultVarDec("deps"), DefaultVarDec("states")]
+  , [ DefaultVarDec("lang")
+    , DefaultVarDec("elems")
+    , DefaultVarDec("tasks")
+    , DefaultVarDec("uris")
+    , DefaultVarDec("states") 
+    ]
   , call
   )
   
@@ -74,11 +89,17 @@
   CallT(
     SVar("nabl-use")
   , []
-  , [ Var("context"), Var("uris"), Var("deps"), LIST(candidates)] 
+  , [ Var("lang")
+    , Var("elems")
+    , Var("tasks")
+    , Var("uris")
+    , LIST(candidates)
+    ] 
   )
   
   CANDIDATE(ns, ps) =
   TERM("UseCandidate", [ns, LIST(ps), TERM("Current"), TERM("All")])
 
-  CANDIDATE(ns1, ns2, n) =
-  TERM("UseCandidate", [ns1, LIST([]), TERM("Current"), TERM("Context", [n, ns2, LIST([]), TERM("All")])])
+  CANDIDATE(ns1, ns2, n, ps) =
+  TERM("UseCandidate", [ns1, LIST(ps), LIST([n]), TERM("One")])
+  
\ No newline at end of file

From m.dejonge at tudelft.nl  Fri Mar 15 15:51:14 2013
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Fri, 15 Mar 2013 14:51:14 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26016 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder
Message-ID: <20130315145114.57FDCCC1BA@mx4.tudelft.nl>

Author: MaartjeDeJonge
Date: Fri Mar 15 14:51:12 2013
New Revision: 26016
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26016&sc=1

Log:
bugfix: WATER productions (deletion recovery by parsing a substring as layout) are not shown as syntax errors

Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java	Thu Mar 14 12:10:13 2013	(r26015)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java	Fri Mar 15 14:51:12 2013	(r26016)
@@ -238,22 +238,17 @@
 			// production nodes
 			children = null;
 
-			ArrayDeque<AbstractParseNode> nodes = new ArrayDeque<AbstractParseNode>();
-			nodes.push(node);
-
+			ArrayDeque<AbstractParseNode> nodes = fillNodeStack(node);
 			while (!nodes.isEmpty()) {
 				AbstractParseNode current = nodes.pop();
-
-				if (current.isParseProductionNode())
+				if (current.isParseProductionNode()){
 					buildTreeProduction((ParseProductionNode) current);
-
-				if (current.isAmbNode()) {
-					nodes.push(current.getChildren()[0]);
-					continue;
 				}
-
-				for (int i = current.getChildren().length - 1; i >= 0; i--)
-					nodes.push(current.getChildren()[i]);
+				if (0 <= current.getLabel() - labelStart && current.getLabel() - labelStart < labels.length) {
+					LabelInfo mjlabel = labels[current.getLabel() - labelStart];
+					tokenizer.markPossibleSyntaxError(mjlabel, prevToken, offset - 1,
+							prodReader);
+				} 
 			}
 		} else if (isList) {
 			children = inLexicalContext ? null : new AutoConcatList<Object>(
@@ -336,6 +331,21 @@
 		return result;
 	}
 
+	private ArrayDeque<AbstractParseNode> fillNodeStack(AbstractParseNode node) {		
+		if (node.isAmbNode()) {
+			return fillNodeStack(node.getChildren()[0]);
+		}
+		ArrayDeque<AbstractParseNode> nodes = new ArrayDeque<AbstractParseNode>();
+		for (int i = 0; i < node.getChildren().length; i++){
+			ArrayDeque<AbstractParseNode> nodesChild = fillNodeStack(node.getChildren()[i]);
+			while(!nodesChild.isEmpty()){
+				nodes.addLast(nodesChild.pop());
+			}
+		}
+		nodes.addLast(node);
+		return nodes;
+	}
+
 	/**
 	 * Efficiently consume lexical chars in parse production chains.
 	 * @see AbstractParseNode#isParseProductionChain()

From gabrielkonat at gmail.com  Mon Mar 18 15:37:22 2013
From: gabrielkonat at gmail.com (Gabriël Konat)
Date: Mon, 18 Mar 2013 14:37:22 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26017 - in
	spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src:
	main/java/org/spoofax/interpreter/library/index
	test/java/org/spoofax/interpreter/library/index...
Message-ID: <20130318143722.B4A7FCC0FD@mx4.tudelft.nl>

Author: gkonat
Date: Mon Mar 18 14:37:22 2013
New Revision: 26017
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26017&sc=1

Log:
Support removing entries with a specific template in all partitions.

Added:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/LANG_index_remove_all.java
Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IIndex.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/Index.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexLibrary.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexManager.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/TransactionIndex.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/IndexSymbolTableTest.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/IndexTest.java

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IIndex.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IIndex.java	Fri Mar 15 14:51:12 2013	(r26016)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IIndex.java	Mon Mar 18 14:37:22 2013	(r26017)
@@ -52,7 +52,15 @@
      * @param template The template to match entries against.
      * @param partitionDescriptor The partition entries will be removed from.
      */
-    public abstract void remove(IStrategoAppl template, IndexPartitionDescriptor partitionDescriptor);
+    public abstract Collection<IndexEntry> remove(IStrategoAppl template, IndexPartitionDescriptor partitionDescriptor);
+    
+    /**
+     * Removes all entries that match given template (from all partitions).
+     * Warning: Quite slow!
+     * 
+     * @param template The template to match entries against.
+     */
+    public abstract Collection<IndexEntry> removeAll(IStrategoAppl template);
 
     /**
      * Gets all entries that match given template.

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/Index.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/Index.java	Fri Mar 15 14:51:12 2013	(r26016)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/Index.java	Mon Mar 18 14:37:22 2013	(r26017)
@@ -119,13 +119,14 @@
         }
     }
 
-    public void remove(IStrategoAppl template, IndexPartitionDescriptor partitionDescriptor) {
+    public Collection<IndexEntry> remove(IStrategoAppl template, IndexPartitionDescriptor partitionDescriptor) {
         IndexURI uri = factory.createURIFromTemplate(template);
         IndexURI parentURI = uri.getParent(termFactory);
+        // TODO: Should this use innerEntries()/innerChildEntries()?
         Multimap<IndexPartitionDescriptor, IndexEntry> entryValues = entries.get(uri);
         Multimap<IndexPartitionDescriptor, IndexEntry> childValues = null;
         if(parentURI != null)
-            childValues = childs.get(uri.getParent(termFactory));
+            childValues = childs.get(parentURI);
         Collection<IndexEntry> removedEntries = entryValues.removeAll(partitionDescriptor);
 
         for(IndexEntry entry : removedEntries) {
@@ -135,7 +136,31 @@
             entriesPerFile.remove(partitionDescriptor.getURI(), entry);
             entriesPerPartition.remove(partitionDescriptor.getPartition(), entry);
         }
+        
+        return removedEntries;
     }
+    
+    public Collection<IndexEntry> removeAll(IStrategoAppl template) {
+        IndexURI uri = factory.createURIFromTemplate(template);
+        IndexURI parentURI = uri.getParent(termFactory);
+        Multimap<IndexPartitionDescriptor, IndexEntry> entryValues = innerEntries(uri);
+        Multimap<IndexPartitionDescriptor, IndexEntry> childValues = null;
+        if(parentURI != null)
+            childValues = innerChildEntries(uri.getParent(termFactory));
+        Collection<IndexEntry> removedEntries = entryValues.values();
+        entries.remove(uri);
+
+        for(IndexEntry entry : removedEntries) {
+            if(parentURI != null)
+                childValues.remove(entry.getPartition(), entry);
+            entriesPerPartitionDescriptor.remove(entry.getPartition(), entry);
+            entriesPerFile.remove(entry.getPartition().getURI(), entry);
+            entriesPerPartition.remove(entry.getPartition().getPartition(), entry);
+        }
+        
+        return removedEntries;
+    }
+
 
     public IIndexEntryIterable get(IStrategoAppl template) {
         IndexURI uri = factory.createURIFromTemplate(template);

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexLibrary.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexLibrary.java	Fri Mar 15 14:51:12 2013	(r26016)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexLibrary.java	Mon Mar 18 14:37:22 2013	(r26017)
@@ -12,6 +12,7 @@
         IndexManager index = new IndexManager();
         add(new LANG_index_add(index));
         add(new LANG_index_remove(index));
+        add(new LANG_index_remove_all(index));
         add(new LANG_index_clear_all(index));
         add(new LANG_index_clear_file(index));
         add(new LANG_index_get_all_files(index));

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexManager.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexManager.java	Fri Mar 15 14:51:12 2013	(r26016)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexManager.java	Mon Mar 18 14:37:22 2013	(r26017)
@@ -17,6 +17,7 @@
 import java.util.concurrent.locks.ReentrantReadWriteLock;
 
 import org.spoofax.interpreter.library.IOAgent;
+import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.ITermFactory;
 import org.spoofax.terms.io.binary.TermReader;
@@ -90,6 +91,9 @@
 
             for(TemplateWithPartitionDescriptor entry : currentIndex.getRemovedEntries())
                 index.remove(entry.getTemplate(), entry.getPartitionDescriptor());
+            
+            for(IStrategoAppl template : currentIndex.getRemovedAllEntries())
+                index.removeAll(template);
 
             for(IndexEntry entry : transactionIndex.getAll())
                 index.add(entry);

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/LANG_index_remove_all.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/LANG_index_remove_all.java	Mon Mar 18 14:37:22 2013	(r26017)
@@ -0,0 +1,37 @@
+package org.spoofax.interpreter.library.index;
+
+import static org.spoofax.interpreter.core.Tools.isTermAppl;
+import static org.spoofax.interpreter.core.Tools.isTermString;
+import static org.spoofax.interpreter.core.Tools.isTermTuple;
+
+import org.spoofax.interpreter.core.IContext;
+import org.spoofax.interpreter.library.AbstractPrimitive;
+import org.spoofax.interpreter.stratego.Strategy;
+import org.spoofax.interpreter.terms.IStrategoAppl;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class LANG_index_remove_all extends AbstractPrimitive {
+    private static String NAME = "LANG_index_remove_all";
+
+    private final IndexManager index;
+
+    public LANG_index_remove_all(IndexManager index) {
+        super(NAME, 0, 2);
+        this.index = index;
+    }
+
+    @Override
+    public boolean call(IContext env, Strategy[] svars, IStrategoTerm[] tvars) {
+        if(isTermAppl(tvars[0]) && (isTermTuple(tvars[1]) || isTermString(tvars[1]))) {
+            IStrategoAppl template = (IStrategoAppl) tvars[0];
+            IIndex ind = index.getCurrent();
+            ind.removeAll(template);
+            return true;
+        } else {
+            return false;
+        }
+    }
+}

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/TransactionIndex.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/TransactionIndex.java	Fri Mar 15 14:51:12 2013	(r26016)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/TransactionIndex.java	Mon Mar 18 14:37:22 2013	(r26017)
@@ -21,6 +21,7 @@
     private IndexPartitionDescriptor currentPartition;
     private boolean clearedCurrentPartition = false;
     private List<TemplateWithPartitionDescriptor> removedEntries = new ArrayList<TemplateWithPartitionDescriptor>();
+    private List<IStrategoAppl> removedAllEntries = new ArrayList<IStrategoAppl>();
 
     public TransactionIndex(IIndex index, IIndex transactionIndex, IndexPartitionDescriptor currentPartition) {
         this.index = index;
@@ -47,6 +48,10 @@
     public Collection<TemplateWithPartitionDescriptor> getRemovedEntries() {
         return removedEntries;
     }
+    
+    public Collection<IStrategoAppl> getRemovedAllEntries() {
+        return removedAllEntries;
+    }
 
     public void initialize(ITermFactory factory, IOAgent agent) {
         // Should not be called, both the index and transaction index should already be initialized.
@@ -69,9 +74,16 @@
         transactionIndex.addAll(entries, partitionDescriptor);
     }
 
-    public void remove(IStrategoAppl template, IndexPartitionDescriptor partitionDescriptor) {
-        transactionIndex.remove(template, partitionDescriptor);
+    public Collection<IndexEntry> remove(IStrategoAppl template, IndexPartitionDescriptor partitionDescriptor) {
+        Collection<IndexEntry> removed = transactionIndex.remove(template, partitionDescriptor);
         removedEntries.add(new TemplateWithPartitionDescriptor(template, partitionDescriptor));
+        return removed;
+    }
+    
+    public Collection<IndexEntry> removeAll(IStrategoAppl template) {
+        Collection<IndexEntry> removed = transactionIndex.removeAll(template);
+        removedAllEntries.add(template);
+        return removed;
     }
 
     public IIndexEntryIterable get(final IStrategoAppl template) {

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/IndexSymbolTableTest.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/IndexSymbolTableTest.java	Fri Mar 15 14:51:12 2013	(r26016)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/IndexSymbolTableTest.java	Mon Mar 18 14:37:22 2013	(r26017)
@@ -285,8 +285,9 @@
     @Test
     public void getEntriesInFileAndRemoveFile() {
         IStrategoTerm fileTerm1 = file("TestFile", "Partition", "1");
+        IStrategoTerm fileTerm2 = file("TestFile", "Partition", "2");
         IndexPartitionDescriptor file1 = setupIndex(fileTerm1);
-        IndexPartitionDescriptor file2 = setupIndex(file("TestFile", "Partition", "2"));
+        IndexPartitionDescriptor file2 = setupIndex(fileTerm2);
 
         IStrategoAppl def1 = def("Entity", "CRM", "Person");
         IStrategoAppl read = read("Function", "CRM", "Person", "GetName");
@@ -397,6 +398,88 @@
     }
 
     @Test
+    public void remove() {
+        IStrategoTerm fileTerm1 = file("TestFile", "Partition", "1");
+        IStrategoTerm fileTerm2 = file("TestFile", "Partition", "2");
+        IndexPartitionDescriptor file1 = setupIndex(fileTerm1);
+        IndexPartitionDescriptor file2 = setupIndex(fileTerm2);
+
+        IStrategoAppl def1 = def("Entity", "CRM", "Person");
+        IStrategoAppl def2 = def("Class", "java", "lang", "String");
+
+        startTransaction();
+
+        assertEquals(0, size(index.get(def1)));
+        assertEquals(0, size(index.get(def2)));
+        assertEquals(0, size(index.getInPartition(file1)));
+        assertEquals(0, size(index.getInPartition(file2)));
+
+        index.add(def1, file1);
+        index.add(def1, file2);
+        index.add(def2, file1);
+        index.add(def2, file2);
+        
+        index.remove(def1, file1);
+        
+        IIndexEntryIterable ret1 = index.getInPartition(file1);
+        IIndexEntryIterable ret2 = index.getInPartition(file2);
+
+        try {
+            ret1.lock();
+            ret2.lock();
+
+            assertFalse(containsEntry(ret1, def1));
+            assertTrue(containsEntry(ret2, def1));
+            assertTrue(containsEntry(ret1, def2));
+            assertTrue(containsEntry(ret2, def2));
+        } finally {
+            ret1.unlock();
+            ret2.unlock();
+        }
+    }
+    
+    @Test
+    public void removeAll() {
+        IStrategoTerm fileTerm1 = file("TestFile", "Partition", "1");
+        IStrategoTerm fileTerm2 = file("TestFile", "Partition", "2");
+        IndexPartitionDescriptor file1 = setupIndex(fileTerm1);
+        IndexPartitionDescriptor file2 = setupIndex(fileTerm2);
+
+        IStrategoAppl def1 = def("Entity", "CRM", "Person");
+        IStrategoAppl def2 = def("Class", "java", "lang", "String");
+
+        startTransaction();
+
+        assertEquals(0, size(index.get(def1)));
+        assertEquals(0, size(index.get(def2)));
+        assertEquals(0, size(index.getInPartition(file1)));
+        assertEquals(0, size(index.getInPartition(file2)));
+
+        index.add(def1, file1);
+        index.add(def1, file2);
+        index.add(def2, file1);
+        index.add(def2, file2);
+        
+        index.removeAll(def1);
+        
+        IIndexEntryIterable ret1 = index.getInPartition(file1);
+        IIndexEntryIterable ret2 = index.getInPartition(file2);
+
+        try {
+            ret1.lock();
+            ret2.lock();
+
+            assertFalse(containsEntry(ret1, def1));
+            assertFalse(containsEntry(ret2, def1));
+            assertTrue(containsEntry(ret1, def2));
+            assertTrue(containsEntry(ret2, def2));
+        } finally {
+            ret1.unlock();
+            ret2.unlock();
+        }
+    }
+    
+    @Test
     public void clear() {
         IndexPartitionDescriptor file1 = setupIndex(file("TestFile", "Partition", "1"));
         IndexPartitionDescriptor file2 = setupIndex(file("TestFile", "Partition", "2"));

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/IndexTest.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/IndexTest.java	Fri Mar 15 14:51:12 2013	(r26016)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/IndexTest.java	Mon Mar 18 14:37:22 2013	(r26017)
@@ -165,6 +165,14 @@
             found = found || entry.toTerm(factory).match(term);
         return found;
     }
+    
+    public static boolean containsEntry(IIndexEntryIterable entries, IndexPartitionDescriptor partition, 
+        IStrategoTerm term) {
+        boolean found = false;
+        for(IndexEntry entry : entries)
+            found = found || (entry.getPartition().equals(partition) && entry.toTerm(factory).match(term));
+        return found;
+    }
 
     public static boolean containsPartitionDescriptor(Collection<IndexPartitionDescriptor> partitionDescriptors,
         IndexPartitionDescriptor partition) {

From v.vergu+vc at gmail.com  Mon Mar 18 16:37:21 2013
From: v.vergu+vc at gmail.com (Vlad Vergu)
Date: Mon, 18 Mar 2013 15:37:21 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26018 -
	spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/statistics
Message-ID: <20130318153721.32A1E7F800E@mx1.tudelft.nl>

Author: VladVergu
Date: Mon Mar 18 15:37:19 2013
New Revision: 26018
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26018&sc=1

Log:
Different extension for streaks

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/statistics/EditStreak.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/statistics/StreakManifest.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/statistics/EditStreak.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/statistics/EditStreak.java	Mon Mar 18 14:37:22 2013	(r26017)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/statistics/EditStreak.java	Mon Mar 18 15:37:19 2013	(r26018)
@@ -56,13 +56,14 @@
 		final int streakNumber = manifest.addStreak(this);
 
 		final File streaksFolder = new File(project.toFile(), EditStreakRecorder.RECORD_LOCATION);
-		if (!streaksFolder.exists()) {
-			streaksFolder.createNewFile();
+		final File recordFolder = new File(streaksFolder, streakNumber + "");
+		if (!recordFolder.exists()) {
+			recordFolder.mkdirs();
 		}
 		for (RecordedEdit edit : edits) {
 			final IPath sFilePath = edit.resource.getProjectRelativePath();
-			ensureDirectories(streaksFolder, sFilePath.segments());
-			final File outFile = new File(streaksFolder, sFilePath.toString() + "._" + streakNumber);
+			ensureDirectories(recordFolder, sFilePath.segments());
+			final File outFile = new File(recordFolder, sFilePath.toString() + "._streak");
 			final PrintStream ps = new PrintStream(outFile);
 			ps.print(ImploderAttachment.getTokenizer(edit.ast).getInput());
 			ps.close();

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/statistics/StreakManifest.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/statistics/StreakManifest.java	Mon Mar 18 14:37:22 2013	(r26017)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/statistics/StreakManifest.java	Mon Mar 18 15:37:19 2013	(r26018)
@@ -74,7 +74,6 @@
 		while (fiter.hasNext()) {
 			final IResource f = fiter.next();
 			streakFilesStr.append(f.getProjectRelativePath().toString());
-			streakFilesStr.append("." + totalStreaks);
 			if (fiter.hasNext()) {
 				streakFilesStr.append(",");
 			}

From gabrielkonat at gmail.com  Mon Mar 18 18:15:36 2013
From: gabrielkonat at gmail.com (Gabriël Konat)
Date: Mon, 18 Mar 2013 17:15:36 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26019 -
	spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index
Message-ID: <20130318171536.E821C108C018@mx3.tudelft.nl>

Author: gkonat
Date: Mon Mar 18 17:15:35 2013
New Revision: 26019
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26019&sc=1

Log:
Added index-get that also returns the partition the retrieved entries are from.
Fixed remove-all primitive taking a partition as second argument.
Allow normal stratego terms to be used as sub partitions as well.

Added:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/LANG_index_get_with_partitions.java
Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/Index.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexEntry.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexLibrary.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexPartitionDescriptor.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/LANG_index_remove_all.java

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/Index.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/Index.java	Mon Mar 18 15:37:19 2013	(r26018)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/Index.java	Mon Mar 18 17:15:35 2013	(r26019)
@@ -36,7 +36,7 @@
     private final Multimap<IndexPartitionDescriptor, IndexEntry> entriesPerPartitionDescriptor = LinkedHashMultimap
         .create();
     private final Multimap<URI, IndexEntry> entriesPerFile = LinkedHashMultimap.create();
-    private final Multimap<IStrategoList, IndexEntry> entriesPerPartition = LinkedHashMultimap.create();
+    private final Multimap<IStrategoTerm, IndexEntry> entriesPerPartition = LinkedHashMultimap.create();
     private final Map<IndexPartitionDescriptor, IndexPartition> partitions =
         new HashMap<IndexPartitionDescriptor, IndexPartition>();
 

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexEntry.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexEntry.java	Mon Mar 18 15:37:19 2013	(r26018)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexEntry.java	Mon Mar 18 17:15:35 2013	(r26019)
@@ -82,6 +82,22 @@
         }
         return results;
     }
+    
+    /**
+     * Returns a list with tuples of term representations of given entries with their partitions.
+     */
+    public static IStrategoList toTermsWithPartition(ITermFactory factory, IIndexEntryIterable entries) {
+        IStrategoList results = factory.makeList();
+        try {
+            entries.lock();
+            for(IndexEntry entry : entries) {
+                results = factory.makeListCons(factory.makeTuple(entry.getPartition().toTerm(factory), entry.toTerm(factory)), results);
+            }
+        } finally {
+            entries.unlock();
+        }
+        return results;
+    }
 
     /**
      * Force an imploder attachment for a term. This ensures that there is always some form of position info, and makes

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexLibrary.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexLibrary.java	Mon Mar 18 15:37:19 2013	(r26018)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexLibrary.java	Mon Mar 18 17:15:35 2013	(r26019)
@@ -20,6 +20,7 @@
         add(new LANG_index_get_children(index));
         add(new LANG_index_get_files_of(index));
         add(new LANG_index_get(index));
+        add(new LANG_index_get_with_partitions(index));
         add(new LANG_index_setup(index));
         add(new LANG_index_commit(index));
         add(new LANG_index_get_files_newer_than(index));

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexPartitionDescriptor.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexPartitionDescriptor.java	Mon Mar 18 15:37:19 2013	(r26018)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexPartitionDescriptor.java	Mon Mar 18 17:15:35 2013	(r26019)
@@ -23,14 +23,14 @@
     private static final long serialVersionUID = -5167366407344668956L;
 
     private final URI uri;
-    private final IStrategoList partition;
+    private final IStrategoTerm partition;
 
     private transient IStrategoTerm cachedTerm;
     private transient String cachedString;
 
-    public IndexPartitionDescriptor(URI uri, IStrategoList subpartition) {
+    public IndexPartitionDescriptor(URI uri, IStrategoTerm subpartition) {
         this.uri = uri;
-        if(subpartition == null || subpartition.isEmpty())
+        if(subpartition == null)
             this.partition = null;
         else
             this.partition = subpartition;
@@ -40,7 +40,7 @@
         return uri;
     }
 
-    public IStrategoList getPartition() {
+    public IStrategoTerm getPartition() {
         return partition;
     }
 
@@ -79,10 +79,10 @@
      */
     public static IndexPartitionDescriptor fromTerm(IOAgent agent, IStrategoTerm term) {
         String name;
-        IStrategoList subpartition;
+        IStrategoTerm subpartition;
         if(isTermTuple(term)) {
             name = asJavaString(term.getSubterm(0));
-            subpartition = (IStrategoList) term.getSubterm(1);
+            subpartition = term.getSubterm(1);
         } else {
             name = asJavaString(term);
             subpartition = null;

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/LANG_index_get_with_partitions.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/LANG_index_get_with_partitions.java	Mon Mar 18 17:15:35 2013	(r26019)
@@ -0,0 +1,36 @@
+package org.spoofax.interpreter.library.index;
+
+import static org.spoofax.interpreter.core.Tools.isTermAppl;
+
+import org.spoofax.interpreter.core.IContext;
+import org.spoofax.interpreter.library.AbstractPrimitive;
+import org.spoofax.interpreter.stratego.Strategy;
+import org.spoofax.interpreter.terms.IStrategoAppl;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class LANG_index_get_with_partitions extends AbstractPrimitive {
+    private static String NAME = "LANG_index_get_with_partitions";
+
+    private final IndexManager index;
+
+    public LANG_index_get_with_partitions(IndexManager index) {
+        super(NAME, 0, 1);
+        this.index = index;
+    }
+
+    @Override
+    public boolean call(IContext env, Strategy[] svars, IStrategoTerm[] tvars) {
+        if(isTermAppl(tvars[0])) {
+            IStrategoAppl template = (IStrategoAppl) tvars[0];
+            IIndex ind = index.getCurrent();
+            IIndexEntryIterable entries = ind.get(template);
+            env.setCurrent(IndexEntry.toTermsWithPartition(env.getFactory(), entries));
+            return true;
+        } else {
+            return false;
+        }
+    }
+}

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/LANG_index_remove_all.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/LANG_index_remove_all.java	Mon Mar 18 15:37:19 2013	(r26018)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/LANG_index_remove_all.java	Mon Mar 18 17:15:35 2013	(r26019)
@@ -1,8 +1,6 @@
 package org.spoofax.interpreter.library.index;
 
 import static org.spoofax.interpreter.core.Tools.isTermAppl;
-import static org.spoofax.interpreter.core.Tools.isTermString;
-import static org.spoofax.interpreter.core.Tools.isTermTuple;
 
 import org.spoofax.interpreter.core.IContext;
 import org.spoofax.interpreter.library.AbstractPrimitive;
@@ -19,13 +17,13 @@
     private final IndexManager index;
 
     public LANG_index_remove_all(IndexManager index) {
-        super(NAME, 0, 2);
+        super(NAME, 0, 1);
         this.index = index;
     }
 
     @Override
     public boolean call(IContext env, Strategy[] svars, IStrategoTerm[] tvars) {
-        if(isTermAppl(tvars[0]) && (isTermTuple(tvars[1]) || isTermString(tvars[1]))) {
+        if(isTermAppl(tvars[0])) {
             IStrategoAppl template = (IStrategoAppl) tvars[0];
             IIndex ind = index.getCurrent();
             ind.removeAll(template);

From gabrielkonat at gmail.com  Mon Mar 18 18:27:15 2013
From: gabrielkonat at gmail.com (Gabriël Konat)
Date: Mon, 18 Mar 2013 17:27:15 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26020 -
	spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index
Message-ID: <20130318172715.6B0742B800E@mx2.tudelft.nl>

Author: gkonat
Date: Mon Mar 18 17:27:15 2013
New Revision: 26020
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26020&sc=1

Log:
Empty list as sub partition is considered a null sub partition.

Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexPartitionDescriptor.java

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexPartitionDescriptor.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexPartitionDescriptor.java	Mon Mar 18 17:15:35 2013	(r26019)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexPartitionDescriptor.java	Mon Mar 18 17:27:15 2013	(r26020)
@@ -2,6 +2,7 @@
 
 import static org.spoofax.interpreter.core.Tools.asJavaString;
 import static org.spoofax.interpreter.core.Tools.isTermTuple;
+import static org.spoofax.interpreter.core.Tools.isTermList;
 
 import java.io.File;
 import java.io.Serializable;
@@ -30,7 +31,7 @@
 
     public IndexPartitionDescriptor(URI uri, IStrategoTerm subpartition) {
         this.uri = uri;
-        if(subpartition == null)
+        if(subpartition == null || (isTermList(subpartition) && ((IStrategoList)subpartition).isEmpty()))
             this.partition = null;
         else
             this.partition = subpartition;

From gabrielkonat at gmail.com  Mon Mar 18 18:48:05 2013
From: gabrielkonat at gmail.com (Gabriël Konat)
Date: Mon, 18 Mar 2013 17:48:05 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26021 -
	spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index
Message-ID: <20130318174806.028C7CC187@mx4.tudelft.nl>

Author: gkonat
Date: Mon Mar 18 17:48:00 2013
New Revision: 26021
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26021&sc=1

Log:
Remove old sub partition behavior.

Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/Index.java

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/Index.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/Index.java	Mon Mar 18 17:27:15 2013	(r26020)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/Index.java	Mon Mar 18 17:48:00 2013	(r26021)
@@ -1,6 +1,5 @@
 package org.spoofax.interpreter.library.index;
 
-import java.net.URI;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
@@ -35,8 +34,6 @@
         new ConcurrentHashMap<IndexURI, Multimap<IndexPartitionDescriptor, IndexEntry>>();
     private final Multimap<IndexPartitionDescriptor, IndexEntry> entriesPerPartitionDescriptor = LinkedHashMultimap
         .create();
-    private final Multimap<URI, IndexEntry> entriesPerFile = LinkedHashMultimap.create();
-    private final Multimap<IStrategoTerm, IndexEntry> entriesPerPartition = LinkedHashMultimap.create();
     private final Map<IndexPartitionDescriptor, IndexPartition> partitions =
         new HashMap<IndexPartitionDescriptor, IndexPartition>();
 
@@ -108,8 +105,6 @@
 
         // Add entry to partitions.
         entriesPerPartitionDescriptor.put(partition, entry);
-        entriesPerFile.put(partition.getURI(), entry);
-        entriesPerPartition.put(partition.getPartition(), entry);
     }
 
     public void addAll(IStrategoList entries, IndexPartitionDescriptor partitionDescriptor) {
@@ -133,8 +128,6 @@
             if(parentURI != null)
                 childValues.remove(partitionDescriptor, entry);
             entriesPerPartitionDescriptor.remove(partitionDescriptor, entry);
-            entriesPerFile.remove(partitionDescriptor.getURI(), entry);
-            entriesPerPartition.remove(partitionDescriptor.getPartition(), entry);
         }
         
         return removedEntries;
@@ -154,14 +147,11 @@
             if(parentURI != null)
                 childValues.remove(entry.getPartition(), entry);
             entriesPerPartitionDescriptor.remove(entry.getPartition(), entry);
-            entriesPerFile.remove(entry.getPartition().getURI(), entry);
-            entriesPerPartition.remove(entry.getPartition().getPartition(), entry);
         }
         
         return removedEntries;
     }
 
-
     public IIndexEntryIterable get(IStrategoAppl template) {
         IndexURI uri = factory.createURIFromTemplate(template);
         return getEntryIterable(innerEntries(uri).values());
@@ -173,12 +163,7 @@
     }
 
     public IIndexEntryIterable getInPartition(IndexPartitionDescriptor partitionDescriptor) {
-        if(partitionDescriptor.getPartition() == null)
-            return getEntryIterable(entriesPerFile.get(partitionDescriptor.getURI()));
-        else if(partitionDescriptor.getURI() == null)
-            return getEntryIterable(entriesPerPartition.get(partitionDescriptor.getPartition()));
-        else
-            return getEntryIterable(entriesPerPartitionDescriptor.get(partitionDescriptor));
+        return getEntryIterable(entriesPerPartitionDescriptor.get(partitionDescriptor));
     }
 
     public Collection<IndexPartitionDescriptor> getPartitionsOf(IStrategoAppl template) {
@@ -231,16 +216,8 @@
         for(Multimap<IndexPartitionDescriptor, IndexEntry> map : childValues)
             map.removeAll(partitionDescriptor);
 
-        if(partitionDescriptor.getPartition() == null)
-            entriesPerFile.removeAll(partitionDescriptor.getURI());
-        else if(partitionDescriptor.getURI() == null)
-            entriesPerPartition.removeAll(partitionDescriptor.getPartition());
-        else {
-            entriesPerPartitionDescriptor.removeAll(partitionDescriptor);
-            clearPartition(new IndexPartitionDescriptor(partitionDescriptor.getURI(), null));
-            clearPartition(new IndexPartitionDescriptor(null, partitionDescriptor.getPartition()));
-        }
-
+        entriesPerPartitionDescriptor.removeAll(partitionDescriptor);
+        
         assert !getInPartition(partitionDescriptor).iterator().hasNext();
     }
 
@@ -256,8 +233,6 @@
         entries.clear();
         childs.clear();
         entriesPerPartitionDescriptor.clear();
-        entriesPerFile.clear();
-        entriesPerPartition.clear();
         partitions.clear();
     }
 

From v.vergu+vc at gmail.com  Mon Mar 18 19:19:51 2013
From: v.vergu+vc at gmail.com (Vlad Vergu)
Date: Mon, 18 Mar 2013 18:19:51 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26022 -
	spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/statistics
Message-ID: <20130318181951.B65AC2B800F@mx2.tudelft.nl>

Author: VladVergu
Date: Mon Mar 18 18:19:50 2013
New Revision: 26022
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26022&sc=1

Log:
Make sure streak recorder does not queue when disabled

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/statistics/EditStreakRecorder.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/statistics/EditStreakRecorder.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/statistics/EditStreakRecorder.java	Mon Mar 18 17:48:00 2013	(r26021)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/statistics/EditStreakRecorder.java	Mon Mar 18 18:19:50 2013	(r26022)
@@ -82,7 +82,7 @@
 	 */
 	public void recordEdit(IStrategoTerm ast) {
 		assert ast != null;
-		if (this.thread == null || !this.thread.isAlive() || doStop) {
+		if (!cfgEnabled || this.thread == null || !this.thread.isAlive() || doStop) {
 			return;
 		}
 		queue.add(new RecordedEdit(ast, System.currentTimeMillis()));
@@ -130,7 +130,6 @@
 
 	private void stop() {
 		if (this.thread != null && this.thread.isAlive()) {
-			System.out.println("Stopping...");
 			this.doStop = true;
 			this.thread.interrupt();
 		}

From g.h.wachsmuth at tudelft.nl  Tue Mar 19 15:40:45 2013
From: g.h.wachsmuth at tudelft.nl (Guido Wachsmuth)
Date: Tue, 19 Mar 2013 14:40:45 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26023 - in
	spoofax-imp/branches/nbl-dev: . editor syntax syntax/common
	syntax/nabl syntax/terms trans trans/generation
Message-ID: <20130319144045.707317F802D@mx1.tudelft.nl>

Author: GuidoWachsmuth
Date: Tue Mar 19 14:40:43 2013
New Revision: 26023
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26023&sc=1

Log:
syntax from the SCP paper

Added:
   spoofax-imp/branches/nbl-dev/syntax/Modules.tmpl
   spoofax-imp/branches/nbl-dev/syntax/NaBL.tmpl
Deleted:
   spoofax-imp/branches/nbl-dev/syntax/common/Modules.sdf
   spoofax-imp/branches/nbl-dev/syntax/nabl/Namespaces.sdf
   spoofax-imp/branches/nbl-dev/syntax/nabl/Properties.sdf
   spoofax-imp/branches/nbl-dev/syntax/nabl/Rules.sdf
Modified:
   spoofax-imp/branches/nbl-dev/   (props changed)
   spoofax-imp/branches/nbl-dev/editor/NameBindingLanguage-Colorer.esv
   spoofax-imp/branches/nbl-dev/syntax/   (props changed)
   spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.generated.pp
   spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.sdf
   spoofax-imp/branches/nbl-dev/syntax/common/   (props changed)
   spoofax-imp/branches/nbl-dev/syntax/common/Identifiers.sdf
   spoofax-imp/branches/nbl-dev/syntax/common/Layout.sdf
   spoofax-imp/branches/nbl-dev/syntax/nabl/   (props changed)
   spoofax-imp/branches/nbl-dev/syntax/terms/Vars.sdf
   spoofax-imp/branches/nbl-dev/trans/generation/constraints.str
   spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str
   spoofax-imp/branches/nbl-dev/trans/generation/rules.str
   spoofax-imp/branches/nbl-dev/trans/generation/sections.str
   spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str
   spoofax-imp/branches/nbl-dev/trans/names.nd
   spoofax-imp/branches/nbl-dev/trans/names.str

Modified: spoofax-imp/branches/nbl-dev/editor/NameBindingLanguage-Colorer.esv
==============================================================================
--- spoofax-imp/branches/nbl-dev/editor/NameBindingLanguage-Colorer.esv	Mon Mar 18 18:19:50 2013	(r26022)
+++ spoofax-imp/branches/nbl-dev/editor/NameBindingLanguage-Colorer.esv	Tue Mar 19 14:40:43 2013	(r26023)
@@ -10,10 +10,10 @@
   
   //keyword    : 0 0 0 bold      
   
-  NamespaceId._: 0 64 128 italic //bold
+  NamespaceID._       : 0 64 128 italic //bold
   
-  PropertyId._ : 0 64 128 italic //bold
-  PropertyRef._: 0 64 128 italic bold
+  PropertyID._        : 0 64 128 italic //bold
+  PropertyRef.TypeProp: 0 64 128 italic bold
   
 colorer documentation
 

Added: spoofax-imp/branches/nbl-dev/syntax/Modules.tmpl
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/nbl-dev/syntax/Modules.tmpl	Tue Mar 19 14:40:43 2013	(r26023)
@@ -0,0 +1,29 @@
+templates
+    
+  Module.Module = 
+  	<module <ModuleID> 
+    
+    <ModMetaData*> 
+    <ModuleSection*>>
+    
+  ModuleSection.Imports = <
+    imports <ImportModule*>>
+
+  ImportModule.ImportWildcard=
+  	<<ModuleID>/->
+  	            
+  ImportModule.Import = <<ModuleID>>
+
+lexical syntax
+
+  ModuleID     = {ModuleIDPart "/"}+ 
+  ModuleIDPart = [a-zA-Z\.\_] [a-zA-Z0-9\'\.\-\_]* 
+    
+  ModuleID = "rules"      {reject}
+  ModuleID = "namespaces" {reject}
+  ModuleID = "properties" {reject}
+
+lexical restrictions
+  
+  ModuleID -/- [a-zA-Z0-9\'\.\-\_]
+  

Added: spoofax-imp/branches/nbl-dev/syntax/NaBL.tmpl
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/nbl-dev/syntax/NaBL.tmpl	Tue Mar 19 14:40:43 2013	(r26023)
@@ -0,0 +1,124 @@
+templates // namespaces
+
+  ModuleSection.Namespaces  = <
+  namespaces   
+    <NamespaceDef*>
+  > 
+  
+  NamespaceDef.NamespaceDef = 
+		<<NamespaceID>
+		>
+  
+  NamespaceRef.NamespaceRef = <<NamespaceID>>
+
+lexical syntax
+
+  NamespaceID = Id
+                
+templates // properties
+
+  ModuleSection.Properties = <
+  properties
+    <PropertyDef*>
+  >  
+    
+  PropertyDef.PropertyDef = <
+  <PropertyID> of <NamespaceRef+; separator=", "> : <Sort>>
+  
+  PropertyRef.TypeProp    = <type>  
+  PropertyRef.PropertyRef = <<PropertyID>>
+
+  PropertyTerm.PropertyTerm       = <of <PropertyRef> <Term>>
+  PropertyPattern.PropertyPattern = <of <PropFilter> <PropertyRef> <Pattern>>
+
+  PropFilter.Equal      = <>
+  PropFilter.Conformant = <conformant>
+  
+  Constraint.PropertyConstraint = <where <Term> has <PropertyRef> <Pattern>>
+    
+lexical syntax
+
+  PropertyID = Id
+  PropertyID = "type" {reject}
+  
+templates // binding rules
+    
+  ModuleSection.BindingRules = <
+  binding rules
+    <BindingRule*>
+  >
+  
+  BindingRule.BindingRule = <
+  <Pattern> <Constraint*> : <BindingClause+>> 
+
+templates // clauses
+
+  BindingClause.DefClause = <
+    <DefKind> defines <Unique> <NamespaceRef> <Term> <PropertyTerm*> <InDefScopes> <Constraint*>
+  > 
+  
+  DefKind.Explicit = <>
+  DefKind.Implicit = <implicitly>
+  
+  Unique.Unique    = <>
+  Unique.Unique    = <unique>
+  Unique.NonUnique = <non-unique>
+    
+  BindingClause.ScopeClause = <
+    scopes <NamespaceRef+; separator=", ">
+  > 
+  
+  BindingClause.RefClause     = <
+    <RefClausePart+; separator="otherwise">
+  >
+    
+  RefClausePart.RefClausePart = <
+  refers to <Disambiguator> <NamespaceRef> <Term> <PropertyPattern*> <InRefScope> <Constraint*>>
+  
+  BindingClause.ImportClause = <
+    <ImportClausePart+; separator="otherwise\n">
+  > 
+  
+  ImportClausePart.SingleImport = <
+  imports <Disambiguator> <NamespaceRef> <Term> <PropertyPattern*> <FromScope> <Alias> <IntoScopes> <Constraint*>>             
+
+  ImportClausePart.WildcardImport = <
+  imports <ImportRef+; separator=", "> <PropertyPattern*> <FromScope> <IntoScopes> <Constraint*>> 
+  
+  Alias.None  = <>
+  Alias.Alias = <<Term>>
+ 
+  ImportRef.Direct     = <<NamespaceRef>>
+  ImportRef.Transitive = <imported <NamespaceRef>>
+   
+templates // scopes
+
+  InDefScopes.Current = <>
+  InDefScopes         = <in <DefScopes>>   {bracket}
+  
+  InRefScope.Current  = <>
+  InRefScope          = <in <RefScope>>    {bracket}
+  
+  FromScope.Current   = <>
+  FromScope           = <from <RefScope>>  {bracket}
+  
+  IntoScopes.Current  = <>
+  IntoScopes          = <into <DefScopes>> {bracket}
+ 
+  DefScopes.Current   = <current scope>
+  DefScopes.DefScopes = <<DefScope+; separator=", ">> 
+  DefScope.Subsequent = <subsequent scope>
+  DefScope.Context    = <<Term>>
+  
+  RefScope.Current    = <current scope>
+  RefScope.Enclosing  = <enclosing <NamespaceRef>>
+  RefScope.Context    = <<Disambiguator> <NamespaceRef> <Term> <PropertyPattern*> <InRefScope>>
+
+  Disambiguator.All   = <>
+  Disambiguator.Best  = <best>
+  
+templates // constraints
+
+  Constraint.Reference = <
+    where <Term> refers to <NamespaceRef> <Pattern> <PropertyPattern*> <InRefScope>> 
+  
\ No newline at end of file

Modified: spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.generated.pp
==============================================================================
--- spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.generated.pp	Mon Mar 18 18:19:50 2013	(r26022)
+++ spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.generated.pp	Tue Mar 19 14:40:43 2013	(r26023)
@@ -1,4 +1,126 @@
 [
+   Namespaces                                             -- V  [H  [KW["namespaces"]] _1],
+   Namespaces.1:iter-star                                 -- _1,
+   NamespaceDef                                           -- _1,
+   NamespaceRef                                           -- _1,
+   COMPLETION-ModuleSection                               -- _1,
+   COMPLETION-NamespaceDef                                -- _1,
+   COMPLETION-NamespaceRef                                -- _1,
+   Properties                                             -- V  [H  [KW["properties"]] _1],
+   Properties.1:iter-star                                 -- _1,
+   PropertyDef                                            -- _1 KW["of"] _2 KW[":"] _3,
+   PropertyDef.2:iter-sep                                 -- _1 KW[","],
+   TypeProp                                               -- KW["type"],
+   PropertyRef                                            -- _1,
+   PropertyTerm                                           -- KW["of"] _1 _2,
+   PropertyPattern                                        -- KW["of"] _1 _2 _3,
+   Equal                                                  -- ,
+   Conformant                                             -- KW["conformant"],
+   PropertyConstraint                                     -- KW["where"] _1 KW["has"] _2 _3,
+   COMPLETION-ModuleSection                               -- _1,
+   COMPLETION-PropertyDef                                 -- _1,
+   COMPLETION-PropertyRef                                 -- _1,
+   COMPLETION-PropertyTerm                                -- _1,
+   COMPLETION-PropertyPattern                             -- _1,
+   COMPLETION-PropFilter                                  -- _1,
+   COMPLETION-Constraint                                  -- _1,
+   BindingRules                                           -- V  [H  [KW["binding"] KW["rules"]] _1],
+   BindingRules.1:iter-star                               -- _1,
+   BindingRule                                            -- _1 _2 KW[":"] _3,
+   BindingRule.2:iter-star                                -- _1,
+   BindingRule.3:iter                                     -- _1,
+   COMPLETION-ModuleSection                               -- _1,
+   COMPLETION-BindingRule                                 -- _1,
+   DefClause                                              -- _1 KW["defines"] _2 _3 _4 _5 _6 _7,
+   DefClause.5:iter-star                                  -- _1,
+   DefClause.7:iter-star                                  -- _1,
+   Explicit                                               -- ,
+   Implicit                                               -- KW["implicitly"],
+   Unique                                                 -- ,
+   Unique                                                 -- KW["unique"],
+   NonUnique                                              -- KW["non-unique"],
+   ScopeClause                                            -- V  [H  [KW["scopes"]] _1],
+   ScopeClause.1:iter-sep                                 -- _1 KW[","],
+   RefClause                                              -- _1,
+   RefClause.1:iter-sep                                   -- _1 KW["otherwise"],
+   RefClausePart                                          -- KW["refers"] KW["to"] _1 _2 _3 _4 _5 _6,
+   RefClausePart.4:iter-star                              -- _1,
+   RefClausePart.6:iter-star                              -- _1,
+   ImportClause                                           -- _1,
+   ImportClause.1:iter-sep                                -- _1 KW["otherwise"],
+   SingleImport                                           -- KW["imports"] _1 _2 _3 _4 _5 _6 _7 _8,
+   SingleImport.4:iter-star                               -- _1,
+   SingleImport.8:iter-star                               -- _1,
+   WildcardImport                                         -- KW["imports"] _1 _2 _3 _4 _5,
+   WildcardImport.1:iter-sep                              -- _1 KW[","],
+   WildcardImport.2:iter-star                             -- _1,
+   WildcardImport.5:iter-star                             -- _1,
+   None                                                   -- ,
+   Alias                                                  -- _1,
+   Direct                                                 -- _1,
+   Transitive                                             -- KW["imported"] _1,
+   COMPLETION-DefKind                                     -- _1,
+   COMPLETION-Unique                                      -- _1,
+   COMPLETION-RefClausePart                               -- _1,
+   COMPLETION-BindingClause                               -- _1,
+   COMPLETION-ImportClausePart                            -- _1,
+   COMPLETION-Alias                                       -- _1,
+   COMPLETION-ImportRef                                   -- _1,
+   Current                                                -- ,
+   Current                                                -- ,
+   Current                                                -- ,
+   Current                                                -- ,
+   Current                                                -- KW["current"] KW["scope"],
+   DefScopes                                              -- _1,
+   DefScopes.1:iter-sep                                   -- _1 KW[","],
+   Subsequent                                             -- KW["subsequent"] KW["scope"],
+   Context                                                -- _1,
+   Current                                                -- KW["current"] KW["scope"],
+   Enclosing                                              -- KW["enclosing"] _1,
+   Context                                                -- _1 _2 _3 _4 _5,
+   Context.4:iter-star                                    -- _1,
+   All                                                    -- ,
+   Best                                                   -- KW["best"],
+   COMPLETION-InDefScopes                                 -- _1,
+   COMPLETION-InRefScope                                  -- _1,
+   COMPLETION-FromScope                                   -- _1,
+   COMPLETION-IntoScopes                                  -- _1,
+   COMPLETION-DefScopes                                   -- _1,
+   COMPLETION-DefScope                                    -- _1,
+   COMPLETION-RefScope                                    -- _1,
+   COMPLETION-Disambiguator                               -- _1,
+   Reference                                              -- KW["where"] _1 KW["refers"] KW["to"] _2 _3 _4 _5,
+   Reference.4:iter-star                                  -- _1,
+   COMPLETION-Constraint                                  -- _1,
+   Module                                                 -- KW["module"] _1 _2 _3,
+   Module.2:iter-star                                     -- _1,
+   Module.3:iter-star                                     -- _1,
+   Imports                                                -- V  [H  [KW["imports"]] _1],
+   Imports.1:iter-star                                    -- _1,
+   ImportWildcard                                         -- _1 KW["/-"],
+   Import                                                 -- _1,
+   COMPLETION-Module                                      -- _1,
+   COMPLETION-ModuleSection                               -- _1,
+   COMPLETION-ImportModule                                -- _1,
+   Todo                                                   -- KW["todo"] _1 _2,
+   Fixme                                                  -- KW["fixme"] _1 _2,
+   Discuss                                                -- KW["discuss"] _1 _2,
+   TestSuite                                              -- KW["test"] KW["suite"] _1,
+   AssignedTo                                             -- _1,
+   AssignedTo.1:iter-star-sep                             -- _1 KW[","],
+   AssignedTo.1:iter-star-sep.1:iter                      -- _1,
+   Example                                                -- KW["example"] _1,
+   Description                                            -- KW["description"] _1,
+   Version                                                -- KW["version"] _1,
+   Status                                                 -- V  [H  [KW["status"]] _1],
+   Status.1:iter                                          -- _1,
+   Author                                                 -- KW["author"] _1 _2 _3,
+   Author.1:iter                                          -- _1,
+   None                                                   -- ,
+   EMail                                                  -- KW["("] _1 KW[")"],
+   None                                                   -- ,
+   Affiliation                                            -- V  [H  [KW[","]] _1],
+   Affiliation.1:iter                                     -- _1,
    SortVar                                                -- _1,
    SortNoArgs                                             -- _1,
    Sort                                                   -- _1 KW["("] _2 KW[")"],
@@ -10,17 +132,6 @@
    TypeParams                                             -- KW["("] _1 KW[")"],
    TypeParams.1:iter-sep                                  -- _1 KW[","],
    TypeParam                                              -- _1 KW[":"] _2,
-   Properties                                             -- V  [H  [KW["properties"]] _1],
-   Properties.1:iter-star                                 -- _1,
-   Property                                               -- _1 KW["of"] _2 KW[":"] _3,
-   Property.2:iter-sep                                    -- _1 KW[","],
-   PropertyRef                                            -- _1,
-   TypeProp                                               -- KW["type"],
-   Namespaces                                             -- V  [H  [KW["namespaces"]] _1],
-   Namespaces.1:iter-star                                 -- _1,
-   Namespace                                              -- _1,
-   NamespaceRef                                           -- _1,
-   ImportedNsRef                                          -- KW["imported"] _1,
    Int                                                    -- _1,
    Real                                                   -- _1,
    Str                                                    -- _1,
@@ -55,95 +166,5 @@
    Var                                                    -- _1,
    ListVar                                                -- _1,
    VarRef                                                 -- _1,
-   ListVarRef                                             -- _1,
-   BindingRules                                           -- V  [H  [KW["binding"] KW["rules"]] _1],
-   BindingRules.1:iter-star                               -- _1,
-   BindingRule                                            -- _1 _2 KW[":"] _3,
-   BindingRule.2:iter-star                                -- _1,
-   BindingRule.3:iter                                     -- _1,
-   DefSite                                                -- KW["defines"] _1 _2 _3 _4 _5,
-   DefSite.3:iter-star                                    -- _1,
-   DefSite.5:iter-star                                    -- _1,
-   Unique                                                 -- ,
-   Unique                                                 -- KW["unique"],
-   NonUnique                                              -- KW["non-unique"],
-   NameBinding                                            -- _1 _2,
-   NameBinding                                            -- _1 _2 _3,
-   All                                                    -- ,
-   All                                                    -- KW["all"],
-   First                                                  -- KW["first"],
-   Single                                                 -- KW["single"],
-   Best                                                   -- KW["best"],
-   NameBinding                                            -- _1 _2,
-   PropertyBinding                                        -- KW["of"] _1 _2,
-   PropertyBinding                                        -- KW["of"] _1 _2 _3,
-   Exact                                                  -- ,
-   Conformance                                            -- KW["conformant"],
-   Current                                                -- ,
-   Current                                                -- KW["current"] KW["scope"],
-   DefScopes                                              -- _1,
-   DefScopes.1:iter-sep                                   -- _1 KW[","],
-   Subsequent                                             -- KW["subsequent"] KW["scope"],
-   DefScope                                               -- _1,
-   Scopes                                                 -- V  [H  [KW["scopes"]] _1],
-   Scopes.1:iter-sep                                      -- _1 KW[","],
-   UseSite                                                -- _1,
-   UseSite.1:iter-sep                                     -- _1 KW["otherwise"],
-   Reference                                              -- _1 _2 _3 _4,
-   Reference.2:iter-star                                  -- _1,
-   Reference.4:iter-star                                  -- _1,
-   All                                                    -- ,
-   Current                                                -- KW["current"] KW["scope"],
-   Surrounding                                            -- KW["surrounding"] _1,
-   RefScope                                               -- _1 _2 _3,
-   RefScope.2:iter-star                                   -- _1,
-   QualifiedName                                          -- _1,
-   QualifiedName.1:iter-sep                               -- _1 KW["otherwise"],
-   OverlayName                                            -- _1,
-   OverlayName.1:iter-sep                                 -- _1 KW["otherwise"],
-   ImportSite                                             -- _1,
-   ImportSite.1:iter-sep                                  -- _1 KW["otherwise"],
-   SingleImport                                           -- KW["imports"] _1 _2 _3 _4 _5,
-   SingleImport.2:iter-star                               -- _1,
-   SingleImport.5:iter-star                               -- _1,
-   WildcardImport                                         -- KW["imports"] _1 _2 _3 _4 _5,
-   WildcardImport.1:iter-sep                              -- _1 KW[","],
-   WildcardImport.2:iter-star                             -- _1,
-   WildcardImport.5:iter-star                             -- _1,
-   Reference                                              -- _1 _2 _3 _4,
-   Reference.2:iter-star                                  -- _1,
-   Reference.4:iter-star                                  -- _1,
-   All                                                    -- ,
-   RefScope                                               -- KW["from"] _1,
-   Current                                                -- ,
-   Constraint                                             -- KW["where"] _1 _2,
-   PropertyCond                                           -- KW["has"] _1 _2,
-   PropertyCond                                           -- KW["is"] KW["of"] _1 _2,
-   ReferenceCond                                          -- KW["refers"] KW["to"] _1 _2 _3,
-   ReferenceCond.2:iter-star                              -- _1,
-   Todo                                                   -- KW["todo"] _1 _2,
-   Fixme                                                  -- KW["fixme"] _1 _2,
-   Discuss                                                -- KW["discuss"] _1 _2,
-   TestSuite                                              -- KW["test"] KW["suite"] _1,
-   AssignedTo                                             -- _1,
-   AssignedTo.1:iter-star-sep                             -- _1 KW[","],
-   AssignedTo.1:iter-star-sep.1:iter                      -- _1,
-   Example                                                -- KW["example"] _1,
-   Description                                            -- KW["description"] _1,
-   Version                                                -- KW["version"] _1,
-   Status                                                 -- V  [H  [KW["status"]] _1],
-   Status.1:iter                                          -- _1,
-   Author                                                 -- KW["author"] _1 _2 _3,
-   Author.1:iter                                          -- _1,
-   None                                                   -- ,
-   EMail                                                  -- KW["("] _1 KW[")"],
-   None                                                   -- ,
-   Affiliation                                            -- V  [H  [KW[","]] _1],
-   Affiliation.1:iter                                     -- _1,
-   Module                                                 -- KW["module"] _1 _2 _3,
-   Module.2:iter-star                                     -- _1,
-   Module.3:iter-star                                     -- _1,
-   Imports                                                -- V  [H  [KW["imports"]] _1],
-   Imports.1:iter-star                                    -- _1,
-   Import                                                 -- _1
+   ListVarRef                                             -- _1
 ]
\ No newline at end of file

Modified: spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.sdf
==============================================================================
--- spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.sdf	Mon Mar 18 18:19:50 2013	(r26022)
+++ spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.sdf	Tue Mar 19 14:40:43 2013	(r26023)
@@ -2,8 +2,15 @@
 
 imports
   
-	common/Modules
-	nabl/Rules
+  common/Layout
+  common/Identifiers
+  terms/Vars
+  terms/Signatures
+  documentation/Metadata
+  documentation/Documentation
+  documentation/Development
+  Modulesgenerated
+	NaBLgenerated
 	
 exports
 	

Modified: spoofax-imp/branches/nbl-dev/syntax/common/Identifiers.sdf
==============================================================================
--- spoofax-imp/branches/nbl-dev/syntax/common/Identifiers.sdf	Mon Mar 18 18:19:50 2013	(r26022)
+++ spoofax-imp/branches/nbl-dev/syntax/common/Identifiers.sdf	Tue Mar 19 14:40:43 2013	(r26023)
@@ -2,25 +2,6 @@
 
 exports
   
-  sorts ModName ModNamePart
-  
-  lexical syntax
-  
-    {ModNamePart "/"}+                -> ModName
-    [a-zA-Z\.\_] [a-zA-Z0-9\'\.\-\_]* -> ModNamePart
-  
-  lexical restrictions
-  
-    ModName -/- [a-zA-Z0-9\'\.\-\_]
-  
-  lexical syntax
-  
-    "imports" 		-> ModName {reject}
-    "overlays" 		-> ModName {reject}
-    "rules"       -> ModName {reject}
-    "signature" 	-> ModName {reject}
-    "strategies" 	-> ModName {reject}
-
   sorts Id LId LCID UCID Wld
   
   lexical syntax
@@ -49,63 +30,13 @@
     Keyword -> LId  {reject}
     Keyword -> LCID {reject}
     Keyword -> UCID {reject}
-
-  lexical restrictions
-    "all"
-    "case" %% not reserved kw
-    "constructors"
-    "else" %% not reserved kw
-    "end" %% not reserved kw
-    "external" %% not reserved kw
-    "fail"
-    "id"
-    "if" %% not reserved kw
-    "in"
-    "imports" %% not reserved kw
-    "let"
-    "module"
-    "not"
-    "one"
-    "overlays"
-    "otherwise" %% not reserved kw
-    "prim"
-    "rec" %% not reserved kw
-    "rules"
-    "script"
-    "signature"
-    "some"
-    "sorts"
-    "strategies"
-    "stratego"
-    "switch" %% not reserved kw
-    "test"
-    "then" %% not reserved kw
-    "where"
-    "import-term"
-      -/- [a-zA-Z0-9\'\-\_]
   
   sorts Keyword
 
   lexical syntax
 
-    "all"           -> Keyword
-    "constructors"  -> Keyword
-    "fail"          -> Keyword
-    "id"            -> Keyword
-    "in"            -> Keyword
-    "let"           -> Keyword
     "module"        -> Keyword
-    "not"           -> Keyword
-    "one"           -> Keyword
-    "overlays"      -> Keyword
-    "prim"          -> Keyword
     "rules"         -> Keyword
-    "script"        -> Keyword
-    "signature"     -> Keyword
-    "some"          -> Keyword
-    "sorts"         -> Keyword
-    "strategies"    -> Keyword
-    "stratego"      -> Keyword
-    "test"          -> Keyword
-    "where"         -> Keyword
-    "import-term"   -> Keyword
+    "namespaces"    -> Keyword
+    "properties"    -> Keyword
+    
\ No newline at end of file

Modified: spoofax-imp/branches/nbl-dev/syntax/common/Layout.sdf
==============================================================================
--- spoofax-imp/branches/nbl-dev/syntax/common/Layout.sdf	Mon Mar 18 18:19:50 2013	(r26022)
+++ spoofax-imp/branches/nbl-dev/syntax/common/Layout.sdf	Tue Mar 19 14:40:43 2013	(r26023)
@@ -1,13 +1,14 @@
 module common/Layout
 exports
 
-  sorts Ws ShortCom LongCom CommChar Asterisk Eof 
+  sorts LongCom CommChar Asterisk Eof 
 
   lexical syntax
 
-    [\t\ \n\r]                -> Ws
+    [\t\ \n\r]                -> LAYOUT
+    "//" ~[\n]* ([\n] | Eof)	-> LAYOUT
 
-    "//" ~[\n]* ([\n] | Eof)	-> ShortCom
+    
     "/*" CommChar* "*/"       -> LongCom
                               -> Eof  
 
@@ -23,10 +24,8 @@
 
   lexical syntax
 
-    ShortCom  -> LAYOUT
     LongCom   -> LAYOUT
-    Ws 		    -> LAYOUT
-
+    
   context-free restrictions
 
     LAYOUT? -/- [\ \t\n\r]

Modified: spoofax-imp/branches/nbl-dev/syntax/terms/Vars.sdf
==============================================================================
--- spoofax-imp/branches/nbl-dev/syntax/terms/Vars.sdf	Mon Mar 18 18:19:50 2013	(r26022)
+++ spoofax-imp/branches/nbl-dev/syntax/terms/Vars.sdf	Tue Mar 19 14:40:43 2013	(r26023)
@@ -27,5 +27,5 @@
 
   context-free syntax
     
-    Term[[Var]]     -> BTerm %% term binding variables
-    Term[[VarRef]]  -> RTerm %% term referencing variables
+    Term[[Var]]     -> Pattern %% term binding variables
+    Term[[VarRef]]  -> Term    %% term referencing variables

Modified: spoofax-imp/branches/nbl-dev/trans/generation/constraints.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/constraints.str	Mon Mar 18 18:19:50 2013	(r26022)
+++ spoofax-imp/branches/nbl-dev/trans/generation/constraints.str	Tue Mar 19 14:40:43 2013	(r26023)
@@ -14,7 +14,7 @@
     foldl(to-ppable-str; constraint-to-str(|replace*, bound*, rule*))
     
   constraint-to-str(|replace*, bound*, rule*):  
-    (Constraint(t1, PropertyCond(p, t2)), cs*) -> [cs*, PROP_TASK(r, <nabl-to-str> p, t1'), match*]
+    (PropertyConstraint(t1, p, t2), cs*) -> [cs*, PROP_TASK(r, <nabl-to-str> p, t1'), match*]
     where
       t1' := <alltd(replace(|replace*))> t1;
       // create new task for property calculation

Modified: spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str	Mon Mar 18 18:19:50 2013	(r26022)
+++ spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str	Tue Mar 19 14:40:43 2013	(r26023)
@@ -11,7 +11,7 @@
   
 rules // definitions, scopes, properties
   def-to-str(|replace*, bound*, rule*, task*, pattern, scopes):
-    DefSite(u, NameBinding(ns, t), ps, ds, constr*) -> <id>
+    DefClause(k, u, ns, t, ps, ds, constr*) -> <id>
     where  
       // replace name with callback to handle definition site
       t' := <to-ppable-str> t;
@@ -42,16 +42,16 @@
     )
     
   def-scope-to-str:
-    DefScope(x) -> (<to-ppable-str> x, SCOPE_CALL())      
+    Context(x) -> (<to-ppable-str> x, SCOPE_CALL())      
 
   prop-to-str:
-    PropertyBinding(p, t) -> PROPERTY(<nabl-to-str> p, <to-ppable-str> t)     
+    PropertyTerm(p, t) -> PROPERTY(<nabl-to-str> p, <to-ppable-str> t)     
 
   nabl-to-str: Current() -> TERM("Current")
   nabl-to-str: 
     DefScopes(ds) -> LIST([sc1*, sc2*])
     where
-      if <fetch-elem(?DefScope(_))> ds then
+      if <fetch-elem(?Context(_))> ds then
         sc1* := [SCOPE()]
       else
         sc1* := []

Modified: spoofax-imp/branches/nbl-dev/trans/generation/rules.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/rules.str	Mon Mar 18 18:19:50 2013	(r26022)
+++ spoofax-imp/branches/nbl-dev/trans/generation/rules.str	Tue Mar 19 14:40:43 2013	(r26023)
@@ -22,7 +22,7 @@
       pattern':= <to-ppable-str> pattern;
       <iset-addlist(|<collect-all(?Var(_))> pattern')> bound*;
       task*  := <constraints-to-str(|replace*, bound*, rule*, [])> constr*;
-      scope* := <filter(?Scopes(<id>)); concat; map(nabl-to-str)> clause*
+      scope* := <filter(?ScopeClause(<id>)); concat; map(nabl-to-str)> clause*
     where try (   
        <fetch-elem(def-to-str(|replace*, bound*, rule*, task*, pattern', scope*))> clause* 
     <+ <iset-add(|SCOPE_RULE(pattern', <nonempty> scope*))> rule*

Modified: spoofax-imp/branches/nbl-dev/trans/generation/sections.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/sections.str	Mon Mar 18 18:19:50 2013	(r26022)
+++ spoofax-imp/branches/nbl-dev/trans/generation/sections.str	Tue Mar 19 14:40:43 2013	(r26023)
@@ -14,7 +14,7 @@
     Namespaces(namespaces) -> Signature([Constructors(<map(nabl-to-str)> namespaces)])
     
   nabl-to-str: // generates constructors for namespaces
-    Namespace(ns) -> CONS_DECL(<ns-name-to-str> ns, "Namespace")
+    NamespaceDef(ns) -> CONS_DECL(<ns-name-to-str> ns, "Namespace")
   
   nabl-to-str: NamespaceRef(ns) -> TERM(<ns-name-to-str> ns)
 
@@ -26,7 +26,7 @@
     Properties(props) -> Signature([Constructors(<map(nabl-to-str)> props)])
   
   nabl-to-str: // generate constructors for properties
-    Property(p, _, _) -> CONS_DECL(<ns-prop-name-to-str> p, "Property") 
+    PropertyDef(p, _, _) -> CONS_DECL(<ns-prop-name-to-str> p, "Property") 
 
   nabl-to-str: PropertyRef(p) -> TERM(<ns-prop-name-to-str> p)
   nabl-to-str: TypeProp()     -> TERM("Type")

Modified: spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str	Mon Mar 18 18:19:50 2013	(r26022)
+++ spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str	Tue Mar 19 14:40:43 2013	(r26023)
@@ -14,7 +14,7 @@
   
   uses-to-str(|replace*, bound*, rule*, task*, pattern) =
     where (try(uses-to-name-rule(|rule*, pattern)));
-    filter(?UseSite(<id>) + ?ImportSite(<id>));
+    filter(?RefClause(<id>) + ?ImportClause(<id>));
     if nonempty then
       (rep*, task'*) := <foldl(use-to-str(|replace*, bound*, rule*))> (<id>, ([], task*));
       ubody  := <foldr(<replace-all(|rep*)> pattern, to-seq)> task'* ;
@@ -22,14 +22,14 @@
     end
   
   uses-to-name-rule(|rule*, pattern) =
-  	?[UseSite(<use-to-name>)]  => t;
+  	?[RefClause(<use-to-name>)]  => t;
   	<iset-add(|NAME_RULE(pattern, t))> rule*
   
   use-to-name =
   	Hd;  
-  	( ?Reference(NameBinding(_, _, t), _, _, _)
-    + ?SingleImport(NameBinding(_, _, t), _, _, _, _)
-    + ?WildcardImport(_, _, RefScope(NameBinding(_, _, t), _, _), _, _)
+  	( ?RefClausePart(_, _, t, _, _, _)
+    + ?SingleImport(_, _, t, _, _, _, _, _)
+    + ?WildcardImport(_, _, Context(_, _, t, _, _), _, _)
     );
     <to-ppable-str> t
     
@@ -42,9 +42,9 @@
   ref-to-str(|replace*, bound*, rule*): 
     (c, (c*, task*)) -> ([c*, CANDIDATE(<nabl-to-str> ns, prop'*)], task'*)
     where
-      < ?Reference(NameBinding(_, ns, _), prop*, All(), constr*)
-      + ?SingleImport(NameBinding(_, ns, _), prop*, All(), _, constr*)
-      + ?WildcardImport(_, _, RefScope(NameBinding(_, ns, _), prop*, All()), _, constr*)
+      < ?RefClausePart(_, ns, _, prop*, Current(), constr*)
+      + ?SingleImport(_, ns, _, prop*, Current(), _, _, constr*)
+      + ?WildcardImport(_, _, Context(_, ns, _, prop*, Current()), _, constr*)
       > c
     where
       replace2* := <hashtable-copy> replace*;
@@ -57,7 +57,7 @@
   ref-to-str(|replace*, bound*, rule*): 
     (c, (c*, task*)) -> ([c*, CANDIDATE(<nabl-to-str> ns, <nabl-to-str> ns', t', prop'*)], task'*)
     where
-      <?Reference(NameBinding(_, ns, _), prop*, RefScope(NameBinding(_, ns', t), _, _), constr*)> c
+      <?RefClausePart(_, ns, _, prop*, Context(_, ns', t, _, _), constr*)> c
     where
       replace2* := <hashtable-copy> replace*;
       bound2*   := <iset-copy> bound*;
@@ -68,7 +68,7 @@
       <iset-destroy> bound2*
      
   prop-to-str:
-    PropertyBinding(_, p, t) -> PROPERTY(<nabl-to-str> p, <to-ppable-str> t)     
+    PropertyPattern(_, p, t) -> PROPERTY(<nabl-to-str> p, <to-ppable-str> t)
 
 overlays
      

Modified: spoofax-imp/branches/nbl-dev/trans/names.nd
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/names.nd	Mon Mar 18 18:19:50 2013	(r26022)
+++ spoofax-imp/branches/nbl-dev/trans/names.nd	Tue Mar 19 14:40:43 2013	(r26023)
@@ -16,18 +16,15 @@
 	
 rules
 
-	Namespace(n): 
+	NamespaceDef(n): 
 		defines Namespace n
 	
 	NamespaceRef(n): 
 		refers to Namespace n
-	
-	ImportedNsRef(n):
-		refers to Namespace n
 		
 rules
 
-	Property(p, ns, t): 
+	PropertyDef(p, ns, t): 
 		defines Property p of type (ns, t)
 	
 	PropertyRef(p): 

Modified: spoofax-imp/branches/nbl-dev/trans/names.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/names.str	Mon Mar 18 18:19:50 2013	(r26022)
+++ spoofax-imp/branches/nbl-dev/trans/names.str	Tue Mar 19 14:40:43 2013	(r26023)
@@ -62,16 +62,16 @@
 rules
 
   nam-get-definition-keys :
-    Namespace(n) -> [n]
+    NamespaceDef(n) -> [n]
 
   nam-get-definitions :
-    Namespace(n) -> [(Namespace(), [n])]
+    NamespaceDef(n) -> [(Namespace(), [n])]
 
   nam-annotate-names(|paths__, path__):
-    Namespace(n) -> <Namespace(nam-annotate-def(|path__))>
+    NamespaceDef(n) -> <NamespaceDef(nam-annotate-def(|path__))>
 
   nam-unique :
-    Namespace(n) -> <id>
+    NamespaceDef(n) -> <id>
 
 
 rules
@@ -88,39 +88,27 @@
 
 rules
 
-  nam-get-uses-keys :
-    ImportedNsRef(n) -> [n]
-
-  nam-get-uses :
-    ImportedNsRef(n) -> [(Namespace(), [n])]
-
-  nam-annotate-names(|paths__, path__):
-    ImportedNsRef(n) -> <ImportedNsRef(nam-annotate-use(|paths__, Namespace()))>
-
-
-rules
-
   nam-get-definition-keys :
-    Property(p, ns, t) -> [p]
+    PropertyDef(p, ns, t) -> [p]
 
   nam-get-definitions :
-    Property(p, ns, t) -> [(Property(), [p])]
+    PropertyDef(p, ns, t) -> [(Property(), [p])]
 
   nam-annotate-names(|paths__, path__):
-    Property(p, ns, t) -> <Property(nam-annotate-def(|path__), id, id)>
+    PropertyDef(p, ns, t) -> <PropertyDef(nam-annotate-def(|path__), id, id)>
 
   adjust-index-def-data(store__|namespace__, path__):
-    Property(p, ns, t) -> <store__> DefData(
-                                      [namespace__|path__]
-                                    , Type()
-                                    , (ns, t)
-                                    )
+    PropertyDef(p, ns, t) -> <store__> DefData(
+                                         [namespace__|path__]
+                                       , Type()
+                                       , (ns, t)
+                                       )
 
   type-of :
-    Property(p, ns, t) -> (ns, t)
+    PropertyDef(p, ns, t) -> (ns, t)
 
   nam-unique :
-    Property(p, ns, t) -> <id>
+    PropertyDef(p, ns, t) -> <id>
 
 
 rules


From v.vergu+vc at gmail.com  Tue Mar 19 15:49:48 2013
From: v.vergu+vc at gmail.com (Vlad Vergu)
Date: Tue, 19 Mar 2013 14:49:48 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26024 -
	spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego
Message-ID: <20130319144948.E74117F8008@mx1.tudelft.nl>

Author: VladVergu
Date: Tue Mar 19 14:49:46 2013
New Revision: 26024
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26024&sc=1

Log:
Primitive for calling a strategy in another language

Added:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/ForeignLangCallPrimitive.java
Modified:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/IMPLibrary.java

Added: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/ForeignLangCallPrimitive.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/ForeignLangCallPrimitive.java	Tue Mar 19 14:49:46 2013	(r26024)
@@ -0,0 +1,73 @@
+package org.strategoxt.imp.runtime.stratego;
+
+import org.eclipse.core.resources.IProject;
+import org.eclipse.imp.language.Language;
+import org.eclipse.imp.language.LanguageRegistry;
+import org.spoofax.interpreter.core.IContext;
+import org.spoofax.interpreter.core.InterpreterException;
+import org.spoofax.interpreter.library.AbstractPrimitive;
+import org.spoofax.interpreter.library.ssl.SSLLibrary;
+import org.spoofax.interpreter.stratego.Strategy;
+import org.spoofax.interpreter.terms.IStrategoString;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.strategoxt.imp.runtime.Environment;
+import org.strategoxt.imp.runtime.dynamicloading.BadDescriptorException;
+import org.strategoxt.imp.runtime.dynamicloading.Descriptor;
+import org.strategoxt.imp.runtime.services.StrategoObserver;
+
+/**
+ * Call a strategy by name in another language by name
+ * 
+ * @author Vlad Vergu <v.a.vergu add tudelft.nl>
+ * 
+ */
+public class ForeignLangCallPrimitive extends AbstractPrimitive {
+
+	public ForeignLangCallPrimitive() {
+		super("SSL_EXT_foreigncall", 0, 2);
+	}
+
+	/**
+	 * Example usage:
+	 * 
+	 * <code>
+	 * foreign-call(|lang,strategy) = PRIM("SSL_EXT_buildercall");
+	 * 
+	 * foobar:
+	 *  foreign-call(|"OtherLang", "strategy-name")
+	 * 
+	 * </code>
+	 */
+	@Override
+	public boolean call(final IContext env, Strategy[] svars, IStrategoTerm[] tvars)
+			throws InterpreterException {
+
+		assert tvars.length == 2;
+		assert tvars[0] instanceof IStrategoString;
+		assert tvars[1] instanceof IStrategoString;
+		try {
+			final String oLangName = ((IStrategoString) tvars[0]).stringValue();
+			final String strategyName = ((IStrategoString) tvars[1]).stringValue();
+			final IStrategoTerm inputTerm = env.current();
+			final EditorIOAgent agent = (EditorIOAgent) SSLLibrary.instance(env).getIOAgent();
+			final IProject project = agent.getProject();
+
+			final Language oLang = LanguageRegistry.findLanguage(oLangName);
+			if (oLang == null)
+				return false;
+			final Descriptor oLangDescr = Environment.getDescriptor(oLang);
+			assert oLangDescr != null;
+			final StrategoObserver observer = oLangDescr.createService(StrategoObserver.class, null);
+			final IStrategoTerm outputTerm = observer.invoke(strategyName, inputTerm, project
+					.getLocation().toFile());
+			env.setCurrent(outputTerm);
+		} catch (ClassCastException cex) {
+			Environment.logException(cex);
+			return false;
+		} catch (BadDescriptorException e) {
+			Environment.logException(e);
+			return false;
+		}
+		return true;
+	}
+}

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/IMPLibrary.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/IMPLibrary.java	Tue Mar 19 14:40:43 2013	(r26023)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/IMPLibrary.java	Tue Mar 19 14:49:46 2013	(r26024)
@@ -22,6 +22,7 @@
 		add(new SetMarkersPrimitive());
 		add(new CandidateSortsPrimitive());
 		add(new GetAllProjectsPrimitive());
+		add(new ForeignLangCallPrimitive());
 		
 		add(new SetTotalWorkUnitsPrimitive());
 		add(new CompleteWorkUnitPrimitive());

From g.h.wachsmuth at tudelft.nl  Tue Mar 19 16:01:10 2013
From: g.h.wachsmuth at tudelft.nl (Guido Wachsmuth)
Date: Tue, 19 Mar 2013 15:01:10 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26025 -
	spoofax-imp/branches/nbl-dev/trans/generation
Message-ID: <20130319150110.E65937F802D@mx1.tudelft.nl>

Author: GuidoWachsmuth
Date: Tue Mar 19 15:01:09 2013
New Revision: 26025
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26025&sc=1

Log:
got rid of all the to-ppable-str calls, does it once now

Modified:
   spoofax-imp/branches/nbl-dev/trans/generation/constraints.str
   spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str
   spoofax-imp/branches/nbl-dev/trans/generation/main.str
   spoofax-imp/branches/nbl-dev/trans/generation/rules.str
   spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str
   spoofax-imp/branches/nbl-dev/trans/generation/util.str

Modified: spoofax-imp/branches/nbl-dev/trans/generation/constraints.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/constraints.str	Tue Mar 19 14:49:46 2013	(r26024)
+++ spoofax-imp/branches/nbl-dev/trans/generation/constraints.str	Tue Mar 19 15:01:09 2013	(r26025)
@@ -11,7 +11,7 @@
   
   constraints-to-str(|replace*, bound*, rule*, task*) = 
     !(<id>, task*);
-    foldl(to-ppable-str; constraint-to-str(|replace*, bound*, rule*))
+    foldl(constraint-to-str(|replace*, bound*, rule*))
     
   constraint-to-str(|replace*, bound*, rule*):  
     (PropertyConstraint(t1, p, t2), cs*) -> [cs*, PROP_TASK(r, <nabl-to-str> p, t1'), match*]

Modified: spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str	Tue Mar 19 14:49:46 2013	(r26024)
+++ spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str	Tue Mar 19 15:01:09 2013	(r26025)
@@ -14,8 +14,7 @@
     DefClause(k, u, ns, t, ps, ds, constr*) -> <id>
     where  
       // replace name with callback to handle definition site
-      t' := <to-ppable-str> t;
-      r  := ( t', DEF_CALL(<nabl-to-str> ns, <nabl-to-str> u, <nabl-to-str> ds, scopes) )
+      r  := ( t, DEF_CALL(<nabl-to-str> ns, <nabl-to-str> u, <nabl-to-str> ds, scopes) )
     where 
       // when we have external scopes in a "defines ... in ..." clause, 
       // replace these external scopes with callbacks
@@ -28,24 +27,24 @@
       // generate a rule handling this defintion site
       <iset-add(|DEF_RULE(Match(pattern), <replace-all(|[r])> pattern))> rule*
     where
-    	<iset-add(|NAME_RULE(pattern, t'))> rule*
+    	<iset-add(|NAME_RULE(pattern, t))> rule*
     where try(
       // when this definition site defines properties,
       // construct sequence of property calculatations
       // and a callback
       task'* := <constraints-to-str(|replace*, bound*, rule*, task*)> constr*;
       pcall  := <alltd(replace(|replace*))> PROP_CALL(<nonempty; map(prop-to-str)> ps);
-      pcall' := <replace-all(|[(t', pcall)])> pattern;
+      pcall' := <replace-all(|[(t, pcall)])> pattern;
       // generate a rule handling properties at this definition site
       pbody  := <foldr(!pcall', to-seq)> task'* ;
       <iset-add(|PROP_RULE(Seq(Match(pattern), pbody)))> rule* 
     )
     
   def-scope-to-str:
-    Context(x) -> (<to-ppable-str> x, SCOPE_CALL())      
+    Context(x) -> (x, SCOPE_CALL())      
 
   prop-to-str:
-    PropertyTerm(p, t) -> PROPERTY(<nabl-to-str> p, <to-ppable-str> t)     
+    PropertyTerm(p, t) -> PROPERTY(<nabl-to-str> p, t)     
 
   nabl-to-str: Current() -> TERM("Current")
   nabl-to-str: 

Modified: spoofax-imp/branches/nbl-dev/trans/generation/main.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/main.str	Tue Mar 19 14:49:46 2013	(r26024)
+++ spoofax-imp/branches/nbl-dev/trans/generation/main.str	Tue Mar 19 15:01:09 2013	(r26025)
@@ -13,13 +13,19 @@
     (selected, position, ast at Module(name, _, _), path, project-path) -> (filename, result)
     with
       filename   := <guarantee-extension(|"str")> path ;
-      str-module := <nabl-to-str; to-ppable-str> ast ;
+      str-module := <to-ppable-str; nabl-to-str> ast ;
       // use next line to debug which AST node cannot be handled by the pretty-printer
       <bottomup(try(not(is-string) ; not(is-list) ; not(pp-stratego-string) ; debug(!"cannot pp ")))> str-module ;
       result     := <pp-stratego-string> str-module
 
 rules // modules
   
+  to-ppable-str = alltd(to-ppable-str-local)
+    
+  to-ppable-str-local: ListVar(x)    -> Var(x)
+  to-ppable-str-local: VarRef(x)     -> Var(x)
+  to-ppable-str-local: ListVarRef(x) -> Var(x)
+
   nabl-to-str:
     Module(name, _, sections) -> Module(name, sections')
     where

Modified: spoofax-imp/branches/nbl-dev/trans/generation/rules.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/rules.str	Tue Mar 19 14:49:46 2013	(r26024)
+++ spoofax-imp/branches/nbl-dev/trans/generation/rules.str	Tue Mar 19 15:01:09 2013	(r26025)
@@ -19,16 +19,15 @@
       <hashtable-clear> replace*;
       <iset-clear> bound*
     where
-      pattern':= <to-ppable-str> pattern;
-      <iset-addlist(|<collect-all(?Var(_))> pattern')> bound*;
+      <iset-addlist(|<collect-all(?Var(_))> pattern)> bound*;
       task*  := <constraints-to-str(|replace*, bound*, rule*, [])> constr*;
       scope* := <filter(?ScopeClause(<id>)); concat; map(nabl-to-str)> clause*
     where try (   
-       <fetch-elem(def-to-str(|replace*, bound*, rule*, task*, pattern', scope*))> clause* 
-    <+ <iset-add(|SCOPE_RULE(pattern', <nonempty> scope*))> rule*
+       <fetch-elem(def-to-str(|replace*, bound*, rule*, task*, pattern, scope*))> clause* 
+    <+ <iset-add(|SCOPE_RULE(pattern, <nonempty> scope*))> rule*
     )
     where
-      <uses-to-str(|replace*, bound*, rule*, task*, pattern')> clause*
+      <uses-to-str(|replace*, bound*, rule*, task*, pattern)> clause*
       
 overlays
 	

Modified: spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str	Tue Mar 19 14:49:46 2013	(r26024)
+++ spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str	Tue Mar 19 15:01:09 2013	(r26025)
@@ -63,12 +63,12 @@
       bound2*   := <iset-copy> bound*;
       task'*    := <constraints-to-str(|replace2*, bound2*, rule*, task*)> constr*;
       prop'*    := <map(prop-to-str); alltd(replace(|replace2*))> prop*;
-      t'        := <to-ppable-str; alltd(replace(|replace2*))> t;
+      t'        := <alltd(replace(|replace2*))> t;
       <hashtable-destroy> replace2*;
       <iset-destroy> bound2*
      
   prop-to-str:
-    PropertyPattern(_, p, t) -> PROPERTY(<nabl-to-str> p, <to-ppable-str> t)
+    PropertyPattern(_, p, t) -> PROPERTY(<nabl-to-str> p, t)
 
 overlays
      

Modified: spoofax-imp/branches/nbl-dev/trans/generation/util.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/util.str	Tue Mar 19 14:49:46 2013	(r26024)
+++ spoofax-imp/branches/nbl-dev/trans/generation/util.str	Tue Mar 19 15:01:09 2013	(r26025)
@@ -22,12 +22,6 @@
   introduce-id: Var(_)     -> Id()
   introduce-id: ListVar(_) -> Id()
     
-  to-ppable-str = alltd(to-ppable-str-local)
-    
-  to-ppable-str-local: ListVar(x)    -> Var(x)
-  to-ppable-str-local: VarRef(x)     -> Var(x)
-  to-ppable-str-local: ListVarRef(x) -> Var(x)
-
   iset-copy = iset-elements => elem*; new-iset ; iset-addlist(|elem*)
   
 overlays

From v.vergu+vc at gmail.com  Wed Mar 20 00:00:06 2013
From: v.vergu+vc at gmail.com (Vlad Vergu)
Date: Tue, 19 Mar 2013 23:00:06 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26026 -
	spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego
Message-ID: <20130319230006.D47A42B802C@mx2.tudelft.nl>

Author: VladVergu
Date: Tue Mar 19 23:00:05 2013
New Revision: 26026
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26026&sc=1

Log:
Call foreign strategy directly on the interpreter instead of on the observer

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/ForeignLangCallPrimitive.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/ForeignLangCallPrimitive.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/ForeignLangCallPrimitive.java	Tue Mar 19 15:01:09 2013	(r26025)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/ForeignLangCallPrimitive.java	Tue Mar 19 23:00:05 2013	(r26026)
@@ -45,29 +45,35 @@
 		assert tvars.length == 2;
 		assert tvars[0] instanceof IStrategoString;
 		assert tvars[1] instanceof IStrategoString;
+		final String oLangName = ((IStrategoString) tvars[0]).stringValue();
+		final String strategyName = ((IStrategoString) tvars[1]).stringValue();
+		boolean result = false;
 		try {
-			final String oLangName = ((IStrategoString) tvars[0]).stringValue();
-			final String strategyName = ((IStrategoString) tvars[1]).stringValue();
 			final IStrategoTerm inputTerm = env.current();
 			final EditorIOAgent agent = (EditorIOAgent) SSLLibrary.instance(env).getIOAgent();
 			final IProject project = agent.getProject();
+			final String dir = ((EditorIOAgent) SSLLibrary.instance(env).getIOAgent())
+					.getProjectPath();
 
 			final Language oLang = LanguageRegistry.findLanguage(oLangName);
 			if (oLang == null)
 				return false;
 			final Descriptor oLangDescr = Environment.getDescriptor(oLang);
 			assert oLangDescr != null;
-			final StrategoObserver observer = oLangDescr.createService(StrategoObserver.class, null);
-			final IStrategoTerm outputTerm = observer.invoke(strategyName, inputTerm, project
-					.getLocation().toFile());
-			env.setCurrent(outputTerm);
-		} catch (ClassCastException cex) {
+			final StrategoObserver observer = oLangDescr
+					.createService(StrategoObserver.class, null);
+			observer.configureRuntime(project, dir);
+			observer.getRuntime().setCurrent(inputTerm);
+			result = observer.getRuntime().invoke(strategyName);
+			env.setCurrent(observer.getRuntime().current());
+			observer.uninitialize();
+		} catch (RuntimeException cex) {
 			Environment.logException(cex);
-			return false;
 		} catch (BadDescriptorException e) {
 			Environment.logException(e);
-			return false;
+		} catch (InterpreterException e) {
+			Environment.logException(e);
 		}
-		return true;
+		return result;
 	}
 }

From m.dejonge at tudelft.nl  Wed Mar 20 14:54:03 2013
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Wed, 20 Mar 2013 13:54:03 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26027 -
	spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project
Message-ID: <20130320135403.108597F8018@mx1.tudelft.nl>

Author: MaartjeDeJonge
Date: Wed Mar 20 13:54:01 2013
New Revision: 26027
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26027&sc=1

Log:


Modified:
   spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-refactoring-library.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-refactoring-library.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-refactoring-library.str	Tue Mar 19 23:00:05 2013	(r26026)
+++ spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-refactoring-library.str	Wed Mar 20 13:54:01 2013	(r26027)
@@ -19,6 +19,7 @@
   lib-refactoring/analysis-multifile.generated
   lib-refactoring/namebinding-preservation.generated
   lib-refactoring/correctness-preservation.generated
+  lib-refactoring/binding-violations.generated
 
 strategies
 

From gabrielkonat at gmail.com  Sat Mar 23 14:37:49 2013
From: gabrielkonat at gmail.com (Gabriël Konat)
Date: Sat, 23 Mar 2013 13:37:49 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26028 -
	spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index
Message-ID: <20130323133749.B747A7F8025@mx1.tudelft.nl>

Author: gkonat
Date: Sat Mar 23 13:37:47 2013
New Revision: 26028
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26028&sc=1

Log:
Fixed NPE in remove operation.

Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/Index.java

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/Index.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/Index.java	Wed Mar 20 13:54:01 2013	(r26027)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/Index.java	Sat Mar 23 13:37:47 2013	(r26028)
@@ -117,11 +117,12 @@
     public Collection<IndexEntry> remove(IStrategoAppl template, IndexPartitionDescriptor partitionDescriptor) {
         IndexURI uri = factory.createURIFromTemplate(template);
         IndexURI parentURI = uri.getParent(termFactory);
-        // TODO: Should this use innerEntries()/innerChildEntries()?
-        Multimap<IndexPartitionDescriptor, IndexEntry> entryValues = entries.get(uri);
+        
+        Multimap<IndexPartitionDescriptor, IndexEntry> entryValues = innerEntries(uri);
         Multimap<IndexPartitionDescriptor, IndexEntry> childValues = null;
         if(parentURI != null)
-            childValues = childs.get(parentURI);
+            childValues = innerChildEntries(uri.getParent(termFactory));
+        
         Collection<IndexEntry> removedEntries = entryValues.removeAll(partitionDescriptor);
 
         for(IndexEntry entry : removedEntries) {
@@ -136,10 +137,12 @@
     public Collection<IndexEntry> removeAll(IStrategoAppl template) {
         IndexURI uri = factory.createURIFromTemplate(template);
         IndexURI parentURI = uri.getParent(termFactory);
+        
         Multimap<IndexPartitionDescriptor, IndexEntry> entryValues = innerEntries(uri);
         Multimap<IndexPartitionDescriptor, IndexEntry> childValues = null;
         if(parentURI != null)
             childValues = innerChildEntries(uri.getParent(termFactory));
+        
         Collection<IndexEntry> removedEntries = entryValues.values();
         entries.remove(uri);
 

From gabrielkonat at gmail.com  Sun Mar 24 22:01:55 2013
From: gabrielkonat at gmail.com (Gabriël Konat)
Date: Sun, 24 Mar 2013 21:01:55 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26029 -
	spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index
Message-ID: <20130324210155.7A8252B8019@mx2.tudelft.nl>

Author: gkonat
Date: Sun Mar 24 21:01:53 2013
New Revision: 26029
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26029&sc=1

Log:
Added unload index primitive.

Added:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/LANG_index_unload.java
Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexLibrary.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexManager.java

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexLibrary.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexLibrary.java	Sat Mar 23 13:37:47 2013	(r26028)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexLibrary.java	Sun Mar 24 21:01:53 2013	(r26029)
@@ -30,6 +30,7 @@
         add(new LANG_index_get_file_revision(index));
         add(new LANG_index_set_current_file(index));
         add(new LANG_index_reload(index));
+        add(new LANG_index_unload(index));
     }
 
     public String getOperatorRegistryName() {

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexManager.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexManager.java	Sat Mar 23 13:37:47 2013	(r26028)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexManager.java	Sun Mar 24 21:01:53 2013	(r26029)
@@ -91,13 +91,13 @@
 
             for(TemplateWithPartitionDescriptor entry : currentIndex.getRemovedEntries())
                 index.remove(entry.getTemplate(), entry.getPartitionDescriptor());
-            
+
             for(IStrategoAppl template : currentIndex.getRemovedAllEntries())
                 index.removeAll(template);
 
             for(IndexEntry entry : transactionIndex.getAll())
                 index.add(entry);
-            
+
             transactionIndex.clearAll();
         } finally {
             transactionLock.writeLock().unlock();
@@ -130,7 +130,7 @@
 
     public void loadIndex(URI project, String language, ITermFactory factory, IOAgent agent) {
         synchronized(getSyncRoot()) {
-        	indexedLanguages.add(language);
+            indexedLanguages.add(language);
             WeakReference<IIndex> indexRef = indexCache.get(project);
             IIndex index = indexRef == null ? null : indexRef.get();
             if(index == null) {
@@ -146,6 +146,21 @@
         }
     }
 
+    public void unloadIndex(URI removedProject) {
+        WeakReference<IIndex> removedIndex = indexCache.remove(removedProject);
+
+        IIndex index = current.get();
+        if(index != null && index == removedIndex.get()) {
+            current.set(null);
+            currentPartition.set(null);
+        }
+
+        URI project = currentProject.get();
+        if(project != null && project.equals(removedProject)) {
+            currentProject.set(null);
+        }
+    }
+
     public IIndex tryReadFromFile(File file, ITermFactory factory, IOAgent agent) {
         IIndex index = new Index(); // TODO: Don't create concrete implementation here.
         index.initialize(factory, agent);

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/LANG_index_unload.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/LANG_index_unload.java	Sun Mar 24 21:01:53 2013	(r26029)
@@ -0,0 +1,35 @@
+package org.spoofax.interpreter.library.index;
+
+import static org.spoofax.interpreter.core.Tools.isTermString;
+
+import org.spoofax.interpreter.core.IContext;
+import org.spoofax.interpreter.library.AbstractPrimitive;
+import org.spoofax.interpreter.library.IOAgent;
+import org.spoofax.interpreter.library.ssl.SSLLibrary;
+import org.spoofax.interpreter.stratego.Strategy;
+import org.spoofax.interpreter.terms.IStrategoString;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+
+public class LANG_index_unload extends AbstractPrimitive {
+    private static String NAME = "LANG_index_unload";
+
+    private final IndexManager index;
+
+    public LANG_index_unload(IndexManager index) {
+        super(NAME, 0, 1);
+        this.index = index;
+    }
+
+    @Override
+    public boolean call(IContext env, Strategy[] svars, IStrategoTerm[] tvars) {
+        if(isTermString(tvars[0])) {
+            IStrategoString projectPath = (IStrategoString) tvars[0];
+            IOAgent agent = SSLLibrary.instance(env).getIOAgent();
+            IndexPartitionDescriptor project = IndexPartitionDescriptor.fromTerm(agent, projectPath);
+            index.unloadIndex(project.getURI());
+            return true;
+        } else {
+            return false;
+        }
+    }
+}

From gabrielkonat at gmail.com  Mon Mar 25 10:02:11 2013
From: gabrielkonat at gmail.com (Gabriël Konat)
Date: Mon, 25 Mar 2013 09:02:11 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26030 - in
	spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src:
	main/java/org/spoofax/interpreter/library/index
	test/java/org/spoofax/interpreter/library/index...
Message-ID: <20130325090211.C8EB8CC0EC@mx4.tudelft.nl>

Author: gkonat
Date: Mon Mar 25 09:02:10 2013
New Revision: 26030
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26030&sc=1

Log:
Added operation to remove one entry.

Added:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/LANG_index_remove_one.java
Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IIndex.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/Index.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexLibrary.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/TransactionIndex.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/IndexSymbolTableTest.java

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IIndex.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IIndex.java	Sun Mar 24 21:01:53 2013	(r26029)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IIndex.java	Mon Mar 25 09:02:10 2013	(r26030)
@@ -61,6 +61,14 @@
      * @param template The template to match entries against.
      */
     public abstract Collection<IndexEntry> removeAll(IStrategoAppl template);
+    
+    /**
+     * Removes one given entry. Compares both the URI and value of the entry.
+     * Warning: VERY SLOW!
+     * 
+     * @param entryTerm The term representing the entry to remove.
+     */
+    public abstract Collection<IndexEntry> removeOne(IStrategoAppl entryTerm);
 
     /**
      * Gets all entries that match given template.

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/Index.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/Index.java	Sun Mar 24 21:01:53 2013	(r26029)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/Index.java	Mon Mar 25 09:02:10 2013	(r26030)
@@ -1,5 +1,6 @@
 package org.spoofax.interpreter.library.index;
 
+import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
@@ -76,7 +77,7 @@
         return ret;
     }
 
-    public void add(IStrategoAppl entry, IndexPartitionDescriptor partitionDescriptor) {
+    private IndexEntry createEntry(IStrategoAppl entry, IndexPartitionDescriptor partitionDescriptor) {
         ensureInitialized();
 
         IStrategoConstructor constructor = entry.getConstructor();
@@ -84,10 +85,11 @@
         IStrategoTerm identifier = factory.getEntryIdentifier(entry);
         IStrategoTerm value = factory.getEntryValue(entry);
 
-        IndexEntry newEntry =
-            factory.createEntry(constructor, identifier, type, value, partitionDescriptor);
-
-        add(newEntry);
+        return factory.createEntry(constructor, identifier, type, value, partitionDescriptor);
+    }
+    
+    public void add(IStrategoAppl entry, IndexPartitionDescriptor partitionDescriptor) {
+        add(createEntry(entry, partitionDescriptor));
     }
 
     public void add(IndexEntry entry) {
@@ -149,6 +151,32 @@
         for(IndexEntry entry : removedEntries) {
             if(parentURI != null)
                 childValues.remove(entry.getPartition(), entry);
+            entriesPerPartitionDescriptor.remove(entry.getPartition(), entry);
+        }
+        
+        return removedEntries;
+    }
+    
+    public Collection<IndexEntry> removeOne(IStrategoAppl entryTerm) {
+        IndexURI uri = factory.createURIFromTemplate(entryTerm);
+        IndexURI parentURI = uri.getParent(termFactory);
+        
+        Multimap<IndexPartitionDescriptor, IndexEntry> entryValues = innerEntries(uri);
+        Multimap<IndexPartitionDescriptor, IndexEntry> childValues = null;
+        if(parentURI != null)
+            childValues = innerChildEntries(uri.getParent(termFactory));
+        
+        Collection<IndexEntry> removedEntries = new ArrayList<IndexEntry>(); 
+        IndexPartitionDescriptor[] partitions = entryValues.keySet().toArray(new IndexPartitionDescriptor[0]);
+        for(IndexPartitionDescriptor partition : partitions) {
+            IndexEntry entry = createEntry(entryTerm, partition);
+            if(entryValues.remove(partition, entry))
+                removedEntries.add(entry);
+        }
+        
+        for(IndexEntry entry : removedEntries) {
+            if(parentURI != null)
+                childValues.remove(entry.getPartition(), entry);
             entriesPerPartitionDescriptor.remove(entry.getPartition(), entry);
         }
         

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexLibrary.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexLibrary.java	Sun Mar 24 21:01:53 2013	(r26029)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexLibrary.java	Mon Mar 25 09:02:10 2013	(r26030)
@@ -13,6 +13,7 @@
         add(new LANG_index_add(index));
         add(new LANG_index_remove(index));
         add(new LANG_index_remove_all(index));
+        add(new LANG_index_remove_one(index));
         add(new LANG_index_clear_all(index));
         add(new LANG_index_clear_file(index));
         add(new LANG_index_get_all_files(index));

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/LANG_index_remove_one.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/LANG_index_remove_one.java	Mon Mar 25 09:02:10 2013	(r26030)
@@ -0,0 +1,32 @@
+package org.spoofax.interpreter.library.index;
+
+import static org.spoofax.interpreter.core.Tools.isTermAppl;
+
+import org.spoofax.interpreter.core.IContext;
+import org.spoofax.interpreter.library.AbstractPrimitive;
+import org.spoofax.interpreter.stratego.Strategy;
+import org.spoofax.interpreter.terms.IStrategoAppl;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+
+public class LANG_index_remove_one extends AbstractPrimitive {
+    private static String NAME = "LANG_index_remove_one";
+
+    private final IndexManager index;
+
+    public LANG_index_remove_one(IndexManager index) {
+        super(NAME, 0, 1);
+        this.index = index;
+    }
+
+    @Override
+    public boolean call(IContext env, Strategy[] svars, IStrategoTerm[] tvars) {
+        if(isTermAppl(tvars[0])) {
+            IStrategoAppl template = (IStrategoAppl) tvars[0];
+            IIndex ind = index.getCurrent();
+            ind.removeOne(template);
+            return true;
+        } else {
+            return false;
+        }
+    }
+}

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/TransactionIndex.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/TransactionIndex.java	Sun Mar 24 21:01:53 2013	(r26029)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/TransactionIndex.java	Mon Mar 25 09:02:10 2013	(r26030)
@@ -85,6 +85,12 @@
         removedAllEntries.add(template);
         return removed;
     }
+    
+    public Collection<IndexEntry> removeOne(IStrategoAppl entryTerm) {
+        Collection<IndexEntry> removed = transactionIndex.removeOne(entryTerm);
+        removedAllEntries.add(entryTerm);
+        return removed;  
+    }
 
     public IIndexEntryIterable get(final IStrategoAppl template) {
         return new AbstractIndexEntryIterable(getReadLock()) {

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/IndexSymbolTableTest.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/IndexSymbolTableTest.java	Sun Mar 24 21:01:53 2013	(r26029)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/IndexSymbolTableTest.java	Mon Mar 25 09:02:10 2013	(r26030)
@@ -480,6 +480,66 @@
     }
     
     @Test
+    public void removeOne() {
+        IStrategoTerm fileTerm1 = file("TestFile", "Partition", "1");
+        IStrategoTerm fileTerm2 = file("TestFile", "Partition", "2");
+        IndexPartitionDescriptor file1 = setupIndex(fileTerm1);
+        IndexPartitionDescriptor file2 = setupIndex(fileTerm2);
+
+        IStrategoAppl def = def("Entity", "CRM", "Person");
+        IStrategoAppl defData = defData(constructor("Type"), constructor("Type", str("String")) ,"Class", "java", "lang", "String");
+        IStrategoAppl defDataTemplate = defData(constructor("Type"), tuple() ,"Class", "java", "lang", "String");
+
+        startTransaction();
+
+        assertEquals(0, size(index.get(def)));
+        assertEquals(0, size(index.get(defData)));
+        assertEquals(0, size(index.getInPartition(file1)));
+        assertEquals(0, size(index.getInPartition(file2)));
+
+        index.add(def, file1);
+        index.add(def, file2);
+        index.add(defData, file1);
+        index.add(defData, file2);
+        
+        index.removeOne(defDataTemplate);
+        
+        IIndexEntryIterable ret1 = index.getInPartition(file1);
+        IIndexEntryIterable ret2 = index.getInPartition(file2);
+
+        try {
+            ret1.lock();
+            ret2.lock();
+
+            assertTrue(containsEntry(ret1, def));
+            assertTrue(containsEntry(ret2, def));
+            assertTrue(containsEntry(ret1, defData));
+            assertTrue(containsEntry(ret2, defData));
+        } finally {
+            ret1.unlock();
+            ret2.unlock();
+        }
+        
+        index.removeOne(defData);
+        
+        IIndexEntryIterable ret3 = index.getInPartition(file1);
+        IIndexEntryIterable ret4 = index.getInPartition(file2);
+
+        try {
+            ret3.lock();
+            ret4.lock();
+
+            assertTrue(containsEntry(ret3, def));
+            assertTrue(containsEntry(ret4, def));
+            assertFalse(containsEntry(ret3, defData));
+            assertFalse(containsEntry(ret4, defData));
+        } finally {
+            ret3.unlock();
+            ret4.unlock();
+        }
+    }
+    
+    @Test
     public void clear() {
         IndexPartitionDescriptor file1 = setupIndex(file("TestFile", "Partition", "1"));
         IndexPartitionDescriptor file2 = setupIndex(file("TestFile", "Partition", "2"));

From gabrielkonat at gmail.com  Wed Mar 27 19:55:18 2013
From: gabrielkonat at gmail.com (Gabriël Konat)
Date: Wed, 27 Mar 2013 18:55:18 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26031 -
	spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/main/java/org/spoofax/interpreter/library/ssl
Message-ID: <20130327185518.A52007F8042@mx1.tudelft.nl>

Author: gkonat
Date: Wed Mar 27 18:55:16 2013
New Revision: 26031
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26031&sc=1

Log:
Added get any term method to StrategoSet

Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/main/java/org/spoofax/interpreter/library/ssl/StrategoSet.java

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/main/java/org/spoofax/interpreter/library/ssl/StrategoSet.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/main/java/org/spoofax/interpreter/library/ssl/StrategoSet.java	Mon Mar 25 09:02:10 2013	(r26030)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/main/java/org/spoofax/interpreter/library/ssl/StrategoSet.java	Wed Mar 27 18:55:16 2013	(r26031)
@@ -87,6 +87,10 @@
             r.add(x.t);
         return r;
     }
+    
+    public IStrategoTerm any() {
+        return map.keySet().iterator().next();
+    }
 
     public boolean containsKey(IStrategoTerm t) {
         return map.containsKey(t);

From v.vergu+vc at gmail.com  Thu Mar 28 18:11:28 2013
From: v.vergu+vc at gmail.com (Vlad Vergu)
Date: Thu, 28 Mar 2013 17:11:28 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26032 -
	spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/statistics
Message-ID: <20130328171128.7F1F77F8007@mx1.tudelft.nl>

Author: VladVergu
Date: Thu Mar 28 17:11:27 2013
New Revision: 26032
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26032&sc=1

Log:
Fix bad assertion

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/statistics/EditStreakRecorder.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/statistics/EditStreakRecorder.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/statistics/EditStreakRecorder.java	Wed Mar 27 18:55:16 2013	(r26031)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/statistics/EditStreakRecorder.java	Thu Mar 28 17:11:27 2013	(r26032)
@@ -81,8 +81,7 @@
 	 * @param ast
 	 */
 	public void recordEdit(IStrategoTerm ast) {
-		assert ast != null;
-		if (!cfgEnabled || this.thread == null || !this.thread.isAlive() || doStop) {
+		if (ast == null || !cfgEnabled || this.thread == null || !this.thread.isAlive() || doStop) {
 			return;
 		}
 		queue.add(new RecordedEdit(ast, System.currentTimeMillis()));

From v.vergu+vc at gmail.com  Fri Mar 29 13:54:17 2013
From: v.vergu+vc at gmail.com (Vlad Vergu)
Date: Fri, 29 Mar 2013 12:54:17 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26033 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.stratego
Message-ID: <20130329125417.29E657F8011@mx1.tudelft.nl>

Author: VladVergu
Date: Fri Mar 29 12:54:15 2013
New Revision: 26033
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26033&sc=1

Log:
Change Ant build file to load the editor building

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/build.main.xml

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/build.main.xml
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/build.main.xml	Thu Mar 28 17:11:27 2013	(r26032)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/build.main.xml	Fri Mar 29 12:54:15 2013	(r26033)
@@ -1,41 +1,44 @@
 <?xml version="1.0" encoding="UTF-8" ?>
 
 <project name="Stratego-Sugar" default="all">
-        
-        <!-- Key input modules -->
-        <property name="sdfmodule" value="Stratego-Sugar"/>
-        <property name="esvmodule" value="Stratego-Sugar"/>
-        <property name="strmodule" value="stratego_sugar"/>
-    
-        <!-- Project directories -->
-        <property name="trans" location="trans"/>
-        <property name="src-gen" location="editor/java"/>
-        <property name="syntax" location="syntax"/>
-        <property name="include" location="include"/>
-        <property name="lib" location="lib"/>
-        <property name="build" location="bin"/>
-        <property name="dist" location="bin/dist"/>
-        
-        <!-- Imports -->
-        <property name="build.sdf.imports" value=""/>
-        <property name="build.stratego.args" value="--library
+
+	<!-- Key input modules -->
+	<property name="sdfmodule" value="Stratego-Sugar" />
+	<property name="esvmodule" value="Stratego-Sugar" />
+	<property name="strmodule" value="stratego_sugar" />
+
+	<!-- Project directories -->
+	<property name="trans" location="trans" />
+	<property name="src-gen" location="editor/java" />
+	<property name="syntax" location="syntax" />
+	<property name="include" location="include" />
+	<property name="lib" location="lib" />
+	<property name="build" location="bin" />
+	<property name="dist" location="bin/dist" />
+
+	<!-- Imports -->
+	<property name="build.sdf.imports" value="" />
+	<property name="build.stratego.args"
+	          value="--library
                         -I &quot;${trans}&quot; -I &quot;${basedir}&quot;
-                        -la stratego-lib -la stratego-sglr -la stratego-gpp -la stratego-xtc -la stratego-aterm -la strc"/>
-        
-        <property name="externaldef" location="syntax/Stratego-Sugar.def"/>
-        <!-- External .def and .jar locations
+                        -la stratego-lib -la stratego-sglr -la stratego-gpp -la stratego-xtc -la stratego-aterm -la strc" />
+
+	<property name="externaldef" location="syntax/Stratego-Sugar.def" />
+	<!-- External .def and .jar locations
         <property name="externaljar" value="../lib.jar"/>
         <property name="externaljarflags" value="-la org.lib"/>
         -->
-    
-        <!-- Environment configuration for command-line builds -->
-        <condition property="build.strategoxt.sdf" value="${eclipse.spoofaximp.nativeprefix}" else="">
-            <isset property="eclipse.spoofaximp.nativeprefix"/>
-        </condition>
-        <property name="build.strategoxt.stratego" location="${user.home}/.nix-profile/bin"/>
-    
-        <import file="build.generated.xml"/>
-
-        <!-- Main target -->
-        <target name="all" depends="utils-files,sdf2table,ppgen.helper.fallback,pppack.helper.fallback,java.jar,stratego.jar,sdf2imp"/>
-    </project>
+
+	<!-- Environment configuration for command-line builds -->
+	<condition property="build.strategoxt.sdf" value="${eclipse.spoofaximp.nativeprefix}" else="">
+		<isset property="eclipse.spoofaximp.nativeprefix" />
+	</condition>
+	<property name="build.strategoxt.stratego" location="${user.home}/.nix-profile/bin" />
+
+	<import file="build.generated.xml" />
+
+	<!-- Main target -->
+	<target name="all"
+	        depends="utils-files,sdf2table,ppgen.helper.fallback,pppack.helper.fallback,java.jar,stratego.jar,sdf2imp,refresh,
+		      sdf2imp.eclipse.load" />
+</project>

From v.vergu+vc at gmail.com  Fri Mar 29 15:38:17 2013
From: v.vergu+vc at gmail.com (Vlad Vergu)
Date: Fri, 29 Mar 2013 14:38:17 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26034 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.stratego
Message-ID: <20130329143817.116C87F8006@mx1.tudelft.nl>

Author: VladVergu
Date: Fri Mar 29 14:38:15 2013
New Revision: 26034
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26034&sc=1

Log:
Reverting previous commit, perhaps resolving build issue.

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/build.main.xml

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/build.main.xml
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/build.main.xml	Fri Mar 29 12:54:15 2013	(r26033)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/build.main.xml	Fri Mar 29 14:38:15 2013	(r26034)
@@ -39,6 +39,5 @@
 
 	<!-- Main target -->
 	<target name="all"
-	        depends="utils-files,sdf2table,ppgen.helper.fallback,pppack.helper.fallback,java.jar,stratego.jar,sdf2imp,refresh,
-		      sdf2imp.eclipse.load" />
+	        depends="utils-files,sdf2table,ppgen.helper.fallback,pppack.helper.fallback,java.jar,stratego.jar,sdf2imp" />
 </project>

