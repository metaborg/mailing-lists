From gabrielkonat at gmail.com  Tue Apr  2 20:39:15 2013
From: gabrielkonat at gmail.com (GabriÃ«l Konat)
Date: Tue, 02 Apr 2013 18:39:15 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26035 -
	spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index
Message-ID: <20130402183916.0BBAFCC153@mx4.tudelft.nl>

Author: gkonat
Date: Tue Apr  2 18:39:14 2013
New Revision: 26035
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26035&sc=1

Log:
Added primitives to get an entry diff from the index

Added:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/LANG_index_start_collection.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/LANG_index_stop_collection.java
Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IIndex.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/Index.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexLibrary.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/TransactionIndex.java

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IIndex.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IIndex.java	Fri Mar 29 14:38:15 2013	(r26034)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IIndex.java	Tue Apr  2 18:39:14 2013	(r26035)
@@ -6,146 +6,158 @@
 import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.IStrategoTuple;
 import org.spoofax.interpreter.terms.ITermFactory;
 
 /**
  * @author Gabri?l Konat
  */
 public interface IIndex {
-    /**
-     * Initializes this index.
-     */
-    public abstract void initialize(ITermFactory factory, IOAgent agent);
-
-    /**
-     * Gets the entry factory used by this index.
-     */
-    public abstract IndexEntryFactory getFactory();
-
-    /**
-     * Adds a new entry to the index.
-     * 
-     * @param entry The entry to add.
-     * @param partitionDescriptor The partition to associate the entry with.
-     */
-    public abstract void add(IStrategoAppl entry, IndexPartitionDescriptor partitionDescriptor);
-
-    /**
-     * Adds a new entry to the index.
-     * 
-     * @param entry The entry to add.
-     */
-    public abstract void add(IndexEntry entry);
-
-    /**
-     * Adds a list of entries to the index.
-     * 
-     * @param entries The entries to add.
-     * @param partitionDescriptor The partition to associate the entries with.
-     */
-    public abstract void addAll(IStrategoList entries, IndexPartitionDescriptor partitionDescriptor);
-
-    /**
-     * Removes all entries that match given template and are from given partition. 
-     * Warning: VERY SLOW!
-     * 
-     * @param template The template to match entries against.
-     * @param partitionDescriptor The partition entries will be removed from.
-     */
-    public abstract Collection<IndexEntry> remove(IStrategoAppl template, IndexPartitionDescriptor partitionDescriptor);
-    
-    /**
-     * Removes all entries that match given template (from all partitions).
-     * Warning: Quite slow!
-     * 
-     * @param template The template to match entries against.
-     */
-    public abstract Collection<IndexEntry> removeAll(IStrategoAppl template);
-    
-    /**
-     * Removes one given entry. Compares both the URI and value of the entry.
-     * Warning: VERY SLOW!
-     * 
-     * @param entryTerm The term representing the entry to remove.
-     */
-    public abstract Collection<IndexEntry> removeOne(IStrategoAppl entryTerm);
-
-    /**
-     * Gets all entries that match given template.
-     * 
-     * @param template The template to match entries against.
-     */
-    public abstract IIndexEntryIterable get(IStrategoAppl template);
-
-    /**
-     * Gets all entries.
-     */
-    public abstract IIndexEntryIterable getAll();
-
-    /**
-     * Gets all child entries for URI in given template.
-     * 
-     * @param template The template to match entries against.
-     */
-    public abstract IIndexEntryIterable getChildren(IStrategoAppl template);
-
-    /**
-     * Gets all entries for given partition descriptor.
-     * 
-     * @param partitionDescriptor The partition descriptor to match entries against.
-     */
-    public abstract IIndexEntryIterable getInPartition(IndexPartitionDescriptor partitionDescriptor);
-
-    /**
-     * Gets all partitions that contain entries that match given template. Returned collection is a set of partitions,
-     * it does not contain duplicates.
-     * 
-     * @param template The template to match entries against.
-     */
-    public abstract Collection<IndexPartitionDescriptor> getPartitionsOf(IStrategoAppl template);
-
-    /**
-     * Gets an index partition for given partition descriptor.
-     * 
-     * @param partitionDescriptor A partition descriptor.
-     */
-    public abstract IndexPartition getPartition(IndexPartitionDescriptor partitionDescriptor);
-
-    /**
-     * Gets an index partition descriptor for given partition term.
-     * 
-     * @param partitionTerm A string or (string, string) tuple with a file name or the file name and partition
-     *            identifier.
-     */
-    public abstract IndexPartitionDescriptor getPartitionDescriptor(IStrategoTerm partitionTerm);
-
-    /**
-     * Gets all partitions that are in the index.
-     */
-    public abstract Collection<IndexPartition> getAllPartitions();
-
-    /**
-     * Gets all partition descriptors that are in the index.
-     */
-    public abstract Collection<IndexPartitionDescriptor> getAllPartitionDescriptors();
-    
-    /**
-     * Removes all entries in given partition term and removes the partition itself.
-     * 
-     * @param partitionTerm A string or (string, string) tuple with a file name or the file name and partition
-     *            identifier.
-     */
-    public abstract void clearPartition(IStrategoTerm partitionTerm);
-
-    /**
-     * Removes all entries for given partition and removes the partition itself.
-     * 
-     * @param partitionDescriptor A partition descriptor.
-     */
-    public abstract void clearPartition(IndexPartitionDescriptor partitionDescriptor);
-
-    /**
-     * Clears the entire index.
-     */
-    public abstract void clearAll();
+	/**
+	 * Initializes this index.
+	 */
+	public abstract void initialize(ITermFactory factory, IOAgent agent);
+
+	/**
+	 * Gets the entry factory used by this index.
+	 */
+	public abstract IndexEntryFactory getFactory();
+
+	/**
+	 * Starts collection for given partition.
+	 * 
+	 * @param partitionDescriptor
+	 */
+	public abstract void startCollection(IndexPartitionDescriptor partitionDescriptor);
+
+	/**
+	 * Stops collection for given partition, returning the entries that were removed and added during collection.
+	 * 
+	 * @return The removed and added entries as a Stratego tuple.
+	 */
+	public abstract IStrategoTuple stopCollection();
+
+	/**
+	 * Adds a new entry to the index.
+	 * 
+	 * @param entry The entry to add.
+	 * @param partitionDescriptor The partition to associate the entry with.
+	 */
+	public abstract void add(IStrategoAppl entry, IndexPartitionDescriptor partitionDescriptor);
+
+	/**
+	 * Adds a new entry to the index.
+	 * 
+	 * @param entry The entry to add.
+	 */
+	public abstract void add(IndexEntry entry);
+
+	/**
+	 * Adds a list of entries to the index.
+	 * 
+	 * @param entries The entries to add.
+	 * @param partitionDescriptor The partition to associate the entries with.
+	 */
+	public abstract void addAll(IStrategoList entries, IndexPartitionDescriptor partitionDescriptor);
+
+	/**
+	 * Removes all entries that match given template and are from given partition. Warning: VERY SLOW!
+	 * 
+	 * @param template The template to match entries against.
+	 * @param partitionDescriptor The partition entries will be removed from.
+	 */
+	public abstract Collection<IndexEntry> remove(IStrategoAppl template, IndexPartitionDescriptor partitionDescriptor);
+
+	/**
+	 * Removes all entries that match given template (from all partitions). Warning: Quite slow!
+	 * 
+	 * @param template The template to match entries against.
+	 */
+	public abstract Collection<IndexEntry> removeAll(IStrategoAppl template);
+
+	/**
+	 * Removes one given entry. Compares both the URI and value of the entry. Warning: VERY SLOW!
+	 * 
+	 * @param entryTerm The term representing the entry to remove.
+	 */
+	public abstract Collection<IndexEntry> removeOne(IStrategoAppl entryTerm);
+
+	/**
+	 * Gets all entries that match given template.
+	 * 
+	 * @param template The template to match entries against.
+	 */
+	public abstract IIndexEntryIterable get(IStrategoAppl template);
+
+	/**
+	 * Gets all entries.
+	 */
+	public abstract IIndexEntryIterable getAll();
+
+	/**
+	 * Gets all child entries for URI in given template.
+	 * 
+	 * @param template The template to match entries against.
+	 */
+	public abstract IIndexEntryIterable getChildren(IStrategoAppl template);
+
+	/**
+	 * Gets all entries for given partition descriptor.
+	 * 
+	 * @param partitionDescriptor The partition descriptor to match entries against.
+	 */
+	public abstract IIndexEntryIterable getInPartition(IndexPartitionDescriptor partitionDescriptor);
+
+	/**
+	 * Gets all partitions that contain entries that match given template. Returned collection is a set of partitions,
+	 * it does not contain duplicates.
+	 * 
+	 * @param template The template to match entries against.
+	 */
+	public abstract Collection<IndexPartitionDescriptor> getPartitionsOf(IStrategoAppl template);
+
+	/**
+	 * Gets an index partition for given partition descriptor.
+	 * 
+	 * @param partitionDescriptor A partition descriptor.
+	 */
+	public abstract IndexPartition getPartition(IndexPartitionDescriptor partitionDescriptor);
+
+	/**
+	 * Gets an index partition descriptor for given partition term.
+	 * 
+	 * @param partitionTerm A string or (string, string) tuple with a file name or the file name and partition
+	 *            identifier.
+	 */
+	public abstract IndexPartitionDescriptor getPartitionDescriptor(IStrategoTerm partitionTerm);
+
+	/**
+	 * Gets all partitions that are in the index.
+	 */
+	public abstract Collection<IndexPartition> getAllPartitions();
+
+	/**
+	 * Gets all partition descriptors that are in the index.
+	 */
+	public abstract Collection<IndexPartitionDescriptor> getAllPartitionDescriptors();
+
+	/**
+	 * Removes all entries in given partition term and removes the partition itself.
+	 * 
+	 * @param partitionTerm A string or (string, string) tuple with a file name or the file name and partition
+	 *            identifier.
+	 */
+	public abstract void clearPartition(IStrategoTerm partitionTerm);
+
+	/**
+	 * Removes all entries for given partition and removes the partition itself.
+	 * 
+	 * @param partitionDescriptor A partition descriptor.
+	 */
+	public abstract void clearPartition(IndexPartitionDescriptor partitionDescriptor);
+
+	/**
+	 * Clears the entire index.
+	 */
+	public abstract void clearAll();
 }

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/Index.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/Index.java	Fri Mar 29 14:38:15 2013	(r26034)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/Index.java	Tue Apr  2 18:39:14 2013	(r26035)
@@ -14,271 +14,302 @@
 import org.spoofax.interpreter.terms.IStrategoConstructor;
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.IStrategoTuple;
 import org.spoofax.interpreter.terms.ITermFactory;
 
 import com.google.common.collect.ArrayListMultimap;
+import com.google.common.collect.HashMultiset;
 import com.google.common.collect.LinkedHashMultimap;
 import com.google.common.collect.Multimap;
+import com.google.common.collect.Multiset;
+import com.google.common.collect.Multisets;
 
 /**
  * @author Gabri?l Konat
  */
 public class Index implements IIndex {
-    public static final boolean DEBUG_ENABLED = Index.class.desiredAssertionStatus();
+	public static final boolean DEBUG_ENABLED = Index.class.desiredAssertionStatus();
 
-    private static final int EXPECTED_DISTINCT_PARTITIONS = 100;
-    private static final int EXPECTED_VALUES_PER_PARTITION = 1000;
+	private static final int EXPECTED_DISTINCT_PARTITIONS = 100;
+	private static final int EXPECTED_VALUES_PER_PARTITION = 1000;
 
-    private final ConcurrentHashMap<IndexURI, Multimap<IndexPartitionDescriptor, IndexEntry>> entries =
-        new ConcurrentHashMap<IndexURI, Multimap<IndexPartitionDescriptor, IndexEntry>>();
-    private final ConcurrentHashMap<IndexURI, Multimap<IndexPartitionDescriptor, IndexEntry>> childs =
-        new ConcurrentHashMap<IndexURI, Multimap<IndexPartitionDescriptor, IndexEntry>>();
-    private final Multimap<IndexPartitionDescriptor, IndexEntry> entriesPerPartitionDescriptor = LinkedHashMultimap
-        .create();
-    private final Map<IndexPartitionDescriptor, IndexPartition> partitions =
-        new HashMap<IndexPartitionDescriptor, IndexPartition>();
-
-    private IOAgent agent;
-    private ITermFactory termFactory;
-    private IndexEntryFactory factory;
-
-    public void initialize(ITermFactory factory, IOAgent agent) {
-        this.agent = agent;
-        this.factory = new IndexEntryFactory(factory);
-        this.termFactory = factory;
-    }
-
-    private void ensureInitialized() {
-        if(factory == null)
-            throw new IllegalStateException("Index not initialized");
-    }
-
-    public IndexEntryFactory getFactory() {
-        return factory;
-    }
-
-    private Multimap<IndexPartitionDescriptor, IndexEntry> innerEntries(IndexURI uri) {
-        Multimap<IndexPartitionDescriptor, IndexEntry> innerMap =
-            ArrayListMultimap.create(EXPECTED_DISTINCT_PARTITIONS, EXPECTED_VALUES_PER_PARTITION);
-
-        Multimap<IndexPartitionDescriptor, IndexEntry> ret = entries.putIfAbsent(uri, innerMap);
-        if(ret == null)
-            ret = innerMap;
-        return ret;
-    }
-
-    private Multimap<IndexPartitionDescriptor, IndexEntry> innerChildEntries(IndexURI uri) {
-        Multimap<IndexPartitionDescriptor, IndexEntry> innerMap =
-            ArrayListMultimap.create(EXPECTED_DISTINCT_PARTITIONS, EXPECTED_VALUES_PER_PARTITION);
-
-        Multimap<IndexPartitionDescriptor, IndexEntry> ret = childs.putIfAbsent(uri, innerMap);
-        if(ret == null)
-            ret = innerMap;
-        return ret;
-    }
-
-    private IndexEntry createEntry(IStrategoAppl entry, IndexPartitionDescriptor partitionDescriptor) {
-        ensureInitialized();
-
-        IStrategoConstructor constructor = entry.getConstructor();
-        IStrategoTerm type = factory.getEntryType(entry);
-        IStrategoTerm identifier = factory.getEntryIdentifier(entry);
-        IStrategoTerm value = factory.getEntryValue(entry);
-
-        return factory.createEntry(constructor, identifier, type, value, partitionDescriptor);
-    }
-    
-    public void add(IStrategoAppl entry, IndexPartitionDescriptor partitionDescriptor) {
-        add(createEntry(entry, partitionDescriptor));
-    }
-
-    public void add(IndexEntry entry) {
-        final IndexPartitionDescriptor partition = entry.getPartition();
-        final IndexURI uri = entry.getKey();
-
-        addOrGetPartition(partition);
-
-        innerEntries(uri).put(partition, entry);
-
-        // Add entry to children.
-        IndexURI parent = uri.getParent(termFactory);
-        if(parent != null)
-            innerChildEntries(parent).put(partition, entry);
-
-        // Add entry to partitions.
-        entriesPerPartitionDescriptor.put(partition, entry);
-    }
-
-    public void addAll(IStrategoList entries, IndexPartitionDescriptor partitionDescriptor) {
-        while(!entries.isEmpty()) {
-            add((IStrategoAppl) entries.head(), partitionDescriptor);
-            entries = entries.tail();
-        }
-    }
-
-    public Collection<IndexEntry> remove(IStrategoAppl template, IndexPartitionDescriptor partitionDescriptor) {
-        IndexURI uri = factory.createURIFromTemplate(template);
-        IndexURI parentURI = uri.getParent(termFactory);
-        
-        Multimap<IndexPartitionDescriptor, IndexEntry> entryValues = innerEntries(uri);
-        Multimap<IndexPartitionDescriptor, IndexEntry> childValues = null;
-        if(parentURI != null)
-            childValues = innerChildEntries(uri.getParent(termFactory));
-        
-        Collection<IndexEntry> removedEntries = entryValues.removeAll(partitionDescriptor);
-
-        for(IndexEntry entry : removedEntries) {
-            if(parentURI != null)
-                childValues.remove(partitionDescriptor, entry);
-            entriesPerPartitionDescriptor.remove(partitionDescriptor, entry);
-        }
-        
-        return removedEntries;
-    }
-    
-    public Collection<IndexEntry> removeAll(IStrategoAppl template) {
-        IndexURI uri = factory.createURIFromTemplate(template);
-        IndexURI parentURI = uri.getParent(termFactory);
-        
-        Multimap<IndexPartitionDescriptor, IndexEntry> entryValues = innerEntries(uri);
-        Multimap<IndexPartitionDescriptor, IndexEntry> childValues = null;
-        if(parentURI != null)
-            childValues = innerChildEntries(uri.getParent(termFactory));
-        
-        Collection<IndexEntry> removedEntries = entryValues.values();
-        entries.remove(uri);
-
-        for(IndexEntry entry : removedEntries) {
-            if(parentURI != null)
-                childValues.remove(entry.getPartition(), entry);
-            entriesPerPartitionDescriptor.remove(entry.getPartition(), entry);
-        }
-        
-        return removedEntries;
-    }
-    
-    public Collection<IndexEntry> removeOne(IStrategoAppl entryTerm) {
-        IndexURI uri = factory.createURIFromTemplate(entryTerm);
-        IndexURI parentURI = uri.getParent(termFactory);
-        
-        Multimap<IndexPartitionDescriptor, IndexEntry> entryValues = innerEntries(uri);
-        Multimap<IndexPartitionDescriptor, IndexEntry> childValues = null;
-        if(parentURI != null)
-            childValues = innerChildEntries(uri.getParent(termFactory));
-        
-        Collection<IndexEntry> removedEntries = new ArrayList<IndexEntry>(); 
-        IndexPartitionDescriptor[] partitions = entryValues.keySet().toArray(new IndexPartitionDescriptor[0]);
-        for(IndexPartitionDescriptor partition : partitions) {
-            IndexEntry entry = createEntry(entryTerm, partition);
-            if(entryValues.remove(partition, entry))
-                removedEntries.add(entry);
-        }
-        
-        for(IndexEntry entry : removedEntries) {
-            if(parentURI != null)
-                childValues.remove(entry.getPartition(), entry);
-            entriesPerPartitionDescriptor.remove(entry.getPartition(), entry);
-        }
-        
-        return removedEntries;
-    }
-
-    public IIndexEntryIterable get(IStrategoAppl template) {
-        IndexURI uri = factory.createURIFromTemplate(template);
-        return getEntryIterable(innerEntries(uri).values());
-    }
-
-    public IIndexEntryIterable getChildren(IStrategoAppl template) {
-        IndexURI uri = factory.createURIFromTemplate(template);
-        return getEntryIterable(innerChildEntries(uri).values());
-    }
-
-    public IIndexEntryIterable getInPartition(IndexPartitionDescriptor partitionDescriptor) {
-        return getEntryIterable(entriesPerPartitionDescriptor.get(partitionDescriptor));
-    }
-
-    public Collection<IndexPartitionDescriptor> getPartitionsOf(IStrategoAppl template) {
-        IndexURI uri = factory.createURIFromTemplate(template);
-        return getCollection(innerEntries(uri).keySet());
-    }
-
-    public IIndexEntryIterable getAll() {
-        List<IndexEntry> allEntries = new LinkedList<IndexEntry>();
-        Collection<Multimap<IndexPartitionDescriptor, IndexEntry>> values = entries.values();
-        for(Multimap<IndexPartitionDescriptor, IndexEntry> map : values)
-            allEntries.addAll(map.values());
-
-        return getEntryIterable(allEntries);
-    }
-
-    public IndexPartition getPartition(IndexPartitionDescriptor partitionDescriptor) {
-        return addOrGetPartition(partitionDescriptor);
-    }
-
-    private IndexPartition addOrGetPartition(IndexPartitionDescriptor partitionDescriptor) {
-        IndexPartition partition = partitions.get(partitionDescriptor);
-        if(partition == null) {
-            partition = new IndexPartition(partitionDescriptor, null);
-            partitions.put(partitionDescriptor, partition);
-        }
-        return partition;
-    }
-
-    public IndexPartitionDescriptor getPartitionDescriptor(IStrategoTerm partitionTerm) {
-        return IndexPartitionDescriptor.fromTerm(agent, partitionTerm);
-    }
-
-    public void clearPartition(IStrategoTerm partitionTerm) {
-        clearPartitionInternal(getPartitionDescriptor(partitionTerm));
-    }
-
-    public void clearPartition(IndexPartitionDescriptor partitionDescriptor) {
-        clearPartitionInternal(partitionDescriptor);
-    }
-
-    private void clearPartitionInternal(IndexPartitionDescriptor partitionDescriptor) {
-        assert partitionDescriptor.getPartition() != null || partitionDescriptor.getURI() != null;
-
-        Collection<Multimap<IndexPartitionDescriptor, IndexEntry>> entryValues = entries.values();
-        for(Multimap<IndexPartitionDescriptor, IndexEntry> map : entryValues)
-            map.removeAll(partitionDescriptor);
-
-        Collection<Multimap<IndexPartitionDescriptor, IndexEntry>> childValues = childs.values();
-        for(Multimap<IndexPartitionDescriptor, IndexEntry> map : childValues)
-            map.removeAll(partitionDescriptor);
-
-        entriesPerPartitionDescriptor.removeAll(partitionDescriptor);
-        
-        assert !getInPartition(partitionDescriptor).iterator().hasNext();
-    }
-
-    public Collection<IndexPartition> getAllPartitions() {
-        return getCollection(partitions.values());
-    }
-
-    public Collection<IndexPartitionDescriptor> getAllPartitionDescriptors() {
-        return getCollection(partitions.keySet());
-    }
-
-    public void clearAll() {
-        entries.clear();
-        childs.clear();
-        entriesPerPartitionDescriptor.clear();
-        partitions.clear();
-    }
-
-    private static final IIndexEntryIterable getEntryIterable(Collection<IndexEntry> collection) {
-        return new IndexEntryIterable(collection, null);
-    }
-    
-    /**
-     * Returns an unmodifiable collection if in debug mode, or the collection if not.
-     */
-    private static final <T> Collection<T> getCollection(Collection<T> collection) {
-        if(DEBUG_ENABLED) {
-            return Collections.unmodifiableCollection(collection);
-        } else {
-            return collection;
-        }
-    }
+	private final ConcurrentHashMap<IndexURI, Multimap<IndexPartitionDescriptor, IndexEntry>> entries =
+		new ConcurrentHashMap<IndexURI, Multimap<IndexPartitionDescriptor, IndexEntry>>();
+	private final ConcurrentHashMap<IndexURI, Multimap<IndexPartitionDescriptor, IndexEntry>> childs =
+		new ConcurrentHashMap<IndexURI, Multimap<IndexPartitionDescriptor, IndexEntry>>();
+	private final Multimap<IndexPartitionDescriptor, IndexEntry> entriesPerPartitionDescriptor = LinkedHashMultimap
+		.create();
+	private final Map<IndexPartitionDescriptor, IndexPartition> partitions =
+		new HashMap<IndexPartitionDescriptor, IndexPartition>();
+
+	private final Multiset<IndexEntry> addedEntries = HashMultiset.create();
+	private final Multiset<IndexEntry> removedEntries = HashMultiset.create();
+	private final Multiset<IndexEntry> oldEntries = HashMultiset.create();
+	private boolean inCollection = false;
+
+	private IOAgent agent;
+	private ITermFactory termFactory;
+	private IndexEntryFactory factory;
+
+	public void initialize(ITermFactory factory, IOAgent agent) {
+		this.agent = agent;
+		this.factory = new IndexEntryFactory(factory);
+		this.termFactory = factory;
+	}
+
+	private void ensureInitialized() {
+		if(factory == null)
+			throw new IllegalStateException("Index not initialized");
+	}
+
+	public IndexEntryFactory getFactory() {
+		return factory;
+	}
+
+	private Multimap<IndexPartitionDescriptor, IndexEntry> innerEntries(IndexURI uri) {
+		Multimap<IndexPartitionDescriptor, IndexEntry> innerMap =
+			ArrayListMultimap.create(EXPECTED_DISTINCT_PARTITIONS, EXPECTED_VALUES_PER_PARTITION);
+
+		Multimap<IndexPartitionDescriptor, IndexEntry> ret = entries.putIfAbsent(uri, innerMap);
+		if(ret == null)
+			ret = innerMap;
+		return ret;
+	}
+
+	private Multimap<IndexPartitionDescriptor, IndexEntry> innerChildEntries(IndexURI uri) {
+		Multimap<IndexPartitionDescriptor, IndexEntry> innerMap =
+			ArrayListMultimap.create(EXPECTED_DISTINCT_PARTITIONS, EXPECTED_VALUES_PER_PARTITION);
+
+		Multimap<IndexPartitionDescriptor, IndexEntry> ret = childs.putIfAbsent(uri, innerMap);
+		if(ret == null)
+			ret = innerMap;
+		return ret;
+	}
+
+	private IndexEntry createEntry(IStrategoAppl entry, IndexPartitionDescriptor partitionDescriptor) {
+		ensureInitialized();
+
+		IStrategoConstructor constructor = entry.getConstructor();
+		IStrategoTerm type = factory.getEntryType(entry);
+		IStrategoTerm identifier = factory.getEntryIdentifier(entry);
+		IStrategoTerm value = factory.getEntryValue(entry);
+
+		return factory.createEntry(constructor, identifier, type, value, partitionDescriptor);
+	}
+
+	public void startCollection(IndexPartitionDescriptor partitionDescriptor) {
+		addedEntries.clear();
+		removedEntries.clear();
+		removedEntries.addAll(entriesPerPartitionDescriptor.get(partitionDescriptor));
+		oldEntries.addAll(entriesPerPartitionDescriptor.get(partitionDescriptor));
+		clearPartition(partitionDescriptor);
+		inCollection = true;
+	}
+
+	public IStrategoTuple stopCollection() {
+		Multisets.removeOccurrences(addedEntries, oldEntries);
+		inCollection = false;
+
+		// TODO: Use an IStrategoList implementation that iterates over the collections instead of constructing it.
+		return termFactory.makeTuple(IndexEntry.toTerms(termFactory, removedEntries),
+			IndexEntry.toTerms(termFactory, addedEntries));
+	}
+
+	public void add(IStrategoAppl entry, IndexPartitionDescriptor partitionDescriptor) {
+		add(createEntry(entry, partitionDescriptor));
+	}
+
+	public void add(IndexEntry entry) {
+		final IndexPartitionDescriptor partition = entry.getPartition();
+		final IndexURI uri = entry.getKey();
+
+		addOrGetPartition(partition);
+
+		innerEntries(uri).put(partition, entry);
+		if(inCollection) {
+			addedEntries.add(entry);
+			removedEntries.remove(entry);
+		}
+
+		// Add entry to children.
+		IndexURI parent = uri.getParent(termFactory);
+		if(parent != null)
+			innerChildEntries(parent).put(partition, entry);
+
+		// Add entry to partitions.
+		entriesPerPartitionDescriptor.put(partition, entry);
+	}
+
+	public void addAll(IStrategoList entries, IndexPartitionDescriptor partitionDescriptor) {
+		while(!entries.isEmpty()) {
+			add((IStrategoAppl) entries.head(), partitionDescriptor);
+			entries = entries.tail();
+		}
+	}
+
+	public Collection<IndexEntry> remove(IStrategoAppl template, IndexPartitionDescriptor partitionDescriptor) {
+		IndexURI uri = factory.createURIFromTemplate(template);
+		IndexURI parentURI = uri.getParent(termFactory);
+
+		Multimap<IndexPartitionDescriptor, IndexEntry> entryValues = innerEntries(uri);
+		Multimap<IndexPartitionDescriptor, IndexEntry> childValues = null;
+		if(parentURI != null)
+			childValues = innerChildEntries(uri.getParent(termFactory));
+
+		Collection<IndexEntry> removedEntries = entryValues.removeAll(partitionDescriptor);
+
+		for(IndexEntry entry : removedEntries) {
+			if(parentURI != null)
+				childValues.remove(partitionDescriptor, entry);
+			entriesPerPartitionDescriptor.remove(partitionDescriptor, entry);
+		}
+
+		return removedEntries;
+	}
+
+	public Collection<IndexEntry> removeAll(IStrategoAppl template) {
+		IndexURI uri = factory.createURIFromTemplate(template);
+		IndexURI parentURI = uri.getParent(termFactory);
+
+		Multimap<IndexPartitionDescriptor, IndexEntry> entryValues = innerEntries(uri);
+		Multimap<IndexPartitionDescriptor, IndexEntry> childValues = null;
+		if(parentURI != null)
+			childValues = innerChildEntries(uri.getParent(termFactory));
+
+		Collection<IndexEntry> removedEntries = entryValues.values();
+		entries.remove(uri);
+
+		for(IndexEntry entry : removedEntries) {
+			if(parentURI != null)
+				childValues.remove(entry.getPartition(), entry);
+			entriesPerPartitionDescriptor.remove(entry.getPartition(), entry);
+		}
+
+		return removedEntries;
+	}
+
+	public Collection<IndexEntry> removeOne(IStrategoAppl entryTerm) {
+		IndexURI uri = factory.createURIFromTemplate(entryTerm);
+		IndexURI parentURI = uri.getParent(termFactory);
+
+		Multimap<IndexPartitionDescriptor, IndexEntry> entryValues = innerEntries(uri);
+		Multimap<IndexPartitionDescriptor, IndexEntry> childValues = null;
+		if(parentURI != null)
+			childValues = innerChildEntries(uri.getParent(termFactory));
+
+		Collection<IndexEntry> removedEntries = new ArrayList<IndexEntry>();
+		IndexPartitionDescriptor[] partitions = entryValues.keySet().toArray(new IndexPartitionDescriptor[0]);
+		for(IndexPartitionDescriptor partition : partitions) {
+			IndexEntry entry = createEntry(entryTerm, partition);
+			if(entryValues.remove(partition, entry))
+				removedEntries.add(entry);
+		}
+
+		for(IndexEntry entry : removedEntries) {
+			if(parentURI != null)
+				childValues.remove(entry.getPartition(), entry);
+			entriesPerPartitionDescriptor.remove(entry.getPartition(), entry);
+		}
+
+		return removedEntries;
+	}
+
+	public IIndexEntryIterable get(IStrategoAppl template) {
+		IndexURI uri = factory.createURIFromTemplate(template);
+		return getEntryIterable(innerEntries(uri).values());
+	}
+
+	public IIndexEntryIterable getChildren(IStrategoAppl template) {
+		IndexURI uri = factory.createURIFromTemplate(template);
+		return getEntryIterable(innerChildEntries(uri).values());
+	}
+
+	public IIndexEntryIterable getInPartition(IndexPartitionDescriptor partitionDescriptor) {
+		return getEntryIterable(entriesPerPartitionDescriptor.get(partitionDescriptor));
+	}
+
+	public Collection<IndexPartitionDescriptor> getPartitionsOf(IStrategoAppl template) {
+		IndexURI uri = factory.createURIFromTemplate(template);
+		return getCollection(innerEntries(uri).keySet());
+	}
+
+	public IIndexEntryIterable getAll() {
+		List<IndexEntry> allEntries = new LinkedList<IndexEntry>();
+		Collection<Multimap<IndexPartitionDescriptor, IndexEntry>> values = entries.values();
+		for(Multimap<IndexPartitionDescriptor, IndexEntry> map : values)
+			allEntries.addAll(map.values());
+
+		return getEntryIterable(allEntries);
+	}
+
+	public IndexPartition getPartition(IndexPartitionDescriptor partitionDescriptor) {
+		return addOrGetPartition(partitionDescriptor);
+	}
+
+	private IndexPartition addOrGetPartition(IndexPartitionDescriptor partitionDescriptor) {
+		IndexPartition partition = partitions.get(partitionDescriptor);
+		if(partition == null) {
+			partition = new IndexPartition(partitionDescriptor, null);
+			partitions.put(partitionDescriptor, partition);
+		}
+		return partition;
+	}
+
+	public IndexPartitionDescriptor getPartitionDescriptor(IStrategoTerm partitionTerm) {
+		return IndexPartitionDescriptor.fromTerm(agent, partitionTerm);
+	}
+
+	public void clearPartition(IStrategoTerm partitionTerm) {
+		clearPartitionInternal(getPartitionDescriptor(partitionTerm));
+	}
+
+	public void clearPartition(IndexPartitionDescriptor partitionDescriptor) {
+		clearPartitionInternal(partitionDescriptor);
+	}
+
+	private void clearPartitionInternal(IndexPartitionDescriptor partitionDescriptor) {
+		assert partitionDescriptor.getPartition() != null || partitionDescriptor.getURI() != null;
+
+		Collection<Multimap<IndexPartitionDescriptor, IndexEntry>> entryValues = entries.values();
+		for(Multimap<IndexPartitionDescriptor, IndexEntry> map : entryValues)
+			map.removeAll(partitionDescriptor);
+
+		Collection<Multimap<IndexPartitionDescriptor, IndexEntry>> childValues = childs.values();
+		for(Multimap<IndexPartitionDescriptor, IndexEntry> map : childValues)
+			map.removeAll(partitionDescriptor);
+
+		entriesPerPartitionDescriptor.removeAll(partitionDescriptor);
+
+		assert !getInPartition(partitionDescriptor).iterator().hasNext();
+	}
+
+	public Collection<IndexPartition> getAllPartitions() {
+		return getCollection(partitions.values());
+	}
+
+	public Collection<IndexPartitionDescriptor> getAllPartitionDescriptors() {
+		return getCollection(partitions.keySet());
+	}
+
+	public void clearAll() {
+		entries.clear();
+		childs.clear();
+		entriesPerPartitionDescriptor.clear();
+		partitions.clear();
+	}
+
+	private static final IIndexEntryIterable getEntryIterable(Collection<IndexEntry> collection) {
+		return new IndexEntryIterable(collection, null);
+	}
+
+	/**
+	 * Returns an unmodifiable collection if in debug mode, or the collection if not.
+	 */
+	private static final <T> Collection<T> getCollection(Collection<T> collection) {
+		if(DEBUG_ENABLED) {
+			return Collections.unmodifiableCollection(collection);
+		} else {
+			return collection;
+		}
+	}
 }

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexLibrary.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexLibrary.java	Fri Mar 29 14:38:15 2013	(r26034)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexLibrary.java	Tue Apr  2 18:39:14 2013	(r26035)
@@ -32,6 +32,8 @@
         add(new LANG_index_set_current_file(index));
         add(new LANG_index_reload(index));
         add(new LANG_index_unload(index));
+        add(new LANG_index_start_collection(index));
+        add(new LANG_index_stop_collection(index));
     }
 
     public String getOperatorRegistryName() {

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/LANG_index_start_collection.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/LANG_index_start_collection.java	Tue Apr  2 18:39:14 2013	(r26035)
@@ -0,0 +1,33 @@
+package org.spoofax.interpreter.library.index;
+
+import static org.spoofax.interpreter.core.Tools.isTermString;
+import static org.spoofax.interpreter.core.Tools.isTermTuple;
+
+import org.spoofax.interpreter.core.IContext;
+import org.spoofax.interpreter.core.InterpreterException;
+import org.spoofax.interpreter.library.AbstractPrimitive;
+import org.spoofax.interpreter.stratego.Strategy;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+
+public class LANG_index_start_collection extends AbstractPrimitive {
+	private static String NAME = "LANG_index_start_collection";
+
+	private final IndexManager index;
+
+	public LANG_index_start_collection(IndexManager index) {
+		super(NAME, 0, 1);
+		this.index = index;
+	}
+
+	@Override
+	public boolean call(IContext env, Strategy[] svars, IStrategoTerm[] tvars) throws InterpreterException {
+		if(isTermTuple(tvars[0]) || isTermString(tvars[0])) {
+			IIndex ind = index.getCurrent();
+			IndexPartitionDescriptor partitionDescriptor = ind.getPartitionDescriptor(tvars[0]);
+			index.getCurrent().startCollection(partitionDescriptor);
+			return true;
+		} else {
+			return false;
+		}
+	}
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/LANG_index_stop_collection.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/LANG_index_stop_collection.java	Tue Apr  2 18:39:14 2013	(r26035)
@@ -0,0 +1,24 @@
+package org.spoofax.interpreter.library.index;
+
+import org.spoofax.interpreter.core.IContext;
+import org.spoofax.interpreter.core.InterpreterException;
+import org.spoofax.interpreter.library.AbstractPrimitive;
+import org.spoofax.interpreter.stratego.Strategy;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+
+public class LANG_index_stop_collection extends AbstractPrimitive {
+	private static String NAME = "LANG_index_start_collection";
+
+	private final IndexManager index;
+
+	public LANG_index_stop_collection(IndexManager index) {
+		super(NAME, 0, 1);
+		this.index = index;
+	}
+
+	@Override
+	public boolean call(IContext env, Strategy[] svars, IStrategoTerm[] tvars) throws InterpreterException {
+		env.setCurrent(index.getCurrent().stopCollection());
+		return true;
+	}
+}

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/TransactionIndex.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/TransactionIndex.java	Fri Mar 29 14:38:15 2013	(r26034)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/TransactionIndex.java	Tue Apr  2 18:39:14 2013	(r26035)
@@ -10,228 +10,237 @@
 import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.IStrategoTuple;
 import org.spoofax.interpreter.terms.ITermFactory;
 
 /**
  * @author Gabri?l Konat
  */
 public class TransactionIndex implements IIndex {
-    private IIndex index;
-    private IIndex transactionIndex;
-    private IndexPartitionDescriptor currentPartition;
-    private boolean clearedCurrentPartition = false;
-    private List<TemplateWithPartitionDescriptor> removedEntries = new ArrayList<TemplateWithPartitionDescriptor>();
-    private List<IStrategoAppl> removedAllEntries = new ArrayList<IStrategoAppl>();
-
-    public TransactionIndex(IIndex index, IIndex transactionIndex, IndexPartitionDescriptor currentPartition) {
-        this.index = index;
-        this.transactionIndex = transactionIndex;
-        this.currentPartition = currentPartition;
-    }
-
-    public IIndex getIndex() {
-        return index;
-    }
-
-    public IIndex getTransactionIndex() {
-        return transactionIndex;
-    }
-
-    public boolean hasClearedCurrentPartition() {
-        return clearedCurrentPartition;
-    }
-
-    public IndexPartitionDescriptor getCurrentPartition() {
-        return currentPartition;
-    }
-
-    public Collection<TemplateWithPartitionDescriptor> getRemovedEntries() {
-        return removedEntries;
-    }
-    
-    public Collection<IStrategoAppl> getRemovedAllEntries() {
-        return removedAllEntries;
-    }
-
-    public void initialize(ITermFactory factory, IOAgent agent) {
-        // Should not be called, both the index and transaction index should already be initialized.
-        assert false;
-    }
-
-    public IndexEntryFactory getFactory() {
-        return index.getFactory();
-    }
-
-    public void add(IStrategoAppl entry, IndexPartitionDescriptor partitionDescriptor) {
-        transactionIndex.add(entry, partitionDescriptor);
-    }
-
-    public void add(IndexEntry entry) {
-        transactionIndex.add(entry);
-    }
-
-    public void addAll(IStrategoList entries, IndexPartitionDescriptor partitionDescriptor) {
-        transactionIndex.addAll(entries, partitionDescriptor);
-    }
-
-    public Collection<IndexEntry> remove(IStrategoAppl template, IndexPartitionDescriptor partitionDescriptor) {
-        Collection<IndexEntry> removed = transactionIndex.remove(template, partitionDescriptor);
-        removedEntries.add(new TemplateWithPartitionDescriptor(template, partitionDescriptor));
-        return removed;
-    }
-    
-    public Collection<IndexEntry> removeAll(IStrategoAppl template) {
-        Collection<IndexEntry> removed = transactionIndex.removeAll(template);
-        removedAllEntries.add(template);
-        return removed;
-    }
-    
-    public Collection<IndexEntry> removeOne(IStrategoAppl entryTerm) {
-        Collection<IndexEntry> removed = transactionIndex.removeOne(entryTerm);
-        removedAllEntries.add(entryTerm);
-        return removed;  
-    }
-
-    public IIndexEntryIterable get(final IStrategoAppl template) {
-        return new AbstractIndexEntryIterable(getReadLock()) {
-            @Override
-            public Iterator<IndexEntry> iterator() {
-                return new TransactionIndexEntryIterator(clearedCurrentPartition, currentPartition, transactionIndex
-                    .get(template).iterator(), index.get(template).iterator());
-            }
-        };
-    }
-
-    public IIndexEntryIterable getAll() {
-        return new AbstractIndexEntryIterable(getReadLock()) {
-            @Override
-            public Iterator<IndexEntry> iterator() {
-                return new TransactionIndexEntryIterator(clearedCurrentPartition, currentPartition, transactionIndex
-                    .getAll().iterator(), index.getAll().iterator());
-            }
-        };
-    }
-
-    public IIndexEntryIterable getChildren(final IStrategoAppl template) {
-        return new AbstractIndexEntryIterable(getReadLock()) {
-            @Override
-            public Iterator<IndexEntry> iterator() {
-                return new TransactionIndexEntryIterator(clearedCurrentPartition, currentPartition, transactionIndex
-                    .getChildren(template).iterator(), index.getChildren(template).iterator());
-            }
-        };
-    }
-
-    public IIndexEntryIterable getInPartition(final IndexPartitionDescriptor partitionDescriptor) {
-        if(isCurrentPartition(partitionDescriptor) && clearedCurrentPartition)
-            // Current partition has been cleared, entries from index should not be visible.
-            return transactionIndex.getInPartition(partitionDescriptor);
-
-        return new AbstractIndexEntryIterable(getReadLock()) {
-            @Override
-            public Iterator<IndexEntry> iterator() {
-                return new TransactionIndexEntryIterator(clearedCurrentPartition, currentPartition, transactionIndex
-                    .getInPartition(partitionDescriptor).iterator(), index.getInPartition(partitionDescriptor)
-                    .iterator());
-            }
-        };
-    }
-
-    public Collection<IndexPartitionDescriptor> getPartitionsOf(IStrategoAppl template) {
-        Collection<IndexPartitionDescriptor> entries1 = transactionIndex.getPartitionsOf(template);
-        getReadLock().lock();
-        try {
-            // TODO: Need to filter hidden entries here?
-            Collection<IndexPartitionDescriptor> entries2 = index.getPartitionsOf(template);
-            return concat(entries1, entries2);
-        } finally {
-            getReadLock().unlock();
-        }
-    }
-
-    public IndexPartition getPartition(IndexPartitionDescriptor partitionDescriptor) {
-        // Need a write lock here because getPartition can add a new partition.
-        getWriteLock().lock();
-        try {
-            return index.getPartition(partitionDescriptor);
-        } finally {
-            getWriteLock().unlock();
-        }
-    }
-
-    public IndexPartitionDescriptor getPartitionDescriptor(IStrategoTerm partitionTerm) {
-        return index.getPartitionDescriptor(partitionTerm);
-    }
-
-    public void clearPartition(IStrategoTerm partitionTerm) {
-        clearPartition(transactionIndex.getPartitionDescriptor(partitionTerm));
-    }
-
-    public void clearPartition(IndexPartitionDescriptor partitionDescriptor) {
-        assert isCurrentPartition(partitionDescriptor); // May only clear current partition.
-
-        clearedCurrentPartition = true;
-        transactionIndex.clearPartition(partitionDescriptor);
-    }
-
-    public Collection<IndexPartition> getAllPartitions() {
-        // TODO: No duplicates?
-        Collection<IndexPartition> partitions1 = transactionIndex.getAllPartitions();
-        getReadLock().lock();
-        try {
-            Collection<IndexPartition> partitions2 = index.getAllPartitions();
-            return concat(partitions1, partitions2);
-        } finally {
-            getReadLock().unlock();
-        }
-    }
-
-    public Collection<IndexPartitionDescriptor> getAllPartitionDescriptors() {
-        // TODO: No duplicates?
-        Collection<IndexPartitionDescriptor> partitions1 = transactionIndex.getAllPartitionDescriptors();
-        getReadLock().lock();
-        try {
-            Collection<IndexPartitionDescriptor> partitions2 = index.getAllPartitionDescriptors();
-            return concat(partitions1, partitions2);
-        } finally {
-            getReadLock().unlock();
-        }
-    }
-
-    public void clearAll() {
-        transactionIndex.clearAll();
-
-        getWriteLock().lock();
-        index.clearAll();
-        getWriteLock().unlock();
-    }
-
-    /**
-     * Queries if given partition descriptor equals the current partition; the partition this transaction index has been
-     * created for.
-     * 
-     * @param partitionDescriptor The partition descriptor to check.
-     * @return True if given partition descriptor equals the current partition.
-     */
-    private boolean isCurrentPartition(IndexPartitionDescriptor partitionDescriptor) {
-        return partitionDescriptor.equals(currentPartition)
-            || partitionDescriptor.getURI().equals(currentPartition.getURI());
-    }
-
-    private <T> Collection<T> concat(Collection<T> c1, Collection<T> c2) {
-        // Need to copy here, collections could be changed from other threads.
-        List<T> l = new ArrayList<T>(c1.size() + c2.size());
-        l.addAll(c1);
-        l.addAll(c2);
-
-        return l;
-    }
-
-    private Lock getReadLock() {
-        return IndexManager.getTransactionLock().readLock();
-    }
-
-    private Lock getWriteLock() {
-        return IndexManager.getTransactionLock().writeLock();
-    }
+	private IIndex index;
+	private IIndex transactionIndex;
+	private IndexPartitionDescriptor currentPartition;
+	private boolean clearedCurrentPartition = false;
+	private List<TemplateWithPartitionDescriptor> removedEntries = new ArrayList<TemplateWithPartitionDescriptor>();
+	private List<IStrategoAppl> removedAllEntries = new ArrayList<IStrategoAppl>();
+
+	public TransactionIndex(IIndex index, IIndex transactionIndex, IndexPartitionDescriptor currentPartition) {
+		this.index = index;
+		this.transactionIndex = transactionIndex;
+		this.currentPartition = currentPartition;
+	}
+
+	public IIndex getIndex() {
+		return index;
+	}
+
+	public IIndex getTransactionIndex() {
+		return transactionIndex;
+	}
+
+	public boolean hasClearedCurrentPartition() {
+		return clearedCurrentPartition;
+	}
+
+	public IndexPartitionDescriptor getCurrentPartition() {
+		return currentPartition;
+	}
+
+	public Collection<TemplateWithPartitionDescriptor> getRemovedEntries() {
+		return removedEntries;
+	}
+
+	public Collection<IStrategoAppl> getRemovedAllEntries() {
+		return removedAllEntries;
+	}
+
+	public void initialize(ITermFactory factory, IOAgent agent) {
+		// Should not be called, both the index and transaction index should already be initialized.
+		assert false;
+	}
+
+	public IndexEntryFactory getFactory() {
+		return index.getFactory();
+	}
+
+	public void startCollection(IndexPartitionDescriptor partitionDescriptor) {
+		transactionIndex.startCollection(partitionDescriptor);
+	}
+
+	public IStrategoTuple stopCollection() {
+		return transactionIndex.stopCollection();
+	}
+
+	public void add(IStrategoAppl entry, IndexPartitionDescriptor partitionDescriptor) {
+		transactionIndex.add(entry, partitionDescriptor);
+	}
+
+	public void add(IndexEntry entry) {
+		transactionIndex.add(entry);
+	}
+
+	public void addAll(IStrategoList entries, IndexPartitionDescriptor partitionDescriptor) {
+		transactionIndex.addAll(entries, partitionDescriptor);
+	}
+
+	public Collection<IndexEntry> remove(IStrategoAppl template, IndexPartitionDescriptor partitionDescriptor) {
+		Collection<IndexEntry> removed = transactionIndex.remove(template, partitionDescriptor);
+		removedEntries.add(new TemplateWithPartitionDescriptor(template, partitionDescriptor));
+		return removed;
+	}
+
+	public Collection<IndexEntry> removeAll(IStrategoAppl template) {
+		Collection<IndexEntry> removed = transactionIndex.removeAll(template);
+		removedAllEntries.add(template);
+		return removed;
+	}
+
+	public Collection<IndexEntry> removeOne(IStrategoAppl entryTerm) {
+		Collection<IndexEntry> removed = transactionIndex.removeOne(entryTerm);
+		removedAllEntries.add(entryTerm);
+		return removed;
+	}
+
+	public IIndexEntryIterable get(final IStrategoAppl template) {
+		return new AbstractIndexEntryIterable(getReadLock()) {
+			@Override
+			public Iterator<IndexEntry> iterator() {
+				return new TransactionIndexEntryIterator(clearedCurrentPartition, currentPartition, transactionIndex
+					.get(template).iterator(), index.get(template).iterator());
+			}
+		};
+	}
+
+	public IIndexEntryIterable getAll() {
+		return new AbstractIndexEntryIterable(getReadLock()) {
+			@Override
+			public Iterator<IndexEntry> iterator() {
+				return new TransactionIndexEntryIterator(clearedCurrentPartition, currentPartition, transactionIndex
+					.getAll().iterator(), index.getAll().iterator());
+			}
+		};
+	}
+
+	public IIndexEntryIterable getChildren(final IStrategoAppl template) {
+		return new AbstractIndexEntryIterable(getReadLock()) {
+			@Override
+			public Iterator<IndexEntry> iterator() {
+				return new TransactionIndexEntryIterator(clearedCurrentPartition, currentPartition, transactionIndex
+					.getChildren(template).iterator(), index.getChildren(template).iterator());
+			}
+		};
+	}
+
+	public IIndexEntryIterable getInPartition(final IndexPartitionDescriptor partitionDescriptor) {
+		if(isCurrentPartition(partitionDescriptor) && clearedCurrentPartition)
+			// Current partition has been cleared, entries from index should not be visible.
+			return transactionIndex.getInPartition(partitionDescriptor);
+
+		return new AbstractIndexEntryIterable(getReadLock()) {
+			@Override
+			public Iterator<IndexEntry> iterator() {
+				return new TransactionIndexEntryIterator(clearedCurrentPartition, currentPartition, transactionIndex
+					.getInPartition(partitionDescriptor).iterator(), index.getInPartition(partitionDescriptor)
+					.iterator());
+			}
+		};
+	}
+
+	public Collection<IndexPartitionDescriptor> getPartitionsOf(IStrategoAppl template) {
+		Collection<IndexPartitionDescriptor> entries1 = transactionIndex.getPartitionsOf(template);
+		getReadLock().lock();
+		try {
+			// TODO: Need to filter hidden entries here?
+			Collection<IndexPartitionDescriptor> entries2 = index.getPartitionsOf(template);
+			return concat(entries1, entries2);
+		} finally {
+			getReadLock().unlock();
+		}
+	}
+
+	public IndexPartition getPartition(IndexPartitionDescriptor partitionDescriptor) {
+		// Need a write lock here because getPartition can add a new partition.
+		getWriteLock().lock();
+		try {
+			return index.getPartition(partitionDescriptor);
+		} finally {
+			getWriteLock().unlock();
+		}
+	}
+
+	public IndexPartitionDescriptor getPartitionDescriptor(IStrategoTerm partitionTerm) {
+		return index.getPartitionDescriptor(partitionTerm);
+	}
+
+	public void clearPartition(IStrategoTerm partitionTerm) {
+		clearPartition(transactionIndex.getPartitionDescriptor(partitionTerm));
+	}
+
+	public void clearPartition(IndexPartitionDescriptor partitionDescriptor) {
+		assert isCurrentPartition(partitionDescriptor); // May only clear current partition.
+
+		clearedCurrentPartition = true;
+		transactionIndex.clearPartition(partitionDescriptor);
+	}
+
+	public Collection<IndexPartition> getAllPartitions() {
+		// TODO: No duplicates?
+		Collection<IndexPartition> partitions1 = transactionIndex.getAllPartitions();
+		getReadLock().lock();
+		try {
+			Collection<IndexPartition> partitions2 = index.getAllPartitions();
+			return concat(partitions1, partitions2);
+		} finally {
+			getReadLock().unlock();
+		}
+	}
+
+	public Collection<IndexPartitionDescriptor> getAllPartitionDescriptors() {
+		// TODO: No duplicates?
+		Collection<IndexPartitionDescriptor> partitions1 = transactionIndex.getAllPartitionDescriptors();
+		getReadLock().lock();
+		try {
+			Collection<IndexPartitionDescriptor> partitions2 = index.getAllPartitionDescriptors();
+			return concat(partitions1, partitions2);
+		} finally {
+			getReadLock().unlock();
+		}
+	}
+
+	public void clearAll() {
+		transactionIndex.clearAll();
+
+		getWriteLock().lock();
+		index.clearAll();
+		getWriteLock().unlock();
+	}
+
+	/**
+	 * Queries if given partition descriptor equals the current partition; the partition this transaction index has been
+	 * created for.
+	 * 
+	 * @param partitionDescriptor The partition descriptor to check.
+	 * @return True if given partition descriptor equals the current partition.
+	 */
+	private boolean isCurrentPartition(IndexPartitionDescriptor partitionDescriptor) {
+		return partitionDescriptor.equals(currentPartition)
+			|| partitionDescriptor.getURI().equals(currentPartition.getURI());
+	}
+
+	private <T> Collection<T> concat(Collection<T> c1, Collection<T> c2) {
+		// Need to copy here, collections could be changed from other threads.
+		List<T> l = new ArrayList<T>(c1.size() + c2.size());
+		l.addAll(c1);
+		l.addAll(c2);
+
+		return l;
+	}
+
+	private Lock getReadLock() {
+		return IndexManager.getTransactionLock().readLock();
+	}
+
+	private Lock getWriteLock() {
+		return IndexManager.getTransactionLock().writeLock();
+	}
 }

From gabrielkonat at gmail.com  Tue Apr  2 21:17:54 2013
From: gabrielkonat at gmail.com (GabriÃ«l Konat)
Date: Tue, 02 Apr 2013 19:17:54 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26036 -
	spoofax-imp/branches/nbl-dev/trans/generation
Message-ID: <20130402191754.7558B2B801C@mx2.tudelft.nl>

Author: gkonat
Date: Tue Apr  2 19:17:52 2013
New Revision: 26036
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26036&sc=1

Log:
Changes to generation to work with new collect interface of NaBl.

Modified:
   spoofax-imp/branches/nbl-dev/trans/generation/constraints.str
   spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str
   spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str

Modified: spoofax-imp/branches/nbl-dev/trans/generation/constraints.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/constraints.str	Tue Apr  2 18:39:14 2013	(r26035)
+++ spoofax-imp/branches/nbl-dev/trans/generation/constraints.str	Tue Apr  2 19:17:52 2013	(r26036)
@@ -46,7 +46,7 @@
       
 overlays
     
-  MATCH_RULE(n, lhs, bnd, rhs) = RDefNoArgs("nabl-match", RuleNoCond(TUPLE([n, lhs, LIST(bnd)]), rhs))
+  MATCH_RULE(n, lhs, bnd, rhs) = RDefNoArgs("task-match", RuleNoCond(TUPLE([n, lhs, LIST(bnd)]), rhs))
 
   PROP_TASK(v, p, t)     = NEW_TASK(v, TERM("PropCalc", [p, t]))
   MATCH_TASK(v, n, b, t) = NEW_TASK(v, TERM("Match", [n, LIST(b), t]))
@@ -55,6 +55,6 @@
   
   NEW_TASK(t) =
   App(
-    CallT(SVar("new-task"), [], [Var("tasks")])
+    CallT(SVar("new-task"), [], [Var("partition")])
   , t
   )
\ No newline at end of file

Modified: spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str	Tue Apr  2 18:39:14 2013	(r26035)
+++ spoofax-imp/branches/nbl-dev/trans/generation/def-sites.str	Tue Apr  2 19:17:52 2013	(r26036)
@@ -100,7 +100,10 @@
   SDefT(
     "nabl-prop-site"
   , []
-  , [ DefaultVarDec("elems"), DefaultVarDec("tasks"), DefaultVarDec("states")]
+  , [ DefaultVarDec("lang")
+    , DefaultVarDec("partition")
+    , DefaultVarDec("elems")
+    , DefaultVarDec("states")]
   , body
   )
   
@@ -108,7 +111,7 @@
   CallT(
     SVar("nabl-props")
   , []
-  , [ Var("elems"), LIST(ps)]
+  , [ Var("lang"), Var("partition"), Var("elems"), LIST(ps)]
   )
   
   PROPERTY(p, v) = TERM("Prop", [p, v])

Modified: spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str	Tue Apr  2 18:39:14 2013	(r26035)
+++ spoofax-imp/branches/nbl-dev/trans/generation/use-sites.str	Tue Apr  2 19:17:52 2013	(r26036)
@@ -77,8 +77,8 @@
     "nabl-use-site"
   , []
   , [ DefaultVarDec("lang")
+    , DefaultVarDec("partition")
     , DefaultVarDec("elems")
-    , DefaultVarDec("tasks")
     , DefaultVarDec("uris")
     , DefaultVarDec("states") 
     ]
@@ -90,8 +90,8 @@
     SVar("nabl-use")
   , []
   , [ Var("lang")
+		, Var("partition")
     , Var("elems")
-    , Var("tasks")
     , Var("uris")
     , LIST(candidates)
     ] 

From gabrielkonat at gmail.com  Wed Apr  3 14:20:48 2013
From: gabrielkonat at gmail.com (GabriÃ«l Konat)
Date: Wed, 03 Apr 2013 12:20:48 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26037 -
	spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index
Message-ID: <20130403122048.67A35CC19E@mx4.tudelft.nl>

Author: gkonat
Date: Wed Apr  3 12:20:46 2013
New Revision: 26037
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26037&sc=1

Log:
Allow duplicates in entriesPerPartitionDescriptor. Fix wrong index_stop_collection primitive name.

Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/Index.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/LANG_index_stop_collection.java

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/Index.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/Index.java	Tue Apr  2 19:17:52 2013	(r26036)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/Index.java	Wed Apr  3 12:20:46 2013	(r26037)
@@ -19,7 +19,6 @@
 
 import com.google.common.collect.ArrayListMultimap;
 import com.google.common.collect.HashMultiset;
-import com.google.common.collect.LinkedHashMultimap;
 import com.google.common.collect.Multimap;
 import com.google.common.collect.Multiset;
 import com.google.common.collect.Multisets;
@@ -37,7 +36,7 @@
 		new ConcurrentHashMap<IndexURI, Multimap<IndexPartitionDescriptor, IndexEntry>>();
 	private final ConcurrentHashMap<IndexURI, Multimap<IndexPartitionDescriptor, IndexEntry>> childs =
 		new ConcurrentHashMap<IndexURI, Multimap<IndexPartitionDescriptor, IndexEntry>>();
-	private final Multimap<IndexPartitionDescriptor, IndexEntry> entriesPerPartitionDescriptor = LinkedHashMultimap
+	private final Multimap<IndexPartitionDescriptor, IndexEntry> entriesPerPartitionDescriptor = ArrayListMultimap
 		.create();
 	private final Map<IndexPartitionDescriptor, IndexPartition> partitions =
 		new HashMap<IndexPartitionDescriptor, IndexPartition>();
@@ -100,6 +99,7 @@
 	public void startCollection(IndexPartitionDescriptor partitionDescriptor) {
 		addedEntries.clear();
 		removedEntries.clear();
+		oldEntries.clear();
 		removedEntries.addAll(entriesPerPartitionDescriptor.get(partitionDescriptor));
 		oldEntries.addAll(entriesPerPartitionDescriptor.get(partitionDescriptor));
 		clearPartition(partitionDescriptor);
@@ -296,6 +296,7 @@
 		childs.clear();
 		entriesPerPartitionDescriptor.clear();
 		partitions.clear();
+		inCollection = false;
 	}
 
 	private static final IIndexEntryIterable getEntryIterable(Collection<IndexEntry> collection) {

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/LANG_index_stop_collection.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/LANG_index_stop_collection.java	Tue Apr  2 19:17:52 2013	(r26036)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/LANG_index_stop_collection.java	Wed Apr  3 12:20:46 2013	(r26037)
@@ -7,7 +7,7 @@
 import org.spoofax.interpreter.terms.IStrategoTerm;
 
 public class LANG_index_stop_collection extends AbstractPrimitive {
-	private static String NAME = "LANG_index_start_collection";
+	private static String NAME = "LANG_index_stop_collection";
 
 	private final IndexManager index;
 

From v.vergu+vc at gmail.com  Wed Apr  3 15:38:04 2013
From: v.vergu+vc at gmail.com (Vlad Vergu)
Date: Wed, 03 Apr 2013 13:38:04 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26038 -
	spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index
Message-ID: <20130403133804.23151108C021@mx3.tudelft.nl>

Author: VladVergu
Date: Wed Apr  3 13:38:02 2013
New Revision: 26038
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26038&sc=1

Log:
Write & Read index to Stream ATerm Format. Should be faster than String.

Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexManager.java

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexManager.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexManager.java	Wed Apr  3 12:20:46 2013	(r26037)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexManager.java	Wed Apr  3 13:38:02 2013	(r26038)
@@ -2,6 +2,7 @@
 
 import java.io.BufferedWriter;
 import java.io.File;
+import java.io.FileOutputStream;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.Writer;
@@ -20,172 +21,181 @@
 import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.ITermFactory;
+import org.spoofax.terms.io.binary.SAFWriter;
 import org.spoofax.terms.io.binary.TermReader;
 
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
- * @author Gabri?l Konat
+ * @author Gabri??l Konat
  */
 public class IndexManager {
-    private final static AtomicLong revisionProvider = new AtomicLong();
-    private final static ReadWriteLock transactionLock = new ReentrantReadWriteLock();
-    private final static IndexFactory indexFactory = new IndexFactory();
-
-    /**
-     * Indices by language and project. Access requires a lock on {@link #getSyncRoot}
-     */
-    private static Map<URI, WeakReference<IIndex>> indexCache = new HashMap<URI, WeakReference<IIndex>>();
-    private static Set<String> indexedLanguages = new HashSet<String>();
-
-    private ThreadLocal<IIndex> current = new ThreadLocal<IIndex>();
-    private ThreadLocal<URI> currentProject = new ThreadLocal<URI>();
-    private ThreadLocal<IndexPartitionDescriptor> currentPartition = new ThreadLocal<IndexPartitionDescriptor>();
-
-    public static ReadWriteLock getTransactionLock() {
-        return transactionLock;
-    }
-
-    public IIndex getCurrent() {
-        ensureInitialized();
-        return current.get();
-    }
-
-    public URI getCurrentProject() {
-        ensureInitialized();
-        return currentProject.get();
-    }
-
-    public IndexPartitionDescriptor getCurrentPartition() {
-        ensureInitialized();
-        return currentPartition.get();
-    }
-
-    public void setCurrentPartition(IndexPartitionDescriptor currentPartition) {
-        this.currentPartition.set(currentPartition);
-    }
-
-    public long startTransaction(ITermFactory factory, IOAgent agent) {
-        long rev = revisionProvider.getAndIncrement();
-        IIndex currentIndex = current.get();
-        currentIndex.getPartition(currentPartition.get()).setRevisionTime(rev, new Date());
-
-        assert currentIndex instanceof Index; // Prevent multiple transactions.
-
-        IIndex transactionIndex = new Index();
-        transactionIndex.initialize(factory, agent);
-        current.set(new TransactionIndex(currentIndex, transactionIndex, currentPartition.get()));
-
-        return rev;
-    }
-
-    public void endTransaction() {
-        TransactionIndex currentIndex = (TransactionIndex) current.get();
-        IIndex index = currentIndex.getIndex();
-        IIndex transactionIndex = currentIndex.getTransactionIndex();
-        current.set(index);
-
-        transactionLock.writeLock().lock();
-        try {
-            if(currentIndex.hasClearedCurrentPartition())
-                index.clearPartition(currentIndex.getCurrentPartition());
-
-            for(TemplateWithPartitionDescriptor entry : currentIndex.getRemovedEntries())
-                index.remove(entry.getTemplate(), entry.getPartitionDescriptor());
-
-            for(IStrategoAppl template : currentIndex.getRemovedAllEntries())
-                index.removeAll(template);
-
-            for(IndexEntry entry : transactionIndex.getAll())
-                index.add(entry);
-
-            transactionIndex.clearAll();
-        } finally {
-            transactionLock.writeLock().unlock();
-        }
-    }
-
-    private static Object getSyncRoot() {
-        return IndexManager.class;
-    }
-
-    public AtomicLong getRevisionProvider() {
-        return revisionProvider;
-    }
-
-    public boolean isInitialized() {
-        return current.get() != null;
-    }
-
-    private void ensureInitialized() {
-        if(!isInitialized())
-            throw new IllegalStateException(
-                "Index has not been set-up, use index-setup(|language, project-paths) to set up the index before use.");
-    }
-
-    public static boolean isKnownIndexingLanguage(String language) {
-        synchronized(getSyncRoot()) {
-            return indexedLanguages.contains(language);
-        }
-    }
-
-    public void loadIndex(URI project, String language, ITermFactory factory, IOAgent agent) {
-        synchronized(getSyncRoot()) {
-            indexedLanguages.add(language);
-            WeakReference<IIndex> indexRef = indexCache.get(project);
-            IIndex index = indexRef == null ? null : indexRef.get();
-            if(index == null) {
-                index = tryReadFromFile(getIndexFile(project), factory, agent);
-            }
-            if(index == null) {
-                index = new Index();
-                NotificationCenter.notifyNewProject(project);
-            }
-            indexCache.put(project, new WeakReference<IIndex>(index));
-            current.set(index);
-            currentProject.set(project);
-        }
-    }
-
-    public void unloadIndex(URI removedProject) {
-        WeakReference<IIndex> removedIndex = indexCache.remove(removedProject);
-
-        IIndex index = current.get();
-        if(index != null && index == removedIndex.get()) {
-            current.set(null);
-            currentPartition.set(null);
-        }
-
-        URI project = currentProject.get();
-        if(project != null && project.equals(removedProject)) {
-            currentProject.set(null);
-        }
-    }
-
-    public IIndex tryReadFromFile(File file, ITermFactory factory, IOAgent agent) {
-        IIndex index = new Index(); // TODO: Don't create concrete implementation here.
-        index.initialize(factory, agent);
-        try {
-            IStrategoTerm term = new TermReader(factory).parseFromFile(file.toString());
-            return indexFactory.indexFromTerms(index, term, factory, true);
-        } catch(Exception e) {
-            return null;
-        }
-    }
-
-    public void storeCurrent(ITermFactory factory) throws IOException {
-        File file = getIndexFile(currentProject.get());
-        IStrategoTerm stored = indexFactory.toTerm(getCurrent(), factory, true);
-        Writer writer = new BufferedWriter(new FileWriter(file));
-        try {
-            stored.writeAsString(writer, IStrategoTerm.INFINITE);
-        } finally {
-            writer.close();
-        }
-    }
-
-    private File getIndexFile(URI project) {
-        File container = new File(new File(project), ".cache");
-        container.mkdirs();
-        return new File(container, "index.idx");
-    }
+	private final static AtomicLong revisionProvider = new AtomicLong();
+	private final static ReadWriteLock transactionLock = new ReentrantReadWriteLock();
+	private final static IndexFactory indexFactory = new IndexFactory();
+
+	/**
+	 * Indices by language and project. Access requires a lock on {@link #getSyncRoot}
+	 */
+	private static Map<URI, WeakReference<IIndex>> indexCache = new HashMap<URI, WeakReference<IIndex>>();
+	private static Set<String> indexedLanguages = new HashSet<String>();
+
+	private ThreadLocal<IIndex> current = new ThreadLocal<IIndex>();
+	private ThreadLocal<URI> currentProject = new ThreadLocal<URI>();
+	private ThreadLocal<IndexPartitionDescriptor> currentPartition = new ThreadLocal<IndexPartitionDescriptor>();
+
+	public static ReadWriteLock getTransactionLock() {
+		return transactionLock;
+	}
+
+	public IIndex getCurrent() {
+		ensureInitialized();
+		return current.get();
+	}
+
+	public URI getCurrentProject() {
+		ensureInitialized();
+		return currentProject.get();
+	}
+
+	public IndexPartitionDescriptor getCurrentPartition() {
+		ensureInitialized();
+		return currentPartition.get();
+	}
+
+	public void setCurrentPartition(IndexPartitionDescriptor currentPartition) {
+		this.currentPartition.set(currentPartition);
+	}
+
+	public long startTransaction(ITermFactory factory, IOAgent agent) {
+		long rev = revisionProvider.getAndIncrement();
+		IIndex currentIndex = current.get();
+		currentIndex.getPartition(currentPartition.get()).setRevisionTime(rev, new Date());
+
+		assert currentIndex instanceof Index; // Prevent multiple transactions.
+
+		IIndex transactionIndex = new Index();
+		transactionIndex.initialize(factory, agent);
+		current.set(new TransactionIndex(currentIndex, transactionIndex, currentPartition.get()));
+
+		return rev;
+	}
+
+	public void endTransaction() {
+		TransactionIndex currentIndex = (TransactionIndex) current.get();
+		IIndex index = currentIndex.getIndex();
+		IIndex transactionIndex = currentIndex.getTransactionIndex();
+		current.set(index);
+
+		transactionLock.writeLock().lock();
+		try {
+			if (currentIndex.hasClearedCurrentPartition())
+				index.clearPartition(currentIndex.getCurrentPartition());
+
+			for (TemplateWithPartitionDescriptor entry : currentIndex.getRemovedEntries())
+				index.remove(entry.getTemplate(), entry.getPartitionDescriptor());
+
+			for (IStrategoAppl template : currentIndex.getRemovedAllEntries())
+				index.removeAll(template);
+
+			for (IndexEntry entry : transactionIndex.getAll())
+				index.add(entry);
+
+			transactionIndex.clearAll();
+		} finally {
+			transactionLock.writeLock().unlock();
+		}
+	}
+
+	private static Object getSyncRoot() {
+		return IndexManager.class;
+	}
+
+	public AtomicLong getRevisionProvider() {
+		return revisionProvider;
+	}
+
+	public boolean isInitialized() {
+		return current.get() != null;
+	}
+
+	private void ensureInitialized() {
+		if (!isInitialized())
+			throw new IllegalStateException(
+					"Index has not been set-up, use index-setup(|language, project-paths) to set up the index before use.");
+	}
+
+	public static boolean isKnownIndexingLanguage(String language) {
+		synchronized (getSyncRoot()) {
+			return indexedLanguages.contains(language);
+		}
+	}
+
+	public void loadIndex(URI project, String language, ITermFactory factory, IOAgent agent) {
+		synchronized (getSyncRoot()) {
+			indexedLanguages.add(language);
+			WeakReference<IIndex> indexRef = indexCache.get(project);
+			IIndex index = indexRef == null ? null : indexRef.get();
+			if (index == null) {
+				index = tryReadFromFile(getIndexFile(project), factory, agent);
+			}
+			if (index == null) {
+				index = new Index();
+				NotificationCenter.notifyNewProject(project);
+			}
+			indexCache.put(project, new WeakReference<IIndex>(index));
+			current.set(index);
+			currentProject.set(project);
+		}
+	}
+
+	public void unloadIndex(URI removedProject) {
+		WeakReference<IIndex> removedIndex = indexCache.remove(removedProject);
+
+		IIndex index = current.get();
+		if (index != null && index == removedIndex.get()) {
+			current.set(null);
+			currentPartition.set(null);
+		}
+
+		URI project = currentProject.get();
+		if (project != null && project.equals(removedProject)) {
+			currentProject.set(null);
+		}
+	}
+
+	public IIndex tryReadFromFile(File file, ITermFactory factory, IOAgent agent) {
+		IIndex index = new Index(); // TODO: Don't create concrete implementation here.
+		index.initialize(factory, agent);
+		try {
+			IStrategoTerm term = new TermReader(factory).parseFromFile(file.toString());
+			return indexFactory.indexFromTerms(index, term, factory, true);
+		} catch (Exception e) {
+			return null;
+		}
+	}
+
+	public void storeCurrent(ITermFactory factory) throws IOException {
+		 File file = getIndexFile(currentProject.get());
+		 IStrategoTerm stored = indexFactory.toTerm(getCurrent(), factory, true);
+		// Writer writer = new BufferedWriter(new FileWriter(file));
+		// try {
+		// stored.writeAsString(writer, IStrategoTerm.INFINITE);
+		// } finally {
+		// writer.close();
+		// }
+		file.createNewFile();
+		FileOutputStream fos = new FileOutputStream(file);
+		try{
+			SAFWriter.writeTermToSAFStream(stored, fos);
+			fos.flush();
+		} finally {
+			fos.close();
+		}
+	}
+
+	private File getIndexFile(URI project) {
+		File container = new File(new File(project), ".cache");
+		container.mkdirs();
+		return new File(container, "index.idx");
+	}
 }

From v.vergu+vc at gmail.com  Wed Apr  3 15:38:46 2013
From: v.vergu+vc at gmail.com (Vlad Vergu)
Date: Wed, 03 Apr 2013 13:38:46 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26039 -
	spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index
Message-ID: <20130403133846.CF361CC1A0@mx4.tudelft.nl>

Author: VladVergu
Date: Wed Apr  3 13:38:46 2013
New Revision: 26039
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26039&sc=1

Log:
Cleanup

Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexManager.java

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexManager.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexManager.java	Wed Apr  3 13:38:02 2013	(r26038)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexManager.java	Wed Apr  3 13:38:46 2013	(r26039)
@@ -177,12 +177,6 @@
 	public void storeCurrent(ITermFactory factory) throws IOException {
 		 File file = getIndexFile(currentProject.get());
 		 IStrategoTerm stored = indexFactory.toTerm(getCurrent(), factory, true);
-		// Writer writer = new BufferedWriter(new FileWriter(file));
-		// try {
-		// stored.writeAsString(writer, IStrategoTerm.INFINITE);
-		// } finally {
-		// writer.close();
-		// }
 		file.createNewFile();
 		FileOutputStream fos = new FileOutputStream(file);
 		try{

From v.vergu+vc at gmail.com  Wed Apr  3 15:39:05 2013
From: v.vergu+vc at gmail.com (Vlad Vergu)
Date: Wed, 03 Apr 2013 13:39:05 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26040 -
	spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index
Message-ID: <20130403133905.ED0D62B802A@mx2.tudelft.nl>

Author: VladVergu
Date: Wed Apr  3 13:39:05 2013
New Revision: 26040
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26040&sc=1

Log:
More cleanup

Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexManager.java

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexManager.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexManager.java	Wed Apr  3 13:38:46 2013	(r26039)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/main/java/org/spoofax/interpreter/library/index/IndexManager.java	Wed Apr  3 13:39:05 2013	(r26040)
@@ -1,11 +1,8 @@
 package org.spoofax.interpreter.library.index;
 
-import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileOutputStream;
-import java.io.FileWriter;
 import java.io.IOException;
-import java.io.Writer;
 import java.lang.ref.WeakReference;
 import java.net.URI;
 import java.util.Date;

From v.vergu+vc at gmail.com  Wed Apr  3 16:53:45 2013
From: v.vergu+vc at gmail.com (Vlad Vergu)
Date: Wed, 03 Apr 2013 14:53:45 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26041 -
	spoofax-imp/branches/nbl-dev/trans/generation2
Message-ID: <20130403145345.4635E7F803A@mx1.tudelft.nl>

Author: VladVergu
Date: Wed Apr  3 14:53:44 2013
New Revision: 26041
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26041&sc=1

Log:
Imported new generation code

Added:
   spoofax-imp/branches/nbl-dev/trans/generation2/
   spoofax-imp/branches/nbl-dev/trans/generation2/constraints.str
   spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str
   spoofax-imp/branches/nbl-dev/trans/generation2/main.str
   spoofax-imp/branches/nbl-dev/trans/generation2/rules.str
   spoofax-imp/branches/nbl-dev/trans/generation2/scopes.str
   spoofax-imp/branches/nbl-dev/trans/generation2/sections.str
   spoofax-imp/branches/nbl-dev/trans/generation2/use-sites.str
   spoofax-imp/branches/nbl-dev/trans/generation2/util.str

Added: spoofax-imp/branches/nbl-dev/trans/generation2/constraints.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/constraints.str	Wed Apr  3 14:53:44 2013	(r26041)
@@ -0,0 +1,73 @@
+module generation2/constraints
+
+imports 
+  
+  libstrc
+  include/NameBindingLanguage
+  generation2/util
+  generation2/main
+  
+rules
+  
+  constraints-to-str(|repl*, b*, n):
+  	[] -> (repl*, b*, [], [], n)
+  
+  constraints-to-str(|repl*, b*, n):
+  	[c|cs] -> (r2*, b2*, [rule1*, rule2*], [task1*, task2*], k)
+  	where
+    	(r1*, b1*, rule1*, task1*, m) := <constraint-to-str(|repl*, b*, n)> c;
+      (r2*, b2*, rule2*, task2*, k) := <constraints-to-str(|r1*, b1*, m)> cs
+  		
+  constraint-to-str(|repl*, b*, n):  
+    PropertyConstraint(t1, p, t2) -> ([r1*, repl*], [b1*, b*], rule*, [task, match*], m)
+    where
+      t1' := <alltd(replace(|repl*))> t1;
+      // create new task for property calculation
+      r   := Var($[r[n]__]);
+      task := PROP_TASK(r, <nabl-to-str> p, t1');
+      if 
+        Var(v) := t2;
+        <not(elem)> (t2, b*) 
+     then // single unbound variable is replaced with result
+        r1* := [(Var(v), r)];
+        b1*    := [Var(v)];
+        match* := [];
+        rule*  := []
+      else
+      	var*   := <collect-all(?Var(_))> t2;
+      	bvar*  := <isect> (var*, b*);
+      	bvar'* := <alltd(replace(|repl*))> bvar*;
+      	(r1*, b1*, match*, rule*, m) := <matches-to-str(|t2, r, bvar*, bvar'*, <inc> n)> var*
+      end
+  
+   matches-to-str(|term, res, bvar*, bvar'*, n):
+     [] -> ([], [], [], [], n)
+   
+   matches-to-str(|term, res, bvar*, bvar'*, n):
+     [c|cs] -> ([r, r*], [b, b*], [rule, rule*], [t, t*], m)
+     where
+       (r, b, t, rule)        := <match-to-str(|term, res, bvar*, bvar'*, n)> c;
+       (r*, b*, t*, rule*, m) := <matches-to-str(|term, res, bvar*, bvar'*, <inc> n)> cs
+       
+   match-to-str(|term, res, bvar*, bvar'*, n):
+  	t at Var(v) -> ((t, r), t, rule, task)
+    where
+    	r    := Var($[r[n]__]);
+    	mn   := NoAnnoList(Str(<newname; double-quote> "match"));
+    	task := MATCH_TASK(r, mn, bvar'*, res);
+    	rule := MATCH_RULE(mn, term, bvar*, Var(v))
+      
+overlays
+    
+  MATCH_RULE(n, lhs, bnd, rhs) = RDefNoArgs("nabl-match", RuleNoCond(TUPLE([n, lhs, LIST(bnd)]), rhs))
+
+  PROP_TASK(v, p, t)     = NEW_TASK(v, TERM("PropCalc", [p, t]))
+  MATCH_TASK(v, n, b, t) = NEW_TASK(v, TERM("Match", [n, LIST(b), t]))
+  
+  NEW_TASK(v, t) = Where(Assign(v, NEW_TASK(t)))
+  
+  NEW_TASK(t) =
+  App(
+    CallT(SVar("new-task"), [], [Var("tasks__")])
+  , t
+  )
\ No newline at end of file

Added: spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str	Wed Apr  3 14:53:44 2013	(r26041)
@@ -0,0 +1,134 @@
+module generation2/def-sites
+
+imports
+  
+  libstrc
+  include/NameBindingLanguage
+  
+  generation2/util
+  generation2/main
+  generation2/scopes
+  generation2/constraints
+
+rules
+  
+  def-to-name = ?DefClause(Explicit(), _, _, <id>, _, _, _)
+    
+rules
+  
+ //  clause-to-pre-str(|pattern, scopes, n):
+ //    DefClause(Explicit(), u, ns, t, ps, ds, constr*) -> ([sc*, dcall], m)
+ //    where
+ //      ns'   := <nabl-to-str> ns
+ //    ; (r*, sc*, ds', m) := <scope-to-str(|ns', n)> ds
+ //    ; r     := (t,  DEF_CALL(ns', <nabl-to-str> u, ds', scopes))
+ //    ; dcall := <replace-all(|[r, r*])> pattern
+ //  
+ //  clause-to-post-str(|pattern, repl*, bound*, n):
+ //    DefClause(Explicit(), u, ns, t, ps, ds, constr*) -> (rule*, [pr*, pcall], m)
+ //    where
+ //      b2*   := <collect-all(?Var(_))> t
+ //    ; (r2*, _, rule*, pr*, m) := <constraints-to-str(|repl*, [bound*, b2*], n)> constr*
+ //    ; r2    := (t, PROP_CALL(<alltd(replace(|r2*)); map(prop-to-str)> ps))
+ //    ; pcall := <replace-all(|[r2, r2*])> pattern
+ //  
+ //  clause-to-pre-str(|pattern, scopes, n):
+ //    DefClause(Implicit(), u, ns, t, ps, ds, constr*) -> ([sc*, dcall], m)
+ //    where
+ //      ns' := <nabl-to-str> ns
+ //    ; (r*, sc*, _, m) := <scope-to-str(|ns', n)> ds
+ //    ; dcall := <replace-all(|r*)> pattern
+ //     
+ //  clause-to-post-str(|pattern, repl*, bound*, n):
+ //    DefClause(Implicit(), u, ns, t, ps, ds, constr*) -> (rule*, [pr*, app], m)
+ //    where
+ //      ns' := <nabl-to-str> ns
+ //    ; b*    := <collect-all(?Var(_))> t
+ //    ; (r2*, b3*, rule*, pr*, m) := <constraints-to-str(|repl*, [bound*, b*], n)> constr*
+ //    ; ps' := <map(prop-to-str); alltd(replace(|r2*))> ps
+ //    ; app := DEF_APPLY(ns', <nabl-to-str> u, ds', t, ps')
+ // 
+  clause-to-str(|pattern, scopes, repl*, bound*, n):
+    DefClause(Explicit(), u, ns, t, ps, ds, constr*) -> (rule*, [sc*, dcall], [pr*, pcall], k)
+    where
+      ns'   := <nabl-to-str> ns
+    ; (r*, sc*, ds', m) := <scope-to-str(|ns', n)> ds
+    ; r     := (t,  DEF_CALL(ns', <nabl-to-str> u, ds', scopes))
+    ; dcall := <replace-all(|[r, r*])> pattern
+    ; b2*   := <collect-all(?Var(_))> t
+    ; (r2*, b3*, rule*, pr*, k) := <constraints-to-str(|repl*, [bound*, b2*], m)> constr*
+    ; r2    := (t, PROP_CALL(<alltd(replace(|r2*)); map(prop-to-str)> ps))
+    ; pcall := <replace-all(|[r2, r2*])> pattern
+    
+  clause-to-str(|pattern, scopes, repl*, bound*, n):
+    DefClause(Implicit(), u, ns, t, ps, ds, constr*) -> (rule*, [sc*, dcall], [pr*, app], k)
+    where
+      ns' := <nabl-to-str> ns
+    ; (r*, sc*, ds', m) := <scope-to-str(|ns', n)> ds
+    ; dcall := <replace-all(|r*)> pattern
+    ; b*    := <collect-all(?Var(_))> t
+    ; (r2*, b3*, rule*, pr*, k) := <constraints-to-str(|repl*, [bound*, b*], m)> constr*
+    ; ps' := <map(prop-to-str); alltd(replace(|r2*))> ps
+    ; app := DEF_APPLY(ns', <nabl-to-str> u, ds', t, ps')
+
+rules
+         
+  prop-to-str: PropertyTerm(p, t) -> PROPERTY(<nabl-to-str> p, t)     
+
+  nabl-to-str: NonUnique() -> TERM("NonUnique")
+  nabl-to-str: Unique()    -> TERM("Unique")
+  
+overlays
+  
+  NAME_RULE(call) =
+  SDefT(
+    "nabl-name-site"
+  , [DefaultVarDec("child-uris__"), DefaultVarDec("sibl-uris__")]
+  , [ DefaultVarDec("lang__")
+    , DefaultVarDec("partition__")
+    , DefaultVarDec("uniques__")
+    , DefaultVarDec("elems__")
+    , DefaultVarDec("tasks__")
+    , DefaultVarDec("uris__")
+    , DefaultVarDec("states__")]
+  , call
+  )
+  
+  NAME_RULE(lhs, rhs) = RDefNoArgs("nabl-get-name", RuleNoCond(lhs, rhs))
+	
+  DEF_CALL(ns, u, ds, s) = 
+  CallT(
+    SVar("nabl-def")
+  , [Match(Var("child-uris__")), CALL("sibl-uris__")]
+  , [ Var("lang__")
+    , Var("partition__")
+    , Var("uniques__")
+    , Var("elems__")
+    , Var("uris__")
+    , ns, u, ds, LIST(s)]
+  )
+  
+  IMP_DEF_CALL(ns, u, ds, s) = 
+  CallT(
+    SVar("nabl-def")
+  , []
+  , [ Var("lang__")
+    , Var("partition__")
+    , Var("uniques__")
+    , Var("elems__")
+    , Var("uris__")
+    , ns, u, ds, LIST(s)]
+  )
+  
+  DEF_APPLY(ns, u, ds, t, ps) = 
+  Where(App(Seq(IMP_DEF_CALL(ns, u, ds, []), PROP_CALL(ps)), t))
+  
+  PROP_CALL(ps) = 
+  CallT(
+    SVar("nabl-props")
+  , []
+  , [ Var("elems__"), LIST(ps)]
+  )
+  
+  PROPERTY(p, v) = TERM("Prop", [p, v])
+

Added: spoofax-imp/branches/nbl-dev/trans/generation2/main.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/main.str	Wed Apr  3 14:53:44 2013	(r26041)
@@ -0,0 +1,32 @@
+module generation2/main
+
+imports
+  
+  libstrc
+  include/NameBindingLanguage
+  generation2/util
+  generation2/sections
+  
+rules
+  
+  generate-name-analysis:
+    (selected, position, ast at Module(name, _, _), path, project-path) -> (filename, result)
+    with
+      filename   := <guarantee-extension(|"str")> path ;
+      str-module := <to-ppable-str; nabl-to-str> ast ;
+      // use next line to debug which AST node cannot be handled by the pretty-printer
+      <bottomup(try(not(is-string) ; not(is-list) ; not(pp-stratego-string) ; debug(!"cannot pp ")))> str-module ;
+      result     := <pp-stratego-string> str-module
+
+rules // modules
+  
+  to-ppable-str = alltd(to-ppable-str-local)
+    
+  to-ppable-str-local: ListVar(x)    -> Var(x)
+  to-ppable-str-local: VarRef(x)     -> Var(x)
+  to-ppable-str-local: ListVarRef(x) -> Var(x)
+
+  nabl-to-str:
+    Module(name, _, sections) -> Module(name, sections')
+    where 
+      sections' := <filter(nabl-to-str)> sections 

Added: spoofax-imp/branches/nbl-dev/trans/generation2/rules.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/rules.str	Wed Apr  3 14:53:44 2013	(r26041)
@@ -0,0 +1,100 @@
+module generation2/rules
+  
+imports
+  
+  libstrc
+  include/NameBindingLanguage
+  
+  generation2/util
+  generation2/constraints
+  generation2/def-sites
+  generation2/use-sites
+  
+rules
+  
+  a = 
+    {x: id};
+    id
+    
+  nabl-to-str: 
+    BindingRule(pattern, constr*, clause*) -> [nrule*, crule*, rule*]
+    where 
+       <filter(def-to-name <+ use-to-name)> clause* => [t];
+       nrule* := [NAME_RULE(pattern, t)]
+    <+ nrule* := []
+    where
+      // collect bound variables
+      bound*   := <collect-all(?Var(_))> pattern
+      // collect names of bound variables
+    ; var*     := <map(?Var(<id>))> bound*
+      // collect horizontal scopes
+    ; scope*   := <filter(?ScopeClause(<id>)); concat; map(nabl-to-str)> clause*
+      // filter def clauses   
+    ; dclause* := <filter(?DefClause(_, _, _, _, _, _, _))> clause* 
+      // filter ref and import clauses
+    ; uclause* := <filter(?ImportClause(<id>))> clause*
+    where
+      // translate constraints
+      (repl*, bound2*, crule*, ctask*, n) := <constraints-to-str(|[], bound*, 1)> constr*
+      // translate def clauses
+    ; (drule*, c1*, c2*, m) := <clauses-to-str(|pattern, scope*, repl*, bound2*, n)> dclause*
+      // translate ref and import clauses
+    ; (urule*, c3*, c4*, _) := <clauses-to-str(|pattern, scope*, repl*, bound2*, m)> uclause*
+    where // combine rules
+      if 
+        <not(fetch-elem(def-to-name))> dclause* // no explicit def
+      ; <nonempty> scope*                       // anonymous scope
+      then
+        dcall1* := [Scope(var*, <to-seq> [Match(pattern), c1*, c3*, ANONYMOUS_CALL(scope*)])]
+      else 
+        dcall1* := <scope-seq(|var*, pattern)> [c1*, c3*]
+      end
+    ; dcall2* := <scope-seq(|var*, pattern)> ctask*
+    ; dcall3* := <scope-seq(|var*, pattern)> c4*
+    ; dcall4* := <scope-seq(|var*, pattern)> c2*
+    ; if <nonempty> [dcall1*, dcall2*, dcall3*, dcall4*] then
+        rule* := [NAME_RULE(<to-seq> [dcall1*, RECURSION(), dcall2*, dcall3*, dcall4*]), drule*]
+      else
+        rule* := []
+      end
+
+  scope-seq(|var*, pattern) = ?[] <+ ![Scope(var*, <to-seq> [Match(pattern)|<id>])]
+
+rules  
+  
+  clauses-to-str(|pattern, scopes, rep1*, b*, n):
+    [] -> ([], [], [], n)
+  
+  clauses-to-str(|pattern, scopes, rep*, b*, n):
+    [e|e*] -> ([r1*, r2*], [sc*, cl*], [a1*, a2*], k)
+    where
+       (r1*, sc*, a1*, m) := <clause-to-str(|pattern, scopes, rep*, b*, n)> e
+    <+ (r1*, sc*, a1*, m) := ([], [], [], n)
+    where
+       (r2*, cl*, a2*, k) := <clauses-to-str(|pattern, scopes, rep*, b*, m)> e*
+       
+overlays
+	
+	ANONYMOUS_CALL(scopes) =
+  CallT(
+    SVar("nabl-anonymous-scope")
+  , [Match(Var("child-uris__"))]
+  , [ Var("lang__")
+    , Var("partition__")
+    , Var("uniques__")
+    , Var("uris__")
+    , LIST(scopes) ]
+  )
+  
+  RECURSION =
+  CallT(
+    SVar("nabl-children")
+  , []
+  , [ Var("lang__")
+    , Var("partition__")
+    , Var("uniques__")
+    , Var("elems__")
+    , Var("tasks__")
+    , Var("child-uris__")]
+  )
+  	

Added: spoofax-imp/branches/nbl-dev/trans/generation2/scopes.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/scopes.str	Wed Apr  3 14:53:44 2013	(r26041)
@@ -0,0 +1,50 @@
+module generation2/scopes
+
+imports
+  libstrc
+  include/NameBindingLanguage
+  
+  generation2/util
+  
+rules
+  
+  scope-to-str(|ns, n): 
+    Current() -> ([], [], TERM("Current"), n)
+  
+  scope-to-str(|ns, n): 
+    DefScopes(ds*) -> (r*, ct*, LIST([ss*, v]), m) 
+    where 
+      if <fetch-elem(?Subsequent())> ds* then
+        ss* := [TERM("Subsequent")] 
+      else
+        ss* := []
+      end
+    ; if x := <fetch-elem(?Context(<id>))> ds* then 
+        v   := Var($[scope[n]__])
+      ; ct* := [SCOPE_CALL(v, ns)] 
+      ; m   := <inc> n
+      else 
+        ct* := []
+      ; m   := n
+      end
+    ; r*  := <filter(?Context(<id>); !(<id>, SCOPE_CALL(v)))> ds*
+       
+overlays
+  
+  SCOPE_CALL(v) = CallT(SVar("nabl-def-scope"), [], [v])
+  SCOPE_CALL(v, ns) = 
+  Where(
+    Assign(
+      v
+    , App(
+        CallT(
+          SVar("nabl-construct-def-scope")
+        , []
+        , [Var("lang__"), Var("partition__"), Var("uniques__")]
+        )
+      , ns
+      )
+    )
+  )
+ 
+     

Added: spoofax-imp/branches/nbl-dev/trans/generation2/sections.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/sections.str	Wed Apr  3 14:53:44 2013	(r26041)
@@ -0,0 +1,44 @@
+module generation2/sections
+
+imports
+  
+  libstrc
+  include/NameBindingLanguage
+  
+  generation2/util
+  generation2/rules
+    
+rules // namespaces 
+      
+  nabl-to-str:
+    Namespaces(namespaces) -> Signature([Constructors(<map(nabl-to-str)> namespaces)])
+    
+  nabl-to-str: // generates constructors for namespaces
+    NamespaceDef(ns) -> CONS_DECL(<ns-name-to-str> ns, "Namespace")
+  
+  nabl-to-str: NamespaceRef(ns) -> TERM(<ns-name-to-str> ns)
+
+  ns-name-to-str: ns -> $[NablNs[ns]]
+  
+rules // properties
+        
+  nabl-to-str:
+    Properties(props) -> Signature([Constructors(<map(nabl-to-str)> props)])
+  
+  nabl-to-str: // generate constructors for properties
+    PropertyDef(p, _, _) -> CONS_DECL(<ns-prop-name-to-str> p, "Property") 
+
+  nabl-to-str: PropertyRef(p) -> TERM(<ns-prop-name-to-str> p)
+  nabl-to-str: TypeProp()     -> TERM("Type")
+
+  ns-prop-name-to-str: p -> $[NablProp_[p]]
+
+rules // imports
+    
+  nabl-to-str = Imports(![ImportWildcard("lib/nbl"), ImportWildcard("lib/task")|<id>])
+    
+rules // binding rules
+
+  nabl-to-str:
+    BindingRules(rs) -> Rules(<filter(nabl-to-str); concat; nonempty> rs)
+    
\ No newline at end of file

Added: spoofax-imp/branches/nbl-dev/trans/generation2/use-sites.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/use-sites.str	Wed Apr  3 14:53:44 2013	(r26041)
@@ -0,0 +1,121 @@
+module generation2/use-sites
+
+imports
+  
+  libstrc
+  include/NameBindingLanguage
+  
+  generation2/util
+  generation2/main
+  generation2/constraints
+  generation2/rules
+  generation2/scopes
+  
+rules
+  
+  use-to-name = 
+    ?RefClause(<fetch-elem(use-to-name)>)
+  + ?RefClausePart(_, _, <id>, _, _, _)
+  + ?SingleImport(_, _, <id>, _, _, _, _, _)
+  + ?WildcardImport(_, _, Context(_, _, <id>, _, _), _, _)
+    
+  clause-to-str(|pattern, scopes, repl*, bound*, n):
+    ImportClause(import*) -> <clauses-to-str(|pattern, scopes, repl*, bound*, n)> import*
+    
+  clause-to-str(|pattern, scopes, repl*, bound*, n):
+    SingleImport(_, ns, t, ps, fsc, alias, isc, constr*) -> (r*, [sc*, dcall], pr*, k)
+    where
+      ns' := <nabl-to-str> ns
+    ; (r*, sc*, isc', m) := <scope-to-str(|ns', n)> isc
+    ; dcall := <replace-all(|r*)> pattern
+    ; b*    := <collect-all(?Var(_))> t
+    ; (r2*, b3*, rule*, pr*, k) := <constraints-to-str(|repl*, [bound*, b*], m)> constr*
+  
+  clause-to-str(|pattern, scopes, repl*, bound*, n):
+    WildcardImport(ns, ps, fsc, isc, constr*) -> (r*, [sc*, dcall], pr*, k)
+    where
+      ns' := <nabl-to-str> ns
+    ; (r*, sc*, isc', m) := <scope-to-str(|ns', n)> isc
+    ; dcall := <replace-all(|r*)> pattern
+    ; (r2*, b3*, rule*, pr*, k) := <constraints-to-str(|repl*, bound*, m)> constr*
+    
+// rules
+//   
+//   uses-to-str(|replace*, bound*, rule*, task*, pattern) =
+//     filter(?RefClause(<id>) + ?ImportClause(<id>));
+//     if nonempty then
+//       (rep*, task'*) := <foldl(use-to-str(|replace*, bound*, rule*))> (<id>, ([], task*));
+//       ubody  := <foldr(<replace-all(|rep*)> pattern, to-seq)> task'* ;
+//       <iset-add(|USE_RULE(Seq(Match(pattern), ubody)))> rule*
+//     end
+//   
+//   use-to-str(|replace*, bound*, rule*):
+//     (u, (r*, task*)) -> ([(t, USE_CALL(c*)), r*], task'*)
+//     where 
+//       t            := <use-to-name> u;
+//       (c*, task'*) := <foldl(id; (ref-to-str(|replace*, bound*, rule*) <+ Snd))> (u, ([], task*))
+//     
+//   ref-to-str(|replace*, bound*, rule*): 
+//     (c, (c*, task*)) -> ([c*, CANDIDATE(<nabl-to-str> ns, prop'*)], task'*)
+//     where
+//       < ?RefClausePart(_, ns, _, prop*, Current(), constr*)
+//       + ?SingleImport(_, ns, _, prop*, Current(), _, _, constr*)
+//       + ?WildcardImport(_, _, Context(_, ns, _, prop*, Current()), _, constr*)
+//       > c
+//     where
+//       replace2* := <hashtable-copy> replace*;
+//       bound2*   := <iset-copy> bound*;
+//       task'*    := <constraints-to-str(|replace2*, bound2*, rule*, task*)> constr*;
+//       prop'*    := <map(prop-to-str); alltd(replace(|replace2*))> prop*;
+//       <hashtable-destroy> replace2*;
+//       <iset-destroy> bound2*
+//       
+//   ref-to-str(|replace*, bound*, rule*): 
+//     (c, (c*, task*)) -> ([c*, CANDIDATE(<nabl-to-str> ns, <nabl-to-str> ns', t', prop'*)], task'*)
+//     where
+//       <?RefClausePart(_, ns, _, prop*, Context(_, ns', t, _, _), constr*)> c
+//     where
+//       replace2* := <hashtable-copy> replace*;
+//       bound2*   := <iset-copy> bound*;
+//       task'*    := <constraints-to-str(|replace2*, bound2*, rule*, task*)> constr*;
+//       prop'*    := <map(prop-to-str); alltd(replace(|replace2*))> prop*;
+//       t'        := <alltd(replace(|replace2*))> t;
+//       <hashtable-destroy> replace2*;
+//       <iset-destroy> bound2*
+//      
+//   prop-to-str:
+//     PropertyPattern(_, p, t) -> PROPERTY(<nabl-to-str> p, t)
+
+overlays
+     
+  USE_RULE(call) =
+  SDefT(
+    "nabl-use-site"
+  , []
+  , [ DefaultVarDec("lang__")
+    , DefaultVarDec("elems__")
+    , DefaultVarDec("tasks__")
+    , DefaultVarDec("uris__")
+    , DefaultVarDec("states__") 
+    ]
+  , call
+  )
+  
+  USE_CALL(candidates) =
+  CallT(
+    SVar("nabl-use")
+  , []
+  , [ Var("lang__")
+    , Var("elems__")
+    , Var("tasks__")
+    , Var("uris__")
+    , LIST(candidates)
+    ] 
+  )
+  
+  CANDIDATE(ns, ps) =
+  TERM("UseCandidate", [ns, LIST(ps), TERM("Current"), TERM("All")])
+
+  CANDIDATE(ns1, ns2, n, ps) =
+  TERM("UseCandidate", [ns1, LIST(ps), LIST([n]), TERM("One")])
+  
\ No newline at end of file

Added: spoofax-imp/branches/nbl-dev/trans/generation2/util.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/util.str	Wed Apr  3 14:53:44 2013	(r26041)
@@ -0,0 +1,40 @@
+module generation2/util
+
+imports
+  
+  libstrc
+  include/NameBindingLanguage
+  
+rules
+  
+  to-seq = is-list; foldr(![], to-seq)
+  
+  //to-seq: (c, Seq(c1, c2)) -> Seq(c1, Seq(c2, c)) 
+  to-seq: (c, s) -> Seq(c, s) where not (<?[]> s) 
+  to-seq: (c, []) -> c
+rules 
+  
+  nonempty = where(Hd)
+
+  replace-all(|rs) = alltd(replace(|rs) <+ introduce-id)
+  
+  replace(|rs): t -> <hashtable-get(|t)> rs
+  replace(|rs): t -> <lookup'> (t, rs)
+  
+  introduce-id: Wld()      -> Id()
+  introduce-id: Var(_)     -> Id()
+  introduce-id: ListVar(_) -> Id()
+    
+  iset-copy = iset-elements => elem*; new-iset ; iset-addlist(|elem*)
+  
+overlays
+  
+  CONS_DECL(c, t) = OpDecl(c, ConstType(SortNoArgs(t)))
+  TERM(o, args)   = NoAnnoList(Op(o, args))
+  TERM(o)         = TERM(o, [])
+  TUPLE(elems)    = NoAnnoList(Tuple(elems))
+  LIST(elems)     = NoAnnoList(List(elems))
+  CALL(s)         = CallNoArgs(SVar(s))
+
+  
+  
\ No newline at end of file

From g.h.wachsmuth at tudelft.nl  Wed Apr  3 18:33:13 2013
From: g.h.wachsmuth at tudelft.nl (Guido Wachsmuth)
Date: Wed, 03 Apr 2013 16:33:13 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26042 - in
	spoofax-imp/branches/nbl-dev/trans: . generation generation2
Message-ID: <20130403163313.654DD7F800F@mx1.tudelft.nl>

Author: GuidoWachsmuth
Date: Wed Apr  3 16:33:11 2013
New Revision: 26042
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26042&sc=1

Log:
split def and prop rules again

Replaced:
   spoofax-imp/branches/nbl-dev/trans/generation/
      - copied from r26041, spoofax-imp/branches/nbl-dev/trans/generation/
Modified:
   spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str
   spoofax-imp/branches/nbl-dev/trans/generation2/rules.str
   spoofax-imp/branches/nbl-dev/trans/namebindinglanguage.str

Modified: spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str	Wed Apr  3 14:53:44 2013	(r26041)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str	Wed Apr  3 16:33:11 2013	(r26042)
@@ -16,50 +16,32 @@
     
 rules
   
- //  clause-to-pre-str(|pattern, scopes, n):
- //    DefClause(Explicit(), u, ns, t, ps, ds, constr*) -> ([sc*, dcall], m)
- //    where
- //      ns'   := <nabl-to-str> ns
- //    ; (r*, sc*, ds', m) := <scope-to-str(|ns', n)> ds
- //    ; r     := (t,  DEF_CALL(ns', <nabl-to-str> u, ds', scopes))
- //    ; dcall := <replace-all(|[r, r*])> pattern
- //  
- //  clause-to-post-str(|pattern, repl*, bound*, n):
- //    DefClause(Explicit(), u, ns, t, ps, ds, constr*) -> (rule*, [pr*, pcall], m)
- //    where
- //      b2*   := <collect-all(?Var(_))> t
- //    ; (r2*, _, rule*, pr*, m) := <constraints-to-str(|repl*, [bound*, b2*], n)> constr*
- //    ; r2    := (t, PROP_CALL(<alltd(replace(|r2*)); map(prop-to-str)> ps))
- //    ; pcall := <replace-all(|[r2, r2*])> pattern
- //  
- //  clause-to-pre-str(|pattern, scopes, n):
- //    DefClause(Implicit(), u, ns, t, ps, ds, constr*) -> ([sc*, dcall], m)
- //    where
- //      ns' := <nabl-to-str> ns
- //    ; (r*, sc*, _, m) := <scope-to-str(|ns', n)> ds
- //    ; dcall := <replace-all(|r*)> pattern
- //     
- //  clause-to-post-str(|pattern, repl*, bound*, n):
- //    DefClause(Implicit(), u, ns, t, ps, ds, constr*) -> (rule*, [pr*, app], m)
- //    where
- //      ns' := <nabl-to-str> ns
- //    ; b*    := <collect-all(?Var(_))> t
- //    ; (r2*, b3*, rule*, pr*, m) := <constraints-to-str(|repl*, [bound*, b*], n)> constr*
- //    ; ps' := <map(prop-to-str); alltd(replace(|r2*))> ps
- //    ; app := DEF_APPLY(ns', <nabl-to-str> u, ds', t, ps')
- // 
-  clause-to-str(|pattern, scopes, repl*, bound*, n):
-    DefClause(Explicit(), u, ns, t, ps, ds, constr*) -> (rule*, [sc*, dcall], [pr*, pcall], k)
+  clause-to-def-rule(counter|pattern, scope*, n):
+    DefClause(Explicit(), unique, ns, term, _, defscope, constr*) -> DEF_RULE(Match(pattern), seq) 
     where
-      ns'   := <nabl-to-str> ns
-    ; (r*, sc*, ds', m) := <scope-to-str(|ns', n)> ds
-    ; r     := (t,  DEF_CALL(ns', <nabl-to-str> u, ds', scopes))
-    ; dcall := <replace-all(|[r, r*])> pattern
-    ; b2*   := <collect-all(?Var(_))> t
-    ; (r2*, b3*, rule*, pr*, k) := <constraints-to-str(|repl*, [bound*, b2*], m)> constr*
-    ; r2    := (t, PROP_CALL(<alltd(replace(|r2*)); map(prop-to-str)> ps))
-    ; pcall := <replace-all(|[r2, r2*])> pattern
+      ns-term := <nabl-to-str> ns
+    ; (replacement*, scope-clause*, defscope-var, <counter>) := <scope-to-str(|ns-term, n)> defscope
+    ; replacement := (term, DEF_CALL(ns-term, <nabl-to-str> unique, defscope-var, scope*))
+    ; congruence := <replace-all(|[replacement, replacement*])> pattern
+    ; seq := <to-seq> [scope-clause*, congruence]
     
+  clause-to-prop-rule(counter|pattern, glob-replacement*, glob-bound*, glob-task*, n):
+    DefClause(Explicit(), _, ns, term, prop*, _, constr*) -> [PROP_RULE(Match(pattern), seq), match-rule*]
+    where
+      ns-term     := <nabl-to-str> ns
+    ; patt-bound* := <collect-all(?Var(_))> term
+    ; (loc-replacement*, loc-bound*, match-rule*, loc-task*, <counter>) := <constraints-to-str(|glob-replacement*, [glob-bound*, patt-bound*], n)> constr*
+    ; replacement := (term, PROP_CALL(<alltd(replace(|loc-replacement*)); map(prop-to-str)> prop*))
+    ; congruence  := <replace-all(|[replacement])> pattern
+    ; seq := <to-seq> [glob-task*, loc-task*, congruence]
+      
+  clause-to-rules(counter|pattern, scope*, repl*, bound*, glob-task*, n):
+    def-clause -> [COORD_RULE(Match(pattern)), def-rule, prop-rule*]
+    where
+      clause-to-def-rule(?m|pattern, scope*, n) => def-rule
+    where
+      clause-to-prop-rule(counter|pattern, repl*, bound*, glob-task*, m) => prop-rule*
+     
   clause-to-str(|pattern, scopes, repl*, bound*, n):
     DefClause(Implicit(), u, ns, t, ps, ds, constr*) -> (rule*, [sc*, dcall], [pr*, app], k)
     where
@@ -80,21 +62,22 @@
   
 overlays
   
-  NAME_RULE(call) =
+  NAME_RULE(lhs, rhs) = RDefNoArgs("nabl-get-name", RuleNoCond(lhs, rhs))
+
+overlays
+  	
+	DEF_RULE(match, call) =
   SDefT(
-    "nabl-name-site"
+    "nabl-def-site"
   , [DefaultVarDec("child-uris__"), DefaultVarDec("sibl-uris__")]
   , [ DefaultVarDec("lang__")
     , DefaultVarDec("partition__")
     , DefaultVarDec("uniques__")
     , DefaultVarDec("elems__")
-    , DefaultVarDec("tasks__")
     , DefaultVarDec("uris__")
     , DefaultVarDec("states__")]
-  , call
-  )
-  
-  NAME_RULE(lhs, rhs) = RDefNoArgs("nabl-get-name", RuleNoCond(lhs, rhs))
+  , Seq(match, call)
+  )  
 	
   DEF_CALL(ns, u, ds, s) = 
   CallT(
@@ -108,6 +91,94 @@
     , ns, u, ds, LIST(s)]
   )
   
+overlays
+  
+	PROP_RULE(match, call)  =
+  SDefT(
+    "nabl-prop-site"
+  , []
+  , [ DefaultVarDec("lang__")
+    , DefaultVarDec("partition__")
+    , DefaultVarDec("elems__")
+    , DefaultVarDec("tasks__")
+    , DefaultVarDec("states__")]
+  , Seq(match, call)
+  )
+
+  PROP_CALL(ps) = 
+  CallT(
+    SVar("nabl-props")
+  , []
+  , [ Var("elems__"), LIST(ps)]
+  )
+  
+  PROPERTY(p, v) = TERM("Prop", [p, v])
+
+overlays
+    
+  COORD_RULE(match) =
+  SDefT(
+    "nabl-name-site"
+  , [DefaultVarDec("child-uris__"), DefaultVarDec("sibl-uris__")]
+  , [ DefaultVarDec("lang__")
+    , DefaultVarDec("partition__")
+    , DefaultVarDec("uniques__")
+    , DefaultVarDec("elems__")
+    , DefaultVarDec("tasks__")
+    , DefaultVarDec("uris__")
+    , DefaultVarDec("states__")]
+  , Seq(
+      match
+    , Seq(
+        DEF_SITE_CALL()
+      , Seq (
+          RECURSION()
+        , PROP_SITE_CALL()
+        )
+      )
+    )
+  )
+  
+  DEF_SITE_CALL = 
+  CallT(
+    SVar("nabl-def-site")
+  , [Match(Var("child-uris__")), CALL("sibl-uris__")]
+  , [ Var("lang__")
+    , Var("partition__")
+    , Var("uniques__")
+    , Var("elems__")
+    , Var("uris__")
+    , Var("states__")
+    ]
+  ) 
+
+  RECURSION =
+  CallT(
+    SVar("nabl-children")
+  , []
+  , [ Var("lang__")
+    , Var("partition__")
+    , Var("uniques__")
+    , Var("elems__")
+    , Var("tasks__")
+    , Var("child-uris__")]
+  )
+  
+  PROP_SITE_CALL = 
+  CallT(
+    SVar("nabl-prop-site")
+  , []
+  , [ Var("lang__")
+    , Var("partition__")
+    , Var("elems__")
+    , Var("tasks__")
+    , Var("states__")
+    ]
+  ) 
+
+
+overlays
+  
   IMP_DEF_CALL(ns, u, ds, s) = 
   CallT(
     SVar("nabl-def")
@@ -123,12 +194,4 @@
   DEF_APPLY(ns, u, ds, t, ps) = 
   Where(App(Seq(IMP_DEF_CALL(ns, u, ds, []), PROP_CALL(ps)), t))
   
-  PROP_CALL(ps) = 
-  CallT(
-    SVar("nabl-props")
-  , []
-  , [ Var("elems__"), LIST(ps)]
-  )
-  
-  PROPERTY(p, v) = TERM("Prop", [p, v])
 

Modified: spoofax-imp/branches/nbl-dev/trans/generation2/rules.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation2/rules.str	Wed Apr  3 14:53:44 2013	(r26041)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/rules.str	Wed Apr  3 16:33:11 2013	(r26042)
@@ -30,33 +30,35 @@
       // collect horizontal scopes
     ; scope*   := <filter(?ScopeClause(<id>)); concat; map(nabl-to-str)> clause*
       // filter def clauses   
-    ; dclause* := <filter(?DefClause(_, _, _, _, _, _, _))> clause* 
+    ; [dclause|_] := <filter(?DefClause(Explicit(), _, _, _, _, _, _))> clause* 
       // filter ref and import clauses
     ; uclause* := <filter(?ImportClause(<id>))> clause*
     where
       // translate constraints
       (repl*, bound2*, crule*, ctask*, n) := <constraints-to-str(|[], bound*, 1)> constr*
       // translate def clauses
-    ; (drule*, c1*, c2*, m) := <clauses-to-str(|pattern, scope*, repl*, bound2*, n)> dclause*
-      // translate ref and import clauses
-    ; (urule*, c3*, c4*, _) := <clauses-to-str(|pattern, scope*, repl*, bound2*, m)> uclause*
-    where // combine rules
-      if 
-        <not(fetch-elem(def-to-name))> dclause* // no explicit def
-      ; <nonempty> scope*                       // anonymous scope
-      then
-        dcall1* := [Scope(var*, <to-seq> [Match(pattern), c1*, c3*, ANONYMOUS_CALL(scope*)])]
-      else 
-        dcall1* := <scope-seq(|var*, pattern)> [c1*, c3*]
-      end
-    ; dcall2* := <scope-seq(|var*, pattern)> ctask*
-    ; dcall3* := <scope-seq(|var*, pattern)> c4*
-    ; dcall4* := <scope-seq(|var*, pattern)> c2*
-    ; if <nonempty> [dcall1*, dcall2*, dcall3*, dcall4*] then
-        rule* := [NAME_RULE(<to-seq> [dcall1*, RECURSION(), dcall2*, dcall3*, dcall4*]), drule*]
-      else
-        rule* := []
-      end
+    ; rule*  := <clause-to-rules(?m|pattern, scope*, repl*, bound2*, ctask*, n)> dclause
+    <+ rule* := []
+    // ; (drule*, c1*, c2*, m) := <clauses-to-str(|pattern, scope*, repl*, bound2*, n)> dclause*
+    //   // translate ref and import clauses
+    // ; (urule*, c3*, c4*, _) := <clauses-to-str(|pattern, scope*, repl*, bound2*, m)> uclause*
+    // where // combine rules
+    //   if 
+    //     <not(fetch-elem(def-to-name))> dclause* // no explicit def
+    //   ; <nonempty> scope*                       // anonymous scope
+    //   then
+    //     dcall1* := [Scope(var*, <to-seq> [Match(pattern), c1*, c3*, ANONYMOUS_CALL(scope*)])]
+    //   else 
+    //     dcall1* := <scope-seq(|var*, pattern)> [c1*, c3*]
+    //   end
+    // ; dcall2* := <scope-seq(|var*, pattern)> ctask*
+    // ; dcall3* := <scope-seq(|var*, pattern)> c4*
+    // ; dcall4* := <scope-seq(|var*, pattern)> c2*
+    // ; if <nonempty> [dcall1*, dcall2*, dcall3*, dcall4*] then
+    //     rule* := [NAME_RULE(<to-seq> [dcall1*, RECURSION(), dcall2*, dcall3*, dcall4*]), drule*]
+    //   else
+    //     rule* := []
+    //   end
 
   scope-seq(|var*, pattern) = ?[] <+ ![Scope(var*, <to-seq> [Match(pattern)|<id>])]
 
@@ -86,15 +88,5 @@
     , LIST(scopes) ]
   )
   
-  RECURSION =
-  CallT(
-    SVar("nabl-children")
-  , []
-  , [ Var("lang__")
-    , Var("partition__")
-    , Var("uniques__")
-    , Var("elems__")
-    , Var("tasks__")
-    , Var("child-uris__")]
-  )
+  
   	

Modified: spoofax-imp/branches/nbl-dev/trans/namebindinglanguage.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/namebindinglanguage.str	Wed Apr  3 14:53:44 2013	(r26041)
+++ spoofax-imp/branches/nbl-dev/trans/namebindinglanguage.str	Wed Apr  3 16:33:11 2013	(r26042)
@@ -9,7 +9,7 @@
   lib/compilation-library.generated
 	constraints
 	names
-  generation/-
+  generation2/-
 
 rules // Analysis
   

From g.h.wachsmuth at tudelft.nl  Wed Apr  3 19:20:07 2013
From: g.h.wachsmuth at tudelft.nl (Guido Wachsmuth)
Date: Wed, 03 Apr 2013 17:20:07 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26043 -
	spoofax-imp/branches/nbl-dev/trans/generation2
Message-ID: <20130403172007.D7D82CC191@mx4.tudelft.nl>

Author: GuidoWachsmuth
Date: Wed Apr  3 17:20:05 2013
New Revision: 26043
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26043&sc=1

Log:
handling multiple def sites

Modified:
   spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str
   spoofax-imp/branches/nbl-dev/trans/generation2/rules.str
   spoofax-imp/branches/nbl-dev/trans/generation2/scopes.str

Modified: spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str	Wed Apr  3 16:33:11 2013	(r26042)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str	Wed Apr  3 17:20:05 2013	(r26043)
@@ -16,14 +16,15 @@
     
 rules
   
-  clause-to-def-rule(counter|pattern, scope*, n):
-    DefClause(Explicit(), unique, ns, term, _, defscope, constr*) -> DEF_RULE(Match(pattern), seq) 
+  clause-to-def-rule(|pattern, scope*):
+    (o, DefClause(Explicit(), unique, ns, term, _, defscope, constr*)) -> [scope-clause*, congruence] 
     where
       ns-term := <nabl-to-str> ns
-    ; (replacement*, scope-clause*, defscope-var, <counter>) := <scope-to-str(|ns-term, n)> defscope
-    ; replacement := (term, DEF_CALL(ns-term, <nabl-to-str> unique, defscope-var, scope*))
+    ; i := <dec> o
+    ; (replacement*, scope-clause*, defscope-var, _) := <scope-to-str(|ns-term, i, 1)> defscope
+    ; replacement := (term, DEF_CALL(ns-term, <nabl-to-str> unique, defscope-var, scope*, $[child-uri__[i]], $[sibl-uri__[i]], $[child-uri__[o]], $[sibl-uri__[o]]))
     ; congruence := <replace-all(|[replacement, replacement*])> pattern
-    ; seq := <to-seq> [scope-clause*, congruence]
+   
     
   clause-to-prop-rule(counter|pattern, glob-replacement*, glob-bound*, glob-task*, n):
     DefClause(Explicit(), _, ns, term, prop*, _, constr*) -> [PROP_RULE(Match(pattern), seq), match-rule*]
@@ -36,11 +37,14 @@
     ; seq := <to-seq> [glob-task*, loc-task*, congruence]
       
   clause-to-rules(counter|pattern, scope*, repl*, bound*, glob-task*, n):
-    def-clause -> [COORD_RULE(Match(pattern)), def-rule, prop-rule*]
+    def-clause* -> [COORD_RULE(Match(pattern)), DEF_RULE(Match(pattern), seq)]//, prop-rule*]
     where
-      clause-to-def-rule(?m|pattern, scope*, n) => def-rule
-    where
-      clause-to-prop-rule(counter|pattern, repl*, bound*, glob-task*, m) => prop-rule*
+      map-with-index(clause-to-def-rule(|pattern, scope*)); concat => clause*
+    ; m := <length> def-clause*
+    ; <to-seq> [clause*, App(CALL("child-uris__"), Var($[child-uri__[m]])), App(CALL("sibl-uris__"), Var($[sibl-uri__[m]]))] => seq
+    
+    //where
+      //clause-to-prop-rule(counter|pattern, repl*, bound*, glob-task*, n) => prop-rule*
      
   clause-to-str(|pattern, scopes, repl*, bound*, n):
     DefClause(Implicit(), u, ns, t, ps, ds, constr*) -> (rule*, [sc*, dcall], [pr*, app], k)
@@ -74,20 +78,22 @@
     , DefaultVarDec("partition__")
     , DefaultVarDec("uniques__")
     , DefaultVarDec("elems__")
-    , DefaultVarDec("uris__")
+    , DefaultVarDec("child-uri__0")
+    , DefaultVarDec("sibl-uri__0")
     , DefaultVarDec("states__")]
   , Seq(match, call)
   )  
 	
-  DEF_CALL(ns, u, ds, s) = 
+  DEF_CALL(ns, u, ds, s, in-child-uris, in-sibl-uris, out-child-uris, out-sibl-uris) = 
   CallT(
     SVar("nabl-def")
-  , [Match(Var("child-uris__")), CALL("sibl-uris__")]
+  , [Match(Var(out-child-uris)), Match(Var(out-sibl-uris))]
   , [ Var("lang__")
     , Var("partition__")
     , Var("uniques__")
     , Var("elems__")
-    , Var("uris__")
+    , Var(in-child-uris)
+    , Var(in-sibl-uris)
     , ns, u, ds, LIST(s)]
   )
   

Modified: spoofax-imp/branches/nbl-dev/trans/generation2/rules.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation2/rules.str	Wed Apr  3 16:33:11 2013	(r26042)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/rules.str	Wed Apr  3 17:20:05 2013	(r26043)
@@ -30,14 +30,14 @@
       // collect horizontal scopes
     ; scope*   := <filter(?ScopeClause(<id>)); concat; map(nabl-to-str)> clause*
       // filter def clauses   
-    ; [dclause|_] := <filter(?DefClause(Explicit(), _, _, _, _, _, _))> clause* 
+    ; dclause* := <filter(?DefClause(Explicit(), _, _, _, _, _, _))> clause* 
       // filter ref and import clauses
     ; uclause* := <filter(?ImportClause(<id>))> clause*
     where
       // translate constraints
       (repl*, bound2*, crule*, ctask*, n) := <constraints-to-str(|[], bound*, 1)> constr*
       // translate def clauses
-    ; rule*  := <clause-to-rules(?m|pattern, scope*, repl*, bound2*, ctask*, n)> dclause
+    ; rule*  := <clause-to-rules(?m|pattern, scope*, repl*, bound2*, ctask*, n)> dclause*
     <+ rule* := []
     // ; (drule*, c1*, c2*, m) := <clauses-to-str(|pattern, scope*, repl*, bound2*, n)> dclause*
     //   // translate ref and import clauses

Modified: spoofax-imp/branches/nbl-dev/trans/generation2/scopes.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation2/scopes.str	Wed Apr  3 16:33:11 2013	(r26042)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/scopes.str	Wed Apr  3 17:20:05 2013	(r26043)
@@ -8,10 +8,12 @@
   
 rules
   
-  scope-to-str(|ns, n): 
+  scope-to-str(|ns, n) = scope-to-str(|ns, 0, n)
+  
+  scope-to-str(|ns, i, n): 
     Current() -> ([], [], TERM("Current"), n)
   
-  scope-to-str(|ns, n): 
+  scope-to-str(|ns, i, n): 
     DefScopes(ds*) -> (r*, ct*, LIST([ss*, v]), m) 
     where 
       if <fetch-elem(?Subsequent())> ds* then
@@ -20,7 +22,7 @@
         ss* := []
       end
     ; if x := <fetch-elem(?Context(<id>))> ds* then 
-        v   := Var($[scope[n]__])
+        v   := Var($[scope[i]_[n]__])
       ; ct* := [SCOPE_CALL(v, ns)] 
       ; m   := <inc> n
       else 

From g.h.wachsmuth at tudelft.nl  Wed Apr  3 20:08:32 2013
From: g.h.wachsmuth at tudelft.nl (Guido Wachsmuth)
Date: Wed, 03 Apr 2013 18:08:32 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26044 -
	spoofax-imp/branches/nbl-dev/trans/generation2
Message-ID: <20130403180832.396777F8039@mx1.tudelft.nl>

Author: GuidoWachsmuth
Date: Wed Apr  3 18:08:30 2013
New Revision: 26044
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26044&sc=1

Log:
support for props in the presence of multiple def clauses

Modified:
   spoofax-imp/branches/nbl-dev/trans/generation2/constraints.str
   spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str

Modified: spoofax-imp/branches/nbl-dev/trans/generation2/constraints.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation2/constraints.str	Wed Apr  3 17:20:05 2013	(r26043)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/constraints.str	Wed Apr  3 18:08:30 2013	(r26044)
@@ -9,21 +9,22 @@
   
 rules
   
-  constraints-to-str(|repl*, b*, n):
+  constraints-to-str(|repl*, b*, n) =  constraints-to-str(|repl*, b*, 0, n)
+  constraints-to-str(|repl*, b*, i, n):
   	[] -> (repl*, b*, [], [], n)
   
-  constraints-to-str(|repl*, b*, n):
+  constraints-to-str(|repl*, b*, i, n):
   	[c|cs] -> (r2*, b2*, [rule1*, rule2*], [task1*, task2*], k)
   	where
-    	(r1*, b1*, rule1*, task1*, m) := <constraint-to-str(|repl*, b*, n)> c;
-      (r2*, b2*, rule2*, task2*, k) := <constraints-to-str(|r1*, b1*, m)> cs
+    	(r1*, b1*, rule1*, task1*, m) := <constraint-to-str(|repl*, b*, i, n)> c;
+      (r2*, b2*, rule2*, task2*, k) := <constraints-to-str(|r1*, b1*, i, m)> cs
   		
-  constraint-to-str(|repl*, b*, n):  
+  constraint-to-str(|repl*, b*, i, n):  
     PropertyConstraint(t1, p, t2) -> ([r1*, repl*], [b1*, b*], rule*, [task, match*], m)
     where
       t1' := <alltd(replace(|repl*))> t1;
       // create new task for property calculation
-      r   := Var($[r[n]__]);
+      r   := Var($[r[i]_[n]__]);
       task := PROP_TASK(r, <nabl-to-str> p, t1');
       if 
         Var(v) := t2;
@@ -37,22 +38,22 @@
       	var*   := <collect-all(?Var(_))> t2;
       	bvar*  := <isect> (var*, b*);
       	bvar'* := <alltd(replace(|repl*))> bvar*;
-      	(r1*, b1*, match*, rule*, m) := <matches-to-str(|t2, r, bvar*, bvar'*, <inc> n)> var*
+      	(r1*, b1*, match*, rule*, m) := <matches-to-str(|t2, r, bvar*, bvar'*, i, <inc> n)> var*
       end
   
-   matches-to-str(|term, res, bvar*, bvar'*, n):
+   matches-to-str(|term, res, bvar*, bvar'*, i, n):
      [] -> ([], [], [], [], n)
    
-   matches-to-str(|term, res, bvar*, bvar'*, n):
+   matches-to-str(|term, res, bvar*, bvar'*, i, n):
      [c|cs] -> ([r, r*], [b, b*], [rule, rule*], [t, t*], m)
      where
-       (r, b, t, rule)        := <match-to-str(|term, res, bvar*, bvar'*, n)> c;
-       (r*, b*, t*, rule*, m) := <matches-to-str(|term, res, bvar*, bvar'*, <inc> n)> cs
+       (r, b, t, rule)        := <match-to-str(|term, res, bvar*, bvar'*, i, n)> c;
+       (r*, b*, t*, rule*, m) := <matches-to-str(|term, res, bvar*, bvar'*, i, <inc> n)> cs
        
-   match-to-str(|term, res, bvar*, bvar'*, n):
+   match-to-str(|term, res, bvar*, bvar'*, i, n):
   	t at Var(v) -> ((t, r), t, rule, task)
     where
-    	r    := Var($[r[n]__]);
+    	r    := Var($[r[i]_[n]__]);
     	mn   := NoAnnoList(Str(<newname; double-quote> "match"));
     	task := MATCH_TASK(r, mn, bvar'*, res);
     	rule := MATCH_RULE(mn, term, bvar*, Var(v))

Modified: spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str	Wed Apr  3 17:20:05 2013	(r26043)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str	Wed Apr  3 18:08:30 2013	(r26044)
@@ -26,25 +26,25 @@
     ; congruence := <replace-all(|[replacement, replacement*])> pattern
    
     
-  clause-to-prop-rule(counter|pattern, glob-replacement*, glob-bound*, glob-task*, n):
-    DefClause(Explicit(), _, ns, term, prop*, _, constr*) -> [PROP_RULE(Match(pattern), seq), match-rule*]
+  clause-to-prop-rule(|pattern, glob-replacement*, glob-bound*):
+    (o, DefClause(Explicit(), _, ns, term, prop*, _, constr*)) -> (match-rule*, [loc-task*, congruence])
     where
       ns-term     := <nabl-to-str> ns
+    ; i := <dec> o
     ; patt-bound* := <collect-all(?Var(_))> term
-    ; (loc-replacement*, loc-bound*, match-rule*, loc-task*, <counter>) := <constraints-to-str(|glob-replacement*, [glob-bound*, patt-bound*], n)> constr*
+    ; (loc-replacement*, loc-bound*, match-rule*, loc-task*, _) := <constraints-to-str(|glob-replacement*, [glob-bound*, patt-bound*], i, 1)> constr*
     ; replacement := (term, PROP_CALL(<alltd(replace(|loc-replacement*)); map(prop-to-str)> prop*))
     ; congruence  := <replace-all(|[replacement])> pattern
-    ; seq := <to-seq> [glob-task*, loc-task*, congruence]
       
-  clause-to-rules(counter|pattern, scope*, repl*, bound*, glob-task*, n):
-    def-clause* -> [COORD_RULE(Match(pattern)), DEF_RULE(Match(pattern), seq)]//, prop-rule*]
+  clause-to-rules(counter|pattern, scope*, glob-replacement*, glob-bound*, glob-task*, n):
+    def-clause* -> [COORD_RULE(Match(pattern)), DEF_RULE(Match(pattern), def-seq), rule*,  PROP_RULE(Match(pattern), prop-seq)]//, prop-rule*]
     where
       map-with-index(clause-to-def-rule(|pattern, scope*)); concat => clause*
     ; m := <length> def-clause*
-    ; <to-seq> [clause*, App(CALL("child-uris__"), Var($[child-uri__[m]])), App(CALL("sibl-uris__"), Var($[sibl-uri__[m]]))] => seq
-    
-    //where
-      //clause-to-prop-rule(counter|pattern, repl*, bound*, glob-task*, n) => prop-rule*
+    ; def-seq := <to-seq> [clause*, App(CALL("child-uris__"), Var($[child-uri__[m]])), App(CALL("sibl-uris__"), Var($[sibl-uri__[m]]))] 
+    where
+      map-with-index(clause-to-prop-rule(|pattern, glob-replacement*, glob-bound*)); unzip; (concat, concat) => (rule*, prop-clause*)
+    ; prop-seq := <to-seq> [glob-task*, prop-clause*, Id()]
      
   clause-to-str(|pattern, scopes, repl*, bound*, n):
     DefClause(Implicit(), u, ns, t, ps, ds, constr*) -> (rule*, [sc*, dcall], [pr*, app], k)

From g.h.wachsmuth at tudelft.nl  Wed Apr  3 20:30:10 2013
From: g.h.wachsmuth at tudelft.nl (Guido Wachsmuth)
Date: Wed, 03 Apr 2013 18:30:10 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26045 -
	spoofax-imp/branches/nbl-dev/trans/generation2
Message-ID: <20130403183010.62964108C021@mx3.tudelft.nl>

Author: GuidoWachsmuth
Date: Wed Apr  3 18:30:10 2013
New Revision: 26045
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26045&sc=1

Log:
prepared for implicits

Modified:
   spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str
   spoofax-imp/branches/nbl-dev/trans/generation2/util.str

Modified: spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str	Wed Apr  3 18:08:30 2013	(r26044)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str	Wed Apr  3 18:30:10 2013	(r26045)
@@ -36,12 +36,13 @@
     ; replacement := (term, PROP_CALL(<alltd(replace(|loc-replacement*)); map(prop-to-str)> prop*))
     ; congruence  := <replace-all(|[replacement])> pattern
       
+       
   clause-to-rules(counter|pattern, scope*, glob-replacement*, glob-bound*, glob-task*, n):
     def-clause* -> [COORD_RULE(Match(pattern)), DEF_RULE(Match(pattern), def-seq), rule*,  PROP_RULE(Match(pattern), prop-seq)]//, prop-rule*]
     where
       map-with-index(clause-to-def-rule(|pattern, scope*)); concat => clause*
     ; m := <length> def-clause*
-    ; def-seq := <to-seq> [clause*, App(CALL("child-uris__"), Var($[child-uri__[m]])), App(CALL("sibl-uris__"), Var($[sibl-uri__[m]]))] 
+    ; def-seq := <to-seq> [clause*, CALL("match", [CALL("child-uris__")], [Var($[child-uri__[m]])]), CALL("match", [CALL("sibl-uris__")], [Var($[sibl-uri__[m]])])] 
     where
       map-with-index(clause-to-prop-rule(|pattern, glob-replacement*, glob-bound*)); unzip; (concat, concat) => (rule*, prop-clause*)
     ; prop-seq := <to-seq> [glob-task*, prop-clause*, Id()]
@@ -73,7 +74,10 @@
 	DEF_RULE(match, call) =
   SDefT(
     "nabl-def-site"
-  , [DefaultVarDec("child-uris__"), DefaultVarDec("sibl-uris__")]
+  , [ DefaultVarDec("child-uris__")
+    , DefaultVarDec("sibl-uris__")
+    , DefaultVarDec("implicits__")
+    ]
   , [ DefaultVarDec("lang__")
     , DefaultVarDec("partition__")
     , DefaultVarDec("uniques__")
@@ -107,7 +111,9 @@
     , DefaultVarDec("partition__")
     , DefaultVarDec("elems__")
     , DefaultVarDec("tasks__")
-    , DefaultVarDec("states__")]
+    , DefaultVarDec("states__")
+    , DefaultVarDec("implicits__")
+    ]
   , Seq(match, call)
   )
 
@@ -148,12 +154,16 @@
   DEF_SITE_CALL = 
   CallT(
     SVar("nabl-def-site")
-  , [Match(Var("child-uris__")), CALL("sibl-uris__")]
+  , [ Match(Var("child-uris__"))
+    , CALL("sibl-uris__")
+    , Match(Var("implicits__"))
+    ]
   , [ Var("lang__")
     , Var("partition__")
     , Var("uniques__")
     , Var("elems__")
     , Var("uris__")
+    , Var("uris__")
     , Var("states__")
     ]
   ) 
@@ -179,10 +189,10 @@
     , Var("elems__")
     , Var("tasks__")
     , Var("states__")
+    , Var("implicits__")
     ]
   ) 
 
-
 overlays
   
   IMP_DEF_CALL(ns, u, ds, s) = 

Modified: spoofax-imp/branches/nbl-dev/trans/generation2/util.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation2/util.str	Wed Apr  3 18:08:30 2013	(r26044)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/util.str	Wed Apr  3 18:30:10 2013	(r26045)
@@ -35,6 +35,7 @@
   TUPLE(elems)    = NoAnnoList(Tuple(elems))
   LIST(elems)     = NoAnnoList(List(elems))
   CALL(s)         = CallNoArgs(SVar(s))
+  CALL(s, ss, ts) = CallT(SVar(s), ss, ts)
 
   
   
\ No newline at end of file

From g.h.wachsmuth at tudelft.nl  Thu Apr  4 18:45:40 2013
From: g.h.wachsmuth at tudelft.nl (Guido Wachsmuth)
Date: Thu, 04 Apr 2013 16:45:40 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26046 -
	spoofax-imp/branches/nbl-dev/trans/generation2
Message-ID: <20130404164540.07DEE7F8012@mx1.tudelft.nl>

Author: GuidoWachsmuth
Date: Thu Apr  4 16:45:39 2013
New Revision: 26046
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26046&sc=1

Log:
support for implicit defs

Modified:
   spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str
   spoofax-imp/branches/nbl-dev/trans/generation2/rules.str

Modified: spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str	Wed Apr  3 18:30:10 2013	(r26045)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str	Thu Apr  4 16:45:39 2013	(r26046)
@@ -17,47 +17,47 @@
 rules
   
   clause-to-def-rule(|pattern, scope*):
-    (o, DefClause(Explicit(), unique, ns, term, _, defscope, constr*)) -> [scope-clause*, congruence] 
+    (o, DefClause(kind, unique, ns, term, _, defscope, constr*)) -> ([scope-clause*, def-clause*], impl-var*)
     where
       ns-term := <nabl-to-str> ns
+    ; unique-term := <nabl-to-str> unique
     ; i := <dec> o
-    ; (replacement*, scope-clause*, defscope-var, _) := <scope-to-str(|ns-term, i, 1)> defscope
-    ; replacement := (term, DEF_CALL(ns-term, <nabl-to-str> unique, defscope-var, scope*, $[child-uri__[i]], $[sibl-uri__[i]], $[child-uri__[o]], $[sibl-uri__[o]]))
-    ; congruence := <replace-all(|[replacement, replacement*])> pattern
+    ; (replacement*, scope-clause*, defscope-term, _) := <scope-to-str(|ns-term, i, 1)> defscope
+    ; scope'* := <?Explicit() < !scope* + ![]> kind
+    ; def-call := DEF_CALL(ns-term, unique-term, defscope-term, scope'*, $[child-uri__[i]], $[sibl-uri__[i]], $[child-uri__[o]], $[sibl-uri__[o]])
+    ; if Explicit() := kind then
+        def-clause* := [<replace-all(|[(term, def-call), replacement*])> pattern]
+      ; impl-var*   := []
+      else
+        impl-var    := Var($[i[i]__])
+      ; def-clause* := [<replace-all(|replacement*)> pattern, Where(Assign(impl-var, App(def-call, term)))]
+      ; impl-var*   := [impl-var]
+      end
    
-    
   clause-to-prop-rule(|pattern, glob-replacement*, glob-bound*):
-    (o, DefClause(Explicit(), _, ns, term, prop*, _, constr*)) -> (match-rule*, [loc-task*, congruence])
+    (o, DefClause(kind, _, ns, term, prop*, _, constr*)) -> (match-rule*, [loc-task*, call])
     where
       ns-term     := <nabl-to-str> ns
     ; i := <dec> o
     ; patt-bound* := <collect-all(?Var(_))> term
     ; (loc-replacement*, loc-bound*, match-rule*, loc-task*, _) := <constraints-to-str(|glob-replacement*, [glob-bound*, patt-bound*], i, 1)> constr*
-    ; replacement := (term, PROP_CALL(<alltd(replace(|loc-replacement*)); map(prop-to-str)> prop*))
-    ; congruence  := <replace-all(|[replacement])> pattern
-      
+    ; prop-call := PROP_CALL(<alltd(replace(|loc-replacement*)); map(prop-to-str)> prop*)
+    ; if Explicit() := kind then
+        call := <replace-all(|[(term, prop-call)])> pattern
+      else
+        call := Where(App(prop-call, Var($[i[i]__])))
+      end
        
   clause-to-rules(counter|pattern, scope*, glob-replacement*, glob-bound*, glob-task*, n):
     def-clause* -> [COORD_RULE(Match(pattern)), DEF_RULE(Match(pattern), def-seq), rule*,  PROP_RULE(Match(pattern), prop-seq)]//, prop-rule*]
     where
-      map-with-index(clause-to-def-rule(|pattern, scope*)); concat => clause*
+      map-with-index(clause-to-def-rule(|pattern, scope*)); unzip; (concat, concat) => (clause*, implicit*)
     ; m := <length> def-clause*
-    ; def-seq := <to-seq> [clause*, CALL("match", [CALL("child-uris__")], [Var($[child-uri__[m]])]), CALL("match", [CALL("sibl-uris__")], [Var($[sibl-uri__[m]])])] 
+    ; def-seq := <to-seq> [clause*, MATCH(CALL("child-uris__"), Var($[child-uri__[m]])), MATCH(CALL("sibl-uris__"), Var($[sibl-uri__[m]])), MATCH(CALL("implicits__"), LIST(implicit*))] 
     where
       map-with-index(clause-to-prop-rule(|pattern, glob-replacement*, glob-bound*)); unzip; (concat, concat) => (rule*, prop-clause*)
-    ; prop-seq := <to-seq> [glob-task*, prop-clause*, Id()]
-     
-  clause-to-str(|pattern, scopes, repl*, bound*, n):
-    DefClause(Implicit(), u, ns, t, ps, ds, constr*) -> (rule*, [sc*, dcall], [pr*, app], k)
-    where
-      ns' := <nabl-to-str> ns
-    ; (r*, sc*, ds', m) := <scope-to-str(|ns', n)> ds
-    ; dcall := <replace-all(|r*)> pattern
-    ; b*    := <collect-all(?Var(_))> t
-    ; (r2*, b3*, rule*, pr*, k) := <constraints-to-str(|repl*, [bound*, b*], m)> constr*
-    ; ps' := <map(prop-to-str); alltd(replace(|r2*))> ps
-    ; app := DEF_APPLY(ns', <nabl-to-str> u, ds', t, ps')
-
+    ; prop-seq := <to-seq> [Assign(LIST(implicit*), Var("implicits__")), glob-task*, prop-clause*, Id()]
+  
 rules
          
   prop-to-str: PropertyTerm(p, t) -> PROPERTY(<nabl-to-str> p, t)     
@@ -195,19 +195,5 @@
 
 overlays
   
-  IMP_DEF_CALL(ns, u, ds, s) = 
-  CallT(
-    SVar("nabl-def")
-  , []
-  , [ Var("lang__")
-    , Var("partition__")
-    , Var("uniques__")
-    , Var("elems__")
-    , Var("uris__")
-    , ns, u, ds, LIST(s)]
-  )
-  
-  DEF_APPLY(ns, u, ds, t, ps) = 
-  Where(App(Seq(IMP_DEF_CALL(ns, u, ds, []), PROP_CALL(ps)), t))
-  
-
+  MATCH(s, v) =
+  CALL("match", [s], [v])

Modified: spoofax-imp/branches/nbl-dev/trans/generation2/rules.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation2/rules.str	Wed Apr  3 18:30:10 2013	(r26045)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/rules.str	Thu Apr  4 16:45:39 2013	(r26046)
@@ -30,7 +30,7 @@
       // collect horizontal scopes
     ; scope*   := <filter(?ScopeClause(<id>)); concat; map(nabl-to-str)> clause*
       // filter def clauses   
-    ; dclause* := <filter(?DefClause(Explicit(), _, _, _, _, _, _))> clause* 
+    ; dclause* := <filter(?DefClause(_, _, _, _, _, _, _))> clause* 
       // filter ref and import clauses
     ; uclause* := <filter(?ImportClause(<id>))> clause*
     where

From g.h.wachsmuth at tudelft.nl  Thu Apr  4 21:24:30 2013
From: g.h.wachsmuth at tudelft.nl (Guido Wachsmuth)
Date: Thu, 04 Apr 2013 19:24:30 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26047 -
	spoofax-imp/branches/nbl-dev/trans/generation2
Message-ID: <20130404192430.5746A2B8034@mx2.tudelft.nl>

Author: GuidoWachsmuth
Date: Thu Apr  4 19:24:28 2013
New Revision: 26047
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26047&sc=1

Log:
avoid empty list matching

Modified:
   spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str

Modified: spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str	Thu Apr  4 16:45:39 2013	(r26046)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str	Thu Apr  4 19:24:28 2013	(r26047)
@@ -56,7 +56,8 @@
     ; def-seq := <to-seq> [clause*, MATCH(CALL("child-uris__"), Var($[child-uri__[m]])), MATCH(CALL("sibl-uris__"), Var($[sibl-uri__[m]])), MATCH(CALL("implicits__"), LIST(implicit*))] 
     where
       map-with-index(clause-to-prop-rule(|pattern, glob-replacement*, glob-bound*)); unzip; (concat, concat) => (rule*, prop-clause*)
-    ; prop-seq := <to-seq> [Assign(LIST(implicit*), Var("implicits__")), glob-task*, prop-clause*, Id()]
+    ; match* := <nonempty < ![Assign(LIST(implicit*), Var("implicits__"))] + ![]> implicit*
+    ; prop-seq := <to-seq> [match*, glob-task*, prop-clause*, Id()]
   
 rules
          

From R.B.Vermaas at tudelft.nl  Tue Apr  9 17:57:28 2013
From: R.B.Vermaas at tudelft.nl (Rob Vermaas)
Date: Tue, 09 Apr 2013 15:57:28 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26048 -
	hydra/strategoxt
Message-ID: <20130409155728.361802B8019@mx2.tudelft.nl>

Author: rob
Date: Tue Apr  9 15:57:26 2013
New Revision: 26048
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26048&sc=1

Log:
Fix strcJava build

Modified:
   hydra/strategoxt/packages.nix

Modified: hydra/strategoxt/packages.nix
==============================================================================
--- hydra/strategoxt/packages.nix	Thu Apr  4 19:24:28 2013	(r26047)
+++ hydra/strategoxt/packages.nix	Tue Apr  9 15:57:26 2013	(r26048)
@@ -441,6 +441,7 @@
       customEnv = {
         postInstall = '' 
           ensureDir $out/nix-support
+          echo "nix-build out $out" >> $out/nix-support/hydra-build-products
           echo "file jar $out/share/strc-java/strategoxt.jar" >> $out/nix-support/hydra-build-products
         '';
       };

From gabrielkonat at gmail.com  Thu Apr 11 12:47:39 2013
From: gabrielkonat at gmail.com (GabriÃ«l Konat)
Date: Thu, 11 Apr 2013 10:47:39 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26049 -
	spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms
Message-ID: <20130411104739.84B7A108C039@mx3.tudelft.nl>

Author: gkonat
Date: Thu Apr 11 10:47:32 2013
New Revision: 26049
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26049&sc=1

Log:
Calculate size of immutable list at construction

Modified:
   spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoList.java

Modified: spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoList.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoList.java	Tue Apr  9 15:57:26 2013	(r26048)
+++ spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoList.java	Thu Apr 11 10:47:32 2013	(r26049)
@@ -46,7 +46,10 @@
         this.head = head;
         this.tail = tail;
         
-        if (storageType != MUTABLE) initImmutableHashCode();
+        if (storageType != MUTABLE) { 
+        	initImmutableHashCode();
+        	size = calculateSize();
+    	}
     }
     
     public IStrategoTerm head() {
@@ -89,6 +92,10 @@
     public final int size() {
         return getSubtermCount();
     }
+    
+    protected int calculateSize() {
+    	return (head == null ? 0 : 1) + (tail == null ? 0 : tail.size());
+    }
 
     public IStrategoTerm getSubterm(int index) {
         IStrategoList list = this;
@@ -101,16 +108,10 @@
     }
 
     public int getSubtermCount() {
-    	int result = size;
-		if (result == UNKNOWN_SIZE) {
-    		result = 0;
-    		for (IStrategoList cur = this; !cur.isEmpty(); cur = cur.tail())
-    			result++;
-    		if (getStorageType() != MUTABLE)
-    			size = result;
-    		return result;
+		if (size == UNKNOWN_SIZE) {
+    		return calculateSize();
     	} else {
-    		return result;
+    		return size;
     	}
     }
 

From v.vergu+vc at gmail.com  Thu Apr 11 20:19:38 2013
From: v.vergu+vc at gmail.com (Vlad Vergu)
Date: Thu, 11 Apr 2013 18:19:38 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26050 -
	spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast
Message-ID: <20130411181938.E7BB6108C00E@mx3.tudelft.nl>

Author: VladVergu
Date: Thu Apr 11 18:19:37 2013
New Revision: 26050
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26050&sc=1

Log:
Placing a maximum length restriction on the marker message

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/MarkerSignature.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/MarkerSignature.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/MarkerSignature.java	Thu Apr 11 10:47:32 2013	(r26049)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/MarkerSignature.java	Thu Apr 11 18:19:37 2013	(r26050)
@@ -23,6 +23,8 @@
  */
 public class MarkerSignature {
 
+	private static final int MAX_MESSAGE_LEN = 1000;
+
 	private static final String[] ATTRIBUTES = { LINE_NUMBER, CHAR_START, CHAR_END, MESSAGE, SEVERITY, PRIORITY, TRANSIENT };
 	
 	private IResource resource;
@@ -39,10 +41,10 @@
 	
 	public MarkerSignature(IResource resource, IToken left, IToken right, String message,
 			int severity, int priority, boolean isTransient) {
-		if (message == null) message = "Problem";
+		assert message != null;
 		this.resource = resource;
 		this.line = left.getLine();
-		this.message = message;
+		this.message = message.substring(0, Math.min(message.length(), MAX_MESSAGE_LEN));
 		this.severity = severity;
 		this.comparisonMessage = removeSyntaxErrorDetails(message);
 		this.values = new Object[] { line, left.getStartOffset(), right.getEndOffset() + 1, message, severity, priority, isTransient };

From v.vergu+vc at gmail.com  Fri Apr 12 14:26:54 2013
From: v.vergu+vc at gmail.com (Vlad Vergu)
Date: Fri, 12 Apr 2013 12:26:54 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26051 -
	spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/binary
Message-ID: <20130412122654.B25A57F8077@mx1.tudelft.nl>

Author: VladVergu
Date: Fri Apr 12 12:26:52 2013
New Revision: 26051
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26051&sc=1

Log:
Performance enhancement of SAFWriter in the case of serialization of lists

Modified:
   spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/binary/SAFWriter.java

Modified: spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/binary/SAFWriter.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/binary/SAFWriter.java	Thu Apr 11 18:19:37 2013	(r26050)
+++ spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/io/binary/SAFWriter.java	Fri Apr 12 12:26:52 2013	(r26051)
@@ -240,27 +240,30 @@
      */
     private IStrategoTerm getNextTerm() {
         IStrategoTerm next = null;
-
         // Make sure the stack remains large enough
         ensureStackCapacity();
 
         while (next == null && stackPosition > -1) {
             ATermMapping current = stack[stackPosition];
             IStrategoTerm term = current.term;
-
-            if (term.getSubtermCount() > current.subTermIndex + 1) {
+	    final boolean hasRemainigSubterms = current.subTermsAfter > 0
+		    || term.getSubtermCount() > current.subTermIndex + 1;
+	    if (hasRemainigSubterms) {
                 if (term.getTermType() != IStrategoTerm.LIST) {
                     next = term.getSubterm(++current.subTermIndex);
                 } else {
                     IStrategoList nextList = current.nextPartOfList;
                     next = nextList.head();
                     current.nextPartOfList = nextList.tail();
-
                     current.subTermIndex++;
+		    current.subTermsAfter--;
                 }
 
                 ATermMapping child = new ATermMapping();
                 child.term = next;
+		if (next.getTermType() == IStrategoTerm.LIST) {
+		    child.subTermsAfter = next.getSubtermCount();
+		}
                 stack[++stackPosition] = child;
             } else if (!current.annosDone && !term.getAnnotations().isEmpty()) {
                 next = term.getAnnotations();
@@ -315,6 +318,7 @@
         public IStrategoTerm term;
 
         public int subTermIndex = -1;
+	public int subTermsAfter = -1;
 
         public boolean annosDone = false;
 

From gabrielkonat at gmail.com  Tue Apr 16 16:47:42 2013
From: gabrielkonat at gmail.com (GabriÃ«l Konat)
Date: Tue, 16 Apr 2013 14:47:42 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26052 - in
	spoofax/trunk/spoofax:
	org.spoofax.interpreter.core/src/main/java/org/spoofax/interpreter/library/ssl
	org.spoofax.terms/src/org/spoofax org.spoofax.terms/src/or...
Message-ID: <20130416144742.C40DB2B8017@mx2.tudelft.nl>

Author: gkonat
Date: Tue Apr 16 14:47:41 2013
New Revision: 26052
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26052&sc=1

Log:
Always cache list size.
Added Iterable<IStrategoTerm> interface to IStrategoTerm.

Added:
   spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/ArrayIterator.java
   spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/EmptyIterator.java
Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/main/java/org/spoofax/interpreter/library/ssl/StrategoHashMap.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/main/java/org/spoofax/interpreter/library/ssl/StrategoSet.java
   spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/IStrategoTerm.java
   spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoAppl.java
   spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoConstructor.java
   spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoInt.java
   spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoReal.java
   spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoString.java
   spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoTuple.java
   spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoWrapped.java
   spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/UniqueValueTerm.java
   spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/skeleton/SkeletonStrategoInt.java

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/main/java/org/spoofax/interpreter/library/ssl/StrategoHashMap.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/main/java/org/spoofax/interpreter/library/ssl/StrategoHashMap.java	Fri Apr 12 12:26:52 2013	(r26051)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/main/java/org/spoofax/interpreter/library/ssl/StrategoHashMap.java	Tue Apr 16 14:47:41 2013	(r26052)
@@ -1,6 +1,7 @@
 package org.spoofax.interpreter.library.ssl;
 
 import java.io.IOException;
+import java.util.Iterator;
 import java.util.LinkedHashMap;
 
 import org.spoofax.interpreter.terms.ISimpleTerm;
@@ -103,4 +104,7 @@
         return false;
     }
 
+    public Iterator<IStrategoTerm> iterator() {
+        return this.iterator();
+    }
 }

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/main/java/org/spoofax/interpreter/library/ssl/StrategoSet.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/main/java/org/spoofax/interpreter/library/ssl/StrategoSet.java	Fri Apr 12 12:26:52 2013	(r26051)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/main/java/org/spoofax/interpreter/library/ssl/StrategoSet.java	Tue Apr 16 14:47:41 2013	(r26052)
@@ -13,6 +13,7 @@
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
@@ -159,4 +160,7 @@
         return false;
     }
 
+    public Iterator<IStrategoTerm> iterator() {
+        return map.keySet().iterator();
+    }
 }

Added: spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/ArrayIterator.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/ArrayIterator.java	Tue Apr 16 14:47:41 2013	(r26052)
@@ -0,0 +1,28 @@
+package org.spoofax;
+
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+public class ArrayIterator<T> implements Iterator<T> {
+	private final T array[];
+	private int pos = 0;
+
+	public ArrayIterator(T array[]) {
+		this.array = array;
+	}
+
+	public boolean hasNext() {
+		return pos < array.length;
+	}
+
+	public T next() throws NoSuchElementException {
+		if(hasNext())
+			return array[pos++];
+		else
+			throw new NoSuchElementException();
+	}
+
+	public void remove() {
+		throw new UnsupportedOperationException();
+	}
+}

Added: spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/EmptyIterator.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/EmptyIterator.java	Tue Apr 16 14:47:41 2013	(r26052)
@@ -0,0 +1,17 @@
+package org.spoofax;
+
+import java.util.Iterator;
+
+public class EmptyIterator<T> implements Iterator<T> {
+	public T next() {
+		return null;
+	}
+
+	public boolean hasNext() {
+		return false;
+	}
+
+	public void remove() {
+		throw new UnsupportedOperationException();
+	}
+}

Modified: spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/IStrategoTerm.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/IStrategoTerm.java	Fri Apr 12 12:26:52 2013	(r26051)
+++ spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/interpreter/terms/IStrategoTerm.java	Tue Apr 16 14:47:41 2013	(r26052)
@@ -11,7 +11,7 @@
 import java.io.Serializable;
 import java.io.Writer;
 
-public interface IStrategoTerm extends ISimpleTerm, Serializable{
+public interface IStrategoTerm extends ISimpleTerm, Serializable, Iterable<IStrategoTerm> {
 
     public static final int APPL = 1;
     public static final int LIST = 2;

Modified: spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoAppl.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoAppl.java	Fri Apr 12 12:26:52 2013	(r26051)
+++ spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoAppl.java	Tue Apr 16 14:47:41 2013	(r26052)
@@ -8,7 +8,9 @@
 package org.spoofax.terms;
 
 import java.io.IOException;
+import java.util.Iterator;
 
+import org.spoofax.ArrayIterator;
 import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoConstructor;
 import org.spoofax.interpreter.terms.IStrategoList;
@@ -147,5 +149,8 @@
         }
         return (int)(r >> 12);
     }
-    
+
+	public Iterator<IStrategoTerm> iterator() {
+		return new ArrayIterator<IStrategoTerm>(kids);
+	}
 }

Modified: spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoConstructor.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoConstructor.java	Fri Apr 12 12:26:52 2013	(r26051)
+++ spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoConstructor.java	Tue Apr 16 14:47:41 2013	(r26052)
@@ -8,7 +8,9 @@
 package org.spoofax.terms;
 
 import java.io.IOException;
+import java.util.Iterator;
 
+import org.spoofax.EmptyIterator;
 import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoConstructor;
 import org.spoofax.interpreter.terms.IStrategoList;
@@ -101,4 +103,8 @@
 	public IStrategoAppl instantiate(ITermFactory factory, IStrategoList kids) {
 		throw new UnsupportedOperationException();
 	}
+
+	public Iterator<IStrategoTerm> iterator() {
+		return new EmptyIterator<IStrategoTerm>();
+	}
 }

Modified: spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoInt.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoInt.java	Fri Apr 12 12:26:52 2013	(r26051)
+++ spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoInt.java	Tue Apr 16 14:47:41 2013	(r26052)
@@ -8,7 +8,9 @@
 package org.spoofax.terms;
 
 import java.io.IOException;
+import java.util.Iterator;
 
+import org.spoofax.EmptyIterator;
 import org.spoofax.interpreter.terms.IStrategoInt;
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoTerm;
@@ -89,4 +91,8 @@
     public int hashFunction() {
         return 449 * intValue() ^ 7841;
     }
+
+	public Iterator<IStrategoTerm> iterator() {
+		return new EmptyIterator<IStrategoTerm>();
+	}
 }

Modified: spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoReal.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoReal.java	Fri Apr 12 12:26:52 2013	(r26051)
+++ spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoReal.java	Tue Apr 16 14:47:41 2013	(r26052)
@@ -8,7 +8,9 @@
 package org.spoofax.terms;
 
 import java.io.IOException;
+import java.util.Iterator;
 
+import org.spoofax.EmptyIterator;
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoReal;
 import org.spoofax.interpreter.terms.IStrategoTerm;
@@ -85,4 +87,8 @@
     public int hashFunction() {
         return (int)(449 * value) ^ 7841;
     }
+
+	public Iterator<IStrategoTerm> iterator() {
+		return new EmptyIterator<IStrategoTerm>();
+	}
 }

Modified: spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoString.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoString.java	Fri Apr 12 12:26:52 2013	(r26051)
+++ spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoString.java	Tue Apr 16 14:47:41 2013	(r26052)
@@ -8,7 +8,9 @@
 package org.spoofax.terms;
 
 import java.io.IOException;
+import java.util.Iterator;
 
+import org.spoofax.EmptyIterator;
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoString;
 import org.spoofax.interpreter.terms.IStrategoTerm;
@@ -109,5 +111,8 @@
     public int hashFunction() {
         return stringValue().hashCode();
     }
-    
+
+	public Iterator<IStrategoTerm> iterator() {
+		return new EmptyIterator<IStrategoTerm>();
+	}
 }

Modified: spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoTuple.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoTuple.java	Fri Apr 12 12:26:52 2013	(r26051)
+++ spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoTuple.java	Tue Apr 16 14:47:41 2013	(r26052)
@@ -8,7 +8,9 @@
 package org.spoofax.terms;
 
 import java.io.IOException;
+import java.util.Iterator;
 
+import org.spoofax.ArrayIterator;
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.IStrategoTuple;
@@ -144,4 +146,7 @@
         return (int)(hc >> 10);
     }
 
+	public Iterator<IStrategoTerm> iterator() {
+		return new ArrayIterator<IStrategoTerm>(kids);
+	}
 }

Modified: spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoWrapped.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoWrapped.java	Fri Apr 12 12:26:52 2013	(r26051)
+++ spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoWrapped.java	Tue Apr 16 14:47:41 2013	(r26052)
@@ -1,6 +1,7 @@
 package org.spoofax.terms;
 
 import java.io.IOException;
+import java.util.Iterator;
 
 import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoConstructor;
@@ -179,4 +180,8 @@
 		return ((IStrategoString) wrapped).stringValue();
 	}
 
+	public Iterator<IStrategoTerm> iterator() {
+		return wrapped.iterator();
+	}
+
 }
\ No newline at end of file

Modified: spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/UniqueValueTerm.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/UniqueValueTerm.java	Fri Apr 12 12:26:52 2013	(r26051)
+++ spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/UniqueValueTerm.java	Tue Apr 16 14:47:41 2013	(r26052)
@@ -1,14 +1,14 @@
 package org.spoofax.terms;
 
 import java.io.IOException;
+import java.util.Iterator;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import org.spoofax.EmptyIterator;
 import org.spoofax.interpreter.terms.IStrategoInt;
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.ITermPrinter;
-import org.spoofax.terms.AbstractSimpleTerm;
-import org.spoofax.terms.TermFactory;
 
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
@@ -89,5 +89,9 @@
 	public boolean isList() {
 		return false;
 	}
+
+	public Iterator<IStrategoTerm> iterator() {
+		return new EmptyIterator<IStrategoTerm>();
+	}
 	
 }
\ No newline at end of file

Modified: spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/skeleton/SkeletonStrategoInt.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/skeleton/SkeletonStrategoInt.java	Fri Apr 12 12:26:52 2013	(r26051)
+++ spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/skeleton/SkeletonStrategoInt.java	Tue Apr 16 14:47:41 2013	(r26052)
@@ -7,7 +7,9 @@
 
 import java.io.IOException;
 import java.math.BigInteger;
+import java.util.Iterator;
 
+import org.spoofax.EmptyIterator;
 import org.spoofax.NotImplementedException;
 import org.spoofax.interpreter.terms.IStrategoInt;
 import org.spoofax.interpreter.terms.IStrategoList;
@@ -89,4 +91,8 @@
     public int hashFunction() {
         return 449 * intValue() ^ 7841;
     }
+    
+	public Iterator<IStrategoTerm> iterator() {
+		return new EmptyIterator<IStrategoTerm>();
+	}
 }

From gabrielkonat at gmail.com  Tue Apr 16 22:17:53 2013
From: gabrielkonat at gmail.com (GabriÃ«l Konat)
Date: Tue, 16 Apr 2013 20:17:53 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26053 - in
	spoofax/trunk/spoofax:
	org.spoofax.interpreter.adapter.ecj/src/main/java/org/spoofax/interpreter/adapter/ecj
	org.spoofax.interpreter.library.interpreter/src/mai...
Message-ID: <20130416201753.62D77CC220@mx4.tudelft.nl>

Author: gkonat
Date: Tue Apr 16 20:17:51 2013
New Revision: 26053
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26053&sc=1

Log:
Always cache list size.
Added Iterable<IStrategoTerm> interface to IStrategoTerm.

Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/main/java/org/spoofax/interpreter/adapter/ecj/ECJAnnoWrapper.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/main/java/org/spoofax/interpreter/adapter/ecj/ECJConstructor.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.interpreter/src/main/java/org/spoofax/interpreter/library/interpreter/SpoofaxInterpreterTerm.java
   spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/LazyTerm.java
   spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoList.java
   spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/skeleton/SkeletonStrategoAppl.java

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/main/java/org/spoofax/interpreter/adapter/ecj/ECJAnnoWrapper.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/main/java/org/spoofax/interpreter/adapter/ecj/ECJAnnoWrapper.java	Tue Apr 16 14:47:41 2013	(r26052)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/main/java/org/spoofax/interpreter/adapter/ecj/ECJAnnoWrapper.java	Tue Apr 16 20:17:51 2013	(r26053)
@@ -1,6 +1,7 @@
 package org.spoofax.interpreter.adapter.ecj;
 
 import java.io.IOException;
+import java.util.Iterator;
 
 import org.spoofax.NotImplementedException;
 import org.spoofax.interpreter.terms.IStrategoAppl;
@@ -144,7 +145,8 @@
     }
 
     @Override
-    public ITermAttachment removeAttachment(TermAttachmentType<?> attachmentType) {
+    public ITermAttachment
+        removeAttachment(TermAttachmentType<?> attachmentType) {
         throw new NotImplementedException();
     }
 
@@ -174,4 +176,9 @@
         throw new NotImplementedException();
     }
 
+    @Override
+    public Iterator<IStrategoTerm> iterator() {
+        return wrappee.iterator();
+    }
+
 }

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/main/java/org/spoofax/interpreter/adapter/ecj/ECJConstructor.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/main/java/org/spoofax/interpreter/adapter/ecj/ECJConstructor.java	Tue Apr 16 14:47:41 2013	(r26052)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.adapter.ecj/src/main/java/org/spoofax/interpreter/adapter/ecj/ECJConstructor.java	Tue Apr 16 20:17:51 2013	(r26053)
@@ -8,7 +8,9 @@
 package org.spoofax.interpreter.adapter.ecj;
 
 import java.io.IOException;
+import java.util.Iterator;
 
+import org.spoofax.EmptyIterator;
 import org.spoofax.NotImplementedException;
 import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoConstructor;
@@ -116,4 +118,9 @@
     public boolean isList() {
         throw new NotImplementedException();
     }
+
+    @Override
+    public Iterator<IStrategoTerm> iterator() {
+        return new EmptyIterator<IStrategoTerm>();
+    }
 }

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.interpreter/src/main/java/org/spoofax/interpreter/library/interpreter/SpoofaxInterpreterTerm.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.interpreter/src/main/java/org/spoofax/interpreter/library/interpreter/SpoofaxInterpreterTerm.java	Tue Apr 16 14:47:41 2013	(r26052)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.interpreter/src/main/java/org/spoofax/interpreter/library/interpreter/SpoofaxInterpreterTerm.java	Tue Apr 16 20:17:51 2013	(r26053)
@@ -6,7 +6,9 @@
 package org.spoofax.interpreter.library.interpreter;
 
 import java.io.IOException;
+import java.util.Iterator;
 
+import org.spoofax.EmptyIterator;
 import org.spoofax.interpreter.ConcreteInterpreter;
 import org.spoofax.interpreter.core.InterpreterErrorExit;
 import org.spoofax.interpreter.core.InterpreterException;
@@ -134,4 +136,8 @@
 		return System.identityHashCode(this);
 	}
 
+	public Iterator<IStrategoTerm> iterator() {
+		return new EmptyIterator<IStrategoTerm>();
+	}
+
 }

Modified: spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/LazyTerm.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/LazyTerm.java	Tue Apr 16 14:47:41 2013	(r26052)
+++ spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/LazyTerm.java	Tue Apr 16 20:17:51 2013	(r26053)
@@ -1,6 +1,7 @@
 package org.spoofax.terms;
 
 import java.io.IOException;
+import java.util.Iterator;
 
 import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoConstructor;
@@ -18,27 +19,29 @@
 /**
  * A lazily initialized term,
  * 
- * @see StrategoWrapped  A non-lazy wrapped term that supports attachments separate from its base term.
- *
+ * @see StrategoWrapped A non-lazy wrapped term that supports attachments separate from its base term.
+ * 
  * @author Lennart Kats <lennart add lclnet.nl>
  */
-public abstract class LazyTerm implements IStrategoAppl, IStrategoInt, IStrategoList, IStrategoReal, IStrategoString, IStrategoTuple {
-	
+public abstract class LazyTerm implements IStrategoAppl, IStrategoInt, IStrategoList, IStrategoReal, IStrategoString,
+	IStrategoTuple {
+
 	private static final long serialVersionUID = 4886871162797987326L;
-	
+
 	private IStrategoTerm term;
-	
+
 	public final IStrategoTerm getWrapped() {
-		if (term == null) term = init();
+		if(term == null)
+			term = init();
 		return term;
 	}
-	
+
 	public final IStrategoTerm getWrapped(boolean skipInit) {
 		return skipInit ? term : getWrapped();
 	}
-	
+
 	protected abstract IStrategoTerm init();
-	
+
 	// Common methods
 
 	public IStrategoTerm[] getAllSubterms() {
@@ -66,12 +69,12 @@
 	public String toString() {
 		return getWrapped().toString();
 	}
-	
+
 	@Override
 	public boolean equals(Object obj) {
 		return getWrapped().equals(obj);
 	}
-	
+
 	@Override
 	public int hashCode() {
 		return getWrapped().hashCode();
@@ -88,7 +91,7 @@
 	public boolean match(IStrategoTerm second) {
 		return getWrapped().match(second);
 	}
-	
+
 	// Semi-specialized accessors
 
 	public final IStrategoTerm get(int index) {
@@ -98,36 +101,36 @@
 	public final IStrategoTerm[] getArguments() {
 		return getWrapped().getAllSubterms();
 	}
-	
+
 	// Specialized accessors
 
 	public IStrategoTerm head() {
-		if (getTermType() != LIST)
+		if(getTermType() != LIST)
 			throw new TermWrapperException("Called head() on a term that is not of type LIST");
 		return ((IStrategoList) getWrapped()).head();
 	}
 
 	public IStrategoList tail() {
-		if (getTermType() != LIST)
+		if(getTermType() != LIST)
 			throw new TermWrapperException("Called tail() on a term that is not of type LIST");
 		return ((IStrategoList) getWrapped()).tail();
 	}
 
 	public boolean isEmpty() {
-		if (getTermType() != LIST)
+		if(getTermType() != LIST)
 			throw new TermWrapperException("Called isEmpty() on a term that is not of type LIST");
 		return ((IStrategoList) getWrapped()).isEmpty();
 	}
 
 	@Deprecated
 	public IStrategoList prepend(IStrategoTerm prefix) {
-		if (getTermType() != LIST)
+		if(getTermType() != LIST)
 			throw new TermWrapperException("Called prepend() on a term that is not of type LIST");
 		return ((IStrategoList) getWrapped()).prepend(prefix);
 	}
 
 	public int size() {
-		switch (getTermType()) {
+		switch(getTermType()) {
 			case LIST:
 				return ((IStrategoList) getWrapped()).size();
 			case TUPLE:
@@ -138,37 +141,37 @@
 	}
 
 	public IStrategoConstructor getConstructor() {
-		if (getTermType() != APPL)
+		if(getTermType() != APPL)
 			throw new TermWrapperException("Called getConstructor() on a term that is not of type APPL");
 		return ((IStrategoAppl) getWrapped()).getConstructor();
 	}
-	
+
 	public String getName() {
-		if (getTermType() != STRING && getTermType() != APPL)
+		if(getTermType() != STRING && getTermType() != APPL)
 			throw new TermWrapperException("Called getName() on a term that is not of type STRING or APPL");
 		return ((IStrategoNamed) getWrapped()).getName();
 	}
 
 	public int intValue() {
-		if (getTermType() != INT)
+		if(getTermType() != INT)
 			throw new TermWrapperException("Called intValue() on a term that is not of type INT");
 		return ((IStrategoInt) getWrapped()).intValue();
 	}
 
 	public boolean isUniqueValueTerm() {
-		if (getTermType() != INT)
+		if(getTermType() != INT)
 			throw new TermWrapperException("Called isUniqueValueTerm() on a term that is not of type INT");
 		return ((IStrategoInt) getWrapped()).isUniqueValueTerm();
 	}
 
 	public double realValue() {
-		if (getTermType() != REAL)
+		if(getTermType() != REAL)
 			throw new TermWrapperException("Called realValue() on a term that is not of type REAL");
 		return ((IStrategoReal) getWrapped()).realValue();
 	}
 
 	public String stringValue() {
-		if (getTermType() != STRING)
+		if(getTermType() != STRING)
 			throw new TermWrapperException("Called stringValue() on a term that is not of type STRING");
 		return ((IStrategoString) getWrapped()).stringValue();
 	}
@@ -181,20 +184,24 @@
 		getWrapped().writeAsString(output, maxDepth);
 	}
 
-	public<T extends ITermAttachment> T getAttachment(TermAttachmentType<T> attachmentType) {
+	public <T extends ITermAttachment> T getAttachment(TermAttachmentType<T> attachmentType) {
 		return getWrapped().getAttachment(attachmentType);
 	}
 
-    public void putAttachment(ITermAttachment attachment) {
-    	getWrapped().putAttachment(attachment);
-    }
-    
-    public ITermAttachment removeAttachment(TermAttachmentType<?> attachmentType) {
-    	return getWrapped().removeAttachment(attachmentType);
-    }
-    
+	public void putAttachment(ITermAttachment attachment) {
+		getWrapped().putAttachment(attachment);
+	}
+
+	public ITermAttachment removeAttachment(TermAttachmentType<?> attachmentType) {
+		return getWrapped().removeAttachment(attachmentType);
+	}
+
 	public boolean isList() {
 		return getWrapped().isList();
 	}
 
-}
\ No newline at end of file
+	public Iterator<IStrategoTerm> iterator() {
+		return getWrapped().iterator();
+	}
+
+}

Modified: spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoList.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoList.java	Tue Apr 16 14:47:41 2013	(r26052)
+++ spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/StrategoList.java	Tue Apr 16 20:17:51 2013	(r26053)
@@ -18,12 +18,10 @@
 /**
  * A basic stratego list implementation using a linked-list data structure.
  */
-public class StrategoList extends StrategoTerm implements IStrategoList, Iterable<IStrategoTerm> {
+public class StrategoList extends StrategoTerm implements IStrategoList {
 	
 	private static final long serialVersionUID = 624120573663698628L;
 
-	private static final int UNKNOWN_SIZE = -1;
-    
     /**
      * @see #hashFunction()
      * @see TermFactory#EMPTY_LIST  The singleton maximally shared empty list instance.
@@ -34,7 +32,7 @@
     
     private IStrategoList tail;
     
-    private int size = UNKNOWN_SIZE;
+    private final int size;
 
     /**
      * Creates a new list.
@@ -46,10 +44,9 @@
         this.head = head;
         this.tail = tail;
         
-        if (storageType != MUTABLE) { 
-        	initImmutableHashCode();
-        	size = calculateSize();
-    	}
+        if (storageType != MUTABLE) initImmutableHashCode();
+        
+        this.size = (head == null ? 0 : 1) + (tail == null ? 0 : tail.size());
     }
     
     public IStrategoTerm head() {
@@ -90,11 +87,7 @@
 
     
     public final int size() {
-        return getSubtermCount();
-    }
-    
-    protected int calculateSize() {
-    	return (head == null ? 0 : 1) + (tail == null ? 0 : tail.size());
+        return size;
     }
 
     public IStrategoTerm getSubterm(int index) {
@@ -108,11 +101,7 @@
     }
 
     public int getSubtermCount() {
-		if (size == UNKNOWN_SIZE) {
-    		return calculateSize();
-    	} else {
-    		return size;
-    	}
+    	return size;
     }
 
     public int getTermType() {

Modified: spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/skeleton/SkeletonStrategoAppl.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/skeleton/SkeletonStrategoAppl.java	Tue Apr 16 14:47:41 2013	(r26052)
+++ spoofax/trunk/spoofax/org.spoofax.terms/src/org/spoofax/terms/skeleton/SkeletonStrategoAppl.java	Tue Apr 16 20:17:51 2013	(r26053)
@@ -2,7 +2,9 @@
 
 
 import java.io.IOException;
+import java.util.Iterator;
 
+import org.spoofax.ArrayIterator;
 import org.spoofax.NotImplementedException;
 import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoList;
@@ -12,101 +14,106 @@
 
 public abstract class SkeletonStrategoAppl extends StrategoTerm implements IStrategoAppl {
 
-  private static final long serialVersionUID = -2522680523775044390L;
+	private static final long serialVersionUID = -2522680523775044390L;
+
+	public SkeletonStrategoAppl(IStrategoList annotations, int storageType) {
+		super(annotations, storageType);
+	}
+
+	@Deprecated
+	final public IStrategoTerm[] getArguments() {
+		throw new NotImplementedException();
+	}
+
+	final public String getName() {
+		return getConstructor().getName();
+	}
+
+	final public int getSubtermCount() {
+		return getConstructor().getArity();
+	}
+
+	final public int getTermType() {
+		return IStrategoTerm.APPL;
+	}
+
+	@Override
+	final protected boolean doSlowMatch(IStrategoTerm second, int commonStorageType) {
+		if(second.getTermType() != IStrategoTerm.APPL)
+			return false;
+		final IStrategoAppl o = (IStrategoAppl) second;
+		if(getConstructor() != o.getConstructor())
+			return false;
+
+		final IStrategoTerm[] kids = getAllSubterms();
+		final IStrategoTerm[] secondKids = o.getAllSubterms();
+		if(kids != secondKids) {
+			for(int i = 0, sz = kids.length; i < sz; i++) {
+				final IStrategoTerm kid = kids[i];
+				final IStrategoTerm secondKid = secondKids[i];
+				if(kid != secondKid && !kid.match(secondKid)) {
+					if(commonStorageType == SHARABLE && i != 0)
+						System.arraycopy(secondKids, 0, kids, 0, i);
+					return false;
+				}
+			}
+
+			// FIXME should update sharing when possible
+			// if (commonStorageType == SHARABLE)
+			// this.kids = secondKids;
+		}
+
+		final IStrategoList annotations = getAnnotations();
+		final IStrategoList secondAnnotations = second.getAnnotations();
+		if(annotations == secondAnnotations) {
+			return true;
+		} else if(annotations.match(secondAnnotations)) {
+			if(commonStorageType == SHARABLE)
+				internalSetAnnotations(secondAnnotations);
+			return true;
+		} else {
+			return false;
+		}
+	}
+
+	final public void writeAsString(Appendable output, int maxDepth) throws IOException {
+		output.append(getName());
+		final IStrategoTerm[] kids = getAllSubterms();
+		if(kids.length > 0) {
+			output.append('(');
+			if(maxDepth == 0) {
+				output.append("...");
+			} else {
+				kids[0].writeAsString(output, maxDepth - 1);
+				for(int i = 1; i < kids.length; i++) {
+					output.append(',');
+					kids[i].writeAsString(output, maxDepth - 1);
+				}
+			}
+			output.append(')');
+		}
+		appendAnnotations(output, maxDepth);
+	}
+
+	@Deprecated
+	public final void prettyPrint(ITermPrinter pp) {
+		new NotImplementedException();
+	}
+
+	@Override
+	final protected int hashFunction() {
+		long r = getConstructor().hashCode();
+		int accum = 6673;
+		final IStrategoTerm[] kids = getAllSubterms();
+		for(int i = 0; i < kids.length; i++) {
+			r += kids[i].hashCode() * accum;
+			accum *= 7703;
+		}
+		return (int) (r >> 12);
+	}
+
+	public Iterator<IStrategoTerm> iterator() {
+		return new ArrayIterator<IStrategoTerm>(getAllSubterms());
+	}
 
-    public SkeletonStrategoAppl(IStrategoList annotations, int storageType) {
-        super(annotations, storageType);
-    }
-    
-    @Deprecated
-    final public IStrategoTerm[] getArguments() {
-        throw new NotImplementedException();
-    }
-
-    final public String getName() {
-        return getConstructor().getName();
-    }
-
-    final public int getSubtermCount() {
-        return getConstructor().getArity();
-    }
-
-    final public int getTermType() {
-        return IStrategoTerm.APPL;
-    }
-
-    @Override
-    final protected boolean doSlowMatch(IStrategoTerm second, int commonStorageType) {
-        if (second.getTermType() != IStrategoTerm.APPL)
-            return false;
-        IStrategoAppl o = (IStrategoAppl)second;
-        if (getConstructor() != o.getConstructor())
-            return false;
-        
-        IStrategoTerm[] kids = getAllSubterms();
-        IStrategoTerm[] secondKids = o.getAllSubterms();
-        if (kids != secondKids) {
-            for (int i = 0, sz = kids.length; i < sz; i++) {
-                IStrategoTerm kid = kids[i];
-                IStrategoTerm secondKid = secondKids[i];
-                if (kid != secondKid && !kid.match(secondKid)) {
-                    if (commonStorageType == SHARABLE && i != 0)
-                        System.arraycopy(secondKids, 0, kids, 0, i);
-                    return false;
-                }
-            }
-  
-// FIXME should update sharing when possible            
-//            if (commonStorageType == SHARABLE)
-//                this.kids = secondKids;
-        }
-        
-        IStrategoList annotations = getAnnotations();
-        IStrategoList secondAnnotations = second.getAnnotations();
-        if (annotations == secondAnnotations) {
-            return true;
-        } else if (annotations.match(secondAnnotations)) {
-            if (commonStorageType == SHARABLE) internalSetAnnotations(secondAnnotations);
-            return true;
-        } else {
-            return false;
-        }
-    }
-
-    final public void writeAsString(Appendable output, int maxDepth) throws IOException {
-        output.append(getName());
-        IStrategoTerm[] kids = getAllSubterms();
-        if(kids.length > 0) {
-            output.append('(');
-            if (maxDepth == 0) {
-            	output.append("...");
-            } else {
-	            kids[0].writeAsString(output, maxDepth - 1);
-	            for(int i = 1; i < kids.length; i++) {
-	                output.append(',');
-	                kids[i].writeAsString(output, maxDepth - 1);
-	            }
-            }
-            output.append(')');
-        }
-        appendAnnotations(output, maxDepth);
-    }
-    
-    @Deprecated
-    public final void prettyPrint(ITermPrinter pp) {
-    	new NotImplementedException();
-    }
-
-    @Override
-    final protected int hashFunction() {
-        long r = getConstructor().hashCode();
-        int accum = 6673;
-        IStrategoTerm[] kids = getAllSubterms();
-        for(int i = 0; i < kids.length; i++) {
-            r += kids[i].hashCode() * accum;
-            accum *= 7703;
-        }
-        return (int)(r >> 12);
-    }
-    
 }

From gabrielkonat at gmail.com  Thu Apr 18 11:41:00 2013
From: gabrielkonat at gmail.com (GabriÃ«l Konat)
Date: Thu, 18 Apr 2013 09:41:00 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26054 - in
	spoofax-imp/trunk/org.strategoxt.imp.editors.template: .
	editor lib trans
Message-ID: <20130418094100.AB48A7F8004@mx1.tudelft.nl>

Author: gkonat
Date: Thu Apr 18 09:40:59 2013
New Revision: 26054
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26054&sc=1

Log:
Generated esv and pp.str files now have correct module names and are put in the editor and trans folders respectively.

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.template/build.generated.xml
   spoofax-imp/trunk/org.strategoxt.imp.editors.template/editor/TemplateLang-Builders.generated.esv
   spoofax-imp/trunk/org.strategoxt.imp.editors.template/lib/analysis-library-internal.generated.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.template/lib/analysis-library.generated.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.template/lib/compilation-library.generated.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.template/lib/editor-common.generated.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.template/lib/index-library.generated.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.template/trans/templatelang.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.template/build.generated.xml
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.template/build.generated.xml	Tue Apr 16 20:17:51 2013	(r26053)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.template/build.generated.xml	Thu Apr 18 09:40:59 2013	(r26054)
@@ -2,9 +2,54 @@
 
 <project name="build.generated">
 
-        <target name="spoofaximp.default" depends="spoofaximp.default.ctree"/>
-        <target name="spoofaximp.default.ctree" depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,java.jar,stratego.ctree,sdf2imp,refresh"/>
-        <target name="spoofaximp.default.jar" depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,java.jar,stratego.jar.helper,sdf2imp,refresh"/>
+			  <target name="spoofaximp.default" depends="spoofaximp.default.ctree"/>
+			  <target name="spoofaximp.default.ctree" depends="
+			      check-classpath,
+			      call-onsave,
+			      init,
+			      sdf2table,
+			      meta-sdf2table,
+			      ppgen,
+			      pppack,
+			      sdf2imp.eclipse,
+			      sdf2imp.standalone,
+			      sdf2parenthesize,
+			      stratego.aster,
+			      java.jar,
+			      stratego.ctree,
+			      refresh,
+			      sdf2imp.eclipse.load"/>
+			  <target name="spoofaximp.default.jar" depends="
+			      check-classpath,
+			      call-onsave,
+			      init,
+			      sdf2table,
+			      meta-sdf2table,
+			      ppgen,
+			      pppack,
+			      sdf2imp.eclipse,
+			      sdf2imp.standalone,
+			      sdf2parenthesize,
+			      stratego.aster,
+			      java.jar,
+			      stratego.jar.helper,
+			      refresh,
+			      sdf2imp.eclipse.load"/>
+			  <target name="spoofaximp.default.nostr" depends="
+			      check-classpath,
+			      call-onsave,
+			      init,
+			      sdf2table,
+			      meta-sdf2table,
+			      ppgen,
+			      pppack,
+			      sdf2imp.eclipse,
+			      sdf2imp.standalone,
+			      sdf2parenthesize,
+			      stratego.aster,
+			      java.jar,
+			      refresh,
+			      sdf2imp.eclipse.load"/>
     
         <!-- Initialization -->
         <available file="${src-gen}/org/strategoxt/imp/editors/template/strategies/Main.java" property="java.jar.enabled"/>
@@ -46,6 +91,23 @@
         <mkdir dir="${lib}"/>
         <mkdir dir="${syntax}"/>
 
+			  <!-- The files for which the on-save handler is called before building -->
+			  <path id="call-onsave.files">
+			    <fileset dir=".">
+			      <include name="**/*.tmpl"/>
+			      <include name="**/*.nd"/>
+			      <include name="**/*.nab"/>
+			    </fileset>
+			  </path>
+				
+				<!-- Call on-save handler for template and name binding files so that their generated files are present -->
+				<target name="call-onsave">
+					<pathconvert pathsep=" " property="call-onsave.args" refid="call-onsave.files"/>
+					<java classname="org.strategoxt.imp.metatooling.building.AntForceOnSave">
+						<arg line="${call-onsave.args}"/>
+					</java>
+				</target>
+
         <target name="sdf2imp" depends="sdf2table,sdf2imp.eclipse,sdf2imp.standalone,sdf2parenthesize"/>
         
         <target name="sdf2imp.eclipse" if="eclipse.running" depends="sdf2rtg">
@@ -54,6 +116,12 @@
             </java>
         </target>
         
+        <target name="sdf2imp.eclipse.load" if="eclipse.running">
+		<java classname="org.strategoxt.imp.metatooling.loading.AntDescriptorLoader" failonerror="true">
+			<arg value="${include}/${esvmodule}.packed.esv"/>
+		</java>
+	</target>
+        
         <target name="refresh" if="eclipse.running">
             <eclipse.convertPath fileSystemPath="${basedir}" property="projectdir"/>
             <eclipse.convertPath fileSystemPath="${syntax}" property="syntaxdir"/>
@@ -161,6 +229,7 @@
             <copy file="${eclipse.spoofaximp.jars}/make_permissive.jar" todir="utils" failonerror="false"/>
             <copy file="${eclipse.spoofaximp.jars}/sdf2imp.jar" todir="utils" failonerror="false"/>
             <copy file="${eclipse.spoofaximp.jars}/aster.jar" todir="utils" failonerror="false"/>
+            <copy file="${eclipse.spoofaximp.jars}/StrategoMix.def" todir="utils" failonerror="false"/>
             <copy file="${eclipse.spoofaximp.strategojar}" todir="utils" failonerror="false"/>
         </target>
     
@@ -385,6 +454,13 @@
     
         <!-- Stratego to Java interpreter -->
         <target name="stratego.ctree" depends="rtg2sig">
+            <fail message="Main stratego file '${strmodule}.str' not found.">
+                <condition>
+                    <not>
+                        <isset property="build.stratego.enabled"/>
+                    </not>
+                </condition>
+            </fail>
             <dependset>
                 <srcfileset dir="${basedir}">
                     <include name="**/*.str"/>
@@ -403,6 +479,13 @@
     
         <!-- Stratego to Java compiler -->
         <target name="stratego.jar" depends="rtg2sig,utils-files">
+            <fail message="Main stratego file '${strmodule}.str' not found.">
+                <condition>
+                    <not>
+                        <isset property="build.stratego.enabled"/>
+                    </not>
+                </condition>
+            </fail>
             <dependset>
                 <srcfileset dir="${basedir}">
                     <include name="**/*.str"/>
@@ -629,12 +712,44 @@
             </apply>
         </target>
         
-        <target name="clean" description="Selective clean up">
-            <delete dir="${build}"/>
-            <delete file="${include}/${sdfmodule}.def"/>
-            <delete file="${include}/${strmodule}.rtree"/>
-            <delete file="${include}/${strmodule}.ctree"/>
-            <delete file="${include}/${strmodule}.jar"/>
-            <delete dir="${src-gen}/trans"/>
-        </target>
+	<target name="clean" description="Clean project">
+		<delete dir="${build}"/>
+		<delete dir=".cache"/>
+		<delete file="${include}/${sdfmodule}.def"/>
+		<delete file="${include}/${sdfmodule}-parenthesize.str"/>
+		<delete file="${include}/${sdfmodule}-Permissive.def"/>
+		<delete file="${include}/${sdfmodule}.generated.pp.af"/>
+		<delete file="${include}/${sdfmodule}.packed.esv"/>
+		<delete file="${include}/${sdfmodule}.pp.af"/>
+		<delete file="${include}/${sdfmodule}.rtg"/>
+		<delete file="${include}/${sdfmodule}.str"/>
+		<delete file="${include}/${sdfmodule}.tbl"/>
+		<delete file="${include}/${strmodule}.rtree"/>
+		<delete file="${include}/${strmodule}.ctree"/>
+		<delete file="${include}/${strmodule}.ctree.dep"/>
+		<delete file="${include}/${strmodule}.jar"/>
+		<delete>
+			<fileset dir="editor" includes="*.generated.esv"/>
+		</delete>
+		<delete dir="${src-gen}/trans"/>
+		<delete file="editor/${sdfmodule}.generated.esv"/>
+		<delete file="${syntax}/${sdfmodule}.generated.esv"/>
+		<delete file="${syntax}/${sdfmodule}.generated.pp"/>
+		<delete file="${include}/${metasdfmodule}-Permissive.def"/>
+		<delete file="${include}/${metasdfmodule}.def"/>
+		<delete file="${include}/${metasdfmodule}.tbl"/>
+		<delete file=".settings/org.eclipse.jdt.core.prefs"/>
+		<delete dir="utils"/>
+		<delete>
+			<fileset dir="lib-refactoring" includes="*.generated.str"/>
+			<fileset dir="${lib}" includes="*.generated.str"/>
+		</delete>
+		<antcall target="refresh-cleaned"/>
+	</target>
+	
+	<target name="refresh-cleaned" if="eclipse.running">
+        <eclipse.convertPath fileSystemPath="${basedir}" property="projectdir"/>
+        <eclipse.refreshLocal resource="${projectdir}" depth="infinite"/>
+    </target>
+	
     </project>
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.template/editor/TemplateLang-Builders.generated.esv
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.template/editor/TemplateLang-Builders.generated.esv	Tue Apr 16 20:17:51 2013	(r26053)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.template/editor/TemplateLang-Builders.generated.esv	Thu Apr 18 09:40:59 2013	(r26054)
@@ -2,70 +2,43 @@
 module TemplateLang-Builders.generated
 
 builders
-                                                                                                                    
-  // Building and analysis is defined in Stratego program or programs:                                              
-  //                                                                                                                
-  //   provider : stratego-program.ctree                                                                            
-  //   provider : stratego-library.jar                                                                              
-  //                                                                                                                
-  // Analysis is carried out by a Stratego rule that can be selected as follows:                                    
-  //                                                                                                                
-  //   observer : analysis-rule                                                                                     
-  //                                                                                                                
-  // Any dynamic rules set in the analysis may be used by other semantic services,                                  
-  // such as reference resolving or the builders.                                                                   
-  //                                                                                                                
-  // The (multifile) annotation can be added to an observer to indcate that this                                    
-  // observer will receive a list of files if multiple files change, instead of running                             
-  // the observer on every file separately.                                                                         
-  //                                                                                                                
-  // Builders may carry out custom transformations on a file or selection.                                          
-  // (At run-time, they can be accessed using the toolbar button with the star icon.)                               
-  // Builders can be specified as follows:                                                                          
-  //                                                                                                                
-  //   builder : "Generate Java code" = generate-java (openeditor) (persistent) (realtime)                          
-  //                                                                                                                
-  // In this example, the caption "Generate Java code" is used in the build button dropdown menu,                   
-  // and the generate-java rule is used to carry out the tranformation.                                             
-  // Builder definitions can also specify any combination of the following annotations:                             
-  //                                                                                                                
-  //   (cursor)      The builder should always transform the tree node at the cursor.                               
-  //   (meta)        Indicates the builder should only be available to meta-programmers                             
-  //                 (i.e., not when the plugin is deployed to end-users).                                          
-  //   (openeditor)  Indicates an editor should be opened with the result.                                          
-  //   (persistent)  Indicates that the resulting file should be saved to disk.                                     
-  //   (realtime)    Indicates that the resulting editor should be updated in real-time                             
-  //                 as the source file is edited.                                                                  
-  //   (source)      Always apply this builder to the source AST, not to the AST                                    
-  //                 after it has been analyzed/desugared by the observer.                                          
-  //                                                                                                                
-  // Refactorings are used for transformations that modify the original source code,                                
-  // while preserving the layout and syntactic sugar.                                                               
-  // A custom pretty-print strategy (T -> String) is used to format newly inserted nodes,                           
-  // a parenthesize strategy (T -> T) surrounds subterms with "Parenthetical(T)" when brackets are required,        
-  // resugar rules are required for desugarings that are not local-to-local or desugarings that duplicate terms     
-  // as the 'l' in \l -> []\ => {l: ( l -> [] )}.                                                                   
-  // Finally, text-reconstruction can be overruled with a strategy (T-old, T-new) -> <try(custom-pp)> T-new,        
-  // the resulting text will be indented according to its location.                                                 
-  // This is sometimes needed in case the node text can not be reconstructed by replacing child texts               
-  // in the original formatting.                                                                                    
-  //                                                                                                                
-  // Refactorings can be specified as shown below, whereby Property* indicates on which constructs the              
-  // refactoring is specified (<sort>.<constructor>).                                                               
-  //                                                                                                                
-  // refactorings                                                                                                   
-  //                                                                                                                
-  //   pretty-print: prettyprint                                                                                    
-  //   parenthesize: parenthesize                                                                                   
-  //   resugar: resugar-node                                                                                        
-  //   override reconstruction: disallow-reconstruction                                                             
-  //                                                                                                                
-  //   refactoring Property*: "Extract Entity" =  extract-entity (source)                                           
-  //     shortcut: Shift+Alt+M                                                                                      
-  //     input                                                                                                      
-  //       identifier: "entity name" = ""                                                                           
-  //       identifier: "property name" = ""                                                                         
-  //                                                                                                                
-  // The 'on save' handler can be used  to generate code as files are saved:                                        
-  //                                                                                                                
-  //   on save : index-on-save                                                                                      
\ No newline at end of file
+                                                                                                      
+  // Building and analysis is defined in Stratego program or programs:                                
+  //                                                                                                  
+  //   provider : stratego-program.ctree                                                              
+  //   provider : stratego-library.jar                                                                
+  //                                                                                                  
+  // Analysis is carried out by a Stratego rule that can be selected as follows:                      
+  //                                                                                                  
+  //   observer : analysis-rule                                                                       
+  //                                                                                                  
+  // Any dynamic rules set in the analysis may be used by other semantic services,                    
+  // such as reference resolving or the builders.                                                     
+  //                                                                                                  
+  // The (multifile) annotation can be added to an observer to indcate that this                      
+  // observer will receive a list of files if multiple files change, instead of running               
+  // the observer on every file separately.                                                           
+  //                                                                                                  
+  // Builders may carry out custom transformations on a file or selection.                            
+  // (At run-time, they can be accessed using the toolbar button with the star icon.)                 
+  // Builders can be specified as follows:                                                            
+  //                                                                                                  
+  //   builder : "Generate Java code" = generate-java (openeditor) (persistent) (realtime)            
+  //                                                                                                  
+  // In this example, the caption "Generate Java code" is used in the build button dropdown menu,     
+  // and the generate-java rule is used to carry out the tranformation.                               
+  // Builder definitions can also specify any combination of the following annotations:               
+  //                                                                                                  
+  //   (cursor)      The builder should always transform the tree node at the cursor.                 
+  //   (meta)        Indicates the builder should only be available to meta-programmers               
+  //                 (i.e., not when the plugin is deployed to end-users).                            
+  //   (openeditor)  Indicates an editor should be opened with the result.                            
+  //   (persistent)  Indicates that the resulting file should be saved to disk.                       
+  //   (realtime)    Indicates that the resulting editor should be updated in real-time               
+  //                 as the source file is edited.                                                    
+  //   (source)      Always apply this builder to the source AST, not to the AST                      
+  //                 after it has been analyzed/desugared by the observer.                            
+  //                                                                                                  
+  // The 'on save' handler can be used  to generate code as files are saved:                          
+  //                                                                                                  
+  //   on save : editor-save                                                                          
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.template/lib/analysis-library-internal.generated.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.template/lib/analysis-library-internal.generated.str	Tue Apr 16 20:17:51 2013	(r26053)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.template/lib/analysis-library-internal.generated.str	Thu Apr 18 09:40:59 2013	(r26054)
@@ -16,6 +16,13 @@
   // Namespaces
   Diff            : Namespace
   ASTDiff         : Namespace
+  AST             : Namespace
+  
+  // Data
+  AST             : Identifier * AST -> AST
+  
+  // Annotations 
+  Scope: Term -> Anno
   
 rules // Analysis traversals
   
@@ -70,7 +77,7 @@
         filesToAnalyze := []
       end
     with
-      <list-loop(analyze-top-store-ast)> astFilePairs4
+      <list-loop(analyze-top-store-ast(|language, full-path))> astFilePairs4
       
   /**
    * Add URI annotations to each definition and unresolved URI annotations to each use site.
@@ -81,7 +88,8 @@
     (ast, file) -> ((ast2, file), defs)
     with
       <index-set-current-file> file;
-      (Some(ast2), defs) := <analyze-defs> Some(ast); // HACK: force origin tracking with Some()... // TODO: still needed?
+      (Some(ast2), edefs) := <analyze-defs> Some(ast); // HACK: force origin tracking with Some()... // TODO: still needed?
+      defs := <map(Snd)> edefs; 
       <index-add-all(|file)> defs
       
   /**
@@ -102,7 +110,7 @@
         data := <origin-track-forced(analyze-tree-data)> ast2;
         
         // Resolve all references in gathered data.
-        (data2, _) := <analyze-uses> data; // Ignoring data uses, have not found a use-case for them yet.
+        (data2, _) := <analyze-uses> data;
         <index-add-all(|file)> data2;
         
         // Store reads into the index (if not testing language)
@@ -141,10 +149,14 @@
    *
    * @internal
    */   
-  analyze-top-store-ast:
-    (ast, file) -> <id>
-    with
-      <index-set-global(|<conc> (<index-file-to-uri> file, ["ast"]))> ast
+  analyze-top-store-ast(|language, full-path):
+    (ast, (file, subfile)) -> <id>
+    where
+      if [] := subfile then
+        <index-add(|full-path)> AST((language, full-path), ast)
+      else
+        <index-add(|full-path)> AST((language, subfile), ast)
+      end
       
   /**
    * Identifies all definitions in the tree and annotates them with their URI.
@@ -152,66 +164,100 @@
    *
    * @internal
    */
-  analyze-defs = analyze-defs(|Anon(), Anon())
+  analyze-defs:
+    ast -> (<analyze-defs(|[], set, Anon(), Anon())> ast, <iset-elements> set)
+    where
+      set := <new-iset>
+       
+  /** @internal */
+  analyze-defs(|paths, defs, head-scope, head-scope-ns):
+    ast{Scope([namespace, name | path])} -> ast'
+    where
+      paths' := <update-index-paths(|[(namespace, path)])> paths ;
+      ast'   := <rm-annotations; analyze-defs(|paths', defs, Anon(), Anon())> ast
+      
+  
   /** @internal */
-  analyze-defs(|head-scope, head-scope-ns):
-    ast -> (ast', defs')
+  analyze-defs(|paths, defs, head-scope, head-scope-ns):
+    ast -> ast'
+    where
+      <not(has-annos)> ast      
     with
-      if def := <nam-get-definition> ast then
-        Def(def-path)                     := def;
-        [head-scope-ns', head-scope' | _] := def-path
+      if (namespace, path) := <nam-get-definition> ast then
+        definition     := <nam-get-def(|paths, namespace)> path;
+        Def(def-path)  := definition; 
+        head-scope-ns' := namespace;
+        head-scope'    := <Hd> path;
+        f#(children)   := <try(nam-annotate-scopes(|def-path))> ast;
+        <iset-add(|(<new>, definition))> defs
       else
         def-path       := INTERNAL_ERROR();
         head-scope-ns' := head-scope-ns;
-        head-scope'    := head-scope
+        head-scope'    := head-scope;
+        f#(children)   := ast
       end;
       if scope-types := <nam-get-scope-types> ast then
-        {| IndexPath:
-          <list-loop(update-index-path(|head-scope', head-scope-ns', ast))> scope-types;
-          // <balanced-update-path> head-scope';
-          (ast', defs) := <analyze-defs-recurse(|Anon(), Anon(), def-path)> ast
-        |}
-      else
-        (ast', defs) := <analyze-defs-recurse(|head-scope', head-scope-ns', def-path)> ast
+        unique          := Anon(<new>);
+        updates         := <map(construct-index-path(|paths, head-scope', head-scope-ns', unique, ast))> scope-types;
+        paths'          := <update-index-paths(|updates)> paths;
+        head-scope-ns'' := Anon();
+        head-scope''    := Anon()
+      else
+        paths'          := paths;
+        head-scope-ns'' := head-scope-ns';
+        head-scope''    := head-scope'
       end;
-      defs' := <![def | defs] <+ !defs>
-      
+      children' := <origin-track-forced(analyze-child-defs(|paths', defs, head-scope'', head-scope-ns''))> children;
+      ast'      := <try(nam-annotate-names(|paths', def-path))> f#(children') 
+       
+  /** @internal */
+  analyze-child-defs(|paths, defs, head-scope, head-scope-ns):
+    [] -> []
+    
   /** @internal */
-  analyze-defs-recurse(|head-scope, head-scope-ns, def-path):
-    ast -> (ast'', defs)
+  analyze-child-defs(|paths, defs, head-scope, head-scope-ns):
+    [d|ds] -> [d'|ds']
     where
-      analyzed      := <all(analyze-defs(|head-scope, head-scope-ns))> ast;
-      (ast', defs)  := <unzip-analyzed> analyzed;
-      ast''         := <try(nam-annotate-names(|def-path))> ast'
- 
+      d'  := <analyze-defs(|paths, defs, head-scope, head-scope-ns)> d ;
+      if <nam-ordered-def> d then
+        [namespace, name | path] := <nam-get-definition-key ; index-uri> d' ;
+        paths'                   := <update-index-paths(|[(namespace, path)])> paths ;
+        ds'                      := <analyze-child-defs(|paths', defs, Anon(), Anon())> ds
+      else
+        ds' := <analyze-child-defs(|paths, defs, head-scope, head-scope-ns)> ds
+      end
+  
   /** @internal */
-  update-index-path(|head-scope, head-scope-ns, ast):
-    scope-type -> scope-type
+  construct-index-path(|paths, head-scope, head-scope-ns, unique, ast):
+    scope-type -> (scope-type, path'')
     where
       if !head-scope-ns => Anon() then
-        path  := <IndexPath <+ ![]> scope-type;
-        path' := <do-adjusted-index-path(|scope-type, path, Anon(<new>))> ast
+        path  := <lookup-index-path> (scope-type, paths);
+        path' := <index-do-adjust-path(|scope-type, path, Anon(<new>))> ast
       else
-        path  := <IndexPath <+ ![]> head-scope-ns;
-        path' := <do-adjusted-index-path(|scope-type, path, head-scope)> ast
+        path  := <lookup-index-path> (head-scope-ns, paths);
+        path' := <index-do-adjust-path(|scope-type, path, head-scope)> ast
       end;
-      rules(IndexPath: scope-type -> path')
- 
-  /* TODO: consider using simple-update-def-path
-   *       which uses "balanced" path scopes
-   *       e.g. when Entity doesn't scope Function
-   *       then it's hard to access properties from a function
-  balanced-update-index-path:
-    head-scope -> head-scope
-    where
-      if !head-scope => Anon() then
-        head-scope' := Anon(<new>)
+      // HACK: Disable generation of anonymous namespaces for unique definitions to let FieldAccess-like constructs work.
+      if /*<nam-unique> ast*/ fail then
+        path'' := <index-do-adjust-path(|scope-type, path', unique)> ast
       else
-        head-scope' := head-scope
-      end;
-      (something with do-adjust-path)
-      rules(IndexPath := [head-scope' | <IndexPath <+ ![]> ()])
-  */
+        path'' := path'
+      end
+      
+  /** @internal */
+  update-index-paths(|updates) = 
+    remove-all(?(<id>, _); !(<id>, updates) ; lookup') ; at-end(!updates)
+  
+  /** @internal */
+  lookup-index-path = 
+    lookup' <+ ![]
+ 
+  /** @internal */
+  index-do-adjust-path(|namespace, path, scope) =
+    adjust-index-path(origin-equal(|scope)|namespace, path)
+  <+
+    ![scope|path]
  
   /**
    * Analyze all uses, changing their preliminary "Unresolved(_)" URI to a definite URI of their definition.
@@ -224,7 +270,7 @@
       analyzed     := <all(analyze-uses)> ast;
       (ast', uses) := <unzip-analyzed> analyzed;
       if !ast' => _{unresolved@[Unresolved(namespace), x | path]} then
-        if Def(def-uri) := <index-lookup(id |namespace, path, <strip-annos> ast')> ast' then
+        if Def(def-uri) := <index-lookup> ast' then
           ast'' := ast{def-uri};
           uses' := [Use(def-uri) | uses]
         else
@@ -271,32 +317,37 @@
       
 rules // Parallel analysis
   
+  index-parallel-analyze(analyze) = index-analyze(parallel-unordered(all(index-do-analysis(analyze))))
+  index-sequential-analyze(analyze) = index-analyze(all(index-do-analysis(analyze)))
+  
   /** @internal */
-  index-parallel-analyze(analyze):
+  index-analyze(do-analysis):
     files -> allResults
     with
-      map(index-parse-file); // Parsing cannot be done in parallel.
-      map(\(ast, file) -> (ast, file, <project-path>)\);
-      parallel-unordered(all(index-analyze(analyze)));
-      ?results;
-      with(<eq> (<length> results, <length> files) | "Input size not equal to output size");
-      filesToAnalyze := <make-set> <mapconcat(?ParallelResults(_, _, _, _, _, <id>))> results;
-      if not([] := filesToAnalyze) then
-        allResults := <concat> [results, <index-parallel-analyze(analyze)> filesToAnalyze]
+      asts      := <map(index-parse-file)> files; 
+      data      := <map(\(ast, file) -> (ast, file, <project-path>)\)> asts;
+      results   := <do-analysis> data;
+      reanalyze := <make-set> <mapconcat(?ParallelResults(_, _, _, _, _, <id>))> results;
+      if not([] := reanalyze) then
+        allResults := <conc> (results, <index-analyze(do-analysis)> reanalyze)
       else
         allResults := results
       end
   
-  /** @internal */   
+  /** @internal */
   index-parse-file:
-    file -> (ast, file)
+    file -> (ast', file)
     with
-    if <file-exists> file then
-      ast := <parse-file> file
-    else
-      ast := ()
-    end
-   
+      if <file-exists> file then
+        if ast := <parse-file> file then
+          ast' := ast
+        else
+          ast' := ()
+        end
+      else
+        ast' := ()
+      end
+      
   /** @internal */   
   index-set-markers:
     ParallelResults(ast, ast', errors, warnings, notes, diffs) -> <id>
@@ -304,11 +355,11 @@
       <set-markers(|ast)> (ast', errors, warnings, notes)
       
   /** @internal */
-  index-analyze(analyze):
-    (ast, path, project-path) -> ParallelResults(ast, ast', errors, warnings, notes, filesToAnalyze)
+  index-do-analysis(analyze):
+    (ast, path, project-path) -> ParallelResults(ast, ast', errors, warnings, notes, reanalyze)
     with
-      (ast', errors, warnings, notes, filesToAnalyze) := <analyze>;
-      if [] := filesToAnalyze then
+      (ast', errors, warnings, notes, reanalyze) := <analyze>;
+      if [] := reanalyze then
         complete-work-unit
       end
       
@@ -425,121 +476,198 @@
 rules // Index lookup rules (that take into account adjust-index-lookup)
   
   /**
-   * Given an annotated AST node, resolves it, returning all its Defs.
+   * Given a term x, namespace n, path s and prefix p, looks for a definition in the 
+   * scope of s and outer scopes in namespace n that start with prefix p, returning the first 
+   * found definition.
+   *
+   * @param namespace Only definitions with this namespace are returned.
+   * @param path      Only definitions with this path or part of this path are returned.
+   * @param prefix    Only definitions with a name that starts with this string are returned.
    *
-   * @param prefix  Only Defs with a name that starts with this string are returned.
+   * @type term -> ?Def(uri')
    *
    * @internal
-   * @type "name"{uri} -> ?Def(uri')
    */
-  index-lookup(is-adjust-lookup-enabled|namespace, path, prefix):
-    x -> def
+  index-lookup-internal(adjust-import, adjust-lookup, get-defs, name-compare|namespace, path, prefix):
+    x -> definition
     where
-      candidates := <index-lookup-one-level(is-adjust-lookup-enabled|namespace, path, prefix)>;
-      if <?StopLookup()> candidates then
+      defs := <index-lookup-all-scoped-internal(adjust-import, adjust-lookup, get-defs, name-compare|namespace, path, prefix)> x;
+      
+      if StopLookup() := defs then
         fail
-      else
-        def        := <index-select(|namespace, path, x)>
-      <+
-        // TODO: optimize: try not to call do-adjust-index-lookup from here
-        [_ | path'] := path;
-        def         := <index-lookup(is-adjust-lookup-enabled|namespace, path', prefix)> x
+      end;
+      
+      if not(definition := <Hd> defs) then
+        [_|path']  := path;
+        definition := <index-lookup-internal(adjust-import, adjust-lookup, get-defs, name-compare|namespace, path', prefix)> x
       end
+      
+  /** @internal */
+  index-lookup-internal(get-defs, name-compare|namespace, path, prefix) = 
+    index-lookup-internal(id, id, get-defs, name-compare|namespace, path, prefix)
 
   /**
-   * Given an annotated AST node, resolves it, returning all its Defs.
-   *
-   * @param prefix  Only Defs with a name that starts with this string are returned.
+   * Given a term x, namespace n, path s and prefix p, looks for definitions in the scope of s 
+   * and outer scopes in namespace n that start with prefix p, returning all found definition.
    *
+   * @param namespace Only definitions with this namespace are returned.
+   * @param path      Only definitions with this path or part of this path are returned.
+   * @param prefix    Only definitions with a name that starts with this string are returned.
    * @type "name"{uri} -> List(Def(uri'))
+   *
    * @internal
    */
-  index-lookup-all(is-adjust-lookup-enabled|namespace, path, prefix):
+  index-lookup-all-internal(adjust-import, adjust-lookup, get-defs, name-compare|namespace, path, prefix):
     x -> defs'
     where
-      candidates := <index-lookup-one-level(is-adjust-lookup-enabled|namespace, path, prefix)>;
-      defs       := <index-select-all(|namespace, path, x)>;
-      // TODO: optimize: try not to call do-adjust-index-lookup from here
-      if [_ | path'] := path then
-        defs2 := <index-lookup-all(is-adjust-lookup-enabled|namespace, path', prefix)> x;
+      defs := <index-lookup-all-scoped-internal(adjust-import, adjust-lookup, get-defs, name-compare|namespace, path, prefix)> x;
+      
+      if [_|path'] := path then
+        defs2 := <index-lookup-all-internal(adjust-import, adjust-lookup, get-defs, name-compare|namespace, path', prefix)> x;
         defs' := <conc> (defs, defs2)
       else
         defs' := defs
       end
+
+  /** @internal */
+  index-lookup-all-internal(get-defs, name-compare|namespace, path, prefix) = 
+    index-lookup-all-internal(id, id, get-defs, name-compare|namespace, path, prefix)
       
   /**
-   * Given an annotated AST node, returns the outermost Def with a corresponding URI.
-   *
-   * @param prefix  Only Defs with a name that starts with this string are returned.
-   *
-   * @type "name"{uri} -> ?Def(uri')
-   * @internal
-   */
-  index-lookup-outermost(is-adjust-lookup-enabled |namespace, path, prefix):
-    x -> def
-    where
-      // TODO: optimize: just like index-lookup
-      [_ | path'] := path;
-      def         := <index-lookup-outermost(is-adjust-lookup-enabled |namespace, path', prefix)> x
-    <+
-      candidates := <index-lookup-one-level(is-adjust-lookup-enabled|namespace, path, prefix)>;
-      def        := <index-select(|namespace, path, x)>
-      
-  /**
-   * Given an annotated AST node, resolves it, and returns all possibly matching Defs with a common ancestor URI. 
+   * Given a term x, namespace n, path s and prefix p, looks for a definition in the 
+   * scope of s in namespace n that start with prefix p, returning the first found definition.
    *
-   * @param namespace Only Defs with this namespace are returned.
-   * @param prefix    Only Defs with a name that starts with this string are returned.
+   * @param namespace Only definitions with this namespace are returned.
+   * @param path      Only definitions with this path are returned.
+   * @param prefix    Only definitions with a name that starts with this string are returned.
+   * @type term -> List(Def(uri))
    *
-   * @type "name"{uri} -> List(Def(uri'))
    * @internal
    */
-  index-lookup-one-level(is-adjusted-lookup-enabled|namespace, path, prefix):
-    x{_} -> defs
+  index-lookup-all-scoped-internal(adjust-import, adjust-lookup, get-defs, name-compare|namespace, path, prefix):
+    x -> defs
     with
-      is-adjusted-lookup-enabled;
-      do-adjust-index-lookup(|namespace, path, x, prefix);
-      if ?StopLookup() then
-        defs := StopLookup()
-      else
-        mapconcat(\d at Def(p) -> [d]\
-          <+ \[namespace' | path'] -> <index-lookup-one-level(fail |namespace', path', prefix)> x\
-          <+ fatal-err(|"Unexpected result from adjust-index-lookup, should be a list Def(_) or [namespace | path] or StopLookup() to stop the lookup"));
-        ?defs
-      end
+      adjust-lookup;
+      adjusted := <index-do-adjust-lookup(|namespace, path, x, prefix)> x;
+      defs     := <index-get-adjust-lookup-results(adjust-import, get-defs, name-compare|adjusted, prefix)> x
+    <+
+      adjust-import;
+      adjusted := <index-do-adjust-import(|namespace, path)> x;
+      defs     := <index-get-adjust-import-results(adjust-lookup, get-defs, name-compare|adjusted, prefix)> x
     <+
-      defs := <index-get-children(|namespace, prefix)> Def([namespace | path])
+      defs     := <get-defs(name-compare|namespace, prefix)> [namespace | path]
       
-  /**
-   * Given an annotated AST node, resolves it, and returns all possibly matching Defs with a common ancestor URI. 
-   *
-   * @param prefix  Only Defs with a name that starts with this string are returned.
-   *
-   * @internal
-   * @type "name"{uri} -> List(Def(uri'))
-   */
-  index-lookup-all-levels(is-adjust-lookup-enabled |namespace, path, prefix):
-    x{_} -> all-defs
+  /** @internal */
+  index-lookup-all-scoped-internal(get-defs, name-compare|namespace, path, prefix) = 
+    index-lookup-all-scoped-internal(id, id, get-defs, name-compare|namespace, path, prefix)
+  
+  /** @internal */
+  index-do-adjust-import(|namespace, path) =
+    adjust-index-import(|namespace, path)
+    
+  /** @internal */
+  index-get-adjust-import-results(adjust-lookup, get-defs, name-compare|adjusted, prefix):
+    x -> defs'
     with
-      is-adjust-lookup-enabled;
-      do-adjust-index-lookup(|namespace, path, x, prefix);
-      if ?StopLookup() then
-        all-defs := []
-      else
-        mapconcat(\d at Def(p) -> [d]\
-            <+ \[namespace' | path'] -> <index-lookup-all-levels(fail |namespace', path', prefix)> x\
-            <+ fatal-err(|"Unexpected result from adjust-index-lookup, should be a list Def(_) or [namespace | path] or StopLookup() to stop the lookup"));
-        ?all-defs
+      defs := 
+        <mapconcat(
+             index-adjust-import-recurse(adjust-lookup, get-defs, name-compare|x, prefix)
+          <+ fatal-err(|"Unexpected result from adjust-index-import, should be a list of [namespace | path].")
+        )> adjusted;
+        if not(<elem> (StopLookup(), defs)) then
+          defs' := <filter(name-compare)> defs
+        else
+          defs' := StopLookup()
+        end
+        
+  /** @internal */
+  index-adjust-import-recurse(adjust-lookup, get-defs, name-compare|x, prefix):
+    [namespace|path] -> results'
+    with
+      results := <index-lookup-all-scoped-internal(fail, adjust-lookup, get-defs, name-compare|namespace, path, prefix)> x;
+      if not(<is-list> results) then
+        results' := [results]
+      else
+        results' := results
       end
-    <+
-      one-level := <index-get-children(|namespace, prefix)> Def([namespace | path]);
-      if [_ | path'] := path then
-        all-defs := <concat> [one-level, <index-lookup-all-levels(fail |namespace, path', prefix)> x]
+        
+  /** @internal */
+  index-do-adjust-lookup(|namespace, path, use, prefix) =
+    repeat-until(
+      prim("SSL_EXT_get_parent", <id>)
+    , adjust-index-lookup(origin-equal(|use)|namespace, path, prefix) 
+    )
+    
+  /** @internal */  
+  index-get-adjust-lookup-results(adjust-import, get-defs, name-compare|adjusted, prefix):
+    x -> defs'
+    with
+      if StopLookup() := adjusted then
+        defs' := StopLookup()
       else
-        all-defs := one-level
+        defs := 
+          <mapconcat(
+               \d at Def(p) -> [d]\
+            <+ \[namespace'|path'] -> <index-lookup-all-scoped-internal(adjust-import, fail, get-defs, name-compare|namespace', path', prefix)> x\
+            <+ fatal-err(|"Unexpected result from adjust-index-lookup, should be a list of Def(uri) or [namespace | path], or StopLookup() to stop the lookup.")
+          )> adjusted;
+          defs' := <filter(name-compare)> defs
       end
+
+rules // Definition retrieval
+  
+  /**
+   * Gets all definitions from the index with given name, namespace and path.
+   * 
+   * @internal 
+   */   
+  index-get-defs(name-compare|namespace, name):
+    [ns|path] -> <index-get-all> Def([ns, name|path])
+  
+  /**
+   * Gets all definitions from the index with given prefix, namespace, path and name-comparison strategy.
+   * 
+   * @internal 
+   */   
+  index-get-defs-prefix(name-compare|namespace, prefix) = 
+    index-get-children(\uri -> Def(uri)\, name-compare|namespace, prefix)
+      
+rules // Name comparisons
+
+  /**
+   * Compares given element (with an URI) to given name using string equality comparison.
+   * 
+   * @internal 
+   */     
+  index-compare-name-equal(|name):
+    element -> <id>
+    where
+      uri := <index-uri> element;
+      <SRTS-EXT-eq-ignore-annos(|name)> <index-uri-name> uri
+  
+  /**
+   * Compares given element (with an URI) to given prefix using substring comparison.
+   * 
+   * @internal 
+   */     
+  index-compare-name-substring(|prefix):
+    element -> <id>
+    where
+      uri := <index-uri> element;
+      <is-substring(!prefix)> <index-uri-name> uri
+      
+  /**
+   * Compares given element (with an URI) to given prefix using substring comparison and given namespace.
+   * 
+   * @internal 
+   */      
+  index-compare-name-substring(|prefix, namespace):
+    element -> <id>
+    where
+      uri := <index-uri> element;
+      <eq> (namespace, <index-uri-namespace> uri);
+      <is-substring(!prefix)> <index-uri-name> uri
       
-/** @internal */
 rules // URI and value projections
        
   /** @internal */
@@ -581,8 +709,7 @@
   /** @internal */
   index-value-impl:
     ReadWildcard(_, value) -> value
-       
-/** @internal */
+    
 rules // Internal helpers
 
   /**
@@ -614,21 +741,9 @@
   fake-file = 
     is-test-file <+ index-is-fake-file
   
-  /** @internal */    
-  index-filepair-to-file = 
-    Fst; string-replace(|$[[<project-path>]/], "")
-  
   /** @internal */
   ast-uri-to-ast-file(|full-path):
     (ast, uri) -> (ast, (full-path, uri))
-  
-  /** @internal */     
-  index-is-name-substring(|name):
-    template -> <id>
-    with
-      [_, uri-name | _] := <index-uri>
-    where
-      <is-substring(!name)> uri-name
    
   /** @internal */    
   index-readwildcard-substring(|prefix):
@@ -643,9 +758,9 @@
         if 1 := <length> children then
           // HACK: This solves the problem of ReadWildcards making too many files re-analyze, but this should
           // be handled in the index primitives instead.
-          <iset-add(|Read([namespace | path]))> set
+          <iset-add(|Read([namespace, prefix|path]))> set
         else
-          <iset-add(|ReadWildcard([namespace | path], prefix))> set
+          <iset-add(|ReadWildcard([namespace|path], prefix))> set
         end
       end
   
@@ -668,35 +783,6 @@
     ?Read(_) <+ ?ReadWildcard(_, _) <+ ?Use(_)
  
   /** @internal */
-  do-adjust-index-lookup(|namespace, path, use, prefix) =
-    repeat-until(
-      prim("SSL_EXT_get_parent", <id>)
-    , adjust-index-lookup(origin-equal(|use) |namespace, path, prefix) 
-    )
- 
-  /** @internal */
-  index-select(|namespace, path, use) =
-    getfirst(
-      where(
-        ?Def([_, <SRTS-EXT-eq-ignore-annos(|use)> | _])
-      )
-    )
- 
-  /** @internal */
-  index-select-all(|namespace, path, use) =
-    filter(
-      where(
-        ?Def([_, <SRTS-EXT-eq-ignore-annos(|use)> | _])
-      )
-    )
- 
-  /** @internal */
-  do-adjusted-index-path(|namespace, path, def) =
-    adjust-index-path(origin-equal(|def) |namespace, path)
-  <+
-    ![def | path]
- 
-  /** @internal */
   index-eq(|namespace, expected) =
     where(
       ?Def([_, name | _]);
@@ -710,22 +796,53 @@
   index-key-unwrap = 
     \key{uri} -> key{<index-uri-unwrap> uri}\ <+ id
     
-/** @internal */
 rules // Interface for generated code
  
   /** @internal */
-  nam-get-def(|namespace):
-    x -> Def([namespace, x | <IndexPath <+ ![]> namespace])
+  nam-get-def(|paths, namespace):
+    part* -> Def([namespace, part* | <lookup-index-path> (namespace, paths)])
+  
+  /** @internal */ 
+  nam-annotate-def(|path):
+    t -> result
+    with
+      result := t{path}
+  
+  /** @internal */ 
+  nam-annotate-use(|paths, namespace):
+    t -> t{[Unresolved(namespace), t | <lookup-index-path> (namespace, paths)]}
   
   /** @internal */ 
-  nam-annotate-use(|namespace):
-    t -> t{[Unresolved(namespace), t | <IndexPath <+ ![]> namespace]}
+  nam-annotate-use(|paths, namespace, namespace2, name):
+    t -> t{[Unresolved(namespace), t | <lookup-index-path> (namespace, paths)]}
+    
+  /** @internal */ 
+  nam-annotate-scope(|path):
+    t -> t{Scope(path)}
   
   /** @internal */ 
   nam-get-scope-types = fail
+  /** @internal */ 
+  nam-ordered-def = fail
+  /** @internal */
+  nam-get-definitions = fail
+  /** @internal */
+  nam-get-definition = nam-get-definitions ; Hd 
+  /** @internal */
+  nam-get-definition-keys = fail
+  /** @internal */
+  nam-get-definition-key = nam-get-definition-keys ; Hd
+  /** @internal */
+  nam-get-uses = fail
+  /** @internal */
+  nam-get-use = nam-get-uses ; Hd 
+  /** @internal */
+  nam-get-uses-keys = fail
+  /** @internal */
+  nam-get-use-key = nam-get-uses-keys ; Hd
   /** @internal */
-  nam-get-definition = fail
+  nam-annotate-names(|paths, def-path) = fail
   /** @internal */
-  nam-get-definition-key = fail
+  nam-annotate-scopes(|def-path) = fail
   /** @internal */
-  nam-annotate-names(|def-path) = fail
+  nam-unique = fail

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.template/lib/analysis-library.generated.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.template/lib/analysis-library.generated.str	Tue Apr 16 20:17:51 2013	(r26053)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.template/lib/analysis-library.generated.str	Thu Apr 18 09:40:59 2013	(r26054)
@@ -70,6 +70,11 @@
    */
   adjust-index-lookup(check-target-name|namespace, path, prefix) = fail
   
+  /**
+   * Extension point.
+   */
+  adjust-index-import(|namespace, path) = fail
+  
   /** 
    * Extension point. Override this rule to store data about definitions in the index. Should call <store-results> on 
    * a (list of) data that must be stored in the index.
@@ -183,12 +188,15 @@
           <analyze-top-internal(|phase, language, project-path, full-path)> astsFilePairs
       else
         Results(asts, _, _, _, _, _, filesToAnalyze) := 
-          <analyze-top-internal(|phase, language, project-path, full-path)> [(ast, full-path)];
-        ast' := <Hd> asts
+          <analyze-top-internal(|phase, language, project-path, full-path)> [(ast, (full-path, []))];
+        ast' := <Hd> asts // Always returns a list of 1 AST if there is no splitter, so take the head.
       end
   
 rules // Parallel analysis
   
+  index-parallel-analyze-files(analyze) = index-analyze-files(index-parallel-analyze(analyze))
+  index-sequential-analyze-files(analyze) = index-analyze-files(index-sequential-analyze(analyze))
+  
   /**
    * Does a parallel analysis of given files using the specified analysis strategy. Automatically does parallel
    * analysis of dependent files that have changed during the analysis.
@@ -201,64 +209,97 @@
    *                a (ast', errors, warnings, notes, filesToAnalyze) tuple as output.
    * @type List((file, subfile) or file) -> None()
    */
-  index-parallel-analyze-files(analyze):
+  index-analyze-files(internal-analyze):
     files -> None()
     with
       length; 
       set-total-work-units
     with
-      index-parallel-analyze(analyze);
+      internal-analyze;
       filter(not(?ParallelResults((), (), _, _, _, _) <+ ?ParallelResults((), [()], _, _, _, _)); index-set-markers)
+      
+rules // Splitter
+  
+  /**
+   * Merges a top level definition back into an AST using splitter rules.
+   *
+   * @param toplevel  The top level definition to merge back into the given AST.
+   * @type ast -> ast'
+   */
+  index-merge-ast(|toplevel):
+    term -> merged
+    with
+      if <is-list> term then
+        [first-ast|_] := term;
+        merged        := <index-merge-ast(|toplevel)> first-ast
+      else
+        if <index-is-qualifier> term then
+          [elem|_]    := <index-qualifier-subelements> term;
+          merged      := <index-create-qualifier(|term)> <index-merge-ast(|toplevel)> elem
+        else
+          merged      := toplevel
+        end
+      end
  
 rules // Query primitives
  
   /**
-   * Gets all DefData entries that match the kind of data and URI in given definition.
+   * Gets a DefData entry that matches the kind of data and given URI, or fail.
    *
    * Example:
    *   <index-get-data(|Type())> Def([Entity(), "Bar"]) => [DefData([Entity(), "Bar"], Type(), TYPE("Bar")), ...]
    *
    * @param kind Only data of this kind is returned.
-   * @type Def(uri) -> List(DefData(uri, kind, value))
+   * @type Def(uri) or "name"{uri} or [namespace|path] -> List(DefData(uri, kind, value))
    */
   index-get-data(|kind):
-    <with(?Def(uri) | "Def expected")> -> <index-get-value> DefData(uri, kind, ())
+    <with(uri := <index-uri> | "Def, key or URI expected")> -> <index-get-value> DefData(uri, kind, ())
       
   /**
-   * Gets all data entries that match the kind of data and URI in given definition.
+   * Gets all DefData entries that match the kind of data and given URI
    *
    * Example:
    *   <index-get-data-all(|Type())> Def([Entity(), "Bar"]) => [TYPE("Bar"), ...]
    *
    * @param kind Only data of this kind is returned.
-   * @type Def(uri) -> List(value)
+   * @type Def(uri) or "name"{uri} or [namespace|path] -> List(value)
    */
   index-get-data-all(|kind):
-    <with(?Def(uri) | "Def expected")> -> <index-get-all-values> DefData(uri, kind, ())
+     <with(uri := <index-uri> | "Def, key or URI expected")> -> <index-get-all-values> DefData(uri, kind, ())
+
+  /**
+   * Gets a Use entry that matches given URI, or fail.
+   *
+   * Example:
+   *   <index-get-uses-all> Def([Entity(), "M", "Bar"]) => [Use([Entity(), "M", "Bar"]), ...]
+   *
+   * @type Def(uri) or "name"{uri} or [namespace|path] -> List(Use(uri))
+   */
+  index-get-use:
+    <with(uri := <index-uri> | "Def, key or URI expected")> -> <index-get-all> Use(uri)
      
   /**
-   * Gets all Use entries that match the URI in given definition.
+   * Gets all Use entries that match the given URI.
    *
    * Example:
    *   <index-get-uses-all> Def([Entity(), "M", "Bar"]) => [Use([Entity(), "M", "Bar"]), ...]
    *
-   * @type Def(uri) -> List(Use(uri))
+   * @type Def(uri) or "name"{uri} or [namespace|path] -> List(Use(uri))
    */
   index-get-uses-all:
-    <with(?Def(uri) | "Def expected")> -> <index-get-all> Use(uri)
+    <with(uri := <index-uri> | "Def, key or URI expected")> -> <index-get-all> Use(uri)
      
   /**
-   * Gets all Read or ReadWildcard entries that match the given template.
+   * Gets all Read and ReadWildcard entries that match the given URI.
    *
    * Example:
    *   <index-get-reads-all> [Property(), "Bar", "p"] => [Read([Property(), "Bar", "p"]), ...]
    *
-   * @type Def(uri) -> List(Read(uri) or ReadWildcard(uri, prefix))
+   * @type Def(uri) or "name"{uri} or [namespace|path] -> List(Read(uri) or ReadWildcard(uri, prefix))
    */
   index-get-reads-all:
-    template -> <conc> (reads, readwildcards')
+    <with(uri := <index-uri> | "Def, key or URI expected")> -> <conc> (reads, readwildcards')
     where
-      uri   := <index-uri> template;
       reads := <index-get-all> Read(uri);
       if !uri => [namespace, prefix | path-parent] then
         readwildcards  := <index-get-all> ReadWildcard([namespace | path-parent], ());
@@ -278,10 +319,10 @@
   index-get-all:
     template -> <indexlib-get-all> template
       with
-       if set := <Index-ReadSet> then
-         uri := <index-uri>;
-         <iset-add(|Read(uri))> set
-       end
+        if set := <Index-ReadSet> then
+          uri := <index-uri>;
+          <iset-add(|Read(uri))> set
+        end
        
   /**
    * Get all values of index entries that match the given template.
@@ -333,18 +374,19 @@
    * @type Def(uri) or "name"{uri} or uri@[namespace|path] -> List(Def(uri))
    */
   index-get-children(|namespace) = 
-    index-get-children(\uri -> Def(uri)\|namespace)
+    index-get-children(\uri -> Def(uri)\, id|namespace)
   
   /**
    * Gets all children elements of an URI in a certain namespace using custom templates.
    * URI can be contained in a Def(uri), key (term{uri} element) or the uri itself.
    *
    * @param construct-template  uri -> template. Should create a template to match index entries with, given an URI.
+   * @param name-compare        element -> ?element. Strategy for filtering children elements.
    * @param namespace           Only child elements in this namespace are returned.
    * @type Def(uri) or "name"{uri} or uri@[namespace|path] -> List(Def(uri))
    */
-  index-get-children(construct-template|namespace):
-    <with(?Def([parent-ns | path]) <+ ?_{[parent-ns | path]} <+ ?[parent-ns | path] | "Def, key or uri expected")> -> children
+  index-get-children(construct-template, name-compare|namespace):
+    <with([parent-ns | path] := <index-uri> | "Def, key or URI expected")> -> children
     with
       template  := <construct-template> [namespace | path];
       children  := <prim("LANG_index_get_children", template)>;
@@ -361,10 +403,10 @@
    *
    * @param namespace Only child Def elements in this namespace are returned.
    * @param prefix    Only child Def elements where the name starts with this prefix are returned.
-   * @type Def(uri) or "name"{uri} or uri@[namespace|path] -> List(Def(uri))
+   * @type Def(uri) or "name"{uri} or [namespace|path] -> List(Def(uri))
    */
   index-get-children(|namespace, prefix) = 
-    index-get-children(\uri -> Def(uri)\|namespace, prefix)
+    index-get-children(\uri -> Def(uri)\, index-compare-name-substring(|prefix, namespace)|namespace, prefix)
   
   /**
    * Gets all children elements of an URI in a certain namespace where the name starts with a prefix
@@ -372,18 +414,18 @@
    * URI can be contained in a Def(uri), key (term{uri} element) or the uri itself.
    *
    * @param construct-template  uri -> template. Should create a template to match index entries with, given an URI.
+   * @param name-compare        element -> ?element. Strategy for filtering children elements.
    * @param namespace           Only child elements in this namespace are returned.
    * @param prefix              Only child elements where the name starts with this prefix are returned.
-   * @type Def(uri) or "name"{uri} or uri@[namespace|path] -> List(Def(uri))
+   * @type Def(uri) or "name"{uri} or [namespace|path] -> List(Def(uri))
    */
-  index-get-children(construct-template|namespace, prefix):
-    <with(?Def([parent-ns | path]) <+ ?_{[parent-ns | path]} <+ ?[parent-ns | path] | "Def, key or uri expected")> -> children'
+  index-get-children(construct-template, name-compare|namespace, prefix):
+    <with([parent-ns | path] := <index-uri> | "Def, key or URI expected")> -> children'
     with
-      prefix'   := <strip-annos> prefix;
       template  := <construct-template> [namespace | path];
       children  := <prim("LANG_index_get_children", template)>;
-      children' := <filter(index-is-name-substring(|prefix'))> children;
-      <store-wildcard-read(|namespace, path, prefix')> children'
+      children' := <filter(name-compare)> children;
+      <store-wildcard-read(|namespace, path, prefix)> children'
 
   /**
    * Gets a set of all files that have a reference to the given index entries.
@@ -420,67 +462,103 @@
 rules // Index lookup rules (that take into account adjust-index-lookup)
  
   /**
-   * Given an annotated AST node, resolves it, returning its Def.
+   * Given an annotated AST node, resolves it, returning its definition.
+   * Uses precise matching for names.
    *
    * @type "name"{uri} -> ?Def(uri')
    */
   index-lookup:
-    x{[namespace|path]} -> <index-lookup(id|<index-namespace-unwrap> namespace, path, <strip-annos> x)>
+    x{[namespace|path]} -> <index-lookup-internal(index-get-defs, index-compare-name-equal(|name)|ns, path, name)> x
+    where
+      ns := <index-namespace-unwrap> namespace;
+      name := <strip-annos> x
  
   /**
-   * Given an annotated AST node, resolves it, returning all its Defs.
+   * Given an annotated AST node, resolves it, returning all its definitions.
+   * Uses precise matching for names.
    * 
    * @type "name"{uri} -> List(Def(uri'))
    */
   index-lookup-all:
-    x{[namespace|path]} -> <index-lookup-all(id|<index-namespace-unwrap> namespace, path, <strip-annos> x)>
+    x{[namespace|path]} -> <index-lookup-all-internal(index-get-defs, index-compare-name-equal(|name)|ns, path, name)> x
+    where
+      ns := <index-namespace-unwrap> namespace;
+      name := <strip-annos> x
  
   /**
-   * Given an annotated AST node, returns the outermost Def with a corresponding URI.
+   * Given an annotated AST node and a prefix, looks for all definitions with given prefix starting at the scope of 
+   * the given node.
+   * Uses substring matching for names.
    *
-   * @param prefix  Only Defs with a name that starts with this string are returned.
-   * @type "name"{uri} -> ?Def(uri')
+   * @param prefix    Only definitions with a name that starts with this string are returned.
+   * @type "name"{uri} -> List(Def(uri'))
    */
-  index-lookup-outermost(|prefix):
-    x{[namespace|path]} -> <index-lookup-outermost(id|<index-namespace-unwrap> namespace, path, prefix)>
- 
+  index-lookup-all(|prefix):
+    x{[namespace|path]} -> <index-lookup-all-internal(index-get-defs-prefix, index-compare-name-substring(|prefix)|ns, path, prefix)> x
+    where
+      ns := <index-namespace-unwrap> namespace
+      
   /**
-   * Given an annotated AST node, returns Defs that have the same parent URI.
+   * Given an annotated AST node, resolves it in only the parent scope of the given node, returning all its definitions.
+   * Uses precise matching for names.
    *
-   * @param prefix  Only Defs with a name that starts with this string are returned.
    * @type "name"{uri} -> List(Def(uri'))
    */
-  index-lookup-one-level(|prefix):
-    x{[namespace|path]} -> <index-lookup-one-level(id|<index-namespace-unwrap> namespace, path, prefix)>
+  index-lookup-all-scoped:
+    x{[namespace|path]} -> <index-lookup-all-scoped-internal(index-get-defs, index-compare-name-equal(|name)|ns, parent-path, name)> x
+    where
+      ns := <index-namespace-unwrap> namespace;
+      name := <strip-annos> x;
+      (<?[_|<id>]> path <+ !path) => parent-path
       
   /**
-   * Given an annotated AST node, resolves it, and returns all possibly matching Defs with a common ancestor URI. 
+   * Given an annotated AST node, resolves it in only the parent scope of the given node, returning all its definitions.
+   * Uses precise matching for names. Imports are not considered.
    *
-   * @param namespace Only Defs with this namespace are returned.
-   * @param prefix    Only Defs with a name that starts with this string are returned.
    * @type "name"{uri} -> List(Def(uri'))
    */
-  index-lookup-all-levels(|prefix):
-    x{[namespace|path]} -> <index-lookup-all-levels(id|<index-namespace-unwrap> namespace, path, prefix)>
- 
+  index-lookup-all-scoped-noimports:
+    x{[namespace|path]} -> <index-lookup-all-scoped-internal(fail, id, index-get-defs, index-compare-name-equal(|name)|ns, parent-path, name)> x
+    where
+      ns := <index-namespace-unwrap> namespace;
+      name := <strip-annos> x;
+      (<?[_|<id>]> path <+ !path) => parent-path
+  
   /**
-   * Given an annotated AST node, resolves it, and returns all child Defs of its definition.
+   * Given an annotated AST node and a prefix, looks for all definitions with given prefix in only the parent scope of 
+   * the given node.
+   * Uses substring matching for names.
    *
-   * @param namespace Only child Defs with this namespace are returned.
-   * @param prefix    Only Defs with a name that starts with this string are returned.
+   * @param prefix    Only definitions with a name that starts with this string are returned.
    * @type "name"{uri} -> List(Def(uri'))
    */
-  index-lookup-children(|namespace, prefix): // TODO: how does this compare w/ index-lookup-one-level?
-    x{[ns | path]} -> defs
-    with
-      if !ns => Unresolved(_) then
-        Def([_ | def-path]) := <index-lookup>;
-        defs := <index-lookup-one-level(id|namespace, def-path, prefix)> x
-      else
-        defs := <index-lookup-one-level(id|<index-namespace-unwrap> namespace, path, prefix)>
-      end
-    <+
-      defs := []
+  index-lookup-all-scoped(|prefix):
+    x{[namespace|path]} -> <index-lookup-all-scoped-internal(index-get-defs-prefix, index-compare-name-substring(|prefix)|ns, parent-path, prefix)> x
+    where
+      ns := <index-namespace-unwrap> namespace;
+      (<?[_|<id>]> path <+ !path) => parent-path
+
+  /**
+   * Given an annotated AST node and a namespace, returns all definitions inside given node with given namespace.
+   * Does not match names, all names are allowed.
+   *
+   * @param namespace Only definitions with this namespace are returned.
+   * @type "name"{uri} -> List(Def(uri'))
+   */
+  index-lookup-children(|namespace) = 
+    index-lookup-children(|namespace, "")
+      
+  /**
+   * Given an annotated AST node, a namespace and prefix, returns all definitions inside given node with given 
+   * namespace and prefix.
+   * Uses substring matching for names.
+   *
+   * @param namespace Only definitions with this namespace are returned.
+   * @param prefix    Only definitions with a name that starts with this string are returned.
+   * @type "name"{uri} -> List(Def(uri'))
+   */    
+  index-lookup-children(|namespace, prefix):
+    x{[_|path]} -> <index-lookup-all-scoped-internal(index-get-defs-prefix, index-compare-name-substring(|prefix, namespace)|namespace, path, prefix)> x
       
 rules // Index utilities
   
@@ -524,21 +602,6 @@
     x{[_|[name|_]]} -> name
     
   /**
-   * Tries to get the name part of the URI for given term or fail if given term does not have an URI or name.
-   *
-   * Example:
-   *   <index-uri-name> Def([Entity(), "Bar", "Baz"]) => "Bar"
-   *   <index-uri-name> Type("Foo") => fail
-   *   <index-uri-name> Read([Entity()]) => fail
-   *
-   * @type x -> name
-   */   
-  index-uri-name:
-    x -> <index-uri-name> <index-uri> x
-    where
-      not(<has-annos> x)
-    
-  /**
    * Determines if a given AST node is a definition site, according to the syntax.
    *
    * FIXME: Also succeeds on use sites.
@@ -562,3 +625,13 @@
     (k1, k2) -> <id>
     where
       <eq> (<index-key-unwrap> k1, <index-key-unwrap> k2)
+      
+  /**
+   * Given a list of file pairs, returns the list of real files.
+   *
+   * @type List((file, subfile)) -> List(file)
+   */    
+  index-filepairs-to-files:
+    filePairs -> files
+    with
+      files := <make-set> <map(Fst; string-replace(|<conc-strings> (<project-path>, "/"), ""))> filePairs

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.template/lib/compilation-library.generated.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.template/lib/compilation-library.generated.str	Tue Apr 16 20:17:51 2013	(r26053)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.template/lib/compilation-library.generated.str	Thu Apr 18 09:40:59 2013	(r26054)
@@ -42,6 +42,16 @@
    * @type ast -> None()
    */
   index-compile-ast(|file, subfile) = fail
+
+  /**
+   * Extension point. 
+   */
+  index-is-partial-ast = fail
+
+  /**
+   * Extension point. 
+   */
+  index-combine-asts = fail
   
 rules // Compilation
   
@@ -67,21 +77,48 @@
       diffs         := <analyze-get-compilediffs>;
       files         := <map(index-compilation-restore-read-file)> diffs;
       filteredFiles := <make-set> <remove-all(index-compilation-filter-file)> files;
+      (completeFiles, partialFiles) := <index-split-partial-files> filteredFiles;
       
       // Clean compile time reads
-      <filter(index-compilation-clean-reads)> filteredFiles;
+      <filter(index-compilation-clean-reads)> completeFiles;
+      <filter(index-compilation-clean-reads)> partialFiles;
       
       // Set total work units to number of files to compile for visual indication
-      <set-total-work-units> <length> filteredFiles;
+      <set-total-work-units> <add> (<length> completeFiles, <length> partialFiles);
       
       // Compile the files
-      <filter(index-compilation-file(|language, project-path); complete-work-unit)> filteredFiles
+      <filter(index-compilation-file(|language); complete-work-unit)> completeFiles;
+      <filter(index-compilation-partial-file(|language); complete-work-unit)> partialFiles
+      
+  /** @internal */    
+  index-split-partial-files:
+    files -> (completeFiles, <make-set> splitFiles)
+    with
+      (completeFiles, splitFiles) := <partition(not(index-file-is-partial), index-file-is-partial)> files
 
   /** @internal */
-  index-compilation-file(|language, project-path):
+  index-compilation-file(|language):
+    (path, subfile) -> None()
+    with
+      asts := <index-get-all-values> AST((language, path), ());
+      <map(index-compilation-ast(|path, subfile))> asts
+      
+  /** @internal */    
+  index-compilation-partial-file(|language):
     (path, subfile) -> None()
     with
-      ast := <index-get-global(|<conc> (<index-file-to-uri> (path, subfile), ["ast"]))>;
+      asts := <index-get-all-values> AST((language, subfile), ());
+      if 1 := <length> asts then
+        ast := <?[<id>|_]> asts
+      else
+        ast := <try(index-combine-asts)> asts
+      end;
+      <index-compilation-ast(|path, subfile)> ast
+      
+  /** @internal */
+  index-compilation-ast(|path, subfile):
+    ast -> None()
+    with
       {| Index-ReadSet:
         readSet := <new-iset>;
         rules(Index-ReadSet: _ -> readSet);
@@ -92,7 +129,7 @@
         // Store compile-time reads.
         reads := <iset-elements> readSet;
         <index-add-all(|<index-compilation-file-tuple> (path, subfile))> reads
-      |}
+      |} 
 
   /** @internal */
   index-compilation-filter-file:
@@ -168,12 +205,22 @@
   index-compilation-restore-read-file:
     (file, subfile) -> (file', subfile)
     where
-      file' := <string-replace(|<index-compilation-read-path>, "")> file
+      if removedPath := <string-replace(|<index-compilation-read-path>, "")> file then
+        file' := removedPath
+      else
+        file' := file
+      end
+
   /** @internal */
   index-compilation-restore-read-file:
-    (file, subfile) -> (file, subfile)
+    file -> file'
     where
-      not(<string-replace(|<index-compilation-read-path>, "")> file)
+      not(<is-tuple> file);
+      if removedPath := <string-replace(|<index-compilation-read-path>, "")> file then
+        file' := removedPath
+      else
+        file' := file
+      end
       
   /** @internal */
   index-compilation-clean-reads = 
@@ -186,3 +233,12 @@
   /** @internal */
   index-compilation-read-path =
     !"/.internal/reads/compile"
+    
+/** @internal */
+rules // Utility
+
+  /** @internal */
+  index-file-is-partial:
+    file -> file
+    where 
+      Snd; index-uri; index-is-partial-ast

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.template/lib/editor-common.generated.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.template/lib/editor-common.generated.str	Tue Apr 16 20:17:51 2013	(r26053)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.template/lib/editor-common.generated.str	Thu Apr 18 09:40:59 2013	(r26054)
@@ -135,8 +135,13 @@
   origin-strip     = prim("SSL_EXT_origin_strip", <id>)
   origin-equal(|t) = prim("SSL_EXT_origin_equal", <id>, t)
 
+  origin-language-description =
+    prim("SSL_EXT_languagedescription", <id>)
+
   origin-language =
-    prim("SSL_EXT_origin_language", <id>)
+    origin-file; 
+    origin-language-description;
+    Fst
   
   origin-surrounding-comments =
     prim("SSL_EXT_origin_surrounding_comments", "TemplateLang", <id>)
@@ -152,6 +157,13 @@
   origin-track-forced(s) =
     ![<id>]; all(s); ?[<id>]
 
+  origin-relative-path:
+    trm -> rel-path
+    where
+      full-path := <origin-file> trm;
+      len-project-prefix := <project-path; string-length; inc>;
+      rel-path := <string-as-chars(drop(|len-project-prefix))> full-path
+      
 strategies
 
   desugar-position(desugar|ast):

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.template/lib/index-library.generated.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.template/lib/index-library.generated.str	Tue Apr 16 20:17:51 2013	(r26053)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.template/lib/index-library.generated.str	Thu Apr 18 09:40:59 2013	(r26054)
@@ -145,6 +145,14 @@
    */
   index-clear = 
     prim("LANG_index_clear_all")
+    
+  /**
+   * Clears all elements from the index and re-analyzes all files in the project.
+   *
+   * @type x -> x
+   */
+  index-reload = 
+    prim("LANG_index_reload")
    
   /**
    * Commits index to a file on disk.
@@ -524,6 +532,19 @@
    */ 
   index-uri-name =
     ?[_|[<id>|_]]
+    
+  /**
+   * Gets the parent of given URI or fail if the URI doesn't have a parent.
+   *
+   * Example:
+   *   <index-uri-parent> [Entity(), "Bar", "Baz"] => [Entity(), "Baz"]
+   *   <index-uri-parent> [Entity(), "Baz"] => [Entity()]
+   *   <index-uri-parent> [Entity()] => fail
+   *
+   * @type uri@[namespace|[name|restPath]] -> ?name
+   */     
+  index-uri-parent =
+    ?[ns|[_|<id>]]; ![ns|<id>]
   
   /**
    * Gets the value part for given term. Can be extended by defining a index-value-impl rule. If no index-value-impl 
@@ -575,6 +596,19 @@
     x -> key
     where
       key := <collect-one(?_{_})> x
+
+  /**
+   * Converts a path from an URI to a string.
+   *
+   * Example:
+   *   <index-path-to-string> ["Bar", "Baz"] => "Bar.Baz"
+   *
+   * @type path -> str
+   */
+  index-path-to-string:
+    path -> str
+    with
+      str := <take-until(?Anon(_)); reverse; separate-by(|"."); concat-strings> path
       
   /**
    * Converts a URI to a string.
@@ -587,7 +621,7 @@
   index-uri-to-string:
     [ns|path] -> <concat-strings> [nsStr, "://", pathStr]
     with
-      pathStr := <take-until(?Anon(_)); reverse; separate-by(|"."); concat-strings> path;
+      pathStr := <index-path-to-string> path;
       nsStr := <?<id>#(_)> ns
   
   /**
@@ -666,6 +700,10 @@
       
 /** @internal */
 rules // URI and value projections
+
+  /** @internal */
+  index-uri-impl:
+    [_|_] -> <id>
   
   /** @internal */
   index-uri-impl:

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.template/trans/templatelang.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.template/trans/templatelang.str	Tue Apr 16 20:17:51 2013	(r26053)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.template/trans/templatelang.str	Thu Apr 18 09:40:59 2013	(r26054)
@@ -103,20 +103,20 @@
     )
 
   // Generate completion templates
-  generate-esv =
+  generate-esv(|path) =
     collect-sections;
     template-sections-to-esv;
-    !Module("example", NoImports(), <id>);
+    !Module($[[<base-filename ; remove-extension> path].generated], NoImports(), <id>);
     topdown(try(pp-fix-string-quotes))
 
   generate-esv-abstract =
-    generate-aterm(generate-esv)
+    generate-aterm(generate-esv(|""))
 
   generate-esv-concrete:
     (selected, position, ast, path, project-path) -> (filename, result)
     with
-      filename := <guarantee-extension(|"generated.esv")> path;
-      result   := <generate-esv; pp-descriptor-to-string> selected
+      filename := $[[project-path]/editor/[<guarantee-extension(|"generated.esv"); base-filename> path]];
+      result   := <generate-esv(|path); pp-descriptor-to-string> selected
 
   // Generate SDF
   generate-sdf(|path) =
@@ -137,19 +137,19 @@
       result   := <generate-sdf(|path); pp-sdf-to-string> selected
 
   // Generate pretty printer (BOX-based)
-  generate-box-pp =
+  generate-box-pp(|path) =
     collect-sections;
     template-sections-to-stratego(|"example");
-    !Specification(<id>)
+    !Module($[[<base-filename ; remove-extension> path].pp.generated], <id>)
 
   generate-box-pp-abstract =
-    generate-aterm(generate-box-pp)
+    generate-aterm(generate-box-pp(|""))
 
   generate-box-pp-concrete:
     (selected, position, ast, path, project-path) -> (filename, result)
     with
-      filename := <guarantee-extension(|"generated.str")> path;
-      result   := <generate-box-pp; pp-stratego-string> selected
+      filename := $[[project-path]/trans/[<guarantee-extension(|"pp.generated.str"); base-filename> path]];
+      result   := <generate-box-pp(|path); pp-stratego-string> selected
 
   generate-signature =
     collect-om(?Desugared(_));

From gabrielkonat at gmail.com  Thu Apr 18 11:47:46 2013
From: gabrielkonat at gmail.com (GabriÃ«l Konat)
Date: Thu, 18 Apr 2013 09:47:46 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26055 - in
	spoofax-imp/branches/spoofax-imp-release: .
	org.strategoxt.imp.editors.aterm
	org.strategoxt.imp.editors.aterm/.externalToolBuilders
	org.strategoxt.imp.editors.e...
Message-ID: <20130418094746.31A5F2B8015@mx2.tudelft.nl>

Author: gkonat
Date: Thu Apr 18 09:47:42 2013
New Revision: 26055
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26055&sc=1

Log:
Merge commit 26054 into stable

Modified:
   spoofax-imp/branches/spoofax-imp-release/   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.aterm/.externalToolBuilders/ATerm build.main.xml.launch   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.aterm/build.generated.xml   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.editorservice/.externalToolBuilders/EditorService build.main.xml.launch   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.editorservice/build.generated.xml   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.sdf/.externalToolBuilders/SDF build.main.xml.launch   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.sdf/build.generated.xml   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.spoofax/   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.stratego/build.generated.xml   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.template/build.generated.xml
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.template/editor/TemplateLang-Builders.generated.esv
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.template/lib/analysis-library-internal.generated.str
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.template/lib/analysis-library.generated.str
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.template/lib/compilation-library.generated.str
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.template/lib/editor-common.generated.str
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.template/lib/index-library.generated.str
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.template/trans/templatelang.str
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.generator/   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.generator/icons/   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.generator/src/sdf2imp/lib/asfix-abstractions.str   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.generator/src/sdf2imp/lib/core-sdf-grammar2rtg.str   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.generator/src/sdf2imp/lib/multi-options.str   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.generator/src/sdf2imp/lib/sdf-options.str   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.generator/src/sdf2imp/project/create-example-file.str   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.generator/src/sdf2imp/services/create-builders-descriptor.meta   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.generator/src/sdf2imp/services/create-builders-descriptor.str   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.generator/src/syntax/BuildersService.sdf   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.generator/test/   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.runtime/   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.runtime/_attic/org/strategoxt/imp/runtime/parser/ast/AsfixImploder.java   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.runtime/_attic/org/strategoxt/imp/runtime/parser/ast/ProductionAttributeReader.java   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.runtime/_attic/org/strategoxt/imp/runtime/services/ContentProposerParser.java   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.runtime/_attic/org/strategoxt/imp/runtime/stratego/adapter/WrappedAstNodeLink.java   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.runtime/icons/stratego.png   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/EditorState.java   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/dynamicloading/AbstractService.java   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/AbstractSGLRI.java   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/JSGLRI.java   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ParseCacheKey.java   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/StandAloneSGLRI.java   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AstMessageHandler.java   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/ast/AstNodeLocator.java   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/FoldingUpdater.java   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/InputTermBuilder.java   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/LabelProvider.java   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/NodeMapping.java   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoObserver.java   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/StrategoObserver.java.softreference.sketch   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/TextAttributeMapping.java   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/TreeModelBuilder.java   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/EditorIOAgent.java   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/FileTrackingIOAgent.java   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/IMPParseStringPTPrimitive.java   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/SourceMappings.java   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/StrategoConsole.java   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.testing.test/.externalToolBuilders/   (props changed)
   spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.testing.test/build.generated.xml   (props changed)

Modified: spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.template/build.generated.xml
==============================================================================
--- spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.template/build.generated.xml	Thu Apr 18 09:40:59 2013	(r26054)
+++ spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.template/build.generated.xml	Thu Apr 18 09:47:42 2013	(r26055)
@@ -2,9 +2,54 @@
 
 <project name="build.generated">
 
-        <target name="spoofaximp.default" depends="spoofaximp.default.ctree"/>
-        <target name="spoofaximp.default.ctree" depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,java.jar,stratego.ctree,sdf2imp,refresh"/>
-        <target name="spoofaximp.default.jar" depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,java.jar,stratego.jar.helper,sdf2imp,refresh"/>
+			  <target name="spoofaximp.default" depends="spoofaximp.default.ctree"/>
+			  <target name="spoofaximp.default.ctree" depends="
+			      check-classpath,
+			      call-onsave,
+			      init,
+			      sdf2table,
+			      meta-sdf2table,
+			      ppgen,
+			      pppack,
+			      sdf2imp.eclipse,
+			      sdf2imp.standalone,
+			      sdf2parenthesize,
+			      stratego.aster,
+			      java.jar,
+			      stratego.ctree,
+			      refresh,
+			      sdf2imp.eclipse.load"/>
+			  <target name="spoofaximp.default.jar" depends="
+			      check-classpath,
+			      call-onsave,
+			      init,
+			      sdf2table,
+			      meta-sdf2table,
+			      ppgen,
+			      pppack,
+			      sdf2imp.eclipse,
+			      sdf2imp.standalone,
+			      sdf2parenthesize,
+			      stratego.aster,
+			      java.jar,
+			      stratego.jar.helper,
+			      refresh,
+			      sdf2imp.eclipse.load"/>
+			  <target name="spoofaximp.default.nostr" depends="
+			      check-classpath,
+			      call-onsave,
+			      init,
+			      sdf2table,
+			      meta-sdf2table,
+			      ppgen,
+			      pppack,
+			      sdf2imp.eclipse,
+			      sdf2imp.standalone,
+			      sdf2parenthesize,
+			      stratego.aster,
+			      java.jar,
+			      refresh,
+			      sdf2imp.eclipse.load"/>
     
         <!-- Initialization -->
         <available file="${src-gen}/org/strategoxt/imp/editors/template/strategies/Main.java" property="java.jar.enabled"/>
@@ -46,6 +91,23 @@
         <mkdir dir="${lib}"/>
         <mkdir dir="${syntax}"/>
 
+			  <!-- The files for which the on-save handler is called before building -->
+			  <path id="call-onsave.files">
+			    <fileset dir=".">
+			      <include name="**/*.tmpl"/>
+			      <include name="**/*.nd"/>
+			      <include name="**/*.nab"/>
+			    </fileset>
+			  </path>
+				
+				<!-- Call on-save handler for template and name binding files so that their generated files are present -->
+				<target name="call-onsave">
+					<pathconvert pathsep=" " property="call-onsave.args" refid="call-onsave.files"/>
+					<java classname="org.strategoxt.imp.metatooling.building.AntForceOnSave">
+						<arg line="${call-onsave.args}"/>
+					</java>
+				</target>
+
         <target name="sdf2imp" depends="sdf2table,sdf2imp.eclipse,sdf2imp.standalone,sdf2parenthesize"/>
         
         <target name="sdf2imp.eclipse" if="eclipse.running" depends="sdf2rtg">
@@ -54,6 +116,12 @@
             </java>
         </target>
         
+        <target name="sdf2imp.eclipse.load" if="eclipse.running">
+		<java classname="org.strategoxt.imp.metatooling.loading.AntDescriptorLoader" failonerror="true">
+			<arg value="${include}/${esvmodule}.packed.esv"/>
+		</java>
+	</target>
+        
         <target name="refresh" if="eclipse.running">
             <eclipse.convertPath fileSystemPath="${basedir}" property="projectdir"/>
             <eclipse.convertPath fileSystemPath="${syntax}" property="syntaxdir"/>
@@ -161,6 +229,7 @@
             <copy file="${eclipse.spoofaximp.jars}/make_permissive.jar" todir="utils" failonerror="false"/>
             <copy file="${eclipse.spoofaximp.jars}/sdf2imp.jar" todir="utils" failonerror="false"/>
             <copy file="${eclipse.spoofaximp.jars}/aster.jar" todir="utils" failonerror="false"/>
+            <copy file="${eclipse.spoofaximp.jars}/StrategoMix.def" todir="utils" failonerror="false"/>
             <copy file="${eclipse.spoofaximp.strategojar}" todir="utils" failonerror="false"/>
         </target>
     
@@ -385,6 +454,13 @@
     
         <!-- Stratego to Java interpreter -->
         <target name="stratego.ctree" depends="rtg2sig">
+            <fail message="Main stratego file '${strmodule}.str' not found.">
+                <condition>
+                    <not>
+                        <isset property="build.stratego.enabled"/>
+                    </not>
+                </condition>
+            </fail>
             <dependset>
                 <srcfileset dir="${basedir}">
                     <include name="**/*.str"/>
@@ -403,6 +479,13 @@
     
         <!-- Stratego to Java compiler -->
         <target name="stratego.jar" depends="rtg2sig,utils-files">
+            <fail message="Main stratego file '${strmodule}.str' not found.">
+                <condition>
+                    <not>
+                        <isset property="build.stratego.enabled"/>
+                    </not>
+                </condition>
+            </fail>
             <dependset>
                 <srcfileset dir="${basedir}">
                     <include name="**/*.str"/>
@@ -629,12 +712,44 @@
             </apply>
         </target>
         
-        <target name="clean" description="Selective clean up">
-            <delete dir="${build}"/>
-            <delete file="${include}/${sdfmodule}.def"/>
-            <delete file="${include}/${strmodule}.rtree"/>
-            <delete file="${include}/${strmodule}.ctree"/>
-            <delete file="${include}/${strmodule}.jar"/>
-            <delete dir="${src-gen}/trans"/>
-        </target>
+	<target name="clean" description="Clean project">
+		<delete dir="${build}"/>
+		<delete dir=".cache"/>
+		<delete file="${include}/${sdfmodule}.def"/>
+		<delete file="${include}/${sdfmodule}-parenthesize.str"/>
+		<delete file="${include}/${sdfmodule}-Permissive.def"/>
+		<delete file="${include}/${sdfmodule}.generated.pp.af"/>
+		<delete file="${include}/${sdfmodule}.packed.esv"/>
+		<delete file="${include}/${sdfmodule}.pp.af"/>
+		<delete file="${include}/${sdfmodule}.rtg"/>
+		<delete file="${include}/${sdfmodule}.str"/>
+		<delete file="${include}/${sdfmodule}.tbl"/>
+		<delete file="${include}/${strmodule}.rtree"/>
+		<delete file="${include}/${strmodule}.ctree"/>
+		<delete file="${include}/${strmodule}.ctree.dep"/>
+		<delete file="${include}/${strmodule}.jar"/>
+		<delete>
+			<fileset dir="editor" includes="*.generated.esv"/>
+		</delete>
+		<delete dir="${src-gen}/trans"/>
+		<delete file="editor/${sdfmodule}.generated.esv"/>
+		<delete file="${syntax}/${sdfmodule}.generated.esv"/>
+		<delete file="${syntax}/${sdfmodule}.generated.pp"/>
+		<delete file="${include}/${metasdfmodule}-Permissive.def"/>
+		<delete file="${include}/${metasdfmodule}.def"/>
+		<delete file="${include}/${metasdfmodule}.tbl"/>
+		<delete file=".settings/org.eclipse.jdt.core.prefs"/>
+		<delete dir="utils"/>
+		<delete>
+			<fileset dir="lib-refactoring" includes="*.generated.str"/>
+			<fileset dir="${lib}" includes="*.generated.str"/>
+		</delete>
+		<antcall target="refresh-cleaned"/>
+	</target>
+	
+	<target name="refresh-cleaned" if="eclipse.running">
+        <eclipse.convertPath fileSystemPath="${basedir}" property="projectdir"/>
+        <eclipse.refreshLocal resource="${projectdir}" depth="infinite"/>
+    </target>
+	
     </project>
\ No newline at end of file

Modified: spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.template/editor/TemplateLang-Builders.generated.esv
==============================================================================
--- spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.template/editor/TemplateLang-Builders.generated.esv	Thu Apr 18 09:40:59 2013	(r26054)
+++ spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.template/editor/TemplateLang-Builders.generated.esv	Thu Apr 18 09:47:42 2013	(r26055)
@@ -2,70 +2,43 @@
 module TemplateLang-Builders.generated
 
 builders
-                                                                                                                    
-  // Building and analysis is defined in Stratego program or programs:                                              
-  //                                                                                                                
-  //   provider : stratego-program.ctree                                                                            
-  //   provider : stratego-library.jar                                                                              
-  //                                                                                                                
-  // Analysis is carried out by a Stratego rule that can be selected as follows:                                    
-  //                                                                                                                
-  //   observer : analysis-rule                                                                                     
-  //                                                                                                                
-  // Any dynamic rules set in the analysis may be used by other semantic services,                                  
-  // such as reference resolving or the builders.                                                                   
-  //                                                                                                                
-  // The (multifile) annotation can be added to an observer to indcate that this                                    
-  // observer will receive a list of files if multiple files change, instead of running                             
-  // the observer on every file separately.                                                                         
-  //                                                                                                                
-  // Builders may carry out custom transformations on a file or selection.                                          
-  // (At run-time, they can be accessed using the toolbar button with the star icon.)                               
-  // Builders can be specified as follows:                                                                          
-  //                                                                                                                
-  //   builder : "Generate Java code" = generate-java (openeditor) (persistent) (realtime)                          
-  //                                                                                                                
-  // In this example, the caption "Generate Java code" is used in the build button dropdown menu,                   
-  // and the generate-java rule is used to carry out the tranformation.                                             
-  // Builder definitions can also specify any combination of the following annotations:                             
-  //                                                                                                                
-  //   (cursor)      The builder should always transform the tree node at the cursor.                               
-  //   (meta)        Indicates the builder should only be available to meta-programmers                             
-  //                 (i.e., not when the plugin is deployed to end-users).                                          
-  //   (openeditor)  Indicates an editor should be opened with the result.                                          
-  //   (persistent)  Indicates that the resulting file should be saved to disk.                                     
-  //   (realtime)    Indicates that the resulting editor should be updated in real-time                             
-  //                 as the source file is edited.                                                                  
-  //   (source)      Always apply this builder to the source AST, not to the AST                                    
-  //                 after it has been analyzed/desugared by the observer.                                          
-  //                                                                                                                
-  // Refactorings are used for transformations that modify the original source code,                                
-  // while preserving the layout and syntactic sugar.                                                               
-  // A custom pretty-print strategy (T -> String) is used to format newly inserted nodes,                           
-  // a parenthesize strategy (T -> T) surrounds subterms with "Parenthetical(T)" when brackets are required,        
-  // resugar rules are required for desugarings that are not local-to-local or desugarings that duplicate terms     
-  // as the 'l' in \l -> []\ => {l: ( l -> [] )}.                                                                   
-  // Finally, text-reconstruction can be overruled with a strategy (T-old, T-new) -> <try(custom-pp)> T-new,        
-  // the resulting text will be indented according to its location.                                                 
-  // This is sometimes needed in case the node text can not be reconstructed by replacing child texts               
-  // in the original formatting.                                                                                    
-  //                                                                                                                
-  // Refactorings can be specified as shown below, whereby Property* indicates on which constructs the              
-  // refactoring is specified (<sort>.<constructor>).                                                               
-  //                                                                                                                
-  // refactorings                                                                                                   
-  //                                                                                                                
-  //   pretty-print: prettyprint                                                                                    
-  //   parenthesize: parenthesize                                                                                   
-  //   resugar: resugar-node                                                                                        
-  //   override reconstruction: disallow-reconstruction                                                             
-  //                                                                                                                
-  //   refactoring Property*: "Extract Entity" =  extract-entity (source)                                           
-  //     shortcut: Shift+Alt+M                                                                                      
-  //     input                                                                                                      
-  //       identifier: "entity name" = ""                                                                           
-  //       identifier: "property name" = ""                                                                         
-  //                                                                                                                
-  // The 'on save' handler can be used  to generate code as files are saved:                                        
-  //                                                                                                                
-  //   on save : index-on-save                                                                                      
\ No newline at end of file
+                                                                                                      
+  // Building and analysis is defined in Stratego program or programs:                                
+  //                                                                                                  
+  //   provider : stratego-program.ctree                                                              
+  //   provider : stratego-library.jar                                                                
+  //                                                                                                  
+  // Analysis is carried out by a Stratego rule that can be selected as follows:                      
+  //                                                                                                  
+  //   observer : analysis-rule                                                                       
+  //                                                                                                  
+  // Any dynamic rules set in the analysis may be used by other semantic services,                    
+  // such as reference resolving or the builders.                                                     
+  //                                                                                                  
+  // The (multifile) annotation can be added to an observer to indcate that this                      
+  // observer will receive a list of files if multiple files change, instead of running               
+  // the observer on every file separately.                                                           
+  //                                                                                                  
+  // Builders may carry out custom transformations on a file or selection.                            
+  // (At run-time, they can be accessed using the toolbar button with the star icon.)                 
+  // Builders can be specified as follows:                                                            
+  //                                                                                                  
+  //   builder : "Generate Java code" = generate-java (openeditor) (persistent) (realtime)            
+  //                                                                                                  
+  // In this example, the caption "Generate Java code" is used in the build button dropdown menu,     
+  // and the generate-java rule is used to carry out the tranformation.                               
+  // Builder definitions can also specify any combination of the following annotations:               
+  //                                                                                                  
+  //   (cursor)      The builder should always transform the tree node at the cursor.                 
+  //   (meta)        Indicates the builder should only be available to meta-programmers               
+  //                 (i.e., not when the plugin is deployed to end-users).                            
+  //   (openeditor)  Indicates an editor should be opened with the result.                            
+  //   (persistent)  Indicates that the resulting file should be saved to disk.                       
+  //   (realtime)    Indicates that the resulting editor should be updated in real-time               
+  //                 as the source file is edited.                                                    
+  //   (source)      Always apply this builder to the source AST, not to the AST                      
+  //                 after it has been analyzed/desugared by the observer.                            
+  //                                                                                                  
+  // The 'on save' handler can be used  to generate code as files are saved:                          
+  //                                                                                                  
+  //   on save : editor-save                                                                          
\ No newline at end of file

Modified: spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.template/lib/analysis-library-internal.generated.str
==============================================================================
--- spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.template/lib/analysis-library-internal.generated.str	Thu Apr 18 09:40:59 2013	(r26054)
+++ spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.template/lib/analysis-library-internal.generated.str	Thu Apr 18 09:47:42 2013	(r26055)
@@ -16,6 +16,13 @@
   // Namespaces
   Diff            : Namespace
   ASTDiff         : Namespace
+  AST             : Namespace
+  
+  // Data
+  AST             : Identifier * AST -> AST
+  
+  // Annotations 
+  Scope: Term -> Anno
   
 rules // Analysis traversals
   
@@ -70,7 +77,7 @@
         filesToAnalyze := []
       end
     with
-      <list-loop(analyze-top-store-ast)> astFilePairs4
+      <list-loop(analyze-top-store-ast(|language, full-path))> astFilePairs4
       
   /**
    * Add URI annotations to each definition and unresolved URI annotations to each use site.
@@ -81,7 +88,8 @@
     (ast, file) -> ((ast2, file), defs)
     with
       <index-set-current-file> file;
-      (Some(ast2), defs) := <analyze-defs> Some(ast); // HACK: force origin tracking with Some()... // TODO: still needed?
+      (Some(ast2), edefs) := <analyze-defs> Some(ast); // HACK: force origin tracking with Some()... // TODO: still needed?
+      defs := <map(Snd)> edefs; 
       <index-add-all(|file)> defs
       
   /**
@@ -102,7 +110,7 @@
         data := <origin-track-forced(analyze-tree-data)> ast2;
         
         // Resolve all references in gathered data.
-        (data2, _) := <analyze-uses> data; // Ignoring data uses, have not found a use-case for them yet.
+        (data2, _) := <analyze-uses> data;
         <index-add-all(|file)> data2;
         
         // Store reads into the index (if not testing language)
@@ -141,10 +149,14 @@
    *
    * @internal
    */   
-  analyze-top-store-ast:
-    (ast, file) -> <id>
-    with
-      <index-set-global(|<conc> (<index-file-to-uri> file, ["ast"]))> ast
+  analyze-top-store-ast(|language, full-path):
+    (ast, (file, subfile)) -> <id>
+    where
+      if [] := subfile then
+        <index-add(|full-path)> AST((language, full-path), ast)
+      else
+        <index-add(|full-path)> AST((language, subfile), ast)
+      end
       
   /**
    * Identifies all definitions in the tree and annotates them with their URI.
@@ -152,66 +164,100 @@
    *
    * @internal
    */
-  analyze-defs = analyze-defs(|Anon(), Anon())
+  analyze-defs:
+    ast -> (<analyze-defs(|[], set, Anon(), Anon())> ast, <iset-elements> set)
+    where
+      set := <new-iset>
+       
+  /** @internal */
+  analyze-defs(|paths, defs, head-scope, head-scope-ns):
+    ast{Scope([namespace, name | path])} -> ast'
+    where
+      paths' := <update-index-paths(|[(namespace, path)])> paths ;
+      ast'   := <rm-annotations; analyze-defs(|paths', defs, Anon(), Anon())> ast
+      
+  
   /** @internal */
-  analyze-defs(|head-scope, head-scope-ns):
-    ast -> (ast', defs')
+  analyze-defs(|paths, defs, head-scope, head-scope-ns):
+    ast -> ast'
+    where
+      <not(has-annos)> ast      
     with
-      if def := <nam-get-definition> ast then
-        Def(def-path)                     := def;
-        [head-scope-ns', head-scope' | _] := def-path
+      if (namespace, path) := <nam-get-definition> ast then
+        definition     := <nam-get-def(|paths, namespace)> path;
+        Def(def-path)  := definition; 
+        head-scope-ns' := namespace;
+        head-scope'    := <Hd> path;
+        f#(children)   := <try(nam-annotate-scopes(|def-path))> ast;
+        <iset-add(|(<new>, definition))> defs
       else
         def-path       := INTERNAL_ERROR();
         head-scope-ns' := head-scope-ns;
-        head-scope'    := head-scope
+        head-scope'    := head-scope;
+        f#(children)   := ast
       end;
       if scope-types := <nam-get-scope-types> ast then
-        {| IndexPath:
-          <list-loop(update-index-path(|head-scope', head-scope-ns', ast))> scope-types;
-          // <balanced-update-path> head-scope';
-          (ast', defs) := <analyze-defs-recurse(|Anon(), Anon(), def-path)> ast
-        |}
-      else
-        (ast', defs) := <analyze-defs-recurse(|head-scope', head-scope-ns', def-path)> ast
+        unique          := Anon(<new>);
+        updates         := <map(construct-index-path(|paths, head-scope', head-scope-ns', unique, ast))> scope-types;
+        paths'          := <update-index-paths(|updates)> paths;
+        head-scope-ns'' := Anon();
+        head-scope''    := Anon()
+      else
+        paths'          := paths;
+        head-scope-ns'' := head-scope-ns';
+        head-scope''    := head-scope'
       end;
-      defs' := <![def | defs] <+ !defs>
-      
+      children' := <origin-track-forced(analyze-child-defs(|paths', defs, head-scope'', head-scope-ns''))> children;
+      ast'      := <try(nam-annotate-names(|paths', def-path))> f#(children') 
+       
+  /** @internal */
+  analyze-child-defs(|paths, defs, head-scope, head-scope-ns):
+    [] -> []
+    
   /** @internal */
-  analyze-defs-recurse(|head-scope, head-scope-ns, def-path):
-    ast -> (ast'', defs)
+  analyze-child-defs(|paths, defs, head-scope, head-scope-ns):
+    [d|ds] -> [d'|ds']
     where
-      analyzed      := <all(analyze-defs(|head-scope, head-scope-ns))> ast;
-      (ast', defs)  := <unzip-analyzed> analyzed;
-      ast''         := <try(nam-annotate-names(|def-path))> ast'
- 
+      d'  := <analyze-defs(|paths, defs, head-scope, head-scope-ns)> d ;
+      if <nam-ordered-def> d then
+        [namespace, name | path] := <nam-get-definition-key ; index-uri> d' ;
+        paths'                   := <update-index-paths(|[(namespace, path)])> paths ;
+        ds'                      := <analyze-child-defs(|paths', defs, Anon(), Anon())> ds
+      else
+        ds' := <analyze-child-defs(|paths, defs, head-scope, head-scope-ns)> ds
+      end
+  
   /** @internal */
-  update-index-path(|head-scope, head-scope-ns, ast):
-    scope-type -> scope-type
+  construct-index-path(|paths, head-scope, head-scope-ns, unique, ast):
+    scope-type -> (scope-type, path'')
     where
       if !head-scope-ns => Anon() then
-        path  := <IndexPath <+ ![]> scope-type;
-        path' := <do-adjusted-index-path(|scope-type, path, Anon(<new>))> ast
+        path  := <lookup-index-path> (scope-type, paths);
+        path' := <index-do-adjust-path(|scope-type, path, Anon(<new>))> ast
       else
-        path  := <IndexPath <+ ![]> head-scope-ns;
-        path' := <do-adjusted-index-path(|scope-type, path, head-scope)> ast
+        path  := <lookup-index-path> (head-scope-ns, paths);
+        path' := <index-do-adjust-path(|scope-type, path, head-scope)> ast
       end;
-      rules(IndexPath: scope-type -> path')
- 
-  /* TODO: consider using simple-update-def-path
-   *       which uses "balanced" path scopes
-   *       e.g. when Entity doesn't scope Function
-   *       then it's hard to access properties from a function
-  balanced-update-index-path:
-    head-scope -> head-scope
-    where
-      if !head-scope => Anon() then
-        head-scope' := Anon(<new>)
+      // HACK: Disable generation of anonymous namespaces for unique definitions to let FieldAccess-like constructs work.
+      if /*<nam-unique> ast*/ fail then
+        path'' := <index-do-adjust-path(|scope-type, path', unique)> ast
       else
-        head-scope' := head-scope
-      end;
-      (something with do-adjust-path)
-      rules(IndexPath := [head-scope' | <IndexPath <+ ![]> ()])
-  */
+        path'' := path'
+      end
+      
+  /** @internal */
+  update-index-paths(|updates) = 
+    remove-all(?(<id>, _); !(<id>, updates) ; lookup') ; at-end(!updates)
+  
+  /** @internal */
+  lookup-index-path = 
+    lookup' <+ ![]
+ 
+  /** @internal */
+  index-do-adjust-path(|namespace, path, scope) =
+    adjust-index-path(origin-equal(|scope)|namespace, path)
+  <+
+    ![scope|path]
  
   /**
    * Analyze all uses, changing their preliminary "Unresolved(_)" URI to a definite URI of their definition.
@@ -224,7 +270,7 @@
       analyzed     := <all(analyze-uses)> ast;
       (ast', uses) := <unzip-analyzed> analyzed;
       if !ast' => _{unresolved@[Unresolved(namespace), x | path]} then
-        if Def(def-uri) := <index-lookup(id |namespace, path, <strip-annos> ast')> ast' then
+        if Def(def-uri) := <index-lookup> ast' then
           ast'' := ast{def-uri};
           uses' := [Use(def-uri) | uses]
         else
@@ -271,32 +317,37 @@
       
 rules // Parallel analysis
   
+  index-parallel-analyze(analyze) = index-analyze(parallel-unordered(all(index-do-analysis(analyze))))
+  index-sequential-analyze(analyze) = index-analyze(all(index-do-analysis(analyze)))
+  
   /** @internal */
-  index-parallel-analyze(analyze):
+  index-analyze(do-analysis):
     files -> allResults
     with
-      map(index-parse-file); // Parsing cannot be done in parallel.
-      map(\(ast, file) -> (ast, file, <project-path>)\);
-      parallel-unordered(all(index-analyze(analyze)));
-      ?results;
-      with(<eq> (<length> results, <length> files) | "Input size not equal to output size");
-      filesToAnalyze := <make-set> <mapconcat(?ParallelResults(_, _, _, _, _, <id>))> results;
-      if not([] := filesToAnalyze) then
-        allResults := <concat> [results, <index-parallel-analyze(analyze)> filesToAnalyze]
+      asts      := <map(index-parse-file)> files; 
+      data      := <map(\(ast, file) -> (ast, file, <project-path>)\)> asts;
+      results   := <do-analysis> data;
+      reanalyze := <make-set> <mapconcat(?ParallelResults(_, _, _, _, _, <id>))> results;
+      if not([] := reanalyze) then
+        allResults := <conc> (results, <index-analyze(do-analysis)> reanalyze)
       else
         allResults := results
       end
   
-  /** @internal */   
+  /** @internal */
   index-parse-file:
-    file -> (ast, file)
+    file -> (ast', file)
     with
-    if <file-exists> file then
-      ast := <parse-file> file
-    else
-      ast := ()
-    end
-   
+      if <file-exists> file then
+        if ast := <parse-file> file then
+          ast' := ast
+        else
+          ast' := ()
+        end
+      else
+        ast' := ()
+      end
+      
   /** @internal */   
   index-set-markers:
     ParallelResults(ast, ast', errors, warnings, notes, diffs) -> <id>
@@ -304,11 +355,11 @@
       <set-markers(|ast)> (ast', errors, warnings, notes)
       
   /** @internal */
-  index-analyze(analyze):
-    (ast, path, project-path) -> ParallelResults(ast, ast', errors, warnings, notes, filesToAnalyze)
+  index-do-analysis(analyze):
+    (ast, path, project-path) -> ParallelResults(ast, ast', errors, warnings, notes, reanalyze)
     with
-      (ast', errors, warnings, notes, filesToAnalyze) := <analyze>;
-      if [] := filesToAnalyze then
+      (ast', errors, warnings, notes, reanalyze) := <analyze>;
+      if [] := reanalyze then
         complete-work-unit
       end
       
@@ -425,121 +476,198 @@
 rules // Index lookup rules (that take into account adjust-index-lookup)
   
   /**
-   * Given an annotated AST node, resolves it, returning all its Defs.
+   * Given a term x, namespace n, path s and prefix p, looks for a definition in the 
+   * scope of s and outer scopes in namespace n that start with prefix p, returning the first 
+   * found definition.
+   *
+   * @param namespace Only definitions with this namespace are returned.
+   * @param path      Only definitions with this path or part of this path are returned.
+   * @param prefix    Only definitions with a name that starts with this string are returned.
    *
-   * @param prefix  Only Defs with a name that starts with this string are returned.
+   * @type term -> ?Def(uri')
    *
    * @internal
-   * @type "name"{uri} -> ?Def(uri')
    */
-  index-lookup(is-adjust-lookup-enabled|namespace, path, prefix):
-    x -> def
+  index-lookup-internal(adjust-import, adjust-lookup, get-defs, name-compare|namespace, path, prefix):
+    x -> definition
     where
-      candidates := <index-lookup-one-level(is-adjust-lookup-enabled|namespace, path, prefix)>;
-      if <?StopLookup()> candidates then
+      defs := <index-lookup-all-scoped-internal(adjust-import, adjust-lookup, get-defs, name-compare|namespace, path, prefix)> x;
+      
+      if StopLookup() := defs then
         fail
-      else
-        def        := <index-select(|namespace, path, x)>
-      <+
-        // TODO: optimize: try not to call do-adjust-index-lookup from here
-        [_ | path'] := path;
-        def         := <index-lookup(is-adjust-lookup-enabled|namespace, path', prefix)> x
+      end;
+      
+      if not(definition := <Hd> defs) then
+        [_|path']  := path;
+        definition := <index-lookup-internal(adjust-import, adjust-lookup, get-defs, name-compare|namespace, path', prefix)> x
       end
+      
+  /** @internal */
+  index-lookup-internal(get-defs, name-compare|namespace, path, prefix) = 
+    index-lookup-internal(id, id, get-defs, name-compare|namespace, path, prefix)
 
   /**
-   * Given an annotated AST node, resolves it, returning all its Defs.
-   *
-   * @param prefix  Only Defs with a name that starts with this string are returned.
+   * Given a term x, namespace n, path s and prefix p, looks for definitions in the scope of s 
+   * and outer scopes in namespace n that start with prefix p, returning all found definition.
    *
+   * @param namespace Only definitions with this namespace are returned.
+   * @param path      Only definitions with this path or part of this path are returned.
+   * @param prefix    Only definitions with a name that starts with this string are returned.
    * @type "name"{uri} -> List(Def(uri'))
+   *
    * @internal
    */
-  index-lookup-all(is-adjust-lookup-enabled|namespace, path, prefix):
+  index-lookup-all-internal(adjust-import, adjust-lookup, get-defs, name-compare|namespace, path, prefix):
     x -> defs'
     where
-      candidates := <index-lookup-one-level(is-adjust-lookup-enabled|namespace, path, prefix)>;
-      defs       := <index-select-all(|namespace, path, x)>;
-      // TODO: optimize: try not to call do-adjust-index-lookup from here
-      if [_ | path'] := path then
-        defs2 := <index-lookup-all(is-adjust-lookup-enabled|namespace, path', prefix)> x;
+      defs := <index-lookup-all-scoped-internal(adjust-import, adjust-lookup, get-defs, name-compare|namespace, path, prefix)> x;
+      
+      if [_|path'] := path then
+        defs2 := <index-lookup-all-internal(adjust-import, adjust-lookup, get-defs, name-compare|namespace, path', prefix)> x;
         defs' := <conc> (defs, defs2)
       else
         defs' := defs
       end
+
+  /** @internal */
+  index-lookup-all-internal(get-defs, name-compare|namespace, path, prefix) = 
+    index-lookup-all-internal(id, id, get-defs, name-compare|namespace, path, prefix)
       
   /**
-   * Given an annotated AST node, returns the outermost Def with a corresponding URI.
-   *
-   * @param prefix  Only Defs with a name that starts with this string are returned.
-   *
-   * @type "name"{uri} -> ?Def(uri')
-   * @internal
-   */
-  index-lookup-outermost(is-adjust-lookup-enabled |namespace, path, prefix):
-    x -> def
-    where
-      // TODO: optimize: just like index-lookup
-      [_ | path'] := path;
-      def         := <index-lookup-outermost(is-adjust-lookup-enabled |namespace, path', prefix)> x
-    <+
-      candidates := <index-lookup-one-level(is-adjust-lookup-enabled|namespace, path, prefix)>;
-      def        := <index-select(|namespace, path, x)>
-      
-  /**
-   * Given an annotated AST node, resolves it, and returns all possibly matching Defs with a common ancestor URI. 
+   * Given a term x, namespace n, path s and prefix p, looks for a definition in the 
+   * scope of s in namespace n that start with prefix p, returning the first found definition.
    *
-   * @param namespace Only Defs with this namespace are returned.
-   * @param prefix    Only Defs with a name that starts with this string are returned.
+   * @param namespace Only definitions with this namespace are returned.
+   * @param path      Only definitions with this path are returned.
+   * @param prefix    Only definitions with a name that starts with this string are returned.
+   * @type term -> List(Def(uri))
    *
-   * @type "name"{uri} -> List(Def(uri'))
    * @internal
    */
-  index-lookup-one-level(is-adjusted-lookup-enabled|namespace, path, prefix):
-    x{_} -> defs
+  index-lookup-all-scoped-internal(adjust-import, adjust-lookup, get-defs, name-compare|namespace, path, prefix):
+    x -> defs
     with
-      is-adjusted-lookup-enabled;
-      do-adjust-index-lookup(|namespace, path, x, prefix);
-      if ?StopLookup() then
-        defs := StopLookup()
-      else
-        mapconcat(\d at Def(p) -> [d]\
-          <+ \[namespace' | path'] -> <index-lookup-one-level(fail |namespace', path', prefix)> x\
-          <+ fatal-err(|"Unexpected result from adjust-index-lookup, should be a list Def(_) or [namespace | path] or StopLookup() to stop the lookup"));
-        ?defs
-      end
+      adjust-lookup;
+      adjusted := <index-do-adjust-lookup(|namespace, path, x, prefix)> x;
+      defs     := <index-get-adjust-lookup-results(adjust-import, get-defs, name-compare|adjusted, prefix)> x
+    <+
+      adjust-import;
+      adjusted := <index-do-adjust-import(|namespace, path)> x;
+      defs     := <index-get-adjust-import-results(adjust-lookup, get-defs, name-compare|adjusted, prefix)> x
     <+
-      defs := <index-get-children(|namespace, prefix)> Def([namespace | path])
+      defs     := <get-defs(name-compare|namespace, prefix)> [namespace | path]
       
-  /**
-   * Given an annotated AST node, resolves it, and returns all possibly matching Defs with a common ancestor URI. 
-   *
-   * @param prefix  Only Defs with a name that starts with this string are returned.
-   *
-   * @internal
-   * @type "name"{uri} -> List(Def(uri'))
-   */
-  index-lookup-all-levels(is-adjust-lookup-enabled |namespace, path, prefix):
-    x{_} -> all-defs
+  /** @internal */
+  index-lookup-all-scoped-internal(get-defs, name-compare|namespace, path, prefix) = 
+    index-lookup-all-scoped-internal(id, id, get-defs, name-compare|namespace, path, prefix)
+  
+  /** @internal */
+  index-do-adjust-import(|namespace, path) =
+    adjust-index-import(|namespace, path)
+    
+  /** @internal */
+  index-get-adjust-import-results(adjust-lookup, get-defs, name-compare|adjusted, prefix):
+    x -> defs'
     with
-      is-adjust-lookup-enabled;
-      do-adjust-index-lookup(|namespace, path, x, prefix);
-      if ?StopLookup() then
-        all-defs := []
-      else
-        mapconcat(\d at Def(p) -> [d]\
-            <+ \[namespace' | path'] -> <index-lookup-all-levels(fail |namespace', path', prefix)> x\
-            <+ fatal-err(|"Unexpected result from adjust-index-lookup, should be a list Def(_) or [namespace | path] or StopLookup() to stop the lookup"));
-        ?all-defs
+      defs := 
+        <mapconcat(
+             index-adjust-import-recurse(adjust-lookup, get-defs, name-compare|x, prefix)
+          <+ fatal-err(|"Unexpected result from adjust-index-import, should be a list of [namespace | path].")
+        )> adjusted;
+        if not(<elem> (StopLookup(), defs)) then
+          defs' := <filter(name-compare)> defs
+        else
+          defs' := StopLookup()
+        end
+        
+  /** @internal */
+  index-adjust-import-recurse(adjust-lookup, get-defs, name-compare|x, prefix):
+    [namespace|path] -> results'
+    with
+      results := <index-lookup-all-scoped-internal(fail, adjust-lookup, get-defs, name-compare|namespace, path, prefix)> x;
+      if not(<is-list> results) then
+        results' := [results]
+      else
+        results' := results
       end
-    <+
-      one-level := <index-get-children(|namespace, prefix)> Def([namespace | path]);
-      if [_ | path'] := path then
-        all-defs := <concat> [one-level, <index-lookup-all-levels(fail |namespace, path', prefix)> x]
+        
+  /** @internal */
+  index-do-adjust-lookup(|namespace, path, use, prefix) =
+    repeat-until(
+      prim("SSL_EXT_get_parent", <id>)
+    , adjust-index-lookup(origin-equal(|use)|namespace, path, prefix) 
+    )
+    
+  /** @internal */  
+  index-get-adjust-lookup-results(adjust-import, get-defs, name-compare|adjusted, prefix):
+    x -> defs'
+    with
+      if StopLookup() := adjusted then
+        defs' := StopLookup()
       else
-        all-defs := one-level
+        defs := 
+          <mapconcat(
+               \d at Def(p) -> [d]\
+            <+ \[namespace'|path'] -> <index-lookup-all-scoped-internal(adjust-import, fail, get-defs, name-compare|namespace', path', prefix)> x\
+            <+ fatal-err(|"Unexpected result from adjust-index-lookup, should be a list of Def(uri) or [namespace | path], or StopLookup() to stop the lookup.")
+          )> adjusted;
+          defs' := <filter(name-compare)> defs
       end
+
+rules // Definition retrieval
+  
+  /**
+   * Gets all definitions from the index with given name, namespace and path.
+   * 
+   * @internal 
+   */   
+  index-get-defs(name-compare|namespace, name):
+    [ns|path] -> <index-get-all> Def([ns, name|path])
+  
+  /**
+   * Gets all definitions from the index with given prefix, namespace, path and name-comparison strategy.
+   * 
+   * @internal 
+   */   
+  index-get-defs-prefix(name-compare|namespace, prefix) = 
+    index-get-children(\uri -> Def(uri)\, name-compare|namespace, prefix)
+      
+rules // Name comparisons
+
+  /**
+   * Compares given element (with an URI) to given name using string equality comparison.
+   * 
+   * @internal 
+   */     
+  index-compare-name-equal(|name):
+    element -> <id>
+    where
+      uri := <index-uri> element;
+      <SRTS-EXT-eq-ignore-annos(|name)> <index-uri-name> uri
+  
+  /**
+   * Compares given element (with an URI) to given prefix using substring comparison.
+   * 
+   * @internal 
+   */     
+  index-compare-name-substring(|prefix):
+    element -> <id>
+    where
+      uri := <index-uri> element;
+      <is-substring(!prefix)> <index-uri-name> uri
+      
+  /**
+   * Compares given element (with an URI) to given prefix using substring comparison and given namespace.
+   * 
+   * @internal 
+   */      
+  index-compare-name-substring(|prefix, namespace):
+    element -> <id>
+    where
+      uri := <index-uri> element;
+      <eq> (namespace, <index-uri-namespace> uri);
+      <is-substring(!prefix)> <index-uri-name> uri
       
-/** @internal */
 rules // URI and value projections
        
   /** @internal */
@@ -581,8 +709,7 @@
   /** @internal */
   index-value-impl:
     ReadWildcard(_, value) -> value
-       
-/** @internal */
+    
 rules // Internal helpers
 
   /**
@@ -614,21 +741,9 @@
   fake-file = 
     is-test-file <+ index-is-fake-file
   
-  /** @internal */    
-  index-filepair-to-file = 
-    Fst; string-replace(|$[[<project-path>]/], "")
-  
   /** @internal */
   ast-uri-to-ast-file(|full-path):
     (ast, uri) -> (ast, (full-path, uri))
-  
-  /** @internal */     
-  index-is-name-substring(|name):
-    template -> <id>
-    with
-      [_, uri-name | _] := <index-uri>
-    where
-      <is-substring(!name)> uri-name
    
   /** @internal */    
   index-readwildcard-substring(|prefix):
@@ -643,9 +758,9 @@
         if 1 := <length> children then
           // HACK: This solves the problem of ReadWildcards making too many files re-analyze, but this should
           // be handled in the index primitives instead.
-          <iset-add(|Read([namespace | path]))> set
+          <iset-add(|Read([namespace, prefix|path]))> set
         else
-          <iset-add(|ReadWildcard([namespace | path], prefix))> set
+          <iset-add(|ReadWildcard([namespace|path], prefix))> set
         end
       end
   
@@ -668,35 +783,6 @@
     ?Read(_) <+ ?ReadWildcard(_, _) <+ ?Use(_)
  
   /** @internal */
-  do-adjust-index-lookup(|namespace, path, use, prefix) =
-    repeat-until(
-      prim("SSL_EXT_get_parent", <id>)
-    , adjust-index-lookup(origin-equal(|use) |namespace, path, prefix) 
-    )
- 
-  /** @internal */
-  index-select(|namespace, path, use) =
-    getfirst(
-      where(
-        ?Def([_, <SRTS-EXT-eq-ignore-annos(|use)> | _])
-      )
-    )
- 
-  /** @internal */
-  index-select-all(|namespace, path, use) =
-    filter(
-      where(
-        ?Def([_, <SRTS-EXT-eq-ignore-annos(|use)> | _])
-      )
-    )
- 
-  /** @internal */
-  do-adjusted-index-path(|namespace, path, def) =
-    adjust-index-path(origin-equal(|def) |namespace, path)
-  <+
-    ![def | path]
- 
-  /** @internal */
   index-eq(|namespace, expected) =
     where(
       ?Def([_, name | _]);
@@ -710,22 +796,53 @@
   index-key-unwrap = 
     \key{uri} -> key{<index-uri-unwrap> uri}\ <+ id
     
-/** @internal */
 rules // Interface for generated code
  
   /** @internal */
-  nam-get-def(|namespace):
-    x -> Def([namespace, x | <IndexPath <+ ![]> namespace])
+  nam-get-def(|paths, namespace):
+    part* -> Def([namespace, part* | <lookup-index-path> (namespace, paths)])
+  
+  /** @internal */ 
+  nam-annotate-def(|path):
+    t -> result
+    with
+      result := t{path}
+  
+  /** @internal */ 
+  nam-annotate-use(|paths, namespace):
+    t -> t{[Unresolved(namespace), t | <lookup-index-path> (namespace, paths)]}
   
   /** @internal */ 
-  nam-annotate-use(|namespace):
-    t -> t{[Unresolved(namespace), t | <IndexPath <+ ![]> namespace]}
+  nam-annotate-use(|paths, namespace, namespace2, name):
+    t -> t{[Unresolved(namespace), t | <lookup-index-path> (namespace, paths)]}
+    
+  /** @internal */ 
+  nam-annotate-scope(|path):
+    t -> t{Scope(path)}
   
   /** @internal */ 
   nam-get-scope-types = fail
+  /** @internal */ 
+  nam-ordered-def = fail
+  /** @internal */
+  nam-get-definitions = fail
+  /** @internal */
+  nam-get-definition = nam-get-definitions ; Hd 
+  /** @internal */
+  nam-get-definition-keys = fail
+  /** @internal */
+  nam-get-definition-key = nam-get-definition-keys ; Hd
+  /** @internal */
+  nam-get-uses = fail
+  /** @internal */
+  nam-get-use = nam-get-uses ; Hd 
+  /** @internal */
+  nam-get-uses-keys = fail
+  /** @internal */
+  nam-get-use-key = nam-get-uses-keys ; Hd
   /** @internal */
-  nam-get-definition = fail
+  nam-annotate-names(|paths, def-path) = fail
   /** @internal */
-  nam-get-definition-key = fail
+  nam-annotate-scopes(|def-path) = fail
   /** @internal */
-  nam-annotate-names(|def-path) = fail
+  nam-unique = fail

Modified: spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.template/lib/analysis-library.generated.str
==============================================================================
--- spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.template/lib/analysis-library.generated.str	Thu Apr 18 09:40:59 2013	(r26054)
+++ spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.template/lib/analysis-library.generated.str	Thu Apr 18 09:47:42 2013	(r26055)
@@ -70,6 +70,11 @@
    */
   adjust-index-lookup(check-target-name|namespace, path, prefix) = fail
   
+  /**
+   * Extension point.
+   */
+  adjust-index-import(|namespace, path) = fail
+  
   /** 
    * Extension point. Override this rule to store data about definitions in the index. Should call <store-results> on 
    * a (list of) data that must be stored in the index.
@@ -183,12 +188,15 @@
           <analyze-top-internal(|phase, language, project-path, full-path)> astsFilePairs
       else
         Results(asts, _, _, _, _, _, filesToAnalyze) := 
-          <analyze-top-internal(|phase, language, project-path, full-path)> [(ast, full-path)];
-        ast' := <Hd> asts
+          <analyze-top-internal(|phase, language, project-path, full-path)> [(ast, (full-path, []))];
+        ast' := <Hd> asts // Always returns a list of 1 AST if there is no splitter, so take the head.
       end
   
 rules // Parallel analysis
   
+  index-parallel-analyze-files(analyze) = index-analyze-files(index-parallel-analyze(analyze))
+  index-sequential-analyze-files(analyze) = index-analyze-files(index-sequential-analyze(analyze))
+  
   /**
    * Does a parallel analysis of given files using the specified analysis strategy. Automatically does parallel
    * analysis of dependent files that have changed during the analysis.
@@ -201,64 +209,97 @@
    *                a (ast', errors, warnings, notes, filesToAnalyze) tuple as output.
    * @type List((file, subfile) or file) -> None()
    */
-  index-parallel-analyze-files(analyze):
+  index-analyze-files(internal-analyze):
     files -> None()
     with
       length; 
       set-total-work-units
     with
-      index-parallel-analyze(analyze);
+      internal-analyze;
       filter(not(?ParallelResults((), (), _, _, _, _) <+ ?ParallelResults((), [()], _, _, _, _)); index-set-markers)
+      
+rules // Splitter
+  
+  /**
+   * Merges a top level definition back into an AST using splitter rules.
+   *
+   * @param toplevel  The top level definition to merge back into the given AST.
+   * @type ast -> ast'
+   */
+  index-merge-ast(|toplevel):
+    term -> merged
+    with
+      if <is-list> term then
+        [first-ast|_] := term;
+        merged        := <index-merge-ast(|toplevel)> first-ast
+      else
+        if <index-is-qualifier> term then
+          [elem|_]    := <index-qualifier-subelements> term;
+          merged      := <index-create-qualifier(|term)> <index-merge-ast(|toplevel)> elem
+        else
+          merged      := toplevel
+        end
+      end
  
 rules // Query primitives
  
   /**
-   * Gets all DefData entries that match the kind of data and URI in given definition.
+   * Gets a DefData entry that matches the kind of data and given URI, or fail.
    *
    * Example:
    *   <index-get-data(|Type())> Def([Entity(), "Bar"]) => [DefData([Entity(), "Bar"], Type(), TYPE("Bar")), ...]
    *
    * @param kind Only data of this kind is returned.
-   * @type Def(uri) -> List(DefData(uri, kind, value))
+   * @type Def(uri) or "name"{uri} or [namespace|path] -> List(DefData(uri, kind, value))
    */
   index-get-data(|kind):
-    <with(?Def(uri) | "Def expected")> -> <index-get-value> DefData(uri, kind, ())
+    <with(uri := <index-uri> | "Def, key or URI expected")> -> <index-get-value> DefData(uri, kind, ())
       
   /**
-   * Gets all data entries that match the kind of data and URI in given definition.
+   * Gets all DefData entries that match the kind of data and given URI
    *
    * Example:
    *   <index-get-data-all(|Type())> Def([Entity(), "Bar"]) => [TYPE("Bar"), ...]
    *
    * @param kind Only data of this kind is returned.
-   * @type Def(uri) -> List(value)
+   * @type Def(uri) or "name"{uri} or [namespace|path] -> List(value)
    */
   index-get-data-all(|kind):
-    <with(?Def(uri) | "Def expected")> -> <index-get-all-values> DefData(uri, kind, ())
+     <with(uri := <index-uri> | "Def, key or URI expected")> -> <index-get-all-values> DefData(uri, kind, ())
+
+  /**
+   * Gets a Use entry that matches given URI, or fail.
+   *
+   * Example:
+   *   <index-get-uses-all> Def([Entity(), "M", "Bar"]) => [Use([Entity(), "M", "Bar"]), ...]
+   *
+   * @type Def(uri) or "name"{uri} or [namespace|path] -> List(Use(uri))
+   */
+  index-get-use:
+    <with(uri := <index-uri> | "Def, key or URI expected")> -> <index-get-all> Use(uri)
      
   /**
-   * Gets all Use entries that match the URI in given definition.
+   * Gets all Use entries that match the given URI.
    *
    * Example:
    *   <index-get-uses-all> Def([Entity(), "M", "Bar"]) => [Use([Entity(), "M", "Bar"]), ...]
    *
-   * @type Def(uri) -> List(Use(uri))
+   * @type Def(uri) or "name"{uri} or [namespace|path] -> List(Use(uri))
    */
   index-get-uses-all:
-    <with(?Def(uri) | "Def expected")> -> <index-get-all> Use(uri)
+    <with(uri := <index-uri> | "Def, key or URI expected")> -> <index-get-all> Use(uri)
      
   /**
-   * Gets all Read or ReadWildcard entries that match the given template.
+   * Gets all Read and ReadWildcard entries that match the given URI.
    *
    * Example:
    *   <index-get-reads-all> [Property(), "Bar", "p"] => [Read([Property(), "Bar", "p"]), ...]
    *
-   * @type Def(uri) -> List(Read(uri) or ReadWildcard(uri, prefix))
+   * @type Def(uri) or "name"{uri} or [namespace|path] -> List(Read(uri) or ReadWildcard(uri, prefix))
    */
   index-get-reads-all:
-    template -> <conc> (reads, readwildcards')
+    <with(uri := <index-uri> | "Def, key or URI expected")> -> <conc> (reads, readwildcards')
     where
-      uri   := <index-uri> template;
       reads := <index-get-all> Read(uri);
       if !uri => [namespace, prefix | path-parent] then
         readwildcards  := <index-get-all> ReadWildcard([namespace | path-parent], ());
@@ -278,10 +319,10 @@
   index-get-all:
     template -> <indexlib-get-all> template
       with
-       if set := <Index-ReadSet> then
-         uri := <index-uri>;
-         <iset-add(|Read(uri))> set
-       end
+        if set := <Index-ReadSet> then
+          uri := <index-uri>;
+          <iset-add(|Read(uri))> set
+        end
        
   /**
    * Get all values of index entries that match the given template.
@@ -333,18 +374,19 @@
    * @type Def(uri) or "name"{uri} or uri@[namespace|path] -> List(Def(uri))
    */
   index-get-children(|namespace) = 
-    index-get-children(\uri -> Def(uri)\|namespace)
+    index-get-children(\uri -> Def(uri)\, id|namespace)
   
   /**
    * Gets all children elements of an URI in a certain namespace using custom templates.
    * URI can be contained in a Def(uri), key (term{uri} element) or the uri itself.
    *
    * @param construct-template  uri -> template. Should create a template to match index entries with, given an URI.
+   * @param name-compare        element -> ?element. Strategy for filtering children elements.
    * @param namespace           Only child elements in this namespace are returned.
    * @type Def(uri) or "name"{uri} or uri@[namespace|path] -> List(Def(uri))
    */
-  index-get-children(construct-template|namespace):
-    <with(?Def([parent-ns | path]) <+ ?_{[parent-ns | path]} <+ ?[parent-ns | path] | "Def, key or uri expected")> -> children
+  index-get-children(construct-template, name-compare|namespace):
+    <with([parent-ns | path] := <index-uri> | "Def, key or URI expected")> -> children
     with
       template  := <construct-template> [namespace | path];
       children  := <prim("LANG_index_get_children", template)>;
@@ -361,10 +403,10 @@
    *
    * @param namespace Only child Def elements in this namespace are returned.
    * @param prefix    Only child Def elements where the name starts with this prefix are returned.
-   * @type Def(uri) or "name"{uri} or uri@[namespace|path] -> List(Def(uri))
+   * @type Def(uri) or "name"{uri} or [namespace|path] -> List(Def(uri))
    */
   index-get-children(|namespace, prefix) = 
-    index-get-children(\uri -> Def(uri)\|namespace, prefix)
+    index-get-children(\uri -> Def(uri)\, index-compare-name-substring(|prefix, namespace)|namespace, prefix)
   
   /**
    * Gets all children elements of an URI in a certain namespace where the name starts with a prefix
@@ -372,18 +414,18 @@
    * URI can be contained in a Def(uri), key (term{uri} element) or the uri itself.
    *
    * @param construct-template  uri -> template. Should create a template to match index entries with, given an URI.
+   * @param name-compare        element -> ?element. Strategy for filtering children elements.
    * @param namespace           Only child elements in this namespace are returned.
    * @param prefix              Only child elements where the name starts with this prefix are returned.
-   * @type Def(uri) or "name"{uri} or uri@[namespace|path] -> List(Def(uri))
+   * @type Def(uri) or "name"{uri} or [namespace|path] -> List(Def(uri))
    */
-  index-get-children(construct-template|namespace, prefix):
-    <with(?Def([parent-ns | path]) <+ ?_{[parent-ns | path]} <+ ?[parent-ns | path] | "Def, key or uri expected")> -> children'
+  index-get-children(construct-template, name-compare|namespace, prefix):
+    <with([parent-ns | path] := <index-uri> | "Def, key or URI expected")> -> children'
     with
-      prefix'   := <strip-annos> prefix;
       template  := <construct-template> [namespace | path];
       children  := <prim("LANG_index_get_children", template)>;
-      children' := <filter(index-is-name-substring(|prefix'))> children;
-      <store-wildcard-read(|namespace, path, prefix')> children'
+      children' := <filter(name-compare)> children;
+      <store-wildcard-read(|namespace, path, prefix)> children'
 
   /**
    * Gets a set of all files that have a reference to the given index entries.
@@ -420,67 +462,103 @@
 rules // Index lookup rules (that take into account adjust-index-lookup)
  
   /**
-   * Given an annotated AST node, resolves it, returning its Def.
+   * Given an annotated AST node, resolves it, returning its definition.
+   * Uses precise matching for names.
    *
    * @type "name"{uri} -> ?Def(uri')
    */
   index-lookup:
-    x{[namespace|path]} -> <index-lookup(id|<index-namespace-unwrap> namespace, path, <strip-annos> x)>
+    x{[namespace|path]} -> <index-lookup-internal(index-get-defs, index-compare-name-equal(|name)|ns, path, name)> x
+    where
+      ns := <index-namespace-unwrap> namespace;
+      name := <strip-annos> x
  
   /**
-   * Given an annotated AST node, resolves it, returning all its Defs.
+   * Given an annotated AST node, resolves it, returning all its definitions.
+   * Uses precise matching for names.
    * 
    * @type "name"{uri} -> List(Def(uri'))
    */
   index-lookup-all:
-    x{[namespace|path]} -> <index-lookup-all(id|<index-namespace-unwrap> namespace, path, <strip-annos> x)>
+    x{[namespace|path]} -> <index-lookup-all-internal(index-get-defs, index-compare-name-equal(|name)|ns, path, name)> x
+    where
+      ns := <index-namespace-unwrap> namespace;
+      name := <strip-annos> x
  
   /**
-   * Given an annotated AST node, returns the outermost Def with a corresponding URI.
+   * Given an annotated AST node and a prefix, looks for all definitions with given prefix starting at the scope of 
+   * the given node.
+   * Uses substring matching for names.
    *
-   * @param prefix  Only Defs with a name that starts with this string are returned.
-   * @type "name"{uri} -> ?Def(uri')
+   * @param prefix    Only definitions with a name that starts with this string are returned.
+   * @type "name"{uri} -> List(Def(uri'))
    */
-  index-lookup-outermost(|prefix):
-    x{[namespace|path]} -> <index-lookup-outermost(id|<index-namespace-unwrap> namespace, path, prefix)>
- 
+  index-lookup-all(|prefix):
+    x{[namespace|path]} -> <index-lookup-all-internal(index-get-defs-prefix, index-compare-name-substring(|prefix)|ns, path, prefix)> x
+    where
+      ns := <index-namespace-unwrap> namespace
+      
   /**
-   * Given an annotated AST node, returns Defs that have the same parent URI.
+   * Given an annotated AST node, resolves it in only the parent scope of the given node, returning all its definitions.
+   * Uses precise matching for names.
    *
-   * @param prefix  Only Defs with a name that starts with this string are returned.
    * @type "name"{uri} -> List(Def(uri'))
    */
-  index-lookup-one-level(|prefix):
-    x{[namespace|path]} -> <index-lookup-one-level(id|<index-namespace-unwrap> namespace, path, prefix)>
+  index-lookup-all-scoped:
+    x{[namespace|path]} -> <index-lookup-all-scoped-internal(index-get-defs, index-compare-name-equal(|name)|ns, parent-path, name)> x
+    where
+      ns := <index-namespace-unwrap> namespace;
+      name := <strip-annos> x;
+      (<?[_|<id>]> path <+ !path) => parent-path
       
   /**
-   * Given an annotated AST node, resolves it, and returns all possibly matching Defs with a common ancestor URI. 
+   * Given an annotated AST node, resolves it in only the parent scope of the given node, returning all its definitions.
+   * Uses precise matching for names. Imports are not considered.
    *
-   * @param namespace Only Defs with this namespace are returned.
-   * @param prefix    Only Defs with a name that starts with this string are returned.
    * @type "name"{uri} -> List(Def(uri'))
    */
-  index-lookup-all-levels(|prefix):
-    x{[namespace|path]} -> <index-lookup-all-levels(id|<index-namespace-unwrap> namespace, path, prefix)>
- 
+  index-lookup-all-scoped-noimports:
+    x{[namespace|path]} -> <index-lookup-all-scoped-internal(fail, id, index-get-defs, index-compare-name-equal(|name)|ns, parent-path, name)> x
+    where
+      ns := <index-namespace-unwrap> namespace;
+      name := <strip-annos> x;
+      (<?[_|<id>]> path <+ !path) => parent-path
+  
   /**
-   * Given an annotated AST node, resolves it, and returns all child Defs of its definition.
+   * Given an annotated AST node and a prefix, looks for all definitions with given prefix in only the parent scope of 
+   * the given node.
+   * Uses substring matching for names.
    *
-   * @param namespace Only child Defs with this namespace are returned.
-   * @param prefix    Only Defs with a name that starts with this string are returned.
+   * @param prefix    Only definitions with a name that starts with this string are returned.
    * @type "name"{uri} -> List(Def(uri'))
    */
-  index-lookup-children(|namespace, prefix): // TODO: how does this compare w/ index-lookup-one-level?
-    x{[ns | path]} -> defs
-    with
-      if !ns => Unresolved(_) then
-        Def([_ | def-path]) := <index-lookup>;
-        defs := <index-lookup-one-level(id|namespace, def-path, prefix)> x
-      else
-        defs := <index-lookup-one-level(id|<index-namespace-unwrap> namespace, path, prefix)>
-      end
-    <+
-      defs := []
+  index-lookup-all-scoped(|prefix):
+    x{[namespace|path]} -> <index-lookup-all-scoped-internal(index-get-defs-prefix, index-compare-name-substring(|prefix)|ns, parent-path, prefix)> x
+    where
+      ns := <index-namespace-unwrap> namespace;
+      (<?[_|<id>]> path <+ !path) => parent-path
+
+  /**
+   * Given an annotated AST node and a namespace, returns all definitions inside given node with given namespace.
+   * Does not match names, all names are allowed.
+   *
+   * @param namespace Only definitions with this namespace are returned.
+   * @type "name"{uri} -> List(Def(uri'))
+   */
+  index-lookup-children(|namespace) = 
+    index-lookup-children(|namespace, "")
+      
+  /**
+   * Given an annotated AST node, a namespace and prefix, returns all definitions inside given node with given 
+   * namespace and prefix.
+   * Uses substring matching for names.
+   *
+   * @param namespace Only definitions with this namespace are returned.
+   * @param prefix    Only definitions with a name that starts with this string are returned.
+   * @type "name"{uri} -> List(Def(uri'))
+   */    
+  index-lookup-children(|namespace, prefix):
+    x{[_|path]} -> <index-lookup-all-scoped-internal(index-get-defs-prefix, index-compare-name-substring(|prefix, namespace)|namespace, path, prefix)> x
       
 rules // Index utilities
   
@@ -524,21 +602,6 @@
     x{[_|[name|_]]} -> name
     
   /**
-   * Tries to get the name part of the URI for given term or fail if given term does not have an URI or name.
-   *
-   * Example:
-   *   <index-uri-name> Def([Entity(), "Bar", "Baz"]) => "Bar"
-   *   <index-uri-name> Type("Foo") => fail
-   *   <index-uri-name> Read([Entity()]) => fail
-   *
-   * @type x -> name
-   */   
-  index-uri-name:
-    x -> <index-uri-name> <index-uri> x
-    where
-      not(<has-annos> x)
-    
-  /**
    * Determines if a given AST node is a definition site, according to the syntax.
    *
    * FIXME: Also succeeds on use sites.
@@ -562,3 +625,13 @@
     (k1, k2) -> <id>
     where
       <eq> (<index-key-unwrap> k1, <index-key-unwrap> k2)
+      
+  /**
+   * Given a list of file pairs, returns the list of real files.
+   *
+   * @type List((file, subfile)) -> List(file)
+   */    
+  index-filepairs-to-files:
+    filePairs -> files
+    with
+      files := <make-set> <map(Fst; string-replace(|<conc-strings> (<project-path>, "/"), ""))> filePairs

Modified: spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.template/lib/compilation-library.generated.str
==============================================================================
--- spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.template/lib/compilation-library.generated.str	Thu Apr 18 09:40:59 2013	(r26054)
+++ spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.template/lib/compilation-library.generated.str	Thu Apr 18 09:47:42 2013	(r26055)
@@ -42,6 +42,16 @@
    * @type ast -> None()
    */
   index-compile-ast(|file, subfile) = fail
+
+  /**
+   * Extension point. 
+   */
+  index-is-partial-ast = fail
+
+  /**
+   * Extension point. 
+   */
+  index-combine-asts = fail
   
 rules // Compilation
   
@@ -67,21 +77,48 @@
       diffs         := <analyze-get-compilediffs>;
       files         := <map(index-compilation-restore-read-file)> diffs;
       filteredFiles := <make-set> <remove-all(index-compilation-filter-file)> files;
+      (completeFiles, partialFiles) := <index-split-partial-files> filteredFiles;
       
       // Clean compile time reads
-      <filter(index-compilation-clean-reads)> filteredFiles;
+      <filter(index-compilation-clean-reads)> completeFiles;
+      <filter(index-compilation-clean-reads)> partialFiles;
       
       // Set total work units to number of files to compile for visual indication
-      <set-total-work-units> <length> filteredFiles;
+      <set-total-work-units> <add> (<length> completeFiles, <length> partialFiles);
       
       // Compile the files
-      <filter(index-compilation-file(|language, project-path); complete-work-unit)> filteredFiles
+      <filter(index-compilation-file(|language); complete-work-unit)> completeFiles;
+      <filter(index-compilation-partial-file(|language); complete-work-unit)> partialFiles
+      
+  /** @internal */    
+  index-split-partial-files:
+    files -> (completeFiles, <make-set> splitFiles)
+    with
+      (completeFiles, splitFiles) := <partition(not(index-file-is-partial), index-file-is-partial)> files
 
   /** @internal */
-  index-compilation-file(|language, project-path):
+  index-compilation-file(|language):
+    (path, subfile) -> None()
+    with
+      asts := <index-get-all-values> AST((language, path), ());
+      <map(index-compilation-ast(|path, subfile))> asts
+      
+  /** @internal */    
+  index-compilation-partial-file(|language):
     (path, subfile) -> None()
     with
-      ast := <index-get-global(|<conc> (<index-file-to-uri> (path, subfile), ["ast"]))>;
+      asts := <index-get-all-values> AST((language, subfile), ());
+      if 1 := <length> asts then
+        ast := <?[<id>|_]> asts
+      else
+        ast := <try(index-combine-asts)> asts
+      end;
+      <index-compilation-ast(|path, subfile)> ast
+      
+  /** @internal */
+  index-compilation-ast(|path, subfile):
+    ast -> None()
+    with
       {| Index-ReadSet:
         readSet := <new-iset>;
         rules(Index-ReadSet: _ -> readSet);
@@ -92,7 +129,7 @@
         // Store compile-time reads.
         reads := <iset-elements> readSet;
         <index-add-all(|<index-compilation-file-tuple> (path, subfile))> reads
-      |}
+      |} 
 
   /** @internal */
   index-compilation-filter-file:
@@ -168,12 +205,22 @@
   index-compilation-restore-read-file:
     (file, subfile) -> (file', subfile)
     where
-      file' := <string-replace(|<index-compilation-read-path>, "")> file
+      if removedPath := <string-replace(|<index-compilation-read-path>, "")> file then
+        file' := removedPath
+      else
+        file' := file
+      end
+
   /** @internal */
   index-compilation-restore-read-file:
-    (file, subfile) -> (file, subfile)
+    file -> file'
     where
-      not(<string-replace(|<index-compilation-read-path>, "")> file)
+      not(<is-tuple> file);
+      if removedPath := <string-replace(|<index-compilation-read-path>, "")> file then
+        file' := removedPath
+      else
+        file' := file
+      end
       
   /** @internal */
   index-compilation-clean-reads = 
@@ -186,3 +233,12 @@
   /** @internal */
   index-compilation-read-path =
     !"/.internal/reads/compile"
+    
+/** @internal */
+rules // Utility
+
+  /** @internal */
+  index-file-is-partial:
+    file -> file
+    where 
+      Snd; index-uri; index-is-partial-ast

Modified: spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.template/lib/editor-common.generated.str
==============================================================================
--- spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.template/lib/editor-common.generated.str	Thu Apr 18 09:40:59 2013	(r26054)
+++ spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.template/lib/editor-common.generated.str	Thu Apr 18 09:47:42 2013	(r26055)
@@ -135,8 +135,13 @@
   origin-strip     = prim("SSL_EXT_origin_strip", <id>)
   origin-equal(|t) = prim("SSL_EXT_origin_equal", <id>, t)
 
+  origin-language-description =
+    prim("SSL_EXT_languagedescription", <id>)
+
   origin-language =
-    prim("SSL_EXT_origin_language", <id>)
+    origin-file; 
+    origin-language-description;
+    Fst
   
   origin-surrounding-comments =
     prim("SSL_EXT_origin_surrounding_comments", "TemplateLang", <id>)
@@ -152,6 +157,13 @@
   origin-track-forced(s) =
     ![<id>]; all(s); ?[<id>]
 
+  origin-relative-path:
+    trm -> rel-path
+    where
+      full-path := <origin-file> trm;
+      len-project-prefix := <project-path; string-length; inc>;
+      rel-path := <string-as-chars(drop(|len-project-prefix))> full-path
+      
 strategies
 
   desugar-position(desugar|ast):

Modified: spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.template/lib/index-library.generated.str
==============================================================================
--- spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.template/lib/index-library.generated.str	Thu Apr 18 09:40:59 2013	(r26054)
+++ spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.template/lib/index-library.generated.str	Thu Apr 18 09:47:42 2013	(r26055)
@@ -145,6 +145,14 @@
    */
   index-clear = 
     prim("LANG_index_clear_all")
+    
+  /**
+   * Clears all elements from the index and re-analyzes all files in the project.
+   *
+   * @type x -> x
+   */
+  index-reload = 
+    prim("LANG_index_reload")
    
   /**
    * Commits index to a file on disk.
@@ -524,6 +532,19 @@
    */ 
   index-uri-name =
     ?[_|[<id>|_]]
+    
+  /**
+   * Gets the parent of given URI or fail if the URI doesn't have a parent.
+   *
+   * Example:
+   *   <index-uri-parent> [Entity(), "Bar", "Baz"] => [Entity(), "Baz"]
+   *   <index-uri-parent> [Entity(), "Baz"] => [Entity()]
+   *   <index-uri-parent> [Entity()] => fail
+   *
+   * @type uri@[namespace|[name|restPath]] -> ?name
+   */     
+  index-uri-parent =
+    ?[ns|[_|<id>]]; ![ns|<id>]
   
   /**
    * Gets the value part for given term. Can be extended by defining a index-value-impl rule. If no index-value-impl 
@@ -575,6 +596,19 @@
     x -> key
     where
       key := <collect-one(?_{_})> x
+
+  /**
+   * Converts a path from an URI to a string.
+   *
+   * Example:
+   *   <index-path-to-string> ["Bar", "Baz"] => "Bar.Baz"
+   *
+   * @type path -> str
+   */
+  index-path-to-string:
+    path -> str
+    with
+      str := <take-until(?Anon(_)); reverse; separate-by(|"."); concat-strings> path
       
   /**
    * Converts a URI to a string.
@@ -587,7 +621,7 @@
   index-uri-to-string:
     [ns|path] -> <concat-strings> [nsStr, "://", pathStr]
     with
-      pathStr := <take-until(?Anon(_)); reverse; separate-by(|"."); concat-strings> path;
+      pathStr := <index-path-to-string> path;
       nsStr := <?<id>#(_)> ns
   
   /**
@@ -666,6 +700,10 @@
       
 /** @internal */
 rules // URI and value projections
+
+  /** @internal */
+  index-uri-impl:
+    [_|_] -> <id>
   
   /** @internal */
   index-uri-impl:

Modified: spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.template/trans/templatelang.str
==============================================================================
--- spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.template/trans/templatelang.str	Thu Apr 18 09:40:59 2013	(r26054)
+++ spoofax-imp/branches/spoofax-imp-release/org.strategoxt.imp.editors.template/trans/templatelang.str	Thu Apr 18 09:47:42 2013	(r26055)
@@ -103,20 +103,20 @@
     )
 
   // Generate completion templates
-  generate-esv =
+  generate-esv(|path) =
     collect-sections;
     template-sections-to-esv;
-    !Module("example", NoImports(), <id>);
+    !Module($[[<base-filename ; remove-extension> path].generated], NoImports(), <id>);
     topdown(try(pp-fix-string-quotes))
 
   generate-esv-abstract =
-    generate-aterm(generate-esv)
+    generate-aterm(generate-esv(|""))
 
   generate-esv-concrete:
     (selected, position, ast, path, project-path) -> (filename, result)
     with
-      filename := <guarantee-extension(|"generated.esv")> path;
-      result   := <generate-esv; pp-descriptor-to-string> selected
+      filename := $[[project-path]/editor/[<guarantee-extension(|"generated.esv"); base-filename> path]];
+      result   := <generate-esv(|path); pp-descriptor-to-string> selected
 
   // Generate SDF
   generate-sdf(|path) =
@@ -137,19 +137,19 @@
       result   := <generate-sdf(|path); pp-sdf-to-string> selected
 
   // Generate pretty printer (BOX-based)
-  generate-box-pp =
+  generate-box-pp(|path) =
     collect-sections;
     template-sections-to-stratego(|"example");
-    !Specification(<id>)
+    !Module($[[<base-filename ; remove-extension> path].pp.generated], <id>)
 
   generate-box-pp-abstract =
-    generate-aterm(generate-box-pp)
+    generate-aterm(generate-box-pp(|""))
 
   generate-box-pp-concrete:
     (selected, position, ast, path, project-path) -> (filename, result)
     with
-      filename := <guarantee-extension(|"generated.str")> path;
-      result   := <generate-box-pp; pp-stratego-string> selected
+      filename := $[[project-path]/trans/[<guarantee-extension(|"pp.generated.str"); base-filename> path]];
+      result   := <generate-box-pp(|path); pp-stratego-string> selected
 
   generate-signature =
     collect-om(?Desugared(_));

From g.h.wachsmuth at tudelft.nl  Thu Apr 18 13:25:23 2013
From: g.h.wachsmuth at tudelft.nl (Guido Wachsmuth)
Date: Thu, 18 Apr 2013 11:25:23 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26056 -
	spoofax-imp/branches/nbl-dev/trans/generation2
Message-ID: <20130418112523.0EF3B7F8005@mx1.tudelft.nl>

Author: GuidoWachsmuth
Date: Thu Apr 18 11:25:22 2013
New Revision: 26056
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26056&sc=1

Log:
generator from cambridge

Added:
   spoofax-imp/branches/nbl-dev/trans/generation2/prop-sites.str
Modified:
   spoofax-imp/branches/nbl-dev/trans/generation2/constraints.str
   spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str
   spoofax-imp/branches/nbl-dev/trans/generation2/main.str
   spoofax-imp/branches/nbl-dev/trans/generation2/rules.str
   spoofax-imp/branches/nbl-dev/trans/generation2/scopes.str
   spoofax-imp/branches/nbl-dev/trans/generation2/sections.str
   spoofax-imp/branches/nbl-dev/trans/generation2/use-sites.str
   spoofax-imp/branches/nbl-dev/trans/generation2/util.str

Modified: spoofax-imp/branches/nbl-dev/trans/generation2/constraints.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation2/constraints.str	Thu Apr 18 09:47:42 2013	(r26055)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/constraints.str	Thu Apr 18 11:25:22 2013	(r26056)
@@ -9,61 +9,71 @@
   
 rules
   
-  constraints-to-str(|repl*, b*, n) =  constraints-to-str(|repl*, b*, 0, n)
-  constraints-to-str(|repl*, b*, i, n):
-  	[] -> (repl*, b*, [], [], n)
+  cdebug(s) = debug(s)
   
-  constraints-to-str(|repl*, b*, i, n):
-  	[c|cs] -> (r2*, b2*, [rule1*, rule2*], [task1*, task2*], k)
+  constraints-to-str(|repl*, b*, i) =  constraints-to-str(|repl*, b*, 0, i)
+  constraints-to-str(|repl*, b*, i, j):
+  	[] -> (repl*, b*, [], [])
+  
+  constraints-to-str(|repl*, b*, i, j):
+  	[c|cs] -> (r2*, b2*, [rule1*, rule2*], [task1*, task2*])
   	where
-    	(r1*, b1*, rule1*, task1*, m) := <constraint-to-str(|repl*, b*, i, n)> c;
-      (r2*, b2*, rule2*, task2*, k) := <constraints-to-str(|r1*, b1*, i, m)> cs
+    	(r1*, b1*, rule1*, task1*) := <constraint-to-str(|repl*, b*, i, j)> c;
+      (r2*, b2*, rule2*, task2*) := <constraints-to-str(|r1*, b1*, i, <inc> j)> cs
   		
-  constraint-to-str(|repl*, b*, i, n):  
-    PropertyConstraint(t1, p, t2) -> ([r1*, repl*], [b1*, b*], rule*, [task, match*], m)
+  constraint-to-str(|repl*, bound*, i, j):  
+    PropertyConstraint(term, kind, prop) -> ([match-repl*, repl*], <union> (bound*, prop-bound*), match-rule*, [task, match-assign*])
+    where
+      <map(cdebug(!"repl: "))> repl*
+    ; <map(cdebug(!"bound: "))>bound*
+    ; <cdebug(!"term: ")> term
+    ; <cdebug(!"kind: ")> kind
+    ; <cdebug(!"prop: ")> prop
     where
-      t1' := <alltd(replace(|repl*))> t1;
       // create new task for property calculation
-      r   := Var($[r[i]_[n]__]);
-      task := PROP_TASK(r, <nabl-to-str> p, t1');
+      result      := <extend-index(|i); result-var> j;
+      task        := PROP_TASK(result, <nabl-to-str> kind, <replace-all(|repl*)> term);
+      prop-bound* := <bound-vars> prop;
+      prev-bound* := <isect> (prop-bound*, bound*);
+      <cdebug(!"task: ")> task;
+      <map(cdebug(!"prop-bound: "))> prop-bound*;
+      <map(cdebug(!"prev-bound: "))> prev-bound*;
       if 
-        Var(v) := t2;
-        <not(elem)> (t2, b*) 
-     then // single unbound variable is replaced with result
-        r1* := [(Var(v), r)];
-        b1*    := [Var(v)];
-        match* := [];
-        rule*  := []
+        Var(_) := prop;
+        []     := prev-bound* 
+      then // single unbound variable is replaced with result
+        cdebug(!"SINGLE ")
+      ; match-repl*   := [(prop, result)]
+      ; match-assign* := []
+      ; match-rule*   := []
       else
-      	var*   := <collect-all(?Var(_))> t2;
-      	bvar*  := <isect> (var*, b*);
-      	bvar'* := <alltd(replace(|repl*))> bvar*;
-      	(r1*, b1*, match*, rule*, m) := <matches-to-str(|t2, r, bvar*, bvar'*, i, <inc> n)> var*
+        cdebug(!"MATCH ")
+      ; k := $[[i]-[j]]
+      ; match-repl*   := <map-with-index(match-replace(|k))> prop-bound*
+      ; match-assign* := <map-with-index(match-task(|k, <replace-all(|repl*)> result, <replace-all(|repl*)> prev-bound*))> match-repl*
+      ; match-rule*   := <map-with-index(match-rule(|k, prop, prev-bound*))> prop-bound*
       end
-  
-   matches-to-str(|term, res, bvar*, bvar'*, i, n):
-     [] -> ([], [], [], [], n)
-   
-   matches-to-str(|term, res, bvar*, bvar'*, i, n):
-     [c|cs] -> ([r, r*], [b, b*], [rule, rule*], [t, t*], m)
-     where
-       (r, b, t, rule)        := <match-to-str(|term, res, bvar*, bvar'*, i, n)> c;
-       (r*, b*, t*, rule*, m) := <matches-to-str(|term, res, bvar*, bvar'*, i, <inc> n)> cs
-       
-   match-to-str(|term, res, bvar*, bvar'*, i, n):
-  	t at Var(v) -> ((t, r), t, rule, task)
-    where
-    	r    := Var($[r[i]_[n]__]);
-    	mn   := NoAnnoList(Str(<newname; double-quote> "match"));
-    	task := MATCH_TASK(r, mn, bvar'*, res);
-    	rule := MATCH_RULE(mn, term, bvar*, Var(v))
+      ; <map(cdebug(!"m-repl: "))> match-repl*
       
+  var-to-match-task: (i, Var(v)) -> <id>
+  
+  match-replace(|i)           : (j, t)      -> (t, <extend-index(|i); result-var> j)
+  match-task(|i, term, bound*): (j, (_, r)) -> MATCH_TASK(r, <extend-index(|i); match-name> j, bound*, term)
+  match-rule(|i, term, bound*): (j, t)      -> MATCH_RULE(<extend-index(|i); match-name> j, term, bound*, t)
+    
+  result-var: i-> Var($[r[i]__])
+  match-name: i -> $["match[i]"]
+  
+  extend-index(|i): j -> $[[i]-[j]]
+
+  nabl-match: ("m", Var(x), [y,z]) -> x
+  
 overlays
     
-  MATCH_RULE(n, lhs, bnd, rhs) = RDefNoArgs("nabl-match", RuleNoCond(TUPLE([n, lhs, LIST(bnd)]), rhs))
+  MATCH_RULE(n, lhs, bnd, rhs) = RDefNoArgs("nabl-match", RuleNoCond(TUPLE([NoAnnoList(Str(n)), lhs, LIST(bnd)]), rhs))
 
   PROP_TASK(v, p, t)     = NEW_TASK(v, TERM("PropCalc", [p, t]))
-  MATCH_TASK(v, n, b, t) = NEW_TASK(v, TERM("Match", [n, LIST(b), t]))
+  MATCH_TASK(v, n, b, t) = NEW_TASK(v, TERM("Match", [NoAnnoList(Str(n)), LIST(b), t]))
   
   NEW_TASK(v, t) = Where(Assign(v, NEW_TASK(t)))
   

Modified: spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str	Thu Apr 18 09:47:42 2013	(r26055)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str	Thu Apr 18 11:25:22 2013	(r26056)
@@ -8,7 +8,7 @@
   generation2/util
   generation2/main
   generation2/scopes
-  generation2/constraints
+  generation2/prop-sites
 
 rules
   
@@ -16,55 +16,66 @@
     
 rules
   
-  clause-to-def-rule(|pattern, scope*):
-    (o, DefClause(kind, unique, ns, term, _, defscope, constr*)) -> ([scope-clause*, def-clause*], impl-var*)
+  implicit-def-vars = filter-with-index(implicit-def-var)
+    
+  implicit-def-var:
+    (i, DefClause(kind, _, _, _, _, _, _)) -> <implicit-def-var(|i)> kind
+  
+  implicit-def-var(|i): Implicit() -> Var($[i[i]__])
+  
+  def-scope(|scope*): Implicit() -> []
+  def-scope(|scope*): Explicit() -> scope*
+  
+  clauses-to-def-rules(|pattern, scope*, implicit*):
+    def-clause* -> result
     where
-      ns-term := <nabl-to-str> ns
-    ; unique-term := <nabl-to-str> unique
-    ; i := <dec> o
-    ; (replacement*, scope-clause*, defscope-term, _) := <scope-to-str(|ns-term, i, 1)> defscope
-    ; scope'* := <?Explicit() < !scope* + ![]> kind
-    ; def-call := DEF_CALL(ns-term, unique-term, defscope-term, scope'*, $[child-uri__[i]], $[sibl-uri__[i]], $[child-uri__[o]], $[sibl-uri__[o]])
-    ; if Explicit() := kind then
-        def-clause* := [<replace-all(|[(term, def-call), replacement*])> pattern]
-      ; impl-var*   := []
-      else
-        impl-var    := Var($[i[i]__])
-      ; def-clause* := [<replace-all(|replacement*)> pattern, Where(Assign(impl-var, App(def-call, term)))]
-      ; impl-var*   := [impl-var]
-      end
-   
-  clause-to-prop-rule(|pattern, glob-replacement*, glob-bound*):
-    (o, DefClause(kind, _, ns, term, prop*, _, constr*)) -> (match-rule*, [loc-task*, call])
+       clause*  := <filter-with-index(clause-to-def-seq(|pattern, scope*)); concat; nonempty> def-clause*
+    ;  m        := <length> def-clause*
+    ;  uri-cvar := <uri-child-var> m
+    ;  uri-svar := <uri-sibl-var> m
+    ;  def-seq  := <to-seq> [ Match(pattern)
+       	                    , clause*
+                            , MATCH(CALL("child-uris__"), uri-cvar)
+                            , MATCH(CALL("sibl-uris__"), uri-svar)
+                            , MATCH(CALL("implicits__"), LIST(implicit*))
+                            ] 
+    ;  result   := [DEF_RULE(def-seq)]
+    <+ result   := []
+ 
+  clause-to-def-seq(|pattern, scope*):
+    (o, DefClause(kind, unique, ns, term, _, scope, constr*)) -> [scope-assign*, def-cong*]
     where
-      ns-term     := <nabl-to-str> ns
-    ; i := <dec> o
-    ; patt-bound* := <collect-all(?Var(_))> term
-    ; (loc-replacement*, loc-bound*, match-rule*, loc-task*, _) := <constraints-to-str(|glob-replacement*, [glob-bound*, patt-bound*], i, 1)> constr*
-    ; prop-call := PROP_CALL(<alltd(replace(|loc-replacement*)); map(prop-to-str)> prop*)
-    ; if Explicit() := kind then
-        call := <replace-all(|[(term, prop-call)])> pattern
+      ns-term       := <nabl-to-str> ns
+    ; scope-assign* := <scope-to-assignments(|ns-term, o)> scope
+    ; scope-term    := <scope-to-term(|o)> scope
+    ; scope-repl*   := <scope-to-replacement(|o) <+ ![]> scope 
+    where
+      unique-term := <nabl-to-str> unique
+    ; i           := <dec> o
+    ; uri-cvar1   := <uri-child-var> i
+    ; uri-cvar2   := <uri-child-var> o
+    ; uri-svar1   := <uri-sibl-var> i
+    ; uri-svar2   := <uri-sibl-var> o
+    ; scope'*     := <def-scope(|scope*)> kind
+    ; def-call    := DEF_CALL(ns-term, unique-term, scope-term, scope'*, uri-cvar1, uri-svar1, uri-cvar2, uri-svar2)
+    ; if impl-var := <implicit-def-var(|o)> kind then
+        if <nonempty> scope-repl* then
+          scope-cong* := [<replace-all-id(|[scope-repl*])> pattern]
+        else
+          scope-cong* := []
+      end
+    ; def-cong* := [scope-cong*, Where(Assign(impl-var, App(def-call, term)))]
       else
-        call := Where(App(prop-call, Var($[i[i]__])))
+        def-cong* := [<replace-all-id(|[scope-repl*, (term, def-call)])> pattern]
       end
-       
-  clause-to-rules(counter|pattern, scope*, glob-replacement*, glob-bound*, glob-task*, n):
-    def-clause* -> [COORD_RULE(Match(pattern)), DEF_RULE(Match(pattern), def-seq), rule*,  PROP_RULE(Match(pattern), prop-seq)]//, prop-rule*]
-    where
-      map-with-index(clause-to-def-rule(|pattern, scope*)); unzip; (concat, concat) => (clause*, implicit*)
-    ; m := <length> def-clause*
-    ; def-seq := <to-seq> [clause*, MATCH(CALL("child-uris__"), Var($[child-uri__[m]])), MATCH(CALL("sibl-uris__"), Var($[sibl-uri__[m]])), MATCH(CALL("implicits__"), LIST(implicit*))] 
-    where
-      map-with-index(clause-to-prop-rule(|pattern, glob-replacement*, glob-bound*)); unzip; (concat, concat) => (rule*, prop-clause*)
-    ; match* := <nonempty < ![Assign(LIST(implicit*), Var("implicits__"))] + ![]> implicit*
-    ; prop-seq := <to-seq> [match*, glob-task*, prop-clause*, Id()]
+    
+rules 
   
-rules
-         
-  prop-to-str: PropertyTerm(p, t) -> PROPERTY(<nabl-to-str> p, t)     
-
-  nabl-to-str: NonUnique() -> TERM("NonUnique")
-  nabl-to-str: Unique()    -> TERM("Unique")
+  uri-var(|kind): 0 -> Var($[uri__])
+  uri-var(|kind): i -> Var($[[kind]-uri[i]__]) where not(?0)
+   
+  uri-child-var = uri-var(|"c")
+  uri-sibl-var  = uri-var(|"s")
   
 overlays
   
@@ -72,7 +83,7 @@
 
 overlays
   	
-	DEF_RULE(match, call) =
+	DEF_RULE(body) =
   SDefT(
     "nabl-def-site"
   , [ DefaultVarDec("child-uris__")
@@ -83,75 +94,24 @@
     , DefaultVarDec("partition__")
     , DefaultVarDec("uniques__")
     , DefaultVarDec("elems__")
-    , DefaultVarDec("child-uri__0")
-    , DefaultVarDec("sibl-uri__0")
+    , DefaultVarDec("uri__")
     , DefaultVarDec("states__")]
-  , Seq(match, call)
+  , body
   )  
 	
   DEF_CALL(ns, u, ds, s, in-child-uris, in-sibl-uris, out-child-uris, out-sibl-uris) = 
   CallT(
     SVar("nabl-def")
-  , [Match(Var(out-child-uris)), Match(Var(out-sibl-uris))]
+  , [Match(out-child-uris), Match(out-sibl-uris)]
   , [ Var("lang__")
     , Var("partition__")
     , Var("uniques__")
     , Var("elems__")
-    , Var(in-child-uris)
-    , Var(in-sibl-uris)
+    , in-child-uris
+    , in-sibl-uris
     , ns, u, ds, LIST(s)]
   )
   
-overlays
-  
-	PROP_RULE(match, call)  =
-  SDefT(
-    "nabl-prop-site"
-  , []
-  , [ DefaultVarDec("lang__")
-    , DefaultVarDec("partition__")
-    , DefaultVarDec("elems__")
-    , DefaultVarDec("tasks__")
-    , DefaultVarDec("states__")
-    , DefaultVarDec("implicits__")
-    ]
-  , Seq(match, call)
-  )
-
-  PROP_CALL(ps) = 
-  CallT(
-    SVar("nabl-props")
-  , []
-  , [ Var("elems__"), LIST(ps)]
-  )
-  
-  PROPERTY(p, v) = TERM("Prop", [p, v])
-
-overlays
-    
-  COORD_RULE(match) =
-  SDefT(
-    "nabl-name-site"
-  , [DefaultVarDec("child-uris__"), DefaultVarDec("sibl-uris__")]
-  , [ DefaultVarDec("lang__")
-    , DefaultVarDec("partition__")
-    , DefaultVarDec("uniques__")
-    , DefaultVarDec("elems__")
-    , DefaultVarDec("tasks__")
-    , DefaultVarDec("uris__")
-    , DefaultVarDec("states__")]
-  , Seq(
-      match
-    , Seq(
-        DEF_SITE_CALL()
-      , Seq (
-          RECURSION()
-        , PROP_SITE_CALL()
-        )
-      )
-    )
-  )
-  
   DEF_SITE_CALL = 
   CallT(
     SVar("nabl-def-site")
@@ -168,33 +128,6 @@
     , Var("states__")
     ]
   ) 
-
-  RECURSION =
-  CallT(
-    SVar("nabl-children")
-  , []
-  , [ Var("lang__")
-    , Var("partition__")
-    , Var("uniques__")
-    , Var("elems__")
-    , Var("tasks__")
-    , Var("child-uris__")]
-  )
-  
-  PROP_SITE_CALL = 
-  CallT(
-    SVar("nabl-prop-site")
-  , []
-  , [ Var("lang__")
-    , Var("partition__")
-    , Var("elems__")
-    , Var("tasks__")
-    , Var("states__")
-    , Var("implicits__")
-    ]
-  ) 
-
-overlays
   
   MATCH(s, v) =
   CALL("match", [s], [v])

Modified: spoofax-imp/branches/nbl-dev/trans/generation2/main.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation2/main.str	Thu Apr 18 09:47:42 2013	(r26055)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/main.str	Thu Apr 18 11:25:22 2013	(r26056)
@@ -15,7 +15,7 @@
       filename   := <guarantee-extension(|"str")> path ;
       str-module := <to-ppable-str; nabl-to-str> ast ;
       // use next line to debug which AST node cannot be handled by the pretty-printer
-      <bottomup(try(not(is-string) ; not(is-list) ; not(pp-stratego-string) ; debug(!"cannot pp ")))> str-module ;
+      // <bottomup(try(not(is-string) ; not(is-list) ; not(pp-stratego-string) ; debug(!"cannot pp ")))> str-module ;
       result     := <pp-stratego-string> str-module
 
 rules // modules

Added: spoofax-imp/branches/nbl-dev/trans/generation2/prop-sites.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/prop-sites.str	Thu Apr 18 11:25:22 2013	(r26056)
@@ -0,0 +1,83 @@
+module generation2/prop-sites
+
+imports
+  
+  libstrc
+  include/NameBindingLanguage
+  
+  generation2/util
+  generation2/main
+  generation2/scopes
+  generation2/constraints
+  generation2/def-sites
+  
+rules
+
+  pdebug(s) = id
+  
+  clauses-to-prop-rules(|pattern, glob-replacement*, glob-bound*, glob-task*, implicit*, i):
+    def-clause* -> result
+    where 
+       (rule*, prop-clause*) := <filter-with-index(clause-to-prop-clauses(|pattern, glob-replacement*, glob-bound*, i)); unzip; (concat, concat)>
+    ;  match*   := <![Assign(LIST(<nonempty>), Var("implicits__"))] <+ ![]> implicit*
+    ;  prop-seq := <to-seq> [match*, glob-task*, prop-clause*]
+    ;  result   := [rule*,  PROP_RULE(Seq(Match(pattern), prop-seq))]
+    <+ result   := []
+    
+  clause-to-prop-clauses(|pattern, glob-replacement*, glob-bound*, i):
+    (o, DefClause(kind, _, ns, term, prop*, _, constr*)) -> (match-rule*, [loc-task*, call])
+    where 
+      <map(pdebug(!"PROP: "))> prop*
+    ; <map(pdebug(!"glob-repl: "))> glob-replacement*
+    ; <map(pdebug(!"glob-bound: "))> glob-bound*
+    ; <map(pdebug(!"constr: "))> constr*
+    where
+      <nonempty> prop*
+    where
+      ns-term     := <nabl-to-str> ns
+    ; patt-bound* := <bound-vars; pdebug(!"bound: ")> term
+    ; (loc-replacement*, loc-bound*, match-rule*, loc-task*) 
+                  := <constraints-to-str(|glob-replacement*, [glob-bound*, patt-bound*], <extend-index(|o)> i, 1)> constr*
+    ; <map(pdebug(!"loc-repl: "))> loc-replacement*
+    ; <map(pdebug(!"loc-bound: "))> loc-bound*
+    ; <map(pdebug(!"loc-task: "))> loc-task*
+    ; prop-call   := PROP_CALL(<replace-all(|loc-replacement*); map(prop-to-str)> prop*)
+    ; <pdebug(!"DONE: ")> prop-call
+    ; if impl-var := <implicit-def-var(|o)> kind then
+        call := Where(App(prop-call, impl-var))
+      else
+        call := <replace-all-id(|[(term, prop-call)])> pattern
+      end
+       
+rules
+         
+  prop-to-str: PropertyTerm(p, t) -> PROPERTY(<nabl-to-str> p, t)     
+
+  nabl-to-str: NonUnique() -> TERM("NonUnique")
+  nabl-to-str: Unique()    -> TERM("Unique")
+  
+overlays
+  
+  PROP_RULE(body)  =
+  SDefT(
+    "nabl-prop-site"
+  , []
+  , [ DefaultVarDec("lang__")
+    , DefaultVarDec("partition__")
+    , DefaultVarDec("elems__")
+    , DefaultVarDec("tasks__")
+    , DefaultVarDec("states__")
+    , DefaultVarDec("implicits__")
+    ]
+  , body
+  )
+
+  PROP_CALL(ps) = 
+  CallT(
+    SVar("nabl-props")
+  , []
+  , [Var("partition__"), Var("elems__"), LIST(ps)]
+  )
+  
+  PROPERTY(p, v) = TERM("Prop", [p, v])
+

Modified: spoofax-imp/branches/nbl-dev/trans/generation2/rules.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation2/rules.str	Thu Apr 18 09:47:42 2013	(r26055)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/rules.str	Thu Apr 18 11:25:22 2013	(r26056)
@@ -8,73 +8,31 @@
   generation2/util
   generation2/constraints
   generation2/def-sites
+  generation2/prop-sites
   generation2/use-sites
   
 rules
   
-  a = 
-    {x: id};
-    id
-    
   nabl-to-str: 
-    BindingRule(pattern, constr*, clause*) -> [nrule*, crule*, rule*]
+    (i, BindingRule(pattern, constr*, clause*)) -> [name-rule*, crule*, def-rule*, prop-rule*]
     where 
-       <filter(def-to-name <+ use-to-name)> clause* => [t];
-       nrule* := [NAME_RULE(pattern, t)]
-    <+ nrule* := []
+       [t]        := <filter(def-to-name <+ use-to-name)> clause*
+    ;  name-rule* := [NAME_RULE(pattern, t)]
+    <+ name-rule* := []
     where
       // collect bound variables
-      bound*   := <collect-all(?Var(_))> pattern
-      // collect names of bound variables
-    ; var*     := <map(?Var(<id>))> bound*
-      // collect horizontal scopes
-    ; scope*   := <filter(?ScopeClause(<id>)); concat; map(nabl-to-str)> clause*
-      // filter def clauses   
-    ; dclause* := <filter(?DefClause(_, _, _, _, _, _, _))> clause* 
-      // filter ref and import clauses
-    ; uclause* := <filter(?ImportClause(<id>))> clause*
+      bound*      := <bound-vars> pattern
+      // collect vertical scopes
+    ; scope*      := <filter(?ScopeClause(<nabl-to-str>)); concat> clause*
+    ; def-clause* := <filter(?DefClause(_, _, _, _, _, _, _))> clause*
     where
       // translate constraints
-      (repl*, bound2*, crule*, ctask*, n) := <constraints-to-str(|[], bound*, 1)> constr*
+      (repl*, bound2*, crule*, task*) := <constraints-to-str(|[], bound*, i, 1)> constr*
       // translate def clauses
-    ; rule*  := <clause-to-rules(?m|pattern, scope*, repl*, bound2*, ctask*, n)> dclause*
-    <+ rule* := []
-    // ; (drule*, c1*, c2*, m) := <clauses-to-str(|pattern, scope*, repl*, bound2*, n)> dclause*
-    //   // translate ref and import clauses
-    // ; (urule*, c3*, c4*, _) := <clauses-to-str(|pattern, scope*, repl*, bound2*, m)> uclause*
-    // where // combine rules
-    //   if 
-    //     <not(fetch-elem(def-to-name))> dclause* // no explicit def
-    //   ; <nonempty> scope*                       // anonymous scope
-    //   then
-    //     dcall1* := [Scope(var*, <to-seq> [Match(pattern), c1*, c3*, ANONYMOUS_CALL(scope*)])]
-    //   else 
-    //     dcall1* := <scope-seq(|var*, pattern)> [c1*, c3*]
-    //   end
-    // ; dcall2* := <scope-seq(|var*, pattern)> ctask*
-    // ; dcall3* := <scope-seq(|var*, pattern)> c4*
-    // ; dcall4* := <scope-seq(|var*, pattern)> c2*
-    // ; if <nonempty> [dcall1*, dcall2*, dcall3*, dcall4*] then
-    //     rule* := [NAME_RULE(<to-seq> [dcall1*, RECURSION(), dcall2*, dcall3*, dcall4*]), drule*]
-    //   else
-    //     rule* := []
-    //   end
-
-  scope-seq(|var*, pattern) = ?[] <+ ![Scope(var*, <to-seq> [Match(pattern)|<id>])]
-
-rules  
-  
-  clauses-to-str(|pattern, scopes, rep1*, b*, n):
-    [] -> ([], [], [], n)
-  
-  clauses-to-str(|pattern, scopes, rep*, b*, n):
-    [e|e*] -> ([r1*, r2*], [sc*, cl*], [a1*, a2*], k)
-    where
-       (r1*, sc*, a1*, m) := <clause-to-str(|pattern, scopes, rep*, b*, n)> e
-    <+ (r1*, sc*, a1*, m) := ([], [], [], n)
-    where
-       (r2*, cl*, a2*, k) := <clauses-to-str(|pattern, scopes, rep*, b*, m)> e*
-       
+    ; implicit*  := <implicit-def-vars> def-clause*
+    ; def-rule*  := <clauses-to-def-rules(|pattern, scope*, implicit*)> def-clause*
+    ; prop-rule* := <clauses-to-prop-rules(|pattern, repl*, bound2*, task*, implicit*, i)> def-clause*
+             
 overlays
 	
 	ANONYMOUS_CALL(scopes) =

Modified: spoofax-imp/branches/nbl-dev/trans/generation2/scopes.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation2/scopes.str	Thu Apr 18 09:47:42 2013	(r26055)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/scopes.str	Thu Apr 18 11:25:22 2013	(r26056)
@@ -8,29 +8,39 @@
   
 rules
   
-  scope-to-str(|ns, n) = scope-to-str(|ns, 0, n)
+  scope-to-term(|i): 
+    Current() -> TERM("Current")
   
-  scope-to-str(|ns, i, n): 
-    Current() -> ([], [], TERM("Current"), n)
-  
-  scope-to-str(|ns, i, n): 
-    DefScopes(ds*) -> (r*, ct*, LIST([ss*, v]), m) 
-    where 
+  scope-to-term(|i): 
+    DefScopes(ds*) -> LIST([ss*, ctx*])
+    where
       if <fetch-elem(?Subsequent())> ds* then
         ss* := [TERM("Subsequent")] 
       else
         ss* := []
       end
     ; if x := <fetch-elem(?Context(<id>))> ds* then 
-        v   := Var($[scope[i]_[n]__])
-      ; ct* := [SCOPE_CALL(v, ns)] 
-      ; m   := <inc> n
-      else 
-        ct* := []
-      ; m   := n
+        ctx* := [<scope-var> i]
+      else
+        ctx* := []
       end
-    ; r*  := <filter(?Context(<id>); !(<id>, SCOPE_CALL(v)))> ds*
-       
+   
+  scope-to-assignments(|ns, i) =
+    if DefScopes(fetch-elem(Context(id))) then
+      ![SCOPE_CALL(<scope-var> i, ns)]
+    else
+      ![]
+    end
+    
+  scope-to-replacement(|i):
+    DefScopes(ds*) -> <filter(context-to-replace(|r))> ds*
+    where
+      r  := SCOPE_CALL(<scope-var> i)
+      
+  context-to-replace(|r): Context(c) -> (c, r)
+  
+  scope-var: i -> Var($[scope[i]__])
+
 overlays
   
   SCOPE_CALL(v) = CallT(SVar("nabl-def-scope"), [], [v])

Modified: spoofax-imp/branches/nbl-dev/trans/generation2/sections.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation2/sections.str	Thu Apr 18 09:47:42 2013	(r26055)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/sections.str	Thu Apr 18 11:25:22 2013	(r26056)
@@ -40,5 +40,5 @@
 rules // binding rules
 
   nabl-to-str:
-    BindingRules(rs) -> Rules(<filter(nabl-to-str); concat; nonempty> rs)
+    BindingRules(rs) -> Rules(<filter-with-index(nabl-to-str); concat; nonempty> rs)
     
\ No newline at end of file

Modified: spoofax-imp/branches/nbl-dev/trans/generation2/use-sites.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation2/use-sites.str	Thu Apr 18 09:47:42 2013	(r26055)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/use-sites.str	Thu Apr 18 11:25:22 2013	(r26056)
@@ -19,26 +19,26 @@
   + ?SingleImport(_, _, <id>, _, _, _, _, _)
   + ?WildcardImport(_, _, Context(_, _, <id>, _, _), _, _)
     
-  clause-to-str(|pattern, scopes, repl*, bound*, n):
-    ImportClause(import*) -> <clauses-to-str(|pattern, scopes, repl*, bound*, n)> import*
-    
-  clause-to-str(|pattern, scopes, repl*, bound*, n):
-    SingleImport(_, ns, t, ps, fsc, alias, isc, constr*) -> (r*, [sc*, dcall], pr*, k)
-    where
-      ns' := <nabl-to-str> ns
-    ; (r*, sc*, isc', m) := <scope-to-str(|ns', n)> isc
-    ; dcall := <replace-all(|r*)> pattern
-    ; b*    := <collect-all(?Var(_))> t
-    ; (r2*, b3*, rule*, pr*, k) := <constraints-to-str(|repl*, [bound*, b*], m)> constr*
-  
-  clause-to-str(|pattern, scopes, repl*, bound*, n):
-    WildcardImport(ns, ps, fsc, isc, constr*) -> (r*, [sc*, dcall], pr*, k)
-    where
-      ns' := <nabl-to-str> ns
-    ; (r*, sc*, isc', m) := <scope-to-str(|ns', n)> isc
-    ; dcall := <replace-all(|r*)> pattern
-    ; (r2*, b3*, rule*, pr*, k) := <constraints-to-str(|repl*, bound*, m)> constr*
-    
+  // clause-to-str(|pattern, scopes, repl*, bound*, n):
+  //   ImportClause(import*) -> <clauses-to-str(|pattern, scopes, repl*, bound*, n)> import*
+  //   
+  // clause-to-str(|pattern, scopes, repl*, bound*, n):
+  //   SingleImport(_, ns, t, ps, fsc, alias, isc, constr*) -> (r*, [sc*, dcall], pr*, k)
+  //   where
+  //     ns' := <nabl-to-str> ns
+  //   ; (r*, sc*, isc', m) := <scope-to-str(|ns', n)> isc
+  //   ; dcall := <replace-all-id(|r*)> pattern
+  //   ; b*    := <collect-all(?Var(_))> t
+  //   ; (r2*, b3*, rule*, pr*, k) := <constraints-to-str(|repl*, [bound*, b*], m)> constr*
+  // 
+  // clause-to-str(|pattern, scopes, repl*, bound*, n):
+  //   WildcardImport(ns, ps, fsc, isc, constr*) -> (r*, [sc*, dcall], pr*, k)
+  //   where
+  //     ns' := <nabl-to-str> ns
+  //   ; (r*, sc*, isc', m) := <scope-to-str(|ns', n)> isc
+  //   ; dcall := <replace-all-id(|r*)> pattern
+  //   ; (r2*, b3*, rule*, pr*, k) := <constraints-to-str(|repl*, bound*, m)> constr*
+  //   
 // rules
 //   
 //   uses-to-str(|replace*, bound*, rule*, task*, pattern) =

Modified: spoofax-imp/branches/nbl-dev/trans/generation2/util.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation2/util.str	Thu Apr 18 09:47:42 2013	(r26055)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/util.str	Thu Apr 18 11:25:22 2013	(r26056)
@@ -6,17 +6,18 @@
   include/NameBindingLanguage
   
 rules
-  
-  to-seq = is-list; foldr(![], to-seq)
-  
-  //to-seq: (c, Seq(c1, c2)) -> Seq(c1, Seq(c2, c)) 
-  to-seq: (c, s) -> Seq(c, s) where not (<?[]> s) 
-  to-seq: (c, []) -> c
+
+  bound-vars = collect-all(?Var(_))  
+ 
+  to-seq: [c]           -> c
+  to-seq: [c1, c2 | c*] -> Seq(c1, <to-seq> [c2|c*])
+
 rules 
   
   nonempty = where(Hd)
 
-  replace-all(|rs) = alltd(replace(|rs) <+ introduce-id)
+  replace-all(|rs)    = alltd(replace(|rs))
+  replace-all-id(|rs) = alltd(replace(|rs) <+ introduce-id)
   
   replace(|rs): t -> <hashtable-get(|t)> rs
   replace(|rs): t -> <lookup'> (t, rs)
@@ -27,6 +28,16 @@
     
   iset-copy = iset-elements => elem*; new-iset ; iset-addlist(|elem*)
   
+  nfilter(s : Int * a -> b | i) = 
+     [] 
+  <+ [s(|i) | nfilter(s | <inc> i)] 
+  <+ Tl; nfilter(s | <inc> i)
+    
+  filter-with-index(s) =
+    let apply(|i) = <s> (i, <id>)
+     in nfilter(apply | 1)
+    end
+
 overlays
   
   CONS_DECL(c, t) = OpDecl(c, ConstType(SortNoArgs(t)))
@@ -37,5 +48,4 @@
   CALL(s)         = CallNoArgs(SVar(s))
   CALL(s, ss, ts) = CallT(SVar(s), ss, ts)
 
-  
   
\ No newline at end of file

From v.vergu+vc at gmail.com  Thu Apr 18 16:51:13 2013
From: v.vergu+vc at gmail.com (Vlad Vergu)
Date: Thu, 18 Apr 2013 14:51:13 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26057 - strategoxt
Message-ID: <20130418145113.DA121108C012@mx3.tudelft.nl>

Author: VladVergu
Date: Thu Apr 18 14:51:01 2013
New Revision: 26057
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26057&sc=1

Log:
Nothing

Modified:
   strategoxt/MOVED

Modified: strategoxt/MOVED
==============================================================================
--- strategoxt/MOVED	Thu Apr 18 11:25:22 2013	(r26056)
+++ strategoxt/MOVED	Thu Apr 18 14:51:01 2013	(r26057)
@@ -1,3 +1,4 @@
 The Stratego/XT project has moved to GitHub at: https://github.com/metaborg/strategoxt.
 
 Please do not commit to this repository anymore.
+

From v.vergu+vc at gmail.com  Thu Apr 18 16:57:23 2013
From: v.vergu+vc at gmail.com (Vlad Vergu)
Date: Thu, 18 Apr 2013 14:57:23 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26058 -
	spoofax-imp/trunk
Message-ID: <20130418145723.5A240CC24C@mx4.tudelft.nl>

Author: VladVergu
Date: Thu Apr 18 14:57:22 2013
New Revision: 26058
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26058&sc=1

Log:
No change

Modified:
   spoofax-imp/trunk/INSTALL

Modified: spoofax-imp/trunk/INSTALL
==============================================================================
--- spoofax-imp/trunk/INSTALL	Thu Apr 18 14:51:01 2013	(r26057)
+++ spoofax-imp/trunk/INSTALL	Thu Apr 18 14:57:22 2013	(r26058)
@@ -1,5 +1,5 @@
 STANDARD INSTALLATION
-
+ 
 Please install Spoofax/IMP from http://www.spoofax.org/.
 
 BUILDING FROM SOURCE

From R.B.Vermaas at tudelft.nl  Fri Apr 19 17:37:37 2013
From: R.B.Vermaas at tudelft.nl (Rob Vermaas)
Date: Fri, 19 Apr 2013 15:37:37 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26059 - hydra
Message-ID: <20130419153738.064062B8036@mx2.tudelft.nl>

Author: rob
Date: Fri Apr 19 15:37:36 2013
New Revision: 26059
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26059&sc=1

Log:
Test commit that should succeed

Modified:
   hydra/job.nix

Modified: hydra/job.nix
==============================================================================
--- hydra/job.nix	Thu Apr 18 14:57:22 2013	(r26058)
+++ hydra/job.nix	Fri Apr 19 15:37:36 2013	(r26059)
@@ -18,4 +18,3 @@
     // extraJobs builder ;
 
 in jobs
-

From R.B.Vermaas at tudelft.nl  Fri Apr 19 17:41:26 2013
From: R.B.Vermaas at tudelft.nl (Rob Vermaas)
Date: Fri, 19 Apr 2013 15:41:26 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26060 - xdoc/trunk
Message-ID: <20130419154126.64F407F806E@mx1.tudelft.nl>

Author: rob
Date: Fri Apr 19 15:41:24 2013
New Revision: 26060
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26060&sc=1

Log:
Test xdoc commit

Modified:
   xdoc/trunk/README

Modified: xdoc/trunk/README
==============================================================================
--- xdoc/trunk/README	Fri Apr 19 15:37:36 2013	(r26059)
+++ xdoc/trunk/README	Fri Apr 19 15:41:24 2013	(r26060)
@@ -41,3 +41,4 @@
   * Simple as hell, results in beautiful colors...
 
 -----------------------------------------------------------------------------
+

From g.h.wachsmuth at tudelft.nl  Tue Apr 23 13:52:25 2013
From: g.h.wachsmuth at tudelft.nl (Guido Wachsmuth)
Date: Tue, 23 Apr 2013 11:52:25 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26061 -
	spoofax-imp/branches/nbl-dev/trans/generation2
Message-ID: <20130423115226.119A12B8021@mx2.tudelft.nl>

Author: GuidoWachsmuth
Date: Tue Apr 23 11:52:24 2013
New Revision: 26061
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26061&sc=1

Log:
improvements with Vlad

Modified:
   spoofax-imp/branches/nbl-dev/trans/generation2/constraints.str
   spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str
   spoofax-imp/branches/nbl-dev/trans/generation2/prop-sites.str
   spoofax-imp/branches/nbl-dev/trans/generation2/rules.str
   spoofax-imp/branches/nbl-dev/trans/generation2/sections.str

Modified: spoofax-imp/branches/nbl-dev/trans/generation2/constraints.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation2/constraints.str	Fri Apr 19 15:41:24 2013	(r26060)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/constraints.str	Tue Apr 23 11:52:24 2013	(r26061)
@@ -9,52 +9,51 @@
   
 rules
   
-  cdebug(s) = debug(s)
-  
-  constraints-to-str(|repl*, b*, i) =  constraints-to-str(|repl*, b*, 0, i)
-  constraints-to-str(|repl*, b*, i, j):
-  	[] -> (repl*, b*, [], [])
-  
-  constraints-to-str(|repl*, b*, i, j):
-  	[c|cs] -> (r2*, b2*, [rule1*, rule2*], [task1*, task2*])
-  	where
-    	(r1*, b1*, rule1*, task1*) := <constraint-to-str(|repl*, b*, i, j)> c;
-      (r2*, b2*, rule2*, task2*) := <constraints-to-str(|r1*, b1*, i, <inc> j)> cs
-  		
-  constraint-to-str(|repl*, bound*, i, j):  
-    PropertyConstraint(term, kind, prop) -> ([match-repl*, repl*], <union> (bound*, prop-bound*), match-rule*, [task, match-assign*])
+  constraints-to-tasks(|bound*, i, j):
+    ([], repl*) -> ([], repl*)
+   	  
+  constraints-to-tasks(|bound*, i, j):
+    ([c at PropertyConstraint(term, kind, prop)|cs], repl*) -> ([task, match-task*, task*], r*)
     where
-      <map(cdebug(!"repl: "))> repl*
-    ; <map(cdebug(!"bound: "))>bound*
-    ; <cdebug(!"term: ")> term
-    ; <cdebug(!"kind: ")> kind
-    ; <cdebug(!"prop: ")> prop
-    where
-      // create new task for property calculation
-      result      := <extend-index(|i); result-var> j;
-      task        := PROP_TASK(result, <nabl-to-str> kind, <replace-all(|repl*)> term);
-      prop-bound* := <bound-vars> prop;
-      prev-bound* := <isect> (prop-bound*, bound*);
-      <cdebug(!"task: ")> task;
-      <map(cdebug(!"prop-bound: "))> prop-bound*;
-      <map(cdebug(!"prev-bound: "))> prev-bound*;
-      if 
-        Var(_) := prop;
-        []     := prev-bound* 
-      then // single unbound variable is replaced with result
-        cdebug(!"SINGLE ")
-      ; match-repl*   := [(prop, result)]
-      ; match-assign* := []
-      ; match-rule*   := []
-      else
-        cdebug(!"MATCH ")
-      ; k := $[[i]-[j]]
-      ; match-repl*   := <map-with-index(match-replace(|k))> prop-bound*
-      ; match-assign* := <map-with-index(match-task(|k, <replace-all(|repl*)> result, <replace-all(|repl*)> prev-bound*))> match-repl*
-      ; match-rule*   := <map-with-index(match-rule(|k, prop, prev-bound*))> prop-bound*
-      end
-      ; <map(cdebug(!"m-repl: "))> match-repl*
+      k           := <extend-index(|i)> j
+    ; result      := <result-var> k
+    ; task        := PROP_TASK(result, <nabl-to-str> kind, <replace-all(|repl*)> term)
+
+    ; bind*       := <bound-vars> prop
+    ; match*      := <isect; replace-all(|repl*)> (bind*, bound*)
+    ; match-repl* := <map-with-index(match-replace(|k))> bind*
       
+    ; match-task* := <
+        if <unbound-var(|bound*)> prop then
+          ![]
+        else
+          <map-with-index(match-task(|k, result, match*))> match-repl*
+        end>
+    ; (task*, r*) := <constraints-to-tasks(|<union> (bound*, bind*), i, <inc> j)> (cs, [match-repl*, repl*])
+            
+  unbound-var(|bound*) =
+  	?Var(v); 
+  	where(
+  		<not(elem)> (Var(v), bound*)
+    )
+  
+  constraints-to-match-rules(|bound*, i, j):
+  	[] -> []
+  
+  constraints-to-match-rules(|bound*, i, j):
+    [c at PropertyConstraint(term, kind, prop)|cs] -> <constraints-to-match-rules(|bound*, i, <inc> j)> cs
+    where 
+    	<unbound-var(|bound*)> prop
+    
+  constraints-to-match-rules(|bound*, i, j):
+  	[c at PropertyConstraint(term, kind, prop)|cs] -> [rule1*, rule2*]
+  	where
+    	k      := <extend-index(|i)> j
+    ; bind*  := <bound-vars> prop
+    ; match* := <isect> (bind*, bound*)
+    ; rule1* := <map-with-index(match-rule(|k, prop, match*))> bind*
+	  ; rule2* := <constraints-to-match-rules(|<union> (bound*, bind*), i, <inc> j)> cs
+
   var-to-match-task: (i, Var(v)) -> <id>
   
   match-replace(|i)           : (j, t)      -> (t, <extend-index(|i); result-var> j)
@@ -69,7 +68,7 @@
   nabl-match: ("m", Var(x), [y,z]) -> x
   
 overlays
-    
+  
   MATCH_RULE(n, lhs, bnd, rhs) = RDefNoArgs("nabl-match", RuleNoCond(TUPLE([NoAnnoList(Str(n)), lhs, LIST(bnd)]), rhs))
 
   PROP_TASK(v, p, t)     = NEW_TASK(v, TERM("PropCalc", [p, t]))

Modified: spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str	Fri Apr 19 15:41:24 2013	(r26060)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str	Tue Apr 23 11:52:24 2013	(r26061)
@@ -8,8 +8,9 @@
   generation2/util
   generation2/main
   generation2/scopes
-  generation2/prop-sites
-
+  generation2/use-sites
+  generation2/sections
+  
 rules
   
   def-to-name = ?DefClause(Explicit(), _, _, <id>, _, _, _)
@@ -43,9 +44,9 @@
     <+ result   := []
  
   clause-to-def-seq(|pattern, scope*):
-    (o, DefClause(kind, unique, ns, term, _, scope, constr*)) -> [scope-assign*, def-cong*]
+    (o, DefClause(kind, unique, ns, term, _, scope, _)) -> [scope-assign*, def-cong*]
     where
-      ns-term       := <nabl-to-str> ns
+      ns-term       := <ns-to-term> ns
     ; scope-assign* := <scope-to-assignments(|ns-term, o)> scope
     ; scope-term    := <scope-to-term(|o)> scope
     ; scope-repl*   := <scope-to-replacement(|o) <+ ![]> scope 
@@ -63,8 +64,8 @@
           scope-cong* := [<replace-all-id(|[scope-repl*])> pattern]
         else
           scope-cong* := []
-      end
-    ; def-cong* := [scope-cong*, Where(Assign(impl-var, App(def-call, term)))]
+        end
+        ; def-cong* := [scope-cong*, Where(Assign(impl-var, App(def-call, term)))]
       else
         def-cong* := [<replace-all-id(|[scope-repl*, (term, def-call)])> pattern]
       end
@@ -112,22 +113,5 @@
     , ns, u, ds, LIST(s)]
   )
   
-  DEF_SITE_CALL = 
-  CallT(
-    SVar("nabl-def-site")
-  , [ Match(Var("child-uris__"))
-    , CALL("sibl-uris__")
-    , Match(Var("implicits__"))
-    ]
-  , [ Var("lang__")
-    , Var("partition__")
-    , Var("uniques__")
-    , Var("elems__")
-    , Var("uris__")
-    , Var("uris__")
-    , Var("states__")
-    ]
-  ) 
-  
   MATCH(s, v) =
   CALL("match", [s], [v])

Modified: spoofax-imp/branches/nbl-dev/trans/generation2/prop-sites.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation2/prop-sites.str	Fri Apr 19 15:41:24 2013	(r26060)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/prop-sites.str	Tue Apr 23 11:52:24 2013	(r26061)
@@ -10,44 +10,36 @@
   generation2/scopes
   generation2/constraints
   generation2/def-sites
+  generation2/sections
   
 rules
 
   pdebug(s) = id
   
-  clauses-to-prop-rules(|pattern, glob-replacement*, glob-bound*, glob-task*, implicit*, i):
+  clauses-to-prop-rules(|pattern, constr*, implicit*, i):
     def-clause* -> result
     where 
-       (rule*, prop-clause*) := <filter-with-index(clause-to-prop-clauses(|pattern, glob-replacement*, glob-bound*, i)); unzip; (concat, concat)>
+       (rule*, prop-clause*) := <filter-with-index(clause-to-prop-clauses(|pattern, constr*, i)); unzip; (concat, concat)>
     ;  match*   := <![Assign(LIST(<nonempty>), Var("implicits__"))] <+ ![]> implicit*
-    ;  prop-seq := <to-seq> [match*, glob-task*, prop-clause*]
+    ;  prop-seq := <to-seq> [match*, prop-clause*]
     ;  result   := [rule*,  PROP_RULE(Seq(Match(pattern), prop-seq))]
     <+ result   := []
     
-  clause-to-prop-clauses(|pattern, glob-replacement*, glob-bound*, i):
-    (o, DefClause(kind, _, ns, term, prop*, _, constr*)) -> (match-rule*, [loc-task*, call])
-    where 
-      <map(pdebug(!"PROP: "))> prop*
-    ; <map(pdebug(!"glob-repl: "))> glob-replacement*
-    ; <map(pdebug(!"glob-bound: "))> glob-bound*
-    ; <map(pdebug(!"constr: "))> constr*
+  clause-to-prop-clauses(|pattern, glob-constr*, i):
+    (o, DefClause(kind, _, ns, term, prop*, _, constr*)) -> (match-rule*, [task*, cong])
     where
       <nonempty> prop*
-    where
-      ns-term     := <nabl-to-str> ns
-    ; patt-bound* := <bound-vars; pdebug(!"bound: ")> term
-    ; (loc-replacement*, loc-bound*, match-rule*, loc-task*) 
-                  := <constraints-to-str(|glob-replacement*, [glob-bound*, patt-bound*], <extend-index(|o)> i, 1)> constr*
-    ; <map(pdebug(!"loc-repl: "))> loc-replacement*
-    ; <map(pdebug(!"loc-bound: "))> loc-bound*
-    ; <map(pdebug(!"loc-task: "))> loc-task*
+    ; ns-term     := <ns-to-term> ns
+    ; patt-bound* := <bound-vars> pattern
+    ; (task*, loc-replacement*) 
+                  := <constraints-to-tasks(|patt-bound*, <extend-index(|o)> i, 1)> ([glob-constr*, constr*], [])
     ; prop-call   := PROP_CALL(<replace-all(|loc-replacement*); map(prop-to-str)> prop*)
-    ; <pdebug(!"DONE: ")> prop-call
     ; if impl-var := <implicit-def-var(|o)> kind then
-        call := Where(App(prop-call, impl-var))
+        cong := Where(App(prop-call, impl-var))
       else
-        call := <replace-all-id(|[(term, prop-call)])> pattern
+        cong := <replace-all-id(|[(term, prop-call)])> pattern
       end
+    ; match-rule* := <constraints-to-match-rules(|patt-bound*, <extend-index(|o)> i, 1)> [glob-constr*, constr*]
        
 rules
          

Modified: spoofax-imp/branches/nbl-dev/trans/generation2/rules.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation2/rules.str	Fri Apr 19 15:41:24 2013	(r26060)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/rules.str	Tue Apr 23 11:52:24 2013	(r26061)
@@ -10,11 +10,12 @@
   generation2/def-sites
   generation2/prop-sites
   generation2/use-sites
+  generation2/sections
   
 rules
   
   nabl-to-str: 
-    (i, BindingRule(pattern, constr*, clause*)) -> [name-rule*, crule*, def-rule*, prop-rule*]
+    (i, BindingRule(pattern, constr*, clause*)) -> [name-rule*, def-rule*, prop-rule*]
     where 
        [t]        := <filter(def-to-name <+ use-to-name)> clause*
     ;  name-rule* := [NAME_RULE(pattern, t)]
@@ -23,15 +24,13 @@
       // collect bound variables
       bound*      := <bound-vars> pattern
       // collect vertical scopes
-    ; scope*      := <filter(?ScopeClause(<nabl-to-str>)); concat> clause*
+    ; scope*      := <filter(?ScopeClause(<map(ns-to-term)>)); concat> clause*
     ; def-clause* := <filter(?DefClause(_, _, _, _, _, _, _))> clause*
     where
-      // translate constraints
-      (repl*, bound2*, crule*, task*) := <constraints-to-str(|[], bound*, i, 1)> constr*
-      // translate def clauses
-    ; implicit*  := <implicit-def-vars> def-clause*
+    // translate def clauses
+      implicit*  := <implicit-def-vars> def-clause*
     ; def-rule*  := <clauses-to-def-rules(|pattern, scope*, implicit*)> def-clause*
-    ; prop-rule* := <clauses-to-prop-rules(|pattern, repl*, bound2*, task*, implicit*, i)> def-clause*
+    ; prop-rule* := <clauses-to-prop-rules(|pattern, constr*, implicit*, i)> def-clause*
              
 overlays
 	

Modified: spoofax-imp/branches/nbl-dev/trans/generation2/sections.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation2/sections.str	Fri Apr 19 15:41:24 2013	(r26060)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/sections.str	Tue Apr 23 11:52:24 2013	(r26061)
@@ -11,14 +11,14 @@
 rules // namespaces 
       
   nabl-to-str:
-    Namespaces(namespaces) -> Signature([Constructors(<map(nabl-to-str)> namespaces)])
+    Namespaces(namespaces) -> Signature([Constructors(<map(ns-to-constructor)> namespaces)])
     
-  nabl-to-str: // generates constructors for namespaces
-    NamespaceDef(ns) -> CONS_DECL(<ns-name-to-str> ns, "Namespace")
+  ns-to-constructor: // generates constructors for namespaces
+    NamespaceDef(ns) -> CONS_DECL(<ns-name> ns, "Namespace")
   
-  nabl-to-str: NamespaceRef(ns) -> TERM(<ns-name-to-str> ns)
+  ns-to-term: NamespaceRef(ns) -> TERM(<ns-name> ns)
 
-  ns-name-to-str: ns -> $[NablNs[ns]]
+  ns-name: ns -> $[NablNs[ns]]
   
 rules // properties
         

From gabrielkonat at gmail.com  Wed Apr 24 14:29:28 2013
From: gabrielkonat at gmail.com (GabriÃ«l Konat)
Date: Wed, 24 Apr 2013 12:29:28 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26062 - hydra/jobs
	spoofax-imp/trunk/org.strategoxt.imp.feature
	spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp
	spoofax-imp/trunk/org.strategoxt.imp.generator/s...
Message-ID: <20130424122928.41AB02B8068@mx2.tudelft.nl>

Author: gkonat
Date: Wed Apr 24 12:29:26 2013
New Revision: 26062
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26062&sc=1

Log:
Add task runtime and task library to Spoofax

Modified:
   hydra/jobs/spoofax-imp.nix
   spoofax-imp/trunk/org.strategoxt.imp.feature/feature.xml
   spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/main.str
   spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-build-xml.str
   spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/main/java/org/spoofax/interpreter/library/ssl/StrategoHashMap.java

Modified: hydra/jobs/spoofax-imp.nix
==============================================================================
--- hydra/jobs/spoofax-imp.nix	Tue Apr 23 11:52:24 2013	(r26061)
+++ hydra/jobs/spoofax-imp.nix	Wed Apr 24 12:29:26 2013	(r26062)
@@ -2,6 +2,7 @@
 , spoofax ? { outPath = ../../spoofax ; rev = 1234; }
 , spoofaxImp ? { outPath = ../../spoofax-imp ; rev = 1234; }
 , lpgRuntime ? { outPath = ../../lpg.runtime.java ; rev = 1234; }
+, metaborgRuntime ? ../../runtime-libraries
 , strategoxtJavaBackend ? ../../strategoxt-java-backend
 , hydraConfig ? { outPath = ../.; rev = 1234; }
 }:
@@ -123,7 +124,8 @@
                  ${spoofaxImp}/org.strategoxt.imp.debug.stratego.runtime \
                  ${spoofaxImp}/org.strategoxt.imp.debug.stratego.test \
                  ${spoofaxImp}/org.strategoxt.imp.debug.stratego.transformer \
-                 ${spoofaxImp}/org.strategoxt.imp.debug.ui
+                 ${spoofaxImp}/org.strategoxt.imp.debug.ui \
+		 ${metaborgRuntime}/org.metaborg.runtime.task
         do
           header "Copying $d"
           cp -R $d .

Modified: spoofax-imp/trunk/org.strategoxt.imp.feature/feature.xml
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.feature/feature.xml	Tue Apr 23 11:52:24 2013	(r26061)
+++ spoofax-imp/trunk/org.strategoxt.imp.feature/feature.xml	Wed Apr 24 12:29:26 2013	(r26062)
@@ -374,6 +374,13 @@
          unpack="false"/>
 
    <plugin
+         id="org.metaborg.runtime.task"
+         download-size="0"
+         install-size="0"
+         version="1.0.0.qualifier"
+         unpack="false"/>
+
+   <plugin
          id="org.spoofax.interpreter.library.xml"
          download-size="0"
          install-size="0"

Modified: spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/main.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/main.str	Tue Apr 23 11:52:24 2013	(r26061)
+++ spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/main.str	Wed Apr 24 12:29:26 2013	(r26062)
@@ -158,6 +158,8 @@
     create-compilation-library;
     create-nbl-library;
     
+    create-all-runtime-libraries;
+    
     create-behavior-preservation;
     create-namebinding-preservation;
     create-correctness-preservation;

Modified: spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-build-xml.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-build-xml.str	Tue Apr 23 11:52:24 2013	(r26061)
+++ spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-build-xml.str	Wed Apr 24 12:29:26 2013	(r26062)
@@ -617,6 +617,7 @@
                 <arg line="${externaljarflags}"/>
                 <arg line="${externaldefimport}"/>
                 <arg line="-I &quot;${lib}&quot; -I &quot;${include}&quot; --cache-dir &quot;${basedir}/.cache&quot;"/>
+                <arg line="-la org.metaborg.runtime.task.interop"/>
             </java>
             <delete file="${include}/${strmodule}.rtree" failonerror="false"/>
             <mkdir dir="${build}/trans"/>

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/main/java/org/spoofax/interpreter/library/ssl/StrategoHashMap.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/main/java/org/spoofax/interpreter/library/ssl/StrategoHashMap.java	Tue Apr 23 11:52:24 2013	(r26061)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.core/src/main/java/org/spoofax/interpreter/library/ssl/StrategoHashMap.java	Wed Apr 24 12:29:26 2013	(r26062)
@@ -33,6 +33,10 @@
         }
     };
 
+    public StrategoHashMap() {
+        super();
+    }
+    
     public StrategoHashMap(int initialSize, int maxLoad) {
         super(initialSize, 1.0f * maxLoad / 100);
     }
@@ -105,6 +109,6 @@
     }
 
     public Iterator<IStrategoTerm> iterator() {
-        return this.iterator();
+        return this.values().iterator();
     }
 }

From gabrielkonat at gmail.com  Wed Apr 24 15:00:46 2013
From: gabrielkonat at gmail.com (GabriÃ«l Konat)
Date: Wed, 24 Apr 2013 13:00:46 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26063 - hydra/jobs
Message-ID: <20130424130046.975122B800B@mx2.tudelft.nl>

Author: gkonat
Date: Wed Apr 24 13:00:45 2013
New Revision: 26063
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26063&sc=1

Log:


Modified:
   hydra/jobs/spoofax-imp.nix

Modified: hydra/jobs/spoofax-imp.nix
==============================================================================
--- hydra/jobs/spoofax-imp.nix	Wed Apr 24 12:29:26 2013	(r26062)
+++ hydra/jobs/spoofax-imp.nix	Wed Apr 24 13:00:45 2013	(r26063)
@@ -2,7 +2,7 @@
 , spoofax ? { outPath = ../../spoofax ; rev = 1234; }
 , spoofaxImp ? { outPath = ../../spoofax-imp ; rev = 1234; }
 , lpgRuntime ? { outPath = ../../lpg.runtime.java ; rev = 1234; }
-, metaborgRuntime ? ../../runtime-libraries
+, metaborgRuntime ? { outPath = ../../runtime-libraries; }
 , strategoxtJavaBackend ? ../../strategoxt-java-backend
 , hydraConfig ? { outPath = ../.; rev = 1234; }
 }:

From gabrielkonat at gmail.com  Wed Apr 24 15:17:32 2013
From: gabrielkonat at gmail.com (GabriÃ«l Konat)
Date: Wed, 24 Apr 2013 13:17:32 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26064 - hydra/jobs
Message-ID: <20130424131732.C5CABCC2F4@mx4.tudelft.nl>

Author: gkonat
Date: Wed Apr 24 13:17:32 2013
New Revision: 26064
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26064&sc=1

Log:


Modified:
   hydra/jobs/spoofax-imp.nix

Modified: hydra/jobs/spoofax-imp.nix
==============================================================================
--- hydra/jobs/spoofax-imp.nix	Wed Apr 24 13:00:45 2013	(r26063)
+++ hydra/jobs/spoofax-imp.nix	Wed Apr 24 13:17:32 2013	(r26064)
@@ -125,7 +125,7 @@
                  ${spoofaxImp}/org.strategoxt.imp.debug.stratego.test \
                  ${spoofaxImp}/org.strategoxt.imp.debug.stratego.transformer \
                  ${spoofaxImp}/org.strategoxt.imp.debug.ui \
-		 ${metaborgRuntime}/org.metaborg.runtime.task
+		 ${metaborgRuntime}/org.metaborg.runtime.task 
         do
           header "Copying $d"
           cp -R $d .

From gabrielkonat at gmail.com  Wed Apr 24 16:07:34 2013
From: gabrielkonat at gmail.com (GabriÃ«l Konat)
Date: Wed, 24 Apr 2013 14:07:34 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26065 -
	spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project
Message-ID: <20130424140734.F3081CC26B@mx4.tudelft.nl>

Author: gkonat
Date: Wed Apr 24 14:07:33 2013
New Revision: 26065
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26065&sc=1

Log:
Added missing create-runtime-libraries.str

Added:
   spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-runtime-libraries.str

Added: spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-runtime-libraries.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/project/create-runtime-libraries.str	Wed Apr 24 14:07:33 2013	(r26065)
@@ -0,0 +1,2228 @@
+module sdf2imp/project/create-runtime-libraries
+
+imports
+  sdf2imp/util/-
+
+strategies
+  
+    create-analysis-core = 
+    <output-text-file(|["lib", "analysis"], "core.str")>
+"module analysis/core
+
+imports
+  
+  nbl/collect
+  nbl/entries
+  nbl/uri
+  nbl/utils
+  index/core
+  task/core
+  
+signature
+
+  constructors
+  
+    File : Path * AST -> File
+    Result : Partition * AST * AST * List(URI) * List(Term) * List(Term) * List(Term) -> Result
+    // Result(partition, initial-ast, analyzed-ast, changed-read*, error*, warning*, note*)
+    
+rules // Analysis
+  
+  analyze-collect(|language, project-path):
+    File(partition, initial-ast) -> Result(partition, initial-ast, analyzed-ast, changed-read*, [], [], [])
+    with
+      measure-time(
+        index-setup(|language, [project-path], partition);
+        index-start-collection(|partition);
+        task-setup(|project-path);
+        task-start-collection(|partition)
+        , id | \"analyze-collect-setup\"
+      ); measure-time(
+        analyzed-ast := <nabl-collect(|partition, Language(language))> initial-ast
+        , id | \"analyze-collect-collect\" 
+      ); measure-time(
+        index-stop-collection => (removed-entry*, added-entry*);
+        task-stop-collection(|partition);
+        changed-read* := <filter(analyze-diff-entry; nabl-uri; try(nabl-replace-uri-qualifier(|())))> [removed-entry*, added-entry*]
+        , id | \"analyze-collect-diff\" 
+      )
+  
+  analyze-perform-all:
+    result* -> (error*, evaluated-count)
+    with
+      measure-time(mapconcat(analyze-result-reads); make-set => changed-read*, id | \"analyze-perform-concat-reads\");
+      measure-time(task-evaluate(|changed-read*) => (error*, evaluated-count), id | \"analyze-perform-evaluate\")
+
+rules // Index entries to diff
+  
+  analyze-diff-entry =
+    ?Def(_)
+    
+  analyze-diff-entry =
+    ?Prop(_, _, _)
+      
+rules // Projections
+  
+  analyze-result-reads:
+    Result(_, _, _, changed-read*, _, _, _) -> changed-read*
+    
+  analyze-result-analyzed-ast:
+    Result(_, _, analyzed-ast, _, _, _, _) -> analyzed-ast
+"
+
+  create-analysis-debug = 
+    <output-text-file(|["lib", "analysis"], "debug.str")>
+"module analysis/debug
+
+imports
+  
+  index/core
+  index/query
+  task/core
+
+rules
+  
+  analysis-debug-show-current-partition(|language):
+    (_, _, _, path, project-path) -> (filename, result)
+    with
+      partition := $[[project-path]/[path]];
+      index-setup(|language, [project-path], partition);
+      filename := <guarantee-extension(|\"index.current.aterm\")> path;
+      result   := <index-get-all-in-partition> partition
+      
+  analysis-debug-show-all-partitions(|language):
+    (_, _, _, path, project-path) -> (filename, result)
+    with
+      partition := $[[project-path]/[path]];
+      index-setup(|language, [project-path], partition);
+      filename := <guarantee-extension(|\"index.all.aterm\")> path;
+      result   := <index-get-all-partitions; map(\\filename -> (filename, <index-get-all-in-partition> filename)\\)>
+      
+  analysis-debug-reset-index(|language):
+    (_, _, _, path, project-path) -> None()
+    with
+      partition := $[[project-path]/[path]];
+      index-setup(|language, [project-path], partition);
+      index-clear
+      
+  analysis-debug-reset-task(|language):
+    (_, _, _, path, project-path) -> None()
+    with
+      task-setup(|project-path);
+      task-reset
+
+  analysis-debug-reanalyze(|language):
+    (_, _, _, path, project-path) -> None()
+    with
+      partition := $[[project-path]/[path]];
+      task-setup(|project-path);
+      task-reset;
+      index-setup(|language, [project-path], partition);
+      index-reload
+
+"
+
+  create-analysis-multiple = 
+    <output-text-file(|["lib", "analysis"], "multiple.str")>
+"module analysis/multiple
+
+imports
+
+  analysis/core
+  task/core
+  nbl/utils
+
+rules // Multi file analysis
+  
+  analyze-multiple(parse-file, parallel, complete-work-unit|language, project-path):
+    path* -> result*
+    with
+      measure-time(
+        file* := <map(analyze-parse-file(parse-file); where(complete-work-unit))> path*
+      , id | \"analyze-multiple-parse\");
+      result* := <analyze-multiple-files(parallel, complete-work-unit|language, project-path)> file*
+
+  analyze-parse-file(parse-file):
+    path -> File(path, ast)
+    with
+      if not(ast := <file-exists; parse-file> path) then
+        ast := ()
+      end
+
+  analyze-multiple-files(parallel, complete-work-unit|language, project-path):
+    file* -> (error*, result*, evaluated-count)
+    with
+      measure-time(
+        result* := <map(analyze-collect(|language, project-path); where(complete-work-unit))> file*
+        , id | \"analyze-multiple-collect\"
+      );
+      measure-time(
+        (error*, evaluated-count) := <analyze-perform-all> result*
+        , id | \"analyze-multiple-perform\"
+      )
+      
+rules // Utility
+
+  nabl-analyze-multiple-work-units = 
+    length; !(<id>, 3); mul
+
+"
+
+  create-analysis-single = 
+    <output-text-file(|["lib", "analysis"], "single.str")>
+"module analysis/single
+
+imports
+  
+  analysis/core
+    
+rules // Single file analysis
+  
+  analyze-one(|language, path, project-path):
+    ast -> (<analyze-result-analyzed-ast> result, error*, evaluated-count)
+    with // Setup index
+      partition                 := $[[project-path]/[path]];
+      result                    := <analyze-collect(|language, project-path)> File(partition, ast);
+      (error*, evaluated-count) := <analyze-perform-all> [result]
+
+"
+
+  create-index-core = 
+    <output-text-file(|["lib", "index"], "core.str")>
+"module index/core
+
+signature
+
+  sorts
+  
+    URI Entry
+  
+rules
+
+  /**
+   * Sets up the index library for given language, project paths and current file.
+   * Must be called once before doing anything with the library.
+   *
+   * Example:
+   *   <index-setup(|\"MiniJava\", [<project-path>], \"test/test.mjv\")
+   *
+   * @param language          The language to set the index up for.
+   * @param project-path      The project paths that contain all source files to analyse and compile.
+   * @param current-partition The current partition that is being analysed. Can be retrieved later using 
+   *                          index-get-current-partition. Can also be changed later using index-set-current-partition.
+   * @type x -> x
+   */
+  index-setup(|language, project-paths, current-partition) =
+    prim(\"LANG_index_setup\", language, project-paths, current-partition)
+    
+  /**
+   * Unloads the currently loaded index.
+   *
+   * Example:
+   *   index-unload(|<project-path>)
+   *
+   * @param project-path The project path that contain all source files to analyse and compile.
+   *
+   * @type x -> x
+   */
+  index-unload(|project-path) =
+    prim(\"LANG_index_unload\", project-path)
+    
+  /**
+   * Sets the current file the index (analysis) is operating on to the given file.
+   *
+   * Example:
+   *   <index-set-current-partition> \"fullpath/file.ext\"
+   *   <index-set-current-partition> (\"fullpath/file.ext\", \"subfile\")
+   *
+   * @type x -> ?x
+   */
+  index-set-current-partition = 
+    prim(\"LANG_index_set_current_file\", <id>)
+
+  index-start-collection(|partition) =
+    prim(\"LANG_index_start_collection\", partition)
+    
+  index-stop-collection =
+    prim(\"LANG_index_stop_collection\")
+
+  /**
+   * Adds given element to the index.
+   *
+   * Example:
+   *   <index-add(|\"fullpath/file.ext\")> Def([Entity(), \"Bar\"])
+   *   <index-add(|(\"fullpath/file.ext\", \"subfile\"))> Def([Entity(), \"Bar\"])
+   *
+   * @param partition The partition to add the element to.
+   * @type x -> ?x
+   */
+  index-add(|partition) =
+    prim(\"LANG_index_add\", <id>, partition)
+
+  /**
+   * Adds all given elements to the index.
+   *
+   * Example:
+   *   <index-add-all(|\"fullpath/file.ext\")> [Def([Entity(), \"Bar\"]), ...]
+   *   <index-add-all(|(\"fullpath/file.ext\", \"subfile\"))> [Def([Entity(), \"Bar\"]), ...]
+   *
+   * @param partition The partition to add the elements to.
+   * @type List(x) -> ?List(x)
+   */
+  index-add-all(|partition) =
+    list-loop(with(index-add(|partition)))
+    
+  /**
+   * Removes given entry from the index that is contained in given partition.
+   *
+   * Example:
+   *   <index-remove(|\"fullpath/file.ext\")> Def([Entity(), \"Bar\"])
+   *   <index-remove(|(\"fullpath/file.ext\", \"subfile\"))> Def([Entity(), \"Bar\"])
+   * 
+   * @param partition The partition to remove the element from.
+   * @type x -> ?x
+   */
+  index-remove(|partition) =
+    prim(\"LANG_index_remove\", <id>, partition)
+    
+  /**
+   * Removes entries with given template from the index (from all partitions).
+   *
+   * Example:
+   *   <index-remove-all> Def([Entity(), \"Bar\"])
+   * 
+   * @param partition The partition to remove the element from.
+   * @type x -> ?x
+   */
+  index-remove-all =
+    prim(\"LANG_index_remove_all\", <id>)
+    
+  /**
+   * Removes given entry from the index (from all partitions).
+   *
+   * Example:
+   *   <index-remove-all> DefData([Entity(), \"Bar\"], Type(), Type(\"Bar\"))
+   * 
+   * @param partition The partition to remove the element from.
+   * @type x -> ?x
+   */
+  index-remove-one =
+    prim(\"LANG_index_remove_one\", <id>)
+    
+  /**
+   * Removes all elements from the index that are contained in given partition.
+   *
+   * Example:
+   *   <index-clear-partition> \"fullpath/file.ext\"
+   *   <index-clear-partition> (\"fullpath/file.ext\", \"subfile\")
+   *
+   * @type x -> ?x
+   */
+  index-clear-partition = 
+    prim(\"LANG_index_clear_file\", <id>)
+    
+  /**
+   * Removes all elements from the index.
+   *
+   * @type x -> x
+   */
+  index-clear = 
+    prim(\"LANG_index_clear_all\")
+    
+  /**
+   * Removes all elements from the index and re-analyzes all partitions in the project.
+   *
+   * @type x -> x
+   */
+  index-reload = 
+    prim(\"LANG_index_reload\")
+   
+  /**
+   * Serializes index to a cache on disk.
+   *
+   * @type x -> x
+   */
+  index-commit = 
+    prim(\"LANG_index_commit\")
+
+  /**
+   * Starts a transaction on the index for the current partition. Additions to the index are not visible to other files 
+   * until index-end-transaction is called. Operations on the index are only thread safe during a transaction.
+   *
+   * @type x -> x
+   */
+  index-start-transaction = 
+    prim(\"LANG_index_start_transaction\")
+  
+  /**
+   * Ends a transaction on the index for the current partition. Additions made to the index during the transaction are
+   * added to the global index visible for other files. Operations on the index are not thread safe any more after 
+   * this call.
+   *
+   * @type x -> x
+   */
+  index-end-transaction = 
+    prim(\"LANG_index_end_transaction\")
+  
+  /**
+   * Starts a transaction, applies given strategy and ends the transaction. All index operations used from the given
+   * strategy are thread safe.
+   * 
+   * @param s The strategy to apply. Transaction will still properly end if strategy fails.
+   * @type x -> x'
+   *
+   * @see index-start-transaction
+   * @see index-end-transaction
+   */
+  index-transaction(s) = 
+      prim(\"LANG_index_start_transaction\")
+    ; try(s)
+    ; prim(\"LANG_index_end_transaction\")
+
+"
+
+  create-index-globals = 
+    <output-text-file(|["lib", "index"], "globals.str")>
+"module index/globals
+
+imports
+
+  index/core
+  index/query
+  
+signature 
+
+  constructors
+    
+    Global : URI               -> Entry
+    Global : URI * List(Entry) -> Entry
+    
+rules
+    
+  /**
+   * Gets the 'fake' path where globals are stored in the index.
+   *
+   * @internal
+   */
+  index-globals-path = 
+    !\"/.internal/globals\"
+    
+  /**
+   * Gets the URI where globals are stored in the index for given name or names.
+   *
+   * @internal
+   * @type name or List(name) -> uri
+   */
+  index-globals-uri:
+    names -> uri
+    with
+      if is-list then
+        uri := <concat> [names, [\"globals\", \".internal\"]]
+      else
+        uri := [names, \"global\", \".internal\"]
+      end
+    
+  /**
+   * Gets the first value in global storage with given name, or fail.
+   *
+   * Example:
+   *   index-get-global(|\"last-compile\") => Timestamp(1334322856)
+   *   index-get-global(|[\"last-compile\", \"file.str\"]) => Timestamp(1334322856)
+   * 
+   * @param name  The name or list of names to identify the global value.
+   * @type _ -> ?value
+   */
+  index-get-global(|name):
+    _ -> value
+    where
+      Global(_, value) := <index-get-all; Hd> Global(<index-globals-uri> name, ())
+    
+  /**
+   * Gets all values in global storage with given name.
+   *
+   * Example:
+   *   index-get-global(|\"last-compile\") => [Timestamp(1334322856), ...]
+   *   index-get-global(|[\"last-compile\", \"file.str\"]) => [Timestamp(1334322856), ...]
+   *
+   * @param name  The name or list of names to identify the global value.
+   * @type _ -> List(value)
+   */ 
+  index-get-all-globals(|name):
+    _ -> values'
+    with
+      values  := <index-get-all> Global(<index-globals-uri> name, ());
+      values' := <filter(?Global(_, <id>))> values
+    
+  /**
+   * Add value to global storage with given name.
+   *
+   * Example:
+   *   <index-add-global(|\"last-compile\")> Timestamp(1334322856)
+   *   <index-add-global(|[\"last-compile\", \"file.str\"])> Timestamp(1334322856)
+   *
+   * @param name  The name or list of names to identify the global value.
+   * @type x -> x
+   */   
+  index-add-global(|name):
+    value -> <id>
+    with
+      <index-add(|<index-globals-path>)> Global(<index-globals-uri> name, value)
+      
+  /**
+   * Overwrites value in global storage with given value.
+   *
+   * Example:
+   *   <index-set-global(|\"last-compile\")> Timestamp(1334322856)
+   *   <index-set-global(|[\"last-compile\", \"file.str\"])> Timestamp(1334322856)
+   *
+   * @param name  The name or list of names to identify the global value.
+   * @type x -> x
+   */   
+  index-set-global(|name):
+    value -> <id>
+    with
+      index-clear-global(|name);
+      <index-add-global(|name)> value
+    
+  /**
+   * Removes all values from global storage with given name.
+   *
+   * Example:
+   *   index-clear-global(|\"last-compile\")
+   *   index-clear-global(|[\"last-compile\", \"file.str\"])
+   *
+   * @param name  The name or list of names to identify the global value.
+   * @type x -> x
+   */   
+  index-clear-global(|name):
+    _ -> <id>
+    with
+      <index-remove(|<index-globals-path>)> Global(<index-globals-uri> name, ())
+      
+  /**
+   * Gets the URI where boolean globals are stored in the index for given name or names.
+   *
+   * @internal
+   */
+  index-boolean-globals-uri:
+    names -> uri
+    with
+      if is-list then
+        uri := <concat> [names, [\"boolean\", \"globals\", \".internal\"]]
+      else
+        uri := [names, \"boolean\", \"global\", \".internal\"]
+      end
+      
+  /**
+   * Sets boolean value true to global boolean storage with given name.
+   *
+   * Example:
+   *   index-enable-global(|\"can-compile\")
+   *   index-enable-global(|[\"can-compile\", \"file.str\"])
+   *
+   * @param name  The name or list of names to identify the global boolean value.
+   * @type x -> x
+   */   
+  index-enable-global(|name):
+    _ -> <id>
+    with
+      <index-add(|<index-globals-path>)> Global(<index-boolean-globals-uri> name)
+      
+  /**
+   * Sets boolean value false to global boolean storage with given name.
+   *
+   * Example:
+   *   index-disable-global(|\"can-compile\")
+   *   index-disable-global(|[\"can-compile\", \"file.str\"])
+   *
+   * @param name  The name or list of names to identify the global boolean value.
+   * @type x -> x
+   */   
+  index-disable-global(|name):
+    _ -> <id>
+    with
+      <index-remove(|<index-globals-path>)> Global(<index-boolean-globals-uri> name)
+      
+  /**
+   * Query for boolean value true in global boolean storage with given name.
+   *
+   * Example:
+   *   index-is-global-enabled(|\"can-compile\")
+   *   index-is-global-enabled(|[\"can-compile\", \"file.str\"])
+   *
+   * @param name  The name or list of names to identify the global boolean value.
+   * @type x -> ?x
+   */   
+  index-is-global-enabled(|name):
+    _ -> <id>
+    where
+      <index-get-all; Hd> Global(<index-boolean-globals-uri> name)
+
+"
+
+  create-index-partition = 
+    <output-text-file(|["lib", "index"], "partition.str")>
+"module index/partition
+
+rules // Construction
+  
+  index-create-partition(|file) =
+    !file
+    
+  index-create-partition(|file, uri) =
+    !(file, uri)
+
+rules // Projections
+  
+  index-partition-file:
+    (file, _) -> file
+    
+  index-partition-file:
+    file -> file
+    where
+      <is-string> file
+    
+  index-partition-uri:
+    (_, uri) -> uri
+"
+
+  create-index-query = 
+    <output-text-file(|["lib", "index"], "query.str")>
+"module index/query
+
+rules
+
+  /**
+   * Get all index entries that match the given template.
+   *
+   * Example:
+   *   <index-get-all> Def([Entity(), \"Bar\"]) => [Def([Entity(), \"Bar\"]), ...]
+   *
+   * @type template -> List(elem)
+   */
+  index-get-all:
+    template -> <prim(\"LANG_index_get\", template)>
+    
+  /**
+   * Get tuples of all index entries that match the given template with their partition
+   *
+   * Example:
+   *   <index-get-all> Def([Entity(), \"Bar\"]) => [((\"fullpath/file.ext\", \"subfile\"), Def([Entity(), \"Bar\"])), ...]
+   *
+   * @type template -> List(elem)
+   */
+  index-get-all-with-partitions:
+    template -> <prim(\"LANG_index_get_with_partitions\", template)>
+
+  /**
+   * Get all children entries of the given template.
+   *
+   * Example:
+   *   <index-get-children> Def([Entity(), \"Bar\", \"Foo\"]) => [Def([Method(), \"Bar\"]), Def([Field(), \"Baz\"]), ...]
+   *
+   * @type template -> List(elem)
+   */    
+  index-get-children:
+    template -> <prim(\"LANG_index_get_children\", template)>
+  
+  /**
+   * Gets the partition that the analysis is currently in.
+   *
+   * @type x -> partition
+   *
+   * @see index-setup(|language, project-paths, current-partition)
+   * @see index-set-current-partition
+   */
+  index-get-current-partition =
+    prim(\"LANG_index_get_current_file\")
+  
+  /**
+   * Gets a list of all partitions for current project.
+   *
+   * Example:
+   *   <index-get-all-partitions> => [(\"fullpath/file.ext\", \"subfile\"), ...]
+   *
+   * @type x -> List(partition)
+   */   
+  index-get-all-partitions =
+    prim(\"LANG_index_all_files\")
+  
+  /**
+   * Gets all index entries for the given partition.
+   *
+   * Examples:
+   *   <index-get-all-in-partition> \"fullpath/file.ext\" => [Def([Entity(), \"Bar\"]), ...]
+   *   <index-get-all-in-partition> (\"fullpath/file.ext\", \"subfile\") => [Def([Entity(), \"Bar\"]), ...]
+   *
+   * @type partition -> List(elem)
+   */  
+  index-get-all-in-partition =
+    prim(\"LANG_index_get_all_in_file\", <id>)
+    
+  /**
+   * Gets the revision of a partition.
+   *
+   * Example:
+   *   <index-get-partition-revision> \"fullpath/file.ext\" => 13
+   *   <index-get-partition-revision> (\"fullpath/file.ext\", \"subfile\") => 37
+   *
+   * @type partition -> Int
+   */
+  index-get-partition-revision:
+    file -> <prim(\"LANG_index_get_file_revision\", file)>
+    
+  /**
+   * Gets the containing partitions of index entry with given template.
+   *
+   * Example:
+   *   <index-get-partitions-of> Def([Entity(), \"Bar\"]) => [(\"fullpath/file.ext\", \"subfile\"), ...]
+   *
+   * @type template -> List(partition)
+   */  
+  index-get-partitions-of:
+    template -> <prim(\"LANG_index_get_files_of\", template)>
+
+"
+
+  create-nbl-check = 
+    <output-text-file(|["lib", "nbl"], "check.str")>
+"module nbl/check
+
+imports
+  
+  nbl/resolve
+  nbl/query
+  nbl/uri
+  nbl/entries
+  
+rules // Unresolved
+ 
+  nabl-is-unresolved =
+    ?node;
+    has-annos;
+    get-annos;
+    nabl-has-reference;
+    not(nabl-collect-one-resolved-def)
+
+rules // Ambiguities
+  
+  nabl-get-ambiguities =
+    nabl-collect-all-resolved-defs;
+    mapconcat(nabl-get-all-aliases);
+    filter(nabl-uri; nabl-uri-parent);
+    make-set;
+    where(<gt> (<length>, 1))
+
+rules // Duplicate definitions
+  
+  nabl-get-duplicate-definitions =
+    has-annos;
+    get-annos;
+    collect-one(?Def(_));
+    nabl-get-all-definitions;
+    make-set;
+    where(<gt> (<length>, 1))
+
+"
+
+  create-nbl-collect = 
+    <output-text-file(|["lib", "nbl"], "collect.str")>
+"module nbl/collect
+
+imports
+  
+  task/core
+  task/tasks
+  nbl/tasks
+  nbl/entries
+  nbl/interface
+  nbl/uri
+  nbl/utils
+  types/interface
+  
+signature 
+
+  sorts
+  
+    State DefScope ImplicitDef Use RefScope Range
+
+  constructors // state
+    
+    State : String * Term -> State
+
+  constructors // def
+
+    Current    :                        DefScope
+    Subsequent :                        DefScope
+    DefScope   : Namespace * Segment -> DefScope
+
+  constructors // implicit def
+    
+    IDefCandidate : Namespace * Name * Unique * List(Property) -> ImplicitDef
+  
+  constructors // use
+      
+    UseCandidate  : Namespace * List(Property) * RefScope * Range        -> Use
+    UseCandidate  : Namespace * Name * List(Property) * RefScope * Range -> Use
+  
+    Current     :                                                   RefScope
+    Surrounding :                                                   RefScope
+    Context     : String * Namespace * List(Property) * RefScope -> RefScope
+    
+    All : Range
+    One : Range
+  
+  constructors // import
+    
+    Imported : Namespace                   -> Namespace
+    Import   : Language * Namespace        -> Property
+    Import   : Language * Namespace * Name -> Property
+    Type     : Property
+    
+  constructors // property
+    
+    Prop : Property * Value -> Prop
+    
+  constructors // partition
+  
+    CollectPartition : Partition
+  
+strategies // generic traversal
+  
+  /**
+   * Main strategy to collect all index elements and task* from an AST.
+   */
+  nabl-collect(|partition, lang):
+    ast -> ast''
+    where
+      new-hashtable => unique*;
+      new-iset => elem*; // TODO: Remove
+      ast'  := <nabl-collect(id|lang, partition, unique*, elem*, [])> ast ;
+      ast'' := <alltd(type-task(|partition))> ast'
+    
+  /**
+   * Performs the collection in a topdown traversal. 
+   * At each node, it tries various calls to generated strategies, which call back to generic strategies.
+   */
+  nabl-collect(sibling-uris|lang, partition, unique*, elem*, uri*) =
+    nabl-state-pop(?state*);
+    nabl-scope-site(?uri'*|lang, uri*); // scopes of external definitions, e.g. variables in let expressions
+    
+    (
+       nabl-def-site(?child-uri*, sibling-uris|lang, partition, unique*, elem*, uri'*, state*)
+    <+ match(sibling-uris|uri*)
+    ;  nabl-anonymous-scope-site(?child-uri*|lang, partition, unique*, uri'*, state*)
+    <+ match(?child-uri*|uri'*)
+    );
+    
+    try(nabl-state-site);
+    
+    preserve-annos(force-origins(id#(nabl-siblings(|lang, partition, unique*, elem*, child-uri*)))); // visit children from left to right
+    
+    try(nabl-use-site(|lang, partition, elem*, uri'*, state*));
+    try(nabl-import-site(|lang, partition, elem*, child-uri*, state*));
+    try(nabl-prop-site(|lang, partition, elem*, state*));
+    try(nabl-implicit-def-site(|lang, partition, unique*, elem*, child-uri*, state*));
+    try(nabl-constraint-site(|lang, partition))
+  
+  nabl-siblings(|lang, partition, unique*, elem*, uri*) = 
+    [] + 
+    [ nabl-collect(?sibling-uri*|lang, partition, unique*, elem*, uri*)
+    | nabl-siblings(|lang, partition, unique*, elem*, sibling-uri*) ]
+
+rules // generic analysis of state
+  
+  nabl-state(pattern|state) =
+    map(try(nabl-state-annotate(pattern|state)))
+      
+  nabl-state-annotate(pattern|state) =
+    ?pattern; add-annotation(|state)
+    
+  nabl-state-pop(states'):
+    term{anno*} -> term'
+    where
+      state* := <collect-all(?State(_, _))> anno*;
+      term'  := <remove-annotations(?State(_, _))> term;
+      match(states'|state*)
+      
+  nabl-get-state(|name) =
+    fetch-elem(?State(name, _))
+
+rules // generic analysis of scopes
+  
+  nabl-scope-site(adapted-uris|lang, uri*) =
+    with (
+      get-annotations;
+      collect-all(?DefScope(_, _));
+      foldr(!uri*, nabl-def-scope-site(|lang));
+      match(adapted-uris|<id>)
+    );
+    remove-annotations(?DefScope(_, _))
+    
+  nabl-def-scope-site(|lang):
+    (DefScope(ns, uri), uri*) -> uri'*
+    where
+      segment := <nabl-uri-path; Hd; nabl-external-segment> uri;
+      uri'*   := <update-scope-uri(nabl-extend-uri(|segment)|lang)> (ns, uri*)
+      
+  nabl-construct-def-scope(|lang, partition, unique*) = 
+    !DefScope(<id>, <nabl-base-uri; nabl-extend-uri-anonymous(|unique*, partition)> lang)
+  
+  nabl-def-scope(|scope) = add-annotation(|scope)
+    
+  // call back for generic analysis of anonymous scopes
+  nabl-anonymous-scope(child-uris|lang, partition, unique*, uri*, ns*) =
+    match(child-uris|<extend-scope-uri(nabl-extend-uri-anonymous(|unique*, partition)|lang)> (ns*, uri*)) 
+  
+rules // generic analysis of defs
+      
+  // call back to generic analysis
+  nabl-def(child-uris, sibling-uris|lang, partition, unique*, elem*, uri*, ns, unique, defscope, scoped):
+    a at name{anno*} -> name{d,anno*}
+    where
+      // get URI for namespace of definition site
+      current-uri := <lookup-uri(|lang, ns)> uri*;
+      switch !defscope
+      // in each case we 
+      // 1. build URI of the definition site
+      // 2. update URIs for children (vertical scope)
+      // 3. update URIs for right siblings (horizontal scope)
+      case ?Current():
+        // 1. extend current URI with ID segment
+        // 2. extend URIs of scoped namespaces
+        // 3. preserve
+        def-uri := <nabl-extend-uri(|unique*, partition, ns, name, unique)> current-uri;
+        match(child-uris|<replace-scope-uri(|def-uri)> (scoped, uri*));
+        match(sibling-uris|uri*)
+      case ?[Subsequent()]:
+        // 1. extend current URI with Subsequent and ID segment
+        // 2. preserve
+        // 3. extend URI for namespace of definition site with Subsequent segment
+        subs-uri := <nabl-extend-uri-subsequent(|unique*, partition)> current-uri;
+        def-uri  := <nabl-extend-uri(|unique*, partition, ns, name, unique)> subs-uri;
+        match(child-uris|uri*);
+        match(sibling-uris|<replace-scope-uri(|subs-uri)> ([ns], uri*))
+      case ?[DefScope(ns, uri)]:
+        // 1. extend base URI with External and ID segment
+        // 2. preserve
+        // 3. preserve
+        def-uri := <nabl-extend-uri(|unique*, partition, ns, name, unique)> uri;
+        match(child-uris|uri*);
+        match(sibling-uris|uri*)
+      case ?[Subsequent(), DefScope(ns, uri)]:
+        // 1a. extend base URI with External and ID segment
+        // 1b. extend current URI with Subsequent and ID segment
+        // 1c. introduce alias from 1b to 1a
+        // 2. preserve
+        // 3. extend URI for namespace of definition site with Subsequent segment
+        def-uri   := <nabl-extend-uri(|unique*, partition, ns, name, unique)> uri;
+        subs-uri  := <nabl-extend-uri-subsequent(|unique*, partition)> current-uri;
+        alias-uri := <nabl-extend-uri(|unique*, partition, ns, name, unique)> subs-uri;
+        <new-alias(|partition, def-uri, alias-uri)> a;
+        match(child-uris|uri*);
+        match(sibling-uris|<replace-scope-uri(|subs-uri)> ([ns], uri*))
+      end;
+      // add Def entry to the index
+      d := <new-def(|partition, def-uri)> a
+  
+rules // generic analysis of uses
+  
+  // single candidate
+  nabl-use(|lang, partition, elem*, uri*, candidate) =
+    where (<not(is-list)> candidate);
+    nabl-use(|lang, partition, elem*, uri*, [candidate])
+  
+  // list of candidates
+  nabl-use(|lang, partition, elem*, uri*, candidate*):
+    name{anno*} -> name{u, anno*}
+    where
+      subtask* := <map(nabl-use-candidate(|lang, partition, elem*, uri*, <nabl-fix-name> name)); unions> candidate*;
+      result   := <new-task(|partition)> Choice(subtask*);
+      u        := <new-use(|partition, result)>
+
+  nabl-use-subtasks(|partition, ns, name, range): 
+    uri  -> [subtask1, subtask2, subtask*|subtasks]
+    with
+      subtask1 := <new-task(|partition)> Resolve(<nabl-use-subtask-uri(|partition)> uri, ns, name);
+      subtask2 := <new-task(|partition)> ResolveImport(<nabl-use-subtask-uri(|partition)> uri, ns, name);
+      if ExternalDef(x) := <nabl-uri-path; Hd> uri then
+        ext-uri  := <nabl-uri-language; nabl-base-uri; nabl-extend-uri(|Anonymous(x))> uri;
+        subtask* := [<new-task(|partition)> Resolve(<nabl-use-subtask-uri(|partition)> ext-uri, ns, name)]
+      else
+        subtask* := []
+      end;
+      switch !range
+        case One(): ![]
+        case All(): <nabl-uri-parent < nabl-use-subtasks(|partition, ns, name, range) + ![]> uri
+      end => subtasks
+      
+  nabl-use-subtask-uri(|partition) =
+    switch id
+      case ?URI(_, _) => uri : ![uri]
+      case is-list           : <new-task(|partition)> Choice(<id>)
+      otherwise              : id
+    end 
+        
+  // candidate in current scope
+  nabl-use-candidate(|lang, partition, elem*, uri*, name):
+    UseCandidate(ns, prop*, Current(), range) -> result
+    where
+      uri      := <lookup-uri(|lang, ns)> uri*;
+      subtask* := <nabl-use-subtasks(|partition, ns, name, range)> uri;
+      if not([] := prop*) then
+        result := [<new-task(|partition)> PropConstraint(prop*, subtask*)]
+      else
+        result := subtask*
+      end
+
+  // candidate in another scope (result of resolution)    
+  nabl-use-candidate(|lang, partition, elem*, uri*, name):
+    UseCandidate(ns, prop*, target-uri*, range) -> result
+    where
+      <?Result(_) <+ map(?Result(_))> target-uri*;
+      subtask* := <nabl-use-subtasks(|partition, ns, <nabl-fix-name> name, range)> target-uri*;
+      if not([] := prop*) then
+        result := [<new-task(|partition)> PropConstraint(prop*, subtask*)]
+      else
+        result := subtask*
+      end
+      
+  // candidate in context
+  //  nabl-use-candidate(|lang, elem*, task*, uri*, dep*):
+  //    (UseCandidate(ns, prop*, Context(name', ns', props', refscope'), range), name{anno*}) -> name{u, anno*}
+  //    where 
+  //      _{uri}   := <nabl-use-candidate(|lang, elem*, task*, uri*, dep*)> (UseCandidate(ns', props', refscope', range), name'{});
+  //      propdep* := <dependent-tasks> prop*;
+  //      result   := <new-task(|task*, [dep*, propdep*])> Resolve(uri, ns, <nabl-fix-name> name, prop*, range);
+  //      u        := <new-use(|partition, result)>
+    
+rules // generic analysis of imports
+  
+  nabl-import(|lang, partition, elem*, uri*, imports):
+    name -> name'
+    where
+      Use(use) := <nabl-collect-use> name;
+      name'    := <foldl(nabl-import-candidate(|lang, partition, elem*, uri*, use))> (imports, name)
+        
+  nabl-import-candidate(|lang, partition, elem*, uri*, use):
+    (import, name) -> name
+    where
+      ns  := <nabl-import-namespace> import;
+      uri := <lookup-uri(|lang, ns)> uri*;
+      new-prop(|partition, uri, import, use)
+      
+  nabl-import-namespace =
+       ?Import(_, Imported(<id>)) 
+    <+ ?Import(_, <id>)
+    <+ ?Import(_, Imported(<id>), _)
+    <+ ?Import(_, <id>, _) 
+
+rules // generic analysis of properties
+  
+  // call back to generic analysis
+  nabl-props(|lang, partition, elem*, prop*):
+    name -> name'
+    where
+      Def(uri) := <nabl-collect-def> name;
+      name'    := <foldl(extend-prop(|partition, elem*, uri))> (prop*, name)
+    
+  extend-prop(|partition, elem*, uri):
+    (Prop(type, result), name) -> name
+    where
+      prop := <new-prop(|partition, uri, type, result)> name
+        
+rules // generic analysis of implicit defs
+ 
+  nabl-implicit-def(|lang, partition, unique*, elem*, uri*, candidates):
+    name -> name
+    where
+      <map(nabl-implicit-def-candidate(|lang, partition, unique*, elem*, uri*))> candidates
+      
+  nabl-implicit-def-candidate(|lang, partition, unique*, elem*, uri*):
+    IDefCandidate(ns, name, unique, prop*) -> <id>
+    where
+      // get path for namespace of definition site
+      current-uri := <lookup-uri(|lang, ns)> uri*;
+      // build path for definition site
+      def-uri     := <nabl-extend-uri(|unique*, partition, ns, name, unique)> current-uri;
+      // build Def entry for the index
+      new-def(|partition, def-uri);
+      // build Prop entries for the index
+      <map(\\Prop(type, result) -> <new-prop(|partition, def-uri, type, result)>\\)> prop*
+
+rules // name retrieval
+  
+  nabl-name = is-string
+  
+  nabl-name-apply(s) = is-string; s
+    
+  nabl-fix-name = try(fix-completion-name); strip-annos
+  
+rules // URI retrieval
+  
+  nabl-collect-def =
+    nabl-name;
+    get-annos;
+    collect-one(?Def(_))
+    
+  nabl-collect-all-def =
+    nabl-name;
+    get-annos;
+    collect-all(?Def(_))
+    
+  nabl-collect-use =
+    nabl-name;
+    get-annos;
+    collect-one(?Use(_))
+    
+  nabl-collect-all-use =
+    nabl-name;
+    get-annos;
+    collect-all(?Use(_))
+
+rules // helpers
+  
+  replace-scope-uri(|path) = foldl(update-scope-uri(!path|<nabl-uri-language> path))
+  extend-scope-uri(s|lang) = foldl(update-scope-uri(s|lang))
+  
+  update-scope-uri(update|lang):
+    (key, uri*) -> result
+    where
+      result := <fetch((?key, update))> uri* 
+    <+ 
+      result := [(key, <nabl-base-uri; update> lang)|uri*]
+        
+  lookup-uri(|lang, ns):
+    uri* -> <<lookup> (ns, uri*) <+ <nabl-base-uri> lang>
+
+"
+
+  create-nbl-complete = 
+    <output-text-file(|["lib", "nbl"], "complete.str")>
+"module nbl/complete
+
+imports
+  
+  nbl/lookup
+  nbl/query
+  nbl/entries
+  nbl/uri
+  task/core
+  index/core
+  
+signature
+
+  constructors
+    
+    COMPLETION : String -> COMPLETION
+    
+rules // Code completion
+
+  nabl-completion-defs = 
+    has-annos;
+    get-annos;
+    collect-all(nabl-completion-defs);
+    concat
+    
+  nabl-completion-defs:
+    Result(taskID) -> <task-get-result>
+
+  nabl-propose-completions:
+    ast -> proposals'*
+      where
+        item        := <collect-one(?COMPLETION(_))> ast;
+        index-transaction(
+          uri*      := <nabl-completion-defs; filter(nabl-uri)> item;
+          proposal* := <mapconcat(nabl-visible-definitions)> uri*
+        );
+        proposals'* := <map(nabl-uri; nabl-uri-name)> proposal*
+        
+rules // Visible entries
+  
+  nabl-visible-definitions:
+    containsURI -> <nabl-visible(\\uri -> Def(uri)\\, id)> containsURI
+      
+  nabl-visible(create-template, constraint|):
+    containsURI -> entries
+    with
+      <with(uri             := <nabl-uri> containsURI                  | \"Could not extract URI from given term.\")> [containsURI];
+      <with(targetNamespace := <nabl-uri-namespace> uri                | \"Could not extract target namespace.\")> [uri];
+      <with(targetPrefix    := <nabl-uri-name> uri                     | \"Could not extract target prefix.\")> [uri];
+      <with(parentURI       := <nabl-uri-parent(|targetNamespace)> uri | \"Could not construct a parent URI.\")> [uri];
+      entries               := <nabl-visible-uri(create-template, constraint|targetNamespace, targetPrefix)> parentURI
+      
+  nabl-visible-uri(create-template, constraint|namespace, prefix):
+    uri -> allEntries
+    with
+      entries := <nabl-visible-uri-scoped(create-template, constraint|namespace, prefix)> uri;
+      if parentURI := <nabl-uri-parent(|namespace)> uri then
+        entries2   := <nabl-visible-uri(create-template, constraint|namespace, prefix)> parentURI;
+        allEntries := <conc> (entries, entries2)
+      else
+        allEntries := entries
+      end
+      
+  nabl-visible-uri-scoped(create-template, constraint|namespace, prefix):
+    uri -> [entry*, importEntry*]
+    with
+      // Standard lookup
+      entry*       := <nabl-standard-visible(create-template|namespace, prefix); filter(constraint)> uri;
+      
+      // Imports & aliases
+      importEntry* := <nabl-visible-imported-entries(create-template|<nabl-uri-language> uri, namespace, prefix); filter(constraint)> uri
+
+  nabl-standard-visible(create-template|namespace, prefix) =
+    create-template;
+    nabl-get-children(|namespace, prefix)
+    
+  nabl-visible-imported-entries(create-template|language, namespace, prefix):
+    uri -> result
+    with
+      unnamedImportURI* := <nabl-get-import-uris-unnamed(|language, namespace)> uri;
+      if <task-has-dependencies> unnamedImportURI* then
+        result := unnamedImportURI*
+      else
+        unnamedEntry* := <mapconcat(nabl-standard-visible(create-template|namespace, prefix))> unnamedImportURI*;
+        result        := unnamedEntry*
+      end
+ 
+"
+
+  create-nbl-constraints = 
+    <output-text-file(|["lib", "nbl"], "constraints.str")>
+"module nbl/constraints
+
+imports
+  
+  task/core
+  task/tasks
+  nbl/interface
+  nbl/tasks
+  
+rules
+
+  nabl-match: (\"constraint-error\",   term, []) -> Error(<constraint-error> term)
+  nabl-match: (\"constraint-warning\", term, []) -> Warning(<constraint-warning> term)
+  nabl-match: (\"constraint-note\",    term, []) -> Note(<constraint-note> term)
+  
+  new-error-check(|task*)   = where(<new-task(|task*)> Match(\"constraint-error\"  , [], <id>))
+  new-warning-check(|task*) = where(<new-task(|task*)> Match(\"constraint-warning\", [], <id>))
+  new-note-check(|task*)    = where(<new-task(|task*)> Match(\"constraint-note\"   , [], <id>))
+  
+  // nabl-constraint-site(|task*) = ?Pattern(...); <new-error-check(|task*)
+  //
+  // constraint-error: Pattern(...) -> (e, msg)
+  
+"
+
+  create-nbl-entries = 
+    <output-text-file(|["lib", "nbl"], "entries.str")>
+"module entries
+
+imports
+  
+  nbl/collect
+  nbl/utils
+  nbl/uri
+  index/core
+  
+signature
+
+  constructors
+    
+    Def   : URI                    -> Entry
+    Alias : URI * URI              -> Entry
+    Use   : URI                    -> Entry
+    Prop  : URI * Property * Value -> Entry
+  
+rules
+  
+  new-def(|partition, uri):
+    x -> definition
+    with
+      definition := <force-origins(!Def(uri))> x;
+      <index-add(|partition)> definition;
+      <new-alias(|partition, <nabl-nonunique-uri> uri, uri)> x
+      
+  new-alias(|partition, uri, alias-uri):
+    x -> alias
+    with
+      alias := <force-origins(!Alias(uri, alias-uri))> x;
+      if <not(eq)> (uri, alias-uri) then
+        <index-add(|partition)> alias
+      end
+      
+  new-use(|partition, uri):
+    x -> use
+    with
+      use := <force-origins(!Use(uri))> x;
+      <index-add(|partition)> use
+
+  new-prop(|partition, uri, kind, val):
+    x -> prop
+    with
+      prop := <force-origins(!Prop(uri, kind, val))> x;
+      <index-add(|partition)> prop
+      
+rules // index uri & value projections
+  
+  /** @internal */
+  nabl-uri-impl:
+    Def(uri) -> uri
+    
+  /** @internal */
+  nabl-uri-impl:
+    Alias(uri, _) -> uri
+    
+  /** @internal */  
+  nabl-uri-impl:
+    Use(uri) -> uri
+    
+  /** @internal */  
+  nabl-uri-impl:
+    Prop(uri, _, _) -> uri
+    
+    
+  /** @internal */
+  nabl-value-impl:
+    Def(value) -> value
+    
+  /** @internal */
+  nabl-value-impl:
+    Alias(_, value) -> value
+
+  /** @internal */
+  nabl-value-impl:
+    Use(value) -> value
+    
+  /** @internal */
+  nabl-value-impl:
+    Prop(_, _, value) -> value
+
+"
+
+  create-nbl-interface = 
+    <output-text-file(|["lib", "nbl"], "interface.str")>
+"module nbl/interface
+
+strategies // Collect
+  
+  nabl-anonymous-scope-site(child-uris|lang, partition, unique*, uri*, state*) = fail
+  
+  nabl-def-site(child-uris, sibiling-uris|lang, partition, unique*, elem*, uri*, state*) = fail
+  
+  nabl-state-site = fail
+  
+  nabl-use-site(|lang, partition, elem*, uri*, state*) = fail
+  
+  nabl-import-site(|lang, partition, elem*, uri*, state*) = fail
+  
+  nabl-implicit-def-site(|lang, partition, unique*, elem*, uri*, state*) = fail
+  
+  nabl-prop-site(|lang, partition, elem*, state*) = fail
+  
+  nabl-constraint-site(|lang, partition) = fail
+  
+  constraint-error = fail
+  
+  constraint-warning = fail
+  
+  constraint-note = fail
+
+strategies // Projections
+  
+  nabl-name = fail
+  
+  nabl-name-apply(s) = fail
+  
+  nabl-scopes = fail
+
+strategies // Tasks
+  
+  calc-property = fail
+
+"
+
+  create-nbl-lookup = 
+    <output-text-file(|["lib", "nbl"], "lookup.str")>
+"module nbl/lookup
+
+imports
+  
+  nbl/collect
+  nbl/query
+  nbl/tasks
+  nbl/uri
+  nbl/entries
+  task/core
+
+rules // Lookup
+  
+  nabl-lookup(|ns, name):
+    scope* -> def*
+    with
+      uri*  := <filter(nabl-uri)> scope*;
+      uri'* := <map(nabl-extend-uri(|ns, name, ()))> uri*; 
+      def*  := <mapconcat(nabl-get-all-definitions)> uri'*
+            
+  nabl-lookup-import(|ns, name):
+    scope* -> import*
+    with
+      uri*    := <filter(nabl-uri)> scope*;
+      import* := <mapconcat(nabl-lookup-import-one(|ns, name))> uri*
+      
+  nabl-lookup-import-one(|ns, name):
+    uri -> [namedImport*, unnamedImport*]
+    with
+      language       := <nabl-uri-language> uri;
+      namedImport*   := <nabl-get-import-uris-named(|language, ns, name)> uri;
+      unnamedImport* := <nabl-get-import-uris-unnamed(|language, ns)> uri
+
+rules // Imports
+
+  nabl-get-import-uris-unnamed(|language, namespace) = nabl-get-import-uris-unnamed(|[], language, namespace)
+
+  nabl-get-import-uris-unnamed(|seen, language, namespace):
+    uri -> [importURI*, transitiveImportURI*]
+    with
+      importResult*        := <nabl-get-all-properties(|Import(language, namespace))> uri;
+      importURI*           := <map(task-get-solved <+ task-create-dependencies; ![<id>]); concat> importResult*;
+      importedResult*      := <nabl-get-all-properties(|Import(language, Imported(namespace)))> uri;
+      importedURI*         := <map(task-get-solved <+ task-create-dependencies; ![<id>]); concat> importedResult*;
+      transitiveImportURI* := <mapconcat(nabl-get-import-uris-unnamed-transitive(|seen, language, namespace))> importedURI*
+
+  nabl-get-import-uris-unnamed-transitive(|seen, language, namespace):
+    uri -> transitiveImportURI*
+    where
+      not(<fetch(?uri)> seen);
+      transitiveImportURI* := <nabl-get-import-uris-unnamed(|[uri|seen], language, namespace)> uri
+    
+  nabl-get-import-uris-named(|language, namespace, name):
+    uri -> importURI*
+    with
+      importResult* := <nabl-get-all-properties(|Import(language, namespace, name))> uri;
+      importURI*    := <map(task-get-solved <+ task-create-dependencies; ![<id>]); concat> importResult*
+
+"
+
+  create-nbl-query = 
+    <output-text-file(|["lib", "nbl"], "query.str")>
+"module nbl/query
+
+imports
+  
+  nbl/uri
+  nbl/entries
+  index/query
+  
+rules // Specific queries
+
+  /**
+   * Gets all unique and non-unique definition entries that match the given URI.
+   *
+   * Example:
+   *   <nabl-get-all-definitions> [Entity(), \"M\", \"Bar\"] => [Def([Entity(), \"M\", \"Bar\"]), ...]
+   *
+   * @type Def(uri) or \"name\"{uri} or URI(language, path) -> List(Def(uri))
+   */
+  nabl-get-all-definitions:
+    <with(uri := <nabl-uri> | \"Could not extract URI from given term.\")> -> <nabl-get-unique-nonunique(\\uri -> Def(uri)\\)> uri
+
+  /**
+   * Gets a property that matches the kind of value and given URI, or fails if no property is found.
+   *
+   * Example:
+   *   <nabl-get-property(|Size())> Def([Entity(), \"Bar\"]) => Size(8)
+   *
+   * @param type Only properties of this kind is returned.
+   * @type Def(uri) or \"name\"{uri} or URI(language, path) -> Prop(uri, kind, value)
+   */
+  nabl-get-property(|kind) = 
+    nabl-get-all-properties(|kind); Hd
+      
+  /**
+   * Gets all properties that match the kind of value and given URI.
+   *
+   * Example:
+   *   <nabl-get-all-properties(|Size())> Def([Entity(), \"Bar\"]) => [Size(8), ...]
+   *
+   * @param kind Only data of this kind is returned.
+   * @type Def(uri) or \"name\"{uri} or URI(language, path) -> List(Prop(uri, kind, value))
+   */
+  nabl-get-all-properties(|kind):
+     <with(uri := <nabl-uri> | \"Could not extract URI from given term.\")> -> <nabl-get-all-values> Prop(uri, kind, ())
+     
+  /**
+   * Gets all Use entries that match the given URI.
+   *
+   * Example:
+   *   <nabl-get-all-uses> Def([Entity(), \"M\", \"Bar\"]) => [Use([Entity(), \"M\", \"Bar\"]), ...]
+   *
+   * @type Def(uri) or \"name\"{uri} or URI(language, path) -> List(Use(uri))
+   */
+  nabl-get-all-uses:
+    <with(uri := <nabl-uri> | \"Could not extract URI from given term.\")> -> <nabl-get-all> Use(uri)
+
+  /**
+   * Gets all Alias entries that match the given URI.
+   *
+   * Example:
+   *   <nabl-get-all-aliases> Def([Entity(), \"M\", \"Bar\"]) => [[Entity(), \"M\", \"Baz\"], ...]
+   *
+   * @type Def(uri) or \"name\"{uri} or URI(language, path) -> List(aliasURI)
+   */
+  nabl-get-all-aliases:
+    <with(uri := <nabl-uri> | \"Could not extract URI from given term.\")> -> aliasURI*
+    where
+      if nonUniqueURI := <nabl-replace-uri-qualifier(|NonUnique())> uri then
+        aliasURI* := <nabl-get-all-values> Alias(nonUniqueURI, ()) 
+      else
+        aliasURI* := []
+      end
+
+rules // Generic queries
+  
+  nabl-get-all:
+    template -> <index-get-all> template
+       
+  nabl-get-all-values:
+    template -> <nabl-get-all; map(nabl-value)> template
+
+  nabl-get:
+    template -> <nabl-get-all; Hd> template
+     
+  nabl-get-value:
+    template -> <nabl-get-all; Hd; nabl-value> template
+  
+  nabl-get-children:
+    template -> entries
+      with
+        entries  := <index-get-children> template
+        
+  nabl-get-children(|namespace, prefix):
+    template -> entries
+      with
+        children := <index-get-children> template;
+        entries  := <nabl-filter-entries(|namespace, prefix)> children
+
+  nabl-get-unique-nonunique(create-template):
+    uri -> [unique*, nonUnique*]
+    where
+      if alias* := <nabl-get-all-aliases> uri then
+        unique* := <mapconcat(create-template; nabl-get-all)> alias*
+      else
+        unique* := []
+      end;
+      if nonUniqueURI := <nabl-replace-uri-qualifier(|NonUnique())> uri then
+        nonUnique*    := <create-template; nabl-get-all> nonUniqueURI
+      else
+        nonUnique*    := []
+      end
+
+rules /** @internal Entry filtering */
+  
+  /** @internal */
+  nabl-filter-entries(|namespace, prefix):
+    entry* -> <filter(nabl-compare-prefix(|namespace, prefix))> entry*
+  
+  /** @internal */
+  nabl-filter-entries(|namespace):
+    entry* -> <filter(nabl-compare-namespace(|namespace))> entry*
+
+rules /** @internal Helpers */
+  
+  /** @internal */
+  nabl-compare-prefix(|namespace, prefix):
+    entry -> <id>
+    where
+      uri := <nabl-uri> entry;
+      <eq> (namespace, <nabl-uri-namespace> uri);
+      <is-substring(!prefix)> <nabl-uri-name> uri
+      
+  /** @internal */
+  nabl-compare-namespace(|namespace):
+    entry -> <id>
+    where
+      uri := <nabl-uri> entry;
+      <eq> (namespace, <nabl-uri-namespace> uri)
+
+"
+
+  create-nbl-resolve = 
+    <output-text-file(|["lib", "nbl"], "resolve.str")>
+"module nbl/resolve
+
+imports
+  
+  nbl/tasks
+  nbl/entries
+  task/core
+      
+rules // Reference resolution
+  
+  nabl-is-reference =
+    ?Use(_)
+    
+  nabl-has-reference =
+    collect-one(nabl-is-reference)
+    
+  nabl-has-reference =
+    has-annos;
+    get-annos;
+    nabl-has-reference
+  
+  // TODO: does not go through annotations?
+  nabl-collect-all-resolved-defs:
+    ast -> def*
+    with
+      if ast' := <insert-results> ast then
+        def* := <collect-all(?Def(_))> ast'
+      else
+        def* := []
+      end
+
+  nabl-collect-one-resolved-def =
+    insert-results-or-create-dependency;
+    oncetd-annos((?Def(_) <+ ?Dependency(_)); ?d); !d
+    
+  oncetd-annos(s) = s <+ has-annos; get-annos; one(oncetd-annos(s)) <+ one(oncetd-annos(s))
+  
+"
+
+  create-nbl-tasks = 
+    <output-text-file(|["lib", "nbl"], "tasks.str")>
+"module nbl/tasks
+
+imports 
+  
+  task/core
+  nbl/lookup
+  nbl/collect
+  nbl/query
+  nbl/interface
+  nbl/uri
+  nbl/utils
+  nbl/entries
+  
+signature
+  
+  constructors
+    
+    Resolve        : Scope * Namespace * Name    -> Instruction
+    ResolveImport  : Scope * Namespace * Name    -> Instruction
+    PropConstraint : List(Prop) * List(Result)   -> Instruction
+    PropCalc       : Property * Term             -> Instruction
+        
+rules // Resolve
+  
+  perform-task(|nr):
+    Resolve(scope*@<with(is-list|\"Expected a list of scopes.\")>, ns, name) -> result
+    where
+      uri* := <filter(nabl-uri)> scope*;
+      def* := <nabl-lookup(|ns, name)> uri*;
+      <map(nabl-extend-uri(|ns, name, ()); task-add-read(|nr))> uri*;
+      switch !def*
+        case ?[]:
+          fail
+        otherwise: 
+          !def*
+      end => result
+
+  perform-task(|nr):
+    ResolveImport(scope*@<with(is-list|\"Expected a list of scopes.\")>, ns, name) -> result
+    where
+      uri* := <filter(nabl-uri)> scope*;
+      import* := <nabl-lookup-import(|ns, name)> uri*;
+      <map(try(nabl-replace-uri-qualifier(|())); task-add-read(|nr))> uri*;
+      if <task-has-dependencies> import* then
+        result := <task-collect-dependencies> import*
+      else
+        def* := <nabl-lookup(|ns, name)> import*;
+        <map(nabl-uri; nabl-extend-uri(|ns, name, ()); task-add-read(|nr))> import*;
+        switch !def*
+          case ?[]:
+            fail
+          otherwise:
+            !def*
+        end => result
+      end
+    
+  perform-task(|nr):
+    PropConstraint(prop*, res*) -> result
+    where
+      filtered := <concat; filter(nabl-resolve-constraint(|prop*))> res*;
+      switch !filtered
+        case task-collect-dependencies => d: !d
+        otherwise: !filtered
+      end => result
+      
+  nabl-resolve-constraint(|prop*):
+    entry -> entry'
+    where
+      filtered := <filter(nabl-resolve-constraint-one(|entry))> prop*;
+      switch !filtered
+        case ?[]: fail
+        case task-collect-dependencies => d: !d
+        otherwise: !entry
+      end => entry'
+      
+  nabl-resolve-constraint-one(|entry):
+    Prop(type, expectedValue) -> entry'
+    where
+      uri   := <nabl-uri> entry;
+      value := <nabl-get-property(|type)> uri;
+      if value' := <insert-results> value then
+        expectedValue' := <insert-results> expectedValue;
+        <eq> (expectedValue', value');
+        entry' := entry
+      else
+        entry' := <task-create-dependencies> value
+      end
+
+  perform-task(|nr): 
+    PropCalc(prop, term) -> result'
+    where
+      result := <calc-property> (prop, term);
+      switch !result
+        case task-collect-dependencies => d : !d
+        case not(is-list)                   : ![result]
+        otherwise                           : !result
+      end => result'
+
+"
+
+  create-nbl-uri = 
+    <output-text-file(|["lib", "nbl"], "uri.str")>
+"module nbl/uri
+
+imports
+  
+  nbl/interface
+  index/core
+  
+signature
+
+  sorts
+  
+    Language
+    Segment
+    Qualifier
+    
+  constructors
+    
+    Language    : String                       -> Language
+    ID          : Namespace * Name * Qualifier -> Segment
+    Subsequent  : String                       -> Segment
+    Anonymous   : String                       -> Segment
+    ExternalDef : String                       -> Segment
+    Unique      : String                       -> Qualifier
+    NonUnique   :                                 Qualifier
+    Unique      :                                 Qualifier
+    URI         : Language * List(Segment)     -> URI
+    
+rules // Construction
+  
+  nabl-base-uri = 
+    !URI(<id>, [])
+     
+  nabl-extend-uri(|segment) = 
+    URI(id, ![segment|<id>])
+    
+  nabl-extend-uri(|namespace, name, qualifier) = 
+    URI(id, ![ID(namespace, name, qualifier)|<id>])
+    
+  nabl-replace-uri(|segment) = 
+    URI(id, [!segment|id])
+    
+  nabl-replace-uri(|namespace, name, qualifier) = 
+    URI(id, [!ID(namespace, name, qualifier)|id])
+    
+  nabl-replace-uri-qualifier(|qualifier) =
+    URI(id, [ID(id, id, !qualifier)|id])
+      
+  nabl-external-segment: Anonymous(name) -> ExternalDef(name)
+  
+  nabl-nonunique-uri =
+    URI(id, [ID(id, id, !NonUnique())|id])
+
+rules // stable URI extensions
+  
+  nabl-extend-uri(|table, partition, ns, n, u):
+    uri -> <nabl-extend-uri(|ns, n, qualifier)> uri
+    where 
+      if where(<?NonUnique()> u) then
+        qualifier := NonUnique()
+      else
+        qualifier := Unique(<stable-uri-part(|table, partition)> (partition, uri, ns, n))
+      end
+    
+  nabl-extend-uri-anonymous(|table, partition):
+    uri -> <nabl-extend-uri(|Anonymous(unique))> uri
+    where
+      unique := <stable-uri-part(|table, partition)> (partition, uri, \"anonymous\")
+      
+  nabl-extend-uri-subsequent(|table, partition):
+    uri -> <nabl-extend-uri(|Subsequent(unique))> uri
+    where
+      unique := <stable-uri-part(|table, partition)> (partition, uri, \"subsequent\")
+
+  stable-uri-part(|table, partition):
+    key -> $[[partition]/[unique]]
+    where
+      if value := <hashtable-get(|key)> table then
+        unique    := <int-to-string> value;
+        new-value := <inc> value
+      else
+        unique    := \"0\";
+        new-value := 1
+      end;
+      <hashtable-put(|key, new-value)> table
+      
+rules // Projections
+  
+  nabl-uri = 
+    nabl-uri-impl <+ nabl-uri-generic
+    
+  nabl-value = 
+    nabl-value-impl <+ nabl-value-generic
+  
+  nabl-uri-language:
+    URI(language, _) -> language
+    
+  nabl-uri-language-name:
+    URI(Language(name), _) -> name
+    
+  nabl-uri-path:
+    URI(_, path) -> path
+    
+  nabl-uri-parent:
+    URI(language, path) -> URI(language, parent)
+    where
+      [_|parent] := path
+  
+  nabl-uri-parent(|targetNamespace):
+    URI(language, path) -> URI(language, parent')
+    where
+      [_|parent] := path;
+      if [segment|_] := parent; namespace := <nabl-segment-namespace> segment then
+        if <nabl-scopes> (namespace, targetNamespace) then
+          parent' := parent
+        else
+          parent' := <nabl-uri-parent(|targetNamespace)> parent
+        end
+      else
+        parent' := parent
+      end
+      
+  nabl-uri-name:
+    uri -> <nabl-uri-path; Hd; nabl-segment-name> uri
+    
+  nabl-uri-namespace:
+    uri -> <nabl-uri-path; Hd; nabl-segment-namespace> uri    
+
+  nabl-uri-qualifier:
+    uri -> <nabl-uri-path; Hd; nabl-segment-qualifier> uri
+      
+  nabl-segment-namespace:
+    ID(namespace, _, _) -> namespace
+    
+  nabl-segment-name:
+    ID(_, name, _) -> name
+    
+  nabl-segment-qualifier:
+    ID(_, _, qualifier) -> qualifier
+    
+  nabl-uri-scope      = URI(id, Tl)
+  nabl-uri-scopes    = nabl-closure(nabl-uri-scope)
+  
+  nabl-uri-in-scope  = URI(id, [id|Tl])
+  nabl-uri-in-scopes = nabl-closure(nabl-uri-in-scope)
+  
+  nabl-closure(s) = 
+      s 
+    < ![<id>|<nabl-closure(s)>] 
+    + ![]
+
+rules // Conditions
+  
+  nabl-is-unique =
+    nabl-uri-qualifier;
+    ?Unique(_)
+    
+  nabl-is-nonunique =
+    nabl-uri-qualifier;
+    ?NonUnique()
+
+rules // Equality
+  
+  nabl-uri-eq = 
+    ?(URI(lang1, segs1), URI(lang2, segs2));
+    <eq> (lang1, lang2);
+    <zip(nabl-uri-segment-eq)> (segs1, segs2)
+    
+  nabl-uri-segment-eq =
+    ?(ID(ns1, name1, _), ID(ns2, name2, _));
+    <eq> (ns1, ns2);
+    <eq> (name1, name2)
+     
+  nabl-uri-segment-eq =
+    ?(Subsequent(_), Subsequent(_))
+    
+  nabl-uri-segment-eq =
+    ?(Anonymous(_), Anonymous(_))
+    
+  nabl-uri-segment-eq =
+    ?(ExternalDef(_), ExternalDef(_))
+
+rules // Printing
+  
+  nabl-print-uri:
+    uri -> $[[ns] [names]]
+    where
+      ns#(_) := <nabl-uri-namespace> uri;
+      names  := <nabl-uri-path; filter(nabl-segment-name); separate-by(|\".\"); concat-strings> uri
+        
+rules /** @internal Projections */
+
+  /** @internal */
+  nabl-uri-impl:
+    URI(_, _) -> <id>
+
+  /** @internal */
+  nabl-uri-generic:
+    term -> <?_#(<?[<id>|_]>)> term
+    
+  /** @internal */
+  nabl-value-impl:
+    URI(_, _) -> <id>
+    
+  /** @internal */
+  nabl-value-generic:
+    term -> <?_#(<?[_, <id>|_]> )> term
+    
+  /** @internal */  
+  nabl-uri-impl:
+    _{anno*} -> <fetch-elem(nabl-uri)> anno*
+
+  /** @internal */  
+  nabl-value-impl:
+    _{anno*} -> <fetch-elem(nabl-value)> anno*
+
+"
+
+  create-nbl-utils = 
+    <output-text-file(|["lib", "nbl"], "utils.str")>
+"module nbl/utils
+
+rules 
+  
+  match(m|val) = where (!val; m)
+  
+  vdebug(s) = where(verbose < debug(s) + id)
+  verbose   = fail
+
+  force-origins(s) =
+    ![<id>]; all(s); ?[<id>]
+
+  fix-completion-name:
+    \"completion123\" -> \"\"
+
+  add-annotation(|a):
+    t{a*} -> t{a, a*}
+
+  remove-annotations(s):
+    t{a*} -> t{a'*}
+    where
+      a'* := <remove-all(s)> a*
+  
+  measure-time(s, log) =
+    where(before := <times>);
+    s;
+    where(after := <times>; !(after, before); diff-times; times-to-seconds; Fst; log)
+  
+  measure-time(s, log | name) = 
+    measure-time(s, record-time-native(|name); log)
+    
+  external record-time-native(|name)
+    
+    
+"
+
+  create-task-core = 
+    <output-text-file(|["lib", "task"], "core.str")>
+"module task/core
+
+imports 
+  
+  task/interface
+  
+signature
+
+  sorts
+  
+    Result Instruction
+  
+  constructors
+    
+    Result : Int -> Result
+    Fail : Result
+    
+    Dependency : List(Int) -> Result
+    
+    Error   : Term -> Result
+    Warning : Term -> Result
+    Note    : Term -> Result
+    
+rules // Creation
+  
+  new-task(|partition) = new-task(|partition, <dependent-tasks>)
+  new-task(|partition, dependencies) = desugar-task(|partition) <+ task-add-task(|partition, dependencies, <id>)
+      
+  dependent-tasks = collect-all(dependent-task, union); flatten-list; make-set
+  dependent-task = ?Result(<id>) 
+  dependent-task =
+    has-annos; get-annos; dependent-tasks
+
+rules // Dependencies
+  
+  task-create-dependencies =
+    collect-all(?Result(<id>));
+    !Dependency(<id>)
+    
+  task-has-dependencies =
+    fetch(?Dependency(_))
+    
+  task-collect-dependencies =
+    collect-all(?Dependency(<id>));
+    concat;
+    where(Hd);
+    !Dependency(<id>)
+
+rules // Results
+  
+  insert-results-with-fail =
+    switch id
+      case has-annos  : !(<id>, <get-annos; insert-results-with-fail>); set-annos
+      case is-list    : filter(insert-results-with-fail; not(?[]))
+      case ?Result(n) : (task-api-get-result(|n) <+ (task-api-has-failed(|n); ![]) <+ with(fail|\"Cannot insert result: \"))
+      otherwise       : all(insert-results-with-fail)
+    end
+  
+  insert-results =
+    switch id
+      case has-annos  : !(<id>, <get-annos; insert-results>); set-annos
+      case is-list    : map(insert-results); remove-all(?[])
+      case ?Result(n) : task-api-get-result(|n) <+ (task-api-has-failed(|n); ![])
+      otherwise       : all(insert-results)
+    end
+    
+  insert-results-or-create-dependency =
+    switch id
+      case has-annos  : !(<id>, <get-annos; insert-results-or-create-dependency>); set-annos
+      case is-list    : map(insert-results-or-create-dependency); remove-all(?[])
+      case ?Result(n) : task-api-get-result(|n) <+ (task-api-has-failed(|n); ![]) <+ !Dependency([n])
+      otherwise       : all(insert-results-or-create-dependency)
+    end
+  
+rules // Projections
+  
+  task-result-id:
+    Result(taskID) -> taskID
+
+rules // API
+  
+  task-setup(|project-path)                            = task-api-setup(|project-path)
+  task-start-collection(|partition)                    = task-api-start-collection(|partition)
+  task-stop-collection(|partition)                     = task-api-stop-collection(|partition)
+  task-add-task(|partition, dependencies, instruction) = task-api-add-task(|partition, dependencies, instruction)
+  task-evaluate(|changed-read*)                        = task-api-evaluate(perform-task, insert-results-with-fail|changed-read*)
+  task-reset                                           = task-api-reset
+  task-persist                                         = task-api-persist
+  task-unload(|project-path)                           = task-api-unload(|project-path)
+  
+  task-get-result =
+    switch id
+      case ?Result(taskID) : task-api-get-result(|taskID)
+      otherwise            : task-api-get-result(|<id>)
+    end
+  
+  task-has-failed =
+    switch id
+      case ?Result(taskID) : task-api-has-failed(|taskID)
+      otherwise            : task-api-has-failed(|<id>)
+    end
+    
+  task-get-solved =
+    switch id
+      case ?Result(taskID) : task-api-get-result(|taskID) <+ (task-api-has-failed(|taskID); ![])
+      otherwise            : task-api-has-failed(|<id>) <+ (task-api-has-failed(|<id>); ![])
+    end
+        
+  task-add-read(|taskID):
+    read -> <task-api-add-read(|taskID, read)>
+
+rules /** @internal API externals */
+
+  external task-api-setup(|project-path)
+  external task-api-start-collection(|partition)
+  external task-api-stop-collection(|partition)
+  external task-api-add-task(|partition, dependencies, instruction)
+  external task-api-get-result(|taskID)
+  external task-api-has-failed(|taskID)
+  external task-api-add-read(|taskID, read)
+  external task-api-evaluate(perform-task, insert-result|changed-reads)
+  external task-api-reset(|)
+  external task-api-persist(|)
+  external task-api-unload(|project-path)
+
+"
+
+  create-task-interface = 
+    <output-text-file(|["lib", "task"], "interface.str")>
+"module task/interface
+
+strategies
+  
+  perform-task(|nr) = fail
+  desugar-task(|partition) = fail
+  task-match = fail
+"
+
+  create-task-tasks = 
+    <output-text-file(|["lib", "task"], "tasks.str")>
+"module task/tasks
+
+imports
+  
+  task/core
+  task/interface
+
+signature
+
+  constructors
+    
+    Choice : List(Result)                -> Instruction
+    Choice : List(Result) * List(String) -> Instruction
+    Match  : ID * List(Term) * Term      -> Instruction
+  
+rules
+  
+  perform-task(|nr):
+    Choice(choice*) -> <Hd> choice*
+
+  perform-task(|n):
+    Choice(choice*, error*) -> <Hd> choice*
+
+  perform-task(|nr): 
+    Match(key, bound, term*@<with(is-list|\"Expected a list of terms.\")>) -> result
+    where
+      result := <filter(!(key, <id>, bound); task-match)> term*;
+      if [] := result then
+        fail
+      end
+  
+"
+
+  create-tmpl-pp = 
+    <output-text-file(|["lib", "tmpl"], "pp.str")>
+"module pp
+
+imports
+  libstratego-lib
+  libstratego-gpp
+
+signature constructors
+
+  Parenthetical : Unknown -> Unknown
+
+strategies
+
+  // Unwrap Parenthetical/1 if pp fails, in case the user is using
+  // parenthesize, but grammar does not contain {bracket} production.
+  pp-one(pp) = (pp <+ ?Parenthetical(<pp>)); filter(gpp-is-real-vbox)
+
+  pp-one-V(pp) = pp-one(pp); (?[] <+ !V([], <id>))
+  pp-one-Z(pp) = pp-one(pp); (?[] <+ !Z([], <id>))
+
+  pp-option(pp) = \\None() -> []\\ + ?Some(<pp>)
+
+  pp-V-list(pp)    = ?[] <+ !V([], <map(pp-one-V(pp))>)
+  pp-V-list(pp|vs) = ?[] <+ !V([SOpt(VS(), vs)], <map(pp-one-V(pp))>)
+
+  pp-indent(|is) = filter(gpp-is-real-vbox); (?[] <+ !I([SOpt(IS(), is)], H([SOpt(HS(), \"0\")], <id>)))
+
+  pp-H-list(pp)     = ?[] <+ !H([], <map(pp-one-Z(pp))>)
+  pp-H-list(pp|sep) = ?[] <+ !H([SOpt(HS(), \"0\")], <map(pp-one-Z(pp)); separate-by(|S(sep))>)
+
+  pp-HV-list(pp)     = ?[] <+ !HV([SOpt(HS(), \"0\")], <map(pp-one-Z(pp))>)
+  pp-HV-list(pp|sep) = ?[] <+ !HV([SOpt(HS(), \"0\")], <map(pp-one-Z(pp)); separate-by(|S(sep))>)
+
+  pp-HZ-list(pp)     = ?[] <+ !HZ([SOpt(HS(), \"0\")], <map(pp-one-Z(pp))>)
+  pp-HZ-list(pp|sep) = ?[] <+ !HZ([SOpt(HS(), \"0\")], <map(pp-one-Z(pp)); separate-by(|S(sep))>)
+"
+
+  create-types-interface = 
+    <output-text-file(|["lib", "types"], "interface.str")>
+"module types/interface
+
+strategies
+  
+  type-task(|partition) = fail
+
+"
+
+  create-types-tasks = 
+    <output-text-file(|["lib", "types"], "tasks.str")>
+"module types/tasks
+
+imports 
+  
+  nbl/resolve
+  nbl/collect
+  nbl/query
+  types/interface
+  
+signature
+  
+  constructors
+
+    PropLookup : Property * Term -> Instruction    
+    PropCalc   : Term * Term     -> Instruction
+    PropCheck  : Term * Term     -> Instruction
+
+rules
+  
+  perform-task(|n): PropLookup(kind, t) -> <nabl-collect-one-resolved-def; nabl-get-property(|kind)> t
+  perform-task(|n): PropCalc(p, check*) -> p where <Hd> check*
+  perform-task(|n): PropCheck(p1, p2)   -> <eq; !p1> (p1, p2)
+  
+  desugar-task(|partition): PropCalc(Type(), t) -> <type-task(|partition)> t
+"
+
+create-all-runtime-libraries = 
+  create-analysis-core
+;   create-analysis-debug
+;   create-analysis-multiple
+;   create-analysis-single
+;   create-index-core
+;   create-index-globals
+;   create-index-partition
+;   create-index-query
+;   create-nbl-check
+;   create-nbl-collect
+;   create-nbl-complete
+;   create-nbl-constraints
+;   create-nbl-entries
+;   create-nbl-interface
+;   create-nbl-lookup
+;   create-nbl-query
+;   create-nbl-resolve
+;   create-nbl-tasks
+;   create-nbl-uri
+;   create-nbl-utils
+;   create-task-core
+;   create-task-interface
+;   create-task-tasks
+;   create-tmpl-pp
+;   create-types-interface
+;   create-types-tasks

From g.h.wachsmuth at tudelft.nl  Wed Apr 24 16:24:24 2013
From: g.h.wachsmuth at tudelft.nl (Guido Wachsmuth)
Date: Wed, 24 Apr 2013 14:24:24 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26066 - in
	spoofax-imp/branches/nbl-dev: syntax trans/generation2
Message-ID: <20130424142424.AF32DCC26B@mx4.tudelft.nl>

Author: GuidoWachsmuth
Date: Wed Apr 24 14:24:24 2013
New Revision: 26066
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26066&sc=1

Log:
finished generator for use-sites

Modified:
   spoofax-imp/branches/nbl-dev/syntax/NaBL.tmpl
   spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.generated.pp
   spoofax-imp/branches/nbl-dev/trans/generation2/constraints.str
   spoofax-imp/branches/nbl-dev/trans/generation2/main.str
   spoofax-imp/branches/nbl-dev/trans/generation2/prop-sites.str
   spoofax-imp/branches/nbl-dev/trans/generation2/rules.str
   spoofax-imp/branches/nbl-dev/trans/generation2/use-sites.str

Modified: spoofax-imp/branches/nbl-dev/syntax/NaBL.tmpl
==============================================================================
--- spoofax-imp/branches/nbl-dev/syntax/NaBL.tmpl	Wed Apr 24 14:07:33 2013	(r26065)
+++ spoofax-imp/branches/nbl-dev/syntax/NaBL.tmpl	Wed Apr 24 14:24:24 2013	(r26066)
@@ -80,10 +80,10 @@
   > 
   
   ImportClausePart.SingleImport = <
-  imports <Disambiguator> <NamespaceRef> <Term> <PropertyPattern*> <FromScope> <Alias> <IntoScopes> <Constraint*>>             
+  imports <Disambiguator> <NamespaceRef> <Term> <PropertyPattern*> <FromRefScope> <Alias> <IntoDefScopes> <Constraint*>>             
 
   ImportClausePart.WildcardImport = <
-  imports <ImportRef+; separator=", "> <PropertyPattern*> <FromScope> <IntoScopes> <Constraint*>> 
+  imports <ImportRef+; separator=", "> <PropertyPattern*> <FromRefScope> <IntoDefScopes> <Constraint*>> 
   
   Alias.None  = <>
   Alias.Alias = <<Term>>
@@ -93,22 +93,22 @@
    
 templates // scopes
 
-  InDefScopes.Current = <>
-  InDefScopes         = <in <DefScopes>>   {bracket}
+  InDefScopes.Current   = <>
+  InDefScopes           = <in <DefScopes>>   {bracket}
   
-  InRefScope.Current  = <>
-  InRefScope          = <in <RefScope>>    {bracket}
-  
-  FromScope.Current   = <>
-  FromScope           = <from <RefScope>>  {bracket}
-  
-  IntoScopes.Current  = <>
-  IntoScopes          = <into <DefScopes>> {bracket}
+  IntoDefScopes.Current = <>
+  IntoDefScopes         = <into <DefScopes>> {bracket}
+
+  DefScopes.Current     = <current scope>
+  DefScopes.DefScopes   = <<DefScope+; separator=", ">> 
+  DefScope.Subsequent   = <subsequent scope>
+  DefScope.Context      = <<Term>>
  
-  DefScopes.Current   = <current scope>
-  DefScopes.DefScopes = <<DefScope+; separator=", ">> 
-  DefScope.Subsequent = <subsequent scope>
-  DefScope.Context    = <<Term>>
+  InRefScope.Current    = <>
+  InRefScope            = <in <RefScope>>    {bracket}
+  
+  FromRefScope.Current  = <>
+  FromRefScope          = <from <RefScope>>  {bracket}
   
   RefScope.Current    = <current scope>
   RefScope.Enclosing  = <enclosing <NamespaceRef>>
@@ -121,4 +121,8 @@
 
   Constraint.Reference = <
     where <Term> refers to <NamespaceRef> <Pattern> <PropertyPattern*> <InRefScope>> 
+  
+context-free syntax
+
+  Id = "into" {reject}
   
\ No newline at end of file

Modified: spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.generated.pp
==============================================================================
--- spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.generated.pp	Wed Apr 24 14:07:33 2013	(r26065)
+++ spoofax-imp/branches/nbl-dev/syntax/NameBindingLanguage.generated.pp	Wed Apr 24 14:24:24 2013	(r26066)
@@ -68,13 +68,13 @@
    COMPLETION-ImportRef                                   -- _1,
    Current                                                -- ,
    Current                                                -- ,
-   Current                                                -- ,
-   Current                                                -- ,
    Current                                                -- KW["current"] KW["scope"],
    DefScopes                                              -- _1,
    DefScopes.1:iter-sep                                   -- _1 KW[","],
    Subsequent                                             -- KW["subsequent"] KW["scope"],
    Context                                                -- _1,
+   Current                                                -- ,
+   Current                                                -- ,
    Current                                                -- KW["current"] KW["scope"],
    Enclosing                                              -- KW["enclosing"] _1,
    Context                                                -- _1 _2 _3 _4 _5,
@@ -82,11 +82,11 @@
    All                                                    -- ,
    Best                                                   -- KW["best"],
    COMPLETION-InDefScopes                                 -- _1,
-   COMPLETION-InRefScope                                  -- _1,
-   COMPLETION-FromScope                                   -- _1,
-   COMPLETION-IntoScopes                                  -- _1,
+   COMPLETION-IntoDefScopes                               -- _1,
    COMPLETION-DefScopes                                   -- _1,
    COMPLETION-DefScope                                    -- _1,
+   COMPLETION-InRefScope                                  -- _1,
+   COMPLETION-FromRefScope                                -- _1,
    COMPLETION-RefScope                                    -- _1,
    COMPLETION-Disambiguator                               -- _1,
    Reference                                              -- KW["where"] _1 KW["refers"] KW["to"] _2 _3 _4 _5,

Modified: spoofax-imp/branches/nbl-dev/trans/generation2/constraints.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation2/constraints.str	Wed Apr 24 14:07:33 2013	(r26065)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/constraints.str	Wed Apr 24 14:24:24 2013	(r26066)
@@ -13,22 +13,20 @@
     ([], repl*) -> ([], repl*)
    	  
   constraints-to-tasks(|bound*, i, j):
-    ([c at PropertyConstraint(term, kind, prop)|cs], repl*) -> ([task, match-task*, task*], r*)
+    ([PropertyConstraint(term, kind, prop)|cs], repl*) -> ([task, match-task*, task*], r*)
     where
       k           := <extend-index(|i)> j
     ; result      := <result-var> k
     ; task        := PROP_TASK(result, <nabl-to-str> kind, <replace-all(|repl*)> term)
-
     ; bind*       := <bound-vars> prop
     ; match*      := <isect; replace-all(|repl*)> (bind*, bound*)
-    ; match-repl* := <map-with-index(match-replace(|k))> bind*
-      
-    ; match-task* := <
-        if <unbound-var(|bound*)> prop then
-          ![]
-        else
-          <map-with-index(match-task(|k, result, match*))> match-repl*
-        end>
+    ; if <unbound-var(|bound*)> prop then
+        match-repl* := [(prop, result)]
+      ; match-task* := [] 
+      else
+        match-repl* := <map-with-index(match-replace(|k))> bind*
+      ; match-task* := <map-with-index(match-task(|k, result, match*))> match-repl*
+      end
     ; (task*, r*) := <constraints-to-tasks(|<union> (bound*, bind*), i, <inc> j)> (cs, [match-repl*, repl*])
             
   unbound-var(|bound*) =

Modified: spoofax-imp/branches/nbl-dev/trans/generation2/main.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation2/main.str	Wed Apr 24 14:07:33 2013	(r26065)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/main.str	Wed Apr 24 14:24:24 2013	(r26066)
@@ -12,12 +12,13 @@
   generate-name-analysis:
     (selected, position, ast at Module(name, _, _), path, project-path) -> (filename, result)
     with
-      filename   := <guarantee-extension(|"str")> path ;
-      str-module := <to-ppable-str; nabl-to-str> ast ;
-      // use next line to debug which AST node cannot be handled by the pretty-printer
-      // <bottomup(try(not(is-string) ; not(is-list) ; not(pp-stratego-string) ; debug(!"cannot pp ")))> str-module ;
-      result     := <pp-stratego-string> str-module
-
+      filename   := <guarantee-extension(|"str")> path
+    ; str-module := <to-ppable-str; nabl-to-str> ast
+    with
+       result := <pp-stratego-string> str-module
+    <+ <bottomup(try(not(is-string) ; not(is-list) ; not(pp-stratego-string) ; debug(!"cannot pp ")))> str-module
+    ;  result := ""
+      
 rules // modules
   
   to-ppable-str = alltd(to-ppable-str-local)

Modified: spoofax-imp/branches/nbl-dev/trans/generation2/prop-sites.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation2/prop-sites.str	Wed Apr 24 14:07:33 2013	(r26065)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/prop-sites.str	Wed Apr 24 14:24:24 2013	(r26066)
@@ -16,30 +16,35 @@
 
   pdebug(s) = id
   
-  clauses-to-prop-rules(|pattern, constr*, implicit*, i):
+  clauses-to-prop-rules(|pattern, bound*, repl*, task*, implicit*, i):
     def-clause* -> result
     where 
-       (rule*, prop-clause*) := <filter-with-index(clause-to-prop-clauses(|pattern, constr*, i)); unzip; (concat, concat)>
-    ;  match*   := <![Assign(LIST(<nonempty>), Var("implicits__"))] <+ ![]> implicit*
-    ;  prop-seq := <to-seq> [match*, prop-clause*]
-    ;  result   := [rule*,  PROP_RULE(Seq(Match(pattern), prop-seq))]
-    <+ result   := []
+       prop-clause* := <filter-with-index(clause-to-prop-clauses(|pattern, bound*, repl*, i)); concat> def-clause*
+    ;  match*       := <![Assign(LIST(<nonempty>), Var("implicits__"))] <+ ![]> implicit*
+    ;  prop-seq     := <to-seq> [match*, task*, prop-clause*]
+    ;  result       := [PROP_RULE(Seq(Match(pattern), prop-seq))]
+    <+ result       := []
     
-  clause-to-prop-clauses(|pattern, glob-constr*, i):
-    (o, DefClause(kind, _, ns, term, prop*, _, constr*)) -> (match-rule*, [task*, cong])
+  clause-to-prop-clauses(|pattern, bound*, glob-repl*, i):
+    (j, DefClause(kind, _, ns, term, prop*, _, constr*)) -> [task*, cong]
     where
       <nonempty> prop*
-    ; ns-term     := <ns-to-term> ns
-    ; patt-bound* := <bound-vars> pattern
-    ; (task*, loc-replacement*) 
-                  := <constraints-to-tasks(|patt-bound*, <extend-index(|o)> i, 1)> ([glob-constr*, constr*], [])
-    ; prop-call   := PROP_CALL(<replace-all(|loc-replacement*); map(prop-to-str)> prop*)
-    ; if impl-var := <implicit-def-var(|o)> kind then
+    ; ns-term        := <ns-to-term> ns
+    ; k              := <extend-index(|i)> j
+    ; (task*, repl*) := <constraints-to-tasks(|bound*, k, 1)> (constr*, glob-repl*)
+    ; prop-call      := PROP_CALL(<replace-all(|repl*); map(prop-to-str)> prop*)
+    ; if impl-var := <implicit-def-var(|j)> kind then
         cong := Where(App(prop-call, impl-var))
       else
         cong := <replace-all-id(|[(term, prop-call)])> pattern
       end
-    ; match-rule* := <constraints-to-match-rules(|patt-bound*, <extend-index(|o)> i, 1)> [glob-constr*, constr*]
+   
+  clause-to-match-rules(|bound*, i):
+    (j, DefClause(kind, _, ns, term, prop*, _, constr*)) -> rule*
+    where
+      <nonempty> prop*
+    ; k      := <extend-index(|i)> j
+    ; rule*  := <constraints-to-match-rules(|bound*, k, 1)> constr*
        
 rules
          

Modified: spoofax-imp/branches/nbl-dev/trans/generation2/rules.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation2/rules.str	Wed Apr 24 14:07:33 2013	(r26065)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/rules.str	Wed Apr 24 14:24:24 2013	(r26066)
@@ -15,35 +15,21 @@
 rules
   
   nabl-to-str: 
-    (i, BindingRule(pattern, constr*, clause*)) -> [name-rule*, def-rule*, prop-rule*]
+    (i, BindingRule(pattern, constr*, clause*)) -> [name-rule*, def-rule*, prop-rule*, use-rule*, match-rule*]
     where 
        [t]        := <filter(def-to-name <+ use-to-name)> clause*
     ;  name-rule* := [NAME_RULE(pattern, t)]
     <+ name-rule* := []
     where
-      // collect bound variables
       bound*      := <bound-vars> pattern
-      // collect vertical scopes
     ; scope*      := <filter(?ScopeClause(<map(ns-to-term)>)); concat> clause*
     ; def-clause* := <filter(?DefClause(_, _, _, _, _, _, _))> clause*
+    ; implicit*   := <implicit-def-vars> def-clause*
     where
-    // translate def clauses
-      implicit*  := <implicit-def-vars> def-clause*
-    ; def-rule*  := <clauses-to-def-rules(|pattern, scope*, implicit*)> def-clause*
-    ; prop-rule* := <clauses-to-prop-rules(|pattern, constr*, implicit*, i)> def-clause*
-             
-overlays
+      def-rule*      := <clauses-to-def-rules(|pattern, scope*, implicit*)> def-clause*
+    ; (task*, repl*) := <constraints-to-tasks(|bound*, i, 0)> (constr*, [])
+    ; prop-rule*     := <clauses-to-prop-rules(|pattern, bound*, repl*, task*, implicit*, i)> def-clause*
+    ; use-rule*      := <clauses-to-use-rules(|pattern, bound*, repl*, task*, i)> clause*
+    ; match-rule*    := <filter-with-index(clause-to-match-rules(|bound*, i)); concat> clause*
+    
 	
-	ANONYMOUS_CALL(scopes) =
-  CallT(
-    SVar("nabl-anonymous-scope")
-  , [Match(Var("child-uris__"))]
-  , [ Var("lang__")
-    , Var("partition__")
-    , Var("uniques__")
-    , Var("uris__")
-    , LIST(scopes) ]
-  )
-  
-  
-  	

Modified: spoofax-imp/branches/nbl-dev/trans/generation2/use-sites.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation2/use-sites.str	Wed Apr 24 14:07:33 2013	(r26065)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/use-sites.str	Wed Apr 24 14:24:24 2013	(r26066)
@@ -6,10 +6,9 @@
   include/NameBindingLanguage
   
   generation2/util
-  generation2/main
+  generation2/sections
+  generation2/prop-sites
   generation2/constraints
-  generation2/rules
-  generation2/scopes
   
 rules
   
@@ -19,72 +18,59 @@
   + ?SingleImport(_, _, <id>, _, _, _, _, _)
   + ?WildcardImport(_, _, Context(_, _, <id>, _, _), _, _)
     
-  // clause-to-str(|pattern, scopes, repl*, bound*, n):
-  //   ImportClause(import*) -> <clauses-to-str(|pattern, scopes, repl*, bound*, n)> import*
-  //   
-  // clause-to-str(|pattern, scopes, repl*, bound*, n):
-  //   SingleImport(_, ns, t, ps, fsc, alias, isc, constr*) -> (r*, [sc*, dcall], pr*, k)
-  //   where
-  //     ns' := <nabl-to-str> ns
-  //   ; (r*, sc*, isc', m) := <scope-to-str(|ns', n)> isc
-  //   ; dcall := <replace-all-id(|r*)> pattern
-  //   ; b*    := <collect-all(?Var(_))> t
-  //   ; (r2*, b3*, rule*, pr*, k) := <constraints-to-str(|repl*, [bound*, b*], m)> constr*
-  // 
-  // clause-to-str(|pattern, scopes, repl*, bound*, n):
-  //   WildcardImport(ns, ps, fsc, isc, constr*) -> (r*, [sc*, dcall], pr*, k)
-  //   where
-  //     ns' := <nabl-to-str> ns
-  //   ; (r*, sc*, isc', m) := <scope-to-str(|ns', n)> isc
-  //   ; dcall := <replace-all-id(|r*)> pattern
-  //   ; (r2*, b3*, rule*, pr*, k) := <constraints-to-str(|repl*, bound*, m)> constr*
-  //   
-// rules
-//   
-//   uses-to-str(|replace*, bound*, rule*, task*, pattern) =
-//     filter(?RefClause(<id>) + ?ImportClause(<id>));
-//     if nonempty then
-//       (rep*, task'*) := <foldl(use-to-str(|replace*, bound*, rule*))> (<id>, ([], task*));
-//       ubody  := <foldr(<replace-all(|rep*)> pattern, to-seq)> task'* ;
-//       <iset-add(|USE_RULE(Seq(Match(pattern), ubody)))> rule*
-//     end
-//   
-//   use-to-str(|replace*, bound*, rule*):
-//     (u, (r*, task*)) -> ([(t, USE_CALL(c*)), r*], task'*)
-//     where 
-//       t            := <use-to-name> u;
-//       (c*, task'*) := <foldl(id; (ref-to-str(|replace*, bound*, rule*) <+ Snd))> (u, ([], task*))
-//     
-//   ref-to-str(|replace*, bound*, rule*): 
-//     (c, (c*, task*)) -> ([c*, CANDIDATE(<nabl-to-str> ns, prop'*)], task'*)
-//     where
-//       < ?RefClausePart(_, ns, _, prop*, Current(), constr*)
-//       + ?SingleImport(_, ns, _, prop*, Current(), _, _, constr*)
-//       + ?WildcardImport(_, _, Context(_, ns, _, prop*, Current()), _, constr*)
-//       > c
-//     where
-//       replace2* := <hashtable-copy> replace*;
-//       bound2*   := <iset-copy> bound*;
-//       task'*    := <constraints-to-str(|replace2*, bound2*, rule*, task*)> constr*;
-//       prop'*    := <map(prop-to-str); alltd(replace(|replace2*))> prop*;
-//       <hashtable-destroy> replace2*;
-//       <iset-destroy> bound2*
-//       
-//   ref-to-str(|replace*, bound*, rule*): 
-//     (c, (c*, task*)) -> ([c*, CANDIDATE(<nabl-to-str> ns, <nabl-to-str> ns', t', prop'*)], task'*)
-//     where
-//       <?RefClausePart(_, ns, _, prop*, Context(_, ns', t, _, _), constr*)> c
-//     where
-//       replace2* := <hashtable-copy> replace*;
-//       bound2*   := <iset-copy> bound*;
-//       task'*    := <constraints-to-str(|replace2*, bound2*, rule*, task*)> constr*;
-//       prop'*    := <map(prop-to-str); alltd(replace(|replace2*))> prop*;
-//       t'        := <alltd(replace(|replace2*))> t;
-//       <hashtable-destroy> replace2*;
-//       <iset-destroy> bound2*
-//      
-//   prop-to-str:
-//     PropertyPattern(_, p, t) -> PROPERTY(<nabl-to-str> p, t)
+  clauses-to-use-rules(|pattern, bound*, repl*, task*, i):
+    use-clause* -> result
+    where 
+       clause* := <filter-with-index(clause-to-use-clauses(|pattern, bound*, repl*, i)); concat; nonempty> use-clause*
+    ;  use-seq := <to-seq> [Match(pattern), task*, clause*]
+    ;  result  := [USE_RULE(use-seq)]
+    <+ result  := []
+    
+  clause-to-use-clauses(|pattern, bound*, repl*, i):
+    (j, RefClause(part*)) -> [clause*, cong]
+    where
+      k        := <extend-index(|i)> j
+    ; (clause*, candidate*) 
+               := <filter-with-index(part-to-candidate(|pattern, bound*, repl*, k)); unzip; (concat, id)> part*
+    ; term     := <fetch-elem(?RefClausePart(_, _, <id>, _, _, _))> part*
+    ; use-call := USE_CALL(candidate*)
+    ; cong     := <replace-all-id(|[(term, use-call)])> pattern
+  
+  part-to-candidate(|pattern, bound*, glob-repl*, i):
+    (j, RefClausePart(disamb, ns, term, prop*, ctx, constr*)) -> (task*, CANDIDATE(ns-term, prop-term*, ctx-term))
+    where
+      ns-term        := <ns-to-term> ns
+    ; k              := <extend-index(|i)> j
+    ; (task*, repl*) := <constraints-to-tasks(|bound*, k, 1)> (constr*, glob-repl*)
+    ; prop-term*     := <map(prop-to-str; replace-all(|repl*))> prop*
+    ; ctx-term       := <context-to-term(|repl*)> ctx
+  
+  context-to-term(|repl*):
+  	Current() -> TERM("Current")
+  	
+  context-to-term(|repl*):
+    Enclosing(ns) -> TERM("Enclosing", [<ns-to-term> ns])
+    
+  context-to-term(|repl*):
+    Context(disamb, ns, term, prop*, ctx) -> TERM("Context", [ns-term, prop-term*, ctx-term])
+    where
+      ns-term        := <ns-to-term> ns
+    ; prop-term*     := <map(prop-to-str; replace-all(|repl*))> prop*
+    ; ctx-term       := <context-to-term(|repl*)> ctx
+    
+      
+  clause-to-match-rules(|bound*, i):
+    (j, RefClause(part*)) -> rule*
+    where
+      k      := <extend-index(|i)> j
+    ; rule*  := <map-with-index(part-to-match-rules(|bound*, k)); concat> part*
+  
+  part-to-match-rules(|bound*, i):
+    (j, RefClausePart(disamb, ns, term, prop*, scope, constr*)) -> rule*
+    where
+      k     := <extend-index(|i)> j
+    ; rule* := <constraints-to-match-rules(|bound*, k, 1)> constr*
+      
 
 overlays
      
@@ -113,9 +99,6 @@
     ] 
   )
   
-  CANDIDATE(ns, ps) =
-  TERM("UseCandidate", [ns, LIST(ps), TERM("Current"), TERM("All")])
-
-  CANDIDATE(ns1, ns2, n, ps) =
-  TERM("UseCandidate", [ns1, LIST(ps), LIST([n]), TERM("One")])
+  CANDIDATE(ns, ps, ctx) =
+  TERM("UseCandidate", [ns, LIST(ps), ctx])
   
\ No newline at end of file

From gabrielkonat at gmail.com  Thu Apr 25 16:19:24 2013
From: gabrielkonat at gmail.com (GabriÃ«l Konat)
Date: Thu, 25 Apr 2013 14:19:24 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26067 - in
	spoofax/trunk/spoofax: org.spoofax.interpreter.externaldeps
	org.spoofax.interpreter.externaldeps/.settings
	org.spoofax.interpreter.externaldeps/META-INF org.spo...
Message-ID: <20130425141924.9AEE67F8057@mx1.tudelft.nl>

Author: gkonat
Date: Thu Apr 25 14:19:24 2013
New Revision: 26067
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26067&sc=1

Log:
Removed direct dependencies on guava and junit-benchmarks libraries, added them to the org.spoofax.interpreter.externaldeps plugin.

Added:
   spoofax/trunk/spoofax/org.spoofax.interpreter.externaldeps/
   spoofax/trunk/spoofax/org.spoofax.interpreter.externaldeps/.classpath
   spoofax/trunk/spoofax/org.spoofax.interpreter.externaldeps/.project
   spoofax/trunk/spoofax/org.spoofax.interpreter.externaldeps/.settings/
   spoofax/trunk/spoofax/org.spoofax.interpreter.externaldeps/.settings/org.eclipse.jdt.core.prefs
   spoofax/trunk/spoofax/org.spoofax.interpreter.externaldeps/META-INF/
   spoofax/trunk/spoofax/org.spoofax.interpreter.externaldeps/META-INF/MANIFEST.MF
   spoofax/trunk/spoofax/org.spoofax.interpreter.externaldeps/build.properties
   spoofax/trunk/spoofax/org.spoofax.interpreter.externaldeps/dependencies.xml
Deleted:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/lib/
Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/.classpath
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/META-INF/MANIFEST.MF
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/build.properties
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/performance/IndexAddPerformanceTest.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/performance/IndexClearPerformanceTest.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/performance/IndexGetChildsPerformanceTest.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/performance/IndexGetKeyPartitionsPerformanceTest.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/performance/IndexGetPartitionElementsPerformanceTest.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/performance/IndexGetPartitionsPerformanceTest.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/performance/IndexGetPerformanceTest.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/performance/IndexPersistPerformanceTest.java

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.externaldeps/.classpath
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.externaldeps/.classpath	Thu Apr 25 14:19:24 2013	(r26067)
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry exported="true" kind="lib" path="lib/junit-benchmarks-0.6.0/junit-benchmarks-0.6.0.jar"/>
+	<classpathentry exported="true" kind="lib" path="lib/guava.jar" sourcepath="lib/guava-sources.jar">
+		<attributes>
+			<attribute name="javadoc_location" value="jar:platform:/resource/org.spoofax.interpreter.externaldeps/lib/guava-javadoc.jar!/"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.externaldeps/.project
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.externaldeps/.project	Thu Apr 25 14:19:24 2013	(r26067)
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>org.spoofax.interpreter.externaldeps</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.pde.ManifestBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.pde.SchemaBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.pde.PluginNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.externaldeps/.settings/org.eclipse.jdt.core.prefs
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.externaldeps/.settings/org.eclipse.jdt.core.prefs	Thu Apr 25 14:19:24 2013	(r26067)
@@ -0,0 +1,7 @@
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.7
+org.eclipse.jdt.core.compiler.compliance=1.7
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.source=1.7

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.externaldeps/META-INF/MANIFEST.MF
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.externaldeps/META-INF/MANIFEST.MF	Thu Apr 25 14:19:24 2013	(r26067)
@@ -0,0 +1,25 @@
+Manifest-Version: 1.0
+Bundle-ManifestVersion: 2
+Bundle-Name: org.spoofax.interpreter.externaldeps
+Bundle-SymbolicName: org.spoofax.interpreter.externaldeps
+Bundle-Version: 1.0.0
+Bundle-ClassPath: lib/guava.jar,
+ lib/junit-benchmarks-0.6.0/junit-benchmarks-0.6.0.jar
+Export-Package: com.carrotsearch.junitbenchmarks,
+ com.carrotsearch.junitbenchmarks.annotation,
+ com.carrotsearch.junitbenchmarks.db,
+ com.carrotsearch.junitbenchmarks.h2,
+ com.carrotsearch.junitbenchmarks.mysql,
+ com.google.common.annotations,
+ com.google.common.base,
+ com.google.common.base.internal,
+ com.google.common.cache,
+ com.google.common.collect,
+ com.google.common.eventbus,
+ com.google.common.hash,
+ com.google.common.io,
+ com.google.common.math,
+ com.google.common.net,
+ com.google.common.primitives,
+ com.google.common.reflect,
+ com.google.common.util.concurrent

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.externaldeps/build.properties
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.externaldeps/build.properties	Thu Apr 25 14:19:24 2013	(r26067)
@@ -0,0 +1,3 @@
+bin.includes = META-INF/,\
+               lib/guava.jar,\
+               lib/junit-benchmarks-0.6.0/junit-benchmarks-0.6.0.jar

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.externaldeps/dependencies.xml
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.externaldeps/dependencies.xml	Thu Apr 25 14:19:24 2013	(r26067)
@@ -0,0 +1,13 @@
+<project name="dependencies" default="download">
+	<property name="lib.dir" value="lib" />
+
+	<target name="download" description="Download external dependencies">
+		<mkdir dir="${lib.dir}" />
+		<get src="http://search.maven.org/remotecontent?filepath=com/google/guava/guava/14.0.1/guava-14.0.1.jar" dest="${lib.dir}/guava.jar" skipexisting="true" />
+		<get src="http://search.maven.org/remotecontent?filepath=com/google/guava/guava/14.0.1/guava-14.0.1-javadoc.jar" dest="${lib.dir}/guava-javadoc.jar" skipexisting="true" />
+		<get src="http://search.maven.org/remotecontent?filepath=com/google/guava/guava/14.0.1/guava-14.0.1-sources.jar" dest="${lib.dir}/guava-sources.jar" skipexisting="true" />
+		
+		<get src="http://labs.carrotsearch.com/download/junit-benchmarks/0.6.0/junit-benchmarks-0.6.0.zip" dest="${lib.dir}/junit-benchmarks.zip" skipexisting="true" />
+		<unzip src="${lib.dir}/junit-benchmarks.zip" dest="${lib.dir}"/>
+	</target>
+</project>
\ No newline at end of file

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/.classpath
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/.classpath	Wed Apr 24 14:24:24 2013	(r26066)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/.classpath	Thu Apr 25 14:19:24 2013	(r26067)
@@ -1,14 +1,8 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src/main/java"/>
-	<classpathentry kind="src" path="src/test/java"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/J2SE-1.5"/>
-	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
-	<classpathentry kind="lib" path="lib/guava-11.0.2.jar" sourcepath="lib/guava-11.0.1-sources.jar">
-		<attributes>
-			<attribute name="javadoc_location" value="jar:platform:/resource/org.spoofax.interpreter.library.index/lib/guava-11.0.1-javadoc.jar!/"/>
-		</attributes>
-	</classpathentry>
-	<classpathentry kind="lib" path="lib/junit-benchmarks-0.4.0.jar"/>
-	<classpathentry kind="output" path="bin"/>
-</classpath>
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src/main/java"/>
+	<classpathentry kind="src" path="src/test/java"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/J2SE-1.5"/>
+	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/META-INF/MANIFEST.MF
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/META-INF/MANIFEST.MF	Wed Apr 24 14:24:24 2013	(r26066)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/META-INF/MANIFEST.MF	Thu Apr 25 14:19:24 2013	(r26067)
@@ -4,12 +4,11 @@
 Bundle-SymbolicName: org.spoofax.interpreter.library.index
 Bundle-Version: 1.0.0.qualifier
 Bundle-RequiredExecutionEnvironment: J2SE-1.5
-Require-Bundle: org.junit,
- org.junit4,
- org.spoofax.interpreter.core,
+Require-Bundle: org.spoofax.interpreter.core,
  org.spoofax.terms;bundle-version="1.0.0",
- org.spoofax.jsglr;bundle-version="0.3.0"
-Bundle-ClassPath: lib/guava-11.0.2.jar,
- lib/junit-benchmarks-0.4.0.jar,
+ org.spoofax.jsglr;bundle-version="0.3.0",
+ org.junit4,
+ org.spoofax.interpreter.externaldeps;bundle-version="1.0.0"
+Bundle-ClassPath: lib/junit-benchmarks-0.4.0.jar,
  .
 Export-Package: org.spoofax.interpreter.library.index

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/build.properties
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/build.properties	Wed Apr 24 14:24:24 2013	(r26066)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/build.properties	Thu Apr 25 14:19:24 2013	(r26067)
@@ -2,6 +2,5 @@
            src/test/java
 output.. = bin/
 bin.includes = META-INF/,\
-               lib/guava-11.0.2.jar,\
                lib/junit-benchmarks-0.4.0.jar,\
                .

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/performance/IndexAddPerformanceTest.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/performance/IndexAddPerformanceTest.java	Wed Apr 24 14:24:24 2013	(r26066)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/performance/IndexAddPerformanceTest.java	Thu Apr 25 14:19:24 2013	(r26067)
@@ -5,7 +5,6 @@
 
 import org.junit.Rule;
 import org.junit.Test;
-import org.junit.rules.MethodRule;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
@@ -17,7 +16,7 @@
 @RunWith(value = Parameterized.class)
 public class IndexAddPerformanceTest extends IndexPerformanceTest {
     @Rule
-    public MethodRule benchmarkRun;
+    public BenchmarkRule benchmarkRun;
 
     public IndexAddPerformanceTest(int numItems, int numFiles, boolean startTransaction) {
         super(numItems, numFiles, startTransaction);

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/performance/IndexClearPerformanceTest.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/performance/IndexClearPerformanceTest.java	Wed Apr 24 14:24:24 2013	(r26066)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/performance/IndexClearPerformanceTest.java	Thu Apr 25 14:19:24 2013	(r26067)
@@ -5,7 +5,6 @@
 
 import org.junit.Rule;
 import org.junit.Test;
-import org.junit.rules.MethodRule;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
@@ -17,7 +16,7 @@
 @RunWith(value = Parameterized.class)
 public class IndexClearPerformanceTest extends IndexPerformanceTest {
     @Rule
-    public MethodRule benchmarkRun;
+    public BenchmarkRule benchmarkRun;
 
     private int fileIndexToClear;
 

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/performance/IndexGetChildsPerformanceTest.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/performance/IndexGetChildsPerformanceTest.java	Wed Apr 24 14:24:24 2013	(r26066)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/performance/IndexGetChildsPerformanceTest.java	Thu Apr 25 14:19:24 2013	(r26067)
@@ -5,7 +5,6 @@
 
 import org.junit.Rule;
 import org.junit.Test;
-import org.junit.rules.MethodRule;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 import org.spoofax.interpreter.library.index.IIndexEntryIterable;
@@ -18,7 +17,7 @@
 @RunWith(value = Parameterized.class)
 public class IndexGetChildsPerformanceTest extends IndexPerformanceTest {
     @Rule
-    public MethodRule benchmarkRun;
+    public BenchmarkRule benchmarkRun;
 
     private static int NUM_GET = 200000;
 

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/performance/IndexGetKeyPartitionsPerformanceTest.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/performance/IndexGetKeyPartitionsPerformanceTest.java	Wed Apr 24 14:24:24 2013	(r26066)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/performance/IndexGetKeyPartitionsPerformanceTest.java	Thu Apr 25 14:19:24 2013	(r26067)
@@ -6,7 +6,6 @@
 
 import org.junit.Rule;
 import org.junit.Test;
-import org.junit.rules.MethodRule;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 import org.spoofax.interpreter.library.index.IndexPartitionDescriptor;
@@ -19,7 +18,7 @@
 @RunWith(value = Parameterized.class)
 public class IndexGetKeyPartitionsPerformanceTest extends IndexPerformanceTest {
     @Rule
-    public MethodRule benchmarkRun;
+    public BenchmarkRule benchmarkRun;
 
     public IndexGetKeyPartitionsPerformanceTest(int numItems, int numFiles, boolean startTransaction) {
         super(numItems, numFiles, startTransaction);

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/performance/IndexGetPartitionElementsPerformanceTest.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/performance/IndexGetPartitionElementsPerformanceTest.java	Wed Apr 24 14:24:24 2013	(r26066)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/performance/IndexGetPartitionElementsPerformanceTest.java	Thu Apr 25 14:19:24 2013	(r26067)
@@ -5,7 +5,6 @@
 
 import org.junit.Rule;
 import org.junit.Test;
-import org.junit.rules.MethodRule;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 import org.spoofax.interpreter.library.index.IIndexEntryIterable;
@@ -18,7 +17,7 @@
 @RunWith(value = Parameterized.class)
 public class IndexGetPartitionElementsPerformanceTest extends IndexPerformanceTest {
     @Rule
-    public MethodRule benchmarkRun;
+    public BenchmarkRule benchmarkRun;
 
     public IndexGetPartitionElementsPerformanceTest(int numItems, int numFiles, boolean startTransaction) {
         super(numItems, numFiles, startTransaction);

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/performance/IndexGetPartitionsPerformanceTest.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/performance/IndexGetPartitionsPerformanceTest.java	Wed Apr 24 14:24:24 2013	(r26066)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/performance/IndexGetPartitionsPerformanceTest.java	Thu Apr 25 14:19:24 2013	(r26067)
@@ -6,7 +6,6 @@
 
 import org.junit.Rule;
 import org.junit.Test;
-import org.junit.rules.MethodRule;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 import org.spoofax.interpreter.library.index.IndexPartition;
@@ -19,7 +18,7 @@
 @RunWith(value = Parameterized.class)
 public class IndexGetPartitionsPerformanceTest extends IndexPerformanceTest {
     @Rule
-    public MethodRule benchmarkRun;
+    public BenchmarkRule benchmarkRun;
 
     private static int NUM_GET = 200000;
 

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/performance/IndexGetPerformanceTest.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/performance/IndexGetPerformanceTest.java	Wed Apr 24 14:24:24 2013	(r26066)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/performance/IndexGetPerformanceTest.java	Thu Apr 25 14:19:24 2013	(r26067)
@@ -5,7 +5,6 @@
 
 import org.junit.Rule;
 import org.junit.Test;
-import org.junit.rules.MethodRule;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 import org.spoofax.interpreter.library.index.IIndexEntryIterable;
@@ -18,7 +17,7 @@
 @RunWith(value = Parameterized.class)
 public class IndexGetPerformanceTest extends IndexPerformanceTest {
     @Rule
-    public MethodRule benchmarkRun;
+    public BenchmarkRule benchmarkRun;
 
     private static int NUM_GET = 200000;
 

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/performance/IndexPersistPerformanceTest.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/performance/IndexPersistPerformanceTest.java	Wed Apr 24 14:24:24 2013	(r26066)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.index/src/test/java/org/spoofax/interpreter/library/index/tests/performance/IndexPersistPerformanceTest.java	Thu Apr 25 14:19:24 2013	(r26067)
@@ -7,7 +7,6 @@
 
 import org.junit.Rule;
 import org.junit.Test;
-import org.junit.rules.MethodRule;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
@@ -19,7 +18,7 @@
 @RunWith(value = Parameterized.class)
 public class IndexPersistPerformanceTest extends IndexPerformanceTest {
     @Rule
-    public MethodRule benchmarkRun;
+    public BenchmarkRule benchmarkRun;
 
     public IndexPersistPerformanceTest(int numItems, int numFiles, boolean startTransaction) {
         super(numItems, numFiles, startTransaction);

From gabrielkonat at gmail.com  Thu Apr 25 16:36:30 2013
From: gabrielkonat at gmail.com (GabriÃ«l Konat)
Date: Thu, 25 Apr 2013 14:36:30 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26068 - hydra/jobs
	spoofax-imp/trunk/org.strategoxt.imp.feature
	spoofax/trunk/spoofax/org.spoofax.interpreter.externaldeps/META-INF
Message-ID: <20130425143630.13CC62B800C@mx2.tudelft.nl>

Author: gkonat
Date: Thu Apr 25 14:36:29 2013
New Revision: 26068
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26068&sc=1

Log:
Update hydra job for Spoofax to work with new org.spoofax.interpreter.externaldeps plugin

Modified:
   hydra/jobs/spoofax-imp.nix
   spoofax-imp/trunk/org.strategoxt.imp.feature/feature.xml
   spoofax/trunk/spoofax/org.spoofax.interpreter.externaldeps/META-INF/MANIFEST.MF

Modified: hydra/jobs/spoofax-imp.nix
==============================================================================
--- hydra/jobs/spoofax-imp.nix	Thu Apr 25 14:19:24 2013	(r26067)
+++ hydra/jobs/spoofax-imp.nix	Thu Apr 25 14:36:29 2013	(r26068)
@@ -30,6 +30,14 @@
     sha256 = "0y13i31xlhian5glk4cahbzxg4mky4q61qzc5g03qkg4d67k12zd";
   };
 
+  guava = pkgs.fetchurl {
+    url = http://search.maven.org/remotecontent?filepath=com/google/guava/guava/14.0.1/guava-14.0.1.jar;
+  };
+
+  junit-benchmarks = pkgs.fetchurl {
+    url = http://labs.carrotsearch.com/download/junit-benchmarks/0.6.0/junit-benchmarks-0.6.0.zip;
+  };
+
   eclipseFun = import ../eclipse.nix pkgs ; 
     
   eclipse = eclipseFun {
@@ -84,6 +92,7 @@
                  ${spoofax}/org.spoofax.compiler \
                  ${spoofax}/org.spoofax.interpreter.core \
                  ${spoofax}/org.spoofax.interpreter \
+                 ${spoofax}/org.spoofax.interpreter.externaldeps \
                  ${spoofax}/org.spoofax.interpreter.ui \
                  ${spoofax}/org.spoofax.interpreter.library.jsglr \
                  ${spoofax}/org.spoofax.interpreter.library.index \
@@ -125,7 +134,7 @@
                  ${spoofaxImp}/org.strategoxt.imp.debug.stratego.test \
                  ${spoofaxImp}/org.strategoxt.imp.debug.stratego.transformer \
                  ${spoofaxImp}/org.strategoxt.imp.debug.ui \
-		 ${metaborgRuntime}/org.metaborg.runtime.task 
+		  ${metaborgRuntime}/org.metaborg.runtime.task 
         do
           header "Copying $d"
           cp -R $d .
@@ -135,6 +144,8 @@
         cp -R ${shrike} com.ibm.wala.shrike
         cp -R ${lpgRuntime} lpg.runtime.java
         cp -R ${strategoxtJavaBackend}/strategoxt-java-backend org.strategoxt.strj
+        mv ${guava} ${spoofax}/org.spoofax.interpreter.externaldeps/lib
+        unzip ${junit-benchmarks} -d ${spoofax}/org.spoofax.interpreter.externaldeps/lib
             
         chmod -R +w .
         rm -rf \

Modified: spoofax-imp/trunk/org.strategoxt.imp.feature/feature.xml
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.feature/feature.xml	Thu Apr 25 14:19:24 2013	(r26067)
+++ spoofax-imp/trunk/org.strategoxt.imp.feature/feature.xml	Thu Apr 25 14:36:29 2013	(r26068)
@@ -381,6 +381,13 @@
          unpack="false"/>
 
    <plugin
+         id="org.spoofax.interpreter.externaldeps"
+         download-size="0"
+         install-size="0"
+         version="1.0.0.qualifier"
+         unpack="false"/>
+
+   <plugin
          id="org.spoofax.interpreter.library.xml"
          download-size="0"
          install-size="0"

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.externaldeps/META-INF/MANIFEST.MF
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.externaldeps/META-INF/MANIFEST.MF	Thu Apr 25 14:19:24 2013	(r26067)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.externaldeps/META-INF/MANIFEST.MF	Thu Apr 25 14:36:29 2013	(r26068)
@@ -2,7 +2,7 @@
 Bundle-ManifestVersion: 2
 Bundle-Name: org.spoofax.interpreter.externaldeps
 Bundle-SymbolicName: org.spoofax.interpreter.externaldeps
-Bundle-Version: 1.0.0
+Bundle-Version: 1.0.0.qualifier
 Bundle-ClassPath: lib/guava.jar,
  lib/junit-benchmarks-0.6.0/junit-benchmarks-0.6.0.jar
 Export-Package: com.carrotsearch.junitbenchmarks,

From gabrielkonat at gmail.com  Thu Apr 25 16:46:15 2013
From: gabrielkonat at gmail.com (GabriÃ«l Konat)
Date: Thu, 25 Apr 2013 14:46:15 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26069 - hydra/jobs
Message-ID: <20130425144615.E98B8CC367@mx4.tudelft.nl>

Author: gkonat
Date: Thu Apr 25 14:46:15 2013
New Revision: 26069
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26069&sc=1

Log:
Added shasums

Modified:
   hydra/jobs/spoofax-imp.nix

Modified: hydra/jobs/spoofax-imp.nix
==============================================================================
--- hydra/jobs/spoofax-imp.nix	Thu Apr 25 14:36:29 2013	(r26068)
+++ hydra/jobs/spoofax-imp.nix	Thu Apr 25 14:46:15 2013	(r26069)
@@ -32,10 +32,12 @@
 
   guava = pkgs.fetchurl {
     url = http://search.maven.org/remotecontent?filepath=com/google/guava/guava/14.0.1/guava-14.0.1.jar;
+    sha256 = "69e12f4c6aeac392555f1ea86fab82b5e5e31ad4";
   };
 
   junit-benchmarks = pkgs.fetchurl {
     url = http://labs.carrotsearch.com/download/junit-benchmarks/0.6.0/junit-benchmarks-0.6.0.zip;
+    sha256 = "7d23728aeeca7adcc049035e9ac57a8e49e084de";
   };
 
   eclipseFun = import ../eclipse.nix pkgs ; 

From g.h.wachsmuth at tudelft.nl  Mon Apr 29 13:46:36 2013
From: g.h.wachsmuth at tudelft.nl (Guido Wachsmuth)
Date: Mon, 29 Apr 2013 11:46:36 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26070 -
	spoofax-imp/branches/nbl-dev/trans/generation2
Message-ID: <20130429114636.128EB108C004@mx3.tudelft.nl>

Author: GuidoWachsmuth
Date: Mon Apr 29 11:46:35 2013
New Revision: 26070
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26070&sc=1

Log:
correct 4-ary context terms in nabl-use calls

Modified:
   spoofax-imp/branches/nbl-dev/trans/generation2/use-sites.str

Modified: spoofax-imp/branches/nbl-dev/trans/generation2/use-sites.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation2/use-sites.str	Thu Apr 25 14:46:15 2013	(r26069)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/use-sites.str	Mon Apr 29 11:46:35 2013	(r26070)
@@ -52,13 +52,13 @@
     Enclosing(ns) -> TERM("Enclosing", [<ns-to-term> ns])
     
   context-to-term(|repl*):
-    Context(disamb, ns, term, prop*, ctx) -> TERM("Context", [ns-term, prop-term*, ctx-term])
+    Context(disamb, ns, term, prop*, ctx) -> TERM("Context", [ns-term, name-term, LIST(prop-term*), ctx-term])
     where
       ns-term        := <ns-to-term> ns
     ; prop-term*     := <map(prop-to-str; replace-all(|repl*))> prop*
+    ; name-term      := <replace-all(|repl*)> term
     ; ctx-term       := <context-to-term(|repl*)> ctx
     
-      
   clause-to-match-rules(|bound*, i):
     (j, RefClause(part*)) -> rule*
     where
@@ -70,7 +70,6 @@
     where
       k     := <extend-index(|i)> j
     ; rule* := <constraints-to-match-rules(|bound*, k, 1)> constr*
-      
 
 overlays
      

From gabrielkonat at gmail.com  Mon Apr 29 14:08:46 2013
From: gabrielkonat at gmail.com (GabriÃ«l Konat)
Date: Mon, 29 Apr 2013 12:08:46 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26071 -
	spoofax-imp/branches/nbl-dev
Message-ID: <20130429120846.8B7E6CC1CA@mx4.tudelft.nl>

Author: gkonat
Date: Mon Apr 29 12:08:45 2013
New Revision: 26071
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26071&sc=1

Log:
Update generated build file.

Modified:
   spoofax-imp/branches/nbl-dev/build.generated.xml

Modified: spoofax-imp/branches/nbl-dev/build.generated.xml
==============================================================================
--- spoofax-imp/branches/nbl-dev/build.generated.xml	Mon Apr 29 11:46:35 2013	(r26070)
+++ spoofax-imp/branches/nbl-dev/build.generated.xml	Mon Apr 29 12:08:45 2013	(r26071)
@@ -2,51 +2,54 @@
 
 <project name="build.generated">
 
-        <target name="spoofaximp.default" depends="spoofaximp.default.ctree"/>
-        <target name="spoofaximp.default.ctree" depends="
-			check-classpath,
-			init,
-			sdf2table,
-			meta-sdf2table,
-			ppgen,
-			pppack,
-			sdf2imp.eclipse,
-			sdf2imp.standalone,
-			sdf2parenthesize,
-			stratego.aster,
-			java.jar,
-			stratego.ctree,
-			refresh,
-			sdf2imp.eclipse.load"/>
-        <target name="spoofaximp.default.jar" depends="
-			check-classpath,
-			init,
-			sdf2table,
-			meta-sdf2table,
-			ppgen,
-			pppack,
-			sdf2imp.eclipse,
-			sdf2imp.standalone,
-			sdf2parenthesize,
-			stratego.aster,
-			java.jar,
-			stratego.jar.helper,
-			refresh,
-			sdf2imp.eclipse.load"/>
-        <target name="spoofaximp.default.nostr" depends="
-      check-classpath,
-      init,
-      sdf2table,
-      meta-sdf2table,
-      ppgen,
-      pppack,
-      sdf2imp.eclipse,
-      sdf2imp.standalone,
-      sdf2parenthesize,
-      stratego.aster,
-      java.jar,
-      refresh,
-      sdf2imp.eclipse.load"/>
+			  <target name="spoofaximp.default" depends="spoofaximp.default.ctree"/>
+			  <target name="spoofaximp.default.ctree" depends="
+			      check-classpath,
+			      call-onsave,
+			      init,
+			      sdf2table,
+			      meta-sdf2table,
+			      ppgen,
+			      pppack,
+			      sdf2imp.eclipse,
+			      sdf2imp.standalone,
+			      sdf2parenthesize,
+			      stratego.aster,
+			      java.jar,
+			      stratego.ctree,
+			      refresh,
+			      sdf2imp.eclipse.load"/>
+			  <target name="spoofaximp.default.jar" depends="
+			      check-classpath,
+			      call-onsave,
+			      init,
+			      sdf2table,
+			      meta-sdf2table,
+			      ppgen,
+			      pppack,
+			      sdf2imp.eclipse,
+			      sdf2imp.standalone,
+			      sdf2parenthesize,
+			      stratego.aster,
+			      java.jar,
+			      stratego.jar.helper,
+			      refresh,
+			      sdf2imp.eclipse.load"/>
+			  <target name="spoofaximp.default.nostr" depends="
+			      check-classpath,
+			      call-onsave,
+			      init,
+			      sdf2table,
+			      meta-sdf2table,
+			      ppgen,
+			      pppack,
+			      sdf2imp.eclipse,
+			      sdf2imp.standalone,
+			      sdf2parenthesize,
+			      stratego.aster,
+			      java.jar,
+			      refresh,
+			      sdf2imp.eclipse.load"/>
     
         <!-- Initialization -->
         <available file="${src-gen}/org/metaborg/meta/lang/nabl/strategies/Main.java" property="java.jar.enabled"/>
@@ -88,6 +91,23 @@
         <mkdir dir="${lib}"/>
         <mkdir dir="${syntax}"/>
 
+			  <!-- The files for which the on-save handler is called before building -->
+			  <path id="call-onsave.files">
+			    <fileset dir=".">
+			      <include name="**/*.tmpl"/>
+			      <include name="**/*.nd"/>
+			      <include name="**/*.nab"/>
+			    </fileset>
+			  </path>
+				
+				<!-- Call on-save handler for template and name binding files so that their generated files are present -->
+				<target name="call-onsave">
+					<pathconvert pathsep=" " property="call-onsave.args" refid="call-onsave.files"/>
+					<java classname="org.strategoxt.imp.metatooling.building.AntForceOnSave">
+						<arg line="${call-onsave.args}"/>
+					</java>
+				</target>
+
         <target name="sdf2imp" depends="sdf2table,sdf2imp.eclipse,sdf2imp.standalone,sdf2parenthesize"/>
         
         <target name="sdf2imp.eclipse" if="eclipse.running" depends="sdf2rtg">

From gabrielkonat at gmail.com  Mon Apr 29 15:39:09 2013
From: gabrielkonat at gmail.com (GabriÃ«l Konat)
Date: Mon, 29 Apr 2013 13:39:09 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r26072 -
	spoofax-imp/branches/nbl-dev/trans/generation2
Message-ID: <20130429133909.DDA74108C004@mx3.tudelft.nl>

Author: gkonat
Date: Mon Apr 29 13:39:08 2013
New Revision: 26072
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=26072&sc=1

Log:
Change to use new collect interface.

Modified:
   spoofax-imp/branches/nbl-dev/trans/generation2/constraints.str
   spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str
   spoofax-imp/branches/nbl-dev/trans/generation2/prop-sites.str
   spoofax-imp/branches/nbl-dev/trans/generation2/use-sites.str

Modified: spoofax-imp/branches/nbl-dev/trans/generation2/constraints.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation2/constraints.str	Mon Apr 29 12:08:45 2013	(r26071)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/constraints.str	Mon Apr 29 13:39:08 2013	(r26072)
@@ -67,7 +67,7 @@
   
 overlays
   
-  MATCH_RULE(n, lhs, bnd, rhs) = RDefNoArgs("nabl-match", RuleNoCond(TUPLE([NoAnnoList(Str(n)), lhs, LIST(bnd)]), rhs))
+  MATCH_RULE(n, lhs, bnd, rhs) = RDefNoArgs("task-match", RuleNoCond(TUPLE([NoAnnoList(Str(n)), lhs, LIST(bnd)]), rhs))
 
   PROP_TASK(v, p, t)     = NEW_TASK(v, TERM("PropCalc", [p, t]))
   MATCH_TASK(v, n, b, t) = NEW_TASK(v, TERM("Match", [NoAnnoList(Str(n)), LIST(b), t]))
@@ -76,6 +76,6 @@
   
   NEW_TASK(t) =
   App(
-    CallT(SVar("new-task"), [], [Var("tasks__")])
+    CallT(SVar("new-task"), [], [Var("partition__")])
   , t
   )
\ No newline at end of file

Modified: spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str	Mon Apr 29 12:08:45 2013	(r26071)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/def-sites.str	Mon Apr 29 13:39:08 2013	(r26072)
@@ -94,7 +94,6 @@
   , [ DefaultVarDec("lang__")
     , DefaultVarDec("partition__")
     , DefaultVarDec("uniques__")
-    , DefaultVarDec("elems__")
     , DefaultVarDec("uri__")
     , DefaultVarDec("states__")]
   , body
@@ -107,7 +106,6 @@
   , [ Var("lang__")
     , Var("partition__")
     , Var("uniques__")
-    , Var("elems__")
     , in-child-uris
     , in-sibl-uris
     , ns, u, ds, LIST(s)]

Modified: spoofax-imp/branches/nbl-dev/trans/generation2/prop-sites.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation2/prop-sites.str	Mon Apr 29 12:08:45 2013	(r26071)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/prop-sites.str	Mon Apr 29 13:39:08 2013	(r26072)
@@ -61,8 +61,6 @@
   , []
   , [ DefaultVarDec("lang__")
     , DefaultVarDec("partition__")
-    , DefaultVarDec("elems__")
-    , DefaultVarDec("tasks__")
     , DefaultVarDec("states__")
     , DefaultVarDec("implicits__")
     ]
@@ -73,7 +71,7 @@
   CallT(
     SVar("nabl-props")
   , []
-  , [Var("partition__"), Var("elems__"), LIST(ps)]
+  , [Var("partition__"), LIST(ps)]
   )
   
   PROPERTY(p, v) = TERM("Prop", [p, v])

Modified: spoofax-imp/branches/nbl-dev/trans/generation2/use-sites.str
==============================================================================
--- spoofax-imp/branches/nbl-dev/trans/generation2/use-sites.str	Mon Apr 29 12:08:45 2013	(r26071)
+++ spoofax-imp/branches/nbl-dev/trans/generation2/use-sites.str	Mon Apr 29 13:39:08 2013	(r26072)
@@ -78,8 +78,7 @@
     "nabl-use-site"
   , []
   , [ DefaultVarDec("lang__")
-    , DefaultVarDec("elems__")
-    , DefaultVarDec("tasks__")
+    , DefaultVarDec("partition__")
     , DefaultVarDec("uris__")
     , DefaultVarDec("states__") 
     ]
@@ -91,8 +90,7 @@
     SVar("nabl-use")
   , []
   , [ Var("lang__")
-    , Var("elems__")
-    , Var("tasks__")
+    , Var("partition__")
     , Var("uris__")
     , LIST(candidates)
     ] 

